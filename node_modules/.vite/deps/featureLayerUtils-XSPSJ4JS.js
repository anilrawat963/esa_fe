import {
  $,
  I,
  P,
  d as d2,
  f,
  m,
  p as p2,
  v,
  w
} from "./chunk-JRLJ2PWQ.js";
import {
  i
} from "./chunk-WVAXXVEK.js";
import "./chunk-NJSGYS3K.js";
import {
  l as l2,
  n
} from "./chunk-65WW7L4T.js";
import {
  o
} from "./chunk-HROH5C5D.js";
import {
  E,
  c,
  l,
  s as s2,
  u
} from "./chunk-H34D76ZQ.js";
import "./chunk-NPYFNHY2.js";
import {
  O
} from "./chunk-CNYNCKEV.js";
import "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-W75DBJD7.js";
import "./chunk-P6IKJIMO.js";
import "./chunk-MHV23XAQ.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-ONXWBTTM.js";
import "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-7P2ANHQ3.js";
import "./chunk-XCKT47LJ.js";
import "./chunk-3FUHCAX3.js";
import "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import "./chunk-2OFHDVO5.js";
import "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-5UPBUJPC.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-SMWUT52Z.js";
import "./chunk-AXZMNHTN.js";
import "./chunk-5T3MJDSR.js";
import "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import {
  p2 as p
} from "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import "./chunk-5EI5H4QX.js";
import "./chunk-ZIE53VIV.js";
import "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import "./chunk-GNMPGHLQ.js";
import {
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  N,
  d,
  h
} from "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/layers/save/featureLayerUtils.js
var g = "Feature Service";
var E2 = "feature-layer-utils";
var P2 = `${E2}-save`;
var O2 = `${E2}-save-as`;
var A = `${E2}-saveall`;
var x = `${E2}-saveall-as`;
function N2(e) {
  return { isValid: O(e) && (!("dynamicDataSource" in e) || !e.dynamicDataSource), errorMessage: "Feature layer should be a layer or table in a map or feature service" };
}
function $2(e, r) {
  const a = o(e, "portal-item");
  return r?.isTable && (a.layerContainerType = "tables"), a;
}
function j(e) {
  const r = $2(e), a = $2(e);
  return a.layerContainerType = "tables", { forLayers: r, forTables: a };
}
function U(e) {
  const r = [], a = [];
  for (const { layer: t, layerJSON: n2 } of e) R(t) ? a.push(n2) : r.push(n2);
  return { layers: r, tables: a };
}
function R(e, r) {
  return e.isTable;
}
function C(e) {
  return U([e]);
}
async function J(e, r) {
  return /\/\d+\/?$/.test(e.url) ? C(r[0]) : G(r, e);
}
async function G(e, r) {
  if (e.reverse(), !r) return U(e);
  const a = await _(r, e);
  for (const t of e) V(t.layer, t.layerJSON, a);
  return M(a, e), a;
}
async function _(e, r) {
  let a = await e.fetchData("json");
  if (D(a) && !s2(e, E.HOSTED_SERVICE)) return a;
  a ||= {}, F(a);
  const { layer: { url: t, customParameters: n2, apiKey: s3 } } = r[0];
  return await B(a, { url: t ?? "", customParameters: n2, apiKey: s3 }, r.map((e2) => e2.layer.layerId)), a;
}
function D(e) {
  return !!(e && Array.isArray(e.layers) && Array.isArray(e.tables));
}
function F(e) {
  e.layers ||= [], e.tables ||= [];
}
function M(e, r) {
  const a = [], t = [];
  for (const { layer: n2 } of r) {
    const { isTable: e2, layerId: r2 } = n2;
    e2 ? t.push(r2) : a.push(r2);
  }
  Y(e.layers, a), Y(e.tables, t);
}
function Y(r, a) {
  if (r.length < 2) return;
  const t = [];
  for (const { id: e } of r) t.push(e);
  h(t.sort(k), a.slice().sort(k)) && r.sort((e, r2) => {
    const t2 = a.indexOf(e.id), n2 = a.indexOf(r2.id);
    return t2 < n2 ? -1 : t2 > n2 ? 1 : 0;
  });
}
function k(e, r) {
  return e < r ? -1 : e > r ? 1 : 0;
}
async function B(e, r, a) {
  const { url: t, customParameters: n2, apiKey: s3 } = r, { serviceJSON: o2, layersJSON: l3 } = await n(t, { customParameters: n2, apiKey: s3 }), i2 = K(e.layers, o2.layers, a), c2 = K(e.tables, o2.tables, a);
  e.layers = i2.itemResources, e.tables = c2.itemResources;
  const u2 = [...i2.added, ...c2.added], y = l3 ? [...l3.layers, ...l3.tables] : [];
  await z(e, u2, t, y);
}
function K(e, a, t) {
  const n2 = d(e, a, (e2, r) => e2.id === r.id);
  e = e.filter((e2) => !n2.removed.some((r) => r.id === e2.id));
  const s3 = n2.added;
  return s3.forEach(({ id: r }) => {
    e.push({ id: r });
  }), { itemResources: e, added: s3.filter(({ id: e2 }) => !t.includes(e2)) };
}
async function z(e, r, a, t) {
  const n2 = await H(r), s3 = r.map(({ id: e2, type: r2 }) => new (n2.get(r2))({ url: a, layerId: e2, sourceJSON: t.find(({ id: r3 }) => r3 === e2) }));
  await Promise.allSettled(s3.map((e2) => e2.load())), s3.forEach((r2) => {
    const { layerId: a2, loaded: t2, defaultPopupTemplate: n3 } = r2;
    if (!t2 || null == n3) return;
    const s4 = { id: a2, popupInfo: n3.toJSON() };
    V(r2, "ArcGISFeatureLayer" === r2.operationalLayerType ? s4 : { ...s4, layerType: r2.operationalLayerType }, e);
  });
}
async function H(e) {
  const r = [];
  e.forEach(({ type: e2 }) => {
    switch (l2(e2)) {
      case "CatalogLayer":
        r.push(import("./CatalogLayer-X2LEHLK2.js").then((e3) => e3.default));
        break;
      case "FeatureLayer":
        r.push(import("./FeatureLayer-67ZFNT6Z.js").then((e3) => e3.default));
        break;
      case "OrientedImageryLayer":
        r.push(import("./OrientedImageryLayer-MXBJJJSJ.js").then((e3) => e3.default));
    }
  });
  const a = await Promise.all(r), t = /* @__PURE__ */ new Map();
  return e.forEach(({ type: e2 }, r2) => {
    t.set(e2, a[r2]);
  }), t;
}
function V(e, r, a) {
  e.isTable ? q(a.tables, r) : q(a.layers, r);
}
function q(e, r) {
  const a = e.findIndex(({ id: e2 }) => e2 === r.id);
  -1 === a ? e.push(r) : e[a] = r;
}
function Q(e, r) {
  if (!e.length) throw new s(`${r}:missing-parameters`, "'layers' array should contain at least one feature layer");
}
function W(e, r) {
  const a = e.map((e2) => e2.portalItem.id);
  if (new Set(a).size > 1) throw new s(`${r}:invalid-parameters`, "All layers in the 'layers' array should be loaded from the same portal item");
}
function X(e, r) {
  const a = e.map((e2) => e2.layerId);
  if (new Set(a).size !== a.length) throw new s(`${r}:invalid-parameters`, "'layers' array should contain only one instance each of layer or table in a feature service");
}
async function Z(e) {
  Q(e, A), await Promise.all(e.map((e2) => e2.load()));
  for (const r of e) p2(r, A, N2), f({ layer: r, itemType: g, errorNamePrefix: A });
  W(e, A), X(e, A);
}
function ee(e) {
  if (!("layerType" in e)) return !!e.charts?.length;
  switch (e.layerType) {
    case "OrientedImageryLayer":
      return !!e.charts?.length;
    case "SubtypeGroupLayer":
      return !!e.layers.some((e2) => !!e2.charts?.length);
    case "SubtypeGroupTable":
      return !!e.tables.some((e2) => !!e2.charts?.length);
    case "CatalogLayer":
      return !!e.footprintLayer?.charts?.length;
  }
}
function re(e, r) {
  let a = 0, t = 0, n2 = 0, s3 = 0;
  for (const o2 of [...r.layers, ...r.tables]) if (ee(o2) && s3++, "layerType" in o2) switch (o2.layerType) {
    case "OrientedImageryLayer":
      a++;
      break;
    case "SubtypeGroupLayer":
      t++;
      break;
    case "SubtypeGroupTable":
      n2++;
  }
  u(e, E.ORIENTED_IMAGERY_LAYER, a > 0), u(e, E.SUBTYPE_GROUP_LAYER, t > 0), u(e, E.SUBTYPE_GROUP_TABLE, n2 > 0), u(e, E.CHARTS, s3 > 0);
}
function ae(e, r, a) {
  c(r, E.METADATA), u(r, E.MULTI_LAYER, e.length > 1), u(r, E.SINGLE_LAYER, 1 === e.length), u(r, E.TABLE, a.tables.length > 0 && 0 === a.layers.length), re(r, a);
}
async function te(e, r, a) {
  re(r, a);
}
async function ne(e, r, a) {
  const { url: t, layerId: n2, title: s3, fullExtent: o2, isTable: l3 } = e, i2 = p(t);
  r.url = ("FeatureServer" === i2?.serverType ? t : `${t}/${n2}`) ?? null, r.title ||= s3, r.extent = null, l3 || null == o2 || (r.extent = await l(o2)), ae([e], r, a);
}
function se(e, r) {
  for (const o2 of e) {
    const a2 = o2.parsedUrl.path, n3 = p(a2), s4 = n3?.url.path;
    if (!s4) throw new s(`${r}:invalid-parameters`, m(o2, `has unsupported url pattern: ${a2}`), { layer: o2 });
    const l3 = n3?.serverType;
    if ("FeatureServer" !== l3 && "MapServer" !== l3) throw new s(`${r}:invalid-parameters`, m(o2, `has unsupported server type: ${l3}`), { layer: o2 });
    if ("MapServer" === l3 && e.length > 1) throw new s(`${r}:invalid-parameters`, "Only one layer or table in a map service can be saved");
  }
  const a = p(e[0].parsedUrl.path), n2 = a?.url.path, s3 = e.every((e2) => {
    const r2 = p(e2.parsedUrl.path);
    return r2?.url.path === n2;
  });
  if (!s3) throw new s(`${r}:invalid-parameters`, "'layers' array should only contain layers or tables that belong to the same feature service");
}
async function oe(e) {
  Q(e, x), await Promise.all(e.map((e2) => e2.load()));
  for (const r of e) p2(r, x, N2);
  se(e, x), X(e, x);
}
function le(e, r) {
  re(e, r), I(e);
}
async function ie(e, r, t) {
  let n2 = 0;
  for (const { isTable: a } of e) a || n2++;
  const s3 = e[0].parsedUrl.path, o2 = p(s3);
  if (r.url = "FeatureServer" === o2?.serverType ? o2.url.path : s3, r.title ||= o2.title, r.extent = null, n2 > 0) {
    const t2 = e.map((e2) => e2.fullExtent).filter(N).reduce((e2, r2) => e2.clone().union(r2));
    t2 && (r.extent = await l(t2));
  }
  ae(e, r, t), I(r);
}
async function ce(e, r) {
  return P({ layer: e, itemType: g, validateLayer: N2, createJSONContext: (r2) => $2(r2, e), createItemData: (e2, r2) => J(r2, [e2]), errorNamePrefix: P2, setItemProperties: te }, r);
}
async function ue(e, r) {
  await Z(e);
  const a = e[0].portalItem, t = j(a), s3 = await Promise.all(e.map((e2) => w(e2, e2.isTable ? t.forTables : t.forLayers, r))), o2 = await J(a, e.map((e2, r2) => ({ layer: e2, layerJSON: s3[r2] })));
  return le(a, o2), await a.update({ data: o2 }), await Promise.all(e.slice(1).map((e2) => e2.portalItem.reload())), i(t.forLayers), i(t.forTables), a.clone();
}
async function ye(e, r, a) {
  return $({ layer: e, itemType: g, validateLayer: N2, createJSONContext: (r2) => $2(r2, e), createItemData: (e2, r2) => Promise.resolve(C(e2)), errorNamePrefix: O2, newItem: r, setItemProperties: ne }, a);
}
async function pe(e, r, a) {
  await oe(e);
  const t = d2({ itemType: g, errorNamePrefix: x, newItem: r }), s3 = j(t), o2 = await Promise.all(e.map((e2) => w(e2, e2.isTable ? s3.forTables : s3.forLayers, a))), u2 = await G(e.map((e2, r2) => ({ layer: e2, layerJSON: o2[r2] })));
  await ie(e, t, u2), await v(t, u2, a);
  for (const n2 of e) n2.portalItem = t.clone();
  return i(s3.forLayers), i(s3.forTables), t;
}
export {
  ce as save,
  ue as saveAll,
  pe as saveAllAs,
  ye as saveAs
};
//# sourceMappingURL=featureLayerUtils-XSPSJ4JS.js.map
