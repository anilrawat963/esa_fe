import {
  n
} from "./chunk-234CIOHE.js";
import {
  has
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/chunks/pe.js
var t;
var o = null;
function r() {
  return !!o;
}
function _() {
  return !!has("esri-wasm");
}
function n2() {
  return t || (t = import("./pe-wasm-NN2VJLIE.js").then(({ default: t2 }) => t2({ locateFile: (t3) => n(`esri/geometry/support/${t3}`) })).then((e) => {
    h(e);
  }), t);
}
var P = { geogToProj(e, t2, r2) {
  o.ensureCache.prepare();
  const _2 = I(r2), n3 = r2 === _2, P2 = o.ensureFloat64(_2), s2 = o._pe_geog_to_proj(o.getPointer(e), t2, P2);
  return s2 && U(r2, t2, P2, n3), s2;
}, projGeog(e, t2, o2, r2) {
  switch (r2) {
    case s.PE_TRANSFORM_P_TO_G:
      return P.projToGeog(e, t2, o2);
    case s.PE_TRANSFORM_G_TO_P:
      return P.geogToProj(e, t2, o2);
  }
  return 0;
}, projToGeog: (e, t2, o2) => P.projToGeogCenter(e, t2, o2, 0), projToGeogCenter(e, t2, r2, _2) {
  o.ensureCache.prepare();
  const n3 = I(r2), P2 = r2 === n3, s2 = o.ensureFloat64(n3), p2 = o._pe_proj_to_geog_center(o.getPointer(e), t2, s2, _2);
  return p2 && U(r2, t2, s2, P2), p2;
} };
var s = class _s {
  static init() {
    _s.PE_BUFFER_MAX = o.PeDefs.prototype.PE_BUFFER_MAX, _s.PE_NAME_MAX = o.PeDefs.prototype.PE_NAME_MAX, _s.PE_MGRS_MAX = o.PeDefs.prototype.PE_MGRS_MAX, _s.PE_USNG_MAX = o.PeDefs.prototype.PE_USNG_MAX, _s.PE_DD_MAX = o.PeDefs.prototype.PE_DD_MAX, _s.PE_DDM_MAX = o.PeDefs.prototype.PE_DDM_MAX, _s.PE_DMS_MAX = o.PeDefs.prototype.PE_DMS_MAX, _s.PE_UTM_MAX = o.PeDefs.prototype.PE_UTM_MAX, _s.PE_PARM_MAX = o.PeDefs.prototype.PE_PARM_MAX, _s.PE_TYPE_NONE = o.PeDefs.prototype.PE_TYPE_NONE, _s.PE_TYPE_GEOGCS = o.PeDefs.prototype.PE_TYPE_GEOGCS, _s.PE_TYPE_PROJCS = o.PeDefs.prototype.PE_TYPE_PROJCS, _s.PE_TYPE_GEOGTRAN = o.PeDefs.prototype.PE_TYPE_GEOGTRAN, _s.PE_TYPE_COORDSYS = o.PeDefs.prototype.PE_TYPE_COORDSYS, _s.PE_TYPE_UNIT = o.PeDefs.prototype.PE_TYPE_UNIT, _s.PE_TYPE_LINUNIT = o.PeDefs.prototype.PE_TYPE_LINUNIT, _s.PE_STR_OPTS_NONE = o.PeDefs.prototype.PE_STR_OPTS_NONE, _s.PE_STR_AUTH_NONE = o.PeDefs.prototype.PE_STR_AUTH_NONE, _s.PE_STR_AUTH_TOP = o.PeDefs.prototype.PE_STR_AUTH_TOP, _s.PE_STR_NAME_CANON = o.PeDefs.prototype.PE_STR_NAME_CANON, _s.PE_STR_FMT_WKT = o.PeDefs.prototype.PE_STR_FMT_WKT, _s.PE_STR_FMT_WKT2 = o.PeDefs.prototype.PE_STR_FMT_WKT2, _s.PE_PARM_X0 = o.PeDefs.prototype.PE_PARM_X0, _s.PE_PARM_ND = o.PeDefs.prototype.PE_PARM_ND, _s.PE_TRANSFORM_1_TO_2 = o.PeDefs.prototype.PE_TRANSFORM_1_TO_2, _s.PE_TRANSFORM_2_TO_1 = o.PeDefs.prototype.PE_TRANSFORM_2_TO_1, _s.PE_TRANSFORM_P_TO_G = o.PeDefs.prototype.PE_TRANSFORM_P_TO_G, _s.PE_TRANSFORM_G_TO_P = o.PeDefs.prototype.PE_TRANSFORM_G_TO_P, _s.PE_HORIZON_RECT = o.PeDefs.prototype.PE_HORIZON_RECT, _s.PE_HORIZON_POLY = o.PeDefs.prototype.PE_HORIZON_POLY, _s.PE_HORIZON_LINE = o.PeDefs.prototype.PE_HORIZON_LINE, _s.PE_HORIZON_DELTA = o.PeDefs.prototype.PE_HORIZON_DELTA;
  }
};
var p = null;
var a = {};
var i = {};
var E = (e) => {
  const t2 = e.getType();
  switch (t2) {
    case s.PE_TYPE_GEOGCS:
      e = o.castObject(e, o.PeGeogcs);
      break;
    case s.PE_TYPE_PROJCS:
      e = o.castObject(e, o.PeProjcs);
      break;
    case s.PE_TYPE_GEOGTRAN:
      e = o.castObject(e, o.PeGeogtran);
      break;
    default:
      t2 & s.PE_TYPE_UNIT && (e = o.castObject(e, o.PeUnit));
  }
  return e;
};
var c = { initialize() {
  o.PeFactory.prototype.initialize(null);
}, coordsys: (e) => c.factoryByType(s.PE_TYPE_COORDSYS, e), factoryByType(e, t2) {
  let r2 = null, _2 = a[e];
  if (_2 || (_2 = {}, a[e] = _2), _2.hasOwnProperty(String(t2)) && (r2 = _2[t2], o.compare(r2, o.NULL) && (r2 = null)), !r2) {
    const n3 = o.PeFactory.prototype.factoryByType(e, t2);
    o.compare(n3, o.NULL) || (r2 = E(n3), _2[t2] = r2);
  }
  return r2;
}, fromString(e, t2) {
  let r2 = null, _2 = i[e];
  if (_2 || (_2 = {}, i[e] = _2), _2.hasOwnProperty(t2) && (r2 = _2[t2], o.compare(r2, o.NULL) && (r2 = null)), !r2) {
    const n3 = o.PeFactory.prototype.fromString(e, t2);
    o.compare(n3, o.NULL) || (r2 = E(n3), _2[t2] = r2);
  }
  return r2;
}, geogcs: (e) => c.factoryByType(s.PE_TYPE_GEOGCS, e), geogtran: (e) => c.factoryByType(s.PE_TYPE_GEOGTRAN, e), getCode: (e) => o.PeFactory.prototype.getCode(e), projcs: (e) => c.factoryByType(s.PE_TYPE_PROJCS, e), unit: (e) => c.factoryByType(s.PE_TYPE_UNIT, e) };
var T;
var g = null;
var y = { PE_GTLIST_OPTS_COMMON: 0, init() {
  y.PE_GTLIST_OPTS_COMMON = o.PeGTlistExtended.prototype.PE_GTLIST_OPTS_COMMON, T = o._pe_getPeGTlistExtendedEntrySize();
}, getGTlist(e, t2, r2, _2, n3, P2) {
  let s2 = null;
  const p2 = new o.PeInteger(P2);
  try {
    const a2 = o.PeGTlistExtended.prototype.getGTlist(e, t2, r2, _2, n3, p2);
    if ((P2 = p2.val) && (s2 = [a2], P2 > 1)) {
      const e2 = o.getPointer(a2);
      for (let t3 = 1; t3 < P2; t3++) s2.push(o.wrapPointer(e2 + T * t3, o.PeGTlistExtendedEntry));
    }
  } finally {
    o.destroy(p2);
  }
  return s2;
} };
var l = { destroy(e) {
  if (e?.length) {
    for (const t2 of e) m(t2), t2.getEntries().forEach((e2) => {
      m(e2);
      const t3 = e2.getGeogtran();
      m(t3), t3.getParameters().forEach(m), [t3.getGeogcs1(), t3.getGeogcs2()].forEach((e3) => {
        m(e3);
        const t4 = e3.getDatum();
        m(t4), m(t4.getSpheroid()), m(e3.getPrimem()), m(e3.getUnit());
      });
    });
    o.PeGTlistExtendedEntry.prototype.Delete(e[0]);
  }
} };
var u = { geogToGeog(e, t2, r2, _2, n3) {
  o.ensureCache.prepare();
  const P2 = I(r2), s2 = r2 === P2, p2 = o.ensureFloat64(P2);
  let a2 = 0;
  _2 && (a2 = o.ensureFloat64(_2));
  const i2 = o._pe_geog_to_geog(o.getPointer(e), t2, p2, a2, n3);
  return i2 && U(r2, t2, p2, s2), i2;
} };
var S = { geodesicCoordinate(e, t2, r2, _2, n3, P2, s2, p2) {
  o.PeLineType.prototype.geodesic_coordinate(e, t2, r2, _2, n3, P2, s2, p2);
}, geodeticCoordinate(e, t2, r2, _2, n3, P2, s2, p2, a2) {
  o.PeLineType.prototype.geodetic_coordinate(e, t2, r2, _2, n3, P2, s2, p2, a2);
}, geodeticDistance(e, t2, r2, _2, n3, P2, s2, p2, a2, i2) {
  o.PeLineType.prototype.geodetic_distance(e, t2, r2, _2, n3, P2, s2, p2, a2, i2);
}, greatEllipticDistance(e, t2, r2, _2, n3, P2, s2, p2, a2) {
  o.PeLineType.prototype.great_elliptic_distance(e, t2, r2, _2, n3, P2, s2, p2, a2);
} };
var O = { phiToEta: (e, t2) => o.PeMath.prototype.phi_to_eta(e, t2), etaToPhi: (e, t2) => o.PeMath.prototype.eta_to_phi(e, t2), phiToPhig: (e, t2) => o.PeMath.prototype.phi_to_phig(e, t2), q: (e, t2, r2) => o.PeMath.prototype.q(e, t2, r2), q90: (e, t2) => o.PeMath.prototype.q90(e, t2) };
var N = (e, t2, r2, _2, n3, P2) => {
  let p2, a2;
  switch (o.ensureCache.prepare(), e) {
    case "dd":
      p2 = o._pe_geog_to_dd, a2 = s.PE_DD_MAX;
      break;
    case "ddm":
      p2 = o._pe_geog_to_ddm, a2 = s.PE_DDM_MAX;
      break;
    case "dms":
      p2 = o._pe_geog_to_dms, a2 = s.PE_DMS_MAX;
  }
  let i2 = 0;
  t2 && (i2 = o.getPointer(t2));
  const E2 = I(_2), c2 = o.ensureFloat64(E2), T2 = C(r2, a2), g2 = p2(i2, r2, c2, n3, o.ensureInt32(T2));
  if (g2) for (let s2 = 0; s2 < r2; s2++) P2[s2] = o.UTF8ToString(T2[s2]);
  return g2;
};
var f = (e, t2, r2, _2, n3) => {
  let P2;
  switch (o.ensureCache.prepare(), e) {
    case "dd":
      P2 = o._pe_dd_to_geog;
      break;
    case "ddm":
      P2 = o._pe_ddm_to_geog;
      break;
    case "dms":
      P2 = o._pe_dms_to_geog;
  }
  let s2 = 0;
  t2 && (s2 = o.getPointer(t2));
  const p2 = _2.map((e2) => o.ensureString(e2)), a2 = o.ensureInt32(p2), i2 = o.ensureFloat64(new Array(2 * r2)), E2 = P2(s2, r2, a2, i2);
  return E2 && U(n3, r2, i2), E2;
};
var d = { geogToDms: (e, t2, o2, r2, _2) => N("dms", e, t2, o2, r2, _2), dmsToGeog: (e, t2, o2, r2) => f("dms", e, t2, o2, r2), geogToDdm: (e, t2, o2, r2, _2) => N("ddm", e, t2, o2, r2, _2), ddmToGeog: (e, t2, o2, r2) => f("ddm", e, t2, o2, r2), geogToDd: (e, t2, o2, r2, _2) => N("dd", e, t2, o2, r2, _2), ddToGeog: (e, t2, o2, r2) => f("dd", e, t2, o2, r2) };
var M = class _M {
  static init() {
    _M.PE_MGRS_STYLE_NEW = o.PeNotationMgrs.prototype.PE_MGRS_STYLE_NEW, _M.PE_MGRS_STYLE_OLD = o.PeNotationMgrs.prototype.PE_MGRS_STYLE_OLD, _M.PE_MGRS_STYLE_AUTO = o.PeNotationMgrs.prototype.PE_MGRS_STYLE_AUTO, _M.PE_MGRS_180_ZONE_1_PLUS = o.PeNotationMgrs.prototype.PE_MGRS_180_ZONE_1_PLUS, _M.PE_MGRS_ADD_SPACES = o.PeNotationMgrs.prototype.PE_MGRS_ADD_SPACES;
  }
  static geogToMgrsExtended(e, t2, r2, _2, n3, P2, p2) {
    o.ensureCache.prepare();
    let a2 = 0;
    e && (a2 = o.getPointer(e));
    const i2 = I(r2), E2 = o.ensureFloat64(i2), c2 = C(t2, s.PE_MGRS_MAX), T2 = o.ensureInt32(c2), g2 = o._pe_geog_to_mgrs_extended(a2, t2, E2, _2, n3, P2, T2);
    if (g2) for (let s2 = 0; s2 < t2; s2++) p2[s2] = o.UTF8ToString(c2[s2]);
    return g2;
  }
  static mgrsToGeogExtended(e, t2, r2, _2, n3) {
    o.ensureCache.prepare();
    let P2 = 0;
    e && (P2 = o.getPointer(e));
    const s2 = r2.map((e2) => o.ensureString(e2)), p2 = o.ensureInt32(s2), a2 = o.ensureFloat64(new Array(2 * t2)), i2 = o._pe_mgrs_to_geog_extended(P2, t2, p2, _2, a2);
    return i2 && U(n3, t2, a2), i2;
  }
};
var A = { geogToUsng(e, t2, r2, _2, n3, P2, p2) {
  o.ensureCache.prepare();
  let a2 = 0;
  e && (a2 = o.getPointer(e));
  const i2 = I(r2), E2 = o.ensureFloat64(i2), c2 = C(t2, s.PE_MGRS_MAX), T2 = o.ensureInt32(c2), g2 = o._pe_geog_to_usng(a2, t2, E2, _2, n3, P2, T2);
  if (g2) for (let s2 = 0; s2 < t2; s2++) p2[s2] = o.UTF8ToString(c2[s2]);
  return g2;
}, usngToGeog(e, t2, r2, _2) {
  o.ensureCache.prepare();
  let n3 = 0;
  e && (n3 = o.getPointer(e));
  const P2 = r2.map((e2) => o.ensureString(e2)), s2 = o.ensureInt32(P2), p2 = o.ensureFloat64(new Array(2 * t2)), a2 = o._pe_usng_to_geog(n3, t2, s2, p2);
  return a2 && U(_2, t2, p2), a2;
} };
var D = class _D {
  static init() {
    _D.PE_UTM_OPTS_NONE = o.PeNotationUtm.prototype.PE_UTM_OPTS_NONE, _D.PE_UTM_OPTS_ADD_SPACES = o.PeNotationUtm.prototype.PE_UTM_OPTS_ADD_SPACES, _D.PE_UTM_OPTS_NS = o.PeNotationUtm.prototype.PE_UTM_OPTS_NS;
  }
  static geogToUtm(e, t2, r2, _2, n3) {
    o.ensureCache.prepare();
    let P2 = 0;
    e && (P2 = o.getPointer(e));
    const p2 = I(r2), a2 = o.ensureFloat64(p2), i2 = C(t2, s.PE_UTM_MAX), E2 = o.ensureInt32(i2), c2 = o._pe_geog_to_utm(P2, t2, a2, _2, E2);
    if (c2) for (let s2 = 0; s2 < t2; s2++) n3[s2] = o.UTF8ToString(i2[s2]);
    return c2;
  }
  static utmToGeog(e, t2, r2, _2, n3) {
    o.ensureCache.prepare();
    let P2 = 0;
    e && (P2 = o.getPointer(e));
    const s2 = r2.map((e2) => o.ensureString(e2)), p2 = o.ensureInt32(s2), a2 = o.ensureFloat64(new Array(2 * t2)), i2 = o._pe_utm_to_geog(P2, t2, p2, _2, a2);
    return i2 && U(n3, t2, a2), i2;
  }
};
var _R = class _R {
  static init() {
    _R.PE_PCSINFO_OPTION_NONE = o.PePCSInfo.prototype.PE_PCSINFO_OPTION_NONE, _R.PE_PCSINFO_OPTION_DOMAIN = o.PePCSInfo.prototype.PE_PCSINFO_OPTION_DOMAIN, _R.PE_POLE_OUTSIDE_BOUNDARY = o.PePCSInfo.prototype.PE_POLE_OUTSIDE_BOUNDARY, _R.PE_POLE_POINT = o.PePCSInfo.prototype.PE_POLE_POINT;
  }
  static generate(e, t2 = _R.PE_PCSINFO_OPTION_DOMAIN) {
    let r2 = null, _2 = null;
    return _R.cache.has(e) && (_2 = _R.cache.get(e), _2[t2] && (r2 = _2[t2])), r2 || (r2 = o.PePCSInfo.prototype.generate(e, t2), _2 || (_2 = [], _R.cache.set(e, _2)), _2[t2] = r2), r2;
  }
};
_R.cache = /* @__PURE__ */ new Map();
var R = _R;
var G = { versionString: () => o.PeVersion.prototype.version_string() };
function h(e) {
  function t2(e2, t3, o2) {
    e2[t3] = o2(e2[t3]);
  }
  o = e, s.init(), y.init(), M.init(), D.init(), R.init(), p = class extends o.PeDouble {
    constructor(e2 = NaN) {
      super(e2);
    }
    destroy() {
      o.destroy(this);
    }
    [Symbol.dispose]() {
      this.destroy();
    }
  }, g = class extends o.PeGCSExtent {
    destroy() {
      o.destroy(this);
    }
    [Symbol.dispose]() {
      this.destroy();
    }
  };
  const r2 = [o.PeAngunit, o.PeDatum, o.PeGeogcs, o.PeGeogtran, o.PeObject, o.PeParameter, o.PePrimem, o.PeProjcs, o.PeSpheroid, o.PeUnit];
  for (const o2 of r2) t2(o2.prototype, "getName", (e2) => function() {
    return e2.call(this, new Array(s.PE_NAME_MAX));
  });
  for (const P2 of [o.PeGeogtran, o.PeProjcs]) t2(P2.prototype, "getParameters", (e2) => function() {
    const t3 = new Array(s.PE_PARM_MAX);
    let r3 = e2.call(this);
    for (let e3 = 0; e3 < t3.length; e3++) {
      const _3 = o.getValue(r3, "*");
      t3[e3] = _3 ? o.wrapPointer(_3, o.PeParameter) : null, r3 += Int32Array.BYTES_PER_ELEMENT;
    }
    return t3;
  });
  t2(o.PeHorizon.prototype, "getCoord", (e2) => function(t3 = false) {
    const o2 = this.getSize();
    if (!o2) return null;
    const r3 = [];
    return U(r3, o2, e2.call(this), t3), r3;
  }), t2(o.PeGTlistExtendedEntry.prototype, "getEntries", (e2) => {
    const t3 = o._pe_getPeGTlistExtendedGTsSize();
    return function() {
      let r3 = null;
      const _3 = e2.call(this);
      if (!o.compare(_3, o.NULL)) {
        r3 = [_3];
        const e3 = this.getSteps();
        if (e3 > 1) {
          const n4 = o.getPointer(_3);
          for (let _4 = 1; _4 < e3; _4++) r3.push(o.wrapPointer(n4 + t3 * _4, o.PeGTlistExtendedGTs));
        }
      }
      return r3;
    };
  });
  const _2 = o._pe_getPeHorizonSize(), n3 = (e2) => function() {
    let t3 = this._cache;
    if (t3 || (t3 = /* @__PURE__ */ new Map(), this._cache = t3), t3.has(e2)) return t3.get(e2);
    let r3 = null;
    const n4 = e2.call(this);
    if (!o.compare(n4, o.NULL)) {
      r3 = [n4];
      const e3 = n4.getNump();
      if (e3 > 1) {
        const t4 = o.getPointer(n4);
        for (let n5 = 1; n5 < e3; n5++) r3.push(o.wrapPointer(t4 + _2 * n5, o.PeHorizon));
      }
    }
    return t3.set(e2, r3), r3;
  };
  t2(o.PeProjcs.prototype, "horizonGcsGenerate", n3), t2(o.PeProjcs.prototype, "horizonPcsGenerate", n3), o.PeObject.prototype.toString = function(e2 = s.PE_STR_OPTS_NONE) {
    o.ensureCache.prepare();
    const t3 = o.getPointer(this), r3 = o.ensureInt8(new Array(s.PE_BUFFER_MAX));
    return o.UTF8ToString(o._pe_object_to_string_ext(t3, e2, r3));
  }, o.PeGeogcs.prototype.destroy = function() {
    this.Delete(), m(this), this.ptr = 0;
  }, o.PeGeogcs.prototype[Symbol.dispose] = function() {
    this.destroy();
  }, o.PeProjcs.prototype.destroy = function() {
    this.Delete(), m(this), this.ptr = 0;
  }, o.PeProjcs.prototype[Symbol.dispose] = function() {
    this.destroy();
  };
}
function m(e) {
  if (!e) return;
  const t2 = o.getClass(e);
  if (!t2) return;
  const r2 = o.getCache(t2);
  if (!r2) return;
  const _2 = o.getPointer(e);
  _2 && delete r2[_2];
}
function C(e, t2) {
  const r2 = [], _2 = new Array(t2);
  for (let n3 = 0; n3 < e; n3++) r2.push(o.ensureInt8(_2));
  return r2;
}
function I(e) {
  return ArrayBuffer.isView(e) ? e : Array.isArray(e[0]) ? e.flat() : e;
}
function U(e, t2, r2, _2 = false) {
  if (_2) for (let n3 = 0; n3 < 2 * t2; n3++) e[n3] = o.getValue(r2 + n3 * Float64Array.BYTES_PER_ELEMENT, "double");
  else {
    const _3 = 0 === e.length;
    for (let n3 = 0; n3 < t2; n3++) _3 && (e[n3] = new Array(2)), e[n3][0] = o.getValue(r2, "double"), e[n3][1] = o.getValue(r2 + Float64Array.BYTES_PER_ELEMENT, "double"), r2 += 2 * Float64Array.BYTES_PER_ELEMENT;
  }
}
var F = Object.freeze(Object.defineProperty({ __proto__: null, PeCSTransformations: P, PeDefs: s, get PeDouble() {
  return p;
}, PeFactory: c, get PeGCSExtent() {
  return g;
}, PeGTTransformations: u, PeGTlistExtended: y, PeGTlistExtendedEntry: l, PeLineType: S, PeMath: O, PeNotationDms: d, PeNotationMgrs: M, PeNotationUsng: A, PeNotationUtm: D, PePCSInfo: R, PeVersion: G, _init: h, get _pe() {
  return o;
}, isLoaded: r, isSupported: _, load: n2 }, Symbol.toStringTag, { value: "Module" }));

export {
  r,
  n2 as n,
  P,
  s,
  c,
  u,
  d,
  R,
  F
};
//# sourceMappingURL=chunk-7DGJB37R.js.map
