import {
  l as l2,
  l2 as l3,
  o as o2,
  o2 as o3
} from "./chunk-Q5ATDQWC.js";
import {
  h
} from "./chunk-QL52LNOM.js";
import {
  c as c2
} from "./chunk-V6DIT5FJ.js";
import "./chunk-NAJIRKWY.js";
import {
  g as g2,
  p as p2,
  u as u4
} from "./chunk-7EFQIJSP.js";
import "./chunk-YJPRACXY.js";
import {
  l as l4
} from "./chunk-TGHWFDOH.js";
import {
  t
} from "./chunk-KBVQCWWY.js";
import "./chunk-GVMCGYZ6.js";
import "./chunk-JHV6OBEB.js";
import {
  e as e3
} from "./chunk-7QPS6ATI.js";
import "./chunk-YYXR3KOD.js";
import {
  q
} from "./chunk-274P3DJ3.js";
import {
  c,
  n as n2,
  u as u2
} from "./chunk-2WMZLC2C.js";
import {
  e as e4,
  f,
  s as s2,
  u
} from "./chunk-HHDWMGJ3.js";
import "./chunk-WHHIH5YU.js";
import "./chunk-MEDXVTKR.js";
import "./chunk-5LMH6D7V.js";
import {
  l
} from "./chunk-BZLHV37L.js";
import "./chunk-V6V3WWJF.js";
import {
  M as M2,
  O,
  T as T2,
  U,
  V,
  g,
  o,
  y
} from "./chunk-NDFIZYZY.js";
import "./chunk-TLTSPUO7.js";
import {
  r as r2
} from "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import "./chunk-WCWUUHUV.js";
import "./chunk-7HTU7ZUX.js";
import "./chunk-QNVJVDYZ.js";
import "./chunk-WDTGOP77.js";
import "./chunk-VYMBX5H5.js";
import "./chunk-K2OZ6WVC.js";
import "./chunk-XL5QPCXN.js";
import "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-XLOINTMG.js";
import "./chunk-T7F6Q6JJ.js";
import {
  r
} from "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-3FUHCAX3.js";
import "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import {
  j,
  n
} from "./chunk-LTPHDYPK.js";
import {
  e as e2
} from "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import {
  u as u3
} from "./chunk-CCQFL76O.js";
import {
  p
} from "./chunk-GY6YF4EN.js";
import "./chunk-7H3U4IJR.js";
import {
  M,
  T
} from "./chunk-SMWUT52Z.js";
import "./chunk-AXZMNHTN.js";
import "./chunk-5T3MJDSR.js";
import "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import {
  H2 as H
} from "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import "./chunk-5EI5H4QX.js";
import "./chunk-ZIE53VIV.js";
import "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import {
  e
} from "./chunk-4DGC7CBY.js";
import "./chunk-GNMPGHLQ.js";
import {
  s2 as s
} from "./chunk-QY7XKUIV.js";
import "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/chunks/mat3.js
function e5(e9, t7, o6) {
  const r4 = e9.typedBuffer, f4 = e9.typedBufferStride, d = t7.typedBuffer, n3 = t7.typedBufferStride, c3 = o6 ? o6.count : t7.count;
  let u6 = (o6?.dstIndex ?? 0) * f4, l5 = (o6?.srcIndex ?? 0) * n3;
  for (let p3 = 0; p3 < c3; ++p3) {
    for (let e10 = 0; e10 < 9; ++e10) r4[u6 + e10] = d[l5 + e10];
    u6 += f4, l5 += n3;
  }
}
var t2 = Object.freeze(Object.defineProperty({ __proto__: null, copy: e5 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/mat4.js
function e6(e9, t7, o6) {
  const r4 = e9.typedBuffer, f4 = e9.typedBufferStride, d = t7.typedBuffer, n3 = t7.typedBufferStride, c3 = o6 ? o6.count : t7.count;
  let u6 = (o6?.dstIndex ?? 0) * f4, l5 = (o6?.srcIndex ?? 0) * n3;
  for (let p3 = 0; p3 < c3; ++p3) {
    for (let e10 = 0; e10 < 16; ++e10) r4[u6 + e10] = d[l5 + e10];
    u6 += f4, l5 += n3;
  }
}
var t3 = Object.freeze(Object.defineProperty({ __proto__: null, copy: e6 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/vec33.js
function e7(e9, f4) {
  t4(e9.typedBuffer, f4.typedBuffer, e9.typedBufferStride, f4.typedBufferStride);
}
function t4(e9, t7, f4 = 3, o6 = f4) {
  const r4 = t7.length / o6;
  let n3 = 0, u6 = 0;
  for (let c3 = 0; c3 < r4; ++c3) e9[n3] = t7[u6], e9[n3 + 1] = t7[u6 + 1], e9[n3 + 2] = t7[u6 + 2], n3 += f4, u6 += o6;
}
function f2(e9, t7, f4, o6, r4) {
  const n3 = e9.typedBuffer, u6 = e9.typedBufferStride, c3 = r4?.count ?? e9.count;
  let d = (r4?.dstIndex ?? 0) * u6;
  for (let l5 = 0; l5 < c3; ++l5) n3[d] = t7, n3[d + 1] = f4, n3[d + 2] = o6, d += u6;
}
var o4 = Object.freeze(Object.defineProperty({ __proto__: null, copy: t4, copyView: e7, fill: f2 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/vec43.js
function e8(e9, f4) {
  t5(e9.typedBuffer, f4, e9.typedBufferStride);
}
function t5(e9, t7, f4 = 4) {
  const o6 = t7.typedBuffer, r4 = t7.typedBufferStride, n3 = t7.count;
  let u6 = 0, c3 = 0;
  for (let d = 0; d < n3; ++d) e9[u6] = o6[c3], e9[u6 + 1] = o6[c3 + 1], e9[u6 + 2] = o6[c3 + 2], e9[u6 + 3] = o6[c3 + 3], u6 += f4, c3 += r4;
}
function f3(e9, t7, f4, o6, r4, n3) {
  const u6 = e9.typedBuffer, c3 = e9.typedBufferStride, d = n3?.count ?? e9.count;
  let l5 = (n3?.dstIndex ?? 0) * c3;
  for (let p3 = 0; p3 < d; ++p3) u6[l5] = t7, u6[l5 + 1] = f4, u6[l5 + 2] = o6, u6[l5 + 3] = r4, l5 += c3;
}
var o5 = Object.freeze(Object.defineProperty({ __proto__: null, copy: t5, copyView: e8, fill: f3 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/geometry/support/buffer/utils.js
function r3(s3, r4) {
  return new s3(new ArrayBuffer(r4 * s3.ElementCount * e3(s3.ElementType)));
}

// node_modules/@arcgis/core/geometry/support/meshUtils/loadGLTFMesh.js
async function G(e9, t7, r4) {
  const n3 = new l3(K(r4)), s3 = await l4(n3, t7, r4, true), a = s3.model, i = a.lods.shift(), l5 = /* @__PURE__ */ new Map(), c3 = /* @__PURE__ */ new Map();
  a.textures.forEach((e10, t8) => l5.set(t8, J(e10))), a.materials.forEach((e10, t8) => c3.set(t8, W(e10, l5)));
  const u6 = H2(i);
  for (const o6 of u6.parts) X(u6, o6, c3);
  const { position: f4, normal: m, tangent: p3, color: d, texCoord0: x } = u6.vertexAttributes, T3 = l(e9, r4), v = e9.spatialReference.isGeographic ? l(e9) : T3, j2 = q({ vertexAttributes: { position: f4.typedBuffer, normal: m?.typedBuffer, tangent: p3?.typedBuffer }, vertexSpace: v, spatialReference: e9.spatialReference }, T3, { allowBufferReuse: true, sourceUnit: r4?.unitConversionDisabled ? void 0 : "meters" });
  if (!j2) throw new s("load-gltf-mesh:vertex-space-projection", `Failed to load mesh from glTF because we could not convert the vertex space from ${v.type} to ${T3.type}`);
  return { mesh: { transform: null, vertexSpace: T3, components: u6.components, spatialReference: e9.spatialReference, vertexAttributes: new c2({ ...j2, color: d?.typedBuffer, uv: x?.typedBuffer }) }, meta: s3.meta };
}
function K(e9) {
  const t7 = e9?.resolveFile;
  return t7 ? { busy: false, request: async (e10, o6, n3) => {
    const s3 = t7?.(e10) ?? e10, a = 2 === o6 ? "image" : 1 === o6 || 3 === o6 ? "array-buffer" : "json";
    return (await H(s3, { responseType: a, signal: n3?.signal, timeout: 0 })).data;
  } } : null;
}
function P(e9, t7) {
  if (null == e9) return "-";
  const r4 = e9.typedBuffer;
  return `${e(t7, r4.buffer, () => t7.size)}/${r4.byteOffset}/${r4.byteLength}`;
}
function Q(e9) {
  return null != e9 ? e9.toString() : "-";
}
function H2(e9) {
  let t7 = 0;
  const has = { color: false, tangent: false, normal: false, texCoord0: false }, r4 = /* @__PURE__ */ new Map(), o6 = /* @__PURE__ */ new Map(), s3 = [];
  for (const a of e9.parts) {
    const { position: e10, normal: i, color: l5, tangent: c3, texCoord0: u6 } = a.attributes, f4 = `
      ${P(e10, r4)}/
      ${P(i, r4)}/
      ${P(l5, r4)}/
      ${P(c3, r4)}/
      ${P(u6, r4)}/
      ${Q(a.transform)}
    `;
    let m = false;
    const p3 = e(o6, f4, () => (m = true, { start: t7, length: e10.count }));
    m && (t7 += e10.count), i && (has.normal = true), l5 && (has.color = true), c3 && (has.tangent = true), u6 && (has.texCoord0 = true), s3.push({ gltf: a, writeVertices: m, region: p3 });
  }
  return { vertexAttributes: { position: r3(U, t7), normal: has.normal ? r3(o, t7) : null, tangent: has.tangent ? r3(T2, t7) : null, color: has.color ? r3(g, t7) : null, texCoord0: has.texCoord0 ? r3(y, t7) : null }, parts: s3, components: [] };
}
function J(e9) {
  return new g2({ data: (t(e9.data), e9.data), wrap: _(e9.parameters.wrap) });
}
function W(t7, r4) {
  const o6 = new u3(re(t7.color, t7.opacity)), n3 = t7.emissiveFactor ? new u3(oe(t7.emissiveFactor)) : null, a = (e9) => e9 ? new p2({ scale: e9.scale ? [e9.scale[0], e9.scale[1]] : [1, 1], rotation: M(e9.rotation ?? 0), offset: e9.offset ? [e9.offset[0], e9.offset[1]] : [0, 0] }) : null;
  return new u4({ color: o6, colorTexture: r4.get(t7.colorTexture), normalTexture: r4.get(t7.normalTexture), emissiveColor: n3, emissiveTexture: r4.get(t7.emissiveTexture), occlusionTexture: r4.get(t7.occlusionTexture), alphaMode: Z(t7.alphaMode), alphaCutoff: t7.alphaCutoff, doubleSided: t7.doubleSided, metallic: t7.metallicFactor, roughness: t7.roughnessFactor, metallicRoughnessTexture: r4.get(t7.metallicRoughnessTexture), colorTextureTransform: a(t7.colorTextureTransform), normalTextureTransform: a(t7.normalTextureTransform), occlusionTextureTransform: a(t7.occlusionTextureTransform), emissiveTextureTransform: a(t7.emissiveTextureTransform), metallicRoughnessTextureTransform: a(t7.metallicRoughnessTextureTransform) });
}
function X(e9, t7, r4) {
  t7.writeVertices && Y(e9, t7);
  const { indices: o6, attributes: n3, primitiveType: s3, material: a } = t7.gltf;
  let i = o3(o6 || n3.position.count, s3);
  const l5 = t7.region.start;
  if (l5) {
    const e10 = new Uint32Array(i);
    for (let t8 = 0; t8 < i.length; t8++) e10[t8] += l5;
    i = e10;
  }
  e9.components.push(new h({ name: t7.gltf.name, faces: i, material: r4.get(a), shading: n3.normal ? "source" : "flat", trustSourceNormals: true }));
}
function Y(e9, t7) {
  const { position: r4, normal: o6, tangent: n3, color: s3, texCoord0: u6 } = e9.vertexAttributes, f4 = t7.region.start, { attributes: m, transform: p3 } = t7.gltf, d = m.position.count;
  if (e4(r4.slice(f4, d), m.position, p3), null != m.normal && null != o6) {
    const e10 = j(e2(), p3), t8 = o6.slice(f4, d);
    f(t8, m.normal, e10), T(e10) && s2(t8, t8);
  } else null != o6 && f2(o6, 0, 0, 1, { dstIndex: f4, count: d });
  if (null != m.tangent && null != n3) {
    const e10 = n(e2(), p3), t8 = n3.slice(f4, d);
    n2(t8, m.tangent, e10), T(e10) && u2(t8, t8);
  } else null != n3 && f3(n3, 0, 0, 1, 1, { dstIndex: f4, count: d });
  if (null != m.texCoord0 && null != u6 ? o2(u6.slice(f4, d), m.texCoord0) : null != u6 && l2(u6, 0, 0, { dstIndex: f4, count: d }), null != m.color && null != s3) {
    const e10 = m.color, t8 = s3.slice(f4, d);
    if (4 === e10.elementCount) e10 instanceof T2 ? c(t8, e10, 1, 255) : (e10 instanceof g || e10 instanceof M2) && c(t8, e10, 1 / 255, 255);
    else {
      f3(t8, 255, 255, 255, 255);
      const r5 = O.fromTypedArray(t8.typedBuffer, t8.typedBufferStride);
      e10 instanceof o ? u(r5, e10, 1, 255) : (e10 instanceof O || e10 instanceof V) && u(r5, e10, 1 / 255, 255);
    }
  } else null != s3 && f3(s3.slice(f4, d), 255, 255, 255, 255);
}
function Z(e9) {
  switch (e9) {
    case "OPAQUE":
      return "opaque";
    case "MASK":
      return "mask";
    case "BLEND":
      return "blend";
  }
}
function _(e9) {
  return { horizontal: ee(e9.s), vertical: ee(e9.t) };
}
function ee(e9) {
  switch (e9) {
    case 33071:
      return "clamp";
    case 33648:
      return "mirror";
    case 10497:
      return "repeat";
  }
}
function te(e9) {
  return e9 ** (1 / p) * 255;
}
function re(e9, t7) {
  return r2(te(e9[0]), te(e9[1]), te(e9[2]), t7);
}
function oe(e9) {
  return r(te(e9[0]), te(e9[1]), te(e9[2]));
}
export {
  G as loadGLTFMesh
};
//# sourceMappingURL=loadGLTFMesh-AJKH3W6I.js.map
