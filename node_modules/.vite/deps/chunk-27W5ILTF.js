import {
  e as e3,
  e2 as e4,
  h as h2,
  o as o2,
  r as r3
} from "./chunk-GVFNGMIY.js";
import {
  B,
  C,
  D,
  E,
  F,
  G,
  J,
  K,
  L,
  w
} from "./chunk-RQGBRVDD.js";
import {
  a2 as a3,
  o as o3,
  s as s5,
  t2
} from "./chunk-JPZOLUPV.js";
import {
  R as R2,
  S as S2,
  X,
  c,
  g,
  l as l3,
  s as s4,
  y,
  z
} from "./chunk-DRHU543D.js";
import {
  r as r2
} from "./chunk-F7RQDGE7.js";
import {
  a
} from "./chunk-U5TTP5E5.js";
import {
  _,
  a as a4,
  i as i3
} from "./chunk-VR2ODL2Y.js";
import {
  h,
  l as l4
} from "./chunk-SMJWJAIA.js";
import {
  q as q2
} from "./chunk-YE4E5JCT.js";
import {
  e as e2
} from "./chunk-SXZO7ULH.js";
import {
  e
} from "./chunk-GCI4MA3M.js";
import {
  n
} from "./chunk-B5A4L35M.js";
import {
  a as a2,
  i as i2,
  s as s3
} from "./chunk-52SEOH5H.js";
import {
  It,
  Jt,
  T,
  at,
  l as l2,
  o,
  q,
  st,
  tt
} from "./chunk-JE2NJSBU.js";
import {
  R
} from "./chunk-QNVJVDYZ.js";
import {
  t2 as t
} from "./chunk-PZ5RULLK.js";
import {
  S
} from "./chunk-AZXJIEZ6.js";
import {
  u as u2
} from "./chunk-CCQFL76O.js";
import {
  u
} from "./chunk-CSMCPN64.js";
import {
  r,
  s as s2
} from "./chunk-SMWUT52Z.js";
import {
  i3 as i,
  l3 as l,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  has
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/grouping.js
function e5(e9, o16) {
  let r12;
  if ("string" == typeof e9) r12 = l(e9 + `-seed(${o16})`);
  else {
    let t4 = 12;
    r12 = e9 ^ o16;
    do {
      r12 = 107 * (r12 >> 8 ^ r12) + t4 | 0;
    } while (0 !== --t4);
  }
  return (1 + r12 / (1 << 31)) / 2;
}
function o4(t4) {
  return Math.floor(e5(t4, r4) * n2);
}
var r4 = 53290320;
var n2 = 10;

// node_modules/@arcgis/core/views/2d/engine/webgl/animations/infos.js
function n3(t4) {
  return t4 instanceof i4 ? t4 : "object" == typeof t4 && "type" in t4 ? c2[t4.type].hydrate(t4) : new o5(t4);
}
var i4 = class {
  constructor(t4) {
    this.inputs = t4;
  }
  encode() {
    const t4 = [];
    for (const n12 of this.inputs) t4.push(...n12.encode());
    return t4.push(...this.instructions), t4;
  }
};
var o5 = class extends i4 {
  constructor(t4) {
    super([]), this.value = t4;
  }
  simplify() {
    return this;
  }
  get instructions() {
    if (Array.isArray(this.value)) {
      const [n12, i12, o16, s19] = this.value;
      return null != s19 ? h2.vector4.encode([n12, i12 || 0, o16 || 0, s19]) : h2.vector3.encode([n12, i12 || 0, o16 || 0]);
    }
    return h2.scalar.encode(this.value);
  }
};
var s6 = class _s extends i4 {
  constructor(t4, n12) {
    super([n12]), this._config = t4, this._parent = n12;
  }
  static hydrate(t4) {
    return new _s(t4, n3(t4.parent));
  }
  simplify() {
    if (this._config.relativeTranslation || this._config.absoluteScale) return this;
    const t4 = this._parent.simplify();
    if (!(t4 instanceof o5)) return this;
    const [n12, i12, r12, e9] = t4.value, c9 = this._config.translation.from[0], a14 = this._config.translation.from[1], f9 = this._config.rotation.from, h9 = this._config.scale.from;
    if (c9 === this._config.translation.to[0] && a14 === this._config.translation.to[1] && f9 === this._config.rotation.to && h9 === this._config.scale.to) {
      const t5 = r12 + f9, s19 = e9 * h9, u10 = Math.sin(r12), l15 = Math.cos(r12);
      return new o5([l15 * e9 * c9 - u10 * e9 * a14 + n12, u10 * e9 * c9 + l15 * e9 * a14 + i12, t5, s19]);
    }
    return new _s(this._config, t4);
  }
  get instructions() {
    return h2.animatedTransform.encode(this._config);
  }
};
var r5 = class _r extends i4 {
  constructor(t4, n12) {
    super([n12]), this._config = t4, this._parent = n12;
  }
  static hydrate(t4) {
    return new _r(t4, n3(t4.parent));
  }
  simplify() {
    const t4 = this._parent.simplify();
    if (!(t4 instanceof o5)) return this;
    const [n12, i12, s19, e9] = t4.value, c9 = this._config.color.from[0], a14 = this._config.color.from[1], f9 = this._config.color.from[2];
    let h9 = this._config.color.from[3];
    const u10 = this._config.opacity.from;
    return c9 === this._config.color.to[0] && a14 === this._config.color.to[1] && f9 === this._config.color.to[2] && h9 === this._config.color.to[3] && u10 === this._config.opacity.to ? (h9 *= u10, new o5([n12 * c9, i12 * a14, s19 * f9, e9 * h9])) : new _r(this._config, t4);
  }
  get instructions() {
    return h2.animatedColor.encode(this._config);
  }
};
var e6 = class _e extends i4 {
  constructor(t4, n12) {
    super([n12]), this._config = t4, this._parent = n12;
  }
  static hydrate(t4) {
    return new _e(t4, n3(t4.parent));
  }
  simplify() {
    const t4 = this._parent.simplify();
    return t4 instanceof o5 ? new _e(this._config, t4) : this;
  }
  get instructions() {
    return h2.animatedShift.encode(this._config);
  }
};
var c2 = { AnimatedTransform: s6, AnimatedColor: r5, AnimatedShift: e6 };

// node_modules/@arcgis/core/views/2d/engine/webgl/animations/utils.js
function s7(e9) {
  return a5(e9.map((e10) => l5(e10)).map((e10) => n3(e10).simplify()));
}
function r6(e9) {
  const t4 = [];
  return t4.push(e9.transform), t4.push(e9.fromColor), t4.push(e9.toColor), t4.push(e9.colorMix), t4.push(e9.toOpacity), t4.push(e9.opacityMix), e9?.shift ? t4.push(e9?.shift) : t4.push([1, 1, 1, 1]), t4;
}
function a5(e9) {
  const t4 = [], o16 = [];
  let i12 = 0;
  for (const s19 of e9) {
    const r12 = [...s19.encode(), ...h2.ret.encode()];
    t4.push([i12 + e9.length, 0, 0, 0]), o16.push(...r12), i12 += r12.length;
  }
  return [...t4, ...o16];
}
async function c3(e9, t4) {
  const o16 = e9;
  let i12;
  if ("number" == typeof o16 || "string" == typeof o16 || "boolean" == typeof o16) i12 = o16;
  else if (Array.isArray(o16)) i12 = await Promise.all(o16.map((e10) => c3(e10, t4)));
  else if ("object" == typeof o16) if ("valueExpressionInfo" in o16) {
    const { valueExpressionInfo: e10 } = o16, { expression: n12 } = e10;
    i12 = { ...o16, computed: await t4.createComputedField({ expression: n12 }) };
  } else {
    i12 = {};
    for (const e10 in o16) i12[e10] = await c3(o16[e10], t4);
  }
  return i12;
}
function l5(i12, n12, s19) {
  function r12(t4) {
    if (!("computed" in t4)) return t4;
    let o16 = t4.computed.readWithDefault(n12, s19, [255 * t4.defaultValue[0], 255 * t4.defaultValue[1], 255 * t4.defaultValue[2], t4.defaultValue[3]]);
    if ("string" == typeof o16) {
      const t5 = u2.fromString(o16);
      t5 && (o16 = [t5.r, t5.g, t5.b, t5.a]);
    }
    return o16;
  }
  const a14 = i12;
  let c9;
  if ("number" == typeof a14 || "string" == typeof a14 || "boolean" == typeof a14) c9 = a14;
  else if (Array.isArray(a14)) c9 = a14.map((e9) => l5(e9, n12, s19));
  else if ("object" == typeof a14) if ("type" in a14 && null != a14.type && "Process" === a14.type) switch (a14.op) {
    case "ArcadeColor":
      {
        const e9 = l5(a14.value, n12, s19);
        p(Array.isArray(e9) && 4 === e9.length);
        c9 = [e9[0] / 255, e9[1] / 255, e9[2] / 255, e9[3]];
      }
      break;
    case "Transparency":
      {
        const e9 = l5(a14.value, n12, s19);
        p("number" == typeof e9), c9 = 1 - e9 / 100;
      }
      break;
    case "Divide":
    case "Multiply":
    case "Add":
      {
        const e9 = l5(a14.left, n12, s19);
        p("number" == typeof e9);
        const t4 = l5(a14.right, n12, s19);
        switch (p("number" == typeof t4), a14.op) {
          case "Divide":
            c9 = e9 / t4;
            break;
          case "Multiply":
            c9 = e9 * t4;
            break;
          case "Add":
            c9 = e9 + t4;
        }
      }
      break;
    case "Random":
      {
        const e9 = l5(a14.seed, n12, s19), i13 = l5(a14.min, n12, s19), r13 = l5(a14.max, n12, s19), f9 = n12.getObjectId(), p8 = o4(f9 || 0);
        c9 = i13 + e5(p8, e9) * (r13 - i13);
      }
      break;
    case "Cond":
      {
        const e9 = l5(a14.condition, n12, s19), t4 = l5(a14.ifTrue, n12, s19), o16 = l5(a14.ifFalse, n12, s19);
        c9 = e9 ? t4 : o16;
      }
      break;
    case "MatchWinding": {
      const e9 = l5(a14.sign, n12, s19);
      let t4 = l5(a14.angle, n12, s19);
      if (e9 > 0) for (; t4 < 0; ) t4 += 2 * Math.PI;
      else for (; t4 > 0; ) t4 -= 2 * Math.PI;
      c9 = t4;
    }
  }
  else if ("computed" in a14) c9 = r12(a14);
  else {
    c9 = {};
    for (const e9 in a14) c9[e9] = l5(a14[e9], n12, s19);
  }
  return c9;
}
function* f(e9) {
  const t4 = e9;
  if (Array.isArray(t4)) for (const o16 of t4) yield* f(o16);
  else if ("object" == typeof t4) if ("type" in t4 && null != t4.type && "Process" === t4.type) switch (t4.op) {
    case "ArcadeColor":
    case "Transparency":
      yield* f(t4.value);
      break;
    case "Divide":
    case "Multiply":
    case "Add":
      yield* f(t4.left), yield* f(t4.right);
      break;
    case "Random":
      yield* f(t4.seed), yield* f(t4.min), yield* f(t4.max);
      break;
    case "Cond":
      yield* f(t4.condition), yield* f(t4.ifTrue), yield* f(t4.ifFalse);
      break;
    case "MatchWinding":
      yield* f(t4.sign), yield* f(t4.angle);
  }
  else if ("computed" in t4) yield t4.computed;
  else for (const o16 in t4) yield* f(t4[o16]);
}
function p(e9) {
  if (!e9) throw new Error("Assertion failed.");
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/meshWriterUtils.js
var n4 = () => i.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.meshWriterUtils");
var o6 = 0;
var c4 = 100;
function s8(r12, e9) {
  return [!!r12?.minScale && e9.scaleToZoom(r12.minScale) || o6, !!r12?.maxScale && e9.scaleToZoom(r12.maxScale) || c4];
}
function i5(r12) {
  return 1 << r12;
}
function u3(r12) {
  let e9 = 0;
  for (const [t4, n12] of r12) n12 && (e9 |= 1 << t4);
  return e9;
}
function a6(t4) {
  let o16;
  if (!t4) return [0, 0, 0, 0];
  if ("string" == typeof t4) {
    const c10 = u2.fromString(t4);
    if (!c10) return n4().errorOnce(new s("mapview:mesh-processing", "Unable to parse string into color", { color: t4 })), [0, 0, 0, 0];
    o16 = c10.toArray();
  } else o16 = t4;
  const [c9, s19, i12, u10] = o16;
  return [c9 * (u10 / 255), s19 * (u10 / 255), i12 * (u10 / 255), u10];
}
function f2(r12) {
  switch (r12) {
    case "butt":
    case "Butt":
      return 0;
    case "round":
    case "Round":
      return 1;
    case "square":
    case "Square":
      return 2;
  }
}
function m(r12) {
  switch (r12) {
    case "bevel":
    case "Bevel":
      return 0;
    case "miter":
    case "Miter":
      return 2;
    case "round":
    case "Round":
      return 1;
  }
}
function l6(r12, e9) {
  return Math.round(Math.min(Math.sqrt(r12 * e9), 255));
}
function g2(r12, e9) {
  return Math.round(r12 * e9) / e9;
}

// node_modules/@arcgis/core/symbols/cim/effects/CIMEffectHelper.js
var n5 = 96 / 72;
var l7 = class {
  static executeEffects(t4, e9, l15, c9) {
    const f9 = n5, m7 = X(t4);
    let p8 = new g(e9);
    for (const o16 of t4) {
      const t5 = R2(o16);
      t5 && (p8 = t5.execute(p8, o16, f9, l15, m7, c9));
    }
    return p8;
  }
  static applyEffects(n12, l15) {
    if (!n12) return l15;
    const c9 = X(n12);
    let f9, m7 = new g(a.fromJSONCIM(l15));
    for (const t4 of n12) {
      const e9 = R2(t4);
      e9 && (m7 = e9.execute(m7, t4, 1, null, c9, false));
    }
    const p8 = [];
    let u10 = null;
    for (; f9 = m7.next(); ) p8.push(...t(f9)), u10 = f9.geometryType;
    return 0 === p8.length || null === u10 ? null : "esriGeometryPolygon" === u10 ? { rings: p8 } : { paths: p8 };
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/mesh/AlignedVertexSpec.js
function s9(t4) {
  switch (t4) {
    case R.BYTE:
    case R.UNSIGNED_BYTE:
      return 1;
    case R.SHORT:
    case R.UNSIGNED_SHORT:
    case R.HALF_FLOAT:
      return 2;
    case R.FLOAT:
    case R.INT:
    case R.UNSIGNED_INT:
      return 4;
  }
}
function o7(t4) {
  const e9 = [], o16 = [], n12 = [];
  for (const i12 of t4) {
    const t5 = s9(i12.type) * i12.count;
    switch (t5 % 2 || t5 % 4 || 4) {
      case 4:
        e9.push(i12);
        continue;
      case 2:
        o16.push(i12);
        continue;
      case 1:
        n12.push(i12);
        continue;
      default:
        throw new Error("Found unexpected dataType byte count");
    }
  }
  return e9.push(...o16), e9.push(...n12), e9;
}
var n6 = class _n {
  static fromVertexSpec(t4, e9) {
    const { attributes: i12, optionalAttributes: r12 } = t4;
    let a14, c9, u10;
    const p8 = [];
    for (const s19 in i12) {
      if (i12[s19].otherSource) continue;
      const t5 = i12[s19];
      "position" === t5.pack ? a14 = { ...t5, name: s19, offset: 0 } : "id" === t5.pack ? c9 = { ...t5, name: s19, offset: 4 } : "bitset" === s19 ? u10 = { ...t5, name: s19, offset: 7 } : p8.push({ ...t5, name: s19 });
    }
    for (const s19 in r12) if (true === e9[s19]) {
      const t5 = r12[s19];
      p8.push({ ...t5, name: s19 });
    }
    const h9 = o7(p8), f9 = [];
    let m7 = 8, b4 = 1;
    for (const o16 of h9) f9.push({ ...o16, offset: m7 }), m7 += s9(o16.type) * o16.count, o16.packAlternating && (b4 = Math.max(o16.packAlternating.count, b4));
    const d5 = Uint32Array.BYTES_PER_ELEMENT, _4 = m7 % d5;
    return new _n(a14, c9, u10, f9, m7 + (_4 ? d5 - _4 : 0), b4);
  }
  constructor(t4, e9, s19, o16, n12, i12) {
    this.position = t4, this.id = e9, this.bitset = s19, this.standardAttributes = o16, this.stride = n12, this.packVertexCount = i12, o16.push(s19), this._attributes = [t4, e9, s19, ...o16];
  }
  get attributeLayout() {
    if (!this._attributeLayout) {
      const e9 = t2(this._attributes), s19 = this._attributes.map((t4) => ({ name: t4.name, count: t4.count, offset: t4.offset, type: t4.type, packPrecisionFactor: t4.packPrecisionFactor, normalized: t4.normalized ?? false }));
      this._attributeLayout = { attributes: s19, hash: e9, stride: this.stride };
    }
    return this._attributeLayout;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/mesh/MeshWriterVertexPack.js
var i6 = class _i {
  static fromVertexSpec(t4, s19) {
    const c9 = n6.fromVertexSpec(t4, s19);
    return new _i(c9);
  }
  constructor(t4) {
    this._spec = t4, this._packed = new Uint8Array(this._spec.stride * this._spec.packVertexCount), this._packedU32View = new Uint32Array(this._packed.buffer), this._dataView = new DataView(this._packed.buffer);
  }
  get attributeLayout() {
    return this._spec.attributeLayout;
  }
  get stride() {
    return this._spec.stride;
  }
  writeVertex(t4, e9, s19, i12, c9, a14) {
    for (let p8 = 0; p8 < this._spec.packVertexCount; p8++) {
      const t5 = p8 * this._spec.stride;
      this._packPosition(s19, i12, t5), this._packId(e9, t5);
      const r12 = this._spec.bitset;
      if (a14) {
        if (r12.packTessellation) {
          const e10 = r12.packTessellation(a14, c9, s19, i12);
          this._pack(e10, r12, t5);
        }
        for (const e10 of this._spec.standardAttributes) if (null != e10.packTessellation) {
          const p9 = e10.packTessellation(a14, c9, s19, i12);
          this._pack(p9, e10, t5);
        } else if (e10.packAlternating?.packTessellation) {
          const t6 = e10.packAlternating.packTessellation(a14, c9, s19, i12);
          for (let s20 = 0; s20 < this._spec.packVertexCount; s20++) {
            const i13 = t6[s20];
            this._pack(i13, e10, s20 * this._spec.stride);
          }
        }
      }
    }
    t4.vertexWriteRegion(this._packedU32View);
  }
  pack(t4, e9) {
    for (const s19 of this._spec.standardAttributes) if (s19.pack && "string" != typeof s19.pack) {
      const i12 = s19.pack(t4, e9);
      for (let t5 = 0; t5 < this._spec.packVertexCount; t5++) this._pack(i12, s19, t5 * this._spec.stride);
    } else if (s19.packAlternating?.pack) {
      const i12 = s19.packAlternating.pack(t4, e9);
      for (let t5 = 0; t5 < this._spec.packVertexCount; t5++) {
        const e10 = i12[t5];
        this._pack(e10, s19, t5 * this._spec.stride);
      }
    }
  }
  _packPosition(e9, s19, i12) {
    const { offset: c9 } = this._spec.position, a14 = this._spec.position.packPrecisionFactor ?? 1, p8 = s5(e9 * a14, s19 * a14);
    this._dataView.setUint32(i12 + c9, p8, true);
  }
  _packId(t4, e9) {
    const s19 = t4 * (this._spec.id.packPrecisionFactor ?? 1), i12 = 4278190080 & this._dataView.getUint32(e9 + this._spec.id.offset, true);
    this._dataView.setUint32(e9 + this._spec.id.offset, s19 | i12, true);
  }
  _pack(t4, e9, i12) {
    o3(this._dataView, t4, e9, i12);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/mesh/MeshWriter.js
var a7 = class {
  constructor(e9, t4, r12, s19) {
    this._instanceId = e9, this._evaluator = t4, this._enabledOptionalAttributes = r12, this._viewParams = s19, this._evaluator.evaluator = (e10) => this.vertexSpec.createComputedParams(e10);
  }
  get _vertexPack() {
    if (!this._cachedVertexPack) {
      const e9 = i6.fromVertexSpec(this.vertexSpec, this._enabledOptionalAttributes);
      this._evaluator.hasDynamicProperties || e9.pack(this._evaluator.evaluatedMeshParams, this._viewParams), this._cachedVertexPack = e9;
    }
    return this._cachedVertexPack;
  }
  get evaluatedMeshParams() {
    return this._evaluator.evaluatedMeshParams;
  }
  get hasEffects() {
    return !!this.evaluatedMeshParams.effects;
  }
  get effectInfos() {
    return this._evaluator.inputMeshParams.effects?.effectInfos;
  }
  get instanceId() {
    return this._instanceId;
  }
  get attributeLayout() {
    return this._vertexPack.attributeLayout;
  }
  get _preventEffectClipping() {
    return false;
  }
  setReferences(e9) {
    this._references = e9;
  }
  getBoundsInfo() {
    return null;
  }
  getTileInfo() {
    return this._viewParams.tileInfo;
  }
  async loadDependencies() {
    for (const { effect: e9 } of this.effectInfos || []) await l3(e9);
  }
  enqueueRequest(e9, t4, r12) {
    this._evaluator.hasDynamicProperties && this._evaluator.enqueueRequest(e9, t4, r12);
  }
  write(e9, t4, r12, s19, a14) {
    this.ensurePacked(t4, r12, s19);
    const i12 = this.evaluatedMeshParams.effects;
    if (!i12 || 0 === i12.length) return void this._write(e9, r12, void 0, a14);
    const n12 = this.getEffectCursor(e9, r12, i12);
    if (!n12) return;
    let c9;
    for (; c9 = n12.next(); ) c9.invertY(), this._write(e9, r12, c9, a14);
  }
  ensurePacked(e9, t4, r12) {
    if (!this._evaluator.hasDynamicProperties) return;
    const s19 = this._evaluator.evaluateMeshParams(e9, t4, r12);
    this._vertexPack.pack(s19, this._viewParams);
  }
  hasArcadeDependency(e9) {
    return this._evaluator.hasArcadeDependency(e9);
  }
  _writeVertex(e9, t4, r12, s19, a14) {
    const i12 = this.evaluatedMeshParams;
    this._vertexPack.writeVertex(e9, t4, r12, s19, i12, a14);
  }
  getEffectCursor(t4, s19, a14) {
    const i12 = s19.readGeometryForDisplay()?.clone();
    if (!i12) return;
    const n12 = a.fromOptimizedCIM(i12, s19.geometryType);
    n12.invertY();
    const c9 = t4.id || "";
    return l7.executeEffects(a14, n12, c9, this._preventEffectClipping);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/animated/AnimatedMeshWriter.js
var o8 = class extends a7 {
};
function r7(e9) {
  const { sprite: o16, isMapAligned: r12, colorLocked: i12, scaleSymbolsProportionally: l15, isStroke: m7 } = e9;
  let n12 = 0;
  return r12 && (n12 |= i5(o2.bitset.isMapAligned)), i12 && (n12 |= i5(o2.bitset.colorLocked)), o16.sdf && (n12 |= i5(o2.bitset.isSDF)), l15 && (n12 |= i5(o2.bitset.scaleSymbolsProportionally)), m7 && (n12 |= i5(o2.bitset.isStroke)), n12;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/animated/attributes.js
var a8 = { type: R.SHORT, count: 2, packPrecisionFactor: st, pack: ({ scaleInfo: t4 }, { tileInfo: e9 }) => s8(t4, e9) };
var s10 = { type: R.FLOAT, count: 4, packPrecisionFactor: 1, packTessellation: ({ value1Position2Value2: t4 }) => (p(t4), t4) };
var p2 = { type: R.FLOAT, count: 4, packPrecisionFactor: 1, packTessellation: () => [0, 0, 0, 1] };
var r8 = { type: R.FLOAT, count: 1, packPrecisionFactor: 1, pack: () => 0 };
var l8 = { type: R.FLOAT, count: 1, packPrecisionFactor: 1, packTessellation: ({ lineLength: t4 }) => t4 };
var k = { type: R.UNSIGNED_SHORT, count: 1, packTessellation: ({ distance: t4 }) => t4 };
var u4 = { type: R.BYTE, count: 2, packPrecisionFactor: 16, packTessellation: ({ directionX: t4, directionY: e9 }) => [t4, e9] };
var T2 = { type: R.FLOAT, count: 2, packPrecisionFactor: 16, packTessellation: ({ normalX: t4, normalY: e9 }) => [t4, e9] };
var m2 = { type: R.UNSIGNED_BYTE, count: 3, pack: "id" };
var y2 = { type: R.UNSIGNED_BYTE, count: 1, pack: r7 };
var F2 = { type: R.SHORT, count: 2, pack: "position", packPrecisionFactor: 1 };
var f3 = { marker: { type: R.FLOAT, count: 2, packAlternating: { count: 4, pack: ({ texelDimensions: t4 }) => [[-0.5 * t4[0], -0.5 * t4[1]], [0.5 * t4[0], -0.5 * t4[1]], [-0.5 * t4[0], 0.5 * t4[1]], [0.5 * t4[0], 0.5 * t4[1]]] } }, line: { type: R.FLOAT, count: 2, packTessellation: ({ extrusionOffsetX: t4, extrusionOffsetY: e9 }, { baseSize: o16 }) => [t4 * o16 / 2, e9 * o16 / 2] }, fill: { type: R.FLOAT, count: 2, packTessellation: () => [0, 0] } };
var O = { marker: { type: R.SHORT, count: 2, packPrecisionFactor: 1, packAlternating: { count: 4, packTessellation: ({ texXmax: t4, texXmin: e9, texYmax: o16, texYmin: i12 }) => [[e9, i12], [t4, i12], [e9, o16], [t4, o16]] } } };
var S3 = { type: R.UNSIGNED_SHORT, count: 4, pack: ({ sprite: t4 }) => {
  const { rect: o16, width: i12, height: c9 } = t4, n12 = o16.x + tt, a14 = o16.y + tt;
  return [n12 + 1, a14 + 1, n12 + i12 - 1, a14 + c9 - 1];
} };
var d = { type: R.UNSIGNED_SHORT, count: 4, packPrecisionFactor: 4, pack: ({ animations: t4, baseSize: e9, referenceSize: o16 }) => [t4.dataColumn, t4.dataRow, e9, o16] };
var x = { type: R.UNSIGNED_SHORT, count: 4, packPrecisionFactor: 8, pack: ({ strokeWidth: t4, pixelDimensions: e9, baseSize: o16, sprite: i12, sizeRatio: c9 }) => {
  const n12 = Math.max(o16 * i12.width / i12.height, o16), a14 = i12.sdfDecodeCoeff * n12 * c9;
  return [e9[0], e9[1], t4, a14];
} };
var N = { type: R.BYTE, count: 1, packTessellation: ({ angle: t4 }) => t4 };

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/bufcut.js
function e7(e9, t4, r12, i12, u10, o16, l15) {
  D2 = 0;
  const y4 = (i12 - r12) * o16, p8 = u10 && u10.length, c9 = p8 ? (u10[0] - r12) * o16 : y4;
  let v3, s19, h9, d5, Z2, a14 = n7(t4, r12, i12, 0, c9, o16, true);
  if (a14 && a14.next !== a14.prev) {
    if (p8 && (a14 = f4(t4, r12, i12, u10, a14, o16)), y4 > 80 * o16) {
      v3 = h9 = t4[0 + r12 * o16], s19 = d5 = t4[1 + r12 * o16];
      for (let e10 = o16; e10 < c9; e10 += o16) {
        const n12 = t4[e10 + r12 * o16], x6 = t4[e10 + 1 + r12 * o16];
        v3 = Math.min(v3, n12), s19 = Math.min(s19, x6), h9 = Math.max(h9, n12), d5 = Math.max(d5, x6);
      }
      Z2 = Math.max(h9 - v3, d5 - s19), Z2 = 0 !== Z2 ? 1 / Z2 : 0;
    }
    x2(a14, e9, o16, v3, s19, Z2, l15, 0);
  }
}
function n7(e9, n12, t4, x6, r12, i12, l15) {
  let f9;
  if (l15 === Z(e9, n12, t4, x6, r12, i12) > 0) for (let o16 = x6; o16 < r12; o16 += i12) f9 = u5(o16 + n12 * i12, e9[o16 + n12 * i12], e9[o16 + 1 + n12 * i12], f9);
  else for (let o16 = r12 - i12; o16 >= x6; o16 -= i12) f9 = u5(o16 + n12 * i12, e9[o16 + n12 * i12], e9[o16 + 1 + n12 * i12], f9);
  return f9 && m3(f9, f9.next) && (o9(f9), f9 = f9.next), f9;
}
function t3(e9, n12 = e9) {
  if (!e9) return e9;
  let t4, x6 = e9;
  do {
    if (t4 = false, x6.steiner || !m3(x6, x6.next) && 0 !== s11(x6.prev, x6, x6.next)) x6 = x6.next;
    else {
      if (o9(x6), x6 = n12 = x6.prev, x6 === x6.next) break;
      t4 = true;
    }
  } while (t4 || x6 !== n12);
  return n12;
}
function x2(e9, n12, u10, l15, f9, y4, p8, v3) {
  if (!e9) return;
  !v3 && y4 && (e9 = c5(e9, l15, f9, y4));
  let s19 = e9;
  for (; e9.prev !== e9.next; ) {
    const c9 = e9.prev, h9 = e9.next;
    if (y4 ? i7(e9, l15, f9, y4) : r9(e9)) n12.push(c9.index / u10 + p8), n12.push(e9.index / u10 + p8), n12.push(h9.index / u10 + p8), o9(e9), e9 = h9.next, s19 = h9.next;
    else if ((e9 = h9) === s19) {
      v3 ? 1 === v3 ? x2(e9 = b(e9, n12, u10, p8), n12, u10, l15, f9, y4, p8, 2) : 2 === v3 && g3(e9, n12, u10, l15, f9, y4, p8) : x2(t3(e9), n12, u10, l15, f9, y4, p8, 1);
      break;
    }
  }
}
function r9(e9) {
  const n12 = e9.prev, t4 = e9, x6 = e9.next;
  if (s11(n12, t4, x6) >= 0) return false;
  let r12 = e9.next.next;
  const i12 = r12;
  let u10 = 0;
  for (; r12 !== e9.prev && (0 === u10 || r12 !== i12); ) {
    if (u10++, a9(n12.x, n12.y, t4.x, t4.y, x6.x, x6.y, r12.x, r12.y) && s11(r12.prev, r12, r12.next) >= 0) return false;
    r12 = r12.next;
  }
  return true;
}
function i7(e9, n12, t4, x6) {
  const r12 = e9.prev, i12 = e9, u10 = e9.next;
  if (s11(r12, i12, u10) >= 0) return false;
  const o16 = r12.x < i12.x ? r12.x < u10.x ? r12.x : u10.x : i12.x < u10.x ? i12.x : u10.x, l15 = r12.y < i12.y ? r12.y < u10.y ? r12.y : u10.y : i12.y < u10.y ? i12.y : u10.y, f9 = r12.x > i12.x ? r12.x > u10.x ? r12.x : u10.x : i12.x > u10.x ? i12.x : u10.x, y4 = r12.y > i12.y ? r12.y > u10.y ? r12.y : u10.y : i12.y > u10.y ? i12.y : u10.y, p8 = z2(o16, l15, n12, t4, x6), c9 = z2(f9, y4, n12, t4, x6);
  let v3 = e9.prevZ, h9 = e9.nextZ;
  for (; v3 && v3.z >= p8 && h9 && h9.z <= c9; ) {
    if (v3 !== e9.prev && v3 !== e9.next && a9(r12.x, r12.y, i12.x, i12.y, u10.x, u10.y, v3.x, v3.y) && s11(v3.prev, v3, v3.next) >= 0) return false;
    if (v3 = v3.prevZ, h9 !== e9.prev && h9 !== e9.next && a9(r12.x, r12.y, i12.x, i12.y, u10.x, u10.y, h9.x, h9.y) && s11(h9.prev, h9, h9.next) >= 0) return false;
    h9 = h9.nextZ;
  }
  for (; v3 && v3.z >= p8; ) {
    if (v3 !== e9.prev && v3 !== e9.next && a9(r12.x, r12.y, i12.x, i12.y, u10.x, u10.y, v3.x, v3.y) && s11(v3.prev, v3, v3.next) >= 0) return false;
    v3 = v3.prevZ;
  }
  for (; h9 && h9.z <= c9; ) {
    if (h9 !== e9.prev && h9 !== e9.next && a9(r12.x, r12.y, i12.x, i12.y, u10.x, u10.y, h9.x, h9.y) && s11(h9.prev, h9, h9.next) >= 0) return false;
    h9 = h9.nextZ;
  }
  return true;
}
function u5(e9, n12, t4, x6) {
  const r12 = q3.create(e9, n12, t4);
  return x6 ? (r12.next = x6.next, r12.prev = x6, x6.next.prev = r12, x6.next = r12) : (r12.prev = r12, r12.next = r12), r12;
}
function o9(e9) {
  e9.next.prev = e9.prev, e9.prev.next = e9.next, e9.prevZ && (e9.prevZ.nextZ = e9.nextZ), e9.nextZ && (e9.nextZ.prevZ = e9.prevZ);
}
function l9(e9) {
  let n12 = e9, t4 = e9;
  do {
    (n12.x < t4.x || n12.x === t4.x && n12.y < t4.y) && (t4 = n12), n12 = n12.next;
  } while (n12 !== e9);
  return t4;
}
function f4(e9, t4, x6, r12, i12, u10) {
  const o16 = new Array();
  for (let f9 = 0, y4 = r12.length; f9 < y4; f9++) {
    const i13 = n7(e9, t4, x6, r12[f9] * u10, f9 < y4 - 1 ? r12[f9 + 1] * u10 : x6 * u10, u10, false);
    i13 === i13.next && (i13.steiner = true), o16.push(l9(i13));
  }
  o16.sort(M);
  for (const n12 of o16) i12 = y3(n12, i12);
  return i12;
}
function y3(e9, n12) {
  const x6 = p3(e9, n12);
  if (!x6) return n12;
  const r12 = A(x6, e9);
  return t3(r12, r12.next), t3(x6, x6.next);
}
function p3(e9, n12) {
  let t4 = n12;
  const x6 = e9.x, r12 = e9.y;
  let i12, u10 = -1 / 0;
  do {
    if (r12 <= t4.y && r12 >= t4.next.y && t4.next.y !== t4.y) {
      const e10 = t4.x + (r12 - t4.y) * (t4.next.x - t4.x) / (t4.next.y - t4.y);
      if (e10 <= x6 && e10 > u10) {
        if (u10 = e10, e10 === x6) {
          if (r12 === t4.y) return t4;
          if (r12 === t4.next.y) return t4.next;
        }
        i12 = t4.x < t4.next.x ? t4 : t4.next;
      }
    }
    t4 = t4.next;
  } while (t4 !== n12);
  if (!i12) return null;
  if (x6 === u10) return i12.prev;
  const o16 = i12, l15 = i12.x, f9 = i12.y;
  let y4, p8 = 1 / 0;
  for (t4 = i12.next; t4 !== o16; ) x6 >= t4.x && t4.x >= l15 && x6 !== t4.x && a9(r12 < f9 ? x6 : u10, r12, l15, f9, r12 < f9 ? u10 : x6, r12, t4.x, t4.y) && (y4 = Math.abs(r12 - t4.y) / (x6 - t4.x), (y4 < p8 || y4 === p8 && t4.x > i12.x) && w2(t4, e9) && (i12 = t4, p8 = y4)), t4 = t4.next;
  return i12;
}
function c5(e9, n12, t4, x6) {
  let r12;
  for (; r12 !== e9; r12 = r12.next) {
    if (r12 = r12 || e9, null === r12.z && (r12.z = z2(r12.x, r12.y, n12, t4, x6)), r12.prev.next !== r12 || r12.next.prev !== r12) return r12.prev.next = r12, r12.next.prev = r12, c5(e9, n12, t4, x6);
    r12.prevZ = r12.prev, r12.nextZ = r12.next;
  }
  return e9.prevZ.nextZ = null, e9.prevZ = null, v(e9);
}
function v(e9) {
  let n12, t4 = 1;
  for (; ; ) {
    let x6, r12 = e9;
    e9 = null, n12 = null;
    let i12 = 0;
    for (; r12; ) {
      i12++, x6 = r12;
      let u10 = 0;
      for (; u10 < t4 && x6; u10++) x6 = x6.nextZ;
      let o16 = t4;
      for (; u10 > 0 || o16 > 0 && x6; ) {
        let t5;
        0 === u10 ? (t5 = x6, x6 = x6.nextZ, o16--) : 0 !== o16 && x6 ? r12.z <= x6.z ? (t5 = r12, r12 = r12.nextZ, u10--) : (t5 = x6, x6 = x6.nextZ, o16--) : (t5 = r12, r12 = r12.nextZ, u10--), n12 ? n12.nextZ = t5 : e9 = t5, t5.prevZ = n12, n12 = t5;
      }
      r12 = x6;
    }
    if (n12.nextZ = null, t4 *= 2, i12 < 2) return e9;
  }
}
function s11(e9, n12, t4) {
  return (n12.y - e9.y) * (t4.x - n12.x) - (n12.x - e9.x) * (t4.y - n12.y);
}
function h3(e9, n12, t4, x6) {
  return !!(m3(e9, n12) && m3(t4, x6) || m3(e9, x6) && m3(t4, n12)) || s11(e9, n12, t4) > 0 != s11(e9, n12, x6) > 0 && s11(t4, x6, e9) > 0 != s11(t4, x6, n12) > 0;
}
function d2(e9, n12) {
  let t4 = e9;
  do {
    if (t4.index !== e9.index && t4.next.index !== e9.index && t4.index !== n12.index && t4.next.index !== n12.index && h3(t4, t4.next, e9, n12)) return true;
    t4 = t4.next;
  } while (t4 !== e9);
  return false;
}
function Z(e9, n12, t4, x6, r12, i12) {
  let u10 = 0;
  for (let o16 = x6, l15 = r12 - i12; o16 < r12; o16 += i12) u10 += (e9[l15 + n12 * i12] - e9[o16 + n12 * i12]) * (e9[o16 + 1 + n12 * i12] + e9[l15 + 1 + n12 * i12]), l15 = o16;
  return u10;
}
function a9(e9, n12, t4, x6, r12, i12, u10, o16) {
  return (r12 - u10) * (n12 - o16) - (e9 - u10) * (i12 - o16) >= 0 && (e9 - u10) * (x6 - o16) - (t4 - u10) * (n12 - o16) >= 0 && (t4 - u10) * (i12 - o16) - (r12 - u10) * (x6 - o16) >= 0;
}
function w2(e9, n12) {
  return s11(e9.prev, e9, e9.next) < 0 ? s11(e9, n12, e9.next) >= 0 && s11(e9, e9.prev, n12) >= 0 : s11(e9, n12, e9.prev) < 0 || s11(e9, e9.next, n12) < 0;
}
function z2(e9, n12, t4, x6, r12) {
  return (e9 = 1431655765 & ((e9 = 858993459 & ((e9 = 252645135 & ((e9 = 16711935 & ((e9 = 32767 * (e9 - t4) * r12) | e9 << 8)) | e9 << 4)) | e9 << 2)) | e9 << 1)) | (n12 = 1431655765 & ((n12 = 858993459 & ((n12 = 252645135 & ((n12 = 16711935 & ((n12 = 32767 * (n12 - x6) * r12) | n12 << 8)) | n12 << 4)) | n12 << 2)) | n12 << 1)) << 1;
}
function m3(e9, n12) {
  return e9.x === n12.x && e9.y === n12.y;
}
function M(e9, n12) {
  return e9.x - n12.x;
}
function b(e9, n12, t4, x6) {
  let r12 = e9;
  do {
    const i12 = r12.prev, u10 = r12.next.next;
    !m3(i12, u10) && h3(i12, r12, r12.next, u10) && w2(i12, u10) && w2(u10, i12) && (n12.push(i12.index / t4 + x6), n12.push(r12.index / t4 + x6), n12.push(u10.index / t4 + x6), o9(r12), o9(r12.next), r12 = e9 = u10), r12 = r12.next;
  } while (r12 !== e9);
  return r12;
}
function g3(e9, n12, r12, i12, u10, o16, l15) {
  let f9 = e9;
  do {
    let e10 = f9.next.next;
    for (; e10 !== f9.prev; ) {
      if (f9.index !== e10.index && k2(f9, e10)) {
        let y4 = A(f9, e10);
        return f9 = t3(f9, f9.next), y4 = t3(y4, y4.next), x2(f9, n12, r12, i12, u10, o16, l15, 0), void x2(y4, n12, r12, i12, u10, o16, l15, 0);
      }
      e10 = e10.next;
    }
    f9 = f9.next;
  } while (f9 !== e9);
}
function k2(e9, n12) {
  return e9.next.index !== n12.index && e9.prev.index !== n12.index && !d2(e9, n12) && w2(e9, n12) && w2(n12, e9) && j(e9, n12);
}
function j(e9, n12) {
  let t4 = e9, x6 = false;
  const r12 = (e9.x + n12.x) / 2, i12 = (e9.y + n12.y) / 2;
  do {
    t4.y > i12 != t4.next.y > i12 && t4.next.y !== t4.y && r12 < (t4.next.x - t4.x) * (i12 - t4.y) / (t4.next.y - t4.y) + t4.x && (x6 = !x6), t4 = t4.next;
  } while (t4 !== e9);
  return x6;
}
function A(e9, n12) {
  const t4 = q3.create(e9.index, e9.x, e9.y), x6 = q3.create(n12.index, n12.x, n12.y), r12 = e9.next, i12 = n12.prev;
  return e9.next = n12, n12.prev = e9, t4.next = r12, r12.prev = t4, x6.next = t4, t4.prev = x6, i12.next = x6, x6.prev = i12, x6;
}
var q3 = class _q {
  constructor() {
    this.index = 0, this.x = 0, this.y = 0, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
  }
  static create(e9, n12, t4) {
    const x6 = D2 < B2.length ? B2[D2++] : new _q();
    return x6.index = e9, x6.x = n12, x6.y = t4, x6.prev = null, x6.next = null, x6.z = null, x6.prevZ = null, x6.nextZ = null, x6.steiner = false, x6;
  }
};
var B2 = [];
var C2 = 8096;
var D2 = 0;
for (let E3 = 0; E3 < C2; E3++) B2.push(new q3());

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/templateUtils.js
var s12 = 1e-5;
var l10 = new h(0, 0, 0, 1, 0);
var i8 = new h(0, 0, 0, 1, 0);
function f5(t4, e9, n12) {
  let o16 = 0;
  for (let r12 = 1; r12 < n12; r12++) {
    const n13 = t4[2 * (e9 + r12 - 1)], s19 = t4[2 * (e9 + r12 - 1) + 1];
    o16 += (t4[2 * (e9 + r12)] - n13) * (t4[2 * (e9 + r12) + 1] + s19);
  }
  return o16;
}
function u6(t4, e9, n12, o16, r12) {
  let s19 = 0;
  const l15 = 2;
  for (let i12 = n12; i12 < o16; i12 += 3) {
    const n13 = (t4[i12] - r12) * l15, o17 = (t4[i12 + 1] - r12) * l15, f9 = (t4[i12 + 2] - r12) * l15;
    s19 += Math.abs((e9[n13] - e9[f9]) * (e9[o17 + 1] - e9[n13 + 1]) - (e9[n13] - e9[o17]) * (e9[f9 + 1] - e9[n13 + 1]));
  }
  return s19;
}
function h4(t4, e9) {
  const { coords: n12, lengths: o16 } = e9, l15 = 0, i12 = t4;
  let h9 = 0;
  for (let c9 = 0; c9 < o16.length; ) {
    let t5 = c9, e10 = o16[c9], a14 = f5(n12, h9, e10);
    const g6 = [];
    for (; ++t5 < o16.length; ) {
      const r12 = o16[t5], s19 = f5(n12, h9 + e10, r12);
      if (!(s19 > 0)) break;
      a14 += s19, g6.push(h9 + e10), e10 += r12;
    }
    const p8 = i12.length;
    e7(i12, n12, h9, h9 + e10, g6, 2, l15);
    const m7 = u6(i12, n12, p8, i12.length, l15), x6 = Math.abs(a14);
    if (Math.abs((m7 - x6) / Math.max(1e-7, x6)) > s12) return i12.length = 0, false;
    c9 = t5, h9 += e10;
  }
  return true;
}
function c6(e9) {
  const { coords: n12, lengths: o16 } = e9, { buffer: r12 } = a4(n12, o16);
  return r12;
}
function a10(t4, e9, n12) {
  let o16 = 0;
  for (let r12 = 0; r12 < t4.lengths.length; r12++) {
    const s19 = t4.lengths[r12];
    for (let r13 = 0; r13 < s19; r13++) {
      const s20 = t4.coords[2 * (r13 + o16)], l15 = t4.coords[2 * (r13 + o16) + 1];
      if (s20 < e9 || s20 > n12 || l15 < e9 || l15 > n12) return true;
    }
    o16 += s19;
  }
  return false;
}
function g4(t4, e9) {
  if (null == t4) return null;
  if (!a10(t4, -128, o + 128)) return t4;
  l10.setPixelMargin(e9), l10.reset(3);
  let r12 = 0;
  for (let n12 = 0; n12 < t4.lengths.length; n12++) {
    const e10 = t4.lengths[n12];
    let o16 = t4.coords[2 * (0 + r12)], s20 = t4.coords[2 * (0 + r12) + 1];
    l10.moveTo(o16, s20);
    for (let n13 = 1; n13 < e10; n13++) o16 = t4.coords[2 * (n13 + r12)], s20 = t4.coords[2 * (n13 + r12) + 1], l10.lineTo(o16, s20);
    l10.close(), r12 += e10;
  }
  const s19 = l10.result(false);
  if (!s19) return null;
  const i12 = [], f9 = [];
  for (const n12 of s19) {
    let t5 = 0;
    for (const e10 of n12) f9.push(e10.x), f9.push(e10.y), t5++;
    i12.push(t5);
  }
  return new e(i12, f9);
}
function p4(t4, e9) {
  i8.setPixelMargin(e9);
  const n12 = i8, r12 = -e9, s19 = o + e9;
  let l15 = [], f9 = false;
  if (!t4.nextPath()) return null;
  let u10 = t4.pathLength(), h9 = true;
  for (; h9; ) {
    t4.seekPathStart();
    const e10 = [];
    if (!t4.pathSize) return null;
    n12.reset(2), t4.nextPoint();
    let o16 = t4.x, i12 = t4.y;
    if (f9) n12.moveTo(o16, i12);
    else {
      if (o16 < r12 || o16 > s19 || i12 < r12 || i12 > s19) {
        f9 = true;
        continue;
      }
      e10.push({ x: o16, y: i12 });
    }
    let c9 = false;
    for (; t4.nextPoint(); ) if (o16 = t4.x, i12 = t4.y, f9) n12.lineTo(o16, i12);
    else {
      if (o16 < r12 || o16 > s19 || i12 < r12 || i12 > s19) {
        c9 = true;
        break;
      }
      e10.push({ x: o16, y: i12 });
    }
    if (c9) f9 = true;
    else {
      if (f9) {
        const t5 = n12.resultWithStarts();
        if (t5) for (const e11 of t5) l15.push({ ...e11, pathLength: u10 });
      } else l15.push({ line: e10, start: 0, pathLength: u10 });
      h9 = t4.nextPath(), u10 = h9 ? t4.pathLength() : 0, f9 = false;
    }
  }
  return l15 = l15.filter((t5) => t5.line.length > 1), 0 === l15.length ? null : l15;
}
l10.setExtent(o), i8.setExtent(o);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/line/LineMeshWriter.js
var d3 = class {
  constructor() {
    this.extrusionOffsetX = 0, this.extrusionOffsetY = 0, this.normalX = 0, this.normalY = 0, this.directionX = 0, this.directionY = 0, this.distance = 0, this.pathLength = 0, this.distanceOffset = 0, this.lineLength = 0;
  }
};
var f6 = { createComputedParams: (t4) => t4, optionalAttributes: { zoomRange: { type: R.SHORT, count: 2, packPrecisionFactor: st, pack: ({ scaleInfo: t4 }, { tileInfo: e9 }) => s8(t4, e9) } }, attributes: { id: { type: R.UNSIGNED_BYTE, count: 3, pack: "id" }, pos: { type: R.SHORT, count: 2, pack: "position", packPrecisionFactor: 10 }, bitset: { type: R.UNSIGNED_BYTE, count: 1 }, color: { type: R.UNSIGNED_BYTE, count: 4, normalized: true, pack: ({ color: t4 }) => a6(t4) }, offset: { type: R.BYTE, count: 2, packPrecisionFactor: 16, packTessellation: ({ extrusionOffsetX: t4, extrusionOffsetY: e9 }) => [g2(t4, 16), g2(e9, 16)] }, normal: { type: R.BYTE, count: 2, packPrecisionFactor: 16, packTessellation: ({ normalX: t4, normalY: e9 }) => [g2(t4, 16), g2(e9, 16)] }, halfWidth: { type: R.HALF_FLOAT, count: 1, pack: ({ width: e9 }) => u(0.5 * e9) }, referenceHalfWidth: { type: R.HALF_FLOAT, count: 1, pack: ({ referenceWidth: e9 }) => u(0.5 * e9) } } };
var _2 = class {
  constructor() {
    this.id = 0, this.bitset = 0, this.indexCount = 0, this.vertexCount = 0, this.vertexFrom = 0, this.vertexBounds = 0, this.pathLength = 0, this.distanceOffset = 0;
  }
};
var x3 = 65535;
var T3 = class extends a7 {
  constructor(t4, e9, s19, i12) {
    super(t4, e9, s19, i12), this.vertexSpec = f6, this._currentWrite = new _2(), this._tessellationOptions = { halfWidth: 0, pixelCoordRatio: 1, offset: 0, wrapDistance: x3, textured: false }, this._tessParams = new d3(), this._initializeTessellator();
  }
  writeLineVertices(t4, e9, s19) {
    const i12 = this._getLines(e9);
    null != i12 && this._writeVertices(t4, s19, i12);
  }
  _initializeTessellator() {
    this._lineTessellator = new _(this._writeTesselatedVertex.bind(this), this._writeTriangle.bind(this), true);
  }
  _write(t4, s19, i12) {
    const r12 = i12 ?? a.fromFeatureSetReaderCIM(s19);
    r12 && this._writeGeometry(t4, s19, r12);
  }
  _writeGeometry(t4, e9, s19, i12) {
    t4.recordStart(this.instanceId, this.attributeLayout, i12), this.writeLineVertices(t4, s19, e9), t4.recordEnd();
  }
  _getLines(t4) {
    return p4(t4, a3(this.evaluatedMeshParams));
  }
  _writeVertices(e9, s19, r12) {
    const { _currentWrite: o16, _tessellationOptions: n12, evaluatedMeshParams: a14 } = this, { width: c9, capType: m7, joinType: u10, miterLimit: p8, hasSizeVV: d5 } = a14, f9 = u(0.5 * c9);
    n12.halfWidth = f9, n12.capType = f2(m7), n12.joinType = m(u10), n12.miterLimit = p8;
    const _4 = !d5;
    o16.out = e9, o16.id = s19.getDisplayId(), o16.vertexCount = 0, o16.indexCount = 0, o16.vertexFrom = e9.vertexCount(), o16.vertexBounds = _4 && f9 < T ? 0 : 1;
    for (const { line: t4, start: i12, pathLength: h9 } of r12) n12.initialDistance = i12 % x3, o16.pathLength = h9, o16.distanceOffset = Math.floor(i12 / x3) * x3, this._lineTessellator.tessellate(t4, n12, _4);
  }
  _writeTesselatedVertex(t4, e9, s19, i12, r12, o16, n12, a14, c9, h9, l15) {
    const { out: m7, id: u10, vertexBounds: p8, pathLength: d5, distanceOffset: f9 } = this._currentWrite;
    return this.hasEffects && m7.recordBounds(t4, e9, p8, p8), this._tessParams.extrusionOffsetX = n12, this._tessParams.extrusionOffsetY = a14, this._tessParams.normalX = c9, this._tessParams.normalY = h9, this._tessParams.directionX = r12, this._tessParams.directionY = o16, this._tessParams.distance = l15, this._tessParams.pathLength = d5, this._tessParams.distanceOffset = f9, this._writeVertex(m7, u10, t4, e9, this._tessParams), this._currentWrite.vertexFrom + this._currentWrite.vertexCount++;
  }
  _writeTriangle(t4, e9, s19) {
    const { out: i12 } = this._currentWrite;
    i12.indexEnsureSize(3), i12.indexWrite(t4), i12.indexWrite(e9), i12.indexWrite(s19), this._currentWrite.indexCount += 3;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/AFillMeshWriter.js
var o10 = 100;
var n8 = has("featurelayer-fast-triangulation-enabled");
var a11 = class extends a7 {
  async loadDependencies() {
    await Promise.all([super.loadDependencies(), i3()]);
  }
  _write(e9, t4, r12) {
    const s19 = r12?.asOptimized() ?? t4.readGeometryForDisplay(), i12 = this._clip(s19);
    i12 && (e9.recordStart(this.instanceId, this.attributeLayout), this._writeGeometry(e9, t4, i12), e9.recordEnd());
  }
  _clip(e9) {
    if (!e9) return null;
    const r12 = this.hasEffects;
    return g4(e9, r12 ? 256 : 8);
  }
  _writeGeometry(e9, t4, i12) {
    const a14 = i12.maxLength > o10, c9 = [], l15 = this.createTesselationParams(t4);
    if (!a14 && n8 && h4(c9, i12)) return void (c9.length && this._writeVertices(e9, t4, i12.coords, l15, c9));
    const d5 = c6(i12);
    this._writeVertices(e9, t4, d5, l15);
  }
  _writeVertices(e9, t4, r12, s19, i12) {
    const o16 = t4.getDisplayId(), n12 = e9.vertexCount(), a14 = this.hasEffects;
    let c9 = 0;
    if (i12) for (const l15 of i12) {
      const t5 = r12[2 * l15], i13 = r12[2 * l15 + 1];
      a14 && e9.recordBounds(t5, i13, 0, 0), this._writeVertex(e9, o16, t5, i13, s19), c9++;
    }
    else for (let l15 = 0; l15 < r12.length; l15 += 2) {
      const t5 = Math.round(r12[l15]), i13 = Math.round(r12[l15 + 1]);
      a14 && e9.recordBounds(t5, i13, 0, 0), this._writeVertex(e9, o16, t5, i13, s19), c9++;
    }
    e9.indexEnsureSize(c9);
    for (let l15 = 0; l15 < c9; l15++) e9.indexWrite(l15 + n12);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/dotDensity/DotDensityMeshWriter.js
var r10 = { createComputedParams: (e9) => e9, optionalAttributes: {}, attributes: { id: { type: R.UNSIGNED_BYTE, count: 3, pack: "id" }, bitset: { type: R.UNSIGNED_BYTE, count: 1 }, pos: { type: R.SHORT, count: 2, pack: "position", packPrecisionFactor: 10 }, inverseArea: { type: R.FLOAT, count: 1, packTessellation: ({ inverseArea: e9 }) => e9 } } };
var s13 = class extends a11 {
  constructor() {
    super(...arguments), this.vertexSpec = r10;
  }
  createTesselationParams(e9) {
    return { inverseArea: 1 / e9.readGeometryArea() };
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/FillMeshWriter.js
var i9 = { createComputedParams: (t4) => t4, optionalAttributes: { zoomRange: { type: R.SHORT, count: 2, packPrecisionFactor: st, pack: ({ scaleInfo: t4 }, { tileInfo: o16 }) => s8(t4, o16) } }, attributes: { id: { type: R.UNSIGNED_BYTE, count: 3, pack: "id" }, bitset: { type: R.UNSIGNED_BYTE, count: 1 }, pos: { type: R.SHORT, count: 2, pack: "position", packPrecisionFactor: 10 }, color: { type: R.UNSIGNED_BYTE, count: 4, normalized: true, pack: ({ color: t4 }) => a6(t4) } } };
var c7 = class extends a11 {
  constructor() {
    super(...arguments), this.vertexSpec = i9;
  }
  createTesselationParams(t4) {
    return null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/PatternFillMeshWriter.js
var s14 = { createComputedParams: (t4) => t4, optionalAttributes: i9.optionalAttributes, attributes: { ...i9.attributes, tlbr: { count: 4, type: R.UNSIGNED_SHORT, pack: ({ sprite: e9 }) => {
  const { rect: r12, width: i12, height: s19 } = e9, o16 = r12.x + tt, a14 = r12.y + tt;
  return [o16, a14, o16 + i12, a14 + s19];
} }, inverseRasterizationScale: { count: 1, type: R.BYTE, packPrecisionFactor: 16, pack: ({ sprite: t4 }) => 1 / t4.rasterizationScale } } };
var o11 = class extends c7 {
  constructor() {
    super(...arguments), this.vertexSpec = s14;
  }
  _write(t4, e9, r12) {
    const i12 = r12?.asOptimized() ?? e9.readGeometryForDisplay(), s19 = this._clip(i12);
    if (!s19) return;
    const o16 = this.evaluatedMeshParams.sprite?.textureBinding;
    t4.recordStart(this.instanceId, this.attributeLayout, o16), this._writeGeometry(t4, e9, s19), t4.recordEnd();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/ComplexFillMeshWriter.js
function p5(e9) {
  const { sprite: o16, aspectRatio: s19, scaleProportionally: r12 } = e9, i12 = u(e9.height), c9 = i12 > 0 ? i12 : o16.height;
  let a14 = i12 * s19;
  return a14 <= 0 ? a14 = o16.width : r12 && (a14 *= o16.width / o16.height), { width: a14, height: c9 };
}
function n9(t4) {
  const { applyRandomOffset: e9, sampleAlphaOnly: s19 } = t4;
  return u3([[C, e9], [w, s19]]);
}
var l11 = { createComputedParams: (t4) => t4, optionalAttributes: s14.optionalAttributes, attributes: { ...s14.attributes, bitset: { count: 1, type: R.UNSIGNED_BYTE, pack: n9 }, width: { count: 1, type: R.HALF_FLOAT, pack: (t4) => p5(t4).width }, height: { count: 1, type: R.HALF_FLOAT, pack: (t4) => p5(t4).height }, offset: { count: 2, type: R.HALF_FLOAT, pack: ({ offsetX: e9, offsetY: o16 }) => [u(e9), -u(o16)] }, scale: { count: 2, type: R.UNSIGNED_BYTE, packPrecisionFactor: 16, pack: ({ scaleX: t4, scaleY: e9 }) => [t4, e9] }, angle: { count: 1, type: R.UNSIGNED_BYTE, pack: ({ angle: t4 }) => l4(t4) } } };
var h5 = class extends o11 {
  constructor() {
    super(...arguments), this.vertexSpec = l11;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/OutlineFillMeshWriter.js
var h6 = { createComputedParams: (e9) => e9, optionalAttributes: f6.optionalAttributes, attributes: { ...f6.attributes, bitset: { type: R.UNSIGNED_BYTE, count: 1, pack: (e9) => 0 }, color: { type: R.UNSIGNED_BYTE, count: 4, normalized: true, pack: ({ color: e9 }) => a6(e9) } } };
var m4 = { createComputedParams: (e9) => e9, optionalAttributes: f6.optionalAttributes, attributes: { ...f6.attributes, bitset: { type: R.UNSIGNED_BYTE, count: 1, pack: (e9) => u3([[B, true], [L, e9.outlineUsesColorVV]]) }, color: { type: R.UNSIGNED_BYTE, count: 4, normalized: true, pack: ({ outlineColor: e9 }) => a6(e9) } } };
var p6 = class extends T3 {
  constructor() {
    super(...arguments), this.vertexSpec = m4;
  }
};
var f7 = class extends c7 {
  constructor(e9, t4, i12, r12) {
    super(e9, t4, i12, r12), this.vertexSpec = h6, this._lineMeshWriter = this._createOutlineWriter(e9, t4, i12, r12);
  }
  _createOutlineWriter(e9, t4, i12, r12) {
    return new p6(e9, t4, i12, r12);
  }
  _write(e9, t4) {
    const i12 = this.evaluatedMeshParams.effects, r12 = this.evaluatedMeshParams.outlineEffects;
    if (i12?.length || r12?.length) {
      if (i12?.length) {
        const r13 = this.getEffectCursor(e9, t4, i12);
        if (r13) {
          let i13;
          for (; i13 = r13?.next(); ) i13.invertY(), this._writeFill(e9, t4, i13);
        }
      } else this._writeFill(e9, t4);
      if (r12?.length) {
        const i13 = this.getEffectCursor(e9, t4, r12);
        if (i13) {
          let r13;
          for (; r13 = i13?.next(); ) r13.invertY(), this._writeOutline(e9, t4, r13);
        }
      } else this._writeOutline(e9, t4);
    } else this._writeSimpleOutlineFill(e9, t4);
  }
  _writeSimpleOutlineFill(t4, i12) {
    const r12 = i12.readGeometryForDisplay(), s19 = this._clip(r12);
    s19 && (this._writeGeometry(t4, i12, s19), this._lineMeshWriter.writeLineVertices(t4, a.fromOptimizedCIM(s19, "esriGeometryPolyline"), i12));
  }
  _writeFill(e9, t4, i12) {
    const r12 = i12?.asOptimized() ?? t4.readGeometryForDisplay(), s19 = this._clip(r12);
    s19 && this._writeGeometry(e9, t4, s19);
  }
  _writeOutline(t4, i12, r12) {
    const s19 = r12?.asOptimized() ?? i12.readGeometryForDisplay(), o16 = this._clip(s19);
    o16 && this._lineMeshWriter.writeLineVertices(t4, a.fromOptimizedCIM(o16, "esriGeometryPolyline"), i12);
  }
  _clip(e9) {
    return e9 ? g4(e9, a3(this.evaluatedMeshParams)) : null;
  }
  get effectInfos() {
    return [...this._evaluator.inputMeshParams.effects?.effectInfos ?? [], ...this._evaluator.inputMeshParams.outlineEffects?.effectInfos ?? []];
  }
  write(e9, t4, i12, r12, s19) {
    this.ensurePacked(t4, i12, r12), e9.recordStart(this.instanceId, this.attributeLayout), this._write(e9, i12), e9.recordEnd();
  }
  ensurePacked(e9, t4, i12) {
    super.ensurePacked(e9, t4, i12), this._lineMeshWriter.ensurePacked(e9, t4, i12);
  }
  enqueueRequest(e9, t4, i12) {
    super.enqueueRequest(e9, t4, i12), this._lineMeshWriter.enqueueRequest(e9, t4, i12);
  }
  async loadDependencies() {
    await Promise.all([super.loadDependencies(), this._lineMeshWriter.loadDependencies()]);
  }
  get hasEffects() {
    return !!this.evaluatedMeshParams.outlineEffects;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/ComplexOutlineFillMeshWriter.js
var d4 = l11;
var h7 = m4;
var m5 = { createComputedParams: (e9) => e9, optionalAttributes: d4.optionalAttributes, attributes: { ...d4.attributes, bitset: { type: R.UNSIGNED_BYTE, count: 1, pack: (e9) => n9(e9) }, aux1: { count: 1, type: R.HALF_FLOAT, pack: (e9) => p5(e9).width }, aux2: { count: 1, type: R.HALF_FLOAT, pack: (e9) => p5(e9).height }, aux3: { count: 2, type: R.HALF_FLOAT, pack: ({ offsetX: t4, offsetY: s19 }) => [u(t4), u(s19)] }, aux4: { count: 2, type: R.UNSIGNED_BYTE, pack: ({ scaleX: e9, scaleY: t4 }) => [e9 * J, t4 * J] } } };
var x4 = { createComputedParams: (e9) => e9, optionalAttributes: d4.optionalAttributes, attributes: { ...d4.attributes, color: h7.attributes.color, bitset: { type: R.UNSIGNED_BYTE, count: 1, pack: (e9) => u3([[B, true]]) }, aux1: { count: 1, type: R.HALF_FLOAT, pack: (t4) => u(0.5 * t4.width) }, aux2: { count: 1, type: R.HALF_FLOAT, pack: (t4) => u(0.5 * t4.referenceWidth) }, aux3: { count: 2, type: R.HALF_FLOAT, packTessellation: ({ extrusionOffsetX: e9, extrusionOffsetY: t4 }) => [e9, t4] }, aux4: { count: 2, type: R.UNSIGNED_BYTE, packTessellation: ({ normalX: e9, normalY: t4 }) => [e9 * J + K, t4 * J + K] } } };
var A2 = class extends p6 {
  constructor() {
    super(...arguments), this.vertexSpec = x4;
  }
};
var f8 = class extends f7 {
  constructor() {
    super(...arguments), this.vertexSpec = m5;
  }
  _createOutlineWriter(e9, t4, s19, r12) {
    return new A2(e9, t4, s19, r12);
  }
  write(e9, t4, s19, r12, i12) {
    this.ensurePacked(t4, s19, r12);
    const a14 = this.evaluatedMeshParams.sprite?.textureBinding;
    e9.recordStart(this.instanceId, this.attributeLayout, a14), this._write(e9, s19), e9.recordEnd();
  }
  ensurePacked(e9, t4, s19) {
    super.ensurePacked(e9, t4, s19), this._lineMeshWriter.ensurePacked(e9, t4, s19);
  }
  enqueueRequest(e9, t4, s19) {
    super.enqueueRequest(e9, t4, s19), this._lineMeshWriter.enqueueRequest(e9, t4, s19);
  }
  async loadDependencies() {
    await Promise.all([super.loadDependencies(), this._lineMeshWriter.loadDependencies()]);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/GradientSizeHelper.js
var a12 = () => i.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.fill.GradientSizeHelper");
var n10 = class {
  constructor(t4, i12) {
    this._size = t4, this._sizeUnits = i12, this._relativeSize = null;
  }
  get relativeSize() {
    return this._relativeSize ??= this.calculateRelativeSize(), this._relativeSize;
  }
  calculateRelativeSize() {
    if (this._sizeUnits === e2.Relative) {
      const t4 = Math.min(this._size / 100, 1);
      return [t4, t4];
    }
    return this.calculateRelativeSizeFromAbsolute();
  }
};
var s15 = class extends n10 {
  constructor(t4, i12, e9, r12) {
    super(i12, e9), this.rotationMatrix00 = 1, this.rotationMatrix01 = 0, this.rotationMatrix10 = 0, this.rotationMatrix11 = 1, this.bounds = { xmin: 1 / 0, ymin: 1 / 0, xmax: -1 / 0, ymax: -1 / 0 }, this.rotationMatrix00 = Math.cos(r12), this.rotationMatrix01 = -Math.sin(r12), this.rotationMatrix10 = -this.rotationMatrix01, this.rotationMatrix11 = this.rotationMatrix00;
    const { bounds: a14, rotationMatrix00: n12, rotationMatrix01: s19, rotationMatrix10: o16, rotationMatrix11: c9 } = this;
    t4.forEachVertex((t5, i13) => {
      const e10 = t5 * n12 + i13 * s19, r13 = t5 * o16 + i13 * c9;
      a14.xmin = Math.min(a14.xmin, e10), a14.ymin = Math.min(a14.ymin, r13), a14.xmax = Math.max(a14.xmax, e10), a14.ymax = Math.max(a14.ymax, r13);
    }), this.center = [(a14.xmin + a14.xmax) / 2, (a14.ymin + a14.ymax) / 2];
  }
};
var o12 = class extends s15 {
  constructor(t4, i12, e9, r12) {
    super(t4, i12, e9, r12), this.method = "linear";
  }
  getRelativePosition(t4, i12) {
    const { rotationMatrix00: e9, rotationMatrix01: r12, bounds: a14 } = this, { xmin: n12, xmax: s19 } = a14;
    return [(t4 * e9 + i12 * r12 - n12) / (s19 - n12), 0];
  }
  calculateRelativeSizeFromAbsolute() {
    const { _size: t4, bounds: i12 } = this, { xmin: r12, xmax: a14 } = i12;
    return [u(t4) / (a14 - r12), 0];
  }
};
var c8 = class extends s15 {
  constructor(t4, i12, e9, r12) {
    super(t4, i12, e9, r12), this.method = "rectangular";
  }
  getRelativePosition(t4, i12) {
    const { bounds: e9, center: r12, rotationMatrix00: a14, rotationMatrix01: n12, rotationMatrix10: s19, rotationMatrix11: o16 } = this, c9 = t4 * s19 + i12 * o16, x6 = t4 * a14 + i12 * n12 - r12[0], l15 = c9 - r12[1];
    return [x6 * (2 / (e9.xmax - e9.xmin)), -l15 * (2 / (e9.ymax - e9.ymin))];
  }
  calculateRelativeSizeFromAbsolute() {
    const { _size: t4, bounds: i12 } = this, { xmin: r12, ymin: a14, xmax: n12, ymax: s19 } = i12;
    return [u(2 * t4) / (n12 - r12), u(2 * t4) / (s19 - a14)];
  }
};
var x5 = class extends s15 {
  constructor(t4, i12, e9) {
    super(t4, i12, e9, 0), this.method = "circular";
    const { xmin: r12, xmax: a14, ymin: n12, ymax: s19 } = this.bounds, o16 = a14 - r12, c9 = s19 - n12;
    this.radius = Math.sqrt(o16 * o16 + c9 * c9) / 2;
  }
  getRelativePosition(t4, i12) {
    const { center: e9, radius: r12 } = this;
    return [(t4 - e9[0]) / r12, -((i12 - e9[1]) / r12)];
  }
  calculateRelativeSizeFromAbsolute() {
    const { _size: t4 } = this;
    return [u(t4) / this.radius, 0];
  }
};
function l12(t4, e9) {
  if (null == t4) return null;
  const r12 = s2(e9.angle), n12 = e9.gradientSize, s19 = e9.gradientSizeUnits;
  switch (e9.gradientMethod.toLowerCase()) {
    case "linear":
      return new o12(t4, n12, s19, r12);
    case "rectangular":
      return new c8(t4, n12, s19, r12);
    case "circular":
      return new x5(t4, n12, s19);
    default:
      return a12().errorOnce(`Gradient fill method "${e9.gradientMethod}" currently unsupported.`), null;
  }
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/GradientFillMeshWriter.js
var p7 = { createComputedParams: (t4) => t4, optionalAttributes: i9.optionalAttributes, attributes: { ...i9.attributes, bitset: { type: R.UNSIGNED_BYTE, count: 1, pack: ({ gradientSizeUnits: e9, gradientType: r12 }) => {
  let i12 = 0;
  return e9 === e2.Absolute && (i12 |= i5(e3.isAbsolute)), "discrete" === r12.toLowerCase() && (i12 |= i5(e3.isDiscrete)), i12;
} }, tlbr: { count: 4, type: R.UNSIGNED_SHORT, pack: ({ sprite: t4 }) => {
  const { rect: i12, width: s19, height: a14 } = t4, o16 = i12.x + tt + at, n12 = i12.y + tt;
  return [o16, n12, o16 + s19 - 2 * at, n12 + a14];
} }, relativePosition: { count: 2, type: R.HALF_FLOAT, packTessellation: ({ gradientStats: t4 }, e9, r12, i12) => t4?.getRelativePosition(r12, i12) ?? [0, 0] }, relativeGradientSize: { count: 2, type: R.HALF_FLOAT, packTessellation: ({ gradientStats: t4 }) => t4?.relativeSize ?? [1, 1] }, gradientMethod: { count: 1, type: R.UNSIGNED_BYTE, pack: ({ gradientMethod: t4 }) => {
  switch (t4.toLowerCase()) {
    case "rectangular":
      return r3.rectangular;
    case "circular":
      return r3.circular;
    default:
      return r3.linear;
  }
} } } };
var u7 = class extends a11 {
  constructor() {
    super(...arguments), this.vertexSpec = p7;
  }
  get _preventEffectClipping() {
    return true;
  }
  createTesselationParams(t4) {
    return { gradientStats: l12(this._unclippedGeometry, this.evaluatedMeshParams) };
  }
  _write(t4, e9, r12) {
    const i12 = r12?.asOptimized() ?? e9.readGeometryForDisplay();
    this._unclippedGeometry = i12;
    const s19 = this._clip(i12);
    if (!s19) return void (this._unclippedGeometry = null);
    const a14 = this.evaluatedMeshParams.sprite?.textureBinding;
    t4.recordStart(this.instanceId, this.attributeLayout, a14), this._writeGeometry(t4, e9, s19), this._unclippedGeometry = null, t4.recordEnd();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/PatternOutlineFillMeshWriter.js
var a13 = { optionalAttributes: s14.optionalAttributes, createComputedParams: (e9) => e9, attributes: { ...s14.attributes, ...h6.attributes } };
var u8 = { optionalAttributes: s14.optionalAttributes, createComputedParams: (e9) => e9, attributes: { ...s14.attributes, ...m4.attributes } };
var n11 = class extends p6 {
  constructor() {
    super(...arguments), this.vertexSpec = u8;
  }
};
var o13 = class extends f7 {
  constructor() {
    super(...arguments), this.vertexSpec = a13;
  }
  _createOutlineWriter(e9, t4, r12, s19) {
    return new n11(e9, t4, r12, s19);
  }
  write(e9, t4, r12, s19, i12) {
    this.ensurePacked(t4, r12, s19);
    const a14 = this.evaluatedMeshParams.sprite?.textureBinding;
    e9.recordStart(this.instanceId, this.attributeLayout, a14), this._write(e9, r12), e9.recordEnd();
  }
  ensurePacked(e9, t4, r12) {
    super.ensurePacked(e9, t4, r12), this._lineMeshWriter.ensurePacked(e9, t4, r12);
  }
  enqueueRequest(e9, t4, r12) {
    super.enqueueRequest(e9, t4, r12), this._lineMeshWriter.enqueueRequest(e9, t4, r12);
  }
  async loadDependencies() {
    await Promise.all([super.loadDependencies(), this._lineMeshWriter.loadDependencies()]);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/heatmap/HeatmapMeshWriter.js
var r11 = { createComputedParams: (t4) => t4, optionalAttributes: {}, attributes: { pos: { type: R.SHORT, count: 2, pack: "position", packPrecisionFactor: 10 }, id: { type: R.UNSIGNED_BYTE, count: 3, pack: "id" }, bitset: { type: R.UNSIGNED_BYTE, count: 1 }, offset: { type: R.BYTE, count: 2, packAlternating: { count: 4, pack: () => [[-1, -1], [1, -1], [-1, 1], [1, 1]] } } } };
var i10 = class extends a7 {
  constructor() {
    super(...arguments), this.vertexSpec = r11;
  }
  _write(t4, e9) {
    t4.recordStart(this.instanceId, this.attributeLayout);
    const r12 = e9.getDisplayId();
    if ("esriGeometryPoint" === e9.geometryType) {
      const i12 = e9.readXForDisplay(), o16 = e9.readYForDisplay();
      this._writeQuad(t4, r12, i12, o16);
    } else if ("esriGeometryMultipoint" === e9.geometryType) {
      const i12 = e9.readGeometryForDisplay();
      i12?.forEachVertex((e10, i13) => {
        e10 >= 0 && e10 <= 512 && i13 >= 0 && i13 <= 512 && this._writeQuad(t4, r12, e10, i13);
      });
    }
    t4.recordEnd();
  }
  _writeQuad(t4, e9, r12, i12) {
    const o16 = t4.vertexCount();
    this._writeVertex(t4, e9, r12, i12), t4.indexWrite(o16 + 0), t4.indexWrite(o16 + 1), t4.indexWrite(o16 + 2), t4.indexWrite(o16 + 1), t4.indexWrite(o16 + 3), t4.indexWrite(o16 + 2);
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/CIMMarkerPlacementHelper.js
var e8 = class {
  static getPlacement(e9, r12, n12, s19, c9) {
    const o16 = S2(n12);
    if (!o16) return null;
    -1 === r12 && e9.invertY();
    return o16.execute(e9, n12, s19, c9);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/text/TextParams.js
var s16 = 96;
var i11 = class {
  constructor(i12) {
    const { offsetX: o16, offsetY: e9, postAngle: f9, fontSize: h9, haloSize: n12, outlineSize: l15, scaleFactor: z4, transforms: a14 } = i12;
    if (this.offsetX = o16, this.offsetY = e9, this.postAngle = f9, this.fontSize = Math.min(h9, s16), this.haloSize = n12 ?? 0, this.outlineSize = l15 ?? 0, this.transforms = a14, a14 && a14.infos.length > 1) {
      const i13 = q2(h9, f9, false, o16, e9, a14, false);
      this.fontSize = Math.min(i13.size, s16);
      const n13 = i13.size / h9;
      this.haloSize *= n13, this.outlineSize *= n13, this.postAngle = i13.rotation, this.offsetX = i13.offsetX, this.offsetY = i13.offsetY;
    }
    z4 && (this.fontSize *= z4, this.offsetX *= z4, this.offsetY *= z4);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/text/TextMeshWriter.js
var _3 = 28;
var P = [4, 4];
var b2 = [16, 4];
var T4 = { topLeft: b2, topRight: b2, bottomLeft: b2, bottomRight: b2 };
var k3 = [4, 2];
var z3 = [4, 6];
var B3 = { topLeft: k3, topRight: k3, bottomLeft: z3, bottomRight: z3 };
var R3 = { topLeft: k3, topRight: z3, bottomLeft: k3, bottomRight: z3 };
var M2 = { topLeft: z3, topRight: z3, bottomLeft: P, bottomRight: P };
var L2 = { topLeft: P, topRight: P, bottomLeft: z3, bottomRight: z3 };
var w3 = { topLeft: z3, topRight: P, bottomLeft: z3, bottomRight: P };
var I = { topLeft: P, topRight: z3, bottomLeft: P, bottomRight: z3 };
var A3 = { createComputedParams: (t4) => t4, optionalAttributes: { zoomRange: { type: R.UNSIGNED_SHORT, count: 2, packPrecisionFactor: st, packTessellation: ({ minZoom: t4, maxZoom: e9 }) => [t4 || 0, e9 || _3] }, clipAngle: { type: R.UNSIGNED_BYTE, count: 1, packTessellation: ({ clipAngle: t4 }) => G2(t4 || 0) }, referenceSymbol: { type: R.BYTE, count: 4, packPrecisionFactor: 1, packTessellation: (t4, o16) => {
  const i12 = t4.isLineLabel || !t4.referenceBounds, n12 = c(i12 ? "center" : o16.horizontalAlignment), a14 = s4(i12 ? "middle" : o16.verticalAlignment), { offsetX: c9, offsetY: l15, size: h9 } = i12 ? { offsetX: 0, offsetY: 0, size: 0 } : t4.referenceBounds;
  return [u(c9), -u(l15), Math.round(u(h9)), n12 + 1 << 2 | a14 + 1];
} }, visibility: { type: R.FLOAT, count: 1, otherSource: true } }, attributes: { pos: { type: R.SHORT, count: 2, pack: "position", packPrecisionFactor: 10 }, id: { type: R.UNSIGNED_BYTE, count: 3, pack: "id" }, bitset: { type: R.UNSIGNED_BYTE, count: 1, packTessellation: ({ isBackground: t4, mapAligned: e9 }) => u3([[F, t4], [G, !!e9]]) }, offset: { type: R.SHORT, count: 2, packPrecisionFactor: 8, packAlternating: { count: 4, packTessellation: ({ offsets: t4 }) => {
  const { bottomLeft: e9, bottomRight: o16, topLeft: i12, topRight: r12 } = t4;
  return [i12, r12, e9, o16];
} } }, textureUV: { type: R.SHORT, count: 2, packPrecisionFactor: 4, packAlternating: { count: 4, packTessellation: ({ texcoords: t4 }) => {
  const { bottomLeft: e9, bottomRight: o16, topLeft: i12, topRight: r12 } = t4;
  return [i12, r12, e9, o16];
} } }, color: { type: R.UNSIGNED_BYTE, count: 4, normalized: true, packTessellation: ({ color: t4 }) => t4 }, fontAndReferenceSize: { type: R.UNSIGNED_SHORT, count: 2, packPrecisionFactor: 4, packTessellation: ({ fontSize: t4 }, { referenceSize: o16 }) => [Math.round(u(t4)), Math.round(u(o16 ?? t4))] }, outlineColor: { type: R.UNSIGNED_BYTE, count: 4, normalized: true, pack: ({ outlineColor: t4 }) => a6(t4) }, haloColor: { type: R.UNSIGNED_BYTE, count: 4, normalized: true, pack: ({ haloColor: t4 }) => a6(t4) }, outlineAndHaloSize: { type: R.UNSIGNED_SHORT, count: 2, packPrecisionFactor: 4, packTessellation: ({ outlineSize: t4, haloSize: o16 }) => [Math.round(u(t4)), Math.round(u(o16))] } } };
var E2 = class extends a7 {
  constructor() {
    super(...arguments), this.vertexSpec = A3, this._textMeshParamsPropsInitialized = false;
  }
  ensurePacked(t4, e9, o16) {
    super.ensurePacked(t4, e9, o16), this._textMeshParamsPropsInitialized && !this._evaluator.hasDynamicProperties || (this._textMeshTransformProps = new i11(this.evaluatedMeshParams), this._textMeshParamsPropsInitialized = true);
  }
  _write(t4, e9, o16) {
    const i12 = this._getShaping();
    if (!i12) return;
    const r12 = e9.getDisplayId();
    if (null != this.evaluatedMeshParams.placement) return this._writePlacedTextMarkers(t4, e9, i12, o16);
    if (o16?.nextPath()) return o16.nextPoint(), this._writeGlyphs(t4, r12, o16.x, o16.y, i12, 0);
    if ("esriGeometryPolygon" === e9.geometryType) {
      const o17 = e9.readCentroidForDisplay();
      if (!o17) return;
      const [s20, n13] = o17.coords;
      return this._writeGlyphs(t4, r12, s20, n13, i12, 0);
    }
    if ("esriGeometryMultipoint" === e9.geometryType) {
      const o17 = e9.readGeometryForDisplay();
      return void o17?.forEachVertex((e10, o18) => this._writeGlyphs(t4, r12, e10, o18, i12, 0));
    }
    const s19 = e9.readXForDisplay(), n12 = e9.readYForDisplay();
    return this._writeGlyphs(t4, r12, s19, n12, i12, 0);
  }
  _writePlacedTextMarkers(t4, r12, s19, n12) {
    const a14 = n12 ?? a.fromFeatureSetReaderCIM(r12);
    if (!a14) return;
    const c9 = -1, l15 = e8.getPlacement(a14, c9, this.evaluatedMeshParams.placement, u(1), t4.id);
    if (!l15) return;
    const h9 = r12.getDisplayId();
    let f9 = l15.next();
    for (; null != f9; ) {
      const e9 = f9.tx, o16 = -f9.ty, i12 = -f9.getAngle();
      this._writeGlyphs(t4, h9, e9, o16, s19, i12), f9 = l15.next();
    }
  }
  _getShaping(o16) {
    const i12 = this._textMeshTransformProps, r12 = this.evaluatedMeshParams;
    if (!r12.glyphs?.glyphs.length) return null;
    const s19 = u(i12.fontSize), n12 = u(i12.offsetX), p8 = u(i12.offsetY), m7 = r(u(r12.lineWidth), It, Jt), d5 = l2 * r(r12.lineHeightRatio, 0.25, 4);
    return z(r12.glyphs, { scale: s19 / q, angle: i12.postAngle, xOffset: n12, yOffset: p8, horizontalAlignment: r12.horizontalAlignment, verticalAlignment: o16 || r12.verticalAlignment, maxLineWidth: m7, lineHeight: d5, decoration: r12.decoration, borderLineSizePx: u(r12.boxBorderLineSize), hasBackground: !!r12.boxBackgroundColor, useCIMAngleBehavior: r12.useCIMAngleBehavior });
  }
  _writeGlyphs(t4, o16, i12, r12, s19, n12, a14, c9, l15 = true) {
    const h9 = this.evaluatedMeshParams, f9 = this._textMeshTransformProps, m7 = u(f9.fontSize), u10 = f9.haloSize, g6 = f9.outlineSize, x6 = u(f9.offsetX), y4 = u(f9.offsetY), [S5, _4] = s8(h9.scaleInfo, this.getTileInfo());
    0 !== n12 && s19.setRotation(n12);
    const P3 = s19.bounds, b4 = i12 + P3.x + x6, T5 = r12 + P3.y - y4, k5 = 2 * (h9.minPixelBuffer ? h9.minPixelBuffer / m7 : 1), z4 = Math.max(P3.width, P3.height) * k5;
    s19.textBox && (t4.recordStart(this.instanceId, this.attributeLayout, s19.glyphs[0].textureBinding), l15 && t4.recordBounds(b4, T5, z4, z4), this._writeTextBox(t4, o16, i12, r12, s19.textBox, a14, c9), t4.recordEnd());
    for (const e9 of s19.glyphs) {
      t4.recordStart(this.instanceId, this.attributeLayout, e9.textureBinding), l15 && t4.recordBounds(b4, T5, z4, z4);
      const { texcoords: s20, offsets: n13 } = e9;
      this._writeQuad(t4, o16, i12, r12, { texcoords: s20, offsets: n13, fontSize: m7, haloSize: u10, outlineSize: g6, color: a6(h9.color), isBackground: false, referenceBounds: a14, minZoom: S5, maxZoom: _4, ...c9 }), t4.recordEnd();
    }
    0 !== n12 && s19.setRotation(-n12);
  }
  _writeTextBox(t4, e9, o16, i12, r12, s19, n12) {
    const a14 = this.evaluatedMeshParams, { fontSize: c9, haloSize: l15, outlineSize: h9 } = this._textMeshTransformProps, { boxBackgroundColor: f9, boxBorderLineColor: m7 } = a14, d5 = { isBackground: true, fontSize: c9, haloSize: l15, outlineSize: h9, referenceBounds: s19, ...n12 };
    f9 && (this._writeQuad(t4, e9, o16, i12, { texcoords: T4, offsets: r12.main, color: a6(f9), ...d5 }), m7 || (this._writeQuad(t4, e9, o16, i12, { texcoords: M2, offsets: r12.top, color: a6(f9), ...d5 }), this._writeQuad(t4, e9, o16, i12, { texcoords: L2, offsets: r12.bot, color: a6(f9), ...d5 }), this._writeQuad(t4, e9, o16, i12, { texcoords: w3, offsets: r12.left, color: a6(f9), ...d5 }), this._writeQuad(t4, e9, o16, i12, { texcoords: I, offsets: r12.right, color: a6(f9), ...d5 }))), m7 && (this._writeQuad(t4, e9, o16, i12, { texcoords: B3, offsets: r12.top, color: a6(m7), ...d5 }), this._writeQuad(t4, e9, o16, i12, { texcoords: B3, offsets: r12.bot, color: a6(m7), ...d5 }), this._writeQuad(t4, e9, o16, i12, { texcoords: R3, offsets: r12.left, color: a6(m7), ...d5 }), this._writeQuad(t4, e9, o16, i12, { texcoords: R3, offsets: r12.right, color: a6(m7), ...d5 }));
  }
  _writeQuad(t4, e9, o16, i12, r12) {
    const s19 = t4.vertexCount();
    this._writeVertex(t4, e9, o16, i12, r12), t4.indexWrite(s19 + 0), t4.indexWrite(s19 + 1), t4.indexWrite(s19 + 2), t4.indexWrite(s19 + 1), t4.indexWrite(s19 + 3), t4.indexWrite(s19 + 2);
  }
};
var G2 = (t4) => Math.round(t4 * (254 / 360));

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/line/GradientStrokeMeshWriter.js
var m6 = { createComputedParams: (t4) => t4, optionalAttributes: f6.optionalAttributes, attributes: { ...f6.attributes, bitset: { type: R.UNSIGNED_BYTE, count: 1, pack: ({ gradientMethod: t4, gradientSizeUnits: e9, gradientType: r12 }) => u3([[e4.isAlongLine, "alongline" === t4.toLowerCase()], [e4.isAbsoluteSize, e9 === e2.Absolute], [e4.isDiscrete, "discrete" === r12.toLowerCase()]]) }, tlbr: { type: R.UNSIGNED_SHORT, count: 4, pack: ({ sprite: t4 }) => {
  const { rect: e9, width: i12, height: o16 } = t4, n12 = e9.x + tt + at, a14 = e9.y + tt;
  return [n12, a14, n12 + i12 - 2 * at, a14 + o16];
} }, accumulatedDistance: { type: R.HALF_FLOAT, count: 1, packTessellation: ({ distance: t4, pathLength: e9, distanceOffset: i12 }) => (i12 + t4) / e9 }, gradientSize: { type: R.HALF_FLOAT, count: 1, pack: ({ gradientSize: e9, gradientSizeUnits: r12 }) => r12 === e2.Relative ? e9 / 100 : u(e9) }, totalLength: { type: R.HALF_FLOAT, count: 1, packTessellation: ({ pathLength: t4 }) => t4 }, segmentDirection: { type: R.BYTE, count: 2, packPrecisionFactor: 16, packTessellation: ({ directionX: t4, directionY: e9 }) => [t4, e9] } } };
var l13 = class extends T3 {
  get _preventEffectClipping() {
    return true;
  }
  constructor(t4, e9, i12, r12) {
    super(t4, e9, i12, r12), this.vertexSpec = m6, this._tessellationOptions.textured = true;
  }
  _write(t4, i12, r12) {
    const s19 = r12 ?? a.fromFeatureSetReaderCIM(i12);
    if (!s19) return;
    const { sprite: o16 } = this.evaluatedMeshParams;
    this._writeGeometry(t4, i12, s19, o16?.textureBinding);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/line/TexturedLineMeshWriter.js
var u9 = { createComputedParams: (t4) => t4, optionalAttributes: f6.optionalAttributes, attributes: { ...f6.attributes, bitset: { type: R.UNSIGNED_BYTE, count: 1, pack: ({ shouldSampleAlphaOnly: t4, shouldScaleDash: e9, isSDF: r12 }) => u3([[w, t4], [D, e9], [E, r12]]) }, tlbr: { type: R.UNSIGNED_SHORT, count: 4, pack: ({ sprite: t4 }) => {
  const { rect: e9, width: s19, height: o16 } = t4, i12 = e9.x + tt, a14 = e9.y + tt;
  return [i12, a14, i12 + s19, a14 + o16];
} }, accumulatedDistance: { type: R.UNSIGNED_SHORT, count: 1, packTessellation: ({ distance: t4 }) => t4 }, segmentDirection: { type: R.BYTE, count: 2, packPrecisionFactor: 16, packTessellation: ({ directionX: t4, directionY: e9 }) => [t4, e9] }, offsetAlongLine: { type: R.HALF_FLOAT, count: 1, pack: ({ offsetAlongLine: e9 }) => u(e9) }, capType: { type: R.UNSIGNED_BYTE, count: 1, pack: ({ capType: t4 }) => {
  switch (t4) {
    case "Butt":
    case "butt":
    default:
      return 0;
    case "Square":
    case "square":
      return 1;
    case "Round":
    case "round":
      return 2;
  }
} } } };
var l14 = class extends T3 {
  constructor(t4, e9, r12, s19) {
    super(t4, e9, r12, s19), this.vertexSpec = u9, this._tessellationOptions.textured = true;
  }
  _write(t4, r12, s19) {
    const o16 = s19 ?? a.fromFeatureSetReaderCIM(r12);
    if (!o16) return;
    const { sprite: i12 } = this.evaluatedMeshParams;
    this._writeGeometry(t4, r12, o16, i12?.textureBinding);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/markers/ComputedMarkerParams.js
var o14 = class _o {
  static from(t4) {
    return "width" in t4 ? this.fromSimpleMeshParams(t4) : this.fromComplexMeshParams(t4);
  }
  static fromSimpleMeshParams(e9) {
    const i12 = new _o(e9.sprite, e9.color, e9.outlineColor, e9.minPixelBuffer, e9.placement, e9.scaleInfo, e9.effects), { type: s19, width: h9, height: r12, angle: n12, alignment: a14, outlineSize: c9, referenceSize: f9, sprite: l15, overrideOutlineColor: m7 } = e9;
    return i12.rawWidth = u(h9), i12.rawHeight = u(r12), i12.angle = n12, i12.alignment = a14, i12.outlineSize = u(c9), i12.referenceSize = u(f9), i12.overrideOutlineColor = m7, i12.offsetX = u(e9.offsetX), i12.offsetY = u(e9.offsetY), "simple" !== s19 || l15.sdf || (i12.rawWidth = l15.width, i12.rawHeight = l15.height), i12._computeSize(e9, false), i12;
  }
  static fromComplexMeshParams(i12) {
    const s19 = new _o(i12.sprite, i12.color, i12.outlineColor, i12.minPixelBuffer, i12.placement, i12.scaleInfo, i12.effects);
    let { alignment: h9, transforms: r12, size: n12, scaleX: a14, anchorX: c9, anchorY: f9, angle: l15, colorLocked: m7, frameHeight: d5, widthRatio: u10, offsetX: p8, offsetY: g6, outlineSize: x6, referenceSize: w4, scaleFactor: z4, sizeRatio: X2, isAbsoluteAnchorPoint: S5, rotateClockwise: Y, scaleSymbolsProportionally: H, sprite: C3 } = i12;
    if (r12 && r12.infos.length > 0) {
      const t4 = q2(n12, l15, Y, p8, g6, r12);
      n12 = t4.size, l15 = t4.rotation, p8 = t4.offsetX, g6 = t4.offsetY, Y = false;
    }
    z4 && (n12 *= z4, p8 *= z4, g6 *= z4);
    const M3 = a14 * (C3.width / C3.height);
    s19.alignment = h9, s19.rawHeight = u(n12), s19.rawWidth = s19.rawHeight * M3, s19.referenceSize = u(w4), s19.sizeRatio = X2, s19.sdfDecodeCoeff = (C3.sdfDecodeCoeff ?? 1) * X2, s19.angle = l15, s19.rotateClockwise = Y, s19.anchorX = c9, s19.anchorY = f9, s19.offsetX = u(p8), s19.offsetY = u(g6), S5 && n12 && (C3.sdf ? s19.anchorX = c9 / (n12 * u10) : s19.anchorX = c9 / (n12 * M3), s19.anchorY = f9 / n12);
    const W = H && d5 ? n12 / d5 : 1;
    return s19.outlineSize = 0 === x6 || isNaN(x6) ? 0 : u(x6) * W, s19.scaleSymbolsProportionally = H, s19.colorLocked = m7, s19._computeSize(i12, true), s19;
  }
  constructor(t4, e9, i12, o16, s19, h9, r12) {
    this.sprite = t4, this.color = e9, this.outlineColor = i12, this.minPixelBuffer = o16, this.placement = s19, this.scaleInfo = h9, this.effects = r12, this.rawWidth = 0, this.rawHeight = 0, this.angle = 0, this.outlineSize = 0, this.referenceSize = 0, this.sizeRatio = 1, this.sdfDecodeCoeff = 1, this.alignment = 0, this.scaleSymbolsProportionally = false, this.overrideOutlineColor = false, this.colorLocked = false, this.anchorX = 0, this.anchorY = 0, this.computedWidth = 0, this.computedHeight = 0, this.texXmin = 0, this.texYmin = 0, this.texXmax = 0, this.texYmax = 0, this.offsetX = 0, this.offsetY = 0, this.rotateClockwise = true;
  }
  get boundsInfo() {
    return { size: Math.max(this.computedHeight, this.computedWidth), offsetX: this.offsetX, offsetY: this.offsetY };
  }
  _computeSize(t4, e9) {
    const { sprite: o16, hasSizeVV: r12 } = t4, n12 = !!o16.sdf, a14 = o16.sdfPaddingRatio ?? 0.5, { rawWidth: c9, rawHeight: f9, sizeRatio: l15, outlineSize: m7 } = this, d5 = o16.rect;
    let u10 = c9 * l15, p8 = f9 * l15, g6 = 0, x6 = 0;
    if (n12) {
      const t5 = 1 / (1 - a14);
      if (u10 *= t5, p8 *= t5, r12) this.computedWidth = u10, this.computedHeight = p8;
      else {
        const t6 = e9 && c9 > f9 ? u10 : c9, i12 = f9, s19 = m7 + 2 * 1;
        this.computedWidth = Math.min(t6 + s19, u10), this.computedHeight = Math.min(i12 + s19, p8);
        const h9 = Math.max(o16.width, o16.height) / Math.max(u10, p8);
        g6 = (this.computedWidth - u10) * h9, x6 = (this.computedHeight - p8) * h9;
      }
    } else this.computedWidth = u10 * (d5.width / o16.width), this.computedHeight = p8 * (d5.height / o16.height), g6 = 2 * tt, x6 = 2 * tt;
    const w4 = d5.x + tt - g6 / 2, z4 = d5.y + tt - x6 / 2, X2 = w4 + o16.width + g6, S5 = z4 + o16.height + x6;
    this.texXmin = s17(w4), this.texYmin = s17(z4), this.texXmax = h8(X2), this.texYmax = h8(S5), this.computedWidth *= (this.texXmax - this.texXmin) / (X2 - w4), this.computedHeight *= (this.texYmax - this.texYmin) / (S5 - z4), this.anchorX *= u10 / this.computedWidth, this.anchorY *= p8 / this.computedHeight;
  }
};
function s17(t4, e9 = 1e-7) {
  const i12 = Math.ceil(t4);
  return i12 - t4 < e9 ? i12 : Math.floor(t4);
}
function h8(t4, e9 = 1e-7) {
  const i12 = Math.floor(t4);
  return t4 - i12 < e9 ? i12 : Math.ceil(t4);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/markers/MarkerMeshWriter.js
var P2 = 3.14159265359 / 180;
var g5 = 128 / Math.PI;
function k4(e9, t4) {
  return e9 %= t4, Math.abs(e9 >= 0 ? e9 : e9 + t4);
}
function b3(e9) {
  return k4(e9 * g5, 256);
}
function v2(e9, a14, i12, n12, c9 = false) {
  const l15 = n(), m7 = c9 ? 1 : -1;
  return a2(l15), (a14 || i12) && i2(l15, l15, [a14, -i12]), n12 && s3(l15, l15, m7 * P2 * -n12), l15;
}
var S4 = { createComputedParams: (e9) => o14.from(e9), optionalAttributes: { zoomRange: { type: R.SHORT, count: 2, packPrecisionFactor: st, pack: ({ scaleInfo: e9 }, { tileInfo: t4 }) => s8(e9, t4) } }, attributes: { pos: { type: R.SHORT, count: 2, pack: "position", packPrecisionFactor: 10 }, id: { type: R.UNSIGNED_BYTE, count: 3, pack: "id" }, bitset: { type: R.UNSIGNED_BYTE, count: 1, pack: ({ sprite: e9, alignment: t4, scaleSymbolsProportionally: r12, overrideOutlineColor: o16, colorLocked: s19 }) => {
  let a14 = 0;
  return e9.sdf && (a14 |= i5(o2.bitset.isSDF)), 1 === t4 && (a14 |= i5(o2.bitset.isMapAligned)), r12 && (a14 |= i5(o2.bitset.scaleSymbolsProportionally)), o16 && (a14 |= i5(o2.bitset.overrideOutlineColor)), s19 && (a14 |= i5(o2.bitset.colorLocked)), a14;
} }, offset: { type: R.HALF_FLOAT, count: 2, packAlternating: { count: 4, pack: ({ angle: e9, computedWidth: t4, computedHeight: r12, anchorX: o16, anchorY: s19, offsetX: i12, offsetY: n12, rotateClockwise: c9 }) => {
  const l15 = v2(0, i12, n12, -e9, c9), m7 = -(0.5 + o16) * t4, u10 = -(0.5 - s19) * r12, d5 = [m7, u10], p8 = [m7 + t4, u10], h9 = [m7, u10 + r12], f9 = [m7 + t4, u10 + r12];
  return S(d5, d5, l15), S(p8, p8, l15), S(h9, h9, l15), S(f9, f9, l15), [d5, p8, h9, f9];
} } }, textureUV: { type: R.SHORT, count: 2, packPrecisionFactor: 4, packAlternating: { count: 4, pack: ({ texXmax: e9, texXmin: t4, texYmax: r12, texYmin: o16 }) => [[t4, o16], [e9, o16], [t4, r12], [e9, r12]] } }, color: { type: R.UNSIGNED_BYTE, count: 4, normalized: true, pack: ({ color: e9 }) => a6(e9) }, outlineColor: { type: R.UNSIGNED_BYTE, count: 4, normalized: true, pack: ({ outlineColor: e9 }) => a6(e9) }, sizing: { type: R.UNSIGNED_BYTE, count: 4, pack: ({ rawWidth: e9, rawHeight: t4, outlineSize: r12, referenceSize: o16 }) => {
  const s19 = Math.max(e9, t4);
  return [l6(s19, 128), l6(r12, 128), l6(o16, 128), 0];
} }, placementAngle: { type: R.UNSIGNED_BYTE, count: 1, packTessellation: ({ placementAngle: e9 }) => b3(e9) }, sdfDecodeCoeff: { type: R.UNSIGNED_SHORT, count: 1, packPrecisionFactor: 64, pack: ({ sdfDecodeCoeff: e9 }) => e9 } } };
var I2 = class extends a7 {
  constructor() {
    super(...arguments), this.vertexSpec = S4;
  }
  getBoundsInfo() {
    return this.evaluatedMeshParams.boundsInfo;
  }
  _write(e9, t4, r12) {
    const o16 = this.evaluatedMeshParams.sprite?.textureBinding, s19 = t4.getDisplayId();
    e9.recordStart(this.instanceId, this.attributeLayout, o16);
    const a14 = this.evaluatedMeshParams.minPixelBuffer, i12 = Math.max(this.evaluatedMeshParams.computedWidth, a14), l15 = Math.max(this.evaluatedMeshParams.computedHeight, a14), m7 = -this.evaluatedMeshParams.anchorX * this.evaluatedMeshParams.computedWidth, u10 = this.evaluatedMeshParams.anchorY * this.evaluatedMeshParams.computedHeight, d5 = this.evaluatedMeshParams.offsetX + m7, p8 = -this.evaluatedMeshParams.offsetY + u10;
    if (null != this.evaluatedMeshParams.placement) {
      let o17 = null;
      if (null != r12) {
        const e10 = Math.max(this.evaluatedMeshParams.computedWidth, this.evaluatedMeshParams.computedHeight);
        if (o17 = y(r12, 2 * e10, false), null === o17) return;
      }
      this._writePlacedMarkers(e9, t4, o17, i12, l15);
    } else if (r12?.nextPath()) {
      r12.nextPoint();
      const t5 = r12.x, o17 = r12.y;
      e9.recordBounds(t5 + d5, o17 + p8, i12, l15), this._writeQuad(e9, s19, t5, o17);
    } else if ("esriGeometryPolygon" === t4.geometryType) {
      const r13 = t4.readCentroidForDisplay();
      if (!r13) return;
      const [o17, a15] = r13.coords;
      e9.recordBounds(o17 + d5, a15 + p8, i12, l15), this._writeQuad(e9, s19, o17, a15);
    } else if ("esriGeometryPoint" === t4.geometryType) {
      const r13 = t4.readXForDisplay(), o17 = t4.readYForDisplay();
      e9.recordBounds(r13 + d5, o17 + p8, i12, l15), this._writeQuad(e9, s19, r13, o17);
    } else {
      const r13 = t4.readGeometryForDisplay();
      r13?.forEachVertex((t5, r14) => {
        e9.recordBounds(t5 + d5, r14 + p8, i12, l15), Math.abs(t5) > r2 || Math.abs(r14) > r2 || this._writeQuad(e9, s19, t5, r14);
      });
    }
    e9.recordEnd();
  }
  _writePlacedMarkers(t4, r12, o16, s19, a14) {
    const n12 = o16 ?? a.fromFeatureSetReaderCIM(r12);
    if (!n12) return;
    const m7 = -1, u10 = e8.getPlacement(n12, m7, this.evaluatedMeshParams.placement, u(1), t4.id);
    if (!u10) return;
    const d5 = r12.getDisplayId();
    let p8 = u10.next();
    const h9 = this.evaluatedMeshParams.offsetX, f9 = -this.evaluatedMeshParams.offsetY;
    for (; null != p8; ) {
      const e9 = p8.tx, r13 = -p8.ty;
      if (Math.abs(e9) > r2 || Math.abs(r13) > r2) {
        p8 = u10.next();
        continue;
      }
      const o17 = -p8.getAngle();
      t4.recordBounds(e9 + h9, r13 + f9, s19, a14), this._writeQuad(t4, d5, e9, r13, o17), p8 = u10.next();
    }
  }
  _writeQuad(e9, t4, r12, o16, s19) {
    const a14 = e9.vertexCount(), i12 = null == s19 ? null : { placementAngle: s19 };
    this._writeVertex(e9, t4, r12, o16, i12), e9.indexWrite(a14 + 0), e9.indexWrite(a14 + 1), e9.indexWrite(a14 + 2), e9.indexWrite(a14 + 1), e9.indexWrite(a14 + 3), e9.indexWrite(a14 + 2);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/pieChart/PieChartMeshWriter.js
var o15 = { createComputedParams: (e9) => e9, optionalAttributes: {}, attributes: { pos: { type: R.SHORT, count: 2, packPrecisionFactor: 10, pack: "position" }, id: { type: R.UNSIGNED_BYTE, count: 3, pack: "id" }, bitset: { type: R.UNSIGNED_BYTE, count: 1, pack: (e9) => 0 }, offset: { type: R.SHORT, count: 2, packPrecisionFactor: 16, packAlternating: { count: 4, pack: ({ size: t4 }) => {
  const r12 = u(t4), i12 = -r12 / 2, o16 = -r12 / 2;
  return [[i12, o16], [i12 + r12, o16], [i12, o16 + r12], [i12 + r12, o16 + r12]];
} } }, texCoords: { type: R.SHORT, count: 2, packPrecisionFactor: 4, packAlternating: { count: 4, pack: () => [[0, 1], [1, 1], [0, 0], [1, 0]] } }, size: { type: R.UNSIGNED_BYTE, count: 2, pack: ({ size: e9 }) => [e9, e9] }, referenceSize: { type: R.UNSIGNED_BYTE, count: 1, pack: ({ size: t4 }) => u(t4) }, zoomRange: { type: R.UNSIGNED_BYTE, count: 2, pack: ({ scaleInfo: e9 }, { tileInfo: r12 }) => s8(e9, r12) } } };
var s18 = class extends a7 {
  constructor() {
    super(...arguments), this.vertexSpec = o15;
  }
  _write(t4, r12) {
    const i12 = r12.getDisplayId(), o16 = this.evaluatedMeshParams.minPixelBuffer, s19 = Math.max(u(this.evaluatedMeshParams.size), o16);
    let c9, n12;
    if ("esriGeometryPoint" === r12.geometryType) c9 = r12.readXForDisplay(), n12 = r12.readYForDisplay();
    else {
      const e9 = r12.readCentroidForDisplay();
      if (!e9) return;
      c9 = e9?.coords[0], n12 = e9?.coords[1];
    }
    t4.recordStart(this.instanceId, this.attributeLayout), t4.recordBounds(c9, n12, s19, s19);
    const a14 = t4.vertexCount();
    this._writeVertex(t4, i12, c9, n12), t4.indexWrite(a14 + 0), t4.indexWrite(a14 + 1), t4.indexWrite(a14 + 2), t4.indexWrite(a14 + 1), t4.indexWrite(a14 + 3), t4.indexWrite(a14 + 2), t4.recordEnd();
  }
};

export {
  e8 as e,
  s8 as s,
  a6 as a,
  f2 as f,
  m,
  l7 as l,
  o8 as o,
  e5 as e2,
  o4 as o2,
  n3 as n,
  s7 as s2,
  r6 as r,
  a5 as a2,
  c3 as c,
  l5 as l2,
  f as f2,
  a8 as a3,
  s10 as s3,
  p2 as p,
  r8 as r2,
  l8 as l3,
  k,
  u4 as u,
  T2 as T,
  m2,
  y2 as y,
  F2 as F,
  f3,
  O,
  S3 as S,
  d,
  x,
  N,
  h4 as h,
  g4 as g,
  p4 as p2,
  d3 as d2,
  T3 as T2,
  s13 as s4,
  c7 as c2,
  o11 as o3,
  h5 as h2,
  f7 as f4,
  f8 as f5,
  u7 as u2,
  o13 as o4,
  i10 as i,
  _3 as _,
  E2 as E,
  l13 as l4,
  l14 as l5,
  I2 as I,
  s18 as s5
};
//# sourceMappingURL=chunk-27W5ILTF.js.map
