import {
  a,
  c,
  e,
  i,
  l,
  o,
  s as s3,
  u,
  y
} from "./chunk-ZMVRYYR6.js";
import "./chunk-63RKYW5K.js";
import {
  n,
  t
} from "./chunk-65WW7L4T.js";
import {
  e as e2
} from "./chunk-HROH5C5D.js";
import {
  t as t2
} from "./chunk-5BAQPFKY.js";
import {
  s as s2
} from "./chunk-H34D76ZQ.js";
import {
  Q,
  R,
  W
} from "./chunk-CNYNCKEV.js";
import "./chunk-XL5QPCXN.js";
import "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-W75DBJD7.js";
import "./chunk-P6IKJIMO.js";
import "./chunk-MHV23XAQ.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-ONXWBTTM.js";
import "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import {
  M
} from "./chunk-7P2ANHQ3.js";
import "./chunk-XCKT47LJ.js";
import "./chunk-3FUHCAX3.js";
import "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import "./chunk-2OFHDVO5.js";
import "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-5UPBUJPC.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-SMWUT52Z.js";
import "./chunk-AXZMNHTN.js";
import "./chunk-5T3MJDSR.js";
import "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import {
  p2 as p
} from "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import "./chunk-5EI5H4QX.js";
import "./chunk-ZIE53VIV.js";
import "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import "./chunk-GNMPGHLQ.js";
import {
  s2 as s
} from "./chunk-QY7XKUIV.js";
import "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/portal/support/layersLoader.js
async function b(e3, t3) {
  const r = e3.instance.portalItem;
  if (r?.id) return await r.load(t3), v(e3), e3.validateItem && e3.validateItem(r), L(e3, t3);
}
function v(t3) {
  const r = t3.instance.portalItem;
  if (!r?.type || !t3.supportedTypes.includes(r.type)) throw new s("portal:invalid-layer-item-type", "Invalid layer item type '${type}', expected '${expectedType}'", { type: r?.type, expectedType: t3.supportedTypes.join(", ") });
}
async function L(e3, t3) {
  const r = e3.instance, o2 = r.portalItem;
  if (!o2) return;
  let { url: n2 } = o2;
  const { title: s4 } = o2, l2 = e2(o2, "portal-item");
  if ("group" === r.type) return S(r, l2, e3);
  n2 && "media" !== r.type && r.read({ url: n2 }, l2);
  const p2 = new e(), { data: u2, preferredHost: c2 } = await x(e3, p2, t3);
  return n2 = o2.url, "isUrlHostModified" in r && (c2 ? r.applyPreferredHost({ preferredHost: c2 }) : r.applyHostFromPortalItem()), u2 && r.read(u2, l2), r.resourceReferences = { portalItem: o2, paths: l2.readResourcePaths ?? [] }, "subtype-group" !== r.type && r.read({ title: s4 }, l2), t2(r, l2);
}
async function S(t3, r, a2) {
  const o2 = t3.portalItem;
  if (!t3.sourceIsPortalItem) return;
  const { title: n2, type: s4 } = o2;
  if ("Group Layer" === s4) {
    if (!s2(o2, "Map")) throw new s("portal:invalid-layer-item-typekeyword", "'Group Layer' item without 'Map' type keyword is not supported");
    return T(t3, a2);
  }
  return t3.read({ title: n2 }, r), j(t3, a2);
}
async function T(t3, r) {
  const a2 = t3.portalItem, o2 = await a2.fetchData("json");
  if (!o2) return;
  if (!r.populateGroupLayer) throw new s("portal:missing-populate-group-layer", "Missing populate group layer");
  const n2 = e2(a2, "web-map");
  t3.read(o2, n2), await r.populateGroupLayer(t3, o2, { context: n2 }), t3.resourceReferences = { portalItem: a2, paths: n2.readResourcePaths ?? [] };
}
async function j(t3, r) {
  let n2;
  const { portalItem: s4 } = t3;
  if (!s4) return;
  const l2 = s4.type, i2 = r.layerModuleTypeMap;
  if (!i2) throw new s("portal:missing-layer-module-type-map", "Layer module type map is required to construct sub layers");
  switch (l2) {
    case "Feature Service":
    case "Feature Collection":
      n2 = i2.FeatureLayer;
      break;
    case "Stream Service":
      n2 = i2.StreamLayer;
      break;
    case "Scene Service":
      n2 = i2.SceneLayer;
      break;
    case "Video Service":
      n2 = i2.VideoLayer;
      break;
    default:
      throw new s("portal:unsupported-item-type-as-group", `The item type '${l2}' is not supported as a 'GroupLayer'`);
  }
  const p2 = "Video Service" === l2, u2 = new e();
  let [m, { data: w }] = await Promise.all([n2(), p2 ? { data: null } : x(r, u2)]), h = () => m;
  if (p2) return F(t3, h, i2);
  if ("Feature Service" === l2) {
    const e3 = s3(w)?.customParameters;
    w = s4.url ? (await l(w, s4.url, u2)).data : {}, h = await E(w, i2) || h;
    const { provider: r2, preferredHost: a2 } = await U(s4.url, { customParameters: e3, loadContext: u2 });
    return W(s4, a2), await H(t3, h, h, w, i2, r2);
  }
  return "Scene Service" === l2 && s4.url && (w = await y(s4, w, u2)), c(w) > 0 ? await H(t3, h, null, w, i2) : await P(t3, h, i2);
}
async function P(e3, t3, r) {
  const { portalItem: a2 } = e3;
  if (!a2?.url) return;
  const o2 = await t(a2.url);
  o2 && H(e3, t3, null, { layers: o2.layers?.map(a), tables: o2.tables?.map(a) }, r);
}
async function F(e3, t3, r) {
  const { portalItem: a2 } = e3;
  if (!a2?.url) return;
  const o2 = await t(a2.url);
  o2 && H(e3, t3, null, { layers: o2.layers?.map(({ id: e4, name: t4 }) => ({ id: e4, name: t4 })) }, r);
}
async function H(e3, t3, r, a2, o2, n2) {
  let s4 = a2.layers || [];
  const l2 = a2.tables || [];
  if ("Feature Collection" === e3.portalItem?.type ? (s4.forEach((e4, t4) => {
    e4.id = t4, "Table" === e4?.layerDefinition?.type && l2.push(e4);
  }), s4 = s4.filter((e4) => "Table" !== e4?.layerDefinition?.type)) : (s4.reverse(), l2.reverse()), s4.forEach((r2) => {
    const o3 = n2?.(r2);
    if (o3 || !n2) {
      const n3 = M2(e3, t3(r2), a2, r2, o3);
      e3.add(n3);
    }
  }), l2.length) {
    const t4 = r ? null : await o2.FeatureLayer();
    l2.forEach((o3) => {
      const s5 = n2?.(o3);
      if (s5 || !n2) {
        const n3 = M2(e3, r ? r(o3) : t4, a2, o3, s5);
        e3.tables.add(n3);
      }
    });
  }
}
function M2(e3, t3, r, a2, o2) {
  const n2 = e3.portalItem, s4 = { portalItem: n2.clone(), layerId: a2.id };
  null != a2.url && (s4.url = a2.url);
  const i2 = new t3(s4);
  if ("sourceJSON" in i2 && (i2.sourceJSON = o2), "subtype-group" !== i2.type && "catalog" !== i2.type && (i2.sublayerTitleMode = "service-name"), "Feature Collection" === n2.type) {
    const e4 = { origin: "portal-item", portal: n2.portal || M.getDefault() };
    i2.read(a2, e4);
    const t4 = r.showLegend;
    null != t4 && i2.read({ showLegend: t4 }, e4);
  }
  return i2;
}
async function x(e3, t3, r) {
  if (false === e3.supportsData) return { data: void 0 };
  const a2 = e3.instance, n2 = a2.portalItem;
  if (!n2) return { data: void 0 };
  let s4 = null;
  try {
    s4 = await n2.fetchData("json", r);
  } catch (l2) {
  }
  if (C(a2)) {
    let e4 = null;
    const { count: r2, preferredHost: l2 } = await G(n2, s4, t3);
    if (W(n2, l2), (s4?.layers || s4?.tables) && r2 > 0) {
      if (null == a2.layerId) {
        const e5 = o(a2.type), t4 = e5?.length ? u(s4, e5)[0] : s3(s4);
        t4 && (a2.layerId = t4.id);
      }
      e4 = k(s4, a2), "OrientedImageryLayer" === e4?.layerType && "oriented-imagery" === a2.type && a2.supportedSourceTypes.add("Feature Layer"), e4 && null != s4.showLegend && (e4.showLegend = s4.showLegend);
    }
    return r2 > 1 && "sublayerTitleMode" in a2 && "service-name" !== a2.sublayerTitleMode && (a2.sublayerTitleMode = "item-title-and-service-name"), { data: e4, preferredHost: l2 };
  }
  return { data: s4 };
}
async function G(e3, r, a2) {
  if (r?.layers && r?.tables) return { count: c(r) };
  const o2 = p(e3.url);
  if (!o2) return { count: 1 };
  const l2 = o2.url.path, i2 = await a2.fetchServiceMetadata(l2, { customParameters: s3(r)?.customParameters }).catch(() => null);
  return { count: (r?.layers?.length ?? i2?.layers?.length ?? 0) + (r?.tables?.length ?? i2?.tables?.length ?? 0), preferredHost: R(e3) ? Q() : null };
}
function k(e3, t3) {
  const { layerId: r } = t3, a2 = e3.layers?.find((e4) => e4.id === r) || e3.tables?.find((e4) => e4.id === r);
  return a2 && D(a2, t3) ? a2 : null;
}
function C(e3) {
  return "stream" !== e3.type && "layerId" in e3;
}
function D(e3, t3) {
  const r = "layerType" in e3 && e3.layerType, { type: a2 } = t3;
  return !("feature" === a2 && r && "ArcGISFeatureLayer" !== e3.layerType || "catalog" === a2 && !r || "oriented-imagery" === a2 && !r || "subtype-group" === a2 && !r);
}
async function U(e3, t3) {
  const { layersJSON: a2, preferredHost: o2 } = await n(e3, t3);
  if (!a2) return { provider: null, preferredHost: o2 };
  const n2 = [...a2.layers, ...a2.tables];
  return { provider: (e4) => n2.find((t4) => t4.id === e4.id), preferredHost: o2 };
}
async function E(e3, t3) {
  const { layers: r, tables: a2 } = e3, o2 = [...r ?? [], ...a2 ?? []];
  if (!o2.length) return;
  const n2 = /* @__PURE__ */ new Set(), s4 = [];
  for (const { layerType: p2 } of o2) {
    const e4 = p2 ?? "ArcGISFeatureLayer";
    if (n2.has(e4)) continue;
    n2.add(e4);
    const r2 = t3[i(e4)];
    s4.push(r2());
  }
  const l2 = await Promise.all(s4), i2 = /* @__PURE__ */ new Map();
  return Array.from(n2).forEach((e4, t4) => {
    i2.set(e4, l2[t4]);
  }), ({ layerType: e4 }) => {
    const t4 = e4 ?? "ArcGISFeatureLayer";
    return i2.get(t4);
  };
}
export {
  b as load
};
//# sourceMappingURL=layersLoader-2PJERWO5.js.map
