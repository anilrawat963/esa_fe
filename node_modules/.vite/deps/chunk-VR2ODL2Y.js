import {
  T
} from "./chunk-JE2NJSBU.js";
import {
  n
} from "./chunk-234CIOHE.js";
import {
  has
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/geometry/libtess.js
var s = 128e3;
var n2 = null;
var e = null;
async function i() {
  return n2 || (n2 = r()), n2;
}
async function r() {
  const s3 = has("esri-csp-restrictions") ? await import("./libtess-asm-ONOQVTGU.js").then((t) => t.l) : await import("./libtess-NVNNZGDD.js").then((t) => t.l);
  e = await s3.default({ locateFile: (s4) => n(`esri/core/libs/libtess/${s4}`) });
}
function a(t, n4) {
  const i3 = Math.max(t.length, s);
  return e.triangulate(t, n4, i3);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/TurboLine.js
function e2(t, e3) {
  return t.x === e3.x && t.y === e3.y;
}
function i2(t) {
  if (!t) return;
  const i3 = t.length;
  if (i3 <= 1) return;
  let x2 = 0;
  for (let r3 = 1; r3 < i3; r3++) e2(t[r3], t[x2]) || ++x2 === r3 || (t[x2] = t[r3]);
  t.length = x2 + 1;
}
function x(t, e3) {
  return t.x = e3.y, t.y = -e3.x, t;
}
function r2(t, e3) {
  return t.x = -e3.y, t.y = e3.x, t;
}
function n3(t, e3) {
  return t.x = e3.x, t.y = e3.y, t;
}
function s2(t, e3) {
  return t.x = -e3.x, t.y = -e3.y, t;
}
function y(t) {
  return Math.sqrt(t.x * t.x + t.y * t.y);
}
function o(t, e3) {
  return t.x * e3.y - t.y * e3.x;
}
function h(t, e3) {
  return t.x * e3.x + t.y * e3.y;
}
function l(t, e3, i3, x2) {
  return t.x = e3.x * i3 + e3.y * x2, t.y = e3.x * x2 - e3.y * i3, t;
}
var _ = class {
  constructor(t, e3, i3) {
    this._writeVertex = t, this._writeTriangle = e3, this._canUseThinTessellation = i3, this._prevNormal = { x: void 0, y: void 0 }, this._nextNormal = { x: void 0, y: void 0 }, this._textureNormalLeft = { x: 0, y: 1 }, this._textureNormalRight = { x: 0, y: -1 }, this._textureNormal = { x: void 0, y: void 0 }, this._joinNormal = { x: void 0, y: void 0 }, this._inner = { x: void 0, y: void 0 }, this._outer = { x: void 0, y: void 0 }, this._roundStart = { x: void 0, y: void 0 }, this._roundEnd = { x: void 0, y: void 0 }, this._startBreak = { x: void 0, y: void 0 }, this._endBreak = { x: void 0, y: void 0 }, this._innerPrev = { x: void 0, y: void 0 }, this._innerNext = { x: void 0, y: void 0 }, this._bevelStart = { x: void 0, y: void 0 }, this._bevelEnd = { x: void 0, y: void 0 }, this._bevelMiddle = { x: void 0, y: void 0 };
  }
  tessellate(e3, x2, r3 = this._canUseThinTessellation) {
    i2(e3), r3 && x2.halfWidth < T && !x2.offset ? this._tessellateThin(e3, x2) : this._tessellate(e3, x2);
  }
  _tessellateThin(t, e3) {
    if (t.length < 2) return;
    const i3 = e3.wrapDistance || 65535;
    let x2 = e3.initialDistance || 0, r3 = false, n4 = t[0].x, s3 = t[0].y;
    const y2 = t.length;
    for (let o2 = 1; o2 < y2; ++o2) {
      r3 && (r3 = false, x2 = 0);
      let e4 = t[o2].x, y3 = t[o2].y, h2 = e4 - n4, l2 = y3 - s3, _2 = Math.sqrt(h2 * h2 + l2 * l2);
      if (h2 /= _2, l2 /= _2, x2 + _2 > i3) {
        r3 = true;
        const t2 = (i3 - x2) / _2;
        _2 = i3 - x2, e4 = (1 - t2) * n4 + t2 * e4, y3 = (1 - t2) * s3 + t2 * y3, --o2;
      }
      const a2 = this._writeVertex(n4, s3, 0, 0, h2, l2, l2, -h2, 0, -1, x2), c = this._writeVertex(n4, s3, 0, 0, h2, l2, -l2, h2, 0, 1, x2);
      x2 += _2;
      const d = this._writeVertex(e4, y3, 0, 0, h2, l2, l2, -h2, 0, -1, x2), u = this._writeVertex(e4, y3, 0, 0, h2, l2, -l2, h2, 0, 1, x2);
      this._writeTriangle(a2, c, d), this._writeTriangle(c, d, u), n4 = e4, s3 = y3;
    }
  }
  _tessellate(t, i3) {
    const _2 = t[0], a2 = t[t.length - 1], c = e2(_2, a2), d = c ? 3 : 2;
    if (t.length < d) return;
    const u = i3.pixelCoordRatio, v = null != i3.capType ? i3.capType : 0, f = null != i3.joinType ? i3.joinType : 2, w = null != i3.miterLimit ? Math.min(i3.miterLimit, 4) : 2, g = null != i3.roundLimit ? Math.min(i3.roundLimit, 1.05) : 1.05, T2 = null != i3.halfWidth ? i3.halfWidth : 2, m = !!i3.textured;
    let V, b, N, k = null;
    const p = this._prevNormal, M = this._nextNormal;
    let E = -1, L = -1;
    const B = this._joinNormal;
    let S, j;
    const P = this._textureNormalLeft, A = this._textureNormalRight, D = this._textureNormal;
    let U = -1, R = -1;
    const W = i3.wrapDistance || 65535;
    let q = i3.initialDistance || 0;
    const X = this._writeVertex, C = this._writeTriangle, z = (t2, e3, i4, x2, r3, n4) => {
      const s3 = X(b, N, S, j, i4, x2, t2, e3, r3, n4, q);
      return U >= 0 && R >= 0 && s3 >= 0 && C(U, R, s3), U = R, R = s3, s3;
    };
    c && (V = t[t.length - 2], M.x = a2.x - V.x, M.y = a2.y - V.y, L = y(M), M.x /= L, M.y /= L);
    let F = false;
    for (let e3 = 0; e3 < t.length; ++e3) {
      if (F && (F = false, q = 0), V && (p.x = -M.x, p.y = -M.y, E = L, q + E > W && (F = true)), F) {
        const i5 = (W - q) / E;
        E = W - q, V = { x: (1 - i5) * V.x + i5 * t[e3].x, y: (1 - i5) * V.y + i5 * t[e3].y }, --e3;
      } else V = t[e3];
      b = V.x, N = V.y;
      const i4 = e3 <= 0 && !F, _3 = e3 === t.length - 1;
      if (i4 || (q += E), k = _3 ? c ? t[1] : null : t[e3 + 1], k ? (M.x = k.x - b, M.y = k.y - N, L = y(M), M.x /= L, M.y /= L) : (M.x = void 0, M.y = void 0), !c) {
        if (i4) {
          r2(B, M), S = B.x, j = B.y, 2 === v && (z(-M.y - M.x, M.x - M.y, M.x, M.y, 0, -1), z(M.y - M.x, -M.x - M.y, M.x, M.y, 0, 1)), 1 === v && (z(-M.y - M.x, M.x - M.y, M.x, M.y, -1, -1), z(M.y - M.x, -M.x - M.y, M.x, M.y, -1, 1)), 1 !== v && 0 !== v || (z(-M.y, M.x, M.x, M.y, 0, -1), z(M.y, -M.x, M.x, M.y, 0, 1));
          continue;
        }
        if (_3) {
          x(B, p), S = B.x, j = B.y, 1 !== v && 0 !== v || (z(p.y, -p.x, -p.x, -p.y, 0, -1), z(-p.y, p.x, -p.x, -p.y, 0, 1)), 2 === v && (z(p.y - p.x, -p.x - p.y, -p.x, -p.y, 0, -1), z(-p.y - p.x, p.x - p.y, -p.x, -p.y, 0, 1)), 1 === v && (z(p.y - p.x, -p.x - p.y, -p.x, -p.y, 1, -1), z(-p.y - p.x, p.x - p.y, -p.x, -p.y, 1, 1));
          continue;
        }
      }
      let a3, d2, X2 = -o(p, M);
      if (Math.abs(X2) < 0.01) h(p, M) > 0 ? (B.x = p.x, B.y = p.y, X2 = 1, a3 = Number.MAX_VALUE, d2 = true) : (r2(B, M), X2 = 1, a3 = 1, d2 = false);
      else {
        B.x = (p.x + M.x) / X2, B.y = (p.y + M.y) / X2, a3 = y(B);
        const t2 = (a3 - 1) * T2 * u;
        d2 = a3 > 4 || t2 > E && t2 > L;
      }
      S = B.x, j = B.y;
      let C2 = f;
      switch (f) {
        case 0:
          a3 < 1.05 && (C2 = 2);
          break;
        case 1:
          a3 < g && (C2 = 2);
          break;
        case 2:
          a3 > w && (C2 = 0);
      }
      switch (C2) {
        case 2:
          if (z(B.x, B.y, -p.x, -p.y, 0, -1), z(-B.x, -B.y, -p.x, -p.y, 0, 1), _3) break;
          if (m) {
            const t2 = F ? 0 : q;
            U = this._writeVertex(b, N, S, j, M.x, M.y, B.x, B.y, 0, -1, t2), R = this._writeVertex(b, N, S, j, M.x, M.y, -B.x, -B.y, 0, 1, t2);
          }
          break;
        case 0: {
          const t2 = X2 < 0;
          let e4, i5, y2, o2;
          if (t2) {
            const t3 = U;
            U = R, R = t3, e4 = P, i5 = A;
          } else e4 = A, i5 = P;
          if (d2) y2 = t2 ? r2(this._innerPrev, p) : x(this._innerPrev, p), o2 = t2 ? x(this._innerNext, M) : r2(this._innerNext, M);
          else {
            const e5 = t2 ? s2(this._inner, B) : n3(this._inner, B);
            y2 = e5, o2 = e5;
          }
          const h2 = t2 ? x(this._bevelStart, p) : r2(this._bevelStart, p);
          z(y2.x, y2.y, -p.x, -p.y, e4.x, e4.y);
          const a4 = z(h2.x, h2.y, -p.x, -p.y, i5.x, i5.y);
          if (_3) break;
          const c2 = t2 ? r2(this._bevelEnd, M) : x(this._bevelEnd, M);
          if (d2) {
            const t3 = this._writeVertex(b, N, S, j, -p.x, -p.y, 0, 0, 0, 0, q);
            U = this._writeVertex(b, N, S, j, M.x, M.y, o2.x, o2.y, e4.x, e4.y, q), R = this._writeVertex(b, N, S, j, M.x, M.y, c2.x, c2.y, i5.x, i5.y, q), this._writeTriangle(a4, t3, R);
          } else {
            if (m) {
              const t3 = this._bevelMiddle;
              t3.x = (h2.x + c2.x) / 2, t3.y = (h2.y + c2.y) / 2, l(D, t3, -p.x, -p.y), z(t3.x, t3.y, -p.x, -p.y, D.x, D.y), l(D, t3, M.x, M.y), U = this._writeVertex(b, N, S, j, M.x, M.y, t3.x, t3.y, D.x, D.y, q), R = this._writeVertex(b, N, S, j, M.x, M.y, o2.x, o2.y, e4.x, e4.y, q);
            } else {
              const t3 = U;
              U = R, R = t3;
            }
            z(c2.x, c2.y, M.x, M.y, i5.x, i5.y);
          }
          if (t2) {
            const t3 = U;
            U = R, R = t3;
          }
          break;
        }
        case 1: {
          const t2 = X2 < 0;
          let e4, i5;
          if (t2) {
            const t3 = U;
            U = R, R = t3, e4 = P, i5 = A;
          } else e4 = A, i5 = P;
          const y2 = t2 ? s2(this._inner, B) : n3(this._inner, B);
          let o2, c2;
          d2 ? (o2 = t2 ? r2(this._innerPrev, p) : x(this._innerPrev, p), c2 = t2 ? x(this._innerNext, M) : r2(this._innerNext, M)) : (o2 = y2, c2 = y2);
          const u2 = t2 ? x(this._roundStart, p) : r2(this._roundStart, p), v2 = t2 ? r2(this._roundEnd, M) : x(this._roundEnd, M), f2 = z(o2.x, o2.y, -p.x, -p.y, e4.x, e4.y), w2 = z(u2.x, u2.y, -p.x, -p.y, i5.x, i5.y);
          if (_3) break;
          const g2 = this._writeVertex(b, N, S, j, -p.x, -p.y, 0, 0, 0, 0, q);
          d2 || this._writeTriangle(U, R, g2);
          const T3 = s2(this._outer, y2), V2 = this._writeVertex(b, N, S, j, M.x, M.y, v2.x, v2.y, i5.x, i5.y, q);
          let k2, E2;
          const L2 = a3 > 2;
          if (L2) {
            let e5;
            a3 !== Number.MAX_VALUE ? (T3.x /= a3, T3.y /= a3, e5 = h(p, T3), e5 = (a3 * (e5 * e5 - 1) + 1) / e5) : e5 = -1, k2 = t2 ? x(this._startBreak, p) : r2(this._startBreak, p), k2.x += p.x * e5, k2.y += p.y * e5, E2 = t2 ? r2(this._endBreak, M) : x(this._endBreak, M), E2.x += M.x * e5, E2.y += M.y * e5;
          }
          l(D, T3, -p.x, -p.y);
          const W2 = this._writeVertex(b, N, S, j, -p.x, -p.y, T3.x, T3.y, D.x, D.y, q);
          l(D, T3, M.x, M.y);
          const C3 = m ? this._writeVertex(b, N, S, j, M.x, M.y, T3.x, T3.y, D.x, D.y, q) : W2, F2 = g2, G = m ? this._writeVertex(b, N, S, j, M.x, M.y, 0, 0, 0, 0, q) : g2;
          let H = -1, I = -1;
          if (L2 && (l(D, k2, -p.x, -p.y), H = this._writeVertex(b, N, S, j, -p.x, -p.y, k2.x, k2.y, D.x, D.y, q), l(D, E2, M.x, M.y), I = this._writeVertex(b, N, S, j, M.x, M.y, E2.x, E2.y, D.x, D.y, q)), m ? L2 ? (this._writeTriangle(F2, w2, H), this._writeTriangle(F2, H, W2), this._writeTriangle(G, C3, I), this._writeTriangle(G, I, V2)) : (this._writeTriangle(F2, w2, W2), this._writeTriangle(G, C3, V2)) : L2 ? (this._writeTriangle(g2, w2, H), this._writeTriangle(g2, H, I), this._writeTriangle(g2, I, V2)) : (this._writeTriangle(g2, w2, W2), this._writeTriangle(g2, C3, V2)), d2 ? (U = this._writeVertex(b, N, S, j, M.x, M.y, c2.x, c2.y, e4.x, e4.y, q), R = V2) : (U = m ? this._writeVertex(b, N, S, j, M.x, M.y, c2.x, c2.y, e4.x, e4.y, q) : f2, this._writeTriangle(U, G, V2), R = V2), t2) {
            const t3 = U;
            U = R, R = t3;
          }
          break;
        }
      }
    }
  }
};

export {
  i,
  a,
  _
};
//# sourceMappingURL=chunk-VR2ODL2Y.js.map
