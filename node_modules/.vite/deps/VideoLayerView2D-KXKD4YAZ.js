import {
  f as f2
} from "./chunk-I6IVIWWT.js";
import "./chunk-2GCOQTG5.js";
import {
  i as i2
} from "./chunk-H3HJIROX.js";
import "./chunk-KRLDYUK3.js";
import {
  O
} from "./chunk-UQ4NKDVH.js";
import "./chunk-6SXRWZMX.js";
import "./chunk-N3OIGAM3.js";
import "./chunk-E77VVW2C.js";
import "./chunk-PG3227VO.js";
import "./chunk-JGWZMI5Q.js";
import "./chunk-43423NKQ.js";
import {
  b,
  n as n3
} from "./chunk-T5PAMHK6.js";
import {
  d
} from "./chunk-PZZ55S55.js";
import {
  e
} from "./chunk-ALLCMCHO.js";
import "./chunk-NNZE65VM.js";
import "./chunk-RZOWZMPW.js";
import "./chunk-7LPDSYJP.js";
import "./chunk-MJIAJDWR.js";
import {
  h as h3,
  p as p2
} from "./chunk-GHIN7ITM.js";
import {
  p
} from "./chunk-XYIGNG2Z.js";
import "./chunk-BTFBYI67.js";
import "./chunk-D3G5WIRR.js";
import {
  S
} from "./chunk-Q3JOE7TC.js";
import "./chunk-VIDAPS4J.js";
import "./chunk-QTS3W27E.js";
import "./chunk-3RABUJDL.js";
import "./chunk-WJ3E33GQ.js";
import "./chunk-U3B7YMY7.js";
import "./chunk-F75XORHS.js";
import "./chunk-2GRS3IMC.js";
import "./chunk-GVFNGMIY.js";
import "./chunk-RQGBRVDD.js";
import "./chunk-JPZOLUPV.js";
import "./chunk-DRHU543D.js";
import "./chunk-F7RQDGE7.js";
import "./chunk-GG4AQJJO.js";
import "./chunk-OGWYK5MD.js";
import "./chunk-4V63WUXV.js";
import "./chunk-TWE24CRT.js";
import "./chunk-Y3GEZC7J.js";
import "./chunk-U5TTP5E5.js";
import "./chunk-CXUJAI27.js";
import "./chunk-QENBEP2X.js";
import "./chunk-VZQ643XD.js";
import "./chunk-SMJWJAIA.js";
import "./chunk-WFCLXKCE.js";
import "./chunk-FHCV4NTV.js";
import "./chunk-M5JMVUW2.js";
import "./chunk-SIUG2XLL.js";
import "./chunk-XTEXJOLG.js";
import "./chunk-NH6FXYCM.js";
import "./chunk-YE4E5JCT.js";
import "./chunk-SXZO7ULH.js";
import "./chunk-VNSHGTPN.js";
import "./chunk-S5ZM63JC.js";
import "./chunk-XHNYLMJC.js";
import "./chunk-NHFKDWOM.js";
import "./chunk-ALR6N4CF.js";
import "./chunk-4X4BOGIG.js";
import "./chunk-EK7HOTRR.js";
import "./chunk-ODQ5APZK.js";
import "./chunk-BA6HYZ35.js";
import "./chunk-VGXUPJSS.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import "./chunk-IRBX64M6.js";
import "./chunk-EKZRA6TO.js";
import "./chunk-M5SP6ZBM.js";
import "./chunk-2HGIYEIL.js";
import "./chunk-XX3OKYJS.js";
import "./chunk-OTCNIJ2H.js";
import "./chunk-JGA5YJWL.js";
import "./chunk-GCI4MA3M.js";
import "./chunk-SJ2OBYX2.js";
import "./chunk-MDJNYPVI.js";
import "./chunk-Z6VKIQV2.js";
import "./chunk-4PXNA4MD.js";
import "./chunk-IXRRTVLJ.js";
import "./chunk-EKM7KERW.js";
import "./chunk-WKTI47FV.js";
import "./chunk-T3SYSTKO.js";
import "./chunk-6RE6OSTE.js";
import "./chunk-QSGJ3ECU.js";
import "./chunk-LQPKVYW2.js";
import {
  A,
  h as h2
} from "./chunk-U55FA2EK.js";
import "./chunk-GBN36VHC.js";
import "./chunk-B5A4L35M.js";
import "./chunk-52SEOH5H.js";
import "./chunk-JUZ3H47H.js";
import "./chunk-UYMV6HXW.js";
import "./chunk-AJGINJLG.js";
import "./chunk-JE2NJSBU.js";
import "./chunk-QNVJVDYZ.js";
import {
  n
} from "./chunk-WDTGOP77.js";
import "./chunk-VYMBX5H5.js";
import "./chunk-BPTFV5VM.js";
import "./chunk-647DAMHU.js";
import "./chunk-O6G3PPOK.js";
import "./chunk-ZKNZTIAS.js";
import "./chunk-OJMISN3F.js";
import "./chunk-EFV6H5NA.js";
import "./chunk-6VL5D5UP.js";
import "./chunk-6QHY54HZ.js";
import "./chunk-GXJJY3ND.js";
import "./chunk-5ONGWFJ3.js";
import "./chunk-PLNHHGHL.js";
import "./chunk-DFK6QMLO.js";
import "./chunk-4WTOIJXV.js";
import "./chunk-BBYMM7CM.js";
import "./chunk-EM7Y2JZC.js";
import "./chunk-QZQPB5XR.js";
import "./chunk-AQFRVV3U.js";
import {
  n as n2
} from "./chunk-36OXW4YN.js";
import "./chunk-PEL3D3ZN.js";
import "./chunk-Q5KWD3VQ.js";
import "./chunk-BUQC3CLV.js";
import "./chunk-W5S3VUFT.js";
import "./chunk-7YH7T6CS.js";
import "./chunk-3T4IXPP4.js";
import "./chunk-XTZAIV4X.js";
import "./chunk-63LDVRFI.js";
import "./chunk-TJTOV6JD.js";
import {
  _ as _2
} from "./chunk-C3FRY5U4.js";
import "./chunk-JNJX34GB.js";
import "./chunk-3STJRSDT.js";
import "./chunk-67Q6KVC6.js";
import {
  x
} from "./chunk-23NJHA5Q.js";
import "./chunk-4LA6K4VI.js";
import "./chunk-KEZCWFAR.js";
import {
  m as m3
} from "./chunk-JZUJ34RR.js";
import "./chunk-PMGS7UDU.js";
import "./chunk-3GHCGAH2.js";
import "./chunk-HWUOAPTX.js";
import "./chunk-QHCKOBU7.js";
import "./chunk-K2OZ6WVC.js";
import "./chunk-MC6NAKKX.js";
import "./chunk-TF6255HN.js";
import "./chunk-GD4FJL3C.js";
import "./chunk-C5OQVQZF.js";
import {
  u as u3
} from "./chunk-F7DKSAOI.js";
import {
  m as m2
} from "./chunk-4SOQWNPG.js";
import "./chunk-LTULADK2.js";
import "./chunk-35ST7YRB.js";
import "./chunk-EDA5QFHZ.js";
import "./chunk-XL5QPCXN.js";
import {
  W
} from "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-UDHS2MGH.js";
import "./chunk-P6IKJIMO.js";
import "./chunk-MHV23XAQ.js";
import "./chunk-V2X4OKYI.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import "./chunk-MA3QDRC3.js";
import "./chunk-W6J7XCPU.js";
import "./chunk-ONXWBTTM.js";
import "./chunk-T7F6Q6JJ.js";
import "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-7P2ANHQ3.js";
import "./chunk-XCKT47LJ.js";
import "./chunk-3FUHCAX3.js";
import {
  P
} from "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import {
  f,
  h,
  l
} from "./chunk-2OFHDVO5.js";
import "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-5UPBUJPC.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import {
  u as u2
} from "./chunk-CCQFL76O.js";
import {
  i
} from "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import "./chunk-7H3U4IJR.js";
import "./chunk-SMWUT52Z.js";
import {
  _
} from "./chunk-AXZMNHTN.js";
import "./chunk-5T3MJDSR.js";
import "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import {
  m,
  r2 as r
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import {
  o4 as o,
  r2,
  u2 as u
} from "./chunk-GNMPGHLQ.js";
import "./chunk-QY7XKUIV.js";
import "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/OverlayMultipoint.js
var f3 = 2;
var x2 = class extends e {
  constructor(r3) {
    super(), this.element = r3, this._handles = new r(), this.isWrapAround = false, this.perspectiveTransform = n(), this.wrapAroundShift = 0, this.clipGeometry = null, this._handles.add(f(() => this.element, () => {
      const e2 = this.element;
      this.ready(), e2 && this._handles.add(o(e2, "play", () => this.requestRender()));
    }, h));
  }
  getMesh(t) {
    throw new Error("Method not implemented.");
  }
  destroy() {
    super.destroy(), this._handles.destroy(), this.texture = r2(this.texture);
  }
  get textureSize() {
    if (!this.texture) return [1, 1];
    const t = this.texture.descriptor;
    return [t.width, t.height];
  }
  get dvsMat3() {
    return this.parent.dvsMat3;
  }
  beforeRender(t) {
    const e2 = this.element;
    if (null == e2) return;
    const { context: r3 } = t, { videoWidth: i3, videoHeight: s } = e2;
    if (0 !== i3 && 0 !== s) {
      if (this.texture) e2.paused || t.animationsEnabled && this.texture.setData(e2);
      else {
        const t2 = new h2(i3, s);
        t2.wrapMode = 33071, t2.preMultiplyAlpha = true, this.texture = new A(r3, t2, e2);
      }
      e2.paused || this.texture.generateMipmap(), super.beforeRender(t);
    }
  }
  _createTransforms() {
    return null;
  }
  updateDrawCoords(t, e2, r3, i3) {
    const s = this.element, o2 = this._getFrameInfo();
    if (!s || !o2) return;
    const { spatialReference: n4 } = r3;
    this._initializeData(t, o2, n4);
    const { controlPoints: a2, horizon: u4 } = o2, m4 = Math.sqrt(a2.length), d2 = m4, { x: c, y: x3 } = t, y = this._vertices, g = a2[0], w2 = a2[m4 - 1], P2 = a2[(d2 - 1) * m4], _3 = a2[(d2 - 1) * m4 + m4 - 1], v = W(u4 ? u4[0].mapPoint : g.mapPoint, n4), j = W(u4 ? u4[1].mapPoint : w2.mapPoint, n4), M = W(P2.mapPoint, n4), A2 = W(_3.mapPoint, n4);
    this.clipGeometry = u4 ? new n3({ geometry: P.fromJSON({ rings: [[[M.x, M.y], [A2.x, A2.y], [j.x, j.y], [v.x, v.y], [M.x, M.y]]], spatialReference: n4 }) }) : null;
    for (let l2 = 0; l2 < a2.length; l2++) {
      const t2 = a2[l2], { sourcePoint: e3, mapPoint: r4 } = t2;
      if (null == e3 || null == r4) continue;
      const i4 = W(r4, n4);
      y[l2 * f3 + 0] = i4.x - c, y[l2 * f3 + 1] = i4.y - x3;
    }
    let b2 = e2;
    if (i3) {
      const t2 = Math.min(v.x, j.x, M.x, A2.x), e3 = Math.max(v.x, j.x, M.x, A2.x), { worldWidth: r4, xBounds: s2 } = i3, [o3, n5] = s2;
      t2 < o3 && e3 > o3 ? b2 = r4 : e3 > n5 && t2 < n5 && (b2 = -r4);
    }
    this.wrapAroundShift = b2, this.isWrapAround = 0 !== b2;
  }
  draw(t, e2) {
    if (!this.visible) return;
    if (!(this.isReady && this._vertices && this._indices && this._texCoords)) return void this.requestRender();
    this.stage || console.warn("OverlayMultipoint: stage is null"), e2.render(t, { transform: { dvs: this.dvsMat3 }, config: { perspective: this.perspectiveTransform, texSize: this.textureSize, wrapAroundShift: this.wrapAroundShift, isWrapAround: this.isWrapAround, opacity: this.opacity, texture: { texture: this.texture, unit: 0 } }, position: this._vertices, tex: this._texCoords, index: this._indices });
  }
  _initializeData(t, e2, r3) {
    if (null != this._vertices && null != this._indices) return;
    const { controlPoints: i3 } = e2, s = Math.sqrt(i3.length), o2 = s, n4 = new Float32Array(f3 * i3.length), a2 = new Uint16Array(2 * i3.length);
    for (let m4 = 0; m4 < i3.length; m4++) {
      const e3 = i3[m4], { sourcePoint: s2, mapPoint: o3 } = e3;
      if (null == s2 || null == o3) continue;
      const l3 = W(o3, r3);
      n4[m4 * f3 + 0] = l3.x - t.x, n4[m4 * f3 + 1] = l3.y - t.y, a2[2 * m4 + 0] = s2.x, a2[2 * m4 + 1] = s2.y;
    }
    const l2 = new Uint16Array(o2 * s + (o2 - 2) * (s + 2));
    let u4 = 0;
    for (let h4 = 0; h4 < o2; h4++) {
      for (let t2 = 0; t2 < s; t2++) l2[u4++] = h4 * s + t2, l2[u4++] = (h4 + 1) * s + t2;
      h4 < o2 - 2 && (l2[u4++] = (h4 + 1) * s + (s - 1), l2[u4++] = (h4 + 1) * s);
    }
    this._vertices = n4, this._texCoords = a2, this._indices = l2;
  }
  _getFrameInfo() {
    if (!this.groundControlPoints) return null;
    const t = this._getFrameControlPoints(), e2 = this.frameHorizonPoints;
    let r3 = null;
    if (e2) {
      const t2 = e2.startX, i3 = e2.startY, s = e2.endX, n4 = e2.endY;
      r3 = [new p({ sourcePoint: i(t2, i3), mapPoint: new _(e2.startLongitude, e2.startLatitude) }), new p({ sourcePoint: i(s, n4), mapPoint: new _(e2.endLongitude, e2.endLatitude) })];
    }
    return { controlPoints: t, horizon: r3 };
  }
  _getFrameControlPoints() {
    const t = this.groundControlPoints, e2 = t?.length;
    if (!e2) return [];
    const r3 = new Array(e2), i3 = Math.max(...t.map(({ x: t2 }) => t2)), s = this.element.videoWidth / i3;
    for (let n4 = 0; n4 < e2; n4++) {
      const { x: e3, y: i4, lat: l2, lon: h4 } = t[n4];
      r3[n4] = new p({ sourcePoint: i(e3 * s, -i4 * s), mapPoint: new _(h4, l2) });
    }
    return r3;
  }
};

// node_modules/@arcgis/core/views/2d/layers/VideoLayerView2D.js
var L = new u2([255, 127, 0]);
var w = 10005;
var T = 10018;
var O2 = class extends b(d) {
  constructor() {
    super(...arguments), this._graphicsLayer = new n2(), this._frameOutlineGraphic = new _2({ symbol: new m3({ outline: { type: "simple-line", color: L } }) }), this._frameCenterGraphic = new _2({ symbol: new u3({ color: L, style: "cross" }) }), this._sensorTrailGraphic = new _2({ symbol: new m2({ color: L }) }), this._sensorSightlineGraphic = new _2({ symbol: new m2({ color: L }) }), this._sensorLocationGraphic = new _2({ symbol: new u3({ color: L }) }), this._overlayContainer = null, this._sensorLocationSymbolType = null, this.layer = null, this.sensorLocationSymbol = null, this.symbolAngle = 0, this.visibleTelemetryElements = null;
  }
  destroy() {
    this._graphicsLayer = u(this._graphicsLayer);
  }
  initialize() {
    this._sensorLocationSymbolType = this.layer?.sensorSymbol.type, this._graphicsLayer.graphics.addMany([this._frameCenterGraphic, this._frameOutlineGraphic, this._sensorLocationGraphic, this._sensorSightlineGraphic, this._sensorTrailGraphic]), this.visibleTelemetryElements = new p2({ frame: this.layer.telemetryDisplay?.frame ?? false, frameCenter: this.layer.telemetryDisplay?.frameCenter ?? true, frameOutline: this.layer.telemetryDisplay?.frameOutline ?? true, lineOfSight: this.layer.telemetryDisplay?.lineOfSight ?? true, sensorLocation: this.layer.telemetryDisplay?.sensorLocation ?? true, sensorTrail: this.layer.telemetryDisplay?.sensorTrail ?? true });
  }
  attach() {
    this._overlayContainer = new f2(), this.container.addChild(this._overlayContainer), this._addOverlayMultipoint(), this.graphicsView = new O({ requestUpdateCallback: () => this.requestUpdate(), view: this.view, graphics: this._graphicsLayer.graphics, container: new i2(this.view.featuresTilingScheme) }), this.container.addChild(this.graphicsView.container), this.addAttachHandles(this._graphicsLayer.on("graphic-update", this.graphicsView.graphicUpdateHandler)), this.addAttachHandles([l(() => [this.layer.telemetryDisplay?.frame, this.layer.telemetryDisplay?.frameCenter, this.layer.telemetryDisplay?.frameOutline, this.layer.telemetryDisplay?.sensorLocation, this.layer.telemetryDisplay?.sensorTrail, this.layer.telemetryDisplay?.lineOfSight], () => this._updateVisibleTelemetryElements(), h), l(() => [this.layer.telemetry, this.visibleTelemetryElements?.frameCenter, this.visibleTelemetryElements?.frameOutline, this.visibleTelemetryElements?.sensorLocation, this.visibleTelemetryElements?.sensorTrail, this.visibleTelemetryElements?.lineOfSight], () => this._updateGraphicGeometries(), h), l(() => this.layer.metadata, () => this._updateSensorLocationSymbolAngle(), h), l(() => this.layer?.frameCenterSymbol, () => this._updateFrameCenterSymbol(), h), l(() => this.layer?.frameOutlineSymbol, () => this._updateFrameOutlineSymbol(), h), l(() => this.layer?.sensorSightLineSymbol, () => this._updateSensorSightlineSymbol(), h), l(() => this.layer?.sensorSymbol, () => this._updateSensorLocationSymbol(), h), l(() => this.layer?.sensorTrailSymbol, () => this._updateSensorTrailSymbol(), h), l(() => this.symbolAngle, () => this._updateSensorLocationSymbol(), h)]);
  }
  detach() {
    this._overlayContainer.removeAllChildren(), this.container.removeAllChildren(), this.graphicsView = u(this.graphicsView);
  }
  supportsSpatialReference(e2) {
    return true;
  }
  moveEnd() {
  }
  viewChange() {
    this.graphicsView.viewChange();
  }
  update(e2) {
    this.graphicsView.processUpdate(e2);
  }
  isUpdating() {
    return !this.graphicsView || this.graphicsView.updating;
  }
  _updateVisibleTelemetryElements() {
    this.view.animationsEnabled && this.visibleTelemetryElements && this.layer.telemetryDisplay && (this.visibleTelemetryElements.frame = this.layer.telemetryDisplay.frame, this.visibleTelemetryElements.frameCenter = this.layer.telemetryDisplay.frameCenter, this.visibleTelemetryElements.frameOutline = this.layer.telemetryDisplay.frameOutline, this.visibleTelemetryElements.lineOfSight = this.layer.telemetryDisplay.lineOfSight, this.visibleTelemetryElements.sensorLocation = this.layer.telemetryDisplay.sensorLocation, this.visibleTelemetryElements.sensorTrail = this.layer.telemetryDisplay.sensorTrail);
  }
  _updateGraphicGeometries() {
    if (!this.view.animationsEnabled) return;
    const { telemetry: e2 } = this.layer, { visibleTelemetryElements: i3 } = this;
    e2 && i3 && (i3.frameOutline && e2.frameOutline ? this._frameOutlineGraphic.geometry = this.layer.telemetry.frameOutline : this._frameOutlineGraphic.geometry = null, i3.sensorTrail && e2.sensorTrail ? this._sensorTrailGraphic.geometry = this.layer.telemetry.sensorTrail : this._sensorTrailGraphic.geometry = null, i3.lineOfSight && e2.lineOfSight ? this._sensorSightlineGraphic.geometry = this.layer.telemetry.lineOfSight : this._sensorSightlineGraphic.geometry = null, i3.sensorLocation && e2.sensorLocation ? this._sensorLocationGraphic.geometry = this.layer.telemetry.sensorLocation : this._sensorLocationGraphic.geometry = null, i3.frameCenter && e2.frameCenter ? this._frameCenterGraphic.geometry = this.layer.telemetry.frameCenter : this._frameCenterGraphic.geometry = null);
  }
  _updateSensorLocationSymbolAngle() {
    if (!this.view.animationsEnabled) return;
    if (!this.layer?.metadata?.size) return;
    const { source: e2, symbolOffset: i3 = 0 } = this.layer.sensorSymbolOrientation || {};
    if (!e2 && !i3) return;
    const t = this.layer?.metadata?.get(w)?.value ?? 0, s = this.layer?.metadata?.get(T)?.value ?? 0, r3 = h3({ cameraAzimuth: s, platformHeading: t, source: this.layer.sensorSymbolOrientation?.source, symbolOffset: this.layer.sensorSymbolOrientation?.symbolOffset ?? 0 });
    this.symbolAngle = Math.round(Math.abs(r3));
  }
  _updateSensorLocationSymbol() {
    switch (this._sensorLocationSymbolType) {
      case "simple-marker":
        this.sensorLocationSymbol = this.layer.sensorSymbol.clone(), this.sensorLocationSymbol.angle = this.symbolAngle, this._sensorLocationGraphic.symbol = this.sensorLocationSymbol.clone();
        break;
      case "picture-marker":
        this.sensorLocationSymbol = this.layer.sensorSymbol, this.sensorLocationSymbol.angle = this.symbolAngle, this._sensorLocationGraphic.symbol = this.sensorLocationSymbol;
        break;
      case "cim":
        this.sensorLocationSymbol = this.layer.sensorSymbol, S(this.sensorLocationSymbol, this.symbolAngle, true), this._sensorLocationGraphic.symbol = this.sensorLocationSymbol;
    }
  }
  _updateFrameCenterSymbol() {
    this.layer?.frameCenterSymbol && (this._frameCenterGraphic.symbol = this.layer.frameCenterSymbol.clone());
  }
  _updateFrameOutlineSymbol() {
    this.layer?.frameOutlineSymbol && (this._frameOutlineGraphic.symbol = this.layer.frameOutlineSymbol.clone());
  }
  _updateSensorSightlineSymbol() {
    this.layer?.sensorSightLineSymbol && (this._sensorSightlineGraphic.symbol = this.layer.sensorSightLineSymbol.clone());
  }
  _updateSensorTrailSymbol() {
    this.layer?.sensorTrailSymbol && (this._sensorTrailGraphic.symbol = this.layer.sensorTrailSymbol.clone());
  }
  async _addOverlayMultipoint() {
    if (!this.layer.videoElement) return;
    const e2 = new x2(this.layer.videoElement);
    this.addAttachHandles([l(() => [this.layer.frameHorizonPoints, this.layer.groundControlPoints, this.layer.frameOpacity, this.layer.telemetryDisplay?.frame], () => {
      if (!this.view.animationsEnabled) return;
      const { visibleTelemetryElements: i3 } = this;
      e2.frameHorizonPoints = this.layer.frameHorizonPoints, e2.groundControlPoints = this.layer.groundControlPoints, e2.opacity = this.layer.frameOpacity, e2.visible = i3?.frame ?? false;
    }, h)]), this._overlayContainer.addChild(e2), this.view.stage.requestRender();
  }
};
__decorate([m()], O2.prototype, "graphicsView", void 0), __decorate([m()], O2.prototype, "layer", void 0), __decorate([m({ types: x })], O2.prototype, "sensorLocationSymbol", void 0), __decorate([m()], O2.prototype, "symbolAngle", void 0), __decorate([m({ type: p2 })], O2.prototype, "visibleTelemetryElements", void 0), O2 = __decorate([a("esri.views.2d.layers.VideoLayerView2D")], O2);
var C = O2;
export {
  C as default
};
//# sourceMappingURL=VideoLayerView2D-KXKD4YAZ.js.map
