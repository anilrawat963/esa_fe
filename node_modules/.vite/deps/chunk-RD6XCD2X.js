import {
  t as t5
} from "./chunk-O53GWXXZ.js";
import {
  P
} from "./chunk-3RNQTFH6.js";
import {
  m
} from "./chunk-VIIQX37N.js";
import {
  M as M2
} from "./chunk-UR6CZJPX.js";
import {
  t as t3
} from "./chunk-JS3I6GIR.js";
import {
  n as n7,
  o as o4,
  s as s2,
  t as t4
} from "./chunk-T6CRNJ3D.js";
import {
  t as t2
} from "./chunk-ME5HHRVQ.js";
import {
  l2 as l3,
  n as n6,
  o2 as o3
} from "./chunk-Q5ATDQWC.js";
import {
  t
} from "./chunk-KBVQCWWY.js";
import {
  a as a3
} from "./chunk-FNMK6NUG.js";
import {
  n as n4
} from "./chunk-2AOVWXAQ.js";
import {
  A as A2
} from "./chunk-YYXR3KOD.js";
import {
  d as d2,
  o as o2
} from "./chunk-2WMZLC2C.js";
import {
  d,
  l as l2,
  n as n5,
  r as r2
} from "./chunk-HHDWMGJ3.js";
import {
  M,
  O,
  T as T2,
  V,
  g,
  o
} from "./chunk-NDFIZYZY.js";
import {
  u as u2
} from "./chunk-SJ2OBYX2.js";
import {
  a as a2,
  i as i4
} from "./chunk-UYMV6HXW.js";
import {
  r as r3
} from "./chunk-7HTU7ZUX.js";
import {
  a
} from "./chunk-WDTGOP77.js";
import {
  A,
  E,
  I,
  c,
  i as i3,
  r
} from "./chunk-VYMBX5H5.js";
import {
  l,
  q
} from "./chunk-HWUOAPTX.js";
import {
  e as e2
} from "./chunk-K2OZ6WVC.js";
import {
  _
} from "./chunk-XL5QPCXN.js";
import {
  h
} from "./chunk-XLOINTMG.js";
import {
  n,
  u
} from "./chunk-75XOUSSS.js";
import {
  i as i2,
  j,
  n as n2
} from "./chunk-LTPHDYPK.js";
import {
  e,
  n as n3
} from "./chunk-3OVERDFX.js";
import {
  p,
  y
} from "./chunk-GY6YF4EN.js";
import {
  T
} from "./chunk-SMWUT52Z.js";
import {
  H2 as H
} from "./chunk-V2H77UEV.js";
import {
  f2 as f
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/views/3d/glTF/internal/TextureTransformUtils.js
function s3(s5) {
  if (null == s5) return null;
  const a4 = null != s5.offset ? s5.offset : a2, n8 = null != s5.rotation ? s5.rotation : 0, e3 = null != s5.scale ? s5.scale : i4, f2 = n3(1, 0, 0, 0, 1, 0, a4[0], a4[1], 1), c2 = n3(Math.cos(n8), -Math.sin(n8), 0, Math.sin(n8), Math.cos(n8), 0, 0, 0, 1), m2 = n3(e3[0], 0, 0, 0, e3[1], 0, 0, 0, 1), u3 = e();
  return i2(u3, c2, m2), i2(u3, f2, u3), u3;
}

// node_modules/@arcgis/core/views/3d/layers/graphics/ProcessedObjectResource.js
var s4 = class {
  constructor() {
    this.geometries = new Array(), this.materials = new Array(), this.textures = new Array();
  }
};
var t6 = class {
  constructor(t7, e3, r4) {
    this.name = t7, this.lodThreshold = e3, this.pivotOffset = r4, this.stageResources = new s4(), this.numberOfVertices = 0;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/wosrLoader.js
var w = () => i.getLogger("esri.views.3d.layers.graphics.objectResourceUtils");
var x = class {
  constructor(e3, t7, r4) {
    this.resource = e3, this.textures = t7, this.usedMemory = r4;
  }
};
async function h2(e3, t7) {
  const r4 = await b(e3, t7), n8 = await U(r4.textureDefinitions ?? {}, t7);
  let o5 = 0;
  for (const s5 in n8) if (n8.hasOwnProperty(s5)) {
    const e4 = n8[s5];
    o5 += e4?.image ? e4.image.width * e4.image.height * 4 : 0;
  }
  return new x(r4, n8, o5 + u2(r4));
}
async function b(r4, n8) {
  const s5 = n8?.streamDataRequester;
  if (s5) return v(r4, s5, n8);
  const o5 = await _(H(r4, n8));
  if (true === o5.ok) return o5.value.data;
  f(o5.error), A3(o5.error);
}
async function v(e3, r4, n8) {
  const s5 = await _(r4.request(e3, 0, n8));
  if (true === s5.ok) return s5.value;
  f(s5.error), A3(s5.error.details.url);
}
function A3(e3) {
  throw new s("", `Request for object resource failed: ${e3}`);
}
function j2(e3) {
  const t7 = e3.params, r4 = t7.topology;
  let n8 = true;
  switch (t7.vertexAttributes || (w().warn("Geometry must specify vertex attributes"), n8 = false), t7.topology) {
    case "PerAttributeArray":
      break;
    case "Indexed":
    case null:
    case void 0: {
      const e4 = t7.faces;
      if (e4) {
        if (t7.vertexAttributes) for (const r5 in t7.vertexAttributes) {
          const t8 = e4[r5];
          t8?.values ? (null != t8.valueType && "UInt32" !== t8.valueType && (w().warn(`Unsupported indexed geometry indices type '${t8.valueType}', only UInt32 is currently supported`), n8 = false), null != t8.valuesPerElement && 1 !== t8.valuesPerElement && (w().warn(`Unsupported indexed geometry values per element '${t8.valuesPerElement}', only 1 is currently supported`), n8 = false)) : (w().warn(`Indexed geometry does not specify face indices for '${r5}' attribute`), n8 = false);
        }
      } else w().warn("Indexed geometries must specify faces"), n8 = false;
      break;
    }
    default:
      w().warn(`Unsupported topology '${r4}'`), n8 = false;
  }
  e3.params.material || (w().warn("Geometry requires material"), n8 = false);
  const s5 = e3.params.vertexAttributes;
  for (const o5 in s5) {
    s5[o5].values || (w().warn("Geometries with externally defined attributes are not yet supported"), n8 = false);
  }
  return n8;
}
function M3(e3, t7) {
  const r4 = new Array(), n8 = new Array(), s5 = new Array(), a4 = new t5(), u3 = e3.resource, c2 = r3.parse(u3.version || "1.0", "wosr");
  k.validate(c2);
  const p2 = u3.model.name, w2 = u3.model.geometries, x2 = u3.materialDefinitions ?? {}, h3 = e3.textures;
  let b2 = 0;
  const v2 = /* @__PURE__ */ new Map();
  for (let o5 = 0; o5 < w2.length; o5++) {
    const e4 = w2[o5];
    if (!j2(e4)) continue;
    const i5 = E2(e4), u4 = e4.params.vertexAttributes, c3 = [], p3 = (t8) => {
      if ("PerAttributeArray" === e4.params.topology) return null;
      const r5 = e4.params.faces;
      for (const e5 in r5) if (e5 === t8) return r5[e5].values;
      return null;
    }, A4 = u4.position, M4 = A4.values.length / A4.valuesPerElement;
    for (const t8 in u4) {
      const e5 = u4[t8], r5 = e5.values, n9 = p3(t8) ?? A2(M4);
      c3.push([t8, new t2(r5, n9, e5.valuesPerElement, true)]);
    }
    const P3 = i5.texture, U2 = h3 && h3[P3];
    if (U2 && !v2.has(P3)) {
      const { image: e5, parameters: t8 } = U2, r5 = new M2(e5, t8);
      n8.push(r5), v2.set(P3, r5);
    }
    const k2 = v2.get(P3), T3 = k2 ? k2.id : void 0, q2 = i5.material;
    let O2 = a4.get(q2, P3);
    if (null == O2) {
      const e5 = x2[q2.slice(q2.lastIndexOf("/") + 1)].params;
      1 === e5.transparency && (e5.transparency = 0);
      const r5 = U2 ? I2(U2.alphaChannelUsage) : void 0, n9 = { ambient: u(e5.diffuse), diffuse: u(e5.diffuse), opacity: 1 - (e5.transparency || 0), textureAlphaMode: r5, textureAlphaCutoff: 0.33, textureId: T3, doubleSided: true, cullFace: 0, colorMixMode: e5.externalColorMixMode || "tint", textureAlphaPremultiplied: U2?.parameters.preMultiplyAlpha ?? false };
      t7?.materialParameters && Object.assign(n9, t7.materialParameters), O2 = new P(n9, t7), a4.set(q2, P3, O2);
    }
    s5.push(O2);
    const C = new m(O2, c3);
    b2 += c3.find((e5) => "position" === e5[0])?.[1]?.indices.length ?? 0, r4.push(C);
  }
  return { engineResources: [{ name: p2, stageResources: { textures: n8, materials: s5, geometries: r4 }, pivotOffset: u3.model.pivotOffset, numberOfVertices: b2, lodThreshold: null }], referenceBoundingBox: P2(r4) };
}
function P2(e3) {
  const t7 = q();
  return e3.forEach((e4) => {
    const r4 = e4.boundingInfo;
    null != r4 && (l(t7, r4.bbMin), l(t7, r4.bbMax));
  }), t7;
}
async function U(e3, t7) {
  const r4 = new Array();
  for (const o5 in e3) {
    const n9 = e3[o5], s6 = n9.images[0].data;
    if (!s6) {
      w().warn("Externally referenced texture data is not yet supported");
      continue;
    }
    const a4 = n9.encoding + ";base64," + s6, i5 = "/textureDefinitions/" + o5, l4 = "rgba" === n9.channels ? n9.alphaChannelUsage || "transparency" : "none", u3 = { noUnpackFlip: true, wrap: { s: 10497, t: 10497 }, preMultiplyAlpha: 1 !== I2(l4) }, c2 = t7?.disableTextures ? Promise.resolve(null) : t3(a4, t7);
    r4.push(c2.then((e4) => ({ refId: i5, image: e4, parameters: u3, alphaChannelUsage: l4 })));
  }
  const n8 = await Promise.all(r4), s5 = {};
  for (const o5 of n8) s5[o5.refId] = o5;
  return s5;
}
function I2(e3) {
  switch (e3) {
    case "mask":
      return 2;
    case "maskAndTransparency":
      return 3;
    case "none":
      return 1;
    default:
      return 0;
  }
}
function E2(e3) {
  const t7 = e3.params;
  return { id: 1, material: t7.material, texture: t7.texture, region: t7.texture };
}
var k = new r3(1, 2, "wosr");

// node_modules/@arcgis/core/views/3d/layers/graphics/objectResourceUtils.js
async function z(e3, r4) {
  const o5 = K(a3(e3));
  if ("wosr" === o5.fileType) {
    const e4 = await (r4.cache ? r4.cache.loadWOSR(o5.url, r4) : h2(o5.url, r4)), { engineResources: t7, referenceBoundingBox: s6 } = M3(e4, r4);
    return { lods: t7, referenceBoundingBox: s6, isEsriSymbolResource: false, isWosr: true };
  }
  let s5;
  if (r4.cache) s5 = await r4.cache.loadGLTF(o5.url, r4, !!r4.usePBR);
  else {
    const { loadGLTF: e4 } = await import("./loader-S6MSISOI.js");
    s5 = await e4(new l3(r4.streamDataRequester), o5.url, r4, r4.usePBR);
  }
  const i5 = s5.model.meta?.ESRI_proxyEllipsoid, n8 = s5.meta.isEsriSymbolResource && null != i5 && "EsriRealisticTreesStyle" === s5.meta.ESRI_webstyle;
  n8 && !s5.customMeta.esriTreeRendering && (s5.customMeta.esriTreeRendering = true, re(s5, i5));
  const l4 = !!r4.usePBR, a4 = s5.meta.isEsriSymbolResource ? { usePBR: l4, isSchematic: false, treeRendering: n8, mrrFactors: s2 } : { usePBR: l4, isSchematic: false, treeRendering: false, mrrFactors: t4 }, u3 = { ...r4.materialParameters, treeRendering: n8 }, { engineResources: c2, referenceBoundingBox: m2 } = J(s5, a4, u3, r4, o5.specifiedLodIndex, n8);
  return { lods: c2, referenceBoundingBox: m2, isEsriSymbolResource: s5.meta.isEsriSymbolResource, isWosr: false };
}
function K(e3) {
  const r4 = e3.match(/(.*\.(gltf|glb))(\?lod=([0-9]+))?$/);
  if (r4) return { fileType: "gltf", url: r4[1], specifiedLodIndex: null != r4[4] ? Number(r4[4]) : null };
  return e3.match(/(.*\.(json|json\.gz))$/) ? { fileType: "wosr", url: e3, specifiedLodIndex: null } : { fileType: "unknown", url: e3, specifiedLodIndex: null };
}
function J(e3, r4, t7, o5, s5, i5) {
  const n8 = e3.model, l4 = new Array(), a4 = /* @__PURE__ */ new Map(), u3 = /* @__PURE__ */ new Map(), c2 = n8.lods.length, m2 = q();
  return n8.lods.forEach((e4, f2) => {
    const d3 = true === o5.skipHighLods && (c2 > 1 && 0 === f2 || c2 > 3 && 1 === f2) || false === o5.skipHighLods && null != s5 && f2 !== s5;
    if (d3 && 0 !== f2) return;
    const p2 = new t6(e4.name, e4.lodThreshold, [0, 0, 0]);
    e4.parts.forEach((e5) => {
      const s6 = d3 ? new P({}, o5) : X(n8, e5, p2, r4, t7, a4, u3, o5, i5), { geometry: l5, vertexCount: c3 } = Y(e5, s6 ?? new P({}, o5)), g2 = l5.boundingInfo;
      null != g2 && 0 === f2 && (l(m2, g2.bbMin), l(m2, g2.bbMax)), null != s6 && (p2.stageResources.geometries.push(l5), p2.numberOfVertices += c3);
    }), d3 || l4.push(p2);
  }), { engineResources: l4, referenceBoundingBox: m2 };
}
function X(e3, t7, o5, s5, i5, n8, l4, a4, c2) {
  const m2 = e3.materials.get(t7.material);
  if (null == m2) return null;
  const { normal: f2, color: d3, texCoord0: p2, tangent: g2 } = t7.attributes, x2 = t7.material + (f2 ? "_normal" : "") + (d3 ? "_color" : "") + (p2 ? "_texCoord0" : "") + (g2 ? "_tangent" : ""), T3 = null != t7.attributes.texCoord0, b2 = null != t7.attributes.normal, h3 = ee(m2.alphaMode);
  if (!n8.has(x2)) {
    if (T3) {
      const r4 = (r5, t9 = false, o7 = false) => {
        if (null != r5 && !l4.has(r5)) {
          const s6 = e3.textures.get(r5);
          if (s6) {
            const e4 = s6.data, i6 = t9 && !t(e4) ? a4.compressionOptions : void 0;
            l4.set(r5, new M2(t(e4) ? e4.data : e4, { ...s6.parameters, preMultiplyAlpha: !t(e4) && o7, encoding: t(e4) ? e4.encoding : void 0, compressionOptions: i6 }));
          }
        }
      }, t8 = 1 !== h3 && !c2;
      r4(m2.colorTexture, t8, 1 !== h3), r4(m2.normalTexture), r4(m2.occlusionTexture, true), r4(m2.emissiveTexture), r4(m2.metallicRoughnessTexture, true);
    }
    const o6 = y(m2.color[0]), f3 = y(m2.color[1]), d4 = y(m2.color[2]), p3 = null != m2.colorTexture && T3 ? l4.get(m2.colorTexture) : null, g3 = n7(m2), y3 = null != m2.normalTextureTransform?.scale ? m2.normalTextureTransform?.scale : a;
    n8.set(x2, new P({ ...s5, customDepthTest: 1, textureAlphaMode: h3, textureAlphaCutoff: m2.alphaCutoff, diffuse: [o6, f3, d4], ambient: [o6, f3, d4], opacity: "OPAQUE" === m2.alphaMode ? 1 : m2.opacity, doubleSided: m2.doubleSided, doubleSidedType: "winding-order", cullFace: m2.doubleSided ? 0 : 2, hasVertexColors: !!t7.attributes.color, hasVertexTangents: !!t7.attributes.tangent, normalType: b2 ? 0 : 2, castShadows: true, receiveShadows: m2.receiveShadows, receiveAmbientOcclusion: m2.receiveAmbientOcclusion, textureId: null != p3 ? p3.id : void 0, colorMixMode: m2.colorMixMode, normalTextureId: null != m2.normalTexture && T3 ? l4.get(m2.normalTexture).id : void 0, textureAlphaPremultiplied: null != p3 && !!p3.parameters.preMultiplyAlpha, occlusionTextureId: null != m2.occlusionTexture && T3 ? l4.get(m2.occlusionTexture).id : void 0, emissiveTextureId: null != m2.emissiveTexture && T3 ? l4.get(m2.emissiveTexture).id : void 0, metallicRoughnessTextureId: null != m2.metallicRoughnessTexture && T3 ? l4.get(m2.metallicRoughnessTexture).id : void 0, emissiveBaseColor: [m2.emissiveFactor[0], m2.emissiveFactor[1], m2.emissiveFactor[2]], mrrFactors: g3 ? o4 : [m2.metallicFactor, m2.roughnessFactor, s5.mrrFactors[2]], isSchematic: g3, colorTextureTransformMatrix: s3(m2.colorTextureTransform), normalTextureTransformMatrix: s3(m2.normalTextureTransform), scale: [y3[0], y3[1]], occlusionTextureTransformMatrix: s3(m2.occlusionTextureTransform), emissiveTextureTransformMatrix: s3(m2.emissiveTextureTransform), metallicRoughnessTextureTransformMatrix: s3(m2.metallicRoughnessTextureTransform), ...i5 }, a4));
  }
  const y2 = n8.get(x2);
  if (o5.stageResources.materials.push(y2), T3) {
    const e4 = (e5) => {
      null != e5 && o5.stageResources.textures.push(l4.get(e5));
    };
    e4(m2.colorTexture), e4(m2.normalTexture), e4(m2.occlusionTexture), e4(m2.emissiveTexture), e4(m2.metallicRoughnessTexture);
  }
  return y2;
}
function Y(e3, r4) {
  const t7 = e3.attributes.position.count, n8 = o3(e3.indices || t7, e3.primitiveType), l4 = n4(3 * t7), { typedBuffer: a4, typedBufferStride: u3 } = e3.attributes.position;
  r2(l4, a4, e3.transform, 3, u3);
  const c2 = [["position", new t2(l4, n8, 3, true)]];
  if (null != e3.attributes.normal) {
    const r5 = n4(3 * t7), { typedBuffer: i5, typedBufferStride: l5 } = e3.attributes.normal;
    j(Z, e3.transform), n5(r5, i5, Z, 3, l5), T(Z) && d(r5, r5), c2.push(["normal", new t2(r5, n8, 3, true)]);
  }
  if (null != e3.attributes.tangent) {
    const r5 = n4(4 * t7), { typedBuffer: s5, typedBufferStride: l5 } = e3.attributes.tangent;
    n2(Z, e3.transform), o2(r5, s5, Z, 4, l5), T(Z) && d(r5, r5, 4), c2.push(["tangent", new t2(r5, n8, 4, true)]);
  }
  if (null != e3.attributes.texCoord0) {
    const r5 = n4(2 * t7), { typedBuffer: o5, typedBufferStride: s5 } = e3.attributes.texCoord0;
    n6(r5, o5, 2, s5), c2.push(["uv0", new t2(r5, n8, 2, true)]);
  }
  const m2 = e3.attributes.color;
  if (null != m2) {
    const r5 = new Uint8Array(4 * t7);
    4 === m2.elementCount ? m2 instanceof T2 ? d2(r5, m2, 1, 255) : (m2 instanceof g || m2 instanceof M) && d2(r5, m2, 1 / 255, 255) : (r5.fill(255), m2 instanceof o ? l2(r5, m2.typedBuffer, 1, 255, 4, m2.typedBufferStride) : (e3.attributes.color instanceof O || e3.attributes.color instanceof V) && l2(r5, m2.typedBuffer, 1 / 255, 255, 4, e3.attributes.color.typedBufferStride)), c2.push(["color", new t2(r5, n8, 4, true)]);
  }
  return { geometry: new m(r4, c2), vertexCount: t7 };
}
var Z = e();
function ee(e3) {
  switch (e3) {
    case "BLEND":
      return 0;
    case "MASK":
      return 2;
    case "OPAQUE":
    case null:
    case void 0:
      return 1;
  }
}
function re(r4, t7) {
  for (let o5 = 0; o5 < r4.model.lods.length; ++o5) {
    const s5 = r4.model.lods[o5];
    for (const i5 of s5.parts) {
      const s6 = i5.attributes.normal;
      if (null == s6) return;
      const n8 = i5.attributes.position, u3 = n8.count, T3 = n(), b2 = n(), h3 = n(), v2 = new Float32Array(4 * u3), R = new Float32Array(3 * u3), B = h(e2(), i5.transform);
      let j3 = 0, S = 0;
      for (let l4 = 0; l4 < u3; l4++) {
        n8.getVec(l4, b2), s6.getVec(l4, T3), E(b2, b2, i5.transform), c(h3, b2, t7.center), i3(h3, h3, t7.radius);
        const a4 = h3[2], u4 = r(h3), x2 = Math.min(0.45 + 0.55 * u4 * u4, 1) ** p;
        i3(h3, h3, t7.radius), null !== B && E(h3, h3, B), A(h3, h3), o5 + 1 !== r4.model.lods.length && r4.model.lods.length > 1 && I(h3, h3, T3, a4 > -1 ? 0.2 : Math.min(-4 * a4 - 3.8, 1)), R[j3] = h3[0], R[j3 + 1] = h3[1], R[j3 + 2] = h3[2], j3 += 3, v2[S] = x2, v2[S + 1] = x2, v2[S + 2] = x2, v2[S + 3] = 1, S += 4;
      }
      i5.attributes.normal = new o(R.buffer), i5.attributes.color = new T2(v2.buffer);
    }
  }
}

export {
  s3 as s,
  z,
  K
};
//# sourceMappingURL=chunk-RD6XCD2X.js.map
