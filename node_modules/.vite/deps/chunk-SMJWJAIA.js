import {
  u
} from "./chunk-OPJX4KXH.js";

// node_modules/@arcgis/core/geometry/support/TileClipper.js
var t = 512;
var i = class _i {
  constructor(t2, i3) {
    this.x = t2, this.y = i3;
  }
  static fromArray(t2) {
    return new _i(t2[0], t2[1]);
  }
  clone() {
    return new _i(this.x, this.y);
  }
  equals(t2, i3) {
    return t2 === this.x && i3 === this.y;
  }
  isEqual(t2) {
    return t2.x === this.x && t2.y === this.y;
  }
  setCoords(t2, i3) {
    return this.x = t2, this.y = i3, this;
  }
  normalize() {
    const t2 = this.x, i3 = this.y, s3 = Math.sqrt(t2 * t2 + i3 * i3);
    return this.x /= s3, this.y /= s3, this;
  }
  rightPerpendicular() {
    const t2 = this.x;
    return this.x = this.y, this.y = -t2, this;
  }
  leftPerpendicular() {
    const t2 = this.x;
    return this.x = -this.y, this.y = t2, this;
  }
  move(t2, i3) {
    return this.x += t2, this.y += i3, this;
  }
  assign(t2) {
    return this.x = t2.x, this.y = t2.y, this;
  }
  assignAdd(t2, i3) {
    return this.x = t2.x + i3.x, this.y = t2.y + i3.y, this;
  }
  assignSub(t2, i3) {
    return this.x = t2.x - i3.x, this.y = t2.y - i3.y, this;
  }
  rotate(t2, i3) {
    const s3 = this.x, h3 = this.y;
    return this.x = s3 * t2 - h3 * i3, this.y = s3 * i3 + h3 * t2, this;
  }
  rotateReverse(t2, i3) {
    const s3 = this.x, h3 = this.y;
    return this.x = s3 * t2 + h3 * i3, this.y = -s3 * i3 + h3 * t2, this;
  }
  scale(t2) {
    return this.x *= t2, this.y *= t2, this;
  }
  length() {
    const t2 = this.x, i3 = this.y;
    return Math.sqrt(t2 * t2 + i3 * i3);
  }
  sub(t2) {
    return this.x -= t2.x, this.y -= t2.y, this;
  }
  add(t2) {
    return this.x += t2.x, this.y += t2.y, this;
  }
  static distance(t2, i3) {
    const s3 = i3.x - t2.x, h3 = i3.y - t2.y;
    return Math.sqrt(s3 * s3 + h3 * h3);
  }
  static add(t2, s3) {
    return new _i(t2.x + s3.x, t2.y + s3.y);
  }
  static sub(t2, s3) {
    return new _i(t2.x - s3.x, t2.y - s3.y);
  }
};
var s = class {
  constructor(t2, i3, s3) {
    this.ratio = t2, this.x = i3, this.y = s3;
  }
};
var h = class {
  constructor(i3, s3, h3, n2 = 8, e3 = 8) {
    this._lines = [], this._starts = [], this.validateTessellation = true, this._pixelRatio = n2, this._pixelMargin = e3, this._tileSize = t * n2, this._dz = i3, this._yPos = s3, this._xPos = h3;
  }
  setPixelMargin(t2) {
    t2 !== this._pixelMargin && (this._pixelMargin = t2, this.setExtent(this._extent));
  }
  setExtent(t2) {
    this._extent = t2, this._finalRatio = this._tileSize / t2 * (1 << this._dz);
    let i3 = this._pixelRatio * this._pixelMargin;
    i3 /= this._finalRatio;
    const s3 = t2 >> this._dz;
    i3 > s3 && (i3 = s3), this._margin = i3, this._xmin = s3 * this._xPos - i3, this._ymin = s3 * this._yPos - i3, this._xmax = this._xmin + s3 + 2 * i3, this._ymax = this._ymin + s3 + 2 * i3;
  }
  reset(t2) {
    this._type = t2, this._lines = [], this._starts = [], this._line = null, this._start = 0;
  }
  moveTo(t2, s3) {
    this._pushLine(), this._prevIsIn = this._isIn(t2, s3), this._moveTo(t2, s3, this._prevIsIn), this._prevPt = new i(t2, s3), this._firstPt = new i(t2, s3), this._dist = 0;
  }
  lineTo(t2, h3) {
    const n2 = this._isIn(t2, h3), e3 = new i(t2, h3), _2 = i.distance(this._prevPt, e3);
    let x2, l2, a2, y2, r2, o2, u3, m;
    if (n2) this._prevIsIn ? this._lineTo(t2, h3, true) : (x2 = this._prevPt, l2 = e3, a2 = this._intersect(l2, x2), this._start = this._dist + _2 * (1 - this._r), this._lineTo(a2.x, a2.y, true), this._lineTo(l2.x, l2.y, true));
    else if (this._prevIsIn) l2 = this._prevPt, x2 = e3, a2 = this._intersect(l2, x2), this._lineTo(a2.x, a2.y, true), this._lineTo(x2.x, x2.y, false);
    else {
      const t3 = this._prevPt, i3 = e3;
      if (t3.x <= this._xmin && i3.x <= this._xmin || t3.x >= this._xmax && i3.x >= this._xmax || t3.y <= this._ymin && i3.y <= this._ymin || t3.y >= this._ymax && i3.y >= this._ymax) this._lineTo(i3.x, i3.y, false);
      else {
        const h4 = [];
        if ((t3.x < this._xmin && i3.x > this._xmin || t3.x > this._xmin && i3.x < this._xmin) && (y2 = (this._xmin - t3.x) / (i3.x - t3.x), m = t3.y + y2 * (i3.y - t3.y), m <= this._ymin ? o2 = false : m >= this._ymax ? o2 = true : h4.push(new s(y2, this._xmin, m))), (t3.x < this._xmax && i3.x > this._xmax || t3.x > this._xmax && i3.x < this._xmax) && (y2 = (this._xmax - t3.x) / (i3.x - t3.x), m = t3.y + y2 * (i3.y - t3.y), m <= this._ymin ? o2 = false : m >= this._ymax ? o2 = true : h4.push(new s(y2, this._xmax, m))), (t3.y < this._ymin && i3.y > this._ymin || t3.y > this._ymin && i3.y < this._ymin) && (y2 = (this._ymin - t3.y) / (i3.y - t3.y), u3 = t3.x + y2 * (i3.x - t3.x), u3 <= this._xmin ? r2 = false : u3 >= this._xmax ? r2 = true : h4.push(new s(y2, u3, this._ymin))), (t3.y < this._ymax && i3.y > this._ymax || t3.y > this._ymax && i3.y < this._ymax) && (y2 = (this._ymax - t3.y) / (i3.y - t3.y), u3 = t3.x + y2 * (i3.x - t3.x), u3 <= this._xmin ? r2 = false : u3 >= this._xmax ? r2 = true : h4.push(new s(y2, u3, this._ymax))), 0 === h4.length) r2 ? o2 ? this._lineTo(this._xmax, this._ymax, true) : this._lineTo(this._xmax, this._ymin, true) : o2 ? this._lineTo(this._xmin, this._ymax, true) : this._lineTo(this._xmin, this._ymin, true);
        else if (h4.length > 1 && h4[0].ratio > h4[1].ratio) this._start = this._dist + _2 * h4[1].ratio, this._lineTo(h4[1].x, h4[1].y, true), this._lineTo(h4[0].x, h4[0].y, true);
        else {
          this._start = this._dist + _2 * h4[0].ratio;
          for (let t4 = 0; t4 < h4.length; t4++) this._lineTo(h4[t4].x, h4[t4].y, true);
        }
        this._lineTo(i3.x, i3.y, false);
      }
    }
    this._dist += _2, this._prevIsIn = n2, this._prevPt = e3;
  }
  close() {
    if (this._line.length > 2) {
      const t2 = this._firstPt, i3 = this._prevPt;
      t2.x === i3.x && t2.y === i3.y || this.lineTo(t2.x, t2.y);
      const s3 = this._line;
      let h3 = s3.length;
      for (; h3 >= 4 && (s3[0].x === s3[1].x && s3[0].x === s3[h3 - 2].x || s3[0].y === s3[1].y && s3[0].y === s3[h3 - 2].y); ) s3.pop(), s3[0].x = s3[h3 - 2].x, s3[0].y = s3[h3 - 2].y, --h3;
    }
  }
  result(t2 = true) {
    return this._pushLine(), 0 === this._lines.length ? null : (3 === this._type && t2 && e.simplify(this._tileSize, this._margin * this._finalRatio, this._lines), this._lines);
  }
  resultWithStarts() {
    if (2 !== this._type) throw new Error("Only valid for lines");
    this._pushLine();
    const t2 = this._lines, i3 = t2.length;
    if (0 === i3) return null;
    const s3 = [];
    for (let h3 = 0; h3 < i3; h3++) s3.push({ line: t2[h3], start: this._starts[h3] || 0 });
    return s3;
  }
  _isIn(t2, i3) {
    return t2 >= this._xmin && t2 <= this._xmax && i3 >= this._ymin && i3 <= this._ymax;
  }
  _intersect(t2, s3) {
    let h3, n2, e3;
    if (s3.x >= this._xmin && s3.x <= this._xmax) n2 = s3.y <= this._ymin ? this._ymin : this._ymax, e3 = (n2 - t2.y) / (s3.y - t2.y), h3 = t2.x + e3 * (s3.x - t2.x);
    else if (s3.y >= this._ymin && s3.y <= this._ymax) h3 = s3.x <= this._xmin ? this._xmin : this._xmax, e3 = (h3 - t2.x) / (s3.x - t2.x), n2 = t2.y + e3 * (s3.y - t2.y);
    else {
      n2 = s3.y <= this._ymin ? this._ymin : this._ymax, h3 = s3.x <= this._xmin ? this._xmin : this._xmax;
      const i3 = (h3 - t2.x) / (s3.x - t2.x), _2 = (n2 - t2.y) / (s3.y - t2.y);
      i3 < _2 ? (e3 = i3, n2 = t2.y + i3 * (s3.y - t2.y)) : (e3 = _2, h3 = t2.x + _2 * (s3.x - t2.x));
    }
    return this._r = e3, new i(h3, n2);
  }
  _pushLine() {
    this._line && (1 === this._type ? this._line.length > 0 && (this._lines.push(this._line), this._starts.push(this._start)) : 2 === this._type ? this._line.length > 1 && (this._lines.push(this._line), this._starts.push(this._start)) : 3 === this._type && this._line.length > 3 && (this._lines.push(this._line), this._starts.push(this._start))), this._line = [], this._start = 0;
  }
  _moveTo(t2, s3, h3) {
    3 !== this._type ? h3 && (t2 = Math.round((t2 - (this._xmin + this._margin)) * this._finalRatio), s3 = Math.round((s3 - (this._ymin + this._margin)) * this._finalRatio), this._line.push(new i(t2, s3))) : (h3 || (t2 < this._xmin && (t2 = this._xmin), t2 > this._xmax && (t2 = this._xmax), s3 < this._ymin && (s3 = this._ymin), s3 > this._ymax && (s3 = this._ymax)), t2 = Math.round((t2 - (this._xmin + this._margin)) * this._finalRatio), s3 = Math.round((s3 - (this._ymin + this._margin)) * this._finalRatio), this._line.push(new i(t2, s3)), this._isH = false, this._isV = false);
  }
  _lineTo(t2, s3, h3) {
    let n2, e3;
    if (3 !== this._type) if (h3) {
      if (t2 = Math.round((t2 - (this._xmin + this._margin)) * this._finalRatio), s3 = Math.round((s3 - (this._ymin + this._margin)) * this._finalRatio), this._line.length > 0 && (n2 = this._line[this._line.length - 1], n2.equals(t2, s3))) return;
      this._line.push(new i(t2, s3));
    } else this._line && this._line.length > 0 && this._pushLine();
    else if (h3 || (t2 < this._xmin && (t2 = this._xmin), t2 > this._xmax && (t2 = this._xmax), s3 < this._ymin && (s3 = this._ymin), s3 > this._ymax && (s3 = this._ymax)), t2 = Math.round((t2 - (this._xmin + this._margin)) * this._finalRatio), s3 = Math.round((s3 - (this._ymin + this._margin)) * this._finalRatio), this._line && this._line.length > 0) {
      n2 = this._line[this._line.length - 1];
      const h4 = n2.x === t2, _2 = n2.y === s3;
      if (h4 && _2) return;
      this._isH && h4 || this._isV && _2 ? (n2.x = t2, n2.y = s3, e3 = this._line[this._line.length - 2], e3.x === t2 && e3.y === s3 ? (this._line.pop(), this._line.length <= 1 ? (this._isH = false, this._isV = false) : (e3 = this._line[this._line.length - 2], this._isH = e3.x === t2, this._isV = e3.y === s3)) : (this._isH = e3.x === t2, this._isV = e3.y === s3)) : (this._line.push(new i(t2, s3)), this._isH = h4, this._isV = _2);
    } else this._line.push(new i(t2, s3));
  }
};
var n = class {
  setExtent(t2) {
    this._ratio = 4096 === t2 ? 1 : 4096 / t2;
  }
  get validateTessellation() {
    return this._ratio < 1;
  }
  reset(t2) {
    this._lines = [], this._line = null;
  }
  moveTo(t2, s3) {
    this._line && this._lines.push(this._line), this._line = [];
    const h3 = this._ratio;
    this._line.push(new i(t2 * h3, s3 * h3));
  }
  lineTo(t2, s3) {
    const h3 = this._ratio;
    this._line.push(new i(t2 * h3, s3 * h3));
  }
  close() {
    const t2 = this._line;
    t2 && !t2[0].isEqual(t2[t2.length - 1]) && t2.push(t2[0]);
  }
  result() {
    return this._line && this._lines.push(this._line), 0 === this._lines.length ? null : this._lines;
  }
};
var e = class _e {
  static simplify(t2, i3, s3) {
    if (!s3) return;
    const h3 = -i3, n2 = t2 + i3, _2 = -i3, x2 = t2 + i3, l2 = [], a2 = [], y2 = s3.length;
    for (let e3 = 0; e3 < y2; ++e3) {
      const t3 = s3[e3];
      if (!t3 || t3.length < 2) continue;
      let i4, y3 = t3[0];
      const r3 = t3.length;
      for (let s4 = 1; s4 < r3; ++s4) i4 = t3[s4], y3.x === i4.x && (y3.x <= h3 && (y3.y > i4.y ? (l2.push(e3), l2.push(s4), l2.push(0), l2.push(-1)) : (a2.push(e3), a2.push(s4), a2.push(0), a2.push(-1))), y3.x >= n2 && (y3.y < i4.y ? (l2.push(e3), l2.push(s4), l2.push(1), l2.push(-1)) : (a2.push(e3), a2.push(s4), a2.push(1), a2.push(-1)))), y3.y === i4.y && (y3.y <= _2 && (y3.x < i4.x ? (l2.push(e3), l2.push(s4), l2.push(2), l2.push(-1)) : (a2.push(e3), a2.push(s4), a2.push(2), a2.push(-1))), y3.y >= x2 && (y3.x > i4.x ? (l2.push(e3), l2.push(s4), l2.push(3), l2.push(-1)) : (a2.push(e3), a2.push(s4), a2.push(3), a2.push(-1)))), y3 = i4;
    }
    if (0 === l2.length || 0 === a2.length) return;
    _e.fillParent(s3, a2, l2), _e.fillParent(s3, l2, a2);
    const r2 = [];
    _e.calcDeltas(r2, a2, l2), _e.calcDeltas(r2, l2, a2), _e.addDeltas(r2, s3);
  }
  static fillParent(t2, i3, s3) {
    const h3 = s3.length, n2 = i3.length;
    for (let e3 = 0; e3 < n2; e3 += 4) {
      const n3 = i3[e3], x2 = i3[e3 + 1], l2 = i3[e3 + 2], a2 = t2[n3][x2 - 1], y2 = t2[n3][x2];
      let r2 = 8092, o2 = -1;
      for (let i4 = 0; i4 < h3; i4 += 4) {
        if (s3[i4 + 2] !== l2) continue;
        const h4 = s3[i4], n4 = s3[i4 + 1], e4 = t2[h4][n4 - 1], x3 = t2[h4][n4];
        switch (l2) {
          case 0:
          case 1:
            if (_(a2.y, e4.y, x3.y) && _(y2.y, e4.y, x3.y)) {
              const t3 = Math.abs(x3.y - e4.y);
              t3 < r2 && (r2 = t3, o2 = i4);
            }
            break;
          case 2:
          case 3:
            if (_(a2.x, e4.x, x3.x) && _(y2.x, e4.x, x3.x)) {
              const t3 = Math.abs(x3.x - e4.x);
              t3 < r2 && (r2 = t3, o2 = i4);
            }
        }
      }
      i3[e3 + 3] = o2;
    }
  }
  static calcDeltas(t2, i3, s3) {
    const h3 = i3.length;
    for (let n2 = 0; n2 < h3; n2 += 4) {
      const h4 = [], _2 = _e.calcDelta(n2, i3, s3, h4);
      t2.push(i3[n2]), t2.push(i3[n2 + 1]), t2.push(i3[n2 + 2]), t2.push(_2);
    }
  }
  static calcDelta(t2, i3, s3, h3) {
    const n2 = i3[t2 + 3];
    if (-1 === n2) return 0;
    const _2 = h3.length;
    return _2 > 1 && h3[_2 - 2] === n2 ? 0 : (h3.push(n2), _e.calcDelta(n2, s3, i3, h3) + 1);
  }
  static addDeltas(t2, i3) {
    const s3 = t2.length;
    let h3 = 0;
    for (let n2 = 0; n2 < s3; n2 += 4) {
      const i4 = t2[n2 + 3];
      i4 > h3 && (h3 = i4);
    }
    for (let n2 = 0; n2 < s3; n2 += 4) {
      const s4 = i3[t2[n2]], e3 = t2[n2 + 1], _2 = h3 - t2[n2 + 3];
      switch (t2[n2 + 2]) {
        case 0:
          s4[e3 - 1].x -= _2, s4[e3].x -= _2, 1 === e3 && (s4[s4.length - 1].x -= _2), e3 === s4.length - 1 && (s4[0].x -= _2);
          break;
        case 1:
          s4[e3 - 1].x += _2, s4[e3].x += _2, 1 === e3 && (s4[s4.length - 1].x += _2), e3 === s4.length - 1 && (s4[0].x += _2);
          break;
        case 2:
          s4[e3 - 1].y -= _2, s4[e3].y -= _2, 1 === e3 && (s4[s4.length - 1].y -= _2), e3 === s4.length - 1 && (s4[0].y -= _2);
          break;
        case 3:
          s4[e3 - 1].y += _2, s4[e3].y += _2, 1 === e3 && (s4[s4.length - 1].y += _2), e3 === s4.length - 1 && (s4[0].y += _2);
      }
    }
  }
};
var _ = (t2, i3, s3) => t2 >= i3 && t2 <= s3 || t2 >= s3 && t2 <= i3;

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/GeometryUtils.js
var r = Number.POSITIVE_INFINITY;
var o = Math.PI;
var e2 = 2 * o;
var i2 = 128 / o;
var u2 = 256 / 360;
var s2 = o / 180;
var c = 1 / Math.LN2;
function a(t2, n2) {
  return (t2 %= n2) >= 0 ? t2 : t2 + n2;
}
function f(t2) {
  return a(t2 * i2, 256);
}
function l(t2) {
  return a(t2 * u2, 256);
}
function h2(t2) {
  return Math.log(t2) * c;
}
function p(t2, n2, r2) {
  return t2 * (1 - r2) + n2 * r2;
}
var x = 8;
var y = 14;
var M = 16;
function d(t2) {
  return x + Math.max((t2 - y) * M, 0);
}
function I(t2, n2, r2) {
  let o2, e3, i3, u3 = 0;
  for (const s3 of r2) {
    o2 = s3.length;
    for (let r3 = 1; r3 < o2; ++r3) {
      if (e3 = s3[r3 - 1], i3 = s3[r3], e3.y > n2 == i3.y > n2) continue;
      (i3.x - e3.x) * (n2 - e3.y) - (i3.y - e3.y) * (t2 - e3.x) > 0 ? u3++ : u3--;
    }
  }
  return 0 !== u3;
}
function N(n2, r2, o2, e3) {
  let i3, u3, s3, c2;
  const a2 = e3 * e3;
  for (const f2 of o2) {
    const o3 = f2.length;
    if (!(o3 < 2)) {
      i3 = f2[0].x, u3 = f2[0].y;
      for (let e4 = 1; e4 < o3; ++e4) {
        if (s3 = f2[e4].x, c2 = f2[e4].y, u(n2, r2, i3, u3, s3, c2) < a2) return true;
        i3 = s3, u3 = c2;
      }
    }
  }
  return false;
}
function w(t2, n2, r2, o2, e3, i3, u3) {
  const s3 = Math.max(o2, Math.min(n2, i3)) - n2, c2 = Math.max(e3, Math.min(r2, u3)) - r2;
  return s3 * s3 + c2 * c2 <= t2 * t2;
}
function P(t2, r2) {
  if (0 === r2 || Number.isNaN(r2)) return t2;
  const o2 = [], e3 = new i(0, 0), i3 = new i(0, 0), u3 = new i(0, 0);
  for (let s3 = 0; s3 < t2.length; s3++) {
    const c2 = t2[s3], a2 = [];
    for (let t3 = 0; t3 < c2.length; t3++) {
      const o3 = c2[t3 - 1], s4 = c2[t3], f2 = c2[t3 + 1];
      0 === t3 ? e3.setCoords(0, 0) : e3.assignSub(s4, o3).normalize().rightPerpendicular(), t3 === c2.length - 1 ? i3.setCoords(0, 0) : i3.assignSub(f2, s4).normalize().rightPerpendicular(), u3.assignAdd(e3, i3).normalize();
      const l2 = u3.x * i3.x + u3.y * i3.y;
      0 !== l2 && u3.scale(1 / l2), a2.push(i.add(s4, u3.scale(r2)));
    }
    o2.push(a2);
  }
  return o2;
}
function b(t2, r2, o2, e3) {
  const i3 = new i(t2[0], t2[1]);
  if (i3.scale(e3), "viewport" === r2) {
    const t3 = -o2 * (Math.PI / 180), n2 = Math.cos(t3), r3 = Math.sin(t3);
    i3.rotate(n2, r3);
  }
  return i3;
}

export {
  i,
  h,
  n,
  r,
  o,
  e2 as e,
  s2 as s,
  a,
  f,
  l,
  h2,
  p,
  d,
  I,
  N,
  w,
  P,
  b
};
//# sourceMappingURL=chunk-SMJWJAIA.js.map
