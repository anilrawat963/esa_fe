import {
  r as r9
} from "./chunk-6AWERJZ7.js";
import {
  A as A2,
  B,
  C,
  F,
  H,
  J as J3,
  K as K2,
  c as c3,
  w as w2
} from "./chunk-MLUR3X6U.js";
import {
  c as c4,
  m as m4
} from "./chunk-SUOIQXQ3.js";
import {
  n as n7
} from "./chunk-TNKZDDMZ.js";
import {
  r as r7
} from "./chunk-Z3EPMK46.js";
import {
  M as M3,
  w
} from "./chunk-VHCNEAMV.js";
import {
  r as r8
} from "./chunk-2XEDAAX5.js";
import {
  i as i4
} from "./chunk-H6PLTW7B.js";
import {
  M as M2,
  s3 as s5
} from "./chunk-3SCRAN3E.js";
import {
  T as T2,
  a as a5,
  c as c2,
  d,
  i as i3,
  j as j3,
  l as l2,
  s as s4
} from "./chunk-IGRCAVBL.js";
import {
  J as J2,
  O,
  R,
  U,
  X,
  j2,
  k as k2,
  y as y3
} from "./chunk-2JMKFI2D.js";
import {
  a as a4,
  f as f2
} from "./chunk-QYAMBIRP.js";
import {
  n as n5,
  r as r5,
  u as u4
} from "./chunk-ZVTEFYZX.js";
import {
  L as L2,
  _ as _3,
  a as a3
} from "./chunk-LPUPM55U.js";
import {
  n as n6,
  o as o2,
  r as r6
} from "./chunk-WDTGOP77.js";
import {
  A,
  I as I2,
  J,
  K,
  P as P2,
  _ as _4,
  g,
  o,
  p as p2,
  s as s3,
  u as u5,
  y as y2
} from "./chunk-VYMBX5H5.js";
import {
  n as n2
} from "./chunk-QF7FRVN6.js";
import {
  n as n3,
  r as r3,
  t as t2,
  u
} from "./chunk-75XOUSSS.js";
import {
  m as m3
} from "./chunk-3FUHCAX3.js";
import {
  M,
  P,
  a as a2,
  c,
  f3 as f,
  h3 as h2,
  i as i2,
  l,
  n2 as n4,
  p2 as p,
  t as t3,
  u3 as u2,
  u4 as u3,
  x,
  y3 as y
} from "./chunk-PZ5RULLK.js";
import {
  v as v2
} from "./chunk-OPJX4KXH.js";
import {
  s as s2
} from "./chunk-LTPHDYPK.js";
import {
  e as e3
} from "./chunk-3OVERDFX.js";
import {
  I,
  T,
  _ as _2,
  e as e2,
  j,
  k,
  m as m2,
  r as r4,
  v,
  z
} from "./chunk-AZXJIEZ6.js";
import {
  r
} from "./chunk-TFJXG32O.js";
import {
  r as r2,
  s
} from "./chunk-SMWUT52Z.js";
import {
  _,
  i
} from "./chunk-AXZMNHTN.js";
import {
  G
} from "./chunk-NMQNUPE4.js";
import {
  b,
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  e,
  t
} from "./chunk-GNMPGHLQ.js";
import {
  L,
  h,
  n
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/views/interactive/coordinateHelper.js
var R2 = class {
  constructor(e6) {
    this.spatialReference = e6;
  }
  createVector() {
    return this._tag(n6());
  }
  pointToVector(e6) {
    return this._tag(r6(e6.x, e6.y));
  }
  arrayToVector(e6) {
    return this._tag(r6(e6[0], e6[1]));
  }
  vectorToArray(e6) {
    return [e6[0], e6[1]];
  }
  pointToArray(e6) {
    return [e6.x, e6.y];
  }
  vectorToPoint(e6, r14 = new _()) {
    if (e6) return r14.x = e6[0], r14.y = e6[1], r14.z = void 0, r14.m = void 0, r14.spatialReference = this.spatialReference, r14;
  }
  arrayToPoint(e6, r14 = new _()) {
    return r14.x = e6[0], r14.y = e6[1], r14.z = void 0, r14.m = void 0, r14.spatialReference = this.spatialReference, r14;
  }
  vectorToDehydratedPoint(e6, r14) {
    if (e6) return r14 ??= { x: void 0, y: void 0, z: void 0, m: void 0, hasZ: void 0, hasM: void 0, spatialReference: void 0, type: "point" }, r14.x = e6[0], r14.y = e6[1], r14.z = void 0, r14.m = void 0, r14.hasZ = false, r14.hasM = false, r14.spatialReference = this.spatialReference, r14;
  }
  lerp(e6, t9, a8, i6) {
    return _2(i6, e6, t9, a8);
  }
  addDelta(e6, r14, t9) {
    e6[0] += r14, e6[1] += t9;
  }
  distance(r14, t9) {
    return m2(r14, t9);
  }
  getZ(e6, r14 = void 0) {
    return r14;
  }
  hasZ() {
    return false;
  }
  getM(e6, r14 = void 0) {
    return r14;
  }
  hasM() {
    return false;
  }
  clone(e6) {
    return this._tag(o2(e6));
  }
  copy(e6, r14) {
    return r4(r14, e6);
  }
  fromXYZ(e6) {
    return this._tag(r6(e6[0], e6[1]));
  }
  toXYZ(e6, r14 = n3()) {
    return o(r14, e6[0], e6[1], 0);
  }
  pointToXYZ(e6, r14 = n3()) {
    return o(r14, e6.x, e6.y, 0);
  }
  equals(e6, r14) {
    return T(e6, r14);
  }
  _tag(e6) {
    return e6;
  }
};
var Z = class {
  constructor(e6, r14) {
    this._valueType = e6, this.spatialReference = r14;
  }
  createVector() {
    return this._tag(n3());
  }
  pointToVector(e6) {
    return this._tag(r3(e6.x, e6.y, 0 === this._valueType ? e6.z : e6.m));
  }
  arrayToVector(e6) {
    return this._tag(r3(e6[0], e6[1], e6[2] || 0));
  }
  vectorToArray(e6) {
    return [e6[0], e6[1], e6[2]];
  }
  pointToArray(e6) {
    return 0 === this._valueType ? [e6.x, e6.y, e6.z] : [e6.x, e6.y, e6.m];
  }
  vectorToPoint(e6, r14 = new _()) {
    if (e6) return r14.x = e6[0], r14.y = e6[1], r14.z = 0 === this._valueType ? e6[2] : void 0, r14.m = 1 === this._valueType ? e6[2] : void 0, r14.spatialReference = this.spatialReference, r14;
  }
  arrayToPoint(e6, r14 = new _()) {
    return r14.x = e6[0], r14.y = e6[1], r14.z = 0 === this._valueType ? e6[2] : void 0, r14.m = 1 === this._valueType ? e6[2] : void 0, r14.spatialReference = this.spatialReference, r14;
  }
  vectorToDehydratedPoint(e6, r14) {
    if (!e6) return;
    r14 ??= { x: void 0, y: void 0, z: void 0, m: void 0, hasZ: void 0, hasM: void 0, spatialReference: void 0, type: "point" };
    const t9 = 0 === this._valueType, a8 = 1 === this._valueType;
    return r14.x = e6[0], r14.y = e6[1], r14.z = t9 ? e6[2] : void 0, r14.m = a8 ? e6[2] : void 0, r14.hasZ = t9, r14.hasM = a8, r14.spatialReference = this.spatialReference, r14;
  }
  lerp(e6, r14, t9, a8) {
    return I2(a8, e6, r14, t9);
  }
  addDelta(e6, r14, t9, a8) {
    e6[0] += r14, e6[1] += t9, 0 === this._valueType && (e6[2] += a8);
  }
  distance(r14, t9) {
    return 0 === this._valueType ? p2(r14, t9) : m2(V(r14), V(t9));
  }
  getZ(e6, r14 = void 0) {
    return 0 === this._valueType ? e6[2] : r14;
  }
  hasZ() {
    return 0 === this._valueType;
  }
  getM(e6, r14 = void 0) {
    return 1 === this._valueType ? e6[2] : r14;
  }
  hasM() {
    return 1 === this._valueType;
  }
  clone(e6) {
    return this._tag(u(e6));
  }
  copy(e6, r14) {
    return s3(r14, e6);
  }
  fromXYZ(e6, r14 = 0, t9 = 0) {
    return this._tag(r3(e6[0], e6[1], 0 === this._valueType ? e6.length > 2 ? e6[2] : r14 : t9));
  }
  toXYZ(e6, r14 = n3()) {
    return o(r14, e6[0], e6[1], 0 === this._valueType ? e6[2] : 0);
  }
  pointToXYZ(e6, r14 = n3()) {
    return o(r14, e6.x, e6.y, 0 === this._valueType ? e6.z ?? 0 : 0);
  }
  equals(e6, r14) {
    return J(e6, r14);
  }
  _tag(e6) {
    return e6;
  }
};
var z2 = class {
  constructor(e6) {
    this.spatialReference = e6;
  }
  createVector() {
    return this._tag(n5());
  }
  pointToVector(e6) {
    return this._tag(r5(e6.x, e6.y, e6.z, e6.m));
  }
  arrayToVector(e6) {
    return this._tag(r5(e6[0], e6[1], e6[2] || 0, e6[3] || 0));
  }
  vectorToArray(e6) {
    return [e6[0], e6[1], e6[2], e6[3]];
  }
  pointToArray(e6) {
    return [e6.x, e6.y, e6.z, e6.m];
  }
  vectorToPoint(e6, r14 = new _()) {
    return r14.x = e6[0], r14.y = e6[1], r14.z = e6[2], r14.m = e6[3], r14.spatialReference = this.spatialReference, r14;
  }
  arrayToPoint(e6, r14 = new _()) {
    return r14.x = e6[0], r14.y = e6[1], r14.z = e6[2], r14.m = e6[3], r14.spatialReference = this.spatialReference, r14;
  }
  vectorToDehydratedPoint(e6, r14) {
    if (e6) return r14 ??= { x: void 0, y: void 0, z: void 0, m: void 0, hasZ: void 0, hasM: void 0, spatialReference: void 0, type: "point" }, r14.x = e6[0], r14.y = e6[1], r14.z = e6[2], r14.m = e6[3], r14.hasZ = true, r14.hasM = true, r14.spatialReference = this.spatialReference, r14;
  }
  lerp(e6, r14, t9, a8) {
    return _3(a8, e6, r14, t9);
  }
  addDelta(e6, r14, t9, a8) {
    e6[0] += r14, e6[1] += t9, e6[2] += a8;
  }
  distance(e6, r14) {
    return p2(M4(e6), M4(r14));
  }
  getZ(e6) {
    return e6[2];
  }
  hasZ() {
    return true;
  }
  getM(e6) {
    return e6[3];
  }
  hasM() {
    return true;
  }
  clone(e6) {
    return this._tag(u4(e6));
  }
  copy(e6, r14) {
    return a3(r14, e6);
  }
  fromXYZ(e6, r14 = 0, t9 = 0) {
    return this._tag(r5(e6[0], e6[1], e6.length > 2 ? e6[2] : r14, t9));
  }
  toXYZ(e6, r14 = n3()) {
    return o(r14, e6[0], e6[1], e6[2]);
  }
  pointToXYZ(e6, r14 = n3()) {
    return o(r14, e6.x, e6.y, e6.z ?? 0);
  }
  equals(e6, r14) {
    return L2(e6, r14);
  }
  _tag(e6) {
    return e6;
  }
};
function M4(e6) {
  return e6;
}
function V(e6) {
  return e6;
}
function w3(e6, r14, t9) {
  return e6 && r14 ? new z2(t9) : r14 ? new Z(1, t9) : e6 ? new Z(0, t9) : new R2(t9);
}

// node_modules/@arcgis/core/views/interactive/editGeometry/unnormalizationHelper.js
function r10(o5, r14) {
  if (!r14.supported) return;
  let p5 = 1 / 0, e6 = -1 / 0;
  const u6 = r14.upperBoundX - r14.lowerBoundX;
  o5.forEach((o6) => {
    let n12 = o6.pos[0];
    for (; n12 < r14.lowerBoundX; ) n12 += u6;
    for (; n12 > r14.upperBoundX; ) n12 -= u6;
    p5 = Math.min(p5, n12), e6 = Math.max(e6, n12), o6.pos[0] = n12;
  });
  const n11 = e6 - p5;
  u6 - n11 < n11 && o5.forEach((o6) => {
    o6.pos[0] < 0 && (o6.pos[0] += u6);
  });
}
function p3(r14, p5) {
  const e6 = G(r14);
  return 1 === p5 && e6 ? { supported: true, lowerBoundX: e6.valid[0], upperBoundX: e6.valid[1] } : { supported: false, lowerBoundX: null, upperBoundX: null };
}

// node_modules/@arcgis/core/views/interactive/editGeometry/EditGeometry.js
var f3 = class {
  constructor(t9) {
    this.part = t9, this.leftSegment = null, this.rightSegment = null, this.type = "vertex", this.index = null;
  }
  get pos() {
    return this._pos;
  }
  set pos(t9) {
    this._pos = t9, this.part.unnormalizeVertexPositions();
  }
};
var m5 = class {
  constructor(t9, e6, r14) {
    this.part = t9, this.leftVertex = e6, this.rightVertex = r14, this.type = "line", e6.rightSegment = this, r14.leftSegment = this;
  }
  toCurveOrCoordinate() {
    return [...this.rightVertex.pos];
  }
};
var d2 = class {
  constructor(t9, e6, r14, i6) {
    this.part = t9, this.leftVertex = e6, this.rightVertex = r14, this.curveDefinition = i6, this.type = "bezier", e6.rightSegment = this, r14.leftSegment = this;
  }
  toCurveOrCoordinate() {
    return { b: [[...this.rightVertex.pos], [...this.curveDefinition.controlPoint1], [...this.curveDefinition.controlPoint2]] };
  }
};
var y4 = class {
  constructor(t9, e6, r14, i6) {
    this.part = t9, this.leftVertex = e6, this.rightVertex = r14, this.curveDefinition = i6, this.type = "circular-arc", e6.rightSegment = this, r14.leftSegment = this;
  }
  toCurveOrCoordinate() {
    const t9 = this.rightVertex.pos, { interiorPoint: e6 } = this.curveDefinition;
    return { c: [[...t9], [...e6]] };
  }
};
var v3 = class {
  constructor(t9, e6, r14, i6) {
    this.part = t9, this.leftVertex = e6, this.rightVertex = r14, this.curveDefinition = i6, this.type = "elliptic-arc-4", e6.rightSegment = this, r14.leftSegment = this;
  }
  toCurveOrCoordinate() {
    const t9 = this.rightVertex.pos, { centerPoint: e6, sweep: r14, orientation: i6 } = this.curveDefinition;
    return { a: [[...t9], [...e6], r14, i6] };
  }
};
var x2 = class {
  constructor(t9, e6, r14, i6) {
    this.part = t9, this.leftVertex = e6, this.rightVertex = r14, this.curveDefinition = i6, this.type = "elliptic-arc-7", e6.rightSegment = this, r14.leftSegment = this;
  }
  toCurveOrCoordinate() {
    const t9 = this.rightVertex.pos, { centerPoint: e6, sweep: r14, orientation: i6, rotation: s8, semiMajorAxisLength: n11, minorMajorAxisRatio: o5 } = this.curveDefinition;
    return { a: [[...t9], e6, r14, i6, s8, n11, o5] };
  }
};
var V2 = class {
  constructor(t9, e6) {
    this._spatialReference = t9, this._viewingMode = e6, this.vertices = [], this.segments = [], this.index = null;
  }
  unnormalizeVertexPositions() {
    this.vertices.length <= 1 || r10(this.vertices, p3(this._spatialReference, this._viewingMode));
  }
  updateVertexIndex(t9, e6) {
    const { vertices: r14 } = this;
    if (0 === r14.length) return;
    const i6 = r14[0];
    let s8 = null, n11 = t9, o5 = e6;
    do {
      s8 = n11, s8.index = o5++, n11 = s8.rightSegment ? s8.rightSegment.rightVertex : null;
    } while (null != n11 && n11 !== i6);
    s8.leftSegment && s8 !== r14[r14.length - 1] && this.swapVertices(r14.indexOf(s8), r14.length - 1);
  }
  getFirstVertex() {
    return this.vertices.at(0);
  }
  getLastVertex() {
    return this.vertices.at(-1);
  }
  isClosed() {
    return null !== this.getFirstVertex()?.leftSegment;
  }
  swapVertices(t9, e6) {
    const { vertices: r14 } = this, i6 = r14[t9];
    r14[t9] = r14[e6], r14[e6] = i6;
  }
  *iterateVertices() {
    const t9 = this.getFirstVertex();
    let e6 = t9;
    if (e6) do {
      yield e6, e6 = e6.rightSegment?.rightVertex;
    } while (e6 !== t9 && null != e6);
  }
};
var w4 = class _w extends r {
  constructor(t9, e6) {
    super(), this.type = t9, this.coordinateHelper = e6, this._geometry = null, this._dirty = true, this.parts = [];
  }
  get geometry() {
    if (this._dirty) {
      switch (this.type) {
        case "point":
          this._geometry = this._toPoint();
          break;
        case "multipoint":
          this._geometry = this._toMultipoint();
          break;
        case "polyline":
          this._geometry = this._toPolyline();
          break;
        case "polygon":
          this._geometry = this._toPolygon();
          break;
        case "mesh":
          break;
        default:
          n(this.type);
      }
      this._dirty = false;
    }
    return this._geometry;
  }
  get spatialReference() {
    return this.coordinateHelper.spatialReference;
  }
  get allVerticesUnordered() {
    return Array.from(this.iterateVerticesUnordered());
  }
  *iterateVerticesUnordered() {
    for (const t9 of this.parts) for (const e6 of t9.vertices) yield e6;
  }
  get allVertices() {
    return Array.from(this.iterateVertices());
  }
  *iterateVertices() {
    for (const t9 of this.parts) yield* t9.iterateVertices();
  }
  notifyChanges(t9) {
    this._dirty = true, this.emit("change", t9);
  }
  _toPoint() {
    const { parts: t9, coordinateHelper: e6 } = this;
    return t9.at(0)?.vertices.length ? e6.vectorToPoint(t9[0].vertices[0].pos) : null;
  }
  _toMultipoint() {
    const t9 = [], { coordinateHelper: e6, parts: r14, spatialReference: s8 } = this;
    for (const i6 of r14) {
      const r15 = i6.getFirstVertex();
      r15 && t9.push(e6.arrayToVector(r15.pos));
    }
    return new m3({ hasM: e6.hasM(), hasZ: e6.hasZ(), spatialReference: s8, points: t9 });
  }
  _toPolyline() {
    const t9 = [];
    let e6 = false;
    for (const r14 of this.parts) {
      if (r14.vertices.length < 1) continue;
      const i6 = r14.vertices[0], s8 = [];
      s8.push(i6.pos);
      let n11 = i6.rightSegment;
      for (; n11; ) e6 ||= "line" !== n11.type, s8.push(n11.toCurveOrCoordinate()), n11 = n11.rightVertex.rightSegment;
      t9.push(s8);
    }
    return new y({ paths: e6 ? void 0 : t9, curvePaths: e6 ? t9 : void 0, spatialReference: this.spatialReference, hasZ: this.coordinateHelper.hasZ(), hasM: this.coordinateHelper.hasM() });
  }
  _toPolygon() {
    const t9 = [];
    let e6 = false;
    for (const r14 of this.parts) {
      if (r14.vertices.length < 1) continue;
      const i6 = r14.vertices[0], s8 = [];
      s8.push(i6.pos);
      let n11 = i6.rightSegment;
      for (; n11 && (e6 ||= "line" !== n11.type, s8.push(n11.toCurveOrCoordinate()), n11 = n11.rightVertex.rightSegment, n11?.leftVertex !== i6); ) ;
      t9.push(s8);
    }
    return new P({ rings: e6 ? void 0 : t9, curveRings: e6 ? t9 : void 0, spatialReference: this.spatialReference, hasZ: this.coordinateHelper.hasZ(), hasM: this.coordinateHelper.hasM() });
  }
  static fromGeometry(t9, e6, r14) {
    const i6 = t9.spatialReference, s8 = w3(t9.hasZ, t9.hasM, i6), n11 = new _w(t9.type, s8);
    switch (t9.type) {
      case "polygon":
        S(n11, t9, e6, r14?.allowCurves ?? false);
        break;
      case "polyline":
        R3(n11, t9, e6, r14?.allowCurves ?? false);
        break;
      case "point":
        C2(n11, t9, e6);
        break;
      case "multipoint":
        M5(n11, t9, e6);
        break;
      case "mesh":
        C2(n11, t9.origin, e6), n11._geometry = t9, n11._dirty = false;
    }
    return n11;
  }
};
function _5(t9, e6, r14, i6) {
  const s8 = new f3(t9);
  t9.vertices.push(s8);
  const n11 = f(i6);
  return s8.pos = e6.arrayToVector(n11), s8.index = t9.vertices.length - 1, r14 && t9.segments.push(P3(t9, r14, s8, i6)), s8;
}
function P3(t9, e6, r14, i6) {
  if (i2(i6)) return new m5(t9, e6, r14);
  if (t3(i6)) {
    const [, s9, n12] = i6.b;
    return new d2(t9, e6, r14, { controlPoint1: [...s9], controlPoint2: [...n12] });
  }
  if (u3(i6)) {
    const [, s9] = i6.c;
    return new y4(t9, e6, r14, { interiorPoint: [...s9] });
  }
  if (c(i6)) {
    const [, s9, n12, o5] = i6.a;
    return new v3(t9, e6, r14, { centerPoint: [...s9], sweep: n12, orientation: o5 });
  }
  const [, s8, n11, l4, p5, u6, g4] = i6.a;
  return new x2(t9, e6, r14, { centerPoint: [...s8], sweep: n11, orientation: l4, rotation: p5, semiMajorAxisLength: u6, minorMajorAxisRatio: g4 });
}
function S(e6, r14, i6, s8) {
  const n11 = r14.spatialReference, o5 = e6.coordinateHelper, { rings: h4, curveRings: c7 } = r14, a8 = c7 && s8 ? c7 : h4;
  for (let p5 = 0; p5 < a8.length; ++p5) {
    const r15 = a8[p5], s9 = new V2(n11, i6);
    if (s9.index = p5, e6.parts.push(s9), r15.length < 1) continue;
    let h5 = null, c8 = null;
    for (let t9 = 0; t9 < r15.length - 1; ++t9) c8 = _5(s9, o5, c8, r15[t9]), h5 ??= c8;
    r15.length > 1 && h(f(r15[r15.length - 1]), h5?.pos) ? c8 && h5 && s9.segments.push(P3(s9, c8, h5, r15[r15.length - 1])) : c8 = _5(s9, o5, c8, r15[r15.length - 1]);
  }
}
function R3(t9, e6, r14, i6) {
  const s8 = e6.spatialReference, n11 = t9.coordinateHelper, { curvePaths: o5, paths: h4 } = e6, c7 = o5 && i6 ? o5 : h4;
  for (let a8 = 0; a8 < c7.length; ++a8) {
    const e7 = c7[a8], i7 = new V2(s8, r14);
    if (i7.index = a8, t9.parts.push(i7), e7.length < 1) continue;
    let o6 = null;
    for (let t10 = 0; t10 < e7.length; ++t10) o6 = _5(i7, n11, o6, e7[t10]);
  }
}
function C2(t9, e6, r14) {
  const i6 = e6.spatialReference, s8 = t9.coordinateHelper, n11 = new V2(i6, r14);
  n11.index = 0;
  const o5 = new f3(n11);
  o5.index = 0, o5.pos = s8.pointToVector(e6), n11.vertices.push(o5), t9.parts.push(n11);
}
function M5(t9, e6, r14) {
  const i6 = e6.spatialReference, { coordinateHelper: s8, parts: n11 } = t9, o5 = e6.points.map((t10) => s8.arrayToVector(t10));
  for (let h4 = 0; h4 < o5.length; h4++) {
    const t10 = new V2(i6, r14);
    t10.index = h4, n11.push(t10);
    const e7 = new f3(t10);
    e7.pos = o5[h4], e7.index = 0, t10.vertices.push(e7);
  }
}
function H2(t9) {
  return "mesh" === t9.type;
}

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/AppendVertex.js
var r11 = class {
  constructor(e6, t9, i6) {
    this._editGeometry = e6, this._part = t9, this._posOrCurveDef = i6, this._addedVertex = null, this._originalSegment = null, this._left = null, this._right = null, this._partAdded = false;
  }
  apply() {
    let r14 = "redo";
    const { _part: d3, _editGeometry: n11, _posOrCurveDef: l4 } = this;
    if (null == this._addedVertex && (r14 = "apply", this._addedVertex = new f3(d3)), !n11.parts.includes(d3)) {
      this._partAdded = true;
      const e6 = n11.parts.at(-1)?.index ?? -1;
      d3.index = e6 + 1, n11.parts.push(d3);
    }
    const h4 = d3.getLastVertex(), a8 = n11.coordinateHelper.arrayToVector(f(l4));
    if (null == h4) d3.vertices.push(this._addedVertex), this._addedVertex.pos = a8, this._addedVertex.index = 0;
    else {
      let e6 = null;
      h4.rightSegment && (this._originalSegment = h4.rightSegment, e6 = this._originalSegment.rightVertex, d3.segments.splice(d3.segments.indexOf(this._originalSegment), 1)), d3.vertices.push(this._addedVertex), this._addedVertex.pos = a8, this._left ??= P3(d3, h4, this._addedVertex, l4), d3.segments.push(this._left), h4.rightSegment = this._left, null != this._originalSegment && null != e6 && (this._right ??= new m5(this._part, this._addedVertex, e6), d3.segments.push(this._right), e6.leftSegment = this._right), d3.updateVertexIndex(this._addedVertex, h4.index + 1);
    }
    this._editGeometry.notifyChanges({ operation: r14, addedVertices: [this._addedVertex] });
  }
  undo() {
    const { _addedVertex: e6, _part: t9, _left: i6, _right: s8, _originalSegment: r14 } = this;
    null != e6 && (t9.vertices.splice(t9.vertices.indexOf(e6), 1), null != i6 && (t9.segments.splice(t9.segments.indexOf(i6), 1), i6.leftVertex.rightSegment = null), null != s8 && (t9.segments.splice(t9.segments.indexOf(s8), 1), s8.rightVertex.leftSegment = null), null != r14 && (t9.segments.push(r14), r14.leftVertex.rightSegment = r14, r14.rightVertex.leftSegment = r14), null != i6 ? t9.updateVertexIndex(i6.leftVertex, i6.leftVertex.index) : t9.updateVertexIndex(e6, 0), this._partAdded && this._editGeometry.parts.splice(this._editGeometry.parts.indexOf(this._part)), this._editGeometry.notifyChanges({ operation: "undo", removedVertices: [e6] }));
  }
  accumulate() {
    return false;
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/UpdateVertices.js
var t4 = class _t {
  constructor(t9, e6, i6) {
    this._editGeometry = t9, this._vertices = e6, this.operation = i6, this._undone = false;
  }
  _notifyChanges(t9) {
    this._editGeometry.parts.forEach((t10) => t10.unnormalizeVertexPositions()), this._editGeometry.notifyChanges({ operation: t9, updatedVertices: this._vertices });
  }
  apply() {
    this._vertices.forEach((t9) => this.operation.apply(t9)), this._notifyChanges(this._undone ? "redo" : "apply");
  }
  undo() {
    this._vertices.forEach((t9) => this.operation.undo(t9)), this._undone = true, this._notifyChanges("undo");
  }
  canAccumulate(t9) {
    if (this._undone || t9._vertices.length !== this._vertices.length) return false;
    for (let e6 = 0; e6 < t9._vertices.length; ++e6) if (t9._vertices[e6] !== this._vertices[e6]) return false;
    return this.operation.canAccumulate(t9.operation);
  }
  accumulate(e6) {
    return !!(e6 instanceof _t && this.canAccumulate(e6)) && (this._vertices.forEach((t9) => this.operation.accumulate(t9, e6.operation)), this.operation.accumulateParams(e6.operation), this._notifyChanges("apply"), true);
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/RemoveVertices.js
var t5 = class {
  constructor(e6, t9, r14 = 0) {
    this._editGeometry = e6, this._vertices = t9, this._minNumberOfVertices = r14, this.removedVertices = null;
  }
  apply() {
    let e6 = "redo";
    if (null == this.removedVertices) {
      const t9 = this.removedVertices = [];
      this._vertices.forEach((e7) => {
        const r14 = this._removeVertex(e7);
        null != r14 && t9.push(r14);
      }), e6 = "apply";
    } else this.removedVertices.forEach((e7) => {
      this._removeVertex(e7.removedVertex);
    });
    this._editGeometry.notifyChanges({ operation: e6, removedVertices: this._vertices });
  }
  undo() {
    this.removedVertices?.forEach((e6) => {
      this._undoRemoveVertex(e6);
    }), this._editGeometry.notifyChanges({ operation: "undo", addedVertices: this._vertices });
  }
  accumulate() {
    return false;
  }
  _removeVertex(t9) {
    const r14 = t9.part;
    if (r14.vertices.length <= this._minNumberOfVertices) return null;
    const s8 = { removedVertex: t9, createdSegment: null }, i6 = t9.leftSegment, n11 = t9.rightSegment;
    return r14.vertices.splice(r14.vertices.indexOf(t9), 1), i6 && (r14.segments.splice(r14.segments.indexOf(i6), 1), i6.leftVertex.rightSegment = null), n11 && (r14.segments.splice(r14.segments.indexOf(n11), 1), n11.rightVertex.leftSegment = null), 0 === t9.index && n11 && this._vertices.length > 0 && r14.swapVertices(r14.vertices.indexOf(n11.rightVertex), 0), i6 && n11 && (s8.createdSegment = new m5(r14, i6.leftVertex, n11.rightVertex), r14.segments.push(s8.createdSegment)), n11 && r14.updateVertexIndex(n11.rightVertex, n11.rightVertex.index - 1), s8;
  }
  _undoRemoveVertex(e6) {
    const t9 = e6.removedVertex, r14 = e6.removedVertex.part, s8 = t9.leftSegment, i6 = t9.rightSegment;
    e6.createdSegment && r14.segments.splice(r14.segments.indexOf(e6.createdSegment), 1), r14.vertices.push(t9), s8 && (r14.segments.push(s8), s8.leftVertex.rightSegment = s8), i6 && (r14.segments.push(i6), i6.rightVertex.leftSegment = i6), r14.updateVertexIndex(t9, t9.index);
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/SplitSegment.js
var n8 = class {
  constructor(e6, t9, r14) {
    this._editGeometry = e6, this._segment = t9, this._t = r14, this.createdVertex = null, this._createdLeftEdge = null, this._createdRightEdge = null;
  }
  apply() {
    let n11 = "redo";
    const g4 = this._editGeometry.coordinateHelper, l4 = this._segment, p5 = l4.part, u6 = l4.leftVertex, m7 = l4.rightVertex;
    p5.segments.splice(p5.segments.indexOf(l4), 1);
    const f4 = [];
    switch (null == this.createdVertex && (n11 = "apply", this.createdVertex = new f3(p5)), l4.type) {
      case "line":
        f4.push(g4.lerp(u6.pos, m7.pos, this._t, g4.createVector()));
        break;
      case "bezier": {
        const t9 = l4.toCurveOrCoordinate();
        f4.push(...M(u6.pos, t9, this._t));
        break;
      }
      case "circular-arc": {
        const e6 = l4.toCurveOrCoordinate(), s8 = l(u6.pos, e6);
        f4.push(...u2(s8, e6, this._t));
        break;
      }
      case "elliptic-arc-4": {
        const e6 = l4.toCurveOrCoordinate(), t9 = h2(u6.pos, e6);
        f4.push(...n4(t9, e6, this._t));
        break;
      }
      case "elliptic-arc-7": {
        const e6 = l4.toCurveOrCoordinate(), t9 = p(u6.pos, e6);
        f4.push(...x(t9, e6, this._t));
        break;
      }
    }
    p5.vertices.push(this.createdVertex), this.createdVertex.pos = g4.arrayToVector(f(f4[0])), f4.length > 1 && (m7.pos = g4.arrayToVector(f(f4[1]))), null == this._createdLeftEdge && (this._createdLeftEdge = P3(p5, u6, this.createdVertex, f4[0])), this._createdLeftEdge.leftVertex.leftSegment ? p5.segments.push(this._createdLeftEdge) : p5.segments.unshift(this._createdLeftEdge), u6.rightSegment = this._createdLeftEdge, null == this._createdRightEdge && (this._createdRightEdge = P3(p5, this.createdVertex, m7, f4.at(1) ?? m7.pos)), p5.segments.push(this._createdRightEdge), m7.leftSegment = this._createdRightEdge, p5.updateVertexIndex(this.createdVertex, u6.index + 1), this._editGeometry.notifyChanges({ operation: n11, addedVertices: [this.createdVertex] });
  }
  undo() {
    if (null == this.createdVertex || null == this._createdLeftEdge || null == this._createdRightEdge) return null;
    const e6 = this._segment, t9 = e6.part, { leftSegment: r14, rightSegment: s8 } = this.createdVertex, i6 = r14?.leftVertex, c7 = s8?.rightVertex;
    t9.vertices.splice(t9.vertices.indexOf(this.createdVertex), 1), t9.segments.splice(t9.segments.indexOf(this._createdLeftEdge), 1), t9.segments.splice(t9.segments.indexOf(this._createdRightEdge), 1), e6.leftVertex.leftSegment ? t9.segments.push(e6) : t9.segments.unshift(e6), i6 && (i6.rightSegment = e6), c7 && (c7.leftSegment = e6), i6 && t9.updateVertexIndex(i6, i6.index), this._editGeometry.notifyChanges({ operation: "undo", removedVertices: [this.createdVertex] });
  }
  accumulate() {
    return false;
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/SetVertexPosition.js
var a6 = class _a {
  constructor(e6, t9, i6) {
    this._editGeometry = e6, this._vertex = t9, this._pos = i6;
  }
  apply() {
    const e6 = null == this._originalPosition;
    e6 && (this._originalPosition = this._vertex.leftSegment?.toCurveOrCoordinate() ?? this._vertex.pos), this._apply(e6 ? "apply" : "redo");
  }
  undo() {
    const t9 = this._vertex.leftSegment;
    t9 && this._originalPosition && this._replaceEdge(t9, this._vertex, this._originalPosition), this._vertex.pos = this._editGeometry.coordinateHelper.arrayToVector(f(this._originalPosition)), this._editGeometry.notifyChanges({ operation: "undo", updatedVertices: [this._vertex] });
  }
  accumulate(e6) {
    return e6 instanceof _a && e6._vertex === this._vertex && (this._pos = e6._pos, this._apply("apply"), true);
  }
  _apply(n11) {
    this._vertex.pos = this._editGeometry.coordinateHelper.arrayToVector(f(this._pos));
    const a8 = this._pos, c7 = this._vertex.leftSegment;
    switch (c7?.type) {
      case void 0:
        break;
      case "line":
        i2(a8) || this._replaceEdge(c7, this._vertex, a8);
        break;
      case "bezier":
        t3(a8) ? (c7.curveDefinition.controlPoint1 = a8.b[1], c7.curveDefinition.controlPoint2 = a8.b[2]) : this._replaceEdge(c7, this._vertex, a8);
        break;
      case "circular-arc":
        u3(a8) ? c7.curveDefinition.interiorPoint = a8.c[1] : this._replaceEdge(c7, this._vertex, a8);
        break;
      case "elliptic-arc-4":
        c(a8) ? (c7.curveDefinition.centerPoint = a8.a[1], c7.curveDefinition.sweep = a8.a[2], c7.curveDefinition.orientation = a8.a[3]) : this._replaceEdge(c7, this._vertex, a8);
        break;
      case "elliptic-arc-7":
        a2(a8) ? (c7.curveDefinition.centerPoint = a8.a[1], c7.curveDefinition.sweep = a8.a[2], c7.curveDefinition.orientation = a8.a[3], c7.curveDefinition.rotation = a8.a[4], c7.curveDefinition.semiMajorAxisLength = a8.a[5], c7.curveDefinition.minorMajorAxisRatio = a8.a[6]) : this._replaceEdge(c7, this._vertex, a8);
    }
    this._editGeometry.parts.forEach((e6) => e6.unnormalizeVertexPositions()), this._editGeometry.notifyChanges({ operation: n11, updatedVertices: [this._vertex] });
  }
  _replaceEdge(e6, t9, i6) {
    const r14 = this._vertex.part, o5 = e6 ? r14.segments.indexOf(e6) : -1;
    if (o5 > -1 && e6.leftVertex) {
      const s8 = P3(r14, e6.leftVertex, t9, i6);
      this._vertex.part.segments.splice(o5, 1, s8);
    }
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/ClosePart.js
var r12 = class {
  constructor(e6, t9) {
    this._editGeometry = e6, this._part = t9, this._createdSegment = null;
  }
  apply() {
    let e6 = "redo";
    const { _part: r14 } = this;
    if (null == this._createdSegment) {
      e6 = "apply";
      const n11 = r14.getFirstVertex(), i6 = r14.getLastVertex();
      if (r14.isClosed() || r14.vertices.length < 2 || null == n11 || null == i6) return;
      if (2 === r14.vertices.length && "line" === i6.leftSegment?.type) return;
      this._createdSegment = new m5(this._part, i6, n11);
    }
    this._createdSegment.leftVertex.rightSegment = this._createdSegment, this._createdSegment.rightVertex.leftSegment = this._createdSegment, r14.segments.push(this._createdSegment), this._editGeometry.notifyChanges({ operation: e6 });
  }
  undo() {
    const { _part: t9, _createdSegment: r14, _editGeometry: n11 } = this;
    null != r14 && (L(t9.segments, r14), r14.leftVertex.rightSegment = null, r14.rightVertex.leftSegment = null, n11.notifyChanges({ operation: "undo" }));
  }
  accumulate() {
    return false;
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/MoveMesh.js
var t6 = class _t {
  constructor(t9, e6, i6, s8) {
    this._editGeometry = t9, this.dx = e6, this.dy = i6, this.dz = s8, this._firstTime = true;
  }
  apply() {
    const t9 = this._firstTime ? "apply" : "redo";
    this._firstTime = false, this._apply(t9, this.dx, this.dy, this.dz);
  }
  undo() {
    this._apply("undo", -this.dx, -this.dy, -this.dz);
  }
  accumulate(e6) {
    const i6 = this._editGeometry.geometry;
    return e6 instanceof _t && e6._editGeometry.geometry === i6 && (this._apply("apply", e6.dx, e6.dy, e6.dz), this.dx += e6.dx, this.dy += e6.dy, this.dz += e6.dz, true);
  }
  _apply(t9, e6, i6, s8) {
    const o5 = this._editGeometry.geometry;
    o5.offset(e6, i6, s8);
    const d3 = this._editGeometry.parts[0].getFirstVertex();
    if (!d3) return;
    const r14 = this._editGeometry.coordinateHelper;
    d3.pos = r14.pointToVector(o5.origin), this._editGeometry.notifyChanges({ operation: t9, updatedVertices: [d3] });
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/MoveVertex.js
var t7 = class _t {
  constructor(t9, e6, i6, c7) {
    this._helper = t9, this.dx = e6, this.dy = i6, this.dz = c7;
  }
  _move(t9, i6, c7, s8) {
    this._helper.addDelta(t9.pos, i6, c7, s8), e4(t9.leftSegment, i6, c7);
  }
  apply(t9) {
    this._move(t9, this.dx, this.dy, this.dz);
  }
  undo(t9) {
    this._move(t9, -this.dx, -this.dy, -this.dz);
  }
  canAccumulate(e6) {
    return e6 instanceof _t;
  }
  accumulate(t9, e6) {
    this._move(t9, e6.dx, e6.dy, e6.dz);
  }
  accumulateParams(t9) {
    this.dx += t9.dx, this.dy += t9.dy, this.dz += t9.dz;
  }
};
function e4(t9, e6, i6) {
  switch (t9?.type) {
    case null:
    case void 0:
    case "line":
      return;
    case "bezier": {
      const { controlPoint1: c7, controlPoint2: s8 } = t9.curveDefinition;
      c7[0] += e6, c7[1] += i6, s8[0] += e6, s8[1] += i6;
      break;
    }
    case "circular-arc": {
      const { interiorPoint: c7 } = t9.curveDefinition;
      c7[0] += e6, c7[1] += i6;
      break;
    }
    case "elliptic-arc-4":
    case "elliptic-arc-7": {
      const { centerPoint: c7 } = t9.curveDefinition;
      c7[0] += e6, c7[1] += i6;
    }
  }
}

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/OffsetEdgeVertex.js
var M6 = class _M {
  get plane() {
    return this._plane;
  }
  get requiresSplitEdgeLeft() {
    return !this._left.isOriginalDirection;
  }
  get requiresSplitEdgeRight() {
    return !this._right.isOriginalDirection;
  }
  get edgeDirection() {
    return this._edgeDirection;
  }
  constructor(t9, i6, e6, s8 = 0, n11 = 0) {
    this._helper = t9, this._planeType = i6, this._edge = e6, this.distance = s8, this._plane = j2(), this._offsetPlane = j2(), this._minDistance = -1 / 0, this._maxDistance = 1 / 0, this._selectedArrow = 1, 0 === n11 && this._initialize();
  }
  _initialize() {
    this._initializeNeighbors(), this._initializePlane(), this._initializeDistanceConstraints();
  }
  _initializeNeighbors() {
    const t9 = this._toXYZ(this._edge.leftVertex.pos), i6 = this._toXYZ(this._edge.leftVertex.leftSegment?.leftVertex?.pos), e6 = this._toXYZ(this._edge.rightVertex.pos), s8 = this._toXYZ(this._edge.rightVertex.rightSegment?.rightVertex?.pos);
    this._edgeDirection = K(n3(), t9, e6), i6 ? (this._left = this._computeNeighbor(t9, i6, this._edgeDirection), this._right = this._computeNeighbor(e6, s8, this._edgeDirection, this._left)) : (this._right = this._computeNeighbor(e6, s8, this._edgeDirection), this._left = this._computeNeighbor(t9, i6, this._edgeDirection, this._right));
  }
  _toXYZ(t9) {
    return null != t9 ? this._helper.toXYZ(t9) : null;
  }
  _pointToXYZ(t9) {
    return this._toXYZ(this._helper.pointToVector(t9));
  }
  _computeNeighbor(t9, i6, e6, s8) {
    const n11 = n3();
    if (i6) {
      K(n11, t9, i6);
      const s9 = !this._passesBisectingAngleThreshold(n11, e6);
      return { start: t9, end: i6, direction: s9 ? this._bisectVectorsPerpendicular(e6, n11) : n11, isOriginalDirection: !s9 };
    }
    return this._helper.hasZ() ? s8 && (_4(n11, e6, s8.direction), _4(n11, n11, e6), A(n11, n11), Math.sign(n11[1]) !== Math.sign(e6[0]) && g(n11, n11, -1)) : o(n11, -e6[1], e6[0], 0), { start: t9, end: i6, direction: n11, isOriginalDirection: true };
  }
  _passesBisectingAngleThreshold(t9, i6) {
    const e6 = Math.abs(a4(i6, t9));
    return e6 >= j4 && e6 <= Math.PI - j4;
  }
  _bisectVectorsPerpendicular(t9, i6) {
    const e6 = P2(t9, i6) < 0 ? t9 : y2(n3(), t9), s8 = Math.abs(P2(e6, i6));
    if (!(s8 < z3 || s8 > 1 - z3)) return this._bisectDirection(e6, i6);
    const n11 = _4(n3(), e6, [0, 0, 1]);
    return A(n11, n11);
  }
  _bisectDirection(t9, i6) {
    const e6 = u5(n3(), t9, i6);
    return A(e6, e6);
  }
  _initializePlane() {
    const t9 = this._computeNormalDirection(this._left), i6 = this._computeNormalDirection(this._right);
    P2(t9, i6) < 0 && y2(i6, i6), U(this._left.start, this._bisectDirection(t9, i6), this._plane);
  }
  _computeNormalDirection(t9) {
    const i6 = _4(n3(), t9.direction, this._edgeDirection);
    A(i6, i6);
    const e6 = _4(n3(), this._edgeDirection, i6);
    return 1 === this._planeType && (e6[2] = 0), A(e6, e6);
  }
  _initializeDistanceConstraints() {
    null == this._left.end || this.requiresSplitEdgeLeft || this._updateDistanceConstraint(X(this._plane, this._left.end)), null == this._right.end || this.requiresSplitEdgeRight || this._updateDistanceConstraint(X(this._plane, this._right.end)), this._updateIntersectDistanceConstraint(this._plane);
  }
  _updateDistanceConstraint(t9) {
    t9 <= 0 && (this._minDistance = Math.max(this._minDistance, t9)), t9 >= 0 && (this._maxDistance = Math.min(this._maxDistance, t9));
  }
  _updateIntersectDistanceConstraint(t9) {
    const i6 = k2(t9), h4 = this._edgeDirection, a8 = u5(n3(), this._left.start, this._left.direction), o5 = u5(n3(), this._right.start, this._right.direction), _6 = this._pointInBasis2D(n6(), i6, h4, this._left.start), l4 = this._pointInBasis2D(n6(), i6, h4, a8), p5 = this._pointInBasis2D(n6(), i6, h4, this._right.start), d3 = this._pointInBasis2D(n6(), i6, h4, o5), [u6] = M2({ start: l4, end: _6, type: 1 }, { start: d3, end: p5, type: 1 });
    if (!u6) return;
    const m7 = e2(n6(), _6, l4);
    v(m7, m7);
    const D2 = e2(n6(), u6, l4), x4 = j(m7, D2), N = u5(n3(), a8, g(n3(), this._left.direction, -x4)), P4 = X(t9, N);
    this._updateDistanceConstraint(P4);
  }
  _pointInBasis2D(t9, i6, e6, s8) {
    return t9[0] = f2(i6, s8), t9[1] = f2(e6, s8), t9;
  }
  _offset(t9, i6) {
    Number.isFinite(this._minDistance) && (i6 = Math.max(this._minDistance, i6)), Number.isFinite(this._maxDistance) && (i6 = Math.min(this._maxDistance, i6)), y3(this._offsetPlane, this._plane), this._offsetPlane[3] -= i6;
    const e6 = (t10, i7, e7) => null != i7 && J2(this._offsetPlane, t10, u5(n3(), t10, i7), e7), s8 = n3();
    (t9 === this._edge.leftVertex ? e6(this._left.start, this._left.direction, s8) : e6(this._right.start, this._right.direction, s8)) && this._helper.copy(this._helper.fromXYZ(s8, void 0, this._helper.getM(t9.pos)), t9.pos);
  }
  selectArrowFromStartPoint(t9) {
    this._selectedArrow = O(this.plane, this._pointToXYZ(t9)) ? 1 : -1;
  }
  get selectedArrow() {
    return this._selectedArrow;
  }
  signedDistanceToPoint(t9) {
    return X(this.plane, this._pointToXYZ(t9));
  }
  clampedStartAndEnd(i6) {
    const e6 = this._helper.toXYZ(this._helper.pointToVector(i6)), s8 = R(this._plane, e6, n3()), n11 = X(this._plane, e6), r14 = r2(n11, this._minDistance, this._maxDistance);
    return I2(e6, s8, e6, r14 / n11), { start: s8, end: e6 };
  }
  apply(t9) {
    this._offset(t9, this.distance);
  }
  undo(t9) {
    this._offset(t9, 0);
  }
  canAccumulate(t9) {
    return t9 instanceof _M && this._edge.leftVertex.index === t9._edge.leftVertex.index && this._edge.rightVertex.index === t9._edge.rightVertex.index && this._edge.part === t9._edge.part && this._maybeEqualsVec3(this._left.direction, t9._left.direction) && this._maybeEqualsVec3(this._right.direction, t9._right.direction) && J(k2(this._plane), k2(t9._plane));
  }
  accumulate(t9, i6) {
    const e6 = this._plane[3] - i6._plane[3] + i6.distance;
    this._offset(t9, e6);
  }
  accumulateParams(t9) {
    const i6 = t9.distance - t9._plane[3];
    this.distance = i6 + this._plane[3];
  }
  clone() {
    const t9 = new _M(this._helper, this._planeType, this._edge, this.distance, 1);
    return y3(t9._plane, this._plane), y3(t9._offsetPlane, this._offsetPlane), t9._maxDistance = this._maxDistance, t9._minDistance = this._minDistance, t9._left = this._cloneNeighbor(this._left), t9._right = this._cloneNeighbor(this._right), t9._edgeDirection = s3(n3(), this._edgeDirection), t9;
  }
  _maybeEqualsVec3(t9, i6) {
    return null == t9 && null == i6 || null != t9 && null != i6 && J(t9, i6);
  }
  _cloneNeighbor({ start: t9, end: i6, direction: e6, isOriginalDirection: s8 }) {
    return { start: s3(n3(), t9), end: null != i6 ? s3(n3(), i6) : null, direction: s3(n3(), e6), isOriginalDirection: s8 };
  }
};
var j4 = s(15);
var z3 = 1e-3;

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/RotateVertex.js
var o3 = class _o {
  constructor(t9, e6, i6 = 0) {
    this.origin = t9, this.angle = e6, this._accumulationType = i6;
  }
  _rotate(t9, i6) {
    I(t9.pos, t9.pos, this.origin, i6), n9(t9.leftSegment, this.origin, i6);
  }
  apply(t9) {
    this._rotate(t9, this.angle);
  }
  undo(t9) {
    this._rotate(t9, -this.angle);
  }
  canAccumulate(e6) {
    return e6 instanceof _o && h(this.origin, e6.origin);
  }
  accumulate(t9, e6) {
    const i6 = 1 === e6._accumulationType;
    this._rotate(t9, i6 ? e6.angle - this.angle : e6.angle);
  }
  accumulateParams(t9) {
    const e6 = 1 === t9._accumulationType;
    this.angle = e6 ? t9.angle : this.angle + t9.angle;
  }
};
function n9(t9, o5, n11) {
  switch (t9?.type) {
    case null:
    case void 0:
    case "line":
      return;
    case "bezier": {
      const { controlPoint1: i6, controlPoint2: r14 } = t9.curveDefinition;
      return I(i6, i6, o5, n11), void I(r14, r14, o5, n11);
    }
    case "circular-arc": {
      const { interiorPoint: i6 } = t9.curveDefinition;
      return void I(i6, i6, o5, n11);
    }
    case "elliptic-arc-4":
    case "elliptic-arc-7": {
      const r14 = t9.leftVertex.pos, a8 = I([0, 0], [r14[0], r14[1]], o5, -n11), c7 = t9.toCurveOrCoordinate(), [, s8, l4, u6, p5, g4, m7] = c3(a8, c7, o5, n11).a;
      if ("elliptic-arc-4" === t9.type) {
        const e6 = t9.curveDefinition;
        e6.centerPoint = [...s8], e6.sweep = l4, e6.orientation = u6;
      } else {
        const e6 = t9.curveDefinition;
        e6.centerPoint = [...s8], e6.sweep = l4, e6.orientation = u6, e6.rotation = p5, e6.semiMajorAxisLength = g4, e6.minorMajorAxisRatio = m7;
      }
    }
  }
}

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/ScaleVertex.js
var l3 = class _l {
  constructor(t9, i6, r14, o5, e6 = 0) {
    this.origin = t9, this.axis1 = i6, this.factor1 = r14, this.factor2 = o5, this._accumulationType = e6, this.axis2 = r6(i6[1], -i6[0]);
  }
  _scale({ pos: t9, leftSegment: i6 }, o5, a8) {
    const e6 = i6?.toCurveOrCoordinate(), { origin: s8, axis1: c7, axis2: n11 } = this;
    k(t9, t9, s8, c7, o5), k(t9, t9, s8, n11, a8), m6(i6, s8, c7, n11, o5, a8, e6);
  }
  apply(t9) {
    this._scale(t9, this.factor1, this.factor2);
  }
  undo(t9) {
    this._scale(t9, 1 / this.factor1, 1 / this.factor2);
  }
  canAccumulate(i6) {
    return i6 instanceof _l && h(this.origin, i6.origin) && h(this.axis1, i6.axis1);
  }
  accumulate(t9, i6) {
    1 === i6._accumulationType ? this._scale(t9, i6.factor1 / this.factor1, i6.factor2 / this.factor2) : this._scale(t9, i6.factor1, i6.factor2);
  }
  accumulateParams(t9) {
    const i6 = 1 === t9._accumulationType;
    this.factor1 = i6 ? t9.factor1 : this.factor1 * t9.factor1, this.factor2 = i6 ? t9.factor2 : this.factor2 * t9.factor2;
  }
};
function m6(t9, a8, l4, m7, h4, p5, u6) {
  switch (t9?.type) {
    case null:
    case void 0:
    case "line":
      return;
    case "bezier": {
      const { controlPoint1: i6, controlPoint2: o5 } = t9.curveDefinition;
      k(i6, i6, a8, l4, h4), k(i6, i6, a8, m7, p5), k(o5, o5, a8, l4, h4), k(o5, o5, a8, m7, p5);
      break;
    }
    case "circular-arc":
    case "elliptic-arc-4":
    case "elliptic-arc-7": {
      if (!u6) return;
      const r14 = t9.leftVertex.pos, x4 = c4(a8[0], a8[1], l4[0], l4[1], m7[0], m7[1], h4, p5), g4 = s2(e3(), x4), j6 = g4 ? z(n6(), [r14[0], r14[1]], g4) : r14, [, y6, _6, v4, b2, d3, A3] = m4(u6, [j6[0], j6[1]], t9, a8, l4, m7, h4, p5).a;
      if ("elliptic-arc-7" === t9.type) {
        const i6 = t9.curveDefinition;
        i6.centerPoint = y6, i6.sweep = _6, i6.orientation = v4, i6.rotation = b2, i6.semiMajorAxisLength = d3, i6.minorMajorAxisRatio = A3;
      } else {
        const i6 = new x2(t9.part, t9.leftVertex, t9.rightVertex, { centerPoint: y6, sweep: _6, orientation: v4, rotation: b2, semiMajorAxisLength: d3, minorMajorAxisRatio: A3 });
        t9.part.segments.splice(t9.part.segments.indexOf(t9), 1, i6);
      }
      return;
    }
  }
}

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/SetAllVertexPositions.js
var i5 = class _i {
  constructor(i6, t9) {
    this._editGeometry = i6, this._newPositions = t9;
  }
  apply() {
    const i6 = null == this._originalPositions ? "apply" : "redo";
    if (!this._originalPositions) {
      const i7 = this._editGeometry.coordinateHelper;
      this._originalPositions = [];
      for (const { pos: t9 } of this._editGeometry.iterateVertices()) this._originalPositions.push(i7.clone(t9));
    }
    this._apply(i6, this._newPositions);
  }
  undo() {
    this._originalPositions && this._apply("undo", this._originalPositions);
  }
  accumulate(t9) {
    return t9 instanceof _i && (this._newPositions = t9._newPositions, this._apply("apply", this._newPositions), true);
  }
  _apply(i6, t9) {
    const o5 = this._editGeometry.coordinateHelper, s8 = this._editGeometry.allVertices;
    for (let e6 = 0; e6 < s8.length; e6++) o5.copy(t9[e6], s8[e6].pos);
    this._editGeometry.parts.forEach((i7) => i7.unnormalizeVertexPositions()), this._editGeometry.notifyChanges({ operation: i6, updatedVertices: s8 });
  }
};

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/UndoGroup.js
var t8;
var s6 = Symbol();
var o4 = class {
  constructor(s8) {
    this._operations = [], this._closed = false, this[t8] = true, s8 && (this._operations = s8, this._closed = true);
  }
  close() {
    this._closed = true;
  }
  apply() {
    for (const t9 of this._operations) t9.apply();
  }
  undo() {
    for (let t9 = this._operations.length - 1; t9 >= 0; t9--) this._operations[t9].undo();
  }
  accumulate(t9) {
    if (this._closed) return false;
    const s8 = this._operations.length ? this._operations[this._operations.length - 1] : null;
    return s8 && s8.accumulate(t9) || (this._operations.push(t9), t9.apply()), true;
  }
};
t8 = s6;

// node_modules/@arcgis/core/views/interactive/editGeometry/EditGeometryOperations.js
var g2 = class _g extends r {
  constructor(e6, t9, r14 = false) {
    super(), this.data = e6, this.viewingMode = t9, this.allowCurves = r14, this._undoStack = [], this._redoStack = [], this._listener = this.data.on("change", (e7) => {
      e7.addedVertices && this.emit("vertex-add", { type: "vertex-add", vertices: e7.addedVertices, operation: e7.operation }), e7.removedVertices && this.emit("vertex-remove", { type: "vertex-remove", vertices: e7.removedVertices, operation: e7.operation }), e7.updatedVertices && this.emit("vertex-update", { type: "vertex-update", vertices: e7.updatedVertices, operation: e7.operation });
    });
  }
  destroy() {
    super.destroy(), this._listener.remove();
  }
  splitSegment(e6, t9) {
    return this._apply(new n8(this.data, e6, t9));
  }
  updateVertices(e6, t9, r14 = 1) {
    return this._apply(new t4(this.data, e6, t9), r14);
  }
  move(e6, t9, r14, s8 = 1) {
    return H2(this.data) ? this._apply(new t6(this.data, e6, t9, r14), s8) : this.moveVertices(this.data.allVerticesUnordered, e6, t9, r14, s8);
  }
  moveVertices(e6, t9, r14, s8, o5 = 1) {
    return H2(this.data) ? this._apply(new t6(this.data, t9, r14, s8), o5) : this.updateVertices(e6, new t7(this.data.coordinateHelper, t9, r14, s8), o5);
  }
  scale(e6, t9, r14, s8, i6 = 1, o5 = 0) {
    return this.scaleVertices(this.data.allVerticesUnordered, e6, t9, r14, s8, i6, o5);
  }
  scaleVertices(e6, t9, r14, s8, i6, o5 = 1, a8 = 0) {
    return this.updateVertices(e6, new l3(t9, r14, s8, i6, a8), o5);
  }
  rotate(e6, t9, r14 = 1, s8 = 0) {
    return this.rotateVertices(this.data.allVerticesUnordered, e6, t9, r14, s8);
  }
  rotateVertices(e6, t9, r14, s8 = 1, i6 = 0) {
    return this.updateVertices(e6, new o3(t9, r14, i6), s8);
  }
  removeVertices(e6) {
    return this._apply(new t5(this.data, e6, this._minNumVerticesPerType));
  }
  appendVertex(e6, t9) {
    return t9 ??= new V2(this.data.spatialReference, this.viewingMode), this._apply(new r11(this.data, t9, e6));
  }
  appendVertexToFirstPart(e6) {
    const t9 = this.data.parts.at(0);
    return t9 ? this._apply(new r11(this.data, t9, e6)) : null;
  }
  setVertexPosition(e6, t9) {
    return this._apply(new a6(this.data, e6, t9));
  }
  offsetEdge(e6, t9, r14, s8 = 1) {
    return this.updateVertices([t9.leftVertex, t9.rightVertex], new M6(this.data.coordinateHelper, e6, t9, r14), s8);
  }
  trySetGeometry(e6, t9 = 1) {
    const { data: r14 } = this, { coordinateHelper: o5 } = r14;
    if (r14.type !== e6.type || !r14.spatialReference.equals(e6.spatialReference) || o5.hasZ() !== e6.hasZ || o5.hasM() !== e6.hasM || !v2(r14.geometry, e6) || H2(r14)) return;
    const n11 = Array.from(w4.fromGeometry(e6, this.viewingMode, { allowCurves: this.allowCurves }).iterateVerticesUnordered(), (e7) => e7.pos);
    return this.setVertexPositions(n11, t9);
  }
  setVertexPositions(e6, t9 = 1) {
    return this._apply(new i5(this.data, e6), t9);
  }
  createResetState() {
    if (H2(this.data)) return this._createResetStateMesh();
    const e6 = this.data.geometry.clone();
    return e(() => this.trySetGeometry(e6));
  }
  closePart(e6) {
    return this.data.parts.includes(e6) ? this._apply(new r12(this.data, e6)) : null;
  }
  canRemoveVertex(e6) {
    return e6.vertices.length > this._minNumVerticesPerType;
  }
  createUndoGroup() {
    const e6 = new o4();
    return this._apply(e6), e(() => e6.close());
  }
  recordUndo(e6) {
    this._undoStack.push(e6), this._redoStack = [];
  }
  undo() {
    if (this._undoStack.length > 0) {
      const e6 = this._undoStack.pop();
      return e6.undo(), this._redoStack.push(e6), e6;
    }
    return null;
  }
  redo() {
    if (this._redoStack.length > 0) {
      const e6 = this._redoStack.pop();
      return e6.apply(), this._undoStack.push(e6), e6;
    }
    return null;
  }
  get canUndo() {
    return this._undoStack.length > 0;
  }
  get canRedo() {
    return this._redoStack.length > 0;
  }
  get lastOperation() {
    return this._undoStack.length > 0 ? this._undoStack[this._undoStack.length - 1] : null;
  }
  get _minNumVerticesPerType() {
    switch (this.data.type) {
      case "point":
        return 1;
      case "polyline":
        return 2;
      case "polygon":
        return 3;
      default:
        return 0;
    }
  }
  _apply(e6, t9 = 1) {
    return 0 !== t9 && null != this.lastOperation && this.lastOperation.accumulate(e6) || (e6.apply(), this.recordUndo(e6)), e6;
  }
  _createResetStateMesh() {
    if (!H2(this.data)) return e();
    const e6 = this.data.geometry, { vertexSpace: s8 } = e6;
    if (s8.origin) {
      const i6 = t2(s8.origin);
      return e(() => {
        e6.vertexSpace.origin = i6;
      });
    }
    const o5 = e6.vertexAttributes.clonePositional();
    return e(() => {
      e6.vertexAttributes = o5, e6.vertexAttributesChanged();
    });
  }
  static fromGeometry(e6, t9, r14) {
    return new _g(w4.fromGeometry(e6, t9, r14), t9, !!r14?.allowCurves);
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/SnappingContext.js
var e5 = class {
  constructor(e6) {
    this.vertexHandle = null, this.excludeFeature = null, this.visualizer = null, this.selfSnappingZ = null, this.drawConstraints = null, this.editGeometryOperations = e6.editGeometryOperations, this.elevationInfo = e6.elevationInfo, this.pointer = e6.pointer, this.vertexHandle = e6.vertexHandle, this.excludeFeature = e6.excludeFeature, this.feature = e6.feature, this.visualizer = e6.visualizer, this.selfSnappingZ = e6.selfSnappingZ, this.drawConstraints = e6.drawConstraints;
  }
  get coordinateHelper() {
    return this.editGeometryOperations.data.coordinateHelper;
  }
  get spatialReference() {
    return this.coordinateHelper.spatialReference;
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/SnappingVisualizer.js
var r13 = class {
  draw(r14, p5) {
    const h4 = a7(r14), f4 = this.sortUniqueHints(h4), u6 = [];
    for (const i6 of f4) i6 instanceof i4 && u6.push(this.visualizeIntersectionPoint(i6, p5)), i6 instanceof s5 && u6.push(this.visualizeLine(i6, p5)), i6 instanceof r7 && u6.push(this.visualizeParallelSign(i6, p5)), i6 instanceof r8 && u6.push(this.visualizeRightAngleQuad(i6, p5)), i6 instanceof n7 && u6.push(this.visualizePoint(i6, p5));
    return t(u6);
  }
  sortUniqueHints(i6) {
    return i6;
  }
};
function a7(i6) {
  const n11 = [];
  for (const t9 of i6) {
    let i7 = true;
    for (const s8 of n11) if (t9.equals(s8)) {
      i7 = false;
      break;
    }
    i7 && n11.push(t9);
  }
  return n11;
}

// node_modules/@arcgis/core/views/interactive/tooltip/fields/TooltipField.js
var s7 = class extends b {
  constructor(t9) {
    super(t9), this.actual = null, this.lockable = true, this.id = n2(), this.inputValue = null, this.readOnly = false, this.suffix = null, this.visible = true, this.invalid = false, this.unlockOnVertexPlacement = true;
  }
  get committed() {
    return this.lockable ? this._get("committed") : null;
  }
  set committed(t9) {
    this.lockable && this._set("committed", t9);
  }
  get dirty() {
    return null != this.inputValue;
  }
  get locked() {
    return this.lockable && null != this.committed;
  }
  onInput(t9) {
    this.inputValue = t9, this.invalid = false;
  }
  onCommit(t9, o5, i6) {
    this.lockable ? this._onCommitLockable(t9, i6) : this._onCommitNonLockable(i6), this.invalid && "commit-and-exit" === t9 || i6.onCommit(o5, t9);
  }
  _onCommitLockable(t9, o5) {
    const { inputValue: i6, locked: l4 } = this;
    l4 && n10(i6) ? this.unlock() : ("commit-and-exit" === t9 && !l4 || null != i6) && this._parseInputAndLock(o5);
  }
  _onCommitNonLockable(t9) {
    const { inputValue: o5 } = this;
    n10(o5) ? this.lockable ? this.setActual(null) : this.clearInputValue() : null != o5 && this._parseInputAndSetActual(t9);
  }
  applyValue(t9) {
    this.lockable ? this.lock(t9) : this.setActual(t9);
  }
  clearInputValue() {
    this.inputValue = null, this.invalid = false;
  }
  setActual(t9) {
    this.actual = t9, this.clearInputValue();
  }
  lock(t9) {
    this.lockable && (this.committed = t9 ?? this.actual, this.clearInputValue());
  }
  unlock() {
    this.lockable && (this.committed = null, this.clearInputValue());
  }
  toggleLock(t9) {
    this.lockable && (this.locked ? this.unlock() : this._parseInputAndLock(t9));
  }
  getSuffix(t9) {
    const { suffix: o5 } = this;
    return "function" == typeof o5 ? o5(t9) : o5;
  }
  getFormattedValue(t9) {
    const { actual: o5, committed: i6, format: l4 } = this;
    return null != i6 ? l4(i6, t9) : null != o5 ? l4(o5, t9) : null;
  }
  getRawDisplayValue(t9) {
    const { actual: o5, committed: i6, inputValue: l4 } = this;
    return null != l4 ? l4 : this.lockable && null != i6 ? this.formatForInputMode(i6, t9) : null != o5 ? this.formatForInputMode(o5, t9) : null;
  }
  _parseInputAndSetActual(t9) {
    const { inputValue: o5 } = this;
    if (null == o5 || n10(o5)) return this.setActual(null);
    const i6 = this.parse(o5, t9);
    null != i6 ? this.setActual(i6) : this.invalid = true;
  }
  _parseInputAndLock(t9) {
    const { inputValue: o5, actual: i6 } = this;
    if (n10(o5)) return this.unlock();
    if (null == o5) return this.lock(i6);
    const l4 = this.parse(o5, t9);
    null != l4 ? this.lock(l4) : this.invalid = true;
  }
};
function n10(t9) {
  return null != t9 && "" === t9.trim();
}
__decorate([m()], s7.prototype, "actual", void 0), __decorate([m()], s7.prototype, "committed", null), __decorate([m()], s7.prototype, "dirty", null), __decorate([m()], s7.prototype, "format", void 0), __decorate([m()], s7.prototype, "formatForInputMode", void 0), __decorate([m()], s7.prototype, "lockable", void 0), __decorate([m()], s7.prototype, "locked", null), __decorate([m()], s7.prototype, "id", void 0), __decorate([m()], s7.prototype, "inputValue", void 0), __decorate([m()], s7.prototype, "name", void 0), __decorate([m()], s7.prototype, "parse", void 0), __decorate([m()], s7.prototype, "readOnly", void 0), __decorate([m()], s7.prototype, "suffix", void 0), __decorate([m()], s7.prototype, "title", void 0), __decorate([m()], s7.prototype, "visible", void 0), __decorate([m()], s7.prototype, "invalid", void 0), __decorate([m()], s7.prototype, "unlockOnVertexPlacement", void 0), s7 = __decorate([a("esri.views.interactive.tooltip.fields.TooltipField")], s7);

// node_modules/@arcgis/core/views/interactive/tooltip/fields/TooltipFieldElevation.js
var c5 = class extends s7 {
  constructor(t9) {
    super(t9), this.showAsZ = false;
  }
  normalizeCtorArgs(t9) {
    const s8 = (t10) => t10.inputUnitInfos.verticalLength.unit;
    return { name: "elevation", actual: d, parse: B({ createQuantity: (t10, o5) => a5(t10, s8(o5)) }), format: (t10, o5) => o5.formatters.verticalLength(t10), formatForInputMode: (t10, o5) => o5.formatters.scalar(s4(t10, s8(o5))), suffix: (t10) => t10.inputUnitInfos.verticalLength.abbreviation, title: (t10) => t10.messages.sketch[this.showAsZ ? "z" : "elevation"], unlockOnVertexPlacement: false, ...t9 };
  }
};
__decorate([m()], c5.prototype, "showAsZ", void 0), c5 = __decorate([a("esri.views.interactive.tooltip.fields.TooltipFieldElevation")], c5);

// node_modules/@arcgis/core/views/interactive/tooltip/fields/TooltipFieldOrientation.js
var c6 = class extends s7 {
  constructor(t9) {
    super(t9), this.precision = 1;
  }
  normalizeCtorArgs(t9) {
    const i6 = (t10) => t10.inputUnitInfos.angle.unit;
    return { name: "orientation", actual: null, parse: B({ createQuantity: (t10, r14) => c2(t10, i6(r14), "geographic"), sanitize: C }), format: (t10) => {
      const o5 = M3(t10);
      return F(o5, "geographic", this.precision);
    }, formatForInputMode: (t10, r14) => {
      const o5 = M3(t10);
      return r14.formatters.scalar(o5);
    }, suffix: (t10) => t10.inputUnitInfos.angle.abbreviation, title: (t10) => t10.messages.sketch.orientation, ...t9 };
  }
};
__decorate([m()], c6.prototype, "precision", void 0), c6 = __decorate([a("esri.views.interactive.tooltip.fields.TooltipFieldOrientation")], c6);

// node_modules/@arcgis/core/views/interactive/tooltip/fields/TooltipFieldSize.js
var p4 = class extends s7 {
  constructor(t9) {
    super(t9), this.precision = null;
  }
  normalizeCtorArgs(t9) {
    const s8 = (t10) => t10.inputUnitInfos.length.unit;
    return { name: "size", actual: null, parse: B({ createQuantity: (t10, o5) => a5(t10, s8(o5)) }), format: (t10, o5) => o5.formatters.length(t10), formatForInputMode: (t10, r14) => r14.formatters.scalar(s4(t10, s8(r14))), suffix: (t10) => t10.inputUnitInfos.length.abbreviation, title: (t10) => t10.messages.sketch.size, ...t9 };
  }
};
__decorate([m()], p4.prototype, "precision", void 0), p4 = __decorate([a("esri.views.interactive.tooltip.fields.TooltipFieldSize")], p4);

// node_modules/@arcgis/core/views/interactive/tooltip/fields/fields.js
function I3(e6) {
  const a8 = (t9) => t9.inputUnitInfos.angle.unit, n11 = (t9) => t9.sketchOptions.values.effectiveDirectionMode;
  return new s7({ name: "direction", actual: j3, parse: B({ createQuantity: (t9, e7) => c2(t9, a8(e7), "geographic"), sanitize: C }), format: (t9, e7) => {
    const a9 = n11(e7), r14 = w(t9, a9);
    switch (a9) {
      case "absolute":
        return e7.formatters.direction(r14);
      case "relative":
        return e7.formatters.directionRelative(r14);
      case "relative-bilateral":
        return e7.formatters.directionRelativeBilateral(r14);
    }
  }, formatForInputMode: (t9, e7) => {
    const i6 = w(t9, n11(e7));
    return e7.formatters.scalar(s4(i6, a8(e7)));
  }, suffix: (t9) => t9.inputUnitInfos.angle.abbreviation, title: (t9) => {
    const e7 = n11(t9), { absolute: a9, relative: r14 } = t9.messages.sketch.direction;
    switch (e7) {
      case "absolute":
        return a9;
      case "relative":
      case "relative-bilateral":
        return r14;
    }
  }, ...e6 });
}
function y5(t9) {
  const e6 = (t10) => t10.inputUnitInfos.length.unit;
  return new s7({ name: "distance", actual: d, parse: B({ createQuantity: (t10, a8) => a5(Math.max(t10, 0), e6(a8)) }), format: (t10, e7) => e7.formatters.length(t10), formatForInputMode: (t10, a8) => a8.formatters.scalar(s4(t10, e6(a8))), suffix: (t10) => t10.inputUnitInfos.length.abbreviation, title: (t10) => t10.messages.sketch.distance, ...t9 });
}
function U2(t9) {
  return y5({ format: (t10, e6) => e6.formatters.totalLength(t10), title: (t10) => t10.messages.sketch.totalLength, readOnly: true, ...t9 });
}
function w5(t9) {
  return y5({ ...t9 });
}
function F2(t9) {
  const e6 = (t10) => t10.inputUnitInfos.length.unit;
  return y5({ ...t9, parse: B({ createQuantity: (t10, a8) => a5(t10, e6(a8)) }), format: (t10, e7) => e7.formatters.lengthRelative(t10) });
}
function x3(t9) {
  return new c5(t9);
}
function M7(t9) {
  return new c6(t9);
}
function k3(t9) {
  return new p4(t9);
}
function j5(t9) {
  return z4("scale", { name: "scale", actual: null, parse: B({ createQuantity: (t10) => i3(Math.abs(t10)) }), ...t9 });
}
function Q(t9) {
  const e6 = (t10) => t10.inputUnitInfos.area.unit;
  return new s7({ name: "area", actual: T2, parse: B({ createQuantity: (t10, a8) => l2(t10, e6(a8)) }), format: (t10, e7) => e7.formatters.area(t10), formatForInputMode: (t10, a8) => a8.formatters.scalar(s4(t10, e6(a8))), suffix: (t10) => t10.inputUnitInfos.area.abbreviation, title: (t10) => t10.messages.sketch.area, readOnly: true, ...t9 });
}
function D(e6) {
  return new s7({ name: "x", actual: j3, parse: H, format: (t9, e7) => e7.formatters.longitudeDecimalDegrees(t9), formatForInputMode: (t9) => w2(t9), suffix: (t9) => t9.inputUnitInfos.angle.abbreviation, title: (t9) => t9.messages.sketch.longitude, ...e6 });
}
function O2(e6) {
  return new s7({ name: "y", actual: j3, parse: J3, format: (t9, e7) => e7.formatters.latitudeDecimalDegrees(t9), formatForInputMode: (t9) => A2(t9), suffix: (t9) => t9.inputUnitInfos.angle.abbreviation, title: (t9) => t9.messages.sketch.latitude, ...e6 });
}
function T3(t9) {
  return z4("x", { name: "x", ...t9 });
}
function R4(t9) {
  return z4("y", { name: "y", ...t9 });
}
function z4(t9, a8) {
  return new s7({ actual: i3(0), parse: B({ createQuantity: (t10) => i3(t10) }), format: (t10, e6) => e6.formatters.scalar(t10), formatForInputMode: (t10, e6) => e6.formatters.scalar(t10), title: (e6) => e6.messages.sketch[t9], ...a8 });
}

// node_modules/@arcgis/core/views/interactive/tooltip/infos/TooltipInfoWithCoordinates.js
var h3 = (h4) => {
  const f4 = h4;
  let m7 = class extends f4 {
    constructor() {
      super(...arguments), this.longitude = D(), this.latitude = O2(), this.x = T3(), this.y = R4(), this.elevation = x3(), this.geographic = false;
    }
    get effectiveX() {
      return this.geographic ? this.longitude : this.x;
    }
    get effectiveY() {
      return this.geographic ? this.latitude : this.y;
    }
    get key() {
      return { longitude: this.longitude.actual, latitude: this.latitude.actual, x: this.x.actual, y: this.y.actual, elevation: this.elevation.actual, geographic: this.geographic };
    }
    setLocationFromPoint(t9, i6 = t9?.spatialReference) {
      if (this.geographic = !!i6 && r9(i6), null == t9) return this._setActualLonLat(null, null), void this._setActualXY(null, null);
      if (this.geographic) {
        const e6 = i(t9, g3);
        this._setActualLonLat(K2(e6?.[0]), K2(e6?.[1]));
      } else this._setActualXY(i3(t9.x), i3(t9.y));
    }
    _setActualLonLat(t9, e6) {
      this.longitude.actual = t9, this.latitude.actual = e6;
    }
    _setActualXY(t9, e6) {
      this.x.actual = t9, this.y.actual = e6;
    }
  };
  return __decorate([m()], m7.prototype, "geographic", void 0), __decorate([m()], m7.prototype, "effectiveX", null), __decorate([m()], m7.prototype, "effectiveY", null), __decorate([m()], m7.prototype, "key", null), m7 = __decorate([a("esri.views.interactive.tooltip.infos.TooltipInfoWithCoordinates")], m7), m7;
};
var g3 = [0, 0];

export {
  r13 as r,
  I3 as I,
  U2 as U,
  w5 as w,
  F2 as F,
  M7 as M,
  k3 as k,
  j5 as j,
  Q,
  h3 as h,
  w3 as w2,
  V2 as V,
  w4 as w3,
  t4 as t,
  t7 as t2,
  M6 as M2,
  o3 as o,
  l3 as l,
  g2 as g,
  e5 as e
};
//# sourceMappingURL=chunk-K5ZF6G4K.js.map
