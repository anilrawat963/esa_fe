import {
  M,
  q,
  v
} from "./chunk-CJCWAWMZ.js";
import {
  o
} from "./chunk-UJWW5AN2.js";
import {
  Al,
  Cc,
  Dc,
  Hu,
  I,
  Ps,
  Rg,
  Vc,
  Wl,
  Wo,
  X,
  Xl,
  cs2 as cs,
  ds,
  fm,
  mg,
  qh,
  ql,
  ur,
  zt
} from "./chunk-RKVVFTIZ.js";
import {
  s
} from "./chunk-WJ5RYEGC.js";
import {
  x as x2
} from "./chunk-7TAAMEZT.js";
import {
  n as n2
} from "./chunk-257FD5T2.js";
import {
  $t,
  P,
  Pt,
  a,
  b,
  ct,
  h,
  mi,
  n,
  w,
  x2 as x
} from "./chunk-ZNI54T6D.js";
import {
  __addDisposableResource,
  __disposeResources
} from "./chunk-SS5CLIUY.js";

// node_modules/@arcgis/core/chunks/OperatorShapePreservingDensify.js
var o2 = class {
  getOperatorType() {
    return 10317;
  }
  supportsCurves() {
    return true;
  }
  accelerateGeometry(e, r, t) {
    return false;
  }
  canAccelerateGeometry(e) {
    return false;
  }
  executeMany(e, t, o3, n3, s2, u) {
    return new o(e, t, 4, o3, n3, s2, u);
  }
  execute(r, o3, n3, s2, u, a2) {
    const c = new s([r]), m = this.executeMany(c, o3, n3, s2, u, a2).next();
    return m || b("null output"), m;
  }
};

// node_modules/@arcgis/core/chunks/GeodeticDistanceCalculator-Ce-woMPw.js
function Y() {
  return new n2();
}
var k = class {
  [Symbol.dispose]() {
    this.m_peR1.destroy(), this.m_peR2.destroy(), this.m_peR3.destroy(), this.m_peR1 = null, this.m_peR2 = null, this.m_peR3 = null;
  }
  constructor(t, e, i) {
    this.m_peR1 = new Cc(), this.m_peR2 = new Cc(), this.m_peR3 = new Cc(), void 0 !== t ? this.reset(t, e, i) : this.reset(1, 0, 1);
  }
  reset(t, e, i) {
    this.m_a = t, this.m_e2 = e, this.m_b = this.m_a * Math.sqrt(1 - this.m_e2), this.m_unitToDegree = i, this.m_unitToRad = 0.017453292519943295 * i, this.m_u180 = 180 / this.m_unitToDegree, this.m_u360 = 360 / this.m_unitToDegree;
  }
  calculateBbox(t, e, i, s2) {
    const n3 = this.m_peR1, o3 = this.m_peR2, a2 = this.m_peR3;
    Dc.geodeticDistance(this.m_a, this.m_e2, t * this.m_unitToRad, e * this.m_unitToRad, i * this.m_unitToRad, s2 * this.m_unitToRad, a2, n3, o3, 0);
    const m = Math.cos(n3.val), r = Math.cos(o3.val + 3.141592653589793), u = e * this.m_unitToRad, h2 = Vc.phiToEta(this.m_e2, u), c = Math.sin(n3.val) * Math.cos(h2);
    let l = e;
    if (m * r < 0) {
      const t2 = m < 0 ? -1 : 1, e2 = Math.acos(Math.abs(c)) * t2;
      l = Vc.etaToPhi(this.m_e2, e2) / this.m_unitToRad;
    }
    let _ = ct((i - t) * this.m_unitToRad, 2 * Math.PI);
    Math.abs(_) > Math.PI && (_ = _ > 0 ? _ - 2 * Math.PI : _ + 2 * Math.PI), _ /= this.m_unitToRad, i = t + _;
    const d = Y();
    return d.xmin = Math.min(t, i), d.xmax = Math.max(t, i), d.ymin = Math.min(e, s2), d.ymin = Math.min(d.ymin, l), d.ymax = Math.max(e, s2), d.ymax = Math.max(d.ymax, l), d;
  }
  minDistanceGeodesic(t, e) {
    const i = O(t), s2 = O(e);
    if (i && s2) return this.lowerDistanceGeodetic_(t.xmin, t.ymin, e.xmin, e.ymin);
    const n3 = this.normalizeGeodesic_(e, t);
    return U(t, n3) ? t.ymin >= n3.ymax ? this.minDistanceGeodesicUpDown_(t, n3) : n3.ymin >= t.ymax ? this.minDistanceGeodesicUpDown_(n3, t) : t.xmin > n3.xmax ? this.minDistanceGeodesicLeftRight_(n3, t) : this.minDistanceGeodesicLeftRight_(t, n3) : 0;
  }
  normalizeGeodesic_(t, e) {
    const i = t.clone(), s2 = t.clone();
    let n3 = V(i, e);
    if (0 === n3) return i;
    for (; s2.xmax > e.xmin; ) {
      s2.xmin -= this.m_u360, s2.xmax -= this.m_u360;
      const t2 = V(s2, e);
      if (t2 < n3 && (i.assign(s2), n3 = t2, 0 === n3)) return i;
    }
    for (s2.assign(t); s2.xmin < e.xmax; ) {
      s2.xmin += this.m_u360, s2.xmax += this.m_u360;
      const t2 = V(s2, e);
      if (t2 < n3 && (i.assign(s2), n3 = t2, 0 === n3)) return i;
    }
    return i;
  }
  lowerDistanceGeodetic_(t, e, i, s2) {
    const n3 = this.m_peR1;
    {
      const o3 = this.m_b * this.m_b / this.m_a, a2 = Vc.phiToPhig(this.m_e2, this.m_unitToRad * e), m = Vc.phiToPhig(this.m_e2, this.m_unitToRad * s2);
      Dc.geodeticDistance(o3, 0, this.m_unitToRad * t, a2, this.m_unitToRad * i, m, n3, null, null, 0);
    }
    return n3.val;
  }
  minDistanceGeodesicUpDown_(t, e) {
    if (e.xmin <= t.xmin ? e.xmax >= t.xmin : t.xmax >= e.xmin) return this.lowerDistanceGeodetic_(0, t.ymin, 0, e.ymax);
    if (e.xmin > t.xmax) {
      const i = this.lowerDistanceGeodeticSegMeridional_(t.xmax, t.ymin, t.ymax, e.xmin, e.ymin, e.ymax);
      if (e.xmax - t.xmin < this.m_u180) return i;
      const s2 = this.lowerDistanceGeodeticSegMeridional_(t.xmin, t.ymin, t.ymax, e.xmax, e.ymin, e.ymax);
      return Math.min(i, s2);
    }
    {
      const i = this.lowerDistanceGeodeticSegMeridional_(t.xmin, t.ymin, t.ymax, e.xmax, e.ymin, e.ymax);
      if (t.xmax - e.xmin < this.m_u180) return i;
      const s2 = this.lowerDistanceGeodeticSegMeridional_(t.xmax, t.ymin, t.ymax, e.xmin, e.ymin, e.ymax);
      return Math.min(i, s2);
    }
  }
  minDistanceGeodesicLeftRight_(t, e) {
    let i = Math.abs(t.xmax - e.xmin);
    for (; i > this.m_u180; ) i -= this.m_u360;
    let s2 = Math.abs(t.xmin - e.xmax);
    for (; s2 > this.m_u180; ) s2 -= this.m_u360;
    return Math.abs(i) <= Math.abs(s2) ? this.minDistanceGeodesicLeftRightNormalized_(t, e) : this.minDistanceGeodesicLeftRightNormalized_(e, t);
  }
  minDistanceGeodesicLeftRightNormalized_(t, e) {
    let i, s2;
    return i = this.lowerDistanceGeodetic_(t.xmax, t.ymin, e.xmin, e.ymin), t.ymin >= e.ymin && t.ymin <= e.ymax && (s2 = this.lowerDistanceGeodeticPtMeridional_(t.xmax, t.ymin, e.xmin, e.ymin, e.ymax), i = Math.min(i, s2)), e.ymin >= t.ymin && e.ymin <= t.ymax && (s2 = this.lowerDistanceGeodeticPtMeridional_(e.xmin, e.ymin, t.xmax, t.ymin, t.ymax), i = Math.min(i, s2)), s2 = this.lowerDistanceGeodetic_(t.xmax, t.ymax, e.xmin, e.ymax), i = Math.min(i, s2), t.ymax >= e.ymin && t.ymax <= e.ymax && (s2 = this.lowerDistanceGeodeticPtMeridional_(t.xmax, t.ymax, e.xmin, e.ymin, e.ymax), i = Math.min(i, s2)), e.ymax >= t.ymin && e.ymax <= t.ymax && (s2 = this.lowerDistanceGeodeticPtMeridional_(e.xmin, e.ymax, t.xmax, t.ymin, t.ymax), i = Math.min(i, s2)), i;
  }
  lowerDistanceGeodeticSegMeridional_(t, e, i, s2, n3, o3) {
    let a2 = this.lowerDistanceGeodeticPtMeridional_(t, e, s2, n3, o3);
    const m = this.lowerDistanceGeodeticPtMeridional_(t, i, s2, n3, o3);
    let r = this.lowerDistanceGeodeticPtMeridional_(s2, n3, t, e, i);
    const u = this.lowerDistanceGeodeticPtMeridional_(s2, o3, t, e, i);
    return a2 = Math.min(a2, m), r = Math.min(r, u), Math.min(a2, r);
  }
  lowerDistanceGeodeticPtMeridional_(t, e, i, s2, n3) {
    const o3 = this.m_b * this.m_b / this.m_a, a2 = Vc.phiToPhig(this.m_e2, this.m_unitToRad * e), m = Vc.phiToPhig(this.m_e2, this.m_unitToRad * s2), r = Vc.phiToPhig(this.m_e2, this.m_unitToRad * n3), u = this.m_peR1, h2 = this.m_peR2;
    Dc.geodeticDistance(o3, 0, this.m_unitToRad * i, m, this.m_unitToRad * t, a2, u, null, null, 0), Dc.geodeticDistance(o3, 0, this.m_unitToRad * i, r, this.m_unitToRad * t, a2, h2, null, null, 0);
    const c = ds(1, 0, new mi(this.m_unitToRad * t, a2)), l = ds(1, 0, new mi(this.m_unitToRad * i, m)), _ = ds(1, 0, new mi(this.m_unitToRad * i, r));
    let g = new X();
    g.setCrossProductVector(l, _);
    const x3 = l.dotProduct(_);
    if (g.length() < 1568e-13) return x3 >= 0 ? Math.min(u.val, h2.val) : 0;
    g = g.getUnitVector();
    let y = new X();
    if (y.setCrossProductVector(g, c), y.length() < 1568e-13) {
      return Math.min(u.val, h2.val) - 1e-5 * o3;
    }
    y = y.getUnitVector();
    let P2 = c.sub(g.mul(c.dotProduct(g)));
    {
      const e2 = new X();
      e2.setCrossProductVector(l, P2);
      const i2 = new X();
      i2.setCrossProductVector(P2, _);
      let s3 = g.dotProduct(e2) > 0 && g.dotProduct(i2) > 0;
      if (s3 || (P2.negateThis(), e2.setCrossProductVector(l, P2), i2.setCrossProductVector(P2, _), s3 = g.dotProduct(e2) > 0 && g.dotProduct(i2) > 0), s3) {
        P2 = P2.getUnitVector();
        const e3 = Ps(1, 0, P2), i3 = this.m_peR3;
        Dc.geodeticDistance(o3, 0, this.m_unitToRad * t, a2, e3.x, e3.y, i3, null, null, 0);
        const s4 = Math.min(u.val, h2.val);
        return Math.min(s4, i3.val);
      }
    }
    return Math.min(u.val, h2.val);
  }
};
function O(t) {
  return t.xmin === t.xmax && t.ymin === t.ymax;
}
function U(t, e) {
  return e.xmax < t.xmin || e.xmin > t.xmax || e.ymax < t.ymin || e.ymin > t.ymax;
}
function V(t, e) {
  let i, s2 = 0;
  return i = t.xmin - e.xmax, i > s2 && (s2 = i), i = e.xmin - t.xmax, i > s2 && (s2 = i), s2;
}
var L = class {
};
function j(t) {
  return { outPoint: void 0 === t ? new mi() : t.clone() };
}
function z(t, e) {
  t.outPoint.assign(e.outPoint);
}
function H() {
  return new n2();
}
var J = class {
  constructor(t, e, i, s2, n3 = 0, o3 = 4) {
    this.m_ptDistFrom = new mi(), this.m_segStartPt = new mi(), this.m_segEndPt = new mi(), this.m_geodeticLength = new Cc(), this.m_az12 = new Cc(), this.m_minGeodeticDist = new Cc(), this.m_segStartPt3d = new X(), this.m_segEndPt3d = new X(), this.m_sr = s2, this.m_distCurveType = n3, this.m_segCurveType = o3, this.m_inputGCS = this.m_sr.getGCS(), this.m_rpu = this.m_inputGCS.getUnit().getUnitToBaseFactor(), this.m_bIsPannablePcs = 2 === this.m_sr.getCoordinateSystemType() && this.m_sr.isPannable();
    const a2 = Hu();
    this.m_inputGCS.querySpheroidData(a2), this.m_a = a2.majorSemiAxis, this.m_eSquared = a2.e2, this.setPointDistFrom(t), this.setSegmentEndPoints(e, i);
  }
  setSegmentEndPoints(t, e) {
    this.m_segStartPt.assign(t), this.m_segEndPt.assign(e), this.m_bIsPannablePcs || (this.m_segStartPt.mulThis(this.m_rpu), this.m_segEndPt.mulThis(this.m_rpu)), 2 === this.m_segCurveType && (this.m_segStartPt3d.assign(ds(this.m_a, this.m_eSquared, this.m_segStartPt)), this.m_segEndPt3d.assign(ds(this.m_a, this.m_eSquared, this.m_segEndPt))), this.calculateAndUpdateSegmentLength();
  }
  setPointDistFrom(t) {
    this.m_ptDistFrom.assign(t), this.m_ptDistFrom.scale(this.m_rpu);
  }
  setSegmentCurveType(t) {
    this.m_segCurveType = t;
  }
  setDistanceCurveType(t) {
    this.m_distCurveType = t;
  }
  makeFunctor() {
    return (i) => {
      let s2;
      switch (this.m_segCurveType) {
        case 0:
        case 1:
        case 3: {
          const o3 = { stack: [], error: void 0, hasError: false };
          try {
            const e = __addDisposableResource(o3, new Cc(), false), n3 = __addDisposableResource(o3, new Cc(), false);
            Dc.geodeticCoordinate(this.m_a, this.m_eSquared, this.m_segStartPt.x, this.m_segStartPt.y, this.m_geodeticLength.val * i, this.m_az12.val, e, n3, this.m_segCurveType), s2 = new mi(e.val, n3.val);
            break;
          } catch (n3) {
            o3.error = n3, o3.hasError = true;
          } finally {
            __disposeResources(o3);
          }
        }
        case 2: {
          const t = X.lerp(this.m_segStartPt3d, this.m_segEndPt3d, i);
          s2 = Ps(this.m_a, this.m_eSquared, t);
          break;
        }
        case 4:
          s2 = mi.lerp(this.m_segStartPt, this.m_segEndPt, i), this.m_bIsPannablePcs && (mg(this.m_sr, 0, [s2], 1), s2.mulThis(this.m_rpu));
          break;
        default:
          b("Invalid curve type");
      }
      return Dc.geodeticDistance(this.m_a, this.m_eSquared, this.m_ptDistFrom.x, this.m_ptDistFrom.y, s2.x, s2.y, this.m_minGeodeticDist, null, null, this.m_distCurveType), this.m_minGeodeticDist.val;
    };
  }
  calculateAndUpdateSegmentLength() {
    switch (this.m_segCurveType) {
      case 0:
      case 2:
      case 1:
      case 3:
        Dc.geodeticDistance(this.m_a, this.m_eSquared, this.m_segStartPt.x, this.m_segStartPt.y, this.m_segEndPt.x, this.m_segEndPt.y, this.m_geodeticLength, this.m_az12, null, this.m_segCurveType);
        break;
      case 4:
        this.m_geodeticLength.val = mi.distance(this.m_segStartPt, this.m_segEndPt);
        break;
      default:
        b("Invalid curve type");
    }
  }
  [Symbol.dispose]() {
    this.m_geodeticLength[Symbol.dispose](), this.m_az12[Symbol.dispose](), this.m_minGeodeticDist[Symbol.dispose]();
  }
};
function K() {
  return new L();
}
var Q = class {
  [Symbol.dispose]() {
    this.m_envHelper[Symbol.dispose]();
  }
  constructor(t, e, i, s2, n3) {
    this.m_boxGeomA = H(), this.m_boxGeomB = H(), this.m_envGeomA = new n2(), this.m_envGeomB = new n2(), this.m_progressCounter = 0, this.m_transformPCS2GCS = null, this.m_segmentBoxesA = /* @__PURE__ */ new Map(), this.m_segmentBoxesB = /* @__PURE__ */ new Map(), this.m_boundaryPtsA = [], this.m_boundaryPtsB = [], this.m_scaleToRadians = new x2(), this.m_scaleToDegrees = new x2(), this.m_inputSR = t, this.m_distCurveType = e, this.m_progressTracker = i, this.m_maxDistance = s2, this.m_maxDeviation = n3, this.m_inputGCS = t.getGCS(), this.m_peGeogcs = this.m_inputGCS.getPECoordSys(), this.m_tolerance = 0;
    const o3 = Hu();
    this.m_inputGCS.querySpheroidData(o3), this.m_a = o3.majorSemiAxis, this.m_eSquared = o3.e2, this.m_rpu = this.m_inputGCS.getUnit().getUnitToBaseFactor(), this.m_envHelper = new k(this.m_a, this.m_eSquared, 1), 4 === this.m_distCurveType && (this.m_distCurveType = 0), this.m_boxGeomA.setEmpty(), this.m_boxGeomB.setEmpty(), this.m_envGeomA.setEmpty(), this.m_envGeomB.setEmpty(), this.m_bIsPannablePcs = 2 === this.m_inputSR.getCoordinateSystemType() && this.m_inputSR.isPannable();
  }
  progress(t = false) {
  }
  calculate(t, e, i, s2) {
    const n3 = j(), o3 = j();
    if (t.queryEnvelope(this.m_envGeomA), e.queryEnvelope(this.m_envGeomB), this.checkGeometriesIntersect(t, e, n3, o3)) return i && z(i, n3), s2 && z(s2, o3), 0;
    const a2 = this.prepareGeometry(t);
    if (a2.isEmpty()) return Number.NaN;
    const m = this.prepareGeometry(e);
    if (m.isEmpty()) return Number.NaN;
    this.m_tolerance = this.computeTolerance(a2, m);
    const r = this._ExecuteBruteForce(a2, m, n3, o3);
    return r >= this.m_maxDistance ? Number.NaN : (i && (this.prepareOutput(n3), z(i, n3)), s2 && (this.prepareOutput(o3), z(s2, o3)), r);
  }
  createDistanceFunctor(t, e, i) {
    const s2 = new J(t, e, i, this.m_inputSR, this.m_distCurveType);
    return this.m_bIsPannablePcs || 1 === this.m_inputSR.getCoordinateSystemType() || s2.setSegmentCurveType(2), s2;
  }
  _NormalizeAndProject(t) {
    if (this.m_inputSR.isPannable() && (t = new qh().foldInto360Range(t, this.m_inputSR)), 2 === this.m_inputSR.getCoordinateSystemType()) {
      const e = Rg(this.m_inputSR, this.m_inputGCS, null);
      t = new qh().execute(t, e, this.m_progressTracker);
    }
    return t;
  }
  _ExecuteBruteForce(t, e, n3, o3) {
    switch (t.getGeometryType()) {
      case a.enumPoint:
        return this.calculateDistanceGeodeticPointGeometry(t, e, n3, o3);
      case a.enumMultiPoint:
        return this.calculateDistanceGeodeticMultipointGeometry(t, e, n3, o3);
      case a.enumPolyline:
      case a.enumPolygon:
      case a.enumEnvelope:
        return this.calculateDistanceGeodeticMultipathGeometry(t, e, n3, o3);
      default:
        P("");
    }
  }
  calculateDistanceGeodeticPointGeometry(t, e, n3, o3) {
    switch (e.getGeometryType()) {
      case a.enumPoint:
        return this.calculateDistanceGeodeticPointPoint(t, e, n3, o3);
      case a.enumMultiPoint:
        return this.calculateDistanceGeodeticPointMultipoint(t, e, n3, o3);
      case a.enumPolyline:
      case a.enumPolygon:
        return this.calculateDistanceGeodeticPointMultipath(t, e, n3, o3);
      default:
        P("");
    }
  }
  calculateDistanceGeodeticPointPoint(i, s2, n3, o3) {
    const a2 = { stack: [], error: void 0, hasError: false };
    try {
      const e = i.getXY();
      e.scale(this.m_rpu);
      const m = s2.getXY();
      m.scale(this.m_rpu), n3.outPoint.assign(e), o3.outPoint.assign(m);
      const r = __addDisposableResource(a2, new Cc(), false);
      return Dc.geodeticDistance(this.m_a, this.m_eSquared, e.x, e.y, m.x, m.y, r, null, null, this.m_distCurveType), r.val;
    } catch (m) {
      a2.error = m, a2.hasError = true;
    } finally {
      __disposeResources(a2);
    }
  }
  calculateDistanceGeodeticPointMultipoint(i, s2, n3, o3) {
    const a2 = { stack: [], error: void 0, hasError: false };
    try {
      this.computeEnvelopesAndBoxes(i, s2);
      const e = this.estimateMinimumDistance(n3, o3);
      let m = e < this.m_maxDistance ? e : this.m_maxDistance;
      const r = i.getXY();
      r.scale(this.m_rpu), n3.outPoint.assign(r);
      const u = ds(this.m_a, this.m_eSquared, r), h2 = new mi(), c = s2.getImpl(), l = __addDisposableResource(a2, new Cc(), false), g = c.getPointCount();
      for (let t = 0; t < g; ++t) {
        c.queryXY(t, h2), h2.scale(this.m_rpu);
        const e2 = ds(this.m_a, this.m_eSquared, h2);
        if (!(X.distance(u, e2) > m) && (!(this.m_envHelper.minDistanceGeodesic(this.m_boxGeomA, this.m_boxGeomB) > m) && (Dc.geodeticDistance(this.m_a, this.m_eSquared, r.x, r.y, h2.x, h2.y, l, null, null, this.m_distCurveType), l.val < m && (m = l.val, o3.outPoint = h2, 0 === m)))) return m;
      }
      return m === this.m_maxDistance ? Number.POSITIVE_INFINITY : m;
    } catch (m) {
      a2.error = m, a2.hasError = true;
    } finally {
      __disposeResources(a2);
    }
  }
  calculateDistanceGeodeticPointMultipath(i, s2, o3, a2) {
    const m = { stack: [], error: void 0, hasError: false };
    try {
      const e = new mi(), r = new mi();
      e.assign(i.getXY()), r.assign(i.getXY()), o3.outPoint.assign(r.mul(this.m_rpu)), this.m_bIsPannablePcs && Wl(this.m_inputSR, [e], 1, false), this.computeEnvelopesAndBoxes(i, s2);
      const u = this.estimateMinimumDistance(o3, a2);
      let h2 = u < this.m_maxDistance ? u : this.m_maxDistance;
      const c = s2.getImpl(), l = new mi(0, 0), _ = new mi(0, 0), p = [1], d = this.canUseSpatialTree(i, s2), x3 = K();
      d && this.buildSpatialTree(x3, s2);
      const y = H();
      y.setCoords({ xmin: r.x, ymin: r.y, xmax: r.x, ymax: r.y });
      const P2 = __addDisposableResource(m, this.createDistanceFunctor(r, l, _), false), S = c.querySegmentIterator();
      if (S.stripAttributes(), d) n(0);
      else for (; S.nextPath(); ) for (; S.hasNextSegment(); ) {
        const t = S.nextSegment(), i2 = this.findOrComputeBoxSegment(S.getStartPointIndex(), t, this.m_segmentBoxesB);
        if (this.m_envHelper.minDistanceGeodesic(y, i2) > h2) continue;
        const s3 = this.calculateDistanceGeodeticPointSegment(e, r, t, p, P2);
        if (s3.second < h2 && (this.updateOutputSegment(a2, t, s3.first), h2 = s3.second, 0 === h2)) return 0;
      }
      return h2 === this.m_maxDistance ? Number.POSITIVE_INFINITY : h2;
    } catch (r) {
      m.error = r, m.hasError = true;
    } finally {
      __disposeResources(m);
    }
  }
  calculateDistanceGeodeticMultipointGeometry(t, e, n3, o3) {
    switch (e.getGeometryType()) {
      case a.enumPoint:
        return this.calculateDistanceGeodeticPointMultipoint(e, t, o3, n3);
      case a.enumMultiPoint:
        return this.calculateDistanceGeodeticMultipointMultipoint(t, e, n3, o3);
      case a.enumPolyline:
      case a.enumPolygon:
      case a.enumEnvelope:
        return this.calculateDistanceGeodeticMultipointMultipath(t, e, n3, o3);
      default:
        P("");
    }
  }
  calculateDistanceGeodeticMultipointMultipoint(i, s2, n3, o3) {
    const a2 = { stack: [], error: void 0, hasError: false };
    try {
      const e = __addDisposableResource(a2, new Cc(), false);
      this.computeEnvelopesAndBoxes(i, s2);
      const m = this.estimateMinimumDistance(n3, o3);
      let r = m < this.m_maxDistance ? m : this.m_maxDistance;
      const u = new mi(), h2 = new mi(), c = i.getImpl(), l = s2.getImpl(), g = H(), x3 = c.getPointCount(), y = l.getPointCount();
      for (let t = 0; t < x3; ++t) {
        if (u.assign(c.getXY(t)), g.setCoords({ xmin: u.x, ymin: u.y, xmax: u.x, ymax: u.y }), this.m_envHelper.minDistanceGeodesic(g, this.m_boxGeomB) > r) continue;
        u.scale(this.m_rpu);
        const i2 = ds(this.m_a, this.m_eSquared, u);
        for (let t2 = 0; t2 < y; ++t2) {
          h2.assign(l.getXY(t2)), h2.scale(this.m_rpu);
          const s3 = ds(this.m_a, this.m_eSquared, h2);
          if (!(X.distance(i2, s3) >= r) && (Dc.geodeticDistance(this.m_a, this.m_eSquared, u.x, u.y, h2.x, h2.y, e, null, null, this.m_distCurveType), e.val < r && (n3.outPoint.assign(u), o3.outPoint.assign(h2), r = e.val, 0 === r))) return r;
        }
      }
      return r === this.m_maxDistance ? Number.POSITIVE_INFINITY : r;
    } catch (m) {
      a2.error = m, a2.hasError = true;
    } finally {
      __disposeResources(a2);
    }
  }
  calculateDistanceGeodeticMultipointMultipath(i, s2, o3, a2) {
    const m = { stack: [], error: void 0, hasError: false };
    try {
      const e = s2.getImpl().querySegmentIterator();
      e.stripAttributes(), this.computeEnvelopesAndBoxes(i, s2);
      const r = this.estimateMinimumDistance(o3, a2);
      let u = r < this.m_maxDistance ? r : this.m_maxDistance;
      const h2 = new mi(), c = new mi(0, 0), l = new mi(0, 0), _ = new mi(0, 0), p = [0], d = H(), x3 = __addDisposableResource(m, this.createDistanceFunctor(c, l, _), false), y = K(), P2 = this.canUseSpatialTree(i, s2);
      P2 && this.buildSpatialTree(y, s2);
      const S = i.getPointCount();
      for (let t = 0; t < S; ++t) if (h2.assign(i.getXY(t)), c.assign(i.getXY(t)), this.m_bIsPannablePcs && Wl(this.m_inputSR, [h2], 1, false), d.setCoords({ xmin: c.x, ymin: c.y, xmax: c.x, ymax: c.y }), !(this.m_envHelper.minDistanceGeodesic(d, this.m_boxGeomB) > u)) if (x3.setPointDistFrom(c), P2) n(0);
      else {
        for (; e.nextPath(); ) for (; e.hasNextSegment(); ) {
          const t2 = e.nextSegment();
          if (this.m_envHelper.minDistanceGeodesic(d, this.findOrComputeBoxSegment(e.getStartPointIndex(), t2, this.m_segmentBoxesB)) > u) continue;
          const i2 = this.calculateDistanceGeodeticPointSegment(h2, c, t2, p, x3);
          if (i2.second < u && (o3.outPoint.assign(c.mul(this.m_rpu)), this.updateOutputSegment(a2, t2, i2.first), u = i2.second, 0 === u)) return 0;
        }
        e.resetToFirstPath();
      }
      return u === this.m_maxDistance ? Number.POSITIVE_INFINITY : u;
    } catch (r) {
      m.error = r, m.hasError = true;
    } finally {
      __disposeResources(m);
    }
  }
  calculateDistanceGeodeticMultipathGeometry(t, e, n3, o3) {
    switch (e.getGeometryType()) {
      case a.enumPoint:
        return this.calculateDistanceGeodeticPointMultipath(e, t, o3, n3);
      case a.enumMultiPoint:
        return this.calculateDistanceGeodeticMultipointMultipath(e, t, o3, n3);
      case a.enumPolyline:
      case a.enumPolygon:
      case a.enumEnvelope:
        return this.calculateDistanceGeodeticMultipathMultipath(t, e, n3, o3);
      default:
        P("");
    }
  }
  calculateDistanceGeodeticMultipathMultipath(t, e, i, s2) {
    const n3 = [t], o3 = [e], a2 = this.swapGeometries(n3, o3), m = n3[0], r = o3[0];
    this.computeEnvelopesAndBoxes(n3[0], o3[0]);
    const u = this.estimateMinimumDistance(i, s2), h2 = this.calculateDistanceGeodeticMultipathMultipath_(m, r, i, s2, u);
    return a2 && (s2.outPoint = Pt(i.outPoint, i.outPoint = s2.outPoint)), h2;
  }
  calculateDistanceGeodeticMultipathMultipath_(i, s2, o3, a2, m = Number.MAX_VALUE) {
    const u = { stack: [], error: void 0, hasError: false };
    try {
      let e = m;
      const h2 = new mi(0, 0), c = new mi(), l = new mi(0, 0), _ = new mi(), p = new mi(0, 0), d = new mi(), g = new mi(), P2 = new mi(), S = [new mi()], f = [0], D = [0], G = H(), v2 = H(), T = __addDisposableResource(u, this.createDistanceFunctor(p, h2, l), false), b2 = K(), w2 = this.canUseSpatialTree(i, s2);
      w2 && this.buildSpatialTree(b2, s2);
      const E = s2.querySegmentIterator();
      E.stripAttributes();
      const R = new fm(), I2 = M(i);
      for (let t = 0; t < I2.length; ++t) {
        const s3 = I2[t];
        i.getSegmentBuffer(s3, R, true);
        const m2 = R.get();
        if (G.assign(this.findOrComputeBoxSegment(s3, m2, this.m_segmentBoxesA)), w2) n(0);
        else {
          if (p.assign(m2.getStartXY()), d.assign(m2.getStartXY()), g.assign(m2.getEndXY()), P2.assign(m2.getEndXY()), this.m_bIsPannablePcs && (mg(this.m_inputSR, 0, [d], 1), mg(this.m_inputSR, 0, [P2], 1)), this.m_envHelper.minDistanceGeodesic(G, this.m_boxGeomB) > e) continue;
          for (; E.nextPath(); ) {
            for (; E.hasNextSegment(); ) {
              const t2 = E.nextSegment();
              if (h2.assign(t2.getStartXY()), c.assign(t2.getStartXY()), l.assign(t2.getEndXY()), _.assign(t2.getEndXY()), m2.intersect(t2, S, f, D, this.m_tolerance)) return this.updateOutputSegment(o3, m2, f[0]), this.updateOutputSegment(a2, t2, D[0]), 0;
              if (this.m_bIsPannablePcs && (mg(this.m_inputSR, 0, [c], 1), mg(this.m_inputSR, 0, [_], 1)), v2.assign(this.findOrComputeBoxPoint(E.getStartPointIndex(), c, _, this.m_segmentBoxesB)), this.m_envHelper.minDistanceGeodesic(G, v2) > e) continue;
              T.setSegmentEndPoints(h2, l), T.setPointDistFrom(d);
              let i2 = cs(T.makeFunctor(), 0, 1, 1e-10);
              if (i2.second < e && (o3.outPoint.assign(d.mul(this.m_rpu)), this.updateOutputSegment(a2, t2, i2.first), e = i2.second, 0 === e)) break;
              if (T.setPointDistFrom(P2), i2 = cs(T.makeFunctor(), 0, 1, 1e-10), i2.second < e && (o3.outPoint.assign(P2.mul(this.m_rpu)), this.updateOutputSegment(a2, t2, i2.first), e = i2.second, 0 === e)) break;
              if (T.setSegmentEndPoints(p, g), T.setPointDistFrom(c), i2 = cs(T.makeFunctor(), 0, 1, 1e-10), i2.second < e && (this.updateOutputSegment(o3, m2, i2.first), a2.outPoint.assign(c.mul(this.m_rpu)), e = i2.second, 0 === e)) break;
              if (T.setPointDistFrom(_), i2 = cs(T.makeFunctor(), 0, 1, 1e-10), i2.second < e && (this.updateOutputSegment(o3, m2, i2.first), a2.outPoint.assign(_.mul(this.m_rpu)), e = i2.second, 0 === e)) break;
            }
            if (0 === e) return 0;
          }
          E.resetToFirstPath();
        }
      }
      return e === this.m_maxDistance ? Number.POSITIVE_INFINITY : e;
    } catch (h2) {
      u.error = h2, u.hasError = true;
    } finally {
      __disposeResources(u);
    }
  }
  calculateDistanceGeodeticPointSegment(t, e, i, s2, n3) {
    const o3 = i.getStartXY(), a2 = i.getEndXY();
    return i.intersectPoint(t, s2, this.m_tolerance) ? $t(s2[0], 0) : (n3.setPointDistFrom(e), n3.setSegmentEndPoints(o3, a2), cs(n3.makeFunctor(), 0, 1, 1e-10));
  }
  prepareGeometry(t) {
    let e = t.clone();
    const i = t.getGeometryType();
    if (i === a.enumPoint || i === a.enumMultiPoint) return this._NormalizeAndProject(e);
    if (i === a.enumEnvelope && (e = this.envelopeToPolygon(e)), this.m_inputSR.isPannable()) return this.prepareGeometryPannable(e, 4);
    if (2 === this.m_inputSR.getCoordinateSystemType()) {
      if (e = Xl(e, this.m_inputSR, 0, null), e.isEmpty()) return e;
      e = new o2().execute(e, this.m_inputSR, 5e4, this.m_maxDeviation / 2, 0, null);
      const t2 = this.m_inputSR.getSRToGCSTransform();
      return new qh().execute(e, t2, this.m_progressTracker);
    }
    const n3 = new n2();
    e.queryLooseEnvelope(n3);
    const o3 = this.m_inputSR.getPannableExtent();
    if (n3.ymin < o3.ymin || n3.ymax > o3.ymax) {
      const t2 = new n2(n3.xmin - 1, o3.ymin, n3.xmax + 1, o3.ymax);
      if (e = new I().execute(e, t2, this.m_inputSR, this.m_progressTracker), e.isEmpty()) return e;
    }
    return n3.width() > 2 * o3.width() ? (e = ql(e, -2 * o3.width(), 2 * o3.width(), this.m_inputSR, true, 0, true, this.m_progressTracker), e) : e;
  }
  prepareGeometryPannable(t, e) {
    const i = new n2();
    t.queryEnvelope(i);
    const s2 = this.m_inputSR.getPannableExtent();
    if (s2.containsEnvelope(i)) return t;
    const n3 = new x();
    s2.queryIntervalX(n3);
    const o3 = new x();
    return i.queryIntervalX(o3), t = n3.contains(o3) ? Al(t, this.m_inputSR) : new qh().foldInto360RangeGeodetic(t, this.m_inputSR, e);
  }
  prepareOutput(t) {
    t.outPoint.scale(1 / this.m_rpu), 2 === this.m_inputSR.getCoordinateSystemType() && Wl(this.m_inputSR, [t.outPoint], 1, false);
  }
  updateOutputSegment(t, e, i) {
    e.queryCoord2D(i, t.outPoint), this.m_bIsPannablePcs && mg(this.m_inputSR, 0, [t.outPoint], 1), t.outPoint.mulThis(this.m_rpu);
  }
  computeTolerance(t, e) {
    t.queryEnvelope(this.m_envGeomA), e.queryEnvelope(this.m_envGeomB);
    const i = new n2(this.m_envGeomA);
    return i.mergeEnvelope2D(this.m_envGeomB), zt(null, i);
  }
  envelopeToPolygon(t) {
    const e = new ur();
    return e.addEnvelope(t, false), e;
  }
  computeEnvelopesAndBoxes(t, e) {
    t.queryEnvelope(this.m_envGeomA), e.queryEnvelope(this.m_envGeomB), this.m_boxGeomA = this.computeBoxGeometry(t, this.m_boundaryPtsA, this.m_segmentBoxesA), this.m_boxGeomB = this.computeBoxGeometry(e, this.m_boundaryPtsB, this.m_segmentBoxesB);
  }
  computeBoxGeometry(t, e, i) {
    switch (t.getGeometryType()) {
      case a.enumPoint:
        return this.computeBoxPoint(t, e);
      case a.enumMultiPoint:
        return this.computeBoxMultiPoint(t, e);
      case a.enumPolyline:
      case a.enumPolygon:
        return this.computeBoxMultiPath(t, e, i);
      default:
        b("Invalid geometry type");
    }
  }
  computeBoxPoint(t, e) {
    const i = t.getXY();
    e.length = 0, e.push(i.mul(this.m_rpu));
    const s2 = H();
    return s2.setCoords({ xmin: i.x, ymin: i.y, xmax: i.x, ymax: i.y }), s2;
  }
  computeBoxMultiPoint(t, e) {
    let i = true;
    for (let n3 = 0; n3 < t.getPointCount(); ++n3) {
      const s3 = t.getXY(n3);
      if (i) {
        e.length = 0;
        for (let t2 = 0; t2 < 4; ++t2) e.push(s3.clone());
        i = false;
      }
      s3.x < e[0].x && e[0].assign(s3), s3.y > e[1].y && e[1].assign(s3), s3.x > e[2].x && e[2].assign(s3), s3.y < e[3].y && e[3].assign(s3);
    }
    for (let n3 = 0; n3 < e.length; ++n3) e[n3].mulThis(this.m_rpu);
    const s2 = H();
    return t.queryEnvelope(s2), s2;
  }
  computeBoxMultiPath(t, e, i) {
    let s2 = true;
    const n3 = H();
    n3.setEmpty();
    const o3 = t.querySegmentIterator();
    for (o3.stripAttributes(); o3.nextPath(); ) for (; o3.hasNextSegment(); ) {
      const t2 = o3.nextSegment(), a2 = t2.getStartXY(), m = t2.getEndXY();
      if (this.m_bIsPannablePcs && (mg(this.m_inputSR, 0, [a2], 1), mg(this.m_inputSR, 0, [m], 1)), s2) {
        for (let t3 = 0; t3 < 4; ++t3) e.push(a2.clone());
        s2 = false;
      }
      a2.x < e[0].x && e[0].assign(a2), a2.y > e[1].y && e[1].assign(a2), a2.x > e[2].x && e[2].assign(a2), a2.y < e[3].y && e[3].assign(a2), m.x < e[0].x && e[0].assign(m), m.y > e[1].y && e[1].assign(m), m.x > e[2].x && e[2].assign(m), m.y < e[3].y && e[3].assign(m);
      const r = this.findOrComputeBoxPoint(o3.getStartPointIndex(), a2, m, i);
      n3.mergeEnvelope2D(r);
    }
    for (let a2 = 0; a2 < e.length; ++a2) e[a2].mulThis(this.m_rpu);
    return n3;
  }
  findOrComputeBoxSegment(t, e, i) {
    if (!i.has(t)) {
      let s2 = H();
      if (e.queryEnvelope(s2), this.m_bIsPannablePcs) {
        const t2 = mi.construct(s2.xmin, s2.ymin), e2 = mi.construct(s2.xmax, s2.ymax);
        mg(this.m_inputSR, 0, [t2], 1), mg(this.m_inputSR, 0, [e2], 1), s2 = this.m_envHelper.calculateBbox(t2.x, t2.y, e2.x, e2.y);
      }
      return i.set(t, s2), s2;
    }
    return i.get(t);
  }
  findOrComputeBoxPoint(t, e, i, s2) {
    if (!s2.has(t)) {
      let n3 = H();
      return n3.setCoords({ xmin: e.x, ymin: e.y, xmax: i.x, ymax: i.y }), this.m_bIsPannablePcs && (n3 = this.m_envHelper.calculateBbox(n3.xmin, n3.ymin, n3.xmax, n3.ymax)), s2.set(t, n3), n3;
    }
    return s2.get(t);
  }
  estimateMinimumDistance(i, s2) {
    const n3 = { stack: [], error: void 0, hasError: false };
    try {
      const e = (t) => ds(this.m_a, this.m_eSquared, t), o3 = this.m_boundaryPtsA.map(e), a2 = this.m_boundaryPtsB.map(e);
      let m = Number.MAX_VALUE, r = 0, u = 0;
      for (let t = 0; t < o3.length; ++t) for (let e2 = 0; e2 < a2.length; ++e2) {
        const i2 = X.distance(o3[t], a2[e2]);
        i2 < m && (m = i2, r = t, u = e2);
      }
      i.outPoint.assign(this.m_boundaryPtsA[r]), s2.outPoint.assign(this.m_boundaryPtsB[u]);
      const h2 = __addDisposableResource(n3, new Cc(), false);
      return Dc.geodeticDistance(this.m_a, this.m_eSquared, this.m_boundaryPtsA[r].x, this.m_boundaryPtsA[r].y, this.m_boundaryPtsB[u].x, this.m_boundaryPtsB[u].y, h2, null, null, this.m_distCurveType), h2.val;
    } catch (o3) {
      n3.error = o3, n3.hasError = true;
    } finally {
      __disposeResources(n3);
    }
  }
  swapGeometries(t, e) {
    return w(t[0]) > w(e[0]) && (e[0] = Pt(t[0], t[0] = e[0]), this.m_envGeomB = Pt(this.m_envGeomA, this.m_envGeomA = this.m_envGeomB), true);
  }
  canUseSpatialTree(t, e) {
    return false;
  }
  checkGeometriesIntersect(t, e, i, n3) {
    let o3 = t.getGeometryType(), a2 = e.getGeometryType();
    if (this.m_envGeomA.isIntersecting(this.m_envGeomB)) {
      if (o3 === a.enumPoint && 2 === e.getDimension()) {
        const s2 = [0], o4 = [t.getXY()];
        if (Wo(e, o4, 1, this.m_tolerance, s2), 0 !== s2[0]) return i.outPoint.assign(o4[0]), n3.outPoint.assign(o4[0]), true;
      } else if (a2 === a.enumPoint && 2 === t.getDimension()) {
        const s2 = [2], o4 = [e.getXY()];
        if (Wo(t, o4, 1, this.m_tolerance, s2), 0 !== s2[0]) return i.outPoint.assign(o4[0]), n3.outPoint.assign(o4[0]), true;
      }
      if (o3 === a.enumMultiPoint && 2 === e.getDimension()) return this.multipointIntersectsArea(t, e, i, n3);
      if (a2 === a.enumMultiPoint && 2 === t.getDimension()) return this.multipointIntersectsArea(e, t, n3, i);
      let r, u, h2 = t, c = e;
      if (o3 === a.enumEnvelope && (r = this.envelopeToPolygon(t), h2 = r, o3 = a.enumPolygon), a2 === a.enumEnvelope && (u = this.envelopeToPolygon(e), c = u, a2 = a.enumPolygon), h(o3) && h(a2)) {
        const t2 = h2.querySegmentIterator(), e2 = c.querySegmentIterator(), s2 = v(), o4 = v();
        if (q(h2, c, t2, e2, s2, o4)) return i.outPoint.assign(s2.outPoint), n3.outPoint.assign(s2.outPoint), true;
      }
    }
    return false;
  }
  multipointIntersectsArea(t, e, i, s2) {
    const n3 = t.getPointCount();
    for (let o3 = 0; o3 < n3; ++o3) {
      const n4 = [2], a2 = t.getXY(o3);
      if (Wo(e, [a2], 1, this.m_tolerance, n4), 0 !== n4[0]) return i.outPoint.assign(a2), s2.outPoint.assign(a2), true;
    }
    return false;
  }
  getNearestNeighbourVisitor(t, e, i, s2, o3, a2, m) {
    return n(0), {};
  }
  buildSpatialTree(t, e) {
    n(0);
  }
};

export {
  j,
  J,
  Q
};
//# sourceMappingURL=chunk-GZD5TMIZ.js.map
