import {
  u
} from "./chunk-KTMKDXZP.js";
import {
  r as r2
} from "./chunk-F43BIMML.js";
import {
  s,
  t as t3
} from "./chunk-CW4AXF3Q.js";
import {
  d,
  t as t2,
  w
} from "./chunk-OWSUTT7E.js";
import {
  e as e2
} from "./chunk-IT62DCG6.js";
import {
  r
} from "./chunk-EGPAQBOO.js";
import {
  r as r3
} from "./chunk-YOYO2XMY.js";
import {
  n,
  t
} from "./chunk-CFXCM2NO.js";
import {
  e
} from "./chunk-K2OZ6WVC.js";
import {
  h,
  i
} from "./chunk-XLOINTMG.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/RibbonVertexPosition.glsl.js
var u2 = 8;
function f(a2, f3) {
  const { vertex: S, attributes: m } = a2;
  S.uniforms.add(new r3("intrinsicWidth", (e4) => e4.width));
  const { hasScreenSizePerspective: y, spherical: O } = f3;
  y ? (a2.include(s, f3), t3(S), d(S, f3), S.uniforms.add(new t2("inverseViewMatrix", (a3, t4) => h(z, i(z, t4.camera.viewMatrix, a3.origin)))), S.code.add(t`
      float applyLineSizeScreenSizePerspective(float size, vec3 pos) {
        vec3 worldPos = (inverseViewMatrix * vec4(pos, 1)).xyz;
        vec3 groundUp = ${O ? t`normalize(worldPos + localOrigin)` : t`vec3(0.0, 0.0, 1.0)`};
        float absCosAngle = abs(dot(groundUp, normalize(worldPos - cameraPosition)));

        return screenSizePerspectiveScaleFloat(size, absCosAngle, length(pos), screenSizePerspective);
      }
    `)) : S.code.add(t`float applyLineSizeScreenSizePerspective(float size, vec3 pos) {
return size;
}`), f3.hasVVSize ? (m.add("sizeFeatureAttribute", "float"), S.uniforms.add(new e2("vvSizeMinSize", (e4) => e4.vvSize.minSize), new e2("vvSizeMaxSize", (e4) => e4.vvSize.maxSize), new e2("vvSizeOffset", (e4) => e4.vvSize.offset), new e2("vvSizeFactor", (e4) => e4.vvSize.factor), new e2("vvSizeFallback", (e4) => e4.vvSize.fallback)), S.code.add(t`
    float getSize(${n(y, "vec3 pos")}) {
      float size = isnan(sizeFeatureAttribute)
        ? vvSizeFallback.x
        : intrinsicWidth * clamp(vvSizeOffset + sizeFeatureAttribute * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).x;

      return ${n(y, "applyLineSizeScreenSizePerspective(size, pos)", "size")};
    }
    `)) : (m.add("size", "float"), S.code.add(t`
    float getSize(${n(y, "vec3 pos")}) {
      float fullSize = intrinsicWidth * size;
      return ${n(y, "applyLineSizeScreenSizePerspective(fullSize, pos)", "fullSize")};
    }
    `)), f3.hasVVOpacity ? (m.add("opacityFeatureAttribute", "float"), S.constants.add("vvOpacityNumber", "int", 8), S.uniforms.add(new r2("vvOpacityValues", (e4) => e4.vvOpacity.values, u2), new r2("vvOpacityOpacities", (e4) => e4.vvOpacity.opacityValues, u2), new r3("vvOpacityFallback", (e4) => e4.vvOpacity.fallback, { supportsNaN: true })), S.code.add(t`
    float interpolateOpacity(float value) {
      if (value <= vvOpacityValues[0]) {
        return vvOpacityOpacities[0];
      }

      for (int i = 1; i < vvOpacityNumber; ++i) {
        if (vvOpacityValues[i] >= value) {
          float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);
          return mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f);
        }
      }

      return vvOpacityOpacities[vvOpacityNumber - 1];
    }

    vec4 applyOpacity(vec4 color) {
      if (isnan(opacityFeatureAttribute)) {
        // If there is a color vv then it will already have taken care of applying the fallback
        return ${n(f3.hasVVColor, "color", "vec4(color.rgb, vvOpacityFallback)")};
      }

      return vec4(color.rgb, interpolateOpacity(opacityFeatureAttribute));
    }
    `)) : S.code.add(t`vec4 applyOpacity(vec4 color) {
return color;
}`), f3.hasVVColor ? (a2.include(u, f3), m.add("colorFeatureAttribute", "float"), S.code.add(t`vec4 getColor() {
vec4 color = interpolateVVColor(colorFeatureAttribute);
if (isnan(color.r)) {
return vec4(0);
}
return applyOpacity(color);
}`)) : (m.add("color", "vec4"), S.code.add(t`vec4 getColor() {
return applyOpacity(color);
}`));
}
var z = e();

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/NoPerspective.glsl.js
function e3(e4) {
  e4.vertex.code.add("#define noPerspectiveWrite(x, w) (x * w)");
}
function d2(e4) {
  e4.fragment.code.add("#define noPerspectiveRead(x) (x * gl_FragCoord.w)");
}

// node_modules/@arcgis/core/views/3d/support/engineContent/marker.js
var i2 = 64;
var s2 = i2 / 2;
var n2 = s2 / 5;
var p = i2 / n2;
var a = 0.25;

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/MarkerSizing.glsl.js
function i3(i4, n3) {
  const d3 = i4.vertex, l = n3.hasScreenSizePerspective;
  w(d3), null == d3.uniforms.get("markerScale") && d3.constants.add("markerScale", "float", 1), d3.constants.add("markerSizePerLineWidth", "float", p).code.add(t`
  float getLineWidth(${n(l, "vec3 pos")}) {
     return max(getSize(${n(l, "pos")}), 1.0) * pixelRatio;
  }

  float getScreenMarkerSize(float lineWidth) {
    return markerScale * markerSizePerLineWidth * lineWidth;
  }
  `), 2 === n3.space && (d3.constants.add("maxSegmentLengthFraction", "float", 0.45), d3.uniforms.add(new r("perRenderPixelRatio", (e4) => e4.camera.perRenderPixelRatio)), d3.code.add(t`
  bool areWorldMarkersHidden(vec3 pos, vec3 other) {
    vec3 midPoint = mix(pos, other, 0.5);
    float distanceToCamera = length(midPoint);
    float screenToWorldRatio = perRenderPixelRatio * distanceToCamera * 0.5;
    float worldMarkerSize = getScreenMarkerSize(getLineWidth(${n(l, "pos")})) * screenToWorldRatio;
    float segmentLen = length(pos - other);
    return worldMarkerSize > maxSegmentLengthFraction * segmentLen;
  }

  float getWorldMarkerSize(vec3 pos) {
    float distanceToCamera = length(pos);
    float screenToWorldRatio = perRenderPixelRatio * distanceToCamera * 0.5;
    return getScreenMarkerSize(getLineWidth(${n(l, "pos")})) * screenToWorldRatio;
  }
  `));
}

export {
  f,
  e3 as e,
  d2 as d,
  i2 as i,
  s2 as s,
  a,
  i3 as i2
};
//# sourceMappingURL=chunk-BLCKE43G.js.map
