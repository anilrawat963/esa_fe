import {
  e
} from "./chunk-M24KZOVI.js";
import {
  _,
  y
} from "./chunk-AXZMNHTN.js";
import {
  f
} from "./chunk-5T3MJDSR.js";
import {
  G,
  T,
  ae,
  c,
  p
} from "./chunk-NMQNUPE4.js";
import {
  o as o2
} from "./chunk-XWE6BM2U.js";
import {
  r
} from "./chunk-SOIZOFSB.js";
import {
  n
} from "./chunk-XXLHAM2M.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a,
  x
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  o
} from "./chunk-65HD3WXL.js";

// node_modules/@arcgis/core/layers/support/LOD.js
var i;
var _a;
var l = (_a = class extends n {
  constructor(e2) {
    super(e2), this.cols = null, this.level = 0, this.levelValue = null, this.origin = null, this.resolution = 0, this.rows = null, this.scale = 0;
  }
  clone() {
    return new i({ cols: this.cols, level: this.level, levelValue: this.levelValue, resolution: this.resolution, rows: this.rows, scale: this.scale });
  }
}, i = _a, _a);
__decorate([m({ json: { write: true, origins: { "web-document": { read: false, write: false }, "portal-item": { read: false, write: false } } } })], l.prototype, "cols", void 0), __decorate([m({ type: x, json: { write: true } })], l.prototype, "level", void 0), __decorate([m({ type: String, json: { write: true } })], l.prototype, "levelValue", void 0), __decorate([m({ json: { write: true, origins: { "web-document": { read: false, write: false }, "portal-item": { read: false, write: false } } } })], l.prototype, "origin", void 0), __decorate([m({ type: Number, json: { write: true } })], l.prototype, "resolution", void 0), __decorate([m({ json: { write: true, origins: { "web-document": { read: false, write: false }, "portal-item": { read: false, write: false } } } })], l.prototype, "rows", void 0), __decorate([m({ type: Number, json: { write: true } })], l.prototype, "scale", void 0), l = i = __decorate([a("esri.layers.support.LOD")], l);

// node_modules/@arcgis/core/layers/support/TileInfo.js
var v;
var w = new o({ PNG: "png", PNG8: "png8", PNG24: "png24", PNG32: "png32", JPEG: "jpg", JPG: "jpg", DIB: "dib", TIFF: "tiff", EMF: "emf", PS: "ps", PDF: "pdf", GIF: "gif", SVG: "svg", SVGZ: "svgz", Mixed: "mixed", MIXED: "mixed", LERC: "lerc", LERC2D: "lerc2d", RAW: "raw", pbf: "pbf" });
var _a2;
var z = (_a2 = class extends n {
  static create(e2 = {}) {
    const { resolutionFactor: t = 1, scales: s, size: r2 = 256, spatialReference: i2 = f.WebMercator, numLODs: l2 = 24 } = e2;
    if (!p(i2)) {
      const e3 = [];
      if (s) for (let t2 = 0; t2 < s.length; t2++) {
        const o3 = s[t2];
        e3.push(new l({ level: t2, scale: o3, resolution: o3 }));
      }
      else {
        let t2 = 5e-4;
        for (let s2 = l2 - 1; s2 >= 0; s2--) e3.unshift(new l({ level: s2, scale: t2, resolution: t2 })), t2 *= 2;
      }
      return new v({ dpi: 96, lods: e3, origin: new _(0, 0, i2), size: [r2, r2], spatialReference: i2 });
    }
    const n2 = G(i2), p2 = e2.origin ? new _({ x: e2.origin.x, y: e2.origin.y, spatialReference: i2 }) : new _(n2 ? { x: n2.origin[0], y: n2.origin[1], spatialReference: i2 } : { x: 0, y: 0, spatialReference: i2 }), m2 = 96, d = 1 / (ae(i2) * 39.37 * m2), y2 = [];
    if (s) for (let o3 = 0; o3 < s.length; o3++) {
      const e3 = s[o3], t2 = e3 * d;
      y2.push(new l({ level: o3, scale: e3, resolution: t2 }));
    }
    else {
      let e3 = c(i2) ? 512 / r2 * 5916575275917094e-7 : 256 / r2 * 591657527591555e-6;
      const s2 = Math.ceil(l2 / t);
      y2.push(new l({ level: 0, scale: e3, resolution: e3 * d }));
      for (let o3 = 1; o3 < s2; o3++) {
        const s3 = e3 / 2 ** t, r3 = s3 * d;
        y2.push(new l({ level: o3, scale: s3, resolution: r3 })), e3 = s3;
      }
    }
    return new v({ dpi: m2, lods: y2, origin: p2, size: [r2, r2], spatialReference: i2 });
  }
  constructor(e2) {
    super(e2), this.dpi = 96, this.format = null, this.origin = null, this.size = null, this.spatialReference = null;
  }
  get isWrappable() {
    const { spatialReference: e2, origin: t } = this;
    if (e2 && t) {
      const s = G(e2);
      return e2.isWrappable && !!s && Math.abs(s.origin[0] - t.x) <= s.dx;
    }
    return false;
  }
  readOrigin(e2, t) {
    return _.fromJSON({ spatialReference: t.spatialReference, ...e2 });
  }
  set lods(e2) {
    let t = 0, s = 0;
    const o3 = [], r2 = this._levelToLOD = {};
    e2 && (t = -1 / 0, s = 1 / 0, e2.forEach((e3) => {
      o3.push(e3.scale), t = e3.scale > t ? e3.scale : t, s = e3.scale < s ? e3.scale : s, r2[e3.level] = e3;
    })), this._set("scales", o3), this._set("lods", e2), this._initializeUpsampleLevels();
  }
  readSize(e2, t) {
    return [t.cols, t.rows];
  }
  writeSize(e2, t) {
    t.cols = e2[0], t.rows = e2[1];
  }
  zoomToScale(e2) {
    const t = this.scales;
    if (e2 <= 0) return t[0];
    if (e2 >= t.length - 1) return t[t.length - 1];
    const s = Math.floor(e2), o3 = s + 1;
    return t[s] / (t[s] / t[o3]) ** (e2 - s);
  }
  scaleToZoom(e2) {
    const t = this.scales, s = t.length - 1;
    let o3 = 0;
    for (; o3 < s; o3++) {
      const s2 = t[o3], r2 = t[o3 + 1];
      if (s2 <= e2) return o3;
      if (r2 === e2) return o3 + 1;
      if (s2 > e2 && r2 < e2) return o3 + Math.log(s2 / e2) / Math.log(s2 / r2);
    }
    return o3;
  }
  tileAt(e2, t, s, o3) {
    const r2 = this.lodAt(e2);
    if (!r2) return null;
    let i2, l2;
    if ("number" == typeof t) i2 = t, l2 = s;
    else if (T(t.spatialReference, this.spatialReference)) i2 = t.x, l2 = t.y, o3 = s;
    else {
      const e3 = y(t, this.spatialReference);
      if (null == e3) return null;
      i2 = e3.x, l2 = e3.y, o3 = s;
    }
    const n2 = r2.resolution * this.size[0], p2 = r2.resolution * this.size[1];
    return o3 ??= new e(0, 0, 0), o3.level = e2, o3.row = Math.floor((this.origin.y - l2) / p2 + 1e-3), o3.col = Math.floor((i2 - this.origin.x) / n2 + 1e-3), this.updateTileInfo(o3), o3;
  }
  updateTileInfo(e2, t = 0) {
    if (!("extent" in e2)) return false;
    let s = this.lodAt(e2.level);
    if (!s && 1 === t) {
      const t2 = this.lods[this.lods.length - 1];
      t2.level < e2.level && (s = t2);
    }
    if (!s) return false;
    const o3 = e2.level - s.level, r2 = s.resolution * this.size[0] / 2 ** o3, i2 = s.resolution * this.size[1] / 2 ** o3;
    return e2.extent[0] = this.origin.x + e2.col * r2, e2.extent[1] = this.origin.y - (e2.row + 1) * i2, e2.extent[2] = e2.extent[0] + r2, e2.extent[3] = e2.extent[1] + i2, true;
  }
  upsampleTile(e2) {
    const t = this._upsampleLevels[e2.level];
    return !(!t || -1 === t.parentLevel) && (e2.level = t.parentLevel, e2.row = Math.floor(e2.row / t.factor + 1e-3), e2.col = Math.floor(e2.col / t.factor + 1e-3), this.updateTileInfo(e2), true);
  }
  getTileBounds(e2, t) {
    const s = this.lodAt(t.level);
    if (null == s) return null;
    const { resolution: o3 } = s, r2 = o3 * this.size[0], i2 = o3 * this.size[1];
    return e2[0] = this.origin.x + t.col * r2, e2[1] = this.origin.y - (t.row + 1) * i2, e2[2] = e2[0] + r2, e2[3] = e2[1] + i2, e2;
  }
  lodAt(e2) {
    return this._levelToLOD?.[e2] ?? null;
  }
  clone() {
    return v.fromJSON(this.write({}));
  }
  getCompatibleForVTL(e2) {
    if (this.size[0] !== this.size[1] || 256 === this.size[0] && 512 === e2) return null;
    const t = (512 === this.size[0] && 256 === e2 ? -1 : 0) + (this.spatialReference.isGeographic ? 1 : 0);
    if (this.size[0] === e2 && 0 === t) return this;
    const s = [], o3 = this.lods.length - t;
    for (let r2 = 0; r2 < o3; r2++) {
      const e3 = r2 + t, { scale: o4, resolution: i2 } = e3 >= 0 ? this.lods[e3] : { scale: 2 * this.lods[0].scale, resolution: 2 * this.lods[0].resolution };
      s.push(new l({ level: r2, scale: o4, resolution: i2 }));
    }
    return new v({ size: [e2, e2], dpi: this.dpi, format: this.format, compressionQuality: this.compressionQuality, origin: this.origin, spatialReference: this.spatialReference, lods: s });
  }
  _initializeUpsampleLevels() {
    const e2 = this.lods;
    this._upsampleLevels = [];
    let t = null;
    for (let s = 0; s < e2.length; s++) {
      const o3 = e2[s];
      this._upsampleLevels[o3.level] = { parentLevel: t ? t.level : -1, factor: t ? t.resolution / o3.resolution : 0 }, t = o3;
    }
  }
}, v = _a2, _a2);
__decorate([m({ type: Number, json: { write: true } })], z.prototype, "compressionQuality", void 0), __decorate([m({ type: Number, json: { write: true } })], z.prototype, "dpi", void 0), __decorate([m({ type: String, json: { read: w.read, write: w.write, origins: { "web-scene": { read: false, write: false } } } })], z.prototype, "format", void 0), __decorate([m({ readOnly: true })], z.prototype, "isWrappable", null), __decorate([m({ type: _, json: { write: true } })], z.prototype, "origin", void 0), __decorate([o2("origin")], z.prototype, "readOrigin", null), __decorate([m({ type: [l], value: null, json: { write: true } })], z.prototype, "lods", null), __decorate([m({ readOnly: true })], z.prototype, "scales", void 0), __decorate([m({ cast: (e2) => Array.isArray(e2) ? e2 : "number" == typeof e2 ? [e2, e2] : [256, 256] })], z.prototype, "size", void 0), __decorate([o2("size", ["rows", "cols"])], z.prototype, "readSize", null), __decorate([r("size", { cols: { type: x }, rows: { type: x } })], z.prototype, "writeSize", null), __decorate([m({ type: f, json: { write: true } })], z.prototype, "spatialReference", void 0), z = v = __decorate([a("esri.layers.support.TileInfo")], z);

export {
  l,
  z
};
//# sourceMappingURL=chunk-YP3WVJP3.js.map
