import {
  h as h9,
  m as m7
} from "./chunk-45IUKBSH.js";
import {
  l as l9,
  t as t9,
  u as u9
} from "./chunk-UNJMLSLI.js";
import "./chunk-NTNXXNRP.js";
import {
  e as e10
} from "./chunk-2GCOQTG5.js";
import {
  F as F3,
  a as a5,
  s as s6
} from "./chunk-DCXQINIS.js";
import {
  i as i6
} from "./chunk-H3HJIROX.js";
import {
  C,
  E as E3,
  P,
  R as R3,
  c as c3,
  e as e11,
  f as f7,
  h as h10,
  h2 as h11,
  l as l8,
  q,
  r as r8,
  r2 as r9,
  r3 as r10,
  v as v3,
  v2 as v4,
  x as x3,
  y,
  y2
} from "./chunk-JQJENO7I.js";
import "./chunk-P77QHDEC.js";
import "./chunk-2I7JAYEU.js";
import "./chunk-KRLDYUK3.js";
import {
  O
} from "./chunk-UQ4NKDVH.js";
import {
  a as a3,
  c,
  h as h8,
  m as m5,
  u as u8
} from "./chunk-TYWPNUCZ.js";
import "./chunk-6SXRWZMX.js";
import {
  k as k2,
  o as o7,
  s as s8,
  t as t7,
  x as x4
} from "./chunk-N3OIGAM3.js";
import "./chunk-E77VVW2C.js";
import "./chunk-PG3227VO.js";
import {
  s as s7
} from "./chunk-JGWZMI5Q.js";
import {
  a as a4,
  e as e9,
  m as m6,
  n as n7,
  n3 as n8
} from "./chunk-43423NKQ.js";
import {
  e as e8,
  n as n6
} from "./chunk-ALLCMCHO.js";
import {
  n as n5
} from "./chunk-TJ7BXOCK.js";
import {
  i as i5,
  m as m4,
  s as s5
} from "./chunk-NNZE65VM.js";
import {
  e as e6,
  e2 as e7
} from "./chunk-RZOWZMPW.js";
import {
  h as h7
} from "./chunk-7LPDSYJP.js";
import "./chunk-MJIAJDWR.js";
import {
  i as i4
} from "./chunk-K5WXOTTP.js";
import {
  t as t5
} from "./chunk-JS3I6GIR.js";
import {
  r as r7
} from "./chunk-QTS3W27E.js";
import "./chunk-3RABUJDL.js";
import "./chunk-FDSAQJ3R.js";
import "./chunk-WJ3E33GQ.js";
import "./chunk-CFXCM2NO.js";
import "./chunk-U3B7YMY7.js";
import "./chunk-XMUWUWWP.js";
import "./chunk-F75XORHS.js";
import {
  u as u7
} from "./chunk-2U5X5TIX.js";
import {
  x as x2
} from "./chunk-QHMSLY43.js";
import {
  l as l7
} from "./chunk-27W5ILTF.js";
import {
  r as r6
} from "./chunk-2GRS3IMC.js";
import "./chunk-YYGF76T3.js";
import "./chunk-GVFNGMIY.js";
import "./chunk-RQGBRVDD.js";
import {
  d as d4,
  f as f6,
  p as p2
} from "./chunk-JPZOLUPV.js";
import {
  N as N4,
  Y,
  e as e4,
  i as i2,
  n as n4,
  t as t2,
  t2 as t3
} from "./chunk-DRHU543D.js";
import {
  f as f5,
  g,
  l as l6,
  m as m3,
  o2 as o5
} from "./chunk-F7RQDGE7.js";
import "./chunk-GG4AQJJO.js";
import {
  f as f4,
  u as u6
} from "./chunk-OGWYK5MD.js";
import "./chunk-4V63WUXV.js";
import "./chunk-TWE24CRT.js";
import "./chunk-Y3GEZC7J.js";
import "./chunk-U5TTP5E5.js";
import "./chunk-CXUJAI27.js";
import "./chunk-VR2ODL2Y.js";
import "./chunk-QENBEP2X.js";
import {
  t as t4
} from "./chunk-VZQ643XD.js";
import "./chunk-SMJWJAIA.js";
import "./chunk-WFCLXKCE.js";
import "./chunk-FHCV4NTV.js";
import "./chunk-M5JMVUW2.js";
import {
  v as v2
} from "./chunk-SIUG2XLL.js";
import {
  i as i3
} from "./chunk-XTEXJOLG.js";
import "./chunk-NH6FXYCM.js";
import {
  A as A2,
  D as D2,
  E as E2,
  F as F2,
  H as H2,
  I as I2,
  L as L3,
  M as M3,
  N as N3,
  Q,
  R as R2,
  T as T2,
  U as U2,
  V as V2,
  X as X2,
  Z,
  b as b3,
  d as d3,
  f as f3,
  h as h5,
  j as j2,
  k,
  o as o4,
  v,
  x
} from "./chunk-YE4E5JCT.js";
import {
  e as e3,
  o as o3
} from "./chunk-SXZO7ULH.js";
import "./chunk-VNSHGTPN.js";
import "./chunk-S5ZM63JC.js";
import "./chunk-XHNYLMJC.js";
import "./chunk-NHFKDWOM.js";
import "./chunk-ALR6N4CF.js";
import {
  t
} from "./chunk-4X4BOGIG.js";
import {
  n as n3
} from "./chunk-IOJ4QFRL.js";
import "./chunk-EK7HOTRR.js";
import "./chunk-ODQ5APZK.js";
import "./chunk-BA6HYZ35.js";
import {
  f as f2,
  j
} from "./chunk-FMFPQ74E.js";
import "./chunk-7J4XCFCY.js";
import "./chunk-VGXUPJSS.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import "./chunk-WJ5RYEGC.js";
import {
  _
} from "./chunk-IRBX64M6.js";
import "./chunk-2HGIYEIL.js";
import "./chunk-XX3OKYJS.js";
import "./chunk-OTCNIJ2H.js";
import "./chunk-JGA5YJWL.js";
import "./chunk-GCI4MA3M.js";
import "./chunk-SJ2OBYX2.js";
import "./chunk-MDJNYPVI.js";
import "./chunk-Z6VKIQV2.js";
import "./chunk-4PXNA4MD.js";
import {
  c as c4,
  e as e12
} from "./chunk-KFU6TDGW.js";
import {
  e as e13
} from "./chunk-6AFWHXSG.js";
import "./chunk-73FJYU43.js";
import "./chunk-3BNOOWTA.js";
import "./chunk-AIJLLSRB.js";
import "./chunk-IXRRTVLJ.js";
import {
  c as c2,
  e as e5,
  o as o6,
  t2 as t8
} from "./chunk-WKTI47FV.js";
import "./chunk-T3SYSTKO.js";
import "./chunk-HOJHSMLY.js";
import "./chunk-6RE6OSTE.js";
import "./chunk-QSGJ3ECU.js";
import "./chunk-LQPKVYW2.js";
import {
  A as A3,
  h as h6,
  t2 as t6
} from "./chunk-U55FA2EK.js";
import "./chunk-GBN36VHC.js";
import "./chunk-ZSZK67ZL.js";
import "./chunk-IPWH4LK2.js";
import "./chunk-7CDU3B2L.js";
import "./chunk-B5A4L35M.js";
import "./chunk-52SEOH5H.js";
import "./chunk-JUZ3H47H.js";
import {
  a as a2
} from "./chunk-UYMV6HXW.js";
import "./chunk-AJGINJLG.js";
import {
  A,
  At,
  B as B2,
  Bt,
  Kt,
  L as L2,
  Lt,
  M as M2,
  U,
  V,
  W as W2,
  X,
  ft,
  ht,
  it,
  ot,
  tt,
  zt
} from "./chunk-JE2NJSBU.js";
import "./chunk-WCWUUHUV.js";
import {
  D,
  E,
  G,
  N as N2,
  R,
  _ as _3
} from "./chunk-QNVJVDYZ.js";
import {
  n as n2,
  r as r5
} from "./chunk-WDTGOP77.js";
import {
  o as o2
} from "./chunk-VYMBX5H5.js";
import {
  h as h4
} from "./chunk-BPTFV5VM.js";
import "./chunk-647DAMHU.js";
import "./chunk-O6G3PPOK.js";
import "./chunk-ZKNZTIAS.js";
import "./chunk-OJMISN3F.js";
import "./chunk-EFV6H5NA.js";
import {
  L
} from "./chunk-6VL5D5UP.js";
import "./chunk-6QHY54HZ.js";
import "./chunk-GXJJY3ND.js";
import "./chunk-5ONGWFJ3.js";
import "./chunk-PLNHHGHL.js";
import "./chunk-DFK6QMLO.js";
import "./chunk-4WTOIJXV.js";
import "./chunk-BBYMM7CM.js";
import {
  r as r3
} from "./chunk-EM7Y2JZC.js";
import "./chunk-QZQPB5XR.js";
import "./chunk-AQFRVV3U.js";
import "./chunk-BUQC3CLV.js";
import "./chunk-63LDVRFI.js";
import "./chunk-JZUJ34RR.js";
import "./chunk-PMGS7UDU.js";
import "./chunk-3GHCGAH2.js";
import "./chunk-HWUOAPTX.js";
import "./chunk-QHCKOBU7.js";
import "./chunk-K2OZ6WVC.js";
import "./chunk-MC6NAKKX.js";
import "./chunk-TF6255HN.js";
import "./chunk-GD4FJL3C.js";
import "./chunk-C5OQVQZF.js";
import "./chunk-F7DKSAOI.js";
import "./chunk-4SOQWNPG.js";
import "./chunk-LTULADK2.js";
import "./chunk-35ST7YRB.js";
import "./chunk-EDA5QFHZ.js";
import {
  d as d2
} from "./chunk-XL5QPCXN.js";
import {
  W,
  b as b2
} from "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-UDHS2MGH.js";
import "./chunk-MHV23XAQ.js";
import "./chunk-V2X4OKYI.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import "./chunk-ONXWBTTM.js";
import "./chunk-T7F6Q6JJ.js";
import "./chunk-YDTPM7OQ.js";
import {
  n
} from "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-3FUHCAX3.js";
import "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import {
  M,
  b,
  f,
  h as h3,
  l as l5,
  m as m2
} from "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import {
  B,
  I,
  l as l4,
  o
} from "./chunk-AZXJIEZ6.js";
import {
  u as u4
} from "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import {
  h as h2,
  l as l3
} from "./chunk-2OFHDVO5.js";
import "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import {
  u as u5
} from "./chunk-CCQFL76O.js";
import {
  e as e2,
  u as u3
} from "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import "./chunk-7H3U4IJR.js";
import {
  r as r4,
  s as s4
} from "./chunk-SMWUT52Z.js";
import {
  _ as _2
} from "./chunk-AXZMNHTN.js";
import "./chunk-5T3MJDSR.js";
import {
  N2 as N,
  T
} from "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import {
  H2 as H,
  kt
} from "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import {
  r2 as r
} from "./chunk-5EI5H4QX.js";
import "./chunk-ZIE53VIV.js";
import "./chunk-SS5CLIUY.js";
import {
  F
} from "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import {
  $,
  d,
  e2 as e,
  h,
  l2,
  m2 as m,
  r2,
  s as s3,
  u2 as u,
  u3 as u2,
  w
} from "./chunk-GNMPGHLQ.js";
import {
  a,
  i3 as i,
  l3 as l,
  s,
  s2
} from "./chunk-QY7XKUIV.js";
import {
  has,
  p
} from "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/symbols/cim/animationUtils.js
function m8(t19, n19, e17) {
  return { transform: b4(t19, n19, e17.transform), fromColor: I3(t19, n19, e17.fromColor), toColor: T3(t19, n19, e17.toColor), colorMix: k3(t19, n19, e17.colorMix), toOpacity: v5(t19, n19, e17.toOpacity), opacityMix: O2(t19, n19, e17.opacityMix), shift: x5(t19, n19, e17.shift), hasAnimations: e17.hasAnimations || c5(n19), hasShiftAnimation: e17.hasShiftAnimation || l10(n19), hasMotionAnimations: e17.hasMotionAnimations || p3(n19) };
}
function c5(t19) {
  return !!t19.animations && t19.animations.length > 0;
}
function l10(t19) {
  return !!t19.animations && t19.animations.some((t20) => "CIMSymbolAnimationMoveAlongLine" === t20.type);
}
var f8 = /* @__PURE__ */ new Set(["CIMSymbolAnimationOffset", "CIMSymbolAnimationRotation", "CIMSymbolAnimationSize", "CIMSymbolAnimationScale"]);
function p3(t19) {
  return !!t19.animations && t19.animations.some((t20) => f8.has(t20.type));
}
function u10(t19) {
  return !t7.forceStaticPath && (t7.forceAnimatedPath || t19.hasAnimations);
}
function y3(n19, e17, o18) {
  if ("CIMCharacterMarker" === e17.type) return i.getLogger("animationUtils").error("#handleMarker()", "CIM character markers do not support animations"), o18;
  const r14 = Q(n19, e17, "OffsetX"), a12 = Q(n19, e17, "OffsetY");
  if ("CIMPictureMarker" === e17.type) return { ...o18, transform: { type: "AnimatedTransform", relativeTranslation: false, absoluteScale: true, translation: z([r14, a12]), rotation: z(0), scale: z(Q(n19, e17, "Size")), parent: o18.transform } };
  const s13 = e17.frame, m11 = s13.ymax - s13.ymin;
  return { ...o18, transform: { type: "AnimatedTransform", relativeTranslation: false, absoluteScale: false, translation: z([r14, a12]), rotation: z(0), scale: z({ type: "Process", op: "Divide", left: Q(n19, e17, "Size"), right: m11 }), parent: o18.transform } };
}
function d5(t19, n19) {
  let e17 = 0, o18 = 0;
  const i12 = "Absolute" !== t19.anchorPointUnits;
  return t19.anchorPoint && (e17 = -t19.anchorPoint.x, o18 = -t19.anchorPoint.y), { ...n19, transform: { type: "AnimatedTransform", relativeTranslation: i12, absoluteScale: false, translation: z([e17, o18]), rotation: z(0), scale: z(1), parent: n19.transform } };
}
function S(t19, n19) {
  return "Absolute" === t19.anchorPointUnits ? n19 : d5(t19, n19);
}
function M4(t19, n19) {
  return "Absolute" !== t19.anchorPointUnits ? n19 : d5(t19, n19);
}
function A4(t19, n19, e17) {
  return { ...t19, transform: { type: "AnimatedTransform", relativeTranslation: false, absoluteScale: false, translation: z([n19, e17]), rotation: z(0), scale: z(1), parent: t19.transform } };
}
function C2(t19, n19) {
  const e17 = n19 ? 0.5 * -(n19.xmin + n19.xmax) : 0, i12 = n19 ? 0.5 * -(n19.ymin + n19.ymax) : 0;
  let r14 = 0, a12 = 0;
  if ("x" in t19 && "y" in t19) r14 = t19.x + e17, a12 = t19.y + i12;
  else {
    const n20 = m5(t19);
    if (n20) {
      r14 = (n20[0] + n20[2]) / 2 + e17, a12 = (n20[1] + n20[3]) / 2 + i12;
    }
  }
  return [r14, a12];
}
function g2(t19, n19) {
  switch (n19.type) {
    case "CIMPictureMarker":
    case "CIMVectorMarker":
      return Q(t19, n19, "Rotation");
  }
  return 0;
}
function h12(t19, n19) {
  switch (n19.type) {
    case "CIMPictureMarker":
    case "CIMVectorMarker":
      return Q(t19, n19, "RotateClockwise");
  }
  return 0;
}
function P2(t19, n19) {
  switch (n19.type) {
    case "CIMPointSymbol":
    case "CIMVectorMarker":
      return [1, 1, 1, 1];
    case "CIMSolidStroke":
    case "CIMSolidFill":
      return Q(t19, n19, "Color");
    case "CIMPictureMarker":
    case "CIMPictureStroke":
    case "CIMPictureFill":
      return Q(t19, n19, "TintColor");
  }
  return [1, 1, 1, 1];
}
function b4(t19, n19, e17) {
  return { type: "AnimatedTransform", relativeTranslation: false, absoluteScale: false, translation: R4(t19, n19), rotation: w2(t19, n19), scale: L4(t19, n19), parent: e17 };
}
function I3(t19, n19, e17) {
  return { type: "AnimatedColor", color: z(P2(t19, n19)), opacity: z(1), parent: e17 };
}
function T3(t19, n19, e17) {
  const { animations: o18 } = n19;
  let r14 = P2(t19, n19);
  const a12 = o18?.find((t20) => "CIMSymbolAnimationColor" === t20.type);
  return a12 && (r14 = Q(t19, a12, "ToColor")), { type: "AnimatedColor", color: z(r14), opacity: z(1), parent: e17 };
}
function k3(t19, n19, e17) {
  const { animations: o18 } = n19, i12 = o18?.find((t20) => "CIMSymbolAnimationColor" === t20.type);
  return i12 ? { type: "AnimatedColor", color: z([1, 1, 1, 1]), opacity: { from: 0, to: 1, timing: D3(t19, i12?.animatedSymbolProperties) }, parent: [1, 1, 1, 1] } : e17;
}
function v5(t19, n19, e17) {
  const { animations: o18 } = n19;
  let r14 = z(1);
  const a12 = o18?.find((t20) => "CIMSymbolAnimationTransparency" === t20.type);
  if (a12) {
    r14 = z({ type: "Process", op: "Transparency", value: Q(t19, a12, "ToTransparency") });
  }
  return { type: "AnimatedColor", color: z([1, 1, 1, 1]), opacity: r14, parent: e17 };
}
function O2(t19, n19, e17) {
  const { animations: o18 } = n19, i12 = o18?.find((t20) => "CIMSymbolAnimationTransparency" === t20.type);
  return i12 ? { type: "AnimatedColor", color: z([1, 1, 1, 1]), opacity: { from: 0, to: 1, timing: D3(t19, i12?.animatedSymbolProperties) }, parent: [1, 1, 1, 1] } : e17;
}
function x5(t19, n19, e17) {
  const { animations: o18 } = n19, a12 = o18?.find((t20) => "CIMSymbolAnimationMoveAlongLine" === t20.type);
  if (!a12) return e17;
  let s13, m11;
  const c12 = D3(t19, a12.animatedSymbolProperties), l16 = Z(t19, a12, "DistanceAlong"), f12 = Z(t19, a12, "Speed"), p5 = l16 && Q(t19, a12, "DistanceAlong"), u15 = f12 && Q(t19, a12, "Speed"), y4 = true === a12.continuous;
  if (false !== p5) s13 = { type: "Process", op: "Divide", left: p5, right: 100 }, m11 = true;
  else if (false !== u15) s13 = { type: "Process", op: "Multiply", left: u15, right: c12.duration }, m11 = false;
  else {
    if (!y4) throw new Error("Either distanceAlong, speed or continuous must be specified.");
    s13 = 1, m11 = true;
  }
  return { type: "AnimatedShift", multiplyByLineLength: m11, shift: { from: 0, to: s13, timing: c12 }, parent: e17 };
}
function D3(t19, n19) {
  if (!n19) return { duration: 1, startTimeOffset: 0, repeatDelay: 0, timeOriginSelector: "Local", repeatType: "Loop", easing: "Linear", playAnimation: 1, reverseAnimation: 0 };
  const o18 = Q(t19, n19, "Duration");
  let r14;
  if (Q(t19, n19, "RandomizeStartTime")) {
    r14 = { type: "Process", op: "Random", min: 0, max: o18, seed: Q(t19, n19, "RandomizeStartSeed") };
  } else r14 = Q(t19, n19, "StartTimeOffset");
  const a12 = Q(t19, n19, "RepeatDelay"), m11 = Q(t19, n19, "PlayAnimation"), c12 = Q(t19, n19, "ReverseAnimation"), l16 = b3(n19.repeatType, o3.CIMAnimatedSymbolProperties.repeattype);
  return { duration: o18, startTimeOffset: r14, repeatDelay: a12, timeOriginSelector: "None" === l16 ? "Local" : "Global", repeatType: l16, easing: b3(n19.easing, o3.CIMAnimatedSymbolProperties.easing), playAnimation: m11, reverseAnimation: c12 };
}
function L4(t19, n19) {
  const { animations: e17 } = n19;
  let o18;
  o18 = "CIMPictureMarker" === n19.type || "CIMVectorMarker" === n19.type ? Q(t19, n19, "Size") : "CIMSolidStroke" === n19.type || "CIMPictureStroke" === n19.type ? Q(t19, n19, "Width") : U2(n19) || 10;
  const r14 = e17?.find((t20) => "CIMSymbolAnimationScale" === t20.type);
  if (!r14) {
    const n20 = e17?.find((t20) => "CIMSymbolAnimationSize" === t20.type);
    if (!n20) return z(1);
    return { from: 1, to: { type: "Process", op: "Divide", left: Q(t19, n20, "ToSize"), right: o18 }, timing: D3(t19, n20.animatedSymbolProperties) };
  }
  return { from: 1, to: Q(t19, r14, "ScaleFactor"), timing: D3(t19, r14.animatedSymbolProperties) };
}
function R4(t19, n19) {
  const { animations: e17 } = n19, o18 = e17?.find((t20) => "CIMSymbolAnimationOffset" === t20.type);
  if (!o18) return z([0, 0]);
  return { from: [0, 0], to: [Q(t19, o18, "OffsetX"), Q(t19, o18, "OffsetY")], timing: D3(t19, o18.animatedSymbolProperties) };
}
function w2(t19, n19) {
  const { animations: e17 } = n19, o18 = h12(t19, n19), r14 = { type: "Process", op: "Divide", left: g2(t19, n19), right: { type: "Process", op: "Cond", condition: o18, ifTrue: -1, ifFalse: 1 } }, a12 = e17?.find((t20) => "CIMSymbolAnimationRotation" === t20.type);
  if (!a12) return z(r14);
  const s13 = { type: "Process", op: "Add", left: Q(t19, a12, "ToRotation"), right: { type: "Process", op: "Divide", left: r14, right: -1 } };
  return { from: r14, to: { type: "Process", op: "Add", left: r14, right: { type: "Process", op: "Cond", condition: Q(t19, a12, "RotateClockwise"), ifTrue: { type: "Process", op: "MatchWinding", sign: -1, angle: s13 }, ifFalse: { type: "Process", op: "MatchWinding", sign: 1, angle: s13 } } }, timing: D3(t19, a12.animatedSymbolProperties) };
}
function z(t19) {
  return { from: t19, to: t19, timing: { duration: 1, startTimeOffset: 0, repeatDelay: 0, timeOriginSelector: "Local", repeatType: "Loop", easing: "Linear", playAnimation: 1, reverseAnimation: 0 } };
}
function F4(t19) {
  if (null == t19) return false;
  if ("object" != typeof t19) return false;
  if (t19.animations && Array.isArray(t19.animations) && t19.animations.length > 0) return true;
  for (const n19 in t19) if (F4(t19[n19])) return true;
  return false;
}

// node_modules/@arcgis/core/symbols/cim/fitVectorMarker.js
var a6 = 0.01;
function t10(t19) {
  if (!t19.frame) return t19;
  const { markerGraphics: f12 } = t19;
  if (!f12 || 0 === f12.length) return t19;
  let n19 = 0, o18 = 0, s13 = 0, i12 = 0;
  for (const m11 of f12) {
    const { geometry: a12, symbol: t20 } = m11;
    if (!a12 || !t20 || !("symbolLayers" in t20)) continue;
    const { symbolLayers: f13 } = t20;
    if (f13) for (const m12 of f13) {
      const { effects: t21 } = m12, f14 = l7.applyEffects(t21, a12), c13 = m5(f14);
      c13 && (n19 = Math.min(n19, c13[0]), o18 = Math.min(o18, c13[1]), s13 = Math.max(s13, c13[2]), i12 = Math.max(i12, c13[3]));
    }
  }
  const { xmin: c12, ymin: x7, xmax: y4, ymax: p5 } = t19.frame, h19 = (y4 - c12) / 2, l16 = (p5 - x7) / 2, M6 = (y4 + c12) / 2, u15 = (p5 + x7) / 2;
  if (h19 <= 0 || l16 <= 0) return t19;
  const b6 = (M6 - n19) / h19, g5 = (s13 - M6) / h19, j5 = (u15 - o18) / l16, E4 = (i12 - u15) / l16, F6 = Math.max(Math.max(b6, g5), Math.max(j5, E4));
  return F6 <= 1 + a6 ? t19 : (t19 = a(t19)).frame ? (t19.frame.xmin = (t19.frame.xmin - M6) * F6 + M6, t19.frame.ymin = (t19.frame.ymin - u15) * F6 + u15, t19.frame.xmax = (t19.frame.xmax - M6) * F6 + M6, t19.frame.ymax = (t19.frame.ymax - u15) * F6 + u15, false !== t19.respectFrame && (t19.size *= F6), t19) : t19;
}

// node_modules/@arcgis/core/symbols/cim/cimAnalyzer.js
var q2 = () => i.getLogger("esri.symbols.cim.cimAnalyzer");
function K(e17) {
  const t19 = e17.markerPlacement;
  return t19 && t19.angleToLine ? 1 : 0;
}
var Q2 = class {
  constructor(e17) {
    this._cimLayers = [], this._poMap = {}, this._primitiveOverrides = [], this._hasTextStringTemplates = false, e17 && (this._resourceManager = e17);
  }
  analyzeSymbolReference(t19, r14, i12) {
    if (this._cimLayers = i12 ?? [], !t19) return this._cimLayers;
    if (this._reset(), this._hasTextStringTemplates = t19.hasTextStringTemplates ?? false, t19.primitiveOverrides) {
      this._primitiveOverrides = t19.primitiveOverrides;
      for (const t20 of this._primitiveOverrides) {
        const r15 = t20.valueExpressionInfo;
        if (r15) this._setPoMap(t20.primitiveName, t20.propertyName, r15);
        else if (null != t20.value) {
          let r16 = t20.value;
          t20.propertyName.includes("Color") && (i3(r16) && (r16 = o4(r16)), r16 = M3(r16)), this._setPoMap(t20.primitiveName, t20.propertyName, r16);
        }
      }
    }
    return this._analyzeSymbol(t19.symbol, r14), this._cimLayers;
  }
  _reset() {
    this._cimLayers = [], this._poMap = {}, this._primitiveOverrides = [];
  }
  _analyzeSymbol(e17, t19) {
    switch (e17?.type) {
      case "CIMPointSymbol":
      case "CIMLineSymbol":
      case "CIMPolygonSymbol":
        this._analyzeMultiLayerSymbol(e17, t19);
    }
  }
  _analyzeMultiLayerSymbol(e17, t19) {
    const r14 = e17?.symbolLayers;
    if (!r14) return;
    for (let l16 = 0; l16 < r14.length; l16++) {
      const e18 = r14[l16];
      "CIMVectorMarker" === e18.type && (r14[l16] = t10(e18));
    }
    const i12 = e17.effects;
    let o18 = 0;
    const a12 = U2(e17) ?? 0;
    if ("CIMPointSymbol" === e17.type && "Map" === e17.angleAlignment && (o18 = 1), oe(r14, i12)) return this._analyzeCompositeOutlineFill(r14, i12, a12);
    let s13 = { transform: [0, 0, 0, 1], fromColor: [1, 1, 1, 1], toColor: [1, 1, 1, 1], colorMix: [0, 0, 0, 0], toOpacity: [1, 1, 1, 1], opacityMix: [0, 0, 0, 0], shift: [1, 1, 1, 1], hasAnimations: F4(e17), hasShiftAnimation: false, hasMotionAnimations: false };
    s13 = m8(this._poMap, e17, s13);
    const p5 = "CIMPolygonSymbol" === e17.type;
    let c12 = r14.length;
    for (; c12--; ) {
      const l16 = r14[c12];
      if (!l16 || false === l16.enable) continue;
      let n19;
      i12?.length && (n19 = [...i12]);
      const m11 = l16.effects;
      m11?.length && (i12 ? n19.push(...m11) : n19 = [...m11]);
      let y4 = null;
      if (n19) {
        y4 = [];
        for (const e18 of n19) {
          const t20 = v2.findEffectOverrides(e18, this._primitiveOverrides);
          t20 && y4.push(t20);
        }
      }
      const d12 = [];
      switch (v2.findApplicableOverrides(l16, this._primitiveOverrides, d12), l16.type) {
        case "CIMSolidFill":
          this._analyzeSolidFill(l16, y4, s13, x(r14));
          break;
        case "CIMPictureFill":
          this._analyzePictureFill(l16, y4, s13);
          break;
        case "CIMHatchFill":
          this._analyzeHatchFill(l16, y4);
          break;
        case "CIMGradientFill":
          this._analyzeGradientFill(l16, y4);
          break;
        case "CIMSolidStroke":
          this._analyzeSolidStroke(l16, y4, p5, a12, s13);
          break;
        case "CIMPictureStroke":
          this._analyzePictureStroke(l16, y4, p5, a12, s13);
          break;
        case "CIMGradientStroke":
          this._analyzeGradientStroke(l16, y4, p5, a12);
          break;
        case "CIMCharacterMarker":
        case "CIMPictureMarker":
        case "CIMVectorMarker": {
          "CIMLineSymbol" !== e17.type && "CIMPolygonSymbol" !== e17.type || (o18 = K(l16));
          const r15 = [], i13 = l16.primitiveName;
          i13 && r15.push(i13);
          const n20 = p5 && h5(l16.markerPlacement);
          this._analyzeMarker(l16, y4, null, r15, o18, a12, t19, [], s13, false, n20);
          break;
        }
        default:
          q2().error("Cannot analyze CIM layer", l16.type);
      }
    }
  }
  _analyzeSolidFill(e17, t19, r14, i12) {
    const { primitiveName: o18, type: a12 } = e17, s13 = M3(e17.color), l16 = m8(this._poMap, e17, r14);
    if (!i12 && t19?.some((e18) => "CIMGeometricEffectTaperedPolygon" === e18.effect.type)) {
      const r15 = this._getValueOrOverrideExpression(a12, o18, "Color", s13);
      return void this._cimLayers.push({ type: "outlineFill", colorLocked: !!e17.colorLocked, color: r15, effects: t19, outlineColor: r15, outlineColorLocked: !!e17.colorLocked, ...l6, outlineEffects: t19 });
    }
    this._cimLayers.push({ type: "fill", spriteRasterizationParam: null, colorLocked: !!e17.colorLocked, color: this._getValueOrOverrideExpression(a12, o18, "Color", s13), height: 0, angle: 0, offsetX: 0, offsetY: 0, scaleX: 1, effects: t19, applyRandomOffset: false, sampleAlphaOnly: true, hasUnresolvedReplacementColor: false, animationParams: se(l16) });
  }
  _analyzePictureFill(e17, t19, r14) {
    const { primitiveName: i12, type: o18 } = e17, a12 = k(e17), s13 = I2(e17.height, o3.CIMPictureFill.height);
    let l16 = I2(e17.scaleX, 1);
    if ("width" in e17 && "number" == typeof e17.width) {
      const t20 = e17.width;
      let r15 = 1;
      const i13 = this._resourceManager.getResource(e17.url);
      null != i13 && (r15 = i13.width / i13.height), l16 /= r15 * (s13 / t20);
    }
    const p5 = { type: "sprite-rasterization-param", resource: e17, overrides: this._getPrimitiveMaterialOverrides(i12, o18) }, c12 = m8(this._poMap, e17, r14);
    this._cimLayers.push({ type: "fill", spriteRasterizationParam: p5, colorLocked: !!e17.colorLocked, effects: t19, color: this._getValueOrOverrideExpression(o18, i12, "TintColor", a12), height: this._getValueOrOverrideExpression(o18, i12, "Height", s13), scaleX: this._getValueOrOverrideExpression(o18, i12, "ScaleX", l16), angle: this._getValueOrOverrideExpression(o18, i12, "Rotation", I2(e17.rotation)), offsetX: this._getValueOrOverrideExpression(o18, i12, "OffsetX", I2(e17.offsetX)), offsetY: this._getValueOrOverrideExpression(o18, i12, "OffsetY", I2(e17.offsetY)), applyRandomOffset: false, sampleAlphaOnly: false, hasUnresolvedReplacementColor: false, animationParams: se(c12) });
  }
  _analyzeHatchFill(e17, t19) {
    const { primitiveName: r14, type: i12 } = e17, o18 = this._analyzeMaterialOverrides(r14, ["Rotation", "OffsetX", "OffsetY"]), a12 = X2(o18);
    let s13 = [255, 255, 255, 1], l16 = false;
    if (e17.lineSymbol?.symbolLayers) for (const p5 of e17.lineSymbol.symbolLayers) {
      if ("CIMSolidStroke" !== p5.type) continue;
      const e18 = p5.primitiveName ?? r14;
      l16 || !e18 || p5.colorLocked || null == this._poMap[e18]?.Color && null == this._poMap[e18]?.StrokeColor || (s13 = M3(p5.color), s13 = this._maybeGetValueOrOverrideExpression(e18, "StrokeColor") ?? this._getValueOrOverrideExpression(i12, e18, "Color", s13), l16 = true);
      const t20 = this._maybeGetValueOrOverrideExpression(e18, "StrokeWidth");
      if (t20) {
        let r15 = null, o19 = null;
        "number" == typeof t20 ? r15 = t20 : o19 = t20.valueExpressionInfo;
        let s14 = a12.find((e19) => "strokeWidth" === e19.propertyName);
        s14 ? s14.propertyName = "width" : (s14 = { type: "CIMPrimitiveOverride", primitiveName: e18, propertyName: "width", valueExpressionInfo: o19, value: r15, defaultValue: R2(i12, "width") }, a12.push(s14));
      }
    }
    const n19 = { type: "sprite-rasterization-param", resource: e17, overrides: a12 };
    this._cimLayers.push({ type: "fill", spriteRasterizationParam: n19, colorLocked: !!e17.colorLocked, effects: t19, color: s13, height: this._getValueOrOverrideExpression(i12, r14, "Separation", I2(e17.separation, o3.CIMHatchFill.separation)), scaleX: 1, angle: this._getValueOrOverrideExpression(i12, r14, "Rotation", I2(e17.rotation)), offsetX: this._getValueOrOverrideExpression(i12, r14, "OffsetX", I2(e17.offsetX)), offsetY: this._getValueOrOverrideExpression(i12, r14, "OffsetY", I2(e17.offsetY)), applyRandomOffset: false, sampleAlphaOnly: true, hasUnresolvedReplacementColor: !l16 });
  }
  _analyzeGradientFill(e17, t19) {
    const { angle: r14, gradientMethod: i12, gradientSize: o18, gradientSizeUnits: a12, gradientType: s13, interval: l16, primitiveName: n19, type: p5 } = e17, c12 = o3.CIMGradientFill, m11 = e17.colorRamp;
    this._cimLayers.push({ type: "gradientFill", spriteRasterizationParam: { type: "sprite-rasterization-param", resource: e17, overrides: this._getPrimitiveMaterialOverrides(n19, p5) }, colorLocked: false, effects: t19, color: [255, 255, 255, 1], gradientMethod: this._getValueOrOverrideExpression(p5, n19, "GradientMethod", i12 ?? "Linear"), angle: this._getValueOrOverrideExpression(p5, n19, "Angle", I2(r14, c12.angle)), gradientType: this._getValueOrOverrideExpression(p5, n19, "GradientType", s13 ?? c12.gradientType), interval: this._getValueOrOverrideExpression(p5, n19, "Interval", I2(l16, "CIMFixedColorRamp" === m11.type ? m11.colors.length : c12.interval)), gradientSize: this._getValueOrOverrideExpression(p5, n19, "GradientSize", I2(o18, c12.gradientSize)), gradientSizeUnits: "Absolute" === a12 ? e3.Absolute : "Relative" === a12 ? e3.Relative : c12.gradientSizeUnits });
  }
  _analyzeCompositeOutlineFill(e17, t19, r14) {
    const i12 = e17.find((e18) => "CIMSolidFill" === e18.type), o18 = e17.find((e18) => "CIMSolidStroke" === e18.type);
    if (null == i12 || null == o18) return;
    const a12 = [...t19 ?? [], ...i12.effects ?? []].map((e18) => v2.findEffectOverrides(e18, this._primitiveOverrides)).filter((e18) => null != e18), s13 = [...t19 ?? [], ...o18.effects ?? []].map((e18) => v2.findEffectOverrides(e18, this._primitiveOverrides)).filter((e18) => null != e18), l16 = I2(o18.width, o3.CIMSolidStroke.width), n19 = d3(o18.capStyle, o3.CIMSolidStroke.capstyle), p5 = d3(o18.joinStyle, o3.CIMSolidStroke.joinstyle), c12 = o18.miterLimit;
    this._cimLayers.push({ type: "outlineFill", colorLocked: !!i12.colorLocked, color: this._getValueOrOverrideExpression(i12.type, i12.primitiveName, "Color", M3(i12.color)), effects: a12, outlineColorLocked: !!o18.colorLocked, outlineColor: this._getValueOrOverrideExpression(o18.type, o18.primitiveName, "Color", M3(o18.color)), outlineWidth: this._getValueOrOverrideExpression(o18.type, o18.primitiveName, "Width", l16), cap: this._getValueOrOverrideExpression(o18.type, o18.primitiveName, "CapStyle", n19), join: this._getValueOrOverrideExpression(o18.type, o18.primitiveName, "JoinStyle", p5), miterLimit: c12 && this._getValueOrOverrideExpression(o18.type, o18.primitiveName, "MiterLimit", c12), referenceWidth: r14, outlineEffects: s13 });
  }
  _analyzeSolidStroke(e17, t19, r14, i12, o18) {
    const { primitiveName: a12, type: s13 } = e17, l16 = M3(e17.color), p5 = I2(e17.width, o3.CIMSolidStroke.width), c12 = d3(e17.capStyle, o3.CIMSolidStroke.capstyle), m11 = d3(e17.joinStyle, o3.CIMSolidStroke.joinstyle), y4 = e17.miterLimit;
    let d12, f12, h19, u15, v7 = [];
    if (this._analyzePrimitiveOverrides(a12, t19, null, null) && (v7 = this._getPrimitiveMaterialOverrides(a12, s13)), t19 && Array.isArray(t19) && t19.length > 0) {
      const e18 = t19[t19.length - 1].effect;
      e18 && "CIMGeometricEffectDashes" === e18.type && "NoConstraint" === e18.lineDashEnding && (d12 = e18.dashTemplate, f12 = e18.scaleDash, h19 = e18.offsetAlongLine, u15 = e18.primitiveName, (t19 = [...t19]).pop());
    }
    null != u15 && v7.push(...this._getPrimitiveMaterialOverrides(u15, s13).filter((e18) => "dashTemplate" === e18.propertyName));
    const O4 = void 0 !== d12 ? { type: "sprite-rasterization-param", resource: { type: "dash", dashTemplate: d12, primitiveName: u15 }, overrides: v7 } : null, _5 = m8(this._poMap, e17, o18);
    this._cimLayers.push({ type: "line", spriteRasterizationParam: O4, isOutline: r14, colorLocked: !!e17.colorLocked, effects: t19, color: this._getValueOrOverrideExpression(s13, a12, "Color", l16), width: this._getValueOrOverrideExpression(s13, a12, "Width", p5), cap: this._getValueOrOverrideExpression(s13, a12, "CapStyle", c12), join: this._getValueOrOverrideExpression(s13, a12, "JoinStyle", m11), miterLimit: y4 && this._getValueOrOverrideExpression(s13, a12, "MiterLimit", y4), referenceWidth: i12, zOrder: $2(e17.name), dashTemplate: this._maybeGetValueOrOverrideExpression(u15, "DashTemplate") ?? d12, offsetAlongLine: this._getValueOrOverrideExpression(s13, u15, "OffsetAlongLine", h19 ?? 0), scaleDash: f12, sampleAlphaOnly: true, animationParams: se(_5) });
  }
  _analyzePictureStroke(e17, t19, r14, i12, o18) {
    const { primitiveName: a12, type: s13 } = e17, l16 = k(e17), p5 = I2(e17.width, o3.CIMPictureStroke.width), c12 = d3(e17.capStyle, o3.CIMPictureStroke.capstyle), m11 = d3(e17.joinStyle, o3.CIMPictureStroke.joinstyle), y4 = e17.miterLimit, d12 = { type: "sprite-rasterization-param", resource: e17, overrides: this._getPrimitiveMaterialOverrides(a12, s13) }, f12 = m8(this._poMap, e17, o18);
    this._cimLayers.push({ type: "line", spriteRasterizationParam: d12, isOutline: r14, colorLocked: !!e17.colorLocked, effects: t19, color: this._getValueOrOverrideExpression(s13, a12, "TintColor", l16), width: this._getValueOrOverrideExpression(s13, a12, "Width", p5), cap: this._getValueOrOverrideExpression(s13, a12, "CapStyle", c12), join: this._getValueOrOverrideExpression(s13, a12, "JoinStyle", m11), miterLimit: y4 && this._getValueOrOverrideExpression(s13, a12, "MiterLimit", y4), referenceWidth: i12, zOrder: $2(e17.name), dashTemplate: null, scaleDash: false, sampleAlphaOnly: false, animationParams: se(f12) });
  }
  _analyzeGradientStroke(e17, t19, r14, i12) {
    const { gradientMethod: o18, gradientSize: a12, gradientSizeUnits: s13, gradientType: l16, interval: n19, primitiveName: p5, type: c12 } = e17, m11 = o3.CIMGradientStroke, y4 = I2(e17.width, m11.width), d12 = d3(e17.capStyle, m11.capstyle), f12 = d3(e17.joinStyle, m11.joinstyle), h19 = e17.miterLimit, u15 = e17.colorRamp;
    this._cimLayers.push({ type: "gradientStroke", spriteRasterizationParam: { type: "sprite-rasterization-param", resource: e17, overrides: this._getPrimitiveMaterialOverrides(p5, c12) }, colorLocked: !!e17.colorLocked, effects: t19, color: [255, 255, 255, 1], width: this._getValueOrOverrideExpression(c12, p5, "Width", y4), cap: this._getValueOrOverrideExpression(c12, p5, "CapStyle", d12), join: this._getValueOrOverrideExpression(c12, p5, "JoinStyle", f12), miterLimit: h19 && this._getValueOrOverrideExpression(c12, p5, "MiterLimit", h19), referenceWidth: i12, isOutline: r14, gradientMethod: this._getValueOrOverrideExpression(c12, p5, "GradientMethod", o18 ?? m11.gradientMethod), gradientType: this._getValueOrOverrideExpression(c12, p5, "GradientType", l16 ?? m11.gradientType), interval: this._getValueOrOverrideExpression(c12, p5, "Interval", I2(n19, "CIMFixedColorRamp" === u15.type ? u15.colors.length : m11.interval)), gradientSize: this._getValueOrOverrideExpression(c12, p5, "GradientSize", I2(a12, m11.gradientSize)), gradientSizeUnits: "Absolute" === s13 ? e3.Absolute : "Relative" === s13 ? e3.Relative : m11.gradientSizeUnits });
  }
  _analyzeMarker(e17, t19, r14, i12, o18, a12, s13, l16, y4, d12 = false, f12 = false) {
    d12 ||= !!e17.colorLocked;
    let h19 = y4;
    if (h19 = M4(e17, h19), h19 = y3(this._poMap, e17, h19), h19 = S(e17, h19), h19 = m8(this._poMap, e17, h19), this._analyzeMarkerInsidePolygon(e17, t19, d12, h19)) return;
    const u15 = I2(e17.size, o3.CIMVectorMarker.size), v7 = I2(e17.rotation), O4 = I2(e17.offsetX), _5 = I2(e17.offsetY), { primitiveName: S2, type: M6 } = e17, k5 = this._getValueOrOverrideExpression(M6, S2, "Size", u15), C4 = this._getValueOrOverrideExpression(M6, S2, "Rotation", v7), b6 = this._getValueOrOverrideExpression(M6, S2, "OffsetX", O4), x7 = this._getValueOrOverrideExpression(M6, S2, "OffsetY", _5);
    switch (e17.type) {
      case "CIMPictureMarker":
        this._analyzePictureMarker(e17, t19, r14, i12, o18, a12, k5, C4, b6, x7, l16, h19, d12, f12);
        break;
      case "CIMVectorMarker":
        this._analyzeVectorMarker(e17, t19, r14, i12, o18, a12, k5, C4, b6, x7, l16, h19, s13, d12, f12);
    }
  }
  _analyzeMarkerInsidePolygon(e17, t19, r14, i12) {
    const { markerPlacement: o18, type: s13 } = e17;
    if (!o18 || "CIMMarkerPlacementInsidePolygon" !== o18.type || i12.hasMotionAnimations) return false;
    if ("CIMVectorMarker" === s13 || "CIMPictureMarker" === s13) {
      const r15 = e17.primitiveName;
      if (r15 && this._analyzePrimitiveOverrides([r15], t19, null, null)) return false;
      const i13 = o18.primitiveName;
      if (i13 && this._analyzePrimitiveOverrides([i13], t19, null, null)) return false;
      if ("CIMVectorMarker" === s13) {
        const { markerGraphics: t20 } = e17;
        if (t20) for (const e18 of t20) {
          const { symbol: t21 } = e18;
          if ("CIMPolygonSymbol" === t21?.type && t21.symbolLayers) {
            const { symbolLayers: e19 } = t21;
            for (const t22 of e19) if ("CIMSolidStroke" === t22.type) return false;
          }
        }
      } else {
        const { animatedSymbolProperties: t20 } = e17;
        if (t20) return false;
      }
    }
    const l16 = Math.abs(o18.stepX), n19 = Math.abs(o18.stepY);
    if (0 === l16 || 0 === n19) return true;
    let p5, c12;
    if ("Random" === o18.gridType) {
      const e18 = e2(ft), t20 = Math.max(Math.floor(e18 / l16), 1);
      p5 = n19 * Math.max(Math.floor(e18 / n19), 1);
      c12 = t20 * l16 / p5;
    } else o18.shiftOddRows ? (p5 = 2 * n19, c12 = l16 / n19 * 0.5) : (p5 = n19, c12 = l16 / n19);
    const m11 = k(e17), y4 = "CIMCharacterMarker" === e17.type ? null : { type: "sprite-rasterization-param", resource: e17, overrides: [] };
    return this._cimLayers.push({ type: "fill", spriteRasterizationParam: y4, colorLocked: r14, effects: t19, color: m11, height: p5, scaleX: c12, angle: o18.gridAngle, offsetX: I2(o18.offsetX), offsetY: I2(o18.offsetY), applyRandomOffset: "Random" === o18.gridType, sampleAlphaOnly: "CIMPictureMarker" !== e17.type, hasUnresolvedReplacementColor: true, animationParams: se(i12) }), true;
  }
  _analyzePictureMarker(e17, t19, i12, o18, a12, l16, n19, p5, c12, m11, y4, d12, f12, h19) {
    const { animatedSymbolProperties: u15, primitiveName: v7, type: O4 } = e17;
    let g5 = I2(e17.scaleX, 1);
    const _5 = k(e17);
    i12 || (i12 = this._createMarkerPlacementOverrideExpression(e17.markerPlacement));
    const S2 = this._createGIFAnimatedSymbolPropertiesOverrideExpression(u15), M6 = e17.anchorPoint ?? { x: 0, y: 0 };
    if ("width" in e17 && "number" == typeof e17.width) {
      const t20 = e17.width;
      let r14 = 1;
      const i13 = this._resourceManager.getResource(e17.url);
      null != i13 && (r14 = i13.width / i13.height);
      g5 /= r14 * (I2(e17.size) / t20);
    }
    const k5 = [...o18];
    let C4;
    e17.primitiveName && k5.push(e17.primitiveName), u15 || S2 ? C4 = { type: "animated", url: e17.url, urlHash: "H" + l(e17.url), playAnimation: e17.animatedSymbolProperties?.playAnimation, reverseAnimation: e17.animatedSymbolProperties?.reverseAnimation, randomizeStartTime: e17.animatedSymbolProperties?.randomizeStartTime, randomizeStartSeed: e17.animatedSymbolProperties?.randomizeStartSeed, startTimeOffset: e17.animatedSymbolProperties?.startTimeOffset, duration: e17.animatedSymbolProperties?.duration, repeatType: e17.animatedSymbolProperties?.repeatType, repeatDelay: e17.animatedSymbolProperties?.repeatDelay } : (C4 = a(e17), C4.markerPlacement = null);
    const b6 = { type: "sprite-rasterization-param", resource: C4, overrides: this._getMaterialOverrides(k5, O4) };
    S2 && b6.overrides.push(...S2.overrides);
    const x7 = n19;
    this._cimLayers.push({ type: "marker", spriteRasterizationParam: b6, colorLocked: f12, effects: t19, scaleSymbolsProportionally: false, alignment: a12, size: n19, scaleX: this._getValueOrOverrideExpression(O4, v7, "ScaleX", g5), rotation: p5, offsetX: c12, offsetY: m11, transform: { type: "cim-marker-transform-param", params: y4 }, color: this._getValueOrOverrideExpression(O4, v7, "TintColor", _5), anchorPoint: { x: M6.x, y: M6.y }, isAbsoluteAnchorPoint: "Relative" !== e17.anchorPointUnits, outlineColor: [0, 0, 0, 0], outlineWidth: 0, frameHeight: 0, widthRatio: 1, rotateClockwise: !!e17.rotateClockwise, referenceSize: l16, sizeRatio: 1, isOutline: h19, markerPlacement: i12, animationParams: se(d12), baseSize: x7 });
  }
  _analyzeVectorMarker(e17, t19, r14, i12, o18, a12, s13, l16, p5, c12, m11, h19, u15, v7, O4) {
    const g5 = e17.markerGraphics;
    if (!g5) return;
    const _5 = e17.frame;
    let S2 = 0;
    S2 = _5 ? _5.ymax - _5.ymin : a12;
    const M6 = !!e17.scaleSymbolsProportionally;
    if (S2) {
      const t20 = { offsetX: p5, offsetY: c12, rotation: l16, size: s13, frameHeight: S2, rotateClockWise: !!e17.rotateClockwise, absoluteAnchorPoint: false, scaleSymbolsProportionally: M6 };
      m11 = [...m11, t20];
    }
    r14 || (r14 = this._createMarkerPlacementOverrideExpression(e17.markerPlacement));
    for (const k5 of g5) if (k5) {
      const s14 = k5.symbol;
      if (!s14) continue;
      const l17 = k5.primitiveName;
      l17 && i12.push(l17);
      let p6, c13 = h19;
      if (("CIMPointSymbol" === s14.type || "CIMTextSymbol" === s14.type) && _5) {
        let t20 = 0, r15 = 0;
        const i13 = k5.geometry;
        "x" in i13 && "y" in i13 && (t20 += i13.x - 0.5 * (_5.xmin + _5.xmax), r15 += i13.y - 0.5 * (_5.ymin + _5.ymax));
        const o19 = e17.anchorPoint;
        let a13 = false;
        o19 && ("Absolute" === e17.anchorPointUnits ? (t20 -= o19.x, r15 -= o19.y, a13 = true) : _5 && (t20 -= (_5.xmax - _5.xmin) * o19.x, r15 -= (_5.ymax - _5.ymin) * o19.y));
        const s15 = { offsetX: t20, offsetY: r15, rotation: 0, size: 0, frameHeight: 0, rotateClockWise: false, absoluteAnchorPoint: a13, scaleSymbolsProportionally: M6 };
        p6 = [...m11, s15];
      }
      const g6 = k5.geometry, [C4, b6] = C2(g6, _5);
      switch (0 === C4 && 0 === b6 || (c13 = A4(c13, C4, b6)), "CIMPointSymbol" === s14.type && (c13 = m8(this._poMap, s14, c13)), s14.type) {
        case "CIMPointSymbol":
        case "CIMLineSymbol":
        case "CIMPolygonSymbol":
          u15 || re(s14) ? (c13 = { ...c13, transform: { type: "AnimatedTransform", relativeTranslation: false, absoluteScale: true, translation: z([0, 0]), rotation: z(0), scale: z(S2), parent: h19.transform } }, this._analyzeMultiLayerGraphicNonSDF(e17, t19, r14, k5, i12, o18, a12, p6 ?? m11, c13, S2, v7, O4)) : this._analyzeMultiLayerGraphic(e17, t19, r14, k5, i12, o18, a12, p6 ?? m11, c13, S2, v7, O4);
          break;
        case "CIMTextSymbol":
          this._analyzeTextGraphic(t19, r14, k5, i12, o18, a12, p6 ?? m11, v7);
      }
      l17 && i12.pop();
    }
  }
  _analyzeMultiLayerGraphic(e17, t19, r14, i12, o18, a12, s13, l16, n19, p5, c12, m11) {
    const y4 = i12.symbol, d12 = y4.symbolLayers;
    if (d12) {
      if (!te(d12) || u10(n19)) return ie(d12) ? (N4(y4, (e18) => {
        e18.colorLocked && (c12 = true);
      }), void this._analyzeMultiLayerGraphicNonSDF(e17, t19, r14, i12, o18, a12, s13, l16, n19, p5, c12, m11)) : void this._analyzeMarkerGraphicSymbolLayers(e17, t19, r14, i12, o18, a12, s13, l16, n19, p5, c12, m11);
      this._analyzeCompositeMarkerGraphic(e17, t19, r14, i12, d12, a12, s13, l16, p5, c12, m11);
    }
  }
  _analyzeMarkerGraphicSymbolLayers(e17, t19, r14, i12, o18, a12, s13, l16, p5, c12, m11, y4) {
    const d12 = i12.symbol, f12 = d12.symbolLayers;
    if (!f12) return;
    const h19 = l7.applyEffects(d12.effects, i12.geometry);
    if (!h19) return;
    let u15 = f12.length;
    for (; u15--; ) {
      const d13 = f12[u15];
      if (!d13 || false === d13.enable) continue;
      const v7 = d13.primitiveName;
      switch (v7 && o18.push(v7), d13.type) {
        case "CIMSolidFill":
        case "CIMSolidStroke": {
          const o19 = l7.applyEffects(d13.effects, h19), f13 = m5(o19);
          if (!f13) continue;
          const u16 = "Relative" !== e17.anchorPointUnits, O4 = v(d13) ?? 0, { frameSizeRatio: _5, anchorX: S2, anchorY: M6, widthRatio: x7, sdfPaddingRatio: z2 } = h8(f13, e17.frame, e17.size, e17.anchorPoint, u16, O4, e17.scaleSymbolsProportionally), I4 = "CIMSolidFill" === d13.type, E4 = { type: "sdf", geom: o19, sdfPaddingRatio: z2, asFill: I4 }, { path: L5 } = d13, N6 = I4 ? M3(T2(d13)) : null == L5 ? M3(N3(d13)) : [0, 0, 0, 0], R5 = I4 ? [0, 0, 0, 0] : M3(N3(d13));
          if (!I4 && !O4) break;
          const A6 = i12.primitiveName;
          let F6 = null;
          I4 && !d13.colorLocked && (F6 = this._maybeGetValueOrOverrideExpression(A6, "FillColor"));
          let X3 = null;
          I4 || d13.colorLocked || (X3 = this._maybeGetValueOrOverrideExpression(A6, "StrokeColor"));
          const j5 = F6 ?? this._getValueOrOverrideExpression(d13.type, v7, "Color", N6), W3 = X3 ?? this._getValueOrOverrideExpression(d13.type, v7, "Color", R5), Y2 = this._maybeGetValueOrOverrideExpression(A6, "StrokeWidth") ?? this._getValueOrOverrideExpression(d13.type, v7, "Width", O4), D4 = L5 ? { type: "sprite-rasterization-param", resource: { type: "path", path: L5, asFill: I4 }, overrides: [] } : { type: "sprite-rasterization-param", resource: E4, overrides: [] }, U4 = m8(this._poMap, d13, p5), J = I2(e17.size, o3.CIMVectorMarker.size), B5 = this._getValueOrOverrideExpression(e17.type, e17.primitiveName, "Size", J);
          this._cimLayers.push({ type: "marker", spriteRasterizationParam: D4, colorLocked: !!d13.colorLocked || !!m11, effects: t19, scaleSymbolsProportionally: !!e17.scaleSymbolsProportionally, alignment: a12, anchorPoint: { x: S2, y: M6 }, isAbsoluteAnchorPoint: u16, size: c12, rotation: 0, offsetX: 0, offsetY: 0, scaleX: 1, transform: { type: "cim-marker-transform-param", params: l16 }, frameHeight: c12, widthRatio: x7, rotateClockwise: false, referenceSize: s13, sizeRatio: _5, color: j5, outlineColor: W3, outlineWidth: Y2, isOutline: y4, markerPlacement: r14, animationParams: se(U4), isStroke: "CIMSolidFill" !== d13.type, baseSize: B5, ...c(o19, z2) });
          break;
        }
        case "CIMPictureMarker":
        case "CIMVectorMarker":
          if (d13.markerPlacement) {
            q2().error("Error analyzing CIM, got unexpected marker placement");
            break;
          }
          this._analyzeMarker(d13, t19, r14, o18, a12, s13, false, l16, p5, m11, y4);
      }
      v7 && o18.pop();
    }
  }
  _analyzeTextGraphic(e17, r14, i12, o18, a12, s13, l16, n19) {
    const p5 = [];
    v2.findApplicableOverrides(i12, this._primitiveOverrides, p5);
    const c12 = i12.geometry;
    if (!("x" in c12) || !("y" in c12)) return;
    const m11 = i12.symbol, y4 = A2(m11), d12 = L3(m11.fontStyleName), f12 = u6(m11.fontFamilyName);
    m11.font = { family: f12, decoration: y4, ...d12 };
    const h19 = I2(m11.height, o3.CIMTextSymbol.height), u15 = I2(m11.angle), v7 = I2(m11.offsetX), O4 = I2(m11.offsetY), { haloSymbol: _5 } = m11, S2 = I2(m11.haloSize, 0);
    let k5 = [0, 0, 0, 0];
    if (_5?.symbolLayers?.length) {
      const e18 = _5.symbolLayers;
      for (const t19 of e18) if (t19.color) {
        k5 = this._getValueOrOverrideExpression(m11?.haloSymbol?.type ?? "CIMPolygonSymbol", t19.primitiveName, "Color", M3(t19.color));
        break;
      }
    }
    const C4 = i12.primitiveName;
    let b6 = [0, 0, 0, 1], x7 = [0, 0, 0, 0], z2 = 0, I4 = false;
    if (m11.symbol?.symbolLayers) for (const t19 of m11.symbol.symbolLayers) {
      const e18 = t19.primitiveName;
      if ("CIMSolidStroke" === t19.type) x7 = this._getValueOrOverrideExpression("CIMSolidStroke", e18, "Color", M3(t19.color)), z2 = this._getValueOrOverrideExpression("CIMSolidStroke", e18, "Width", v(t19) ?? 0);
      else if ("CIMSolidFill" === t19.type) {
        const r15 = M3(t19.color);
        I4 = I4 ?? !!t19.colorLocked, b6 = this._getValueOrOverrideExpression("CIMSolidFill", e18 ?? C4, "Color", r15);
      }
    }
    let E4 = null, L5 = null, N6 = null, R5 = null, A6 = null;
    C4 && (E4 = this._maybeGetValueOrOverrideExpression(C4, "TextSize"), L5 = this._maybeGetValueOrOverrideExpression(C4, "TextAngle"), N6 = this._maybeGetValueOrOverrideExpression(C4, "TextOffsetX"), R5 = this._maybeGetValueOrOverrideExpression(C4, "TextOffsetY"), I4 || (A6 = this._maybeGetValueOrOverrideExpression(C4, "FillColor")));
    const G3 = A6 ?? b6;
    let T4 = null, Y2 = null, D4 = 0;
    if (m11.callout && "CIMBackgroundCallout" === m11.callout.type) {
      const e18 = m11.callout;
      if (e18.backgroundSymbol) {
        const t19 = e18.backgroundSymbol.symbolLayers;
        if (t19) for (const e19 of t19) "CIMSolidFill" === e19.type ? T4 = M3(e19.color) : "CIMSolidStroke" === e19.type && (Y2 = M3(e19.color), D4 = I2(e19.width, o3.CIMSolidStroke.width));
      }
    }
    const U4 = this._getValueOrOverrideExpression(m11.type, i12.primitiveName, "TextString", i12.textString ?? "");
    if (null == U4) return;
    const { fontStyleName: H3 } = m11, J = f12 + (H3 ? "-" + H3.toLowerCase() : "-regular"), B5 = this._getMaterialOverrides(o18, m11.type);
    B5.push(...this._getPrimitiveMaterialOverrides(i12.primitiveName, m11.type)), this._collectDictionaryTemplateOverrides(B5, i12);
    const q3 = { type: "text-rasterization-param", resource: { type: "text", textString: i12.textString ?? "", font: m11.font, symbol: m11, primitiveName: i12.primitiveName }, overrides: B5 };
    this._cimLayers.push({ type: "text", lineWidth: m11.lineWidth, textRasterizationParam: q3, colorLocked: !!n19 || !!I4, effects: e17, alignment: a12, anchorPoint: { x: 0, y: 0 }, isAbsoluteAnchorPoint: false, fontName: J, decoration: y4, haloSize: S2, haloColor: k5, weight: d12.weight, style: d12.style, size: E4 ?? h19, angle: L5 ?? u15, offsetX: N6 ?? v7, offsetY: R5 ?? O4, transform: { type: "cim-marker-transform-param", params: l16 }, horizontalAlignment: F2(m11.horizontalAlignment), verticalAlignment: V2(m11.verticalAlignment), text: U4, color: G3, outlineColor: x7, outlineSize: z2, backgroundColor: T4, borderLineColor: Y2, borderLineWidth: D4, referenceSize: s13, sizeRatio: 1, markerPlacement: r14 });
  }
  _collectDictionaryTemplateOverrides(e17, t19) {
    if (t19.textString && this._hasTextStringTemplates) {
      const r14 = H2(t19.symbol);
      e17.push({ propertyName: "textString", defaultValue: "", valueExpressionInfo: { type: "dictionary-template", textCase: r14, template: t19.textString }, primitiveName: t19.primitiveName });
    }
  }
  _analyzeMultiLayerGraphicNonSDF(e17, t19, r14, i12, a12, s13, l16, n19, p5, c12, m11, y4) {
    const d12 = Z2(e17, i12), f12 = e17.primitiveName, h19 = this._analyzeMaterialOverrides(f12, ["Rotation", "OffsetX", "OffsetY"]), u15 = X2(h19), [O4, _5, S2] = Y.getTextureAnchor(d12, this._resourceManager, ot), M6 = this._getMaterialOverrides(a12, e17.type);
    M6.push(...u15);
    const k5 = { type: "sprite-rasterization-param", resource: { ...d12, avoidSDFRasterization: true }, overrides: M6 }, C4 = I2(e17.size, o3.CIMVectorMarker.size), b6 = this._getValueOrOverrideExpression(e17.type, f12, "Size", C4);
    this._cimLayers.push({ type: "marker", spriteRasterizationParam: k5, colorLocked: m11, effects: t19, scaleSymbolsProportionally: !!e17.scaleSymbolsProportionally, alignment: s13, anchorPoint: { x: O4, y: _5 }, isAbsoluteAnchorPoint: false, size: c12, rotation: 0, offsetX: 0, offsetY: 0, transform: { type: "cim-marker-transform-param", params: n19 }, color: [255, 255, 255, 1], outlineColor: [0, 0, 0, 0], outlineWidth: 0, scaleX: 1, frameHeight: c12, widthRatio: 1, rotateClockwise: !!e17.rotateClockwise, referenceSize: l16, sizeRatio: S2 / u3(e17.size), isOutline: y4, markerPlacement: r14, animationParams: se(p5), baseSize: b6 });
  }
  _createMarkerPlacementOverrideExpression(e17) {
    if (!e17) return null;
    const t19 = [];
    return v2.findApplicableOverrides(e17, this._primitiveOverrides, t19), { type: "cim-marker-placement-param", placement: e17, overrides: ae(t19) };
  }
  _createGIFAnimatedSymbolPropertiesOverrideExpression(e17) {
    if (!e17) return null;
    const t19 = [];
    return v2.findApplicableOverrides(e17, this._primitiveOverrides, t19), { type: "cim-gif-animation-params", animation: e17, overrides: ae(t19) };
  }
  _analyzeCompositeMarkerGraphic(e17, t19, r14, i12, o18, a12, s13, l16, n19, p5, c12) {
    const m11 = i12.geometry, y4 = o18[0], d12 = o18[1], f12 = m5(m11);
    if (!f12) return;
    const h19 = "Relative" !== e17.anchorPointUnits, u15 = I2(y4.width, o3.CIMSolidStroke.width), { frameSizeRatio: v7, anchorX: O4, anchorY: _5, widthRatio: S2, sdfPaddingRatio: M6 } = h8(f12, e17.frame, e17.size, e17.anchorPoint, h19, u15, e17.scaleSymbolsProportionally), { path: b6 } = d12, x7 = d12.primitiveName, z2 = y4.primitiveName, I4 = i12.primitiveName;
    let E4 = null;
    d12.colorLocked || p5 || (E4 = this._maybeGetValueOrOverrideExpression(I4, "FillColor"));
    const L5 = E4 ?? this._getValueOrOverrideExpression(d12.type, x7, "Color", M3(d12.color));
    let N6 = null;
    y4.colorLocked || p5 || (N6 = this._maybeGetValueOrOverrideExpression(I4, "StrokeColor"));
    const R5 = N6 ?? this._getValueOrOverrideExpression(y4.type, z2, "Color", M3(y4.color)), A6 = this._maybeGetValueOrOverrideExpression(I4, "StrokeWidth") ?? this._getValueOrOverrideExpression(y4.type, z2, "Width", u15), w4 = { type: "sprite-rasterization-param", resource: b6 ? { type: "path", path: b6, asFill: true } : { type: "sdf", geom: m11, sdfPaddingRatio: M6, asFill: true }, overrides: [] };
    this._cimLayers.push({ type: "marker", spriteRasterizationParam: w4, colorLocked: p5, effects: t19, scaleSymbolsProportionally: !!e17.scaleSymbolsProportionally, alignment: a12, anchorPoint: { x: O4, y: _5 }, isAbsoluteAnchorPoint: h19, size: n19, rotation: 0, offsetX: 0, offsetY: 0, scaleX: 1, transform: { type: "cim-marker-transform-param", params: l16 }, frameHeight: n19, widthRatio: S2, rotateClockwise: false, referenceSize: s13, sizeRatio: v7, color: L5, outlineColor: R5, outlineWidth: A6, isOutline: c12, markerPlacement: r14 });
  }
  _setPoMap(e17, t19, r14) {
    let i12;
    this._poMap[e17] ? i12 = this._poMap[e17] : (i12 = {}, this._poMap[e17] = i12), i12[t19] = r14;
  }
  _maybeGetValueOrOverrideExpression(e17, t19, r14) {
    return this._getValueOrOverrideExpression("", e17, t19, r14, false);
  }
  _getValueOrOverrideExpression(e17, t19, r14, i12, o18 = true) {
    if (o18 && !E2(i12) && (i12 = R2(e17, r14.toLowerCase())), null == t19) return i12;
    const a12 = this._poMap[t19];
    if (null == a12) return i12;
    const s13 = a12[r14];
    return "string" == typeof s13 || "number" == typeof s13 || Array.isArray(s13) ? s13 : s13 ? { valueExpressionInfo: s13, defaultValue: i12 } : i12;
  }
  _analyzePrimitiveOverrides(e17, t19, r14, i12) {
    if (null == e17) return false;
    "string" == typeof e17 && (e17 = [e17]);
    for (const o18 of this._primitiveOverrides) if (e17.includes(o18.primitiveName) && o18.valueExpressionInfo) return true;
    if (null != t19) {
      for (const o18 of t19) if (o18?.overrides.length > 0) return true;
    }
    if (null != r14) {
      for (const o18 of r14) if (o18?.overrides.length > 0) return true;
    }
    if (null != i12) {
      for (const o18 of i12) if (o18?.overrides.length > 0) return true;
    }
    return false;
  }
  _getMaterialOverrides(e17, t19) {
    if (!e17) return [];
    const r14 = [];
    for (const i12 of e17) r14.push(...this._getPrimitiveMaterialOverrides(i12, t19));
    return r14;
  }
  _getPrimitiveMaterialOverrides(e17, t19) {
    if (!e17) return [];
    const r14 = X2(this._primitiveOverrides.filter((t20) => t20.primitiveName === e17));
    return r14.forEach((e18) => e18.defaultValue = R2(t19, e18.propertyName.toLowerCase())), r14;
  }
  _analyzeMaterialOverrides(e17, t19) {
    return this._primitiveOverrides.filter((r14) => r14.primitiveName !== e17 || !t19.includes(r14.propertyName));
  }
};
function Z2(e17, t19) {
  return { type: e17.type, enable: true, name: e17.name, colorLocked: e17.colorLocked, primitiveName: e17.primitiveName, anchorPoint: e17.anchorPoint, anchorPointUnits: e17.anchorPointUnits, offsetX: 0, offsetY: 0, rotateClockwise: e17.rotateClockwise, rotation: 0, size: e17.size, billboardMode3D: e17.billboardMode3D, depth3D: e17.depth3D, frame: e17.frame, markerGraphics: [t19], scaleSymbolsProportionally: e17.scaleSymbolsProportionally, respectFrame: e17.respectFrame, clippingPath: e17.clippingPath };
}
function $2(e17) {
  if (e17?.startsWith("Level_")) {
    const t19 = parseInt(e17.slice(6), 10);
    if (!isNaN(t19)) return t19;
  }
  return 0;
}
var te = (e17) => e17 && 2 === e17.length && e17[0].enable && e17[1].enable && "CIMSolidStroke" === e17[0].type && "CIMSolidFill" === e17[1].type && null == e17[0].path && null == e17[1].path && !e17[0].effects && !e17[1].effects && !e17[0].animations && !e17[1].animations;
function re(e17) {
  const t19 = e17.symbolLayers;
  if (!t19) return false;
  const r14 = t19.find((e18) => e18.effects?.find((e19) => "CIMGeometricEffectDashes" === e19.type && null != e19.dashTemplate)), i12 = t19.find((e18) => e18.effects?.find((e19) => "CIMGeometricEffectAddControlPoints" === e19.type));
  return !!r14 || !!i12;
}
function ie(e17) {
  return e17.some((e18) => "CIMSolidFill" !== e18.type && "CIMSolidStroke" !== e18.type && ("CIMVectorMarker" !== e18.type && "CIMPictureMarker" !== e18.type || null != e18.markerPlacement));
}
function oe(e17, t19) {
  if (t19?.some((e18) => "CIMGeometricEffectRadial" === e18.type) && t19?.some((e18) => "CIMGeometricEffectTaperedPolygon" === e18.type) && 2 === e17.length) {
    const t20 = e17.find((e18) => "CIMSolidFill" === e18.type), r14 = e17.find((e18) => "CIMSolidStroke" === e18.type), i12 = r14?.effects?.some((e18) => "CIMGeometricEffectDashes" === e18.type);
    if (null != t20 && null != r14 && !i12) return true;
  }
  return false;
}
function ae(e17) {
  return a(e17).map((e18) => ({ ...e18, propertyName: D2(e18.propertyName) }));
}
function se(e17) {
  return u10(e17) ? { type: "animation-params", params: e17 } : null;
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/sources/shaderRepository.js
var e14 = { background: { "background.frag": "#ifdef PATTERN\nuniform lowp float u_opacity;\nuniform lowp sampler2D u_texture;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#else\nuniform lowp vec4 u_color;\n#endif\nvoid main() {\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = u_opacity * color;\n#else\ngl_FragColor = u_color;\n#endif\n}", "background.vert": "precision mediump float;\nattribute vec2 a_pos;\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix;\nvarying mediump vec2 v_tileTextureCoord;\nuniform mediump vec4 u_tlbr;\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\n#endif\nvoid main() {\ngl_Position = vec4((u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0)).xy, u_depth, 1.0);\n#ifdef PATTERN\nv_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\nv_tlbr             = u_tlbr / u_mosaicSize.xyxy;\n#endif\n}" }, circle: { "circle.frag": "precision lowp float;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\nvoid main()\n{\nmediump float dist = length(v_offset);\nmediump float alpha = smoothstep(0.0, -v_blur, dist - 1.0);\nlowp float color_mix_ratio = v_stroke_width < 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));\ngl_FragColor = alpha * mix(v_color, v_stroke_color, color_mix_ratio);\n}", "circle.vert": "precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_circleTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_antialiasingWidth;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_stroke_color = stroke_color * stroke_opacity;\nv_stroke_width = stroke_width;\nv_radius = radius;\nv_blur = max(blur, u_antialiasingWidth / (radius + stroke_width));\nmediump vec2 offset = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\nv_offset = offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos * 0.5, 1.0) + u_displayMat3 * vec3((v_radius + v_stroke_width) * offset + u_circleTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}" }, fill: { "fill.frag": "precision lowp float;\n#ifdef PATTERN\nuniform lowp sampler2D u_texture;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\nvarying lowp vec4 v_color;\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = fract(v_tileTextureCoord);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = v_color[3] * color;\n#else\ngl_FragColor = v_color;\n#endif\n}", "fill.vert": "precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump float u_depth;\nuniform mediump vec2 u_fillTranslation;\n#ifdef PATTERN\n#include <util/util.glsl>\nuniform mediump vec2 u_mosaicSize;\nuniform mediump float u_patternFactor;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\nvarying lowp vec4 v_color;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef PATTERN\nfloat patternWidth = nextPOT(tlbr.z - tlbr.x);\nfloat patternHeight = nextPOT(tlbr.w - tlbr.y);\nfloat scaleX = 1.0 / (patternWidth * u_patternFactor);\nfloat scaleY = 1.0 / (patternHeight * u_patternFactor);\nmat3 patterMat = mat3(scaleX, 0.0,    0.0,\n0.0,    -scaleY, 0.0,\n0.0,    0.0,    1.0);\nv_tileTextureCoord = (patterMat * vec3(a_pos, 1.0)).xy;\nv_tlbr             = tlbr / u_mosaicSize.xyxy;\n#endif\nvec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}" }, icon: { "icon.frag": "precision mediump float;\nuniform lowp sampler2D u_texture;\n#ifdef SDF\nuniform lowp vec4 u_color;\nuniform lowp vec4 u_outlineColor;\n#endif\nuniform highp int u_isStencilPass;\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump flaot v_halo_width;\n#endif\nconst float alphaCutoff = 1.0 / 255.5;\n#include <util/encoding.glsl>\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef SDF\nlowp vec4 fillPixelColor = v_color;\nfloat d = rgba2float(texture2D(u_texture, v_tex)) - 0.5;\nconst float softEdgeRatio = 0.248062016;\nfloat size = max(v_size.x, v_size.y);\nfloat dist = d * softEdgeRatio * size;\nfillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\nif (v_halo_width > 0.25) {\nlowp vec4 outlinePixelColor = u_outlineColor;\nconst float outlineLimitRatio = (16.0 / 86.0);\nfloat clampedOutlineSize = softEdgeRatio * min(v_halo_width, outlineLimitRatio * max(v_size.x, v_size.y));\noutlinePixelColor *= clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);\ngl_FragColor = v_opacity * mixColors(fillPixelColor, outlinePixelColor);\n}\nelse {\ngl_FragColor = v_opacity * fillPixelColor;\n}\n#else\nlowp vec4 texColor = texture2D(u_texture, v_tex);\nif (u_isStencilPass == 1 && texColor.a < alphaCutoff) {\ndiscard;\n}\ngl_FragColor = v_opacity * texColor;\n#endif\n}", "icon.vert": "attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump float v_halo_width;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_iconTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nconst float C_OFFSET_PRECISION = 1.0 / 8.0;\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float tileCoordRatio = 1.0 / 8.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nv_color = color;\nv_opacity = opacity;\n#ifdef SDF\nv_halo_width = halo_width;\n#endif\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_opacity *= interpolatedOpacity;\nmediump float a_angle         = a_levelInfo[1];\nmediump float a_minLevel      = a_levelInfo[2];\nmediump float a_maxLevel      = a_levelInfo[3];\nmediump vec2 a_tex            = a_texAngleRange.xy;\nmediump float delta_z = 0.0;\nmediump float rotated = mod(a_angle + u_mapRotation, 256.0);\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated));\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_opacity, 0.0);\nvec2 offset = C_OFFSET_PRECISION * a_vertexOffset;\nv_size = abs(offset);\n#ifdef SDF\noffset = (120.0 / 86.0) * offset;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayViewMat3 * vec3(size * offset, 0.0) + u_displayMat3 * vec3(u_iconTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\nv_tex = a_tex.xy / u_mosaicSize;\n}" }, line: { "line.frag": "precision lowp float;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying mediump float v_blur;\n#if defined (PATTERN) || defined(SDF)\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\nuniform sampler2D u_texture;\nuniform mediump float u_antialiasing;\n#endif\n#ifdef SDF\n#include <util/encoding.glsl>\n#endif\nvoid main()\n{\nmediump float fragDist = length(v_normal) * v_lineHalfWidth;\nlowp float alpha = clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);\n#ifdef PATTERN\nmediump float relativeTexX = fract(v_accumulatedDistance / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY = 0.5 + v_normal.y * v_lineHalfWidth / (v_patternSize.y * v_widthRatio);\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nlowp vec4 color = texture2D(u_texture, texCoord);\ngl_FragColor = alpha * v_color[3] * color;\n#elif defined(SDF)\nmediump float relativeTexX = fract((v_accumulatedDistance * 0.5) / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY =  0.5 + 0.25 * v_normal.y;\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nmediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\nfloat dist = d * (v_lineHalfWidth + u_antialiasing / 2.0);\ngl_FragColor = alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n#else\ngl_FragColor = alpha * v_color;\n#endif\n}", "line.vert": "precision mediump float;\nattribute vec2 a_pos;\nattribute vec4 a_extrude_offset;\nattribute vec4 a_dir_normal;\nattribute vec2 a_accumulatedDistance;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump float u_zoomFactor;\nuniform mediump vec2 u_lineTranslation;\nuniform mediump float u_antialiasing;\nuniform mediump float u_depth;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nconst float scale = 1.0 / 31.0;\nconst mediump float tileCoordRatio = 8.0;\n#if defined (SDF)\nconst mediump float sdfPatternHalfWidth = 15.5;\n#endif\n#if defined (PATTERN) || defined(SDF)\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\n#endif\nvarying lowp vec4 v_color;\nvarying mediump float v_lineHalfWidth;\nvarying mediump float v_blur;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_blur = blur + u_antialiasing;\nv_normal = a_dir_normal.zw * scale;\n#if defined (PATTERN) || defined(SDF)\nv_tlbr          = tlbr / u_mosaicSize.xyxy;\nv_patternSize   = vec2(tlbr.z - tlbr.x, tlbr.y - tlbr.w);\n#if defined (PATTERN)\nv_widthRatio = width / v_patternSize.y;\n#else\nv_widthRatio = width / sdfPatternHalfWidth / 2.0;\n#endif\n#endif\nv_lineHalfWidth = (width + u_antialiasing) * 0.5;\nmediump vec2 dir = a_dir_normal.xy * scale;\nmediump vec2 offset_ = a_extrude_offset.zw * scale * offset;\nmediump vec2 dist = v_lineHalfWidth * scale * a_extrude_offset.xy;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos + offset_ * tileCoordRatio / u_zoomFactor, 1.0) + u_displayViewMat3 * vec3(dist, 0.0) + u_displayMat3 * vec3(u_lineTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n#if defined (PATTERN) || defined(SDF)\nv_accumulatedDistance = a_accumulatedDistance.x * u_zoomFactor / tileCoordRatio + dot(dir, dist + offset_);\n#endif\n}" }, outline: { "outline.frag": "varying lowp vec4 v_color;\nvarying mediump vec2 v_normal;\nvoid main()\n{\nlowp float dist = abs(v_normal.y);\nlowp float alpha = smoothstep(1.0, 0.0, dist);\ngl_FragColor = alpha * v_color;\n}", "outline.vert": "attribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_xnormal;\n#pragma header\nvarying lowp vec4 v_color;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_fillTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_outline_width;\nvarying lowp vec2 v_normal;\nconst float scale = 1.0 / 15.0;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_normal = a_xnormal;\nmediump vec2 dist = u_outline_width * scale * a_offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(dist + u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}" }, text: { "text.frag": "uniform lowp sampler2D u_texture;\nvarying lowp vec2 v_tex;\nvarying lowp vec4 v_color;\nvarying mediump float v_edgeWidth;\nvarying mediump float v_edgeDistance;\nvoid main()\n{\nlowp float dist = texture2D(u_texture, v_tex).a;\nmediump float alpha = smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist);\ngl_FragColor = alpha * v_color;\n}", "text.vert": "attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_textTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying lowp vec2 v_tex;\nconst float offsetPrecision = 1.0 / 8.0;\nconst mediump float edgePos = 0.75;\nuniform mediump float u_antialiasingWidth;\nvarying mediump float v_edgeDistance;\nvarying mediump float v_edgeWidth;\nuniform lowp float u_halo;\nconst float sdfFontScale = 1.0 / 24.0;\nconst float sdfPixel = 3.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nif (u_halo > 0.5)\n{\nv_color = halo_color * opacity;\nhalo_width *= sdfPixel;\nhalo_blur *= sdfPixel;\n}\nelse\n{\nv_color = color * opacity;\nhalo_width = 0.0;\nhalo_blur = 0.0;\n}\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_color *= interpolatedOpacity;\nmediump float a_angle       = a_levelInfo[1];\nmediump float a_minLevel    = a_levelInfo[2];\nmediump float a_maxLevel    = a_levelInfo[3];\nmediump vec2 a_tex          = a_texAngleRange.xy;\nmediump float a_visMinAngle    = a_texAngleRange.z;\nmediump float a_visMaxAngle    = a_texAngleRange.w;\nmediump float delta_z = 0.0;\nmediump float angle = mod(a_angle + u_mapRotation, 256.0);\nif (a_visMinAngle < a_visMaxAngle)\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) + (1.0 - step(a_visMinAngle, angle)));\n}\nelse\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) * (1.0 - step(a_visMinAngle, angle)));\n}\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_color[3], 0.0);\nv_tex = a_tex.xy / u_mosaicSize;\nv_edgeDistance = edgePos - halo_width / size;\nv_edgeWidth = (u_antialiasingWidth + halo_blur) / size;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + sdfFontScale * u_displayViewMat3 * vec3(offsetPrecision * size * a_vertexOffset, 0.0) + u_displayMat3 * vec3(u_textTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n}" }, util: { "encoding.glsl": "const vec4 rgba2float_factors = vec4(\n255.0 / (256.0),\n255.0 / (256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\nreturn dot(rgba, rgba2float_factors);\n}", "util.glsl": "float nextPOT(in float x) {\nreturn pow(2.0, ceil(log2(abs(x))));\n}" } };

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/sources/resolver.js
function o8(e17) {
  let o18 = e14;
  return e17.split("/").forEach((r14) => {
    o18 && (o18 = o18[r14]);
  }), o18;
}
var t11 = new e6(o8);
function n9(r14) {
  return t11.resolveIncludes(r14);
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/Programs.js
var t12 = (e17) => n5({ PATTERN: e17.pattern });
var a7 = { shaders: (r14) => ({ vertexShader: t12(r14) + n9("background/background.vert"), fragmentShader: t12(r14) + n9("background/background.frag") }) };
var d6 = { shaders: (r14) => ({ vertexShader: n9("circle/circle.vert"), fragmentShader: n9("circle/circle.frag") }) };
var n10 = (e17) => n5({ PATTERN: e17.pattern });
var i7 = { shaders: (r14) => ({ vertexShader: n10(r14) + n9("fill/fill.vert"), fragmentShader: n10(r14) + n9("fill/fill.frag") }) };
var l11 = { shaders: (r14) => ({ vertexShader: n9("outline/outline.vert"), fragmentShader: n9("outline/outline.frag") }) };
var s9 = (e17) => n5({ SDF: e17.sdf });
var f9 = { shaders: (r14) => ({ vertexShader: s9(r14) + n9("icon/icon.vert"), fragmentShader: s9(r14) + n9("icon/icon.frag") }) };
var h13 = (e17) => n5({ PATTERN: e17.pattern, SDF: e17.sdf });
var o9 = { shaders: (r14) => ({ vertexShader: h13(r14) + n9("line/line.vert"), fragmentShader: h13(r14) + n9("line/line.frag") }) };
var g3 = { shaders: (r14) => ({ vertexShader: n9("text/text.vert"), fragmentShader: n9("text/text.frag") }) };

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/VTLMaterialManager.js
var o10 = class {
  constructor() {
    this._programByKey = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._programByKey.forEach((e17) => e17.dispose()), this._programByKey.clear();
  }
  getMaterialProgram(e17, r14, a12) {
    const t19 = r14.key << 3 | this._getMaterialOptionsValue(r14.type, a12);
    if (this._programByKey.has(t19)) return this._programByKey.get(t19);
    const s13 = this._getProgramTemplate(r14.type), { shaders: n19 } = s13, { vertexShader: c12, fragmentShader: o18 } = n19(a12), p5 = r14.getShaderHeader(), i12 = r14.getShaderMain(), u15 = c12.replace("#pragma header", p5).replace("#pragma main", i12), g5 = e17.programCache.acquire(u15, o18, r14.getAttributeLocations());
    return this._programByKey.set(t19, g5), g5;
  }
  _getMaterialOptionsValue(e17, r14) {
    switch (e17) {
      case 0:
        return (r14.pattern ? 1 : 0) << 1;
      case 1:
        return (r14.pattern ? 1 : 0) << 1;
      case 2:
      case 5:
      case 6:
      default:
        return 0;
      case 3: {
        const e18 = r14;
        return (e18.sdf ? 1 : 0) << 2 | (e18.pattern ? 1 : 0) << 1;
      }
      case 4:
        return (r14.sdf ? 1 : 0) << 1;
    }
  }
  _getProgramTemplate(o18) {
    switch (o18) {
      case 0:
        return a7;
      case 5:
        return d6;
      case 1:
        return i7;
      case 4:
        return f9;
      case 3:
        return o9;
      case 2:
        return l11;
      case 6:
        return g3;
      default:
        return null;
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/BitBlitRenderer.js
var n11 = class {
  constructor() {
    this._initialized = false;
  }
  dispose() {
    this._program = r2(this._program), this._vertexArrayObject = r2(this._vertexArrayObject);
  }
  render(r14, t19, i12, s13) {
    r14 && (this._initialized || this._initialize(r14), r14.setBlendFunctionSeparate(1, 771, 1, 771), r14.bindVAO(this._vertexArrayObject), r14.useProgram(this._program), t19.setSamplingMode(i12), r14.bindTexture(t19, 0), this._program.setUniform1i("u_tex", 0), this._program.setUniform1f("u_opacity", s13), r14.drawArrays(_3.TRIANGLE_STRIP, 0, 4), r14.bindTexture(null, 0), r14.bindVAO(null));
  }
  _initialize(r14) {
    if (this._initialized) return true;
    const e17 = new Int8Array(16);
    e17[0] = -1, e17[1] = -1, e17[2] = 0, e17[3] = 0, e17[4] = 1, e17[5] = -1, e17[6] = 1, e17[7] = 0, e17[8] = -1, e17[9] = 1, e17[10] = 0, e17[11] = 1, e17[12] = 1, e17[13] = 1, e17[14] = 1, e17[15] = 1;
    const n19 = new h7(r14, new r7(r14, n8, e17));
    return this._program = e7(r14, r8, n19.locations), this._vertexArrayObject = n19, this._initialized = true, true;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/MaterialManager.js
var e15 = class {
  constructor(r14) {
    this._rctx = r14, this._programByKey = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._programByKey.forEach((r14) => r14.dispose()), this._programByKey.clear();
  }
  getProgram(e17, a12 = []) {
    const t19 = e17.vsPath + "." + e17.fsPath + JSON.stringify(a12);
    if (this._programByKey.has(t19)) return this._programByKey.get(t19);
    const s13 = { ...a12.map((r14) => "string" == typeof r14 ? { name: r14, value: true } : r14).reduce((r14, e18) => ({ ...r14, [e18.name]: e18.value }), {}) }, { vsPath: o18, fsPath: h19, locations: i12 } = e17, g5 = s6(o18, h19, s13), m11 = this._rctx.programCache.acquire(g5.vertexShader, g5.fragmentShader, i12);
    if (!m11) throw new Error("Unable to get program for key: ${key}");
    return this._programByKey.set(t19, m11), m11;
  }
};

// node_modules/@arcgis/core/symbols/cim/Rasterizer.js
var f10 = 512;
var d7 = class {
  constructor(e17) {
    this._resourceManager = e17, this._cachedRasterizationCanvas = null;
  }
  dispose() {
    this._cachedRasterizationCanvas = null;
  }
  get _canvas() {
    return this._cachedRasterizationCanvas || (this._cachedRasterizationCanvas = document.createElement("canvas")), this._cachedRasterizationCanvas;
  }
  rasterizeJSONResource(e17) {
    switch (e17.type) {
      case "dash": {
        const r14 = j2(e17.dashTemplate), [a12, n19, s13] = m3(r14);
        return { size: [n19, s13], image: new Uint32Array(a12.buffer), sdf: true, simplePattern: true, anchorX: 0, anchorY: 0 };
      }
      case "fill-style": {
        const [t19, a12, n19, s13] = f5(this._canvas, e17, it);
        return { size: [a12, n19], image: new Uint32Array(t19.buffer), sdf: false, simplePattern: true, anchorX: 0, anchorY: 0, rasterizationScale: s13 };
      }
      case "sdf":
        return u11(e17);
      case "CIMGradientFill":
      case "CIMGradientStroke":
      case "CIMHatchFill":
      case "CIMPictureMarker":
      case "CIMVectorMarker":
        return this._rasterizeCIMJSONResource(e17);
    }
  }
  _rasterizeCIMJSONResource(r14) {
    switch (r14.type) {
      case "CIMGradientFill":
      case "CIMGradientStroke": {
        const [e17, t19, n19] = g(this._canvas, r14);
        return { size: [t19, n19], image: new Uint32Array(e17.buffer), sdf: false, simplePattern: false, anchorX: 0, anchorY: 0, samplingMode: "Discrete" === r14.gradientType || "CIMFixedColorRamp" === r14.colorRamp.type ? "Nearest" : "Linear" };
      }
      case "CIMHatchFill": {
        const t19 = Y.fromCIMHatchFill(r14, it);
        return this._rasterizeCIMVectorMarker(t19);
      }
      case "CIMPictureMarker": {
        const t19 = Y.fromCIMInsidePolygon(r14);
        return this._rasterizeCIMVectorMarker(t19);
      }
      case "CIMVectorMarker": {
        if ("CIMMarkerPlacementInsidePolygon" === r14.markerPlacement?.type) {
          const t20 = Y.fromCIMInsidePolygon(r14);
          return this._rasterizeCIMVectorMarker(t20);
        }
        const t19 = a3(r14);
        return t19 && !r14.avoidSDFRasterization ? u11(t19) : this._rasterizeCIMVectorMarker(r14, false, ot);
      }
    }
  }
  _rasterizeCIMVectorMarker(r14, t19 = true, a12) {
    const s13 = t19 ? t2.fromExtent(r14.frame) : null, [i12, o18, c12, l16, h19] = Y.rasterize(this._canvas, r14, s13, this._resourceManager, true, a12);
    return i12 ? { size: [o18, c12], image: new Uint32Array(i12.buffer), sdf: false, simplePattern: false, anchorX: l16, anchorY: h19 } : null;
  }
  rasterizeImageResource(e17, r14, t19, a12) {
    this._canvas.width = e17, this._canvas.height = r14;
    const n19 = this._canvas.getContext("2d", { willReadFrequently: true });
    t19 instanceof ImageData ? n19.putImageData(t19, 0, 0) : (t19.setAttribute("width", `${e17}px`), t19.setAttribute("height", `${r14}px`), n19.drawImage(t19, 0, 0, e17, r14));
    const s13 = n19.getImageData(0, 0, e17, r14), i12 = new Uint8Array(s13.data);
    if (a12) {
      for (const c12 of a12) if (c12 && c12.oldColor && 4 === c12.oldColor.length && c12.newColor && 4 === c12.newColor.length) {
        const [e18, r15, t20, a13] = c12.oldColor, [n20, s14, o19, l17] = c12.newColor;
        if (e18 === n20 && r15 === s14 && t20 === o19 && a13 === l17) continue;
        for (let c13 = 0; c13 < i12.length; c13 += 4) e18 === i12[c13] && r15 === i12[c13 + 1] && t20 === i12[c13 + 2] && a13 === i12[c13 + 3] && (i12[c13] = n20, i12[c13 + 1] = s14, i12[c13 + 2] = o19, i12[c13 + 3] = l17);
      }
    }
    let o18;
    for (let c12 = 0; c12 < i12.length; c12 += 4) o18 = i12[c12 + 3] / 255, i12[c12] = i12[c12] * o18, i12[c12 + 1] = i12[c12 + 1] * o18, i12[c12 + 2] = i12[c12 + 2] * o18;
    let l16 = i12, h19 = e17, d12 = r14;
    const u15 = f10;
    if (h19 >= u15 || d12 >= u15) {
      const t20 = h19 / d12;
      t20 > 1 ? (h19 = u15, d12 = Math.round(u15 / t20)) : (d12 = u15, h19 = Math.round(u15 * t20)), l16 = new Uint8Array(4 * h19 * d12);
      const a13 = new Uint8ClampedArray(l16.buffer);
      f3(i12, e17, r14, a13, h19, d12, false);
    }
    return { size: [h19, d12], image: new Uint32Array(l16.buffer), sdf: false, simplePattern: false, anchorX: 0, anchorY: 0 };
  }
};
function u11(e17) {
  if (!e17) return null;
  const { data: r14, width: t19, height: a12, sdfPaddingRatio: n19, sdfDecodeCoeff: s13 } = u8(e17);
  return r14 ? { size: [t19, a12], image: new Uint32Array(r14.buffer), sdf: true, simplePattern: true, sdfPaddingRatio: n19, sdfDecodeCoeff: s13, anchorX: 0, anchorY: 0 } : null;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/RectangleBinPack.js
var t13 = class {
  constructor(t19, e17) {
    this._width = 0, this._height = 0, this._free = [], this._width = t19, this._height = e17, this._free.push(new t4(0, 0, t19, e17));
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  allocate(t19, e17) {
    if (t19 > this._width || e17 > this._height) return new t4();
    let i12 = null, s13 = -1;
    for (let h19 = 0; h19 < this._free.length; ++h19) {
      const r14 = this._free[h19];
      t19 <= r14.width && e17 <= r14.height && (null === i12 || r14.y <= i12.y && r14.x <= i12.x) && (i12 = r14, s13 = h19);
    }
    return null === i12 ? new t4() : (this._free.splice(s13, 1), i12.width < i12.height ? (i12.width > t19 && this._free.push(new t4(i12.x + t19, i12.y, i12.width - t19, e17)), i12.height > e17 && this._free.push(new t4(i12.x, i12.y + e17, i12.width, i12.height - e17))) : (i12.width > t19 && this._free.push(new t4(i12.x + t19, i12.y, i12.width - t19, i12.height)), i12.height > e17 && this._free.push(new t4(i12.x, i12.y + e17, t19, i12.height - e17))), new t4(i12.x, i12.y, t19, e17));
  }
  release(h19) {
    for (let t19 = 0; t19 < this._free.length; ++t19) {
      const e17 = this._free[t19];
      if (e17.y === h19.y && e17.height === h19.height && e17.x + e17.width === h19.x) e17.width += h19.width;
      else if (e17.x === h19.x && e17.width === h19.width && e17.y + e17.height === h19.y) e17.height += h19.height;
      else if (h19.y === e17.y && h19.height === e17.height && h19.x + h19.width === e17.x) e17.x = h19.x, e17.width += h19.width;
      else {
        if (h19.x !== e17.x || h19.width !== e17.width || h19.y + h19.height !== e17.y) continue;
        e17.y = h19.y, e17.height += h19.height;
      }
      this._free.splice(t19, 1), this.release(h19);
    }
    this._free.push(h19);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/GlyphMosaic.js
var r11 = 256;
var a8 = (t19) => Math.floor(t19 / 256);
function n12(t19) {
  const e17 = /* @__PURE__ */ new Set();
  for (const i12 of t19) e17.add(a8(i12));
  return e17;
}
function c6(e17, i12, h19) {
  return e17.has(i12) || e17.set(i12, h19().then(() => {
    e17.delete(i12);
  }).catch((h20) => {
    e17.delete(i12), m(h20);
  })), e17.get(i12);
}
var o11 = (t19) => ({ rect: new t4(0, 0, 0, 0), page: 0, metrics: { left: 0, width: 0, height: 0, advance: 0, top: 0 }, code: t19, sdf: true });
var l12 = class {
  constructor(t19, e17, h19) {
    this.width = 0, this.height = 0, this._dirties = [], this._glyphData = [], this._currentPage = 0, this._glyphCache = {}, this._textures = [], this._rangePromises = /* @__PURE__ */ new Map(), this._preloadCache = {}, this.width = t19, this.height = e17, this._glyphSource = h19, this._binPack = new t13(t19, e17), this._glyphData.push(new Uint8Array(t19 * e17)), this._dirties.push(true), this._textures.push(null), this._initDecorationGlyphs();
  }
  dispose() {
    this._binPack = null;
    for (const t19 of this._textures) t19 && t19.dispose();
    this._textures.length = 0, this._glyphData.length = 0;
  }
  _initDecorationGlyphs() {
    const t19 = [117, 149, 181, 207, 207, 181, 149, 117], e17 = [], i12 = [];
    for (let r14 = 0; r14 < t19.length; r14++) {
      const h20 = t19[r14];
      for (let t20 = 0; t20 < 11; t20++) {
        const s14 = r14 >= 3 && r14 < 5 && t20 >= 3 && t20 < 8 ? 255 : 0;
        e17.push(h20), i12.push(s14);
      }
    }
    const h19 = { metrics: { width: 5, height: 2, left: 0, top: 0, advance: 0 }, bitmap: new Uint8Array(e17) }, s13 = { metrics: { width: 5, height: 2, left: 0, top: 0, advance: 0 }, bitmap: new Uint8Array(i12) };
    this._recordGlyph(h19), this._recordGlyph(s13);
  }
  getTexture(t19, e17) {
    if (!this._textures[e17]) {
      const i12 = new h6(this.width, this.height);
      i12.pixelFormat = 6406, i12.wrapMode = 33071, this._textures[e17] = new A3(t19, i12, new Uint8Array(this.width * this.height));
    }
    return this._dirties[e17] && (this._textures[e17].setData(this._glyphData[e17]), this._dirties[e17] = false), this._textures[e17];
  }
  async getGlyphItems(t19, e17, i12) {
    const h19 = this._getGlyphCache(t19);
    return await this._fetchRanges(t19, e17, i12), e17.map((e18) => this._getMosaicItem(h19, t19, e18));
  }
  bind(t19, e17, i12, h19) {
    const s13 = this.getTexture(t19, i12);
    s13.setSamplingMode(e17), t19.bindTexture(s13, h19);
  }
  preloadASCIIGlyphCache(t19) {
    const e17 = this._preloadCache[t19];
    if (null != e17) return e17;
    const i12 = this._glyphSource.preloadASCIIRange(t19).then(() => {
      const e18 = this._getGlyphCache(t19);
      for (let i13 = 0; i13 < 256; i13++) this._getMosaicItem(e18, t19, i13);
    });
    return this._preloadCache[t19] = i12, i12;
  }
  _getGlyphCache(t19) {
    return this._glyphCache[t19] || (this._glyphCache[t19] = {}), this._glyphCache[t19];
  }
  _invalidate() {
    this._dirties[this._currentPage] = true;
  }
  async _fetchRanges(t19, e17, i12) {
    const h19 = n12(e17), s13 = [];
    h19.forEach((e18) => {
      s13.push(this._fetchRange(t19, e18, i12));
    }), await Promise.all(s13);
  }
  async _fetchRange(t19, e17, i12) {
    if (e17 > r11) return;
    const h19 = t19 + e17;
    return c6(this._rangePromises, h19, () => this._glyphSource.getRange(t19, e17, i12));
  }
  _getMosaicItem(t19, e17, i12) {
    if (!t19[i12]) {
      const h19 = this._glyphSource.getGlyph(e17, i12);
      if (!h19?.metrics) return o11(i12);
      const s13 = this._recordGlyph(h19), r14 = this._currentPage, a12 = h19.metrics;
      t19[i12] = { rect: s13, page: r14, metrics: a12, code: i12, sdf: true }, this._invalidate();
    }
    return t19[i12];
  }
  _recordGlyph(t19) {
    const h19 = t19.metrics;
    let s13;
    if (0 === h19.width) s13 = new t4(0, 0, 0, 0);
    else {
      const e17 = 3, r14 = h19.width + 2 * e17, a12 = h19.height + 2 * e17;
      s13 = this._binPack.allocate(r14, a12), s13.isEmpty && (this._dirties[this._currentPage] || (this._glyphData[this._currentPage] = null), this._currentPage = this._glyphData.length, this._glyphData.push(new Uint8Array(this.width * this.height)), this._dirties.push(true), this._textures.push(null), this._initDecorationGlyphs(), this._binPack = new t13(this.width, this.height), s13 = this._binPack.allocate(r14, a12));
      const n19 = this._glyphData[this._currentPage], c12 = t19.bitmap;
      let o18, l16;
      if (c12) for (let t20 = 0; t20 < a12; t20++) {
        o18 = r14 * t20, l16 = this.width * (s13.y + t20) + s13.x;
        for (let t21 = 0; t21 < r14; t21++) n19[l16 + t21] = c12[o18 + t21];
      }
      has("esri-glyph-debug") && this._showDebugPage(n19);
    }
    return s13;
  }
  _showDebugPage(t19) {
    const e17 = document.createElement("canvas"), i12 = e17.getContext("2d"), h19 = new ImageData(this.width, this.height), s13 = h19.data;
    e17.width = this.width, e17.height = this.height, e17.style.border = "1px solid black";
    for (let r14 = 0; r14 < t19.length; ++r14) s13[4 * r14] = t19[r14], s13[4 * r14 + 1] = 0, s13[4 * r14 + 2] = 0, s13[4 * r14 + 3] = 255;
    i12.putImageData(h19, 0, 0), document.body.appendChild(e17);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/GlyphSource.js
var a9 = class {
  constructor(e17) {
    for (this._metrics = [], this._bitmaps = []; e17.next(); ) switch (e17.tag()) {
      case 1: {
        const t19 = e17.getMessage();
        for (; t19.next(); ) switch (t19.tag()) {
          case 3: {
            const e18 = t19.getMessage();
            let a12, s13, r14, n19, i12, c12, g5;
            for (; e18.next(); ) switch (e18.tag()) {
              case 1:
                a12 = e18.getUInt32();
                break;
              case 2:
                s13 = e18.getBytes();
                break;
              case 3:
                r14 = e18.getUInt32();
                break;
              case 4:
                n19 = e18.getUInt32();
                break;
              case 5:
                i12 = e18.getSInt32();
                break;
              case 6:
                c12 = e18.getSInt32();
                break;
              case 7:
                g5 = e18.getUInt32();
                break;
              default:
                e18.skip();
            }
            e18.release(), a12 && (this._metrics[a12] = { width: r14, height: n19, left: i12, top: c12, advance: g5 }, this._bitmaps[a12] = s13);
            break;
          }
          default:
            t19.skip();
        }
        t19.release();
        break;
      }
      default:
        e17.skip();
    }
  }
  getMetrics(e17) {
    return this._metrics[e17];
  }
  getBitmap(e17) {
    return this._bitmaps[e17];
  }
};
var s10 = class {
  constructor() {
    this._ranges = [];
  }
  getRange(e17) {
    return this._ranges[e17];
  }
  addRange(e17, t19) {
    this._ranges[e17] = t19;
  }
};
var r12 = class {
  constructor(e17) {
    this._glyphInfo = {}, this._baseURL = e17;
  }
  getRange(s13, r14, n19) {
    const i12 = this._getFontStack(s13);
    if (i12.getRange(r14)) return Promise.resolve();
    const c12 = 256 * r14, g5 = c12 + 255, o18 = this._baseURL.replace("{fontstack}", s13).replace("{range}", c12 + "-" + g5);
    return H(o18, { responseType: "array-buffer", ...n19 }).then((e17) => {
      i12.addRange(r14, new a9(new n3(new Uint8Array(e17.data), new DataView(e17.data))));
    });
  }
  async preloadASCIIRange(s13) {
    const r14 = this._getFontStack(s13), n19 = 0, i12 = 255, c12 = this._baseURL.replace("{fontstack}", s13).replace("{range}", n19 + "-" + i12), g5 = await H(c12, { responseType: "array-buffer" }), o18 = new a9(new n3(new Uint8Array(g5.data), new DataView(g5.data)));
    for (let e17 = n19; e17 <= i12; e17++) r14.getRange(e17) || r14.addRange(e17, o18);
  }
  getGlyph(e17, t19) {
    const a12 = this._getFontStack(e17);
    if (!a12) return;
    const s13 = Math.floor(t19 / 256), r14 = a12.getRange(s13);
    return r14 ? { metrics: r14.getMetrics(t19), bitmap: r14.getBitmap(t19) } : void 0;
  }
  _getFontStack(e17) {
    let t19 = this._glyphInfo[e17];
    return t19 || (t19 = this._glyphInfo[e17] = new s10()), t19;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/SDFConverter.js
var o12 = 1e20;
var a10 = class {
  constructor(t19, e17 = 2) {
    this._textureSize = t19, this._rasterizationScale = e17, this._canvasSize = this._textureSize * this._rasterizationScale, this._svg = null;
    const { _canvasSize: s13 } = this, i12 = document.createElement("canvas");
    i12.width = i12.height = s13, this._context = i12.getContext("2d", { willReadFrequently: false }), this._gridOuter = new Float64Array(s13 * s13), this._gridInner = new Float64Array(s13 * s13), this._f = new Float64Array(s13), this._d = new Float64Array(s13), this._z = new Float64Array(s13 + 1), this._v = new Int16Array(s13);
  }
  dispose() {
    this._context = this._gridOuter = this._gridInner = this._f = this._d = this._z = this._v = null, this._svg = n4(this._svg);
  }
  draw(i12, r14, n19) {
    const { _canvasSize: a12, _textureSize: h19, _rasterizationScale: _5 } = this, l16 = h19 / 4;
    this._initSVG();
    const c12 = this.createSVGString(i12, r14);
    return new Promise((i13, r15) => {
      const d12 = new Image();
      d12.src = "data:image/svg+xml; charset=utf8, " + encodeURIComponent(c12), d12.onload = () => {
        d12.onload = null, this._context.clearRect(0, 0, a12, a12), this._context.drawImage(d12, 0, 0, a12, a12);
        const e17 = this._context.getImageData(0, 0, a12, a12), s13 = new Uint8Array(h19 * h19 * 4);
        for (let t19 = 0; t19 < a12 * a12; t19++) {
          const s14 = e17.data[4 * t19 + 3] / 255;
          this._gridOuter[t19] = 1 === s14 ? 0 : 0 === s14 ? o12 : Math.max(0, 0.5 - s14) ** 2, this._gridInner[t19] = 1 === s14 ? o12 : 0 === s14 ? 0 : Math.max(0, s14 - 0.5) ** 2;
        }
        this._edt(this._gridOuter, a12, a12), this._edt(this._gridInner, a12, a12);
        for (let i14 = 0; i14 < h19 * h19; i14++) {
          let e18 = 0;
          for (let t19 = 0; t19 < _5; t19++) {
            const s14 = Math.floor(i14 / h19) * _5 + t19;
            for (let t20 = 0; t20 < _5; t20++) {
              const r16 = s14 * a12 + (i14 % h19 * _5 + t20);
              e18 += this._gridOuter[r16] - this._gridInner[r16];
            }
          }
          e18 /= _5 * _5, e18 /= _5;
          o5(0.5 - e18 / (2 * l16), s13, 4 * i14);
        }
        i13(s13);
      };
      const g5 = n19?.signal;
      g5 && w(g5, () => r15(u2()));
    });
  }
  _initSVG() {
    return this._svg || (this._svg = e4()), this._svg;
  }
  createSVGString(t19, e17) {
    const s13 = this._initSVG(), i12 = t3("path");
    i12.setAttribute("d", t19), s13.appendChild(i12);
    const r14 = i12.getBBox(), o18 = r14.width / r14.height, a12 = this._canvasSize / 2;
    let h19, _5, l16;
    if (o18 > 1) {
      h19 = a12 / r14.width;
      const t20 = a12 * (1 / o18);
      _5 = this._canvasSize / 4, l16 = a12 - t20 / 2;
    } else {
      h19 = a12 / r14.height;
      _5 = a12 - a12 * o18 / 2, l16 = this._canvasSize / 4;
    }
    const c12 = -r14.x * h19 + _5, d12 = -r14.y * h19 + l16;
    i12.setAttribute("style", `transform: matrix(${h19}, 0, 0, ${h19}, ${c12}, ${d12})`), i12.setAttribute("stroke-width", "" + 0.5 / h19);
    const g5 = `<svg style="fill:${e17 ? "red" : "none"}; stroke:${e17 ? "none" : "red"}" height="${this._canvasSize}" width="${this._canvasSize}" xmlns="http://www.w3.org/2000/svg">${s13.innerHTML}</svg>`;
    return s13.removeChild(i12), g5;
  }
  _edt(t19, e17, s13) {
    const i12 = this._f, r14 = this._d, n19 = this._v, o18 = this._z;
    for (let a12 = 0; a12 < e17; a12++) {
      for (let r15 = 0; r15 < s13; r15++) i12[r15] = t19[r15 * e17 + a12];
      this._edt1d(i12, r14, n19, o18, s13);
      for (let i13 = 0; i13 < s13; i13++) t19[i13 * e17 + a12] = r14[i13];
    }
    for (let a12 = 0; a12 < s13; a12++) {
      for (let s14 = 0; s14 < e17; s14++) i12[s14] = t19[a12 * e17 + s14];
      this._edt1d(i12, r14, n19, o18, e17);
      for (let s14 = 0; s14 < e17; s14++) t19[a12 * e17 + s14] = Math.sqrt(r14[s14]);
    }
  }
  _edt1d(t19, e17, s13, i12, r14) {
    s13[0] = 0, i12[0] = -o12, i12[1] = +o12;
    for (let n19 = 1, a12 = 0; n19 < r14; n19++) {
      let e18 = (t19[n19] + n19 * n19 - (t19[s13[a12]] + s13[a12] * s13[a12])) / (2 * n19 - 2 * s13[a12]);
      for (; e18 <= i12[a12]; ) a12--, e18 = (t19[n19] + n19 * n19 - (t19[s13[a12]] + s13[a12] * s13[a12])) / (2 * n19 - 2 * s13[a12]);
      a12++, s13[a12] = n19, i12[a12] = e18, i12[a12 + 1] = +o12;
    }
    for (let n19 = 0, o18 = 0; n19 < r14; n19++) {
      for (; i12[o18 + 1] < n19; ) o18++;
      e17[n19] = (n19 - s13[o18]) * (n19 - s13[o18]) + t19[s13[o18]];
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/SpriteMosaic.js
function h14(t19) {
  return t19 && "static" === t19.type;
}
var c7 = class _c {
  constructor(t19, e17, i12 = 0) {
    this._mosaicPages = [], this._maxItemSize = 0, this._currentPage = 0, this._pageWidth = 0, this._pageHeight = 0, this._mosaicRects = /* @__PURE__ */ new Map(), this._spriteCopyQueue = [], this.pixelRatio = 1, this._pageWidth = t19, this._pageHeight = e17, i12 > 0 && (this._maxItemSize = i12), this.pixelRatio = window.devicePixelRatio || 1, this._binPack = new t13(this._pageWidth, this._pageHeight);
    const s13 = Math.floor(this._pageWidth), r14 = Math.floor(this._pageHeight);
    this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(s13 * r14) }, size: [this._pageWidth, this._pageHeight], dirty: true, texture: void 0 });
  }
  getWidth(t19) {
    return t19 >= this._mosaicPages.length ? -1 : this._mosaicPages[t19].size[0];
  }
  getHeight(t19) {
    return t19 >= this._mosaicPages.length ? -1 : this._mosaicPages[t19].size[1];
  }
  getPageTexture(t19) {
    return t19 < this._mosaicPages.length ? this._mosaicPages[t19].texture : null;
  }
  has(t19) {
    return this._mosaicRects.has(t19);
  }
  get itemCount() {
    return this._mosaicRects.size;
  }
  getSpriteItem(t19) {
    return this._mosaicRects.get(t19);
  }
  addSpriteItem(t19, i12, a12, r14, o18, c12, n19 = 1, g5 = "Linear", p5 = 0.5, m11 = 1) {
    if (this._mosaicRects.has(t19)) return this._mosaicRects.get(t19);
    let d12, u15, l16;
    if (h14(a12)) [d12, u15, l16] = this._allocateImage(i12[0], i12[1]);
    else {
      d12 = new t4(0, 0, i12[0], i12[1]), u15 = this._mosaicPages.length;
      const t20 = void 0;
      this._mosaicPages.push({ mosaicsData: a12, size: [i12[0] + 2 * tt, i12[1] + 2 * tt], dirty: true, texture: t20 });
    }
    if (d12.width <= 0 || d12.height <= 0) return null;
    const _5 = { type: "sprite", rect: d12, width: i12[0], height: i12[1], sdf: o18, simplePattern: c12, rasterizationScale: n19, samplingMode: g5, sdfPaddingRatio: p5, sdfDecodeCoeff: m11, page: u15 };
    return this._mosaicRects.set(t19, _5), h14(a12) && (has("esri-mosaic-debug") && this._showDebugSprite(i12, a12.data), this._copy({ rect: d12, spriteSize: i12, spriteData: a12.data, page: u15, pageSize: l16, repeat: r14, sdf: o18 })), _5;
  }
  hasItemsToProcess() {
    return 0 !== this._spriteCopyQueue.length;
  }
  processNextItem() {
    const t19 = this._spriteCopyQueue.pop();
    t19 && this._copy(t19);
  }
  getMosaicItemPosition(t19) {
    const i12 = this.getSpriteItem(t19), s13 = i12?.rect;
    if (!s13) return null;
    s13.width = i12.width, s13.height = i12.height;
    const a12 = i12.width, r14 = i12.height, o18 = tt, h19 = this._mosaicPages[i12.page].size;
    return { size: [i12.width, i12.height], tl: [(s13.x + o18) / h19[0], (s13.y + o18) / h19[1]], br: [(s13.x + o18 + a12) / h19[0], (s13.y + o18 + r14) / h19[1]], page: i12.page };
  }
  bind(t19, e17, i12 = 0, s13 = 0) {
    const a12 = this._mosaicPages[i12], r14 = a12.mosaicsData;
    let o18 = a12.texture;
    if (o18 || (o18 = g4(t19, a12.size), a12.texture = o18), o18.setSamplingMode(e17), t19.bindTexture(o18, s13), h14(r14)) a12.dirty && (o18.setData(new Uint8Array(r14.data.buffer)), o18.generateMipmap(), has("esri-mosaic-debug") && this._showDebugPage(i12));
    else {
      const t20 = r14.data;
      t20.hasFrameData && (t20.loadFrame(o18), o18.generateMipmap());
    }
    a12.dirty = false;
  }
  getTexture(t19, e17 = 0) {
    const { context: i12 } = t19, s13 = this._mosaicPages[e17], a12 = s13.mosaicsData;
    let r14 = s13.texture;
    if (r14 || (r14 = g4(i12, s13.size), s13.texture = r14), h14(a12)) s13.dirty && (r14.setData(new Uint8Array(a12.data.buffer)), r14.generateMipmap(), has("esri-mosaic-debug") && this._showDebugPage(e17));
    else {
      const e18 = a12.data;
      e18.update(t19), e18.hasFrameData && (e18.loadFrame(r14), r14.generateMipmap());
    }
    return s13.dirty = false, r14;
  }
  dispose() {
    this._binPack = null;
    for (const t19 of this._mosaicPages) {
      const e17 = t19.texture;
      e17 && e17.dispose();
      const i12 = t19.mosaicsData;
      if (!h14(i12)) {
        i12.data.destroy();
      }
    }
    this._mosaicPages = null, this._mosaicRects.clear();
  }
  static _copyBits(t19, e17, i12, s13, a12, r14, o18, h19, c12, n19, g5) {
    let p5 = s13 * e17 + i12, m11 = h19 * r14 + o18;
    if (g5) {
      m11 -= r14;
      for (let o19 = -1; o19 <= n19; o19++, p5 = ((o19 + n19) % n19 + s13) * e17 + i12, m11 += r14) for (let e18 = -1; e18 <= c12; e18++) a12[m11 + e18] = t19[p5 + (e18 + c12) % c12];
    } else for (let d12 = 0; d12 < n19; d12++) {
      for (let e18 = 0; e18 < c12; e18++) a12[m11 + e18] = t19[p5 + e18];
      p5 += e17, m11 += r14;
    }
  }
  _copy(i12) {
    if (i12.page >= this._mosaicPages.length) return;
    const s13 = this._mosaicPages[i12.page], a12 = s13.mosaicsData;
    if (!h14(s13.mosaicsData)) throw new s2("mapview-invalid-resource", "unsuitable data type!");
    const r14 = i12.spriteData, o18 = a12.data;
    _c._copyBits(r14, i12.spriteSize[0], 0, 0, o18, i12.pageSize[0], i12.rect.x + tt, i12.rect.y + tt, i12.spriteSize[0], i12.spriteSize[1], i12.repeat), s13.dirty = true;
  }
  _allocateImage(t19, r14) {
    t19 += 2 * tt, r14 += 2 * tt;
    const o18 = Math.max(t19, r14);
    if (this._maxItemSize && this._maxItemSize < o18) {
      const e17 = 2 ** Math.ceil(e9(t19)), a12 = 2 ** Math.ceil(e9(r14)), o19 = new t4(0, 0, t19, r14);
      return this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(e17 * a12) }, size: [e17, a12], dirty: true, texture: void 0 }), [o19, this._mosaicPages.length - 1, [e17, a12]];
    }
    const c12 = this._binPack.allocate(t19, r14);
    if (c12.width <= 0) {
      const e17 = this._mosaicPages[this._currentPage];
      return !e17.dirty && h14(e17.mosaicsData) && (e17.mosaicsData.data = null), this._currentPage = this._mosaicPages.length, this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(this._pageWidth * this._pageHeight) }, size: [this._pageWidth, this._pageHeight], dirty: true, texture: void 0 }), this._binPack = new t13(this._pageWidth, this._pageHeight), this._allocateImage(t19, r14);
    }
    return [c12, this._currentPage, [this._pageWidth, this._pageHeight]];
  }
  _showDebugSprite([t19, e17], i12) {
    const s13 = document.createElement("canvas");
    s13.width = t19, s13.height = e17, s13.setAttribute("style", `position: absolute; top: ${4 + 204 * n13++}px; right: 208px; width: 200px; height: 200px; border: 1px solid black;`);
    const a12 = s13.getContext("2d"), r14 = new ImageData(t19, e17);
    r14.data.set(new Uint8Array(i12.buffer)), a12.putImageData(r14, 0, 0), document.body.appendChild(s13);
  }
  _showDebugPage(t19) {
    const e17 = this._mosaicPages[t19], { size: [i12, s13], mosaicsData: a12 } = e17;
    if (!h14(a12)) return;
    const r14 = `mosaicDebugPage${t19}`, o18 = document.getElementById(r14) ?? document.createElement("canvas");
    o18.id = r14, o18.width = i12, o18.height = s13, o18.setAttribute("style", `position: absolute; top: ${4 + 204 * t19}px; right: 4px; width: 200px; height: 200px; border: 1px solid black;`);
    const c12 = o18.getContext("2d"), n19 = new ImageData(i12, s13);
    n19.data.set(new Uint8Array(a12.data.buffer)), c12.putImageData(n19, 0, 0), document.body.appendChild(o18);
  }
};
var n13 = 0;
function g4(t19, e17) {
  const i12 = new h6(e17[0], e17[1]);
  return i12.wrapMode = 33071, new A3(t19, i12, null);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/animatedFormats/AnimatableTextureResource.js
var e16 = class {
  constructor(t19, a12, e17, h19) {
    this._animation = t19, this._frameData = null;
    const s13 = (t20) => {
      this._frameData = t20, a12.requestRender();
    };
    this.frameCount = this._animation.frameDurations.length, this.width = this._animation.width, this.height = this._animation.height, this._player = h9(this._animation, e17, h19, s13);
  }
  destroy() {
  }
  loadFrame(i12) {
    const a12 = this._frameData;
    if (null == a12) return;
    const e17 = "width" in a12 ? a12.width : a12.codedWidth, h19 = "height" in a12 ? a12.height : a12.codedHeight;
    i12.updateData(0, tt, tt, e17, h19, a12), this._frameData = null;
  }
  get hasFrameData() {
    return null != this._frameData;
  }
  update(t19) {
    m7(t19, this._player);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/animations/store/AnimationStore.js
var o13 = class {
  constructor() {
    this._entries = new n14(), this._nodes = /* @__PURE__ */ new Map(), this._book = new h15();
  }
  add(t19) {
    let e17 = this._entries.get(t19);
    if (!e17) {
      const s13 = this._book.add(t19), r14 = new Object();
      e17 = { location: s13, references: 0, handle: r14 };
      const o18 = this._entries.set(t19, e17);
      this._nodes.set(r14, o18);
    }
    return e17.references++, e17;
  }
  remove(t19) {
    const e17 = this._nodes.get(t19.handle);
    e17 && e17.payload && (e17.payload.references--, 0 === e17.payload.references && (this._book.remove(e17.payload.location), this._entries.delete(e17), this._nodes.delete(t19.handle)));
  }
  getTexture(t19, e17) {
    return this._book.getTexture(t19, e17);
  }
  destroy() {
    this._book.destroy();
  }
};
var i8 = class _i {
  constructor(t19, e17) {
    this.parent = t19, this.key = e17, this.payload = null, this._children = /* @__PURE__ */ new Map();
  }
  get(t19) {
    return this._children.get(t19);
  }
  ensure(t19) {
    let e17 = this._children.get(t19);
    return e17 || (e17 = new _i(this, t19), this._children.set(t19, e17)), e17;
  }
  delete(t19) {
    this._children.delete(t19);
  }
};
var n14 = class {
  constructor() {
    this._root = new i8(null, NaN);
  }
  set(t19, e17) {
    let s13 = this._root;
    for (const r14 of t19) for (const t20 of r14) s13 = s13.ensure(t20);
    return s13.payload = e17, s13;
  }
  delete(t19) {
    t19.parent?.delete(t19.key);
  }
  get(t19) {
    let e17 = this._root;
    for (const s13 of t19) for (const t20 of s13) {
      const s14 = e17.get(t20);
      if (!s14) return;
      e17 = s14;
    }
    return e17.payload || void 0;
  }
};
var h15 = class {
  constructor() {
    this._pages = [];
  }
  add(t19) {
    0 === this._pages.length && this._pages.push(new u12());
    let e17 = this._pages.length - 1, s13 = this._pages[e17].add(t19);
    if (s13 || (this._pages.push(new u12()), e17 = this._pages.length - 1, s13 = this._pages[e17].add(t19)), !s13) throw new Error("Data allocation failed.");
    return { ...s13, page: e17 };
  }
  remove(t19) {
    this._pages[t19.page].remove(t19);
  }
  getTexture(t19, e17) {
    return this._pages[e17].getTexture(t19);
  }
  destroy() {
  }
};
var u12 = class {
  constructor() {
    this._cursor = { row: 0, column: 0 }, this._columns = 1024, this._rows = 1024, this._data = new Float32Array(this._columns * this._rows * 4), this._texture = null, this._textureCursor = { row: 0, column: 0 };
  }
  add(t19) {
    if (t19.length > this._columns) throw new Error(`The maximum allocation size is ${this._columns} texels.`);
    const e17 = { ...this._cursor };
    if (e17.column += t19.length, e17.column >= this._columns && (e17.column = t19.length, e17.row++), e17.row >= this._rows) return null;
    this._cursor = e17;
    const s13 = { ...this._cursor };
    s13.column -= t19.length;
    let r14 = 4 * (s13.row * this._columns + s13.column);
    for (let o18 = 0; o18 < t19.length; o18++) this._data[r14++] = t19[o18][0], this._data[r14++] = t19[o18][1], this._data[r14++] = t19[o18][2], this._data[r14++] = t19[o18][3];
    return s13;
  }
  remove(t19) {
  }
  getTexture(o18) {
    if (!this._texture) {
      const i13 = new h6(this._columns, this._rows);
      i13.pixelFormat = 6408, i13.dataType = N2.FLOAT, i13.wrapMode = 33071, i13.samplingMode = 9728, i13.hasMipmap = false;
      const n20 = new t6(o18, i13);
      this._texture = new A3(o18, n20);
    }
    if (this._cursor.row === this._textureCursor.row && this._cursor.column === this._textureCursor.column) return this._texture;
    const i12 = this._textureCursor.row, n19 = this._cursor.row - i12 + 1;
    return this._texture.updateData(0, 0, i12, this._columns, n19, this._data, i12), this._textureCursor.row = this._cursor.row, this._textureCursor.column = this._cursor.column, this._texture;
  }
  destroy() {
    this._texture?.dispose();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/TextureManager.js
var b5 = "arial-unicode-ms-regular";
var $3 = () => i.getLogger("esri.views.MapView");
var j3 = (e17, t19, i12) => $3().error(new s2(e17, t19, i12));
var v6 = (e17, t19 = "") => $3().warnOnce(e17, t19);
var k4 = class _k {
  static fromMosaic(e17, t19) {
    return new _k(e17, t19.page, t19.sdf, t19.samplingMode);
  }
  constructor(e17, t19, i12, r14) {
    this.mosaicType = e17, this.page = t19, this.sdf = i12, this.samplingMode = r14;
  }
};
var F5 = class {
  constructor(i12) {
    this._requestRender = i12, this._resourceManager = new i4(), this._invalidFonts = /* @__PURE__ */ new Set(), this._sdfConverter = new a10(ht), this._bindingInfos = new Array(), this._hashToBindingIndex = /* @__PURE__ */ new Map(), this._ongoingRasterizations = /* @__PURE__ */ new Map(), this._imageRequestQueue = new _({ concurrency: 10, process: async (e17, i13) => {
      s3(i13);
      try {
        return await H(e17, { responseType: "image", signal: i13 });
      } catch (s13) {
        if (!d(s13)) throw new s2("mapview-invalid-resource", `Could not fetch requested resource at ${e17}`, s13);
        throw s13;
      }
    } }), this.animationStore = new o13(), this._spriteMosaic = new c7(2048, 2048, 500), this._glyphSource = new r12(`${s.fontsUrl}/{fontstack}/{range}.pbf`), this._glyphMosaic = new l12(1024, 1024, this._glyphSource), this._rasterizer = new d7(this.resourceManager);
  }
  dispose() {
    this._spriteMosaic.dispose(), this._glyphMosaic.dispose(), this._rasterizer.dispose(), this._sdfConverter.dispose(), this._spriteMosaic = null, this._glyphMosaic = null, this._sdfConverter = null, this._hashToBindingIndex.clear(), this._hashToBindingIndex = null, this._bindingInfos = null, this._ongoingRasterizations.clear(), this._ongoingRasterizations = null, this._imageRequestQueue.clear(), this._imageRequestQueue = null, this._resourceManager.destroy(), this.animationStore.destroy();
  }
  get sprites() {
    return this._spriteMosaic;
  }
  get glyphs() {
    return this._glyphMosaic;
  }
  get resourceManager() {
    return this._resourceManager;
  }
  async rasterizeItem(e17, t19) {
    if (null == e17) return j3("mapview-null-resource", "Unable to rasterize null resource"), null;
    if ("animation-info" === e17.type) {
      const { resource: t20 } = e17, i13 = this.animationStore.add(t20), { location: r15 } = i13;
      return { rect: new t4(r15.column, r15.row, t20.length, 1), page: r15.page, type: "sprite", width: t20.length, height: 1, rasterizationScale: 1, sdfPaddingRatio: 0.5, samplingMode: "Linear", sdfDecodeCoeff: 1, simplePattern: false };
    }
    if ("cim-rasterization-info" !== e17.type) return j3("mapview-unexpected-resource", "Unable to rasterize resource"), null;
    const { resource: i12 } = e17;
    if ("text" === i12.type) {
      const e18 = await this._rasterizeText(i12, t19);
      for (const t20 of e18.glyphs) this._setTextureBinding(1, t20);
      return e18;
    }
    const r14 = await this._rasterizeSprite(i12, t19);
    return r14 && this._setTextureBinding(0, r14), r14;
  }
  getMosaicInfo(e17, t19, i12 = false) {
    const r14 = this._getTextureBindingInfo(e17, t19, i12);
    return r14 ? { size: r14.size, texture: { texture: r14.texture, unit: "sprite" === r14.type ? A : B2 } } : (j3("mapview-invalid-resource", `Unable to find resource for ${t19}`), { size: [0, 0], texture: { texture: null, unit: 0 } });
  }
  _getTextureBindingInfo(e17, t19, i12) {
    const { context: r14 } = e17, s13 = this._bindingInfos[t19 - 1], a12 = s13.page, n19 = "Nearest" === s13.samplingMode ? 9728 : i12 ? 9987 : 9729;
    switch (s13.mosaicType) {
      case 0: {
        const t20 = [this.sprites.getWidth(a12), this.sprites.getHeight(a12)], i13 = this._spriteMosaic.getTexture(e17, a12);
        return i13.setSamplingMode(n19), { type: "sprite", texture: i13, size: t20 };
      }
      case 1: {
        const e18 = [this.glyphs.width, this.glyphs.height], t20 = this._glyphMosaic.getTexture(r14, a12);
        return this._glyphMosaic.bind(r14, n19, a12, B2), t20.setSamplingMode(n19), { type: "glyph", texture: t20, size: e18 };
      }
      default:
        return j3("mapview-texture-manager", `Cannot handle unknown type ${s13.mosaicType}`), null;
    }
  }
  _hashMosaic(e17, t19) {
    return 1 | e17 << 1 | (t19.sdf ? 1 : 0) << 2 | ("Nearest" === t19.samplingMode ? 1 : 0) << 3 | t19.page << 4;
  }
  _setTextureBinding(e17, t19) {
    const i12 = this._hashMosaic(e17, t19);
    if (!this._hashToBindingIndex.has(i12)) {
      const r14 = k4.fromMosaic(e17, t19), s13 = this._bindingInfos.length + 1;
      this._hashToBindingIndex.set(i12, s13), this._bindingInfos.push(r14);
    }
    t19.textureBinding = this._hashToBindingIndex.get(i12);
  }
  async _rasterizeText(e17, t19) {
    const { font: r14, textString: a12 } = e17, n19 = f4(r14), o18 = this._invalidFonts.has(n19), [c12, h19] = i2(a12), l16 = d4(c12);
    try {
      const e18 = o18 ? b5 : n19;
      has("esri-2d-stabilize-glyphs") && await this._glyphMosaic.preloadASCIIGlyphCache(e18);
      return { type: "glyphs", glyphs: await this._glyphMosaic.getGlyphItems(e18, l16, t19), isRightToLeft: h19 };
    } catch (u15) {
      v6(`Font ${n19} is not available on the web, using "Arial Unicode MS Regular"`), this._invalidFonts.add(n19);
      return { type: "glyphs", glyphs: await this._glyphMosaic.getGlyphItems(b5, l16, t19), isRightToLeft: h19 };
    }
  }
  _hashSpriteResource(e17) {
    switch (e17.type) {
      case "path":
        return `path:${e17.path}.${e17.asFill ? 1 : 0}`;
      case "CIMPictureMarker":
        return `${e17.type}:${e17.url}:${e17.size}:${p2(e17.markerPlacement)}`;
      case "CIMPictureFill":
        return `${e17.type}:${e17.url}:${e17.height}`;
      case "CIMPictureStroke":
        return `${e17.type}:${e17.url}:${e17.width}`;
      case "dash":
        return `dash:${e17.capStyle}.${j2(e17.dashTemplate).join("")}`;
      case "sdf":
        return `sdf:${JSON.stringify(e17.geom)}.${e17.asFill ? 1 : 0}`;
      case "fill-style":
        return `fill_style:${e17.style}`;
      case "animated":
        return JSON.stringify(r6(e17));
      case "CIMGradientFill":
      case "CIMGradientStroke":
        return `gradient:${JSON.stringify(e17.colorRamp)}.${e17.gradientType}.${e17.interval}`;
      case "CIMHatchFill":
      case "CIMVectorMarker":
        return JSON.stringify(e17);
    }
  }
  async _rasterizeSprite(e17, t19) {
    if (!e17) return null;
    const i12 = l(this._hashSpriteResource(e17));
    if (this._spriteMosaic.has(i12)) return this._spriteMosaic.getSpriteItem(i12);
    if ("url" in e17 && e17.url || "CIMPictureFill" === e17.type || "CIMPictureStroke" === e17.type || "CIMPictureMarker" === e17.type || "CIMVectorMarker" === e17.type) {
      const t20 = [];
      Y.fetchResources({ type: "CIMPointSymbol", symbolLayers: [e17] }, this._resourceManager, t20), t20.length > 0 && await Promise.all(t20);
    }
    switch (e17.type) {
      case "CIMPictureMarker":
        return "CIMMarkerPlacementInsidePolygon" === e17.markerPlacement?.type ? this._rasterizeJSONResource(i12, e17) : this._handleAsyncResource(i12, e17, t19);
      case "animated":
      case "CIMPictureFill":
      case "CIMPictureStroke":
      case "path":
        return this._handleAsyncResource(i12, e17, t19);
      case "CIMGradientFill":
      case "CIMGradientStroke":
      case "CIMHatchFill":
      case "CIMVectorMarker":
      case "dash":
      case "fill-style":
      case "sdf":
        return this._rasterizeJSONResource(i12, e17);
    }
  }
  _rasterizeJSONResource(e17, t19) {
    const i12 = this._rasterizer.rasterizeJSONResource(t19);
    if (i12) {
      const { size: r14, image: s13, sdf: a12, simplePattern: n19, rasterizationScale: o18, samplingMode: c12, sdfPaddingRatio: h19, sdfDecodeCoeff: l16 } = i12;
      return this._addItemToMosaic(e17, r14, { type: "static", data: s13 }, A5(t19), a12, n19, o18, c12, h19, l16);
    }
    return null;
  }
  async _handleAsyncResource(e17, t19, i12) {
    if (this._ongoingRasterizations.has(e17)) return this._ongoingRasterizations.get(e17);
    let r14;
    return r14 = "path" === t19.type ? this._handleSVG(t19, e17, i12) : this._handleImage(t19, e17, i12), this._ongoingRasterizations.set(e17, r14), r14.finally(() => this._ongoingRasterizations.delete(e17)), r14;
  }
  async _handleSVG(e17, t19, i12) {
    const r14 = [ht, ht], { asFill: s13 } = e17, a12 = await this._sdfConverter.draw(e17.path, s13, i12);
    return this._addItemToMosaic(t19, r14, { type: "static", data: new Uint32Array(a12.buffer) }, false, true, true);
  }
  _handleGIFOrPNG(e17, t19, i12) {
    const r14 = e17.url, s13 = this.resourceManager.getResource(r14);
    if (null == s13) return null;
    const { width: a12, height: n19 } = s13;
    if (s13 instanceof HTMLImageElement) {
      if ("animated" === e17.type) return j3("mapview-unexpected-resource", "Attempt to configure animations for a non-animated image."), null;
      const i13 = "colorSubstitutions" in e17 ? e17.colorSubstitutions : void 0, { size: r15, sdf: o19, image: c13 } = this._rasterizer.rasterizeImageResource(a12, n19, s13, i13);
      return this._addItemToMosaic(t19, r15, { type: "static", data: c13 }, A5(e17), o19, false);
    }
    let o18, c12, h19;
    "animated" === e17.type ? (o18 = false, c12 = { type: "CIMAnimatedSymbolProperties", playAnimation: e17.playAnimation, reverseAnimation: e17.reverseAnimation, randomizeStartTime: e17.randomizeStartTime, randomizeStartSeed: e17.randomizeStartSeed, startTimeOffset: e17.startTimeOffset, duration: e17.duration, repeatType: e17.repeatType, repeatDelay: e17.repeatDelay }, h19 = e17.startGroup || 0) : (o18 = A5(e17), c12 = { type: "CIMAnimatedSymbolProperties" }, h19 = 0);
    const l16 = new e16(s13, this._requestRender, c12, h19);
    return this._addItemToMosaic(t19, [l16.width, l16.height], { type: "animated", data: l16 }, o18, false, false);
  }
  async _handleImage(e17, t19, i12) {
    const s13 = e17.url;
    if (B3(s13) || N5(s13)) return this._handleGIFOrPNG(e17, t19, i12);
    if ("animated" === e17.type) return j3("mapview-unexpected-resource", "Attempt to configure animations for a non-animated image."), null;
    try {
      let r14;
      const a12 = this.resourceManager.getResource(s13);
      if (null != a12 && a12 instanceof HTMLImageElement) r14 = a12;
      else {
        const { data: e18 } = await this._imageRequestQueue.push(s13, { ...i12 });
        r14 = e18;
      }
      if (f6(s13)) {
        if ("width" in e17 && "height" in e17) r14.width = u3(e17.width), r14.height = u3(e17.height);
        else if ("cim" in e17) {
          const t20 = e17;
          r14.width = u3(t20.width ?? t20.scaleX * t20.size), r14.height = u3(t20.size);
        }
      }
      if (!r14.width || !r14.height) return null;
      const n19 = r14.width, o18 = r14.height, c12 = "colorSubstitutions" in e17 ? e17.colorSubstitutions : void 0, { size: l16, sdf: u15, image: p5 } = this._rasterizer.rasterizeImageResource(n19, o18, r14, c12);
      return this._addItemToMosaic(t19, l16, { type: "static", data: p5 }, A5(e17), u15, false);
    } catch (j5) {
      if (!d(j5)) throw new s2("mapview-invalid-resource", `Could not fetch requested resource at ${s13}. ${j5.message}`);
      throw j5;
    }
  }
  _addItemToMosaic(e17, t19, i12, r14, s13, a12, n19, o18, c12, h19) {
    return this._spriteMosaic.addSpriteItem(e17, t19, i12, r14, s13, a12, n19, o18, c12, h19);
  }
};
function A5(e17) {
  switch (e17.type) {
    case "CIMVectorMarker":
    case "CIMPictureMarker":
      return U3(e17);
    default:
      return true;
  }
}
var G2 = (e17) => null != e17 && e17.startsWith("data:image/gif");
var B3 = (e17) => e17 && (e17.includes(".gif") || G2(e17));
var O3 = (e17) => null != e17 && e17.startsWith("data:image/png");
var N5 = (e17) => e17 && (e17.includes(".png") || O3(e17));
var U3 = (e17) => e17 && "markerPlacement" in e17 && e17.markerPlacement && "CIMMarkerPlacementInsidePolygon" === e17.markerPlacement.type;

// node_modules/@arcgis/core/views/2d/engine/webgl/TextureUploadManager.js
var u13 = class {
  constructor(e17) {
    this._queue = [], this._refreshable = e17;
  }
  destroy() {
    this._queue = [];
  }
  enqueueTextureUpdate(r14, u15) {
    const n19 = $(), h19 = r14, i12 = zt, a12 = Math.ceil(h19.height / i12);
    s3(u15);
    for (let e17 = 0; e17 < a12; e17++) {
      const t19 = e17 * i12, s13 = e17 === a12 - 1, o18 = s13 ? h19.height - i12 * e17 : i12;
      this._queue.push({ type: "chunk", request: r14, resolver: n19, chunk: e17, chunkOffset: t19, destHeight: o18, chunkIsLast: s13, options: u15 });
    }
    return h(u15, (e17) => n19.reject(e17)), n19.promise;
  }
  upload() {
    const e17 = performance.now();
    let t19 = 0;
    for (; this._queue.length; ) {
      const s13 = this._queue.shift();
      if (s13) {
        if (null != s13.options.signal && s13.options.signal.aborted) continue;
        switch (s13.type) {
          case "chunk":
            this._uploadChunk(s13);
            break;
          case "no-chunk":
            this._uploadNoChunk(s13);
        }
        ++t19;
        const o18 = performance.now() - e17;
        if (o18 + o18 / t19 >= At) break;
      }
    }
    this._queue.length && this._refreshable.requestRender();
  }
  _uploadChunk(e17) {
    const { request: t19, resolver: s13, chunkOffset: o18, chunkIsLast: r14, destHeight: u15 } = e17, { data: n19, texture: h19, width: i12 } = t19;
    null != n19 && (h19.updateData(0, 0, o18, i12, u15, n19, o18), r14 && s13.resolve());
  }
  _uploadNoChunk(e17) {
    const { request: t19, resolver: s13 } = e17, { data: o18, texture: r14 } = t19;
    r14.setData(o18), s13.resolve();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/WorldExtentClipRenderer.js
var f11 = r5(-0.5, -0.5);
var u14 = class {
  constructor() {
    this._centerNdc = n(), this._pxToNdc = n(), this._worldDimensionsPx = n(), this._mat3 = e5(), this._initialized = false;
  }
  dispose() {
    this._program = r2(this._program), this._quad = r2(this._quad);
  }
  render(t19, i12, e17) {
    const { context: r14 } = t19, s13 = this._updateGeometry(t19, e17);
    if (null != i12) {
      const { r: t20, g: e18, b: s14, a: o18 } = i12;
      r14.setClearColor(o18 * t20 / 255, o18 * e18 / 255, o18 * s14 / 255, o18);
    } else r14.setClearColor(0, 0, 0, 0);
    if (r14.setStencilFunction(519, 0, 255), r14.setStencilWriteMask(255), !s13) return r14.setClearStencil(Kt), void r14.clear(17408);
    r14.setClearStencil(Lt), r14.clear(17408), this._initialized || this._initialize(r14), r14.setDepthWriteEnabled(false), r14.setDepthTestEnabled(false), r14.setColorMask(false, false, false, false), r14.setBlendingEnabled(false), r14.setStencilOp(7680, 7680, 7681), r14.setStencilFunction(519, Kt, 255), r14.setStencilTestEnabled(true), r14.useProgram(this._program), this._program.setUniformMatrix3fv("u_worldExtent", this._mat3), this._quad.bind(), this._quad.draw(), this._quad.unbind();
  }
  _initialize(t19) {
    this._initialized || (this._quad = new a5(t19, [0, 0, 1, 0, 0, 1, 1, 1]), this._program = e7(t19, r9, this._quad.locations), this._initialized = true);
  }
  _updateGeometry(t19, a12) {
    const { state: n19, pixelRatio: m11 } = t19, { size: c12, rotation: h19 } = n19, d12 = Math.round(c12[0] * m11), _5 = Math.round(c12[1] * m11);
    if (!n19.spatialReference.isWrappable) return false;
    const p5 = u4(h19), u15 = Math.abs(Math.cos(p5)), b6 = Math.abs(Math.sin(p5)), g5 = Math.round(d12 * u15 + _5 * b6), x7 = Math.round(m11 * n19.worldScreenWidth);
    if (g5 <= x7) return false;
    const j5 = d12 * b6 + _5 * u15, M6 = (a12.left - a12.right) * m11 / d12, S2 = (a12.bottom - a12.top) * m11 / _5;
    o2(this._worldDimensionsPx, x7, j5, 1), o2(this._pxToNdc, 2 / d12, -2 / _5, 1), o2(this._centerNdc, M6, S2, 1);
    const w4 = this._mat3;
    return l5(w4, this._centerNdc), f(w4, w4, this._pxToNdc), 0 !== h19 && h3(w4, w4, p5), f(w4, w4, this._worldDimensionsPx), M(w4, w4, f11), true;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/blend/BlendTechnique.js
var o14 = class extends s7 {
  constructor() {
    super(...arguments), this.type = 5, this._backBufferTexture = null, this.shaders = { blend: new E3(), opacity: new v3() };
  }
  shutdown() {
    super.shutdown(), null !== this._backBufferTexture && (this._backBufferTexture.dispose(), this._backBufferTexture = null);
  }
  render(t19, r14) {
    const { context: s13, state: u15, pixelRatio: i12, inFadeTransition: o18, painter: n19 } = t19, { size: a12 } = u15, c12 = s13.getBoundFramebufferObject();
    let f12, l16;
    null != c12 ? (f12 = c12.width, l16 = c12.height) : (f12 = Math.round(i12 * a12[0]), l16 = Math.round(i12 * a12[1]));
    const { blendMode: h19 } = r14;
    if ("normal" === h19) {
      const t20 = { shader: this.shaders.opacity, uniforms: { config: { layerTexture: { texture: r14.colorTexture, unit: 0 }, opacity: r14.config.opacity } }, defines: null, optionalAttributes: null, useComputeBuffer: false };
      return n19.setPipelineState(e10), void n19.submitDrawMesh(s13, t20, n19.quadMesh);
    }
    const d12 = this._createOrResizeTexture(t19, f12, l16);
    c12.copyToTexture(0, 0, f12, l16, 0, 0, d12);
    const p5 = { color: { write: [true, true, true, true], blendMode: "custom", blendParameters: { srcRGB: 1, dstRGB: 0, srcAlpha: 1, dstAlpha: 0 } }, depth: false, stencil: false };
    n19.setPipelineState(p5);
    const x7 = { backbufferTexture: { texture: d12, unit: 0 }, layerTexture: { texture: r14.colorTexture, unit: 1 }, inFadeOpacity: o18 ? 1 : 0, ...r14.config }, b6 = { shader: this.shaders.blend, uniforms: { config: x7 }, defines: { blendMode: h19 }, optionalAttributes: null, useComputeBuffer: false };
    n19.submitDrawMesh(s13, b6, n19.quadMesh);
  }
  _createOrResizeTexture(e17, t19, r14) {
    const { context: s13 } = e17;
    if (null !== this._backBufferTexture && this._backBufferTexture.descriptor?.width === t19 && this._backBufferTexture.descriptor?.height === r14) return this._backBufferTexture;
    if (null === this._backBufferTexture) {
      const e18 = new h6(t19, r14);
      e18.internalFormat = 6408, e18.wrapMode = 33071, this._backBufferTexture = new A3(s13, e18);
    } else this._backBufferTexture.resize(t19, r14);
    return this._backBufferTexture;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/BlendEffect.js
var n15 = class {
  constructor() {
    this._blendTechnique = new o14();
  }
  dispose(e17) {
    this._blendTechnique?.shutdown();
  }
  draw(e17, n19, d12, i12, o18) {
    this._blendTechnique.render(e17, { colorTexture: n19, config: { opacity: o18, samplingMode: d12 }, blendMode: i12 });
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/Effect.js
var t14 = class {
  constructor() {
    this.name = this.constructor.name;
  }
  createOptions(t19, r14) {
    return null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/FeatureEffect.js
var t15 = class extends t14 {
  constructor(e17) {
    super(), this.name = this.constructor.name, this.defines = [e17];
  }
  dispose() {
  }
  bind({ context: e17, painter: t19 }) {
    this._prev = e17.getBoundFramebufferObject();
    const r14 = t19.getFbos().effect0;
    e17.bindFramebuffer(r14), e17.setColorMask(true, true, true, true), e17.setClearColor(0, 0, 0, 0), e17.clear(16384);
  }
  unbind() {
  }
  draw(e17, t19) {
    const { context: r14, painter: s13 } = e17, n19 = s13.getPostProcessingEffects(t19), o18 = r14.getBoundFramebufferObject();
    for (const { postProcessingTechnique: c12, effect: f12 } of n19) c12.render(e17, { layerFBO: o18, effect: f12 });
    r14.bindFramebuffer(this._prev), r14.setStencilTestEnabled(false), s13.blitTexture(r14, o18.colorTexture, 9728), r14.setStencilTestEnabled(true);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/highlight/HighlightRenderer.js
var _4 = class {
  constructor() {
    this._width = void 0, this._height = void 0, this._resources = null;
  }
  dispose() {
    this._resources && (this._resources.quadGeometry.dispose(), this._resources.quadVAO.dispose(), this._resources.highlightProgram.dispose(), this._resources.blurProgram.dispose(), this._resources = null);
  }
  preBlur(e17, i12) {
    e17.bindTexture(i12, L2), e17.useProgram(this._resources.blurProgram), this._resources.blurProgram.setUniform4fv("u_direction", [1, 0, 1 / this._width, 0]), this._resources.blurProgram.setUniformMatrix4fv("u_channelSelector", t8), e17.bindVAO(this._resources.quadVAO), e17.drawArrays(_3.TRIANGLE_STRIP, 0, 4), e17.bindVAO(null);
  }
  finalBlur(e17, s13) {
    e17.bindTexture(s13, L2), e17.useProgram(this._resources.blurProgram), this._resources.blurProgram.setUniform4fv("u_direction", [0, 1, 0, 1 / this._height]), this._resources.blurProgram.setUniformMatrix4fv("u_channelSelector", c2), e17.bindVAO(this._resources.quadVAO), e17.drawArrays(_3.TRIANGLE_STRIP, 0, 4), e17.bindVAO(null);
  }
  renderHighlight(e17, s13, i12) {
    e17.bindTexture(s13, L2), e17.useProgram(this._resources.highlightProgram), i12.applyHighlightOptions(e17, this._resources.highlightProgram), e17.bindVAO(this._resources.quadVAO), e17.setBlendingEnabled(true), e17.setBlendFunction(1, 771), e17.drawArrays(_3.TRIANGLE_STRIP, 0, 4), e17.bindVAO(null);
  }
  _initialize(s13, i12, h19) {
    this._width = i12, this._height = h19;
    const _5 = new r7(s13, [new t("a_position", 2, R.BYTE, 0, 4), new t("a_texcoord", 2, R.BYTE, 2, 4)], new Int8Array([-1, -1, 0, 0, 1, -1, 1, 0, -1, 1, 0, 1, 1, 1, 1, 1]).buffer), d12 = new h7(s13, _5), c12 = e7(s13, e11, d12.locations), f12 = e7(s13, h10, d12.locations);
    s13.useProgram(c12), c12.setUniform1i("u_texture", L2), c12.setUniform1i("u_shade", M2), c12.setUniform1f("u_sigma", o6), s13.useProgram(f12), f12.setUniform1i("u_texture", L2), f12.setUniform1f("u_sigma", o6), this._resources = { quadGeometry: _5, quadVAO: d12, highlightProgram: c12, blurProgram: f12 };
  }
  setup(r14, e17, s13) {
    this._resources ? (this._width = e17, this._height = s13) : this._initialize(r14, e17, s13);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/highlight/HighlightSurfaces.js
function t16(t19, o18, i12) {
  const h19 = new h6(o18, i12);
  return h19.wrapMode = 33071, new m4(t19, h19, new i5(36168, o18, i12));
}
var o15 = class {
  constructor() {
    this._width = void 0, this._height = void 0, this._resources = null;
  }
  dispose() {
    this._resources && (this._resources.sharedBlur1Fbo.dispose(), this._resources.sharedBlur2Fbo.dispose(), this._resources = null);
  }
  _initialize(r14, e17, s13) {
    this._width = e17, this._height = s13;
    const o18 = t16(r14, e17, s13), i12 = t16(r14, e17, s13);
    this._resources = { sharedBlur1Fbo: o18, sharedBlur2Fbo: i12 };
  }
  setup(r14, e17, s13) {
    !this._resources || this._width === e17 && this._height === s13 || this.dispose(), this._resources || this._initialize(r14, e17, s13);
  }
  get sharedBlur1Tex() {
    return this._resources.sharedBlur1Fbo.colorTexture;
  }
  get sharedBlur1Fbo() {
    return this._resources.sharedBlur1Fbo;
  }
  get sharedBlur2Tex() {
    return this._resources.sharedBlur2Fbo.colorTexture;
  }
  get sharedBlur2Fbo() {
    return this._resources.sharedBlur2Fbo;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/HighlightEffect.js
var i9 = 4;
var h16 = 4 / i9;
var d8 = class extends t14 {
  constructor() {
    super(...arguments), this.defines = ["highlight"], this._hlRenderer = new _4(), this._width = void 0, this._height = void 0, this._boundFBO = null, this._hlSurfaces = new o15(), this._adjustedWidth = void 0, this._adjustedHeight = void 0, this._blitRenderer = new n11();
  }
  dispose() {
    this._hlSurfaces?.dispose(), this._hlRenderer?.dispose(), this._boundFBO = null;
  }
  bind(e17) {
    const { context: t19, painter: s13 } = e17, { width: r14, height: i12 } = t19.getViewport(), h19 = s13.getFbos().effect0;
    this.setup(e17, r14, i12), t19.bindFramebuffer(h19), t19.setColorMask(true, true, true, true), t19.setClearColor(0, 0, 0, 0), t19.clear(16384);
  }
  unbind() {
  }
  setup({ context: e17 }, t19, s13) {
    this._width = t19, this._height = s13;
    const r14 = t19 % i9, d12 = s13 % i9;
    t19 += r14 < i9 / 2 ? -r14 : i9 - r14, s13 += d12 < i9 / 2 ? -d12 : i9 - d12, this._adjustedWidth = t19, this._adjustedHeight = s13, this._boundFBO = e17.getBoundFramebufferObject();
    const l16 = Math.round(t19 * h16), o18 = Math.round(s13 * h16);
    this._hlRenderer.setup(e17, l16, o18), this._hlSurfaces.setup(e17, l16, o18);
  }
  draw(e17) {
    const { context: t19, passOptions: s13 } = e17, r14 = s13.activeGradient, i12 = t19.getBoundFramebufferObject();
    t19.setViewport(0, 0, this._adjustedWidth * h16, this._adjustedHeight * h16), t19.bindFramebuffer(this._hlSurfaces.sharedBlur1Fbo), t19.setStencilTestEnabled(false), t19.setClearColor(0, 0, 0, 0), t19.clear(16384), this._blitRenderer.render(t19, i12.colorTexture, 9728, 1), t19.setStencilTestEnabled(false), t19.setBlendingEnabled(false), t19.setColorMask(false, false, false, true), t19.bindFramebuffer(this._hlSurfaces.sharedBlur2Fbo), t19.setClearColor(0, 0, 0, 0), t19.clear(16384), this._hlRenderer.preBlur(t19, this._hlSurfaces.sharedBlur1Tex), t19.bindFramebuffer(this._hlSurfaces.sharedBlur1Fbo), t19.setClearColor(0, 0, 0, 0), t19.clear(16384), this._hlRenderer.finalBlur(t19, this._hlSurfaces.sharedBlur2Tex), t19.bindFramebuffer(this._boundFBO), t19.setBlendingEnabled(true), t19.setColorMask(true, true, true, true), t19.setViewport(0, 0, this._width, this._height), this._hlRenderer.renderHighlight(t19, this._hlSurfaces.sharedBlur1Tex, r14), this._boundFBO = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/HittestEffect.js
var n16 = class extends t14 {
  constructor() {
    super(...arguments), this.name = this.constructor.name, this.defines = ["hittest"];
  }
  dispose() {
    null != this._fbo && this._fbo.dispose();
  }
  createOptions({ pixelRatio: o18 }, r14) {
    if (!r14.length) return null;
    const n19 = r14.shift(), l16 = n19.x, c12 = n19.y;
    this._outstanding = n19;
    const a12 = has("esri-mobile");
    return { type: "hittest", distance: (a12 ? U : V) * o18, smallSymbolDistance: (a12 ? U : W2) * o18, smallSymbolSizeThreshold: X, position: [l16, c12] };
  }
  bind(t19) {
    const { context: e17, attributeView: s13 } = t19;
    if (!s13.size) return;
    const i12 = s13.getBlock(2);
    if (null == i12) return;
    const o18 = i12.getFBO(e17);
    e17.setViewport(0, 0, s13.size, s13.size), e17.bindFramebuffer(o18), e17.setColorMask(true, true, true, true), e17.setClearColor(0, 0, 0, 0), e17.clear(16640);
  }
  unbind() {
  }
  draw(t19) {
    if (null == this._outstanding) return;
    const e17 = this._outstanding;
    this._outstanding = null, this._resolve(t19, e17.resolvers);
  }
  async _resolve(t19, e17) {
    const { context: s13, attributeView: i12 } = t19, o18 = i12.getBlock(2);
    if (null == o18) return void e17.forEach((t20) => t20.resolve([]));
    const n19 = o18.getFBO(s13), l16 = new Uint8Array(n19.width * n19.height * 4);
    try {
      await n19.readPixelsAsync(0, 0, n19.width, n19.height, 6408, N2.UNSIGNED_BYTE, l16);
    } catch (a12) {
      return void e17.forEach((t20) => t20.resolve([]));
    }
    const c12 = [];
    for (let r14 = 0; r14 < l16.length; r14 += 4) {
      const t20 = r14 / 4;
      l16[r14] && c12.push(t20);
    }
    e17.forEach((t20) => t20.resolve(c12));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/bloom/BloomTechnique.js
var a11 = 5;
var l13 = [1, 0];
var m9 = [0, 1];
var d9 = [1, 0.8, 0.6, 0.4, 0.2];
var c8 = [1, 1, 1];
var p4 = class extends s7 {
  constructor() {
    super(...arguments), this.type = 6, this._intensityFBO = null, this._compositeFBO = null, this._mipsFBOs = new Array(a11), this._nMips = a11, this._kernelSizeArray = [3, 5, 7, 9, 11], this._size = [0, 0], this.shaders = { luminosityPass: new x3(), gaussianBlur: new h11(), composite: new C(), blit: new f7() };
  }
  shutdown() {
    if (super.shutdown(), this._intensityFBO = r2(this._intensityFBO), this._compositeFBO = r2(this._compositeFBO), this._mipsFBOs) {
      for (let e17 = 0; e17 < this._nMips; e17++) this._mipsFBOs[e17] && (this._mipsFBOs[e17].horizontal.dispose(), this._mipsFBOs[e17].vertical.dispose());
      this._mipsFBOs = null;
    }
  }
  render(e17, t19) {
    const { layerFBO: s13 } = t19, { width: i12, height: r14 } = s13, { strength: o18, radius: n19, threshold: u15 } = t19.effect;
    this._createOrResizeResources(e17, i12, r14), this._renderLuminosityHighPass(e17, s13, u15), this._renderGaussianBlur(e17, s13), this._renderComposite(e17, s13, o18, n19), this._renderBlit(e17, s13);
  }
  _renderLuminosityHighPass(e17, s13, i12) {
    const { context: r14, painter: o18 } = e17, { width: n19, height: u15 } = s13, h19 = { ...e10, color: { write: [true, true, true, true], blendMode: "custom", blendParameters: { srcRGB: 1, dstRGB: 771, srcAlpha: 1, dstAlpha: 771 } }, stencil: { write: { mask: 0 }, test: false } };
    o18.setPipelineState(h19), r14.bindFramebuffer(this._intensityFBO);
    const a12 = [Math.round(n19 / 2), Math.round(u15 / 2)];
    r14.setViewport(0, 0, a12[0], a12[1]), r14.setClearColor(0, 0, 0, 0), r14.clear(16384), o18.submitDrawMesh(r14, { shader: this.shaders.luminosityPass, uniforms: { luminosityHighPassConfig: { luminosityTexture: { texture: s13.colorTexture, unit: 0 }, defaultColor: [0, 0, 0], defaultOpacity: 0, luminosityThreshold: i12, smoothWidth: 0.01 } }, defines: null, optionalAttributes: null, useComputeBuffer: false }, o18.quadMesh);
  }
  _renderGaussianBlur(e17, s13) {
    const { context: i12, painter: r14 } = e17, { width: o18, height: n19 } = s13, u15 = { ...e10, color: { write: [true, true, true, true], blendMode: "none" } };
    r14.setPipelineState(u15);
    let h19 = this._intensityFBO.colorTexture;
    const a12 = [Math.round(o18 / 2), Math.round(n19 / 2)];
    for (let t19 = 0; t19 < this._nMips; t19++) {
      i12.setViewport(0, 0, a12[0], a12[1]);
      const e18 = this._mipsFBOs[t19];
      i12.bindFramebuffer(e18.horizontal), r14.submitDrawMesh(i12, { shader: this.shaders.gaussianBlur, uniforms: { gaussianBlurConfig: { texture: { texture: h19, unit: t19 + 1 }, texSize: a12, direction: l13, sigma: this._kernelSizeArray[t19] } }, defines: { kernelRadius: this._kernelSizeArray[t19] }, optionalAttributes: null, useComputeBuffer: false }, r14.quadMesh), h19 = e18.horizontal.colorTexture, i12.bindFramebuffer(e18.vertical), r14.submitDrawMesh(i12, { shader: this.shaders.gaussianBlur, uniforms: { gaussianBlurConfig: { texture: { texture: h19, unit: t19 + 1 }, texSize: a12, direction: m9, sigma: this._kernelSizeArray[t19] } }, defines: { kernelRadius: this._kernelSizeArray[t19] }, optionalAttributes: null, useComputeBuffer: false }, r14.quadMesh), h19 = e18.vertical.colorTexture, a12[0] = Math.round(a12[0] / 2), a12[1] = Math.round(a12[1] / 2);
    }
  }
  _renderComposite(e17, t19, s13, i12) {
    const { context: r14, painter: o18 } = e17, { width: n19, height: u15 } = t19;
    r14.setViewport(0, 0, n19, u15), r14.bindFramebuffer(this._compositeFBO), o18.submitDrawMesh(r14, { shader: this.shaders.composite, uniforms: { compositeConfig: { blurTexture1: { texture: this._mipsFBOs[0].vertical.colorTexture, unit: 1 }, blurTexture2: { texture: this._mipsFBOs[1].vertical.colorTexture, unit: 2 }, blurTexture3: { texture: this._mipsFBOs[2].vertical.colorTexture, unit: 3 }, blurTexture4: { texture: this._mipsFBOs[3].vertical.colorTexture, unit: 4 }, blurTexture5: { texture: this._mipsFBOs[4].vertical.colorTexture, unit: 5 }, bloomStrength: s13, bloomRadius: i12, bloomFactors: d9, bloomTintColor: c8 } }, defines: { numMips: this._nMips }, optionalAttributes: null, useComputeBuffer: false }, o18.quadMesh);
  }
  _renderBlit(e17, s13) {
    const { context: i12, painter: r14 } = e17;
    i12.bindFramebuffer(s13);
    const o18 = { blitTexture: { texture: this._compositeFBO.colorTexture, unit: 6 } }, n19 = { ...e10, color: { write: [true, true, true, true], blendMode: "custom", blendParameters: { srcRGB: 1, dstRGB: 1, srcAlpha: 1, dstAlpha: 1 } } };
    r14.setPipelineState(n19), r14.submitDrawMesh(i12, { shader: this.shaders.blit, uniforms: { blitConfig: o18 }, defines: null, optionalAttributes: null, useComputeBuffer: false }, r14.quadMesh);
  }
  _createOrResizeResources(e17, t19, s13) {
    const { context: i12 } = e17;
    if (this._compositeFBO && this._size[0] === t19 && this._size[1] === s13) return;
    this._size[0] = t19, this._size[1] = s13;
    const r14 = [Math.round(t19 / 2), Math.round(s13 / 2)];
    if (this._compositeFBO) this._compositeFBO.resize(t19, s13);
    else {
      const e18 = new h6(t19, s13);
      e18.internalFormat = 6408, e18.wrapMode = 33071, this._compositeFBO = new m4(i12, e18);
    }
    if (this._intensityFBO) this._intensityFBO.resize(r14[0], r14[1]);
    else {
      const e18 = new h6(r14[0], r14[1]);
      e18.internalFormat = 6408, e18.wrapMode = 33071, this._intensityFBO = new m4(i12, e18);
    }
    for (let o18 = 0; o18 < this._nMips; o18++) {
      if (this._mipsFBOs[o18]) this._mipsFBOs[o18].horizontal.resize(r14[0], r14[1]), this._mipsFBOs[o18].vertical.resize(r14[0], r14[1]);
      else {
        const e18 = new h6(r14[0], r14[1]);
        e18.internalFormat = 6408, e18.wrapMode = 33071, this._mipsFBOs[o18] = { horizontal: new m4(i12, e18), vertical: new m4(i12, e18) };
      }
      r14[0] = Math.round(r14[0] / 2), r14[1] = Math.round(r14[1] / 2);
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/blur/BlurTechnique.js
var o16 = [1, 0];
var l14 = [0, 1];
var d10 = class extends s7 {
  constructor() {
    super(...arguments), this.type = 7, this._blurFBO = null, this._size = [0, 0], this.shaders = { gaussianBlur: new h11(), radialBlur: new R3(), blit: new f7() };
  }
  shutdown() {
    super.shutdown(), this._blurFBO = r2(this._blurFBO);
  }
  render(e17, t19) {
    const { type: s13, radius: r14 } = t19.effect, { layerFBO: i12 } = t19;
    0 !== r14 && (this._createOrResizeResources(e17), "blur" === s13 ? this._gaussianBlur(e17, i12, t19.effect.radius) : this._radialBlur(e17, t19.layerFBO));
  }
  _gaussianBlur(e17, s13, r14) {
    const { context: i12, state: u15, painter: a12, pixelRatio: n19 } = e17, { size: d12 } = u15, h19 = [Math.round(n19 * d12[0]), Math.round(n19 * d12[1])], f12 = this._blurFBO, c12 = { ...e10, color: { write: [true, true, true, true], blendMode: "none" } };
    a12.setPipelineState(c12), i12.bindFramebuffer(f12), a12.submitDrawMesh(i12, { shader: this.shaders.gaussianBlur, uniforms: { gaussianBlurConfig: { texture: { texture: s13.colorTexture, unit: 4 }, texSize: h19, direction: o16, sigma: r14 } }, defines: { kernelRadius: Math.ceil(r14) }, optionalAttributes: null, useComputeBuffer: false }, a12.quadMesh), i12.bindFramebuffer(s13);
    const b6 = { color: { write: [true, true, true, true], blendMode: "none" }, depth: { write: false, test: false }, stencil: { write: { mask: 0 }, test: false } };
    a12.setPipelineState(b6), a12.submitDrawMesh(i12, { shader: this.shaders.gaussianBlur, uniforms: { gaussianBlurConfig: { texture: { texture: f12?.colorTexture, unit: 5 }, texSize: h19, direction: l14, sigma: r14 } }, defines: { kernelRadius: Math.ceil(r14) }, optionalAttributes: null, useComputeBuffer: false }, a12.quadMesh), a12.setPipelineState({ ...e10, stencil: { test: { mask: 255, compare: 514, op: { fail: 7680, zFail: 7680, zPass: 7680 } }, write: false }, color: { write: [true, true, true, true], blendMode: "additive" } });
  }
  _radialBlur(e17, s13) {
    const { context: r14, painter: i12 } = e17, u15 = this._blurFBO;
    r14.bindFramebuffer(u15);
    const a12 = { ...e10, color: { write: [true, true, true, true], blendMode: "none" } };
    i12.setPipelineState(a12), i12.submitDrawMeshUntyped(r14, { shader: this.shaders.radialBlur, uniforms: { radialBlurConfig: { texture: { texture: s13.colorTexture, unit: 4 } } }, defines: null, optionalAttributes: null, useComputeBuffer: false }, i12.quadMesh), r14.bindFramebuffer(s13), i12.setPipelineState({ ...e10, color: { write: [true, true, true, true], blendMode: "custom", blendParameters: { srcRGB: 1, dstRGB: 771, srcAlpha: 1, dstAlpha: 771 } } }), i12.submitDrawMeshUntyped(r14, { shader: this.shaders.blit, uniforms: { blitConfig: { blitTexture: { texture: u15?.colorTexture, unit: 5 } } }, defines: null, optionalAttributes: null, useComputeBuffer: false }, i12.quadMesh);
  }
  _createOrResizeResources(e17) {
    const { context: t19, state: s13, pixelRatio: r14 } = e17, { size: i12 } = s13, u15 = Math.round(r14 * i12[0]), o18 = Math.round(r14 * i12[1]);
    if (!this._blurFBO || this._size[0] !== u15 || this._size[1] !== o18) if (this._size[0] = u15, this._size[1] = o18, this._blurFBO) this._blurFBO.resize(u15, o18);
    else {
      const e18 = new h6(u15, o18);
      e18.internalFormat = 6408, e18.wrapMode = 33071, this._blurFBO = new m4(t19, e18);
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/colorize/ColorizeTechnique.js
var l15 = class extends s7 {
  constructor() {
    super(...arguments), this.type = 8, this._layerFBOTexture = null, this._size = [0, 0], this.shaders = { filterEffect: new y() };
  }
  shutdown() {
    super.shutdown(), this._layerFBOTexture = r2(this._layerFBOTexture);
  }
  render(e17, r14) {
    const { width: s13, height: i12 } = r14.layerFBO;
    this._createOrResizeResources(e17, s13, i12);
    const { context: o18, painter: l16 } = e17, a12 = r14.effect.colorMatrix, n19 = this._layerFBOTexture;
    o18.bindFramebuffer(r14.layerFBO), r14.layerFBO.copyToTexture(0, 0, s13, i12, 0, 0, n19);
    const u15 = { color: { write: [true, true, true, true], blendMode: "none" }, depth: false, stencil: false };
    l16.setPipelineState(u15);
    const c12 = { colorTexture: { texture: n19, unit: 2 }, coefficients: a12 };
    l16.submitDrawMesh(o18, { shader: this.shaders.filterEffect, uniforms: { filterEffectConfig: c12 }, defines: null, optionalAttributes: null, useComputeBuffer: false }, l16.quadMesh), l16.setPipelineState({ ...e10, stencil: { test: { mask: 255, compare: 514, op: { fail: 7680, zFail: 7680, zPass: 7680 } }, write: false } });
  }
  _createOrResizeResources(e17, t19, r14) {
    const { context: s13 } = e17;
    if (!this._layerFBOTexture || this._size[0] !== t19 || this._size[1] !== r14) if (this._size[0] = t19, this._size[1] = r14, this._layerFBOTexture) this._layerFBOTexture.resize(t19, r14);
    else {
      const e18 = new h6(t19, r14);
      e18.internalFormat = 6408, e18.wrapMode = 33071, this._layerFBOTexture = new A3(s13, e18);
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/drop-shadow/DropShadowTechnique.js
var h17 = [1, 0];
var B4 = [0, 1];
var c9 = class extends s7 {
  constructor() {
    super(...arguments), this.type = 12, this._layerFBOTexture = null, this._horizontalBlurFBO = null, this._verticalBlurFBO = null, this._size = [0, 0], this.shaders = { gaussianBlur: new h11(), composite: new c3(), blit: new f7() };
  }
  shutdown() {
    super.shutdown(), this._horizontalBlurFBO = r2(this._horizontalBlurFBO), this._verticalBlurFBO = r2(this._verticalBlurFBO), this._layerFBOTexture = r2(this._layerFBOTexture);
  }
  render(e17, s13) {
    const { context: i12, state: o18, painter: a12 } = e17, { layerFBO: u15 } = s13, l16 = u15.width, n19 = u15.height, c12 = [Math.round(l16), Math.round(n19)], { blurRadius: f12, offsetX: d12, offsetY: m11, color: p5 } = s13.effect, F6 = [u3(d12), u3(m11)];
    this._createOrResizeResources(e17, l16, n19, c12);
    const w4 = this._horizontalBlurFBO, _5 = this._verticalBlurFBO, x7 = { color: { write: [true, true, true, true], blendMode: "none" }, depth: { write: false, test: false }, stencil: { write: { mask: 0 }, test: false } };
    a12.setPipelineState(x7);
    const O4 = this._layerFBOTexture;
    u15.copyToTexture(0, 0, l16, n19, 0, 0, O4), i12.setViewport(0, 0, c12[0], c12[1]), i12.bindFramebuffer(w4), a12.submitDrawMesh(i12, { shader: this.shaders.gaussianBlur, uniforms: { gaussianBlurConfig: { texture: { texture: u15.colorTexture, unit: 4 }, texSize: c12, direction: h17, sigma: f12 } }, defines: { kernelRadius: Math.ceil(f12) }, optionalAttributes: null, useComputeBuffer: false }, a12.quadMesh), i12.bindFramebuffer(_5), a12.submitDrawMesh(i12, { shader: this.shaders.gaussianBlur, uniforms: { gaussianBlurConfig: { texture: { texture: w4?.colorTexture, unit: 5 }, texSize: c12, direction: B4, sigma: f12 } }, defines: { kernelRadius: Math.ceil(f12) }, optionalAttributes: null, useComputeBuffer: false }, a12.quadMesh), i12.bindFramebuffer(u15), i12.setViewport(0, 0, l16, n19), a12.submitDrawMesh(i12, { shader: this.shaders.composite, uniforms: { compositeConfig: { blurTexture: { texture: _5?.colorTexture, unit: 2 }, layerFBOTexture: { texture: O4, unit: 3 }, shadowColor: [p5[3] * (p5[0] / 255), p5[3] * (p5[1] / 255), p5[3] * (p5[2] / 255), p5[3]], displayViewMat3: o18.displayMat3, shadowOffset: F6 } }, defines: null, optionalAttributes: null, useComputeBuffer: false }, a12.quadMesh), a12.setPipelineState({ ...e10, stencil: { test: { mask: 255, compare: 514, op: { fail: 7680, zFail: 7680, zPass: 7680 } }, write: false } });
  }
  _createOrResizeResources(e17, t19, r14, s13) {
    const { context: i12 } = e17;
    if (!this._horizontalBlurFBO || this._size[0] !== t19 || this._size[1] !== r14) {
      if (this._size[0] = t19, this._size[1] = r14, this._horizontalBlurFBO) this._horizontalBlurFBO.resize(s13[0], s13[1]);
      else {
        const e18 = new h6(s13[0], s13[1]);
        e18.internalFormat = 6408, e18.wrapMode = 33071, this._horizontalBlurFBO = new m4(i12, e18);
      }
      if (this._verticalBlurFBO) this._verticalBlurFBO.resize(s13[0], s13[1]);
      else {
        const e18 = new h6(s13[0], s13[1]);
        e18.internalFormat = 6408, e18.wrapMode = 33071, this._verticalBlurFBO = new m4(i12, e18);
      }
      if (this._layerFBOTexture) this._layerFBOTexture.resize(t19, r14);
      else {
        const e18 = new h6(t19, r14);
        e18.internalFormat = 6408, e18.wrapMode = 33071, this._layerFBOTexture = new A3(i12, e18);
      }
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/opacity/OpacityTechnique.js
var o17 = class extends s7 {
  constructor() {
    super(...arguments), this.type = 23, this._layerFBOTexture = null, this._size = [0, 0], this.shaders = { opacity: new v3() };
  }
  shutdown() {
    super.shutdown(), this._layerFBOTexture = r2(this._layerFBOTexture);
  }
  render(e17, t19) {
    const { layerFBO: r14 } = t19, { width: s13, height: i12 } = r14;
    this._createOrResizeResources(e17, s13, i12);
    const { context: o18, painter: a12 } = e17, { amount: u15 } = t19.effect, l16 = this._layerFBOTexture;
    o18.bindFramebuffer(r14), t19.layerFBO.copyToTexture(0, 0, s13, i12, 0, 0, l16);
    const n19 = { color: { write: [true, true, true, true], blendMode: "custom", blendParameters: { srcRGB: 1, dstRGB: 771, srcAlpha: 1, dstAlpha: 771 } }, depth: false, stencil: false }, h19 = { layerTexture: { texture: l16, unit: 0 }, opacity: u15 };
    l16.setSamplingMode(9728), o18.setClearColor(0, 0, 0, 0), o18.clear(16384), a12.setPipelineState(n19), a12.submitDrawMesh(o18, { shader: this.shaders.opacity, uniforms: { config: h19 }, defines: null, optionalAttributes: null, useComputeBuffer: false }, a12.quadMesh);
  }
  _createOrResizeResources(e17, t19, r14) {
    const { context: o18 } = e17;
    if (!this._layerFBOTexture || this._size[0] !== t19 || this._size[1] !== r14) if (this._size[0] = t19, this._size[1] = r14, this._layerFBOTexture) this._layerFBOTexture.resize(t19, r14);
    else {
      const e18 = new h6(t19, r14);
      e18.internalFormat = 6408, e18.wrapMode = 33071, e18.samplingMode = 9728, this._layerFBOTexture = new A3(o18, e18);
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/EffectManager.js
function c10(e17) {
  switch (e17) {
    case "bloom":
    case "blur":
    case "opacity":
    case "drop-shadow":
      return e17;
    default:
      return "colorize";
  }
}
var h18 = { colorize: () => new l15(), blur: () => new d10(), bloom: () => new p4(), opacity: () => new o17(), "drop-shadow": () => new c9() };
var i10 = class {
  constructor() {
    this._effectMap = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._effectMap.forEach((e17) => e17.shutdown()), this._effectMap.clear();
  }
  getPostProcessingEffects(e17) {
    if (!e17 || 0 === e17.length) return [];
    const o18 = [];
    for (const t19 of e17) {
      const e18 = c10(t19.type);
      let r14 = this._effectMap.get(e18);
      r14 || (r14 = h18[e18](), this._effectMap.set(e18, r14)), o18.push({ postProcessingTechnique: r14, effect: t19 });
    }
    return o18;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/painter/RenderPass.js
var t17 = class {
  constructor(e17, t19) {
    this.brushes = e17, this.name = t19.name, this.drawPhase = t19.drawPhase || 1, this._targetFn = t19.target, this.effects = t19.effects || [], this.enableDefaultDraw = t19.enableDefaultDraw ?? (() => true), this.forceDrawByDisplayOrder = !!t19.forceDrawByDisplayOrder;
  }
  render(e17) {
    const { context: t19, profiler: r14 } = e17, s13 = this._targetFn(), a12 = this.drawPhase & e17.drawPhase;
    if (r14.recordPassStart(this.name), a12) {
      this.enableDefaultDraw() && this._doRender(e17, s13), r14.recordPassEnd();
      for (const r15 of this.effects) {
        if (!r15.enable()) continue;
        const a13 = r15.apply, n19 = r15.args?.(), i12 = t19.getViewport(), d12 = t19.getBoundFramebufferObject(), o18 = e17.passOptions;
        this._bindEffect(e17, a13, n19), this._doRender(e17, s13, a13.defines), this._drawAndUnbindEffect(e17, a13, i12, d12, o18, n19);
      }
    }
  }
  _doRender(e17, t19, r14) {
    if (null == t19) return;
    const { profiler: s13, context: a12 } = e17;
    for (const n19 of this.brushes) {
      if (s13.recordBrushStart(n19.name), null != n19.brushEffect) {
        const s14 = a12.getViewport(), i12 = a12.getBoundFramebufferObject(), d12 = e17.passOptions;
        this._bindEffect(e17, n19.brushEffect), this._drawWithBrush(n19, e17, t19, r14), this._drawAndUnbindEffect(e17, n19.brushEffect, s14, i12, d12);
      } else this._drawWithBrush(n19, e17, t19, r14);
      s13.recordBrushEnd();
    }
  }
  _drawWithBrush(t19, r14, s13, a12) {
    p(s13) ? (t19.prepareState(r14, a12), t19.drawMany(r14, s13, a12)) : s13.visible && (t19.prepareState(r14, a12), t19.draw(r14, s13, a12));
  }
  _bindEffect(e17, t19, r14) {
    const { profiler: s13 } = e17;
    s13.recordPassStart(this.name + "." + t19.name), t19.bind(e17, r14);
    const a12 = t19.createOptions(e17, r14);
    e17.passOptions = a12;
  }
  _drawAndUnbindEffect(e17, t19, r14, s13, a12, n19) {
    const { profiler: i12, context: d12 } = e17;
    e17.passOptions = a12, i12.recordBrushStart(t19.name), t19.draw(e17, n19), t19.unbind(e17, n19), d12.bindFramebuffer(s13);
    const { x: o18, y: f12, width: h19, height: c12 } = r14;
    d12.setViewport(o18, f12, h19, c12), i12.recordBrushEnd(), i12.recordPassEnd();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/TechniqueProgramCache.js
var r13 = class {
  constructor() {
    this._programCache = /* @__PURE__ */ new Map();
  }
  destroy() {
    for (const r14 of this._programCache.values()) r14.destroy();
    this._programCache.clear();
  }
  getProgram(r14, e17, t19, a12, o18) {
    const s13 = r14.getShaderKey(e17, t19, a12, o18);
    let c12 = this._programCache.get(s13);
    return c12 || (c12 = r14.getProgram(e17, t19, a12, o18), this._programCache.set(s13, c12)), c12;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/Painter.js
var P3 = class {
  constructor(e17, t19) {
    this.context = e17, this._currentPipelineStateNeedsUpdate = false, this._blitRenderer = new n11(), this._worldExtentRenderer = new u14(), this._brushCache = /* @__PURE__ */ new Map(), this._lastWidth = null, this._lastHeight = null, this._vtlMaterialManager = new o10(), this._blendEffect = new n15(), this._stencilBuf = null, this._prevBeforeLayerFBOStack = [], this._fboPool = [], this.effects = { highlight: new d8(), hittest: new n16(), insideEffect: new t15("inside"), outsideEffect: new t15("outside") }, this._programCache = new r13(), this.materialManager = new e15(e17), this.textureManager = new F5(t19), this.textureUploadManager = new u13(t19), this._effectsManager = new i10(), this._quadMesh = s8.fromVertexStream(e17, [0, 0, 1, 0, 0, 1, 1, 1]);
  }
  dispose() {
    if (this._programCache.destroy(), this.materialManager.dispose(), this.textureManager.dispose(), this.textureUploadManager.destroy(), this._blitRenderer = r2(this._blitRenderer), this._worldExtentRenderer = r2(this._worldExtentRenderer), this._quadMesh = u(this._quadMesh), this._brushCache && (this._brushCache.forEach((e17) => e17.dispose()), this._brushCache.clear(), this._brushCache = null), this._fbos) {
      let e17;
      for (e17 in this._fbos) this._fbos[e17] && this._fbos[e17].dispose();
    }
    for (const e17 of this._fboPool) e17.dispose();
    if (this._fboPool.length = 0, this.effects) {
      let e17;
      for (e17 in this.effects) this.effects[e17] && this.effects[e17].dispose();
    }
    this._effectsManager.dispose(), this._blendEffect.dispose(this.context), this._vtlMaterialManager = r2(this._vtlMaterialManager);
  }
  clearShaderCache() {
    this._programCache.destroy(), this._programCache = new r13();
  }
  get blitRenderer() {
    return this._blitRenderer;
  }
  get vectorTilesMaterialManager() {
    return this._vtlMaterialManager;
  }
  get quadMesh() {
    return this._quadMesh;
  }
  getFbos() {
    if (!this._fbos) throw new Error("InternalError: Painter FBOs not initialized");
    return this._fbos;
  }
  acquireFbo(e17, t19) {
    let s13;
    if (this._fboPool.length > 0) s13 = this._fboPool.pop();
    else {
      const r14 = new h6(e17, t19);
      r14.samplingMode = 9728, r14.wrapMode = 33071, s13 = new m4(this.context, r14, this._stencilBuf);
    }
    return s13.width === e17 && s13.height === t19 || s13.resize(e17, t19), s13;
  }
  releaseFbo(e17) {
    this._fboPool.push(e17);
  }
  getSharedStencilBuffer() {
    return this._stencilBuf;
  }
  beforeRenderPhases(e17, t19, s13) {
    const { context: r14 } = e17;
    this._worldExtentRenderer.render(e17, t19, s13);
    const { width: i12, height: n19 } = r14.getViewport();
    if (this.updateFBOs(i12, n19), this._prevFBO = r14.getBoundFramebufferObject(), r14.bindFramebuffer(this.getFbos().output), r14.setColorMask(true, true, true, true), null != t19) {
      const { r: e18, g: s14, b: i13, a: n20 } = t19;
      r14.setClearColor(n20 * e18 / 255, n20 * s14 / 255, n20 * i13 / 255, n20);
    } else r14.setClearColor(0, 0, 0, 0);
    r14.setDepthWriteEnabled(true), r14.setClearDepth(1), r14.clear(16640), r14.setDepthWriteEnabled(false);
  }
  afterRenderPhases(e17) {
    const { context: t19 } = e17;
    t19.bindFramebuffer(this._prevFBO), t19.setStencilFunction(514, Kt, 255), t19.setStencilTestEnabled(true), t19.setDepthTestEnabled(false), this.blitTexture(t19, this.getFbos().output.colorTexture, 9728);
  }
  beforeRenderLayer(e17, t19, s13) {
    const { context: r14, blendMode: i12, effects: n19, drawPhase: a12, requireFBO: o18 } = e17;
    if (r14.setClearColor(0, 0, 0, 0), o18 || C3(a12, i12, n19, s13)) {
      const e18 = r14.getBoundFramebufferObject();
      this._prevBeforeLayerFBOStack.push(e18);
      const { width: t20, height: s14 } = r14.getViewport(), i13 = this.acquireFbo(t20, s14);
      r14.bindFramebuffer(i13), r14.setColorMask(true, true, true, true), r14.setClearColor(0, 0, 0, 0), r14.setDepthWriteEnabled(true), r14.setClearDepth(1), r14.clear(16640), r14.setDepthWriteEnabled(false);
    }
    r14.setDepthWriteEnabled(false), r14.setDepthTestEnabled(false), r14.setStencilTestEnabled(true), r14.setClearStencil(t19), r14.setStencilWriteMask(255), r14.clear(1024);
  }
  afterRenderLayer(e17, t19) {
    const { context: s13, blendMode: r14, effects: i12, requireFBO: n19, drawPhase: a12 } = e17;
    if (n19 || C3(a12, r14, i12, t19)) {
      const n20 = s13.getBoundFramebufferObject();
      null != i12 && i12.length > 0 && 1 === a12 && (s13.setColorMask(true, true, true, true), this._applyEffects(e17, i12, n20)), s13.bindFramebuffer(this._prevBeforeLayerFBOStack.pop()), s13.setStencilTestEnabled(false), s13.setStencilWriteMask(0), s13.setBlendingEnabled(true), s13.setBlendFunctionSeparate(1, 771, 1, 771), s13.setColorMask(true, true, true, true);
      const o18 = null == r14 || 16 === a12 || 2 === a12 ? "normal" : r14;
      this._blendEffect.draw(e17, n20.colorTexture, 9728, o18, t19), this.releaseFbo(n20);
    }
  }
  renderObject(e17, t19, r14, i12) {
    const n19 = m6[r14];
    if (!n19) return;
    let a12 = this._brushCache.get(n19);
    void 0 === a12 && (a12 = new n19(), this._brushCache.set(n19, a12)), a12.prepareState(e17), a12.draw(e17, t19, i12);
  }
  renderObjects(e17, t19, r14, i12) {
    const n19 = m6[r14];
    if (!n19) return;
    let a12 = this._brushCache.get(n19);
    void 0 === a12 && (a12 = new n19(), this._brushCache.set(n19, a12)), a12.drawMany(e17, t19, i12);
  }
  registerRenderPass(e17) {
    const t19 = e17.brushes.map((e18) => (this._brushCache.has(e18) || this._brushCache.set(e18, new e18()), this._brushCache.get(e18)));
    return new t17(t19, e17);
  }
  blitTexture(e17, t19, s13, r14 = 1) {
    e17.setBlendingEnabled(true), e17.setBlendFunctionSeparate(1, 771, 1, 771), e17.setColorMask(true, true, true, true), this._blitRenderer.render(e17, t19, s13, r14), this._currentPipelineStateNeedsUpdate = true;
  }
  getPostProcessingEffects(e17) {
    return this._effectsManager.getPostProcessingEffects(e17);
  }
  updateFBOs(e17, t19) {
    if (e17 !== this._lastWidth || t19 !== this._lastHeight) {
      if (this._lastWidth = e17, this._lastHeight = t19, this._fbos) {
        let s14;
        for (s14 in this._fbos) this._fbos[s14].resize(e17, t19);
        return;
      }
      const s13 = new h6(e17, t19);
      s13.samplingMode = 9728, s13.wrapMode = 33071;
      const r14 = new i5(G.DEPTH24_STENCIL8, e17, t19);
      this._stencilBuf = new s5(this.context, r14), this._fbos = { output: new m4(this.context, s13, this._stencilBuf), effect0: new m4(this.context, s13, this._stencilBuf) };
    }
  }
  _applyEffects(e17, t19, s13) {
    const { context: r14 } = e17, i12 = this._effectsManager.getPostProcessingEffects(t19);
    for (const { postProcessingTechnique: n19, effect: a12 } of i12) r14.bindFramebuffer(s13), n19.render(e17, { layerFBO: s13, effect: a12 });
    this._currentPipelineStateNeedsUpdate = true;
  }
  setShader(e17) {
    return this._shaderState = { shader: e17.shader, uniforms: e17.uniforms, defines: e17.defines, optionalAttributes: e17.optionalAttributes, useComputeBuffer: e17.useComputeBuffer ?? false }, this._shaderState;
  }
  setPipelineState(e17) {
    e17 !== this._currentPipelineState && (this._currentPipelineState = e17, this._currentPipelineStateNeedsUpdate = true);
  }
  submitDraw(e17, t19, s13) {
    let r14 = s13?.stencilRef;
    if (!this._shaderState) return null;
    const { shader: i12, uniforms: n19, defines: a12, optionalAttributes: o18 } = this._shaderState, l16 = e17.context, h19 = t19.getAttributePrecisionPackFactors(), f12 = this._programCache.getProgram(i12, h19, n19, a12 ?? {}, o18 ?? {});
    if (f12.setUniforms(n19), f12.bind(l16), this.updatePipelineState(l16), null == r14) {
      const e18 = t19.getStencilReference();
      null != e18 && (r14 = e18);
    }
    return null != r14 && this.setStencilRef(l16, r14), t19.draw(e17, i12.locationInfo), f12.cleanupTemporaryTextures(), { vertexShader: f12.vertexShader, fragmentShader: f12.fragmentShader };
  }
  submitDrawMesh(e17, t19, s13, r14) {
    this.submitDrawMeshUntyped(e17, t19, s13, r14);
  }
  submitDrawMeshUntyped(e17, t19, s13, r14) {
    const i12 = r14?.parts, n19 = r14?.stencilRef, { shader: a12, uniforms: o18, defines: l16, optionalAttributes: h19 } = this.setShader(t19), f12 = this._programCache.getProgram(a12, {}, o18, l16 ?? {}, h19 ?? {});
    if (f12.setUniforms(o18), f12.bind(e17), this.updatePipelineState(e17), this.setStencilRef(e17, n19), i12) for (const c12 of i12) s13.bind(e17, t19.shader.locationInfo, c12), s13.draw(e17);
    else for (let c12 = 0; c12 < s13.parts.length; c12++) s13.bind(e17, t19.shader.locationInfo, c12), s13.draw(e17);
    s13.unbind(e17), f12.cleanupTemporaryTextures();
  }
  updatePipelineState(e17) {
    this._currentPipelineStateNeedsUpdate && (this._currentPipelineStateNeedsUpdate = false, this._updatePipelineState(e17));
  }
  _updatePipelineState(e17) {
    if (null == this._currentPipelineState) throw new Error("Pipeline state not defined. Call setPipelineState before calling submitDraw ");
    const { color: t19, depth: s13, stencil: r14 } = this._currentPipelineState;
    if (t19) {
      const { blendMode: s14, write: r15 } = t19;
      switch (e17.setColorMask(...r15), e17.setBlendingEnabled("none" !== s14), e17.setBlendEquation(32774), s14) {
        case "composite":
          e17.setBlendFunctionSeparate(1, 771, 1, 771);
          break;
        case "additive":
          e17.setBlendFunctionSeparate(1, 1, 1, 1);
          break;
        case "custom": {
          const { blendParameters: s15 } = t19, { dstAlpha: r16, dstRGB: i12, srcAlpha: n19, srcRGB: a12 } = s15;
          e17.setBlendFunctionSeparate(a12, i12, n19, r16);
          break;
        }
        case "delete":
          e17.setBlendEquation(32779), e17.setBlendFunctionSeparate(1, 771, 1, 771);
          break;
        case "none":
          e17.setBlendingEnabled(false);
      }
    } else e17.setColorMask(false, false, false, false);
    if (s13) {
      const { test: t20, write: r15 } = s13;
      r15 ? (e17.setDepthWriteEnabled(true), e17.setDepthRange(r15.zNear, r15.zFar)) : e17.setDepthWriteEnabled(false), t20 ? (e17.setDepthTestEnabled(true), e17.setDepthFunction(t20)) : e17.setDepthTestEnabled(false);
    } else e17.setDepthTestEnabled(false), e17.setDepthWriteEnabled(false);
    if (r14) {
      const { test: t20, write: s14 } = r14;
      if (t20) {
        const { op: s15 } = t20;
        e17.setStencilTestEnabled(true), e17.setStencilOpSeparate(1032, s15.fail, s15.zFail, s15.zPass);
      } else e17.setStencilTestEnabled(false);
      if (s14) {
        const { mask: t21 } = s14;
        e17.setStencilWriteMask(t21);
      } else e17.setStencilWriteMask(0);
    } else e17.setStencilTestEnabled(false), e17.setStencilWriteMask(0);
  }
  setStencilRef(e17, t19) {
    if (null == this._currentPipelineState) throw new Error("Pipeline state not defined. Call setPipelineState before calling submitDraw ");
    const { stencil: s13 } = this._currentPipelineState;
    if (s13) {
      const { test: r14 } = s13;
      if (r14) {
        const { compare: s14, mask: i12 } = r14;
        if (null == t19) throw new Error("InternalError: Stencil reference expected for target but not defined");
        e17.setStencilFunctionSeparate(1032, s14, t19, i12);
      }
    }
  }
};
function C3(e17, t19, s13, r14) {
  return 4 !== e17 && 2 !== e17 && 16 !== e17 && (1 !== r14 || null != t19 && "normal" !== t19 || null != s13 && s13.length > 0);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/TileReshuffleManager.js
var s11 = class {
  constructor() {
    this._candidateTiles = [];
  }
  schedule(s13) {
    this._candidateTiles.includes(s13) || this._candidateTiles.push(s13);
  }
  reshuffle(s13) {
    const e17 = [];
    for (const i12 of this._candidateTiles) s13 > 0 ? (i12.reshuffle(), s13--) : e17.push(i12);
    this._candidateTiles = e17;
  }
};

// node_modules/@arcgis/core/views/2d/engine/Stage.js
var P4 = 2e3;
var j4 = class extends n6 {
  constructor(t19, i12, a12) {
    super(), this.meshWriterRegistry = new x2(), this._trash = /* @__PURE__ */ new Set(), this._renderRemainingTime = 0, this._lastFrameRenderTime = 0, this._renderRequested = r3(false), this.stage = this, this._stationary = true, this._animationsEnabled = true, this._reshuffleManager = new s11(), this._managedCanvas = a12, this.context = new F3(this._managedCanvas.gl, i12.contextOptions ?? new e13()), this.painter = new P3(this.context, this), this._cimAnalyzer = new Q2(this.painter.textureManager.resourceManager), has("esri-2d-profiler") && null != t19 && (this._debugOutput = document.createElement("div"), this._debugOutput.setAttribute("style", "margin: 24px 64px; position: absolute; color: red;"), t19.appendChild(this._debugOutput));
    const o18 = () => this.highlightGradient;
    this._renderParameters = { drawPhase: 0, state: this.state, pixelRatio: window.devicePixelRatio, stationary: false, globalOpacity: 1, blendMode: null, deltaTime: -1, time: 0, inFadeTransition: false, effects: null, context: this.context, painter: this.painter, timeline: i12.timeline || new e12(), renderingOptions: i12.renderingOptions, requestRender: () => this.requestRender(), allowDelayedRender: false, requireFBO: false, profiler: new r10(this.context, this._debugOutput), dataUploadCounter: 0, get highlightGradient() {
      return o18();
    }, reshuffleManager: this._reshuffleManager, backgroundColor: i12.backgroundColor, animationsEnabled: true };
    let c12 = (e17) => this.renderFrame(e17);
    null != i12.renderFrame && (c12 = i12.renderFrame), this._taskHandle = F({ render: (e17) => c12(e17) }), this._taskHandle.pause(), this._lostWebGLContextHandle = this._managedCanvas.events.on("webgl-context-lost", (t20) => this.emit("webgl-error", { error: new s2("webgl-context-lost", t20.statusMessage) })), this._bufferPool = new a4(), x4();
  }
  destroy() {
    super.destroy(), k2(this.context), this.removeAllChildren(), this._emptyTrash(), this._taskHandle = l2(this._taskHandle), this._lostWebGLContextHandle = l2(this._lostWebGLContextHandle), this._managedCanvas.destroy(), this._debugOutput?.parentNode?.removeChild(this._debugOutput), this._bufferPool.destroy(), this.painter.dispose(), this.context.dispose(), this._managedCanvas = null;
  }
  get textureManager() {
    return this.painter.textureManager;
  }
  get profiler() {
    return this._renderParameters.profiler;
  }
  get backgroundColor() {
    return this._renderParameters.backgroundColor;
  }
  set backgroundColor(e17) {
    this._renderParameters.backgroundColor = e17, this.requestRender();
  }
  get canvas() {
    return this._managedCanvas.canvas;
  }
  get bufferPool() {
    return this._bufferPool;
  }
  get cimAnalyzer() {
    return this._cimAnalyzer;
  }
  get renderingOptions() {
    return this._renderingOptions;
  }
  set renderingOptions(e17) {
    this._renderingOptions = e17, this.requestRender();
  }
  get renderRequested() {
    return this._renderRequested.value;
  }
  get state() {
    return this._state;
  }
  set state(e17) {
    this._state = e17, this.requestRender();
  }
  get stationary() {
    return this._stationary;
  }
  set stationary(e17) {
    this._stationary !== e17 && (this._stationary = e17, this.requestRender());
  }
  get animationsEnabled() {
    return this._animationsEnabled;
  }
  set animationsEnabled(e17) {
    this._animationsEnabled !== e17 && (this._animationsEnabled = e17, this._animationsEnabled && this.requestRender());
  }
  trashDisplayObject(e17) {
    this._trash.add(e17), this.requestRender();
  }
  untrashDisplayObject(e17) {
    return this._trash.delete(e17);
  }
  requestRender() {
    this._renderRemainingTime = P4, this.renderRequested || (this._renderRequested.value = true, this._taskHandle.resume());
  }
  renderFrame(e17) {
    const t19 = this._lastFrameRenderTime ? e17.time - this._lastFrameRenderTime : 0;
    this._renderRemainingTime -= t19, this._renderRemainingTime <= 0 && this._taskHandle.pause(), this._lastFrameRenderTime = e17.time, this._renderRequested.value = false, this._renderParameters.state = this._state, this._renderParameters.stationary = this.stationary, this._renderParameters.pixelRatio = window.devicePixelRatio, this._renderParameters.globalOpacity = 1, this._renderParameters.time = e17.time, this._renderParameters.deltaTime = e17.deltaTime, this._renderParameters.effects = null, this._renderParameters.animationsEnabled = this._animationsEnabled, this.processRender(this._renderParameters), this._emptyTrash();
  }
  _createTransforms() {
    return { displayViewScreenMat3: e5() };
  }
  renderChildren(e17) {
    this._reshuffleManager.reshuffle(Bt), this._managedCanvas.render(e17, () => this._renderChildren(this.children, e17));
  }
  _renderChildren(e17, t19) {
    for (const s13 of e17) s13.beforeRender(t19);
    const r14 = this.context;
    this.painter.textureUploadManager.upload(), r14.resetInfo(), t19.profiler.recordStart("drawLayers"), t19.dataUploadCounter = 0, this.painter.beforeRenderPhases(t19, t19.backgroundColor, this.state.padding), t19.drawPhase = 1;
    for (const s13 of e17) s13.processRender(t19);
    if (this.children.some((e18) => e18.hasHighlight)) {
      t19.drawPhase = 16;
      for (const r15 of e17) r15.processRender(t19);
    }
    if (this.children.some((e18) => e18.hasLabels)) {
      t19.drawPhase = 2;
      for (const r15 of e17) r15.processRender(t19);
    }
    if (has("esri-tiles-debug")) {
      t19.drawPhase = 64;
      for (const r15 of e17) r15.processRender(t19);
    }
    this.painter.afterRenderPhases(t19), t19.profiler.recordEnd("drawLayers"), r14.logInfo();
    for (const s13 of e17) s13.afterRender(t19);
  }
  doRender(e17) {
    const t19 = this.context, { state: r14, pixelRatio: s13 } = e17;
    this._managedCanvas.resize(e17), t19.setViewport(0, 0, s13 * r14.size[0], s13 * r14.size[1]), t19.setDepthWriteEnabled(true), t19.setStencilWriteMask(255), this.renderChildren(e17);
  }
  async takeScreenshot(e17, t19, r14, s13) {
    const i12 = Math.round(this.state.size[0] * e17.resolutionScale), n19 = Math.round(this.state.size[1] * e17.resolutionScale), a12 = e17.resolutionScale, o18 = this.context, h19 = this._state.clone();
    if (null != s13) {
      const e18 = h19.viewpoint;
      h19.viewpoint.rotation = s13, h19.viewpoint = e18;
    }
    const d12 = { ...this._renderParameters, drawPhase: null, globalOpacity: 1, stationary: true, state: h19, pixelRatio: a12, time: performance.now(), deltaTime: 0, blendMode: null, effects: null, inFadeTransition: false, backgroundColor: r14 }, l16 = new h6(i12, n19);
    l16.wrapMode = 33071, l16.internalFormat = E.RGBA8, l16.isImmutable = true;
    const m11 = new m4(o18, l16, new i5(G.DEPTH24_STENCIL8, i12, n19)), u15 = o18.getBoundFramebufferObject(), c12 = o18.getViewport();
    o18.bindFramebuffer(m11), o18.setViewport(0, 0, i12, n19), this._renderChildren(t19 ?? this.children, d12);
    const p5 = this._readbackScreenshot(m11, { ...e17.cropArea, y: n19 - (e17.cropArea.y + e17.cropArea.height) });
    o18.bindFramebuffer(u15), o18.setViewport(c12.x, c12.y, c12.width, c12.height), this.requestRender();
    const g5 = await p5;
    let b6;
    return 1 === e17.outputScale ? b6 = g5 : (b6 = new ImageData(Math.round(g5.width * e17.outputScale), Math.round(g5.height * e17.outputScale)), (await import("./screenshotUtils-AX6UMZDL.js")).resampleHermite(g5, b6, true)), m11.dispose(), b6;
  }
  async _readbackScreenshot(e17, t19) {
    const r14 = (await import("./screenshotUtils-AX6UMZDL.js")).createEmptyImageData(t19.width, t19.height, document.createElement("canvas"));
    return await e17.readPixelsAsync(t19.x, t19.y, t19.width, t19.height, 6408, N2.UNSIGNED_BYTE, new Uint8Array(r14.data.buffer)), r14;
  }
  _emptyTrash() {
    for (; this._trash.size > 0; ) {
      const e17 = Array.from(this._trash);
      this._trash.clear();
      for (const t19 of e17) t19.processDetach();
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/videoScreenRenderer/VideoScreenTechnique.js
var c11 = class extends s7 {
  constructor() {
    super(...arguments), this.type = 33, this._mesh = null, this.shaders = { geometry: new v4() };
  }
  render(e17, t19) {
    const { context: s13, painter: o18 } = e17, { texture: n19, textureCoords: i12 } = t19, m11 = this._getMesh(e17), c12 = t19.ndcRect[2], a12 = t19.ndcRect[3], h19 = t19.ndcRect[0], u15 = t19.ndcRect[1], d12 = new Float32Array(180);
    for (let r14 = 0; r14 < 6; r14++) {
      const e18 = a12 * r14 / 5;
      for (let t20 = 0; t20 < 6; t20++) {
        const s14 = c12 * t20 / 5, { u: o19, v: n20 } = i12[6 * r14 + t20];
        d12[5 * (6 * r14 + t20)] = h19 + s14, d12[5 * (6 * r14 + t20) + 1] = u15 - e18, d12[5 * (6 * r14 + t20) + 2] = o19, d12[5 * (6 * r14 + t20) + 3] = n20, d12[5 * (6 * r14 + t20) + 4] = 1;
      }
    }
    m11.vertexBuffers.get("geometry")?.setData(d12);
    const p5 = { texture: { texture: n19, unit: 0 }, opacity: t19.opacity }, l16 = { shader: this.shaders.geometry, uniforms: { config: p5 }, defines: {}, optionalAttributes: null, useComputeBuffer: false };
    o18.setPipelineState(e10), o18.submitDrawMeshUntyped(s13, l16, m11);
  }
  shutdown() {
    u(this._mesh);
  }
  _getMesh(e17) {
    const { context: r14 } = e17, s13 = new Uint32Array(150);
    for (let t19 = 0; t19 < 5; t19++) for (let e18 = 0; e18 < 5; e18++) {
      const r15 = 6 * (5 * t19 + e18), o18 = 6 * (t19 + 1) + e18 + 1, n19 = o18 - 1, i12 = o18 - 6, m11 = o18 - 7;
      s13[r15] = o18, s13[r15 + 1] = n19, s13[r15 + 2] = i12, s13[r15 + 3] = n19, s13[r15 + 4] = m11, s13[r15 + 5] = i12;
    }
    return this._mesh || (this._mesh = new o7(r14, { vertex: { geometry: { data: new Float32Array(180), layout: [new t("position", 2, R.FLOAT, 0, 20), new t("texcoord", 2, R.FLOAT, 8, 20), new t("w", 1, R.FLOAT, 16, 20)] } }, index: { index: { data: s13 } }, groups: [{ primitive: _3.TRIANGLES, index: "index" }], parts: [{ group: 0, start: 0, count: s13.length }] })), this._mesh;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/VideoScreenRenderer.js
var m10 = class extends e8 {
  constructor(e17, t19) {
    super(), this._controlPointsOwner = t19, this.readbackScreenCoords = n7(), this.videoTextureCoords = new Array(36), this.overlayTextureCoords = new Array(36), this._prevFBO = null, this._acquiredFBO = null, this._isBound = false, this._hasCoordinates = false, this._geIsLoaded = false, this._ndcRect = [0, 0, 2, 2], this._technique = new c11(), this.visible = false, this.stage = e17;
    for (let r14 = 0; r14 < 6; r14++) {
      const e18 = r14 / 5;
      for (let t20 = 0; t20 < 6; t20++) {
        const o18 = t20 / 5;
        this.videoTextureCoords[6 * r14 + t20] = { u: o18, v: e18 };
      }
    }
  }
  getMesh(e17) {
    throw new Error("Method not implemented.");
  }
  destroy() {
    super.destroy(), r2(this._readbackTexture);
  }
  bind(e17) {
    const { context: t19, pixelRatio: r14, state: o18 } = e17;
    if (this._update(e17), !this.ready || 0 === this.readbackScreenCoords[2] || 0 === this.readbackScreenCoords[3]) return this.requestRender(), false;
    const { size: s13 } = o18, i12 = Math.round(r14 * s13[0]), a12 = Math.round(r14 * s13[1]), n19 = new h6(i12, a12);
    return n19.samplingMode = 9729, n19.wrapMode = 33071, this._acquiredFBO || (this._acquiredFBO = new m4(t19, n19)), this._acquiredFBO.resize(i12, a12), t19.bindFramebuffer(this._acquiredFBO), this._isBound = true, true;
  }
  unbind(e17) {
    if (!this._isBound) return;
    const { context: t19, pixelRatio: r14, state: o18 } = e17, { size: s13 } = o18, i12 = this._acquiredFBO;
    if (!i12.getColorTexture(D)) throw new Error("Failed to get color texture from FBO.");
    const a12 = this._getReadbackTexture(e17), n19 = this.readbackScreenCoords, d12 = Math.round(r14 * n19[0]), h19 = Math.round(r14 * (s13[1] - n19[1])) - a12.descriptor.height, u15 = d12 + a12.descriptor.width, l16 = h19 + a12.descriptor.height, m11 = Math.max(d12, 0), _5 = Math.max(h19, 0), x7 = Math.min(u15, i12.width) - m11, b6 = Math.min(l16, i12.height) - _5;
    x7 > 0 && b6 > 0 && i12.copyToTexture(m11, _5, x7, b6, m11 - d12, _5 - h19, a12), t19.bindFramebuffer(this._prevFBO);
  }
  _update(e17) {
    const { state: r14 } = e17, a12 = this._controlPointsOwner, n19 = a12.groundControlPoints(), c12 = a12.getSize(), d12 = r14.size, h19 = n19?.length;
    if (!h19) return;
    if (f2().then(() => {
      this._geIsLoaded = true;
    }), !this._geIsLoaded) return void this.requestRender();
    const u15 = c12[0], l16 = c12[1], m11 = d12[0], _5 = l16 / d12[1], x7 = u15 / m11;
    if (_5 > x7) {
      const e18 = x7 / _5 * 2, t19 = (2 - e18) / 2;
      this._ndcRect[0] = -1 + t19, this._ndcRect[1] = 1, this._ndcRect[2] = e18, this._ndcRect[3] = 2;
    } else {
      const e18 = _5 / x7 * 2, t19 = (2 - e18) / 2;
      this._ndcRect[0] = -1, this._ndcRect[1] = 1 - t19, this._ndcRect[2] = 2, this._ndcRect[3] = e18;
    }
    const b6 = new Array(h19), f12 = r14.spatialReference;
    for (let t19 = 0; t19 < h19; t19++) {
      const { lat: e18, lon: r15 } = n19[t19], s13 = new _2(r15, e18);
      b6[t19] = j(s13, f12);
    }
    const p5 = [];
    let M6 = 1 / 0, g5 = 1 / 0, w4 = -1 / 0, C4 = -1 / 0;
    for (const o18 of b6) {
      const e18 = n2();
      r14.toScreen(e18, o18.x, o18.y), p5.push({ x: e18[0], y: e18[1] }), M6 = Math.min(M6, e18[0]), g5 = Math.min(g5, e18[1]), w4 = Math.max(w4, e18[0]), C4 = Math.max(C4, e18[1]);
    }
    const R5 = [M6, C4], T4 = [w4, g5];
    this.readbackScreenCoords[0] = Math.max(Math.floor(R5[0]), 0), this.readbackScreenCoords[1] = Math.max(Math.floor(T4[1]), 0), this.readbackScreenCoords[2] = Math.ceil(T4[0]), this.readbackScreenCoords[3] = Math.ceil(R5[1]);
    for (let t19 = 0; t19 < p5.length; t19++) {
      const e18 = p5[t19], r15 = (e18.x - M6) / (w4 - M6), o18 = (C4 - e18.y) / (C4 - g5);
      this.overlayTextureCoords[t19] = { u: r15, v: o18 };
    }
    this._hasCoordinates = true;
  }
  _createTransforms() {
    return null;
  }
  doRender(e17) {
    this._readbackTexture && this._hasCoordinates ? this._technique.render(e17, { texture: this._readbackTexture, textureCoords: this.overlayTextureCoords, opacity: 1, ndcRect: this._ndcRect }) : this.requestRender();
  }
  _getReadbackTexture(e17) {
    const { context: t19, pixelRatio: r14 } = e17, o18 = Math.round(r14 * Math.abs(this.readbackScreenCoords[2] - this.readbackScreenCoords[0])), s13 = Math.round(r14 * Math.abs(this.readbackScreenCoords[3] - this.readbackScreenCoords[1]));
    if (this._readbackTexture) this._readbackTexture.resize(o18, s13);
    else {
      const e18 = new h6(o18, s13);
      e18.wrapMode = 33071, e18.internalFormat = E.RGBA8, this._readbackTexture = new A3(t19, e18);
    }
    return this._readbackTexture;
  }
};

// node_modules/@arcgis/core/views/2d/engine/ParentChildStage.js
var n17 = class extends j4 {
  constructor(e17, s13, n19) {
    super(null, s13 = { ...s13, renderFrame: (e18) => {
    } }, new c4(null, { canvas: e17 })), this._requestRender = n19, this.viewIsReady = false, this.videoScreenRenderer = new m10(this, s13), this.videoScreenRenderer.visible = true;
  }
  requestRender() {
    this._requestRender();
  }
  processRender(r14) {
    this.videoScreenRenderer.bind(r14), r14.backgroundColor = u5.fromArray([0, 0, 0, 0]), super.processRender(r14), this.videoScreenRenderer.unbind(r14);
  }
};
var i11 = class extends j4 {
  constructor(e17, r14, s13) {
    super(e17, r14 = { ...r14, renderFrame: (e18) => {
      this.render(e18);
    } }, s13), this._childStage = new n17(s13.canvas, r14, () => this.requestRender());
  }
  get childStage() {
    return this._childStage;
  }
  render(e17) {
    this._childStage.viewIsReady ? (this._childStage.context.enforceState(), this._childStage.renderFrame(e17)) : this.requestRender(), this.context.enforceState(), super.renderFrame(e17);
  }
  processRender(e17) {
    super.processRender(e17), this._childStage.viewIsReady && this._childStage.visible && this._childStage.videoScreenRenderer.processRender(e17);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/magnifier/MagnifierTechnique.js
var n18 = class extends s7 {
  constructor() {
    super(...arguments), this.type = 20, this._resourcePixelRatio = 1, this._position = [0, 0, 0, 0], this.shaders = { magnifier: new P() };
  }
  updateResources(t19, i12, r14, s13) {
    t19.pixelRatio !== this._resourcePixelRatio && this._destroyResources(), this._readbackTexture || this._initializeResources(t19, i12, r14, s13);
    const { context: o18, pixelRatio: a12 } = t19, { factor: u15, offset: n19, position: l16 } = s13, { size: h19 } = t19.state, c12 = s13.size * a12, p5 = 1 / u15, x7 = Math.ceil(p5 * c12);
    this._readbackTexture.resize(x7, x7);
    const m11 = a12 * h19[0], d12 = a12 * h19[1], _5 = 0.5 * x7, T4 = 0.5 * x7, f12 = r4(a12 * l16.x, _5, m11 - _5 - 1), b6 = r4(d12 - a12 * l16.y, T4, d12 - T4 - 1), g5 = f12 - _5, y4 = b6 - T4, k5 = this._readbackTexture;
    o18.bindTexture(k5, 0), o18.gl.copyTexImage2D(k5.descriptor.target, 0, k5.descriptor.pixelFormat, g5, y4, x7, x7, 0);
    const w4 = (f12 + n19.x * a12) / m11 * 2 - 1, R5 = (b6 - n19.y * a12) / d12 * 2 - 1, M6 = c12 / m11 * 2, j5 = c12 / d12 * 2;
    this._position[0] = w4, this._position[1] = R5, this._position[2] = M6, this._position[3] = j5;
  }
  render(e17, t19) {
    const { context: i12, painter: s13 } = e17;
    s13.setPipelineState(e10);
    const o18 = { readbackTexture: { texture: this._readbackTexture, unit: 0 }, maskTexture: { texture: this._maskTexture, unit: 7 }, overlayTexture: { texture: this._overlayTexture, unit: 6 }, drawPos: this._position, ...t19 };
    s13.submitDrawMesh(i12, { shader: this.shaders.magnifier, uniforms: { config: o18 }, defines: null, optionalAttributes: null, useComputeBuffer: false }, s13.quadMesh);
  }
  shutdown() {
    this._destroyResources();
  }
  _initializeResources(e17, t19, r14, s13) {
    const o18 = e17.context;
    this._resourcePixelRatio = e17.pixelRatio;
    const n19 = Math.ceil(s13.size * e17.pixelRatio);
    r14.width = n19, r14.height = n19;
    const l16 = new h6(Math.ceil(n19 / s13.factor));
    l16.internalFormat = 6408, l16.wrapMode = 33071, l16.samplingMode = 9728, l16.flipped = true, l16.preMultiplyAlpha = !kt(r14.src) || !e17.context.driverTest.svgPremultipliesAlpha.result, this._overlayTexture = new A3(o18, l16, r14), t19.width = n19, t19.height = n19, l16.pixelFormat = l16.internalFormat = 6406, this._maskTexture = new A3(o18, l16, t19), l16.pixelFormat = l16.internalFormat = 6408, l16.samplingMode = 9729, l16.flipped = false, this._readbackTexture = new A3(o18, l16);
  }
  _destroyResources() {
    r2(this._maskTexture), r2(this._overlayTexture), r2(this._readbackTexture), this._maskTexture = null, this._overlayTexture = null, this._readbackTexture = null;
  }
};

// node_modules/@arcgis/core/views/magnifier/resources.js
async function s12(s13) {
  const r14 = import("./mask-svg-UHW4L2K6.js"), i12 = import("./overlay-svg-GQXT4U3Q.js"), o18 = t5((await r14).default, { signal: s13 }), e17 = t5((await i12).default, { signal: s13 }), m11 = { mask: await o18, overlay: await e17 };
  return s3(s13), m11;
}

// node_modules/@arcgis/core/views/2d/magnifier/MagnifierView2D.js
var d11 = class extends e8 {
  constructor() {
    super(), this._handles = new r(), this._magnifierTechnique = new n18(), this.updatingHandles = new h4(), this.visible = false;
  }
  destroy() {
    super.destroy(), this._handles = u(this._handles), this._magnifierTechnique.shutdown(), this._resourcesTask = e(this._resourcesTask);
  }
  get backgroundColor() {
    return this._backgroundColor;
  }
  set backgroundColor(e17) {
    this._backgroundColor = e17, this.requestRender();
  }
  get magnifier() {
    return this._magnifier;
  }
  set magnifier(e17) {
    this._magnifier = e17, this._handles.removeAll(), this._handles.add([l3(() => e17.version, () => {
      this.visible = e17.visible && null != e17.position && e17.size > 0, this.requestRender();
    }, h2), l3(() => [e17.maskUrl, e17.overlayUrl], () => this._reloadResources()), l3(() => e17.size, () => {
      this._magnifierTechnique.shutdown(), this.requestRender();
    })]);
  }
  _createTransforms() {
    return { displayViewScreenMat3: e5() };
  }
  doRender(e17) {
    if (!this._resourcesTask) return void this._reloadResources();
    if (1 !== e17.drawPhase || !this._canRender()) return;
    const s13 = this._magnifier;
    if (null == s13.position) return;
    this._magnifierTechnique.updateResources(e17, this._mask, this._overlay, s13);
    const r14 = this.backgroundColor, i12 = r14 ? [r14.a * r14.r / 255, r14.a * r14.g / 255, r14.a * r14.b / 255, r14.a] : [1, 1, 1, 1];
    this._magnifierTechnique.render(e17, { background: i12, maskEnabled: s13.maskEnabled ? 1 : 0, overlayEnabled: s13.overlayEnabled ? 1 : 0 });
  }
  _canRender() {
    return this._mask && this._overlay && null != this._magnifier;
  }
  _reloadResources() {
    this._resourcesTask && this._resourcesTask.abort();
    const r14 = null != this._magnifier ? this._magnifier.maskUrl : null, i12 = null != this._magnifier ? this._magnifier.overlayUrl : null;
    this._resourcesTask = d2(async (s13) => {
      const t19 = null == r14 || null == i12 ? s12(s13) : null, n19 = null != r14 ? H(r14, { responseType: "image", signal: s13 }).then((e17) => e17.data) : t19.then((e17) => e17.mask), a12 = null != i12 ? H(i12, { responseType: "image", signal: s13 }).then((e17) => e17.data) : t19.then((e17) => e17.overlay), [o18, l16] = await Promise.all([n19, a12]);
      this._mask = o18, this._overlay = l16, this._magnifierTechnique.shutdown(), this.requestRender();
    }), this.updatingHandles.addPromise(this._resourcesTask.promise);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/grid/GridTechnique.js
var t18 = class extends s7 {
  constructor() {
    super(...arguments), this.type = 16, this.shaders = { grid: new q() };
  }
  render(s13, r14) {
    const { context: t19, painter: i12 } = s13;
    i12.setPipelineState(e10), i12.submitDrawMesh(t19, { shader: this.shaders.grid, uniforms: r14, defines: null, optionalAttributes: null, useComputeBuffer: false }, i12.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/grid/GridView2D.js
var x6 = n2();
var P5 = class extends e8 {
  constructor() {
    super(), this._handles = new r(), this._projectedCenter = null, this._metersPerSRUnit = null, this._technique = new t18(), this._grid = null, this.visible = true;
  }
  destroy() {
    super.destroy(), this._handles = u(this._handles), this._technique.shutdown();
  }
  get grid() {
    return this._grid;
  }
  set grid(e17) {
    this._grid = e17, this._handles.removeAll(), this._handles.add([l3(() => e17?.center, () => {
      this._projectedCenter = null;
    }, h2), l3(() => [e17?.center, e17?.dynamicScaling, e17?.majorLineColor, e17?.majorLineInterval, e17?.minorLineColor, e17?.rotateWithMap, e17?.rotation, e17?.spacing, e17?.units], () => this.requestRender(), h2)]);
  }
  _createTransforms() {
    return { displayViewScreenMat3: e5() };
  }
  doRender(e17) {
    if (1 !== e17.drawPhase || null == this.grid || !this.visible) return;
    const { spacing: t19, units: r14, majorLineInterval: i12, dynamicScaling: s13, majorLineColor: o18, minorLineColor: a12 } = this.grid;
    if (0 === t19) return;
    if (this._updateDerivedValues(e17), null == this._projectedCenter || null == this._metersPerSRUnit) return;
    const { scale: l16, spatialReference: m11 } = e17.state, c12 = N(t19, r14, "meters"), h19 = this._metersPerSRUnit * u7(l16, m11), p5 = c12 / h19;
    if (!s13 && p5 < t9) return;
    const d12 = c12 * l9(i12, p5, s13);
    this._updateTransform(e17, h19, d12), this._technique.render(e17, { transform: { dvs: this.transforms.displayViewScreenMat3 }, config: { pxPerCell: d12 / h19, minorLineColor: M5(a12), majorLineColor: M5(o18), majorLineInterval: i12, halfWidth: 0.25, aaWidth: 0.5 } });
  }
  _updateDerivedValues(e17) {
    if (!this.grid) return;
    const { center: t19 } = this.grid, { spatialReference: r14 } = e17.state;
    this._projectedCenter && T(this._projectedCenter.spatialReference, r14) || (this._metersPerSRUnit = null, T(t19.spatialReference, r14) ? this._projectedCenter = t19 : b2(t19.spatialReference, r14) ? this._projectedCenter = W(t19, r14) : this.requestRender()), null == this._metersPerSRUnit && null != this._projectedCenter && (this._metersPerSRUnit = u9(this._projectedCenter));
  }
  _updateTransform(e17, r14, i12) {
    const { grid: s13 } = this, { center: n19, rotation: c12, size: j5, spatialReference: _5 } = e17.state;
    if (null == s13 || null == this._projectedCenter || null == this._metersPerSRUnit) return;
    const g5 = r14 * (j5[0] / 2), R5 = r14 * (j5[1] / 2), U4 = this._metersPerSRUnit / i12, v7 = this._projectedCenter, y4 = s4(s13.rotation), S2 = s4(c12), b6 = this.transforms.displayViewScreenMat3;
    m2(b6, -y4);
    const L5 = _5.isWrappable ? L(v7.x, n19[0], _5) : v7.x, P6 = o(x6, L5, v7.y), M6 = B(x6, n19, P6);
    l4(M6, M6, U4), s13.rotateWithMap || I(M6, M6, a2, -S2), I(M6, M6, a2, -y4), l4(M6, M6, 1 / s13.majorLineInterval), w3(M6, M6), l4(M6, M6, s13.majorLineInterval), I(M6, M6, a2, y4), M(b6, b6, M6), s13.rotateWithMap && h3(b6, b6, S2);
    const q3 = o(x6, g5 / i12, R5 / i12);
    b(b6, b6, q3);
  }
};
function w3(e17, t19) {
  return e17[0] = t19[0] - Math.trunc(t19[0]), e17[1] = t19[1] - Math.trunc(t19[1]), e17;
}
function M5(e17) {
  const [t19, r14, i12, s13] = e17.toArray().map((e18) => e18 / 255);
  return [t19 * s13, r14 * s13, i12 * s13, s13];
}
export {
  n17 as ChildStage,
  i6 as GraphicContainer,
  O as GraphicsView2D,
  P5 as GridView2D,
  l8 as LabelManager,
  d11 as MagnifierView2D,
  y2 as MapViewNavigation,
  i11 as ParentStage,
  j4 as Stage
};
//# sourceMappingURL=mapViewDeps-4XLRGU2Z.js.map
