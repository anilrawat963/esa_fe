import {
  i as i2,
  o
} from "./chunk-UTZXKPS3.js";
import "./chunk-5XYRAKJX.js";
import "./chunk-Y2DYCFJT.js";
import "./chunk-HUA6ZZZG.js";
import "./chunk-TNKZDDMZ.js";
import "./chunk-OL6EYE44.js";
import {
  h as h3,
  y as y2
} from "./chunk-36YQJD5W.js";
import "./chunk-BQ6DEXWK.js";
import "./chunk-3SCRAN3E.js";
import "./chunk-NTNXXNRP.js";
import {
  A as A2
} from "./chunk-BTFBYI67.js";
import "./chunk-D3G5WIRR.js";
import "./chunk-Q3JOE7TC.js";
import {
  P as P2,
  t
} from "./chunk-GD72EK2J.js";
import "./chunk-ALKEERWI.js";
import "./chunk-U6CJFTOF.js";
import {
  a as a3
} from "./chunk-4V63WUXV.js";
import "./chunk-2JMKFI2D.js";
import "./chunk-QYAMBIRP.js";
import "./chunk-YE4E5JCT.js";
import "./chunk-SXZO7ULH.js";
import "./chunk-JHV6OBEB.js";
import {
  i,
  n,
  r
} from "./chunk-RNW3VGJP.js";
import {
  f
} from "./chunk-5DFXT3PU.js";
import "./chunk-CKE7BUXC.js";
import "./chunk-B5SL7XHP.js";
import {
  W as W2
} from "./chunk-3VXANCFN.js";
import "./chunk-MBQEPUQX.js";
import "./chunk-ODQ5APZK.js";
import "./chunk-G5IXTUNN.js";
import "./chunk-ZNQKJRCD.js";
import "./chunk-BA6HYZ35.js";
import "./chunk-GCTH5LET.js";
import "./chunk-Q7VRQYAO.js";
import "./chunk-SJB744AD.js";
import "./chunk-WM2VG5F2.js";
import "./chunk-IXFJYDA2.js";
import "./chunk-TTLSEJNG.js";
import "./chunk-U73R3I4U.js";
import "./chunk-VGXUPJSS.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import "./chunk-DLM5SBNY.js";
import "./chunk-EKZRA6TO.js";
import "./chunk-M5SP6ZBM.js";
import "./chunk-FAA2FDN5.js";
import {
  Z
} from "./chunk-2HGIYEIL.js";
import {
  ut
} from "./chunk-XX3OKYJS.js";
import "./chunk-OTCNIJ2H.js";
import {
  s as s2
} from "./chunk-JGA5YJWL.js";
import "./chunk-GCI4MA3M.js";
import "./chunk-SJ2OBYX2.js";
import "./chunk-MDJNYPVI.js";
import "./chunk-Z6VKIQV2.js";
import "./chunk-4PXNA4MD.js";
import "./chunk-4VQDBNTM.js";
import "./chunk-3BNOOWTA.js";
import "./chunk-AIJLLSRB.js";
import "./chunk-VX2NEBRT.js";
import "./chunk-7HTU7ZUX.js";
import "./chunk-WDTGOP77.js";
import "./chunk-VYMBX5H5.js";
import {
  h as h2
} from "./chunk-BPTFV5VM.js";
import "./chunk-647DAMHU.js";
import "./chunk-O6G3PPOK.js";
import "./chunk-ZKNZTIAS.js";
import "./chunk-OJMISN3F.js";
import "./chunk-EFV6H5NA.js";
import {
  f as f2
} from "./chunk-XDLV73DB.js";
import "./chunk-ARTU4L55.js";
import "./chunk-6VL5D5UP.js";
import "./chunk-6QHY54HZ.js";
import "./chunk-GXJJY3ND.js";
import "./chunk-5ONGWFJ3.js";
import "./chunk-PLNHHGHL.js";
import "./chunk-DFK6QMLO.js";
import "./chunk-BBYMM7CM.js";
import "./chunk-EM7Y2JZC.js";
import "./chunk-QZQPB5XR.js";
import "./chunk-AQFRVV3U.js";
import "./chunk-Q5KWD3VQ.js";
import "./chunk-BUQC3CLV.js";
import "./chunk-XTZAIV4X.js";
import "./chunk-63LDVRFI.js";
import "./chunk-23NJHA5Q.js";
import "./chunk-4LA6K4VI.js";
import "./chunk-KEZCWFAR.js";
import "./chunk-JZUJ34RR.js";
import {
  y
} from "./chunk-PMGS7UDU.js";
import "./chunk-3GHCGAH2.js";
import "./chunk-HWUOAPTX.js";
import "./chunk-QHCKOBU7.js";
import "./chunk-K2OZ6WVC.js";
import "./chunk-MC6NAKKX.js";
import "./chunk-TF6255HN.js";
import "./chunk-GD4FJL3C.js";
import "./chunk-C5OQVQZF.js";
import "./chunk-F7DKSAOI.js";
import "./chunk-4SOQWNPG.js";
import "./chunk-LTULADK2.js";
import "./chunk-35ST7YRB.js";
import "./chunk-EDA5QFHZ.js";
import {
  d
} from "./chunk-XL5QPCXN.js";
import {
  J,
  N,
  W
} from "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-C5M24ACM.js";
import "./chunk-L4A2QJG4.js";
import "./chunk-ENINOZUZ.js";
import "./chunk-MHV23XAQ.js";
import "./chunk-V2X4OKYI.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import "./chunk-MA3QDRC3.js";
import "./chunk-W6J7XCPU.js";
import "./chunk-T7F6Q6JJ.js";
import "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-7P2ANHQ3.js";
import "./chunk-XCKT47LJ.js";
import "./chunk-3FUHCAX3.js";
import {
  P
} from "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import {
  a as a2,
  h,
  l
} from "./chunk-2OFHDVO5.js";
import "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-5UPBUJPC.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-CCQFL76O.js";
import "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import "./chunk-7H3U4IJR.js";
import "./chunk-SMWUT52Z.js";
import "./chunk-AXZMNHTN.js";
import "./chunk-5T3MJDSR.js";
import "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import {
  b,
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import {
  A,
  p,
  s
} from "./chunk-GNMPGHLQ.js";
import "./chunk-QY7XKUIV.js";
import {
  j
} from "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/GraphicsSnappingSource.js
var x = "graphics-collections";
var z = class extends b {
  get updating() {
    return this._updatingHandles.updating;
  }
  get _hasZ() {
    const e = this.view;
    return null != e && "3d" === e.type && "map-notes" !== this.layerSource.layer.type;
  }
  get _snappingElevationAligner() {
    const { view: e } = this, { layer: t2 } = this.layerSource, o2 = null != e && "3d" === e.type;
    if (!o2 || "map-notes" === t2.type) return i();
    const r2 = async (o3, r3) => (await p(e.whenLayerView(t2), r3)).elevationAlignPointsInFeatures(o3, r3);
    return i(o2, { elevationInfo: t2.elevationInfo, alignPointsInFeatures: r2 });
  }
  get _snappingElevationFilter() {
    const { view: e } = this, t2 = null != e && "3d" === e.type && "map-notes" !== this.layerSource.layer.type;
    return r(t2);
  }
  get _symbologySnappingFetcher() {
    const { view: e } = this, { layer: t2 } = this.layerSource, o2 = null != e && "3d" === e.type, r2 = this._extrudedPolygonSymbolsCount > 0;
    return o2 && "map-notes" !== t2.type && r2 ? n(r2, async (o3, r3) => {
      const s3 = await e.whenLayerView(t2);
      return s(r3), s3.queryForSymbologySnapping({ candidates: o3, spatialReference: e.spatialReference }, r3);
    }) : n();
  }
  constructor(e) {
    super(e), this.availability = 1, this._sources = { multipoint: null, point: null, polygon: null, polyline: null }, this._loadedWkids = /* @__PURE__ */ new Set(), this._loadedWkts = /* @__PURE__ */ new Set(), this._pendingAdds = [], this._extrudedPolygonSymbolsCount = 0, this._updatingHandles = new h2(), this._memoizedMakeGetGroundElevation = t(i2);
  }
  destroy() {
    for (const e of this._pendingAdds) e.task.abort();
    this._pendingAdds.length = 0, this._mapSources((e) => this._destroySource(e)), this._updatingHandles.destroy();
  }
  initialize() {
    this._updatingHandles.add(() => this.getGraphicsLayers(), (e2) => {
      this._updatingHandles.removeHandles(x);
      for (const t3 of e2) this._addMany(t3.graphics.toArray()), this.addHandles([t3.on("graphic-update", (e3) => this._onGraphicUpdate(e3)), this._updatingHandles.addOnCollectionChange(() => t3.graphics, (e3) => this._onGraphicsChanged(e3))], x);
    }, h);
    const { view: e } = this, { layer: t2 } = this.layerSource;
    null != e && "3d" === e.type && "map-notes" !== t2.type && e.elevationProvider && this.addHandles([e.elevationProvider.on("elevation-change", ({ context: e2 }) => {
      P2(e2, t2.elevationInfo) && this._snappingElevationAligner.notifyElevationSourceChange();
    }), l(() => t2.elevationInfo, () => this._snappingElevationAligner.notifyElevationSourceChange(), h), a2(() => t2, ["edits", "apply-edits", "graphic-update"], () => this._symbologySnappingFetcher.notifySymbologyChange())]);
  }
  async fetchCandidates(e, t2) {
    const { point: o2, coordinateHelper: { spatialReference: r2 } } = e, s3 = await A(this._mapSources((o3) => this._fetchCandidatesForSource(o3, e, t2)));
    s(t2);
    const a4 = this._memoizedMakeGetGroundElevation(this.view, r2), p2 = s3.flat().map((e2) => o(e2, a4));
    return y2(o2, p2), p2;
  }
  async _fetchCandidatesForSource(e, t2, o2) {
    const r2 = h3({ parameters: t2, mode: this.view?.type ?? "2d" }), s3 = await e.queryEngine.executeQueryForSnapping(r2, o2);
    s(o2);
    const n2 = await this._snappingElevationAligner.alignCandidates(s3.candidates, t2.coordinateHelper.spatialReference, o2);
    s(o2);
    const a4 = await this._symbologySnappingFetcher.fetch(n2, o2);
    s(o2);
    const p2 = 0 === a4.length ? n2 : [...n2, ...a4];
    return this._snappingElevationFilter.filter(r2, p2);
  }
  refresh() {
  }
  _onGraphicUpdate(e) {
    if (this.getGraphicsLayers().some((t2) => t2.graphics.includes(e.graphic))) switch (e.property) {
      case "geometry":
      case "visible":
        this._remove(e.graphic), this._addMany([e.graphic]);
    }
  }
  _onGraphicsChanged(e) {
    for (const t2 of e.removed) this._remove(t2);
    this._addMany(e.added);
  }
  _addMany(e) {
    const t2 = [], o2 = /* @__PURE__ */ new Map();
    for (const r2 of e) null != r2.geometry && (this._needsInitializeProjection(r2.geometry.spatialReference) ? (t2.push(r2.geometry.spatialReference), o2.set(r2.uid, r2)) : this._add(r2));
    this._createPendingAdd(t2, o2);
  }
  _createPendingAdd(e, t2) {
    if (!e.length) return;
    const s3 = d(async (o2) => {
      await N(e.map((e2) => ({ source: e2, dest: this.spatialReference })), { signal: o2 }), this._markLoadedSpatialReferences(e);
      for (const e2 of t2.values()) this._add(e2);
    });
    this._updatingHandles.addPromise(s3.promise);
    const i3 = { task: s3, graphics: t2 }, n2 = () => j(this._pendingAdds, i3);
    s3.promise.then(n2, n2), this._pendingAdds.push(i3);
  }
  _markLoadedSpatialReferences(e) {
    for (const t2 of e) {
      null != t2.wkid && this._loadedWkids.add(t2.wkid);
      const e2 = t2.wkt2 || t2.wkt;
      e2 && this._loadedWkts.add(e2);
    }
  }
  _add(e) {
    if (null == e.geometry || !e.visible) return;
    let t2 = e.geometry;
    if ("mesh" === t2.type) return;
    "extent" === t2.type && (t2 = P.fromExtent(t2));
    const o2 = this._ensureSource(t2.type);
    if (null == o2) return;
    const r2 = this._createOptimizedFeature(e.uid, t2);
    null != r2 && (o2.featureStore.add(r2), A2(e.symbol) && this._extrudedPolygonSymbolsCount++);
  }
  _needsInitializeProjection(e) {
    if (null != e.wkid && this._loadedWkids.has(e.wkid)) return false;
    const t2 = e.wkt2 || e.wkt;
    return (!t2 || !this._loadedWkts.has(t2)) && !J(e, this.spatialReference);
  }
  _createOptimizedFeature(e, t2) {
    const o2 = W(a3(t2), this.spatialReference);
    if (!o2) return null;
    const r2 = this._ensureGeometryHasZ(o2), s3 = ut(r2, this._hasZ, false);
    return new s2(s3, { [O]: e }, null, e);
  }
  _ensureGeometryHasZ(e) {
    if (!this._hasZ) return e;
    const t2 = (e2) => {
      for (; e2.length < 3; ) e2.push(0);
    }, o2 = e.clone();
    switch (o2.hasZ = true, o2.type) {
      case "point":
        o2.z = o2.z ?? 0;
        break;
      case "multipoint":
        o2.points.forEach(t2);
        break;
      case "polyline":
        o2.paths.forEach((e2) => e2.forEach(t2));
        break;
      case "polygon":
        o2.rings.forEach((e2) => e2.forEach(t2));
    }
    return o2;
  }
  _ensureSource(e) {
    const t2 = this._sources[e];
    if (null != t2) return t2;
    const o2 = this._createSource(e);
    return this._sources[e] = o2, o2;
  }
  _createSource(e) {
    const t2 = y.toJSON(e), o2 = this._hasZ, r2 = new f({ geometryType: t2, hasZ: o2, hasM: false });
    return { featureStore: r2, queryEngine: new W2({ featureStore: r2, fieldsIndex: Z.fromLayerJSON({ fields: [{ name: O, type: "esriFieldTypeOID", alias: O }] }), geometryType: t2, hasM: false, hasZ: o2, featureIdInfo: { type: "object-id", fieldName: O }, spatialReference: this.spatialReference, priority: f2.SNAPPING, scheduler: null != this.view && "3d" === this.view.type ? this.view.resourceController.scheduler : null }), type: e };
  }
  _remove(e) {
    this._mapSources((t2) => this._removeFromSource(t2, e));
    for (const t2 of this._pendingAdds) t2.graphics.delete(e.uid), 0 === t2.graphics.size && t2.task.abort();
  }
  _removeFromSource(e, t2) {
    const o2 = t2.uid;
    e.featureStore.has(o2) && (e.featureStore.removeById(t2.uid), A2(t2.symbol) && this._extrudedPolygonSymbolsCount--);
  }
  _destroySource(e) {
    e.queryEngine.destroy(), this._sources[e.type] = null;
  }
  _mapSources(e) {
    const { point: t2, polygon: o2, polyline: r2, multipoint: s3 } = this._sources, i3 = [];
    return null != t2 && i3.push(e(t2)), null != o2 && i3.push(e(o2)), null != r2 && i3.push(e(r2)), null != s3 && i3.push(e(s3)), i3;
  }
};
__decorate([m()], z.prototype, "getGraphicsLayers", void 0), __decorate([m({ constructOnly: true })], z.prototype, "layerSource", void 0), __decorate([m({ constructOnly: true })], z.prototype, "spatialReference", void 0), __decorate([m({ constructOnly: true })], z.prototype, "view", void 0), __decorate([m({ readOnly: true })], z.prototype, "updating", null), __decorate([m({ readOnly: true })], z.prototype, "availability", void 0), __decorate([m()], z.prototype, "_hasZ", null), __decorate([m()], z.prototype, "_snappingElevationAligner", null), __decorate([m()], z.prototype, "_snappingElevationFilter", null), __decorate([m()], z.prototype, "_symbologySnappingFetcher", null), __decorate([m()], z.prototype, "_extrudedPolygonSymbolsCount", void 0), z = __decorate([a("esri.views.interactive.snapping.featureSources.GraphicsSnappingSource")], z);
var O = "OBJECTID";
export {
  z as GraphicsSnappingSource
};
//# sourceMappingURL=GraphicsSnappingSource-RVDCOC25.js.map
