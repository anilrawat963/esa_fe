import {
  s,
  t
} from "./chunk-WJ5RYEGC.js";
import {
  x as x3
} from "./chunk-7TAAMEZT.js";
import {
  e
} from "./chunk-4POFO7MP.js";
import {
  n as n3
} from "./chunk-257FD5T2.js";
import {
  $,
  $s,
  $t,
  A,
  A2,
  As,
  B,
  B2,
  Bs,
  Bt,
  C,
  Ct,
  D,
  D2,
  Ds,
  Dt,
  Et,
  F,
  Ft,
  G,
  G2,
  Gs,
  Gt,
  H,
  Hs,
  Ht,
  I,
  I2,
  It,
  J,
  Js,
  Jt,
  K,
  Kt,
  L,
  L2,
  Ls,
  Lt,
  N,
  O,
  Os,
  Ot,
  P,
  P2,
  Ps,
  Pt,
  Q,
  Qs,
  Qt,
  R,
  R2,
  Rt,
  S,
  Ss,
  St,
  T,
  U,
  U2,
  Us,
  Ut,
  V,
  Vs,
  Vt,
  Ws,
  Wt,
  Xs,
  Xt,
  Y,
  Ys,
  Yt,
  Zs,
  Zt,
  _s,
  _t,
  a,
  ai,
  b,
  bs,
  cs,
  ct,
  ds,
  ei,
  f,
  fs,
  ft,
  g,
  gt,
  h,
  hi,
  ii,
  j,
  j2,
  js,
  jt,
  k,
  k2,
  kt,
  l,
  ls,
  m,
  mi,
  n,
  n2,
  ni,
  oi,
  p,
  p2,
  qs,
  qt,
  rs,
  si,
  st,
  v,
  vs,
  vt,
  w,
  w2,
  wt,
  x,
  x2,
  y,
  z,
  z2,
  zs,
  zt
} from "./chunk-ZNI54T6D.js";
import {
  __addDisposableResource,
  __disposeResources
} from "./chunk-SS5CLIUY.js";

// node_modules/@arcgis/core/chunks/Envelope.js
var C2 = [0, 0, Number.NaN, 0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 0];
var T2 = [2, 1, 1, 1, 3, 1, 2, 3, 2, 4, 1, 1, 2, 1];
var R3 = [1, 1, 1, 0, 2, 1, 1, 1, 0, 0, 0, 0, 0, 1];
var A3 = [1, 1, 1, 2, 0, 0, 0, 0, 2, 2, 4, 2, 2, 1];
var q = [4, 8, 4, 8, 1];
var w3 = 25;
function B3() {
  return Yt(w3, Number.NaN);
}
var z3 = class s2 {
  getAttributeCount() {
    return this.m_attributeCount;
  }
  getSemantics(t3) {
    return this.m_indexToSemantics[t3];
  }
  getSemanticsBitArray() {
    return this.m_semanticsBitArray;
  }
  getAttributeIndex(t3) {
    return this.m_semanticsToIndexMap[t3];
  }
  static getInterpolation(t3) {
    return R3[t3];
  }
  static getPersistence(t3) {
    return A3[t3];
  }
  static getPersistenceSize(t3) {
    return q[t3];
  }
  static getPersistenceSizeFromSemantics(t3) {
    return s2.getPersistenceSize(s2.getPersistence(t3)) * s2.getComponentCount(t3);
  }
  static getComponentCount(t3) {
    return T2[t3];
  }
  static maxComponentCount() {
    return 4;
  }
  static isInteger(t3) {
    return 2 === t3 || 3 === t3 || 4 === t3;
  }
  static isIntegerSemantics(t3) {
    return s2.isInteger(s2.getPersistence(t3));
  }
  static isTexture(t3) {
    return 5 === t3 || 6 === t3 || 7 === t3;
  }
  hasAttribute(t3) {
    return !!(this.m_semanticsBitArray & 1 << t3);
  }
  hasAttributesFrom(t3) {
    return (this.m_semanticsBitArray & t3.m_semanticsBitArray) === t3.m_semanticsBitArray;
  }
  hasZ() {
    return this.hasAttribute(1);
  }
  hasM() {
    return this.hasAttribute(2);
  }
  hasID() {
    return this.hasAttribute(3);
  }
  getTotalComponentCount() {
    return this.m_totalComponentCount;
  }
  static getDefaultValue(t3) {
    return C2[t3];
  }
  static isDefaultValue(e2, s3) {
    return ls(C2[e2], s3);
  }
  equals(t3) {
    return this === t3;
  }
  getDefaultPointAttributes() {
    return this.m_defaultPointAttributes;
  }
  getPointAttributeOffset(t3) {
    return this.m_pointAttributeOffsets[t3];
  }
  constructor(t3) {
    this.m_semanticsBitArray = t3, this.m_attributeCount = 0, this.m_totalComponentCount = 0, this.m_semanticsToIndexMap = new Int32Array(14), this.m_indexToSemantics = new Int32Array(14), this.m_pointAttributeOffsets = new Int32Array(14), this.m_defaultPointAttributes = Yt(w3, Number.NaN), this.m_semanticsToIndexMap.fill(-1), this.m_indexToSemantics.fill(-1);
    let i2 = 0, n5 = 1, r = 14;
    for (; i2 < r; i2++) t3 & n5 && (this.m_semanticsToIndexMap[i2] = this.m_attributeCount, this.m_indexToSemantics[this.m_attributeCount] = i2, this.m_attributeCount++, this.m_totalComponentCount += s2.getComponentCount(i2)), n5 <<= 1;
    let h2 = 0;
    for (i2 = 0, r = this.getAttributeCount(); i2 < r; i2++) {
      const t4 = this.getSemantics(i2), e2 = s2.getComponentCount(t4), n6 = s2.getDefaultValue(t4);
      this.m_pointAttributeOffsets[i2] = h2;
      for (let s3 = 0; s3 < e2; s3++) this.m_defaultPointAttributes[h2] = n6, h2++;
    }
  }
};
var L3 = z3;
function S2() {
  return Yt(14, 0);
}
var F2 = class _F {
  static getInstance() {
    return _F.s_thisInstance;
  }
  constructor() {
    this.m_map = /* @__PURE__ */ new Map(), this.m_vd2D = new L3(1), this.m_map.set(1, this.m_vd2D), this.m_vd3D = new L3(3), this.m_map.set(3, this.m_vd2D);
  }
  GetVD2D() {
    return this.m_vd2D;
  }
  GetVD3D() {
    return this.m_vd3D;
  }
  FindOrAdd(t3) {
    if (1 === t3) return this.GetVD2D();
    if (3 === t3) return this.GetVD3D();
    const e2 = this.m_map.get(t3);
    if (e2) return e2;
    const s3 = new L3(t3);
    return this.m_map.set(t3, s3), s3;
  }
};
function P3(t3) {
  return F2.getInstance().FindOrAdd(t3);
}
function H2(t3, e2) {
  if (!t3 || !e2) return e2 || t3;
  const s3 = t3.getSemanticsBitArray() | e2.getSemanticsBitArray();
  return (s3 & t3.getSemanticsBitArray()) === s3 ? t3 : (s3 & e2.getSemanticsBitArray()) === s3 ? e2 : P3(s3);
}
function V2(t3, e2) {
  const s3 = t3.getSemanticsBitArray() | 1 << e2;
  return (s3 & t3.getSemanticsBitArray()) === s3 ? t3 : P3(s3);
}
function k3(t3, e2) {
  const s3 = (t3.getSemanticsBitArray() | 1 << e2) - (1 << e2);
  return s3 === t3.getSemanticsBitArray() ? t3 : P3(s3);
}
function M() {
  return F2.getInstance().GetVD2D();
}
function O2() {
  return F2.getInstance().GetVD3D();
}
function Y2(t3, e2, s3) {
  if (s3.fill(-1), null !== t3 && null !== e2) for (let i2 = 0, n5 = t3.getAttributeCount(); i2 < n5; i2++) s3[i2] = e2.getAttributeIndex(t3.getSemantics(i2));
}
F2.s_thisInstance = new F2();
var X = class _X {
  static construct(t3, e2, s3) {
    return new _X(t3, e2, s3);
  }
  constructor(t3, e2, s3) {
    void 0 !== t3 ? (this.x = t3, this.y = e2, this.z = s3) : this.x = this.y = this.z = Number.NaN;
  }
  get 0() {
    return this.x;
  }
  get 1() {
    return this.y;
  }
  get 2() {
    return this.z;
  }
  set 0(t3) {
    this.x = t3;
  }
  set 1(t3) {
    this.y = t3;
  }
  set 2(t3) {
    this.z = t3;
  }
  clone() {
    return new _X(this.x, this.y, this.z);
  }
  assign(t3) {
    return this.x = t3.x, this.y = t3.y, this.z = t3.z, this;
  }
  setCoords(t3, e2, s3) {
    return this.x = t3, this.y = e2, this.z = s3, this;
  }
  setCoordsPoint2DZ(t3, e2) {
    return this.setCoords(t3.x, t3.y, e2);
  }
  setCoordsPoint3D(t3) {
    this.x = t3.x, this.y = t3.y, this.z = t3.z;
  }
  setZero() {
    this.x = 0, this.y = 0, this.z = 0;
  }
  setNormalized(t3) {
    this.assign(t3), this.normalizeThis();
  }
  normalizeThis() {
    const t3 = this.length();
    return t3 ? (this.x /= t3, this.y /= t3, this.z /= t3) : (this.x = 1, this.y = 0, this.z = 0), this;
  }
  getUnitVector() {
    const t3 = new _X();
    return t3.setNormalized(this), t3;
  }
  sqrLength() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  lengthXY() {
    return n(0), 0;
  }
  static sqrDistance(t3, e2) {
    return H(t3.x - e2.x) + H(t3.y - e2.y) + H(t3.z - e2.z);
  }
  static sqrDistanceCoords(t3, e2, i2, n5, r, h2) {
    return H(t3 - n5) + H(e2 - r) + H(i2 - h2);
  }
  static distance(t3, e2) {
    return Math.sqrt(_X.sqrDistance(t3, e2));
  }
  isEqual(t3, e2) {
    return void 0 === e2 && (e2 = 0), Math.abs(this.x - t3.x) <= e2 && Math.abs(this.y - t3.y) <= e2 && cs(this.z, t3.z, e2);
  }
  static compareByLength(t3, e2, s3, i2) {
    return n(0), 0;
  }
  isEqualCoords(t3, e2, s3, i2) {
    return n(0), this.x === t3 && this.y === e2 && this.z === s3;
  }
  isEqualsTols(t3, e2, s3) {
    return n(0), false;
  }
  isEqualCoordsTols(t3, e2, s3, i2, n5) {
    return n(0), false;
  }
  static st_isEqual(t3, e2, s3, i2) {
    return n(0), false;
  }
  equals(t3, e2) {
    return this.isEqual(t3, e2);
  }
  equalsTols(t3, e2, s3) {
    return n(0), false;
  }
  divThis(t3) {
    return this.x /= t3, this.y /= t3, this.z /= t3, this;
  }
  subThis(t3) {
    return this.x -= t3.x, this.y -= t3.y, this.z -= t3.z, this;
  }
  setSub(t3, e2) {
    return this.x = t3.x - e2.x, this.y = t3.y - e2.y, this.z = t3.z - e2.z, this;
  }
  sub(t3) {
    return _X.construct(this.x - t3.x, this.y - t3.y, this.z - t3.z);
  }
  addThis(t3) {
    return this.x += t3.x, this.y += t3.y, this.z += t3.z, this;
  }
  add(t3) {
    return this.clone().addThis(t3);
  }
  setAdd(t3, e2) {
    return this.x = t3.x + e2.x, this.y = t3.y + e2.y, this.z = t3.z + e2.z, this;
  }
  mul(t3) {
    return _X.construct(this.x * t3, this.y * t3, this.z * t3);
  }
  dotProduct(t3) {
    return this.x * t3.x + this.y * t3.y + this.z * t3.z;
  }
  crossProductVector(t3) {
    const e2 = this.y * t3.z - t3.y * this.z, s3 = t3.x * this.z - this.x * t3.z, i2 = this.x * t3.y - t3.x * this.y;
    return new _X(e2, s3, i2);
  }
  setCrossProductVector(t3, e2) {
    const s3 = t3.y * e2.z - e2.y * t3.z, i2 = e2.x * t3.z - t3.x * e2.z, n5 = t3.x * e2.y - e2.x * t3.y;
    return this.x = s3, this.y = i2, this.z = n5, this;
  }
  setScaled(t3, e2) {
    return this.x = t3 * e2.x, this.y = t3 * e2.y, this.z = t3 * e2.z, this;
  }
  scaleThis(t3) {
    return this.x *= t3, this.y *= t3, this.z *= t3, this;
  }
  scaleZThis(t3) {
    return this.z *= t3, this;
  }
  setNAN() {
    return n(0), this;
  }
  isNAN() {
    return Number.isNaN(this.x) || Number.isNaN(this.y) || Number.isNaN(this.z);
  }
  static getNAN() {
    return _X.construct(Number.NaN, Number.NaN, Number.NaN);
  }
  isFinite() {
    return n(0), false;
  }
  isZero() {
    return 0 === this.x && 0 === this.y && 0 === this.z;
  }
  norm(t3) {
    return n(0), 0;
  }
  sqrDistanceFromCenterToSpheroidSurface(t3, e2) {
    return n(0), 0;
  }
  distanceFromCenterToSpheroidSurface(t3, e2) {
    return Math.sqrt(this.sqrDistanceFromCenterToSpheroidSurface(t3, e2));
  }
  static getClosestCoordinate(t3, e2, s3, i2 = false) {
    return n(0), 0;
  }
  compare(t3) {
    return this.y < t3.y ? -1 : this.y > t3.y ? 1 : this.x < t3.x ? -1 : this.x > t3.x ? 1 : this.z < t3.z ? -1 : this.z > t3.z ? 1 : 0;
  }
  compareXYZ(t3) {
    return n(0), 0;
  }
  negateThis() {
    this.x = -this.x, this.y = -this.y, this.z = -this.z;
  }
  static averageFast(t3, e2) {
    return n(0), {};
  }
  static average(t3, e2) {
    return n(0), {};
  }
  static size() {
    return _X.dimensions;
  }
  static lerp(t3, e2, s3) {
    const i2 = new _X();
    return j2(t3, e2, s3, i2), i2;
  }
  static slerp(t3, e2, s3) {
    return n(0), {};
  }
  static compareVectors(t3, e2) {
    return n(0), 0;
  }
  static selectRightHandedBasisFromNormal(t3, e2, s3) {
    const i2 = t3.getUnitVector(), n5 = i2.createAPerpendicular(), r = new _X();
    r.setCrossProductVector(i2, n5), r.normalizeThis(), e2.setCoordsPoint3D(n5), s3.setCoordsPoint3D(r);
  }
  createAPerpendicular() {
    const t3 = [this.crossProductVector(new _X(0, 0, 1)), this.crossProductVector(new _X(1, 0, 0)), this.crossProductVector(new _X(0, 1, 0))], e2 = [t3[0].sqrLength(), t3[1].sqrLength(), t3[2].sqrLength()], s3 = t3[e2.reduce((t4, s4, i2) => e2[t4] > e2[i2] ? t4 : i2, 0)];
    return s3.normalizeThis(), s3;
  }
  calculateAngle(t3) {
    return n(0), 0;
  }
  static crossDotSign(t3, e2, s3) {
    return n(0), 0;
  }
  static isBisectorRobust(t3, e2, s3) {
    return n(0), 0;
  }
  static compareZOrder(t3, e2) {
    return n(0), false;
  }
};
X.dimensions = 3;
var G3 = class _G {
  static constructEmpty() {
    return new _G(Number.NaN, Number.NaN, Number.NaN, Number.NaN, Number.NaN, Number.NaN);
  }
  constructor(t3, e2, s3, i2, n5, r) {
    this.m_EnvelopeType = 3, this.xmin = t3, this.ymin = e2, this.zmin = s3, this.xmax = i2, this.ymax = n5, this.zmax = r, this.normalize();
  }
  inflate(t3) {
    this.inflateCoords(t3, t3, t3);
  }
  inflateCoords(t3, e2, s3) {
    n(0);
  }
  getEnvelope2D() {
    return new n3(this.xmin, this.ymin, this.xmax, this.ymax);
  }
  getEnvelopeZs() {
    return new x2(this.zmin, this.zmax);
  }
  setEmptyZ() {
    this.zmin = Number.NaN, this.zmax = Number.NaN;
  }
  normalize() {
    let t3 = false;
    this.xmin <= this.xmax || (this.xmax = Pt(this.xmin, this.xmin = this.xmax), t3 = true), this.ymin <= this.ymax || (this.ymax = Pt(this.ymin, this.ymin = this.ymax), t3 = true), !t3 || this.xmin <= this.xmax && this.ymin <= this.ymax ? this.zmin <= this.zmax || (this.zmax = Pt(this.zmin, this.zmin = this.zmax), this.zmin <= this.zmax || this.setEmptyZ()) : this.setEmpty();
  }
  isEmpty() {
    return Number.isNaN(this.xmin) || Number.isNaN(this.ymin) || Number.isNaN(this.xmax) || Number.isNaN(this.ymax);
  }
  isEmptyZ() {
    return Number.isNaN(this.zmin) || Number.isNaN(this.zmax);
  }
  setEmpty() {
    this.xmin = Number.NaN, this.ymin = Number.NaN, this.zmin = Number.NaN, this.xmax = Number.NaN, this.ymax = Number.NaN, this.zmax = Number.NaN;
  }
  mergeEnv3D(t3) {
    t3.isEmpty() || (this.mergeCoords(t3.xmin, t3.ymin, t3.zmin), this.mergeCoords(t3.xmax, t3.ymax, t3.zmax));
  }
  mergeNe(t3) {
    this.mergeNeCoords(t3.x, t3.y, t3.z);
  }
  mergeNeCoords(t3, e2, s3) {
    this.xmin > t3 ? this.xmin = t3 : this.xmax < t3 && (this.xmax = t3), this.ymin > e2 ? this.ymin = e2 : this.ymax < e2 && (this.ymax = e2), this.zmin > s3 ? this.zmin = s3 : this.zmax < s3 && (this.zmax = s3);
  }
  mergeCoords(t3, e2, s3) {
    this.isEmpty() ? (this.xmin = t3, this.xmax = t3, this.ymin = e2, this.ymax = e2, this.zmin = s3, this.zmax = s3) : (this.isEmptyZ() && (this.zmin = s3, this.zmax = s3), this.mergeNeCoords(t3, e2, s3));
  }
  setCoords(t3, e2, s3, i2, n5, r) {
    this.xmin = t3, this.ymin = e2, this.zmin = s3, this.xmax = i2, this.ymax = n5, this.zmax = r, this.normalize();
  }
  sqrDistanceEnvelope3DAndPoints(t3, e2, s3, i2 = 1) {
    return n(0), 0;
  }
  sqrMaxDistance(t3, e2 = 1) {
    return n(0), 0;
  }
};
var U3 = -559038737;
var Z = z3;
function Q2(t3, e2, s3) {
  switch (t3) {
    case 0:
      return new it(e2, s3);
    case 1:
      return new nt(e2, s3);
    case 2:
      return new st2(e2, s3);
    case 3:
      throw new Error("64 bit int attribute stream not implemented");
    case 4:
      return new et(e2, s3);
    default:
      P("");
  }
}
function j3(t3, e2) {
  const s3 = Z.getComponentCount(t3);
  return Q2(Z.getPersistence(t3), e2 * s3, Z.getDefaultValue(t3));
}
function W(t3, e2) {
  const s3 = Z.getComponentCount(t3);
  return Q2(Z.getPersistence(t3), e2 * s3);
}
function J2(t3, e2) {
  return new st2(t3, e2);
}
function K2(t3, e2) {
  return new et(t3, e2);
}
function $2(t3, e2) {
  return new nt(t3, e2);
}
var tt = class _tt {
  size() {
    return this.m_size;
  }
  checkResize(t3, e2) {
    t3 > this.m_size && this.resize(t3, e2);
  }
  resize(t3, e2) {
    if ((t3 = Math.trunc(t3)) === this.m_size) return;
    const s3 = !!e2 || Number.isNaN(e2);
    if (t3 < this.m_a.length) this.m_a.length > _tt.s_resizeMin && 1.25 * t3 < this.m_a.length && (this.m_a = this.m_a.slice(0, t3)), s3 && t3 > this.m_size && this.m_a.fill(e2, this.m_size, t3);
    else if (t3 >= this.m_a.length) {
      const i2 = 1.25 * t3, n5 = new this.m_a.constructor(i2);
      n5.set(this.m_a), this.m_a = n5, s3 && this.m_a.fill(e2, this.m_size, t3);
    }
    this.m_size = t3;
  }
  resizeRounded(t3, e2) {
    return this.resize(t3, e2);
  }
  reserve(t3) {
  }
  read(t3) {
    return this.m_a[t3];
  }
  readAsDbl(t3) {
    return this.read(t3);
  }
  write(t3, e2) {
    this.m_a[t3] = e2;
  }
  writeAsDbl(t3, e2) {
    this.write(t3, e2);
  }
  setRange(t3, e2, s3) {
    (e2 < 0 || s3 < 0 || s3 + e2 > this.size()) && P(), this.m_a.fill(t3, e2, e2 + s3);
  }
  add(t3) {
    this.resize(this.m_size + 1), this.m_a[this.m_size - 1] = t3;
  }
  addArray(t3, e2) {
    const s3 = this.m_size;
    void 0 === e2 ? (this.resize(this.m_size + t3.length), this.m_a.set(t3, s3)) : (this.resize(this.m_size + e2), this.m_a.set(t3.slice(0, e2), s3));
  }
  equals(t3, e2, s3, i2) {
    if (this.getPersistence() !== t3.getPersistence()) return false;
    return rt(this, t3, e2, s3, i2);
  }
  insertRange(t3, e2, s3, i2) {
    const n5 = this.m_size;
    this.checkResize(Math.max(0, i2) + s3), this.m_a.copyWithin(t3 + s3, t3, i2 >= 0 ? i2 : n5), this.m_a.fill(e2, t3, t3 + s3);
  }
  readRange(t3, e2) {
    return this.m_a.slice(t3, t3 + e2);
  }
  insertRangeFromStream(t3, e2, s3, i2, n5, r, h2) {
    n(this.getPersistence() === e2.getPersistence());
    const o = e2, a2 = this.m_size;
    i2 && this.checkResize(Math.max(0, h2) + i2), this.m_a.copyWithin(t3 + i2, t3, h2 >= 0 ? h2 : a2), this.m_a.set(o.readRange(s3, i2), t3), n5 || this.reverseRange(t3, i2, r);
  }
  writeRange(t3, e2, s3, i2, n5, r) {
    n(this.getPersistence() === s3.getPersistence());
    const h2 = s3;
    if ((t3 < 0 || e2 < 0 || i2 < 0) && P(), h2.size() < i2 + e2 && P(), 0 === e2) return;
    this.size() < e2 + t3 && this.resize(e2 + t3);
    const o = h2.m_a.subarray(i2, i2 + e2);
    ht(this.m_a, t3, e2, o);
  }
  insertAttributes(t3, e2, s3, i2) {
    const n5 = Z.getComponentCount(s3);
    this.m_a.copyWithin(t3 + n5, t3, i2 >= 0 ? i2 : this.m_size);
    for (let r = 0; r < n5; r++) this.m_a[t3 + r] = e2.getAttributeAsDbl(s3, r);
  }
  insertAttributesFromPoints(t3, e2, s3, i2, n5) {
    n(Z.getPersistence(i2) === this.getPersistence());
    const r = Z.getComponentCount(i2), h2 = this.m_size;
    if (this.checkResize(Math.max(0, n5) + r * s3), this.m_a.copyWithin(t3 + r * s3, t3, n5 >= 0 ? n5 : h2), 0 === i2) {
      const i3 = new mi();
      for (let n6 = t3, r2 = 0; r2 < s3; r2++, n6 += 2) e2[r2].queryXY(i3), this.m_a[n6] = i3.x, this.m_a[n6 + 1] = i3.y;
    } else if (1 === r) for (let o = t3, a2 = 0; a2 < s3; a2++, o++) this.m_a[o] = e2[a2].getAttributeAsDbl(i2, 0);
    else for (let o = t3, a2 = 0; a2 < s3; a2++, o += r) for (let t4 = 0; t4 < r; t4++) this.m_a[o + t4] = e2[a2].getAttributeAsDbl(i2, t4);
  }
  eraseRange(t3, e2, s3) {
    this.m_size < t3 + e2 && P(), this.m_a.copyWithin(t3, t3 + e2), this.m_size -= e2;
  }
  reverseRange(t3, e2, s3) {
    if ((s3 < 1 || e2 % s3 !== 0) && P(), this.m_a.subarray(t3, t3 + e2).reverse(), s3 > 1) for (let i2 = t3, n5 = t3 + e2; i2 < n5; i2 += s3) {
      let t4 = i2, e3 = i2 + s3 - 1;
      for (; t4 < e3; ) {
        const s4 = this.m_a[t4];
        this.m_a[t4] = this.m_a[e3], this.m_a[e3] = s4, t4++, e3--;
      }
    }
  }
  rotate(t3, e2, s3) {
    (e2 < t3 || e2 > s3 || t3 > s3) && A("rotate"), e2 !== t3 && e2 !== s3 && (this.reverseRange(t3, e2 - t3, 1), this.reverseRange(e2, s3 - e2, 1), this.reverseRange(t3, s3 - t3, 1));
  }
  sort(t3, e2, s3) {
    this.m_a.subarray(t3, e2).sort(s3);
  }
  constructor(t3) {
    if (t3.move) this.m_a = t3.move.m_a, this.m_size = t3.move.m_size, t3.move.m_a = t3.move.m_a.slice(0, 0), t3.move.m_size = 0;
    else if (t3.copy) this.m_size = t3.copy.m_size, t3.maxSize && (this.m_size = Math.min(t3.maxSize, this.m_size)), this.m_a = t3.copy.m_a.slice(0, this.m_size);
    else {
      const e2 = Math.max(t3.size, _tt.s_constructMin);
      this.m_a = new t3.ctor(e2), (t3.defaultValue || Number.isNaN(t3.defaultValue)) && this.m_a.fill(t3.defaultValue), this.m_size = t3.size;
    }
  }
};
tt.s_constructMin = 2, tt.s_resizeMin = 30;
var et = class _et extends tt {
  setBits(t3, e2) {
    this.m_a[t3] |= e2;
  }
  clearBits(t3, e2) {
    this.m_a[t3] &= ~e2;
  }
  getPersistence() {
    return 4;
  }
  clone() {
    return new _et({ ctor: Int8Array, copy: this });
  }
  restrictedClone(t3) {
    return new _et({ ctor: Int8Array, copy: this, maxSize: t3 });
  }
  constructor(t3, e2) {
    super("number" == typeof t3 ? { ctor: Int8Array, size: t3, defaultValue: e2 } : t3);
  }
};
var st2 = class _st extends tt {
  getPersistence() {
    return 2;
  }
  clone() {
    return new _st({ ctor: Int32Array, copy: this });
  }
  restrictedClone(t3) {
    return new _st({ ctor: Int32Array, copy: this, maxSize: t3 });
  }
  write(t3, e2) {
    n(e2 <= ds()), super.write(t3, e2);
  }
  constructor(t3, e2) {
    super("number" == typeof t3 ? { ctor: Int32Array, size: t3, defaultValue: e2 } : t3);
  }
};
var it = class _it extends tt {
  getPersistence() {
    return 0;
  }
  clone() {
    return new _it({ ctor: Float32Array, copy: this });
  }
  restrictedClone(t3) {
    return new _it({ ctor: Float32Array, copy: this, maxSize: t3 });
  }
  constructor(t3, e2) {
    super("number" == typeof t3 ? { ctor: Float32Array, size: t3, defaultValue: e2 } : t3);
  }
};
var nt = class _nt extends tt {
  getPersistence() {
    return 1;
  }
  getArray() {
    return this.m_a;
  }
  applyTransformation(t3, e2, s3) {
    (1 & e2 || e2 + 2 * s3 > this.size()) && P();
    const i2 = 0 === e2 ? this.m_a : this.m_a.subarray(e2);
    t3.transformInterleavedPoints(i2, s3, i2);
  }
  readPoint2D(t3) {
    const e2 = this.m_a[t3], s3 = this.m_a[t3 + 1];
    return new mi(e2, s3);
  }
  queryPoint2D(t3, e2) {
    return e2.x = this.m_a[t3], e2.y = this.m_a[t3 + 1], e2;
  }
  writePoint2D(t3, e2) {
    this.write(t3, e2.x), this.write(t3 + 1, e2.y);
  }
  insert(t3, e2, s3) {
    this.checkResize(s3 + 2), this.m_a.copyWithin(t3 + 2, t3, s3), this.m_a[t3] = e2.x, this.m_a[t3 + 1] = e2.y;
  }
  insertRangeFromPoints(t3, e2, s3, i2, n5, r) {
    const h2 = this.m_size;
    if (this.checkResize(Math.max(r, 0) + 2 * i2), this.m_a.copyWithin(t3 + 2 * i2, t3, r >= 0 ? r : h2), n5) for (let o = s3, a2 = t3, m3 = 0; m3 < i2; ++m3, ++o) {
      const t4 = e2[o];
      this.m_a[a2++] = t4.x, this.m_a[a2++] = t4.y;
    }
    else for (let o = s3 + i2 - 1, a2 = t3, m3 = 0; m3 < i2; ++m3, --o) {
      const t4 = e2[o];
      this.m_a[a2++] = t4.x, this.m_a[a2++] = t4.y;
    }
  }
  queryRange(t3, e2, s3, i2, n5) {
    if ((t3 < 0 || e2 < 0) && P(), !i2 && (n5 <= 0 || e2 % n5 !== 0) && P(), 0 === e2) return;
    if (1 === e2) return void (s3[0] = this.m_a[t3]);
    const r = this.m_a.subarray(t3, t3 + e2);
    s3.set(r);
  }
  writeRangeFromArray(t3, e2, s3, i2, n5) {
    if ((t3 < 0 || e2 < 0) && P(), 0 === e2) return;
    if (1 === e2) return void (this.m_a[t3] = s3[0]);
    let r = s3;
    e2 < s3.length && (r = s3.subarray(0, e2)), this.m_a.set(r, t3);
  }
  clone() {
    return new _nt({ ctor: Float64Array, copy: this });
  }
  restrictedClone(t3) {
    return new _nt({ ctor: Float64Array, copy: this, maxSize: t3 });
  }
  constructor(t3, e2) {
    super("number" == typeof t3 ? { ctor: Float64Array, size: t3, defaultValue: e2 } : t3);
  }
};
function rt(t3, e2, s3, n5, r) {
  if (t3.getPersistence() !== e2.getPersistence()) return false;
  const h2 = t3.getPersistence() <= 1, o = t3.size(), a2 = e2.size();
  if (n5 > o || n5 > a2) return false;
  if (r) if (h2) {
    for (let m3 = s3; m3 < n5; m3++) if (!cs(t3.read(m3), e2.read(m3), r)) return false;
  } else for (let i2 = s3; i2 < n5; i2++) {
    let s4 = t3.read(i2) - e2.read(i2);
    if (s4 < 0 && (s4 = -s4), s4 > r) return false;
  }
  else for (let i2 = s3; i2 < n5; i2++) {
    const s4 = t3.read(i2), n6 = e2.read(i2);
    if (s4 !== n6) {
      if (h2 && Number.isNaN(s4) && Number.isNaN(n6)) continue;
      return false;
    }
  }
  return true;
}
function ht(t3, e2, s3, i2, n5, r) {
  if ((e2 < 0 || s3 < 0) && P(), 0 === s3) return;
  if (1 === s3) return void (t3[e2] = i2[0]);
  let h2 = i2;
  s3 < i2.length && (h2 = i2.subarray(0, s3)), t3.set(h2, e2);
}
var ot = class _ot {
  constructor() {
    this.m_minValue = -1, this.m_maxValue = -1, this.m_dy = Number.NaN, this.m_buckets = new st2(0), this.m_bucketedIndices = new st2(0);
  }
  static sortEx(t3, e2, s3, i2, n5 = 32) {
    if (s3 - e2 <= n5) return void i2.userSort(e2, s3, t3);
    new _ot().sort(t3, e2, s3, i2, n5);
  }
  sort(t3, e2, s3, i2, n5 = 32) {
    if (s3 - e2 <= n5) return void i2.userSort(e2, s3, t3);
    let r = true, h2 = Number.POSITIVE_INFINITY, o = Number.NEGATIVE_INFINITY;
    for (let m3 = e2; m3 < s3; m3++) {
      const e3 = i2.getValue(t3.read(m3));
      e3 < h2 && (h2 = e3), e3 > o && (o = e3);
    }
    if (this.reset(s3 - e2, h2, o, s3 - e2)) {
      for (let r2 = e2; r2 < s3; r2++) {
        const s4 = t3.read(r2), n7 = i2.getValue(s4), h3 = this.getBucket(n7);
        this.m_buckets.write(h3, this.m_buckets.read(h3) + 1), this.m_bucketedIndices.write(r2 - e2, s4);
      }
      let n6 = this.m_buckets.read(0);
      this.m_buckets.write(0, 0);
      for (let t4 = 1, e3 = this.m_buckets.size(); t4 < e3; t4++) {
        const e4 = this.m_buckets.read(t4);
        this.m_buckets.write(t4, n6), n6 += e4;
      }
      for (let r2 = e2; r2 < s3; r2++) {
        const s4 = this.m_bucketedIndices.read(r2 - e2), n7 = i2.getValue(s4), h3 = this.getBucket(n7), o2 = this.m_buckets.read(h3);
        t3.write(o2 + e2, s4), this.m_buckets.write(h3, o2 + 1);
      }
      r = false;
    }
    if (r) return void i2.userSort(e2, s3, t3);
    let a2 = 0;
    for (let m3 = 0, _ = this.m_buckets.size(); m3 < _; m3++) {
      const s4 = a2;
      a2 = this.m_buckets.read(m3), a2 > s4 && i2.userSort(e2 + s4, e2 + a2, t3);
    }
    this.m_buckets.size() > 100 && (this.m_buckets.resize(0), this.m_bucketedIndices.resize(0));
  }
  reset(t3, e2, s3, i2) {
    if (t3 < 2 || s3 === e2) return false;
    const n5 = Math.min(_ot.c_maxBuckets, t3);
    return this.m_buckets.resize(n5), this.m_buckets.setRange(0, 0, this.m_buckets.size()), this.m_minValue = e2, this.m_maxValue = s3, this.m_bucketedIndices.resize(i2), this.m_dy = (s3 - e2) / (n5 - 1), true;
  }
  getBucket(t3) {
    return Math.trunc((t3 - this.m_minValue) / this.m_dy);
  }
  getBucketCount() {
    return this.m_buckets.size();
  }
};
ot.c_maxBuckets = 65536;
var at = class {
  capacity() {
    return this.capacity_;
  }
  constructor(t3) {
    this.m_buffer = new Int32Array(0), this.m_firstFree = -1, this.m_last = 0, this.size_ = 0, this.capacity_ = 0, this.stride = t3;
  }
  size() {
    return this.size_;
  }
  deleteElement(t3) {
    t3 < this.m_last ? (this.m_buffer[t3 * this.stride] = this.m_firstFree, this.m_firstFree = t3) : this.m_last--, this.size_--;
  }
  getField(t3, e2) {
    return this.m_buffer[t3 * this.stride + e2];
  }
  setField(t3, e2, s3) {
    this.m_buffer[t3 * this.stride + e2] = s3;
  }
  elementToIndex(t3) {
    return t3;
  }
  newElement() {
    let t3 = this.m_firstFree;
    if (-1 === t3) {
      if (this.m_last === this.capacity_) {
        let t4 = 0 !== this.capacity_ ? Math.trunc(3 * (this.capacity_ + 1) / 2) : 1;
        if (t4 > Number.MAX_SAFE_INTEGER && (t4 = Number.MAX_SAFE_INTEGER), t4 === this.capacity_) throw new Error("index out of bounds");
        this.grow_(t4);
      }
      t3 = this.m_last, this.m_last++;
    } else this.m_firstFree = this.m_buffer[t3 * this.stride];
    this.size_++;
    for (let e2 = t3 * this.stride; e2 < t3 * this.stride + this.stride; e2++) this.m_buffer[e2] = -1;
    return t3;
  }
  newElementPset(t3) {
    let e2 = this.m_firstFree;
    if (-1 === e2) {
      if (this.m_last === this.capacity_) {
        let t4 = 0 !== this.capacity_ ? Math.trunc(3 * (this.capacity_ + 1) / 2) : 1;
        if (t4 > Number.MAX_SAFE_INTEGER && (t4 = Number.MAX_SAFE_INTEGER), t4 === this.capacity_) throw new Error("index out of bounds");
        this.grow_(t4);
      }
      e2 = this.m_last, this.m_last++;
    } else this.m_firstFree = this.m_buffer[e2 * this.stride];
    this.size_++;
    const s3 = e2 * this.stride;
    for (let i2 = 0; i2 < t3.length; i2++) this.m_buffer[s3 + i2] = t3[i2];
    return e2;
  }
  deleteAll(t3) {
    this.m_firstFree = -1, this.m_last = 0, this.size_ = 0, t3 && (this.m_buffer = new Int32Array(0), this.capacity_ = 0);
  }
  setCapacity(t3) {
    t3 > this.capacity_ && this.grow_(t3);
  }
  swap(t3, e2) {
    const s3 = t3 * this.stride, i2 = e2 * this.stride;
    for (let n5 = 0; n5 < this.stride; n5++) {
      const t4 = this.m_buffer[i2 + n5];
      this.m_buffer[i2 + n5] = this.m_buffer[s3 + n5], this.m_buffer[s3 + n5] = t4;
    }
  }
  swapField(t3, e2, s3) {
    const i2 = this.m_buffer[this.stride * e2 + s3];
    this.m_buffer[this.stride * e2 + s3] = this.m_buffer[this.stride * t3 + s3], this.m_buffer[this.stride * t3 + s3] = i2;
  }
  static impossibleIndex2() {
    return -2;
  }
  static impossibleIndex3() {
    return -3;
  }
  static isValidElement(t3) {
    return t3 >= 0;
  }
  grow_(t3) {
    null == this.m_buffer && (this.m_buffer = new Int32Array(0));
    const e2 = this.stride * t3, s3 = new Int32Array(e2);
    s3.set(this.m_buffer, 0), this.m_buffer = s3, this.capacity_ = t3;
  }
};
function mt(t3, e2) {
  return { element: t3, box: e2.clone() };
}
var _t2 = class __t {
  constructor(t3, e2, s3) {
    this.m_extent = new n3(), this.m_dataExtent = new n3(), this.m_childExtents = [new n3(), new n3(), new n3(), new n3()], this.m_elementNodes = new at(4), this.m_data = [], this.m_freeData = [], this.m_root = -1, this.m_height = 8, void 0 === s3 && (s3 = false), this.m_quadTreeNodes = new at(s3 ? 11 : 10), this.m_bStoreDuplicates = s3, this.reset_(t3, e2);
  }
  reset(t3, e2) {
    this.m_quadTreeNodes.deleteAll(false), this.m_elementNodes.deleteAll(false), this.m_data.length = 0, this.m_freeData.length = 0, this.reset_(t3, e2);
  }
  insert(t3, e2) {
    if (-1 === this.m_root && this.createRoot_(), this.m_bStoreDuplicates) {
      const s4 = this.insertDuplicates_(t3, e2, 0, this.m_extent, this.m_root, false, -1);
      return -1 !== s4 && (this.m_dataExtent.isEmpty() ? this.m_dataExtent.setCoords({ env2D: e2 }) : this.m_dataExtent.mergeEnvelope2D(e2)), s4;
    }
    const s3 = this.insert_(t3, e2, 0, this.m_extent, this.m_root, false, -1);
    return -1 !== s3 && (this.m_dataExtent.isEmpty() ? this.m_dataExtent.setCoords({ env2D: e2 }) : this.m_dataExtent.mergeEnvelope2D(e2)), s3;
  }
  insertEx(t3, e2, s3) {
    if (-1 === this.m_root && this.createRoot_(), this.m_bStoreDuplicates) {
      const s4 = this.insertDuplicates_(t3, e2, 0, this.m_extent, this.m_root, false, -1);
      return -1 !== s4 && (this.m_dataExtent.isEmpty() ? this.m_dataExtent.setCoords({ env2D: e2 }) : this.m_dataExtent.mergeEnvelope2D(e2)), s4;
    }
    let i2;
    i2 = -1 === s3 ? this.m_root : this.getQuad_(s3);
    const n5 = this.getHeight(i2), r = this.getExtent(i2), h2 = this.insert_(t3, e2, n5, r, i2, false, -1);
    return -1 !== h2 && (this.m_dataExtent.isEmpty() ? this.m_dataExtent.setCoords({ env2D: e2 }) : this.m_dataExtent.mergeEnvelope2D(e2)), h2;
  }
  removeElement(t3) {
    n(0);
  }
  getElement(t3) {
    return this.getElementValue_(this.getData_(t3));
  }
  getElementAtIndex(t3) {
    return n(0), 0;
  }
  getElementExtent(t3) {
    const e2 = this.getData_(t3);
    return this.getBoundingBoxValue_(e2).clone();
  }
  getElementExtentAtIndex(t3) {
    return n(0), {};
  }
  getDataExtent() {
    return this.m_dataExtent.clone();
  }
  getQuadTreeExtent() {
    return n(0), {};
  }
  getHeight(t3) {
    return this.m_quadTreeNodes.getField(t3, 6) >> __t.m_heightBitShift;
  }
  getMaxHeight() {
    return this.m_height;
  }
  getExtent(t3) {
    const e2 = new n3();
    if (e2.setCoords({ env2D: this.m_extent }), t3 === this.m_root) return e2;
    const s3 = [];
    let i2 = t3;
    do {
      s3.push(this.getQuadrant_(i2)), i2 = this.getParent_(i2);
    } while (i2 !== this.m_root);
    const n5 = s3.length;
    for (let r = 0; r < n5; r++) {
      const t4 = s3.at(-1);
      s3.pop(), 0 === t4 ? (e2.xmin = 0.5 * (e2.xmin + e2.xmax), e2.ymin = 0.5 * (e2.ymin + e2.ymax)) : 1 === t4 ? (e2.xmax = 0.5 * (e2.xmin + e2.xmax), e2.ymin = 0.5 * (e2.ymin + e2.ymax)) : 2 === t4 ? (e2.xmax = 0.5 * (e2.xmin + e2.xmax), e2.ymax = 0.5 * (e2.ymin + e2.ymax)) : (e2.xmin = 0.5 * (e2.xmin + e2.xmax), e2.ymax = 0.5 * (e2.ymin + e2.ymax));
    }
    return e2;
  }
  getQuad(t3) {
    return this.getQuad_(t3);
  }
  getElementCount() {
    return -1 === this.m_root ? 0 : this.getSubTreeElementCount_(this.m_root);
  }
  getSubTreeElementCount(t3) {
    return this.getSubTreeElementCount_(t3);
  }
  getContainedSubTreeElementCount(t3) {
    return this.m_bStoreDuplicates ? this.getContainedSubTreeElementCount_(t3) : this.getSubTreeElementCount_(t3);
  }
  getIntersectionCount(t3, e2, s3) {
    if (-1 === this.m_root) return 0;
    const i2 = new n3();
    i2.setCoords({ env2D: t3 }), i2.inflateCoords(e2, e2);
    const n5 = [], r = [];
    n5.push(this.m_root), r.push(this.m_extent.clone());
    const h2 = Ot(n3, 4);
    let o = 0;
    for (; n5.length > 0; ) {
      let t4 = false;
      const e3 = n5.at(-1), a2 = r.at(-1);
      if (n5.pop(), r.pop(), i2.containsEnvelope(a2)) {
        if (o += this.getSubTreeElementCount(e3), s3 > 0 && o >= s3) return s3;
      } else if (i2.isIntersecting(a2)) {
        for (let t5 = this.getFirstElement_(e3); -1 !== t5; t5 = this.getNextElement_(t5)) {
          const e4 = this.getData_(t5);
          if (this.getBoundingBoxValue_(e4).isIntersecting(i2) && (o++, s3 > 0 && o >= s3)) return s3;
        }
        t4 = this.getHeight(e3) + 1 <= this.m_height;
      }
      if (t4) {
        __t.setChildExtents_(a2, h2);
        for (let t5 = 0; t5 < 4; t5++) {
          const s4 = this.getChild_(e3, t5);
          if (-1 !== s4 && this.getSubTreeElementCount_(s4) > 0) {
            i2.isIntersecting(h2[t5]) && (n5.push(s4), r.push(h2[t5].clone()));
          }
        }
      }
    }
    return o;
  }
  hasData(t3, e2) {
    return this.getIntersectionCount(t3, e2, 1) >= 1;
  }
  getIterator(t3, e2) {
    return new lt(this, t3, e2);
  }
  getIteratorForQT() {
    return new lt(this);
  }
  getSortedIterator(t3, e2) {
    return new ut(this.getIterator(t3, e2));
  }
  getSortedIteratorForQT() {
    return new ut(this.getIteratorForQT());
  }
  visitLeavesNearest(t3, e2, s3, i2) {
    n(0);
  }
  reset_(t3, e2) {
    (e2 < 0 || e2 > 127) && P("invalid height"), this.m_height = e2, this.m_extent.setCoords({ env2D: t3 }), this.m_dataExtent.setEmpty(), this.m_root = -1;
  }
  insert_(t3, e2, s3, i2, n5, r, h2) {
    if (!i2.containsEnvelope(e2)) return 0 === s3 ? -1 : this.insert_(t3, e2, 0, this.m_extent, this.m_root, r, h2);
    if (!r) for (let _ = n5; -1 !== _; _ = this.getParent_(_)) this.setSubTreeElementCount_(_, this.getSubTreeElementCount_(_) + 1);
    const o = new n3();
    o.setCoords({ env2D: i2 });
    let a2, m3 = n5;
    for (a2 = s3; a2 < this.m_height && this.canPushDown_(m3); a2++) {
      __t.setChildExtents_(o, this.m_childExtents);
      let t4 = false;
      for (let s4 = 0; s4 < 4; s4++) if (this.m_childExtents[s4].containsEnvelope(e2)) {
        t4 = true;
        let e3 = this.getChild_(m3, s4);
        -1 === e3 && (e3 = this.createChild_(m3, s4)), this.setSubTreeElementCount_(e3, this.getSubTreeElementCount_(e3) + 1), m3 = e3, o.setCoords({ env2D: this.m_childExtents[s4] });
        break;
      }
      if (!t4) break;
    }
    return this.insertAtQuad_(t3, e2, a2, o, m3, r, n5, h2, -1);
  }
  insertDuplicates_(t3, e2, s3, i2, n5, r, h2) {
    if (!r) {
      if (!i2.containsEnvelope(e2)) return -1;
      this.setSubTreeElementCount_(n5, this.getSubTreeElementCount_(n5) + 1), this.setContainedSubTreeElementCount_(n5, this.getContainedSubTreeElementCount_(n5) + 1);
    }
    const o = Math.max(e2.width(), e2.height());
    let a2 = -1;
    const m3 = [], _ = [], l2 = [];
    m3.push(n5), _.push(i2.clone()), l2.push(s3);
    const u = Ot(n3, 4);
    for (; m3.length > 0; ) {
      let s4 = false;
      const i3 = m3.at(-1), d2 = _.at(-1), c = l2.at(-1);
      if (m3.pop(), _.pop(), l2.pop(), c + 1 < this.m_height && this.canPushDown_(i3)) {
        o <= Math.max(d2.width(), d2.height()) / 2 && (s4 = true);
      }
      if (s4) {
        __t.setChildExtents_(d2, u);
        let t4 = false;
        for (let s5 = 0; s5 < 4; s5++) if (t4 = u[s5].containsEnvelope(e2), t4) {
          let t5 = this.getChild_(i3, s5);
          -1 === t5 && (t5 = this.createChild_(i3, s5)), m3.push(t5), _.push(u[s5].clone()), l2.push(c + 1), this.setSubTreeElementCount_(t5, this.getSubTreeElementCount_(t5) + 1), this.setContainedSubTreeElementCount_(t5, this.getContainedSubTreeElementCount_(t5) + 1);
          break;
        }
        if (!t4) for (let s5 = 0; s5 < 4; s5++) {
          if (u[s5].isIntersecting(e2)) {
            let t5 = this.getChild_(i3, s5);
            -1 === t5 && (t5 = this.createChild_(i3, s5)), m3.push(t5), _.push(u[s5].clone()), l2.push(c + 1), this.setSubTreeElementCount_(t5, this.getSubTreeElementCount_(t5) + 1);
          }
        }
      } else a2 = this.insertAtQuad_(t3, e2, c, d2, i3, r, n5, h2, a2), r = false;
    }
    return 0;
  }
  insertAtQuad_(t3, e2, s3, i2, n5, r, h2, o, a2) {
    this.getFirstElement_(n5);
    const m3 = this.getLastElement_(n5);
    let _ = -1;
    if (r) {
      if (n5 === h2) return o;
      this.disconnectElementHandle_(o), _ = o;
    } else -1 === a2 ? (_ = this.createElement_(), this.setDataValues_(this.getData_(_), t3, e2)) : _ = this.createElementFromDuplicate_(a2);
    return this.setQuad_(_, n5), -1 !== m3 ? (this.setPrevElement_(_, m3), this.setNextElement_(m3, _)) : this.setFirstElement_(n5, _), this.setLastElement_(n5, _), this.setLocalElementCount_(n5, this.getLocalElementCount_(n5) + 1), this.canFlush_(n5) && this.flush_(s3, i2, n5), _;
  }
  static setChildExtents_(t3, e2) {
    const s3 = 0.5 * (t3.xmin + t3.xmax), i2 = 0.5 * (t3.ymin + t3.ymax);
    e2[0].setCoords({ xmin: s3, ymin: i2, xmax: t3.xmax, ymax: t3.ymax }), e2[1].setCoords({ xmin: t3.xmin, ymin: i2, xmax: s3, ymax: t3.ymax }), e2[2].setCoords({ xmin: t3.xmin, ymin: t3.ymin, xmax: s3, ymax: i2 }), e2[3].setCoords({ xmin: s3, ymin: t3.ymin, xmax: t3.xmax, ymax: i2 });
  }
  disconnectElementHandle_(t3) {
    const e2 = this.getQuad_(t3), s3 = this.getFirstElement_(e2), i2 = this.getLastElement_(e2), n5 = this.getPrevElement_(t3), r = this.getNextElement_(t3);
    s3 === t3 ? (-1 !== r ? this.setPrevElement_(r, -1) : this.setLastElement_(e2, -1), this.setFirstElement_(e2, r)) : i2 === t3 ? (this.setNextElement_(n5, -1), this.setLastElement_(e2, n5)) : (this.setPrevElement_(r, n5), this.setNextElement_(n5, r)), this.setPrevElement_(t3, -1), this.setNextElement_(t3, -1), this.setLocalElementCount_(e2, this.getLocalElementCount_(e2) - 1);
  }
  canFlush_(t3) {
    return this.getLocalElementCount_(t3) === __t.m_flushingCount && !this.hasChildren_(t3);
  }
  flush_(t3, e2, s3) {
    let i2;
    const n5 = new n3();
    let r = this.getFirstElement_(s3), h2 = -1, o = -1;
    do {
      o = this.getData_(r), i2 = this.getElementValue_(o), n5.setCoords({ env2D: this.getBoundingBoxValue_(o) }), h2 = this.getNextElement_(r), this.m_bStoreDuplicates ? this.insertDuplicates_(i2, n5, t3, e2, s3, true, r) : this.insert_(i2, n5, t3, e2, s3, true, r), r = h2;
    } while (-1 !== r);
  }
  canPushDown_(t3) {
    return this.getLocalElementCount_(t3) >= __t.m_flushingCount || this.hasChildren_(t3);
  }
  hasChildren_(t3) {
    return -1 !== this.getChild_(t3, 0) || -1 !== this.getChild_(t3, 1) || -1 !== this.getChild_(t3, 2) || -1 !== this.getChild_(t3, 3);
  }
  createChild_(t3, e2) {
    const s3 = this.m_quadTreeNodes.newElement();
    return this.setChild_(t3, e2, s3), this.setSubTreeElementCount_(s3, 0), this.setLocalElementCount_(s3, 0), this.setParent_(s3, t3), this.setHeightAndQuadrant_(s3, this.getHeight_(t3) + 1, e2), this.m_bStoreDuplicates && this.setContainedSubTreeElementCount_(s3, 0), s3;
  }
  createRoot_() {
    this.m_root = this.m_quadTreeNodes.newElement(), this.setSubTreeElementCount_(this.m_root, 0), this.setLocalElementCount_(this.m_root, 0), this.setHeightAndQuadrant_(this.m_root, 0, 0), this.m_bStoreDuplicates && this.setContainedSubTreeElementCount_(this.m_root, 0);
  }
  createElement_() {
    const t3 = this.m_elementNodes.newElement();
    let e2;
    return this.m_freeData.length > 0 ? (e2 = this.m_freeData.at(-1), this.m_freeData.pop()) : (e2 = this.m_data.length, this.m_data.length = e2 + 1), this.setData_(t3, e2), t3;
  }
  createElementFromDuplicate_(t3) {
    const e2 = this.m_elementNodes.newElement(), s3 = this.getData_(t3);
    return this.setData_(e2, s3), e2;
  }
  freeElementAndBoxNode_(t3) {
    n(0);
  }
  getChild_(t3, e2) {
    return this.m_quadTreeNodes.getField(t3, e2);
  }
  setChild_(t3, e2, s3) {
    this.m_quadTreeNodes.setField(t3, e2, s3);
  }
  getFirstElement_(t3) {
    return this.m_quadTreeNodes.getField(t3, 4);
  }
  setFirstElement_(t3, e2) {
    this.m_quadTreeNodes.setField(t3, 4, e2);
  }
  getLastElement_(t3) {
    return this.m_quadTreeNodes.getField(t3, 5);
  }
  setLastElement_(t3, e2) {
    this.m_quadTreeNodes.setField(t3, 5, e2);
  }
  getQuadrant_(t3) {
    return this.m_quadTreeNodes.getField(t3, 6) & __t.m_quadrantMask;
  }
  getHeight_(t3) {
    return this.m_quadTreeNodes.getField(t3, 6) >> __t.m_heightBitShift;
  }
  setHeightAndQuadrant_(t3, e2, s3) {
    const i2 = e2 << __t.m_heightBitShift | s3;
    this.m_quadTreeNodes.setField(t3, 6, i2);
  }
  getLocalElementCount_(t3) {
    return this.m_quadTreeNodes.getField(t3, 7);
  }
  setLocalElementCount_(t3, e2) {
    this.m_quadTreeNodes.setField(t3, 7, e2);
  }
  getSubTreeElementCount_(t3) {
    return this.m_quadTreeNodes.getField(t3, 8);
  }
  setSubTreeElementCount_(t3, e2) {
    this.m_quadTreeNodes.setField(t3, 8, e2);
  }
  getParent_(t3) {
    return this.m_quadTreeNodes.getField(t3, 9);
  }
  setParent_(t3, e2) {
    this.m_quadTreeNodes.setField(t3, 9, e2);
  }
  getContainedSubTreeElementCount_(t3) {
    return this.m_quadTreeNodes.getField(t3, 10);
  }
  setContainedSubTreeElementCount_(t3, e2) {
    this.m_quadTreeNodes.setField(t3, 10, e2);
  }
  getData_(t3) {
    return this.m_elementNodes.getField(t3, 0);
  }
  setData_(t3, e2) {
    this.m_elementNodes.setField(t3, 0, e2);
  }
  getPrevElement_(t3) {
    return this.m_elementNodes.getField(t3, 1);
  }
  getNextElement_(t3) {
    return this.m_elementNodes.getField(t3, 2);
  }
  setPrevElement_(t3, e2) {
    this.m_elementNodes.setField(t3, 1, e2);
  }
  setNextElement_(t3, e2) {
    this.m_elementNodes.setField(t3, 2, e2);
  }
  getQuad_(t3) {
    return this.m_elementNodes.getField(t3, 3);
  }
  setQuad_(t3, e2) {
    this.m_elementNodes.setField(t3, 3, e2);
  }
  getElementValue_(t3) {
    return this.m_data[t3].element;
  }
  getBoundingBoxValue_(t3) {
    return this.m_data[t3].box;
  }
  setDataValues_(t3, e2, s3) {
    this.m_data[t3] = mt(e2, s3);
  }
};
_t2.m_quadrantMask = 3, _t2.m_heightBitShift = 2, _t2.m_flushingCount = 5;
var lt = class {
  constructor(t3, e2, s3) {
    this.m_bLinear = false, this.m_queryStart = new mi(), this.m_queryEnd = new mi(), this.m_queryBox = new n3(), this.m_tolerance = 0, this.m_currentElementHandle = -1, this.m_nextElementHandle = -1, this.m_quadsStack = [], this.m_extentsStack = [], this.m_childExtents = [new n3(), new n3(), new n3(), new n3()], this.m_quadTree = t3, e2 && this.resetIterator(e2, s3);
  }
  resetIterator(t3, e2) {
    if (void 0 === e2 && (e2 = 0), t3 instanceof n3) return this.m_quadsStack.length = 0, this.m_extentsStack.length = 0, this.m_currentElementHandle = -1, this.m_queryBox.setCoords({ env2D: t3 }), this.m_queryBox.inflateCoords(e2, e2), this.m_tolerance = Number.NaN, void (-1 !== this.m_quadTree.m_root && this.m_queryBox.isIntersecting(this.m_quadTree.m_extent) ? (this.m_quadsStack.push(this.m_quadTree.m_root), this.m_extentsStack.push(this.m_quadTree.m_extent.clone()), this.m_nextElementHandle = this.m_quadTree.getFirstElement_(this.m_quadTree.m_root), this.m_bLinear = false) : this.m_nextElementHandle = -1);
    if (this.m_quadsStack.length = 0, this.m_extentsStack.length = 0, this.m_currentElementHandle = -1, t3.queryLooseEnvelope(this.m_queryBox), this.m_queryBox.inflateCoords(e2, e2), -1 !== this.m_quadTree.m_root && this.m_queryBox.isIntersecting(this.m_quadTree.m_extent)) {
      const s3 = t3.getGeometryType();
      if (this.m_bLinear = s3 === a.enumLine, this.m_bLinear) {
        const s4 = t3;
        this.m_queryStart.assign(s4.getStartXY()), this.m_queryEnd.assign(s4.getEndXY()), this.m_tolerance = e2;
      } else this.m_tolerance = Number.NaN;
      this.m_quadsStack.push(this.m_quadTree.m_root), this.m_extentsStack.push(this.m_quadTree.m_extent.clone()), this.m_nextElementHandle = this.m_quadTree.getFirstElement_(this.m_quadTree.m_root);
    } else this.m_nextElementHandle = -1;
  }
  next() {
    if (0 === this.m_quadsStack.length) return -1;
    this.m_currentElementHandle = this.m_nextElementHandle;
    const t3 = new mi(), e2 = new mi(), s3 = new n3();
    let i2 = false;
    for (; !i2; ) {
      for (; -1 !== this.m_currentElementHandle; ) {
        const n5 = this.m_quadTree.getData_(this.m_currentElementHandle);
        if (s3.setCoords({ env2D: this.m_quadTree.getBoundingBoxValue_(n5) }), s3.isIntersecting(this.m_queryBox)) {
          if (!this.m_bLinear) {
            i2 = true;
            break;
          }
          if (t3.setCoordsPoint2D(this.m_queryStart), e2.setCoordsPoint2D(this.m_queryEnd), s3.inflateCoords(this.m_tolerance, this.m_tolerance), s3.clipLine(t3, e2) > 0) {
            i2 = true;
            break;
          }
        }
        this.m_currentElementHandle = this.m_quadTree.getNextElement_(this.m_currentElementHandle);
      }
      if (-1 === this.m_currentElementHandle) {
        const s4 = this.m_quadsStack.at(-1), i3 = this.m_extentsStack.at(-1);
        _t2.setChildExtents_(i3, this.m_childExtents), this.m_quadsStack.pop(), this.m_extentsStack.pop();
        for (let n5 = 0; n5 < 4; n5++) {
          const i4 = this.m_quadTree.getChild_(s4, n5);
          if (-1 !== i4 && this.m_quadTree.getSubTreeElementCount(i4) > 0 && this.m_childExtents[n5].isIntersecting(this.m_queryBox)) if (this.m_bLinear) {
            t3.setCoordsPoint2D(this.m_queryStart), e2.setCoordsPoint2D(this.m_queryEnd);
            const s5 = new n3();
            s5.setCoords({ env2D: this.m_childExtents[n5] }), s5.inflateCoords(this.m_tolerance, this.m_tolerance), s5.clipLine(t3, e2) > 0 && (this.m_quadsStack.push(i4), this.m_extentsStack.push(this.m_childExtents[n5].clone()));
          } else this.m_quadsStack.push(i4), this.m_extentsStack.push(this.m_childExtents[n5].clone());
        }
        if (0 === this.m_quadsStack.length) return -1;
        this.m_currentElementHandle = this.m_quadTree.getFirstElement_(this.m_quadsStack.at(-1));
      }
    }
    return this.m_nextElementHandle = this.m_quadTree.getNextElement_(this.m_currentElementHandle), this.m_currentElementHandle;
  }
  clone() {
    return n(0), {};
  }
};
var ut = class {
  constructor(t3) {
    this.m_bucketSort = new ot(), this.m_sortedHandles = new st2(0), this.m_index = -1, this.m_quadTreeIteratorImpl = t3;
  }
  resetIterator(t3, e2) {
    this.m_quadTreeIteratorImpl.resetIterator(t3, e2), this.m_sortedHandles.resize(0), this.m_index = -1;
  }
  next() {
    if (-1 === this.m_index) {
      let t3 = -1;
      for (; -1 !== (t3 = this.m_quadTreeIteratorImpl.next()); ) this.m_sortedHandles.add(t3);
      const e2 = this, s3 = { userSort(t4, s4, i2) {
        i2.sort(t4, s4, (t5, s5) => e2.m_quadTreeIteratorImpl.m_quadTree.getElement(t5) - e2.m_quadTreeIteratorImpl.m_quadTree.getElement(s5));
      }, getValue: (t4) => e2.m_quadTreeIteratorImpl.m_quadTree.getElement(t4) };
      this.m_bucketSort.sort(this.m_sortedHandles, 0, this.m_sortedHandles.size(), s3);
    }
    return this.m_index === this.m_sortedHandles.size() - 1 ? -1 : (this.m_index++, this.m_sortedHandles.read(this.m_index));
  }
  clone() {
    return n(0), {};
  }
};
var dt = class {
  constructor(t3 = false) {
    this.m_bNotifyOnActions = t3;
  }
  onDelete(t3) {
  }
  onSet(t3) {
  }
  onEndSearch(t3) {
  }
  onAddUniqueElementFailed(t3) {
  }
  onDeleteImpl(t3, e2) {
    this.m_bNotifyOnActions && this.onDelete(t3.getElement(e2));
  }
  onSetImpl(t3, e2) {
    this.m_bNotifyOnActions && this.onSet(t3.getElement(e2));
  }
  onAddUniqueElementFailedImpl(t3) {
    this.m_bNotifyOnActions && this.onAddUniqueElementFailed(t3);
  }
  onEndSearchImpl(t3) {
    this.m_bNotifyOnActions && this.onEndSearch(t3);
  }
};
var ct2 = class _ct {
  static st_nullNode() {
    return -1;
  }
  constructor() {
    this.m_defaultTreap = -1, this.m_random = 124234251, this.m_comparator = null, this.m_treapData = new at(7), this.m_treapCount = 0, this.m_maxDepthEver = 0, this.m_bBalancing = true;
  }
  setComparator(t3) {
    this.m_comparator = t3;
  }
  getComparator() {
    return this.m_comparator;
  }
  disableBalancing() {
    this.m_bBalancing = false;
  }
  enableBalancing() {
    this.m_bBalancing || (n(this.m_treapCount <= 1), this.rebalance(-1), this.m_bBalancing = true);
  }
  isAutoBalancing() {
    return this.m_bBalancing;
  }
  rebalance(t3) {
    if (this.m_bBalancing) return;
    if (-1 === t3 && (t3 = this.m_defaultTreap), 0 === this.size(t3)) return;
    const e2 = [];
    for (let s3 = this.getFirst(t3); -1 !== s3; s3 = this.getNext(s3)) e2.push(s3), this.setParent_(s3, -1), this.setRight_(s3, -1), this.setLeft_(s3, -1);
    this.setRoot_(-1, t3), this.setFirst_(-1, t3), this.setLast_(-1, t3), this.setSize_(0, t3), this.m_bBalancing = true;
    for (const s3 of e2) this.addBiggestElement_(s3, t3);
    this.m_bBalancing = false;
  }
  setCapacity(t3) {
    this.m_treapData.setCapacity(t3);
  }
  createTreap(t3) {
    const e2 = this.m_treapData.newElement();
    return this.setSize_(0, e2), this.setTreapData_(t3, e2), this.m_treapCount++, e2;
  }
  deleteTreap(t3) {
    this.m_treapData.deleteElement(t3), this.m_treapCount--;
  }
  addElement(t3, e2 = -1) {
    return -1 === e2 && (this.m_defaultTreap === _ct.st_nullNode() && (this.m_defaultTreap = this.createTreap(-1)), e2 = this.m_defaultTreap), this.addElement_(t3, 0, e2);
  }
  addUniqueElement(t3, e2 = -1) {
    return -1 === e2 && (this.m_defaultTreap === _ct.st_nullNode() && (this.m_defaultTreap = this.createTreap(-1)), e2 = this.m_defaultTreap), this.addElement_(t3, 1, e2);
  }
  addBiggestElement(t3, e2 = -1) {
    -1 === e2 && (this.m_defaultTreap === _ct.st_nullNode() && (this.m_defaultTreap = this.createTreap(-1)), e2 = this.m_defaultTreap);
    const s3 = this.newNode_(t3);
    return this.addBiggestElement_(s3, e2), s3;
  }
  addElementAtPosition(t3, e2, s3, i2, n5, r = -1) {
    if (-1 === r && (this.m_defaultTreap === _ct.st_nullNode() && (this.m_defaultTreap = this.createTreap(-1)), r = this.m_defaultTreap), this.getRoot_(r) === _ct.st_nullNode()) {
      const t4 = this.newNode_(s3);
      return this.setRoot_(t4, r), this.addToList_(-1, t4, r), t4;
    }
    let h2, o, a2, m3, _;
    if (n5 ? (h2 = e2 !== _ct.st_nullNode() ? this.m_comparator.compare(this, s3, e2) : -1, o = t3 !== _ct.st_nullNode() ? this.m_comparator.compare(this, s3, t3) : 1) : (h2 = -1, o = 1), i2 && (0 === h2 || 0 === o)) {
      this.m_comparator.onAddUniqueElementFailedImpl(s3);
      const i3 = 0 === h2 ? e2 : t3;
      return this.setDuplicateElement_(i3, r), -1;
    }
    _ = e2 !== _ct.st_nullNode() && t3 !== _ct.st_nullNode() ? this.m_random > Ss(this.m_random) >> 1 : e2 !== _ct.st_nullNode(), _ ? (m3 = h2, a2 = e2) : (m3 = o, a2 = t3);
    let u = -1, d2 = -1, c = true;
    for (; ; ) {
      if (m3 < 0) {
        const t4 = this.getLeft(a2);
        if (t4 === _ct.st_nullNode()) {
          d2 = a2, u = this.newNode_(s3), this.setLeft_(a2, u), this.setParent_(u, a2);
          break;
        }
        a2 = t4;
      } else {
        const t4 = this.getRight(a2);
        if (t4 === _ct.st_nullNode()) {
          d2 = this.getNext(a2), u = this.newNode_(s3), this.setRight_(a2, u), this.setParent_(u, a2);
          break;
        }
        a2 = t4;
      }
      c && (m3 *= -1, c = false);
    }
    return this.bubbleUp_(u), this.getParent(u) === _ct.st_nullNode() && this.setRoot_(u, r), this.addToList_(d2, u, r), u;
  }
  replaceElementAtPosition(t3, e2, s3, i2, n5 = -1) {
    if (i2) {
      const i3 = this.getNext(t3);
      let r = -1;
      i3 !== _ct.st_nullNode() && (r = this.m_comparator.compare(this, e2, i3));
      const h2 = this.getPrev(t3);
      let o = -1;
      if (h2 !== _ct.st_nullNode() && (o = this.m_comparator.compare(this, e2, h2)), s3 && (0 === r || 0 === o)) {
        this.m_comparator.onAddUniqueElementFailedImpl(e2);
        const t4 = 0 === r ? i3 : h2;
        return n5 === _ct.st_nullNode() && (this.m_defaultTreap === _ct.st_nullNode() && (this.m_defaultTreap = this.createTreap(-1)), n5 = this.m_defaultTreap), this.setDuplicateElement_(t4, n5), -1;
      }
    }
    return this.setElement_(t3, e2), t3;
  }
  getDuplicateElement(t3 = -1) {
    return -1 === t3 ? this.getDuplicateElement_(this.m_defaultTreap) : this.getDuplicateElement_(t3);
  }
  deleteNode(t3, e2 = -1) {
    this.m_comparator && this.m_comparator.onDeleteImpl(this, t3), -1 === e2 && (e2 = this.m_defaultTreap), this.m_bBalancing ? this.deleteNode_(t3, e2) : this.unbalancedDelete_(t3, e2);
  }
  search(t3, e2 = -1) {
    let s3 = this.getRoot(e2);
    for (; s3 !== _ct.st_nullNode(); ) {
      const e3 = this.m_comparator.compare(this, t3, s3);
      if (!e3) return s3;
      s3 = e3 < 0 ? this.getLeft(s3) : this.getRight(s3);
    }
    return this.m_comparator.onEndSearchImpl(t3), _ct.st_nullNode();
  }
  searchLowerBound(t3, e2 = -1) {
    let s3 = this.getRoot(e2), i2 = -1;
    for (; s3 !== _ct.st_nullNode(); ) {
      const e3 = t3.compare(this, s3);
      if (!e3) return s3;
      e3 < 0 ? s3 = this.getLeft(s3) : (i2 = s3, s3 = this.getRight(s3));
    }
    return i2;
  }
  searchUpperBound(t3, e2 = -1) {
    let s3 = this.getRoot(e2), i2 = -1;
    for (; s3 !== _ct.st_nullNode(); ) {
      const e3 = t3.compare(this, s3);
      if (!e3) return s3;
      e3 < 0 ? (i2 = s3, s3 = this.getLeft(s3)) : s3 = this.getRight(s3);
    }
    return i2;
  }
  getElement(t3) {
    return this.m_treapData.getField(t3, 3);
  }
  getLeft(t3) {
    return this.m_treapData.getField(t3, 0);
  }
  getRight(t3) {
    return this.m_treapData.getField(t3, 1);
  }
  getParent(t3) {
    return this.m_treapData.getField(t3, 2);
  }
  getNext(t3) {
    return this.m_treapData.getField(t3, 6);
  }
  getPrev(t3) {
    return this.m_treapData.getField(t3, 5);
  }
  getFirst(t3 = -1) {
    return -1 === t3 ? this.getFirst_(this.m_defaultTreap) : this.getFirst_(t3);
  }
  getLast(t3 = -1) {
    return -1 === t3 ? this.getLast_(this.m_defaultTreap) : this.getLast_(t3);
  }
  getTreapData(t3 = -1) {
    return -1 === t3 ? this.getTreapData_(this.m_defaultTreap) : this.getTreapData_(t3);
  }
  setElement(t3, e2) {
    null !== this.m_comparator && this.m_comparator.onSetImpl(this, t3), this.setElement_(t3, e2);
  }
  getRoot(t3 = -1) {
    return -1 === t3 ? this.getRoot_(this.m_defaultTreap) : this.getRoot_(t3);
  }
  clear() {
    this.m_treapData.deleteAll(false), this.m_defaultTreap = _ct.st_nullNode(), this.m_treapCount = 0, this.m_maxDepthEver = 0;
  }
  addToList_(t3, e2, s3) {
    let i2;
    -1 !== t3 ? (i2 = this.getPrev(t3), this.setPrev_(t3, e2)) : i2 = this.getLast_(s3), this.setPrev_(e2, i2), -1 !== i2 && this.setNext_(i2, e2), this.setNext_(e2, t3), t3 === this.getFirst_(s3) && this.setFirst_(e2, s3), -1 === t3 && this.setLast_(e2, s3), this.setSize_(this.getSize_(s3) + 1, s3);
  }
  size(t3 = -1) {
    return -1 === t3 ? this.getSize_(this.m_defaultTreap) : this.getSize_(t3);
  }
  getMaxDepth(t3 = -1) {
    return this.getMaxDepthHelper_(this.getRoot(t3));
  }
  getMaxDepthEver() {
    return this.m_maxDepthEver;
  }
  static st_isValidNode(t3) {
    return at.isValidElement(t3);
  }
  dbgCheck_(t3) {
  }
  getPriority_(t3) {
    return this.m_treapData.getField(t3, 4);
  }
  bubbleDown_(t3) {
    let e2 = this.getLeft(t3), s3 = this.getRight(t3);
    const i2 = this.getPriority_(t3);
    for (; e2 !== _ct.st_nullNode() || s3 !== _ct.st_nullNode(); ) {
      const n5 = e2 !== _ct.st_nullNode() ? this.getPriority_(e2) : vs(), r = s3 !== _ct.st_nullNode() ? this.getPriority_(s3) : vs();
      if (i2 <= Math.min(n5, r)) return;
      n5 <= r ? this.rotateRight_(e2) : this.rotateLeft_(t3), e2 = this.getLeft(t3), s3 = this.getRight(t3);
    }
  }
  bubbleUp_(t3) {
    if (!this.m_bBalancing) return;
    const e2 = this.getPriority_(t3);
    let s3 = this.getParent(t3);
    for (; s3 !== _ct.st_nullNode() && this.getPriority_(s3) > e2; ) this.getLeft(s3) === t3 ? this.rotateRight_(t3) : this.rotateLeft_(s3), s3 = this.getParent(t3);
  }
  rotateLeft_(t3) {
    const e2 = t3, s3 = this.getRight(t3);
    let i2;
    this.setParent_(s3, this.getParent(e2)), this.setParent_(e2, s3), i2 = this.getLeft(s3), this.setRight_(e2, i2), i2 !== _ct.st_nullNode() && this.setParent_(i2, e2), this.setLeft_(s3, e2), i2 = this.getParent(s3), i2 !== _ct.st_nullNode() && (this.getLeft(i2) === e2 ? this.setLeft_(i2, s3) : this.setRight_(i2, s3));
  }
  rotateRight_(t3) {
    const e2 = this.getParent(t3), s3 = t3;
    let i2;
    this.setParent_(s3, this.getParent(e2)), this.setParent_(e2, s3), i2 = this.getRight(s3), this.setLeft_(e2, i2), i2 !== _ct.st_nullNode() && this.setParent_(i2, e2), this.setRight_(s3, e2), i2 = this.getParent(s3), i2 !== _ct.st_nullNode() && (this.getLeft(i2) === e2 ? this.setLeft_(i2, s3) : this.setRight_(i2, s3));
  }
  setParent_(t3, e2) {
    this.m_treapData.setField(t3, 2, e2);
  }
  setLeft_(t3, e2) {
    this.m_treapData.setField(t3, 0, e2);
  }
  setRight_(t3, e2) {
    this.m_treapData.setField(t3, 1, e2);
  }
  setPriority_(t3, e2) {
    this.m_treapData.setField(t3, 4, e2);
  }
  setPrev_(t3, e2) {
    this.m_treapData.setField(t3, 5, e2);
  }
  setNext_(t3, e2) {
    this.m_treapData.setField(t3, 6, e2);
  }
  setRoot_(t3, e2) {
    this.m_treapData.setField(e2, 0, t3);
  }
  setFirst_(t3, e2) {
    this.m_treapData.setField(e2, 1, t3);
  }
  setLast_(t3, e2) {
    this.m_treapData.setField(e2, 2, t3);
  }
  setDuplicateElement_(t3, e2) {
    this.m_treapData.setField(e2, 3, t3);
  }
  setSize_(t3, e2) {
    this.m_treapData.setField(e2, 4, t3);
  }
  setTreapData_(t3, e2) {
    this.m_treapData.setField(e2, 5, t3);
  }
  getRoot_(t3) {
    return -1 === t3 ? _ct.st_nullNode() : this.m_treapData.getField(t3, 0);
  }
  getFirst_(t3) {
    return -1 === t3 ? _ct.st_nullNode() : this.m_treapData.getField(t3, 1);
  }
  getLast_(t3) {
    return -1 === t3 ? _ct.st_nullNode() : this.m_treapData.getField(t3, 2);
  }
  getDuplicateElement_(t3) {
    return -1 === t3 ? _ct.st_nullNode() : this.m_treapData.getField(t3, 3);
  }
  getSize_(t3) {
    return -1 === t3 ? 0 : this.m_treapData.getField(t3, 4);
  }
  getTreapData_(t3) {
    return this.m_treapData.getField(t3, 5);
  }
  newNode_(t3) {
    const e2 = this.m_treapData.newElement();
    return this.setPriority_(e2, this.generatePriority_()), this.setElement_(e2, t3), e2;
  }
  freeNode_(t3, e2) {
    t3 !== _ct.st_nullNode() && this.m_treapData.deleteElement(t3);
  }
  generatePriority_() {
    return this.m_random = Ss(this.m_random), this.m_random & vs() >> 1;
  }
  maxPriority() {
    return n(0), 0;
  }
  getMaxDepthHelper_(t3) {
    return t3 === _ct.st_nullNode() ? 0 : 1 + Math.max(this.getMaxDepthHelper_(this.getLeft(t3)), this.getMaxDepthHelper_(this.getRight(t3)));
  }
  addElement_(t3, e2, s3) {
    if (this.getRoot(s3) === _ct.st_nullNode()) {
      const e3 = this.newNode_(t3);
      return this.setRoot_(e3, s3), this.addToList_(-1, e3, s3), this.m_maxDepthEver = Math.max(this.m_maxDepthEver, 1), e3;
    }
    let i2 = this.getRoot_(s3), n5 = -1, r = -1, h2 = 1;
    for (; ; ) {
      const o = -1 === e2 ? 1 : this.m_comparator.compare(this, t3, i2);
      if (o < 0) {
        const e3 = this.getLeft(i2);
        if (e3 === _ct.st_nullNode()) {
          r = i2, n5 = this.newNode_(t3), this.setLeft_(i2, n5), this.setParent_(n5, i2);
          break;
        }
        i2 = e3;
      } else {
        if (1 === e2 && 0 === o) return this.m_comparator.onAddUniqueElementFailedImpl(t3), this.setDuplicateElement_(i2, s3), -1;
        const h3 = this.getRight(i2);
        if (h3 === _ct.st_nullNode()) {
          r = this.getNext(i2), n5 = this.newNode_(t3), this.setRight_(i2, n5), this.setParent_(n5, i2);
          break;
        }
        i2 = h3;
      }
      h2++;
    }
    return this.bubbleUp_(n5), this.getParent(n5) === _ct.st_nullNode() && this.setRoot_(n5, s3), this.addToList_(r, n5, s3), this.m_maxDepthEver = Math.max(h2, this.m_maxDepthEver), n5;
  }
  removeFromList_(t3, e2) {
    const s3 = this.getPrev(t3), i2 = this.getNext(t3);
    -1 !== s3 ? this.setNext_(s3, i2) : this.setFirst_(i2, e2), -1 !== i2 ? this.setPrev_(i2, s3) : this.setLast_(s3, e2), this.setSize_(this.getSize_(e2) - 1, e2);
  }
  unbalancedDelete_(t3, e2) {
    this.removeFromList_(t3, e2);
    let s3 = this.getLeft(t3), i2 = this.getRight(t3), n5 = this.getParent(t3), r = t3;
    if (-1 !== s3 && -1 !== i2) {
      let h3;
      this.m_random = Ss(this.m_random), h3 = this.m_random > vs() >> 1 ? this.getNext(t3) : this.getPrev(t3);
      const o = this.getParent(h3) === t3;
      this.m_treapData.swapField(t3, h3, 0), this.m_treapData.swapField(t3, h3, 1), this.m_treapData.swapField(t3, h3, 2), -1 !== n5 ? this.getLeft(n5) === t3 ? this.setLeft_(n5, h3) : this.setRight_(n5, h3) : this.setRoot_(h3, e2), o ? (s3 === h3 ? (this.setLeft_(h3, t3), this.setParent_(i2, h3)) : i2 === h3 && (this.setRight_(h3, t3), this.setParent_(s3, h3)), this.setParent_(t3, h3), n5 = h3) : (this.setParent_(s3, h3), this.setParent_(i2, h3), n5 = this.getParent(t3), r = h3), s3 = this.getLeft(t3), i2 = this.getRight(t3), -1 !== s3 && this.setParent_(s3, t3), -1 !== i2 && this.setParent_(i2, t3);
    }
    const h2 = -1 !== s3 ? s3 : i2;
    -1 === n5 ? this.setRoot_(h2, e2) : this.getLeft(n5) === r ? this.setLeft_(n5, h2) : this.setRight_(n5, h2), -1 !== h2 && this.setParent_(h2, n5), this.freeNode_(t3, e2);
  }
  deleteNode_(t3, e2) {
    this.setPriority_(t3, vs());
    let s3 = _ct.st_nullNode(), i2 = _ct.st_nullNode();
    const n5 = this.getRoot_(e2), r = n5 === t3;
    if (r && (s3 = this.getLeft(n5), i2 = this.getRight(n5), s3 === _ct.st_nullNode() && i2 === _ct.st_nullNode())) return this.removeFromList_(n5, e2), this.freeNode_(n5, e2), void this.setRoot_(_ct.st_nullNode(), e2);
    this.bubbleDown_(t3);
    const h2 = this.getParent(t3);
    h2 !== _ct.st_nullNode() && (this.getLeft(h2) === t3 ? this.setLeft_(h2, _ct.st_nullNode()) : this.setRight_(h2, _ct.st_nullNode())), this.removeFromList_(t3, e2), this.freeNode_(t3, e2), r && this.setRoot_(s3 === _ct.st_nullNode() || this.getParent(s3) !== _ct.st_nullNode() ? i2 : s3, e2);
  }
  setElement_(t3, e2) {
    this.m_treapData.setField(t3, 3, e2);
  }
  addBiggestElement_(t3, e2) {
    if (this.getRoot_(e2) === _ct.st_nullNode()) return this.setRoot_(t3, e2), void this.addToList_(-1, t3, e2);
    const s3 = this.getLast_(e2);
    this.setRight_(s3, t3), this.setParent_(t3, s3), this.bubbleUp_(t3), this.getParent(t3) === _ct.st_nullNode() && this.setRoot_(t3, e2), this.addToList_(-1, t3, e2);
  }
};
var pt = class _pt {
  constructor(t3) {
    this.m_lists = new at(6), this.m_listOfLists = _pt.st_nullNode(), void 0 === t3 ? (this.m_listNodes = new at(3), this.m_bStoreListIndexWithNode = false) : (this.m_listNodes = new at(t3 ? 4 : 3), this.m_bStoreListIndexWithNode = t3);
  }
  freeNode_(t3) {
    this.m_listNodes.deleteElement(t3);
  }
  newNode_() {
    return this.m_listNodes.newElement();
  }
  freeList_(t3) {
    n(0);
  }
  newList_() {
    return this.m_lists.newElement();
  }
  setPrev_(t3, e2) {
    this.m_listNodes.setField(t3, 1, e2);
  }
  setNext_(t3, e2) {
    this.m_listNodes.setField(t3, 2, e2);
  }
  setData_(t3, e2) {
    n(0);
  }
  setList_(t3, e2) {
    return this.m_listNodes.setField(t3, 3, e2);
  }
  setListSize_(t3, e2) {
    this.m_lists.setField(t3, 4, e2);
  }
  setNextList_(t3, e2) {
    n(0);
  }
  setPrevList_(t3, e2) {
    this.m_lists.setField(t3, 2, e2);
  }
  createList(t3) {
    const e2 = this.newList_();
    return this.m_lists.setField(e2, 3, this.m_listOfLists), this.m_lists.setField(e2, 4, 0), this.m_lists.setField(e2, 5, t3), this.m_listOfLists !== _pt.st_nullNode() && this.setPrevList_(this.m_listOfLists, e2), this.m_listOfLists = e2, e2;
  }
  deleteList(t3) {
    this.clear(t3);
    const e2 = this.m_lists.getField(t3, 2), s3 = this.m_lists.getField(t3, 3);
    return e2 !== _pt.st_nullNode() ? this.setNextList_(e2, s3) : this.m_listOfLists = s3, s3 !== _pt.st_nullNode() && this.setPrevList_(s3, e2), this.freeList_(t3), s3;
  }
  reserveLists(t3) {
    n(0);
  }
  getListData(t3) {
    return this.m_lists.getField(t3, 5);
  }
  getList(t3) {
    return n(0), 0;
  }
  setListData(t3, e2) {
    this.m_lists.setField(t3, 5, e2);
  }
  addElement(t3, e2) {
    return this.insertElement(t3, -1, e2);
  }
  insertElement(t3, e2, s3) {
    const i2 = this.newNode_();
    let n5 = -1;
    e2 !== _pt.st_nullNode() && (n5 = this.getPrev(e2), this.setPrev_(e2, i2)), this.setNext_(i2, e2), n5 !== _pt.st_nullNode() && this.setNext_(n5, i2);
    if (e2 === this.m_lists.getField(t3, 0) && this.m_lists.setField(t3, 0, i2), e2 === _pt.st_nullNode()) {
      const e3 = this.m_lists.getField(t3, 1);
      this.setPrev_(i2, e3), -1 !== e3 && this.setNext_(e3, i2), this.m_lists.setField(t3, 1, i2);
    }
    return this.setData(i2, s3), this.setListSize_(t3, this.getListSize(t3) + 1), this.m_bStoreListIndexWithNode && this.setList_(i2, t3), i2;
  }
  deleteElement(t3, e2) {
    const s3 = this.getPrev(e2), i2 = this.getNext(e2);
    return s3 !== _pt.st_nullNode() ? this.setNext_(s3, i2) : this.m_lists.setField(t3, 0, i2), i2 !== _pt.st_nullNode() ? this.setPrev_(i2, s3) : this.m_lists.setField(t3, 1, s3), this.freeNode_(e2), this.setListSize_(t3, this.getListSize(t3) - 1), i2;
  }
  reserveNodes(t3) {
    this.m_listNodes.setCapacity(t3);
  }
  getData(t3) {
    return this.m_listNodes.getField(t3, 0);
  }
  getElement(t3) {
    return this.getData(t3);
  }
  setData(t3, e2) {
    this.m_listNodes.setField(t3, 0, e2);
  }
  getNext(t3) {
    return this.m_listNodes.getField(t3, 2);
  }
  getPrev(t3) {
    return this.m_listNodes.getField(t3, 1);
  }
  getFirst(t3) {
    return this.m_lists.getField(t3, 0);
  }
  getLast(t3) {
    return this.m_lists.getField(t3, 1);
  }
  static st_nullNode() {
    return -1;
  }
  clear(t3) {
    if (void 0 !== t3) {
      let e2 = this.getLast(t3);
      for (; e2 !== _pt.st_nullNode(); ) {
        const t4 = e2;
        e2 = this.getPrev(t4), this.freeNode_(t4);
      }
      return this.m_lists.setField(t3, 0, -1), this.m_lists.setField(t3, 1, -1), void this.setListSize_(t3, 0);
    }
    for (let e2 = this.getFirstList(); -1 !== e2; ) e2 = this.deleteList(e2);
  }
  isEmpty(t3) {
    return n(0), false;
  }
  getNodeCount() {
    return this.m_listNodes.size();
  }
  getListCount() {
    return this.m_lists.size();
  }
  getListSize(t3) {
    return this.m_lists.getField(t3, 4);
  }
  getFirstList() {
    return this.m_listOfLists;
  }
  getNextList(t3) {
    return this.m_lists.getField(t3, 3);
  }
};
var gt2 = class extends dt {
  constructor(t3) {
    super(), this.m_intervalTree = t3;
  }
  compare(t3, e2, s3) {
    const i2 = t3.getElement(s3), n5 = this.m_intervalTree.getValue_(e2), r = this.m_intervalTree.getValue_(i2);
    return n5 < r ? -1 : n5 === r ? ft2.isLeft_(e2) && ft2.isRight_(i2) ? -1 : ft2.isLeft_(i2) && ft2.isRight_(e2) ? 1 : 0 : 1;
  }
};
var ft2 = class _ft {
  constructor(t3) {
    this.m_bEnvelopesRef = false, this.m_intervals = [], this.m_envelopesRef = null, this.m_intervalNodes = new at(3), this.m_intervalHandles = [], this.m_endIndicesUnique = [], this.m_cCount = -1, this.m_root = -1, this.m_bSortIntervals = false, this.m_bConstructing = false, this.m_bConstructionEnded = false, this.m_bOfflineDynamic = t3, this.m_tertiaryNodes = new at(this.m_bOfflineDynamic ? 5 : 4), this.m_secondaryTreaps = new ct2(), this.m_secondaryTreaps.setComparator(new gt2(this)), this.m_secondaryLists = new pt();
  }
  addEnvelopesRef(t3) {
    this.reset_(true, true), this.m_bEnvelopesRef = true, this.m_envelopesRef = t3, this.m_bConstructing = false, this.m_bConstructionEnded = true, this.m_bOfflineDynamic || (this.insertIntervalsStatic_(), this.m_cCount = this.m_envelopesRef.length);
  }
  startConstruction() {
    this.reset_(true, false);
  }
  addInterval(t3) {
    this.m_bConstructing || C(""), this.m_intervals.push(t3.clone());
  }
  addIntervalCoords(t3, e2) {
    n(0);
  }
  endConstruction() {
    this.m_bConstructing || C(""), this.m_bConstructing = false, this.m_bConstructionEnded = true, this.m_bOfflineDynamic || (this.insertIntervalsStatic_(), this.m_cCount = this.m_intervals.length);
  }
  insert(t3) {
    if (this.m_bOfflineDynamic && this.m_bConstructionEnded || C(""), -1 === this.m_root) {
      const t4 = this.m_bEnvelopesRef ? this.m_envelopesRef.length : this.m_intervals.length;
      if (this.m_bSortIntervals) {
        const e3 = new st2(0);
        this.querySortedEndPointIndices_(e3), this.m_endIndicesUnique.length = 0, this.querySortedDuplicatesRemoved_(e3), this.m_intervalHandles.length = t4, this.m_intervalHandles.fill(-1), this.m_bSortIntervals = false;
      } else this.m_intervalHandles.fill(-1, 0, t4);
      this.m_root = this.createRoot_();
    }
    const e2 = this.insertIntervalEnd_(t3 << 1, this.m_root), s3 = this.getSecondaryFromInterval_(e2), i2 = this.m_secondaryTreaps.addElement(1 + (t3 << 1), s3);
    this.setRightEnd_(e2, i2), this.m_intervalHandles[t3] = e2, this.m_cCount++;
  }
  remove(t3) {
    this.m_bOfflineDynamic && this.m_bConstructionEnded || C("");
    const e2 = this.m_intervalHandles[t3];
    let s3;
    -1 === e2 && P("the interval does not exist in the interval tree"), this.m_intervalHandles[t3] = -1, this.m_cCount--;
    let i2 = this.getSecondaryFromInterval_(e2), n5 = -1;
    n5 = this.m_secondaryTreaps.getTreapData(i2), this.m_secondaryTreaps.deleteNode(this.getLeftEnd_(e2), i2), this.m_secondaryTreaps.deleteNode(this.getRightEnd_(e2), i2), s3 = this.m_secondaryTreaps.size(i2), 0 === s3 && (this.m_secondaryTreaps.deleteTreap(i2), this.setSecondaryToTertiary_(n5, -1)), this.m_intervalNodes.deleteElement(e2);
    let r = this.getPptr_(n5), h2 = this.getLptr_(n5), o = this.getRptr_(n5);
    for (; !(s3 > 0 || n5 === this.m_root || -1 !== h2 && -1 !== o); ) n5 === this.getLptr_(r) ? -1 !== h2 ? (this.setLptr_(r, h2), this.setPptr_(h2, r), this.setLptr_(n5, -1), this.setPptr_(n5, -1)) : -1 !== o ? (this.setLptr_(r, o), this.setPptr_(o, r), this.setRptr_(n5, -1), this.setPptr_(n5, -1)) : (this.setLptr_(r, -1), this.setPptr_(n5, -1)) : -1 !== h2 ? (this.setRptr_(r, h2), this.setPptr_(h2, r), this.setLptr_(n5, -1), this.setPptr_(n5, -1)) : -1 !== o ? (this.setRptr_(r, o), this.setPptr_(o, r), this.setRptr_(n5, -1), this.setPptr_(n5, -1)) : (this.setRptr_(r, -1), this.setPptr_(n5, -1)), this.m_tertiaryNodes.deleteElement(n5), n5 = r, i2 = this.getSecondaryFromTertiary_(n5), s3 = -1 !== i2 ? this.m_secondaryTreaps.size(i2) : 0, h2 = this.getLptr_(n5), o = this.getRptr_(n5), r = this.getPptr_(n5);
  }
  size() {
    return this.m_cCount;
  }
  getIteratorQuery(t3, e2) {
    return t3 instanceof x2 ? new vt2(this, t3, e2) : (n(0), {});
  }
  getIterator() {
    return new vt2(this);
  }
  querySortedEndPointIndices_(t3) {
    const e2 = this.m_bEnvelopesRef ? this.m_envelopesRef.length : this.m_intervals.length;
    for (let s3 = 0; s3 < 2 * e2; s3++) t3.add(s3);
    this.sortEndIndices_(t3, 0, 2 * e2);
  }
  querySortedDuplicatesRemoved_(t3) {
    let e2 = Number.NaN;
    for (let s3 = 0; s3 < t3.size(); s3++) {
      const i2 = t3.read(s3), n5 = this.getValue_(i2);
      n5 !== e2 && (this.m_endIndicesUnique.push(i2), e2 = n5);
    }
  }
  insertIntervalsStatic_() {
    const t3 = this.m_bEnvelopesRef ? this.m_envelopesRef.length : this.m_intervals.length, s3 = new st2(0);
    this.querySortedEndPointIndices_(s3), this.m_endIndicesUnique.length = 0, this.querySortedDuplicatesRemoved_(s3), this.m_intervalNodes.setCapacity(t3), this.m_secondaryLists.reserveNodes(2 * t3);
    const i2 = Yt(t3, -1);
    this.m_root = this.createRoot_();
    for (let e2 = 0; e2 < s3.size(); e2++) {
      const t4 = s3.read(e2);
      let n5 = i2[t4 >> 1];
      if (-1 !== n5) {
        const e3 = this.getSecondaryFromInterval_(n5);
        this.setRightEnd_(n5, this.m_secondaryLists.addElement(e3, t4));
      } else n5 = this.insertIntervalEnd_(t4, this.m_root), i2[t4 >> 1] = n5;
    }
  }
  createRoot_() {
    const t3 = this.calculateDiscriminantIndex1_(0, this.m_endIndicesUnique.length - 1);
    return this.createTertiaryNode_(t3);
  }
  insertIntervalEnd_(t3, e2) {
    let s3 = -1, i2 = e2, n5 = -1, r = -1, h2 = 0, o = this.m_endIndicesUnique.length - 1, a2 = 0;
    const m3 = t3 >> 1;
    let _ = Number.NaN, l2 = Number.NaN, u = true;
    const d2 = this.getMin_(m3), c = this.getMax_(m3);
    let p3 = -1;
    for (; u; ) {
      a2 = h2 + (o - h2 >> 1), p3 = this.calculateDiscriminantIndex1_(h2, o);
      const e3 = this.getDiscriminantFromIndex1_(p3);
      if (c < e3) {
        if (-1 !== i2) {
          if (p3 === this.getDiscriminantIndex1_(i2)) s3 = i2, _ = e3, i2 = this.getLptr_(i2), l2 = -1 !== i2 ? this.getDiscriminant_(i2) : Number.NaN;
          else if (l2 > e3) {
            const t4 = this.createTertiaryNode_(p3);
            e3 < _ ? this.setLptr_(s3, t4) : this.setRptr_(s3, t4), this.setRptr_(t4, i2), this.m_bOfflineDynamic && (this.setPptr_(t4, s3), this.setPptr_(i2, t4)), s3 = t4, _ = e3, i2 = -1, l2 = Number.NaN;
          }
        }
        o = a2;
        continue;
      }
      if (d2 > e3) {
        if (-1 !== i2) {
          if (p3 === this.getDiscriminantIndex1_(i2)) s3 = i2, _ = e3, i2 = this.getRptr_(i2), l2 = -1 !== i2 ? this.getDiscriminant_(i2) : Number.NaN;
          else if (l2 < e3) {
            const t4 = this.createTertiaryNode_(p3);
            e3 < _ ? this.setLptr_(s3, t4) : this.setRptr_(s3, t4), this.setLptr_(t4, i2), this.m_bOfflineDynamic && (this.setPptr_(t4, s3), this.setPptr_(i2, t4)), s3 = t4, _ = e3, i2 = -1, l2 = Number.NaN;
          }
        }
        h2 = a2 + 1;
        continue;
      }
      let m4 = -1;
      m4 = -1 === i2 || p3 !== this.getDiscriminantIndex1_(i2) ? this.createTertiaryNode_(p3) : i2, n5 = this.getSecondaryFromTertiary_(m4), -1 === n5 && (n5 = this.createSecondary_(m4), this.setSecondaryToTertiary_(m4, n5));
      const g2 = this.addEndIndex_(n5, t3);
      r = this.createIntervalNode_(), this.setSecondaryToInterval_(r, n5), this.setLeftEnd_(r, g2), -1 !== i2 && p3 === this.getDiscriminantIndex1_(i2) || (e3 < _ ? this.setLptr_(s3, m4) : this.setRptr_(s3, m4), this.m_bOfflineDynamic && this.setPptr_(m4, s3), -1 !== i2 && (l2 < e3 ? this.setLptr_(m4, i2) : this.setRptr_(m4, i2), this.m_bOfflineDynamic && this.setPptr_(i2, m4))), u = false;
      break;
    }
    return r;
  }
  createTertiaryNode_(t3) {
    const e2 = this.m_tertiaryNodes.newElement();
    return this.setDiscriminantIndex1_(e2, t3), e2;
  }
  createSecondary_(t3) {
    return this.m_bOfflineDynamic ? this.m_secondaryTreaps.createTreap(t3) : this.m_secondaryLists.createList(t3);
  }
  createIntervalNode_() {
    return this.m_intervalNodes.newElement();
  }
  reset() {
    this.m_bOfflineDynamic && this.m_bConstructionEnded || C(""), this.reset_(false, this.m_bEnvelopesRef);
  }
  reset_(t3, e2) {
    t3 ? (this.m_bEnvelopesRef = false, this.m_envelopesRef = null, this.m_bSortIntervals = true, this.m_bConstructing = true, this.m_bConstructionEnded = false, this.m_endIndicesUnique.length = 0, e2 ? (this.m_intervals.length = 0, this.m_bEnvelopesRef = true) : this.m_intervals.length = 0) : this.m_bSortIntervals = false, this.m_bOfflineDynamic ? this.m_secondaryTreaps.clear() : this.m_secondaryLists.clear(), this.m_intervalNodes.deleteAll(false), this.m_tertiaryNodes.deleteAll(false), this.m_root = -1, this.m_cCount = 0;
  }
  getDiscriminant_(t3) {
    const e2 = this.getDiscriminantIndex1_(t3);
    return this.getDiscriminantFromIndex1_(e2);
  }
  getDiscriminantFromIndex1_(t3) {
    if (-1 === t3) return Number.NaN;
    if (t3 > 0) {
      const e3 = t3 - 2, s4 = this.m_endIndicesUnique[e3], i2 = this.m_endIndicesUnique[e3 + 1];
      return 0.5 * (this.getValue_(s4) + this.getValue_(i2));
    }
    const e2 = -t3 - 2, s3 = this.m_endIndicesUnique[e2];
    return this.getValue_(s3);
  }
  calculateDiscriminantIndex1_(t3, e2) {
    let s3;
    if (t3 < e2) {
      s3 = t3 + (e2 - t3 >> 1) + 2;
    } else s3 = -(t3 + 2);
    return s3;
  }
  setDiscriminantIndex1_(t3, e2) {
    this.m_tertiaryNodes.setField(t3, 0, e2);
  }
  setSecondaryToTertiary_(t3, e2) {
    this.m_tertiaryNodes.setField(t3, 1, e2);
  }
  setLptr_(t3, e2) {
    this.m_tertiaryNodes.setField(t3, 2, e2);
  }
  setRptr_(t3, e2) {
    this.m_tertiaryNodes.setField(t3, 3, e2);
  }
  setPptr_(t3, e2) {
    this.m_tertiaryNodes.setField(t3, 4, e2);
  }
  setSecondaryToInterval_(t3, e2) {
    this.m_intervalNodes.setField(t3, 0, e2);
  }
  addEndIndex_(t3, e2) {
    let s3 = -1;
    return s3 = this.m_bOfflineDynamic ? this.m_secondaryTreaps.addElement(e2, t3) : this.m_secondaryLists.addElement(t3, e2), s3;
  }
  setLeftEnd_(t3, e2) {
    this.m_intervalNodes.setField(t3, 1, e2);
  }
  setRightEnd_(t3, e2) {
    this.m_intervalNodes.setField(t3, 2, e2);
  }
  getFirst_(t3) {
    return this.m_bOfflineDynamic ? this.m_secondaryTreaps.getFirst(t3) : this.m_secondaryLists.getFirst(t3);
  }
  getLast_(t3) {
    return this.m_bOfflineDynamic ? this.m_secondaryTreaps.getLast(t3) : this.m_secondaryLists.getLast(t3);
  }
  static isLeft_(t3) {
    return !(1 & t3);
  }
  static isRight_(t3) {
    return !(1 & ~t3);
  }
  getDiscriminantIndex1_(t3) {
    return this.m_tertiaryNodes.getField(t3, 0);
  }
  getSecondaryFromTertiary_(t3) {
    return this.m_tertiaryNodes.getField(t3, 1);
  }
  getLptr_(t3) {
    return this.m_tertiaryNodes.getField(t3, 2);
  }
  getRptr_(t3) {
    return this.m_tertiaryNodes.getField(t3, 3);
  }
  getPptr_(t3) {
    return this.m_tertiaryNodes.getField(t3, 4);
  }
  getSecondaryFromInterval_(t3) {
    return this.m_intervalNodes.getField(t3, 0);
  }
  getLeftEnd_(t3) {
    return this.m_intervalNodes.getField(t3, 1);
  }
  getRightEnd_(t3) {
    return this.m_intervalNodes.getField(t3, 2);
  }
  getMin_(t3) {
    return this.m_bEnvelopesRef ? this.m_envelopesRef[t3].xmin : this.m_intervals[t3].vmin;
  }
  getMax_(t3) {
    return this.m_bEnvelopesRef ? this.m_envelopesRef[t3].xmax : this.m_intervals[t3].vmax;
  }
  sortEndIndices_(t3, e2, s3) {
    const i2 = this, n5 = { userSort(t4, e3, s4) {
      i2.sortEndIndicesHelper_(s4, t4, e3);
    }, getValue: (t4) => i2.getValue_(t4) };
    new ot().sort(t3, e2, s3, n5);
  }
  sortEndIndicesHelper_(t3, e2, s3) {
    t3.sort(e2, s3, (t4, e3) => {
      const s4 = this.getValue_(t4), i2 = this.getValue_(e3);
      return s4 < i2 || s4 === i2 && _ft.isLeft_(t4) && _ft.isRight_(e3) ? -1 : 1;
    });
  }
  getValue_(t3) {
    if (!this.m_bEnvelopesRef) {
      const e3 = this.m_intervals[t3 >> 1];
      return _ft.isLeft_(t3) ? e3.vmin : e3.vmax;
    }
    const e2 = this.m_envelopesRef[t3 >> 1];
    return _ft.isLeft_(t3) ? e2.xmin : e2.xmax;
  }
};
var vt2 = class {
  constructor(t3, e2, s3) {
    this.m_query = x2.constructEmpty(), this.m_tertiaryHandle = -1, this.m_nextTertiaryHandle = -1, this.m_forkedHandle = -1, this.m_currentEndHandle = -1, this.m_nextEndHandle = -1, this.m_tertiaryStack = [], this.m_functionIndex = 0, this.m_intervalTree = t3, this.m_functionStack = new Array(2), this.m_functionStack[0] = this.nullFunc_, this.m_functionStack[1] = this.nullFunc_, void 0 !== e2 && this.resetIterator(e2, s3);
  }
  nullFunc_() {
    return b("should not be called"), false;
  }
  resetIterator(t3, e2) {
    if ("number" == typeof t3) {
      const s3 = new x2();
      s3.setCoords(t3, t3), this.resetIterator(s3, e2);
    } else void 0 === e2 && (e2 = 0), this.m_query.vmin = t3.vmin - e2, this.m_query.vmax = t3.vmax + e2, this.m_tertiaryStack.length = 0, this.m_functionIndex = 0, this.m_functionStack[0] = this.initialize_;
  }
  next() {
    if (this.m_intervalTree.m_bConstructionEnded || C(""), this.m_functionIndex < 0) return -1;
    for (; this.m_fi = this.m_functionStack[this.m_functionIndex], this.m_fi(); ) ;
    return -1 !== this.m_currentEndHandle ? this.getCurrentEndIndex_() >> 1 : -1;
  }
  initialize_() {
    return this.m_tertiaryHandle = -1, this.m_nextTertiaryHandle = -1, this.m_forkedHandle = -1, this.m_currentEndHandle = -1, this.m_intervalTree.m_tertiaryNodes.size() > 0 ? (this.m_functionStack[0] = this.pIn_, this.m_nextTertiaryHandle = this.m_intervalTree.m_root, true) : (this.m_functionIndex = -1, false);
  }
  pIn_() {
    if (this.m_tertiaryHandle = this.m_nextTertiaryHandle, -1 === this.m_tertiaryHandle) return this.m_functionIndex = -1, this.m_currentEndHandle = -1, false;
    const t3 = this.m_intervalTree.getDiscriminant_(this.m_tertiaryHandle);
    if (this.m_query.vmax < t3) {
      const t4 = this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);
      return this.m_nextTertiaryHandle = this.m_intervalTree.getLptr_(this.m_tertiaryHandle), -1 !== t4 && (this.m_nextEndHandle = this.m_intervalTree.getFirst_(t4), this.m_functionStack[++this.m_functionIndex] = this.left_), true;
    }
    if (t3 < this.m_query.vmin) {
      const t4 = this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);
      return this.m_nextTertiaryHandle = this.m_intervalTree.getRptr_(this.m_tertiaryHandle), -1 !== t4 && (this.m_nextEndHandle = this.m_intervalTree.getLast_(t4), this.m_functionStack[++this.m_functionIndex] = this.right_), true;
    }
    this.m_functionStack[this.m_functionIndex] = this.pL_, this.m_forkedHandle = this.m_tertiaryHandle;
    const e2 = this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);
    return this.m_nextTertiaryHandle = this.m_intervalTree.getLptr_(this.m_tertiaryHandle), -1 !== e2 && (this.m_nextEndHandle = this.m_intervalTree.getFirst_(e2), this.m_functionStack[++this.m_functionIndex] = this.all_), true;
  }
  pL_() {
    if (this.m_tertiaryHandle = this.m_nextTertiaryHandle, -1 === this.m_tertiaryHandle) return this.m_functionStack[this.m_functionIndex] = this.pR_, this.m_nextTertiaryHandle = this.m_intervalTree.getRptr_(this.m_forkedHandle), true;
    if (this.m_intervalTree.getDiscriminant_(this.m_tertiaryHandle) < this.m_query.vmin) {
      const t4 = this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);
      return this.m_nextTertiaryHandle = this.m_intervalTree.getRptr_(this.m_tertiaryHandle), -1 !== t4 && (this.m_nextEndHandle = this.m_intervalTree.getLast_(t4), this.m_functionStack[++this.m_functionIndex] = this.right_), true;
    }
    const t3 = this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);
    this.m_nextTertiaryHandle = this.m_intervalTree.getLptr_(this.m_tertiaryHandle), -1 !== t3 && (this.m_nextEndHandle = this.m_intervalTree.getFirst_(t3), this.m_functionStack[++this.m_functionIndex] = this.all_);
    const e2 = this.m_intervalTree.getRptr_(this.m_tertiaryHandle);
    return -1 !== e2 && this.m_tertiaryStack.push(e2), true;
  }
  pR_() {
    if (this.m_tertiaryHandle = this.m_nextTertiaryHandle, -1 === this.m_tertiaryHandle) return this.m_functionStack[this.m_functionIndex] = this.pT_, true;
    const t3 = this.m_intervalTree.getDiscriminant_(this.m_tertiaryHandle);
    if (this.m_query.vmax < t3) {
      const t4 = this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);
      return this.m_nextTertiaryHandle = this.m_intervalTree.getLptr_(this.m_tertiaryHandle), -1 !== t4 && (this.m_nextEndHandle = this.m_intervalTree.getFirst_(t4), this.m_functionStack[++this.m_functionIndex] = this.left_), true;
    }
    const e2 = this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);
    this.m_nextTertiaryHandle = this.m_intervalTree.getRptr_(this.m_tertiaryHandle), -1 !== e2 && (this.m_nextEndHandle = this.m_intervalTree.getFirst_(e2), this.m_functionStack[++this.m_functionIndex] = this.all_);
    const s3 = this.m_intervalTree.getLptr_(this.m_tertiaryHandle);
    return -1 !== s3 && this.m_tertiaryStack.push(s3), true;
  }
  pT_() {
    if (0 === this.m_tertiaryStack.length) return this.m_functionIndex = -1, this.m_currentEndHandle = -1, false;
    this.m_tertiaryHandle = this.m_tertiaryStack.at(-1), this.m_tertiaryStack.pop();
    const t3 = this.m_intervalTree.getSecondaryFromTertiary_(this.m_tertiaryHandle);
    return -1 !== t3 && (this.m_nextEndHandle = this.m_intervalTree.getFirst_(t3), this.m_functionStack[++this.m_functionIndex] = this.all_), -1 !== this.m_intervalTree.getLptr_(this.m_tertiaryHandle) && this.m_tertiaryStack.push(this.m_intervalTree.getLptr_(this.m_tertiaryHandle)), -1 !== this.m_intervalTree.getRptr_(this.m_tertiaryHandle) && this.m_tertiaryStack.push(this.m_intervalTree.getRptr_(this.m_tertiaryHandle)), true;
  }
  left_() {
    return this.m_currentEndHandle = this.m_nextEndHandle, -1 !== this.m_currentEndHandle && ft2.isLeft_(this.getCurrentEndIndex_()) && this.m_intervalTree.getValue_(this.getCurrentEndIndex_()) <= this.m_query.vmax ? (this.m_nextEndHandle = this.getNext_(), false) : (this.m_functionIndex--, true);
  }
  right_() {
    return this.m_currentEndHandle = this.m_nextEndHandle, -1 !== this.m_currentEndHandle && ft2.isRight_(this.getCurrentEndIndex_()) && this.m_intervalTree.getValue_(this.getCurrentEndIndex_()) >= this.m_query.vmin ? (this.m_nextEndHandle = this.getPrev_(), false) : (this.m_functionIndex--, true);
  }
  all_() {
    return this.m_currentEndHandle = this.m_nextEndHandle, -1 !== this.m_currentEndHandle && ft2.isLeft_(this.getCurrentEndIndex_()) ? (this.m_nextEndHandle = this.getNext_(), false) : (this.m_functionIndex--, true);
  }
  getNext_() {
    return this.m_intervalTree.m_bOfflineDynamic ? this.m_intervalTree.m_secondaryTreaps.getNext(this.m_currentEndHandle) : this.m_intervalTree.m_secondaryLists.getNext(this.m_currentEndHandle);
  }
  getPrev_() {
    return this.m_intervalTree.m_bOfflineDynamic ? this.m_intervalTree.m_secondaryTreaps.getPrev(this.m_currentEndHandle) : this.m_intervalTree.m_secondaryLists.getPrev(this.m_currentEndHandle);
  }
  getCurrentEndIndex_() {
    return this.m_intervalTree.m_bOfflineDynamic ? this.m_intervalTree.m_secondaryTreaps.getElement(this.m_currentEndHandle) : this.m_intervalTree.m_secondaryLists.getData(this.m_currentEndHandle);
  }
};
var yt = class {
  constructor() {
    this.m_tolerance = 0, this.m_sweepIndexRed = -1, this.m_sweepIndexBlue = -1, this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_intervalTreeRed = null, this.m_intervalTreeBlue = null, this.m_iteratorRed = null, this.m_iteratorBlue = null, this.m_envelopesRed = [], this.m_envelopesBlue = [], this.m_elementsRed = [], this.m_elementsBlue = [], this.m_sortedEndIndicesRed = new st2(0), this.m_sortedEndIndicesBlue = new st2(0), this.m_queuedListRed = -1, this.m_queuedListBlue = -1, this.m_queuedEnvelopes = new pt(), this.m_queuedIndicesRed = [], this.m_queuedIndicesBlue = [], this.m_bAddRed = false, this.m_bAddBlue = false, this.m_bAddRedRed = false, this.m_bDone = true, this.m_function = this.nullFunc_, this.reset_();
  }
  startConstruction() {
    this.reset_(), this.m_bAddRedRed = true, this.m_elementsRed.length = 0, this.m_envelopesRed.length = 0;
  }
  addEnvelope(t3, e2) {
    this.m_bAddRedRed || C(""), this.m_elementsRed.push(t3), this.m_envelopesRed.push(new n3(e2));
  }
  endConstruction() {
    this.m_bAddRedRed || C(""), this.m_bAddRedRed = false, this.m_envelopesRed.length > 0 && (this.m_function = this.initialize_, this.m_bDone = false);
  }
  startRedConstruction() {
    this.reset_(), this.m_bAddRed = true, this.m_elementsRed.length = 0, this.m_envelopesRed.length = 0;
  }
  addRedEnvelope(t3, e2) {
    this.m_bAddRed || C(""), this.m_elementsRed.push(t3), this.m_envelopesRed.push(e2.clone());
  }
  endRedConstruction() {
    this.m_bAddRed || C(""), this.m_bAddRed = false, this.m_envelopesRed.length > 0 && this.m_envelopesBlue.length > 0 && (this.m_function === this.nullFunc_ || this.m_function === this.initializeBlue_ ? this.m_function = this.initializeRedBlue_ : this.m_function !== this.initializeRedBlue_ && (this.m_function = this.initializeRed_), this.m_bDone = false);
  }
  startBlueConstruction() {
    this.reset_(), this.m_bAddBlue = true, this.m_elementsBlue.length = 0, this.m_envelopesBlue.length = 0;
  }
  addBlueEnvelope(t3, e2) {
    this.m_bAddBlue || C(""), this.m_elementsBlue.push(t3), this.m_envelopesBlue.push(e2.clone());
  }
  endBlueConstruction() {
    this.m_bAddBlue || C(""), this.m_bAddBlue = false, this.m_envelopesRed.length > 0 && this.m_envelopesBlue.length > 0 && (this.m_function === this.nullFunc_ || this.m_function === this.initializeRed_ ? this.m_function = this.initializeRedBlue_ : this.m_function !== this.initializeRedBlue_ && (this.m_function = this.initializeBlue_), this.m_bDone = false);
  }
  next() {
    if (this.m_bDone) return false;
    for (; this.m_function(); ) ;
    return !this.m_bDone;
  }
  getHandleA() {
    return this.m_envelopeHandleA;
  }
  getHandleB() {
    return this.m_envelopeHandleB;
  }
  setTolerance(t3) {
    this.m_tolerance = t3;
  }
  getElement(t3) {
    return this.m_elementsRed[t3];
  }
  getRedEnvelope(t3) {
    return this.m_envelopesRed[t3];
  }
  getBlueEnvelope(t3) {
    return this.m_envelopesBlue[t3];
  }
  getRedElement(t3) {
    return this.m_elementsRed[t3];
  }
  getBlueElement(t3) {
    return this.m_elementsBlue[t3];
  }
  isTop_(t3) {
    return !(1 & ~t3);
  }
  isBottom_(t3) {
    return !(1 & t3);
  }
  reset_() {
    this.m_bAddRed = false, this.m_bAddBlue = false, this.m_bAddRedRed = false, this.m_sweepIndexRed = -1, this.m_sweepIndexBlue = -1, this.m_queuedListRed = -1, this.m_queuedListBlue = -1, this.m_bDone = true;
  }
  initialize_() {
    if (this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_envelopesRed.length < 10) return this.m_sweepIndexRed = this.m_envelopesRed.length, this.m_function = this.sweepBruteForce_, true;
    this.m_intervalTreeRed || (this.m_intervalTreeRed = new ft2(true)), this.m_intervalTreeRed.addEnvelopesRef(this.m_envelopesRed), null === this.m_iteratorRed && (this.m_iteratorRed = this.m_intervalTreeRed.getIterator()), this.m_sortedEndIndicesRed.resize(0);
    for (let t3 = 0; t3 < 2 * this.m_envelopesRed.length; t3++) this.m_sortedEndIndicesRed.add(t3);
    return this.sortYEndIndices_(this.m_sortedEndIndicesRed, 0, 2 * this.m_envelopesRed.length, true), this.m_sweepIndexRed = 2 * this.m_envelopesRed.length, this.m_function = this.sweep_, true;
  }
  initializeRed_() {
    if (this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_envelopesRed.length < 10 || this.m_envelopesBlue.length < 10) return this.m_sweepIndexRed = this.m_envelopesRed.length, this.m_function = this.sweepRedBlueBruteForce_, true;
    this.m_intervalTreeRed || (this.m_intervalTreeRed = new ft2(true)), this.m_intervalTreeRed.addEnvelopesRef(this.m_envelopesRed), null === this.m_iteratorRed && (this.m_iteratorRed = this.m_intervalTreeRed.getIterator()), this.m_sortedEndIndicesRed.resize(0);
    for (let t3 = 0; t3 < 2 * this.m_envelopesRed.length; t3++) this.m_sortedEndIndicesRed.add(t3);
    return this.sortYEndIndices_(this.m_sortedEndIndicesRed, 0, this.m_sortedEndIndicesRed.size(), true), this.m_sweepIndexRed = this.m_sortedEndIndicesRed.size(), -1 !== this.m_queuedListRed && (this.m_queuedEnvelopes.deleteList(this.m_queuedListRed), this.m_queuedIndicesRed.length = 0, this.m_queuedListRed = -1), this.m_function = this.sweepRedBlue_, this.resetBlue_();
  }
  initializeBlue_() {
    if (this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_envelopesRed.length < 10 || this.m_envelopesBlue.length < 10) return this.m_sweepIndexRed = this.m_envelopesRed.length, this.m_function = this.sweepRedBlueBruteForce_, true;
    this.m_intervalTreeBlue || (this.m_intervalTreeBlue = new ft2(true)), this.m_intervalTreeBlue.addEnvelopesRef(this.m_envelopesBlue), null == this.m_iteratorBlue && (this.m_iteratorBlue = this.m_intervalTreeBlue.getIterator()), this.m_sortedEndIndicesBlue.resize(0);
    for (let t3 = 0; t3 < 2 * this.m_envelopesBlue.length; t3++) this.m_sortedEndIndicesBlue.add(t3);
    return this.sortYEndIndices_(this.m_sortedEndIndicesBlue, 0, this.m_sortedEndIndicesBlue.size(), false), this.m_sweepIndexBlue = this.m_sortedEndIndicesBlue.size(), -1 !== this.m_queuedListBlue && (this.m_queuedEnvelopes.deleteList(this.m_queuedListBlue), this.m_queuedIndicesBlue.length = 0, this.m_queuedListBlue = -1), this.m_function = this.sweepRedBlue_, this.resetRed_();
  }
  initializeRedBlue_() {
    if (this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_envelopesRed.length < 10 || this.m_envelopesBlue.length < 10) return this.m_sweepIndexRed = this.m_envelopesRed.length, this.m_function = this.sweepRedBlueBruteForce_, true;
    this.m_intervalTreeRed || (this.m_intervalTreeRed = new ft2(true)), this.m_intervalTreeBlue || (this.m_intervalTreeBlue = new ft2(true)), this.m_intervalTreeRed.addEnvelopesRef(this.m_envelopesRed), this.m_intervalTreeBlue.addEnvelopesRef(this.m_envelopesBlue), null === this.m_iteratorRed && (this.m_iteratorRed = this.m_intervalTreeRed.getIterator()), null === this.m_iteratorBlue && (this.m_iteratorBlue = this.m_intervalTreeBlue.getIterator()), this.m_sortedEndIndicesRed.resize(0), this.m_sortedEndIndicesBlue.resize(0);
    for (let t3 = 0; t3 < 2 * this.m_envelopesRed.length; t3++) this.m_sortedEndIndicesRed.add(t3);
    for (let t3 = 0; t3 < 2 * this.m_envelopesBlue.length; t3++) this.m_sortedEndIndicesBlue.add(t3);
    return this.sortYEndIndices_(this.m_sortedEndIndicesRed, 0, this.m_sortedEndIndicesRed.size(), true), this.sortYEndIndices_(this.m_sortedEndIndicesBlue, 0, this.m_sortedEndIndicesBlue.size(), false), this.m_sweepIndexRed = this.m_sortedEndIndicesRed.size(), this.m_sweepIndexBlue = this.m_sortedEndIndicesBlue.size(), -1 !== this.m_queuedListRed && (this.m_queuedEnvelopes.deleteList(this.m_queuedListRed), this.m_queuedIndicesRed.length = 0, this.m_queuedListRed = -1), -1 !== this.m_queuedListBlue && (this.m_queuedEnvelopes.deleteList(this.m_queuedListBlue), this.m_queuedIndicesBlue.length = 0, this.m_queuedListBlue = -1), this.m_function = this.sweepRedBlue_, true;
  }
  sweep_() {
    const t3 = this.m_sortedEndIndicesRed.read(--this.m_sweepIndexRed), e2 = t3 >> 1;
    if (this.isBottom_(t3)) return this.m_intervalTreeRed.remove(e2), 0 !== this.m_sweepIndexRed || (this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_bDone = true, false);
    const s3 = x2.construct(this.m_envelopesRed[e2].xmin, this.m_envelopesRed[e2].xmax);
    return this.m_iteratorRed.resetIterator(s3, this.m_tolerance), this.m_envelopeHandleA = e2, this.m_function = this.iterate_, true;
  }
  sweepBruteForce_() {
    return -1 === --this.m_sweepIndexRed ? (this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_bDone = true, false) : (this.m_envelopeHandleA = this.m_sweepIndexRed, this.m_sweepIndexBlue = this.m_sweepIndexRed, this.m_function = this.iterateBruteForce_, true);
  }
  sweepRedBlueBruteForce_() {
    return -1 === --this.m_sweepIndexRed ? (this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_bDone = true, false) : (this.m_envelopeHandleA = this.m_sweepIndexRed, this.m_sweepIndexBlue = this.m_envelopesBlue.length, this.m_function = this.iterateRedBlueBruteForce_, true);
  }
  sweepRedBlue_() {
    const t3 = this.m_sortedEndIndicesRed.read(this.m_sweepIndexRed - 1), e2 = this.m_sortedEndIndicesBlue.read(this.m_sweepIndexBlue - 1), s3 = this.getAdjustedValue_(t3, true), i2 = this.getAdjustedValue_(e2, false);
    return s3 > i2 ? this.sweepRed_() : s3 < i2 ? this.sweepBlue_() : this.isTop_(t3) ? this.sweepRed_() : this.isTop_(e2) ? this.sweepBlue_() : this.sweepRed_();
  }
  sweepRed_() {
    const t3 = this.m_sortedEndIndicesRed.read(--this.m_sweepIndexRed), e2 = t3 >> 1;
    if (this.isBottom_(t3)) return -1 !== this.m_queuedListRed && -1 !== this.m_queuedIndicesRed[e2] ? (this.m_queuedEnvelopes.deleteElement(this.m_queuedListRed, this.m_queuedIndicesRed[e2]), this.m_queuedIndicesRed[e2] = -1) : this.m_intervalTreeRed.remove(e2), 0 !== this.m_sweepIndexRed || (this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_bDone = true, false);
    if (-1 !== this.m_queuedListBlue && this.m_queuedEnvelopes.getListSize(this.m_queuedListBlue) > 0) {
      let t4 = this.m_queuedEnvelopes.getFirst(this.m_queuedListBlue);
      for (; -1 !== t4; ) {
        const e3 = this.m_queuedEnvelopes.getData(t4);
        this.m_intervalTreeBlue.insert(e3), this.m_queuedIndicesBlue[e3] = -1;
        const s3 = this.m_queuedEnvelopes.getNext(t4);
        this.m_queuedEnvelopes.deleteElement(this.m_queuedListBlue, t4), t4 = s3;
      }
    }
    if (this.m_intervalTreeBlue.size() > 0) {
      const t4 = x2.construct(this.m_envelopesRed[e2].xmin, this.m_envelopesRed[e2].xmax);
      this.m_iteratorBlue.resetIterator(t4, this.m_tolerance), this.m_envelopeHandleA = e2, this.m_function = this.iterateBlue_;
    } else -1 === this.m_queuedListRed && (Ft(this.m_queuedIndicesRed, this.m_envelopesRed.length, -1), this.m_queuedListRed = this.m_queuedEnvelopes.createList(1)), this.m_queuedIndicesRed[e2] = this.m_queuedEnvelopes.addElement(this.m_queuedListRed, e2), this.m_function = this.sweepRedBlue_;
    return true;
  }
  sweepBlue_() {
    const t3 = this.m_sortedEndIndicesBlue.read(--this.m_sweepIndexBlue), e2 = t3 >> 1;
    if (this.isBottom_(t3)) return -1 !== this.m_queuedListBlue && -1 !== this.m_queuedIndicesBlue[e2] ? (this.m_queuedEnvelopes.deleteElement(this.m_queuedListBlue, this.m_queuedIndicesBlue[e2]), this.m_queuedIndicesBlue[e2] = -1) : this.m_intervalTreeBlue.remove(e2), 0 !== this.m_sweepIndexBlue || (this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1, this.m_bDone = true, false);
    if (-1 !== this.m_queuedListRed && this.m_queuedEnvelopes.getListSize(this.m_queuedListRed) > 0) {
      let t4 = this.m_queuedEnvelopes.getFirst(this.m_queuedListRed);
      for (; -1 !== t4; ) {
        const e3 = this.m_queuedEnvelopes.getData(t4);
        this.m_intervalTreeRed.insert(e3), this.m_queuedIndicesRed[e3] = -1;
        const s3 = this.m_queuedEnvelopes.getNext(t4);
        this.m_queuedEnvelopes.deleteElement(this.m_queuedListRed, t4), t4 = s3;
      }
    }
    if (this.m_intervalTreeRed.size() > 0) {
      const t4 = x2.construct(this.m_envelopesBlue[e2].xmin, this.m_envelopesBlue[e2].xmax);
      this.m_iteratorRed.resetIterator(t4, this.m_tolerance), this.m_envelopeHandleB = e2, this.m_function = this.iterateRed_;
    } else -1 === this.m_queuedListBlue && (Ft(this.m_queuedIndicesBlue, this.m_envelopesBlue.length, -1), this.m_queuedListBlue = this.m_queuedEnvelopes.createList(0)), this.m_queuedIndicesBlue[e2] = this.m_queuedEnvelopes.addElement(this.m_queuedListBlue, e2), this.m_function = this.sweepRedBlue_;
    return true;
  }
  iterate_() {
    if (this.m_envelopeHandleB = this.m_iteratorRed.next(), -1 !== this.m_envelopeHandleB) return false;
    const t3 = this.m_sortedEndIndicesRed.read(this.m_sweepIndexRed) >> 1;
    return this.m_intervalTreeRed.insert(t3), this.m_function = this.sweep_, true;
  }
  iterateRed_() {
    if (this.m_envelopeHandleA = this.m_iteratorRed.next(), -1 !== this.m_envelopeHandleA) return false;
    this.m_envelopeHandleA = -1, this.m_envelopeHandleB = -1;
    const t3 = this.m_sortedEndIndicesBlue.read(this.m_sweepIndexBlue) >> 1;
    return this.m_intervalTreeBlue.insert(t3), this.m_function = this.sweepRedBlue_, true;
  }
  iterateBlue_() {
    if (this.m_envelopeHandleB = this.m_iteratorBlue.next(), -1 !== this.m_envelopeHandleB) return false;
    const t3 = this.m_sortedEndIndicesRed.read(this.m_sweepIndexRed) >> 1;
    return this.m_intervalTreeRed.insert(t3), this.m_function = this.sweepRedBlue_, true;
  }
  iterateBruteForce_() {
    if (-1 === --this.m_sweepIndexBlue) return this.m_function = this.sweepBruteForce_, true;
    const t3 = this.m_envelopesRed[this.m_sweepIndexRed].clone(), e2 = this.m_envelopesRed[this.m_sweepIndexBlue];
    return t3.inflateCoords(this.m_tolerance, this.m_tolerance), !t3.isIntersecting(e2) || (this.m_envelopeHandleB = this.m_sweepIndexBlue, false);
  }
  iterateRedBlueBruteForce_() {
    if (-1 === --this.m_sweepIndexBlue) return this.m_function = this.sweepRedBlueBruteForce_, true;
    const t3 = this.m_envelopesRed[this.m_sweepIndexRed].clone(), e2 = this.m_envelopesBlue[this.m_sweepIndexBlue];
    return t3.inflateCoords(this.m_tolerance, this.m_tolerance), !t3.isIntersecting(e2) || (this.m_envelopeHandleB = this.m_sweepIndexBlue, false);
  }
  resetRed_() {
    return this.m_sweepIndexRed = this.m_sortedEndIndicesRed.size(), this.m_intervalTreeRed.size() > 0 && this.m_intervalTreeRed.reset(), -1 !== this.m_queuedListRed && (this.m_queuedEnvelopes.deleteList(this.m_queuedListRed), this.m_queuedIndicesRed.length = 0, this.m_queuedListRed = -1), this.m_bDone = false, true;
  }
  resetBlue_() {
    return this.m_sweepIndexBlue = this.m_sortedEndIndicesBlue.size(), this.m_intervalTreeBlue.size() > 0 && this.m_intervalTreeBlue.reset(), -1 !== this.m_queuedListBlue && (this.m_queuedEnvelopes.deleteList(this.m_queuedListBlue), this.m_queuedIndicesBlue.length = 0, this.m_queuedListBlue = -1), this.m_bDone = false, true;
  }
  nullFunc_() {
    return b("should not be called"), false;
  }
  sortYEndIndices_(t3, e2, s3, i2) {
    const n5 = this, r = { userSort(t4, e3, s4) {
      n5.sortYEndIndicesHelper_(s4, t4, e3, i2);
    }, getValue: (t4) => n5.getAdjustedValue_(t4, i2) };
    new ot().sort(t3, e2, s3, r);
  }
  sortYEndIndicesHelper_(t3, e2, s3, i2) {
    t3.sort(e2, s3, (t4, e3) => {
      const s4 = this.getAdjustedValue_(t4, i2), n5 = this.getAdjustedValue_(e3, i2);
      return s4 < n5 || s4 === n5 && this.isBottom_(t4) && this.isTop_(e3) ? -1 : 1;
    });
  }
  getAdjustedValue_(t3, e2) {
    const s3 = 0.5 * this.m_tolerance;
    if (e2) {
      const e3 = this.m_envelopesRed[t3 >> 1];
      return this.isBottom_(t3) ? e3.ymin - s3 : e3.ymax + s3;
    }
    const i2 = this.m_envelopesBlue[t3 >> 1];
    return this.isBottom_(t3) ? i2.ymin - s3 : i2.ymax + s3;
  }
};
var xt = z3;
var Et2 = class _Et {
  constructor(t3, e2) {
    this.tolerance = void 0 !== t3 ? t3 : Number.NaN, this.resolution = void 0 !== e2 ? e2 : Number.NaN;
  }
  add(t3) {
    return new _Et(this.tolerance + t3, this.resolution);
  }
  scale(t3) {
    return new _Et(this.tolerance * t3, this.resolution * t3);
  }
  total() {
    return this.tolerance + this.resolution;
  }
};
function bt(t3, e2, i2, n5, r) {
  const h2 = n5 * n5, o = t3.sub(e2), a2 = i2.sub(e2), m3 = o.sqrLength(), _ = a2.sqrLength();
  if (m3 <= h2 || _ <= h2) return true;
  const l2 = H(o.crossProduct(a2));
  if (l2 <= h2 * m3 || l2 <= h2 * _) {
    return o.dotProduct(a2) >= 0;
  }
  return false;
}
function Nt(t3, e2, s3) {
  return (i2) => 0 === s3 ? (i2 + t3) * e2 : 1 * (i2 - t3 * e2) / e2;
}
function Dt2(t3, e2) {
  const s3 = new n3();
  return t3.queryLooseEnvelope(s3), s3.mergeEnvelope2D(e2), s3;
}
function It2(t3, e2) {
  const s3 = n3.constructEmpty();
  t3.queryLooseEnvelope(s3);
  const i2 = n3.constructEmpty();
  return e2.queryLooseEnvelope(i2), s3.mergeEnvelope2D(i2), s3;
}
function Ct2(t3, e2) {
  return (Number.isFinite(t3) || Number.isNaN(t3)) && (Number.isFinite(e2) || Number.isNaN(e2));
}
function Tt(t3, e2) {
  return Number.isFinite(t3) && Number.isFinite(e2);
}
function Rt2(t3, e2, s3) {
  const i2 = n3.constructEmpty();
  i2.setFromPoints(t3, e2);
  return St2(0, null, i2.calculateToleranceFromEnvelope(), s3, false);
}
function At(t3, e2, s3) {
  return St2(0, t3, e2.calculateToleranceFromEnvelope(), s3, false);
}
function qt2(t3, e2, s3) {
  return St2(1, t3, e2.calculateToleranceFromEnvelope(), s3, false);
}
function wt2(t3, e2, s3) {
  return qt2(t3, e2.queryInterval(1, 0), s3);
}
function Bt2(t3, e2, s3) {
  const i2 = n3.constructEmpty();
  return e2.queryEnvelope(i2), At(t3, i2, s3);
}
function zt2(t3, e2, s3 = false) {
  return St2(0, t3, e2.calculateToleranceFromEnvelope(), s3, true).total();
}
function Lt2(t3, e2, s3) {
  const i2 = n3.constructEmpty();
  return e2.queryEnvelope(i2), zt2(t3, i2, s3);
}
function St2(t3, e2, s3, i2, n5) {
  const r = new Et2(0, 0);
  if (null !== e2 && (r.tolerance = e2.getTolerance(t3), (!n5 || i2) && null !== e2)) {
    const s4 = e2.getResolution(t3);
    r.resolution = s4, i2 && (r.resolution *= 2);
  }
  i2 && (s3 *= 4, r.tolerance *= 1.01, r.resolution *= 1.01);
  return r.total() < s3 ? new Et2(s3, 0) : r;
}
function Ft2(t3) {
  return Math.sqrt(2) * (2 * t3.tolerance + t3.resolution);
}
function Pt2(t3) {
  return Math.sqrt(2) * (t3.tolerance + t3.resolution);
}
function Ht2(t3) {
  return t3 >= 3;
}
function Vt2(t3, e2) {
  const s3 = [0];
  return t3.getImpl().getIsSimple(e2, s3) >= 3;
}
function kt2(t3, e2) {
  t3.getImpl().setIsSimple(3, e2);
}
function Mt(t3, e2, n5, r) {
  if (H(e2.x - t3.x) + H(e2.y - t3.y) <= n5 * n5) {
    const s3 = t3.z, n6 = e2.z;
    return cs(s3, n6, r);
  }
  return false;
}
function Ot2(t3) {
  return t3 >= 4;
}
function Yt2(t3, e2) {
  return t3 === a.enumPolygon ? Ht2(e2) : e2 >= 1;
}
function Xt2(t3, e2, s3) {
  const i2 = n3.constructEmpty(), n5 = n3.constructEmpty();
  t3.queryLooseEnvelope(i2), e2.queryLooseEnvelope(n5), i2.inflateCoords(s3, s3), n5.inflateCoords(s3, s3);
  const r = n3.constructEmpty();
  r.setCoords({ env2D: i2 }), r.intersect(n5);
  const h2 = t3.querySegmentIterator(), o = e2.querySegmentIterator(), a2 = n3.constructEmpty(), m3 = n3.constructEmpty(), _ = new yt();
  _.setTolerance(s3);
  let l2 = false;
  for (_.startRedConstruction(); h2.nextPath(); ) for (; h2.hasNextSegment(); ) {
    h2.nextSegment().queryLooseEnvelope(a2), a2.isIntersecting(r) && (l2 = true, _.addRedEnvelope(h2.getStartPointIndex(), a2));
  }
  if (_.endRedConstruction(), !l2) return null;
  let u = false;
  for (_.startBlueConstruction(); o.nextPath(); ) for (; o.hasNextSegment(); ) {
    o.nextSegment().queryLooseEnvelope(m3), m3.isIntersecting(r) && (u = true, _.addBlueEnvelope(o.getStartPointIndex(), m3));
  }
  return _.endBlueConstruction(), u ? _ : null;
}
function Gt2(t3, e2, s3, i2, n5) {
  t3.getGeometryType(), e2.getGeometryType();
  const r = n3.constructEmpty(), h2 = n3.constructEmpty();
  t3.queryLooseEnvelope(r), e2.queryLooseEnvelope(h2), r.inflateCoords(s3, s3), h2.inflateCoords(s3, s3);
  const o = n3.constructEmpty();
  o.setCoords({ env2D: r }), o.intersect(h2);
  const a2 = new yt();
  a2.setTolerance(s3);
  let m3 = false;
  a2.startRedConstruction();
  for (let l2 = 0, u = t3.getPathCount(); l2 < u; l2++) t3.queryLoosePathEnvelope(l2, r), r.isIntersecting(o) && (m3 = true, a2.addRedEnvelope(l2, r));
  if (a2.endRedConstruction(), !m3) return null;
  let _ = false;
  a2.startBlueConstruction();
  for (let l2 = 0, u = e2.getPathCount(); l2 < u; l2++) e2.queryLoosePathEnvelope(l2, h2), h2.isIntersecting(o) && (_ = true, a2.addBlueEnvelope(l2, h2));
  return a2.endBlueConstruction(), _ ? a2 : null;
}
function Ut2(t3, e2, s3) {
  const i2 = n3.constructEmpty(), n5 = n3.constructEmpty();
  t3.queryLooseEnvelope(i2), e2.queryEnvelope(n5), i2.inflateCoords(s3, s3), n5.inflateCoords(s3, s3);
  const r = n3.constructEmpty();
  r.setCoords({ env2D: i2 }), r.intersect(n5);
  const h2 = t3.querySegmentIterator(), o = new yt();
  o.setTolerance(s3);
  let a2 = false;
  for (o.startRedConstruction(); h2.nextPath(); ) for (; h2.hasNextSegment(); ) {
    h2.nextSegment().queryLooseEnvelope(i2), i2.isIntersecting(r) && (a2 = true, o.addRedEnvelope(h2.getStartPointIndex(), i2));
  }
  if (o.endRedConstruction(), !a2) return null;
  let m3 = false;
  o.startBlueConstruction();
  for (let _ = 0, l2 = e2.getPointCount(); _ < l2; _++) {
    const t4 = e2.getXY(_);
    r.contains(t4) && (m3 = true, o.addBlueEnvelope(_, n3.construct(t4.x, t4.y, t4.x, t4.y)));
  }
  return o.endBlueConstruction(), m3 ? o : null;
}
function Zt2(t3, e2, s3) {
  const i2 = n3.constructEmpty(), n5 = n3.constructEmpty();
  t3.queryEnvelope(i2), e2.queryEnvelope(n5), i2.inflateCoords(s3, s3), n5.inflateCoords(s3, s3);
  const r = n3.constructEmpty();
  r.setCoords({ env2D: i2 }), r.intersect(n5);
  const h2 = new yt();
  h2.setTolerance(s3);
  let a2 = false;
  h2.startRedConstruction();
  const m3 = new mi();
  for (let o = 0, u = t3.getPointCount(); o < u; o++) t3.queryXY(o, m3), r.contains(m3) && (a2 = true, h2.addRedEnvelope(o, n3.construct(m3.x, m3.y, m3.x, m3.y)));
  if (h2.endRedConstruction(), !a2) return null;
  let _ = false;
  h2.startBlueConstruction();
  const l2 = new mi();
  for (let o = 0, u = e2.getPointCount(); o < u; o++) e2.queryXY(o, l2), r.contains(l2) && (_ = true, h2.addBlueEnvelope(o, n3.construct(l2.x, l2.y, l2.x, l2.y)));
  return h2.endBlueConstruction(), _ ? h2 : null;
}
function Qt2(t3) {
  const e2 = new n3();
  return t3.queryLooseEnvelope(e2), e2.inflateCoords(1, 1), jt2(t3, e2);
}
function jt2(t3, e2, s3) {
  const i2 = new n3();
  if (t3.queryLooseEnvelope(i2), i2.isEmpty()) return null;
  t3.getGeometryType();
  const n5 = new _t2(i2, 8);
  let r = -1;
  const h2 = new n3();
  let o = false;
  do {
    for (let s4 = 0, a2 = t3.getPathCount(); s4 < a2; s4++) if (t3.queryLoosePathEnvelope(s4, h2), h2.isIntersecting(e2)) {
      if (r = n5.insertEx(s4, h2, r), -1 === r) {
        o && b("build_quad_tree_for_paths"), i2.assign(t3.calculateEnvelope2D(false)), o = true, n5.reset(i2, 8);
        break;
      }
      o = false;
    }
  } while (o);
  return n5;
}
function Wt2(t3, e2) {
  if (!e2) {
    const e3 = new n3();
    t3.queryLooseEnvelope(e3);
    const s4 = new _t2(e3, 8);
    let i3 = -1;
    const n6 = new n3(), r2 = t3.querySegmentIterator();
    let h3 = false;
    for (; r2.nextPath(); ) for (; r2.hasNextSegment(); ) {
      const o2 = r2.nextSegment(), a2 = r2.getStartPointIndex();
      if (o2.queryLooseEnvelope(n6), i3 = s4.insertEx(a2, n6, i3), -1 === i3) {
        h3 && b(""), e3.assign(t3.calculateEnvelope2D(false)), h3 = true, s4.reset(e3, 8), r2.resetToFirstPath();
        break;
      }
    }
    return s4;
  }
  const s3 = new n3();
  t3.queryLooseEnvelope(s3);
  const i2 = new _t2(s3, 8);
  let n5 = -1;
  const r = new n3(), h2 = t3.querySegmentIterator();
  let o = false;
  for (; h2.nextPath(); ) for (; h2.hasNextSegment(); ) {
    const a2 = h2.nextSegment(), m3 = h2.getStartPointIndex();
    if (a2.queryLooseEnvelope(r), r.isIntersecting(e2) && (n5 = i2.insertEx(m3, r, n5), -1 === n5)) {
      o && b(""), s3.assign(t3.calculateEnvelope2D(false)), o = true, i2.reset(s3, 8), h2.resetToFirstPath();
      break;
    }
  }
  return i2;
}
function Jt2(t3, e2) {
  if (e2) {
    const s3 = new _t2(e2, 8), i2 = new mi(), n5 = new n3();
    let r = false;
    for (let h2 = 0; h2 < t3.getPointCount(); h2++) {
      if (i2.setCoordsPoint2D(t3.getXY(h2)), !e2.contains(i2)) continue;
      n5.setCoords({ pt: i2 });
      -1 !== s3.insert(h2, n5) || (r && b(""), r = true, s3.reset(t3.calculateEnvelope2D(), 8), h2 = -1);
    }
    return s3;
  }
  return z("no-extent version not yet impl"), null;
}
function Kt2(t3, e2, s3, i2, n5) {
  let r = false;
  const h2 = n5.vmin, o = n5.vmax;
  for (let a2 = s3; a2 < e2; a2 += i2) {
    const e3 = t3.read(a2);
    e3 < h2 ? (r = true, t3.write(a2, h2)) : e3 > o && (r = true, t3.write(a2, o));
  }
  return r;
}
function $t2(t3, e2, s3, i2) {
  if (!t3.hasAttribute(s3)) return false;
  const n5 = t3.getGeometryType();
  if (n5 === a.enumGeometryCollection) {
    const n6 = t3, r = n6.getGeometryCount();
    let h2 = 0;
    for (let t4 = 0; t4 < r; ++t4) {
      h2 |= $t2(n6.getGeometry(t4), e2, s3, i2) ? 1 : 0;
    }
    return !!h2;
  }
  if (y(n5)) {
    const n6 = t3, r = xt.getPersistence(s3), h2 = xt.getComponentCount(s3), o = n6.getPointCount();
    if (1 === r) {
      const t4 = Kt2(n6.getAttributeStreamRef(s3), o * h2, i2, h2, e2);
      return t4 && n6.notifyModified(), t4;
    }
    if (2 === r) {
      const t4 = Kt2(n6.getAttributeStreamRef(s3), o * h2, i2, h2, e2);
      return t4 && n6.notifyModified(), t4;
    }
    b("snap_coordinate not implemented");
  }
  if (n5 === a.enumEnvelope) {
    const n6 = t3, r = n6.queryInterval(s3, i2);
    let h2 = false;
    return r.vmin < e2.vmin && (h2 = true, r.vmin = e2.vmin), r.vmax > e2.vmax && (h2 = true, r.vmax = e2.vmax), h2 && n6.setIntervalEnvelope(s3, i2, r), h2;
  }
  if (n5 === a.enumPoint) {
    const n6 = t3;
    let r = n6.getAttributeAsDbl(s3, i2), h2 = false;
    return r < e2.vmin && (h2 = true, r = e2.vmin), r > e2.vmax && (h2 = true, r = e2.vmax), h2 && n6.setAttributeBasic(s3, i2, r), h2;
  }
  if (f(n5)) {
    const n6 = t3;
    let r = n6.getStartAttributeAsDbl(s3, i2), h2 = false;
    return r < e2.vmin && (h2 = true, r = e2.vmin), r > e2.vmax && (h2 = true, r = e2.vmax), h2 && n6.setStartAttribute(s3, i2, r), r = n6.getEndAttributeAsDbl(s3, i2), r < e2.vmin && (h2 = true, r = e2.vmin), r > e2.vmax && (h2 = true, r = e2.vmax), h2 && n6.setEndAttribute(s3, i2, r), h2;
  }
  b("snap_coordinate not implemented");
}
var te = z3;
var ee = class _ee {
  constructor(t3) {
    if (this.m_description = null, this.x = Number.NaN, this.y = Number.NaN, this.m_attribs = null, t3) {
      if (!t3.copy) return t3.move ? (this.m_description = t3.move.m_description, t3.move.m_description = null, this.m_attribs = t3.move.m_attribs, t3.move.m_attribs = null, this.x = t3.move.x, void (this.y = t3.move.y)) : t3.vd ? (this.m_description = t3.vd, void (t3.attribBuffer ? (this.m_attribs = t3.attribBuffer, t3.initDefaultValues && this.setDefaultAttributeValues()) : this.ensureAttributes())) : t3.pt ? (this.m_description = M(), void this.setXY(t3.pt)) : void ("x" in t3 && ("z" in t3 ? (this.m_description = O2(), this.ensureAttributes(), this.setXYZ(new X(t3.x, t3.y, t3.z))) : (this.m_description = M(), this.setXYCoords(t3.x, t3.y))));
      t3.copy.copyTo(this);
    } else this.m_description = M();
  }
  assignCopy(t3) {
    return this.m_attribs = null, t3.copyTo(this), this;
  }
  assignMove(t3) {
    return this.m_attribs = null, t3.copyTo(this), t3.setEmpty(), this;
  }
  getXY() {
    return new mi(this.x, this.y);
  }
  queryXY(t3) {
    t3.x = this.x, t3.y = this.y;
  }
  setXY(t3) {
    this.x = t3.x, this.y = t3.y;
  }
  setXYCoords(t3, e2) {
    this.x = t3, this.y = e2;
  }
  getXYZ() {
    const t3 = new X();
    return t3.x = this.x, t3.y = this.y, t3.z = this.getZ(), t3;
  }
  setXYZ(t3) {
    this.addAttribute(1), this.x = t3.x, this.y = t3.y, this.m_attribs[0] = t3.z;
  }
  getX() {
    return this.x;
  }
  setX(t3) {
    this.x = t3;
  }
  getY() {
    return this.y;
  }
  setY(t3) {
    this.y = t3;
  }
  getZ() {
    return this.m_description.hasZ() ? this.m_attribs[0] : te.getDefaultValue(1);
  }
  setZ(t3) {
    this.addAttribute(1), this.m_attribs[0] = t3;
  }
  getM() {
    return this.getAttributeAsDbl(2, 0);
  }
  setM(t3) {
    this.addAttribute(2), this.m_description.hasZ() ? this.m_attribs[1] = t3 : this.m_attribs[0] = t3;
  }
  getID() {
    return this.getAttributeAsInt(3, 0);
  }
  setID(t3) {
    this.setAttributeBasic(3, 0, t3);
  }
  isEqualXY(t3, e2) {
    return void 0 === e2 && (e2 = 0), Math.abs(t3.x - this.x) <= e2 && Math.abs(t3.y - this.y) <= e2;
  }
  isEqualXYCoords(t3, e2, s3) {
    return void 0 === s3 && (s3 = 0), Math.abs(t3 - this.x) <= s3 && Math.abs(e2 - this.y) <= s3;
  }
  getAttributeAsDbl(t3, e2) {
    if (0 === t3) {
      if (0 === e2) return this.x;
      if (1 === e2) return this.y;
      A("");
    }
    const s3 = te.getComponentCount(t3);
    (e2 < 0 || e2 >= s3) && A("");
    const i2 = this.m_description.getAttributeIndex(t3);
    return i2 >= 0 ? this.m_attribs[this.m_description.getPointAttributeOffset(i2) - 2 + e2] : te.getDefaultValue(t3);
  }
  getAttributeAsInt(t3, e2) {
    return Math.trunc(this.getAttributeAsDbl(t3, e2));
  }
  setAttributeBasic(t3, e2, s3) {
    if (0 === t3) return void (0 === e2 ? this.x = s3 : 1 === e2 ? this.y = s3 : A(""));
    const i2 = te.getComponentCount(t3);
    (e2 < 0 || e2 >= i2) && A("");
    let n5 = this.m_description.getAttributeIndex(t3);
    n5 < 0 && (this.addAttribute(t3), n5 = this.m_description.getAttributeIndex(t3)), this.m_attribs[this.m_description.getPointAttributeOffset(n5) - 2 + e2] = s3;
  }
  copyAttributesFrom(t3, e2) {
    if (this === t3) return;
    const s3 = t3.getDescription();
    for (let i2 = e2 && s3.hasZ() ? 2 : 1, n5 = s3.getAttributeCount(); i2 < n5; ++i2) {
      const e3 = s3.getSemantics(i2), n6 = te.getComponentCount(e3);
      for (let s4 = 0; s4 < n6; ++s4) {
        const i3 = t3.getAttributeAsDbl(e3, s4);
        this.setAttributeBasic(e3, s4, i3);
      }
    }
  }
  getAttributeArray() {
    return this.m_attribs;
  }
  getDescription() {
    return this.m_description;
  }
  assignVertexDescription(t3) {
    this.m_description !== t3 && this.assignVertexDescriptionImpl(t3);
  }
  mergeVertexDescription(t3) {
    this.m_description !== t3 && (this.m_description.hasAttributesFrom(t3) || this.mergeVertexDescriptionImpl(t3));
  }
  hasAttribute(t3) {
    return this.m_description.hasAttribute(t3);
  }
  addAttribute(t3) {
    if (this.m_description.hasAttribute(t3)) return;
    const e2 = V2(this.m_description, t3);
    this.assignVertexDescription(e2);
  }
  dropAttribute(t3) {
    if (!this.m_description.hasAttribute(t3)) return;
    const e2 = k3(this.m_description, t3);
    this.assignVertexDescription(e2);
  }
  dropAllAttributes() {
    const t3 = M();
    t3 !== this.m_description && this.assignVertexDescription(t3);
  }
  getGeometryType() {
    return a.enumPoint;
  }
  getDimension() {
    return 0;
  }
  queryEnvelope(t3) {
    if (t3 instanceof re) return t3.setEmpty(), t3.assignVertexDescription(this.m_description), void t3.merge(this);
    if (t3 instanceof G3) {
      if (this.isEmpty()) return void t3.setEmpty();
      const e2 = this.getXYZ();
      return t3.xmin = e2.x, t3.ymin = e2.y, t3.zmin = e2.z, t3.xmax = e2.x, t3.ymax = e2.y, void (t3.zmax = e2.z);
    }
    this.isEmpty() ? t3.setEmpty() : (t3.xmin = this.x, t3.ymin = this.y, t3.xmax = this.x, t3.ymax = this.y);
  }
  queryLooseEnvelope(t3) {
    this.queryEnvelope(t3);
  }
  queryInterval(t3, e2) {
    const s3 = new x2();
    if (this.isEmpty()) return s3.setEmpty(), s3;
    const i2 = this.getAttributeAsDbl(t3, e2);
    return s3.vmin = i2, s3.vmax = i2, s3;
  }
  applyTransformation(t3) {
    if (!this.isEmpty()) {
      if (1 === t3.m_TransformationType) {
        const e2 = this.getXY();
        return t3.transformInPlace(e2), void this.setXY(e2);
      }
      z("3d not impl");
    }
  }
  transformAttribute(t3, e2, s3, i2, n5) {
    if (this.isEmpty()) return;
    this.addAttribute(t3);
    const r = this.getAttributeAsDbl(t3, e2), h2 = Nt(s3, i2, n5);
    this.setAttributeBasic(t3, e2, h2(r));
  }
  createInstance() {
    return new _ee({ vd: this.m_description });
  }
  copyTo(t3) {
    if (this === t3) return;
    t3.getGeometryType() !== a.enumPoint && P();
    const e2 = t3;
    e2.x = this.x, e2.y = this.y, this.m_attribs ? (e2.assignVertexDescription(this.m_description), e2.m_attribs = this.m_attribs.slice()) : (e2.releaseAttributes(), e2.assignVertexDescription(this.m_description));
  }
  isEmpty() {
    return Number.isNaN(this.x) || Number.isNaN(this.y);
  }
  setEmpty() {
    this.m_description || (this.m_description = M(), this.releaseAttributes()), this.x = Number.NaN, this.y = Number.NaN, this.m_attribs && Dt(this.m_attribs, this.m_description.getDefaultPointAttributes(), 0, 2, this.m_description.getTotalComponentCount() - 2);
  }
  calculateArea2D() {
    return 0;
  }
  calculateLength2D() {
    return 0;
  }
  calculateLength3D(t3) {
    return 0;
  }
  equals(t3, e2) {
    if (t3 === this) return true;
    if (t3.getGeometryType() !== a.enumPoint) return false;
    const s3 = t3;
    if (this.m_description !== s3.m_description) return false;
    if (this.isEmpty() !== s3.isEmpty()) return false;
    if (this.isEmpty()) return true;
    if (void 0 === e2 && (e2 = 0), Math.abs(this.x - s3.x) > e2) return false;
    if (Math.abs(this.y - s3.y) > e2) return false;
    for (let n5 = 0, r = this.m_description.getTotalComponentCount() - 2; n5 < r; n5++) if (!cs(this.m_attribs[n5], s3.m_attribs[n5], e2)) return false;
    return true;
  }
  getBoundary() {
    return null;
  }
  clone() {
    const t3 = new _ee({ vd: this.m_description });
    return this.copyTo(t3), t3;
  }
  swap(t3) {
    if (this === t3) return;
    t3.getGeometryType() !== a.enumPoint && P("wrong geometry type");
    const e2 = t3;
    e2.m_description = Pt(this.m_description, this.m_description = e2.m_description), e2.x = Pt(this.x, this.x = e2.x), e2.y = Pt(this.y, this.y = e2.y), e2.m_attribs = Pt(this.m_attribs, this.m_attribs = e2.m_attribs);
  }
  replaceNaNs(t3, e2) {
    if (this.addAttribute(t3), this.isEmpty()) return;
    const s3 = te.getComponentCount(t3);
    for (let i2 = 0; i2 < s3; i2++) {
      const s4 = this.getAttributeAsDbl(t3, i2);
      Number.isNaN(s4) && this.setAttributeBasic(t3, i2, e2);
    }
  }
  lerp(t3, e2, s3) {
    if (t3.getDescription() !== e2.getDescription() && P("Point.lerp"), this.assignVertexDescription(t3.getDescription()), t3.isEmpty() || e2.isEmpty()) return this.setEmpty(), this;
    this.ensureAttributes();
    const i2 = B3();
    t3.queryValues(i2, i2.length);
    const n5 = B3();
    e2.queryValues(n5, n5.length);
    const r = B3();
    let h2 = i2, o = n5;
    const a2 = r;
    let m3 = 0;
    for (let l2 = 0, u = this.m_description.getAttributeCount(); l2 < u; l2++) {
      const t4 = this.m_description.getSemantics(l2), e3 = te.getInterpolation(t4), i3 = te.getComponentCount(t4), n6 = te.getDefaultValue(t4);
      wt(e3, h2, o, a2, m3, i3, s3, n6), h2 = h2.slice(i3), o = o.slice(i3), m3 += i3;
    }
    return this.setValues(r, m3), this;
  }
  static lerp(t3, e2, s3, i2) {
    i2.lerp(t3, e2, s3);
  }
  setDefaultAttributeValues() {
    const t3 = this.m_description.getTotalComponentCount() - 2;
    t3 > 0 && (this.m_attribs ? Dt(this.m_attribs, this.m_description.getDefaultPointAttributes(), 0, 2, t3) : this.m_attribs = this.m_description.getDefaultPointAttributes().slice(2));
  }
  static sqrDistance2D(t3, e2) {
    return mi.sqrDistanceCoords(t3.x, t3.y, e2.x, e2.y);
  }
  getImpl() {
    return this;
  }
  mergeVertexDescriptionImpl(t3) {
    const e2 = H2(this.getDescription(), t3);
    this.assignVertexDescription(e2);
  }
  releaseAttributes() {
    this.m_attribs = null;
  }
  assignVertexDescriptionImpl(t3) {
    this.m_description || (this.m_description = M());
    const e2 = S2();
    Y2(t3, this.m_description, e2);
    let s3 = null;
    t3.getTotalComponentCount() - 2 > 0 && (s3 = t3.getDefaultPointAttributes().slice(2));
    for (let i2 = 1, n5 = t3.getAttributeCount(); i2 < n5; i2++) {
      const n6 = e2[i2];
      if (-1 !== n6) {
        const e3 = this.m_description.getPointAttributeOffset(n6) - 2, r = t3.getPointAttributeOffset(i2) - 2, h2 = te.getComponentCount(t3.getSemantics(i2));
        for (let t4 = 0; t4 < h2; t4++) s3[r + t4] = this.m_attribs[e3 + t4];
      }
    }
    this.m_attribs = s3, this.m_description = t3;
  }
  ensureAttributes() {
    this.m_description.getTotalComponentCount() - 2 > 0 && null === this.m_attribs && (this.m_attribs = this.m_description.getDefaultPointAttributes().slice(2));
  }
  queryValues(t3, e2) {
    const s3 = this.m_description.getTotalComponentCount();
    n(s3 <= e2), t3[0] = this.x, t3[1] = this.y, Dt(t3, this.m_attribs, 2, 0, s3 - 2);
  }
  copyCommonAttributesTo(t3) {
    t3.x = this.x, t3.y = this.y;
    const e2 = t3.getDescription();
    if (e2 === this.m_description) this.m_attribs && Dt(t3.m_attribs, this.m_attribs, 0, 0, this.m_description.getTotalComponentCount() - 2);
    else {
      let s3 = 0;
      for (let i2 = 1, n5 = e2.getAttributeCount(); i2 < n5; i2++) {
        const n6 = e2.getSemantics(i2);
        let r = te.getComponentCount(n6);
        if (this.m_description.hasAttribute(n6)) {
          let e3 = this.m_description.getPointAttributeOffset(this.m_description.getAttributeIndex(n6)) - 2;
          for (; 0 !== r; ) t3.m_attribs[s3++] = this.m_attribs[e3++], r--;
        } else {
          const e3 = te.getDefaultValue(n6);
          for (; 0 !== r; ) t3.m_attribs[s3++] = e3, r--;
        }
      }
    }
  }
  setValues(t3, e2) {
    const s3 = this.m_description.getTotalComponentCount();
    n(s3 <= e2), this.x = t3[0], this.y = t3[1], Dt(this.m_attribs, t3, 0, 2, s3 - 2);
  }
  dbgDefaultAttribs() {
  }
};
ee.type = a.enumPoint;
var se = z3;
function ie(t3, e2) {
  return e2 * (t3.getTotalComponentCount() - 2);
}
var ne = class {
  constructor(t3) {
    if (this.m_attributes = null, t3) if (void 0 !== t3.xmin) this.m_envelope2D = new n3(t3.xmin, t3.ymin, t3.xmax, t3.ymax);
    else if (void 0 !== t3.env2D) this.m_envelope2D = new n3(t3.env2D);
    else if (t3.move) this.m_envelope2D = new n3(t3.move.m_envelope2D), this.m_attributes = t3.move.m_attributes, t3.move.m_attributes = null;
    else {
      if (!t3.moveEnv) throw new Error("unrecognized EnvelopeData constructor options");
      {
        const e2 = t3.moveEnv.accessEnvelopeData();
        this.m_envelope2D = new n3(e2.m_envelope2D), this.m_attributes = e2.m_attributes, e2.m_attributes = null;
      }
    }
    else this.m_envelope2D = n3.constructEmpty();
  }
  ensureAttributes(t3) {
    const s3 = t3.getTotalComponentCount() - 2;
    !this.m_attributes && s3 && (this.m_attributes = Yt(2 * s3, Number.NaN), this.m_attributes.fill(Number.NaN));
  }
  copyTo(t3, s3) {
    const i2 = s3, n5 = t3.getTotalComponentCount() - 2;
    if (i2.m_description !== t3 && (i2.releaseAttributes_(), i2.m_description = t3, n5 && (i2.m_data.m_attributes = Yt(2 * n5, Number.NaN))), n5) {
      n(this.m_attributes && i2.m_data.m_attributes);
      const t4 = 2 * n5;
      Dt(i2.m_data.m_attributes, this.m_attributes, 0, 0, t4);
    }
    i2.m_data.m_envelope2D = new n3(this.m_envelope2D);
  }
  copyToIfNotNull(t3, e2) {
    e2.m_envelope2D = new n3(this.m_envelope2D), e2.releaseAttributes();
    t3.getTotalComponentCount() - 2 && this.m_attributes && (e2.m_attributes = this.m_attributes.slice());
  }
  releaseAttributes() {
    this.m_attributes = null;
  }
  isEmpty() {
    return this.m_envelope2D.isEmpty();
  }
  transformAttribute(t3, e2, s3, i2, n5) {
    n(0);
  }
  queryInterval(t3, e2, s3, i2) {
    if (this.isEmpty()) return void i2.setEmpty();
    if (0 === e2) return void (0 === s3 ? this.m_envelope2D.queryIntervalX(i2) : 1 === s3 ? this.m_envelope2D.queryIntervalY(i2) : A(""));
    const n5 = se.getComponentCount(e2);
    (s3 < 0 || s3 >= n5) && A("");
    const r = t3.getAttributeIndex(e2);
    if (r >= 0) return i2.vmin = this.m_attributes[ie(t3, 0) + t3.getPointAttributeOffset(r) - 2 + s3], void (i2.vmax = this.m_attributes[ie(t3, 1) + t3.getPointAttributeOffset(r) - 2 + s3]);
    {
      const t4 = se.getDefaultValue(e2);
      return void i2.setCoords(t4, t4);
    }
  }
  queryEnvelope3D(t3, e2) {
    const s3 = new x2();
    this.queryInterval(t3, 1, 0, s3), e2.setCoords(this.m_envelope2D.xmin, this.m_envelope2D.ymin, s3.vmin, this.m_envelope2D.xmax, this.m_envelope2D.ymax, s3.vmax);
  }
  setEmpty(t3) {
    this.m_envelope2D.setEmpty();
    const s3 = t3.getTotalComponentCount() - 2;
    s3 && (this.m_attributes ? this.dbgAssertSize(s3) : this.m_attributes = Yt(2 * s3, Number.NaN), this.m_attributes.fill(Number.NaN));
  }
  dbgAssertSize(t3) {
  }
};
var re = class t2 {
  constructor(t3) {
    if (this.m_EnvelopeType = 4, this.m_description = M(), void 0 === t3) this.m_data = new ne();
    else if (void 0 !== t3.vd) this.m_description = t3.vd, this.m_data = new ne(), this.ensureAttributes_();
    else if (t3?.env2D) this.m_data = new ne({ env2D: t3.env2D });
    else if (void 0 !== t3.xmin) this.m_data = new ne({ xmin: t3.xmin, ymin: t3.ymin, xmax: t3.xmax, ymax: t3.ymax });
    else if (t3.copy) this.m_data = new ne(), t3.copy.copyTo(this);
    else if (t3.move) this.m_description = t3.move.m_description, t3.move.m_description = null, this.m_data = new ne({ move: t3.move.m_data });
    else {
      if (!t3.centerPoint) throw new Error("unrecognized Envelope constructor options");
      this.m_description = t3.centerPoint.getDescription(), this.m_data = new ne(), this.ensureAttributes_(), this.setFromPoint(t3.centerPoint, t3.width, t3.height);
    }
  }
  accessEnvelopeData() {
    return this.m_description = null, this.m_data;
  }
  assignMove(t3) {
    return this === t3 || (this.m_description = t3.m_description, t3.m_description = null, this.m_data = new ne({ move: t3.m_data })), this;
  }
  assignCopy(t3) {
    return this === t3 || t3.copyTo(this), this;
  }
  transformAttribute(t3, e2, s3, i2, n5) {
    n(0);
  }
  setAttributeBasic(t3, e2, s3) {
    if (this.addAttribute(t3), this.m_data.isEmpty()) return;
    const i2 = this.queryInterval(t3, e2);
    i2.vmin = s3, i2.vmax = s3, this.setIntervalEnvelope(t3, e2, i2);
  }
  mergeVertexDescriptionImpl(t3) {
    const e2 = H2(this.getDescription(), t3);
    this.assignVertexDescription(e2);
  }
  asEnvelope2D() {
    return new n3(this.m_data.m_envelope2D);
  }
  assignVertexDescription(t3) {
    this.m_description !== t3 && this.assignVertexDescriptionImpl(t3);
  }
  getGeometryType() {
    return a.enumEnvelope;
  }
  getDimension() {
    return 2;
  }
  getXMin() {
    return this.m_data.m_envelope2D.xmin;
  }
  getYMin() {
    return this.m_data.m_envelope2D.ymin;
  }
  getXMax() {
    return this.m_data.m_envelope2D.xmax;
  }
  getYMax() {
    return this.m_data.m_envelope2D.ymax;
  }
  width() {
    return this.m_data.isEmpty() ? Number.NaN : this.m_data.m_envelope2D.width();
  }
  height() {
    return this.m_data.isEmpty() ? Number.NaN : this.m_data.m_envelope2D.height();
  }
  getCenterXY() {
    return this.m_data.isEmpty() ? new mi() : this.m_data.m_envelope2D.getCenter();
  }
  getCenter(t3) {
    if (t3.assignVertexDescription(this.m_description), this.m_data.isEmpty()) return void t3.setEmpty();
    const e2 = this.m_description.getAttributeCount();
    for (let s3 = 1; s3 < e2; s3++) {
      const e3 = this.m_description.getSemantics(s3), i2 = se.getComponentCount(e3);
      for (let s4 = 0; s4 < i2; s4++) {
        const i3 = 0.5 * (this.getAttributeAsDblImpl(0, e3, s4) + this.getAttributeAsDblImpl(1, e3, s4));
        t3.setAttributeBasic(e3, s4, i3);
      }
    }
    t3.setXY(this.m_data.m_envelope2D.getCenter());
  }
  setCoords(t3, e2, s3, i2) {
    this.m_data.m_envelope2D.setCoords({ xmin: t3, ymin: e2, xmax: s3, ymax: i2 });
  }
  setEnvelope(t3) {
    if (t3 instanceof n3) this.m_data.m_envelope2D = new n3(t3), this.m_data.m_envelope2D.normalize();
    else {
      this.addAttribute(1), this.m_data.m_envelope2D = t3.getEnvelope2D(), this.m_data.m_envelope2D.normalize();
      const e2 = x2.constructEmpty();
      e2.setCoords(t3.zmin, t3.zmax), this.setInterval(1, 0, e2.vmin, e2.vmax);
    }
  }
  merge(e2) {
    if (e2 instanceof n3) return e2.isValid() || P(""), void this.m_data.m_envelope2D.mergeEnvelope2D(e2);
    if (e2 instanceof t2) {
      if (e2.m_data.isEmpty()) return;
      const t3 = e2.getDescription();
      this.mergeVertexDescription(t3), this.m_data.m_envelope2D.mergeEnvelope2D(e2.m_data.m_envelope2D);
      for (let s3 = 1, i2 = t3.getAttributeCount(); s3 < i2; s3++) {
        const i3 = t3.getSemantics(s3), n5 = se.getComponentCount(i3);
        for (let t4 = 0; t4 < n5; t4++) {
          const s4 = e2.queryInterval(i3, t4), n6 = this.queryInterval(i3, t4);
          n6.merge(s4), this.setIntervalEnvelope(i3, t4, n6);
        }
      }
      return;
    }
    if (e2 instanceof ee) {
      const t3 = e2;
      if (t3.isEmpty()) return;
      const s3 = t3.getDescription();
      if (this.mergeVertexDescription(s3), this.m_data.isEmpty()) return void this.setFromPoint(t3);
      this.m_data.m_envelope2D.merge(t3.getXY());
      for (let e3 = 1, i2 = s3.getAttributeCount(); e3 < i2; e3++) {
        const i3 = s3.getSemantics(e3), n5 = se.getComponentCount(i3);
        for (let e4 = 0; e4 < n5; e4++) {
          const s4 = t3.getAttributeAsDbl(i3, e4), n6 = this.queryInterval(i3, e4);
          n6.mergeCoordinate(s4), this.setIntervalEnvelope(i3, e4, n6);
        }
      }
      return;
    }
    z("unrecognized type for envelope.merge");
  }
  intersect(t3) {
    if (!this.m_data.m_envelope2D.intersect(t3.m_data.m_envelope2D)) return this.setEmpty(), false;
    const e2 = t3.getDescription();
    this.mergeVertexDescription(e2);
    for (let s3 = 1, i2 = this.m_description.getAttributeCount(); s3 < i2; s3++) {
      const e3 = this.m_description.getSemantics(s3), i3 = se.getComponentCount(e3);
      for (let s4 = 0; s4 < i3; s4++) {
        const i4 = t3.queryInterval(e3, s4), n5 = this.queryInterval(e3, s4);
        n5.intersect(i4), this.setIntervalEnvelope(e3, s4, n5);
      }
    }
    return true;
  }
  intersectCommonAttributes(t3) {
    if (!this.m_data.m_envelope2D.intersect(t3.m_data.m_envelope2D)) return this.setEmpty(), false;
    const e2 = t3.getDescription();
    for (let s3 = 1, i2 = this.m_description.getAttributeCount(); s3 < i2; s3++) {
      const i3 = this.m_description.getSemantics(s3);
      if (!e2.hasAttribute(i3)) continue;
      const n5 = se.getComponentCount(i3);
      for (let e3 = 0; e3 < n5; e3++) {
        const s4 = t3.queryInterval(i3, e3), n6 = this.queryInterval(i3, e3);
        n6.intersect(s4), this.setIntervalEnvelope(i3, e3, n6);
      }
    }
    return true;
  }
  move(t3, e2) {
    this.m_data.m_envelope2D.move(t3, e2);
  }
  centerAt(t3, e2) {
    this.m_data.m_envelope2D.centerAtCoords(t3, e2);
  }
  centerAtPoint(t3) {
    this.m_data.m_envelope2D.centerAt(t3);
  }
  reaspect(t3, e2) {
    this.m_data.m_envelope2D.reaspect(t3, e2);
  }
  inflateCoords(t3, e2) {
    this.m_data.m_envelope2D.inflateCoords(t3, e2);
  }
  containsCoords(t3, e2) {
    return this.m_data.m_envelope2D.containsCoords(t3, e2);
  }
  contains(t3) {
    return this.m_data.m_envelope2D.contains(t3);
  }
  containsPoint(t3) {
    return !t3.isEmpty() && this.m_data.m_envelope2D.contains(t3.getXY());
  }
  containsEnvelope(t3) {
    return this.m_data.m_envelope2D.containsEnvelope(t3.m_data.m_envelope2D);
  }
  setIntervalEnvelope(t3, e2, s3) {
    if (this.addAttribute(t3), this.m_data.isEmpty()) return;
    const i2 = new x2(s3);
    if (i2.normalize(), 0 === t3) {
      if (i2.isEmpty()) return void this.setEmpty();
      0 === e2 ? (this.m_data.m_envelope2D.xmin = i2.vmin, this.m_data.m_envelope2D.xmax = i2.vmax) : 1 === e2 ? (this.m_data.m_envelope2D.ymin = i2.vmin, this.m_data.m_envelope2D.ymax = i2.vmax) : A("");
    } else this.setAttributeAsDblImpl(0, t3, e2, i2.vmin), this.setAttributeAsDblImpl(1, t3, e2, i2.vmax);
  }
  setInterval(t3, e2, s3, i2) {
    this.setIntervalEnvelope(t3, e2, new x2(s3, i2));
  }
  queryInterval(t3, e2) {
    const s3 = new x2();
    return this.m_data.queryInterval(this.m_description, t3, e2, s3), s3;
  }
  queryEnvelope(t3) {
    2 !== t3.m_EnvelopeType ? 3 !== t3.m_EnvelopeType ? 4 !== t3.m_EnvelopeType ? z("unrecognized type for queryEnveloper") : this.copyTo(t3) : this.m_data.queryEnvelope3D(this.m_description, t3) : t3.setCoords({ env2D: this.m_data.m_envelope2D });
  }
  applyTransformation(t3) {
    1 !== t3.m_TransformationType ? n(0) : t3.transformEnvInPlace(this.m_data.m_envelope2D);
  }
  createInstance() {
    return new t2({ vd: this.m_description });
  }
  copyTo(t3) {
    t3 !== this && this.m_data.copyTo(this.m_description, t3);
  }
  isEmpty() {
    return this.m_data.isEmpty();
  }
  setEmpty() {
    this.m_description || (this.m_description = M()), this.m_data.setEmpty(this.m_description);
  }
  calculateArea2D() {
    return this.m_data.m_envelope2D.getArea();
  }
  calculateLength2D() {
    return this.m_data.m_envelope2D.getLength();
  }
  calculateLength3D(t3) {
    return n(0), 0;
  }
  equals(t3, e2) {
    if (t3 === this) return true;
    const s3 = t3;
    if (this.m_description !== s3.m_description) return false;
    if (this.m_data.isEmpty() !== s3.m_data.isEmpty()) return false;
    if (this.m_data.isEmpty()) return true;
    if (void 0 === e2 && (e2 = 0), Math.abs(this.m_data.m_envelope2D.xmin - s3.m_data.m_envelope2D.xmin) > e2) return false;
    if (Math.abs(this.m_data.m_envelope2D.ymin - s3.m_data.m_envelope2D.ymin) > e2) return false;
    if (Math.abs(this.m_data.m_envelope2D.xmax - s3.m_data.m_envelope2D.xmax) > e2) return false;
    if (Math.abs(this.m_data.m_envelope2D.ymax - s3.m_data.m_envelope2D.ymax) > e2) return false;
    for (let n5 = 0, r = 2 * (this.m_description.getTotalComponentCount() - 2); n5 < r; n5++) if (!cs(this.m_data.m_attributes[n5], s3.m_data.m_attributes[n5], e2)) return false;
    return true;
  }
  getBoundary() {
    return z("getBoundary not available in this context. Use the boundary operator with an envelope parameter"), null;
  }
  clone() {
    return new t2({ copy: this });
  }
  swap(t3) {
    if (this === t3) return;
    t3.getGeometryType() !== a.enumEnvelope && P("wrong geometry type");
    const e2 = t3;
    e2.m_description = Pt(this.m_description, this.m_description = e2.m_description), e2.m_data.m_envelope2D = Pt(this.m_data.m_envelope2D, this.m_data.m_envelope2D = e2.m_data.m_envelope2D), e2.m_data.m_attributes = Pt(this.m_data.m_attributes, this.m_data.m_attributes = e2.m_data.m_attributes);
  }
  queryCoordinates(t3) {
    this.m_data.isEmpty() && P(""), this.m_data.m_envelope2D.queryCorners(t3);
  }
  queryCornerByVal(t3, e2) {
    (t3 < 0 || t3 > 3) && A(""), e2.assignVertexDescription(this.m_description);
    const s3 = this.getDescription().getAttributeCount();
    for (let i2 = 1; i2 < s3; i2++) {
      const s4 = this.m_description.getSemantics(i2), n5 = se.getComponentCount(s4);
      for (let i3 = 0; i3 < n5; i3++) e2.setAttributeBasic(s4, i3, this.getAttributeAsDblImpl(t3 % 2, s4, i3));
    }
    e2.setXY(this.m_data.m_envelope2D.queryCorner(t3));
  }
  queryCorner(t3, e2) {
    e2.assign(this.m_data.m_envelope2D.queryCorner(t3));
  }
  getDescription() {
    return this.m_description;
  }
  mergeVertexDescription(t3) {
    this.m_description !== t3 && (this.m_description && this.m_description.hasAttributesFrom(t3) || this.mergeVertexDescriptionImpl(t3));
  }
  hasAttribute(t3) {
    return this.m_description.hasAttribute(t3);
  }
  addAttribute(t3) {
    if (this.m_description.hasAttribute(t3)) return;
    const e2 = V2(this.m_description, t3);
    this.assignVertexDescription(e2);
  }
  dropAttribute(t3) {
    if (!this.m_description.hasAttribute(t3)) return;
    const e2 = k3(this.m_description, t3);
    this.assignVertexDescription(e2);
  }
  dropAllAttributes() {
    const t3 = M();
    t3 !== this.m_description && this.assignVertexDescription(t3);
  }
  queryLooseEnvelope(t3) {
    this.queryEnvelope(t3);
  }
  replaceNaNs(t3, e2) {
    if (this.addAttribute(t3), this.m_data.isEmpty()) return;
    const s3 = se.getComponentCount(t3);
    for (let i2 = 0; i2 < s3; i2++) {
      const s4 = this.queryInterval(t3, i2);
      s4.isEmpty() && (s4.vmin = e2, s4.vmax = e2, this.setIntervalEnvelope(t3, i2, s4));
    }
  }
  getImpl() {
    return this;
  }
  setFromPoint(t3, e2, s3) {
    this.m_data.m_envelope2D.setCoords({ center: t3.getXY(), width: e2 ?? 0, height: s3 ?? 0 });
    const i2 = t3.getDescription();
    for (let n5 = 1, r = i2.getAttributeCount(); n5 < r; n5++) {
      const e3 = i2.getSemantics(n5), s4 = se.getComponentCount(e3);
      for (let i3 = 0; i3 < s4; i3++) {
        const s5 = t3.getAttributeAsDbl(e3, i3);
        this.setInterval(e3, i3, s5, s5);
      }
    }
  }
  assignVertexDescriptionImpl(t3) {
    const s3 = S2();
    Y2(t3, this.m_description, s3);
    let i2 = null;
    const n5 = t3.getTotalComponentCount() - 2, r = this.m_description ? this.m_description.getTotalComponentCount() - 2 : 0;
    n5 > 0 && (i2 = Yt(2 * n5, Number.NaN));
    for (let e2 = 1; e2 < t3.getAttributeCount(); e2++) {
      const h2 = s3[e2];
      if (-1 !== h2) {
        const s4 = t3.getPointAttributeOffset(e2) - 2, o = se.getComponentCount(t3.getSemantics(e2)), a2 = this.m_description.getPointAttributeOffset(h2) - 2;
        Dt(i2, this.m_data.m_attributes, s4, a2, o), Dt(i2, this.m_data.m_attributes, n5 + s4, r + a2, o);
      }
    }
    this.releaseAttributes_(), this.m_data.m_attributes = i2, this.m_description = t3;
  }
  getAttributeAsDblImpl(t3, e2, s3) {
    if (this.m_data.isEmpty() && x(""), 0 === e2) return t3 ? s3 ? this.m_data.m_envelope2D.ymax : this.m_data.m_envelope2D.xmax : s3 ? this.m_data.m_envelope2D.ymin : this.m_data.m_envelope2D.xmin;
    s3 >= se.getComponentCount(e2) && A("");
    const i2 = this.m_description.getAttributeIndex(e2);
    return i2 >= 0 ? this.m_data.m_attributes[ie(this.m_description, t3) + this.m_description.getPointAttributeOffset(i2) - 2 + s3] : z3.getDefaultValue(e2);
  }
  setAttributeAsDblImpl(t3, e2, s3, i2) {
    0 === e2 && (t3 ? 1 === s3 ? this.m_data.m_envelope2D.ymax = i2 : 0 === s3 ? this.m_data.m_envelope2D.xmax = i2 : A("") : 1 === s3 ? this.m_data.m_envelope2D.ymin = i2 : 0 === s3 ? this.m_data.m_envelope2D.xmin = i2 : A(""));
    const n5 = se.getComponentCount(e2);
    (s3 < 0 || s3 >= n5) && A(""), this.addAttribute(e2);
    const r = this.m_description.getAttributeIndex(e2);
    this.m_data.m_attributes[ie(this.m_description, t3) + this.m_description.getPointAttributeOffset(r) - 2 + s3] = i2;
  }
  releaseAttributes_() {
    this.m_data.releaseAttributes();
  }
  ensureAttributes_() {
    this.m_data.ensureAttributes(this.m_description);
  }
};
re.type = a.enumEnvelope;
var he = Object.freeze(Object.defineProperty({ __proto__: null, Envelope: re, EnvelopeData: ne }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/MultiPathImpl.js
var ge = class extends t {
  constructor(t3, e2) {
    super(), this.m_index = -1, this.gc = t3, this.dim = e2;
  }
  next() {
    for (; ; ) {
      if (this.m_index >= this.gc.getGeometryCount()) return null;
      if (this.m_index++, this.m_index === this.gc.getGeometryCount()) return null;
      const t3 = this.gc.getGeometry(this.m_index);
      if (-1 === this.dim || 1 << t3.getDimension() & this.dim) return t3;
    }
    return null;
  }
  getGeometryID() {
    return this.m_index;
  }
  tock() {
    return true;
  }
  getRank() {
    return 1;
  }
};
var de = class _de {
  constructor(e2) {
    this.m_geoms = [], this.m_description = M(), e2 && (e2.vd ? this.m_description = e2.vd : e2.copy ? e2.copy.copyTo(this) : P("constructor argument not recognized"));
  }
  getGeometryCount() {
    return this.m_geoms.length;
  }
  reserve(t3) {
  }
  addGeometry(t3) {
    if (t3.getGeometryType() === a.enumGeometryCollection) {
      const e2 = t3;
      for (let t4 = 0, s3 = e2.getGeometryCount(); t4 < s3; t4++) this.addGeometry(e2.getGeometry(t4));
    } else this.m_geoms.push(t3.clone()), this.mergeVertexDescription(t3.getDescription());
  }
  addCursor(t3) {
    for (let e2 = t3.next(); null !== e2; e2 = t3.next()) this.addGeometry(e2);
  }
  getGeometry(e2) {
    return (e2 < 0 || e2 >= this.m_geoms.length) && P("Geometry_collection.get_geometry"), this.m_geoms[e2];
  }
  modifiedElementIndex(t3) {
    this.mergeVertexDescription(this.getGeometry(t3).getDescription());
  }
  modifiedElement(t3) {
    this.mergeVertexDescription(t3.getDescription());
  }
  getGeometryType() {
    return a.enumGeometryCollection;
  }
  getDimension() {
    let t3 = 0;
    for (const e2 of this.m_geoms) t3 = Math.max(t3, e2.getDimension());
    return t3;
  }
  getDescription() {
    return this.m_description;
  }
  assignVertexDescription(t3) {
    this.m_description !== t3 && this.assignVertexDescriptionImpl(t3);
  }
  assignVertexDescriptionImpl(t3) {
    for (const e2 of this.m_geoms) e2.assignVertexDescription(t3);
    this.m_description = t3;
  }
  mergeVertexDescription(t3) {
    this.m_description !== t3 && (this.m_description.hasAttributesFrom(t3) || this.mergeVertexDescriptionImpl(t3));
  }
  hasAttribute(t3) {
    return this.m_description.hasAttribute(t3);
  }
  addAttribute(t3) {
    if (this.m_description.hasAttribute(t3)) return;
    const e2 = V2(this.m_description, t3);
    this.assignVertexDescription(e2);
  }
  dropAttribute(t3) {
    if (!this.m_description.hasAttribute(t3)) return;
    const e2 = k3(this.m_description, t3);
    this.assignVertexDescription(e2);
  }
  dropAllAttributes() {
    const t3 = M();
    t3 !== this.m_description && this.assignVertexDescription(t3);
  }
  queryInterval(t3, e2) {
    let s3 = new x2();
    const n5 = new x2();
    n5.setEmpty();
    for (const i2 of this.m_geoms) s3 = i2.queryInterval(t3, e2), n5.merge(s3);
    return n5;
  }
  queryEnvelope(t3) {
    if (4 === t3.m_EnvelopeType) {
      const e2 = new re();
      t3.setEmpty(), t3.assignVertexDescription(this.m_description);
      for (const s3 of this.m_geoms) s3.queryEnvelope(e2), t3.merge(e2);
    } else if (2 === t3.m_EnvelopeType) {
      const e2 = new n3();
      t3.setEmpty();
      for (const s3 of this.m_geoms) s3.queryEnvelope(e2), t3.mergeEnvelope2D(e2);
    }
    z("3d envelope case not implemented");
  }
  queryLooseEnvelope(t3) {
    if (2 === t3.m_EnvelopeType) {
      const e2 = new n3();
      t3.setEmpty();
      for (const s3 of this.m_geoms) s3.queryLooseEnvelope(e2), t3.mergeEnvelope2D(e2);
    }
    z("3d not impl");
  }
  isEmpty() {
    return 0 === this.m_geoms.length;
  }
  setEmpty() {
    this.m_geoms.length = 0;
  }
  applyTransformation(t3) {
    if (1 === t3.m_TransformationType) for (const e2 of this.m_geoms) e2.applyTransformation(t3);
    z("3d xform not impl");
  }
  transformAttribute(t3, e2, s3, n5, i2) {
    for (const r of this.m_geoms) r.transformAttribute(t3, e2, s3, n5, i2);
  }
  createInstance() {
    return new _de({ vd: this.getDescription() });
  }
  copyTo(s3) {
    s3.getGeometryType() !== a.enumGeometryCollection && P("");
    const n5 = s3;
    if (n5 !== this) {
      n5.m_geoms.length = 0, n5.assignVertexDescription(this.m_description);
      for (const t3 of this.m_geoms) n5.m_geoms.push(t3.clone());
    }
  }
  calculateArea2D() {
    const t3 = new n2(0);
    for (const e2 of this.m_geoms) t3.pe(e2.calculateArea2D());
    return t3.getResult();
  }
  calculateLength2D() {
    const t3 = new n2(0);
    for (const e2 of this.m_geoms) t3.pe(e2.calculateLength2D());
    return t3.getResult();
  }
  calculateLength3D(t3) {
    return n(0), 0;
  }
  getBoundary() {
    const t3 = this.createInstance(), e2 = t3;
    for (const s3 of this.m_geoms) {
      const t4 = s3.getBoundary();
      t4 && e2.m_geoms.push(t4);
    }
    return t3;
  }
  clone() {
    return new _de({ copy: this });
  }
  equals(t3, s3) {
    if (t3 === this) return true;
    if (t3.getGeometryType() !== a.enumGeometryCollection) return false;
    const n5 = t3;
    if (this.m_description !== n5.m_description) return false;
    if (this.m_geoms.length !== n5.m_geoms.length) return false;
    for (let e2 = 0; e2 < this.m_geoms.length; ++e2) if (!this.m_geoms[e2].equals(n5.m_geoms[e2], s3)) return false;
    return true;
  }
  swap(s3) {
    s3.getGeometryType() !== a.enumGeometryCollection && P("");
    const n5 = s3;
    n5 !== this && (this.m_geoms = Pt(n5.m_geoms, n5.m_geoms = this.m_geoms));
  }
  setAttributeBasic(t3, e2, s3) {
    for (const n5 of this.m_geoms) n5.setAttributeBasic(t3, e2, s3);
  }
  replaceNaNs(t3, e2) {
    for (const s3 of this.m_geoms) s3.replaceNaNs(t3, e2);
  }
  getImpl() {
    return this;
  }
  mergeVertexDescriptionImpl(t3) {
    const e2 = this.getDescription(), s3 = H2(e2, t3);
    this.assignVertexDescription(s3);
  }
};
function _e(t3, e2 = -1) {
  return new ge(t3, e2);
}
de.type = a.enumGeometryCollection;
var pe = class _pe {
  constructor() {
    this.m_EnvelopeType = 5, this.envAabb = n3.constructEmpty(), this.envRot = n3.constructEmpty();
  }
  static constructEmpty() {
    return new _pe();
  }
  width() {
    return this.envAabb.width();
  }
  height() {
    return this.envAabb.height();
  }
  maxDim() {
    return Math.max(this.width(), this.height());
  }
  setEmpty() {
    this.envAabb.setEmpty(), this.envRot.setEmpty();
  }
  setCoords(t3) {
    this.envAabb.setCoords(t3), this.envRot.setCoords({ x: ye(t3), y: xe(t3) });
  }
  setFromPoints(t3, e2) {
    this.setEmpty(), this.mergePoints(t3, e2);
  }
  mergeNe(t3) {
    this.envAabb.mergeNe(t3), this.envRot.mergeNeCoords(ye(t3), xe(t3));
  }
  mergePoints(t3, e2) {
    this.envAabb.mergePoints(t3, e2);
    for (let s3 = 0; s3 < e2; ) {
      if (!this.envRot.isEmpty()) {
        for (let n5 = s3; n5 < e2; n5++) {
          const e3 = ye(t3[n5]), s4 = xe(t3[n5]);
          this.envRot.mergeNeCoords(e3, s4);
        }
        break;
      }
      {
        const e3 = ye(t3[s3]), n5 = xe(t3[s3]);
        this.envRot.setCoords({ x: e3, y: n5 }), s3++;
      }
    }
  }
  isIntersectingPoint2D(t3) {
    return !(!this.envAabb.contains(t3) || !this.envRot.containsCoords(ye(t3), xe(t3)));
  }
  isIntersectingW(t3) {
    return this.envAabb.isIntersecting(t3.envAabb) && this.envRot.isIntersecting(t3.envRot);
  }
  containsW(t3) {
    return !(!this.envAabb.containsEnvelope(t3.envAabb) || !this.envRot.containsEnvelope(t3.envRot));
  }
  containsPoint2D(t3) {
    return this.isIntersectingPoint2D(t3);
  }
  intersectW(t3) {
    const e2 = this.envAabb.intersect(t3.envAabb), s3 = this.envRot.intersect(t3.envRot);
    return e2 && !s3 && this.envAabb.setEmpty(), s3 && !e2 && this.envRot.setEmpty(), e2 && s3;
  }
  inflate(t3) {
    this.envAabb.inflateCoords(t3, t3);
    const e2 = t3 * Gs();
    this.envRot.inflateCoords(e2, e2), e2 < 0 && _pe.st_reduceEmpty(this);
  }
  static st_reduceEmpty(t3) {
    const e2 = t3.envAabb.isEmpty(), s3 = t3.envRot.isEmpty();
    e2 && !s3 ? t3.envRot.setEmpty() : s3 && !e2 && t3.envAabb.setEmpty();
  }
  sqrMaxMinDistance(t3) {
    const e2 = this.envAabb.sqrMaxMinDistance(t3), s3 = this.envRot.sqrMaxMinDistance(Ce(t3)) / 2;
    return Math.max(e2, s3);
  }
  sqrMinDistance(t3) {
    const e2 = this.envAabb.sqrMinDistance(t3), s3 = this.envRot.sqrMinDistance(Ce(t3)) / 2;
    return Math.max(e2, s3);
  }
  sqrMaxDistance(t3) {
    const e2 = this.envAabb.sqrMaxDistance(t3), s3 = this.envRot.sqrMaxDistance(Ce(t3)) / 2;
    return Math.max(e2, s3);
  }
  getEnvelope2D() {
    return this.envAabb;
  }
  getRotatedEnvelope2D() {
    return this.envRot;
  }
  xyRot(t3, e2) {
    const s3 = fe(t3.x, t3.y), n5 = Pe(t3.x, t3.y);
    e2.setCoords(s3, n5);
  }
};
function fe(t3, e2) {
  return t3 - e2;
}
function Pe(t3, e2) {
  return t3 + e2;
}
function ye(t3) {
  return t3.x - t3.y;
}
function xe(t3) {
  return t3.x + t3.y;
}
function Ce(t3) {
  return new mi(ye(t3), xe(t3));
}
var ve = class _ve {
  constructor() {
    this.x = p2.getNAN(), this.y = p2.getNAN();
  }
  static getNAN() {
    return new _ve();
  }
  static constructPoint2D(t3) {
    const e2 = new _ve();
    return e2.x.set(t3.x), e2.y.set(t3.y), e2;
  }
  static constructCoords(t3, e2) {
    const s3 = new _ve();
    return s3.x.set(t3), s3.y.set(e2), s3;
  }
  static constructCoordsE(t3, e2) {
    const s3 = new _ve();
    return s3.setCoordsE(t3, e2), s3;
  }
  get 0() {
    return this.x.clone();
  }
  set 0(t3) {
    this.x.setE(t3);
  }
  get 1() {
    return this.y.clone();
  }
  set 1(t3) {
    this.y.setE(t3);
  }
  clone() {
    return new _ve().setE(this);
  }
  scaleThis(t3) {
    return this.x.mulThisE(t3), this.y.mulThisE(t3), this;
  }
  setCoords(t3, e2) {
    return this.x.set(t3), this.y.set(e2), this;
  }
  setCoordsE(t3, e2) {
    return this.x.setE(t3), this.y.setE(e2), this;
  }
  set(t3) {
    return this.x.set(t3.x), this.y.set(t3.y), this;
  }
  setE(t3) {
    return this.x.setE(t3.x), this.y.setE(t3.y), this;
  }
  setWithEps(t3, e2) {
    return this.x.setWithEps(t3.x, e2), this.y.setWithEps(t3.y, e2), this;
  }
  getUnitVector() {
    const t3 = this.clone();
    return t3.normalize(), t3;
  }
  sqrLength() {
    return this.x.sqr().addE(this.y.sqr());
  }
  length() {
    return this.sqrLength().sqrt();
  }
  mulE(t3) {
    const e2 = new _ve();
    return e2.setCoordsE(this.x.mulE(t3), this.y.mulE(t3)), e2;
  }
  mul(t3) {
    const e2 = new _ve();
    return e2.setCoordsE(this.x.mul(t3), this.y.mul(t3)), e2;
  }
  mulThis(t3) {
    return this.x.mulThis(t3), this.y.mulThis(t3), this;
  }
  mulThisE(t3) {
    return this.x.mulThisE(t3), this.y.mulThisE(t3), this;
  }
  divE(t3) {
    return this.clone().divThisE(t3);
  }
  divThisE(t3) {
    return this.x.divThisE(t3), this.y.divThisE(t3), this;
  }
  normalize() {
    const t3 = this.length();
    0 === t3.value() ? (this.x = w2.clone(), this.y = I2.clone()) : (this.x.divThisE(t3), this.y.divThisE(t3));
  }
  addE(t3) {
    return this.clone().addThisE(t3);
  }
  addThisE(t3) {
    return this.x.addThisE(t3.x), this.y.addThisE(t3.y), this;
  }
  subE(t3) {
    return this.clone().subThisE(t3);
  }
  subThisE(t3) {
    return this.x.subThisE(t3.x), this.y.subThisE(t3.y), this;
  }
  static distance(t3, e2) {
    return t3.subE(e2).length();
  }
  negateThis() {
    return this.x.negateThis(), this.y.negateThis(), this;
  }
  eq(t3) {
    return this.x.eq(t3.x) && this.y.eq(t3.y);
  }
  isZero() {
    return this.x.isZero() && this.y.isZero();
  }
  isTrueZero() {
    return !this.x.value() && !this.y.value();
  }
  rotateDirect(t3, e2) {
    const s3 = this.x.mulE(t3).subThisE(this.y.mulE(e2)), n5 = this.x.mulE(e2).addThisE(this.y.mulE(t3));
    return this.x.setE(s3), this.y.setE(n5), this;
  }
  rotateReverse(t3, e2) {
    const s3 = this.x.mulE(t3).addThisE(this.y.mulE(e2)), n5 = this.x.negate().mulThisE(e2).addThisE(this.y.mulE(t3));
    return this.x.setE(s3), this.y.setE(n5), this;
  }
  dotProduct(t3) {
    return this.x.mulE(t3.x).addE(this.y.mulE(t3.y));
  }
  crossProduct(t3) {
    return this.x.mulE(t3.y).subE(this.y.mulE(t3.x));
  }
  value() {
    return mi.construct(this.x.value(), this.y.value());
  }
};
var be = class _be {
  constructor() {
    this.a11 = new p2(1), this.a12 = new p2(0), this.a21 = new p2(0), this.a22 = new p2(1);
  }
  clone() {
    const t3 = new _be();
    return t3.a11.setE(this.a11), t3.a12.setE(this.a12), t3.a21.setE(this.a21), t3.a22.setE(this.a22), t3;
  }
  assign(t3) {
    return this.a11.setE(t3.a11), this.a12.setE(t3.a12), this.a21.setE(t3.a21), this.a22.setE(t3.a22), this;
  }
  mulThis(t3) {
    const e2 = this.a11.mulE(t3.a11).addThisE(this.a12.mulE(t3.a21)), s3 = this.a11.mulE(t3.a12).addThisE(this.a12.mulE(t3.a22)), n5 = this.a21.mulE(t3.a11).addThisE(this.a22.mulE(t3.a21)), i2 = this.a21.mulE(t3.a12).addThisE(this.a22.mulE(t3.a22));
    return this.a11 = e2, this.a12 = s3, this.a21 = n5, this.a22 = i2, this;
  }
  mulLeftThis(t3) {
    const e2 = t3.clone();
    return this.assign(e2.mulThis(this)), this;
  }
  det() {
    return this.a11.mulE(this.a22).subThisE(this.a12.mulE(this.a21));
  }
  invertThis() {
    const t3 = this.det();
    if (0 !== t3.value()) {
      const e2 = this.a22.divE(t3), s3 = this.a12.negate().divThisE(t3), n5 = this.a21.negate().divThisE(t3), i2 = this.a11.divE(t3);
      this.a11 = e2, this.a12 = s3, this.a21 = n5, this.a22 = i2;
    } else this.setZero();
    return !t3.isZero();
  }
  transposeThis() {
    return this.a21 = Pt(this.a12, this.a12 = this.a21), this;
  }
  eigenSymmetric(t3, e2) {
    const s3 = this.a12.clone();
    s3.addThisE(this.a21), s3.mulThisByPower2(0.5);
    let n5 = new p2(1), i2 = new p2(0);
    if (s3.isZero()) t3[0].setE(this.a11), t3[1].setE(this.a22);
    else {
      const e3 = new p2(1);
      if (this.a11.ne(this.a22)) {
        const r = this.a11.subE(this.a22).divE(s3);
        r.mulThisByPower2(0.5);
        const o = r.sqr();
        e3.setE(r), e3.absThis(), e3.subThisE(o.add(1).sqrtThis()), r.gt(I2) && e3.negateThis();
        const a2 = e3.sqr().addThis(1).sqrtThis().invThis();
        i2 = e3.mulE(a2), n5.setE(a2);
        const h2 = e3.mulE(s3);
        t3[0] = this.a11.addE(h2), t3[1] = this.a22.subE(h2);
      } else n5 = new p2(1 / Math.sqrt(2)), i2 = n5.clone(), t3[0] = this.a11.addE(s3), t3[1] = this.a22.subE(s3);
    }
    e2[0].x = n5.toDouble(), e2[0].y = i2.toDouble(), e2[1].x = i2.negate().toDouble(), e2[1].y = n5.toDouble(), Math.abs(t3[0].toDouble()) > Math.abs(t3[1].toDouble()) && (t3[1] = Pt(t3[0], t3[0] = t3[1]), e2[1] = Pt(e2[0], e2[0] = e2[1]));
  }
  setZero() {
    this.a11.set(0), this.a21.set(0), this.a12.set(0), this.a22.set(0);
  }
};
var Ee = class _Ee {
  static constructPoint2D(t3) {
    return new _Ee(si.constructDouble(t3.x), si.constructDouble(t3.y));
  }
  constructor(t3, e2) {
    if (void 0 === t3) return this.x = new si().setNAN(), void (this.y = new si().setNAN());
    this.x = t3.clone(), this.y = e2.clone();
  }
  assignPoint2D(t3) {
    return this.x.setDouble(t3.x), this.y.setDouble(t3.y), this;
  }
  setCoords(t3, e2) {
    return this.x.setThis(t3), this.y.setThis(e2), this;
  }
  asPoint2D() {
    return new mi(this.x.value(), this.y.value());
  }
  crossProduct(t3) {
    return this.x.mul(t3.y).sub(this.y.mul(t3.x));
  }
  leftPerpendicularThis() {
    const t3 = this.x.clone();
    this.x = this.y.clone().negate(), this.y = t3;
  }
  clone() {
    return new _Ee(this.x, this.y);
  }
  dotProduct(t3) {
    return this.x.mul(t3.x).add(this.y.mul(t3.y));
  }
  add(t3) {
    return new _Ee(this.x.add(t3.x), this.y.add(t3.y));
  }
  sub(t3) {
    return new _Ee(this.x.sub(t3.x), this.y.sub(t3.y));
  }
  sqrLength() {
    return this.x.sqr().addThis(this.y.sqr());
  }
  mulThis(t3) {
    return this.x.mulThis(t3), this.y.mulThis(t3), this;
  }
  mul(t3) {
    return this.clone().mulThis(t3);
  }
  subThis(t3) {
    return this.x.subThis(t3.x), this.y.subThis(t3.y), this;
  }
  addThis(t3) {
    return this.x.addThis(t3.x), this.y.addThis(t3.y), this;
  }
};
var Se = z3;
function De(t3) {
  let e2 = false;
  for (let s3 = 0; s3 < 2; s3++) {
    const n5 = fs(t3[0][s3], t3[3][s3]);
    n5 > 0 ? (fs(t3[0][s3], t3[1][s3]) < 0 && (t3[1][s3] = t3[0][s3], e2 = true), fs(t3[1][s3], t3[3][s3]) < 0 && (t3[1][s3] = t3[3][s3], e2 = true), fs(t3[0][s3], t3[2][s3]) < 0 && (t3[2][s3] = t3[0][s3], e2 = true), fs(t3[2][s3], t3[3][s3]) < 0 && (t3[2][s3] = t3[3][s3], e2 = true), fs(t3[1][s3], t3[2][s3]) < 0 && (t3[2][s3] = t3[1][s3], e2 = true)) : n5 < 0 ? (fs(t3[0][s3], t3[1][s3]) > 0 && (t3[1][s3] = t3[0][s3], e2 = true), fs(t3[1][s3], t3[3][s3]) > 0 && (t3[1][s3] = t3[3][s3], e2 = true), fs(t3[0][s3], t3[2][s3]) > 0 && (t3[2][s3] = t3[0][s3], e2 = true), fs(t3[2][s3], t3[3][s3]) > 0 && (t3[2][s3] = t3[3][s3], e2 = true), fs(t3[1][s3], t3[2][s3]) > 0 && (t3[2][s3] = t3[1][s3], e2 = true)) : t3[1][s3] === t3[0][s3] && t3[2][s3] === t3[0][s3] || (t3[1][s3] = t3[0][s3], t3[2][s3] = t3[0][s3], e2 = true);
  }
  return e2;
}
function we(t3) {
  const e2 = fs(t3[0].y, t3[1].y), s3 = fs(t3[1].y, t3[2].y), n5 = fs(t3[2].y, t3[3].y);
  if (e2 >= 0 && s3 >= 0 && n5 >= 0 || e2 <= 0 && s3 <= 0 && n5 <= 0) {
    const e3 = fs(t3[0].x, t3[1].x), s4 = fs(t3[1].x, t3[2].x), n6 = fs(t3[2].x, t3[3].x);
    if (e3 >= 0 && s4 >= 0 && n6 >= 0 || e3 <= 0 && s4 <= 0 && n6 <= 0) return true;
  }
  return false;
}
function Ae(t3, e2) {
  const s3 = t3.getStartXY();
  if (s3.equals(e2.getStartXY())) return true;
  if (s3.equals(e2.getEndXY())) return true;
  const n5 = t3.getEndXY();
  return !!n5.equals(e2.getStartXY()) || !!n5.equals(e2.getEndXY());
}
function Te(t3, e2) {
  let s3 = t3.calculateLowerLength2D();
  return !(s3 > e2) && (!!t3.isLine() || (s3 = t3.calculateUpperLength2D(), s3 <= e2 || 0 !== e2 && t3.calculateLength2D() <= e2));
}
function Ie(t3, s3, n5) {
  const i2 = Ot(mi, 4);
  let r = t3.queryControlPointsHelper(i2);
  const o = Ot(mi, 4);
  let h2 = s3.queryControlPointsHelper(o);
  i2[0].equals(o[0]) || k("");
  const u = t3.getGeometryType();
  if (u === s3.getGeometryType() && i2.map((t4, e2) => o[e2].equals(t4)).reduce((t4, e2) => t4 && e2)) {
    if (u !== a.enumRationalBezier2) return 0;
    {
      const e2 = s3, n6 = [0, 0, 0], i3 = [0, 0, 0];
      if (t3.queryWeights(n6), e2.queryWeights(i3), n6.map((t4, e3) => i3[e3] === t4).reduce((t4, e3) => t4 && e3)) return 0;
    }
  }
  for (; r > 2 && i2[1].equals(i2[0]); ) i2.splice(1, 1), r--;
  for (; h2 > 2 && o[1].equals(o[0]); ) o.splice(1, 1), h2--;
  (i2[1].equals(i2[0]) || o[1].equals(i2[0])) && k("");
  const m3 = mi.compareVectorsOrigin(i2[0], i2[1], o[1]);
  if (0 === m3) {
    const e2 = Ee.constructPoint2D(i2[0]), n6 = new Ee();
    t3.queryCoord2DMP(1e-16, n6), n6.sub(e2);
    const r2 = new Ee();
    s3.queryCoord2DMP(1e-16, r2), r2.sub(e2);
    return r2.crossProduct(n6).sign();
  }
  return m3;
}
function Me(t3, e2, s3, i2, r, o, a2, h2) {
  let u = t3.calculateUpperLength2D(), m3 = e2.calculateUpperLength2D(), l2 = t3, c = e2, g2 = false;
  u > m3 && (c = Pt(l2, l2 = c), i2 = Pt(s3, s3 = i2), m3 = Pt(u, u = m3), g2 = true);
  const d2 = 0 === s3;
  {
    a2[0] = d2 ? 1 : 0;
    const t4 = l2.getCoord2D(a2[0]);
    h2[0] = c.getClosestCoordinate(t4, false);
    const e3 = c.getCoord2D(h2[0]);
    if (mi.distance(t4, e3) <= r) {
      const e4 = [0.5, 0.75, 0.25, 0.1, 0.9];
      let s4 = true;
      for (let n5 = 0; n5 < e4.length; n5++) if (t4.assign(l2.getCoord2D(e4[n5])), !c.isCloserThanDistance(t4, new x2(0, 1), r)) {
        s4 = false;
        break;
      }
      if (s4) return g2 && (h2[0] = Pt(a2[0], a2[0] = h2[0])), 1;
    }
  }
  if (u <= 3 * r) return 0;
  let _ = Us(Math.max(r / u, 0.1), 0, 0.5), p3 = 0.01 * r, f3 = 0, P5 = 0, y2 = _, x4 = -1, C3 = 0, v3 = 1 / 32;
  for (let b2 = 0; ; b2++) {
    n(b2 < 4095);
    const t4 = d2 ? _ : 1 - _, e3 = l2.getCoord2D(t4), s4 = c.getClosestCoordinate(e3, false);
    if (s4 === i2) return C3;
    const u2 = c.getCoord2D(s4), m4 = mi.distance(e3, u2);
    if (0 === b2 && (x4 = m4), m4 <= p3 ? (v3 = 0.5, P5 = m4, f3 = _) : (y2 = _, x4 = m4), Math.abs(P5 - x4) > 0.1 * p3 && y2 - f3 > 1e-16) _ = Q(f3, y2, v3);
    else {
      if (a2[C3] = t4, h2[C3] = s4, g2 && (h2[C3] = Pt(a2[C3], a2[C3] = h2[C3])), 1 === o || 1 === C3) return 1 === C3 && a2[0] > a2[1] && (a2[1] = Pt(a2[0], a2[0] = a2[1]), h2[1] = Pt(h2[0], h2[0] = h2[1])), C3 + 1;
      C3++, f3 = y2, P5 = x4, y2 = 0.8, x4 = -1, _ = 0.8, v3 = 1 / 32, p3 = 10 * r, b2 = 0;
    }
  }
}
function Ye(t3, e2, s3, n5, i2, r, o, a2, h2) {
  if (Vs(s3, 0, 1) && Vs(n5, 0, 1)) {
    if (0 === mi.distance(t3.getCoord2D(s3), e2.getCoord2D(n5))) {
      const h3 = 1e-12, u = new ve(), m3 = Qs();
      if (t3.queryDerivative(new p2(s3, m3), u), u.isTrueZero()) {
        const e3 = 1 === s3 ? -1e-12 : h3;
        t3.queryDerivative(new p2(s3, m3).add(e3), u);
      }
      1 === s3 && u.negateThis();
      const l2 = new ve();
      if (e2.queryDerivative(new p2(n5, m3), l2), l2.isTrueZero()) {
        const t4 = 1 === s3 ? -1e-12 : h3;
        e2.queryDerivative(new p2(n5, m3).add(t4), l2);
      }
      1 === n5 && l2.negateThis(), u.isZero() || u.normalize(), l2.isZero() || l2.normalize();
      const c = u.dotProduct(l2), g2 = u.crossProduct(l2);
      g2.scaleError(3);
      const d2 = () => {
        {
          const s4 = t3.calculateUpperLength2D(), n6 = e2.calculateUpperLength2D();
          return Math.min(0.01 * i2 / Math.min(s4, n6), 1e-10);
        }
      };
      if (c.ge(I2) && (g2.isZero() || Math.abs(g2.value()) < d2())) {
        return Me(t3, e2, s3, n5, i2, r, o, a2);
      }
    }
  }
  return 0;
}
function Ne(t3, e2, s3) {
  if (n(t3.isCurve() || e2.isCurve()), t3.getStartXY().equals(e2.getStartXY())) {
    if (Ye(t3, e2, 0, 0, s3, 2, [0, 0], [0, 0])) return true;
  }
  if (t3.getEndXY().equals(e2.getEndXY())) {
    if (Ye(t3, e2, 1, 1, s3, 2, [0, 0], [0, 0])) return true;
  }
  if (t3.getStartXY().equals(e2.getEndXY())) {
    if (Ye(t3, e2, 0, 1, s3, 2, [0, 0], [0, 0])) return true;
  }
  if (t3.getEndXY().equals(e2.getStartXY())) {
    if (Ye(t3, e2, 1, 0, s3, 2, [0, 0], [0, 0])) return true;
  }
  return false;
}
function Xe(t3, e2) {
  t3.m_XStart = e2.x, t3.m_YStart = e2.y;
}
function qe(t3, e2, s3) {
  t3.m_XStart = e2, t3.m_YStart = s3;
}
function Fe(t3, e2) {
  t3.m_XEnd = e2.x, t3.m_YEnd = e2.y;
}
function Ve(t3, e2, s3) {
  t3.m_XEnd = e2, t3.m_YEnd = s3;
}
function Le(t3, e2, s3) {
  e2 ? t3.m_XEnd === s3.x && t3.m_YEnd === s3.y || (t3.m_XEnd = s3.x, t3.m_YEnd = s3.y, t3.endPointModified()) : t3.m_XStart === s3.x && t3.m_YStart === s3.y || (t3.m_XStart = s3.x, t3.m_YStart = s3.y, t3.endPointModified());
}
function Re(t3, e2) {
  const s3 = new X();
  return e2 ? (s3.x = t3.m_XEnd, s3.y = t3.m_YEnd) : (s3.x = t3.m_XStart, s3.y = t3.m_YStart), s3.z = ze(t3, e2), s3;
}
function ze(t3, e2) {
  return t3.m_description.hasZ() ? t3.m_attributes[e2 * (t3.m_description.getTotalComponentCount() - 2)] : Se.getDefaultValue(1);
}
function Be(t3, e2, s3) {
  t3.m_description.hasZ() || t3.addAttribute(1), e2 ? t3.m_XEnd === s3.x && t3.m_YEnd === s3.y || (t3.m_XEnd = s3.x, t3.m_YEnd = s3.y, t3.endPointModified()) : t3.m_XStart === s3.x && t3.m_YStart === s3.y || (t3.m_XStart = s3.x, t3.m_YStart = s3.y, t3.endPointModified()), t3.m_attributes[(t3.m_description.getTotalComponentCount() - 2) * e2] = s3.z;
}
function ke(t3, e2, s3) {
  s3.assignVertexDescription(t3.m_description);
  const n5 = 0 === e2 ? t3.m_XStart : t3.m_XEnd, i2 = 0 === e2 ? t3.m_YStart : t3.m_YEnd;
  s3.setXYCoords(n5, i2);
  for (let r = 1; r < t3.m_description.getAttributeCount(); r++) {
    const n6 = t3.m_description.getSemantics(r);
    for (let i3 = 0, r2 = Se.getComponentCount(n6); i3 < r2; i3++) {
      const r3 = We(t3, e2, n6, i3);
      s3.setAttributeBasic(n6, i3, r3);
    }
  }
}
function Ge(t3, e2, s3) {
  s3.isEmpty() && x(""), Le(t3, e2, s3.getXY());
  const n5 = s3.getDescription();
  n5 !== t3.m_description && t3.mergeVertexDescription(n5);
  for (let i2 = 1, r = n5.getAttributeCount(); i2 < r; i2++) {
    const r2 = n5.getSemantics(i2), o = Se.getComponentCount(r2);
    for (let n6 = 0; n6 < o; n6++) {
      je(t3, e2, r2, n6, s3.getAttributeAsDbl(r2, n6));
    }
  }
}
function We(t3, e2, s3, n5) {
  if ((e2 < 0 || e2 > 1) && A(""), 0 === s3) return (n5 < 0 || n5 >= 2) && A(""), 0 === e2 ? 0 === n5 ? t3.m_XStart : t3.m_YStart : 0 === n5 ? t3.m_XEnd : t3.m_YEnd;
  const r = Se.getComponentCount(s3);
  (n5 < 0 || n5 >= r) && A("");
  const o = t3.m_description.getAttributeIndex(s3);
  return o >= 0 ? t3.m_attributes[e2 * (t3.m_description.getTotalComponentCount() - 2) + t3.m_description.getPointAttributeOffset(o) - 2 + n5] : Se.getDefaultValue(s3);
}
function je(t3, e2, s3, n5, r) {
  if ((e2 < 0 || e2 > 1) && A(""), 0 === s3) return 0 === e2 ? 0 === n5 ? t3.m_XStart = r : 1 === n5 ? t3.m_YStart = r : A("") : 1 === e2 ? 0 === n5 ? t3.m_XEnd = r : 1 === n5 ? t3.m_YEnd = r : A("") : A(""), void t3.endPointModified();
  const o = Se.getComponentCount(s3);
  (n5 < 0 || n5 >= o) && A("");
  let a2 = t3.m_description.getAttributeIndex(s3);
  a2 < 0 && (t3.addAttribute(s3), a2 = t3.m_description.getAttributeIndex(s3)), t3.m_attributes[e2 * (t3.m_description.getTotalComponentCount() - 2) + t3.m_description.getPointAttributeOffset(a2) - 2 + n5] = r;
}
function Ze(t3, e2) {
  if (t3 === e2) return;
  e2.isEmpty() && x("");
  const s3 = e2.getDescription();
  s3 !== t3.m_description && t3.mergeVertexDescription(s3);
  for (let n5 = 1, i2 = s3.getAttributeCount(); n5 < i2; n5++) {
    const i3 = s3.getSemantics(n5), r = Se.getComponentCount(i3);
    for (let s4 = 0; s4 < r; s4++) {
      let n6 = We(e2, 0, i3, s4);
      je(t3, 0, i3, s4, n6), n6 = We(e2, 1, i3, s4), je(t3, 1, i3, s4, n6);
    }
  }
}
function He(t3, e2) {
  const s3 = S2();
  Y2(e2, t3.m_description, s3);
  let n5 = null;
  const i2 = e2.getTotalComponentCount() - 2, r = t3.m_description ? t3.m_description.getTotalComponentCount() - 2 : 0;
  if (i2 > 0 && (n5 = Yt(2 * i2, Number.NaN), Dt(n5, e2.getDefaultPointAttributes(), 0, 2, i2), Dt(n5, e2.getDefaultPointAttributes(), i2, 2, i2), null !== t3.m_description)) for (let o = 1; o < e2.getAttributeCount(); o++) {
    const a2 = s3[o];
    if (-1 !== a2) {
      const s4 = t3.m_description.getPointAttributeOffset(a2) - 2, h2 = e2.getPointAttributeOffset(o) - 2, u = Se.getComponentCount(e2.getSemantics(o));
      for (let e3 = 0; e3 < u; ++e3) n5[h2] = t3.m_attributes[s4], n5[i2 + h2] = t3.m_attributes[r + s4];
    }
  }
  t3.m_attributes = n5, t3.m_description = e2;
}
function Ue(t3) {
  return t3.absNorm() * Ls();
}
function Oe(t3, e2) {
  return Math.max(t3.absNorm(), e2.absNorm()) * Ls();
}
function Qe(t3, e2, s3) {
  const n5 = new pe();
  t3.queryEnvelopeW(x2.unit(), n5);
  const i2 = new pe();
  return e2.queryEnvelopeW(x2.unit(), i2), i2.inflate(s3), !n5.isIntersectingW(i2);
}
function Ke(t3, e2, s3) {
  const n5 = Qt(t3, s3), i2 = Qt(e2, s3);
  n5.sort((t4, e3) => t4.compare(e3)), i2.sort((t4, e3) => t4.compare(e3));
  for (let r = 0; r < 3; r++) {
    if (n5[r].compare(i2[r]) < 0) return -1;
    if (0 !== n5[r].compare(i2[r])) return 1;
  }
  return 0;
}
var Je = z3;
var $e = class {
  constructor(t3) {
    if (t3.copy) {
      if (this.m_XStart = t3.copy.m_XStart, this.m_YStart = t3.copy.m_YStart, this.m_XEnd = t3.copy.m_XEnd, this.m_YEnd = t3.copy.m_YEnd, this.m_description = t3.copy.m_description, this.m_attributes = null, this.m_description) {
        this.m_description.getTotalComponentCount() - 2 && (this.m_attributes = t3.copy.m_attributes.slice());
      }
    } else {
      if (t3.move) return this.m_description = t3.move.m_description, t3.move.m_description = null, this.m_attributes = t3.move.m_attributes, t3.move.m_attributes = null, this.m_XStart = t3.move.m_XStart, this.m_YStart = t3.move.m_YStart, this.m_XEnd = t3.move.m_XEnd, void (this.m_YEnd = t3.move.m_YEnd);
      if (void 0 !== t3.XStart) return this.m_XStart = t3.XStart, this.m_YStart = t3.YStart, this.m_XEnd = t3.XEnd, this.m_YEnd = t3.YEnd, this.m_attributes = null, this.m_description = t3.vd ? t3.vd : M(), void (t3.vd && this.setDefaultAttributeValues());
      if (void 0 !== t3.ZStart) return this.m_XStart = t3.XStart, this.m_YStart = t3.YStart, this.m_XEnd = t3.XEnd, this.m_YEnd = t3.YEnd, this.m_description = t3.vd ? t3.vd : O2(), void (t3.vd ? (this.setDefaultAttributeValues(), this.addAttribute(1), this.m_attributes[0] = t3.ZStart, this.m_attributes[this.m_description.getTotalComponentCount() - 2] = t3.ZEnd) : this.m_attributes = [t3.ZStart, t3.ZEnd]);
      if (t3.start) return this.m_XStart = t3.start.x, this.m_YStart = t3.start.y, this.m_XEnd = t3.end.x, this.m_YEnd = t3.end.y, this.m_attributes = null, void (this.m_description = M());
      if (t3.start3D) return this.m_XStart = t3.start3D.x, this.m_YStart = t3.start3D.y, this.m_XEnd = t3.end3D.x, this.m_YEnd = t3.end3D.y, this.m_description = t3.vd ? t3.vd : O2(), void (t3.vd ? (this.setDefaultAttributeValues(), this.addAttribute(1), this.m_attributes[0] = t3.start3D.z, this.m_attributes[this.m_description.getTotalComponentCount() - 2] = t3.end3D.z) : this.m_attributes = [t3.start3D.z, t3.end3D.z]);
      b("bad constructor params"), this.m_XStart = this.m_YStart = this.m_XEnd = this.m_YEnd = Number.NaN;
    }
  }
  setDefaultAttributeValues() {
    const t3 = this.m_description.getTotalComponentCount() - 2;
    t3 > 0 && (null === this.m_attributes && (this.m_attributes = Yt(2 * t3, Number.NaN)), Dt(this.m_attributes, this.m_description.getDefaultPointAttributes(), 0, 2, t3), Dt(this.m_attributes, this.m_description.getDefaultPointAttributes(), t3, 2, t3));
  }
  absNormXYZ(t3) {
    return z("not implemented"), 0;
  }
  queryWeights(t3) {
  }
  snapControlPoints3D() {
    return z("not implemented"), false;
  }
  setCoordsForIntersector3D(t3, e2, n5) {
    z("not implemented");
  }
  transformAttribute(t3, e2, n5, i2, r) {
    z("");
  }
  mergeVertexDescriptionImpl(t3) {
    const e2 = this.getDescription(), s3 = H2(e2, t3);
    this.assignVertexDescription(s3);
  }
  changeEndPoints(t3, e2) {
    const s3 = t3.getXY(), n5 = e2.getXY();
    this.changeEndPoints2D(s3, n5);
    let i2 = t3.getDescription();
    i2 !== this.getDescription() && this.mergeVertexDescription(i2), i2 = e2.getDescription(), i2 !== this.getDescription() && this.mergeVertexDescription(i2);
    for (let r = 1, o = i2.getAttributeCount(); r < o; r++) {
      const s4 = i2.getSemantics(r), n6 = Je.getComponentCount(s4);
      for (let i3 = 0; i3 < n6; i3++) {
        je(this, 0, s4, i3, t3.getAttributeAsDbl(s4, i3));
        je(this, 1, s4, i3, e2.getAttributeAsDbl(s4, i3));
      }
    }
  }
  getStartXY() {
    return new mi(this.m_XStart, this.m_YStart);
  }
  setStartXY(t3) {
    this.m_XStart = t3.x, this.m_YStart = t3.y, this.endPointModified();
  }
  setStartXYCoords(t3, e2) {
    this.m_XStart = t3, this.m_YStart = e2, this.endPointModified();
  }
  getStartXYZ() {
    return Re(this, 0);
  }
  setStartXYZ(t3) {
    Be(this, 0, t3);
  }
  setStartXYZCoords(t3, e2, s3) {
    Be(this, 0, X.construct(t3, e2, s3));
  }
  queryStart(t3) {
    ke(this, 0, t3);
  }
  setStart(t3) {
    Ge(this, 0, t3);
  }
  setStart2D(t3) {
    this.setStartXY(t3);
  }
  getStartAttributeAsDbl(t3, e2) {
    return We(this, 0, t3, e2);
  }
  getStartAttributeAsInt(t3, e2) {
    return n(0), 0;
  }
  setStartAttribute(t3, e2, s3) {
    je(this, 0, t3, e2, s3);
  }
  setStartAttributesFromPoint(t3, e2) {
    const s3 = t3.getDescription();
    for (let n5 = e2 && s3.hasZ() ? 2 : 1, i2 = s3.getAttributeCount(); n5 < i2; ++n5) {
      const e3 = s3.getSemantics(n5), i3 = Je.getComponentCount(e3);
      for (let s4 = 0; s4 < i3; ++s4) {
        const n6 = t3.getAttributeAsDbl(e3, s4);
        this.setStartAttribute(e3, s4, n6);
      }
    }
  }
  setEndAttributesFromPoint(t3, e2) {
    const s3 = t3.getDescription();
    for (let n5 = e2 && s3.hasZ() ? 2 : 1, i2 = s3.getAttributeCount(); n5 < i2; ++n5) {
      const e3 = s3.getSemantics(n5), i3 = Je.getComponentCount(e3);
      for (let s4 = 0; s4 < i3; ++s4) {
        const n6 = t3.getAttributeAsDbl(e3, s4);
        this.setEndAttribute(e3, s4, n6);
      }
    }
  }
  getStartX() {
    return this.m_XStart;
  }
  getStartY() {
    return this.m_YStart;
  }
  getStartZ() {
    return n(0), 0;
  }
  getEndX() {
    return this.m_XEnd;
  }
  getEndY() {
    return this.m_YEnd;
  }
  getEndZ() {
    return n(0), 0;
  }
  getEndXY() {
    return new mi(this.m_XEnd, this.m_YEnd);
  }
  setEndXY(t3) {
    this.m_XEnd = t3.x, this.m_YEnd = t3.y, this.endPointModified();
  }
  setEndXYCoords(t3, e2) {
    this.m_XEnd = t3, this.m_YEnd = e2, this.endPointModified();
  }
  getEndXYZ() {
    return Re(this, 1);
  }
  setEndXYZ(t3) {
    Be(this, 1, t3);
  }
  setEndXYZCoords(t3, e2, s3) {
    Be(this, 1, X.construct(t3, e2, s3));
  }
  queryEnd(t3) {
    ke(this, 1, t3);
  }
  setEnd(t3) {
    Ge(this, 1, t3);
  }
  setEnd2D(t3) {
    this.setEndXY(t3);
  }
  getEndAttributeAsDbl(t3, e2) {
    return We(this, 1, t3, e2);
  }
  getEndAttributeAsInt(t3, e2) {
    return n(0), Math.trunc(0);
  }
  setEndAttribute(t3, e2, s3) {
    je(this, 1, t3, e2, s3);
  }
  getDimension() {
    return 1;
  }
  copyTo(e2) {
    if (this === e2) return;
    e2.getGeometryType() !== this.getGeometryType() && P("");
    const s3 = e2;
    s3.assignVertexDescription(this.m_description), s3.m_attributes && Dt(s3.m_attributes, this.m_attributes, 0, 0, 2 * (this.m_description.getTotalComponentCount() - 2)), s3.m_XStart = this.m_XStart, s3.m_YStart = this.m_YStart, s3.m_XEnd = this.m_XEnd, s3.m_YEnd = this.m_YEnd, this.copyToImpl(s3);
  }
  isEmpty() {
    return this.isEmptyImpl();
  }
  isClosed() {
    return this.m_XStart === this.m_XEnd && this.m_YStart === this.m_YEnd;
  }
  setEmpty() {
  }
  calculateArea2D() {
    return 0;
  }
  queryInterval(t3, e2) {
    const s3 = x2.constructEmpty();
    return s3.vmin = We(this, 0, t3, e2), s3.vmax = s3.vmin, s3.mergeNeCoordinate(We(this, 1, t3, e2)), s3;
  }
  calculateLength3D(t3) {
    return n(0), 0;
  }
  getCoord3D(t3) {
    return n(0), {};
  }
  getCoord2D(t3) {
    const e2 = mi.getNAN();
    return this.queryCoord2D(t3, e2), e2;
  }
  queryCoord3D(t3, e2) {
    n(0);
  }
  getCoordZ(t3) {
    return n(0), 0;
  }
  queryCoord(t3, e2) {
    e2.assignVertexDescription(this.m_description), e2.setXY(this.getCoord2D(t3));
    for (let s3 = 1, n5 = this.m_description.getAttributeCount(); s3 < n5; s3++) {
      const n6 = this.m_description.getSemantics(s3), i2 = Je.getComponentCount(n6);
      for (let s4 = 0; s4 < i2; s4++) {
        const i3 = this.getAttributeAsDbl(t3, n6, s4);
        e2.setAttributeBasic(n6, s4, i3);
      }
    }
  }
  isCloserThanDistance(t3, e2, s3) {
    const n5 = n3.constructEmpty();
    this.queryLooseEnvelopeOnInterval(e2, n5);
    if (n5.distance(t3) > s3) return false;
    const i2 = this.getClosestCoordinateOnInterval(t3, e2, s3);
    return !Number.isNaN(i2) && mi.distance(t3, this.getCoord2D(i2)) <= s3;
  }
  isMonotoneQuickAndDirty() {
    return false;
  }
  isTrue3D() {
    return false;
  }
  getReversed() {
    const t3 = this.clone();
    return t3.reverse(), t3;
  }
  reverse() {
    this.m_XEnd = Pt(this.m_XStart, this.m_XStart = this.m_XEnd), this.m_YEnd = Pt(this.m_YStart, this.m_YStart = this.m_YEnd), this.reverseImpl();
    for (let t3 = 1, e2 = this.m_description.getAttributeCount(); t3 < e2; t3++) {
      const e3 = this.m_description.getSemantics(t3);
      for (let t4 = 0, s3 = Je.getComponentCount(e3); t4 < s3; t4++) {
        const s4 = We(this, 0, e3, t4);
        je(this, 0, e3, t4, We(this, 1, e3, t4)), je(this, 1, e3, t4, s4);
      }
    }
    return this.afterCompletedModification(), this;
  }
  isEmptyImpl() {
    return false;
  }
  isCircular() {
    return false;
  }
  distance(t3, e2, s3, i2) {
    if (!e2 && this.isIntersecting(t3, 0, false)) {
      if (null !== s3 || null !== i2) {
        const e3 = Yt(9, Number.NaN), o2 = Yt(9, Number.NaN), a3 = this.intersect(t3, null, e3, o2, 0);
        n(a3 <= 9), 0 === a3 && b(""), null !== s3 && (s3[0] = e3[0]), null !== i2 && (i2[0] = o2[0]);
      }
      return 0;
    }
    let o, a2 = Number.MAX_VALUE, h2 = -1, u = a2;
    return o = this.getStartXY(), h2 = t3.getClosestCoordinate(o, false), o.subThis(t3.getCoord2D(h2)), u = o.length(), u < a2 && (a2 = u, null !== i2 && (i2[0] = h2), null !== s3 && (s3[0] = 0)), o = this.getEndXY(), h2 = t3.getClosestCoordinate(o, false), o.subThis(t3.getCoord2D(h2)), u = o.length(), u < a2 && (a2 = u, null !== i2 && (i2[0] = h2), null !== s3 && (s3[0] = 1)), o = t3.getStartXY(), h2 = this.getClosestCoordinate(o, false), o.subThis(this.getCoord2D(h2)), u = o.length(), u < a2 && (a2 = u, null !== s3 && (s3[0] = h2), null !== i2 && (i2[0] = 0)), o = t3.getEndXY(), h2 = this.getClosestCoordinate(o, false), o.subThis(this.getCoord2D(h2)), u = o.length(), u < a2 && (a2 = u, null !== s3 && (s3[0] = h2), null !== i2 && (i2[0] = 1)), a2;
  }
  calculateSubLengthFromStart(t3) {
    return this.tToLength(t3);
  }
  calculateSubLength(t3, e2) {
    return e2 === t3 ? 0 : this.tToLength(e2) - this.tToLength(t3);
  }
  static recalculateParentT(t3, e2, s3) {
    return Q(t3, e2, s3);
  }
  moveTo(t3) {
    const e2 = this.isClosed(), s3 = new x3();
    s3.setShift(t3.sub(this.getStartXY())), this.applyTransformation(s3), e2 ? this.changeEndPoints2D(t3, t3) : this.changeEndPoints2D(t3, this.getEndXY());
  }
  moveTo3D(t3) {
    n(0);
  }
  getDescription() {
    return this.m_description;
  }
  assignVertexDescription(t3) {
    He(this, t3);
  }
  mergeVertexDescription(t3) {
    this.m_description !== t3 && (this.m_description.hasAttributesFrom(t3) || this.mergeVertexDescriptionImpl(t3));
  }
  hasAttribute(t3) {
    return this.m_description.hasAttribute(t3);
  }
  addAttribute(t3) {
    if (this.m_description.hasAttribute(t3)) return;
    const e2 = V2(this.m_description, t3);
    this.assignVertexDescription(e2);
  }
  dropAttribute(t3) {
    if (!this.m_description.hasAttribute(t3)) return;
    const e2 = k3(this.m_description, t3);
    this.assignVertexDescription(e2);
  }
  dropAllAttributes() {
    const t3 = M();
    t3 !== this.m_description && this.assignVertexDescription(t3);
  }
  swap(e2) {
    if (this === e2) return;
    e2.getGeometryType() !== this.getGeometryType() && P("wrong geometry type");
    const s3 = e2;
    s3.m_description = Pt(this.m_description, this.m_description = s3.m_description), s3.m_XStart = Pt(this.m_XStart, this.m_XStart = s3.m_XStart), s3.m_YStart = Pt(this.m_YStart, this.m_YStart = s3.m_YStart), s3.m_XEnd = Pt(this.m_XEnd, this.m_XEnd = s3.m_XEnd), s3.m_YEnd = Pt(this.m_YEnd, this.m_YEnd = s3.m_YEnd), s3.m_attributes = Pt(this.m_attributes, this.m_attributes = s3.m_attributes), this.swapImpl(s3);
  }
  equals(t3, e2) {
    if (this.getGeometryType() !== t3.getGeometryType()) return false;
    const s3 = void 0 === e2;
    s3 && (e2 = 0);
    const n5 = t3;
    if (this === n5) return true;
    if (this.m_description !== n5.m_description) return false;
    if (Math.abs(this.m_XStart - n5.m_XStart) > e2 || Math.abs(this.m_XEnd - n5.m_XEnd) > e2 || Math.abs(this.m_YStart - n5.m_YStart) > e2 || Math.abs(this.m_YEnd - n5.m_YEnd) > e2) return false;
    for (let i2 = 0, r = 2 * (this.m_description.getTotalComponentCount() - 2); i2 < r; i2++) if (!cs(this.m_attributes[i2], n5.m_attributes[i2], e2)) return false;
    return s3 ? this.equalsImpl(n5) : this.equalsImplTol(n5, e2);
  }
  getImpl() {
    return this;
  }
  setAttributeBasic(e2, s3, n5) {
    if (this.addAttribute(e2), 0 === e2 && this.isCurve()) {
      (s3 < 0 || s3 > 1) && P("");
      const e3 = new x3(), i2 = 0 === s3 ? n5 : 0, r = 1 === s3 ? n5 : 0;
      e3.setShiftCoords(i2, r), 0 === s3 ? e3.xx = 0 : e3.yy = 0, this.applyTransformation(e3);
    } else this.setStartAttribute(e2, s3, n5), this.setEndAttribute(e2, s3, n5);
  }
  replaceNaNs(t3, e2) {
    if (this.addAttribute(t3), this.isEmpty()) return;
    const s3 = Je.getComponentCount(t3);
    for (let n5 = 0; n5 < s3; n5++) {
      const s4 = this.getStartAttributeAsDbl(t3, n5);
      Number.isNaN(s4) && this.setStartAttribute(t3, n5, e2);
      const i2 = this.getEndAttributeAsDbl(t3, n5);
      Number.isNaN(i2) && this.setEndAttribute(t3, n5, e2);
    }
  }
};
$e.s_maxMonotonicPartParams = 8;
var ts = class {
  constructor() {
    this.posStream = null, this.streams = null;
  }
  get(t3) {
    return t3 > 0 ? this.streams[t3 - 1] : this.posStream;
  }
  set(t3, e2) {
    t3 > 0 ? this.streams[t3 - 1] = e2 : this.posStream = e2;
  }
  destroyAndSetSize(t3) {
    if (this.streams = null, t3 > 1) {
      this.streams = new Array(t3 - 1);
      for (let e2 = 0; e2 < t3 - 1; ++e2) this.streams[e2] = null;
    }
    this.posStream = null;
  }
  swap(t3) {
    [this.streams, t3.streams] = [t3.streams, this.streams], [this.posStream, t3.posStream] = [t3.posStream, this.posStream];
  }
  empty() {
    return null === this.posStream && null === this.streams;
  }
};
function es(e2, s3, n5, i2, r) {
  (s3 < 0 || n5 < 0 || i2 < 1 || s3 + i2 * (n5 - 1) + 1 > e2.size()) && P("Index out of bound");
  for (let t3 = s3, o = s3 + i2 * (n5 - 1) + 1; t3 < o; t3 += i2) e2.writeAsDbl(t3, r(e2.readAsDbl(t3)));
}
function ss(t3, e2, s3) {
  if (t3) for (let n5 = e2.length - 1; n5 >= 0; --n5) s3(e2[n5]);
  else e2.forEach(s3);
}
function ns(t3, e2) {
  let s3 = Ss(t3);
  const n5 = e2.length / ds();
  for (let i2 = 0; i2 < e2.length; ++i2) {
    const t4 = Math.trunc(s3 * n5);
    s3 = Ss(s3);
    const i3 = Math.trunc(s3 * n5), r = e2[t4];
    e2[t4] = e2[i3], e2[i3] = r;
  }
}
function hs(t3, e2, s3) {
  const n5 = t3.getDescription().getTotalComponentCount();
  t3.setX(e2[0]), t3.setY(e2[1]), Dt(t3.getAttributeArray(), e2, 0, 2, n5 - 2);
}
var us = z3;
var ms = "can not assign an empty point to a vertex";
var ls2 = class {
  constructor(t3) {
    if (this.m_accelerators = null, void 0 !== t3 && t3.move) this.m_description = t3.move.m_description, t3.move.m_description = M(), this.m_vertexAttributes = t3.move.m_vertexAttributes, t3.move.m_vertexAttributes = new ts(), this.m_envelopeData = t3.move.m_envelopeData, t3.move.m_envelopeData = new ne(), this.m_pointCount = t3.move.m_pointCount, this.m_reservedPointCount = t3.move.m_reservedPointCount, this.m_flags = t3.move.m_flags, this.m_bFillRule = t3.move.m_bFillRule, this.m_bPathStarted = t3.move.m_bPathStarted, this.m_bPolygon = t3.move.m_bPolygon, this.m_simpleTolerance = t3.move.m_simpleTolerance;
    else {
      const e2 = void 0 !== t3 && t3.vd ? t3.vd : M();
      this.m_description = e2, this.m_vertexAttributes = new ts(), this.m_envelopeData = new ne(), this.m_pointCount = 0, this.m_reservedPointCount = -1, this.m_flags = 4063, this.m_bFillRule = this.m_bPathStarted = this.m_bPolygon = false, this.m_simpleTolerance = 0, void 0 !== t3 && t3.copy && t3.copy.copyTo(this);
    }
  }
  equalsBase(t3, e2) {
    if (!y(t3.getGeometryType())) return false;
    const s3 = t3;
    if (this === s3) return true;
    if (!this.m_description.equals(s3.getDescription())) return false;
    if (this.isEmptyImpl() !== s3.isEmptyImpl()) return false;
    if (this.isEmptyImpl()) return true;
    const n5 = this.getPointCount();
    if (n5 !== s3.getPointCount()) return false;
    for (let i2 = 0; i2 < this.m_description.getAttributeCount(); i2++) {
      const t4 = this.m_description.getSemantics(i2), r = this.getAttributeStreamRef(t4), o = s3.getAttributeStreamRef(t4), a2 = us.getComponentCount(t4);
      if (!r.equals(o, 0, n5 * a2, e2)) return false;
    }
    if (e2) {
      if (!this.equalsImplTol(t3, e2)) return false;
    } else if (!this.equalsImpl(t3)) return false;
    return true;
  }
  transformAttribute(e2, s3, n5, i2, r) {
    if (this.addAttribute(e2), !this.isEmpty() && (0 !== n5 || 1 !== i2)) {
      if (0 === e2) {
        const e3 = new x3();
        return 0 === r ? 0 === s3 ? (e3.setShiftCoords(n5, 0), e3.scale(i2, 1)) : 1 === s3 ? (e3.setShiftCoords(0, n5), e3.scale(1, i2)) : P("") : 0 === s3 ? (e3.setScaleCoords(1 / i2, 1), e3.shiftCoords(-n5, 0)) : 1 === s3 ? (e3.setScaleCoords(1, 1 / i2), e3.shiftCoords(0, -n5)) : P(""), void this.applyTransformation(e3);
      }
      es(this.getAttributeStreamRef(e2), s3, this.getPointCount(), us.getComponentCount(e2), Nt(n5, i2, r)), this.notifyModified();
    }
  }
  getDescription() {
    return this.m_description;
  }
  assignVertexDescription(t3) {
    this.m_description !== t3 && this.assignVertexDescriptionImpl(t3);
  }
  mergeVertexDescriptionImpl(t3) {
    const e2 = this.getDescription(), s3 = H2(e2, t3);
    this.assignVertexDescription(s3);
  }
  mergeVertexDescription(t3) {
    this.m_description !== t3 && (this.m_description.hasAttributesFrom(t3) || this.mergeVertexDescriptionImpl(t3));
  }
  hasAttribute(t3) {
    return this.m_description.hasAttribute(t3);
  }
  addAttribute(t3) {
    if (this.m_description.hasAttribute(t3)) return;
    const e2 = V2(this.m_description, t3);
    this.assignVertexDescription(e2);
  }
  dropAttribute(t3) {
    if (!this.m_description.hasAttribute(t3)) return;
    const e2 = k3(this.m_description, t3);
    this.assignVertexDescription(e2);
  }
  dropAllAttributes() {
    const t3 = M();
    t3 !== this.m_description && this.assignVertexDescription(t3);
  }
  getAttributeStreamRef(e2) {
    this.throwIfEmpty(), this.m_description.hasAttribute(e2) || P("AttributeStream : Geometry does not have the attribute");
    const s3 = this.m_description.getAttributeIndex(e2);
    return this.m_vertexAttributes.get(s3);
  }
  setAttributeStreamRef(e2, s3) {
    s3 || P("stream"), s3 && us.getPersistence(e2) !== s3.getPersistence() && P(""), this.addAttribute(e2);
    const n5 = this.m_description.getAttributeIndex(e2);
    this.m_vertexAttributes.empty() && this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()), this.m_vertexAttributes.set(n5, s3), this.notifyModifiedFlags(2001);
  }
  notifyModifiedFlags(t3) {
    65535 === t3 && (this.m_reservedPointCount = -1, this.notifyModifiedAllImpl()), this.setDirtyFlagProtected(t3, true), this.clearAccelerators(), 32 & t3 && this.verifyAllStreamsAfterSizeChange();
  }
  notifyModified() {
    this.notifyModifiedFlags(2001);
  }
  getPointCount() {
    return this.m_pointCount;
  }
  getPointByVal(t3, e2) {
    const s3 = e2;
    s3.assignVertexDescription(this.m_description);
    for (let n5 = 0; n5 < this.m_description.getAttributeCount(); n5++) {
      const e3 = this.m_description.getSemantics(n5);
      for (let i2 = 0, r = us.getComponentCount(e3); i2 < r; i2++) {
        const o = this.m_vertexAttributes.get(n5).readAsDbl(r * t3 + i2);
        s3.setAttributeBasic(e3, i2, o);
      }
    }
  }
  setPointByValNoCurves(e2, s3) {
    const n5 = s3;
    n5.isEmpty() && P(ms);
    const i2 = n5.getDescription();
    i2 !== this.m_description && this.mergeVertexDescription(i2);
    const r = this.m_vertexAttributes.get(0);
    r.write(2 * e2, n5.getX()), r.write(2 * e2 + 1, n5.getY());
    for (let t3 = 1, o = this.m_description.getAttributeCount(); t3 < o; t3++) {
      const s4 = this.m_description.getSemantics(t3), i3 = us.getComponentCount(s4);
      for (let r2 = 0; r2 < i3; r2++) {
        const o2 = n5.getAttributeAsDbl(s4, r2);
        this.m_vertexAttributes.get(t3).writeAsDbl(e2 * i3 + r2, o2);
      }
    }
    this.notifyModifiedFlags(2001);
  }
  setPointByValFromArrayNoCurves(t3, e2, s3, i2) {
    n(0);
  }
  getPointByValAsArray(t3, e2, s3, i2) {
    n(0);
  }
  isEmpty() {
    return this.isEmptyImpl();
  }
  isEmptyImpl() {
    return 0 === this.m_pointCount;
  }
  getAttributeAsDbl(t3, e2, s3) {
    const n5 = us.getComponentCount(t3);
    s3 >= n5 && A("");
    const r = this.m_description.getAttributeIndex(t3);
    return r >= 0 ? this.m_vertexAttributes.get(r).readAsDbl(e2 * n5 + s3) : us.getDefaultValue(t3);
  }
  queryAttributeAsDbl(t3, e2, s3, n5) {
    const r = us.getComponentCount(t3);
    n5 < r && A("");
    const o = this.m_description.getAttributeIndex(t3);
    if (o >= 0) {
      const t4 = e2 * r, n6 = this.m_vertexAttributes.get(o);
      for (let e3 = 0; e3 < r; e3++) s3[e3] = n6.readAsDbl(t4 + e3);
    } else {
      const e3 = us.getDefaultValue(t3);
      for (let t4 = 0; t4 < r; t4++) s3[t4] = e3;
    }
  }
  getAttributeAsInt(t3, e2, s3) {
    return Math.trunc(this.getAttributeAsDbl(t3, e2, s3));
  }
  queryAttributeAsInt(t3, e2, s3, i2) {
    n(0);
  }
  setAttributeNoCurves(t3, e2, s3, n5) {
    const r = us.getComponentCount(t3);
    s3 >= r && A(""), this.addAttribute(t3);
    const o = this.m_description.getAttributeIndex(t3);
    this.notifyModifiedFlags(2001), this.m_vertexAttributes.get(o).writeAsDbl(e2 * r + s3, n5);
  }
  setAttributeFromArrayNoCurves(t3, e2, s3, n5) {
    (e2 < 0 || e2 >= this.m_pointCount) && A("");
    const r = us.getComponentCount(t3);
    n5 < r && A(""), this.addAttribute(t3);
    const o = this.m_description.getAttributeIndex(t3);
    this.notifyModifiedFlags(2001);
    const a2 = this.m_vertexAttributes.get(o);
    for (let i2 = 0; i2 < r; ++i2) a2.writeAsDbl(e2 * r + i2, s3[i2]);
  }
  getXY(t3) {
    return this.m_vertexAttributes.get(0).readPoint2D(2 * t3);
  }
  queryXY(t3, e2) {
    return this.m_vertexAttributes.get(0).queryPoint2D(2 * t3, e2);
  }
  setXYNoCurves(t3, e2) {
    this.m_vertexAttributes.get(0).writePoint2D(2 * t3, e2), this.notifyModifiedFlags(2001);
  }
  setXYCoordsNoCurves(t3, e2, s3) {
    const n5 = this.m_vertexAttributes.get(0);
    n5.write(2 * t3, e2), n5.write(2 * t3 + 1, s3), this.notifyModifiedFlags(2001);
  }
  getXYZ(t3) {
    const e2 = this.m_vertexAttributes.get(0), s3 = X.getNAN();
    return s3.x = e2.read(2 * t3), s3.y = e2.read(2 * t3 + 1), this.m_description.hasAttribute(1) ? s3.z = this.m_vertexAttributes.get(1).read(t3) : s3.z = us.getDefaultValue(1), s3;
  }
  setXYZNoCurves(t3, e2) {
    this.addAttribute(1), this.notifyModifiedFlags(2001);
    const s3 = this.m_vertexAttributes.get(0);
    s3.write(2 * t3, e2.x), s3.write(2 * t3 + 1, e2.y);
    this.m_vertexAttributes.get(1).write(t3, e2.z);
  }
  queryEnvelope(t3) {
    t3 instanceof n3 || t3 instanceof G3 ? this.updateEnvelope(t3) : (this.updateAllDirtyIntervals(true), this.m_envelopeData.copyTo(this.m_description, t3));
  }
  queryLooseEnvelope(t3) {
    this.updateLooseEnvelope(t3);
  }
  queryInterval(t3, e2) {
    const s3 = x2.constructEmpty();
    return this.isEmptyImpl() || (this.updateAllDirtyIntervals(true), this.m_envelopeData.queryInterval(this.m_description, t3, e2, s3)), s3;
  }
  setAttributeBasic(t3, e2, s3) {
    this.setAttributeImpl(t3, e2, s3);
  }
  setAttributeImpl(t3, e2, s3) {
    if (this.addAttribute(t3), this.isEmpty()) return;
    let n5 = false;
    const i2 = us.getComponentCount(t3), r = this.getAttributeStreamRef(t3), o = Number.isNaN(s3);
    if (1 === r.getPersistence()) {
      const t4 = r;
      for (let r2 = e2, a2 = this.m_pointCount * i2; r2 < a2; r2 += i2) {
        const e3 = t4.read(r2);
        (o || e3 === s3) && Number.isNaN(e3) || (t4.write(r2, s3), n5 = true);
      }
    } else for (let a2 = e2, h2 = this.m_pointCount * i2; a2 < h2; a2 += i2) {
      r.readAsDbl(a2) !== s3 && (r.writeAsDbl(a2, s3), n5 = true);
    }
    n5 && this.notifyModifiedFlags(2001);
  }
  replaceNaNs(t3, e2) {
    if (this.addAttribute(t3), this.isEmpty()) return;
    let s3 = false;
    const n5 = us.getComponentCount(t3), i2 = this.getAttributeStreamRef(t3);
    for (let r = 0; r < n5; r++) if (1 === i2.getPersistence()) {
      const t4 = i2;
      for (let i3 = 0, r2 = this.m_pointCount * n5; i3 < r2; i3++) {
        const n6 = t4.read(i3);
        Number.isNaN(n6) && (t4.write(i3, e2), s3 = true);
      }
    } else for (let t4 = 0, o = this.m_pointCount * n5; t4 < o; t4++) {
      const n6 = i2.readAsDbl(t4);
      Number.isNaN(n6) && (i2.writeAsDbl(t4, e2), s3 = true);
    }
    s3 && this.notifyModifiedFlags(2001);
  }
  calculateLength3D(t3) {
    return n(0), 0;
  }
  setEnvelopeForImport(e2) {
    this.m_description.equals(e2.getDescription()) || P(""), this.m_envelopeData = new ne({ moveEnv: e2 }), this.setDirtyFlagProtected(192, false);
  }
  copyTo(e2) {
    e2.getGeometryType() !== this.getGeometryType() && P(""), this !== e2 && this.copyToUnchecked(e2, false);
  }
  queryCoordinates(e2, s3, n5, i2) {
    let r = i2 < 0 ? this.m_pointCount : i2;
    if (r = Math.min(r, n5 + s3), (n5 < 0 || r < n5 || this.m_pointCount > 0 && n5 >= this.m_pointCount) && P(""), 0 === this.m_pointCount) return r;
    const o = this.getAttributeStreamRef(0);
    for (let t3 = 2 * n5, a2 = 2 * r, h2 = 0; t3 < a2; t3 += 2, h2++) o.queryPoint2D(t3, e2[h2]);
    return r;
  }
  queryCoordinates3D(e2, s3, n5, i2) {
    let r = i2 < 0 ? this.m_pointCount : i2;
    if (r = Math.min(r, n5 + s3), (n5 < 0 || r < n5 || this.m_pointCount > 0 && n5 >= this.m_pointCount) && P(""), 0 === this.m_pointCount) return r;
    const o = this.getAttributeStreamRef(0);
    let a2 = null;
    const h2 = us.getDefaultValue(1), u = this.m_description.hasAttribute(1);
    u && (a2 = this.getAttributeStreamRef(1));
    let m3 = 0;
    for (let t3 = n5; t3 < r; t3++, m3++) e2[m3].x = o.read(2 * t3), e2[m3].y = o.read(2 * t3 + 1), e2[m3].z = u ? a2.read(t3) : h2;
    return r;
  }
  clearAndSetDirtyFlagProtected(t3, e2) {
    let s3 = 0;
    const n5 = t3 & ~e2, i2 = e2 | n5;
    s3 = this.m_flags, (s3 & i2) !== e2 && (this.m_flags = s3 & ~n5 | e2);
  }
  getIsSimple(t3, e2) {
    e2[0] = 0;
    let s3 = -1;
    const n5 = this.m_flags, i2 = this.m_simpleTolerance;
    if (!(1 & n5)) {
      s3 = (14 & n5) >> 1, e2[0] = i2, i2 < t3 && (s3 = -1);
    }
    return s3;
  }
  setIsSimple(t3, s3, i2 = false) {
    if (2 === t3 ? n(this.getGeometryType() === a.enumPolyline) : 1 === t3 ? n(this.getGeometryType() === a.enumMultiPoint || this.getGeometryType() === a.enumPolyline) : 3 === t3 && n(this.getGeometryType() === a.enumPolygon), -1 === t3) this.setDirtyFlagProtected(17, true);
    else {
      let e2 = t3 << 1;
      i2 || (e2 |= 16);
      const n5 = 31;
      this.clearAndSetDirtyFlagProtected(n5, e2), this.m_simpleTolerance !== s3 && (this.m_simpleTolerance = s3);
    }
  }
  attributeStreamIsAllocated(t3) {
    this.throwIfEmpty();
    const e2 = this.m_description.getAttributeIndex(t3);
    return e2 >= 0 && null !== this.m_vertexAttributes.get(e2);
  }
  capacity() {
    return -1 === this.m_reservedPointCount && 0 === this.m_pointCount ? 0 : this.m_reservedPointCount;
  }
  getDescriptionImpl() {
    return this.m_description;
  }
  copyToUnchecked(t3, s3 = false) {
    s3 && this.hasDirtyFlag(32) && T("Cannot do shallow clone on unprepared geometry");
    const i2 = t3, r = this.getGeometryType(), o = i2.getGeometryType();
    n(r === o || r === a.enumPolygon && o === a.enumPolyline, "failure in copyToUnchcked"), i2.clearAccelerators(), i2.m_description = this.m_description, i2.m_vertexAttributes.destroyAndSetSize(0), i2.m_envelopeData.releaseAttributes();
    const a2 = this.m_description.getAttributeCount(), h2 = new ts();
    if (!this.m_vertexAttributes.empty()) {
      h2.destroyAndSetSize(a2);
      for (let t4 = 0; t4 < a2; t4++) if (this.m_vertexAttributes.get(t4)) if (s3) h2.set(t4, this.m_vertexAttributes.get(t4));
      else {
        const e2 = us.getComponentCount(this.m_description.getSemantics(t4));
        h2.set(t4, this.m_vertexAttributes.get(t4).restrictedClone(this.getPointCount() * e2));
      }
    }
    if (this.m_envelopeData.copyToIfNotNull(this.m_description, i2.m_envelopeData), i2.m_flags = this.m_flags, i2.m_simpleTolerance = this.m_simpleTolerance, r !== o) {
      const t4 = [Number.NaN];
      i2.getIsSimple(0, t4) >= 3 ? i2.setIsSimple(1, t4[0]) : i2.setIsSimple(-1, 0);
    }
    i2.m_vertexAttributes.swap(h2), h2.destroyAndSetSize(0), i2.m_pointCount = this.m_pointCount, i2.hasDirtyFlag(32) || i2.m_vertexAttributes.empty() ? (n(!s3 || 0 === i2.m_pointCount), i2.m_reservedPointCount = -1) : i2.m_reservedPointCount = i2.m_pointCount;
    try {
      this.copyToImpl(i2, s3);
    } catch (m3) {
      throw i2.setEmpty(), m3;
    }
    i2.verifyAllStreamsAfterSizeChange();
  }
  buildRasterizedGeometryAccelerator(t3, e2) {
    return false;
  }
  getAccelerators() {
    return this.m_accelerators;
  }
  clearAccelerators() {
    this.m_accelerators && this.m_accelerators.release(), this.m_accelerators = null;
  }
  ensureUniqueAccelerators() {
    if (this.m_accelerators && !this.m_accelerators.uniqueUse()) {
      const t3 = this.m_accelerators.clone();
      this.m_accelerators.release(), this.m_accelerators = t3;
    }
  }
  interpolateTwoVertices(t3, e2, s3, r) {
    (t3 < 0 || t3 >= this.m_pointCount) && A(""), (e2 < 0 || e2 >= this.m_pointCount) && A(""), r.assignVertexDescription(this.m_description);
    const o = Yt(us.maxComponentCount(), Number.NaN), a2 = Yt(us.maxComponentCount(), Number.NaN), h2 = B3();
    let u = 0;
    for (let i2 = 0; i2 < this.m_description.getAttributeCount(); i2++) {
      const r2 = this.m_description.getSemantics(i2), m3 = us.getInterpolation(r2), l2 = us.getComponentCount(r2), c = us.getDefaultValue(r2);
      this.queryAttributeAsDbl(r2, t3, o, l2), this.queryAttributeAsDbl(r2, e2, a2, l2), n(u + l2 <= w3), wt(m3, o, a2, h2, u, l2, s3, c), u += l2;
    }
    hs(r, h2);
  }
  getShortestDistance(t3, e2) {
    return mi.distance(this.getXY(t3), this.getXY(e2));
  }
  getShortestSqrDistance(t3, e2) {
    return mi.sqrDistance(this.getXY(t3), this.getXY(e2));
  }
  resizeImpl(e2) {
    if (e2 < 0 && P(), (e2 = Math.ceil(e2)) === this.m_pointCount) return;
    this.m_pointCount = e2;
    const s3 = this.m_pointCount <= this.m_reservedPointCount ? 2001 : 4095;
    this.notifyModifiedFlags(s3);
  }
  assignVertexDescriptionImpl(t3) {
    if (!this.m_vertexAttributes.empty()) {
      const e2 = S2();
      Y2(t3, this.m_description, e2);
      const s3 = new ts();
      s3.destroyAndSetSize(t3.getAttributeCount());
      for (let n5 = 0; n5 < t3.getAttributeCount(); n5++) {
        const t4 = e2[n5];
        -1 !== t4 ? s3.set(n5, this.m_vertexAttributes.get(t4)) : this.m_reservedPointCount = -1;
      }
      s3.swap(this.m_vertexAttributes);
    }
    this.m_description = t3, this.m_envelopeData.releaseAttributes(), this.notifyModifiedFlags(4095);
  }
  hasDirtyFlag(t3) {
    return 0 !== (this.m_flags & t3);
  }
  setDirtyFlagProtected(t3, e2) {
    e2 ? this.m_flags |= t3 : this.m_flags &= ~t3;
  }
  notifyModifiedAllImpl() {
  }
  verifyAllStreamsAfterSizeChange() {
    this.hasDirtyFlag(32) && this.verifyAllStreamsAfterSizeChangeImpl();
  }
  verifyAllStreamsAfterSizeChangeImpl() {
    if (this.hasDirtyFlag(32)) {
      if (this.m_reservedPointCount < this.m_pointCount) {
        this.m_vertexAttributes.empty() && this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()), this.m_reservedPointCount = -1;
        let t3 = Number.MAX_SAFE_INTEGER, e2 = 0;
        e2 = this.m_pointCount < 4 ? 3 : this.m_pointCount <= 128 ? 2 * this.m_pointCount : Math.trunc((4 * this.m_pointCount + 2) / 3);
        for (let s3 = 0; s3 < this.m_description.getAttributeCount(); s3++) {
          const n5 = this.m_description.getSemantics(s3);
          let i2 = 0;
          if (null !== this.m_vertexAttributes.get(s3)) {
            const t4 = us.getComponentCount(n5);
            i2 = this.m_vertexAttributes.get(s3).size() / t4, i2 < this.m_pointCount && (this.m_vertexAttributes.get(s3).resize(e2 * t4, us.getDefaultValue(n5)), i2 = e2);
          } else this.m_vertexAttributes.set(s3, j3(n5, e2)), i2 = e2;
          i2 < t3 && (t3 = i2);
        }
        this.m_reservedPointCount = t3;
      }
      this.verifyStreamsAfterSizeChangeExtraImpl(), this.setDirtyFlagProtected(32, false);
    }
  }
  verifyStreamsAfterSizeChangeExtraImpl() {
  }
  updateAllDirtyIntervals(t3) {
    if (t3 ? this.hasDirtyFlag(192) : this.hasDirtyFlag(128)) {
      if (this.isEmpty()) return this.hasDirtyFlag(192) && this.m_envelopeData.setEmpty(this.m_description), void this.setDirtyFlagProtected(192, false);
      const e2 = this.updateXYImpl(t3), s3 = new re({ vd: this.m_description });
      s3.setEnvelope(e2);
      for (let t4 = 1; t4 < this.m_description.getAttributeCount(); t4++) {
        const e3 = this.m_description.getSemantics(t4), n5 = us.getComponentCount(e3), i2 = this.m_vertexAttributes.get(t4);
        for (let t5 = 0; t5 < n5; t5++) {
          const r = new x2();
          r.setEmpty();
          for (let e4 = 0; e4 < this.m_pointCount; e4++) {
            const s4 = i2.readAsDbl(e4 * n5 + t5);
            r.mergeCoordinate(s4);
          }
          s3.setIntervalEnvelope(e3, t5, r);
        }
      }
      (t3 ? this.hasDirtyFlag(192) : this.hasDirtyFlag(128)) && (this.m_envelopeData = new ne({ moveEnv: s3 }), this.clearDirtyIntervalsFlag(t3));
    }
  }
  updateXYImpl(t3) {
    const e2 = n3.constructEmpty(), s3 = this.m_vertexAttributes.get(0);
    return e2.mergePointsInterleaved(s3, 0, this.m_pointCount), e2;
  }
  updateEnvelope3D(t3) {
    n(0);
  }
  updateLooseEnvelope(t3) {
    this.updateAllDirtyIntervals(false), t3 instanceof n3 ? t3.assign(this.m_envelopeData.m_envelope2D) : this.m_envelopeData.queryEnvelope3D(this.m_description, t3);
  }
  updateEnvelope(t3) {
    this.updateAllDirtyIntervals(true), t3.assign(this.m_envelopeData.m_envelope2D);
  }
  setEmptyImpl() {
    this.m_pointCount = 0, this.m_reservedPointCount = -1, this.m_vertexAttributes.destroyAndSetSize(0), this.notifyModifiedFlags(4095);
  }
  clearDirtyIntervalsFlag(t3) {
    this.setDirtyFlagProtected(192, false);
  }
  reserveImpl(e2, s3) {
    if (e2 < 0 && P(""), 0 === e2) return;
    let n5 = e2 = Math.ceil(e2);
    if (this.m_reservedPointCount < n5) {
      this.m_vertexAttributes.empty() && this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()), s3 ? (null === this.m_vertexAttributes.get(0) && this.m_vertexAttributes.set(0, W(0, 0)), this.m_vertexAttributes.get(0).resizeRounded(2 * n5), n5 = this.m_vertexAttributes.get(0).size() >> 1) : null === this.m_vertexAttributes.get(0) ? this.m_vertexAttributes.set(0, W(0, n5)) : this.m_vertexAttributes.get(0).resize(2 * n5);
      for (let t3 = 1; t3 < this.m_description.getAttributeCount(); t3++) {
        const e3 = this.m_description.getSemantics(t3), s4 = us.getComponentCount(e3);
        null !== this.m_vertexAttributes.get(t3) ? this.m_vertexAttributes.get(t3).resize(n5 * s4) : this.m_vertexAttributes.set(t3, W(e3, n5));
      }
      this.reserveImplImpl(n5, s3), this.m_reservedPointCount = n5;
    }
  }
  reserveRounded(e2) {
    e2 < 0 && P(), e2 = Math.ceil(e2), this.reserveImpl(e2, true);
  }
  reserveImplImpl(t3, e2) {
  }
  throwIfEmpty() {
    this.isEmptyImpl() && x("");
  }
};
var cs2 = class _cs extends ls2 {
  constructor(t3) {
    super(t3), t3 && (t3.points ? this.addPoints2D(t3.points, t3.pointsSize, 0, -1) : t3.point && this.add(t3.point));
  }
  assignCopy(t3) {
    return t3.copyTo(this), this;
  }
  assignMove(t3) {
    return t3.copyTo(this), t3.setEmpty(), this;
  }
  insertPoint2D(e2, s3) {
    e2 > this.getPointCount() && P("invalid point index"), e2 < 0 && (e2 = this.getPointCount());
    const n5 = this.m_pointCount;
    this.resizeNoInit(this.m_pointCount + 1);
    for (let t3 = 0, i2 = this.m_description.getAttributeCount(); t3 < i2; t3++) {
      const i3 = this.m_description.getSemantics(t3), r = z3.getComponentCount(i3);
      if (0 === i3) this.m_vertexAttributes.get(t3).insert(r * e2, s3, r * n5);
      else {
        const s4 = z3.getDefaultValue(i3);
        this.m_vertexAttributes.get(t3).insertRange(r * e2, s4, r, r * n5);
      }
    }
    this.notifyModifiedFlags(2001);
  }
  insertPoint(e2, s3) {
    s3.isEmpty() && P(ms), e2 < 0 && (e2 = this.getPointCount()), this.mergeVertexDescription(s3.getDescription());
    const n5 = this.m_pointCount;
    this.resizeNoInit(this.m_pointCount + 1);
    for (let t3 = 0, i2 = this.m_description.getAttributeCount(); t3 < i2; t3++) {
      const i3 = this.m_description.getSemantics(t3), r = z3.getComponentCount(i3);
      if (s3.hasAttribute(i3)) this.m_vertexAttributes.get(t3).insertAttributes(r * e2, s3, i3, r * n5);
      else {
        const s4 = z3.getDefaultValue(i3);
        this.m_vertexAttributes.get(t3).insertRange(r * e2, s4, r, r * n5);
      }
    }
    this.notifyModifiedFlags(2001);
  }
  insertPoints(t3, e2, s3) {
    if ((t3 > this.getPointCount() || s3 < 0) && A(""), t3 < 0 && (t3 = this.getPointCount()), 0 === s3) return;
    const n5 = e2[0].getDescription();
    this.mergeVertexDescription(n5);
    const r = this.m_pointCount;
    this.resizeNoInit(this.m_pointCount + s3);
    for (let i2 = 0, o = this.m_description.getAttributeCount(); i2 < o; i2++) {
      const o2 = this.m_description.getSemantics(i2), a2 = z3.getComponentCount(o2);
      if (this.m_vertexAttributes.get(i2)) if (n5.hasAttribute(o2)) this.m_vertexAttributes.get(i2).insertAttributesFromPoints(t3 * a2, e2, s3, o2, r * a2);
      else {
        const e3 = z3.getDefaultValue(o2);
        this.m_vertexAttributes.get(i2).insertRange(a2 * t3, e3, a2 * s3, a2 * r);
      }
    }
    this.notifyModifiedFlags(2001);
  }
  insertPoints2D(e2, s3, n5) {
    if ((e2 > this.getPointCount() || n5 < 0) && P("invalid point index"), e2 < 0 && (e2 = this.getPointCount()), 0 === n5) return;
    const i2 = this.m_pointCount;
    this.resizeNoInit(this.m_pointCount + n5);
    for (let t3 = 0, r = this.m_description.getAttributeCount(); t3 < r; t3++) {
      const r2 = this.m_description.getSemantics(t3), o = z3.getComponentCount(r2);
      if (this.m_vertexAttributes.get(t3)) if (0 === r2) this.m_vertexAttributes.get(t3).insertRangeFromPoints(o * e2, s3, 0, n5, true, o * i2);
      else {
        const s4 = z3.getDefaultValue(r2);
        this.m_vertexAttributes.get(t3).insertRange(o * e2, s4, o, o * i2);
      }
    }
    this.notifyModifiedFlags(2001);
  }
  removePoints(t3, e2) {
    if ((t3 < 0 || e2 < 0 || t3 + e2 > this.getPointCount()) && A("remove_points"), 0 !== e2) {
      for (let s3 = 0, n5 = this.m_description.getAttributeCount(); s3 < n5; s3++) if (this.m_vertexAttributes.get(s3)) {
        const n6 = this.m_description.getSemantics(s3), i2 = z3.getComponentCount(n6);
        this.m_vertexAttributes.get(s3).eraseRange(i2 * t3, i2 * e2, i2 * this.m_pointCount);
      }
      this.m_pointCount -= e2, this.m_reservedPointCount > 0 && (this.m_reservedPointCount -= e2), this.notifyModifiedFlags(2001);
    }
  }
  removePoint(t3) {
    for (let e2 = 0, s3 = this.m_description.getAttributeCount(); e2 < s3; e2++) if (this.m_vertexAttributes.get(e2)) {
      const s4 = this.m_description.getSemantics(e2), n5 = z3.getComponentCount(s4);
      this.m_vertexAttributes.get(e2).eraseRange(n5 * t3, n5, n5 * this.m_pointCount);
    }
    this.m_pointCount--, this.m_reservedPointCount > 0 && this.m_reservedPointCount--, this.notifyModifiedFlags(2001);
  }
  calculateEnvelope2D() {
    return this.updateXYImpl(true);
  }
  resizeNoInit(t3) {
    this.resizeImpl(t3);
  }
  resizeAndInitNonPositionAttributes(t3) {
    const e2 = this.m_pointCount;
    if (this.resizeImpl(t3), this.m_pointCount > e2) for (let s3 = 1, n5 = this.m_description.getAttributeCount(); s3 < n5; s3++) {
      const t4 = this.m_description.getSemantics(s3), n6 = z3.getDefaultValue(t4), i2 = z3.getComponentCount(t4);
      this.m_vertexAttributes.get(s3).insertRange(i2 * e2, n6, i2 * (this.m_pointCount - e2), i2 * e2);
    }
  }
  queryCoordinates3D(e2, s3, n5, i2) {
    let r = i2 < 0 ? this.m_pointCount : i2;
    if (r = Math.min(r, n5 + s3), (n5 < 0 || r < n5 || this.m_pointCount > 0 && n5 >= this.m_pointCount) && P(""), 0 === this.m_pointCount) return r;
    const o = this.getAttributeStreamRef(0);
    let a2 = null;
    const h2 = z3.getDefaultValue(1), u = this.m_description.hasAttribute(1);
    u && (a2 = this.getAttributeStreamRef(1));
    let m3 = 0;
    for (let t3 = n5; t3 < r; t3++, m3++) e2[m3].x = o.read(2 * t3), e2[m3].y = o.read(2 * t3 + 1), e2[m3].z = u ? a2.read(t3) : h2;
    return r;
  }
  queryAttributeAsInt(t3, e2, s3, i2) {
    n(0);
  }
  add(e2) {
    e2.isEmpty() && P(ms), this.resizeAndInitNonPositionAttributes(this.m_pointCount + 1), this.setPointByValNoCurves(this.m_pointCount - 1, e2);
  }
  addXY(t3, e2) {
    this.resizeAndInitNonPositionAttributes(this.m_pointCount + 1);
    const s3 = new mi(t3, e2);
    this.setXYNoCurves(this.m_pointCount - 1, s3);
  }
  addXYZ(t3, e2, s3) {
    this.resizeAndInitNonPositionAttributes(this.m_pointCount + 1);
    const n5 = new X();
    n5.setCoords(t3, e2, s3), this.setXYZNoCurves(this.m_pointCount - 1, n5);
  }
  addPoint2D(t3) {
    this.addXY(t3.x, t3.y);
  }
  addPoint3D(t3) {
    this.addXYZ(t3.x, t3.y, t3.z);
  }
  addPoints(e2, s3, n5) {
    this === e2 && P("Multi_point_impl.add");
    const i2 = n5 < 0 ? e2.getPointCount() : n5;
    if ((s3 < 0 || s3 > e2.getPointCount() || i2 < s3) && P(""), s3 === i2) return;
    const r = e2.getDescription();
    this.mergeVertexDescription(r);
    const o = i2 - s3, a2 = this.m_pointCount;
    this.resizeNoInit(this.m_pointCount + o);
    for (let t3 = 0, h2 = this.m_description.getAttributeCount(); t3 < h2; t3++) {
      const n6 = this.m_description.getSemantics(t3), i3 = z3.getComponentCount(n6), h3 = this.getAttributeStreamRef(n6);
      if (r.hasAttribute(n6)) {
        const t4 = e2.getAttributeStreamRef(n6);
        h3.insertRangeFromStream(a2 * i3, t4, s3 * i3, o * i3, true, 1, a2 * i3);
      } else {
        const t4 = z3.getDefaultValue(n6);
        h3.insertRange(a2 * i3, t4, o * i3, a2 * i3);
      }
    }
  }
  addPoints2D(e2, s3, n5, i2) {
    let r = s3;
    const o = i2 < 0 ? r : i2;
    if ((r < 0 || n5 < 0 || n5 > r || o < n5) && P(""), n5 === o) return;
    r = o - n5;
    const a2 = this.m_pointCount;
    this.resizeAndInitNonPositionAttributes(this.m_pointCount + r);
    const h2 = this.getAttributeStreamRef(0);
    for (let t3 = 0; t3 < r; ++t3) h2.writePoint2D(2 * (a2 + t3), e2[n5 + t3]);
    this.notifyModifiedFlags(2001);
  }
  addPoints3D(e2, s3, n5, i2) {
    let r = s3;
    const o = i2 < 0 ? r : i2;
    if ((r < 0 || n5 < 0 || n5 > r || o < n5) && P(""), this.addAttribute(1), n5 === o) return;
    r = o - n5;
    const a2 = this.m_pointCount;
    this.resizeAndInitNonPositionAttributes(this.m_pointCount + r);
    const h2 = this.getAttributeStreamRef(0), u = new mi();
    for (let t3 = 0; t3 < r; t3++) u.x = e2[n5 + t3].x, u.y = e2[n5 + t3].y, h2.writePoint2D(2 * (a2 + t3), u);
    const m3 = this.getAttributeStreamRef(1);
    for (let t3 = 0; t3 < r; t3++) m3.write(a2 + t3, e2[n5 + t3].z);
    this.notifyModifiedFlags(2001);
  }
  setPointByVal(t3, e2) {
    this.setPointByValNoCurves(t3, e2);
  }
  setXY(t3, e2) {
    this.setXYNoCurves(t3, e2);
  }
  setXYCoords(t3, e2, s3) {
    this.setXYCoordsNoCurves(t3, e2, s3);
  }
  setXYZ(t3, e2) {
    this.setXYZNoCurves(t3, e2);
  }
  setAttribute(t3, e2, s3, n5) {
    this.setAttributeNoCurves(t3, e2, s3, n5);
  }
  getGeometryType() {
    return a.enumMultiPoint;
  }
  getDimension() {
    return 0;
  }
  createInstance() {
    return new _cs({ vd: this.getDescription() });
  }
  setEmpty() {
    this.setEmptyImpl();
  }
  applyTransformation(t3) {
    if (this.isEmpty()) return;
    if (t3.isIdentity()) return;
    const e2 = this.m_vertexAttributes.get(0);
    1 === t3.m_TransformationType ? e2.applyTransformation(t3, 0, this.m_pointCount) : z("3d xform not impl"), this.notifyModifiedFlags(2001);
  }
  calculateArea2D() {
    return 0;
  }
  calculateLength2D() {
    return 0;
  }
  calculateLength3D(t3) {
    return 0;
  }
  equals(t3, s3) {
    return t3.getGeometryType() === a.enumMultiPoint && this.equalsBase(t3, s3);
  }
  queryEnvelope(t3) {
    4 === t3.m_EnvelopeType ? (this.updateAllDirtyIntervals(true), this.m_envelopeData.copyTo(this.m_description, t3)) : 2 === t3.m_EnvelopeType ? this.updateEnvelope(t3) : z("");
  }
  getImpl() {
    return this;
  }
  getBoundary() {
    return null;
  }
  reserve(t3) {
    this.reserveImpl(t3);
  }
  clone() {
    const t3 = this.createInstance();
    return this.copyTo(t3), t3;
  }
  swap(t3) {
    n(0);
  }
  buildQuadTreeAccelerator(t3) {
    return false;
  }
  getHashCodeImpl() {
    return n(0), 0;
  }
  equalsImpl(t3) {
    return true;
  }
  equalsImplTol(t3, e2) {
    return true;
  }
  copyToImpl(t3, e2) {
  }
};
cs2.type = a.enumMultiPoint;
var gs = class extends $e {
  constructor(t3) {
    super(t3);
  }
};
var ds2 = class extends gs {
  isTrue3D() {
    return true;
  }
  constructor(t3) {
    super(t3);
  }
};
function _s2(t3, e2, s3) {
  ps(e2, t3.getStartXY(), t3.getEndXY(), s3);
}
function ps(t3, e2, s3, n5) {
  Y(e2, s3, t3, n5);
}
function fs2(t3, e2) {
  return Q(t3.m_XStart, t3.m_XEnd, e2);
}
function Ps2(t3, e2) {
  return Q(t3.m_YStart, t3.m_YEnd, e2);
}
function ys(t3, e2) {
  const s3 = t3.getStartZ(), n5 = t3.getEndZ();
  return Q(s3, n5, e2);
}
function xs(t3, e2, s3) {
  const n5 = ve.constructPoint2D(t3.getStartXY()), i2 = ve.constructPoint2D(t3.getEndXY());
  s3.setCoordsE(i2.x.subE(n5.x), i2.y.subE(n5.y));
}
function Cs(t3, e2, s3) {
  e2.value() <= 0.5 ? O(2, ve.constructPoint2D(t3.getStartXY()), ve.constructPoint2D(t3.getEndXY()), e2, s3) : G2(2, ve.constructPoint2D(t3.getStartXY()), ve.constructPoint2D(t3.getEndXY()), e2, s3);
}
function vs2(t3, e2, s3) {
  t3.m_XStart = e2.x, t3.m_YStart = e2.y, t3.m_XEnd = s3.x, t3.m_YEnd = s3.y, t3.afterCompletedModification();
}
function bs2(t3, e2) {
  const s3 = t3.getStartXYZ();
  s3.z *= e2;
  const n5 = t3.getEndXYZ();
  return n5.z *= e2, s3.norm(1) + n5.norm(1);
}
function Es(t3) {
  if (t3.m_YEnd < t3.m_YStart || t3.m_YEnd === t3.m_YStart && t3.m_XEnd < t3.m_XStart) {
    t3.m_XEnd = Pt(t3.m_XStart, t3.m_XStart = t3.m_XEnd), t3.m_YEnd = Pt(t3.m_YStart, t3.m_YStart = t3.m_YEnd);
    for (let e2 = 0, s3 = t3.m_description.getTotalComponentCount() - 2; e2 < s3; e2++) t3.m_attributes[e2 + s3] = Pt(t3.m_attributes[e2], t3.m_attributes[e2] = t3.m_attributes[e2 + s3]);
  }
}
function Ss2(t3, e2, s3, n5) {
  let i2 = 0;
  if ((t3.m_XStart === e2.m_XStart && t3.m_YStart === e2.m_YStart || t3.m_XStart === e2.m_XEnd && t3.m_YStart === e2.m_YEnd) && (i2++, !n5)) return 1;
  if (t3.m_XEnd === e2.m_XStart && t3.m_YEnd === e2.m_YStart || t3.m_XEnd === e2.m_XEnd && t3.m_YEnd === e2.m_YEnd) {
    if (i2++, 2 === i2) return 2;
    if (!n5) return 1;
  }
  return e2.isIntersectingPoint(t3.getStartXY(), s3, true) || e2.isIntersectingPoint(t3.getEndXY(), s3, true) || t3.isIntersectingPoint(e2.getStartXY(), s3, true) || t3.isIntersectingPoint(e2.getEndXY(), s3, true) ? 4 : n5 && i2 ? 0 : As2(t3, e2) ? 4 : 0;
}
function Ds2(t3, e2, s3, n5, i2, r, o, a2) {
  null !== n5 && Ft(n5, 2, Number.NaN), null !== i2 && Ft(i2, 2, Number.NaN), null !== s3 && Lt(s3, mi, 2);
  const h2 = ws(t3, e2, 2, s3, n5, i2, r, o, a2);
  return n5 && (n5.length = h2), i2 && (i2.length = h2), s3 && (s3.length = h2), h2;
}
function ws(t3, e2, s3, n5, i2, r, o, a2, h2) {
  const u = Is(t3, e2.getStartXY(), o, false), m3 = Is(t3, e2.getEndXY(), o, false), l2 = Is(e2, t3.getStartXY(), o, false), c = Is(e2, t3.getEndXY(), o, false);
  let g2 = 0, d2 = 0;
  if (!Number.isNaN(u)) {
    let s4 = false;
    a2 && Vs(u, 0, 1) && t3.getCoord2D(u).isEqualPoint2D(e2.getStartXY()) && (g2++, s4 = true), s4 || (i2 && (i2[d2] = u), r && (r[d2] = 0), n5 && n5[d2].setCoords(e2.m_XStart, e2.m_YStart), d2++);
  }
  if (!Number.isNaN(m3)) {
    let o2 = false;
    a2 && Vs(m3, 0, 1) && t3.getCoord2D(m3).isEqualPoint2D(e2.getEndXY()) && (g2++, o2 = true), o2 || (s3 > d2 && (i2 && (i2[d2] = m3), r && (r[d2] = 1), n5 && n5[d2].setCoords(e2.m_XEnd, e2.m_YEnd)), d2++);
  }
  if (2 !== d2 && !Number.isNaN(l2) && !(0 === u && 0 === l2 || 0 === m3 && 1 === l2)) {
    let o2 = false;
    a2 && Vs(l2, 0, 1) && e2.getCoord2D(l2).isEqualPoint2D(t3.getStartXY()) && (g2++, o2 = true), o2 || (s3 > d2 && (i2 && (i2[d2] = 0), r && (r[d2] = l2), n5 && n5[d2].setCoords(t3.m_XStart, t3.m_YStart)), d2++);
  }
  if (2 !== d2 && !Number.isNaN(c) && !(1 === u && 0 === c || 1 === m3 && 1 === c)) {
    let o2 = false;
    a2 && Vs(c, 0, 1) && e2.getCoord2D(c).isEqualPoint2D(t3.getEndXY()) && (g2++, o2 = true), o2 || (s3 > d2 && (i2 && (i2[d2] = 1), r && (r[d2] = c), n5 && n5[d2].setCoords(e2.m_XEnd, e2.m_YEnd)), d2++);
  }
  if (d2 > 0) return h2 && (r = Pt(i2, i2 = r)), 2 === d2 && s3 >= 2 && i2 && i2[0] > i2[1] && (i2[1] = Pt(i2[0], i2[0] = i2[1]), r && (r[1] = Pt(r[0], r[0] = r[1])), n5 && (n5[1] = Pt(n5[0], n5[0] = n5[1]))), d2;
  if (g2 > 0) return 0;
  const _ = qs2(t3, e2, o);
  return Number.isNaN(_.x) ? 0 : (n5 && (n5[0] = t3.getCoord2D(_.x)), i2 && (i2[0] = _.x), r && (r[0] = _.y), 1);
}
function As2(t3, e2) {
  const s3 = Ms(t3, e2.m_XStart, e2.m_YStart), n5 = Ms(t3, e2.m_XEnd, e2.m_YEnd);
  if (s3 < 0 && n5 < 0 || s3 > 0 && n5 > 0) return false;
  const i2 = Ms(e2, t3.m_XStart, t3.m_YStart), r = Ms(e2, t3.m_XEnd, t3.m_YEnd);
  if (i2 < 0 && r < 0 || i2 > 0 && r > 0) return false;
  return Xs2(t3) > Xs2(e2) ? Ns(t3, e2) : Ns(e2, t3);
}
function Is(t3, e2, s3, n5) {
  const i2 = mi.getNAN(), r = mi.getNAN();
  let o = false;
  t3.m_YEnd < t3.m_YStart || t3.m_YEnd === t3.m_YStart && t3.m_XEnd < t3.m_XStart ? (i2.setCoords(t3.m_XEnd, t3.m_YEnd), r.setCoords(t3.m_XStart, t3.m_YStart), o = true) : (i2.setCoords(t3.m_XStart, t3.m_YStart), r.setCoords(t3.m_XEnd, t3.m_YEnd));
  const a2 = o ? 1 : 0, h2 = o ? 0 : 1, u = mi.getNAN();
  u.setSub(e2, i2);
  let m3 = u.length(), l2 = 3 * m3 * Qs();
  if (m3 <= Math.max(s3, l2)) return n5 && 0 === m3 ? Number.NaN : a2;
  if (u.setSub(e2, r), m3 = u.length(), l2 = 3 * m3 * Qs(), m3 <= Math.max(s3, l2)) return n5 && 0 === m3 ? Number.NaN : h2;
  u.setCoords(r.x - i2.x, r.y - i2.y);
  const c = u.length();
  if (c > 0) {
    const t4 = 1 / c;
    u.scale(t4);
    const n6 = mi.getNAN();
    n6.setSub(e2, i2);
    const m4 = n6.dotProduct(u), l3 = 8 * n6.dotProductAbs(u) * Qs();
    u.leftPerpendicularThis();
    const g2 = n6.dotProduct(u), d2 = 8 * n6.dotProductAbs(u) * Qs(), _ = Math.max(s3, l3);
    if (m4 < -_ || m4 > c + _) return Number.NaN;
    const p3 = Math.max(s3, d2);
    if (Math.abs(g2) <= p3) {
      let n7 = m4 * t4;
      n7 = Us(n7, 0, 1);
      const u2 = mi.getNAN();
      if (ps(n7, i2, r, u2), mi.distance(u2, e2) <= s3) {
        if (n7 < 0.5) {
          if (mi.distance(u2, i2) <= s3 && mi.distance(e2, i2) <= s3) return a2;
        } else if (mi.distance(u2, r) <= s3 && mi.distance(e2, r) <= s3) return h2;
        return o ? 1 - n7 : n7;
      }
    }
  }
  return Number.NaN;
}
function Ms(t3, e2, s3) {
  const n5 = mi.getNAN();
  n5.setCoords(e2, s3), n5.subThis(t3.getStartXY());
  const i2 = mi.getNAN();
  i2.setSub(t3.getEndXY(), t3.getStartXY());
  const r = i2.crossProduct(n5), o = 4 * Qs() * (Math.abs(i2.x * n5.y) + Math.abs(i2.y * n5.x));
  return r > o ? -1 : r < -o ? 1 : 0;
}
function Ys2(t3, e2, s3, n5) {
  const i2 = n5 ? t3.m_XStart : t3.m_XEnd, r = n5 ? t3.m_YStart : t3.m_YEnd, o = mi.getNAN();
  o.x = e2.getEndX() - i2, o.y = e2.getEndY() - r;
  if (s3.dotProduct(o) > 3 * Qs() * s3.dotProductAbs(o)) {
    o.x = e2.getStartX() - i2, o.y = e2.getStartY() - r;
    return s3.dotProduct(o) <= 3 * Qs() * s3.dotProductAbs(o);
  }
  return true;
}
function Ns(t3, e2) {
  const s3 = mi.getNAN();
  return s3.x = t3.m_XEnd - t3.m_XStart, s3.y = t3.m_YEnd - t3.m_YStart, !!Ys2(t3, e2, s3, false) && (s3.negateThis(), !!Ys2(t3, e2, s3, true));
}
function Xs2(t3) {
  const e2 = t3.m_XStart - t3.m_XEnd, s3 = t3.m_YStart - t3.m_YEnd;
  return e2 * e2 + s3 * s3;
}
function qs2(t3, e2, s3) {
  const n5 = t3.m_XEnd - t3.m_XStart, i2 = t3.m_YEnd - t3.m_YStart, r = e2.m_XEnd - e2.m_XStart, o = e2.m_YEnd - e2.m_YStart, a2 = r * i2 - n5 * o;
  if (0 === a2) return mi.getNAN();
  const h2 = 4 * Qs() * (Math.abs(r * i2) + Math.abs(n5 * o)), u = e2.m_XStart - t3.m_XStart, m3 = e2.m_YStart - t3.m_YStart, l2 = r * m3 - u * o, c = 4 * Qs() * (Math.abs(r * m3) + Math.abs(u * o)), g2 = l2 / a2, d2 = Math.abs(a2), _ = (c * d2 + h2 * Math.abs(l2)) / (a2 * a2) + Qs() * Math.abs(g2);
  if (g2 < -_ || g2 > 1 + _) return mi.getNAN();
  const p3 = n5 * m3 - u * i2, f3 = p3 / a2, P5 = (4 * Qs() * (Math.abs(n5 * m3) + Math.abs(u * i2)) * d2 + h2 * Math.abs(p3)) / (a2 * a2) + Qs() * Math.abs(f3);
  if (f3 < -P5 || f3 > 1 + P5) return mi.getNAN();
  let y2 = Us(g2, 0, 1), x4 = Us(f3, 0, 1);
  const C3 = mi.getNAN();
  _s2(t3, y2, C3);
  const v3 = mi.getNAN();
  if (_s2(e2, x4, v3), !s3 || mi.distance(C3, v3) > s3) {
    const n6 = mi.getNAN();
    Y(C3, v3, 0.5, n6), y2 = t3.getClosestCoordinate(n6, false), x4 = e2.getClosestCoordinate(n6, false);
    const i3 = mi.getNAN();
    _s2(t3, y2, i3);
    const r2 = mi.getNAN();
    _s2(e2, x4, r2), i3.subThis(r2);
    const o2 = i3.length(), a3 = (t3.absNorm() + e2.absNorm()) * Ls();
    if (o2 > Math.max(s3, a3)) return mi.getNAN();
  }
  return new mi(y2, x4);
}
var Fs = class {
  constructor(t3) {
    if (this.m_segFlagStream = null, this.m_xyStream = null, this.m_bCirculator = false, this.m_currentSegmentIndex = -1, this.m_nextSegmentIndex = 0, this.m_nextPathIndex = 0, this.m_currentPathIndex = -1, this.m_parent = t3.parent, this.m_buffer = new this.m_parent.m_segmentBufferCTor(), this.m_description = t3.parent.getDescription(), this.m_segmentCount = this.getSegmentCount(this.m_nextPathIndex), void 0 !== t3.pointIndex) {
      (t3.pointIndex < 0 || t3.pointIndex >= t3.parent.getPointCount()) && A("");
      const e2 = t3.parent.getPathIndexFromPointIndex(t3.pointIndex);
      this.m_currentPathIndex = e2, this.m_nextPathIndex = e2 + 1, this.m_nextSegmentIndex = t3.pointIndex - t3.parent.getPathStart(e2), this.m_segmentCount = this.getSegmentCount(this.m_currentPathIndex);
    } else if (void 0 !== t3.pathIndex) {
      (t3.pathIndex < 0 || t3.pathIndex >= t3.parent.getPathCount() || t3.segmentIndex < 0) && A("");
      const e2 = t3.parent.isClosedPath(t3.pathIndex) ? 0 : 1;
      t3.segmentIndex >= t3.parent.getPathSize(t3.pathIndex) - e2 && A(""), this.m_nextSegmentIndex = t3.segmentIndex, this.m_currentPathIndex = t3.pathIndex, this.m_nextPathIndex = this.m_nextSegmentIndex + 1, this.m_segmentCount = this.getSegmentCount(this.m_nextPathIndex);
    }
    this.prepare(), this.m_pathBegin = -1, this.m_bCurrentPathClosed = false, this.m_bStripAttributes = false, this.m_prevPathIndex = -1, this.m_prevSegmentIndex = -1, this.m_bNeedsUpdate = false, this.m_currentPathIndex > -1 && (this.m_pathBegin = this.m_parent.getPathStart(this.m_currentPathIndex), this.m_bCurrentPathClosed = this.m_parent.isClosedPath(this.m_currentPathIndex));
  }
  stripAttributes() {
    this.m_bStripAttributes = true;
  }
  prepare() {
    this.m_bCirculator = false, this.m_parent.isEmptyImpl() ? (this.m_segFlagStream = null, this.m_xyStream = null) : (this.m_segFlagStream = this.m_parent.getSegmentFlagsStreamRef(), this.m_xyStream = this.m_parent.getAttributeStreamRef(0));
  }
  nextPath() {
    return this.m_currentPathIndex = this.m_nextPathIndex, !(this.m_currentPathIndex >= this.m_parent.getPathCount()) && (this.m_currentSegmentIndex = -1, this.m_nextSegmentIndex = 0, this.m_segmentCount = this.getSegmentCount(this.m_currentPathIndex), this.m_pathBegin = this.m_parent.getPathStart(this.m_currentPathIndex), this.m_bCurrentPathClosed = this.m_parent.isClosedPath(this.m_currentPathIndex), this.m_nextPathIndex++, true);
  }
  previousPath() {
    return 0 !== this.m_nextPathIndex && (this.m_nextPathIndex--, this.m_currentSegmentIndex = -1, this.m_nextSegmentIndex = 0, this.m_segmentCount = this.getSegmentCount(this.m_nextPathIndex), this.m_currentPathIndex = this.m_nextPathIndex, this.m_pathBegin = this.m_parent.getPathStart(this.m_currentPathIndex), this.m_bCurrentPathClosed = this.m_parent.isClosedPath(this.m_currentPathIndex), this.resetToLastSegment(), true);
  }
  getSegmentCount(t3) {
    return this.m_parent.isEmptyImpl() ? 0 : this.m_parent.getSegmentCountPath(t3);
  }
  resetToFirstPath() {
    this.m_currentSegmentIndex = -1, this.m_nextSegmentIndex = -1, this.m_segmentCount = -1, this.m_nextPathIndex = 0, this.m_currentPathIndex = -1, this.m_pathBegin = -1, this.m_bCurrentPathClosed = false;
  }
  resetToLastPath() {
    this.m_nextPathIndex = this.m_parent.getPathCount(), this.m_currentPathIndex = -1, this.m_currentSegmentIndex = -1, this.m_nextSegmentIndex = -1, this.m_segmentCount = -1, this.m_pathBegin = -1;
  }
  resetToPath(t3) {
    (t3 < 0 || t3 > this.m_parent.getPathCount()) && A(""), this.m_nextPathIndex = t3, this.m_currentPathIndex = -1, this.m_currentSegmentIndex = -1, this.m_nextSegmentIndex = -1, this.m_segmentCount = -1, this.m_pathBegin = -1, this.m_bCurrentPathClosed = false;
  }
  isLastPath() {
    return this.m_currentPathIndex === this.m_parent.getPathCount() - 1;
  }
  isFirstSegmentInPath() {
    return 0 === this.m_currentSegmentIndex;
  }
  isLastSegmentInPath() {
    return this.m_currentSegmentIndex === this.m_segmentCount - 1;
  }
  resetToFirstSegment() {
    this.m_currentSegmentIndex = -1, this.m_nextSegmentIndex = 0;
  }
  resetToLastSegment() {
    this.m_nextSegmentIndex = this.m_segmentCount, this.m_currentSegmentIndex = -1;
  }
  resetTo(t3) {
    this.m_parent !== t3.m_parent && C(""), this.m_currentSegmentIndex = t3.m_currentSegmentIndex, this.m_nextSegmentIndex = t3.m_nextSegmentIndex, this.m_currentPathIndex = t3.m_currentPathIndex, this.m_nextPathIndex = t3.m_nextPathIndex, this.m_segmentCount = t3.m_segmentCount, this.m_bCirculator = t3.m_bCirculator, this.m_pathBegin = t3.m_pathBegin, this.m_bCurrentPathClosed = t3.m_bCurrentPathClosed, this.m_bStripAttributes = t3.m_bStripAttributes, this.m_description = t3.m_description;
  }
  resetToVertex(t3, e2) {
    if (this.m_currentPathIndex >= 0 && this.m_currentPathIndex < this.m_parent.getPathCount()) {
      const e3 = this.getPathBegin();
      if (t3 >= e3 && t3 < this.m_parent.getPathEnd(this.m_currentPathIndex)) return this.m_currentSegmentIndex = -1, void (this.m_nextSegmentIndex = t3 - e3);
    }
    let s3;
    s3 = e2 >= 0 && e2 < this.m_parent.getPathCount() && t3 >= this.m_parent.getPathStart(e2) && t3 < this.m_parent.getPathEnd(e2) ? e2 : this.m_parent.getPathIndexFromPointIndex(t3), this.m_nextPathIndex = s3 + 1, this.m_currentPathIndex = s3, this.m_currentSegmentIndex = -1, this.m_nextSegmentIndex = t3 - this.m_parent.getPathStart(s3), this.m_segmentCount = this.getSegmentCount(s3), this.m_pathBegin = this.m_parent.getPathStart(this.m_currentPathIndex), this.m_bCurrentPathClosed = this.m_parent.isClosedPath(this.m_currentPathIndex);
  }
  hasNextSegment() {
    return this.m_nextSegmentIndex < this.m_segmentCount;
  }
  hasPreviousSegment() {
    return this.m_nextSegmentIndex > 0;
  }
  nextSegment() {
    return this.m_currentSegmentIndex !== this.m_nextSegmentIndex && this.updateSegment(), this.m_bCirculator ? this.m_nextSegmentIndex = (this.m_nextSegmentIndex + 1) % this.m_segmentCount : (this.m_nextSegmentIndex === this.m_segmentCount && A("Segment_iterator_impl::next_segment"), this.m_nextSegmentIndex++), this.m_buffer.get();
  }
  previousSegment() {
    return this.m_bCirculator ? this.m_nextSegmentIndex = (this.m_segmentCount + this.m_nextSegmentIndex - 1) % this.m_segmentCount : (0 === this.m_nextSegmentIndex && A(""), this.m_nextSegmentIndex--), this.m_nextSegmentIndex !== this.m_currentSegmentIndex && this.updateSegment(), this.m_buffer.get();
  }
  nextCurve() {
    if (!this.m_parent.hasNonLinearSegments()) return this.resetToLastSegment(), null;
    let t3 = 0;
    for (; ; ) {
      if (this.m_nextSegmentIndex === this.m_segmentCount || t3 === this.m_segmentCount) return null;
      const e2 = this.getPathBegin() + this.m_nextSegmentIndex;
      if (1 !== (31 & this.m_segFlagStream.read(e2))) {
        this.updateSegment();
        break;
      }
      this.m_bCirculator ? this.m_nextSegmentIndex = (this.m_nextSegmentIndex + 1) % this.m_segmentCount : this.m_nextSegmentIndex++, t3++;
    }
    return this.m_currentSegmentIndex !== this.m_nextSegmentIndex && this.updateSegment(), this.m_bCirculator ? this.m_nextSegmentIndex = (this.m_nextSegmentIndex + 1) % this.m_segmentCount : (this.m_nextSegmentIndex === this.m_segmentCount && A(""), this.m_nextSegmentIndex++), this.m_buffer.get();
  }
  getPathBegin() {
    return this.m_pathBegin;
  }
  getPathIndex() {
    return this.m_currentPathIndex;
  }
  getStartPointIndex() {
    return this.getPathBegin() + this.m_currentSegmentIndex;
  }
  getEndPointIndex() {
    return this.isClosingSegment() ? this.getPathBegin() : this.getStartPointIndex() + 1;
  }
  updateSegment() {
    (this.m_nextSegmentIndex < 0 || this.m_nextSegmentIndex >= this.m_segmentCount || this.m_currentPathIndex < 0) && A(""), this.m_currentSegmentIndex = this.m_nextSegmentIndex, this.m_parent.getSegmentFromPath(this.m_currentPathIndex, this.m_currentSegmentIndex, this.m_buffer, this.m_bStripAttributes);
  }
  isClosingSegment() {
    return this.m_bCurrentPathClosed && this.m_currentSegmentIndex === this.m_segmentCount - 1;
  }
  isCurve() {
    if (null !== this.m_segFlagStream) {
      return 1 !== (31 & this.m_segFlagStream.read(this.m_currentSegmentIndex));
    }
    return false;
  }
  isPathClosed() {
    return this.m_bCurrentPathClosed;
  }
  setCirculator(t3) {
    this.m_bCirculator = t3;
  }
  getImpl() {
    return this;
  }
};
var Vs2 = class _Vs {
  constructor(t3) {
    this.m_rasterizedGeometry = null, this.m_quadTree = null, this.m_quadTreeForPaths = null, this.m_refCount = 1, t3 && t3.copyTo(this);
  }
  getRasterizedGeometry() {
    return this.m_rasterizedGeometry;
  }
  copyTo(t3) {
    t3 !== this && (n(t3.uniqueUse()), t3.m_quadTree = this.m_quadTree, t3.m_quadTreeForPaths = this.m_quadTreeForPaths, t3.m_rasterizedGeometry = this.m_rasterizedGeometry);
  }
  clone() {
    const t3 = new _Vs();
    return this.copyTo(t3), t3;
  }
  uniqueUse() {
    return 1 === this.m_refCount;
  }
  addRef() {
    ++this.m_refCount;
  }
  release() {
    0 === --this.m_refCount && (this.m_rasterizedGeometry = null, this.m_quadTree = null, this.m_quadTreeForPaths = null);
  }
  setRasterizedGeometry(t3) {
    n(this.uniqueUse());
  }
  setQuadTree(t3) {
    n(this.uniqueUse()), this.m_quadTree = t3;
  }
  setQuadTreeForPaths(t3) {
    n(this.uniqueUse()), this.m_quadTreeForPaths = t3;
  }
  getQuadTree() {
    return this.m_quadTree;
  }
  getQuadTreeForPaths() {
    return this.m_quadTreeForPaths;
  }
};
function Ls2(t3) {
  return !(t3.isEmpty() || t3.getGeometryType() !== a.enumPolyline && t3.getGeometryType() !== a.enumPolygon) && !(t3.getPointCount() < 20);
}
function Rs(t3) {
  return !(t3.isEmpty() || t3.getGeometryType() !== a.enumPolyline && t3.getGeometryType() !== a.enumPolygon) && !(t3.getPointCount() < 20);
}
function zs2(t3, e2) {
  return t3.readPoint2D(e2 + 4);
}
function Bs2(t3) {
  const s3 = t3.getGeometryType();
  return s3 === a.enumEllipticArc ? 10 : s3 === a.enumBezier ? 4 : s3 === a.enumRationalBezier2 ? 5 : s3 === a.enumBezier2 ? 2 : void b("");
}
function ks(t3) {
  const e2 = 31 & t3;
  return 4 === e2 ? 10 : 2 === e2 ? 4 : 8 === e2 ? 5 : 16 === e2 ? 2 : 0;
}
function Gs2(t3, e2, s3, n5) {
  const i2 = t3.getPathStart(e2), r = t3.getPathEnd(e2);
  if (r - i2 < 3) return;
  const o = 2 * i2, a2 = mi.getNAN();
  s3.queryPoint2D(o, a2);
  const h2 = a2.x, u = a2.y, m3 = mi.getNAN();
  s3.queryPoint2D(o + 2, m3);
  const l2 = mi.getNAN();
  for (let c = o + 4, g2 = 2 * r; c < g2; c += 2) s3.queryPoint2D(c, l2), n5.pe((l2.x - a2.x) * (m3.y - u)), a2.setCoordsPoint2D(m3), m3.setCoordsPoint2D(l2);
  n5.pe((h2 - a2.x) * (m3.y - u));
}
function Ws2(t3, e2, s3) {
  for (; e2.hasNextSegment(); ) {
    const t4 = e2.nextCurve();
    if (null === t4) break;
    s3.pe(2 * t4.calculateArea2DHelper());
  }
}
var js2 = z3;
var Zs2 = class {
  static toSegType(t3) {
    let s3 = 0;
    switch (t3) {
      case a.enumLine:
        s3 = 1;
        break;
      case a.enumBezier:
        s3 = 2;
        break;
      case a.enumEllipticArc:
        s3 = 4;
        break;
      case a.enumRationalBezier2:
        s3 = 8;
        break;
      case a.enumBezier2:
        s3 = 16;
        break;
      default:
        b("");
    }
    return s3;
  }
  constructor() {
    this.m_segmentFlags = null, this.m_segmentParamIndex = null, this.m_segmentParams = null, this.m_curveCount = 0, this.m_bezierCount = 0, this.m_arcCount = 0, this.m_rbezier2Count = 0, this.m_bezier2Count = 0, this.m_curveParamWritePoint = 0;
  }
  assignCopy(t3) {
    return this.m_segmentFlags = t3.m_segmentFlags, this.m_segmentParamIndex = t3.m_segmentParamIndex, this.m_segmentParams = t3.m_segmentParams, this.m_curveCount = t3.m_curveCount, this.m_bezierCount = t3.m_bezierCount, this.m_arcCount = t3.m_arcCount, this.m_rbezier2Count = t3.m_rbezier2Count, this.m_bezier2Count = t3.m_bezier2Count, this.m_curveParamWritePoint = t3.m_curveParamWritePoint, this;
  }
};
var Hs2 = class _Hs extends ls2 {
  constructor(t3) {
    super(t3), this.m_cachedRingAreas2D = null, this.m_paths = null, this.m_pathFlags = null, this.m_curveData = null, t3.move ? (this.m_bPolygon = t3.move.m_bPolygon, this.m_cachedLength2D = t3.move.m_cachedLength2D, this.m_cachedArea2D = t3.move.m_cachedArea2D, this.m_currentPathIndex = t3.move.m_currentPathIndex, this.m_cachedRingAreas2D = t3.move.m_cachedRingAreas2D, this.m_paths = t3.move.m_paths, this.m_pathFlags = t3.move.m_pathFlags, this.m_curveData = t3.move.m_curveData, t3.move.m_curveData = null, t3.move.setEmpty()) : (this.m_bPolygon = t3.bPolygon, this.m_cachedLength2D = 0, this.m_cachedArea2D = 0, this.m_currentPathIndex = 0);
  }
  getGeometryType() {
    return this.m_bPolygon ? a.enumPolygon : a.enumPolyline;
  }
  getDimension() {
    return this.m_bPolygon ? 2 : 1;
  }
  changeRingStartPoint(e2) {
    n(this.m_bPolygon);
    const s3 = this.getPathIndexFromPointIndex(e2), i2 = this.getPathStart(s3);
    if (i2 === e2) return;
    const r = this.getPathEnd(s3);
    (e2 >= r || e2 < i2) && P("change_ring_start_point");
    for (let t3 = 0, n5 = this.m_description.getAttributeCount(); t3 < n5; t3++) {
      const s4 = this.m_description.getSemantics(t3), n6 = js2.getComponentCount(s4);
      this.m_vertexAttributes.get(t3).rotate(i2 * n6, e2 * n6, r * n6);
    }
    this.hasNonLinearSegments() && (this.m_curveData.m_segmentFlags.rotate(i2, e2, r), this.m_curveData.m_segmentParamIndex.rotate(i2, e2, r));
  }
  setFillRule(t3) {
    this.m_bFillRule = 1 === t3;
  }
  getFillRule() {
    return this.m_bFillRule ? 1 : 0;
  }
  isExteriorRingOGC(t3) {
    return !!this.m_bPolygon && (this.updateOGCFlagsProtected(), !!(8 & this.m_pathFlags.read(t3)));
  }
  isExteriorRing(t3) {
    return this.calculateRingArea2D(t3) > 0;
  }
  calculateRingArea2D(t3) {
    return this.m_bPolygon ? (this.updateRingAreas2DProtected(), this.m_cachedRingAreas2D.read(t3)) : 0;
  }
  updateRingAreas2DProtected() {
    if (!this.hasDirtyFlag(1024)) return;
    const t3 = this.getPathCount();
    if (0 === t3) return this.hasDirtyFlag(1024) && (this.m_cachedArea2D = 0), void this.setDirtyFlagProtected(1024, false);
    const e2 = new nt(t3), s3 = new n2(0), n5 = new n2(0);
    if (0 !== this.m_pointCount) {
      const i2 = this.getAttributeStreamRef(0);
      if (this.hasNonLinearSegments()) {
        const t4 = new Fs({ parent: this });
        for (t4.stripAttributes(); t4.nextPath(); ) {
          n5.reset();
          const r = t4.getPathIndex();
          Gs2(this, r, i2, n5), Ws2(this, t4, n5);
          const o = 0.5 * n5.getResult();
          s3.add(o), e2.write(r, o);
        }
      } else for (let r = 0; r < t3; r++) {
        n5.reset(), Gs2(this, r, i2, n5);
        const t4 = 0.5 * n5.getResult();
        s3.add(t4), e2.write(r, t4);
      }
    }
    this.hasDirtyFlag(1024) && (this.m_cachedArea2D = s3.getResult(), this.m_cachedRingAreas2D = e2, this.setDirtyFlagProtected(1024, false));
  }
  getOGCPolygonCount() {
    if (!this.m_bPolygon) return 0;
    this.updateOGCFlagsProtected();
    let t3 = 0;
    const e2 = this.getPathCount();
    for (let s3 = 0; s3 < e2; s3++) 8 & this.m_pathFlags.read(s3) && t3++;
    return t3;
  }
  getHashCodeImpl() {
    return n(0), 0;
  }
  equalsImpl(t3) {
    const e2 = t3, s3 = this.getPathCount();
    if (s3 !== e2.getPathCount()) return false;
    const n5 = this.hasNonLinearSegments();
    if (n5 !== e2.hasNonLinearSegments()) return false;
    if (n5) {
      if (this.m_curveData.m_curveCount !== e2.m_curveData.m_curveCount) return false;
      if (this.m_curveData.m_bezierCount !== e2.m_curveData.m_bezierCount) return false;
    }
    if (this.m_paths && !this.m_paths.equals(e2.m_paths, 0, s3 + 1)) return false;
    if (this.m_bFillRule !== e2.m_bFillRule) return false;
    if (!this.m_bPolygon && this.m_pathFlags && !this.m_pathFlags.equals(e2.m_pathFlags, 0, s3)) return false;
    if (this.hasNonLinearSegments()) {
      if (!this.m_curveData.m_segmentFlags.equals(e2.m_curveData.m_segmentFlags, 0, this.getPointCount())) return false;
      for (let t4 = 0, s4 = this.getPointCount(); t4 < s4; t4++) {
        const s5 = this.m_curveData.m_segmentFlags.read(t4);
        if (!_Hs.isNonLinearSegmentFlag(s5)) continue;
        const n6 = this.m_curveData.m_segmentParamIndex.read(t4), i2 = e2.m_curveData.m_segmentParamIndex.read(t4), r = ks(s5);
        for (let t5 = 0; t5 < r; t5++) {
          const s6 = this.m_curveData.m_segmentParams.read(n6 + t5), r2 = e2.m_curveData.m_segmentParams.read(i2 + t5);
          if (!ls(s6, r2)) return false;
        }
      }
    }
    return true;
  }
  equalsImplTol(t3, e2) {
    const s3 = t3, n5 = this.getPathCount();
    if (n5 !== s3.getPathCount()) return false;
    const i2 = this.hasNonLinearSegments();
    if (i2 !== s3.hasNonLinearSegments()) return false;
    if (i2) {
      if (this.m_curveData.m_curveCount !== s3.m_curveData.m_curveCount) return false;
      if (this.m_curveData.m_bezierCount !== s3.m_curveData.m_bezierCount) return false;
    }
    if (this.m_paths && !this.m_paths.equals(s3.m_paths, 0, n5 + 1)) return false;
    if (this.m_bFillRule !== s3.m_bFillRule) return false;
    if (!this.m_bPolygon && this.m_pathFlags && !this.m_pathFlags.equals(s3.m_pathFlags, 0, n5)) return false;
    if (!i2) return true;
    if (!this.m_curveData.m_segmentFlags.equals(s3.m_curveData.m_segmentFlags, 0, this.getPointCount())) return false;
    const r = this.querySegmentIterator(), o = s3.querySegmentIterator();
    for (; r.nextPath(); ) {
      if (!o.nextPath()) return false;
      for (; r.hasNextSegment(); ) {
        const t4 = r.nextCurve(), s4 = o.nextCurve();
        if (!(t4 && s4 && t4.equals(s4, e2))) {
          if (!t4 && !s4) break;
          return false;
        }
      }
    }
    return true;
  }
  reserveImplImpl(t3, e2) {
    this.m_curveData && this.m_curveData.m_segmentFlags && (this.m_curveData.m_segmentFlags.resize(t3, 1), this.m_curveData.m_segmentParamIndex.resize(t3, -1), this.checkCompactSegmentParams());
  }
  verifyStreamsAfterSizeChangeExtraImpl() {
    this.m_paths || (this.m_paths = J2(1, 0), this.m_pathFlags = K2(1, 0)), this.m_curveData && this.m_curveData.m_segmentFlags && (this.m_curveData.m_segmentFlags.resize(this.m_reservedPointCount, 1), this.m_curveData.m_segmentParamIndex.resize(this.m_reservedPointCount, -1), this.checkCompactSegmentParams());
  }
  copyToImpl(t3, e2) {
    const s3 = t3;
    s3.m_bPathStarted = false, s3.m_bFillRule = this.m_bFillRule, this.m_paths ? s3.m_paths = e2 ? this.m_paths : this.m_paths.clone() : s3.m_paths = null, this.m_pathFlags ? s3.m_pathFlags = e2 ? this.m_pathFlags : this.m_pathFlags.clone() : s3.m_pathFlags = null, this.m_curveData && (s3.m_curveData || (s3.m_curveData = new Zs2()), s3.m_curveData.assignCopy(this.m_curveData), s3.m_curveData.m_curveCount = 0, s3.updateCurveCounter(this.m_curveData.m_curveCount), e2 || (this.m_curveData.m_segmentParamIndex ? s3.m_curveData.m_segmentParamIndex = this.m_curveData.m_segmentParamIndex.clone() : s3.m_curveData.m_segmentParamIndex = null, this.m_curveData.m_segmentFlags ? s3.m_curveData.m_segmentFlags = this.m_curveData.m_segmentFlags.clone() : s3.m_curveData.m_segmentFlags = null, this.m_curveData.m_segmentParams ? s3.m_curveData.m_segmentParams = this.m_curveData.m_segmentParams.clone() : s3.m_curveData.m_segmentParams = null)), s3.hasDirtyFlag(512) || (s3.m_cachedLength2D = this.m_cachedLength2D), s3.m_cachedRingAreas2D = null, s3.hasDirtyFlag(1024) || (s3.m_cachedArea2D = this.m_cachedArea2D, null !== this.m_cachedRingAreas2D && (s3.m_cachedRingAreas2D = e2 ? this.m_cachedRingAreas2D : this.m_cachedRingAreas2D.clone()));
  }
  calculateArea2D() {
    return this.m_bPolygon ? (this.updateRingAreas2DProtected(), this.m_cachedArea2D) : 0;
  }
  calculateLength2D() {
    if (!this.hasDirtyFlag(512)) return this.m_cachedLength2D;
    const t3 = this.querySegmentIterator(), e2 = new n2(0);
    for (; t3.nextPath(); ) for (; t3.hasNextSegment(); ) e2.add(t3.nextSegment().calculateLength2D());
    return this.hasDirtyFlag(512) && (this.m_cachedLength2D = e2.getResult()), this.setDirtyFlagProtected(512, false), e2.getResult();
  }
  calculatePathLength2D(t3) {
    const e2 = this.querySegmentIteratorAtVertex(this.getPathStart(t3)), s3 = new n2(0);
    for (; e2.hasNextSegment(); ) s3.add(e2.nextSegment().calculateLength2D());
    return s3.getResult();
  }
  calculateLength3D(t3) {
    return n(0), 0;
  }
  calculatePathLength3D(t3, e2) {
    return n(0), 0;
  }
  copyTo(e2) {
    h(e2.getGeometryType()) || P(""), this !== e2 && super.copyTo(e2);
  }
  swap(t3) {
    n(0);
  }
  setPointByVal(t3, e2) {
    this.setPointByValWithCurves(t3, e2);
  }
  setPointByValWithCurves(t3, e2) {
    if (this.hasNonLinearSegments()) {
      const s3 = e2.getXY();
      if (this.setXYCoordsWithCurves(t3, s3.x, s3.y), 1 === this.m_description.getAttributeCount()) return;
    }
    this.setPointByValNoCurves(t3, e2);
  }
  setXYCoordsWithCurves(t3, e2, s3) {
    if (this.hasNonLinearSegments()) {
      const n5 = _Hs.getPathIndexFromPointIndexImpl(this.m_paths, this.getPathCount(), t3, this.m_currentPathIndex);
      this.m_currentPathIndex = n5;
      const i2 = this.getPrevSegmentTypeFromPath(n5, t3), r = this.getNextSegmentType(t3);
      if (1 !== i2 || 1 !== r) {
        let o = t3 - 1;
        const a2 = new fm();
        if (1 !== i2) {
          if (this.isClosedPath(n5) && t3 === this.getPathStart(n5)) {
            o = this.getPathEnd(n5) - 1;
          }
          this.getSegmentBuffer(o, a2, true);
        }
        const h2 = new fm();
        1 !== r && this.getSegmentBuffer(t3, h2, true);
        const u = t3 + 1;
        this.setXYCoordsNoCurves(t3, e2, s3);
        const m3 = new mi(e2, s3);
        return 1 !== i2 && (a2.get().changeEndPoints2D(a2.get().getStartXY(), m3), this.replaceSegmentImpl(o, t3, a2.get(), true)), void (1 !== r && (h2.get().changeEndPoints2D(m3, h2.get().getEndXY()), this.replaceSegmentImpl(t3, u, h2.get(), true)));
      }
    }
    this.setXYCoordsNoCurves(t3, e2, s3);
  }
  setXYZWithCurves(t3, e2) {
    this.hasNonLinearSegments() ? (this.setXYCoordsWithCurves(t3, e2.x, e2.y), this.setAttributeNoCurves(1, t3, 0, e2.z)) : this.setXYZNoCurves(t3, e2);
  }
  setAttributeWithCurves(t3, e2, s3, n5) {
    if (0 === t3 && this.hasNonLinearSegments()) {
      const t4 = this.getXY(e2);
      0 === s3 ? t4.x = n5 : t4.y = n5, this.setXYCoordsWithCurves(e2, t4.x, t4.y);
    } else this.setAttributeNoCurves(t3, e2, s3, n5);
  }
  setXY(t3, e2) {
    this.setXYCoordsWithCurves(t3, e2.x, e2.y);
  }
  setXYCoords(t3, e2, s3) {
    this.setXYCoordsWithCurves(t3, e2, s3);
  }
  setXYZ(t3, e2) {
    this.setXYZWithCurves(t3, e2);
  }
  setAttribute(t3, e2, s3, n5) {
    this.setAttributeWithCurves(t3, e2, s3, n5);
  }
  setAttributeWithCurvesFromArray(t3, e2, s3, n5) {
    if (0 === t3 && this.hasNonLinearSegments()) {
      n5 < 2 && A("");
      const t4 = this.getXY(e2);
      t4.x = s3[0], t4.y = s3[1], this.setXYCoordsWithCurves(e2, t4.x, t4.y);
    } else this.setAttributeFromArrayNoCurves(t3, e2, s3, n5);
  }
  setAttributeFromArray(t3, e2, s3, n5) {
    this.setAttributeWithCurvesFromArray(t3, e2, s3, n5);
  }
  hasNonLinearSegments() {
    return 0 !== this.getCurveCount();
  }
  getSegmentCount() {
    let t3 = this.getPointCount();
    if (!this.m_bPolygon) {
      t3 -= this.getPathCount();
      for (let e2 = 0, s3 = this.getPathCount(); e2 < s3; e2++) this.isClosedPath(e2) && t3++;
    }
    return t3;
  }
  getSegmentCountPath(t3) {
    let e2 = this.getPathSize(t3);
    return !this.isClosedPath(t3) && e2 > 0 && e2--, e2;
  }
  add(e2, s3) {
    this === e2 && P("Multi_path_impl::add");
    for (let t3 = 0, n5 = e2.getPathCount(); t3 < n5; t3++) this.addPath(e2, t3, !s3);
  }
  addPath(t3, e2, s3) {
    this.insertPath(-1, t3, e2, s3);
  }
  addPathPoint2D(t3, e2, s3) {
    this.insertPath2D(-1, t3, 0, e2, s3);
  }
  addPathMultiPoint(t3, e2, s3, n5) {
    s3 < 0 && (s3 = t3.getPointCount() - e2), this.insertPointsFromMultipoint(-1, 0, t3, e2, s3, n5);
  }
  addSegmentsFromPath(e2, s3, n5, r, o) {
    if (this === e2 && P("Multi_path_impl.add_segments_from_path"), o || 0 !== this.getPathCount() || (o = true), s3 < 0 && (s3 = e2.getPathCount() - 1), (s3 >= e2.getPathCount() || n5 < 0 || r < 0 || n5 + r > e2.getSegmentCountPath(s3)) && A("add_segments_from_path"), 0 === r) return;
    const a2 = e2.getPathStart(s3), h2 = e2.isClosedPath(s3) && n5 + r === e2.getSegmentCountPath(s3);
    this.m_bPathStarted = false, this.mergeVertexDescription(e2.getDescription());
    let u = r;
    const m3 = a2 + n5;
    let l2 = m3 + 1;
    o && (u++, l2--), !o && e2.hasNonLinearSegments() && 1 !== e2.m_curveData.m_segmentFlags.read(m3) && (e2.getXY(m3).equals(this.getXY(this.m_pointCount - 1)) || P("add_segments_from_path: start point mismatch"));
    const c = this.m_pointCount;
    if (this.resizeImpl(this.m_pointCount + u), this.verifyAllStreamsAfterSizeChange(), o) {
      if (0 === u) return;
      this.m_paths.add(this.m_pointCount);
      let t3 = e2.m_pathFlags.read(s3);
      this.m_bPolygon && (t3 |= 1), this.m_pathFlags.write(this.m_pathFlags.size() - 1, t3), this.m_pathFlags.add(0);
    } else this.m_paths.write(this.m_pathFlags.size() - 1, this.m_pointCount);
    const g2 = h2 ? u - 1 : u;
    for (let t3 = 0, i2 = this.m_description.getAttributeCount(); t3 < i2; t3++) {
      const s4 = this.m_description.getSemantics(t3), n6 = js2.getComponentCount(s4), i3 = e2.m_description.getAttributeIndex(s4);
      if (g2 > 0) {
        if (i3 < 0 || !e2.m_vertexAttributes.get(i3)) {
          const e3 = js2.getDefaultValue(s4);
          this.m_vertexAttributes.get(t3).insertRange(n6 * c, e3, g2 * n6, n6 * c), h2 && this.m_vertexAttributes.get(t3).insertRange(n6 * c + g2 * n6, e3, n6, n6 * c);
          continue;
        }
        this.m_vertexAttributes.get(t3).insertRangeFromStream(n6 * c, e2.m_vertexAttributes.get(i3), n6 * l2, g2 * n6, true, n6, n6 * c);
      }
      h2 && this.m_vertexAttributes.get(t3).insertRangeFromStream(n6 * (c + g2), e2.m_vertexAttributes.get(i3), n6 * a2, n6, true, n6, n6 * (c + g2));
    }
    if (this.hasNonLinearSegments() && this.initSegmentData(0), e2.hasNonLinearSegments()) {
      let t3 = 0;
      for (let s4 = 0, n6 = m3; s4 < r; s4++) {
        t3 += ks(e2.m_curveData.m_segmentFlags.read(n6)), n6++;
      }
      if (t3 > 0) {
        this.initSegmentData(t3);
        let s4 = m3, n6 = c - (o ? 0 : 1), i2 = 0;
        for (let t4 = 0; t4 < r; t4++) {
          const t5 = e2.m_curveData.m_segmentFlags.read(s4);
          if (this.m_curveData.m_segmentFlags.write(n6, t5), _Hs.isNonLinearSegmentFlag(t5)) {
            i2++;
            let r2 = e2.m_curveData.m_segmentParamIndex.read(s4);
            const o2 = ks(t5);
            this.m_curveData.m_segmentParamIndex.write(n6, this.m_curveData.m_curveParamWritePoint);
            for (let t6 = 0; t6 < o2; t6++) {
              const t7 = e2.m_curveData.m_segmentParams.read(r2);
              this.m_curveData.m_segmentParams.write(this.m_curveData.m_curveParamWritePoint, t7), this.m_curveData.m_curveParamWritePoint++, r2++;
            }
            this.incCurveType(t5, 1);
          } else this.m_curveData.m_segmentParamIndex.write(n6, -1);
          n6++, s4++;
        }
        this.modifyCurveCounter(i2);
      }
    }
    if (h2) {
      const t3 = this.getPathCount() - 1, e3 = this.getPathStart(t3), s4 = this.getPathEnd(t3) - 1, n6 = this.getXY(e3), i2 = this.getXY(s4);
      n6.isEqualPoint2D(i2) && (--this.m_pointCount, this.m_paths.write(t3 + 1, this.m_pointCount));
    }
    this.notifyModifiedFlags(2001);
  }
  reverseAllPaths() {
    for (let t3 = 0, e2 = this.getPathCount(); t3 < e2; t3++) this.reversePath(t3);
  }
  reversePath(e2) {
    e2 >= this.getPathCount() && P("");
    const s3 = this.getPathSize(e2);
    if (0 === s3) return;
    const n5 = this.getPathStart(e2), i2 = this.isClosedPath(e2);
    if (this.hasNonLinearSegments()) {
      let t3 = n5;
      const e3 = new this.m_segmentBufferCTor();
      let r2 = false;
      for (let n6 = 0; n6 < s3; n6++, t3++) {
        const s4 = this.m_curveData.m_segmentFlags.read(t3);
        if (!_Hs.isNonLinearSegmentFlag(s4)) continue;
        r2 = true, this.querySegment(t3, e3, true), e3.get().reverse();
        const n7 = this.m_curveData.m_segmentParamIndex.read(t3);
        e3.get().writeInBufferStream(this.m_curveData.m_segmentParams, n7);
      }
      if (r2) {
        const t4 = i2 ? 0 : 1;
        this.m_curveData.m_segmentFlags.reverseRange(n5, s3 - t4, 1), this.m_curveData.m_segmentParamIndex.reverseRange(n5, s3 - t4, 1);
      }
    }
    const r = i2 ? 1 : 0;
    for (let t3 = 0, a2 = this.m_description.getAttributeCount(); t3 < a2; t3++) if (this.m_vertexAttributes.get(t3)) {
      const e3 = this.m_description.getSemantics(t3), i3 = js2.getComponentCount(e3);
      this.m_vertexAttributes.get(t3).reverseRange(i3 * (n5 + r), i3 * (s3 - r), i3);
    }
    const o = 6 & this.m_pathFlags.read(e2);
    if (o) {
      let t3 = 0;
      4 & o && (t3 |= 2), 2 & o && (t3 |= 4), this.m_pathFlags.clearBits(e2, 6), this.m_pathFlags.setBits(e2, t3);
    }
    this.notifyModifiedFlags(1233);
  }
  removePath(e2) {
    const s3 = this.getPathCount();
    e2 < 0 && (e2 = s3 - 1), e2 >= s3 && P("");
    const n5 = this.getPathStart(e2), i2 = this.getPathSize(e2);
    for (let t3 = 0, r = this.m_description.getAttributeCount(); t3 < r; t3++) if (this.m_vertexAttributes.get(t3)) {
      const e3 = this.m_description.getSemantics(t3), s4 = js2.getComponentCount(e3);
      this.m_vertexAttributes.get(t3).eraseRange(s4 * n5, s4 * i2, s4 * this.m_pointCount);
    }
    if (this.hasNonLinearSegments()) {
      let t3 = 0;
      for (let e3 = n5, s4 = n5 + i2; e3 < s4; e3++) {
        const s5 = this.m_curveData.m_segmentFlags.read(e3);
        _Hs.isNonLinearSegmentFlag(s5) && (this.incCurveType(s5, -1), t3++);
      }
      this.modifyCurveCounter(-t3), this.m_curveData.m_segmentFlags.eraseRange(n5, i2, this.m_pointCount), this.m_curveData.m_segmentParamIndex.eraseRange(n5, i2, this.m_pointCount);
    }
    for (let t3 = e2 + 1; t3 <= s3; t3++) {
      const e3 = this.m_paths.read(t3);
      this.m_paths.write(t3 - 1, e3 - i2);
    }
    if (this.m_pathFlags) for (let t3 = e2 + 1; t3 <= s3; t3++) {
      const e3 = this.m_pathFlags.read(t3);
      this.m_pathFlags.write(t3 - 1, e3);
    }
    this.m_paths.resize(s3), this.m_pathFlags.resize(s3), this.m_pointCount -= i2, this.m_reservedPointCount -= i2, e2 === s3 - 1 && (this.m_bPathStarted = false), this.notifyModifiedFlags(2001), this.checkCompactSegmentParams(), this.dbgVerifyCurves();
  }
  dbgVerifyCurves() {
  }
  insertPath(e2, s3, n5, i2) {
    this === s3 && P("Multi_path_impl::insert_path");
    const r = this.getPathCount();
    if (!i2 && s3.hasNonLinearSegmentsPath(n5)) return e2 = this.insertPath(e2, s3, n5, true), this.reversePath(e2), e2;
    n5 >= s3.getPathCount() && P(""), e2 > r && P(""), e2 < 0 && (e2 = r), n5 < 0 && (n5 = s3.getPathCount() - 1), this.m_bPathStarted = false, this.mergeVertexDescription(s3.getDescription());
    const o = s3.getPathStart(n5), a2 = s3.getPathSize(n5);
    if (0 === a2) return this.insertPath2D(e2, null, 0, 0, true);
    const h2 = this.m_pointCount, u = s3.isClosedPath(n5) && !i2 ? 1 : 0;
    this.resizeImpl(this.m_pointCount + a2), this.verifyAllStreamsAfterSizeChange();
    const m3 = e2 < r ? this.getPathStart(e2) : h2;
    for (let t3 = 0, g2 = this.m_description.getAttributeCount(); t3 < g2; t3++) {
      const e3 = this.m_description.getSemantics(t3), n6 = s3.getDescription().getAttributeIndex(e3), r2 = js2.getComponentCount(e3);
      if (n6 >= 0 && s3.m_vertexAttributes.get(n6)) 0 !== u && this.m_vertexAttributes.get(t3).insertRangeFromStream(m3 * r2, s3.m_vertexAttributes.get(n6), r2 * o, r2, true, r2, r2 * h2), this.m_vertexAttributes.get(t3).insertRangeFromStream((m3 + u) * r2, s3.m_vertexAttributes.get(n6), r2 * (o + u), r2 * (a2 - u), i2, r2, r2 * (h2 + u));
      else {
        const s4 = js2.getDefaultValue(e3);
        this.m_vertexAttributes.get(t3).insertRange(m3 * r2, s4, r2 * a2, r2 * h2);
      }
    }
    const l2 = h2 + a2;
    this.m_paths.add(l2);
    for (let t3 = r; t3 >= e2 + 1; t3--) {
      const e3 = this.m_paths.read(t3 - 1);
      this.m_paths.write(t3, e3 + a2);
    }
    this.m_pathFlags.add(0);
    for (let t3 = r - 1; t3 >= e2 + 1; t3--) {
      let e3 = this.m_pathFlags.read(t3);
      e3 &= -9, this.m_pathFlags.write(t3 + 1, e3);
    }
    let c = s3.getPathFlagsStreamRef().read(n5);
    if (c &= -9, this.m_bPolygon && (c |= 1), this.m_pathFlags.write(e2, c), s3.hasNonLinearSegments()) {
      this.initSegmentData(0);
      let t3 = o, e3 = 0;
      for (let n6 = 0; n6 < a2; n6++) {
        e3 += ks(s3.m_curveData.m_segmentFlags.read(t3)), t3++;
      }
      if (e3 > 0) {
        null === this.m_curveData.m_segmentFlags ? (this.m_curveData.m_segmentFlags = K2(this.m_pointCount, 1), this.m_curveData.m_segmentParamIndex = J2(this.m_pointCount, -1)) : (this.m_curveData.m_segmentFlags.insertRange(m3, 1, a2, h2), this.m_curveData.m_segmentParamIndex.insertRange(m3, -1, a2, h2)), this.m_curveData.m_segmentParams ? this.m_curveData.m_segmentParams.resize(this.m_curveData.m_curveParamWritePoint + e3) : this.m_curveData.m_segmentParams = $2(e3), t3 = o;
        let n6 = m3, i3 = 0;
        for (let e4 = 0; e4 < a2; e4++) {
          const e5 = s3.m_curveData.m_segmentFlags.read(t3);
          if (_Hs.isNonLinearSegmentFlag(e5)) {
            this.m_curveData.m_segmentFlags.write(n6, e5), this.m_curveData.m_segmentParamIndex.write(n6, this.m_curveData.m_curveParamWritePoint);
            const r2 = ks(e5);
            let o2 = s3.m_curveData.m_segmentParamIndex.read(t3);
            for (let t4 = 0; t4 < r2; t4++) {
              const t5 = s3.m_curveData.m_segmentParams.read(o2);
              this.m_curveData.m_segmentParams.write(this.m_curveData.m_curveParamWritePoint, t5), this.m_curveData.m_curveParamWritePoint++, o2++;
            }
            i3++, this.incCurveType(e5, 1);
          }
          t3++, n6++;
        }
        this.modifyCurveCounter(i3);
      }
    }
    return this.notifyModifiedFlags(2001), e2;
  }
  insertPath2D(e2, s3, n5, i2, r) {
    const o = this.getPathCount();
    (e2 > o || n5 < 0) && P(""), e2 < 0 && (e2 = o), this.m_bPathStarted = false;
    const a2 = this.m_pointCount;
    this.resizeImpl(this.m_pointCount + i2), 0 === i2 && this.notifyModifiedFlags(32), this.verifyAllStreamsAfterSizeChange();
    const h2 = e2 < o ? this.getPathStart(e2) : a2;
    if (s3) this.m_vertexAttributes.get(0).insertRangeFromPoints(2 * h2, s3, n5, i2, r, 2 * a2);
    else {
      const t3 = js2.getDefaultValue(0);
      this.m_vertexAttributes.get(0).insertRange(2 * h2, t3, 2 * i2, 2 * a2);
    }
    for (let t3 = 1, u = this.m_description.getAttributeCount(); t3 < u; t3++) {
      const e3 = this.m_description.getSemantics(t3), s4 = js2.getComponentCount(e3), n6 = js2.getDefaultValue(e3);
      this.m_vertexAttributes.get(t3).insertRange(h2 * s4, n6, s4 * i2, s4 * a2);
    }
    this.m_paths.add(this.m_pointCount);
    for (let t3 = o; t3 >= e2 + 1; t3--) {
      const e3 = this.m_paths.read(t3 - 1);
      this.m_paths.write(t3, e3 + i2);
    }
    this.m_pathFlags.add(0);
    for (let t3 = o - 1; t3 >= e2 + 1; t3--) {
      let e3 = this.m_pathFlags.read(t3);
      e3 &= -9, this.m_pathFlags.write(t3 + 1, e3);
    }
    return this.m_bPolygon && this.m_pathFlags.write(e2, 1), this.hasNonLinearSegments() && (this.m_curveData.m_segmentFlags.insertRange(h2, 1, i2, a2), this.m_curveData.m_segmentParamIndex.insertRange(h2, -1, i2, a2)), this.notifyModifiedFlags(2001), e2;
  }
  insertPathFromMultipoint(e2, s3, n5, i2, r) {
    const o = s3.getImpl(), a2 = this.getPathCount();
    (e2 > a2 || n5 < 0) && P("");
    const h2 = i2 < 0 ? o.getPointCount() - n5 : i2;
    if (h2 > o.getPointCount() && P(""), n5 >= o.getPointCount() && P("pointsOffset"), e2 < 0 && (e2 = a2), this.m_bPathStarted = false, this.mergeVertexDescription(o.getDescription()), 0 === h2) return void this.insertPath2D(e2, null, 0, 0, true);
    const u = this.m_pointCount, m3 = n5;
    this.resizeImpl(this.m_pointCount + h2), this.verifyAllStreamsAfterSizeChange();
    const l2 = e2 < a2 ? this.getPathStart(e2) : u;
    for (let t3 = 0, d2 = this.m_description.getAttributeCount(); t3 < d2; t3++) {
      const e3 = this.m_description.getSemantics(t3), s4 = o.getDescription().getAttributeIndex(e3), n6 = js2.getComponentCount(e3);
      if (s4 >= 0) {
        const s5 = o.getAttributeStreamRef(e3);
        this.m_vertexAttributes.get(t3).insertRangeFromStream(l2 * n6, s5, n6 * m3, n6 * h2, r, n6, n6 * u);
      } else {
        const s5 = js2.getDefaultValue(e3);
        this.m_vertexAttributes.get(t3).insertRange(l2 * n6, s5, n6 * h2, n6 * u);
      }
    }
    const c = u + h2;
    this.m_paths.add(c);
    for (let t3 = a2; t3 >= e2 + 1; t3--) {
      const e3 = this.m_paths.read(t3 - 1);
      this.m_paths.write(t3, e3 + h2);
    }
    this.m_pathFlags.add(0);
    for (let t3 = a2 - 1; t3 >= e2 + 1; t3--) {
      let e3 = this.m_pathFlags.read(t3);
      e3 &= -9, this.m_pathFlags.write(t3 + 1, e3);
    }
    let g2 = 0;
    this.m_bPolygon && (g2 |= 1), this.m_pathFlags.write(e2, g2), this.notifyModifiedFlags(2001);
  }
  insertPoints(e2, s3, n5, r, o, a2, h2) {
    if (this === n5 && P("Multi_path_impl.insert_points"), e2 < 0 && (e2 = this.getPathCount()), r < 0 && (r = n5.getPathCount() - 1), (e2 > this.getPathCount() || s3 >= 0 && s3 > this.getPathSize(e2) || r >= n5.getPathCount() || a2 > n5.getPathSize(r)) && A(""), !a2) return;
    if (this.mergeVertexDescription(n5.m_description), e2 === this.getPathCount()) {
      this.m_paths.add(this.m_pointCount);
      let t3 = n5.m_pathFlags.read(r);
      t3 &= -9, this.m_bPolygon ? this.m_pathFlags.add(1 | t3) : this.m_pathFlags.add(t3);
    }
    s3 < 0 && (s3 = this.getPathSize(e2));
    const u = this.m_pointCount;
    this.resizeImpl(this.m_pointCount + a2), this.verifyAllStreamsAfterSizeChange();
    const m3 = this.getPathStart(e2), l2 = m3 + s3;
    a2 < 0 && (a2 = n5.getPathSize(r));
    const c = n5.getPathStart(r), g2 = c + a2;
    for (let t3 = 0, i2 = this.m_description.getAttributeCount(); t3 < i2; t3++) {
      const e3 = this.m_description.getSemantics(t3), i3 = js2.getComponentCount(e3), r2 = n5.m_description.getAttributeIndex(e3);
      if (r2 < 0 || !n5.m_vertexAttributes.get(r2)) {
        const s4 = js2.getDefaultValue(e3);
        this.m_vertexAttributes.get(t3).insertRange(i3 * l2, s4, g2 * i3, i3 * u);
        continue;
      }
      this.m_vertexAttributes.get(t3)?.insertRangeFromStream(i3 * (m3 + s3), n5.m_vertexAttributes.get(r2), i3 * (c + o), a2 * i3, h2, i3, i3 * u);
    }
    this.hasNonLinearSegments() && (this.m_curveData.m_segmentFlags.insertRange(m3 + s3, 1, a2, u), this.m_curveData.m_segmentParamIndex.insertRange(m3 + s3, -1, a2, u), s3 > 0 && this.isNonLinearSegment(m3 + s3 - 1) && (this.incCurveType(this.m_curveData.m_segmentFlags.read(m3 + s3 - 1), -1), this.m_curveData.m_segmentFlags.write(m3 + s3 - 1, 1), this.m_curveData.m_segmentParamIndex.write(m3 + s3 - 1, -1), this.modifyCurveCounter(-1)));
    for (let t3 = e2 + 1, i2 = this.getPathCount(); t3 <= i2; t3++) {
      const e3 = this.m_paths.read(t3);
      this.m_paths.write(t3, e3 + a2);
    }
    this.notifyModifiedFlags(2001);
  }
  insertPointsFromPoints(t3, e2, s3, n5, r, o) {
    if (t3 < 0 && (t3 = this.getPathCount()), (t3 > this.getPathCount() || e2 > this.getPathSize(t3) || n5 < 0) && A(""), !r) return;
    t3 === this.getPathCount() && (this.m_paths.add(this.m_pointCount), this.m_bPolygon ? this.m_pathFlags.add(1) : this.m_pathFlags.add(0)), e2 < 0 && (e2 = this.getPathSize(t3));
    const a2 = this.m_pointCount;
    this.resizeImpl(this.m_pointCount + r), this.verifyAllStreamsAfterSizeChange();
    const h2 = this.getPathStart(t3);
    this.m_vertexAttributes.get(0).insertRangeFromPoints(2 * (h2 + e2), s3, n5, r, o, 2 * a2);
    for (let i2 = 1, u = this.m_description.getAttributeCount(); i2 < u; i2++) {
      const t4 = this.m_description.getSemantics(i2), s4 = js2.getComponentCount(t4), n6 = js2.getDefaultValue(t4);
      this.m_vertexAttributes.get(i2).insertRange((h2 + e2) * s4, n6, s4 * r, s4 * a2);
    }
    this.hasNonLinearSegments() && (this.m_curveData.m_segmentFlags.insertRange(h2 + e2, 1, r, a2), this.m_curveData.m_segmentParamIndex.insertRange(h2 + e2, -1, r, a2), e2 > 0 && this.isNonLinearSegment(h2 + e2 - 1) && (this.incCurveType(this.m_curveData.m_segmentFlags.read(h2 + e2 - 1), -1), this.m_curveData.m_segmentFlags.write(h2 + e2 - 1, 1), this.m_curveData.m_segmentParamIndex.write(h2 + e2 - 1, -1), this.modifyCurveCounter(-1)));
    for (let i2 = t3 + 1, u = this.getPathCount(); i2 <= u; i2++) this.m_paths.write(i2, this.m_paths.read(i2) + r);
    this.notifyModifiedFlags(2001);
  }
  insertPointsFromMultipoint(t3, e2, s3, n5, r, o) {
    const a2 = s3.getImpl(), h2 = this.getPathCount();
    t3 < 0 && (t3 = this.getPathCount());
    const u = a2.getPointCount();
    if ((n5 < 0 || n5 > u) && A(""), (r < 0 || n5 + r > u) && (r = u - n5), e2 < 0 && (e2 = t3 < h2 ? this.getPathSize(t3) : 0), (t3 > h2 || t3 < h2 && e2 > this.getPathSize(t3) || t3 === h2 && e2 > 0 || r < 0) && A(""), !r) return;
    if (this.mergeVertexDescription(a2.getDescription()), t3 === h2) {
      this.m_paths.add(this.m_pointCount);
      const t4 = 0;
      this.m_bPolygon ? this.m_pathFlags.add(1 | t4) : this.m_pathFlags.add(t4);
    }
    e2 < 0 && (e2 = this.getPathSize(t3));
    const m3 = this.m_pointCount;
    this.resizeImpl(this.m_pointCount + r), this.verifyAllStreamsAfterSizeChange();
    const l2 = this.getPathStart(t3), c = l2 + e2, g2 = 0, d2 = g2 + r;
    for (let i2 = 0, _ = this.m_description.getAttributeCount(); i2 < _; i2++) {
      const t4 = this.m_description.getSemantics(i2), s4 = js2.getComponentCount(t4);
      if (a2.getDescription().getAttributeIndex(t4) < 0) {
        const e3 = js2.getDefaultValue(t4);
        this.m_vertexAttributes.get(i2).insertRange(s4 * c, e3, d2 * s4, s4 * m3);
        continue;
      }
      const h3 = a2.getAttributeStreamRef(t4);
      this.m_vertexAttributes.get(i2).insertRangeFromStream(s4 * (l2 + e2), h3, s4 * (g2 + n5), r * s4, o, s4, s4 * m3);
    }
    this.hasNonLinearSegments() && (this.m_curveData.m_segmentFlags.insertRange(l2 + e2, 1, r, m3), this.m_curveData.m_segmentParamIndex.insertRange(l2 + e2, -1, r, m3), e2 > 0 && this.isNonLinearSegment(l2 + e2 - 1) && (this.incCurveType(this.m_curveData.m_segmentFlags.read(l2 + e2 - 1), -1), this.m_curveData.m_segmentFlags.write(l2 + e2 - 1, 1), this.m_curveData.m_segmentParamIndex.write(l2 + e2 - 1, -1), this.modifyCurveCounter(-1)));
    for (let i2 = t3 + 1, _ = this.getPathCount(); i2 <= _; i2++) {
      const t4 = this.m_paths.read(i2);
      this.m_paths.write(i2, t4 + r);
    }
    this.notifyModifiedFlags(2001);
  }
  insertPoint2D(t3, e2, s3) {
    const n5 = this.getPathCount();
    t3 < 0 && (t3 = n5), (t3 > n5 || t3 < n5 && e2 > this.getPathSize(t3)) && A(""), t3 === n5 && this.addPathPoint2D(null, 0, true);
    const r = this.m_pointCount;
    this.resizeImpl(this.m_pointCount + 1), this.verifyAllStreamsAfterSizeChange();
    const o = this.getPathStart(t3), a2 = e2 < 0 ? this.getPathSize(t3) + o : e2 + o, h2 = this.m_vertexAttributes.get(0);
    if (a2 === r) this.m_paths.write(t3 + 1, r + 1), h2.writePoint2D(2 * a2, s3);
    else {
      h2.insert(2 * a2, s3, 2 * r);
      for (let t4 = 1, e3 = this.m_description.getAttributeCount(); t4 < e3; t4++) {
        const e4 = this.m_description.getSemantics(t4), s4 = js2.getComponentCount(e4), n6 = js2.getDefaultValue(e4);
        this.m_vertexAttributes.get(t4).insertRange(s4 * a2, n6, s4, s4 * r);
      }
      this.m_curveData && this.m_curveData.m_segmentFlags && (this.m_curveData.m_segmentFlags.insertRange(a2, 1, 1, r), this.m_curveData.m_segmentParamIndex.insertRange(a2, -1, 1, r));
      for (let e3 = t3 + 1, s4 = n5; e3 <= s4; e3++) this.m_paths.write(e3, this.m_paths.read(e3) + 1);
    }
    this.m_curveData && this.m_curveData.m_segmentFlags && a2 > o && this.isNonLinearSegment(a2 - 1) && (this.incCurveType(this.m_curveData.m_segmentFlags.read(a2 - 1), -1), this.modifyCurveCounter(-1), this.m_curveData.m_segmentFlags.write(a2 - 1, 1), this.m_curveData.m_segmentParamIndex.write(a2 - 1, -1)), this.notifyModifiedFlags(2001);
  }
  insertPoint(t3, e2, s3) {
    const n5 = this.getPathCount();
    t3 < 0 && (t3 = n5), (t3 > n5 || t3 < n5 && e2 > this.getPathSize(t3)) && A(""), t3 === n5 && this.addPathPoint2D(null, 0, true);
    const r = this.m_pointCount;
    this.resizeImpl(this.m_pointCount + 1), this.verifyAllStreamsAfterSizeChange();
    const o = this.getPathStart(t3), a2 = e2 < 0 ? this.getPathSize(t3) + o : e2 + o;
    if (a2 === r) this.m_paths.write(t3 + 1, r + 1), this.setPointByValNoCurves(a2, s3);
    else {
      const e3 = s3.getDescription();
      this.m_description !== e3 && this.mergeVertexDescription(e3);
      for (let t4 = 0, n6 = this.m_description.getAttributeCount(); t4 < n6; t4++) {
        const n7 = this.m_description.getSemantics(t4), i2 = js2.getComponentCount(n7);
        if (e3.hasAttribute(n7)) this.m_vertexAttributes.get(t4).insertAttributes(i2 * a2, s3, n7, i2 * r);
        else {
          const e4 = js2.getDefaultValue(n7);
          this.m_vertexAttributes.get(t4).insertRange(i2 * a2, e4, i2, i2 * r);
        }
      }
      this.m_curveData && this.m_curveData.m_segmentFlags && (this.m_curveData.m_segmentFlags.insertRange(a2, 1, 1, r), this.m_curveData.m_segmentParamIndex.insertRange(a2, -1, 1, r));
      for (let s4 = t3 + 1, i2 = n5; s4 <= i2; s4++) this.m_paths.write(s4, this.m_paths.read(s4) + 1);
    }
    this.m_curveData && this.m_curveData.m_segmentFlags && a2 > o && this.isNonLinearSegment(a2 - 1) && (this.incCurveType(this.m_curveData.m_segmentFlags.read(a2 - 1), -1), this.modifyCurveCounter(-1), this.m_curveData.m_segmentFlags.write(a2 - 1, 1), this.m_curveData.m_segmentParamIndex.write(a2 - 1, -1)), this.notifyModifiedFlags(2001);
  }
  removePointFromPath(t3, e2) {
    const s3 = this.getPathCount();
    t3 < 0 && (t3 = s3 - 1), (t3 >= s3 || e2 >= this.getPathSize(t3)) && A("Multi_path.remove_point");
    const n5 = this.getPathStart(t3), r = this.isClosedPath(t3);
    e2 < 0 && (e2 = this.getPathSize(t3) - 1), e2 < 0 && A("Multi_path.remove_point");
    const o = n5 + e2;
    for (let i2 = 0, a2 = this.m_description.getAttributeCount(); i2 < a2; i2++) if (this.m_vertexAttributes.get(i2)) {
      const t4 = this.m_description.getSemantics(i2), e3 = js2.getComponentCount(t4);
      this.m_vertexAttributes.get(i2).eraseRange(e3 * o, e3, e3 * this.m_pointCount);
    }
    if (this.m_curveData && this.m_curveData.m_segmentFlags) {
      this.checkCompactSegmentParams();
      let e3 = 0;
      if (o > n5 && this.isNonLinearSegment(o - 1)) e3 += 1, this.incCurveType(this.m_curveData.m_segmentFlags.read(o - 1), -1), this.m_curveData.m_segmentFlags.write(o - 1, 1), this.m_curveData.m_segmentParamIndex.write(o - 1, -1);
      else {
        const s4 = this.getPathEnd(t3);
        r && n5 + 1 < s4 && this.isNonLinearSegment(s4 - 1) && (this.incCurveType(this.m_curveData.m_segmentFlags.read(s4 - 1), -1), this.m_curveData.m_segmentFlags.write(s4 - 1, 1), this.m_curveData.m_segmentParamIndex.write(s4 - 1, -1), e3 += 1);
      }
      this.isNonLinearSegment(o) && (this.incCurveType(this.m_curveData.m_segmentFlags.read(o), -1), e3 += 1), e3 > 0 && this.modifyCurveCounter(-e3), this.m_curveData.m_segmentFlags.eraseRange(o, 1, this.m_pointCount), this.m_curveData.m_segmentParamIndex.eraseRange(o, 1, this.m_pointCount);
    }
    for (let i2 = s3; i2 >= t3 + 1; i2--) {
      const t4 = this.m_paths.read(i2);
      this.m_paths.write(i2, t4 - 1);
    }
    this.m_pointCount--, this.m_reservedPointCount--, this.notifyModifiedFlags(2001);
  }
  removePoint(t3) {
    let e2;
    e2 = t3 < 0 ? this.getPathCount() - 1 : this.getPathIndexFromPointIndex(t3), this.removePointFromPath(e2, t3 - this.getPathStart(e2));
  }
  getNextSegmentType(t3) {
    return this.hasNonLinearSegments() ? this.m_curveData.m_segmentFlags.read(t3) : 1;
  }
  getPrevSegmentTypeFromPath(t3, e2) {
    if (!this.hasNonLinearSegments()) return 1;
    const s3 = this.getPathStart(t3);
    if (e2 > s3) return this.m_curveData.m_segmentFlags.read(e2 - 1);
    if (e2 === s3) {
      if (this.isClosedPath(t3)) {
        const e3 = this.getPathEnd(t3);
        return this.m_curveData.m_segmentFlags.read(e3 - 1);
      }
      return 1;
    }
    b("");
  }
  getNumberOfCurves(t3) {
    if (!this.hasNonLinearSegments()) return 0;
    let e2 = 0;
    for (let s3 = this.getPathStart(t3), n5 = this.getPathEnd(t3); s3 < n5; s3++) _Hs.isNonLinearSegmentFlag(this.m_curveData.m_segmentFlags.read(s3)) && ++e2;
    return e2;
  }
  getPathCount() {
    return this.m_paths ? this.m_paths.size() - 1 : 0;
  }
  getPathSize(t3) {
    return this.m_paths.read(t3 + 1) - this.m_paths.read(t3);
  }
  getPathStart(t3) {
    return this.m_paths.read(t3);
  }
  getPathEnd(t3) {
    return this.m_paths.read(t3 + 1);
  }
  getPathIndexFromPointIndex(t3, e2 = -1) {
    -1 === e2 && (e2 = this.m_currentPathIndex);
    const s3 = this.getPathCount(), n5 = _Hs.getPathIndexFromPointIndexImpl(this.m_paths, s3, t3, e2);
    return this.m_currentPathIndex = n5, n5;
  }
  startPathCoords(t3, e2) {
    this.startPathPoint(new ee({ x: t3, y: e2 }));
  }
  startPath(t3) {
    this.startPathPoint(new ee({ pt: t3 }));
  }
  startPath3D(t3) {
    this.startPathPoint(new ee({ x: t3.x, y: t3.y, z: t3.z }));
  }
  startPath3DCoords(t3, e2, s3) {
    this.startPathPoint(new ee({ x: t3, y: e2, z: s3 }));
  }
  startPathPoint(e2) {
    e2.isEmpty() && P("");
    const s3 = e2.getDescription();
    let n5;
    if (this.m_description !== s3) {
      this.mergeVertexDescription(s3);
      const t3 = new ee({ vd: this.m_description });
      e2.copyCommonAttributesTo(t3), n5 = t3;
    } else n5 = e2;
    this.m_bPathStarted ? this.setPointByValNoCurves(this.m_pointCount - 1, n5) : (this.insertPoint(-1, -1, n5), this.m_bPathStarted = true);
  }
  beforeNewSegmentHelper2() {
    this.m_paths = J2(2), this.m_paths.write(0, 0), this.m_pathFlags = K2(2, 0), this.m_bPolygon && this.m_pathFlags.write(0, 1);
  }
  beforeNewSegmentHelper1() {
    null !== this.m_paths ? (this.m_paths.add(0), this.m_pathFlags.add(0), this.m_bPolygon && this.m_pathFlags.write(this.m_pathFlags.size() - 2, 1)) : this.beforeNewSegmentHelper2();
  }
  beforeNewSegment(t3) {
    0 !== this.m_pointCount || this.m_bPathStarted || this.startPathCoords(0, 0);
    const e2 = this.m_pointCount, s3 = this.m_paths.size() - 1, n5 = e2 + t3;
    this.m_paths.write(s3, n5), this.resizeImpl(n5), this.m_bPathStarted && (this.m_bPathStarted = false);
  }
  finishLineTo() {
    if (this.hasNonLinearSegments()) {
      const t3 = this.m_curveData.m_segmentFlags.read(this.m_pointCount - 1);
      1 !== t3 && (this.m_curveData.m_segmentFlags.write(this.m_pointCount - 1, 1), this.m_curveData.m_segmentParamIndex.write(this.m_pointCount - 1, -1), this.modifyCurveCounter(-1), this.incCurveType(t3, -1));
    }
  }
  lineToCoords(t3, e2) {
    if (this.beforeNewSegment(1), 1 === this.m_description.getAttributeCount()) this.setXYCoordsNoCurves(this.m_pointCount - 1, t3, e2);
    else {
      const s3 = B3(), n5 = new ee({ vd: this.m_description, attribBuffer: s3, initDefaultValues: true });
      n5.setXYCoords(t3, e2), this.setPointByValNoCurves(this.m_pointCount - 1, n5);
    }
    this.finishLineTo();
  }
  lineTo(t3) {
    this.lineToCoords(t3.x, t3.y);
  }
  lineTo3D(t3) {
    this.beforeNewSegment(1);
    const e2 = H2(this.m_description, O2()), s3 = B3(), n5 = new ee({ vd: e2, attribBuffer: s3, initDefaultValues: true });
    n5.setXYZ(t3), this.setPointByValNoCurves(this.m_pointCount - 1, n5), this.finishLineTo();
  }
  lineTo3DCoords(t3, e2, s3) {
    this.lineTo3D(new X(t3, e2, s3));
  }
  lineToPoint(t3) {
    if (this.beforeNewSegment(1), this.m_description === t3.getDescription()) this.setPointByValNoCurves(this.m_pointCount - 1, t3);
    else {
      this.mergeVertexDescription(t3.getDescription());
      const e2 = B3(), s3 = new ee({ vd: this.m_description, attribBuffer: e2, initDefaultValues: false });
      t3.copyCommonAttributesTo(s3), this.setPointByValNoCurves(this.m_pointCount - 1, s3);
    }
    this.finishLineTo();
  }
  openPathAndDuplicateStartVertex(e2) {
    this.m_bPolygon && b("");
    const s3 = this.getPathCount();
    if (e2 > s3 && P(""), !this.isClosedPath(e2)) return;
    this.m_pathFlags || b("");
    const n5 = this.m_pointCount, i2 = this.getPathStart(e2), o = this.getPathEnd(e2);
    if (o - i2 !== 0) {
      this.resizeImpl(this.m_pointCount + 1), this.verifyAllStreamsAfterSizeChange();
      for (let t3 = 0, e3 = this.m_description.getAttributeCount(); t3 < e3; t3++) if (this.m_vertexAttributes.get(t3)) {
        const e4 = this.m_description.getSemantics(t3), s4 = js2.getComponentCount(e4);
        this.m_vertexAttributes.get(t3).insertRangeFromStream(s4 * o, this.m_vertexAttributes.get(t3), s4 * i2, s4, true, 1, s4 * n5);
      }
      for (let t3 = s3; t3 > e2; t3--) {
        const e3 = this.m_paths.read(t3);
        this.m_paths.write(t3, e3 + 1);
      }
      this.hasNonLinearSegments() && (this.m_curveData.m_segmentFlags.insertRange(o, 1, 1, n5), this.m_curveData.m_segmentParamIndex.insertRange(o, -1, 1, n5)), this.m_pathFlags.clearBits(e2, 1);
    }
  }
  openPath(e2) {
    this.m_bPolygon && b(""), e2 > this.getPathCount() && P(""), this.m_pathFlags || b(""), this.m_pathFlags.clearBits(e2, 1);
  }
  isStrongPathStart(t3) {
    return !!(2 & this.m_pathFlags.read(t3));
  }
  setStrongPathStart(t3, e2) {
    e2 ? this.m_pathFlags.setBits(t3, 2) : this.m_pathFlags.clearBits(t3, 2);
  }
  isStrongPathEnd(t3) {
    return !!(4 & this.m_pathFlags.read(t3));
  }
  setStrongPathEnd(t3, e2) {
    e2 ? this.m_pathFlags.setBits(t3, 4) : this.m_pathFlags.clearBits(t3, 4);
  }
  clearStrongPathEnds() {
    for (let t3 = 0, e2 = this.getPathCount(); t3 < e2; ++t3) this.m_pathFlags.clearBits(t3, 6);
  }
  openAllPathsAndDuplicateStartVertex() {
    if (this.m_bPolygon && b(""), this.isEmpty()) return;
    this.m_pathFlags || b("");
    let t3 = 0;
    const e2 = this.getPathCount();
    for (let r = 0; r < e2; r++) this.isClosedPath(r) && (this.getPathSize(r) > 0 ? t3++ : this.m_pathFlags.clearBits(r, 1));
    if (0 === t3) return;
    const s3 = this.hasNonLinearSegments();
    let n5 = 0;
    const i2 = this.getPathCount(), o = this.m_description.getAttributeCount(), a2 = new Array(o);
    let h2 = null, u = null;
    for (let r = 0; r < i2; ++r) {
      const e3 = this.getPathStart(r), i3 = this.getPathSize(r), m3 = this.isClosedPath(r);
      if (i3 > 0) {
        const r2 = e3 + n5;
        for (let s4 = 0; s4 < o; s4++) if (this.m_vertexAttributes.get(s4)) {
          const n6 = this.m_description.getSemantics(s4), o2 = js2.getComponentCount(n6);
          if (!a2[s4]) {
            const e4 = o2 * (this.m_pointCount + t3), i4 = W(n6, e4);
            a2[s4] = i4;
          }
          a2[s4].writeRange(r2 * o2, i3 * o2, this.m_vertexAttributes.get(s4), e3 * o2, true, 1), m3 && a2[s4].writeRange((r2 + i3) * o2, o2, this.m_vertexAttributes.get(s4), e3 * o2, true, 1);
        }
        if (s3) {
          if (null === h2) {
            const e4 = this.m_pointCount + t3;
            h2 = K2(e4), u = J2(e4);
          }
          h2.writeRange(r2, i3, this.m_curveData.m_segmentFlags, e3, true, 1), u.writeRange(r2, i3, this.m_curveData.m_segmentParamIndex, e3, true, 1), m3 && (h2.write(r2 + i3, 1), u.write(r2 + i3, -1));
        }
      }
      this.m_paths.write(r, e3 + n5), m3 && (this.m_pathFlags.clearBits(r, 1), ++n5);
    }
    this.m_paths.write(i2, this.m_pointCount + t3), this.m_pathFlags.clearBits(i2, 1);
    for (let r = 0; r < o; r++) this.m_vertexAttributes.get(r) && this.m_vertexAttributes.set(r, a2[r]);
    s3 && (this.m_curveData.m_segmentFlags = h2, this.m_curveData.m_segmentParamIndex = u), this.m_pointCount += t3, this.m_reservedPointCount > 0 && (this.m_reservedPointCount = this.m_pointCount);
  }
  closePathWithLine(e2) {
    void 0 === e2 && (e2 = this.getPathCount() - 1), this.throwIfEmpty(), (e2 < 0 || e2 >= this.getPathCount()) && P("close_path_with_line"), e2 === this.getPathCount() - 1 && (this.m_bPathStarted = false);
    const s3 = this.m_pathFlags.read(e2);
    if (1 & s3 || this.m_pathFlags.write(e2, 1 | s3), this.m_curveData && this.m_curveData.m_segmentFlags) {
      const t3 = this.getPathEnd(e2) - 1, s4 = this.m_curveData.m_segmentFlags.read(t3);
      1 !== s4 && (this.m_curveData.m_segmentFlags.write(t3, 1), this.m_curveData.m_segmentParamIndex.write(t3, -1), this.incCurveType(s4, -1), this.modifyCurveCounter(-1));
    }
    this.notifyModifiedFlags(2001);
  }
  closeLastPathWithSegment(t3) {
    this.closePathWithSegment(this.getPathCount() - 1, t3);
  }
  closePathWithSegment(s3, n5) {
    if (this.throwIfEmpty(), (s3 < 0 || s3 >= this.getPathCount()) && P("close_path_with_line"), n5.getEndXY().equals(this.getXY(this.getPathStart(s3))) || P("close_path_with_segment: end point mismatch"), s3 === this.getPathCount() - 1) this.m_bPathStarted = false, this.addSegment(n5, false), --this.m_pointCount, this.m_paths.write(s3 + 1, this.m_pointCount);
    else {
      this.mergeVertexDescription(n5.getDescription());
      const i3 = n5.getStartXY(), r = this.getPathEnd(s3) - 1;
      i3.equals(this.getXY(r)) || P("close_path_with_segment: start point mismatch");
      const o = n5.getGeometryType();
      if (o === a.enumLine) return void this.closePathWithLine(s3);
      {
        const t3 = Bs2(n5);
        this.initSegmentData(t3);
        const e2 = Zs2.toSegType(o), s4 = this.m_curveData.m_segmentFlags.read(r);
        if (s4 !== e2) this.m_curveData.m_segmentParamIndex.write(r, this.m_curveData.m_curveParamWritePoint), n5.writeInBufferStream(this.m_curveData.m_segmentParams, this.m_curveData.m_curveParamWritePoint), this.m_curveData.m_curveParamWritePoint += t3, this.incCurveType(e2, 1), 1 !== s4 ? this.incCurveType(s4, -1) : this.modifyCurveCounter(1);
        else {
          const t4 = this.m_curveData.m_segmentParamIndex.read(r);
          n5.writeInBufferStream(this.m_curveData.m_segmentParams, t4);
        }
        this.m_curveData.m_segmentFlags.write(r, e2);
      }
    }
    const i2 = this.m_pathFlags.read(s3);
    1 & i2 || this.m_pathFlags.write(s3, 1 | i2), this.notifyModifiedFlags(2001);
  }
  closeAllPaths() {
    if (this.m_bPolygon || this.isEmptyImpl()) return;
    this.m_bPathStarted = false;
    let t3 = false;
    for (let e2 = 0, s3 = this.m_paths.size() - 1; e2 < s3; e2++) {
      if (this.isClosedPath(e2)) continue;
      const s4 = this.m_pathFlags.read(e2);
      this.m_pathFlags.write(e2, 1 | s4), t3 = true;
    }
    t3 && this.notifyModifiedFlags(512);
  }
  isClosedPath(t3) {
    return !!(1 & this.m_pathFlags.read(t3));
  }
  isClosedPathInXYPlane(t3) {
    if (this.isClosedPath(t3)) return true;
    const e2 = this.getPathStart(t3), s3 = this.getPathEnd(t3) - 1;
    if (e2 > s3) return false;
    const n5 = this.getXY(e2), i2 = this.getXY(s3);
    return n5.isEqualPoint2D(i2);
  }
  isClosedPathIn3D(t3) {
    return n(0), false;
  }
  hasNonLinearSegmentsPath(t3) {
    if (!this.hasNonLinearSegments()) return false;
    for (let e2 = this.getPathStart(t3), s3 = this.getPathEnd(t3); e2 < s3; e2++) if (_Hs.isNonLinearSegmentFlag(this.m_curveData.m_segmentFlags.read(e2))) return true;
    return false;
  }
  isNonLinearSegment(t3) {
    return !(1 & this.getSegmentFlags(t3));
  }
  addEnvelope(t3, e2) {
    if (t3.isEmpty()) return;
    const s3 = 0 === this.m_pointCount;
    if (t3 instanceof n3) this.startPathCoords(t3.xmin, t3.ymin), e2 ? (this.lineToCoords(t3.xmax, t3.ymin), this.lineToCoords(t3.xmax, t3.ymax), this.lineToCoords(t3.xmin, t3.ymax)) : (this.lineToCoords(t3.xmin, t3.ymax), this.lineToCoords(t3.xmax, t3.ymax), this.lineToCoords(t3.xmax, t3.ymin));
    else {
      const s4 = t3.getDescription(), n5 = B3(), i2 = new ee({ vd: s4, attribBuffer: n5, initDefaultValues: false });
      for (let r = 0, o = 4; r < o; r++) {
        const s5 = e2 ? o - r - 1 : r;
        t3.queryCornerByVal(s5, i2), 0 === r ? this.startPathPoint(i2) : this.lineToPoint(i2);
      }
    }
    this.closePathWithLine(), this.m_bPathStarted = false, s3 && !e2 && (this.setDirtyFlagProtected(256, false), this.m_bPolygon && Math.min(t3.width(), t3.height()) > 0 && this.setIsSimple(3, 0));
  }
  addPathFromClosedSegment(e2, s3) {
    if (e2.isClosed() || P("add_path_from_closedSegment: segment must be closed"), s3) {
      const t3 = e2.getReversed(), s4 = new ee();
      t3.queryStart(s4), this.startPathPoint(s4), this.closeLastPathWithSegment(t3);
    } else {
      const t3 = new ee();
      e2.queryStart(t3), this.startPathPoint(t3), this.closeLastPathWithSegment(e2);
    }
  }
  addSegment_(s3, n5) {
    const i2 = s3.getDescription();
    this.mergeVertexDescription(i2);
    const r = B3(), o = new ee({ vd: i2, attribBuffer: r, initDefaultValues: false }), a2 = s3.getGeometryType();
    if (a2 === a.enumLine) (n5 || this.isEmptyImpl()) && (s3.queryStart(o), this.startPathPoint(o)), s3.queryEnd(o), this.lineToPoint(o);
    else {
      let e2 = false;
      if ((n5 || this.isEmptyImpl()) && (e2 = true), !e2) {
        s3.getStartXY().equals(this.getXY(this.m_pointCount - 1)) || P("add_segment: start point mismatch");
      }
      if (e2 && (s3.queryStart(o), this.startPathPoint(o)), this.beforeNewSegment(1), s3.queryEnd(o), o.getDescription() === this.m_description) this.setPointByVal(this.m_pointCount - 1, o);
      else {
        const t3 = B3(), e3 = new ee({ vd: this.m_description, attribBuffer: t3, initDefaultValues: false });
        o.copyCommonAttributesTo(e3), this.setPointByVal(this.m_pointCount - 1, e3);
      }
      const i3 = Bs2(s3);
      this.initSegmentData(i3), this.m_curveData.m_segmentParamIndex.write(this.m_pointCount - 2, this.m_curveData.m_curveParamWritePoint), s3.writeInBufferStream(this.m_curveData.m_segmentParams, this.m_curveData.m_curveParamWritePoint), this.m_curveData.m_curveParamWritePoint += i3;
      const r2 = Zs2.toSegType(a2);
      this.incCurveType(r2, 1), this.modifyCurveCounter(1), this.m_curveData.m_segmentFlags.write(this.m_pointCount - 2, r2);
    }
  }
  addSegment(t3, e2, s3) {
    s3 ? e2 ? this.addPathFromClosedSegment(t3, false) : this.closeLastPathWithSegment(t3) : this.addSegment_(t3, e2);
  }
  interpolateAttributesRange(e2, s3, n5, i2) {
    for (let a2 = e2; a2 < n5 - 1; a2++) this.isClosedPath(a2) && P("cannot interpolate across closed paths");
    const r = this.m_description.getAttributeCount();
    if (1 === r) return;
    const o = this.calculateSubLength2D(e2, s3, n5, i2);
    if (0 !== o) for (let t3 = 1; t3 < r; t3++) {
      const r2 = this.m_description.getSemantics(t3);
      this.interpolateAttributesSemanticsImpl(r2, e2, s3, n5, i2, o);
    }
  }
  interpolateAttributesSemantics(e2, s3, n5, i2, r) {
    if (0 === e2) return;
    this.hasAttribute(e2) || P("does not have the given attribute");
    2 === js2.getInterpolation(e2) && P("angular interpolation");
    for (let a2 = s3; a2 < i2 - 1; a2++) this.isClosedPath(a2) && P("cannot interpolate across closed paths");
    const o = this.calculateSubLength2D(s3, n5, i2, r);
    0 !== o && this.interpolateAttributesSemanticsImpl(e2, s3, n5, i2, r, o);
  }
  interpolateAttributesPath(t3, e2, s3) {
    const n5 = this.m_description.getAttributeCount();
    if (1 === n5) return;
    if (e2 === s3) return;
    const i2 = this.calculatePathSubLength2D(t3, e2, s3);
    for (let r = 1; r < n5; r++) {
      const n6 = this.m_description.getSemantics(r);
      this.interpolateAttributesSemanticsPathImpl(n6, t3, e2, s3, i2);
    }
  }
  interpolateAttributesSemanticsPath(e2, s3, n5, i2) {
    if (0 === e2) return;
    this.hasAttribute(e2) || P("does not have the given attribute");
    2 === js2.getInterpolation(e2) && P("angular interpolation");
    const r = this.calculatePathSubLength2D(s3, n5, i2);
    0 !== r && this.interpolateAttributesSemanticsPathImpl(e2, s3, n5, i2, r);
  }
  interpolateAttributesSemanticsImpl(t3, e2, s3, n5, i2, r) {
    const o = this.querySegmentIterator(), a2 = this.getPathStart(e2) + s3, h2 = this.getPathStart(n5) + i2, u = js2.getComponentCount(t3), m3 = Yt(js2.maxComponentCount(), Number.NaN);
    this.queryAttributeAsDbl(t3, a2, m3, u);
    const l2 = Yt(js2.maxComponentCount(), Number.NaN);
    this.queryAttributeAsDbl(t3, h2, l2, u);
    const c = Yt(js2.maxComponentCount(), Number.NaN);
    Dt(c, m3, 0, 0, u);
    let g2 = 0;
    const d2 = js2.getDefaultValue(t3), _ = js2.getInterpolation(t3);
    o.resetToVertex(a2, e2);
    do {
      if (o.hasNextSegment()) {
        if (o.nextSegment(), o.getStartPointIndex() === h2) return;
        this.setAttributeFromArray(t3, o.getStartPointIndex(), c, u), o.previousSegment();
        do {
          const e3 = o.nextSegment();
          if (o.getEndPointIndex() === h2) return;
          g2 += e3.calculateLength2D();
          wt(_, m3, l2, c, 0, u, g2 / r, d2), o.isClosingSegment() || this.setAttributeFromArray(t3, o.getEndPointIndex(), c, u);
        } while (o.hasNextSegment());
      }
    } while (o.nextPath());
  }
  interpolateAttributesSemanticsPathImpl(t3, e2, s3, i2, r) {
    n(0 !== t3);
    const o = this.querySegmentIterator(), a2 = js2.getInterpolation(t3), h2 = this.getPathStart(e2) + s3, u = this.getPathStart(e2) + i2;
    if (u === h2) return;
    const m3 = js2.getComponentCount(t3), l2 = Yt(js2.maxComponentCount(), Number.NaN);
    this.queryAttributeAsDbl(t3, h2, l2, m3);
    const c = Yt(js2.maxComponentCount(), Number.NaN);
    this.queryAttributeAsDbl(t3, u, c, m3);
    const g2 = new n2(0);
    o.resetToVertex(h2, e2), o.setCirculator(this.isClosedPath(e2));
    const d2 = js2.getDefaultValue(t3), _ = Yt(js2.maxComponentCount(), Number.NaN);
    Dt(_, l2, 0, 0, m3);
    const p3 = 0 === r;
    let f3 = 0.5;
    do {
      const e3 = o.nextSegment();
      if (this.setAttributeFromArrayNoCurves(t3, o.getStartPointIndex(), _, m3), !p3) {
        const t4 = e3.calculateLength2D();
        g2.pe(t4), f3 = g2.getResult() / r;
      }
      wt(a2, l2, c, _, 0, m3, f3, d2);
    } while (o.getEndPointIndex() !== u);
  }
  querySegment(e2, s3, n5) {
    const i2 = this.getPathIndexFromPointIndex(e2), r = e2 - this.getPathStart(i2);
    r >= this.getSegmentCountPath(i2) && P("get_segment"), this.getSegmentFromPath(i2, r, s3, n5);
  }
  getSegment(t3, e2) {
    const s3 = new this.m_segmentBufferCTor();
    return this.getSegmentBuffer(t3, s3, e2), s3.releaseSegment();
  }
  getSegmentType(e2) {
    const s3 = this.getPathIndexFromPointIndex(e2), n5 = e2 - this.getPathStart(s3);
    return n5 >= this.getSegmentCountPath(s3) && P("get_segment"), this.getSegmentTypeFromPath(s3, n5);
  }
  getSegmentFromPath(t3, e2, s3, n5) {
    const i2 = this.getPathStart(t3) + e2, o = this.getSegmentFlagsStreamRef();
    let a2 = 1;
    switch (o && (a2 = 31 & o.read(i2)), a2) {
      case 1:
        s3.createLine();
        break;
      case 2:
        s3.createCubicBezier();
        break;
      case 4:
        s3.createEllipticArc();
        break;
      case 8:
        s3.createQuadraticRationalBezier();
        break;
      case 16:
        s3.createQuadraticBezier();
        break;
      default:
        b("");
    }
    const h2 = s3.get();
    let u, m3 = null;
    n5 ? (m3 = M(), h2.assignVertexDescription(m3)) : h2.assignVertexDescription(this.m_description), u = i2 === this.getPathEnd(t3) - 1 && this.isClosedPath(t3) ? this.getPathStart(t3) : i2 + 1;
    Xe(h2, this.getXY(i2));
    if (Fe(h2, this.getXY(u)), !n5) for (let r = 1, l2 = this.m_description.getAttributeCount(); r < l2; r++) {
      const t4 = this.m_description.getSemantics(r), e3 = js2.getComponentCount(t4);
      for (let s4 = 0; s4 < e3; s4++) {
        const e4 = this.getAttributeAsDbl(t4, i2, s4);
        h2.setStartAttribute(t4, s4, e4);
        const n6 = this.getAttributeAsDbl(t4, u, s4);
        h2.setEndAttribute(t4, s4, n6);
      }
    }
    if (_Hs.isNonLinearSegmentFlag(a2)) {
      const t4 = this.m_curveData.m_segmentParamIndex.read(i2);
      h2.readFromBufferStream(this.m_curveData.m_segmentParams, t4);
    }
  }
  replaceLinearEllipticalArcsWithTrueLines() {
    if (!this.hasNonLinearSegments()) return false;
    if (0 === this.m_curveData.m_arcCount) return false;
    let t3 = false;
    for (let e2 = 0, s3 = this.getPointCount(); e2 < s3; e2++) {
      if (4 === this.m_curveData.m_segmentFlags.read(e2)) {
        const s4 = this.m_curveData.m_segmentParamIndex.read(e2);
        zs2(this.m_curveData.m_segmentParams, s4).isNAN() && (this.m_curveData.m_segmentFlags.write(e2, 1), this.m_curveData.m_segmentParamIndex.write(e2, -1), this.incCurveType(4, -1), this.modifyCurveCounter(-1), t3 = true);
      }
    }
    return t3 && this.checkCompactSegmentParams(), t3;
  }
  queryPointAlongPath(e2, s3, n5, i2 = false) {
    const r = { iSegment: -1 }, o = i2 ? r : { tSegment: 0 };
    if (n5.setEmpty(), this.isEmpty()) return r;
    if ((e2 < 0 || e2 >= this.getPathCount()) && P("query_point_along_path"), s3 < 0) return r;
    const a2 = this.getPathSize(e2);
    if (0 === a2) return r;
    if (1 === a2) return this.getPointByVal(this.getPathStart(e2), n5), o.tSegment = 0, r.iSegment = this.getPathStart(e2), r;
    const h2 = this.querySegmentIteratorAtVertex(this.getPathStart(e2)), u = new n2(0);
    for (; h2.hasNextSegment(); ) {
      const t3 = h2.nextSegment(), e3 = t3.calculateLength2D(), i3 = u.getResult();
      if (u.add(e3), u.getResult() >= s3) {
        let a3 = s3 - i3;
        a3 > e3 && (a3 = e3);
        const u2 = t3.lengthToT(a3);
        return t3.queryCoord(u2, n5), o.tSegment = u2, r.iSegment = h2.getStartPointIndex(), r;
      }
    }
    if (this.isClosedPath(e2)) {
      const t3 = this.getPathStart(e2);
      return this.getPointByVal(t3, n5), o.tSegment = 1, r.iSegment = this.getPathEnd(e2) - 1, r;
    }
    {
      const t3 = this.getPathEnd(e2) - 1;
      return this.getPointByVal(t3, n5), this.getPathSize(e2) > 1 ? (o.tSegment = 1, r.iSegment = this.getPathEnd(e2) - 2, r) : (o.tSegment = 0, r.iSegment = this.getPathStart(e2), r);
    }
  }
  queryPointsAlongPath(e2, s3, n5, i2, r, o) {
    {
      let e3 = 0;
      for (let a3 = 0; a3 < s3; ++a3) i2 && i2[a3].setEmpty(), r && (r[a3] = -1), o && (o[a3] = 0), e3 > n5[a3] && P("query_points_along"), e3 = n5[a3];
    }
    const a2 = this.getPathSize(e2);
    if (0 === s3 || 0 === a2) return 0;
    if (1 === a2) {
      const t3 = this.getPathStart(e2);
      return i2 && this.getPointByVal(t3, i2[0]), o && (o[0] = 0), r && (r[0] = t3), 1;
    }
    const h2 = this.getPathStart(e2), u = new n2(0), m3 = this.querySegmentIteratorAtVertex(h2);
    let l2 = 0, c = 0, g2 = n5[l2];
    for (; m3.hasNextSegment(); ) {
      const t3 = m3.nextSegment(), e3 = t3.calculateLength2D(), a3 = u.getResult();
      for (u.add(e3); u.getResult() >= g2; ) {
        let h3 = g2 - a3;
        h3 > e3 && (h3 = e3);
        const u2 = t3.lengthToT(h3);
        if (i2 && t3.queryCoord(u2, i2[c]), o && (o[c] = u2), r && (r[c] = m3.getStartPointIndex()), c++, l2++, g2 = n5[l2], l2 === s3) return c;
      }
    }
    if (this.isClosedPath(e2)) {
      const t3 = this.getPathStart(e2), s4 = 0;
      i2 && this.getPointByVal(t3, i2[c]), o && (o[c] = s4), r && (r[c] = t3), c++;
    } else if (this.getPathSize(e2) > 1) {
      const t3 = this.getPathEnd(e2) - 2, s4 = 1;
      i2 && this.getPointByVal(t3 + 1, i2[c]), o && (o[c] = s4), r && (r[c] = t3), c++;
    }
    return c;
  }
  queryPointsAlong(e2, s3, n5, i2, r) {
    {
      let o2 = 0;
      for (let a3 = 0; a3 < e2; ++a3) n5 && n5[a3].setEmpty(), i2 && (i2[a3] = -1), r && (r[a3] = 0), o2 > s3[a3] && P("query_points_along"), o2 = s3[a3];
    }
    if (0 === e2) return 0;
    const o = new n2(0), a2 = this.querySegmentIterator();
    let h2 = -1, u = 0, m3 = 0, l2 = s3[u];
    for (; a2.nextPath(); ) for (; a2.hasNextSegment(); ) {
      h2 = a2.getPathIndex();
      const t3 = a2.nextSegment(), c = t3.calculateLength2D(), g2 = o.getResult();
      for (o.add(c); o.getResult() >= l2; ) {
        let o2 = l2 - g2;
        o2 > c && (o2 = c);
        const h3 = t3.lengthToT(o2);
        if (n5 && t3.queryCoord(h3, n5[m3]), r && (r[m3] = h3), i2 && (i2[m3] = a2.getStartPointIndex()), m3++, u++, l2 = s3[u], u === e2) return m3;
      }
    }
    if (h2 < 0) return 0;
    if (this.isClosedPath(h2)) {
      const t3 = this.getPathStart(h2), e3 = 0;
      n5 && this.getPointByVal(t3, n5[m3]), r && (r[m3] = e3), i2 && (i2[m3] = t3), m3++;
    } else if (this.getPathSize(h2) > 1) {
      const t3 = this.getPathEnd(h2) - 2, e3 = 1;
      n5 && this.getPointByVal(t3 + 1, n5[m3]), r && (r[m3] = e3), i2 && (i2[m3] = t3), m3++;
    }
    return m3;
  }
  querySegmentIterator() {
    return new Fs({ parent: this });
  }
  querySegmentIteratorAtVertex(t3) {
    return new Fs({ parent: this, pointIndex: t3 });
  }
  queryPathEnvelope(t3, e2) {
    this.queryPathEnvelopeImpl(t3, e2, true);
  }
  queryLoosePathEnvelope(t3, e2) {
    this.queryPathEnvelopeImpl(t3, e2, false);
  }
  queryPathEnvelopeImpl(e2, s3, i2) {
    if (s3 instanceof re && n(0, "not implemented for Envelope"), s3 instanceof G3 && n(0, "not implemented for Envelope3D"), (e2 >= this.getPathCount() || e2 < 0) && P(""), this.isEmpty()) return void s3.setEmpty();
    const r = this.getAttributeStreamRef(0), o = n3.constructEmpty();
    o.setEmpty();
    for (let t3 = 2 * this.getPathStart(e2), a2 = 2 * this.getPathEnd(e2); t3 < a2; ) {
      const e3 = a2 - t3;
      n(!(1 & e3)), o.mergePointsInterleaved(r, t3 / 2, e3 / 2), t3 += e3;
    }
    if (s3.setCoords({ env2D: o }), this.hasNonLinearSegmentsPath(e2)) {
      const t3 = this.querySegmentIterator();
      if (t3.resetToPath(e2), t3.nextPath()) for (; t3.hasNextSegment(); ) {
        const e3 = t3.nextCurve();
        if (!e3) break;
        {
          const t4 = n3.constructEmpty();
          i2 ? e3.queryEnvelope(t4) : e3.queryLooseEnvelope(t4), s3.mergeEnvelope2D(t4);
        }
      }
      else n(0);
    }
  }
  checkCompactSegmentParams() {
    if (!this.m_curveData || null === this.m_curveData.m_segmentParams) return false;
    if (this.m_curveData.m_segmentParams.size() <= this.m_vertexAttributes.get(0).size()) return false;
    const t3 = 10, e2 = ks(4) * this.m_curveData.m_arcCount + ks(2) * this.m_curveData.m_bezierCount + ks(8) * this.m_curveData.m_rbezier2Count + ks(16) * this.m_curveData.m_bezier2Count;
    return this.m_curveData.m_segmentParams.size() > Math.max(3 * e2 >> 1, t3) ? (this.forceCompactSegmentParams(), true) : (0 === this.m_pointCount && (this.m_curveData.m_curveParamWritePoint = 0), false);
  }
  forceCompactSegmentParams() {
    let t3 = 0;
    for (let n5 = 0, i2 = this.getPointCount(); n5 < i2; n5++) {
      const e3 = this.m_curveData.m_segmentFlags.read(n5);
      if (_Hs.isNonLinearSegmentFlag(e3)) {
        t3 += ks(e3);
      }
    }
    const e2 = $2(t3);
    let s3 = 0;
    for (let n5 = 0, i2 = this.getPointCount(); n5 < i2; n5++) {
      const t4 = this.m_curveData.m_segmentFlags.read(n5);
      if (_Hs.isNonLinearSegmentFlag(t4)) {
        let i3 = this.m_curveData.m_segmentParamIndex.read(n5);
        this.m_curveData.m_segmentParamIndex.write(n5, s3);
        const r = ks(t4);
        for (let t5 = 0; t5 < r; t5++) e2.write(s3, this.m_curveData.m_segmentParams.read(i3)), s3++, i3++;
      }
    }
    this.m_curveData.m_segmentParams = e2, this.m_curveData.m_curveParamWritePoint = s3;
  }
  setEmpty() {
    this.m_curveData && (this.removeAllCurvesFromGlobalCounter(), this.m_curveData = null), this.m_bPathStarted = false, this.m_paths = null, this.m_pathFlags = null, this.setEmptyImpl();
  }
  applyTransformation(t3) {
    this.applyTransformationToPath(t3, -1);
  }
  applyTransformation3D(t3) {
    n(0);
  }
  getImpl() {
    return this;
  }
  reserve(t3) {
    this.reserveImpl(t3), t3 > 0 && !this.m_paths && (this.m_paths = J2(0), this.m_pathFlags = K2(0), this.m_paths.reserve(2), this.m_pathFlags.reserve(2), this.m_paths.resize(1, 0), this.m_pathFlags.resize(1, this.m_bPolygon ? 1 : 0));
  }
  reserveParts(t3, e2) {
    this.reserveImpl(t3), e2 > 0 && (this.m_paths ? (this.m_paths.reserve(e2 + 1), this.m_pathFlags.reserve(e2 + 1)) : (this.m_paths = J2(0), this.m_pathFlags = K2(0), this.m_paths.reserve(e2 + 1), this.m_pathFlags.reserve(e2 + 1), this.m_paths.resize(1, 0), this.m_pathFlags.resize(1, this.m_bPolygon ? 1 : 0)));
  }
  clone() {
    const t3 = this.createInstance();
    return this.copyTo(t3), t3;
  }
  queryLimitedSegmentIterator(t3) {
    return new Us2(this, t3);
  }
  getPathStreamRef() {
    return this.throwIfEmpty(), this.m_paths;
  }
  setPathStreamRef(t3) {
    this.m_paths = t3;
  }
  getSegmentFlagsStreamRef() {
    return this.throwIfEmpty(), null != this.m_curveData ? this.m_curveData.m_segmentFlags : null;
  }
  getPathFlagsStreamRef() {
    return this.throwIfEmpty(), this.m_pathFlags;
  }
  setPathFlagsStreamRef(t3) {
    this.m_pathFlags = t3;
  }
  getSegmentIndexStreamRef() {
    return this.throwIfEmpty(), null !== this.m_curveData ? this.m_curveData.m_segmentParamIndex : null;
  }
  getSegmentDataStreamRef() {
    return this.throwIfEmpty(), null !== this.m_curveData ? this.m_curveData.m_segmentParams : null;
  }
  setSegmentData(t3, e2, s3, n5) {
    this.m_curveData || (this.m_curveData = new Zs2()), this.m_curveData.m_segmentFlags = s3, this.m_curveData.m_segmentParams = e2, this.m_curveData.m_segmentParamIndex = t3, this.m_curveData.m_curveParamWritePoint = n5;
  }
  static getPathIndexFromPointIndexImpl(t3, e2, s3, n5) {
    if (n5 >= 0 && n5 < e2) {
      if (s3 >= t3.read(n5)) {
        if (s3 < t3.read(n5 + 1)) return n5;
        n5++;
      } else n5--;
      if (n5 >= 0 && n5 < e2 && s3 >= t3.read(n5) && s3 < t3.read(n5 + 1)) return n5;
    }
    if (e2 < 5) {
      for (let n6 = 0; n6 < e2; n6++) if (s3 < t3.read(n6 + 1)) return n6;
      v("");
    }
    let i2 = 0, r = e2 - 1;
    for (; r > i2; ) {
      const e3 = i2 + (r - i2 >> 1);
      if (s3 < t3.read(e3)) r = e3 - 1;
      else {
        if (!(s3 >= t3.read(e3 + 1))) return e3;
        i2 = e3 + 1;
      }
    }
    return i2;
  }
  getHighestPointIndex(t3) {
    n(t3 >= 0 && t3 < this.getPathCount());
    const e2 = this.getAttributeStreamRef(0), s3 = this.getPathEnd(t3), i2 = this.getPathStart(t3);
    let r = -1;
    const o = new mi();
    o.y = Number.NEGATIVE_INFINITY, o.x = Number.NEGATIVE_INFINITY;
    for (let n5 = i2 + 0; n5 < s3; n5++) {
      const t4 = e2.readPoint2D(2 * n5);
      -1 === o.compare(t4) && (r = n5, o.setCoordsPoint2D(t4));
    }
    return r;
  }
  applyTransformationToPath(e2, s3) {
    if (s3 >= this.getPathCount() && P("apply_transformation"), this.isEmpty()) return;
    if (e2.isIdentity()) return;
    const n5 = this.m_vertexAttributes.get(0);
    if (!(s3 < 0 ? this.hasNonLinearSegments() : this.hasNonLinearSegmentsPath(s3))) {
      let t3, i3;
      return s3 < 0 ? (t3 = 0, i3 = this.m_pointCount) : (t3 = this.getPathStart(s3), i3 = this.getPathEnd(s3)), n5.applyTransformation(e2, 2 * t3, i3 - t3), void this.notifyModifiedFlags(2001);
    }
    const i2 = new this.m_segmentBufferCTor(), r = this.getPathCount();
    let o = s3 < 0 ? 0 : s3;
    do {
      const t3 = this.getPathStart(o), r2 = this.getPathEnd(o), a2 = this.isClosedPath(o), h2 = n5.readPoint2D(2 * t3);
      if (!this.hasNonLinearSegmentsPath(o)) {
        n5.applyTransformation(e2, 2 * t3, r2 - t3);
        continue;
      }
      const u = mi.getNAN();
      for (let s4 = t3; s4 < r2; ++s4) {
        if (1 !== (31 & this.m_curveData.m_segmentFlags.read(s4))) {
          const o3 = a2 && s4 + 1 === r2;
          o3 && n5.writePoint2D(2 * t3, h2), this.getSegmentBuffer(s4, i2, true), i2.get().applyTransformation(e2);
          const u2 = this.m_curveData.m_segmentParamIndex.read(s4);
          i2.get().writeInBufferStream(this.m_curveData.m_segmentParams, u2), n5.writePoint2D(2 * s4, i2.get().getStartXY()), o3 && n5.writePoint2D(2 * t3, i2.get().getEndXY());
          continue;
        }
        const o2 = 2 * s4;
        n5.queryPoint2D(o2, u), e2.transformInPlace(u), n5.writePoint2D(o2, u);
      }
      if (o === s3) break;
    } while (++o < r);
    this.notifyModifiedFlags(2001);
  }
  calculateSubLength2D(t3, e2, s3, n5) {
    const i2 = this.getPathStart(t3) + e2, r = this.getPathStart(s3) + n5;
    (r < i2 || i2 < 0 || r > this.getPointCount() - 1) && C("");
    const o = this.querySegmentIterator();
    let a2 = 0;
    o.resetToVertex(i2, t3);
    do {
      for (; o.hasNextSegment(); ) {
        const t4 = o.nextSegment();
        if (o.getStartPointIndex() === r) break;
        a2 += t4.calculateLength2D();
      }
      if (o.getStartPointIndex() === r) break;
    } while (o.nextPath());
    return a2;
  }
  calculatePathSubLength2D(e2, s3, n5) {
    const i2 = this.getPathStart(e2) + s3, r = this.getPathStart(e2) + n5;
    (i2 < 0 || r > this.getPointCount() - 1) && C("");
    const o = this.querySegmentIterator();
    if (i2 > r && (this.isClosedPath(e2) || P("cannot iterate across an open path"), o.setCirculator(true)), i2 === r) return 0;
    let a2 = 0, h2 = 0;
    o.resetToVertex(i2, e2);
    do {
      h2 += a2;
      a2 = o.nextSegment().calculateLength2D();
    } while (o.getStartPointIndex() !== r);
    return h2;
  }
  calculateEnvelope2D(t3) {
    return this.updateXYImpl(t3);
  }
  updateXYImpl(t3) {
    const e2 = super.updateXYImpl(t3);
    if (this.hasNonLinearSegments()) {
      const s3 = n3.constructEmpty(), n5 = this.querySegmentIterator();
      for (; n5.nextPath(); ) for (; n5.hasNextSegment(); ) {
        const i2 = n5.nextCurve();
        if (!i2) break;
        t3 ? i2.queryEnvelope(s3) : i2.queryLooseEnvelope(s3), e2.mergeEnvelope2D(s3);
      }
    }
    return e2;
  }
  notifyModifiedAllImpl() {
    null !== this.m_paths && this.m_paths.size() ? this.m_pointCount = this.m_paths.read(this.m_paths.size() - 1) : this.m_pointCount = 0;
  }
  setDirtyOGCFlags(t3) {
    this.setDirtyFlagProtected(16, t3);
  }
  hasDirtyOGCStartFlags() {
    return this.hasDirtyFlag(16);
  }
  setDirtyRingAreas2D(t3) {
    this.setDirtyFlagProtected(1024, t3);
  }
  hasDirtyRingAreas2D() {
    return this.hasDirtyFlag(1024);
  }
  static isNonLinearSegmentFlag(t3) {
    return !(1 & t3);
  }
  addAndExplicitlyOpenAllPaths(e2, s3) {
    this === e2 && P("Multi_path_impl::add");
    let n5 = this.getPathCount();
    for (let t3 = 0, i2 = e2.getPathCount(); t3 < i2; t3++) this.addPath(e2, t3, !s3), this.openPathAndDuplicateStartVertex(n5), n5++;
  }
  getSegmentFlags(t3) {
    return null !== this.m_curveData && null !== this.m_curveData.m_segmentFlags ? this.m_curveData.m_segmentFlags.read(t3) : 1;
  }
  getSegmentBuffer(e2, s3, n5) {
    const i2 = this.getPathIndexFromPointIndex(e2), r = e2 - this.getPathStart(i2);
    r >= this.getSegmentCountPath(i2) && P("getSegmentBuffer"), this.getSegmentFromPath(i2, r, s3, n5);
  }
  getSegmentTypeFromPath(t3, s3) {
    const n5 = this.getPathStart(t3) + s3, i2 = this.getSegmentFlagsStreamRef();
    let o = 1;
    switch (i2 && (o = 31 & i2.read(n5)), o) {
      case 1:
        return a.enumLine;
      case 2:
        return a.enumBezier;
      case 4:
        return a.enumEllipticArc;
      case 8:
        return a.enumRationalBezier2;
      case 16:
        return a.enumBezier2;
      default:
        b("");
    }
  }
  ensureXYMonotoneSegments() {
    if (!this.m_curveData) return false;
    let t3 = false;
    for (let e2 = 0, n5 = this.getPathCount(); e2 < n5; e2++) {
      const n6 = this.getPathStart(e2), i2 = this.getPathEnd(e2), r = i2 - n6;
      for (let e3 = n6; e3 < i2; e3++) {
        const i3 = 31 & this.m_curveData.m_segmentFlags.read(e3);
        if (1 === i3) continue;
        2 !== i3 && z("ensure_xy_monotone_segments");
        const o = (e3 - n6 + 1) % r + n6, a2 = this.m_curveData.m_segmentParamIndex.read(e3), h2 = Ot(mi, 4);
        h2[0] = this.getXY(e3), h2[3] = this.getXY(o), h2[1].x = this.m_curveData.m_segmentParams.read(a2), h2[1].y = this.m_curveData.m_segmentParams.read(a2 + 1), h2[2].x = this.m_curveData.m_segmentParams.read(a2 + 2), h2[2].y = this.m_curveData.m_segmentParams.read(a2 + 3), De(h2) && (t3 = true, this.m_curveData.m_segmentParams.write(a2, h2[1].x), this.m_curveData.m_segmentParams.write(a2 + 1, h2[1].y), this.m_curveData.m_segmentParams.write(a2 + 2, h2[2].x), this.m_curveData.m_segmentParams.write(a2 + 3, h2[2].y));
      }
    }
    return t3 && this.notifyModifiedFlags(2001), t3;
  }
  buildRasterizedGeometryAccelerator(t3, e2) {
    return false;
  }
  buildQuadTreeAccelerator(t3) {
    if (this.m_accelerators || (this.m_accelerators = new Vs2()), null !== this.m_accelerators.getQuadTree()) return true;
    this.ensureUniqueAccelerators(), this.m_accelerators.setQuadTree(null);
    const e2 = Wt2(this);
    return this.m_accelerators.setQuadTree(e2), true;
  }
  buildQuadTreeForPathsAccelerator(t3) {
    if (this.m_accelerators || (this.m_accelerators = new Vs2()), null !== this.m_accelerators.getQuadTreeForPaths()) return true;
    this.ensureUniqueAccelerators(), this.m_accelerators.setQuadTreeForPaths(null);
    const e2 = Qt2(this);
    return this.m_accelerators.setQuadTreeForPaths(e2), true;
  }
  updateCurveCounter(t3) {
    this.modifyCurveCounter(t3 - this.getCurveCount());
  }
  removeAllCurvesFromGlobalCounter() {
    this.m_curveData && (_Hs.st_totalCurveCount -= this.m_curveData.m_curveCount, this.m_curveData.m_curveCount = 0, this.m_curveData.m_bezierCount = 0, this.m_curveData.m_arcCount = 0, this.m_curveData.m_bezier2Count = 0, this.m_curveData.m_rbezier2Count = 0, this.m_curveData.m_curveParamWritePoint = 0);
  }
  modifyCurveCounter(t3) {
    t3 && (this.m_curveData || (this.m_curveData = new Zs2()), _Hs.st_totalCurveCount += t3, this.m_curveData.m_curveCount += t3);
  }
  getCurveCount() {
    return this.m_curveData ? this.m_curveData.m_curveCount : 0;
  }
  incCurveType(t3, e2) {
    this.m_curveData || (this.m_curveData = new Zs2()), 2 & t3 ? this.m_curveData.m_bezierCount += e2 : 4 & t3 ? this.m_curveData.m_arcCount += e2 : 8 & t3 ? this.m_curveData.m_rbezier2Count += e2 : 16 & t3 && (this.m_curveData.m_bezier2Count += e2);
  }
  getCurveWritePoint() {
    return null !== this.m_curveData ? this.m_curveData.m_curveParamWritePoint : 0;
  }
  initSegmentData(t3) {
    null === this.m_curveData && (this.m_curveData = new Zs2());
    const e2 = this.m_reservedPointCount > 0 ? this.m_reservedPointCount : this.m_pointCount;
    null === this.m_curveData.m_segmentParamIndex && (this.m_curveData.m_segmentFlags = K2(e2, 1), this.m_curveData.m_segmentParamIndex = J2(e2, -1));
    const s3 = this.m_curveData.m_curveParamWritePoint + t3;
    null === this.m_curveData.m_segmentParams ? this.m_curveData.m_segmentParams = $2(s3) : s3 !== this.m_curveData.m_segmentParams.size() && this.m_curveData.m_segmentParams.resize(s3, 0), this.m_curveData.m_segmentFlags.size() < e2 && (this.m_curveData.m_segmentFlags.resize(e2, 1), this.m_curveData.m_segmentParamIndex.resize(e2, -1));
  }
  updateCurveWritePoint(t3) {
    null === this.m_curveData && (this.m_curveData = new Zs2()), this.m_curveData.m_curveParamWritePoint = t3;
  }
  updateOGCFlagsHelper() {
    const t3 = this.getPathCount();
    if (0 === t3) return;
    const e2 = this.m_pathFlags;
    let s3 = 0;
    for (let n5 = 0; n5 < t3; n5++) {
      const t4 = this.m_cachedRingAreas2D.read(n5);
      0 === s3 && (s3 = K(t4)), t4 * s3 > 0 || 0 === s3 ? e2.setBits(n5, 8) : e2.clearBits(n5, 8);
    }
  }
  updateOGCFlagsProtected() {
    this.hasDirtyFlag(16) && (this.updateRingAreas2DProtected(), this.updateOGCFlagsHelper(), this.setDirtyFlagProtected(16, false));
  }
  replaceSegment(e2, s3, i2) {
    (e2 < 0 || e2 >= this.getPointCount()) && P("Multi_path_impl.replace_segment"), n(s3.isCurve());
    const r = this.getPathIndexFromPointIndex(e2), o = this.getPathStart(r), a2 = (e2 - o + 1) % this.getPathSize(r) + o;
    {
      const t3 = this.getXY(e2), i3 = this.getXY(a2), r2 = !t3.isEqualPoint2D(s3.getStartXY()) || !i3.isEqualPoint2D(s3.getEndXY());
      n(!r2);
    }
    this.replaceSegmentImpl(e2, a2, s3, i2);
  }
  replaceSegmentImpl(t3, e2, s3, i2) {
    const r = s3.getDescription();
    this.mergeVertexDescription(r);
    const o = Yt(32, Number.NaN), a2 = new ee({ vd: r, attribBuffer: o, initDefaultValues: false }), h2 = null === this.m_curveData ? 1 : 31 & this.m_curveData.m_segmentFlags.read(t3), u = ks(h2), m3 = Bs2(s3);
    let l2, c = false;
    u >= m3 ? (n(null !== this.m_curveData), c = true, l2 = this.m_curveData.m_segmentParamIndex.read(t3)) : (this.initSegmentData(m3), c = false, l2 = this.m_curveData.m_curveParamWritePoint);
    const g2 = s3.getGeometryType(), d2 = Zs2.toSegType(g2);
    i2 || (s3.queryStart(a2), this.setPointByValNoCurves(t3, a2), s3.queryEnd(a2), this.setPointByValNoCurves(e2, a2)), this.m_curveData.m_segmentParamIndex.write(t3, 1 !== d2 ? l2 : -1), this.m_curveData.m_segmentFlags.write(t3, d2), 1 !== d2 && s3.writeInBufferStream(this.m_curveData.m_segmentParams, l2), c || (this.m_curveData.m_curveParamWritePoint += m3), h2 !== d2 && (this.incCurveType(h2, -1), this.incCurveType(d2, 1), this.modifyCurveCounter(1 === h2 ? 1 : -1));
  }
  setAttributeImpl(e2, s3, n5) {
    if (this.addAttribute(e2), !this.isEmpty()) if (this.hasNonLinearSegments() && 0 === e2) {
      (s3 < 0 || s3 > 1) && P("");
      const e3 = new x3(), i2 = 0 === s3 ? n5 : 0, r = 0 === s3 ? 0 : 1;
      e3.setShiftCoords(i2, r), 0 === s3 ? e3.xx = 0 : e3.yy = 0, this.applyTransformation(e3);
    } else super.setAttributeImpl(e2, s3, n5);
  }
};
Hs2.st_totalCurveCount = 0;
var Us2 = class {
  constructor(t3, e2) {
    this.m_segIter = null, this.m_quadTree = null, this.m_qtIter = null, this.m_extentOfInterest = new n3(e2), this.m_bfirst = true, this.m_prevIndex = -100, this.m_parent = t3;
  }
  nextSegment() {
    return this.m_bfirst && this.prepare_(), this.m_quadTree ? this.nextSegmentQt() : this.nextSegmentNoQt();
  }
  getPathIndex() {
    return this.m_segIter.getPathIndex();
  }
  getStartPointIndex() {
    return this.m_segIter.getStartPointIndex();
  }
  getEndPointIndex() {
    return this.m_segIter.getEndPointIndex();
  }
  isClosingSegment() {
    return this.m_segIter.isClosingSegment();
  }
  isPathClosed() {
    return this.m_segIter.isPathClosed();
  }
  prepare_() {
    const t3 = this.m_parent.getAccelerators();
    t3 && (this.m_quadTree = t3.getQuadTree(), this.m_quadTree && (this.m_qtIter = this.m_quadTree.getSortedIterator(this.m_extentOfInterest, 0))), this.m_segIter = this.m_parent.querySegmentIterator();
  }
  nextSegmentQt() {
    this.m_bfirst = false;
    const t3 = this.m_qtIter.next();
    if (-1 === t3) return null;
    const e2 = this.m_quadTree.getElement(t3);
    (e2 !== this.m_prevIndex + 1 || this.m_segIter.isLastSegmentInPath()) && (this.m_segIter.resetToVertex(e2, this.m_segIter.getPathIndex()), this.m_prevIndex = e2);
    return this.m_segIter.nextSegment();
  }
  nextSegmentNoQt() {
    for (; ; ) {
      if (!this.m_bfirst && this.m_segIter.hasNextSegment()) {
        const t3 = this.m_segIter.nextSegment(), e2 = n3.constructEmpty();
        if (t3.queryLooseEnvelope(e2), !e2.isIntersecting(this.m_extentOfInterest)) continue;
        return t3;
      }
      if (this.m_bfirst = false, !this.m_segIter.nextPath()) return null;
    }
  }
};
var Os2 = class _Os extends Hs2 {
  constructor(t3) {
    t3 ? t3.vd ? (super({ vd: t3.vd, bPolygon: false }), this.m_segmentBufferCTor = fm) : t3.copy ? (super({ vd: t3.copy.getDescription(), bPolygon: false }), this.m_segmentBufferCTor = fm, t3.copy.copyTo(this)) : t3.move ? (super({ move: t3.move }), this.m_segmentBufferCTor = fm) : t3.start ? (super({ vd: t3.start.getDescription(), bPolygon: false }), this.m_segmentBufferCTor = fm, this.startPathPoint(t3.start), this.lineToPoint(t3.end)) : t3.path ? (super({ bPolygon: false }), this.m_segmentBufferCTor = fm, this.addPathPoint2D(t3.path, t3.pointCount, t3.bForward)) : b("bad constructor arg") : (super({ bPolygon: false }), this.m_segmentBufferCTor = fm);
  }
  getBoundary() {
    return Js2(this);
  }
  assignCopy(t3) {
    return this !== t3 && t3.copyTo(this), this;
  }
  assignMove(t3) {
    return t3.copyTo(this), this;
  }
  getGeometryType() {
    return _Os.type;
  }
  getDimension() {
    return 1;
  }
  createInstance() {
    return new _Os({ vd: this.getDescription() });
  }
  equals(t3, e2) {
    return this.equalsBase(t3, e2);
  }
};
Os2.type = a.enumPolyline;
var Qs2 = a;
function Ks(t3, e2) {
  if (t3.isEmpty()) return false;
  const n5 = t3.getGeometryType();
  if (n5 === Qs2.enumPolygon) return 0 !== t3.calculateArea2D();
  if (n5 === Qs2.enumPolyline) return $s2(t3.getImpl(), e2, true).bNotEmpty;
  if (n5 === Qs2.enumEnvelope) return true;
  if (f(n5)) return !!t3.isClosed();
  if (l(n5)) return false;
  if (n5 === Qs2.enumGeometryCollection) {
    const s3 = t3;
    for (let t4 = 0, n6 = s3.getGeometryCount(); t4 < n6; t4++) if (Ks(s3.getGeometry(t4), e2)) return true;
    return false;
  }
  z("");
}
function Js2(t3, e2) {
  const n5 = t3.getGeometryType();
  if (n5 === Qs2.enumPolygon) {
    const e3 = new Os2({ vd: t3.getDescription() });
    return t3.isEmpty() || t3.copyToUnchecked(e3), e3;
  }
  if (n5 === Qs2.enumPolyline) return $s2(t3.getImpl(), e2, false).boundary;
  if (n5 === Qs2.enumEnvelope) {
    const e3 = new Os2({ vd: t3.getDescription() });
    return t3.isEmpty() || e3.addEnvelope(t3, false), e3;
  }
  if (f(n5)) {
    const e3 = new cs2({ vd: t3.getDescription() });
    if (!t3.isEmpty() && !t3.isClosed()) {
      const s3 = new ee();
      e3.reserve(2), t3.queryStart(s3), e3.add(s3), t3.queryEnd(s3), e3.add(s3);
    }
    return e3;
  }
  if (n5 === Qs2.enumGeometryCollection) {
    const s3 = t3;
    let n6 = null;
    for (let i2 = 0, r = s3.getGeometryCount(); i2 < r; i2++) {
      const r2 = Js2(s3.getGeometry(i2), e2);
      if (null !== r2) {
        null === n6 && (n6 = t3.createInstance());
        const e3 = r2;
        n6.addGeometry(e3);
      }
    }
    return n6;
  }
  if (l(n5)) return new ee({ vd: t3.getDescription() });
  z("");
}
function $s2(t3, e2, s3) {
  const n5 = false, i2 = t3;
  let r = null;
  if (s3 || (r = new cs2({ vd: i2.getDescription() })), !i2.isEmpty()) {
    const t4 = new st2(0);
    for (let e3 = 0, s4 = i2.getPathCount(); e3 < s4; e3++) {
      if (i2.getPathSize(e3) > 0 && !i2.isClosedPathInXYPlane(e3)) {
        const s5 = i2.getPathStart(e3);
        t4.add(s5);
        const n6 = i2.getPathEnd(e3) - 1;
        t4.add(n6);
      }
    }
    if (t4.size() > 0) {
      const e3 = new ot(), n6 = i2.getAttributeStreamRef(0), o = { userSort(t5, e4, s4) {
        const i3 = mi.getNAN(), r2 = mi.getNAN();
        s4.sort(t5, e4, (t6, e5) => (n6.queryPoint2D(2 * t6, i3), n6.queryPoint2D(2 * e5, r2), i3.compare(r2)));
      }, getValue: (t5) => n6.read(2 * t5 + 1) };
      e3.sort(t4, 0, t4.size(), o);
      let a2 = n6.readPoint2D(2 * t4.read(0)), h2 = 0, u = 1;
      const m3 = new ee();
      for (let i3 = 1, r2 = t4.size(); i3 < r2; i3++) {
        const e4 = n6.readPoint2D(2 * t4.read(i3));
        if (e4.isEqualPoint2D(a2)) t4.read(h2) > t4.read(i3) ? (t4.write(h2, vs()), h2 = i3) : t4.write(i3, vs()), u++;
        else {
          if (1 & u) {
            if (s3) return { bNotEmpty: true, boundary: new cs2({}) };
          } else t4.write(h2, vs());
          a2 = e4, h2 = i3, u = 1;
        }
      }
      if (1 & u) {
        if (s3) return { bNotEmpty: true, boundary: new cs2({}) };
      } else t4.write(h2, vs());
      if (!s3) {
        t4.sort(0, t4.size());
        for (let e4 = 0, s4 = t4.size(); e4 < s4 && t4.read(e4) !== vs(); e4++) i2.getPointByVal(t4.read(e4), m3), r.add(m3);
      }
    }
  }
  return s3 ? { bNotEmpty: n5, boundary: new cs2({}) } : { bNotEmpty: n5, boundary: r };
}
function tn(t3, e2, s3, i2) {
  const r = 4 * Qs() * (Math.abs(e2.vmin) + Math.abs(e2.vmax)), o = Qs();
  if (1 === t3.getMaxDerivative()) {
    n(s3 > 0);
    const o2 = hn(t3, 0, e2, Qs(), r);
    return i2[0] = o2.root, o2.cRoots;
  }
  let a2, h2 = [];
  const u = new x2(e2.vmin - r, e2.vmax + r);
  h2.push(new mi(u.vmin, u.vmax));
  let m3 = 0;
  for (let n5 = t3.getMaxDerivative() - 1; n5 >= 0; n5--) {
    a2 = h2, h2 = [];
    for (let u2 = 0, l2 = a2.length; u2 < l2; u2++) {
      if (a2[u2][0] < a2[u2][1]) {
        let l3, c, g2;
        if (n5 === t3.getMaxDerivative() - 1 ? { root: l3, funcAtRoot: c, cRoots: g2 } = hn(t3, n5, x2.construct(a2[u2][0], a2[u2][1]), o, 0.5 * r) : { root: l3, funcAtRoot: c, cRoots: g2 } = un(t3, n5, x2.construct(a2[u2][0], a2[u2][1]), o, 0.5 * r), 1 === g2) {
          if (0 === n5) {
            if (m3 < s3) {
              if (a2[u2][0] <= e2.vmin && a2[u2][1] >= e2.vmin && l3 !== e2.vmin) {
                0 === t3.getValue(0, e2.vmin) && (l3 = e2.vmin);
              }
              if (a2[u2][0] <= e2.vmax && a2[u2][1] >= e2.vmax && l3 !== e2.vmax) {
                0 === t3.getValue(0, e2.vmax) && (l3 = e2.vmax);
              }
              i2[m3] = e2.snapClip(l3), m3 > 0 ? i2[m3] - i2[m3 - 1] > r && m3++ : m3++;
            }
          } else {
            const t4 = mi.getNAN();
            t4[0] = a2[u2][0], t4[1] = l3, h2.push(t4);
            const e3 = mi.getNAN();
            e3[0] = l3, e3[1] = a2[u2][1], h2.push(e3);
          }
          continue;
        }
      }
      h2.push(a2[u2]);
    }
  }
  return m3;
}
function en(t3, e2, s3, n5) {
  const i2 = new p2(), r = cn(new p2(t3), new p2(e2), s3, i2);
  return n5[0] = i2.value(), r;
}
function sn(t3, e2, s3, n5, i2, r) {
  const o = Ot(p2, 2), a2 = gn(new p2(t3), new p2(e2), new p2(s3), n5, i2, o);
  return r[0] = o[0].value(), r[1] = o[1].value(), a2;
}
function nn(t3, e2, s3, n5, i2, r, o) {
  const a2 = Ot(p2, 3), h2 = dn(new p2(t3), new p2(e2), new p2(s3), new p2(n5), i2, r, a2);
  return o[0] = a2[0].value(), o[1] = a2[1].value(), o[2] = a2[2].value(), h2;
}
function rn(t3, e2, s3, n5, i2, r, o, a2) {
  return an(t3, e2, s3, n5, i2, r, o, a2);
}
function on(t3, e2, s3, n5, i2, r) {
  return ln(t3, e2, s3, n5, i2, r);
}
function an(t3, e2, s3, n5, i2, r, o, a2) {
  const h2 = Yt(s3 * s3, Number.NaN);
  h2.fill(0), Dt(a2, n5, 0, 0, s3);
  const u = Yt(s3, Number.NaN), m3 = Yt(s3, Number.NaN), l2 = Yt(s3, Number.NaN);
  let c = t3(a2, s3, e2);
  const g2 = 100;
  let d2 = 0;
  for (d2 = 0; d2 < g2; d2++) {
    const n6 = c;
    for (let t4 = 0; t4 < s3; ++t4) m3[t4] = a2[t4];
    if (d2 % s3 === 0) {
      h2.fill(0);
      for (let t4 = 0; t4 < s3; t4++) h2[t4 * s3 + t4] = 1;
    }
    let o2 = 0, g3 = 0;
    for (let m4 = 0; m4 < s3; ++m4) {
      for (let t4 = 0; t4 < s3; ++t4) u[t4] = h2[m4 * s3 + t4];
      const n7 = c;
      c = mn(t3, e2, a2, u, i2, r, s3);
      const l3 = n7 - c;
      l3 > o2 && (g3 = m4, o2 = l3);
    }
    for (let t4 = 0; t4 < s3; t4++) u[t4] = a2[t4] - m3[t4], l2[t4] = a2[t4] + (a2[t4] - m3[t4]);
    const _ = t3(l2, s3, e2);
    if (_ < n6) {
      if (2 * (n6 - 2 * c + _) * H(n6 - c - o2) < H(n6 - _) * o2) {
        c = mn(t3, e2, a2, u, i2, r, s3);
        for (let t4 = 0; t4 < s3; ++t4) h2[g3 * s3 + t4] = h2[(s3 - 1) * s3 + t4], h2[(s3 - 1) * s3 + t4] = u[t4];
      }
    }
    if (n6 <= c) return t3(a2, s3, e2);
  }
  return c;
}
function hn(t3, e2, s3, n5, i2) {
  const o = { root: 0, funcAtRoot: 0, cRoots: 0 };
  let a2 = s3.vmin, h2 = s3.vmax, u = 0, m3 = Number.MAX_VALUE, l2 = t3.getValue(e2, a2), c = t3.getValue(e2, h2), g2 = 0, d2 = 0, _ = 0;
  if (l2 >= 0 && c >= 0 || l2 <= 0 && c <= 0) return Math.abs(l2) < Math.abs(c) ? (o.funcAtRoot = l2, o.root = a2, o.cRoots = 0 === l2 ? 1 : 0, o) : (o.funcAtRoot = c, o.root = h2, o.cRoots = 0 === c ? 1 : 0, o);
  Math.abs(l2) < Math.abs(c) && (h2 = Pt(a2, a2 = h2), c = Pt(l2, l2 = c)), u = a2, g2 = l2;
  let p3 = true, f3 = 0;
  for (; 0 !== c && Math.abs(a2 - h2) > n5 * Math.abs(h2) + i2; f3++) {
    let s4 = f3 > 64;
    if (!s4) {
      d2 = l2 !== g2 && c !== g2 ? a2 * c * g2 / ((l2 - c) * (l2 - g2)) + h2 * l2 * g2 / ((c - l2) * (c - g2)) + u * l2 * c / ((g2 - l2) * (g2 - c)) : h2 - c * (h2 - a2) / (c - l2);
      const t4 = (3 * a2 + h2) / 4;
      if (s4 = !(d2 > t4 && d2 < h2 || d2 > h2 && d2 < t4), !s4) {
        const t5 = n5 * Math.abs(h2) + i2;
        if (p3) {
          const e3 = Math.abs(h2 - u);
          s4 = Math.abs(d2 - h2) >= 0.5 * e3 || e3 < t5;
        } else {
          const e3 = Math.abs(u - m3);
          s4 = Math.abs(d2 - h2) >= 0.5 * e3 || e3 < t5;
        }
      }
    }
    if (s4 ? (d2 = (a2 + h2) / 2, p3 = true) : p3 = false, _ = t3.getValue(e2, d2), 0 === _) return o.root = d2, o.funcAtRoot = _, o.cRoots = 1, o;
    if (!s4) {
      const s5 = a2 - d2, n6 = d2 - h2;
      if (Math.abs(s5) > 10 * Math.abs(n6)) {
        let s6 = h2 + 3 * n6;
        for (let n7 = 0; n7 < 2; n7++) {
          const n8 = t3.getValue(e2, s6);
          K(l2) * K(n8) > 0 ? (a2 = s6, l2 = n8) : s6 = Q(a2, h2, 0.75);
        }
      } else if (Math.abs(n6) > 10 * Math.abs(s5)) {
        let n7 = a2 - 3 * s5;
        for (let s6 = 0; s6 < 2; ++s6) {
          const s7 = t3.getValue(e2, n7);
          K(c) * K(s7) > 0 ? (h2 = n7, c = s7) : n7 = Q(a2, h2, 0.25);
        }
      }
    }
    m3 = u, u = h2, g2 = c, K(l2) * K(_) < 0 ? (h2 = d2, c = _) : (a2 = d2, l2 = _), Math.abs(l2) < Math.abs(c) && (h2 = Pt(a2, a2 = h2), c = Pt(l2, l2 = c)), 128 === f3 && b("Root_finder iterations exceeded");
  }
  return o.root = h2, o.funcAtRoot = c, o.cRoots = 1, o;
}
function un(t3, e2, s3, n5, i2) {
  const o = { root: 0, funcAtRoot: 0, cRoots: 0 };
  let a2 = s3.vmin, h2 = t3.getValue(e2, a2), u = s3.vmax, m3 = t3.getValue(e2, u);
  if (h2 >= 0 && m3 >= 0 || h2 <= 0 && m3 <= 0) return Math.abs(h2) < Math.abs(m3) ? (o.funcAtRoot = h2, o.root = a2, o.cRoots = 0 === h2 ? 1 : 0, o) : (o.funcAtRoot = m3, o.root = u, o.cRoots = 0 === m3 ? 1 : 0, o);
  m3 < 0 && (m3 = Pt(h2, h2 = m3), u = Pt(a2, a2 = u));
  let l2 = 0.5 * (a2 + u), c = Math.abs(u - a2), g2 = c, d2 = t3.getValue(e2, l2), _ = t3.getValue(e2 + 1, l2);
  const p3 = 1, f3 = 4;
  let P5 = f3;
  const y2 = 2;
  let x4 = 1, C3 = 0, v3 = 0, b2 = p3;
  const E2 = 32;
  let S3 = 0;
  for (; ++S3 < 100; ) {
    let s4;
    S3 > E2 || 0 === _ || b2 === y2 && C3 > 1 || b2 === p3 && P5 < f3 ? (b2 = p3, x4 > 1 && x4--) : (b2 = y2, v3 > 1 && Math.abs(2 * d2) > Math.abs(c * _) && x4++), c = g2;
    let n6 = false;
    if (b2 === p3) do {
      if (v3 > 2) {
        const t4 = 16 * Math.abs(c);
        if (0.5 * Math.abs(a2 - u) > t4) {
          const e3 = Math.min(a2, u), n7 = Math.max(a2, u);
          if (l2 === e3) {
            s4 = l2, l2 = e3 + t4, g2 = l2 - s4;
            break;
          }
          if (l2 === n7) {
            s4 = l2, l2 = n7 - t4, g2 = l2 - s4;
            break;
          }
        }
      }
      g2 = 0.5 * (u - a2), s4 = l2, l2 = a2 + g2, n6 = a2 === l2 || u === l2;
    } while (0);
    else for (; ; ) {
      g2 = x4 * d2 / _, s4 = l2, l2 -= g2, n6 = l2 === s4;
      const t4 = Math.min(a2, u), e3 = Math.max(a2, u);
      if (l2 < t4) {
        if (x4 > 1) {
          l2 = s4, x4--;
          continue;
        }
        g2 = s4 - t4, l2 = t4;
      } else if (l2 > e3) {
        if (x4 > 1) {
          l2 = s4, x4--;
          continue;
        }
        g2 = s4 - e3, l2 = e3;
      }
      break;
    }
    if (n6 || Math.abs(g2) < i2) {
      s4 !== l2 && (d2 = t3.getValue(e2, l2));
      break;
    }
    d2 = t3.getValue(e2, l2), _ = t3.getValue(e2 + 1, l2);
    const r = a2, o2 = u;
    d2 < 0 ? (h2 = d2, a2 = l2) : (m3 = d2, u = l2), b2 === y2 && (a2 === r && u === o2 || v3 > 1 && Math.abs(g2) >= 0.5001 * Math.abs(c)) ? C3++ : C3 = 0, b2 === p3 ? (P5++, v3 = 0) : (P5 = 0, v3++);
  }
  return 100 === S3 && b("Root_finder iterations exceeded"), o.root = l2, o.funcAtRoot = d2, o.cRoots = 1, o;
}
function mn(t3, e2, s3, n5, i2, r, o) {
  const a2 = n5.slice(0, o);
  let h2 = 0;
  for (let f3 = 0; f3 < o; f3++) h2 += n5[f3] * n5[f3];
  if (h2 = Math.sqrt(h2), h2 > 0) for (let f3 = 0; f3 < o; f3++) a2[f3] /= h2;
  let u = Number.NEGATIVE_INFINITY, m3 = Number.POSITIVE_INFINITY;
  {
    const t4 = Yt(o, 0);
    for (let e3 = 0; e3 < o; e3++) t4[e3] = e3;
    t4.sort((t5, e3) => {
      const s4 = Math.abs(a2[t5]), n6 = Math.abs(a2[e3]);
      return s4 < n6 ? -1 : s4 > n6 ? 1 : 0;
    });
    for (let e3 = 0; e3 < o; e3++) {
      const n6 = t4[e3];
      if (0 === a2[n6]) continue;
      let o2 = (i2[n6] - s3[n6]) / a2[n6], h3 = (r[n6] - s3[n6]) / a2[n6];
      h3 < o2 && (h3 = Pt(o2, o2 = h3)), o2 > u && (u = o2), h3 < m3 && (m3 = h3);
    }
  }
  let l2 = 0;
  const c = (Math.abs(u) + Math.abs(m3)) * Qs() * 100, g2 = Yt(o, Number.NaN), d2 = a2.slice();
  function _(n6, i3) {
    for (let t4 = 0, e3 = o; t4 < e3; t4++) g2[t4] = s3[t4] + n6 * d2[t4];
    return t3(g2, o, e2);
  }
  c > 0 && (l2 = on(_, null, u, 0, m3, c));
  const p3 = _(l2);
  for (let f3 = 0, P5 = o; f3 < P5; f3++) s3[f3] = Us(g2[f3], i2[f3], r[f3]);
  return p3;
}
function ln(t3, e2, s3, n5, i2, r) {
  const o = Os();
  let a2 = n5, h2 = t3(a2, e2), u = s3, m3 = i2, l2 = t3(u, e2), c = t3(m3, e2);
  h2 > l2 && (h2 = l2, a2 = u), h2 > c && (h2 = c, a2 = m3);
  let g2 = u, d2 = m3, _ = l2, p3 = c;
  _ > p3 && (_ = Pt(p3, p3 = _), d2 = Pt(g2, g2 = d2));
  let f3 = a2 - g2, P5 = g2 - d2;
  const y2 = 0.5 * Math.min(r, m3 - u), x4 = 2 * y2, C3 = 100;
  let v3, b2 = 0;
  for (v3 = 0; v3 < C3 && !(m3 - u <= x4); ++v3) {
    const s4 = u + 0.5 * (m3 - u);
    let n6 = b2 > 0;
    if (!n6 && Math.abs(P5) <= y2 && (n6 = true, b2 = 3), !n6) {
      const t4 = a2 - g2, e3 = a2 - d2, s5 = t4 * (h2 - p3);
      let i4 = e3 * (h2 - _), r3 = e3 * i4 - t4 * s5;
      i4 = 2 * (i4 - s5), i4 > 0 && (r3 = -r3), i4 = Math.abs(i4), 0 === i4 || Math.abs(r3) >= Math.abs(i4 * P5 / 2) || r3 <= i4 * (u - a2) || r3 >= i4 * (m3 - a2) ? (n6 = true, b2 = 3) : (P5 = f3, f3 = r3 / i4);
    }
    n6 && (P5 = a2 >= s4 ? u - a2 : m3 - a2, f3 = o * P5, b2--);
    let i3 = a2 + f3;
    i3 < u + y2 ? i3 = u + y2 : i3 > m3 - y2 && (i3 = m3 - y2);
    const r2 = t3(i3, e2);
    r2 < h2 ? (i3 >= a2 ? (u = a2, l2 = h2) : (m3 = a2, c = h2), d2 = g2, g2 = a2, a2 = i3, p3 = _, _ = h2, h2 = r2) : (i3 < a2 ? (u = i3, l2 = r2) : (m3 = i3, c = r2), r2 <= _ || g2 === a2 ? (d2 = g2, g2 = i3, p3 = _, _ = r2) : (r2 <= p3 || d2 === a2 || d2 === g2) && (d2 = i3, p3 = r2));
  }
  return a2;
}
function cn(t3, e2, s3, n5) {
  return t3.isZero() ? e2.isZero() ? -1 : 0 : (n5.setE(e2.clone().negateThis().divThisE(t3)), s3.containsCoordinate(n5.value()) ? 1 : 0);
}
function gn(t3, e2, s3, n5, i2, r) {
  if (0 === t3.value()) {
    if (i2) return r[0].set(1), n5.containsCoordinate(r[0].value()) ? 1 : 0;
    return cn(e2, s3, n5, r[0]);
  }
  if (i2) {
    let e3 = 2;
    return r[0].set(1), r[1].setE(s3).divThisE(t3), r[1].eq(r[0]) && (r[1].set(1), e3 = 1), n5.containsCoordinate(r[1].value()) || (e3 = 1), n5.containsCoordinate(r[0].value()) || (e3--, r[0].setE(r[1])), 2 === e3 && r[0].value() > r[1].value() && (r[1] = Pt(r[0], r[0] = r[1])), e3;
  }
  const o = e2.clone().sqrThis().subThisE(t3.clone().mulThisE(s3).mulThisE(D2));
  if (o.lt(I2)) return 0;
  const a2 = new p2(e2.value() >= 0 ? 1 : -1), h2 = o.clone().sqrtThis(), u = new p2(-0.5).mulThisE(e2.clone().addThisE(a2.clone().mulThisE(h2)));
  let m3 = 0;
  r[0].setE(u.divE(t3));
  const l2 = new p2(r[0].value()), c = new p2(t3.value()).mulE(l2).addE(new p2(e2.value()).mulE(l2).addE(new p2(s3.value())));
  return c.isZero() || Cn(r[0], t3, e2, s3, r[0]), n5.containsCoordinate(r[0].value()) && m3++, 0 !== h2.value() && 0 !== u.value() ? (r[m3].assign(s3.divE(u)), l2.set(r[m3].value()), c.assign(new p2(t3.value()).mulE(l2).addE(new p2(e2.value()).mulE(l2).addE(new p2(s3.value())))), c.isZero() || Cn(r[m3], t3, e2, s3, r[m3]), n5.containsCoordinate(r[m3].value()) && m3++, 2 === m3 && r[0].value() > r[1].value() && (r[1] = Pt(r[0], r[0] = r[1])), m3) : m3;
}
function dn(t3, e2, s3, n5, i2, r, o) {
  if (0 === t3.value()) {
    return gn(e2, s3, n5, i2, r, o);
  }
  if (r) {
    let s4 = 1;
    o[0].set(1);
    const r2 = o.slice(s4), a2 = gn(t3, e2.addE(t3), n5.negate(), i2, false, r2);
    if (a2 > 0) {
      s4 += a2;
      for (let t4 = 1; t4 < s4; t4++) o[t4].eq(w2) && (o[s4 - 1] = Pt(o[t4], o[t4] = o[s4 - 1]), s4--);
    }
    const h2 = o.slice(0, s4);
    h2.sort((t4, e3) => t4.value() < e3.value() ? -1 : t4.value() > e3.value() ? 1 : 0);
    for (let t4 = 0; t4 < s4; ++t4) o[t4] = h2[t4];
    return s4;
  }
  return vn(t3, e2, s3, n5, i2, o);
}
function _n(e2, s3, n5, i2, r, o) {
  return (o < s3 || s3 < 0) && P("nth_degree_real_roots"), bn(e2, s3, n5, i2, r);
}
function pn(t3, e2, s3, n5) {
  return { coef0: t3.clone(), coef1: e2.clone(), coef2: s3.clone(), coef3: n5.clone(), calcF(t4) {
    return this.coef0.clone().mulThis(t4).addThisE(this.coef1).mulThis(t4).addThisE(this.coef2).mulThis(t4).addThisE(this.coef3);
  }, calcDF(t4) {
    return this.coef0.clone().mulThis(3).mulThis(t4).addThisE(this.coef1.clone().mulThisByPower2(2)).mulThis(t4).addThisE(this.coef2);
  }, estimateError(t4) {
    const e3 = Math.abs(t4), s4 = ((this.coef0.eps() * e3 + this.coef1.eps()) * e3 + this.coef2.eps()) * e3 + this.coef3.eps() + this.calcF(t4).eps(), n6 = this.coef0.clone().mulThis(t4).mulThis(3).addThisE(this.coef1.clone().mulThis(2)).mulThis(t4).addThisE(this.coef2);
    if (n6.isZero()) {
      const e4 = this.coef0.clone().mulThis(t4).mulThis(6).addThisE(this.coef1.clone().mulThis(2));
      if (e4.isZero()) {
        const t5 = this.coef0.clone().mulThis(6);
        return Math.pow(6 * s4 / Math.abs(t5.value()), 1 / 3);
      }
      return Math.sqrt(2 * s4 / Math.abs(e4.value()));
    }
    return s4 / Math.abs(n6.value());
  } };
}
var fn = class {
  updateCoefs(t3) {
    if (this.lastDeriv1 === t3) return this.curCoefs = this.derivCoefs1, void (this.lastUsed = 1);
    if (this.lastDeriv2 === t3) return this.curCoefs = this.derivCoefs2, void (this.lastUsed = 2);
    let e2;
    1 === this.lastUsed ? (e2 = this.derivCoefs2, this.lastDeriv2 = t3, this.lastUsed = 2) : (e2 = this.derivCoefs1, this.lastDeriv1 = t3, this.lastUsed = 1), e2.length = 0;
    for (let s3 = 0, n5 = this.truePower - t3; s3 <= n5; ++s3) {
      e2.push(this.coefs[s3 + t3].clone());
      let n6 = s3 + t3, i2 = n6--;
      for (let e3 = 1; e3 < t3; e3++) i2 *= n6--;
      e2[s3].mulThis(i2);
    }
    this.curCoefs = e2;
  }
  constructor(t3, e2, s3, n5) {
    this.derivCoefs1 = [], this.derivCoefs2 = [], this.lastDeriv1 = -1, this.lastDeriv2 = -1, this.lastUsed = -1, this.curCoefs = null, this.coefs = t3, this.power = e2, this.truePower = 0;
    for (let i2 = e2; i2 >= 1; i2--) if (0 !== this.coefs[i2].value()) {
      this.truePower = i2;
      break;
    }
  }
  getMaxDerivative() {
    return this.truePower + 1;
  }
  getValue(t3, e2) {
    let s3 = this.coefs;
    0 === t3 ? s3 = this.coefs : (this.updateCoefs(t3), s3 = this.curCoefs);
    const n5 = new n2(0);
    let i2 = 1;
    for (let r = 0, o = this.truePower - t3; r <= o; ++r) n5.pe(i2 * s3[r].value()), i2 *= e2;
    return n5.getResult();
  }
  getError(t3) {
    const e2 = Math.abs(t3), s3 = new n2(0), n5 = new p2(1), i2 = new p2(0);
    for (let o = 0, a2 = this.power; o <= a2; ++o) i2.addThisE(this.coefs[o].mulE(n5)), s3.pe(n5.value() * this.coefs[o].eps()), n5.mulThis(e2);
    s3.pe(i2.eps());
    let r = 1;
    for (let o = 1; o <= this.truePower; ++o) {
      r *= o, this.updateCoefs(o);
      const e3 = new p2(1), n6 = new p2(0);
      for (let s4 = 0, i3 = this.truePower - o; s4 <= i3; ++s4) n6.addThisE(this.curCoefs[s4].mulE(e3)), e3.mulThis(t3);
      if (!n6.isZero()) return Math.pow(r * s3.getResult() / Math.abs(n6.value()), 1 / o);
    }
    return 0;
  }
};
function Pn(t3, e2, s3, n5, i2, r) {
  let o = t3, a2 = e2, h2 = a2 - o;
  if (!r) {
    let s4 = n5.calcF(t3).value(), i3 = n5.calcF(e2).value();
    if ((s4 > 0 || s4 > i3) && (a2 = Pt(o, o = a2), i3 = Pt(s4, s4 = i3)), s4 >= 0 || i3 <= 0) return false;
  }
  let u, m3 = false, l2 = s3, c = 0;
  for (; c < 100; c++) {
    const t4 = n5.calcF(l2);
    if (u = n5.calcDF(l2), u.isZero()) return false;
    if (!t4.value() || c > 3 && t4.isZero()) {
      m3 = true;
      break;
    }
    r || (t4.value() < 0 ? o = l2 : a2 = l2);
    const e3 = t4.value() / u.value(), s4 = l2 - e3;
    r || (s4 >= o && s4 <= a2 || s4 >= a2 && s4 <= o) && Math.abs(e3) <= 0.5 * h2 ? (l2 = s4, h2 = Math.abs(e3)) : (h2 = Math.abs(0.5 * (a2 - o)), l2 = 0.5 * (o + a2));
  }
  return !!m3 && (i2.set(l2, n5.estimateError(l2)), true);
}
function yn(t3, e2, s3, n5, i2, r, o, a2) {
  return Pn(t3, e2, s3.value(), pn(n5, i2, r, o), a2, false);
}
var xn = class {
  constructor(t3, e2, s3) {
    this.coefs = Ot(p2, 3), this.coefs[0].setE(t3), this.coefs[1].setE(e2), this.coefs[2].setE(s3);
  }
  calcF(t3) {
    const e2 = new p2(t3);
    return this.coefs[0].mulE(e2).addE(this.coefs[1]).mulE(e2).addE(this.coefs[2]);
  }
  calcDF(t3) {
    const e2 = new p2(t3);
    return p2.st_mulByPower2(this.coefs[0], 2).mulE(e2).addE(this.coefs[1]);
  }
  estimateError(t3) {
    const e2 = Math.abs(t3), s3 = (this.coefs[0].eps() * e2 + this.coefs[1].eps()) * e2 + this.coefs[2].eps() + this.calcF(t3).eps(), n5 = new p2(2).mulE(this.coefs[0]).mul(t3).addE(this.coefs[1]);
    if (n5.isZero()) {
      const t4 = this.coefs[0].value();
      return Math.sqrt(s3 / Math.abs(t4));
    }
    return s3 / Math.abs(n5.value());
  }
};
function Cn(t3, e2, s3, n5, i2) {
  return Pn(0, 0, t3.value(), new xn(e2, s3, n5), i2, true);
}
function vn(t3, e2, s3, n5, i2, o) {
  const a2 = Ot(p2, 3);
  let h2 = 0;
  const u = e2.negate().divThisE(t3.clone().mulThis(3));
  i2.containsCoordinate(u.value()) && (a2[0].setE(u), h2 = 1);
  const m3 = Ot(p2, 2), l2 = gn(t3.mul(3), e2.mul(2), s3, i2, false, m3);
  if (l2 < 0) return n5.isZero() ? -1 : 0;
  for (let r = 0; r < l2; r++) i2.containsCoordinate(m3[r].value()) && a2[h2++].setE(m3[r]);
  Zt(a2, 0, h2, (t4, e3) => t4.value() < e3.value() ? -1 : t4.value() > e3.value() ? 1 : 0);
  const c = Ot(p2, 5);
  c[0].set(i2.vmin);
  for (let r = 0; r < h2; r++) c[1 + r].setE(a2[r]);
  c[1 + h2].set(i2.vmax);
  const g2 = h2 + 2;
  let d2 = 1, _ = 0;
  {
    const i3 = c[0].clone();
    if (t3.clone().mulThisE(i3).addThisE(e2).mulThisE(i3).addThisE(s3).mulThisE(i3).addThisE(n5).isZero()) {
      const r = pn(t3, e2, s3, n5);
      i3.setError(r.estimateError(i3.value())), o[_] = i3, _++, d2++;
    }
  }
  for (let p3 = d2; p3 < g2; p3++) {
    const a3 = c[p3].clone(), h3 = t3.clone().mulThisE(a3).addThisE(e2).mulThisE(a3).addThisE(s3).mulThisE(a3).addThisE(n5).isZero();
    if (h3 || !c[p3].eq(c[p3 - 1])) {
      if (h3 || yn(c[p3 - 1].value(), c[p3].value(), c[p3 - 1].clone().addThisE(c[p3]).divThisByPower2(2), t3, e2, s3, n5, a3)) {
        if (_ > 0 && a3.eq(o[_ - 1])) continue;
        if (_ >= 3 && b("cubic_polynomial_solver_too_many_roots"), h3) {
          const i3 = pn(t3, e2, s3, n5);
          a3.setError(i3.estimateError(a3.value()));
        }
        o[_] = a3, _++;
      }
      if (c[p3].value() === i2.vmax) break;
      h3 && p3++;
    }
  }
  return _;
}
function bn(t3, e2, s3, n5, i2, r) {
  const o = new fn(t3, e2, s3, Qs());
  let a2 = 0;
  if (2 === o.truePower) a2 = gn(t3[2], t3[1], t3[0], s3, n5, i2);
  else if (1 === o.truePower) a2 = cn(t3[1], t3[0], s3, i2[0]);
  else {
    if (0 === o.truePower) return t3[0].value() ? 0 : -1;
    {
      const t4 = [];
      t4.length = e2, a2 = tn(o, s3, e2, t4);
      for (let e3 = 0; e3 < a2; e3++) i2[e3].set(t4[e3]);
    }
  }
  for (let h2 = 0; h2 < a2; h2++) i2[h2].setError(o.getError(i2[h2].value()));
  return a2;
}
var En = z3;
var Sn = class _Sn extends gs {
  constructor(e2) {
    return void 0 === e2 || jt(e2, "vd") ? (super({ vd: e2?.vd, XStart: 0, YStart: 0, XEnd: 0, YEnd: 0 }), this.m_cp = new mi(0, 0), void (this.m_weights = [1, 0, 1])) : (e2.fromPoint && e2.weight ? e2 = { fromPoint: e2.fromPoint, controlPoint1: e2.controlPoint1, toPoint: e2.toPoint, weight0: 1, weight1: e2.weight, weight2: 1 } : e2.points && e2.weight ? e2 = { fromPoint: e2.points[0], controlPoint1: e2.points[1], toPoint: e2.points[2], weight0: 1, weight1: e2.weight, weight2: 1 } : e2.points && e2.weights && (e2 = { fromPoint: e2.points[0], controlPoint1: e2.points[1], toPoint: e2.points[2], weight0: e2.weights[0], weight1: e2.weights[1], weight2: e2.weights[2] }), e2.fromPoint && e2.weight0 ? (super({ start: e2.fromPoint, end: e2.toPoint }), (e2.weight0 <= 0 || e2.weight1 < 0 || e2.weight2 <= 0) && P("weights"), this.m_cp = e2.controlPoint1.clone(), void (this.m_weights = [e2.weight0, e2.weight1, e2.weight2])) : e2.copy ? (super(e2), this.m_cp = e2.copy.m_cp.clone(), void (this.m_weights = e2.copy.m_weights.slice())) : e2.move ? (super(e2), this.m_cp = e2.move.m_cp.clone(), void (this.m_weights = e2.move.m_weights.slice())) : void z("unexpected constructor param"));
  }
  getBoundary() {
    return Js2(this);
  }
  assignMove(t3) {
    return this;
  }
  assignCopy(t3) {
    return t3.copyTo(this), this;
  }
  construct(t3, e2, s3, n5) {
    this.dropAllAttributes(), this.setCpsAndWeights(t3, e2, s3, 1, n5, 1), la(this);
  }
  constructWeights(t3, e2, s3, n5, i2, r) {
    this.dropAllAttributes(), this.setCpsAndWeights(t3, e2, s3, n5, i2, r), la(this);
  }
  constructArray(t3, e2) {
    this.construct(t3[0], t3[1], t3[2], e2);
  }
  constructArrayWeights(t3, e2) {
    this.dropAllAttributes(), this.setCpsAndWeightsArray(t3, e2), la(this);
  }
  convertToStandardForm() {
  }
  getStandardFormWeight() {
    return this.m_weights[1] / Math.sqrt(this.m_weights[0] * this.m_weights[2]);
  }
  getGeometryType() {
    return a.enumRationalBezier2;
  }
  queryEnvelope(t3) {
    if (t3 instanceof n3) {
      if (t3.setCoords(this.getStartXY()), t3.mergeNe(this.getEndXY()), t3.contains(this.m_cp)) return;
      const e2 = Va(this);
      if (null !== e2) {
        const s3 = new mi();
        for (const n5 of e2.specialPoints) this.queryCoord2D(n5, s3), t3.mergeNe(s3);
      } else {
        const e3 = [], s3 = Ot(mi, 3);
        this.queryControlPoints(s3), da(s3, this.m_weights, e3);
        const n5 = new mi();
        for (const i2 of e3) this.queryCoord2D(i2, n5), t3.mergeNe(n5);
      }
    }
  }
  applyTransformation(t3) {
    if (t3 instanceof x3) {
      const e2 = Ot(mi, 3);
      return this.queryControlPoints(e2), t3.transformPoints2D(e2, 3, e2), this.setStartXY(e2[0]), this.m_cp.assign(e2[1]), this.setEndXY(e2[2]), void this.afterCompletedModification();
    }
  }
  createInstance() {
    return new _Sn({ vd: this.m_description });
  }
  calculateLength2D() {
    return _a(this, 1, false);
  }
  calculateLowerLength2D() {
    return mi.distance(this.getStartXY(), this.getEndXY());
  }
  calculateUpperLength2D() {
    return this.calculateUpperLength2D_();
  }
  calculateUpperLength2D_() {
    if (this.m_weights[1] > 0) {
      return mi.distance(this.getStartXY(), this.m_cp) + mi.distance(this.getEndXY(), this.m_cp);
    }
    return mi.distance(this.getStartXY(), this.getEndXY());
  }
  queryCoord2D(t3, e2) {
    return this.queryCoord2DExtension(t3, e2, true);
  }
  queryCoord2DE(t3, e2) {
    lh(this, t3, e2);
  }
  queryCoord2DExtension(t3, e2, s3) {
    if (s3) {
      if (t3 < 0) {
        return void _s2(new pm({ start: this.getStartXY(), end: this.getStartXY().add(this.getTangent(0).getUnitVector()) }), t3, e2);
      }
      if (t3 > 1) {
        return void _s2(new pm({ start: this.getEndXY(), end: this.getEndXY().add(this.getTangent(1).getUnitVector()) }), t3 - 1, e2);
      }
    }
    const n5 = Ot(mi, 3);
    this.queryControlPoints(n5), _h(n5, this.m_weights, t3, e2);
  }
  getCoordX(t3) {
    const e2 = new mi();
    return this.queryCoord2DExtension(t3, e2, true), e2.x;
  }
  getCoordY(t3) {
    const e2 = new mi();
    return this.queryCoord2DExtension(t3, e2, true), e2.y;
  }
  cut(t3, e2, s3) {
    const n5 = new fm();
    return this.queryCut(t3, e2, n5, s3), n5.releaseSegment();
  }
  queryCut(t3, e2, s3, n5) {
    const i2 = s3.createQuadraticRationalBezier();
    if (this.cutBezierIgnoreAttributes(t3, e2, i2), n5) return;
    i2.assignVertexDescription(this.m_description);
    const r = this.m_description.getAttributeCount();
    if (r > 1) {
      for (let e3 = 1; e3 < r; e3++) {
        const s4 = this.m_description.getSemantics(e3), n6 = En.getComponentCount(s4);
        for (let e4 = 0; e4 < n6; e4++) {
          const n7 = this.getAttributeAsDbl(t3, s4, e4);
          i2.setStartAttribute(s4, e4, n7);
        }
      }
      for (let t4 = 1; t4 < r; t4++) {
        const s4 = this.m_description.getSemantics(t4), n6 = En.getComponentCount(s4);
        for (let t5 = 0; t5 < n6; t5++) {
          const n7 = this.getAttributeAsDbl(e2, s4, t5);
          i2.setEndAttribute(s4, t5, n7);
        }
      }
    }
  }
  queryDerivative(t3, e2) {
    Sa(this, t3, e2);
  }
  cutBezierIgnoreAttributes(e2, s3, n5) {
    (e2 < 0 || s3 > 1 || e2 > s3) && P("Quadratic_rational_bezier.cut_bezier_ignore_attributes");
    const i2 = Ot(mi, 3);
    this.queryControlPoints(i2);
    const r = [0, 0, 0];
    Qa(i2, this.m_weights, e2, s3, i2, r), n5.setControlPointsAndWeights(i2, r);
  }
  splitBezierIgnoreAttributes(t3, e2, s3) {
  }
  getAttributeAsDbl(t3, e2, s3) {
    if (0 === e2) return 0 === s3 ? this.getCoordX(t3) : this.getCoordY(t3);
    const n5 = this.calculateLength2D(), i2 = n5 > 0 ? this.tToLength(t3) / n5 : 0, r = En.getInterpolation(e2), o = this.getStartAttributeAsDbl(e2, s3), a2 = this.getEndAttributeAsDbl(e2, s3);
    return It(r, o, a2, i2, En.getDefaultValue(e2));
  }
  getClosestCoordinate(t3, e2) {
    return Ra(this, t3, x2.unit(), e2, -1);
  }
  getClosestCoordinateOnInterval(t3, e2, s3 = -1) {
    return Ra(this, t3, e2, false, s3);
  }
  getYMonotonicParts(t3, e2) {
    return this.getMonotonicParts(t3, e2);
  }
  getMonotonicParts(e2, s3) {
    e2.length < 2 && P("");
    const i2 = ga(this);
    let r = 0;
    if (2 === i2.specialPointsCount()) return 0;
    n(e2.length >= i2.specialPointsCount() - 1);
    for (let t3 = 1, n5 = i2.specialPointsCount(); t3 < n5; ++t3) this.queryCut(i2.specialPoints[t3 - 1], i2.specialPoints[t3], e2[r], s3), r++;
    for (let t3 = 0; t3 < r; ++t3) {
      Za(e2[t3].get());
    }
    return r;
  }
  intersectionWithAxis2D(t3, e2, s3, n5) {
    s3 && (s3.length = 9), n5 && (n5.length = 9);
    const i2 = new Array(3), r = Ot(p2, 2), o = new x2(0, 1);
    let a2 = 0;
    const h2 = Ot(mi, 3);
    if (this.queryControlPoints(h2), t3) {
      if (i2[0] = new p2(h2[0].y).sub(e2).mul(this.m_weights[0]), i2[1] = new p2(h2[1].y).sub(e2).mul(this.m_weights[1]), i2[2] = i2[0].subE(i2[1].mul(2)).addE(new p2(h2[2].y).sub(e2).mul(this.m_weights[2])), i2[1] = i2[1].subE(i2[0]).mulThisByPower2(2), a2 = gn(i2[2], i2[1], i2[0], o, false, r), s3) for (let u = 0; u < a2; u++) s3[u] = this.getCoordX(r[u].value());
    } else if (i2[0] = new p2(h2[0].x).sub(e2).mul(this.m_weights[0]), i2[1] = new p2(h2[1].x).sub(e2).mul(this.m_weights[1]), i2[2] = i2[0].subE(i2[1].mul(2)).addE(new p2(h2[2].x).sub(e2).mul(this.m_weights[2])), i2[1] = i2[1].subE(i2[0]).mulThisByPower2(2), a2 = gn(i2[2], i2[1], i2[0], o, false, r), s3) for (let u = 0; u < a2; u++) s3[u] = this.getCoordY(r[u].value());
    if (n5) for (let u = 0; u < a2; u++) n5[u] = r[u].value();
    else s3 && Zt(s3, 0, a2, Ct);
    return a2;
  }
  intersectionOfYMonotonicWithAxisX(t3, e2) {
    if (this.m_YStart === this.m_YEnd) return t3 === this.m_YStart ? e2 : Number.NaN;
    if (t3 === this.m_YStart) return this.m_XStart;
    if (t3 === this.m_YEnd) return this.m_XEnd;
    const s3 = [Number.NaN, Number.NaN], i2 = this.intersectionWithAxis2D(true, t3, s3, null);
    return n(2 !== i2), -1 === i2 ? e2 : s3[0];
  }
  isCurve() {
    return true;
  }
  isDegenerate(t3) {
    return Te(this, t3);
  }
  isDegenerate3D(t3, e2) {
    return false;
  }
  queryLooseEnvelope(t3) {
    if (t3 instanceof n3) return t3.setCoords({ pt: this.getStartXY() }), t3.mergeNe(this.m_cp), void t3.mergeNe(this.getEndXY());
  }
  clone(t3) {
    const e2 = this.createInstance();
    return this.copyTo(e2), e2;
  }
  queryInterval(t3, e2) {
    if (0 === t3) {
      const t4 = n3.constructEmpty();
      this.queryEnvelope(t4);
      const s3 = x2.constructEmpty();
      return 0 === e2 ? t4.queryIntervalX(s3) : t4.queryIntervalY(s3), s3;
    }
    return super.queryInterval(t3, e2);
  }
  queryLooseEnvelopeOnInterval(t3, e2) {
    const s3 = Ot(mi, 3);
    this.queryControlPoints(s3);
    const n5 = [0, 0, 0];
    Qa(s3, this.m_weights, t3.vmin, t3.vmax, s3, n5), e2.setFromPoints(s3, 3);
  }
  changeEndPoints2D(t3, e2) {
    if (t3.isEqual(this.m_XStart, this.m_YStart) && e2.isEqual(this.m_XEnd, this.m_YEnd)) return;
    const s3 = this.m_cp.isEqual(this.m_XStart, this.m_YStart), n5 = this.m_cp.isEqual(this.m_XEnd, this.m_YEnd);
    this.setStartXY(t3), this.setEndXY(e2), s3 ? this.m_cp.setCoordsPoint2D(t3) : n5 && this.m_cp.setCoordsPoint2D(e2), this.normalizeAfterEndpointChange();
  }
  tToLength(t3) {
    return _a(this, t3, true);
  }
  lengthToT(t3) {
    return Ta(this, t3);
  }
  calculateWeightedAreaCentroid2D(t3) {
    const e2 = Na(this), s3 = Ia(this);
    return e2.x += (this.getStartX() - t3.x) * s3, e2.y += (this.getStartY() - t3.y) * s3, e2;
  }
  calculateWeightedCentroid2D() {
    const t3 = new mi();
    return this.isDegenerate(0) ? (t3.setCoords(0, 0), t3) : Fa(this) ? (t3.assign(this.getCoord2D(0.5).mul(this.calculateLength2D())), t3) : (t3.assign(Ua(this, 1)), t3);
  }
  getControlPoint1() {
    return this.m_cp.clone();
  }
  setControlPoint1(t3) {
    this.m_cp.setCoordsPoint2D(t3), this.afterCompletedModification();
  }
  queryWeights(t3) {
    for (let e2 = 0; e2 < 3; ++e2) t3[e2] = this.m_weights[e2];
  }
  queryCoord2DMP(t3, e2) {
    const s3 = Ot(mi, 3);
    return this.queryControlPoints(s3), gh(s3.map((t4) => Ee.constructPoint2D(t4)), this.m_weights.map((t4) => si.constructDouble(t4)), si.constructDouble(t3), e2);
  }
  setWeights(t3) {
  }
  queryControlPoints(t3) {
    t3[0].assign(this.getStartXY()), t3[1].assign(this.m_cp), t3[2].assign(this.getEndXY());
  }
  queryControlPointsHelper(t3) {
    return this.queryControlPoints(t3), 3;
  }
  setControlPointsAndWeights(t3, e2) {
    this.setCpsAndWeightsArray(t3, e2), this.afterCompletedModification();
  }
  getTangent(t3) {
    const e2 = Ot(mi, 3);
    return this.queryControlPoints(e2), wa(e2, this.m_weights, t3);
  }
  getDerivative(t3) {
    const e2 = Us(t3, 0, 1), s3 = Ot(mi, 4);
    return pa(this, 1, e2, s3), s3[1];
  }
  getCurvature(t3) {
    const e2 = Ot(mi, 4);
    pa(this, 2, t3, e2);
    const s3 = e2[1].sqrLength();
    if (0 === s3) return Number.NaN;
    e2[1].divThis(Math.sqrt(s3));
    return e2[1].crossProduct(e2[2]) / s3;
  }
  isIntersecting(t3, e2, s3) {
    return false;
  }
  isIntersectingPoint(t3, e2, s3) {
    return false;
  }
  isIntersectingPoint3D(t3, e2, s3, n5, i2 = 1) {
    return false;
  }
  isMonotoneQuickAndDirty() {
    const t3 = Ot(mi, 3);
    return this.queryControlPoints(t3), ja(t3);
  }
  getMonotonicPartParams(e2, s3) {
    const n5 = ga(this), i2 = n5.specialPointsCount();
    if (!s3) return n5.specialPointsCount();
    e2 < i2 && P("");
    for (let t3 = 0; t3 < i2; t3++) s3[t3] = n5.specialPoints[t3];
    return i2;
  }
  normalizeAfterEndpointChange() {
    return false;
  }
  orientBottomUp() {
    if (this.m_YEnd < this.m_YStart || this.m_YEnd === this.m_YStart && this.m_XEnd < this.m_XStart) {
      this.m_XEnd = Pt(this.m_XStart, this.m_XStart = this.m_XEnd), this.m_YEnd = Pt(this.m_YStart, this.m_YStart = this.m_YEnd), this.m_weights[2] = Pt(this.m_weights[0], this.m_weights[0] = this.m_weights[2]);
      for (let t3 = 0, e2 = this.m_description.getTotalComponentCount() - 2; t3 < e2; t3++) this.m_attributes[t3 + e2] = Pt(this.m_attributes[t3], this.m_attributes[t3] = this.m_attributes[t3 + e2]);
      this.m_cachedValues = null;
    }
  }
  isLine() {
    return false;
  }
  isDegenerateToLineHelper(t3) {
    const e2 = Ot(mi, 3);
    this.queryControlPoints(e2);
    const s3 = e2[2].sub(e2[0]), n5 = s3.length();
    if (mi.distance(e2[0], e2[1]) + mi.distance(e2[2], e2[1]) - n5 > t3) return false;
    const i2 = t3, r = e2[1].clone();
    r.subThis(e2[0]);
    return !(Math.abs(r.crossProduct(s3)) / n5 > i2);
  }
  copyIgnoreAttributes(t3) {
    const e2 = Ot(mi, 3);
    this.queryControlPoints(e2);
    const s3 = [0, 0, 0];
    this.queryWeights(s3), t3.setControlPointsAndWeights(e2, s3);
  }
  calculateArea2DHelper() {
    return Ia(this);
  }
  absNorm() {
    return this.getStartXY().norm(1) + this.getEndXY().norm(1) + this.m_cp.norm(1);
  }
  absNormXYZ(t3) {
    return n(0), 0;
  }
  queryEnvelopeW(t3, e2) {
    Ga(this, t3, e2);
  }
  setSegmentFromCoordsForStitcher(t3, e2) {
    const s3 = [0, 0, 0];
    this.queryWeights(s3), this.constructWeights(t3[0], this.getControlPoint1(), t3[e2 - 1], s3[0], s3[1], s3[2]);
  }
  writeInBufferStream(t3, e2) {
    const s3 = new Float64Array(5);
    return s3[0] = this.m_cp.x, s3[1] = this.m_cp.y, s3[2] = this.m_weights[0], s3[3] = this.m_weights[1], s3[4] = this.m_weights[2], t3.writeRangeFromArray(e2, s3.length, s3, true, 1), e2 + s3.length;
  }
  readFromBufferStream(t3, e2) {
    const s3 = new Float64Array(5);
    t3.queryRange(e2, s3.length, s3, true, 1), this.m_cp.x = s3[0], this.m_cp.y = s3[1], this.m_weights[0] = s3[2], this.m_weights[1] = s3[3], this.m_weights[2] = s3[4], this.m_cachedValues = null;
  }
  snapControlPoints(t3) {
    const e2 = Ot(mi, 3);
    this.queryControlPoints(e2);
    const s3 = mi.sqrDistance(e2[1], e2[0]), n5 = mi.sqrDistance(e2[1], e2[2]);
    let i2 = e2[0].clone(), r = s3;
    s3 > n5 && (i2 = e2[2].clone(), r = n5);
    let o = false;
    return r <= t3 && 0 !== r && (o = true, this.setControlPoint1(i2)), o;
  }
  needsSnapControlPoints(t3) {
    if (!t3) return false;
    const e2 = Ot(mi, 3);
    this.queryControlPoints(e2);
    const s3 = mi.sqrDistance(e2[1], e2[0]), n5 = mi.sqrDistance(e2[1], e2[2]);
    e2[0].clone();
    let i2 = s3;
    return s3 > n5 && (e2[2].clone(), i2 = n5), i2 <= t3 && 0 !== i2;
  }
  calculateSpecialPointsForCracking(t3, e2) {
    return 0;
  }
  ensureXYMonotone() {
    return Za(this);
  }
  setCoordsForIntersector(t3, e2, s3) {
    Ja(this, t3, e2, s3);
  }
  copyToImpl(t3) {
    const e2 = t3;
    e2.m_cp.setCoordsPoint2D(this.m_cp), e2.m_weights[0] = this.m_weights[0], e2.m_weights[1] = this.m_weights[1], e2.m_weights[2] = this.m_weights[2], La(e2, Va(this));
  }
  reverseImpl() {
    this.m_weights[2] = Pt(this.m_weights[0], this.m_weights[0] = this.m_weights[2]);
  }
  equalsImpl(t3) {
    const e2 = t3;
    if (!this.m_cp.equals(e2.m_cp)) return false;
    for (let s3 = 0; s3 < 3; s3++) if (this.m_weights[s3] !== e2.m_weights[s3]) return false;
    return true;
  }
  equalsImplTol(t3, e2) {
    const s3 = t3;
    if (!this.m_cp.isEqualPoint2D(s3.m_cp, e2)) return false;
    const n5 = Ot(mi, 3);
    this.queryControlPoints(n5);
    const i2 = Ot(mi, 3);
    s3.queryControlPoints(i2);
    const r = [s3.m_weights[0], s3.m_weights[1], s3.m_weights[2]];
    for (let o = 0; o < 3; o++) {
      const t4 = new X();
      t4.setCoordsPoint2DZ(n5[o].mul(this.m_weights[o]), this.m_weights[o]);
      const s4 = new X();
      if (s4.setCoordsPoint2DZ(i2[o].mul(r[o]), r[o]), !t4.isEqual(s4, e2)) return false;
    }
    return true;
  }
  swapImpl(t3) {
    const e2 = t3;
    e2.m_cp = Pt(this.m_cp, this.m_cp = e2.m_cp), e2.m_weights = Pt(this.m_weights, this.m_weights = e2.m_weights), ca(this, e2);
  }
  afterCompletedModification() {
    la(this);
  }
  intersect(t3, e2, s3, n5, i2) {
    return um(false, this, t3, e2, s3, n5, i2);
  }
  intersectPoint(t3, e2, s3) {
    return ka(this, t3, e2, s3);
  }
  endPointModified() {
    la(this);
  }
  clearEndPointModified() {
  }
  setCpsAndWeights(e2, s3, n5, i2, r, o) {
    (i2 <= 0 || o <= 0 || r < 0) && P("weights"), (e2.isNAN() || s3.isNAN() || n5.isNAN()) && P("NAN control points in bezier are not supported"), this.setStartXY(e2), this.m_cp.assign(s3), this.m_weights[0] = i2, this.m_weights[1] = r, this.m_weights[2] = o, this.setEndXY(n5);
  }
  setCpsAndWeightsArray(t3, e2) {
    this.setCpsAndWeights(t3[0], t3[1], t3[2], e2[0], e2[1], e2[2]);
  }
};
Sn.type = a.enumRationalBezier2;
var Dn = z3;
var wn = class _wn extends gs {
  constructor(t3) {
    void 0 === t3 || jt(t3, "vd") ? (super({ vd: t3?.vd, XStart: 0, YStart: 0, XEnd: 0, YEnd: 0 }), this.m_cp = new mi(0, 0)) : t3.from ? (super({ XStart: t3.from.x, YStart: t3.from.y, XEnd: t3.to.x, YEnd: t3.to.y, ...t3.vd }), this.m_cp = t3.cp.clone()) : t3.points ? (super({ XStart: t3.points[0].x, YStart: t3.points[0].y, XEnd: t3.points[2].x, YEnd: t3.points[2].y, ...t3.vd }), this.m_cp = t3.points[1].clone()) : t3.copy ? (super(t3), this.m_cp = t3.copy.m_cp.clone()) : b("unexpected constructor args");
  }
  getBoundary() {
    return Js2(this);
  }
  assignCopy(t3) {
    return this !== t3 && t3.copyTo(this), this;
  }
  construct(t3, e2, s3) {
    this.setStartXY(t3), this.m_cp.assign(e2), this.setEndXY(s3), ii2(this);
  }
  constructPoints(t3) {
    this.setStartXY(t3[0]), this.m_cp.assign(t3[1]), this.setEndXY(t3[2]), ii2(this);
  }
  getGeometryType() {
    return a.enumBezier2;
  }
  queryEnvelope(t3) {
    if (2 === t3.m_EnvelopeType) {
      if (t3.setCoords(this.getStartXY()), t3.mergeNe(this.getEndXY()), t3.contains(this.m_cp)) return;
      const e2 = yi(this);
      if (null !== e2) {
        const s3 = new mi();
        for (const n5 of e2.specialPoints) this.queryCoord2D(n5, s3), t3.mergeNe(s3);
      } else {
        const e3 = [];
        ai2(this, e3);
        const s3 = new mi();
        for (const n5 of e3) this.queryCoord2D(n5, s3), t3.mergeNe(s3);
      }
      return;
    }
    z("env type not impl");
  }
  applyTransformation(t3) {
    if (1 === t3.m_TransformationType) {
      const e2 = Ot(mi, 3);
      return this.queryControlPoints(e2), t3.transformPoints2D(e2, 3, e2), this.setStartXY(e2[0]), this.m_cp.assign(e2[1]), this.setEndXY(e2[2]), void this.afterCompletedModification();
    }
    n(0);
  }
  createInstance() {
    return new _wn({ vd: this.m_description });
  }
  calculateLength2D() {
    return hi2(this, 1, false);
  }
  calculateLowerLength2D() {
    return mi.distance(this.getStartXY(), this.getEndXY());
  }
  calculateUpperLength2D() {
    return this.calculateUpperLength2D_();
  }
  calculateUpperLength2D_() {
    return mi.distance(this.getStartXY(), this.m_cp) + mi.distance(this.getEndXY(), this.m_cp);
  }
  queryCoord2D(t3, e2) {
    this.queryCoord2DExtended(t3, e2, false);
  }
  queryCoord2DExtended(t3, e2, s3) {
    const n5 = Ot(mi, 3);
    this.queryControlPoints(n5), ji(n5, t3, e2, s3);
  }
  queryCoord2DE(t3, e2) {
    Zi(this, t3, e2);
  }
  queryCoord2DMP(t3, e2) {
    n(false, "bernstein polynomials not ported");
  }
  getCoordX(t3) {
    if (t3 < 0 || t3 > 1) {
      const e2 = new mi();
      return this.queryCoord2DExtended(t3, e2, true), e2.x;
    }
    if (t3 <= 0.5) {
      const e2 = V(this.getStartX(), this.m_cp.x, t3), s3 = V(this.m_cp.x, this.getEndX(), t3);
      return V(e2, s3, t3);
    }
    {
      const e2 = U2(this.getStartX(), this.m_cp.x, t3), s3 = U2(this.m_cp.x, this.getEndX(), t3);
      return U2(e2, s3, t3);
    }
  }
  getCoordY(t3) {
    if (t3 < 0 || t3 > 1) {
      const e2 = new mi();
      return this.queryCoord2DExtended(t3, e2, true), e2.y;
    }
    if (t3 <= 0.5) {
      const e2 = V(this.getStartX(), this.m_cp.x, t3), s3 = V(this.m_cp.x, this.getEndX(), t3);
      return V(e2, s3, t3);
    }
    {
      const e2 = U2(this.getStartY(), this.m_cp.y, t3), s3 = U2(this.m_cp.y, this.getEndY(), t3);
      return U2(e2, s3, t3);
    }
  }
  cut(t3, e2, s3) {
    const n5 = new fm();
    return this.queryCut(t3, e2, n5, s3), n5.releaseSegment();
  }
  queryCut(t3, e2, s3, n5) {
    const i2 = s3.createQuadraticBezier();
    if (this.cutBezierIgnoreAttributes(t3, e2, i2), n5) return;
    i2.assignVertexDescription(this.m_description);
    const r = this.m_description.getAttributeCount();
    if (r > 1) {
      for (let e3 = 1; e3 < r; e3++) {
        const s4 = this.m_description.getSemantics(e3), n6 = Dn.getComponentCount(s4);
        for (let e4 = 0; e4 < n6; e4++) {
          const n7 = this.getAttributeAsDbl(t3, s4, e4);
          i2.setStartAttribute(s4, e4, n7);
        }
      }
      for (let t4 = 1; t4 < r; t4++) {
        const s4 = this.m_description.getSemantics(t4), n6 = Dn.getComponentCount(s4);
        for (let t5 = 0; t5 < n6; t5++) {
          const n7 = this.getAttributeAsDbl(e2, s4, t5);
          i2.setEndAttribute(s4, t5, n7);
        }
      }
    }
  }
  queryDerivative(t3, e2) {
    Ui(this, t3, e2);
  }
  cutBezierIgnoreAttributes(e2, s3, n5) {
    if ((e2 < 0 || s3 > 1 || e2 > s3) && P("Quadratic_bezier.cut_bezier_ignore_attributes"), 0 === e2 && 1 === s3) return n5.setStartXY(this.getStartXY()), n5.m_cp.assign(this.m_cp), void n5.setEndXY(this.getEndXY());
    const i2 = Ot(mi, 3);
    this.queryControlPoints(i2), Mi(i2, e2, s3, i2), n5.constructPoints(i2);
  }
  splitBezierIgnoreAttributes(t3, e2, s3) {
    n(0);
  }
  getAttributeAsDbl(t3, e2, s3) {
    if (0 === e2) return 0 === s3 ? this.getCoordX(t3) : this.getCoordY(t3);
    const n5 = this.calculateLength2D(), i2 = n5 > 0 ? this.tToLength(t3) / n5 : 0, r = Dn.getInterpolation(e2), o = this.getStartAttributeAsDbl(e2, s3), a2 = this.getEndAttributeAsDbl(e2, s3);
    return It(r, o, a2, i2, Dn.getDefaultValue(e2));
  }
  getClosestCoordinate(t3, e2) {
    return Ci(this, t3, x2.unit(), e2);
  }
  getClosestCoordinateOnInterval(t3, e2, s3 = -1) {
    return Ci(this, t3, e2, false);
  }
  getYMonotonicParts(t3, e2) {
    return this.getMonotonicParts(t3, e2);
  }
  getMonotonicParts(e2, s3) {
    e2.length < 2 && P("");
    const i2 = oi2(this);
    let r = 0;
    if (2 === i2.specialPointsCount()) return 0;
    n(e2.length >= i2.specialPointsCount() - 1);
    for (let t3 = 1, n5 = i2.specialPointsCount(); t3 < n5; ++t3) this.queryCut(i2.specialPoints[t3 - 1], i2.specialPoints[t3], e2[r], s3), r++;
    for (let t3 = 0; t3 < r; ++t3) {
      wi(e2[t3].get());
    }
    return r;
  }
  intersectionWithAxis2D(t3, e2, s3, n5) {
    const i2 = Ot(p2, 3), r = Ot(p2, 2), o = new x2(0, 1);
    let a2 = 0;
    if (t3) {
      if (i2[0] = new p2(this.getStartY()).sub(e2), i2[1] = new p2(this.m_cp.y).subE(new p2(this.getStartY())).mulThisByPower2(2), i2[2] = new p2(this.getStartY()).add(this.getEndY()).subE(new p2(this.m_cp.y).mulThisByPower2(2)), a2 = gn(i2[2], i2[1], i2[0], o, false, r), s3) for (let h2 = 0; h2 < a2; h2++) s3[h2] = this.getCoordX(r[h2].value());
    } else if (i2[0] = new p2(this.getStartX()).sub(e2), i2[1] = new p2(this.m_cp.x).subE(new p2(this.getStartX())).mulThisByPower2(2), i2[2] = new p2(this.getStartX()).add(this.getEndX()).subE(new p2(this.m_cp.x).mulThisByPower2(2)), a2 = gn(i2[2], i2[1], i2[0], o, false, r), s3) for (let h2 = 0; h2 < a2; h2++) s3[h2] = this.getCoordY(r[h2].value());
    if (n5) for (let h2 = 0; h2 < a2; h2++) n5[h2] = r[h2].value();
    else s3 && zt(s3, a2);
    return a2;
  }
  intersectionOfYMonotonicWithAxisX(t3, e2) {
    if (this.m_YStart === this.m_YEnd) return t3 === this.m_YStart ? e2 : Number.NaN;
    if (t3 === this.m_YStart) return this.m_XStart;
    if (t3 === this.m_YEnd) return this.m_XEnd;
    const s3 = [0, 0], i2 = this.intersectionWithAxis2D(true, t3, s3, null);
    return n(2 !== i2), -1 === i2 ? e2 : s3[0];
  }
  isCurve() {
    return true;
  }
  isLine() {
    return false;
  }
  isDegenerate(t3) {
    return Te(this, t3);
  }
  isDegenerate3D(t3, e2) {
    return n(0), false;
  }
  queryLooseEnvelope(t3) {
    if (2 === t3.m_EnvelopeType) return t3.setCoords(this.getStartXY()), t3.mergeNe(this.m_cp), void t3.mergeNe(this.getEndXY());
    n(0);
  }
  clone(t3) {
    const e2 = this.createInstance();
    return this.copyTo(e2), e2;
  }
  queryInterval(t3, e2) {
    if (0 === t3) {
      const t4 = new n3();
      this.queryEnvelope(t4);
      const s3 = new x2();
      return 0 === e2 ? t4.queryIntervalX(s3) : t4.queryIntervalY(s3), s3;
    }
    return super.queryInterval(t3, e2);
  }
  queryLooseEnvelopeOnInterval(t3, e2) {
    const s3 = Ot(mi, 4);
    this.queryControlPoints(s3), Mi(s3, t3.vmin, t3.vmax, s3), e2.setFromPoints(s3, 4);
  }
  changeEndPoints2D(t3, e2) {
    if (t3.isEqual(this.m_XStart, this.m_YStart) && e2.isEqual(this.m_XEnd, this.m_YEnd)) return;
    const s3 = this.m_cp.isEqual(this.m_XStart, this.m_YStart), n5 = this.m_cp.isEqual(this.m_XEnd, this.m_YEnd);
    this.setStartXY(t3), this.setEndXY(e2), s3 ? this.m_cp.setCoordsPoint2D(t3) : n5 && this.m_cp.setCoordsPoint2D(e2), this.normalizeAfterEndpointChange();
  }
  tToLength(t3) {
    return hi2(this, t3, true);
  }
  lengthToT(t3) {
    return _i(this, t3);
  }
  calculateWeightedAreaCentroid2D(t3) {
    const e2 = Ot(mi, 3);
    Bi(this, e2);
    const s3 = e2[2], n5 = e2[1], i2 = new mi(), r = s3.y * n5.x - s3.x * n5.y;
    i2.x = -(4 * s3.x + 5 * n5.x) * r / 60, i2.y = -(4 * s3.y + 5 * n5.y) * r / 60;
    const o = pi(this);
    return i2.x += (e2[0].x - t3.x) * o, i2.y += (e2[0].y - t3.y) * o, i2;
  }
  calculateWeightedCentroid2D() {
    const t3 = new mi();
    return this.isDegenerate(0) ? (t3.setCoords(0, 0), t3) : Pi(this) ? (t3.assign(this.getCoord2D(0.5).mul(this.calculateLength2D())), t3) : (t3.assign(Ti(this, 1)), t3);
  }
  getControlPoint1() {
    return this.m_cp.clone();
  }
  setControlPoint1(t3) {
    this.m_cp.setCoordsPoint2D(t3), this.afterCompletedModification();
  }
  queryControlPoints(t3) {
    t3[0].assign(this.getStartXY()), t3[1].assign(this.m_cp), t3[2].assign(this.getEndXY());
  }
  queryControlPointsHelper(t3) {
    return this.queryControlPoints(t3), 3;
  }
  setControlPoints(e2) {
    for (let s3 = 0; s3 < 3; s3++) e2[s3].isNAN() && P("NaN control points in bezier are not supported");
    this.m_XStart = e2[0].x, this.m_YStart = e2[0].y, this.m_cp.setCoordsPoint2D(e2[1]), this.m_XEnd = e2[2].x, this.m_YEnd = e2[2].y, this.afterCompletedModification();
  }
  getTangent(t3) {
    const e2 = Us(t3, 0, 1);
    let s3 = ci(this, 1, e2);
    return s3.isZero() && (s3 = ci(this, 2, e2), 1 === e2 && s3.negateThis()), s3;
  }
  getDerivative(t3) {
    return ci(this, 1, Us(t3, 0, 1));
  }
  getCurvature(t3) {
    const e2 = ci(this, 1, t3), s3 = ci(this, 2, t3), n5 = e2.sqrLength();
    if (0 === n5) return Number.NaN;
    e2.divThis(Math.sqrt(n5));
    return e2.crossProduct(s3) / n5;
  }
  isIntersecting(t3, e2, s3) {
    return 0 !== rm(false, this, t3, e2, s3);
  }
  isIntersectingPoint(t3, e2, s3) {
    if (s3 && (t3.isEqualPoint2D(this.getStartXY()) || t3.isEqualPoint2D(this.getEndXY()))) return false;
    const n5 = new n3();
    if (this.queryLooseEnvelope(n5), n5.inflateCoords(e2, e2), !n5.contains(t3)) return false;
    const i2 = this.getClosestCoordinate(t3, false), r = new mi();
    this.queryCoord2D(i2, r);
    return mi.distance(r, t3) <= e2;
  }
  isIntersectingPoint3D(t3, e2, s3, i2, r = 1) {
    return n(0), false;
  }
  isMonotoneQuickAndDirty() {
    return false;
  }
  getMonotonicPartParams(e2, s3) {
    const n5 = oi2(this), i2 = n5.specialPointsCount();
    if (!s3) return n5.specialPointsCount();
    e2 < i2 && P("");
    for (let t3 = 0; t3 < i2; t3++) s3[t3] = n5.specialPoints[t3];
    return i2;
  }
  normalizeAfterEndpointChange() {
    return false;
  }
  orientBottomUp() {
    if (this.m_YEnd < this.m_YStart || this.m_YEnd === this.m_YStart && this.m_XEnd < this.m_XStart) {
      Pt(this.m_XStart, this.m_XStart = this.m_XEnd), Pt(this.m_YStart, this.m_YStart = this.m_YEnd);
      for (let t3 = 0, e2 = this.m_description.getTotalComponentCount() - 2; t3 < e2; t3++) this.m_attributes[t3 + e2] = Pt(this.m_attributes[t3], this.m_attributes[t3] = this.m_attributes[t3 + e2]);
      this.m_cachedValues = null;
    }
  }
  isDegenerateToLineHelper(t3) {
    const e2 = Ot(mi, 3);
    this.queryControlPoints(e2);
    const s3 = e2[2].sub(e2[0]), n5 = s3.length();
    if (mi.distance(e2[0], e2[1]) + mi.distance(e2[2], e2[1]) - n5 > t3) return false;
    const i2 = t3, r = e2[1].clone();
    r.subThis(e2[0]);
    return !(Math.abs(r.crossProduct(s3)) / n5 > i2);
  }
  copyIgnoreAttributes(t3) {
    const e2 = Ot(mi, 3);
    this.queryControlPoints(e2), t3.setControlPoints(e2);
  }
  calculateArea2DHelper() {
    return pi(this);
  }
  absNorm() {
    return Ni(this);
  }
  queryEnvelopeW(t3, e2) {
    const s3 = Ot(mi, 3);
    this.queryControlPoints(s3), Si(s3, t3, e2);
  }
  setSegmentFromCoordsForStitcher(t3, e2) {
    this.construct(t3[0], this.getControlPoint1(), t3[e2 - 1]);
  }
  snapControlPoints(t3) {
    return $i(this, t3);
  }
  writeInBufferStream(t3, e2) {
    const s3 = new Float64Array(2);
    return s3[0] = this.m_cp.x, s3[1] = this.m_cp.y, t3.writeRangeFromArray(e2, s3.length, s3, true, 1), e2 + s3.length;
  }
  readFromBufferStream(t3, e2) {
    const s3 = new Float64Array(2);
    t3.queryRange(e2, s3.length, s3, true, 1), this.m_cp.x = s3[0], this.m_cp.y = s3[1], this.m_cachedValues = null;
  }
  needsSnapControlPoints(t3) {
    return tr(this, t3);
  }
  calculateSpecialPointsForCracking(t3, e2) {
    return 0;
  }
  ensureXYMonotone() {
    return wi(this);
  }
  setCoordsForIntersector(t3, e2, s3) {
    Yi(this, t3, e2, s3);
  }
  copyToImpl(t3) {
    const e2 = t3;
    e2.m_cp.setCoordsPoint2D(this.m_cp), xi(e2, yi(this));
  }
  reverseImpl() {
  }
  equalsImplTol(t3, e2) {
    const s3 = t3;
    return !!this.m_cp.isEqualPoint2D(s3.m_cp, e2);
  }
  equalsImpl(t3) {
    const e2 = t3;
    return !!this.m_cp.equals(e2.m_cp);
  }
  swapImpl(t3) {
    const e2 = t3;
    e2.m_cp = Pt(this.m_cp, this.m_cp = e2.m_cp), ri(this, e2);
  }
  afterCompletedModification() {
    ii2(this);
  }
  intersect(t3, e2, s3, n5, i2) {
    return um(false, this, t3, e2, s3, n5, i2);
  }
  intersectPoint(t3, e2, s3) {
    return bi(this, t3, e2.length, e2, s3);
  }
  endPointModified() {
    ii2(this);
  }
  clearEndPointModified() {
  }
};
wn.type = a.enumBezier2;
var An = class {
  constructor(t3) {
    return t3.coefsT ? (this.m_zeroCtor = t3.zeroCtor, this.m_elements = t3.coefsT.map((t4) => t4.clone()), n(this.m_elements.length === t3.power + 1), void this.updatePower()) : t3.coef0 ? (this.m_zeroCtor = t3.zeroCtor, void (this.m_elements = [t3.coef0.clone()])) : t3.copy ? (this.m_zeroCtor = t3.copy.m_zeroCtor, void (this.m_elements = t3.copy.m_elements.map((t4) => t4.clone()))) : (this.m_zeroCtor = t3.zeroCtor, void (this.m_elements = [new this.m_zeroCtor()]));
  }
  construct(t3, e2) {
    return this.m_elements = t3.map((t4) => t4.clone()), this.updatePower(), this;
  }
  construct0(t3) {
    return this.m_elements.length = 0, this.m_elements.push(t3.clone()), this.updatePower(), this;
  }
  assignCopy(t3) {
    return this.m_elements = t3.m_elements.map((t4) => t4.clone()), this.updatePower(), this;
  }
  assignMove(t3) {
    return this.m_elements = t3.m_elements, t3.m_elements = [], this.updatePower(), this;
  }
  power() {
    return this.m_elements.length - 1;
  }
  addElement(t3) {
    this.m_elements.push(t3.clone());
  }
  scaleRangeToUnitInterval(t3, e2) {
    const s3 = e2;
    s3.subThis(t3);
    const n5 = this.power();
    for (let i2 = 0; i2 <= n5; i2++) {
      const e3 = new this.m_zeroCtor();
      for (let s4 = i2; s4 <= n5; s4++) {
        const n6 = this.m_elements[s4];
        n6.mulDoubleThis(gt(s4, i2));
        const r2 = t3.pow(s4 - i2);
        n6.mulThis(r2), e3.addThis(n6);
      }
      const r = s3.pow(i2);
      e3.mulThis(r), this.m_elements[i2] = e3;
    }
  }
  fmSubThis(t3, e2) {
    return n(0), this;
  }
  addThis(t3) {
    const e2 = Math.min(this.power(), t3.power());
    for (let n5 = 0; n5 <= e2; ++n5) this.m_elements[n5].addThis(t3.m_elements[n5]);
    const s3 = t3.power();
    this.m_elements.length = Math.max(this.power(), t3.power()) + 1;
    for (let n5 = e2 + 1; n5 <= s3; ++n5) this.m_elements[n5] = t3.m_elements[n5];
    return this.updatePower(), this;
  }
  add0(t3) {
    return this.m_elements[0].addThis(t3), this.updatePower(), this;
  }
  addNumber0(t3) {
    return n(0), this;
  }
  sub(t3) {
    const e2 = Math.min(this.power(), t3.power());
    for (let n5 = 0; n5 <= e2; ++n5) this.m_elements[n5].subThis(t3.m_elements[n5]);
    const s3 = t3.power();
    this.m_elements.length = Math.max(this.power(), t3.power()) + 1;
    for (let n5 = e2 + 1; n5 <= s3; ++n5) this.m_elements[n5] = t3.m_elements[n5].clone(), this.m_elements[n5].negateThis();
    return this.updatePower(), this;
  }
  sub0(t3) {
    return n(0), this;
  }
  subNumber0(t3) {
    return n(0), this;
  }
  subShifted(t3, e2) {
    const s3 = this.power(), n5 = t3.power() + e2, i2 = Math.min(this.power(), n5);
    let r = 0;
    for (let o = e2; o <= i2; ++o) this.m_elements[o].subThis(t3.m_elements[r]), r++;
    if (n5 <= s3) return this.updatePower(), this;
    this.m_elements.length = n5 + 1;
    for (let o = s3 + 1; o < this.m_elements.length; ++o) this.m_elements[o] = new this.m_zeroCtor();
    for (let o = i2 + 1; o <= n5; ++o) this.m_elements[o].subThis(t3.m_elements[r++]);
    return this.updatePower(), this;
  }
  subShiftedWithCoef(t3, e2, s3) {
    const n5 = this.power(), i2 = t3.power() + s3, r = Math.min(this.power(), i2);
    let o = 0;
    for (let a2 = s3; a2 <= r; ++a2) this.m_elements[a2].fmSubThis(t3.m_elements[o], e2), o++;
    if (i2 <= n5) return this.updatePower(), this;
    this.m_elements.length = i2 + 1;
    for (let a2 = n5 + 1; a2 < this.m_elements.length; ++a2) this.m_elements[a2] = new this.m_zeroCtor();
    for (let a2 = r + 1; a2 <= i2; ++a2) this.m_elements[a2].fmSubThis(t3.m_elements[o++], e2);
    return this.updatePower(), this;
  }
  mulThis(t3) {
    if (this.constructor === t3.constructor) {
      const e2 = t3, s3 = [];
      for (let t4 = 0, n5 = this.power(); t4 <= n5; t4++) for (let i2 = 0, r = e2.power(); i2 <= r; i2++) {
        const n6 = this.m_elements[t4].clone();
        n6.mulThis(e2.m_elements[i2]), t4 + i2 < s3.length ? s3[t4 + i2].addThis(n6) : s3.push(n6);
      }
      this.m_elements = s3;
    } else for (let e2 = 0, s3 = this.power(); e2 <= s3; e2++) this.m_elements[e2].mulThis(t3);
    return this.updatePower(), this;
  }
  mulElementThis(t3) {
    for (let e2 = 0, s3 = this.power(); e2 <= s3; e2++) this.m_elements[e2].mulThis(t3);
    return this.updatePower(), this;
  }
  mulDoubleThis(t3) {
    for (let e2 = 0, s3 = this.power(); e2 <= s3; e2++) this.m_elements[e2].mulDoubleThis(t3);
    return this.updatePower(), this;
  }
  mulNumber0(t3) {
    return n(0), this;
  }
  mulBigint0(t3) {
    return n(0), this;
  }
  mulBigIntThis(t3) {
    return n(0), this;
  }
  mulInt320(t3) {
    return n(0), this;
  }
  div0(t3) {
    return n(0), this;
  }
  absThis() {
    return n(0), this;
  }
  div(t3, e2, s3) {
    if (this.power() < t3.power()) return s3.assignCopy(this), void e2.setZero();
    s3.setZero(), e2.setZero();
    const n5 = t3.getElement(t3.power()), i2 = this.clone();
    let r = i2.power();
    const o = i2.power() - t3.power();
    let a2 = o;
    for (e2.m_elements = Ot(e2.m_zeroCtor, o + 1); ; ) {
      if (r < t3.power()) {
        s3.assignMove(i2);
        break;
      }
      if (r === i2.power()) {
        const s4 = i2.getElement(i2.power());
        s4.divThis(n5), i2.subShiftedWithCoef(t3, s4, i2.power() - t3.power()), e2.m_elements[a2] = s4.clone();
      }
      a2--, r--;
    }
    s3.updatePower(), e2.updatePower();
  }
  divThis(t3) {
    return n(0), this;
  }
  subThis(t3) {
    const e2 = Math.min(this.power(), t3.power());
    for (let n5 = 0; n5 <= e2; ++n5) this.m_elements[n5].subThis(t3.m_elements[n5]);
    const s3 = t3.power();
    this.m_elements.length = Math.max(this.power(), t3.power()) + 1;
    for (let n5 = e2 + 1; n5 <= s3; ++n5) this.m_elements[n5] = t3.m_elements[n5].clone(), this.m_elements[n5].negateThis();
    return this.updatePower(), this;
  }
  sub0This(t3) {
    return this.m_elements[0].subThis(t3), this.updatePower(), this;
  }
  subFrom(t3, e2) {
    n(0);
  }
  isZero() {
    return 0 === this.power() && this.m_elements[0].isZero();
  }
  negateThis() {
    for (let t3 = this.m_elements.length - 1; t3 >= 0; t3--) this.m_elements[t3].negateThis();
    return this;
  }
  getElement(t3) {
    return this.m_elements[t3].clone();
  }
  setElement(t3, e2) {
    return this.m_elements[t3] = e2.clone(), this;
  }
  evaluate(t3) {
    const e2 = this.power(), s3 = this.m_elements[e2].clone();
    for (let n5 = e2 - 1; n5 >= 0; --n5) s3.mulThis(t3), s3.addThis(this.m_elements[n5]);
    return s3;
  }
  equals(t3) {
    if (this === t3) return true;
    if (this.power() !== t3.power()) return false;
    for (let e2 = this.m_elements.length - 1; e2 >= 0; e2--) if (!this.m_elements[e2].equals(t3.m_elements[e2])) return false;
    return true;
  }
  updatePower() {
    for (let t3 = this.m_elements.length - 1; t3 > 0 && this.m_elements[t3].isZero(); t3--) this.m_elements.pop();
    return this;
  }
  setZero() {
    return this.m_elements.length = 1, this.m_elements[0] = new this.m_zeroCtor(), this.updatePower(), this;
  }
  derivative(t3) {
    if (this.power() < t3) return this.clone().setZero();
    if (0 === t3) return this.clone();
    const e2 = new this.constructor({ coefsT: this.m_elements.slice(t3), power: this.power() - t3 });
    for (let s3 = t3, n5 = this.power(); s3 <= n5; s3++) {
      let n6 = BigInt(s3);
      for (let e3 = s3 - 1, i2 = s3 - t3; e3 > i2; --e3) n6 *= BigInt(e3);
      e2.m_elements[s3 - t3].mulBigIntThis(n6);
    }
    return e2.updatePower(), e2;
  }
  derivative1This() {
    if (this.m_elements.length > 1) {
      this.m_elements = this.m_elements.slice(1);
      for (let t3 = 1, e2 = this.power(); t3 <= e2; t3++) this.m_elements[t3].mulThis(si.constructInt32(t3 + 1));
    } else this.m_elements.length = 0, this.m_elements.push(new this.m_zeroCtor());
    return this;
  }
  limitPrecisionThis(t3) {
    for (let e2 = this.power(); e2 >= 0; --e2) this.m_elements[e2].limitPrecisionThis(t3);
    return this.updatePower(), this;
  }
  hiBitIndex() {
    return this.m_elements.reduce((t3, e2) => {
      const s3 = e2.hiBitIndex();
      return t3 < s3 ? s3 : t3;
    }, 0);
  }
  shiftRight(t3) {
    return this.m_elements.splice(0, t3), this.updatePower(), this;
  }
  evaluateDerivative(t3) {
    const e2 = this.power(), s3 = this.m_elements[e2];
    s3.mulDoubleThis(e2);
    for (let n5 = e2 - 1; n5 >= 1; --n5) {
      s3.mulThis(t3);
      const e3 = this.m_elements[n5];
      e3.mulDoubleThis(n5), s3.addThis(e3);
    }
    return s3;
  }
  static evaluateCoefs(t3, e2, s3) {
    const n5 = t3.power();
    s3.construct0(t3.getElement(0).evaluate(e2));
    for (let i2 = 1; i2 <= n5; ++i2) s3.addElement(t3.getElement(i2).evaluate(e2));
    s3.updatePower();
  }
};
var Tn = class _Tn extends An {
  constructor(t3) {
    super(void 0 === t3 ? { zeroCtor: si } : { ...t3, zeroCtor: si });
  }
  clone() {
    return new _Tn({ copy: this });
  }
  absEvaluate(t3) {
    const e2 = this.power(), s3 = this.m_elements[e2].clone();
    s3.absThis();
    const n5 = t3.clone();
    n5.absThis();
    for (let i2 = e2 - 1; i2 >= 0; --i2) s3.mulThis(n5), s3.addThis(this.m_elements[i2].abs());
    return s3;
  }
};
var In = class _In extends An {
  constructor(t3) {
    super(void 0 === t3 ? { zeroCtor: Tn } : { ...t3, zeroCtor: Tn });
  }
  clone() {
    return new _In({ copy: this });
  }
  constructFromMPValues(t3, e2) {
    this.m_elements.length = 0;
    for (let s3 = 0; s3 <= e2; ++s3) this.m_elements.push(new Tn({ coef0: t3[s3] }));
    return this.updatePower(), this;
  }
};
function Mn() {
  return { polypoly1: new In(), polypoly2: new In(), polyX2: new Tn(), polyY2: new Tn(), polyX2Deriv: new Tn(), polyY2Deriv: new Tn(), polypolyX1: new In(), polypolyY1: new In(), polypolyX1Deriv: new In(), polypolyY1Deriv: new In(), lazyPolypolyD1: new In(), lazyPolypolyD1Deriv: new In(), lazyPolyD2: new Tn(), lazyPolyD2Deriv: null, polypoly11: new In(), polypoly12: new In(), tempPp: new In(), tempPp1: new In(), tempPp2: new In(), tempP: new Tn(), tempP1: new Tn(), tempP2: new Tn() };
}
function Yn(t3, e2, s3, i2, o, a2, h2, u, m3, l2, c, g2, d2, _, p3, f3, P5, y2, x4, C3 = false) {
  const v3 = Mn();
  v3.polyX2.construct(h2, u), v3.polyY2.construct(m3, l2), v3.polypolyX1.constructFromMPValues(t3, e2), v3.polypolyY1.constructFromMPValues(s3, i2), v3.polypoly11.assignCopy(v3.polypolyX1), v3.polypoly12.assignCopy(v3.polypolyY1), c && (v3.lazyPolyD2.construct(c, g2), v3.polypoly11.mulElementThis(v3.lazyPolyD2), v3.polypoly12.mulElementThis(v3.lazyPolyD2)), o ? (v3.lazyPolypolyD1.constructFromMPValues(o, a2), v3.lazyPolypolyD1Deriv = new In({ copy: v3.lazyPolypolyD1 }), v3.lazyPolypolyD1Deriv.derivative1This(), v3.tempPp.assignCopy(v3.lazyPolypolyD1), v3.tempPp.mulElementThis(v3.polyX2), v3.polypoly11.subThis(v3.tempPp), v3.tempPp.assignCopy(v3.lazyPolypolyD1), v3.tempPp.mulElementThis(v3.polyY2), v3.polypoly12.subThis(v3.tempPp)) : (v3.polypoly11.sub0This(v3.polyX2), v3.polypoly12.sub0This(v3.polyY2)), v3.polypolyX1Deriv.assignCopy(v3.polypolyX1), v3.polypolyX1Deriv.derivative1This(), v3.polypolyY1Deriv.assignCopy(v3.polypolyY1), v3.polypolyY1Deriv.derivative1This(), o && (v3.polypolyX1Deriv.mulThis(v3.lazyPolypolyD1), v3.tempPp2.assignCopy(v3.lazyPolypolyD1Deriv), v3.tempPp2.mulThis(v3.polypolyX1), v3.polypolyX1Deriv.subThis(v3.tempPp2), v3.polypolyY1Deriv.mulThis(v3.lazyPolypolyD1), v3.tempPp2.assignCopy(v3.lazyPolypolyD1Deriv), v3.tempPp2.mulThis(v3.polypolyY1), v3.polypolyY1Deriv.subThis(v3.tempPp2)), v3.polyX2Deriv.assignCopy(v3.polyX2), v3.polyX2Deriv.derivative1This(), v3.polyY2Deriv.assignCopy(v3.polyY2), v3.polyY2Deriv.derivative1This(), c && (n(null === v3.lazyPolyD2Deriv), v3.lazyPolyD2Deriv = new Tn({ copy: v3.lazyPolyD2 }), v3.lazyPolyD2Deriv.derivative1This(), v3.polyX2Deriv.mulThis(v3.lazyPolyD2), v3.tempP1.assignCopy(v3.lazyPolyD2Deriv), v3.tempP1.mulThis(v3.polyX2), v3.polyX2Deriv.subThis(v3.tempP1), v3.polyY2Deriv.mulThis(v3.lazyPolyD2), v3.tempP1.assignCopy(v3.lazyPolyD2Deriv), v3.tempP1.mulThis(v3.polyY2), v3.polyY2Deriv.subThis(v3.tempP1)), v3.polypoly1.assignCopy(v3.polypoly11), v3.polypoly1.mulElementThis(v3.polyX2Deriv), v3.tempPp.assignCopy(v3.polypoly12), v3.tempPp.mulElementThis(v3.polyY2Deriv), v3.polypoly1.addThis(v3.tempPp), v3.polypoly2.assignCopy(v3.polypolyX1Deriv), v3.polypoly2.mulElementThis(v3.polyY2Deriv), v3.tempPp.assignCopy(v3.polypolyY1Deriv), v3.tempPp.mulElementThis(v3.polyX2Deriv), v3.polypoly2.subThis(v3.tempPp);
  let b2 = [];
  const E2 = [];
  P5 || (P5 = []), f3 || (f3 = []), kn(v3.polypoly11, v3.polypoly12, v3.tempP);
  const S3 = 64, D3 = ii.ldexp(-59).toDouble(), w4 = [];
  let A4 = Gn(v3.tempP, d2, p3, D3, S3, w4, y2, y2);
  if (A4 < 0) return -1;
  for (let Y3 = 0; Y3 < A4; Y3++) {
    const t4 = v3.tempP1, e3 = v3.tempP2;
    Tn.evaluateCoefs(v3.polypoly11, w4[Y3], t4);
    const s4 = Et(t4.m_elements, t4.power() + 1);
    s4.sort((t5, e4) => t5.compare(e4)), Tn.evaluateCoefs(v3.polypoly12, w4[Y3], e3);
    const i3 = Et(e3.m_elements, e3.power() + 1);
    i3.sort((t5, e4) => t5.compare(e4));
    const o2 = s4[0], a3 = s4.at(-1), h3 = i3[0], u2 = i3.at(-1);
    a3.subThis(o2), u2.subThis(h3);
    const m4 = a3.subThis(u2).GEZ(), l3 = 58, c2 = ii.ldexp(-59).toDouble(), g3 = [];
    let p4;
    if (p4 = Gn(m4 ? t4 : e3, d2, _, c2, l3, g3, y2, y2), p4 < 0 && b("mp_curve_proximity"), p4 > 0) {
      const s5 = m4 ? e3 : t4;
      for (let t5 = 0; t5 < p4; t5++) {
        let e4;
        if (m4) {
          const s6 = v3.tempP;
          Tn.evaluateCoefs(v3.polypoly12, w4[Y3].addDouble(Number.EPSILON), s6), e4 = s6.evaluate(g3[t5]);
        } else {
          const s6 = v3.tempP;
          Tn.evaluateCoefs(v3.polypoly11, w4[Y3].addDouble(Number.EPSILON), s6), e4 = s6.evaluate(g3[t5]);
        }
        const i4 = s5.evaluateDerivative(g3[t5]).abs().mulDoubleThis(Number.EPSILON), r = s5.evaluate(g3[t5]);
        i4.addThis(e4.sub(r).absThis()), i4.ldexpThis(3), r.absThis(), r.lt(i4) ? E2.push($t(g3[t5].toDouble(), w4[Y3].toDouble())) : n(r.gte(i4));
      }
    }
  }
  A4 = E2.length, kn(v3.polypoly1, v3.polypoly2, v3.tempP);
  const T3 = [];
  let I4 = Gn(v3.tempP, d2, p3, D3, S3, T3);
  I4 < 0 && (I4 = 0);
  for (let n5 = 0; n5 < I4; n5++) {
    Tn.evaluateCoefs(v3.polypoly1, T3[n5], v3.tempP1);
    const t4 = [];
    let e3 = Gn(v3.tempP1, d2, _, D3, S3, t4);
    if (0 !== e3) if (Tn.evaluateCoefs(v3.polypoly2, T3[n5], v3.tempP2), e3 < 0) {
      if (e3 = Gn(v3.tempP2, d2, _, D3, S3, t4), e3 < 0) continue;
      for (let s4 = 0; s4 < e3; s4++) b2.push($t(t4[s4].toDouble(), T3[n5].toDouble()));
    } else {
      const s4 = v3.tempP2.absEvaluate(ii);
      s4.mulThis(si.constructDouble(1e-12));
      for (let i3 = 0; i3 < e3; i3++) {
        const e4 = v3.tempP2.evaluate(t4[i3]);
        e4.absThis(), e4.lt(s4) && b2.push($t(t4[i3].toDouble(), T3[n5].toDouble()));
      }
    }
  }
  if (I4 = b2.length, 0 === A4 && 0 === I4) return 0;
  b2 = b2.concat(E2), b2.sort((t4, e3) => C3 ? Ct(t4.second, e3.second) : Ct(t4.first, e3.first));
  const M2 = Bt(b2, (t4, e3) => t4.first === e3.first && t4.second === e3.second);
  b2 = b2.slice(0, M2), f3.length = 0, P5.length = 0;
  for (const n5 of b2) f3.push(n5.first), P5.push(n5.second);
  return n(f3.length === P5.length), P5.length;
}
function Nn(t3, e2, s3, n5, i2, r, o) {
  if (0 === t3.power()) return t3.isZero() ? -1 : 0;
  const a2 = t3.evaluate(si.constructInt32(1)).isZero();
  if (1 === t3.power()) {
    const s4 = Fn(t3.getElement(1), t3.getElement(0), e2, r.at(0));
    return r[0].limitPrecisionThis(n5), 1 !== s4 ? 0 : (r[0].limitPrecisionThis(n5), 1);
  }
  if (2 === t3.power()) {
    return Vn(t3.getElement(2), t3.getElement(1), t3.getElement(0), n5, e2, a2, r);
  }
  if (3 === t3.power()) {
    return Ln(t3.getElement(3), t3.getElement(2), t3.getElement(1), t3.getElement(0), n5, e2, a2, r);
  }
  if (4 === t3.power()) {
    return Rn(t3.getElement(4), t3.getElement(3), t3.getElement(2), t3.getElement(1), t3.getElement(0), n5, e2, a2, r);
  }
  return Un(t3, e2, s3, n5, a2, i2, r, o);
}
function Xn() {
  return { polyIntersect: new Tn(), polyX1: new Tn(), polyY1: new Tn(), polyX1Deriv: new Tn(), polyY1Deriv: new Tn(), lazyPolyD1: new Tn(), lazyPolyD1Deriv: new Tn(), tempP: new Tn(), tempP1: new Tn(), tempP2: new Tn(), polypoly1Proximity: new In(), polypoly2Proximity: new In() };
}
function qn(t3, e2, s3, n5, i2, r, o, a2, h2, u, m3, l2, c) {
  const g2 = Xn();
  g2.polyX1.construct(t3, e2), g2.polyY1.construct(s3, n5), g2.polyX1Deriv.assignCopy(g2.polyX1), g2.polyX1Deriv.derivative1This(), g2.polyY1Deriv.assignCopy(g2.polyY1), g2.polyY1Deriv.derivative1This(), g2.polyIntersect.assignCopy(g2.polyX1), g2.polyIntersect.mulThis(g2.polyX1), g2.polyIntersect.mulElementThis(o[0]), g2.tempP.assignCopy(g2.polyY1), g2.tempP.mulThis(g2.polyY1), g2.tempP.mulElementThis(o[1]), g2.polyIntersect.addThis(g2.tempP), i2 ? (g2.lazyPolyD1.construct(i2, r), g2.tempP.assignCopy(g2.lazyPolyD1), g2.tempP.mulThis(g2.lazyPolyD1), g2.tempP.mulElementThis(o[2]), g2.polyIntersect.addThis(g2.tempP)) : g2.polyIntersect.add0(o[2]);
  {
    const i3 = o[0].clone(), r2 = i3.clone();
    r2.sqrThis();
    const a3 = o[1].clone(), h3 = a3.clone();
    h3.sqrThis();
    const u2 = o[2].clone(), m4 = i3.clone();
    m4.subThis(a3), g2.polyX1.construct(t3, e2), g2.polyX1Deriv.assignCopy(g2.polyX1), g2.polyX1Deriv.derivative1This(), g2.polyY1.construct(s3, n5), g2.polyY1Deriv.assignCopy(g2.polyY1), g2.polyY1Deriv.derivative1This(), g2.tempP.assignCopy(g2.polyX1), g2.tempP.mulThis(g2.polyX1), g2.tempP.mulElementThis(h3), g2.tempP.mulElementThis(u2), g2.polypoly1Proximity.construct0(g2.tempP), g2.tempP.assignCopy(g2.polyX1), g2.tempP.mulThis(a3.mul(m4).mul(u2).ldexpThis(1)), g2.polypoly1Proximity.addElement(g2.tempP), g2.tempP.assignCopy(g2.polyX1), g2.tempP.mulThis(g2.polyX1), g2.tempP.mulElementThis(i3.mul(h3)), g2.tempP1.assignCopy(g2.polyY1), g2.tempP1.mulThis(g2.polyY1), g2.tempP1.mulElementThis(r2.mul(a3)), g2.tempP.addThis(g2.tempP1), g2.tempP.add0(m4.mul(m4).mul(u2)), g2.polypoly1Proximity.addElement(g2.tempP), g2.tempP.assignCopy(g2.polyX1), g2.tempP.mulElementThis(m4.mul(i3).mul(a3).ldexpThis(1)), g2.polypoly1Proximity.addElement(g2.tempP), g2.tempP.construct0(i3.mul(m4).mul(m4)), g2.polypoly1Proximity.addElement(g2.tempP), g2.polypoly1Proximity.updatePower(), g2.tempP.construct0(ei), g2.polypoly2Proximity.construct0(g2.tempP), g2.tempP.assignCopy(g2.polyX1), g2.tempP.mulThis(g2.polyX1Deriv), g2.tempP1.assignCopy(g2.polyY1), g2.tempP1.mulThis(g2.polyY1Deriv), g2.tempP.addThis(g2.tempP1), g2.tempP.mulElementThis(i3.mul(a3)), g2.polypoly2Proximity.addElement(g2.tempP), g2.tempP.assignCopy(g2.polyX1Deriv), g2.tempP.mulElementThis(m4.mul(i3)), g2.polypoly2Proximity.addElement(g2.tempP), g2.polypoly2Proximity.updatePower();
  }
  const d2 = [], _ = [];
  null === m3 && (m3 = []);
  let p3 = 2 * g2.polyIntersect.power() + 58;
  const f3 = 0.5 * Number.EPSILON, P5 = [], y2 = Gn(g2.polyIntersect, a2, h2, f3, p3, P5, l2, l2);
  if (y2 < 0) return -1;
  for (const b2 of P5) _.push(b2.toDouble());
  kn(g2.polypoly1Proximity, g2.polypoly2Proximity, g2.tempP), p3 = 2 * g2.tempP.power() + 58, P5.length = 0;
  let x4 = Gn(g2.tempP, a2, h2, f3, p3, P5);
  if (x4 < 0 && (x4 = 0), 0 === y2 && 0 === x4) return 0;
  for (const b2 of P5) d2.push(b2.toDouble());
  const C3 = d2.concat(_);
  m3.length = C3.length, Dt(m3, C3, 0, 0, C3.length), qt(m3);
  const v3 = Bt(m3, (t4, e3) => 0 === Ct(t4, e3));
  return m3.length = v3, m3.length;
}
function Fn(t3, e2, s3, n5) {
  return t3.isZero() ? e2.isZero() ? -1 : 0 : (n5.setThis(e2), n5.negateThis(), n5.divThis(t3), s3.isEmpty() || s3.containsCoordinate(n5.value()) ? 1 : 0);
}
function Vn(t3, e2, s3, n5, i2, r, o) {
  if (t3.isZero()) {
    if (r) return o[0].setInt32(1), i2.containsCoordinate(1) ? 1 : 0;
    return Fn(e2, s3, i2, o[0]);
  }
  if (r) {
    let e3 = 2;
    return o[0].setInt32(1), s3.equals(t3) ? (o[1].setInt32(1), e3 = 1) : o[1].setThis(s3.div(t3)), i2.containsCoordinate(o[1].value()) || (e3 = 1), i2.containsCoordinate(o[0].value()) || (e3--, o[0].setThis(o[1])), 2 === e3 && o[0].value() > o[1].value() && (o[1] = Pt(o[0], o[0] = o[1])), e3;
  }
  const a2 = e2.clone();
  a2.sqrThis();
  const h2 = t3.clone();
  if (h2.mulThis(s3).ldexpThis(2).negateThis().addThis(a2), h2.LZ()) return 0;
  const u = n5 + 2, m3 = si.sqrt(h2, u), l2 = m3.clone();
  e2.LZ() && l2.negateThis(), l2.addThis(e2).limitPrecisionThis(u).ldexpThis(-1).negateThis();
  let c = 0;
  return o[0].setThis(l2).divThis(si.constructAssign(t3, u)).limitPrecisionThis(n5), (i2.isEmpty() || i2.containsCoordinate(o[0].value())) && c++, m3.isZero() || l2.isZero() || (o[c].setThis(s3).divThis(l2).limitPrecisionThis(n5), (i2.isEmpty() || i2.containsCoordinate(o[c].value())) && c++, 2 === c && o[0].gt(o[1]) && (o[1] = Pt(o[0], o[0] = o[1]))), c;
}
function Ln(t3, e2, s3, i2, r, o, a2, h2) {
  if (t3.isZero()) {
    return Vn(e2, s3, i2, r, o, a2, h2);
  }
  const u = (t4, e3) => {
    if (t4 > 0) {
      let s4 = e3 + t4;
      for (let t5 = 1; t5 < s4; t5++) h2[t5].equals(h2[0]) && (h2[s4 - 1] = Pt(h2[t5], h2[t5] = h2[s4 - 1]), s4--);
      e3 = s4;
    }
    return Zt(h2, 0, e3, (t5, e4) => t5.compare(e4)), e3;
  };
  if (i2.isZero()) {
    let n5 = 0;
    o.containsCoordinate(0) && (h2[0].setInt32(0), n5 = 1);
    return u(Vn(t3, e2, s3, r, o, a2, h2.slice(1)), n5);
  }
  if (a2) {
    let s4 = 0;
    o.containsCoordinate(1) && (h2[0].setInt32(1), s4 = 1);
    const n5 = e2.add(t3), a3 = i2.negate(), m4 = t3.add(n5).add(a3).isZero();
    return u(Vn(t3, n5, a3, r, o, m4, h2.slice(s4)), s4);
  }
  const m3 = new si(), l2 = new si(), c = new si(), g2 = e2.clone();
  if (g2.isZero()) l2.setThis(s3), l2.divThis(t3), c.setThis(i2), c.divThis(t3);
  else {
    g2.divThis(t3).divDoubleThis(3).negateThis();
    const n5 = e2.clone();
    n5.sqrThis();
    const r2 = t3.clone();
    r2.sqrThis(), l2.setThis(t3), l2.mulThis(s3).mulDoubleThis(3).subThis(n5).divThis(r2).divDoubleThis(3), c.setThis(n5), c.mulThis(e2), c.ldexpThis(1), m3.setThis(t3), m3.mulThis(e2).mulThis(s3).mulDoubleThis(9), c.subThis(m3), m3.setThis(r2), m3.mulThis(i2).mulDoubleThis(27), c.addThis(m3), c.divThis(r2).divThis(t3).divDoubleThis(27);
  }
  if (l2.isZero()) {
    const t4 = c.clone();
    return t4.negateThis(), t4.isZero() ? (h2[0].setThis(g2), Qn(o, r, h2, 1)) : (h2[0].setThis(si.cubicRoot(t4, r).add(g2)), Qn(o, r, h2, 1));
  }
  const d2 = c.clone();
  if (d2.sqrThis().ldexpThis(-2), m3.setThis(l2.clone()), m3.sqrThis().mulThis(l2).divDoubleThis(27), d2.addThis(m3), d2.isZero()) return h2[0].setThis(c), h2[0].mulDoubleThis(3).divThis(l2), h2[1].setThis(h2[0]), h2[1].negateThis(), h2[1].ldexpThis(-1), h2[0].addThis(g2), h2[1].addThis(g2), Qn(o, r, h2, 2);
  if (d2.GZ()) return d2.setThis(si.sqrt(d2, r + 8)), m3.setThis(c), m3.ldexpThis(-1).negateThis(), m3.addThis(d2), h2[0].setThis(si.cubicRoot(m3, r + 8)), m3.setThis(c), m3.ldexpThis(-1).negateThis(), m3.subThis(d2), h2[0].addThis(si.cubicRoot(m3, r + 8)), h2[0].addThis(g2), Qn(o, r, h2, 1);
  m3.setThis(l2), m3.divDoubleThis(3).negateThis(), n(m3.GEZ());
  const _ = si.sqrt(m3, r + 8), p3 = _.clone();
  p3.negateThis(), p3.addThis(g2), _.addThis(g2);
  const f3 = si.constructDouble(o.isEmpty() ? -Number.MAX_VALUE : o.vmin), P5 = si.constructDouble(o.isEmpty() ? Number.MAX_VALUE : o.vmax), y2 = new Tn({ zeroCtor: si });
  y2.construct0(i2), y2.addElement(s3), y2.addElement(e2), y2.addElement(t3);
  const x4 = new Tn({ copy: y2 });
  x4.derivative1This();
  let C3 = 0;
  const v3 = Ot(si, 4);
  v3[C3++].setThis(f3), p3.gt(f3) && p3.lt(P5) && v3[C3++].setThis(p3), _.gt(f3) && _.lt(P5) && v3[C3++].setThis(_), v3[C3++].setThis(P5);
  const b2 = 3 * r;
  let E2 = 52, S3 = Number.EPSILON;
  for (; E2 < b2; ) 2 * E2 <= b2 ? (S3 *= S3, E2 *= 2) : (S3 *= Number.EPSILON, E2 += 52);
  E2 += 2;
  let D3 = 0, w4 = false;
  for (let n5 = 1; n5 < C3; n5++) {
    if (Zn(y2, x4, v3[n5 - 1], v3[n5], S3, E2, h2[0])) {
      D3 = 1, w4 = n5 + 1 < C3;
      break;
    }
  }
  if (!D3) return 0;
  if (w4) {
    const t4 = new Tn({ zeroCtor: si, coef0: h2[0] });
    t4.negateThis(), t4.addElement(ii);
    const e3 = new Tn({ zeroCtor: si }), s4 = new Tn({ zeroCtor: si });
    y2.div(t4, e3, s4), n(2 === e3.power()), n(0 === s4.power());
    const i3 = Vn(e3.getElement(2), e3.getElement(1), e3.getElement(0), r, o, false, h2.slice(1));
    n(i3 >= 0 && i3 <= 2), D3 += i3;
  }
  return Qn(o, r, h2, D3);
}
function Rn(t3, e2, s3, n5, i2, r, o, a2, h2) {
  if (t3.isZero()) return Ln(e2, s3, n5, i2, r, o, a2, h2);
  const u = (t4, e3) => {
    if (t4 > 0) {
      let s4 = e3 + t4;
      for (let t5 = 1; t5 < s4; t5++) h2[t5].equals(h2[0]) && (h2[s4 - 1] = Pt(h2[t5], h2[t5] = h2[s4 - 1]), s4--);
      e3 = s4;
    }
    return Zt(h2, 0, e3, (t5, e4) => t5.compare(e4)), e3;
  };
  if (i2.isZero()) {
    let i3 = 0;
    o.containsCoordinate(0) && (h2[0].setInt32(0), i3 = 1);
    return u(Ln(t3, e2, s3, n5, r, o, a2, h2.slice(i3)), i3);
  }
  const m3 = new Tn({ zeroCtor: si, coef0: i2 });
  if (m3.addElement(n5), m3.addElement(s3), m3.addElement(e2), m3.addElement(t3), a2) {
    let t4 = 0;
    o.containsCoordinate(1) && (h2[0].setInt32(1), t4 = 1);
    const e3 = new Tn({ zeroCtor: si, coef0: si.constructInt32(-1) });
    e3.addElement(si.constructInt32(1));
    const s4 = new Tn({ zeroCtor: si }), n6 = new Tn({ zeroCtor: si });
    m3.div(e3, s4, n6);
    return u(Ln(3 === s4.power() ? s4.getElement(3) : ei.clone(), s4.power() >= 2 ? s4.getElement(2) : ei.clone(), s4.power() >= 1 ? s4.getElement(1) : ei.clone(), s4.getElement(0), r, o, s4.evaluate(ii).isZero(), h2.slice(t4)), t4);
  }
  if (m3.getElement(0).isZero()) {
    let t4 = 0;
    for (o.containsCoordinate(0) && (t4 = 1, h2[0].setDouble(0)); m3.getElement(0).isZero() && m3.power() > 0; ) m3.shiftRight(1);
    const e3 = Ln(3 === m3.power() ? m3.getElement(3) : ei.clone(), m3.power() >= 2 ? m3.getElement(2) : ei.clone(), m3.power() >= 1 ? m3.getElement(1) : ei.clone(), m3.getElement(0), r, o, false, h2.slice(t4));
    return e3 > 0 && (t4 += e3), Zt(h2, 0, t4, (t5, e4) => t5.compare(e4)), t4;
  }
  let l2 = 52, c = Number.EPSILON;
  for (; l2 < r; ) 2 * l2 <= r ? (c *= c, l2 *= 2) : (c *= Number.EPSILON, l2 += 52);
  l2 += 2;
  const g2 = On(m3), d2 = si.constructDouble(Math.max(Math.abs(o.vmax), Math.abs(o.vmin)));
  return c = (g2.lt(d2) ? g2 : d2).mul(si.constructDouble(c)).toDouble(), Un(m3, o, c, l2, a2, false, h2, 4);
}
function zn(t3, e2) {
  let s3 = t3, n5 = e2;
  n5.power() > s3.power() && (n5 = Pt(s3, s3 = n5));
  const i2 = s3.power() - n5.power(), r = new Tn({ copy: s3.getElement(s3.power()) });
  s3.mulThis(n5.getElement(n5.power()));
  for (let o = 0, a2 = s3.power(); o < a2; o++) if (o >= i2) {
    const t4 = new Tn({ copy: n5.getElement(o - i2) });
    t4.mulThis(r);
    const e3 = s3.getElement(o).sub(t4);
    s3.setElement(o, e3);
  }
  s3.setElement(s3.power(), s3.getElement(s3.power()).setZero()), s3.updatePower(), Bn(s3);
}
function Bn(t3) {
  let e2 = 0;
  for (; e2 < t3.power() && t3.getElement(e2).isZero(); ) e2++;
  return e2 > 0 && (t3.shiftRight(e2), true);
}
function kn(t3, e2, s3) {
  const n5 = t3.clone(), i2 = e2.clone();
  for (Bn(n5), Bn(i2); 0 !== n5.power() || 0 !== i2.power(); ) zn(n5, i2);
  s3.assignMove(n5.getElement(0));
}
function Gn(t3, e2, s3, n5, i2, r, o = false, a2 = false) {
  r.length = 0;
  const h2 = t3.power(), u = Ot(si, 2 * h2 + 4), m3 = Nn(t3, s3 || x2.unit(), n5, i2, false, u, u.length);
  if (m3 > 0) {
    r.length = 0;
    for (let t4 = 0; t4 < m3; t4++) {
      const e3 = u[t4];
      t4 > 0 && e3.lte(r.at(-1)) || r.push(e3.clone());
    }
    return r.length;
  }
  return m3;
}
function Wn(t3, e2, s3) {
  if (n(s3 >= 1), 0 === t3.power()) return t3.isZero() ? -1 : 0;
  const i2 = t3.getElement(0);
  return i2.negateThis(), i2.divThis(t3.getElement(1)), e2[0].setThis(i2), 1;
}
function jn(t3, e2, s3, i2) {
  if (t3.power() < 2) return Wn(t3, s3, i2);
  n(i2 >= 1);
  let r = t3.getElement(1);
  r.mulThis(t3.getElement(1));
  const o = t3.getElement(0);
  if (o.mulThis(t3.getElement(2)), o.ldexpThis(2), r.subThis(o), r.LZ()) return 0;
  if (r.isZero()) {
    const n5 = t3.getElement(1);
    return n5.negateThis(), n5.divThis(t3.getElement(2)), n5.ldexpThis(-1), n5.limitPrecisionThis(e2), s3[0].setThis(n5), 1;
  }
  n(i2 >= 2), r = si.sqrt(r, e2 + 8);
  const a2 = t3.getElement(1);
  a2.negateThis();
  const h2 = a2.clone();
  h2.subThis(r), h2.divThis(t3.getElement(2)), h2.ldexpThis(-1), h2.limitPrecisionThis(e2);
  const u = a2.clone();
  return u.addThis(r), u.divThis(t3.getElement(2)), u.ldexpThis(-1), u.limitPrecisionThis(e2), h2.lt(u) ? (s3[0].setThis(h2), s3[1].setThis(u)) : (s3[1].setThis(h2), s3[0].setThis(u)), 2;
}
function Zn(t3, e2, s3, n5, i2, o, a2) {
  let h2 = s3.clone(), u = n5.clone();
  h2.limitPrecisionThis(o), u.limitPrecisionThis(o);
  let m3 = t3.evaluate(h2);
  m3.limitPrecisionThis(o + 2);
  let l2 = t3.evaluate(u);
  if (l2.limitPrecisionThis(o + 2), m3.GEZ() && l2.GEZ() || m3.LEZ() && l2.LEZ()) return m3.absLessAbs(l2) ? (a2 = h2, m3.isZero()) : (a2 = u, l2.isZero());
  const c = l2.LZ();
  c && (l2 = Pt(m3, m3 = l2), u = Pt(h2, h2 = u));
  const g2 = c ? u : h2, d2 = c ? h2 : u, _ = h2.add(u).ldexpThis(-1);
  _.limitPrecisionThis(o);
  const p3 = u.sub(h2);
  p3.limitPrecisionThis(o), p3.absThis();
  const f3 = p3.clone();
  let P5 = t3.evaluate(_), y2 = e2.evaluate(_);
  const x4 = new Tn({ copy: t3 }), C3 = new Tn({ copy: e2 });
  {
    const s4 = Math.max(t3.hiBitIndex(), e2.hiBitIndex()), n6 = ii.clone();
    n6.ldexpThis(-(o + 2));
    for (let i3 = 64; i3 < s4; ) {
      x4.limitPrecisionThis(i3), C3.limitPrecisionThis(i3);
      const r = x4.evaluate(_), o2 = C3.evaluate(_), a3 = r.sub(P5), h3 = o2.sub(y2);
      if (a3.divThis(P5).absThis().lt(n6) && (y2.isZero() || h3.divThis(y2).absThis().lt(n6))) break;
      x4.assignCopy(t3), C3.assignCopy(e2), i3 = Math.min(i3 + 64, s4);
    }
    P5.limitPrecisionThis(o + 2), y2.limitPrecisionThis(o + 2);
  }
  const v3 = 1, b2 = 4;
  let E2 = b2;
  const S3 = 2;
  let D3 = 1, w4 = 0, A4 = 0, T3 = v3;
  const I4 = 32, M2 = si.constructDouble(0.25 * i2), Y3 = si.constructDouble(0.5001);
  let N2 = 0;
  const X3 = 300;
  for (; ++N2 < X3; ) {
    if (N2 > I4 && w4 > 0 || y2.isZero() || T3 === S3 && w4 > 1 || T3 === v3 && E2 < b2) T3 = v3, D3 > 1 && D3--;
    else if (T3 = S3, A4 > 1) {
      const t5 = p3.mul(y2);
      t5.absThis(), t5.ldexpThis(-3), t5.absLessAbs(P5) && D3++;
    }
    p3.setThis(f3);
    const t4 = new si();
    let e3 = false;
    if (T3 === v3) do {
      if (A4 > 2) {
        const e4 = p3.clone();
        if (e4.absThis(), e4.ldexpThis(4), d2.sub(g2).ldexpThis(-1).gt(e4)) {
          if (_.equals(g2)) {
            t4.setThis(_), _.setThis(g2.add(e4)), _.limitPrecisionThis(o), f3.setThis(_.sub(t4));
            break;
          }
          if (_.equals(d2)) {
            t4.setThis(_), _.setThis(d2.sub(e4)), _.limitPrecisionThis(o), f3.setThis(_.sub(t4));
            break;
          }
        }
      }
      f3.setThis(u.sub(h2)), f3.ldexpThis(-1), f3.limitPrecisionThis(o), t4.setThis(_), _.setThis(h2.add(f3)), _.limitPrecisionThis(o), _.lt(g2) ? _.setThis(g2) : _.gt(d2) && _.setThis(d2), e3 = h2.equals(_) || u.equals(_);
    } while (0);
    else for (; ; ) {
      if (f3.setThis(P5.div(y2)), f3.limitPrecisionThis(o), 1 !== D3 && f3.mulDoubleThis(D3), t4.setThis(_), _.subThis(f3), _.limitPrecisionThis(o), e3 = _.equals(t4), _.lt(g2)) {
        if (D3 > 1) {
          _.setThis(t4), D3--;
          continue;
        }
        f3.setThis(t4.sub(g2)), _.setThis(g2);
      } else if (_.gt(d2)) {
        if (D3 > 1) {
          _.setThis(t4), D3--;
          continue;
        }
        f3.setThis(t4.sub(d2)), _.setThis(d2);
      }
      break;
    }
    if (e3 || f3.absLessAbs(M2)) {
      t4.equals(_) || (P5 = x4.evaluate(_), P5.limitPrecisionThis(o + 2));
      break;
    }
    P5 = x4.evaluate(_), P5.limitPrecisionThis(o + 2), y2 = C3.evaluate(_), y2.limitPrecisionThis(o + 2);
    const s4 = h2.clone(), n6 = u.clone();
    P5.LZ() ? (m3.setThis(P5), h2.setThis(_)) : (l2.setThis(P5), u.setThis(_)), T3 === S3 && (h2.equals(s4) && u.equals(n6) || A4 > 1 && !f3.absLessAbs(Y3.mul(p3))) ? w4++ : w4 = 0, T3 === v3 ? (E2++, A4 = 0) : (E2 = 0, A4++);
  }
  return N2 >= X3 && b("Root_finder iterations exceeded"), a2.setThis(_), true;
}
function Hn(t3, e2, s3, n5, i2) {
  const r = t3.evaluate(s3);
  if (r.isZero()) return true;
  const o = si.constructDouble(0.5 * n5), a2 = s3.clone();
  a2.subThis(o);
  const h2 = t3.evaluate(a2), u = s3.clone();
  u.addThis(o);
  const m3 = t3.evaluate(u);
  if (h2.LZ() && m3.GZ() || h2.GZ() && m3.LZ()) return true;
  if (r.GZ() ? h2.LEZ() || m3.LEZ() : h2.GEZ() || m3.GEZ()) return true;
  const l2 = h2.LEZ() && m3.LEZ(), c = h2.GEZ() && m3.GEZ();
  let g2 = false;
  return l2 ? r.gt(h2) && r.gt(m3) && (g2 = true) : c && r.lt(h2) && r.lt(m3) && (g2 = true), !!g2 && r.absThis().lt(si.constructDouble(1e-17));
}
function Un(t3, e2, s3, i2, r, o, a2, h2) {
  n(s3 > 0), n(h2 >= t3.power());
  const u = a2, m3 = [];
  let l2 = [];
  const c = new Tn({ zeroCtor: t3.m_zeroCtor }), g2 = new Tn({ zeroCtor: t3.m_zeroCtor }), d2 = new Tn({ zeroCtor: t3.m_zeroCtor }), _ = si.constructDouble(s3), p3 = si.constructDouble(e2.vmin), f3 = si.constructDouble(e2.vmax), P5 = p3.sub(_), y2 = f3.add(_), x4 = On(t3), C3 = x4.clone();
  if (C3.negateThis(), P5.lt(C3)) P5.setThis(C3.sub(_));
  else if (P5.gt(x4)) return 0;
  if (y2.gt(x4)) y2.setThis(x4.add(_));
  else if (y2.lt(C3)) return 0;
  let v3 = t3, b2 = null;
  if (r) {
    const e3 = new Tn({ coef0: si.constructInt32(-1) });
    e3.addElement(ii), b2 = new Tn(), v3 = b2;
    const s4 = new Tn(), n5 = new Tn();
    for (t3.div(e3, s4, n5), b2.assignCopy(s4); v3.evaluate(ii).isZero(); ) v3.div(e3, s4, n5), b2.assignCopy(s4);
  }
  let E2 = false;
  if (v3.power() > 0 && v3.getElement(0).isZero()) for (E2 = true, b2 || (b2 = new Tn({ copy: v3 }), v3 = b2); v3.getElement(0).isZero(); ) b2.shiftRight(1);
  let S3 = i2 + 2 * v3.power() + 2, D3 = s3 / Math.pow(2, v3.power() + 2), w4 = S3;
  if (ei.gt(P5) && ei.lt(y2)) {
    for (let n5 = 0, Y3 = v3.power(); n5 < Y3; n5++) if (v3.getElement(n5).isZero()) {
      m3.push(ei.clone());
      break;
    }
  }
  for (let Y3 = v3.power() - 1; Y3 > 0; Y3--) {
    if (D3 *= 2, S3 -= 2, w4 -= 2, v3.power() - Y3 === 1) {
      g2.assignMove(v3.derivative(Y3));
      1 === Wn(g2, u, h2) && (u[0].gt(P5) && u[0].lt(y2) && !u[0].isZero() && m3.push(u[0].clone()), c.assignMove(g2), d2.assignMove(v3.derivative(Y3 - 1)));
      continue;
    }
    if (v3.power() - Y3 === 2) {
      g2.assignMove(v3.derivative(Y3));
      const t4 = jn(g2, S3, u, h2);
      n(t4 >= 0 && t4 <= 2);
      for (let e3 = 0; e3 < t4; e3++) u[e3].gt(P5) && u[e3].lt(y2) && !u[e3].isZero() && m3.push(u[e3].clone());
      if (m3.length > 1 && m3.sort((t5, e3) => t5.compare(e3)), m3.length > 0) {
        let t5 = m3[0].sub(_);
        t5.limitPrecisionThis(w4), l2.push($t(P5.clone(), t5));
        let e3 = 1 === m3.length ? y2.clone() : m3[1].sub(_);
        t5 = m3[0].add(_), t5.limitPrecisionThis(w4), e3.limitPrecisionThis(w4), l2.push($t(t5, e3)), m3.length > 1 && (e3 = 2 === m3.length ? y2.clone() : m3[2].sub(_), e3.limitPrecisionThis(w4), t5 = m3[1].add(_), t5.limitPrecisionThis(w4), l2.push($t(t5, e3)), m3.length > 2 && (t5 = m3[2].add(_), t5.limitPrecisionThis(w4), l2.push($t(t5, y2.clone()))));
      } else l2.push($t(P5.clone(), y2.clone()));
      c.assignCopy(g2), d2.assignMove(v3.derivative(Y3 - 1));
      continue;
    }
    {
      g2.assignMove(d2), d2.assignMove(v3.derivative(Y3 - 1));
      let t4 = [];
      for (let e3 = 0, s4 = l2.length; e3 < s4; ++e3) if (l2[e3].first.lte(l2[e3].second)) {
        const s5 = new si();
        if (Zn(g2, c, l2[e3].first, l2[e3].second, D3, S3, s5)) {
          m3.push(s5);
          let n5 = s5.sub(_);
          n5.limitPrecisionThis(w4), t4.push($t(l2[e3].first, n5)), n5 = s5.add(_), n5.limitPrecisionThis(w4), t4.push($t(n5, l2[e3].second));
        } else t4.push(l2[e3]);
      }
      l2 = t4, t4 = [], c.assignMove(g2);
    }
  }
  m3.sort((t4, e3) => t4.compare(e3)), 0 === l2.length && (c.assignMove(v3.derivative(v3.power())), c.isZero() || l2.push($t(P5.clone(), y2.clone())));
  let A4 = 0, T3 = 0, I4 = 0;
  const M2 = new si();
  for (; ; ) {
    if (T3 < l2.length) {
      if (l2[T3].first.gt(l2[T3].second)) {
        T3++;
        continue;
      }
      let t4 = false;
      if (I4 < m3.length && m3[I4].lt(l2[T3].first) && (t4 = true), !t4) {
        Zn(v3, c, l2[T3].first, l2[T3].second, s3, i2, M2) && (M2.lt(p3) ? u[A4++].setThis(p3) : M2.gt(f3) ? u[A4++].setThis(f3) : u[A4++].setThis(M2)), T3++;
        continue;
      }
    }
    if (!(I4 < m3.length)) break;
    0 !== I4 && m3[I4 - 1].equals(m3[I4]) || Hn(v3, c, m3[I4], s3) && (M2.setThis(m3[I4]), M2.lt(p3) ? M2.setThis(p3) : M2.gt(f3) && M2.setThis(f3), 0 !== A4 && u[A4].equals(M2) || u[A4++].setThis(M2)), I4++;
  }
  return E2 && ei.gt(P5) && ei.lt(y2) && (u[A4++].setThis(ei), Zt(u, 0, A4, (t4, e3) => t4.compare(e3))), r && ii.gt(P5) && ii.lt(y2) && (u[A4++].setThis(ii), Zt(u, 0, A4, (t4, e3) => t4.compare(e3))), A4;
}
function On(t3) {
  const e2 = t3.getElement(t3.power());
  e2.limitPrecisionThis(53), e2.absThis();
  const s3 = ei.clone();
  for (let n5 = 0, i2 = t3.power(); n5 < i2; n5++) {
    const e3 = t3.getElement(n5);
    e3.limitPrecisionThis(53), e3.gt(s3) && s3.setThis(e3);
  }
  return s3.divThis(e2), s3.addThis(ii), s3.mulThis(si.constructDouble(1 + 100 * Number.EPSILON)), s3;
}
function Qn(t3, e2, s3, n5) {
  let i2 = n5;
  if (!t3.isEmpty()) {
    i2 = 0;
    for (let e3 = 0; e3 < n5; ++e3) t3.containsCoordinate(s3[e3].value()) && (i2 !== e3 && s3[i2].setThis(s3[e3]), i2++);
  }
  i2 > 1 && (s3[0].gt(s3[1]) && (s3[1] = Pt(s3[0], s3[0] = s3[1])), i2 > 2 && (s3[0].gt(s3[2]) && (s3[2] = Pt(s3[0], s3[0] = s3[2])), s3[1].gt(s3[2]) && (s3[2] = Pt(s3[1], s3[1] = s3[2]))));
  for (let r = 0; r < i2; ++r) s3[r].limitPrecisionThis(e2);
  return i2;
}
function Kn(t3, e2, s3, n5, i2, r) {
  return ti(t3, e2, s3, r, n5, i2);
}
function Jn(t3, e2, s3, n5, i2, r) {
  let o = i2;
  if (n5) return r[0] = 1, o = 0.5 * (e2 - t3) * (s3(t3) + s3(e2)), o;
  const a2 = r[0], h2 = (e2 - t3) / a2, u = t3, m3 = new n2(0);
  for (let l2 = 1; l2 <= r[0]; ++l2) {
    const t4 = (l2 - 0.5) * h2;
    m3.add(s3(u + t4));
  }
  return o = 0.5 * (o + (e2 - t3) * m3.getResult() / a2), r[0] *= 2, o;
}
function $n(t3, e2, s3, n5, i2, r, o) {
  let a2 = 0, h2 = Math.abs(i2 - s3[t3]);
  const u = Yt(e2, Number.NaN), m3 = Yt(e2, Number.NaN);
  for (let d2 = 0; d2 < e2; ++d2) {
    const e3 = Math.abs(i2 - s3[t3 + d2]);
    e3 < h2 && (a2 = d2, h2 = e3), u[d2] = n5[t3 + d2], m3[d2] = n5[t3 + d2];
  }
  let l2 = 0, c = 0, g2 = 0;
  r[0] = n5[t3 + a2], a2--;
  for (let d2 = 1; d2 < e2; d2++) {
    for (let n6 = 0; n6 < e2 - d2; n6++) {
      if (c = s3[t3 + n6] - i2, g2 = s3[t3 + n6 + d2] - i2, l2 = c - g2, 0 === l2) return false;
      const e3 = (u[n6 + 1] - m3[n6]) / l2;
      u[n6] = c * e3, m3[n6] = g2 * e3;
    }
    if (2 * (a2 + 1) < e2 - d2) {
      const t4 = a2 + 1;
      o[0] = u[t4];
    } else {
      const t4 = a2;
      o[0] = m3[t4], a2--;
    }
    r[0] += o[0];
  }
  return true;
}
function ti(e2, s3, n5, i2, o, a2) {
  if (n5 < s3 && P("xTo < xFrom"), n5 === s3) return 0;
  const h2 = [0];
  let u = Number.MAX_VALUE;
  const m3 = [Number.MAX_VALUE];
  let l2 = 0;
  const c = 32, g2 = Yt(c + 1, Number.NaN), d2 = Yt(c + 1, Number.NaN), _ = [0];
  g2[0] = 1;
  let p3 = 0, f3 = 0;
  for (let t3 = 0; t3 < c; t3++) {
    if (l2 = Jn(s3, n5, i2, 0 === t3, l2, _), d2[t3] = l2, t3 + 1 >= e2) {
      $n(t3 + 1 - e2, e2, g2, d2, 0, h2, m3) || b("polynomial_interpolation");
      const s4 = o * Math.abs(h2[0]) + a2, n6 = Math.abs(u - h2[0]);
      if (n6 <= s4 && Math.abs(m3[0]) <= s4) {
        if (p3++, p3 > 1 && (n6 <= 0.1 * f3 || 0 === f3 || p3 > 2)) return h2[0];
      } else p3 = 0;
      f3 = n6, u = h2[0];
    }
    d2[t3 + 1] = d2[t3], g2[t3 + 1] = 0.25 * g2[t3];
  }
  return h2[0];
}
var ei2 = class {
  constructor() {
    this.area = Number.NaN, this.centroid_x = Number.NaN, this.centroid_y = 0, this.specialPoints = [], this.specialPointsLength = [];
  }
  specialPointsCount() {
    return this.specialPoints.length;
  }
};
var si2 = class {
  constructor(t3, e2) {
    this.b = t3, this.len = e2;
  }
  getMaxDerivative() {
    return 1;
  }
  getValue(t3, e2) {
    return 0 === t3 ? this.len - hi2(this.b, e2, false) : 0;
  }
  getError(t3) {
    return n(0), 0;
  }
};
function ni2(t3, e2, s3, n5, i2) {
  let r = true;
  const o = Ot(mi, 3);
  t3.queryControlPoints(o);
  let a2 = r ? 0 : 1, h2 = o[1][a2] - o[0][a2], u = o[2][a2] - o[0][a2];
  const m3 = Kn(5, e2, s3, n5, i2, (t4) => {
    let e3;
    if (t4 <= 0.5) {
      const s4 = V(0, h2, t4), n6 = V(h2, u, t4);
      e3 = V(s4, n6, t4);
    } else {
      const s4 = U2(0, h2, t4), n6 = U2(h2, u, t4);
      e3 = U2(s4, n6, t4);
    }
    return e3 * gi(o, 1, t4).length();
  });
  r = false, a2 = r ? 0 : 1, h2 = o[1][a2] - o[0][a2], u = o[2][a2] - o[0][a2];
  const l2 = Kn(5, e2, s3, n5, i2, (t4) => {
    let e3;
    if (t4 <= 0.5) {
      const s4 = V(0, h2, t4), n6 = V(h2, u, t4);
      e3 = V(s4, n6, t4);
    } else {
      const s4 = U2(0, h2, t4), n6 = U2(h2, u, t4);
      e3 = U2(s4, n6, t4);
    }
    return e3 * gi(o, 1, t4).length();
  });
  return new mi(m3, l2);
}
function ii2(t3) {
  t3.m_cachedValues = null;
}
function ri(t3, e2) {
  e2.m_cachedValues = Pt(t3.m_cachedValues, t3.m_cachedValues = e2.m_cachedValues);
}
function oi2(t3) {
  if (t3.m_cachedValues) return t3.m_cachedValues;
  const e2 = new ei2();
  return ai2(t3, e2.specialPoints), xi(t3, e2), e2;
}
function ai2(t3, e2) {
  const s3 = Ot(mi, 3);
  t3.queryControlPoints(s3);
  const n5 = Ot(p2, 8);
  n5[0].set(0);
  let i2 = 1;
  {
    const t4 = Ot(p2, 3);
    ki(s3, t4, false);
    const e3 = Ot(p2, 2), r = new x2(0, 1);
    let o = cn(t4[2].mul(2), t4[1], r, e3[0]);
    o < 0 && (o = 0);
    for (let s4 = 0; s4 < o; s4++) Vs(e3[s4].value(), 0, 1) || (n5[i2] = e3[s4], i2++);
  }
  {
    const t4 = Ot(p2, 3);
    Gi(s3, t4, false);
    const e3 = Ot(p2, 2), r = new x2(0, 1);
    let o = cn(t4[2].mul(2), t4[1], r, e3[0]);
    o < 0 && (o = 0);
    for (let s4 = 0; s4 < o; s4++) Vs(e3[s4].value(), 0, 1) || (n5[i2] = e3[s4], i2++);
  }
  if (n5[i2].set(1), i2++, i2 > 2) {
    Zt(n5, 0, i2, (t5, e4) => t5.value() - e4.value());
    let t4 = 0, e3 = n5[0].value(), s4 = 1;
    for (let r = 1; r < i2; r++) n5[r].eq(n5[r - 1]) ? (e3 += n5[r].value(), s4++) : (s4 > 1 && (e3 /= s4, n5[t4].set(e3)), t4++, n5[t4] = n5[r], e3 = n5[r].value(), s4 = 1);
    t4++, i2 = t4;
  }
  n5[0].set(0), n5[i2 - 1].set(1), e2.length = i2;
  for (let r = 0; r < i2; r++) e2[r] = n5[r].value();
}
function hi2(t3, e2, s3) {
  const n5 = Ot(mi, 3);
  return t3.queryControlPoints(n5), ui(n5, e2, s3);
}
function ui(t3, e2, s3) {
  if (s3) {
    if (e2 < 0) return e2;
    if (e2 > 1) return e2 - 1 + ui(t3, 1, false);
  }
  if (1 === e2) return mi2(t3);
  const n5 = Ot(mi, 3);
  return Ii(t3, e2, n5, null), mi2(n5);
}
function mi2(t3) {
  if (t3[0].equals(t3[1])) return mi.distance(t3[2], t3[0]);
  if (t3[1].equals(t3[2])) return mi.distance(t3[0], t3[2]);
  const e2 = mi.distance(t3[0], t3[1]) + mi.distance(t3[2], t3[1]), s3 = mi.distance(t3[0], t3[2]);
  if (e2 - s3 <= e2 * Number.EPSILON) return s3;
  const n5 = 1, i2 = Ot(mi, 3);
  zi(t3, i2, true);
  const r = 4 * (H(i2[2].x) + H(i2[2].y)), o = 2 * (i2[2].x * i2[1].x + i2[2].y * i2[1].y), a2 = H(i2[1].x) + H(i2[1].y);
  if (1e-14 * (Math.abs(o) + Math.abs(a2)) >= Math.abs(r)) {
    if (1e-14 * Math.abs(a2) >= Math.abs(o)) {
      return Math.sqrt(a2) * n5;
    }
    return 2 / (3 * o) * (Math.pow(o * n5 + a2, 1.5) - Math.pow(a2, 1.5));
  }
  const h2 = o / r, u = a2 / r, m3 = u - h2 * h2, l2 = n5 + h2;
  if (0 === m3) {
    if (h2 >= 0 && l2 >= 0 || h2 <= 0 && l2 <= 0) {
      return Math.abs(0.5 * Math.sqrt(r) * (l2 * l2 - h2 * h2));
    }
    return 0.5 * Math.sqrt(r) * (l2 * l2 + h2 * h2);
  }
  const c = Math.sqrt(m3 + l2 * l2), g2 = Math.sqrt(u);
  return 0.5 * Math.sqrt(r) * (l2 * c - h2 * g2 + m3 * Math.log(Math.abs((l2 + c) / (h2 + g2))));
}
function li(t3, e2) {
  const s3 = Us(e2, 0, 1);
  let n5 = gi(t3, 1, s3);
  return n5.isZero() && (n5 = gi(t3, 2, s3)), n5;
}
function ci(t3, e2, s3) {
  const n5 = Ot(mi, 3);
  return t3.queryControlPoints(n5), gi(n5, e2, s3);
}
function gi(t3, e2, s3) {
  if (1 === e2) {
    const e3 = t3[1].sub(t3[0]).mul(1 - s3).add(t3[2].sub(t3[1]).mul(s3));
    return e3.mulThis(2), e3;
  }
  return 2 === e2 ? t3[2].sub(t3[1]).sub(t3[1].sub(t3[0]).mul(2)) : mi.construct(0, 0);
}
function di(t3, e2, s3) {
  {
    const e3 = ve.constructPoint2D(t3[1]).subE(ve.constructPoint2D(t3[0])), n5 = new p2(1).subE(s3), i2 = ve.constructPoint2D(t3[2]).subE(ve.constructPoint2D(t3[1])), r = e3.mulE(n5).addE(i2.mulE(s3));
    return r.mulThisE(new p2(2)), r;
  }
}
function _i(t3, e2, s3) {
  const n5 = hi2(t3, 1, false);
  if (e2 <= 0) return e2;
  if (e2 >= n5) return e2 - n5 + 1;
  const i2 = [0];
  return 1 !== tn(new si2(t3, e2), x2.unit(), 1, i2) && b(""), i2[0];
}
function pi(t3) {
  const e2 = Ot(mi, 3);
  return t3.queryControlPoints(e2), fi(e2);
}
function fi(t3) {
  return -t3[1].sub(t3[0]).crossProduct(t3[2].sub(t3[0])) / 3;
}
function Pi(t3) {
  const e2 = mi.distance(t3.getStartXY(), t3.getEndXY()), s3 = t3.calculateUpperLength2D();
  return s3 - e2 <= 8 * Number.EPSILON * s3;
}
function yi(t3) {
  return t3.m_cachedValues;
}
function xi(t3, e2) {
  t3.m_cachedValues = e2;
}
function Ci(t3, e2, s3, n5, i2) {
  D(x2.unit().contains(s3), "QuadraticBezierHelper::getClosestCoordinateSegment");
  const r = Ot(mi, 3);
  t3.queryControlPoints(r);
  let o = Number.MAX_VALUE;
  const a2 = [0], h2 = vi(r, e2, a2);
  if (s3.containsCoordinate(a2[0])) o = mi.distance(e2, h2);
  else {
    a2[0] = s3.vmin, ji(r, a2[0], h2), o = mi.distance(h2, e2);
    const t4 = new mi();
    ji(r, s3.vmax, t4);
    const n6 = mi.distance(t4, e2);
    o > n6 && (h2.setCoordsPoint2D(t4), a2[0] = s3.vmax, o = n6);
  }
  if (!n5) return a2[0];
  if (s3.vmin <= 0) {
    const n6 = new mi();
    t3.queryCoord2DExtended(-1, n6, true);
    const i3 = new mi();
    t3.queryCoord2D(s3.vmin, i3);
    const r2 = new pm({ start: n6, end: i3 }), u = r2.getClosestCoordinate(e2, true);
    if (u < 1) {
      const t4 = r2.getCoord2D(u), s4 = mi.distance(t4, e2);
      s4 < o && (o = s4, a2[0] = u - 1, h2.assign(t4));
    }
  }
  if (s3.vmin >= 1) {
    const n6 = new mi();
    t3.queryCoord2DExtended(2, n6, true);
    const i3 = new mi();
    t3.queryCoord2D(s3.vmax, i3);
    const r2 = new pm({ start: i3, end: n6 }), u = r2.getClosestCoordinate(e2, true);
    if (u > 0) {
      const t4 = r2.getCoord2D(u), s4 = mi.distance(t4, e2);
      s4 < o && (o = s4, a2[0] = 1 + u, h2.assign(t4));
    }
  }
  return a2[0];
}
function vi(t3, e2, s3) {
  const n5 = t3[2].sub(t3[1]).sub(t3[1].sub(t3[0])), i2 = t3[1].sub(t3[0]), r = t3[0].sub(e2), o = r.dotProduct(i2), a2 = r.dotProduct(n5) + 2 * i2.dotProduct(i2), h2 = 3 * i2.dotProduct(n5), u = n5.dotProduct(n5), m3 = Yt(3, Number.NaN), l2 = nn(u, h2, a2, o, x2.unit(), false, m3), c = t3[0].clone();
  let g2 = 0, d2 = mi.sqrDistance(t3[0], e2), _ = mi.sqrDistance(t3[2], e2);
  _ < d2 && (g2 = 1, c.assign(t3[2]), d2 = _);
  for (let p3 = 0; p3 < l2; p3++) {
    const s4 = new mi();
    ji(t3, m3[p3], s4), _ = mi.sqrDistance(s4, e2), _ < d2 && (d2 = _, c.assign(s4), g2 = m3[p3]);
  }
  return s3 && (s3[0] = g2), c;
}
function bi(t3, e2, s3, n5, i2, r) {
  const o = new pe();
  if (Ei(t3, x2.unit(), o), o.inflate(i2), !o.isIntersectingPoint2D(e2)) return 0;
  const a2 = new mi(), h2 = Ci(t3, e2, x2.unit(), false);
  t3.queryCoord2D(h2, a2);
  return mi.distance(a2, e2) <= i2 ? (n5 && (n5[0] = h2), 1) : 0;
}
function Ei(t3, e2, s3) {
  const n5 = Ot(mi, 3);
  t3.queryControlPoints(n5), Si(n5, e2, s3);
}
function Si(t3, e2, s3) {
  if (e2.equalsRange(0, 1)) return void s3.setFromPoints(t3, 3);
  const n5 = Ot(mi, 3);
  Mi(t3, e2.vmin, e2.vmax, n5), s3.setFromPoints(n5, 3);
}
function Di(t3, e2, s3) {
  s3.setEmpty();
  const n5 = [];
  n5.push(new x2(0, 1));
  const i2 = 0.5 * Math.max(e2.width(), e2.height());
  for (; n5.length; ) {
    const r = n5.at(-1);
    n5.pop();
    const o = new pe();
    if (Si(t3, r, o), o.isIntersectingW(e2)) {
      const t4 = Math.max(o.width(), o.height());
      if (e2.containsW(o) || t4 <= i2 || r.width() < 1e-12) s3.merge(r);
      else {
        const t5 = r.getCenter();
        n5.push(x2.construct(r.vmin, t5)), n5.push(x2.construct(t5, r.vmax));
      }
    }
  }
}
function wi(t3) {
  const e2 = Ot(mi, 3);
  t3.queryControlPoints(e2);
  const s3 = Ai(e2);
  return s3 && (t3.m_cp.setCoordsPoint2D(e2[1]), t3.afterCompletedModification()), s3;
}
function Ai(t3) {
  let e2 = false;
  for (let s3 = 0; s3 < 2; s3++) {
    const n5 = fs(t3[0][s3], t3[2][s3]);
    n5 > 0 ? (fs(t3[0][s3], t3[1][s3]) < 0 && (t3[1][s3] = t3[0][s3], e2 = true), fs(t3[1][s3], t3[2][s3]) < 0 && (t3[1][s3] = t3[2][s3], e2 = true)) : n5 < 0 ? (fs(t3[0][s3], t3[1][s3]) > 0 && (t3[1][s3] = t3[0][s3], e2 = true), fs(t3[1][s3], t3[2][s3]) > 0 && (t3[1][s3] = t3[2][s3], e2 = true)) : t3[1][s3] !== t3[0][s3] && (t3[1][s3] = t3[0][s3], e2 = true);
  }
  return e2;
}
function Ti(e2, s3, n5) {
  void 0 === n5 && (n5 = s3, s3 = 0);
  const i2 = new mi();
  if (s3 < 0 || n5 > 1) return i2.setNAN(), i2;
  if (s3 > n5 && P("calculate_sub_weighted_centroid"), s3 === n5 || e2.isDegenerate(0)) return i2.setCoords(0, 0), i2;
  const r = oi2(e2), o = Ue(e2), a2 = Math.min(o / e2.calculateUpperLength2D(), 1e-7);
  let h2 = s3, u = 0;
  for (let t3 = 1, m3 = r.specialPointsCount(); t3 < m3; t3++) if (s3 < r.specialPoints[t3]) {
    u = t3 - 1;
    break;
  }
  i2.setCoords(0, 0);
  for (let t3 = u + 1, m3 = r.specialPointsCount(); t3 < m3; t3++) {
    const s4 = Math.min(r.specialPoints[t3], n5), u2 = ni2(e2, h2, s4, a2, o);
    if (i2.addThis(u2), h2 = s4, n5 <= r.specialPoints[t3]) break;
  }
  return i2.add(e2.getStartXY().mul(e2.calculateLength2D()));
}
function Ii(t3, e2, s3, n5) {
  new mi().setCoordsPoint2D(t3[0]);
  new mi().setCoordsPoint2D(t3[1]);
  new mi().setCoordsPoint2D(t3[2]);
  const i2 = new mi(), r = new mi(), o = new mi();
  if (Y(t3[0], t3[1], e2, i2), Y(t3[1], t3[2], e2, r), Y(i2, r, e2, o), s3 && (s3[0].assign(t3[0]), s3[1].assign(i2), s3[2].assign(o)), n5) {
    const e3 = t3[2];
    n5[0].assign(o), n5[1].assign(r), n5[2].assign(e3);
  }
}
function Mi(t3, e2, s3, n5) {
  if (e2 === s3) {
    const s4 = new mi();
    return ji(t3, e2, s4), n5[0] = s4, n5[1] = s4, void (n5[2] = s4);
  }
  const i2 = Ot(mi, 3);
  Ii(t3, s3, i2, null), Ii(i2, e2 / s3, null, i2), ji(t3, e2, i2[0]), ji(t3, s3, i2[2]), n5[0].setCoordsPoint2D(i2[0]), n5[1].setCoordsPoint2D(i2[1]), n5[2].setCoordsPoint2D(i2[2]);
}
function Yi(t3, e2, s3, n5) {
  if (e2.isEqual(t3.m_XStart, t3.m_YStart) && s3.isEqual(t3.m_XEnd, t3.m_YEnd)) return;
  const i2 = !!n5 && t3.isMonotoneQuickAndDirty(), r = new x3(), o = Ot(mi, 3);
  o[0].setCoords(t3.m_XStart, t3.m_YStart), o[2].setCoords(t3.m_XEnd, t3.m_YEnd);
  const a2 = new mi();
  a2.setSub(o[2], o[0]), a2.leftPerpendicularThis(), o[1].setAdd(o[0], a2);
  const h2 = Ot(mi, 3);
  h2[0].setCoordsPoint2D(e2), h2[2].setCoordsPoint2D(s3), a2.setSub(h2[2], h2[0]), a2.leftPerpendicularThis(), h2[1].setAdd(h2[0], a2), r.setFromTwoTriangles(o, h2) ? r.transformInPlace(t3.m_cp) : Y(e2, s3, 0.5, t3.m_cp), t3.changeEndPoints2D(e2, s3), i2 && wi(t3);
}
function Ni(t3) {
  return t3.getStartXY().norm(1) + t3.getEndXY().norm(1) + t3.m_cp.norm(1);
}
function Xi(t3, e2, s3, n5, i2) {
  if (i2) {
    if (0 !== am(e2, s3)) return t3 ? 4 : 2;
  } else if (Ae(e2, s3)) return 1;
  return 0 !== Vi(t3, e2, s3, null, null, null, n5, i2 ?? false, true, false) ? 4 : 0;
}
function qi(t3, e2, s3, n5, i2) {
  if (i2) {
    if (0 !== am(e2, s3)) return t3 ? 4 : 2;
  } else if (Ae(e2, s3)) return 1;
  return 0 !== Li(t3, e2, s3, null, null, null, n5, i2 ?? false, true, false) ? 4 : 0;
}
function Fi(t3, e2, s3, n5, i2) {
  if (i2) {
    if (0 !== am(e2, s3)) return 2;
  } else if (Ae(e2, s3)) return 1;
  return 0 !== Ri(t3, e2, s3, null, null, null, n5, i2 ?? false, true, false) ? 4 : 0;
}
function Vi(t3, e2, s3, i2, r, o, a2, h2, u, m3) {
  if (null != r && (r.length = 0), null !== o && (o.length = 0), null !== i2 && (i2.length = 0), s3.isDegenerate(0)) {
    const t4 = [0, 0], n5 = e2.intersectPoint(s3.getStartXY(), t4, a2);
    if (n5 > 0) {
      if (null !== r) for (let e3 = 0; e3 < n5; e3++) r.push(t4[e3]);
      if (null !== o) for (let t5 = 0; t5 < n5; t5++) o.push(0);
      if (null !== i2) for (let s4 = 0; s4 < n5; s4++) {
        const n6 = new mi();
        e2.queryCoord2D(t4[s4], n6), i2.push(n6);
      }
    }
    return n5;
  }
  const l2 = Oe(e2, s3);
  if (a2 = Math.max(a2, l2), e2.isDegenerateToLineHelper(l2)) {
    const t4 = new pm({ start: e2.getStartXY(), end: e2.getEndXY() }), n5 = Ds2(t4, s3, i2, r, o, a2, h2, m3);
    if (r) for (let s4 = 0; s4 < n5; ++s4) {
      const n6 = t4.getCoord2D(r[s4]);
      r[s4] = e2.getClosestCoordinate(n6, false);
    }
    return n5;
  }
  if (Qe(e2, s3, a2)) return 0;
  const c = Ee.constructPoint2D(s3.getStartXY()), g2 = Ee.constructPoint2D(s3.getEndXY()).sub(c), d2 = g2.clone();
  d2.leftPerpendicularThis();
  const _ = Ee.constructPoint2D(e2.m_cp).sub(Ee.constructPoint2D(e2.getStartXY())), p3 = Ee.constructPoint2D(e2.getEndXY()).sub(Ee.constructPoint2D(e2.m_cp));
  let f3 = _.dotProduct(d2).toDouble(), P5 = p3.sub(_).dotProduct(d2).toDouble();
  const y2 = Yt(12, Number.NaN), x4 = Yt(12, Number.NaN);
  let C3 = en(P5, f3, x2.unit(), y2);
  C3 < 0 && (y2[0] = 0, y2[1] = 1, C3 = 2);
  let v3, b2 = 0;
  for (let n5 = 0, w4 = b2; n5 < C3; ++n5) {
    const t4 = e2.getCoord2D(y2[n5 + w4]);
    x4[b2] = s3.getClosestCoordinate(t4, false), mi.distance(t4, s3.getCoord2D(x4[b2])) <= a2 && (y2[b2] = y2[n5 + w4], b2++);
  }
  const E2 = Ot(mi, 3);
  e2.queryControlPoints(E2);
  {
    const t4 = Ot(Ee, 3);
    if (Wi(E2, t4, false), t4[0] = t4[0].sub(c), g2.x.abs().gte(g2.y.abs())) {
      const e3 = g2.y.div(g2.x);
      P5 = t4[2].y.sub(t4[2].x.mul(e3)).toDouble(), f3 = t4[1].y.sub(t4[1].x.mul(e3)).toDouble(), v3 = t4[0].y.sub(t4[0].x.mul(e3)).toDouble();
    } else {
      const e3 = g2.x.div(g2.y);
      P5 = t4[2].x.sub(t4[2].y.mul(e3)).toDouble(), f3 = t4[1].x.sub(t4[1].y.mul(e3)).toDouble(), v3 = t4[0].x.sub(t4[0].y.mul(e3)).toDouble();
    }
  }
  const S3 = e2.getEndXY().equals(s3.getStartXY()) || e2.getEndXY().equals(s3.getEndXY()), D3 = [0, 0];
  C3 = sn(P5, f3, v3, x2.unit(), S3, D3);
  for (let n5 = 0, w4 = b2; n5 < C3; ++n5) {
    y2[n5 + w4] = D3[n5];
    const t4 = e2.getCoord2D(y2[n5 + w4]);
    x4[b2] = s3.getClosestCoordinate(t4, false), mi.distance(t4, s3.getCoord2D(x4[b2])) <= a2 && (y2[b2] = y2[n5 + w4], b2++);
  }
  n(b2 < y2.length + 4), C3 = e2.intersectPoint(s3.getStartXY(), D3, a2);
  for (let n5 = 0; n5 < C3; n5++) y2[b2] = D3[n5], x4[b2++] = 0;
  C3 = e2.intersectPoint(s3.getEndXY(), D3, a2);
  for (let n5 = 0; n5 < C3; n5++) y2[b2] = D3[n5], x4[b2++] = 1;
  C3 = s3.intersectPoint(e2.getStartXY(), D3, a2);
  for (let n5 = 0; n5 < C3; n5++) x4[b2] = D3[n5], y2[b2++] = 0;
  C3 = s3.intersectPoint(e2.getEndXY(), D3, a2);
  for (let n5 = 0; n5 < C3; n5++) x4[b2] = D3[n5], y2[b2++] = 0;
  return 0 === b2 ? 0 : cm(t3, e2, s3, y2, x4, b2, i2, r, o, a2, h2, u, m3);
}
function Li(t3, e2, s3, n5, i2, r, o, a2, h2, u) {
  if (Eu(s3)) {
    return Vi(t3, e2, new pm({ start: s3.getStartXY(), end: s3.getEndXY() }), n5, i2, r, o, a2, h2, u);
  }
  const m3 = Oe(e2, s3);
  if (Qe(e2, s3, o = Math.max(o, m3))) return 0;
  const l2 = [], c = [], g2 = Ot(mi, 3);
  {
    e2.queryControlPoints(g2);
    const t4 = Ot(mi, 3), n6 = new x3();
    s3.canonicToWorldTransformation(n6);
    const i3 = new x3();
    i3.setInvert(n6), i3.transformPoints2D(g2, 3, t4);
    const r2 = Ot(Ee, 3);
    Wi(t4, r2);
    const h3 = [r2[0].x, r2[1].x, r2[2].x], u2 = [r2[0].y, r2[1].y, r2[2].y], m4 = Ot(si, 3);
    m4[0].setDouble(s3.getSemiMinorAxis()), m4[0].sqrThis(), m4[1].setDouble(s3.getSemiMajorAxis()), m4[1].sqrThis(), m4[2] = m4[0], m4[2].mul(m4[1]), m4[2].negate();
    const d3 = qn(h3, 2, u2, 2, null, 0, m4, true, x2.unit(), x2.unit(), l2, a2);
    if (d3 > 0) {
      let t5 = 0;
      for (let n7 = 0; n7 < d3; n7++) {
        const i4 = new mi();
        e2.queryCoord2D(l2[n7], i4);
        const r3 = s3.getClosestCoordinate(i4, false), a3 = new mi();
        s3.queryCoord2D(r3, a3), mi.distance(i4, a3) <= o && (l2[t5] = l2[n7], c.push(r3), t5++);
      }
      l2.length = t5;
    }
  }
  const d2 = [0, 1];
  for (let _ = 0; _ < 2; _++) {
    const t4 = 0 === _ ? s3.getStartXY() : s3.getEndXY(), e3 = [0];
    vi(g2, t4, e3);
    const n6 = new mi();
    ji(g2, e3[0], n6), mi.distance(t4, n6) <= o && (l2.push(e3[0]), c.push(d2[_]));
  }
  for (let _ = 0; _ < 2; _++) {
    const t4 = [0, 2];
    {
      const e3 = s3.getClosestCoordinate(g2[t4[_]], false), n6 = new mi();
      s3.queryCoord2D(e3, n6), mi.distance(g2[t4[_]], n6) <= o && (l2.push(d2[_]), c.push(e3));
    }
  }
  return cm(t3, e2, s3, l2, c, l2.length, n5, i2, r, o, a2, h2, u);
}
function Ri(t3, e2, s3, n5, i2, r, o, a2, h2, u) {
  const m3 = Ot(mi, 3);
  e2.queryControlPoints(m3);
  const l2 = Ot(mi, 3);
  if (s3.queryControlPoints(l2), Ke(m3, l2, 3) < 0) return Ri(t3, s3, e2, n5, r, i2, o, a2, h2, !u);
  const c = Oe(e2, s3);
  if (Qe(e2, s3, o = Math.max(o, c))) return 0;
  if (er(e2, s3, n5, i2, r, o, a2, h2, u)) return 2;
  const g2 = new x2(0, 1), d2 = new x2(0, 1);
  {
    const t4 = new pe();
    Si(m3, x2.unit(), t4);
    const e3 = new pe();
    Si(l2, x2.unit(), e3);
    const s4 = Math.max(t4.maxDim(), e3.maxDim());
    if (t4.inflate(3 * o), e3.inflate(3 * o), !t4.intersectW(e3)) return 0;
    if (t4.maxDim() < 0.1 * s4) {
      if (Di(m3, t4, g2), Di(l2, t4, d2), g2.isEmpty() || d2.isEmpty()) return 0;
      Mi(m3, g2.vmin, g2.vmax, m3), Mi(l2, d2.vmin, d2.vmax, l2);
    }
  }
  const _ = dm(m3, 2, l2, 2, o);
  if (0 === _) return 0;
  const p3 = [], f3 = [];
  if (-1 === _) {
    const t4 = Ot(Ee, 3);
    Wi(m3, t4);
    const e3 = [t4[0].x, t4[1].x, t4[2].x], s4 = [t4[0].y, t4[1].y, t4[2].y], n6 = Ot(Ee, 3);
    Wi(l2, n6);
    const i3 = Yn(e3, 2, s4, 2, null, 0, [n6[0].x, n6[1].x, n6[2].x], 2, [n6[0].y, n6[1].y, n6[2].y], 2, null, 0, true, x2.unit(), x2.unit(), p3, f3, u, a2, u);
    if (i3 > 0) {
      let t5 = 0;
      for (let e4 = 0; e4 < i3; e4++) {
        const s5 = new mi(), n7 = new mi();
        ji(l2, f3[e4], n7), ji(m3, p3[e4], s5), mi.distance(s5, n7) <= o && (p3[t5] = p3[e4], f3[t5] = f3[e4], t5++);
      }
      p3.length = t5, f3.length = t5;
    }
  }
  for (let P5 = 0; P5 < 2; P5++) {
    const t4 = 0 === P5 ? m3 : l2, e3 = 0 === P5 ? l2 : m3;
    for (let s4 = 0; s4 < 2; s4++) {
      const n6 = 0 === s4 ? 0 : 2, i3 = [0];
      vi(e3, t4[n6], i3);
      const r2 = new mi();
      ji(e3, i3[0], r2), mi.distance(t4[n6], r2) <= o && (0 === P5 ? (p3.push(0 === n6 ? 0 : 1), f3.push(i3[0])) : (f3.push(0 === n6 ? 0 : 1), p3.push(i3[0])));
    }
  }
  if (0 === p3.length) return 0;
  if (!g2.equalsRange(0, 1)) for (let P5 = 0; P5 < p3.length; ++P5) p3[P5] = wn.recalculateParentT(g2.vmin, g2.vmax, p3[P5]);
  if (!d2.equalsRange(0, 1)) for (let P5 = 0; P5 < f3.length; ++P5) f3[P5] = wn.recalculateParentT(d2.vmin, d2.vmax, f3[P5]);
  return cm(t3, e2, s3, p3, f3, p3.length, n5, i2, r, o, a2, h2, u);
}
function zi(t3, e2, s3 = false) {
  const n5 = t3[1].sub(t3[0]);
  e2[1].assign(n5.mul(2)), e2[2].assign(t3[2].sub(t3[1]).sub(n5)), s3 ? e2[0].setCoords(0, 0) : e2[0].assign(t3[0]);
}
function Bi(t3, e2, s3 = false) {
  const n5 = Ot(mi, 3);
  t3.queryControlPoints(n5), zi(n5, e2, s3);
}
function ki(t3, e2, s3 = false) {
  const n5 = 0, i2 = new p2(t3[1][n5]).subE(new p2(t3[0][n5]));
  e2[1] = i2.mul(2), e2[2] = new p2(t3[2][n5]).subE(new p2(t3[1][n5])).subE(i2), s3 ? e2[0].set(0) : e2[0].set(t3[0][n5]);
}
function Gi(t3, e2, s3 = false) {
  const n5 = 1, i2 = new p2(t3[1][n5]).subE(new p2(t3[0][n5]));
  e2[1] = i2.mul(2), e2[2] = new p2(t3[2][n5]).subE(new p2(t3[1][n5])).subE(i2), s3 ? e2[0].set(0) : e2[0].set(t3[0][n5]);
}
function Wi(t3, e2, s3 = false) {
  const n5 = Ee.constructPoint2D(t3[1]), i2 = n5.sub(Ee.constructPoint2D(t3[0]));
  e2[1] = i2.mul(si.constructInt32(2)), e2[2] = Ee.constructPoint2D(t3[2]).sub(n5).sub(i2), e2[0] = s3 ? new Ee(ei, ei) : Ee.constructPoint2D(t3[0]);
}
function ji(t3, e2, s3, n5) {
  if (n5) {
    if (e2 < 0) {
      return void _s2(new pm({ start: t3[0], end: t3[0].add(li(t3, 0).getUnitVector()) }), e2, s3);
    }
    if (e2 > 1) {
      return void _s2(new pm({ start: t3[2], end: t3[2].add(li(t3, 1).getUnitVector()) }), e2 - 1, s3);
    }
  }
  if (e2 <= 0.5) {
    const n6 = t3[1].clone(), i2 = new mi();
    k2(2, t3[0], n6, e2, i2);
    const r = new mi();
    k2(2, n6, t3[2], e2, r);
    const o = new mi();
    k2(2, i2, r, e2, o), s3.assign(o);
  } else {
    const n6 = t3[1].clone(), i2 = new mi();
    F(2, t3[0], n6, e2, i2);
    const r = new mi();
    F(2, n6, t3[2], e2, r);
    const o = new mi();
    F(2, i2, r, e2, o), s3.assign(o);
  }
}
function Zi(t3, e2, s3) {
  const n5 = Ot(mi, 3);
  t3.queryControlPoints(n5), Hi(n5, e2, s3);
}
function Hi(t3, e2, s3) {
  if (e2.value() <= 0.5) {
    const n5 = ve.constructPoint2D(t3[1]), i2 = new ve();
    O(2, ve.constructPoint2D(t3[0]), n5, e2, i2);
    const r = new ve();
    O(2, n5, ve.constructPoint2D(t3[2]), e2, r);
    const o = new ve();
    O(2, i2, r, e2, o), s3.setE(o);
  } else {
    const n5 = ve.constructPoint2D(t3[1]), i2 = new ve();
    G2(2, ve.constructPoint2D(t3[0]), n5, e2, i2);
    const r = new ve();
    G2(2, n5, ve.constructPoint2D(t3[2]), e2, r);
    const o = new ve();
    G2(2, i2, r, e2, o), s3.setE(o);
  }
}
function Ui(t3, e2, s3) {
  const n5 = Ot(mi, 4);
  t3.queryControlPoints(n5), Oi(n5, e2, s3);
}
function Oi(t3, e2, s3) {
  e2.value() < 0 && e2.set(0, e2.eps()), e2.value() > 1 && e2.set(1, e2.eps()), s3.setE(di(t3, 1, e2));
}
function Ji(t3, e2) {
  e2[0].assign(t3[0]), e2[3].assign(t3[2]), Y(t3[0], t3[1], 2 / 3, e2[1]), Y(t3[1], t3[2], 1 / 3, e2[2]);
}
function $i(t3, e2) {
  const s3 = Ot(mi, 3);
  t3.queryControlPoints(s3);
  const n5 = mi.sqrDistance(s3[1], s3[0]), i2 = mi.sqrDistance(s3[1], s3[2]);
  let r = s3[0].clone(), o = n5;
  n5 > i2 && (r = s3[2].clone(), o = i2);
  let a2 = false;
  return o <= e2 && 0 !== o && (a2 = true, t3.setControlPoint1(r)), a2;
}
function tr(t3, e2) {
  if (!e2) return false;
  const s3 = Ot(mi, 3);
  t3.queryControlPoints(s3);
  const n5 = mi.sqrDistance(s3[1], s3[0]), i2 = mi.sqrDistance(s3[1], s3[2]);
  s3[0].clone();
  let r = n5;
  return n5 > i2 && (s3[2].clone(), r = i2), r <= e2 && 0 !== r;
}
function er(t3, e2, s3, n5, i2, r, o, a2, h2) {
  const u = Ot(mi, 3);
  t3.queryControlPoints(u);
  const m3 = Ot(mi, 3);
  if (e2.queryControlPoints(m3), u[0].equals(m3[0])) {
    if (u[1].equals(m3[1]) && u[2].equals(m3[2])) return s3 && (s3.length = 0, s3.push(u[0]), s3.push(u[2])), n5 && (n5.length = 0, n5.push(0), n5.push(1)), i2 && (i2.length = 0, i2.push(0), i2.push(1)), true;
    if (!u[0].equals(m3[2])) return false;
  }
  return !!(u[0].equals(m3[2]) && u[1].equals(m3[1]) && u[2].equals(m3[0])) && (n5 && (n5.length = 0, n5.push(0), n5.push(1), h2 && (n5[1] = Pt(n5[0], n5[0] = n5[1]))), i2 && (i2.length = 0, i2.push(1), i2.push(0), h2 && (i2[1] = Pt(i2[0], i2[0] = i2[1]))), s3 && (s3.length = 0, s3.push(u[0]), s3.push(u[2]), h2 && (s3[1] = Pt(s3[0], s3[0] = s3[1]))), true);
}
var sr = [[0.33998104358485626, 0.6521451548625461], [0.8611363115940526, 0.34785484513745385]];
var nr = [[0.1834346424956498, 0.362683783378362], [0.525532409916329, 0.31370664587788727], [0.7966664774136267, 0.22238103445337448], [0.9602898564975363, 0.10122853629037626]];
var ir = [[0.09501250983763744, 0.1894506104550685], [0.2816035507792589, 0.18260341504492358], [0.45801677765722737, 0.16915651939500254], [0.6178762444026438, 0.14959598881657674], [0.755404408355003, 0.12462897125553388], [0.8656312023878318, 0.09515851168249279], [0.9445750230732326, 0.062253523938647894], [0.9894009349916499, 0.027152459411754096]];
var rr = [[0.04830766568773832, 0.0965400885147278], [0.1444719615827965, 0.09563872007927486], [0.23928736225213706, 0.09384439908080457], [0.33186860228212767, 0.09117387869576389], [0.42135127613063533, 0.08765209300440381], [0.5068999089322294, 0.08331192422694675], [0.5877157572407623, 0.07819389578707031], [0.6630442669302152, 0.0723457941088485], [0.7321821187402897, 0.06582222277636185], [0.7944837959679424, 0.058684093478535544], [0.84936761373257, 0.050998059262376175], [0.8963211557660521, 0.04283589802222668], [0.9349060759377397, 0.03427386291302143], [0.9647622555875064, 0.02539206530926206], [0.9856115115452684, 0.01627439473090567], [0.9972638618494816, 0.007018610009470096]];
var or = [[0.024350292663424433, 0.048690957009139724], [0.07299312178779904, 0.04857546744150343], [0.12146281929612056, 0.048344762234802954], [0.16964442042399283, 0.04799938859645831], [0.21742364374000708, 0.04754016571483031], [0.2646871622087674, 0.04696818281621002], [0.31132287199021097, 0.046284796581314416], [0.3572201583376681, 0.04549162792741814], [0.4022701579639916, 0.044590558163756566], [0.4463660172534641, 0.04358372452932345], [0.48940314570705296, 0.04247351512365359], [0.5312794640198946, 0.04126256324262353], [0.571895646202634, 0.03995374113272034], [0.6111553551723933, 0.038550153178615626], [0.6489654712546573, 0.03705512854024005], [0.6852363130542333, 0.035472213256882386], [0.7198818501716109, 0.033805161837141606], [0.7528199072605319, 0.03205792835485155], [0.7839723589433414, 0.030234657072402478], [0.8132653151227975, 0.028339672614259483], [0.8406292962525803, 0.02637746971505466], [0.8659993981540928, 0.024352702568710874], [0.8893154459951141, 0.022270173808383253], [0.9105221370785028, 0.02013482315353021], [0.9295691721319396, 0.017951715775697343], [0.9464113748584028, 0.015726030476024718], [0.9610087996520538, 0.013463047896718643], [0.973326827789911, 0.011168139460131128], [0.983336253884626, 0.008846759826363947], [0.9910133714767443, 0.006504457968978363], [0.9963401167719553, 0.004147033260562468], [0.9993050417357722, 0.001783280721696433]];
var ar = [[0.012223698960615764, 0.024446180196262518], [0.03666379096873349, 0.024431569097850044], [0.06108196960413957, 0.02440235563384958], [0.08546364050451549, 0.024358557264690626], [0.10979423112764375, 0.024300200167971867], [0.13405919946118777, 0.02422731922281525], [0.15824404271422493, 0.024139957989019287], [0.18233430598533718, 0.024038168681024052], [0.2063155909020792, 0.023922012136703457], [0.23017356422666, 0.023791557781003402], [0.2538939664226943, 0.023646883584447616], [0.2774626201779044, 0.02348807601653591], [0.3008654388776772, 0.02331522999406276], [0.32408843502441337, 0.023128448824387027], [0.3471177285976355, 0.022927844143686846], [0.369939555349859, 0.02271353585023646], [0.39254027503326744, 0.022485652032744968], [0.414906379552275, 0.022244328893799764], [0.43702450103710416, 0.02198971066846049], [0.4588814198335522, 0.021721949538052076], [0.48046407240417205, 0.02144120553920846], [0.5017595591361445, 0.02114764646822135], [0.5227551520511755, 0.02084144778075115], [0.5434383024128103, 0.02052279248696007], [0.5637966482266181, 0.020191871042130043], [0.5838180216287631, 0.01984888123283086], [0.6034904561585486, 0.019494028058706602], [0.6228021939105849, 0.019127523609950944], [0.6417416925623075, 0.01874958694054471], [0.660297632272646, 0.01836044393733134], [0.6784589224477192, 0.017960327185008687], [0.6962147083695144, 0.017549475827117706], [0.7135543776835874, 0.01712813542311138], [0.7304675667419088, 0.016696557801589205], [0.746944166797062, 0.016255000909785187], [0.7629743300440948, 0.015803728659399347], [0.7785484755064119, 0.015343010768865144], [0.7936572947621933, 0.014873122602147314], [0.8082917575079137, 0.014394345004166847], [0.8224431169556439, 0.013906964132951985], [0.8361029150609068, 0.013411271288616333], [0.8492629875779689, 0.012907562739267348], [0.8619154689395485, 0.012396139543950923], [0.8740527969580318, 0.01187730737274028], [0.8856677173453972, 0.011351376324080417], [0.8967532880491582, 0.010818660739503076], [0.9073028834017568, 0.010279479015832158], [0.9173101980809605, 0.009734153415006806], [0.9267692508789478, 0.009183009871660874], [0.9356743882779164, 0.00862637779861675], [0.9440202878302202, 0.008064589890486059], [0.9518019613412644, 0.0074979819256347285], [0.9590147578536999, 0.006926892566898814], [0.9656543664319652, 0.006351663161707189], [0.9717168187471366, 0.005772637542865698], [0.9771984914639074, 0.00519016183267633], [0.9820961084357185, 0.004604584256702955], [0.9864067427245862, 0.004016254983738642], [0.9901278184917344, 0.0034255260409102157], [0.9932571129002129, 0.0028327514714579912], [0.9957927585349812, 0.0022382884309626186], [0.997733248625514, 0.0016425030186690294], [0.9990774599773758, 0.0010458126793403489], [0.9998248879471319, 44938096029209035e-20]];
function hr(t3, e2, s3, n5) {
  const i2 = 0.5 * (n5 - s3), r = s3 + i2, o = new n2(0);
  for (let a2 = 0, h2 = Math.trunc(t3 / 2); a2 < h2; ++a2) {
    let s4, n6;
    switch (t3) {
      case 4:
        s4 = sr[a2][0], n6 = sr[a2][1];
        break;
      case 8:
        s4 = nr[a2][0], n6 = nr[a2][1];
        break;
      case 16:
        s4 = ir[a2][0], n6 = ir[a2][1];
        break;
      case 32:
        s4 = rr[a2][0], n6 = rr[a2][1];
        break;
      case 64:
        s4 = or[a2][0], n6 = or[a2][1];
        break;
      case 128:
        s4 = ar[a2][0], n6 = ar[a2][1];
        break;
      default:
        throw new Error("Quadrature_integral: invalid n");
    }
    const h3 = st(-0.5, s4, r), u = st(i2, s4, r);
    o.pe(e2(h3) * n6), o.pe(e2(u) * n6);
  }
  return o.getResult() * i2;
}
var ur = class _ur extends Hs2 {
  constructor(t3) {
    t3 ? t3.vd ? (super({ vd: t3.vd, bPolygon: true }), this.m_segmentBufferCTor = fm) : t3.copy ? (super({ vd: t3.copy.getDescription(), bPolygon: true }), this.m_segmentBufferCTor = fm, t3.copy.copyTo(this)) : t3.move ? (super({ move: t3.move }), this.m_segmentBufferCTor = fm) : t3.envelope ? z("envelope constructor not impl") : b("bad arg to polygon constructor") : (super({ bPolygon: true }), this.m_segmentBufferCTor = fm);
  }
  assignMove(t3) {
    return t3.copyTo(this), this;
  }
  assignCopy(t3) {
    return t3.copyTo(this), this;
  }
  getBoundary() {
    return Js2(this);
  }
  getExteriorRingCount() {
    return this.getOGCPolygonCount();
  }
  getGeometryType() {
    return _ur.type;
  }
  getDimension() {
    return 2;
  }
  createInstance() {
    return new _ur({ vd: this.getDescription() });
  }
  equals(t3, e2) {
    return this.equalsBase(t3, e2);
  }
};
function mr(n5, i2) {
  let r, o = i2, a2 = null;
  switch (o || (a2 = g(n5) ? O2() : M(), o = a2), n5) {
    case a.enumPoint:
      r = new ee({ vd: o });
      break;
    case a.enumLine:
      r = new pm({ vd: o });
      break;
    case a.enumBezier:
      r = new ia({ vd: o });
      break;
    case a.enumEllipticArc:
      r = new Xh({ vd: o });
      break;
    case a.enumRationalBezier2:
      r = new Sn({ vd: o });
      break;
    case a.enumBezier2:
      r = new wn({ vd: o });
      break;
    case a.enumEnvelope:
      r = new re({ vd: o });
      break;
    case a.enumMultiPoint:
      r = new cs2({ vd: o });
      break;
    case a.enumPolyline:
      r = new Os2({ vd: o });
      break;
    case a.enumPolygon:
      r = new ur({ vd: o });
      break;
    case a.enumMultipatch:
      z("multipatch not impl");
      break;
    case a.enumGeometryCollection:
      r = new de({ vd: o });
      break;
    default:
      P("Geometry.create");
  }
  return r;
}
ur.type = a.enumPolygon;
var lr = z3;
var cr = -1;
var gr = 1;
var dr = class {
  constructor(t3) {
    this.m_shape = t3;
  }
  userSort(t3, e2, s3) {
    this.m_shape.sortVerticesSimpleByYHelper(s3, t3, e2);
  }
  getValue(t3) {
    return this.m_shape.getY(t3);
  }
};
function _r(t3) {
  return void 0 !== t3.parent;
}
var pr = class _pr {
  constructor(t3) {
    _r(t3) ? (this.m_parent = t3.parent, this.m_geometry = t3.geometry, this.m_path = t3.path, this.m_vertex = t3.vertex, this.m_firstVertex = t3.firstVertex, this.m_index = t3.selection ? 0 : t3.index, this.m_bSkipMultiPoints = t3.bSkipMultiPoints, this.m_selection = t3.selection, this.m_bOneGeom = t3.bOneGeom, this.m_bFirst = true) : (this.m_parent = t3.copy.m_parent, this.m_geometry = t3.copy.m_geometry, this.m_path = t3.copy.m_path, this.m_vertex = t3.copy.m_vertex, this.m_index = t3.copy.m_index, this.m_bSkipMultiPoints = t3.copy.m_bSkipMultiPoints, this.m_firstVertex = t3.copy.m_firstVertex, this.m_bFirst = true, this.m_selection = t3.copy.m_selection, this.m_bOneGeom = t3.copy.m_bOneGeom);
  }
  moveToNextHelper() {
    for (this.m_path = this.m_parent.getNextPath(this.m_path), this.m_index = 0; this.m_geometry !== cr; ) {
      for (; this.m_path !== cr; this.m_path = this.m_parent.getNextPath(this.m_path)) if (this.m_vertex = this.m_parent.getFirstVertex(this.m_path), this.m_firstVertex = this.m_vertex, this.m_vertex !== cr) return this.m_vertex;
      if (this.m_bOneGeom) return cr;
      if (this.m_geometry = this.m_parent.getNextGeometry(this.m_geometry), this.m_geometry === cr) break;
      this.m_bSkipMultiPoints && !h(this.m_parent.getGeometryType(this.m_geometry)) || (this.m_path = this.m_parent.getFirstPath(this.m_geometry));
    }
    return cr;
  }
  nextSelection() {
    for (; this.m_index < this.m_parent.m_selectedVertices.length; ) {
      const t3 = this.m_parent.m_selectedVertices[this.m_index++];
      if (t3 !== cr && (this.m_path = this.m_parent.getPathFromVertex(t3), !this.m_bOneGeom || this.m_geometry === this.m_parent.getGeometryFromPath(this.m_path))) return this.m_geometry = this.m_parent.getGeometryFromPath(this.m_path), t3;
    }
    return cr;
  }
  next() {
    return this.m_selection ? this.nextSelection() : this.m_bFirst ? (this.m_bFirst = false, this.m_vertex) : this.m_vertex !== cr ? (this.m_vertex = this.m_parent.getNextVertex(this.m_vertex), this.m_index++, this.m_vertex !== cr && this.m_vertex !== this.m_firstVertex ? this.m_vertex : this.moveToNextHelper()) : cr;
  }
  currentGeometry() {
    return this.m_geometry;
  }
  currentPath() {
    return this.m_path;
  }
  static create_(t3, e2, s3, n5, i2, r, o, a2, h2) {
    return new _pr({ parent: t3, geometry: e2, path: s3, vertex: n5, firstVertex: i2, index: r, bSkipMultiPoints: o, selection: a2, bOneGeom: h2 });
  }
};
var fr = class {
  constructor(t3) {
    this.parentage = t3;
  }
  equals(t3) {
    return this.parentage === t3.parentage;
  }
};
var Pr = class _Pr {
  setPrevPath(t3, e2) {
    this.m_pathIndexList.setField(t3, 1, e2);
  }
  setNextPath(t3, e2) {
    this.m_pathIndexList.setField(t3, 2, e2);
  }
  setPathFlags(t3, e2) {
    this.m_pathIndexList.setField(t3, 6, e2);
  }
  getPathFlags(t3) {
    return this.m_pathIndexList.getField(t3, 6);
  }
  setPathGeometry(t3, e2) {
    this.m_pathIndexList.setField(t3, 7, e2);
  }
  getPathIndex(t3) {
    return this.m_pathIndexList.getField(t3, 0);
  }
  setNextGeometry(t3, e2) {
    this.m_geometryIndexList.setField(t3, 1, e2);
  }
  setPrevGeometry(t3, e2) {
    this.m_geometryIndexList.setField(t3, 0, e2);
  }
  getGeometryIndex(t3) {
    return this.m_geometryIndexList.getField(t3, 7);
  }
  setFirstPath(t3, e2) {
    this.m_geometryIndexList.setField(t3, 3, e2);
  }
  setLastPath(t3, e2) {
    this.m_geometryIndexList.setField(t3, 4, e2);
  }
  newGeometry(t3) {
    const e2 = this.m_geometryIndexList.newElement();
    return this.m_geometryIndexList.setField(e2, 2, t3), this.m_geometryIndexList.setField(e2, 5, 0), this.m_geometryIndexList.setField(e2, 6, 0), this.m_geometryIndexList.setField(e2, 7, this.m_geometryIndexList.elementToIndex(e2)), e2;
  }
  freeGeometry(t3) {
    this.m_geometryIndexList.deleteElement(t3);
  }
  newPath(t3) {
    const e2 = this.m_pathIndexList.newElement(), s3 = this.m_pathIndexList.elementToIndex(e2);
    if (this.m_pathIndexList.setField(e2, 0, s3), this.m_pathIndexList.setField(e2, 3, 0), this.m_pathIndexList.setField(e2, 6, 0), this.setPathGeometry(e2, t3), s3 >= this.m_pathAreas.length) {
      const t4 = Math.trunc(s3 < 16 ? 16 : 3 * s3 / 2);
      this.m_pathAreas.length = t4, this.m_pathLengths.length = t4;
    }
    return this.m_pathAreas[s3] = 0, this.m_pathLengths[s3] = 0, this.m_pathCount++, e2;
  }
  freePath(t3) {
    this.m_pathIndexList.deleteElement(t3), this.m_pathCount--;
  }
  newVertex(t3) {
    const e2 = this.m_vertexIndexList.newElement(), s3 = t3 >= 0 ? t3 : this.m_vertexIndexList.elementToIndex(e2);
    if (this.m_vertexIndexList.setField(e2, 0, s3), t3 < 0) {
      if (s3 >= this.m_vertices.getPointCount()) {
        const t4 = Math.trunc(s3 < 16 ? 16 : 3 * s3 / 2);
        this.m_vertices.reserveRounded(t4), this.m_vertices.resizeNoInit(t4), null !== this.m_segments && (this.m_segments.length = t4), this.m_xyStream = this.m_vertices.getAttributeStreamRef(0);
      }
      this.m_segments && (this.m_segments[s3] = null);
    }
    return this.m_pointCount++, e2;
  }
  freeVertex(t3) {
    this.unselect(t3);
    const e2 = this.getVertexIndex(t3);
    this.m_vertexIndexList.deleteElement(t3), this.m_pointCount--;
    for (let s3 = 0, n5 = this.m_indices.length; s3 < n5; s3++) {
      if (s3 === this.m_selectionIndex) continue;
      const t4 = this.m_indices[s3];
      null !== t4 && t4.size() > e2 && t4.write(e2, -1);
    }
    this.m_weights && this.m_weights.size() > e2 && this.m_weights.write(e2, 1), this.m_ranks && this.m_ranks.size() > e2 && this.m_ranks.write(e2, gr), this.m_segmentWeights && this.m_segmentWeights.size() > e2 && this.m_segmentWeights.write(e2, 1), this.m_segmentRanks && this.m_segmentRanks.size() > e2 && this.m_segmentRanks.write(e2, gr), this.m_segments && this.setSegmentToIndex(e2, null);
  }
  insertVertex_(t3, e2, s3, n5) {
    this.m_hasForceSetEnvelope = 0;
    const i2 = e2 !== cr ? this.getPrevVertex(e2) : this.getLastVertex(t3), r = i2 !== cr ? this.getNextVertex(i2) : cr, o = this.newVertex(null === s3 ? this.m_pointCount : -1), a2 = this.getVertexIndex(o);
    null !== s3 && this.m_vertices.setPointByValNoCurves(a2, s3), this.setPathToVertex(o, t3), this.setNextVertex(o, r), this.setPrevVertex(o, i2), r !== cr && this.setPrevVertex(r, o), i2 !== cr && this.setNextVertex(i2, o);
    const h2 = this.isClosedPath(t3), u = this.getFirstVertex(t3);
    e2 === cr && this.setLastVertex(t3, o), e2 === u && (h2 && n5 && u !== cr || this.setFirstVertex(t3, o)), h2 && r === cr && (this.setNextVertex(o, o), this.setPrevVertex(o, o)), this.setPathSize(t3, this.getPathSize(t3) + 1);
    const m3 = this.getGeometryFromPath(t3);
    return this.setGeometryVertexCount(m3, this.getPointCount(m3) + 1), o;
  }
  getHelperPoint() {
    return this.m_helperPoint || (this.m_helperPoint = new ee({ vd: this.m_vertices.getDescription() }), this.m_helperPoint.setXYCoords(0, 0)), this.m_helperPoint;
  }
  addMultiPoint(t3, e2) {
    const s3 = this.createGeometry(t3.getGeometryType(), t3.getDescription());
    return this.appendMultiPoint(s3, t3, e2), s3;
  }
  addPoint_(t3, s3) {
    const n5 = this.createGeometry(a.enumMultiPoint, t3.getDescription());
    return this.appendPoint(n5, t3, s3), n5;
  }
  appendMultiPath_(t3, e2) {
    if (e2.isEmpty()) return;
    const s3 = e2.getImpl();
    this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + s3.getPointCount()), this.m_verticesMp.addPoints(e2, 0, s3.getPointCount()), this.m_xyStream = this.m_vertices.getAttributeStreamRef(0);
    const n5 = null !== this.m_segments || null !== s3.getSegmentFlagsStreamRef();
    this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size() + s3.getPointCount()), this.m_pathIndexList.setCapacity(this.m_pathIndexList.size() + s3.getPathCount());
    for (let i2 = 0, r = s3.getPathCount(); i2 < r; i2++) {
      if (0 === s3.getPathSize(i2)) continue;
      const e3 = this.insertPath(t3, cr);
      this.setClosedPath(e3, s3.isClosedPath(i2));
      for (let t4 = s3.getPathStart(i2), r2 = s3.getPathEnd(i2); t4 < r2; t4++) {
        const i3 = this.insertVertex_(e3, cr, null, false);
        if (n5) {
          const e4 = this.getVertexIndex(i3);
          if (1 & s3.getSegmentFlags(t4)) this.setSegmentToIndex(e4, null);
          else {
            const n6 = new fm();
            s3.querySegment(t4, n6, true), this.setSegmentToIndex(e4, n6.releaseSegment());
          }
        }
      }
      s3.isStrongPathStart(i2) && this.setStrongPathStart(e3, true), s3.isStrongPathEnd(i2) && this.setStrongPathEnd(e3, true);
    }
  }
  addMultiPath(t3, s3) {
    const n5 = this.createGeometry(t3.getGeometryType(), t3.getDescription());
    return t3.getGeometryType() === a.enumPolygon && this.setFillRule(n5, t3.getFillRule()), this.appendMultiPath(n5, t3, s3), n5;
  }
  appendMultiPathPolyline(t3, e2, s3) {
    const n5 = e2.getImpl(), i2 = null !== this.m_segments || null !== n5.getSegmentFlagsStreamRef(), r = new n3();
    e2.queryEnvelope(r);
    {
      const r2 = s3.clone();
      let o = n5.getPointCount();
      const a2 = n5.getAccelerators();
      if (a2 && a2.getQuadTree()) {
        o = a2.getQuadTree().getIntersectionCount(r2, 0, n5.getPointCount() + 1);
      }
      if (o < e2.getPointCount()) {
        if (0 === o) return;
        const s4 = n5.queryLimitedSegmentIterator(r2);
        let a3 = -1, h2 = -100, u = -1, m3 = 0, l2 = -1, c = cr, g2 = false, d2 = s4.nextSegment();
        if (null !== d2) for (; ; d2 = s4.nextSegment()) {
          let r3 = null === d2;
          const o2 = null !== d2 ? s4.getPathIndex() : a3, _ = null !== d2 ? s4.getStartPointIndex() : h2;
          if (r3 || (a3 === o2 && h2 + 1 === _ ? m3++ : r3 = true), r3) {
            if (-1 !== l2) {
              let t4 = -1, s5 = -1;
              if (m3 === u) {
                this.setClosedPath(c, g2);
                const i3 = n5.getPathEnd(a3);
                this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + i3 - l2), this.m_verticesMp.addPoints(e2, l2, i3), s5 = n5.getPathSize(a3), t4 = i3 - 1;
              } else if (!g2 || h2 + 1 < n5.getPathEnd(a3)) this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + h2 + 2 - l2), this.m_verticesMp.addPoints(e2, l2, h2 + 2), s5 = h2 - l2 + 2, t4 = h2;
              else {
                this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + h2 + 2 - l2), this.m_verticesMp?.addPoints(e2, l2, h2 + 1), t4 = h2, s5 = h2 - l2 + 1;
                const i3 = n5.getPathStart(a3);
                this.m_verticesMp.addPoints(e2, i3, i3 + 1), s5 += 1;
              }
              this.m_xyStream = this.m_vertices.getAttributeStreamRef(0);
              for (let e3 = 0, r4 = l2; e3 < s5; e3++, r4++) {
                const e4 = this.insertVertex_(c, cr, null, false);
                if (i2) {
                  const s6 = this.getVertexIndex(e4);
                  if (1 & n5.getSegmentFlags(r4) || r4 > t4) this.setSegmentToIndex(s6, null);
                  else {
                    const t5 = new fm();
                    n5.getSegmentBuffer(r4, t5, true), this.setSegmentToIndex(s6, t5.releaseSegment());
                  }
                }
              }
            }
            if (null === d2) break;
            m3 = 1, l2 = _, a3 !== o2 ? (c = this.insertPath(t3, cr), this.setClosedPath(c, false), u = n5.getSegmentCountPath(o2), g2 = n5.isClosedPath(o2), a3 = o2) : c = this.insertPath(t3, cr);
          }
          h2 = _;
        }
        return;
      }
    }
    this.appendMultiPath_(t3, e2);
  }
  appendMultiPathPolygon(t3, e2, s3) {
    const i2 = e2.getImpl(), r = null !== this.m_segments || null !== i2.getSegmentFlagsStreamRef(), o = n3.constructEmpty();
    e2.queryEnvelope(o), n(s3.isIntersecting(o) && !s3.containsEnvelope(o));
    let a2 = n3.construct(Number.NEGATIVE_INFINITY, s3.ymin, Number.POSITIVE_INFINITY, s3.ymax), h2 = n3.construct(s3.xmin, Number.NEGATIVE_INFINITY, s3.xmax, Number.POSITIVE_INFINITY);
    const u = i2.getAccelerators();
    if (u && u.getQuadTree()) {
      const t4 = u.getQuadTree(), e3 = t4.getIntersectionCount(a2, 0, 0);
      e3 > t4.getIntersectionCount(h2, 0, e3 + 1) && (h2 = Pt(a2, a2 = h2));
    } else a2.height() > h2.width() && (h2 = Pt(a2, a2 = h2));
    const m3 = [], l2 = i2.queryLimitedSegmentIterator(a2);
    let c = -1, g2 = -100, d2 = -1, _ = 0, p3 = -1, f3 = -1, P5 = cr, y2 = true, x4 = l2.nextSegment();
    if (null !== x4) for (; ; x4 = l2.nextSegment()) {
      let s4 = null === x4;
      const o2 = null !== x4 ? l2.getPathIndex() : c, a3 = null !== x4 ? l2.getStartPointIndex() : g2;
      if (s4 || (o2 === c ? g2 + 1 === a3 ? _++ : s4 = true : (s4 = c >= 0, c < 0 && (c = o2, d2 = i2.getSegmentCountPath(c), p3 = a3, P5 = cr, _ = 1))), s4) {
        if (!(0 === m3.length && d2 === _)) {
          0 !== m3.length && m3[0].first === p3 || (this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + 1), this.m_verticesMp.addPoints(e2, p3, p3 + 1), -1 === f3 && (f3 = p3), P5 === cr && (P5 = this.insertPath(t3, cr), this.setClosedPath(P5, true)), this.m_xyStream = this.m_vertices.getAttributeStreamRef(0), this.insertVertex_(P5, cr, null, false));
          for (const { first: s5, second: o3 } of m3) {
            -1 === f3 && (f3 = s5);
            let a4 = -1, h3 = -1;
            const u2 = s5 + o3 - 1;
            if (o3 === d2) {
              const t4 = u2 + 1;
              h3 = t4 - s5, this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + h3), this.m_verticesMp.addPoints(e2, s5, t4), a4 = u2, n(1 === m3.length);
            } else if (u2 + 1 < i2.getPathEnd(c)) {
              const t4 = u2 + 2;
              h3 = t4 - s5, this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + h3), this.m_verticesMp.addPoints(e2, s5, t4), a4 = u2;
            } else {
              const t4 = i2.getPathStart(c), n5 = t4 !== f3 ? 1 : 0, r2 = u2 + 1;
              h3 = r2 - s5 + n5, this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + (r2 - s5) + n5), this.m_verticesMp.addPoints(e2, s5, r2), a4 = u2, n5 > 0 && this.m_verticesMp?.addPoints(e2, t4, t4 + 1);
            }
            this.m_xyStream = this.m_vertices.getAttributeStreamRef(0), P5 === cr && (P5 = this.insertPath(t3, cr), this.setClosedPath(P5, true));
            for (let t4 = 0, e3 = s5; t4 < h3; t4++, e3++) {
              const t5 = this.insertVertex_(P5, cr, null, false);
              if (r) {
                const s6 = this.getVertexIndex(t5);
                if (1 & i2.getSegmentFlags(e3) || e3 > a4) this.setSegmentToIndex(s6, null);
                else {
                  const t6 = new fm();
                  i2.getSegmentBuffer(e3, t6, true), this.setSegmentToIndex(s6, t6.releaseSegment());
                }
              }
            }
          }
          if (0 === m3.length || m3.at(-1).first + m3.at(-1).second !== p3 + _) {
            let t4 = p3 + _;
            t4 === e2.getPathEnd(c) && (t4 = e2.getPathStart(c)), f3 !== t4 && (this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + 1), this.m_verticesMp.addPoints(e2, t4, t4 + 1), this.insertVertex_(P5, cr, null, false));
          }
        }
        m3.length = 0, y2 = true, o2 !== c && (c = o2, d2 = i2.getSegmentCountPath(c), P5 = cr, f3 = -1), p3 = a3, _ = 1;
      }
      if (!x4) break;
      {
        const t4 = n3.constructEmpty();
        x4.queryLooseEnvelope(t4), h2.isIntersecting(t4) ? (y2 ? m3.push($t(a3, 1)) : m3.at(-1).second++, y2 = false) : y2 = true;
      }
      g2 = a3;
    }
  }
  appendMultiPath(t3, s3, n5) {
    if (void 0 === n5) return void this.appendMultiPath_(t3, s3);
    if (s3.isEmpty()) return;
    const i2 = s3.getGeometryType() === a.enumPolygon, r = n3.constructEmpty();
    s3.queryEnvelope(r), n5.isIntersecting(r) && (!n5.containsEnvelope(r) && s3.getPointCount() > 10 ? i2 ? this.appendMultiPathPolygon(t3, s3, n5) : this.appendMultiPathPolyline(t3, s3, n5) : this.appendMultiPath_(t3, s3));
  }
  appendPoint(t3, e2, s3) {
    if (e2.isEmpty()) return;
    if (void 0 !== s3 && !s3.contains(e2.getXY())) return;
    this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + 1), this.m_verticesMp.add(e2), this.m_xyStream = this.m_vertices.getAttributeStreamRef(0), this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size() + 1);
    const n5 = this.insertPath(t3, cr);
    this.insertVertex_(n5, cr, null, false);
  }
  appendMultiPoint_(t3, e2) {
    this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + e2.getPointCount()), this.m_verticesMp.addPoints(e2, 0, e2.getPointCount()), this.m_xyStream = this.m_vertices.getAttributeStreamRef(0), this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size() + e2.getPointCount());
    const s3 = this.insertPath(t3, cr);
    for (let n5 = 0, i2 = e2.getPointCount(); n5 < i2; n5++) this.insertVertex_(s3, cr, null, false);
  }
  appendMultiPoint(t3, e2, s3) {
    if (void 0 === s3) return void this.appendMultiPoint_(t3, e2);
    const n5 = e2.getAttributeStreamRef(0);
    let i2 = 0;
    for (let u = 0, m3 = e2.getPointCount(); u < m3; u++) {
      const t4 = n5.readPoint2D(2 * u);
      s3.contains(t4) && i2++;
    }
    this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + i2);
    let r = -1, o = -1, a2 = 0;
    for (let u = 0, m3 = e2.getPointCount(); u < m3; u++) {
      const t4 = n5.readPoint2D(2 * u);
      s3.contains(t4) ? (-1 === r && (r = u, o = u), o++) : r >= 0 && (this.m_verticesMp.addPoints(e2, r, o - r), r = -1, a2++);
    }
    if (r > 0 && (this.m_verticesMp.addPoints(e2, r, o - r), a2++), !a2) return;
    this.m_xyStream = this.m_vertices.getAttributeStreamRef(0), this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size() + i2);
    const h2 = this.insertPath(t3, cr);
    for (let u = 0, m3 = e2.getPointCount(); u < m3; u++) {
      const t4 = n5.readPoint2D(2 * u);
      s3.contains(t4) && this.insertVertex_(h2, cr, null, false);
    }
  }
  splitSegmentForward(s3, n5, i2, r, o) {
    const a2 = this.getNextVertex(s3);
    a2 === cr && P("Edit_shape.split_segment_forward_");
    const h2 = this.getHelperPoint(), u = this.getPathFromVertex(s3);
    let m3 = s3;
    const l2 = this.hasSegmentParentage();
    for (let t3 = 0, c = n5.getResultSegmentCount(i2); t3 < c; t3++) {
      const s4 = this.getVertexIndex(m3), r2 = this.getNextVertex(m3), g2 = n5.getResultSegment(i2, t3);
      let d2 = null;
      if (g2.getGeometryType() !== a.enumLine && (d2 = g2.clone(), d2.dropAllAttributes()), 0 === t3 && (g2.queryStart(h2), this.setSegmentToIndex(s4, null), this.setPointEx(m3, h2, n5.getResultSegmentStartPointRank(i2, t3), n5.getResultSegmentStartPointWeight(i2, t3), o)), this.setSegmentRank(m3, n5.getResultSegmentInteriorRank(i2, t3)), this.setSegmentWeight(m3, n5.getResultSegmentInteriorWeight(i2, t3)), l2) {
        const e2 = n5.getResultSegmentSegmentParentage(i2, t3), s5 = n5.getResultSegmentStartPointIsBreak(i2, t3);
        this.setSegmentParentageAndBreak(m3, e2, s5);
      }
      if (g2.queryEnd(h2), t3 < c - 1) {
        this.setSegmentToIndex(s4, d2);
        const e2 = this.insertVertex(u, r2, h2);
        this.setWeight(e2, n5.getResultSegmentEndPointWeight(i2, t3)), this.setRank(e2, n5.getResultSegmentEndPointRank(i2, t3)), this.select(e2), m3 = e2;
      } else {
        this.setPointEx(a2, h2, n5.getResultSegmentEndPointRank(i2, t3), n5.getResultSegmentEndPointWeight(i2, t3), o);
        const e2 = n5.getResultSegmentEndPointIsBreak(i2, t3);
        this.setSegmentParentageBreakVertex(a2, e2), this.setSegmentToIndex(s4, d2);
      }
    }
  }
  splitSegmentBackward(s3, n5, i2, r, o) {
    const a2 = this.getNextVertex(s3);
    a2 === cr && P("Edit_shape.split_segment_backward_");
    const h2 = this.getHelperPoint(), u = this.getPathFromVertex(s3);
    let m3 = s3;
    const l2 = this.hasSegmentParentage();
    for (let t3 = 0, c = n5.getResultSegmentCount(i2); t3 < c; t3++) {
      const s4 = c - t3 - 1, r2 = this.getVertexIndex(m3), g2 = this.getNextVertex(m3), d2 = n5.getResultSegment(i2, s4);
      let _ = null;
      if (d2.getGeometryType() !== a.enumLine && (_ = d2.clone(), _.reverse(), _.dropAllAttributes()), 0 === t3 && (d2.queryEnd(h2), this.setSegmentToIndex(r2, null), this.setPointEx(m3, h2, n5.getResultSegmentEndPointRank(i2, s4), n5.getResultSegmentEndPointWeight(i2, s4), o), this.setSegmentParentageAndBreak(m3, n5.getResultSegmentSegmentParentage(i2, s4), n5.getResultSegmentEndPointIsBreak(i2, s4))), d2.getGeometryType() === a.enumLine ? this.setSegmentToIndex(r2, null) : this.setSegmentToIndex(r2, _), this.setSegmentRank(m3, n5.getResultSegmentInteriorRank(i2, s4)), this.setSegmentWeight(m3, n5.getResultSegmentInteriorWeight(i2, s4)), d2.queryStart(h2), t3 < c - 1) {
        const t4 = this.insertVertex(u, g2, h2);
        this.setWeight(t4, n5.getResultSegmentStartPointWeight(i2, s4)), this.setRank(t4, n5.getResultSegmentStartPointRank(i2, s4)), this.select(t4), m3 = t4, l2 && this.setSegmentParentageAndBreak(t4, n5.getResultSegmentSegmentParentage(i2, s4), n5.getResultSegmentEndPointIsBreak(i2, s4));
      } else this.setPointEx(a2, h2, n5.getResultSegmentStartPointRank(i2, s4), n5.getResultSegmentStartPointWeight(i2, s4), o);
    }
  }
  selected_(t3) {
    return this.getUserIndex(t3, this.m_selectionIndex) >= 0;
  }
  allocateIndex(t3 = true) {
    if (this.m_deletedIndices.length) {
      const e2 = this.m_deletedIndices.pop();
      return t3 && e2.setRange(-1, 0, e2.size()), e2;
    }
    return t3 ? J2(0, -1) : J2(0);
  }
  recycleUserIndex(t3) {
    this.m_deletedIndices.push(t3);
  }
  allocatePathIndex() {
    if (this.m_deletedPathIndices.length) {
      const t3 = this.m_deletedPathIndices.at(-1);
      return this.m_deletedPathIndices.pop(), t3;
    }
    return J2(0);
  }
  recyclePathUserIndex(t3) {
    this.m_deletedPathIndices.push(t3);
  }
  peelALoop_(t3, e2, s3) {
    const n5 = this.getNextVertex(t3), i2 = this.getNextVertex(e2), r = this.getVertexIndex(t3), o = this.getVertexIndex(e2);
    if (this.setNextVertex(t3, i2), this.setPrevVertex(i2, t3), this.setNextVertex(e2, n5), this.setPrevVertex(n5, e2), this.m_segments) {
      const t4 = this.getSegmentFromIndex(r), e3 = this.getSegmentFromIndex(o);
      this.setSegmentToIndex(o, null), this.setSegmentToIndex(r, e3), this.setSegmentToIndex(o, t4);
    }
    if (this.hasSegmentParentage()) {
      let s4 = this.getSegmentParentage(e2), n6 = this.getSegmentParentage(t3);
      -1 === s4 && -1 === n6 || (n6 = Pt(s4, s4 = n6), this.setSegmentParentageAndBreak(t3, n6), this.setSegmentParentageAndBreak(e2, s4));
    }
    if (s3) {
      const e3 = this.getPathFromVertex(t3), s4 = this.getGeometryFromPath(e3), r2 = [false], o2 = this.insertClosedPath(s4, cr, n5, this.getFirstVertex(e3), r2);
      r2[0] && this.setFirstVertex(e3, i2);
      let a2 = this.getPathSize(e3);
      return a2 -= this.getPathSize(o2), this.setPathSize(e3, a2), o2;
    }
    return cr;
  }
  sortVerticesSimpleByYHelper(t3, e2, s3) {
    t3.sort(e2, s3, (t4, e3) => {
      let s4 = this.compareVerticesSimpleY(t4, e3);
      if (0 === s4) {
        const n5 = this.getPathInternalIndexFromVertex(t4), i2 = this.getPathInternalIndexFromVertex(e3);
        s4 = n5 < i2 ? -1 : n5 > i2 ? 1 : 0;
      }
      return s4;
    });
  }
  sortVerticesSimpleByYHelper3D(t3, e2, s3) {
    n(0);
  }
  constructor() {
    this.m_verticesMp = null, this.m_vertices = null, this.m_xyStream = null, this.m_vertexDescription = null, this.m_segments = null, this.m_weights = null, this.m_ranks = null, this.m_segmentWeights = null, this.m_segmentRanks = null, this.m_indices = [], this.m_deletedIndices = [], this.m_pathAreas = [], this.m_pathLengths = [], this.m_pathindices = [], this.m_deletedPathIndices = [], this.m_geometryIndices = [], this.m_selectedVertices = [], this.m_helperPoint = null, this.m_forceSetEnvelope = G3.constructEmpty(), this.m_hasForceSetEnvelope = 0, this.m_workPoint2D = mi.getNAN(), this.m_workPoint2_2D = mi.getNAN(), this.m_curveStitcher = null, this.m_pathCount = 0, this.m_pointCount = 0, this.m_firstGeometry = cr, this.m_lastGeometry = cr, this.m_vertexIndexList = new at(5), this.m_pathIndexList = new at(8), this.m_geometryIndexList = new at(8), this.m_bHasAttributes = false, this.m_selectedCount = 0, this.m_selectionIndex = -1, this.m_selection = false, this.m_bucketSort = new ot(), this.m_segmentParentageIndex = -1;
  }
  getTotalPointCount() {
    return this.m_pointCount;
  }
  getEnvelope2D(t3) {
    if (0 !== this.m_hasForceSetEnvelope) return new n3(this.m_forceSetEnvelope.xmin, this.m_forceSetEnvelope.ymin, this.m_forceSetEnvelope.xmax, this.m_forceSetEnvelope.ymax);
    const e2 = this.hasCurves(), s3 = n3.constructEmpty(), n5 = this.queryVertexIterator();
    let i2 = true;
    for (let r = n5.next(); r !== cr; r = n5.next()) {
      if (i2 ? s3.merge(this.getXY(r)) : s3.mergeNe(this.getXY(r)), e2) {
        const t4 = this.getSegment(r);
        if (null !== t4) {
          const e3 = n3.constructEmpty();
          t4.queryLooseEnvelope(e3), s3.mergeEnvelope2D(e3);
        }
      }
      i2 = false;
    }
    return s3;
  }
  getEnvelope3D(t3) {
    return n(0), G3.constructEmpty();
  }
  forceSetEnvelope2D(t3) {
    this.m_hasForceSetEnvelope = 1, this.m_forceSetEnvelope.setCoords(t3.xmin, t3.ymin, 0, t3.xmax, t3.ymax, 0);
  }
  forceSetEnvelope3D(t3) {
    n(0);
  }
  forgetForceSetEnvelope() {
    this.m_hasForceSetEnvelope = 0;
  }
  getGeometryCount() {
    return this.m_geometryIndexList.size();
  }
  addGeometry(s3, n5) {
    const i2 = s3.getGeometryType();
    if (h(i2)) return this.addMultiPath(s3, n5);
    if (i2 === a.enumMultiPoint) return this.addMultiPoint(s3, n5);
    if (i2 === a.enumPoint) return this.addPoint_(s3, n5);
    if (i2 === a.enumEnvelope) {
      const t3 = new ur();
      return t3.addEnvelope(s3, false), this.addMultiPath(t3, n5);
    }
    P("");
  }
  appendGeometry(s3, n5) {
    this.mergeVertexDescription(n5.getDescription());
    const i2 = n5.getGeometryType();
    h(i2) ? this.appendMultiPath(s3, n5) : i2 !== a.enumMultiPoint ? P("") : this.appendMultiPoint(s3, n5);
  }
  assignRankToGeometryVertices(t3, e2) {
    e2 < gr && (e2 = gr);
    const s3 = this.queryVertexIterator();
    for (let n5 = s3.next(); n5 !== cr; n5 = s3.next()) this.setRank(n5, e2), this.setSegmentRank(n5, e2);
  }
  collapseAllGeometriesToFirst() {
    this.collapseGeometriesToFirst(a.enumUnknown);
  }
  collapseGeometriesToFirst(t3) {
    this.dbgVerifyVertexCounts();
    let s3 = cr, n5 = -1, i2 = -1;
    for (let r = this.getFirstGeometry(); r !== cr; ) {
      if (t3 === a.enumUnknown || this.getGeometryType(r) === t3) {
        if (s3 === cr) {
          s3 = r, n5 = this.getPathCount(s3), i2 = this.getPointCount(s3), r = this.getNextGeometry(r);
          continue;
        }
        for (let n6 = this.getFirstPath(r); n6 !== cr; n6 = this.getNextPath(n6)) this.setPathGeometry(n6, s3);
        n5 += this.getPathCount(r), i2 += this.getPointCount(r);
        const t4 = this.getLastPath(s3), e2 = this.getFirstPath(r);
        t4 !== cr ? this.setNextPath(t4, e2) : this.setFirstPath(s3, e2), e2 !== cr && (this.setPrevPath(e2, t4), this.setLastPath(s3, this.getLastPath(r))), this.setFirstPath(r, cr), this.setLastPath(r, cr);
        const o = r;
        r = this.getNextGeometry(r), this.setGeometryVertexCount(o, 0), this.removeGeometry(o);
        continue;
      }
      r = this.getNextGeometry(r);
    }
    return s3 !== cr && (this.setGeometryVertexCount(s3, i2), this.setGeometryPathCount(s3, n5), this.dbgVerifyVertexCounts()), s3;
  }
  setFillRule(t3, e2) {
    let s3 = this.m_geometryIndexList.getField(t3, 2);
    s3 &= -134217729, s3 |= 1 === e2 ? 134217728 : 0, this.m_geometryIndexList.setField(t3, 2, s3);
  }
  getFillRule(t3) {
    return 134217728 & this.m_geometryIndexList.getField(t3, 2) ? 1 : 0;
  }
  setGeometryModified(t3, e2) {
    let s3 = this.m_geometryIndexList.getField(t3, 2);
    !!(67108864 & s3) !== e2 && (s3 &= -67108865, s3 |= e2 ? 67108864 : 0, this.m_geometryIndexList.setField(t3, 2, s3));
  }
  getGeometryModified(t3) {
    return !!(67108864 & this.m_geometryIndexList.getField(t3, 2));
  }
  setGeometryModifiedWithVertex(t3, e2) {
    const s3 = this.getPathFromVertex(t3), n5 = this.getGeometryFromPath(s3);
    this.setGeometryModified(n5, e2);
  }
  getGeometryModifiedWithVertex(t3) {
    const e2 = this.getPathFromVertex(t3), s3 = this.getGeometryFromPath(e2);
    return this.getGeometryModified(s3);
  }
  swapGeometry(t3, e2) {
    const s3 = this.getFirstPath(t3), n5 = this.getFirstPath(e2), i2 = this.getLastPath(t3), r = this.getLastPath(e2);
    for (let c = this.getFirstPath(t3); c !== cr; c = this.getNextPath(c)) this.setPathGeometry(c, e2);
    for (let c = this.getFirstPath(e2); c !== cr; c = this.getNextPath(c)) this.setPathGeometry(c, t3);
    this.setFirstPath(t3, n5), this.setFirstPath(e2, s3), this.setLastPath(t3, r), this.setLastPath(e2, i2);
    const o = this.getPointCount(t3), a2 = this.getPathCount(t3), h2 = this.getPointCount(e2), u = this.getPathCount(e2);
    this.setGeometryVertexCount(t3, h2), this.setGeometryVertexCount(e2, o), this.setGeometryPathCount(t3, u), this.setGeometryPathCount(e2, a2);
    const m3 = this.m_geometryIndexList.getField(t3, 2), l2 = this.m_geometryIndexList.getField(e2, 2);
    this.m_geometryIndexList.setField(t3, 2, l2), this.m_geometryIndexList.setField(e2, 2, m3);
  }
  addPathFromMultiPath(t3, s3, n5) {
    const i2 = this.createGeometry(n5 ? a.enumPolygon : a.enumPolyline, t3.getDescription()), r = t3.getImpl();
    if (t3.getPathSize(s3) < 2) return i2;
    this.m_vertices.reserveRounded(this.m_vertices.getPointCount() + t3.getPathSize(s3)), this.m_verticesMp.addPoints(t3, t3.getPathStart(s3), r.getPathEnd(s3)), this.m_xyStream = this.m_vertices.getAttributeStreamRef(0);
    const o = this.insertPath(i2, cr);
    this.setClosedPath(o, r.isClosedPath(s3) || n5);
    const a2 = null !== this.m_segments || null !== r.getSegmentFlagsStreamRef();
    for (let e2 = r.getPathStart(s3), h2 = r.getPathEnd(s3); e2 < h2; e2++) {
      const t4 = this.insertVertex_(o, cr, null, false);
      if (a2) {
        const s4 = this.getVertexIndex(t4);
        if (1 & r.getSegmentFlags(e2)) this.setSegmentToIndex(s4, null);
        else {
          const t5 = new fm();
          r.querySegment(e2, t5, true), this.setSegmentToIndex(s4, t5.releaseSegment());
        }
      }
    }
    return r.isStrongPathStart(s3) && this.setStrongPathStart(o, true), r.isStrongPathEnd(s3) && this.setStrongPathEnd(o, true), i2;
  }
  getGeometry(t3) {
    const s3 = this.getGeometryType(t3), n5 = mr(s3, this.m_verticesMp.getDescription()), i2 = this.getPointCount(t3);
    if (0 === i2) return n5;
    if (h(s3)) {
      const e2 = n5.getImpl(), s4 = this.getPathCount(t3), r = J2(s4 + 1), o = K2(s4 + 1, 0), a2 = n5.getDescription(), h2 = this.hasCurves();
      for (let n6 = 0, u = a2.getAttributeCount(); n6 < u; n6++) {
        const h3 = a2.getSemantics(n6), u2 = lr.getComponentCount(h3), m3 = j3(h3, i2), l2 = this.m_vertices.getAttributeStreamRef(h3);
        let c = 0, g2 = 0, d2 = 0;
        for (let e3 = this.getFirstPath(t3); e3 !== cr; e3 = this.getNextPath(e3)) {
          let t4 = 0;
          this.isClosedPath(e3) && (t4 |= 1), this.isExterior(e3) && (t4 |= 8), this.isStrongPathStart(e3) && (t4 |= 2), this.isStrongPathEnd(e3) && (t4 |= 4), t4 && o.setBits(g2, t4);
          const s5 = this.getPathSize(e3);
          if (r.write(g2++, d2), d2 += s5, 0 === h3) {
            const t5 = l2, s6 = m3;
            let n7;
            for (let i3 = this.getFirstVertex(e3); c < d2; i3 = this.getNextVertex(i3), c++) {
              const e4 = this.getVertexIndex(i3);
              n7 = t5.readPoint2D(2 * e4), s6.writePoint2D(2 * c, n7);
            }
          } else for (let n7 = this.getFirstVertex(e3); c < d2; n7 = this.getNextVertex(n7), c++) {
            const t5 = this.getVertexIndex(n7);
            for (let e4 = 0; e4 < u2; e4++) {
              const s6 = l2.readAsDbl(t5 * u2 + e4);
              m3.writeAsDbl(c * u2 + e4, s6);
            }
          }
        }
        e2.setAttributeStreamRef(h3, m3), r.write(s4, i2);
      }
      if (e2.setPathFlagsStreamRef(o), e2.setPathStreamRef(r), e2.notifyModifiedFlags(65535), h2) {
        let s5 = 0, n6 = 0;
        for (let i3 = this.getFirstPath(t3); i3 !== cr; i3 = this.getNextPath(i3)) {
          s5 += this.getPathSize(i3);
          for (let t4 = this.getFirstVertex(i3); n6 < s5; t4 = this.getNextVertex(t4)) {
            const s6 = this.getSegment(t4);
            null !== s6 && s6.isCurve() && e2.replaceSegment(n6, s6, true), n6++;
          }
        }
      }
    } else if (s3 === a.enumMultiPoint) {
      const e2 = n5.getImpl(), s4 = n5.getDescription();
      e2.reserve(i2), e2.resizeNoInit(i2);
      for (let n6 = 0, i3 = s4.getAttributeCount(); n6 < i3; n6++) {
        const i4 = s4.getSemantics(n6), r = lr.getComponentCount(i4), o = e2.getAttributeStreamRef(i4), a2 = this.m_vertices.getAttributeStreamRef(i4);
        let h2 = 0;
        const u = this.getFirstPath(t3), m3 = this.getPathSize(u);
        for (let t4 = this.getFirstVertex(u); h2 < m3; t4 = this.getNextVertex(t4), h2++) {
          const e3 = this.getVertexIndex(t4);
          for (let t5 = 0; t5 < r; t5++) {
            const s5 = a2.readAsDbl(e3 * r + t5);
            o.writeAsDbl(h2 * r + t5, s5);
          }
        }
        e2.setAttributeStreamRef(i4, o);
      }
      e2.notifyModifiedFlags(65535);
    } else b("getGeometry");
    return n5;
  }
  queryPointGeometryOnly(s3, n5) {
    this.getGeometryType(s3) !== a.enumMultiPoint && P("get_point_geometry_only");
    const i2 = this.getPointCount(s3);
    if (i2 > 1 && P("get_point_geometry_only"), 0 === i2) return n5.assignVertexDescription(this.m_vertexDescription), void n5.setEmpty();
    const r = this.getFirstPath(s3), o = this.getFirstVertex(r);
    this.queryPoint(o, n5);
  }
  removeGeometry(t3) {
    for (let n5 = this.getFirstPath(t3); n5 !== cr; n5 = this.removePath(n5)) ;
    const e2 = this.getPrevGeometry(t3), s3 = this.getNextGeometry(t3);
    return e2 !== cr ? this.setNextGeometry(e2, s3) : this.m_firstGeometry = s3, s3 !== cr ? this.setPrevGeometry(s3, e2) : this.m_lastGeometry = e2, this.freeGeometry(t3), s3;
  }
  createGeometry(t3, e2) {
    void 0 === e2 && (e2 = M());
    const s3 = this.newGeometry(t3);
    return this.m_vertices || (this.m_verticesMp = new cs2({ vd: e2 }), this.m_vertices = this.m_verticesMp.getImpl()), this.mergeVertexDescription(e2), this.m_firstGeometry === cr ? (this.m_firstGeometry = s3, this.m_lastGeometry = s3) : (this.setPrevGeometry(s3, this.m_lastGeometry), this.setNextGeometry(this.m_lastGeometry, s3), this.m_lastGeometry = s3), s3;
  }
  getFirstGeometry() {
    return this.m_firstGeometry;
  }
  getLastGeometry() {
    return this.m_lastGeometry;
  }
  getNextGeometry(t3) {
    return this.m_geometryIndexList.getField(t3, 1);
  }
  getPrevGeometry(t3) {
    return this.m_geometryIndexList.getField(t3, 0);
  }
  getGeometryType(t3) {
    return 16777215 & this.m_geometryIndexList.getField(t3, 2);
  }
  setGeometryUserIndex(t3, e2, s3) {
    const n5 = this.m_geometryIndices[e2], i2 = this.getGeometryIndex(t3);
    i2 >= n5.size() && n5.resize(Math.max(1.25 * i2, 16), -1), n5.write(i2, s3);
  }
  getGeometryUserIndex(t3, e2) {
    const s3 = this.getGeometryIndex(t3), n5 = this.m_geometryIndices[e2];
    return s3 < n5.size() ? n5.read(s3) : -1;
  }
  createGeometryUserIndex() {
    for (let e2 = 0; e2 < this.m_geometryIndices.length; e2++) if (null === this.m_geometryIndices[e2]) return this.m_geometryIndices[e2] = J2(0), e2;
    this.m_geometryIndices.push(J2(0));
    const t3 = this.m_geometryIndices.length - 1;
    return n(t3 >= 0 && t3 <= Number.MAX_SAFE_INTEGER), t3;
  }
  removeGeometryUserIndex(t3) {
    for (this.m_geometryIndices[t3] = null; this.m_geometryIndices.length > 0 && null === this.m_geometryIndices.at(-1); ) this.m_geometryIndices.pop();
  }
  getFirstPath(t3) {
    return this.m_geometryIndexList.getField(t3, 3);
  }
  getLastPath(t3) {
    return this.m_geometryIndexList.getField(t3, 4);
  }
  hasPointFeatures() {
    for (let t3 = this.getFirstGeometry(); t3 !== cr; t3 = this.getNextGeometry(t3)) if (!h(this.getGeometryType(t3))) return true;
    return false;
  }
  getPointCount(t3) {
    return this.m_geometryIndexList.getField(t3, 5);
  }
  getPathCount(t3) {
    return this.m_geometryIndexList.getField(t3, 6);
  }
  filterClosePoints(t3, s3, i2, r, o) {
    const a2 = t3 * t3;
    let h2 = 0;
    const u = this.hasCurves(), m3 = this.hasSegmentParentage(), l2 = true;
    for (let g2 = o === cr ? this.getFirstGeometry() : o; g2 !== cr; g2 = o === cr ? this.getNextGeometry(g2) : cr) {
      const t4 = this.getGeometryType(g2);
      if (!h(t4)) continue;
      if (i2 && t4 !== a.enumPolygon) continue;
      const o2 = this.getGeometryType(g2) === a.enumPolygon;
      let d2 = this.getGeometryModified(g2);
      for (let e2 = this.getFirstPath(g2); e2 !== cr; ) {
        let t5 = 0;
        for (let s4 = this.getFirstVertex(e2); t5 < Math.trunc(this.getPathSize(e2) / 2); ) {
          const i4 = this.getNextVertex(s4);
          if (i4 === cr) break;
          const o3 = this.getXY(s4), c2 = this.getXY(i4);
          let _2 = mi.sqrDistance(o3, c2), p3 = true;
          do {
            if (_2 <= a2) {
              if (u) {
                const t6 = this.getSegment(s4);
                if (null !== t6) {
                  const e3 = t6.calculateLength2D();
                  if (_2 = e3 * e3, _2 > a2) break;
                }
              }
              if (0 === _2 ? 0 === h2 && (h2 = -1) : h2 = 1, i4 !== this.getLastVertex(e2)) {
                const t6 = m3 && (this.getSegmentParentageBreakVertex(s4) || this.getSegmentParentageBreakVertex(i4));
                if (this.transferAllDataToTheVertex(i4, s4, l2), this.removeVertex(i4, false), r && !d2 && (this.setGeometryModified(g2, true), d2 = true), m3 && s4 !== i4) {
                  this.setSegmentParentageBreakVertex(s4, t6);
                  const e3 = this.getNextVertex(s4);
                  n(e3 !== cr), this.isDiscontinuousSegmentParentage(e3) && this.setSegmentParentageBreakVertex(e3, true);
                }
              }
              p3 = false;
            }
          } while (0);
          p3 && (s4 = this.getNextVertex(s4)), t5++;
        }
        let i3 = this.getFirstVertex(e2);
        for (let s4 = this.isClosedPath(e2) ? i3 : this.getLastVertex(e2); this.getPathSize(e2) > 0; ) {
          const t6 = this.getPrevVertex(s4);
          if (t6 === cr) break;
          {
            const o3 = this.getXY(t6), c2 = this.getXY(s4);
            let _2 = mi.sqrDistance(o3, c2), p3 = true;
            do {
              if (_2 <= a2) {
                if (u) {
                  const e3 = this.getSegment(t6);
                  if (null !== e3) {
                    const t7 = e3.calculateLength2D();
                    if (_2 = t7 * t7, _2 > a2) break;
                  }
                }
                if (0 === _2 ? 0 === h2 && (h2 = -1) : h2 = 1, m3) {
                  n(this.m_segmentParentageIndex >= 0);
                  const e3 = this.getUserIndex(s4, this.m_segmentParentageIndex);
                  this.transferAllDataToTheVertex(t6, s4, l2), this.setUserIndex(s4, this.m_segmentParentageIndex, e3);
                } else this.transferAllDataToTheVertex(t6, s4, l2);
                const o4 = m3 && (this.getSegmentParentageBreakVertex(s4) || this.getSegmentParentageBreakVertex(t6));
                this.removeVertex(t6, true), r && !d2 && (this.setGeometryModified(g2, true), d2 = true), m3 && t6 !== s4 && (o4 || this.isDiscontinuousSegmentParentage(s4)) && this.setSegmentParentageBreakVertex(s4, true), i3 === t6 && (i3 = this.getFirstVertex(e2)), p3 = false;
              }
            } while (0);
            if (p3 && (s4 = this.getPrevVertex(s4), s4 === i3)) break;
          }
        }
        const c = this.getPathSize(e2);
        let _ = s3 && c < (o2 ? 3 : 2);
        _ && o2 && 2 === c && u && (_ = !this.pathHasCurves(e2)), _ ? (e2 = this.removePath(e2), 0 === h2 && (h2 = -1), r && !d2 && (this.setGeometryModified(g2, true), d2 = true)) : e2 = this.getNextPath(e2);
      }
    }
    return h2;
  }
  filterClosePoints3D(t3, e2, s3, i2, r, o) {
    return n(0), 0;
  }
  hasDegenerateSegments(t3) {
    for (let e2 = this.getFirstGeometry(); e2 !== cr; e2 = this.getNextGeometry(e2)) if (h(this.getGeometryType(e2))) for (let s3 = this.getFirstPath(e2); s3 !== cr; ) {
      const e3 = this.getPathSize(s3);
      if (0 === e3) return true;
      let n5 = this.getFirstVertex(s3);
      for (let s4 = 0; s4 < e3; s4++) {
        const e4 = this.getNextVertex(n5);
        if (e4 === cr) break;
        const s5 = this.getVertexIndex(n5), i2 = this.getSegmentFromIndex(s5);
        let r = 0;
        if (null !== i2) {
          if (r = i2.calculateLowerLength2D(), r <= t3) {
            if (r = i2.calculateUpperLength2D(), r <= t3) return true;
            if (r = i2.calculateLength2D(), r <= t3) return true;
          }
        } else {
          const n6 = this.getVertexIndex(e4);
          if (r = this.m_vertices.getShortestDistance(s5, n6), r <= t3) return true;
        }
        n5 = e4;
      }
      s3 = this.getNextPath(s3);
    }
    return false;
  }
  hasDegenerateSegments3D(t3, e2) {
    return n(0), false;
  }
  transferAllDataToTheVertex(t3, e2, s3 = false) {
    const n5 = this.getVertexIndex(t3), i2 = this.getVertexIndex(e2);
    if (s3) {
      let t4 = 1, e3 = 1;
      if (this.m_ranks && (t4 = this.getRankWithIndex(n5), e3 = this.getRankWithIndex(i2)), t4 > e3 && this.setRankWithIndex(i2, t4), t4 >= e3 && this.m_weights) {
        const s4 = this.getWeightWithIndex(n5), r2 = this.getWeightWithIndex(i2);
        (t4 > e3 || s4 > r2) && this.setWeightWithIndex(i2, s4);
      }
    } else {
      if (this.m_weights) {
        const t4 = this.getWeightWithIndex(n5);
        this.setWeightWithIndex(i2, t4);
      }
      if (this.m_ranks) {
        const t4 = this.getRankWithIndex(n5);
        this.setRankWithIndex(i2, t4);
      }
    }
    if (this.m_segmentWeights) {
      const t4 = this.getSegmentWeightWithIndex(n5);
      this.setSegmentWeightWithIndex(i2, t4);
    }
    if (this.m_segmentRanks) {
      const t4 = this.getSegmentRankWithIndex(n5);
      this.setSegmentRankWithIndex(i2, t4);
    }
    for (let o = 0, a2 = this.m_indices.length; o < a2; o++) if (o !== this.m_selectionIndex && null !== this.m_indices[o]) {
      const s4 = this.getUserIndex(t3, o);
      this.setUserIndex(e2, o, s4);
    }
    const r = this.selected(t3);
    r !== this.selected(e2) && (r ? this.select(e2) : this.unselect(e2));
  }
  splitSegmentAxisAware(e2, s3, n5, i2, r) {
    let o = 0;
    const a2 = this.getNextVertex(e2);
    a2 === cr && P("");
    const h2 = this.getVertexIndex(e2), u = this.getVertexIndex(a2), m3 = this.getSegmentFromIndex(h2);
    let l2 = this.m_vertices.getShortestDistance(h2, u);
    const c = this.getPathFromVertex(e2), g2 = this.m_bHasAttributes;
    g2 && m3 && (l2 = m3.calculateLength2D());
    const d2 = this.getSegmentParentage(e2), _ = this.getHelperPoint();
    if (m3) {
      let t3 = 0, e3 = 0, r2 = cr;
      for (let p3 = 0; p3 < n5; p3++) {
        const n6 = s3[p3];
        if (t3 < n6 && n6 < 1) {
          const s4 = m3.cut(t3, n6);
          if (null !== i2 && (p3 > 0 && s4.setStartXY(i2[p3 - 1]), s4.setEndXY(i2[p3]), s4.normalizeAfterEndpointChange(), e3 = p3), g2) {
            const t4 = l2 > 0 ? m3.calculateSubLengthFromStart(n6) / l2 : 0;
            this.m_vertices.interpolateTwoVertices(h2, u, t4, _);
          }
          _.setXY(s4.getEndXY()), r2 = this.insertVertex(c, a2, _), o++;
          const f3 = this.getPrevVertex(r2), P5 = this.getVertexIndex(f3);
          this.setSegmentToIndex(P5, s4), -1 !== d2 && this.setSegmentParentageAndBreak(r2, d2, false), t3 = n6;
        }
      }
      if (r2 !== cr) {
        const s4 = m3.cut(t3, 1);
        null !== i2 && (s4.setStartXY(i2[e3]), s4.normalizeAfterEndpointChange());
        const n6 = this.getVertexIndex(r2);
        this.setSegmentToIndex(n6, s4);
      }
    } else {
      let t3 = 0;
      for (let e3 = 0; e3 < n5; e3++) {
        const n6 = s3[e3];
        if (t3 < n6 && n6 < 1) {
          this.m_vertices.interpolateTwoVertices(h2, u, n6, _);
          const t4 = this.insertVertex(c, a2, _);
          o++, -1 !== d2 && this.setSegmentParentageAndBreak(t4, d2, false);
        }
        t3 = n6;
      }
    }
    return o;
  }
  splitSegment(t3, e2, s3, n5 = null) {
    return this.splitSegmentAxisAware(t3, e2, s3, n5, -1);
  }
  snapControlPoints(e2, s3, n5) {
    this.getNextVertex(e2) === cr && P("");
    let i2 = e2, r = false;
    for (let t3 = 0; t3 < s3; ++t3) {
      const t4 = this.getVertexIndex(i2), e3 = this.getSegmentFromIndex(t4);
      if (e3) {
        const t5 = e3.snapControlPoints(n5);
        r ||= t5;
      }
      i2 = this.getNextVertex(i2);
    }
    return r;
  }
  snapControlPointsOnSelection(t3) {
    if (!this.hasCurves()) return false;
    let e2 = 0;
    const s3 = this.queryVertexIteratorOnSelection();
    for (let n5 = s3.next(); n5 !== cr; n5 = s3.next()) {
      const s4 = this.getVertexIndex(n5), i2 = this.getSegmentFromIndex(s4);
      i2 && (e2 |= i2.snapControlPoints(t3) ? 1 : 0);
    }
    return 0 !== e2;
  }
  calculateSubLength2D(t3, e2, s3) {
    return n(0), 0;
  }
  setPoint(t3, e2, s3) {
    if (this.setPointOnly(t3, e2), null !== this.m_segments) {
      const n5 = this.getVertexIndex(t3), i2 = this.getSegmentFromIndex(n5);
      null !== i2 && (i2.setStartXY(e2.getXY()), i2.normalizeAfterEndpointChange(), s3 && i2.ensureXYMonotone());
      const r = this.getPrevVertex(t3);
      if (r !== cr) {
        const t4 = this.getVertexIndex(r), n6 = this.getSegmentFromIndex(t4);
        null !== n6 && (n6.setEndXY(e2.getXY()), n6.normalizeAfterEndpointChange(), s3 && n6.ensureXYMonotone());
      }
    }
  }
  setPointEx(t3, e2, s3, n5, i2) {
    this.setPoint(t3, e2, i2);
    const r = this.getVertexIndex(t3);
    this.setWeightWithIndex(r, n5), this.setRankWithIndex(r, s3);
  }
  setPointOnly(t3, e2) {
    const s3 = this.getVertexIndex(t3);
    this.m_vertices.setPointByValNoCurves(s3, e2);
  }
  setPointOnlyEx(t3, e2, s3, i2) {
    n(0);
  }
  queryPoint(t3, e2) {
    const s3 = this.getVertexIndex(t3);
    this.m_vertices.getPointByVal(s3, e2);
  }
  setXY(t3, e2) {
    this.setXYCoords(t3, e2.x, e2.y);
  }
  setXYCoords(t3, e2, s3) {
    const n5 = this.getVertexIndex(t3);
    if (this.m_vertices?.setXYCoordsNoCurves(n5, e2, s3), null !== this.m_segments) {
      const i2 = this.getSegmentFromIndex(n5);
      null !== i2 && (i2.setStartXYCoords(e2, s3), i2.normalizeAfterEndpointChange());
      const r = this.getPrevVertex(t3);
      if (r !== cr) {
        const t4 = this.getVertexIndex(r), n6 = this.getSegmentFromIndex(t4);
        null != n6 && (n6.setEndXYCoords(e2, s3), n6.normalizeAfterEndpointChange());
      }
    }
  }
  setXYMonotonic(t3, e2, s3) {
    const n5 = this.getVertexIndex(t3);
    if (this.m_vertices.setXYCoordsNoCurves(n5, e2, s3), null !== this.m_segments) {
      const i2 = this.getSegmentFromIndex(n5);
      if (null !== i2) {
        const t4 = i2.getEndXY();
        i2.setCoordsForIntersector(new mi(e2, s3), t4, false), i2.ensureXYMonotone();
      }
      const r = this.getPrevVertex(t3);
      if (r !== cr) {
        const t4 = this.getVertexIndex(r), n6 = this.getSegmentFromIndex(t4);
        if (null !== n6) {
          const t5 = n6.getStartXY();
          n6.setCoordsForIntersector(t5, new mi(e2, s3), false), n6.ensureXYMonotone();
        }
      }
    }
  }
  setXYMonotonicPoint2D(t3, e2) {
    this.setXYMonotonic(t3, e2.x, e2.y);
  }
  queryXY(t3, e2) {
    const s3 = this.getVertexIndex(t3);
    return this.m_vertices.queryXY(s3, e2);
  }
  getXY(t3) {
    const e2 = this.getVertexIndex(t3);
    return this.m_vertices.getXY(e2);
  }
  getXYWithIndex(t3) {
    return this.m_xyStream.readPoint2D(2 * t3);
  }
  static setSegDefault(t3, e2, s3) {
    n(0);
  }
  setXYZ(t3, e2, s3) {
    n(0);
  }
  setXYZCoords(t3, e2, s3, i2) {
    n(0);
  }
  queryXYZ(t3, e2) {
    n(0);
  }
  getXYZ(t3) {
    return n(0), X.getNAN();
  }
  getXYZWithIndex(t3) {
    return n(0), X.getNAN();
  }
  mergeVertexDescription(t3) {
    this.m_verticesMp.mergeVertexDescription(t3), this.m_vertexDescription = this.m_verticesMp.getDescription(), this.m_bHasAttributes = this.m_vertexDescription.getAttributeCount() > 1;
  }
  addAttribute(t3) {
    n(0);
  }
  getAttributeAsDbl(t3, e2, s3) {
    return this.m_vertices.getAttributeAsDbl(t3, this.getVertexIndex(e2), s3);
  }
  queryAttributeAsDbl(t3, e2, s3, i2) {
    n(0);
  }
  setAttribute(t3, e2, s3, i2) {
    n(0);
  }
  setAttributeInt(t3, e2, s3, i2) {
    n(0);
  }
  getVertexDescription() {
    return this.m_vertexDescription;
  }
  getMinPathVertexY(t3) {
    return n(0), 0;
  }
  getVertexIndex(t3) {
    return this.m_vertexIndexList.getField(t3, 0);
  }
  getY(t3) {
    const e2 = this.getVertexIndex(t3);
    return this.m_vertices.queryXY(e2, this.m_workPoint2D), this.m_workPoint2D.y;
  }
  getX(t3) {
    return this.getXY(t3).x;
  }
  isEqualXY(t3, e2) {
    return this.queryXY(t3, this.m_workPoint2D), this.queryXY(e2, this.m_workPoint2_2D), this.m_workPoint2D.isEqualPoint2D(this.m_workPoint2_2D);
  }
  isEqualXYPoint2D(t3, e2) {
    return this.queryXY(t3, this.m_workPoint2D), this.m_workPoint2D.isEqualPoint2D(e2);
  }
  isEqualXYZPoint3D(t3, e2) {
    return n(0), false;
  }
  setWeight(t3, e2) {
    e2 < 1 && (e2 = 1);
    const s3 = 1 === e2;
    if (null == this.m_weights) {
      if (s3) return;
      this.m_weights = $2(this.m_vertices.getPointCount(), 1);
    }
    const n5 = this.getVertexIndex(t3);
    if (n5 >= this.m_weights.size()) {
      if (s3) return;
      this.m_weights.resize(n5 + 1, 1);
    }
    this.m_weights.write(n5, e2);
  }
  setWeightWithIndex(t3, e2) {
    e2 < 1 && (e2 = 1);
    const s3 = 1 === e2;
    if (null === this.m_weights) {
      if (s3) return;
      this.m_weights = $2(this.m_vertices.getPointCount(), 1);
    }
    if (t3 >= this.m_weights.size()) {
      if (s3) return;
      this.m_weights.resize(t3 + 1, 1);
    }
    this.m_weights.write(t3, e2);
  }
  getWeight(t3) {
    if (null === this.m_weights) return 1;
    const e2 = this.getVertexIndex(t3);
    return e2 >= this.m_weights.size() ? 1 : this.m_weights.read(e2);
  }
  getWeightWithIndex(t3) {
    return null === this.m_weights || t3 >= this.m_weights.size() ? 1 : this.m_weights.read(t3);
  }
  getRank(t3) {
    if (null === this.m_ranks) return gr;
    const e2 = this.getVertexIndex(t3);
    return e2 >= this.m_ranks.size() ? gr : this.m_ranks.read(e2);
  }
  getRankWithIndex(t3) {
    return null === this.m_ranks || t3 >= this.m_ranks.size() ? gr : this.m_ranks.read(t3);
  }
  setRank(t3, e2) {
    e2 < gr && (e2 = gr);
    const s3 = e2 === gr;
    if (null === this.m_ranks) {
      if (s3) return;
      this.m_ranks = J2(this.m_vertices.getPointCount(), gr);
    }
    const n5 = this.getVertexIndex(t3);
    if (n5 >= this.m_ranks.size()) {
      if (s3) return;
      this.m_ranks.resize(n5 + 1, gr);
    }
    this.m_ranks.write(n5, e2);
  }
  setRankWithIndex(t3, e2) {
    e2 < gr && (e2 = gr);
    const s3 = e2 === gr;
    if (null === this.m_ranks) {
      if (s3) return;
      this.m_ranks = J2(this.m_vertices.getPointCount(), gr);
    }
    if (t3 >= this.m_ranks.size()) {
      if (s3) return;
      this.m_ranks.resize(t3 + 1, gr);
    }
    this.m_ranks.write(t3, e2);
  }
  setSegmentWeight(t3, e2) {
    e2 < 1 && (e2 = 1);
    const s3 = 1 === e2;
    if (null === this.m_segmentWeights) {
      if (s3) return;
      this.m_segmentWeights = $2(this.m_vertices.getPointCount(), 1);
    }
    const n5 = this.getVertexIndex(t3);
    if (n5 >= this.m_segmentWeights.size()) {
      if (s3) return;
      this.m_segmentWeights.resize(n5 + 1, 1);
    }
    this.m_segmentWeights.write(n5, e2);
  }
  setSegmentWeightWithIndex(t3, e2) {
    e2 < 1 && (e2 = 1);
    const s3 = 1 === e2;
    if (null == this.m_segmentWeights) {
      if (s3) return;
      this.m_segmentWeights = $2(this.m_vertices.getPointCount(), 1);
    }
    if (t3 >= this.m_segmentWeights.size()) {
      if (s3) return;
      this.m_segmentWeights.resize(t3 + 1, 1);
    }
    this.m_segmentWeights.write(t3, e2);
  }
  getSegmentWeight(t3) {
    if (null === this.m_segmentWeights) return 1;
    const e2 = this.getVertexIndex(t3);
    return e2 >= this.m_segmentWeights.size() ? 1 : this.m_segmentWeights.read(e2);
  }
  getSegmentWeightWithIndex(t3) {
    return null == this.m_segmentWeights || t3 >= this.m_segmentWeights.size() ? 1 : this.m_segmentWeights.read(t3);
  }
  getSegmentRank(t3) {
    if (null === this.m_segmentRanks) return _Pr.st_defaultRank;
    const e2 = this.getVertexIndex(t3);
    return e2 >= this.m_segmentRanks.size() ? _Pr.st_defaultRank : this.m_segmentRanks.read(e2);
  }
  getSegmentRankWithIndex(t3) {
    return null === this.m_segmentRanks || t3 >= this.m_segmentRanks.size() ? gr : this.m_segmentRanks.read(t3);
  }
  setSegmentRank(t3, e2) {
    e2 < gr && (e2 = gr);
    const s3 = e2 === gr;
    if (null === this.m_segmentRanks) {
      if (s3) return;
      this.m_segmentRanks = J2(this.m_vertices.getPointCount(), gr);
    }
    const n5 = this.getVertexIndex(t3);
    if (n5 >= this.m_segmentRanks.size()) {
      if (s3) return;
      this.m_segmentRanks.resize(n5 + 1, gr);
    }
    this.m_segmentRanks.write(n5, e2);
  }
  setSegmentRankWithIndex(t3, e2) {
    e2 < gr && (e2 = gr);
    const s3 = e2 === gr;
    if (null === this.m_segmentRanks) {
      if (s3) return;
      this.m_segmentRanks = J2(this.m_vertices.getPointCount(), gr);
    }
    if (t3 >= this.m_segmentRanks.size()) {
      if (s3) return;
      this.m_segmentRanks.resize(t3 + 1, gr);
    }
    this.m_segmentRanks.write(t3, e2);
  }
  removeWeights() {
    this.m_weights = null, this.m_segmentWeights = null;
  }
  removeRanks() {
    this.m_ranks = null, this.m_segmentRanks = null;
  }
  setUserIndex(t3, e2, s3) {
    const n5 = this.m_indices[e2], i2 = this.getVertexIndex(t3);
    if (n5.size() <= i2) {
      if (-1 === s3) return;
      n5.resize(this.m_vertices.getPointCount(), -1);
    }
    n5.write(i2, s3);
  }
  getUserIndex(t3, e2) {
    const s3 = this.getVertexIndex(t3), n5 = this.m_indices[e2];
    if (s3 < n5.size()) {
      return n5.read(s3);
    }
    return -1;
  }
  addToUserIndex(t3, e2, s3) {
    const n5 = this.m_indices[e2], i2 = this.getVertexIndex(t3);
    n5.size() <= i2 && n5.resize(this.m_vertices.getPointCount(), -1);
    const r = n5.read(i2);
    n5.write(i2, r + s3);
  }
  createUserIndex() {
    for (let e2 = 0; e2 < this.m_indices.length; e2++) if (null === this.m_indices[e2]) return this.m_indices[e2] = this.allocateIndex(), e2;
    this.m_indices.push(this.allocateIndex());
    const t3 = this.m_indices.length - 1;
    return n(t3 >= 0 && t3 <= ds()), t3;
  }
  createUserIndexUninitialized() {
    for (let e2 = 0; e2 < this.m_indices.length; e2++) if (null === this.m_indices[e2]) return this.m_indices[e2] = this.allocateIndex(false), e2;
    this.m_indices.push(this.allocateIndex(false));
    const t3 = this.m_indices.length - 1;
    return n(t3 >= 0 && t3 <= Number.MAX_SAFE_INTEGER), t3;
  }
  fillUserIndexForGeometry(t3, e2, s3) {
    const n5 = this.m_indices[e2], i2 = n5.size();
    for (let r = this.getFirstPath(t3); r !== cr; r = this.getNextPath(r)) {
      let t4 = this.getFirstVertex(r);
      for (let e3 = 0, o = this.getPathSize(r); e3 < o; e3++, t4 = this.getNextVertex(t4)) {
        const e4 = this.getVertexIndex(t4);
        e4 < i2 && n5.write(e4, s3);
      }
    }
  }
  fillUserIndexForSelection(t3, e2) {
    n(0);
  }
  removeUserIndex(t3) {
    for (this.recycleUserIndex(this.m_indices[t3]), this.m_indices[t3] = null; this.m_indices.length > 0 && null === this.m_indices[this.m_indices.length - 1]; ) this.m_indices.pop();
  }
  replaceCurveWithLine(t3) {
    if (null !== this.m_segments) {
      const e2 = this.getVertexIndex(t3);
      this.setSegmentToIndex(e2, null);
    }
  }
  queryLineConnector(t3, e2, s3 = false) {
    const n5 = this.getNextVertex(t3);
    if (n5 === cr) return false;
    if (!this.m_bHasAttributes || s3) {
      const s4 = this.getXY(t3);
      e2.setStartXY(s4);
      const i2 = this.getXY(n5);
      e2.setEndXY(i2);
    } else {
      const s4 = new ee({ vd: this.getVertexDescription() });
      this.queryPoint(t3, s4), e2.setStart(s4), this.queryPoint(n5, s4), e2.setEnd(s4);
    }
    return true;
  }
  queryLineConnector3D(t3, e2, s3 = false) {
    return n(0), false;
  }
  hasCurves() {
    return null !== this.m_segments;
  }
  geometryHasCurves(t3) {
    return n(0), false;
  }
  pathHasCurves(t3) {
    if (!this.hasCurves()) return false;
    const s3 = this.getFirstVertex(t3);
    if (s3 === cr) return false;
    const n5 = this.getPathSize(t3);
    let i2 = s3;
    for (let r = 0; r < n5; r++, i2 = this.getNextVertex(i2)) {
      const t4 = this.getSegment(i2);
      if (null !== t4 && t4.getGeometryType() !== a.enumLine) return true;
    }
    return false;
  }
  insertPath(e2, s3) {
    let n5 = cr;
    s3 !== cr ? (e2 !== this.getGeometryFromPath(s3) && P(""), n5 = this.getPrevPath(s3)) : n5 = this.getLastPath(e2);
    const i2 = this.newPath(e2);
    return s3 !== cr && this.setPrevPath(s3, i2), this.setNextPath(i2, s3), this.setPrevPath(i2, n5), n5 !== cr ? this.setNextPath(n5, i2) : this.setFirstPath(e2, i2), s3 === cr && this.setLastPath(e2, i2), this.setGeometryPathCount(e2, this.getPathCount(e2) + 1), i2;
  }
  removePath(t3) {
    const e2 = this.getPrevPath(t3), s3 = this.getNextPath(t3), n5 = this.getGeometryFromPath(t3);
    return e2 !== cr ? this.setNextPath(e2, s3) : this.setFirstPath(n5, s3), s3 !== cr ? this.setPrevPath(s3, e2) : this.setLastPath(n5, e2), this.clearPath(t3), this.setGeometryPathCount(n5, this.getPathCount(n5) - 1), this.freePath(t3), s3;
  }
  clearPath(t3) {
    const e2 = this.getFirstVertex(t3);
    if (e2 !== cr) {
      let s3 = e2;
      for (let e3 = 0, i2 = this.getPathSize(t3); e3 < i2; e3++) {
        const t4 = s3;
        s3 = this.getNextVertex(s3), this.freeVertex(t4);
      }
      const n5 = this.getGeometryFromPath(t3);
      this.setGeometryVertexCount(n5, this.getPointCount(n5) - this.getPathSize(t3));
    }
    this.setPathSize(t3, 0);
  }
  getNextPath(t3) {
    return this.m_pathIndexList.getField(t3, 2);
  }
  getPrevPath(t3) {
    return this.m_pathIndexList.getField(t3, 1);
  }
  getPathSize(t3) {
    return this.m_pathIndexList.getField(t3, 3);
  }
  isClosedPath(t3) {
    return !!(1 & this.getPathFlags(t3));
  }
  setClosedPath(t3, e2) {
    if (this.isClosedPath(t3) === e2) return;
    if (this.getPathSize(t3) > 0) {
      const s4 = this.getFirstVertex(t3), n5 = this.getLastVertex(t3);
      if (e2) {
        this.setNextVertex(n5, s4), this.setPrevVertex(s4, n5);
        const t4 = this.getVertexIndex(n5);
        this.setSegmentToIndex(t4, null);
      } else {
        this.setNextVertex(n5, cr), this.setPrevVertex(s4, cr);
        const t4 = this.getVertexIndex(n5);
        this.setSegmentToIndex(t4, null);
      }
    }
    const s3 = (1 | this.getPathFlags(t3)) - 1;
    this.setPathFlags(t3, s3 | (e2 ? 1 : 0));
  }
  closeAllPaths(t3) {
    n(0);
  }
  isStrongPathStart(t3) {
    return !!(8 & this.getPathFlags(t3));
  }
  isStrongPathEnd(t3) {
    return !!(16 & this.getPathFlags(t3));
  }
  setStrongPathStart(t3, e2) {
    const s3 = (8 | this.getPathFlags(t3)) - 8;
    this.setPathFlags(t3, s3 | (e2 ? 8 : 0));
  }
  setStrongPathEnd(t3, e2) {
    const s3 = (16 | this.getPathFlags(t3)) - 16;
    this.setPathFlags(t3, s3 | (e2 ? 16 : 0));
  }
  getGeometryFromPath(t3) {
    return this.m_pathIndexList.getField(t3, 7);
  }
  isExterior(t3) {
    return !!(2 & this.getPathFlags(t3));
  }
  setExterior(t3, e2) {
    const s3 = (2 | this.getPathFlags(t3)) - 2;
    this.setPathFlags(t3, s3 | (e2 ? 2 : 0));
  }
  getRingArea(t3) {
    if (this.isRingAreaValid(t3)) return this.m_pathAreas[this.getPathIndex(t3)];
    const s3 = this.getFirstVertex(t3);
    if (s3 === cr) return 0;
    const n5 = this.getXY(s3), i2 = new n2(0), r = this.getPathSize(t3);
    if (r > 2) {
      const t4 = n5.clone(), e2 = t4.x, o2 = t4.y;
      let a2 = this.getNextVertex(s3);
      const h2 = this.getXY(a2);
      a2 = this.getNextVertex(a2);
      const u = mi.getNAN();
      for (let s4 = 2; s4 < r; s4++, a2 = this.getNextVertex(a2)) this.queryXY(a2, u), i2.pe((u.x - t4.x) * (h2.y - o2)), t4.setCoordsPoint2D(h2), h2.setCoordsPoint2D(u);
      i2.pe((e2 - t4.x) * (h2.y - o2));
    }
    if (this.hasCurves()) {
      let t4 = s3;
      for (let s4 = 0; s4 < r; s4++, t4 = this.getNextVertex(t4)) {
        const s5 = this.getSegment(t4);
        if (null === s5 || s5.getGeometryType() === a.enumLine) continue;
        const n6 = 2 * s5.calculateArea2DHelper();
        i2.pe(n6);
      }
    }
    this.setRingAreaValid(t3, true);
    const o = 0.5 * i2.getResult();
    return this.m_pathAreas[this.getPathIndex(t3)] = o, o;
  }
  getPathIndexInternal(t3) {
    return this.getPathIndex(t3);
  }
  getPathInternalIndexFromVertex(t3) {
    return this.getPathIndex(this.getPathFromVertex(t3));
  }
  setPathUserIndex(t3, e2, s3) {
    const n5 = this.m_pathindices[e2], i2 = this.getPathIndex(t3);
    n5.size() < this.m_pathAreas.length && n5.resize(this.m_pathAreas.length, -1), n5.write(i2, s3);
  }
  getPathUserIndex(t3, e2) {
    const s3 = this.getPathIndex(t3), n5 = this.m_pathindices[e2];
    return s3 < n5.size() ? n5.read(s3) : -1;
  }
  createPathUserIndex() {
    for (let e2 = 0; e2 < this.m_pathindices.length; e2++) if (null === this.m_pathindices[e2]) return this.m_pathindices[e2] = this.allocatePathIndex(), e2;
    this.m_pathindices.push(this.allocatePathIndex());
    const t3 = this.m_pathindices.length - 1;
    return n(t3 >= 0 && t3 <= Number.MAX_SAFE_INTEGER), t3;
  }
  fillPathUserIndexForGeometry(t3, e2, s3) {
    const n5 = this.m_pathindices[e2], i2 = n5.size();
    for (let r = this.getFirstPath(t3); r !== cr; r = this.getNextPath(r)) {
      const t4 = this.getPathIndex(r);
      t4 < i2 && n5.write(t4, s3);
    }
  }
  removePathUserIndex(t3) {
    for (this.recyclePathUserIndex(this.m_pathindices[t3]), this.m_pathindices[t3] = null; this.m_pathindices.length > 0 && null === this.m_pathindices.at(-1); ) this.m_pathindices.pop();
  }
  movePath(e2, s3, n5) {
    if (n5 === cr && P(""), s3 === n5) return;
    const i2 = this.getNextPath(n5);
    let r = this.getPrevPath(n5);
    const o = this.getGeometryFromPath(n5);
    r === cr ? this.setFirstPath(o, i2) : this.setNextPath(r, i2), i2 === cr ? this.setLastPath(o, r) : this.setPrevPath(i2, r), this.setGeometryVertexCount(o, this.getPointCount(o) - this.getPathSize(n5)), this.setGeometryPathCount(o, this.getPathCount(o) - 1), r = s3 === cr ? this.getLastPath(e2) : this.getPrevPath(s3), this.setPrevPath(n5, r), this.setNextPath(n5, s3), s3 === cr ? this.setLastPath(e2, n5) : this.setPrevPath(s3, n5), r === cr ? this.setFirstPath(e2, n5) : this.setNextPath(r, n5), this.setGeometryVertexCount(e2, this.getPointCount(e2) + this.getPathSize(n5)), this.setGeometryPathCount(e2, this.getPathCount(e2) + 1), this.setPathGeometry(n5, e2);
  }
  addVertex(t3, e2) {
    this.m_vertices.getPointByVal(this.getVertexIndex(e2), this.getHelperPoint());
    return this.insertVertex_(t3, cr, this.getHelperPoint(), false);
  }
  insertVertex(t3, e2, s3) {
    return this.insertVertex_(t3, e2, s3, true);
  }
  removeVertex(t3, e2) {
    const s3 = this.getPathFromVertex(t3), n5 = this.getPrevVertex(t3), i2 = this.getNextVertex(t3);
    n5 !== cr && this.setNextVertex(n5, i2);
    const r = this.getPathSize(s3);
    t3 === this.getFirstVertex(s3) && this.setFirstVertex(s3, r > 1 ? i2 : cr), i2 !== cr && this.setPrevVertex(i2, n5), t3 === this.getLastVertex(s3) && this.setLastVertex(s3, r > 1 ? n5 : cr);
    if (this.hasCurves() && n5 !== cr && i2 !== cr) {
      const s4 = this.getVertexIndex(t3), r2 = this.getVertexIndex(n5), o2 = this.getVertexIndex(i2);
      if (e2) {
        const t4 = this.getSegmentFromIndex(r2);
        if (null !== t4) {
          const e3 = this.m_vertices.getXY(o2);
          t4.setEndXY(e3), t4.normalizeAfterEndpointChange();
        }
        this.setSegmentToIndex(s4, null);
      } else {
        const t4 = this.getSegmentFromIndex(s4);
        if (this.setSegmentToIndex(s4, null), null !== t4) {
          const e3 = this.m_vertices.getXY(r2);
          t4.setStartXY(e3), t4.normalizeAfterEndpointChange();
        }
        this.setSegmentToIndex(r2, t4);
      }
    }
    this.setPathSize(s3, r - 1);
    const o = this.getGeometryFromPath(s3);
    return this.setGeometryVertexCount(o, this.getPointCount(o) - 1), this.freeVertex(t3), i2;
  }
  removeVertices(t3, e2) {
    n(t3 !== e2);
    const s3 = this.getPathFromVertex(t3), i2 = this.getPrevVertex(t3), r = this.getPrevVertex(e2);
    i2 !== cr && this.setNextVertex(i2, e2);
    let o = this.getPathSize(s3);
    const a2 = this.getVertexIndex(t3);
    this.setSegmentToIndex(a2, null), this.setPrevVertex(e2, i2), this.setPrevVertex(t3, cr), this.setNextVertex(r, cr);
    let h2 = 0, u = t3;
    const m3 = this.getFirstVertex(s3);
    let l2 = false;
    for (; ; ) {
      const t4 = this.getNextVertex(u);
      if (l2 ||= m3 === u, this.freeVertex(u), h2++, u === r) break;
      u = t4;
    }
    o -= h2, l2 && this.setFirstVertex(s3, o > 0 ? e2 : cr), this.setPathSize(s3, o);
    const c = this.getGeometryFromPath(s3);
    this.setGeometryVertexCount(c, this.getPointCount(c) - h2);
  }
  getFirstVertex(t3) {
    return this.m_pathIndexList.getField(t3, 4);
  }
  getLastVertex(t3) {
    return this.m_pathIndexList.getField(t3, 5);
  }
  getNextVertex(t3) {
    return this.m_vertexIndexList.getField(t3, 2);
  }
  getPrevVertex(t3) {
    return this.m_vertexIndexList.getField(t3, 1);
  }
  getNextVertexEx(t3, e2) {
    return e2 > 0 ? this.m_vertexIndexList.getField(t3, 2) : this.m_vertexIndexList.getField(t3, 1);
  }
  getPrevVertexEx(t3, e2) {
    return e2 > 0 ? this.m_vertexIndexList.getField(t3, 1) : this.m_vertexIndexList.getField(t3, 2);
  }
  getPathFromVertex(t3) {
    return this.m_vertexIndexList.getField(t3, 3);
  }
  addPoint(t3, e2) {
    return this.insertVertex_(t3, cr, e2, false);
  }
  getGeometryFromVertex(t3) {
    return this.getGeometryFromPath(this.getPathFromVertex(t3));
  }
  replaceNaNs(t3, e2) {
    this.m_vertexDescription.hasAttribute(t3) || b(""), this.m_vertices.replaceNaNs(t3, e2);
  }
  removeNaNVertices() {
    for (let t3 = this.getFirstGeometry(); t3 !== cr; t3 = this.getNextGeometry(t3)) for (let e2 = this.getFirstPath(t3); e2 !== cr; e2 = this.getNextPath(e2)) {
      let t4 = this.getFirstVertex(e2);
      for (let s3 = 0, n5 = this.getPathSize(e2); s3 < n5; s3++) t4 = this.getXY(t4).isFinite() ? this.getNextVertex(t4) : this.removeVertex(t4, true);
    }
  }
  queryVertexIterator(t3 = cr) {
    return this.queryVertexIteratorEx(false, t3);
  }
  queryVertexIteratorEx(t3, e2 = cr) {
    let s3 = cr, n5 = cr, i2 = cr, r = cr, o = 0, a2 = false;
    for (s3 = e2 !== cr ? e2 : this.getFirstGeometry(); s3 !== cr; s3 = this.getNextGeometry(s3)) if (!t3 || h(this.getGeometryType(s3))) {
      for (n5 = this.getFirstPath(s3); n5 !== cr; n5 = this.getNextPath(n5)) if (i2 = this.getFirstVertex(n5), r = i2, o = 0, i2 !== cr) {
        a2 = true;
        break;
      }
      if (a2 || e2 !== cr) break;
    }
    return a2 || (s3 = cr), pr.create_(this, s3, n5, i2, r, o, t3, false, e2 !== cr);
  }
  queryVertexIteratorOnSelection(t3 = cr) {
    return this.m_selection ? pr.create_(this, t3, cr, cr, cr, -1, false, true, t3 !== cr) : this.queryVertexIteratorEx(false, t3);
  }
  hasSelection() {
    return this.m_selection;
  }
  createEmptySelection() {
    n(0);
  }
  removeSelection() {
    this.m_selection && (this.m_selectedVertices.length = 0, this.removeUserIndex(this.m_selectionIndex), this.m_selectionIndex = -1, this.m_selection = false, this.m_selectedCount = 0);
  }
  select(t3) {
    return !!this.selected(t3) || (this.setUserIndex(t3, this.m_selectionIndex, this.m_selectedVertices.length), this.m_selectedVertices.push(t3), this.m_selectedCount++, false);
  }
  unselect(t3) {
    if (!this.m_selection) return;
    const e2 = this.getUserIndex(t3, this.m_selectionIndex);
    e2 >= 0 && (this.m_selectedVertices[e2] = cr, this.setUserIndex(t3, this.m_selectionIndex, -1), this.m_selectedCount--);
  }
  selected(t3) {
    return !this.m_selection || this.selected_(t3);
  }
  getSelectedCount() {
    return this.m_selection ? this.m_selectedCount : this.getTotalPointCount();
  }
  createSelectionForCrackingAndClustering(t3, e2) {
    return n(0), false;
  }
  peelALoop(t3, e2) {
    this.peelALoop_(t3, e2, false);
  }
  peelALoopIntoAPath(t3, e2) {
    return this.peelALoop_(t3, e2, true);
  }
  applyTransformation(t3) {
    if (this.m_verticesMp.applyTransformation(t3), null !== this.m_segments) for (let e2 = 0, s3 = this.m_segments.length; e2 < s3; e2++) this.m_segments[e2] && this.m_segments[e2].applyTransformation(t3);
  }
  setGeometryType(t3, e2) {
    this.m_geometryIndexList.setField(t3, 2, e2);
  }
  splitSegmentWithIntersector(t3, e2, s3, n5, i2) {
    n5 ? this.splitSegmentForward(t3, e2, s3, true, i2) : this.splitSegmentBackward(t3, e2, s3, true, i2);
  }
  setPrevVertex(t3, e2) {
    this.m_vertexIndexList.setField(t3, 1, e2);
  }
  setNextVertex(t3, e2) {
    this.m_vertexIndexList.setField(t3, 2, e2);
  }
  setPathToVertex(t3, e2) {
    this.m_vertexIndexList.setField(t3, 3, e2);
  }
  setPathSize(t3, e2) {
    this.m_pathIndexList.setField(t3, 3, e2);
  }
  setFirstVertex(t3, e2) {
    this.m_pathIndexList.setField(t3, 4, e2);
  }
  setLastVertex(t3, e2) {
    this.m_pathIndexList.setField(t3, 5, e2);
  }
  getSegment(t3) {
    if (null != this.m_segments) {
      const e2 = this.getVertexIndex(t3);
      return this.getSegmentFromIndex(e2);
    }
    return null;
  }
  isCurve(t3) {
    if (null === this.m_segments) return false;
    const e2 = this.getVertexIndex(t3);
    return this.m_segments.length > e2 && null !== this.m_segments[e2];
  }
  querySegment(t3, e2, s3 = true, n5 = false) {
    const i2 = this.getNextVertex(t3);
    if (i2 === cr) return false;
    const r = this.getSegment(t3);
    if (!r) return !s3 && (this.queryLineConnector(t3, e2.createLine(), n5), true);
    if (e2.copyFrom(r, true), n5) return true;
    if (this.m_vertexDescription.getAttributeCount() > 1) {
      const s4 = this.getHelperPoint();
      this.queryPoint(t3, s4), e2.get().setStart(s4), this.queryPoint(i2, s4), e2.get().setEnd(s4);
    }
    return true;
  }
  getSegmentFromIndex(t3) {
    const e2 = null !== this.m_segments && this.m_segments.length > t3 ? this.m_segments[t3] : null;
    return e2 || null;
  }
  getAndClearSegmentFromIndex(t3) {
    const e2 = null !== this.m_segments && this.m_segments.length > t3 ? this.m_segments[t3] : null;
    return e2 || null;
  }
  setSegmentToIndex(t3, e2) {
    if (this.m_hasForceSetEnvelope = 0, null === this.m_segments) {
      if (!e2) return;
      this.m_segments = [], this.m_segments.length = this.m_vertices.getPointCount();
    }
    t3 >= this.m_segments.length && (this.m_segments.length = t3 + 1), this.m_segments[t3] = e2;
  }
  setGeometryPathCount(t3, e2) {
    this.m_geometryIndexList.setField(t3, 6, e2);
  }
  setGeometryVertexCount(t3, e2) {
    this.m_geometryIndexList.setField(t3, 5, e2);
  }
  ringParentageCheckInternal(t3, e2) {
    return n(0), false;
  }
  reverseRingInternal(t3) {
    const e2 = this.hasCurves(), s3 = this.hasSegmentParentage();
    let n5 = null, i2 = -1, r = t3;
    if (e2) {
      const t4 = this.getVertexIndex(r);
      n5 = this.getAndClearSegmentFromIndex(t4);
    }
    s3 && (i2 = this.getSegmentParentage(r));
    do {
      const t4 = this.getPrevVertex(r), o = this.getNextVertex(r);
      if (this.setNextVertex(r, t4), this.setPrevVertex(r, o), e2) {
        const t5 = this.getVertexIndex(o), e3 = this.getSegmentFromIndex(t5);
        n5 && n5.reverse(), this.setSegmentToIndex(t5, n5), n5 = e3;
      }
      if (s3) {
        const t5 = this.getSegmentParentage(o);
        this.setSegmentParentagePreserveBreak(o, i2), i2 = t5;
      }
      r = o;
    } while (r !== t3);
    this.dbgVerifyIntegrity(t3);
  }
  setTotalPointCount(t3) {
    this.m_pointCount = t3;
  }
  removePathOnly(t3) {
    const e2 = this.getPrevPath(t3), s3 = this.getNextPath(t3), n5 = this.getGeometryFromPath(t3);
    e2 !== cr ? this.setNextPath(e2, s3) : this.setFirstPath(n5, s3), s3 !== cr ? this.setPrevPath(s3, e2) : this.setLastPath(n5, e2), this.setFirstVertex(t3, cr), this.setLastVertex(t3, cr), this.freePath(t3);
  }
  insertClosedPath(t3, e2, s3, n5, i2) {
    const r = this.insertPath(t3, cr);
    let o = 0, a2 = s3;
    for (i2[0] = false; ; ) {
      a2 === n5 && (i2[0] = true), this.setPathToVertex(a2, r), o++;
      const t4 = this.getNextVertex(a2);
      if (t4 === s3) break;
      a2 = t4;
    }
    return this.setClosedPath(r, true), this.setPathSize(r, o), i2[0] && (s3 = n5), this.setFirstVertex(r, s3), this.setLastVertex(r, this.getPrevVertex(s3)), this.setRingAreaValid(r, false), r;
  }
  findVertex2D(t3, e2) {
    return n(0), 0;
  }
  findVertex3D(t3, e2, s3) {
    return n(0), 0;
  }
  dbgVerifyMonotone() {
  }
  dbgCheckSelection() {
  }
  dbgVerifySegment(t3) {
  }
  dbgVerifyIntegrity(t3, e2 = true) {
  }
  dbgVerifyVertexCounts() {
  }
  dbgVerifyCurves() {
  }
  dbgDumpGeometry(t3, e2) {
  }
  getNextNthVertex(t3, e2) {
    if (0 === e2) return t3;
    let s3 = t3;
    for (let n5 = 0; n5 < e2; ++n5) if (s3 = e2 > 0 ? this.getNextVertex(s3) : this.getPrevVertex(s3), s3 === cr) return cr;
    return s3;
  }
  removeVertexInternal(t3, e2) {
    const s3 = this.getPrevVertex(t3), n5 = this.getNextVertex(t3);
    s3 !== cr && this.setNextVertex(s3, n5), n5 !== cr && this.setPrevVertex(n5, s3);
    if (this.hasCurves() && s3 !== cr && n5 !== cr) {
      const i2 = this.getVertexIndex(t3), r = this.getVertexIndex(s3), o = this.getVertexIndex(n5);
      if (e2) {
        const t4 = this.getSegmentFromIndex(r);
        if (null !== t4) {
          const e3 = this.m_vertices.getXY(o);
          t4.setEndXY(e3), t4.normalizeAfterEndpointChange();
        }
        this.setSegmentToIndex(i2, null);
      } else {
        const t4 = this.getSegmentFromIndex(i2);
        if (this.setSegmentToIndex(i2, null), null !== t4) {
          const e3 = this.m_vertices.getXY(r);
          t4.setStartXY(e3), t4.normalizeAfterEndpointChange();
        }
        this.setSegmentToIndex(r, t4);
      }
    }
    return this.freeVertex(t3), n5;
  }
  isRingAreaValid(t3) {
    return !!(4 & this.getPathFlags(t3));
  }
  setRingAreaValid(t3, e2) {
    const s3 = (4 | this.getPathFlags(t3)) - 4;
    this.setPathFlags(t3, s3 | (e2 ? 4 : 0));
  }
  compareVerticesSimpleY(t3, e2) {
    return this.queryXY(t3, this.m_workPoint2D), this.queryXY(e2, this.m_workPoint2_2D), this.m_workPoint2D.compare(this.m_workPoint2_2D);
  }
  compareVerticesSimpleY3D(t3, e2) {
    return this.getXYZ(t3).compare(this.getXYZ(e2));
  }
  compareVerticesSimpleX(t3, e2) {
    return this.getXY(t3).compareX(this.getXY(e2));
  }
  sortVerticesSimpleByYHeapMerge(t3, e2) {
    n(0);
  }
  sortVerticesSimpleByY(t3, e2, s3) {
    this.m_bucketSort.sort(t3, e2, s3, new dr(this));
  }
  sortVerticesSimpleByX(t3, e2, s3) {
    n(0);
  }
  sortVerticesSimpleByY3D(t3, e2, s3) {
    n(0);
  }
  snapVertexForPoleClipping(t3, e2) {
    const s3 = this.getPrevVertex(t3);
    s3 !== cr && this.replaceCurveWithLine(s3);
    this.getNextVertex(t3) !== cr && this.replaceCurveWithLine(t3);
    const n5 = new mi();
    this.queryXY(t3, n5), n5.y = e2, this.setXY(t3, n5);
  }
  setSegmentParentageAndBreak(t3, e2, s3 = true) {
    if (-1 === this.m_segmentParentageIndex) {
      if (-1 === e2) return;
      this.m_segmentParentageIndex = this.createUserIndex();
    }
    e2 >= 0 && (n(e2 <= vs() >> 1), e2 <<= 1, e2 |= s3 ? 1 : 0), this.setUserIndex(t3, this.m_segmentParentageIndex, e2);
  }
  setSegmentParentagePreserveBreak(t3, e2) {
    if (n(e2 >= -1), -1 === this.m_segmentParentageIndex) {
      if (-1 === e2) return;
      this.m_segmentParentageIndex = this.createUserIndex();
    }
    if (e2 >= 0) {
      n(e2 <= vs() >> 1), e2 <<= 1;
      e2 |= this.getSegmentParentageBreakVertex(t3) ? 1 : 0;
    }
    this.setUserIndex(t3, this.m_segmentParentageIndex, e2);
  }
  getSegmentParentage(t3) {
    if (-1 === this.m_segmentParentageIndex) return -1;
    const e2 = this.getUserIndex(t3, this.m_segmentParentageIndex);
    return e2 < 0 ? e2 : e2 >> 1;
  }
  getOriginalSegmentInfo(t3) {
    if (-1 !== this.m_segmentParentageIndex) {
      const e2 = this.getSegmentParentage(t3);
      return new fr(e2);
    }
    return new fr(-1);
  }
  setSegmentParentageBreakVertex(t3, e2) {
    if (-1 === this.m_segmentParentageIndex) return;
    let s3 = this.getUserIndex(t3, this.m_segmentParentageIndex);
    s3 < 0 || !!(1 & s3) !== e2 && (e2 ? s3 |= 1 : s3 &= vs() >> 1 << 1, this.setUserIndex(t3, this.m_segmentParentageIndex, s3));
  }
  getSegmentParentageBreakVertex(t3) {
    if (-1 === this.m_segmentParentageIndex) return true;
    const e2 = this.getUserIndex(t3, this.m_segmentParentageIndex);
    return e2 < 0 || !!(1 & e2);
  }
  isDiscontinuousSegmentParentage(t3) {
    const e2 = this.getPrevVertex(t3);
    if (e2 === cr) return false;
    return this.getSegmentParentage(e2) !== this.getSegmentParentage(t3);
  }
  setCurveStitcherPointer(t3) {
    this.m_curveStitcher = t3;
  }
  hasSegmentParentage() {
    return -1 !== this.m_segmentParentageIndex;
  }
  deleteSegmentParentage() {
    -1 !== this.m_segmentParentageIndex && (this.removeUserIndex(this.m_segmentParentageIndex), this.m_segmentParentageIndex = -1), this.m_curveStitcher = null;
  }
  clearSegments() {
    this.m_segments = null;
  }
};
function yr(t3) {
  if (t3.isEmpty()) return new ur({ vd: t3.getDescription() });
  if (h(t3.getGeometryType()) && t3.hasNonLinearSegments()) return Cr(t3);
  const e2 = t3.getImpl(), s3 = e2.getPointCount();
  if (s3 <= 2) {
    if (1 === s3 || e2.getXY(0).equals(e2.getXY(1))) {
      const t4 = new ee({ vd: e2.getDescription() });
      return e2.getPointByVal(0, t4), t4;
    }
    {
      const t4 = new ee(), s4 = new Os2({ vd: e2.getDescription() });
      return e2.getPointByVal(0, t4), s4.startPathPoint(t4), e2.getPointByVal(1, t4), s4.lineToPoint(t4), s4;
    }
  }
  const n5 = e2.getAttributeStreamRef(0), i2 = new wr({ stream: n5, n: s3 });
  let r = 0, o = 1;
  const a2 = n5.readPoint2D(r << 1), h2 = new mi();
  for (; o < s3 && n5.queryPoint2D(o << 1, h2).equals(a2); ) o++;
  if (i2.m_treeHull.addElement(r), o < s3) {
    i2.m_treeHull.addBiggestElement(o);
    const t4 = new mi();
    for (let s4 = o + 1; s4 < e2.getPointCount(); s4++) {
      n5.queryPoint2D(s4 << 1, t4);
      const e3 = i2.treeHull(t4);
      -1 !== e3 && i2.m_treeHull.setElement(e3, s4);
    }
  }
  const u = e2.getDescription(), m3 = u.getAttributeCount() > 1, l2 = i2.m_treeHull.size();
  let g2 = null;
  if (l2 >= 2) {
    g2 = l2 >= 3 ? new ur({ vd: u }) : new Os2({ vd: u });
    const t4 = g2.getImpl();
    t4.reserve(i2.m_treeHull.size()), t4.addPathPoint2D(null, 0, true);
    const s4 = new mi();
    for (let r2 = i2.m_treeHull.getFirst(); -1 !== r2; r2 = i2.m_treeHull.getNext(r2)) if (m3) {
      const s5 = new ee();
      e2.getPointByVal(i2.m_treeHull.getElement(r2), s5), t4.insertPoint(0, -1, s5);
    } else n5.queryPoint2D(i2.m_treeHull.getElement(r2) << 1, s4), t4.insertPoint2D(0, -1, s4);
  } else if (m3) {
    const t4 = new ee({ vd: u });
    e2.getPointByVal(i2.m_treeHull.getElement(i2.m_treeHull.getFirst()), t4), g2 = t4;
  } else {
    const t4 = n5.readPoint2D(i2.m_treeHull.getElement(i2.m_treeHull.getFirst()) << 1);
    g2 = new ee(t4);
  }
  return g2;
}
function xr(t3, e2, s3, n5 = false) {
  if (e2 <= 262144) return Ir(t3, e2, s3, n5);
  const i2 = new wr({ points: t3, n: e2 }), r = 0;
  let o = 1;
  const a2 = t3[r];
  for (; o < e2 && t3[o].equals(a2); ) o++;
  if (i2.m_treeHull.addElement(r), o < e2) {
    i2.m_treeHull.addBiggestElement(o);
    for (let s4 = o + 1; s4 < e2; s4++) {
      const e3 = t3[s4], n6 = i2.treeHull(e3);
      -1 !== n6 && i2.m_treeHull.setElement(n6, s4);
    }
  }
  let h2 = 0;
  for (let u = i2.m_treeHull.getFirst(); -1 !== u; u = i2.m_treeHull.getNext(u)) s3[h2++] = i2.m_treeHull.getElement(u);
  return h2;
}
function Cr(t3) {
  n(t3.hasNonLinearSegments() && !t3.isEmpty());
  const e2 = new wr();
  return e2.addGeometry(t3), e2.getBoundingGeometry();
}
function vr(e2, s3, n5) {
  if ((s3 < 0 || s3 >= e2.getPathCount()) && P("path index"), e2.hasNonLinearSegmentsPath(s3)) return false;
  const i2 = e2.getImpl(), r = i2.getPathStart(s3), o = i2.getPathEnd(s3), a2 = !i2.isClosedPath(s3) && i2.isClosedPathInXYPlane(s3), h2 = i2.getAttributeStreamRef(0), u = 2 * r;
  let m3 = 2 * o;
  if (a2 && (m3 -= 2), m3 - u < 6) return true;
  const l2 = h2.readPoint2D(u), c = h2.readPoint2D(u + 2), g2 = h2.readPoint2D(u + 4);
  if (!Mr(mi.orientationRobust(c, g2, l2))) return false;
  const d2 = c.clone(), _ = new mi();
  for (let t3 = u + 6; t3 < m3; t3 += 2) {
    _.assign(c), c.assign(g2), h2.queryPoint2D(t3, g2);
    if (!Mr(mi.orientationRobust(c, g2, l2))) return false;
    if (!Mr(mi.orientationRobust(d2, g2, l2))) return false;
    if (!Mr(mi.orientationRobust(c, g2, _))) return false;
  }
  return true;
}
function br(t3, e2, s3) {
  t3.setNAN(), e2.setCoords(1, 0), s3.setCoords(0, 0);
}
function Er(t3, s3, n5, i2, r) {
  if (br(n5, i2, r), t3.isEmpty()) return;
  if (t3.getGeometryType() === a.enumPoint) return void n5.assign(t3.getXY());
  const o = t3, a2 = o.getPointCount();
  0 !== a2 && (1 !== a2 ? Sr(o, a2, s3, n5, i2, r) : n5.assign(o.getXY(0)));
}
function Sr(t3, e2, s3, n5, i2, r) {
  if (2 === e2) {
    const e3 = t3.getXY(0), s4 = t3.getXY(1);
    n5.assign(e3.add(s4).mul(0.5));
    const o = s4.sub(e3);
    i2 = Xr(o), r.setCoords(0.5 * o.length(), 0);
  } else {
    let o = Number.MAX_VALUE;
    const a2 = [0, 1, 0, 0], h2 = new Xt(4, 2);
    for (h2.set(0, 0, 0), h2.set(0, 1, 1), h2.set(1, 0, 1), h2.set(1, 1, 2); a2[0] < e2; ++a2[0], qr(h2, 0, e2)) {
      a2[1] === a2[0] && (++a2[1], qr(h2, 1, e2));
      for (let s4 = 1; ; ++s4) {
        for (; ; ) {
          const n6 = Fr(t3.getXY(h2.get(0, 0)), t3.getXY(h2.get(0, 1)), t3.getXY(h2.get(s4, 0)), t3.getXY(h2.get(s4, 1)), 2 ^ s4);
          if (n6 > 0) break;
          if (++a2[s4], qr(h2, s4, e2), 0 === n6) break;
        }
        if (3 === s4) break;
        a2[s4 + 1] < a2[s4] && (a2[s4 + 1] = a2[s4], h2.set(s4 + 1, 0, h2.get(s4, 0)), h2.set(s4 + 1, 1, h2.get(s4, 1)));
      }
      const u = t3.getXY(h2.get(0, 0)).add(t3.getXY(h2.get(2, 0))).mul(0.5), m3 = Xr(t3.getXY(h2.get(0, 1)).sub(t3.getXY(h2.get(0, 0)))), l2 = new mi();
      let c, g2;
      if (l2.x = Math.max(0, m3.dotProduct(t3.getXY(h2.get(1, 0)).sub(t3.getXY(h2.get(3, 0))))), l2.y = Math.max(0, m3.crossProduct(t3.getXY(h2.get(0, 0)).sub(t3.getXY(h2.get(2, 0))))), s3 ? (c = l2.x * l2.y, g2 = c < o) : (c = l2.y, g2 = c < o), g2) {
        o = c;
        const e3 = t3.getXY(h2.get(1, 0)), s4 = t3.getXY(h2.get(3, 0)), a3 = e3.add(s4).mul(0.5).sub(u);
        n5.assign(u.add(m3.mul(m3.dotProduct(a3)))), i2.assign(m3), r.assign(l2);
      }
    }
    r.mulThis(0.5), r.x < r.y && (r.y = Pt(r.x, r.x = r.y), i2.leftPerpendicularThis());
  }
  i2.y < 0 ? i2.negateThis() : 0 === i2.y && (i2.x = 1);
}
Pr.st_defaultRank = 1;
var Dr = class {
  constructor(t3) {
    this.m_handleP = -1, this.m_handleQ = -1, this.m_currentSupport = -1, this.m_area = 0, this.m_bDone = true, n(0), this.m_convexHull = t3, this.m_function = this.done_;
  }
  next() {
    return n(0), false;
  }
  get_vertex_handle_p() {
    return n(0), 0;
  }
  get_vertex_handle_q() {
    return n(0), 0;
  }
  get_current_support() {
    return n(0), 0;
  }
  getNext(t3) {
    return n(0), 0;
  }
  getPrev(t3) {
    return n(0), 0;
  }
  intialize_() {
    return n(0), false;
  }
  increment_() {
    return n(0), false;
  }
  increment_q_() {
    return n(0), false;
  }
  increment_p_() {
    return n(0), false;
  }
  parallel_edge_with_q_support_() {
    return n(0), false;
  }
  parallel_edge_with_p_support_() {
    return n(0), false;
  }
  done_() {
    return n(0), false;
  }
};
var wr = class _wr {
  nullGetXY(t3) {
    return b("m_getXY is null"), {};
  }
  nullDeleteNode(t3) {
    b("m_deleteNode is null");
  }
  constructor(t3) {
    return this.m_treeHull = new ct2(), this.m_shape = null, this.m_stream = null, this.m_points = null, this.m_geometryHandle = -1, this.m_pathHandle = -1, this.m_getXY = this.nullGetXY, this.m_deleteNode = this.nullDeleteNode, t3 ? t3.stream ? (this.m_treeHull.setCapacity(Math.min(20, t3.n)), this.m_stream = t3.stream, this.m_getXY = this.getXYStream, this.m_deleteNode = this.deleteNodeStream, this.m_points = null, this.m_geometryHandle = cr, void (this.m_pathHandle = cr)) : t3.points ? (this.m_treeHull.setCapacity(Math.min(20, t3.n)), this.m_points = t3.points, this.m_getXY = this.getXYPoints, this.m_deleteNode = this.deleteNodePoints, this.m_stream = null, this.m_geometryHandle = cr, void (this.m_pathHandle = cr)) : void C("unrecognized constructor parameter") : (this.m_treeHull.setCapacity(20), this.m_shape = new Pr(), this.m_geometryHandle = this.m_shape.createGeometry(a.enumMultiPoint), this.m_pathHandle = this.m_shape.insertPath(this.m_geometryHandle, cr), this.m_getXY = this.getXYShape, this.m_deleteNode = this.deleteNodeShape, this.m_stream = null, void (this.m_points = null));
  }
  getXYShape(t3) {
    return this.m_shape.getXY(t3);
  }
  getXYStream(t3) {
    return this.m_stream.readPoint2D(t3 << 1);
  }
  getXYPoints(t3) {
    return n(0), new mi();
  }
  deleteNodeShape(t3) {
    const e2 = this.m_treeHull.getElement(t3);
    this.m_treeHull.deleteNode(t3), this.m_shape.removeVertex(e2, false);
  }
  deleteNodeStream(t3) {
    this.m_treeHull.deleteNode(t3);
  }
  deleteNodePoints(t3) {
    n(0);
  }
  addGeometry(s3) {
    if (s3.isEmpty()) return;
    const n5 = s3.getGeometryType();
    if (n5 === a.enumGeometryCollection) {
      const t3 = s3;
      for (let e2 = 0, s4 = t3.getGeometryCount(); e2 < s4; e2++) this.addGeometry(t3.getGeometry(e2));
    } else y(n5) ? this.addMultiVertexGeometry(s3) : f(n5) ? this.addSegment(s3, false) : n5 === a.enumEnvelope ? this.addEnvelope(s3) : n5 === a.enumPoint ? this.addPoint(s3) : P("Convex_hull: geometry not supported");
  }
  getBoundingGeometry() {
    const t3 = new ee(), e2 = this.m_treeHull.getFirst(), s3 = new ur({ vd: this.m_shape.getVertexDescription() });
    if (0 === this.m_treeHull.size()) return s3;
    s3.reserve(this.m_treeHull.size()), this.m_shape.queryPoint(this.m_treeHull.getElement(e2), t3), s3.startPathPoint(t3);
    for (let n5 = this.m_treeHull.getNext(e2); -1 !== n5; n5 = this.m_treeHull.getNext(n5)) this.m_shape.queryPoint(this.m_treeHull.getElement(n5), t3), s3.lineToPoint(t3);
    return s3;
  }
  getAntipodalPairsIterator() {
    return n(0), new Dr(this);
  }
  getXY(t3) {
    return n(0), new mi();
  }
  getXYWithIndex(t3) {
    return n(0), new mi();
  }
  getFirst() {
    return n(0), 0;
  }
  getLast() {
    return n(0), 0;
  }
  getNext(t3) {
    return n(0), 0;
  }
  getPrev(t3) {
    return n(0), 0;
  }
  getVertexIndex(t3) {
    return n(0), 0;
  }
  getPointCount() {
    return n(0), 0;
  }
  addMultiVertexGeometry(t3) {
    const e2 = new ee(), s3 = t3.getImpl(), n5 = new mi();
    for (let i2 = 0; i2 < t3.getPointCount(); i2++) {
      s3.queryXY(i2, n5);
      const r = this.addPoint2D(n5);
      if (-1 !== r) {
        t3.getPointByVal(i2, e2);
        const s4 = this.m_shape.addPoint(this.m_pathHandle, e2);
        this.m_treeHull.setElement(r, s4);
      }
    }
    if (h(t3.getGeometryType())) {
      const e3 = t3;
      if (e3.hasNonLinearSegments()) {
        const t4 = e3.querySegmentIterator();
        for (; t4.nextPath(); ) for (; t4.hasNextSegment(); ) {
          const e4 = t4.nextCurve();
          null !== e4 && this.addSegment(e4, true);
        }
      }
    }
  }
  addEnvelope(t3) {
    const e2 = new ee();
    for (let s3 = 0; s3 < 4; s3++) {
      const n5 = new mi();
      t3.queryCorner(s3, n5);
      const i2 = this.addPoint2D(n5);
      if (-1 !== i2) {
        t3.queryCornerByVal(s3, e2);
        const n6 = this.m_shape.addPoint(this.m_pathHandle, e2);
        this.m_treeHull.setElement(i2, n6);
      }
    }
  }
  static querySegmentControlPoints(s3, i2, r) {
    const o = s3.getGeometryType();
    if (n(o !== a.enumLine), o === a.enumEllipticArc) {
      const t3 = s3, e2 = 60 * Math.PI / 180, n5 = Math.abs(t3.getSweepAngle());
      if (n5 > e2) {
        const s4 = Math.min(6, Math.ceil(n5 / e2)), r2 = 1 / s4, o2 = new fm();
        t3.queryStart(i2[0]);
        let a2 = 1;
        for (let e3 = 0; e3 < s4; e3++) {
          t3.queryCut(e3 * r2, (e3 + 1) * r2, o2);
          const n6 = Ot(mi, 3);
          Bu(o2.get(), n6);
          const h2 = mi.calculateLength(n6, 3), u = mi.calculateLength(n6, 2), m3 = h2 > 0 ? u / h2 : 0.5;
          e3 < s4 - 1 ? o2.get().queryEnd(i2[a2 + 1]) : t3.queryEnd(i2[a2 + 1]), ee.lerp(i2[a2 - 1], i2[a2 + 1], m3, i2[a2]), i2[a2].setXY(n6[1]), a2 += 2;
        }
        return a2;
      }
      {
        const t4 = Ot(mi, 3);
        Bu(s3, t4);
        const e3 = mi.calculateLength(t4, 3);
        s3.queryStart(i2[0]), s3.queryEnd(i2[2]);
        const n6 = mi.calculateLength(t4, 2), r2 = e3 > 0 ? n6 / e3 : 0.5;
        return ee.lerp(i2[0], i2[2], r2, i2[1]), i2[1].setXY(t4[1]), 3;
      }
    }
    if (o === a.enumBezier) {
      const t3 = s3, e2 = Ot(mi, 4);
      t3.queryControlPoints(e2);
      const n5 = mi.calculateLength(e2, 4), r2 = mi.calculateLength(e2, 2), o2 = mi.calculateLength(e2, 3);
      s3.queryStart(i2[0]), s3.queryEnd(i2[3]);
      const a2 = n5 > 0 ? r2 / n5 : 0.5;
      ee.lerp(i2[0], i2[3], a2, i2[1]), i2[1].setXY(e2[1]);
      const h2 = n5 > 0 ? o2 / n5 : 0.5;
      return ee.lerp(i2[0], i2[3], h2, i2[2]), i2[2].setXY(e2[2]), 4;
    }
    if (o === a.enumBezier2) {
      const t3 = s3, e2 = Ot(mi, 3);
      t3.queryControlPoints(e2);
      const n5 = mi.calculateLength(e2, 3);
      s3.queryStart(i2[0]), s3.queryEnd(i2[2]);
      const r2 = mi.calculateLength(e2, 2), o2 = n5 > 0 ? r2 / n5 : 0.5;
      return ee.lerp(i2[0], i2[2], o2, i2[1]), i2[1].setXY(e2[1]), 3;
    }
    if (o === a.enumRationalBezier2) {
      const t3 = s3, e2 = Ot(mi, 3);
      t3.queryControlPoints(e2);
      const n5 = mi.calculateLength(e2, 3);
      s3.queryStart(i2[0]), s3.queryEnd(i2[2]);
      const r2 = mi.calculateLength(e2, 2), o2 = n5 > 0 ? r2 / n5 : 0.5;
      return ee.lerp(i2[0], i2[2], o2, i2[1]), i2[1].setXY(e2[1]), 3;
    }
    P("Convex_hull: segment type not supported");
  }
  addSegment(t3, e2) {
    if (!e2) {
      const e3 = new ee(), s3 = t3.getStartXY(), n5 = this.addPoint2D(s3);
      if (-1 !== n5) {
        t3.queryStart(e3);
        const s4 = this.m_shape.addPoint(this.m_pathHandle, e3);
        this.m_treeHull.setElement(n5, s4);
      }
      const i2 = t3.getEndXY(), r = this.addPoint2D(i2);
      if (-1 !== r) {
        t3.queryEnd(e3);
        const s4 = this.m_shape.addPoint(this.m_pathHandle, e3);
        this.m_treeHull.setElement(r, s4);
      }
    }
    if (t3.isCurve()) {
      const e3 = Ot(ee, 13);
      for (let s3 = 1, n5 = _wr.querySegmentControlPoints(t3, e3, e3.length) - 1; s3 < n5; ++s3) {
        const t4 = e3[s3].getXY(), n6 = this.addPoint2D(t4);
        if (-1 !== n6) {
          const t5 = this.m_shape.addPoint(this.m_pathHandle, e3[s3]);
          this.m_treeHull.setElement(n6, t5);
        }
      }
    }
  }
  addPoint(t3) {
    const e2 = t3.getXY(), s3 = this.addPoint2D(e2);
    if (-1 !== s3) {
      const e3 = this.m_shape.addPoint(this.m_pathHandle, t3);
      this.m_treeHull.setElement(s3, e3);
    }
  }
  addPoint2D(t3) {
    let e2 = -1;
    if (0 === this.m_treeHull.size()) return e2 = this.m_treeHull.addElement(-4), e2;
    if (1 === this.m_treeHull.size()) {
      const s3 = this.m_treeHull.getElement(this.m_treeHull.getFirst()), n5 = this.m_shape.getXY(s3);
      return t3.equals(n5) || (e2 = this.m_treeHull.addBiggestElement(-5)), e2;
    }
    return e2 = this.treeHull(t3), e2;
  }
  treeHull(t3) {
    let e2 = -1;
    do {
      const s3 = this.m_treeHull.getFirst(), n5 = this.m_treeHull.getLast(), i2 = this.m_treeHull.getElement(s3), r = this.m_treeHull.getElement(n5), o = this.m_getXY(i2), a2 = this.m_getXY(r), h2 = mi.orientationRobust(a2, t3, o);
      if (Mr(h2)) {
        e2 = this.m_treeHull.addBiggestElement(-1);
        const i3 = this.treeHullWalkBackward(t3, n5, s3);
        i3 !== s3 && this.treeHullWalkForward(t3, s3, this.m_treeHull.getPrev(i3));
        break;
      }
      if (Yr(h2)) {
        let i3 = this.m_treeHull.getRoot(), r2 = this.m_treeHull.getFirst(), a3 = this.m_treeHull.getLast(), h3 = -1, u = -1, m3 = -1;
        for (; r2 !== this.m_treeHull.getPrev(a3); ) {
          u = this.m_treeHull.getElement(i3);
          const e3 = this.m_getXY(u);
          Yr(mi.orientationRobust(e3, t3, o)) ? (a3 = i3, i3 = this.m_treeHull.getLeft(i3)) : (r2 = i3, i3 = this.m_treeHull.getRight(i3));
        }
        i3 = a3, h3 = r2, u = this.m_treeHull.getElement(i3), m3 = this.m_treeHull.getElement(h3);
        const l2 = this.m_getXY(u), c = this.m_getXY(m3);
        if (h3 !== s3) {
          if (!Mr(mi.orientationRobust(c, t3, l2))) break;
        }
        e2 = this.m_treeHull.addElementAtPosition(h3, i3, -2, true, false), this.treeHullWalkForward(t3, i3, n5), this.treeHullWalkBackward(t3, h3, s3);
        break;
      }
      {
        const i3 = Nr(t3, a2, o);
        if (-1 === i3) {
          const i4 = this.m_treeHull.getPrev(n5);
          this.m_treeHull.deleteNode(n5), e2 = this.m_treeHull.addBiggestElement(-3), this.treeHullWalkBackward(t3, i4, s3);
        } else if (1 === i3) {
          const i4 = this.m_treeHull.getNext(s3);
          this.m_treeHull.deleteNode(s3), e2 = this.m_treeHull.addElementAtPosition(-1, i4, -3, true, false), this.treeHullWalkForward(t3, i4, n5);
        }
        break;
      }
    } while (0);
    return e2;
  }
  treeHullWalkForward(t3, e2, s3) {
    if (e2 === s3) return s3;
    let n5 = e2, i2 = this.m_treeHull.getElement(n5), r = this.m_treeHull.getNext(n5);
    const o = this.m_getXY(i2);
    for (; n5 !== s3 && this.m_treeHull.size() > 2; ) {
      const e3 = this.m_treeHull.getElement(r), s4 = this.m_getXY(e3);
      if (Mr(mi.orientationRobust(s4, t3, o))) break;
      const a2 = n5;
      n5 = r, i2 = e3, o.assign(s4), r = this.m_treeHull.getNext(n5), this.m_deleteNode(a2);
    }
    return n5;
  }
  treeHullWalkBackward(t3, e2, s3) {
    if (e2 === s3) return s3;
    let n5 = e2, i2 = this.m_treeHull.getElement(n5), r = this.m_treeHull.getPrev(n5);
    const o = this.m_getXY(i2);
    for (; n5 !== s3 && this.m_treeHull.size() > 2; ) {
      const e3 = this.m_treeHull.getElement(r), s4 = this.m_getXY(e3);
      if (Mr(mi.orientationRobust(o, t3, s4))) break;
      const a2 = n5;
      n5 = r, i2 = e3, o.assign(s4), r = this.m_treeHull.getPrev(n5), this.m_deleteNode(a2);
    }
    return n5;
  }
};
function Ar(t3, e2, s3) {
  const n5 = e2.sub(t3), i2 = s3.sub(e2);
  if (0 === n5.x) return i2.x > 0 ? -1 : 0;
  if (0 === n5.y) return i2.y > 0 ? 1 : i2.y < 0 ? -1 : 0;
  const r = n5.crossProduct(i2), o = 4 * Number.EPSILON * (Math.abs(i2.x * n5.y) + Math.abs(i2.y * n5.x));
  return r > o ? 1 : r < -o ? -1 : mi.orientationRobust(t3, e2, s3);
}
function Tr(t3, e2, s3) {
  const n5 = e2.sub(t3), i2 = s3.sub(e2);
  if (0 === n5.x) return i2.x < 0 ? -1 : 0;
  if (0 === n5.y) return i2.y > 0 ? -1 : i2.y < 0 ? 1 : 0;
  const r = n5.crossProduct(i2), o = 4 * Number.EPSILON * (Math.abs(i2.x * n5.y) + Math.abs(i2.y * n5.x));
  return r > o ? 1 : r < -o ? -1 : mi.orientationRobust(t3, e2, s3);
}
function Ir(t3, e2, s3, n5) {
  const i2 = new st2(0);
  for (let h2 = 0; h2 < e2; h2++) i2.add(h2);
  const r = { userSort(e3, s4, n6) {
    n6.sort(e3, s4, (e4, s5) => t3[e4].compareX(t3[s5]));
  }, getValue: (e3) => t3[e3].x };
  n5 || ot.sortEx(i2, 0, e2, r);
  let o = 0;
  t: for (let h2 = 0; h2 < e2; ++h2) {
    const e3 = i2.read(h2);
    for (; o >= 2; ) {
      const n6 = s3[o - 2], r2 = s3[o - 1];
      if (t3[r2].equals(t3[e3])) {
        i2.write(h2, -1);
        continue t;
      }
      if (!(Ar(t3[n6], t3[r2], t3[e3]) >= 0)) {
        r2 === i2.read(h2 - 1) && i2.write(h2 - 1, -1);
        break;
      }
      o--;
    }
    s3[o++] = e3, 2 === o && t3[e3].equals(t3[s3[0]]) && (i2.write(1, -1), o--);
  }
  const a2 = o + 1;
  t: for (let h2 = e2 - 2; h2 >= 0; --h2) {
    const e3 = i2.read(h2);
    if (!(e3 < 0)) {
      for (; o >= a2; ) {
        const n6 = s3[o - 2], i3 = s3[o - 1];
        if (t3[i3].equals(t3[e3])) continue t;
        if (!(Tr(t3[n6], t3[i3], t3[e3]) >= 0)) break;
        o--;
      }
      if (0 !== h2) {
        const n6 = s3[o - 1];
        s3[o++] = e3, t3[e3].equals(t3[n6]) && o--;
      }
    }
  }
  return o > 1 && t3[s3[0]].equals(t3[s3[o - 1]]) && o--, o;
}
function Mr(t3) {
  return t3 < 0;
}
function Yr(t3) {
  return t3 > 0;
}
function Nr(t3, e2, s3) {
  let n5 = -1;
  if (e2.y === s3.y) n5 = 0;
  else if (e2.x === s3.x) n5 = 1;
  else {
    n5 = Math.abs(e2.x - s3.x) >= Math.abs(e2.y - s3.y) ? 0 : 1;
  }
  let i2 = -1;
  return i2 = e2[n5] < s3[n5] ? t3[n5] < e2[n5] ? -1 : s3[n5] < t3[n5] ? 1 : 0 : e2[n5] < t3[n5] ? -1 : t3[n5] < s3[n5] ? 1 : 0, i2;
}
function Xr(t3) {
  return (t3 = t3.clone()).divThis(Math.max(Math.abs(t3.x), Math.abs(t3.y))), t3.normalize(), t3;
}
function qr(t3, e2, s3) {
  t3.inc(e2, 0) === s3 && t3.set(e2, 0, 0), t3.inc(e2, 1) === s3 && t3.set(e2, 1, 0);
}
function Fr(e2, s3, n5, i2, r) {
  switch (r) {
    case 0:
      break;
    case 1:
      s3.rightPerpendicularThis(), e2.rightPerpendicularThis();
      break;
    case 2:
      s3.negateThis(), e2.negateThis();
      break;
    case 3:
      s3.leftPerpendicularThis(), e2.leftPerpendicularThis();
      break;
    default:
      P("");
  }
  return mi.orientationRobustEx(e2, s3, n5, i2);
}
var Vr = class {
  constructor() {
    this.length = Number.NaN, this.specialPoints = [];
  }
  specialPointsCount() {
    return this.specialPoints.length;
  }
};
function Lr(t3) {
  return Rr(t3.calculateUpperLength2D());
}
function Rr(t3) {
  return 256 * Qs() * t3;
}
function zr(t3) {
  const e2 = mi.distance(t3.getStartXY(), t3.getEndXY()), s3 = t3.calculateUpperLength2D();
  return s3 - e2 <= 8 * Number.EPSILON * s3;
}
function Br(t3, e2, s3 = false) {
  e2[1].setCoords(t3.m_cp[0].x - t3.getStartX(), t3.m_cp[0].y - t3.getStartY()), e2[1].mulThis(3), e2[2].setCoords(t3.m_cp[1].x - t3.m_cp[0].x, t3.m_cp[1].y - t3.m_cp[0].y), e2[2].mulThis(3), e2[3] = t3.getEndXY().sub(t3.getStartXY()), e2[3].subThis(e2[2]), e2[2].subThis(e2[1]), s3 ? e2[0].setCoords(0, 0) : e2[0] = t3.getStartXY();
}
function kr(t3, e2, s3) {
  const n5 = Ot(mi, 4);
  t3.queryControlPoints(n5), Wr(n5, e2, s3);
}
function Gr(t3, e2, s3) {
  const n5 = Ot(mi, 4);
  t3.queryControlPoints(n5), jr(n5, e2, s3);
}
function Wr(t3, e2, s3) {
  let n5 = t3[1].x;
  n5 -= t3[0].x, n5 *= 3;
  let i2 = t3[2].x;
  i2 -= t3[1].x, i2 *= 3;
  let r = t3[3].x;
  r -= t3[0].x, r -= i2, i2 -= n5, e2[3].setWithEps(r), e2[2].setWithEps(i2), e2[1].setWithEps(n5), s3 ? e2[0].set(0) : e2[0].set(t3[0].x);
}
function jr(t3, e2, s3) {
  let n5 = t3[1].y;
  n5 -= t3[0].y, n5 *= 3;
  let i2 = t3[2].y;
  i2 -= t3[1].y, i2 *= 3;
  let r = t3[3].y;
  r -= t3[0].y, r -= i2, i2 -= n5, e2[3].setWithEps(r), e2[2].setWithEps(i2), e2[1].setWithEps(n5), s3 ? e2[0].set(0) : e2[0].set(t3[0].y);
}
function Zr(t3, e2, s3 = false) {
  const n5 = Ot(Ee, 4);
  n5[0].assignPoint2D(t3[0]), n5[1].assignPoint2D(t3[1]), n5[2].assignPoint2D(t3[2]), n5[3].assignPoint2D(t3[3]), e2[1].setCoords(n5[1].x.sub(n5[0].x), n5[1].y.sub(n5[0].y)), e2[1].mulThis(si.constructInt32(3)), e2[2].setCoords(n5[2].x.sub(n5[1].x), n5[2].y.sub(n5[1].y)), e2[2].mulThis(si.constructInt32(3)), e2[3] = n5[3].sub(n5[0]), e2[3] = e2[3].sub(e2[2]), e2[2] = e2[2].sub(e2[1]), s3 ? e2[0].setCoords(ei, ei) : e2[0] = n5[0].clone();
}
function Hr(t3, e2, s3) {
  if (s3) {
    if (e2 < 0) return e2;
    if (e2 > 1) return e2 - 1 + Hr(t3, 1, false);
  }
  if (t3.isDegenerate(0)) return 0;
  const n5 = 1 === e2, i2 = Qr(t3);
  if (n5 && !Number.isNaN(i2.length) && !Number.isNaN(i2.length)) return i2.length;
  const r = Lr(t3), o = r / t3.calculateUpperLength2D();
  let a2 = 0, h2 = 0;
  for (let u = 1, m3 = i2.specialPointsCount(); u < m3; u++) {
    const s4 = i2.specialPoints[u];
    if (a2 += $o(t3, h2, Math.min(e2, s4), o, r), e2 <= s4) break;
    h2 = s4;
  }
  return n5 && (i2.length = a2), a2;
}
function Ur(t3, e2, s3) {
  const n5 = Hr(t3, 1, false);
  if (e2 <= 0) return e2;
  if (e2 >= n5) return e2 - n5 + 1;
  const i2 = [0];
  return 1 !== tn(new Ko(t3, e2), x2.unit(), 1, i2) && b(""), i2[0];
}
function Or(e2, s3, n5) {
  void 0 === n5 && (n5 = s3, s3 = 0);
  const i2 = new mi();
  if (s3 < 0 || n5 > 1) return i2.setNAN(), i2;
  if (s3 > n5 && P("calculate_sub_weightedCentroid"), s3 === n5 || e2.isDegenerate(0)) return i2.setCoords(0, 0), i2;
  const r = Qr(e2), o = Lr(e2), a2 = o / e2.calculateUpperLength2D();
  let h2 = s3, u = 0;
  for (let t3 = 1, m3 = r.specialPointsCount(); t3 < m3; t3++) if (s3 < r.specialPoints[t3]) {
    u = t3 - 1;
    break;
  }
  i2.setCoords(0, 0);
  for (let t3 = u + 1, m3 = r.specialPointsCount(); t3 < m3; t3++) {
    const s4 = Math.min(r.specialPoints[t3], n5), u2 = ta(e2, h2, s4, a2, o);
    if (i2.addThis(u2), h2 = s4, n5 <= r.specialPoints[t3]) break;
  }
  return i2.add(e2.getStartXY().mul(e2.calculateLength2D()));
}
function Qr(t3) {
  if (t3.m_cachedValues) return t3.m_cachedValues;
  const e2 = new Vr(), s3 = Ot(p2, 8), n5 = Ot(mi, 4);
  t3.queryControlPoints(n5);
  const i2 = jo(n5, s3);
  e2.specialPoints = [];
  for (let r = 0; r < i2; r++) e2.specialPoints.push(s3[r].value());
  return Jr(t3, e2), e2;
}
function Kr(t3) {
  let e2 = null;
  return e2 = t3.m_cachedValues, e2;
}
function Jr(t3, e2) {
  t3.m_cachedValues = e2;
}
function $r(t3) {
  t3.m_cachedValues = null;
}
function to(t3, e2) {
  e2.m_cachedValues = Pt(t3.m_cachedValues, t3.m_cachedValues = e2.m_cachedValues);
}
function eo(t3, e2, s3, n5) {
  if (e2.isEqual(t3.m_XStart, t3.m_YStart) && s3.isEqual(t3.m_XEnd, t3.m_YEnd)) return;
  const i2 = !!n5 && t3.isMonotoneQuickAndDirty(), r = new x3(), o = Ot(mi, 3);
  o[0].setCoords(t3.m_XStart, t3.m_YStart), o[2].setCoords(t3.m_XEnd, t3.m_YEnd);
  const a2 = new mi();
  a2.setSub(o[2], o[0]), a2.leftPerpendicularThis(), o[1].setAdd(o[0], a2);
  const h2 = Ot(mi, 3);
  h2[0].setCoordsPoint2D(e2), h2[2].setCoordsPoint2D(s3), a2.setSub(h2[2], h2[0]), a2.leftPerpendicularThis(), h2[1].setAdd(h2[0], a2), r.setFromTwoTriangles(o, h2) ? r.transformPoints2D(t3.m_cp, 2, t3.m_cp) : (Y(e2, s3, 1 / 3, t3.m_cp[0]), Y(e2, s3, 2 / 3, t3.m_cp[1])), t3.changeEndPoints2D(e2, s3), i2 && lo(t3);
}
function so(t3, e2, s3, n5, i2) {
  return { tmin: t3, tmax: e2, t: s3, d: n5, pt: i2.clone() };
}
function no(t3, e2, s3, n5) {
  const i2 = Ot(mi, 4);
  t3.queryControlPoints(i2);
  const r = Yt(18, NaN), o = tn(new Vo(i2, e2, NaN), x2.construct(s3, n5), 18, r), a2 = new mi();
  t3.queryCoord2D(s3, a2);
  let h2 = s3, u = mi.distance(a2, e2);
  const m3 = new mi();
  t3.queryCoord2D(n5, m3);
  const l2 = mi.distance(m3, e2);
  l2 < u && (u = l2, h2 = n5, a2.assign(m3));
  for (let c = 0; c < o; c++) {
    t3.queryCoord2D(r[c], m3);
    const s4 = mi.distance(m3, e2);
    s4 < u && (u = s4, h2 = r[c], a2.assign(m3));
  }
  return so(s3, n5, h2, u, a2);
}
function io(t3, e2) {
  const s3 = Ot(p2, 4);
  kr(t3, s3, true);
  const i2 = Ot(p2, 4);
  Gr(t3, i2, true);
  const r = s3[3].clone(), o = s3[2].clone(), a2 = s3[1].clone(), h2 = i2[3].clone(), u = i2[2].clone(), m3 = i2[1].clone(), l2 = o.mulE(a2).addE(u.mulE(m3)).mul(4), c = o.mulE(o).mul(8).addE(r.mulE(a2).mul(12)).addE(u.mulE(u).mul(8).addE(h2.mulE(m3).mul(12))), g2 = r.mulE(o).addE(h2.mulE(u)).mul(36), d2 = r.mulE(r).addE(h2.mulE(h2)).mul(36), _ = Ot(p2, 3), p3 = dn(d2, g2, c, l2, new x2(0, 1), false, _);
  if (n(p3 <= 3), p3 > 0) {
    const s4 = uo(t3, 1, 0).sqrLength(), n5 = uo(t3, 1, 1).sqrLength();
    let i3 = s4;
    e2.set(0), i3 < n5 && (i3 = n5, e2.set(1));
    for (let r2 = 0; r2 < p3; r2++) {
      const s5 = uo(t3, 1, _[r2].value()).sqrLength();
      s5 < i3 && (i3 = s5, e2 = _[r2]);
    }
  }
}
function ro(t3, e2, s3, n5) {
  if (1 === e2) {
    const e3 = 1 - s3, i2 = e3 * e3, r = s3 * s3, o = t3[1].sub(t3[0]), a2 = t3[2].sub(t3[1]), h2 = t3[3].sub(t3[2]), u = o.mul(i2).add(a2.mul(2 * e3 * s3)).add(h2.mul(r));
    n5.assign(u.mul(3));
  } else if (2 === e2) {
    const e3 = 1 - s3, i2 = t3[2].sub(t3[1]).sub(t3[1].sub(t3[0])), r = t3[3].sub(t3[2]).sub(t3[2].sub(t3[1])), o = i2.mul(e3).add(r.mul(s3));
    n5.assign(o.mul(6));
  } else if (3 === e2) {
    const e3 = t3[2].sub(t3[1]), s4 = t3[3].sub(e3.mul(3)).sub(t3[0]);
    n5.assign(s4.mul(6));
  } else n5.setCoords(0, 0);
}
function oo(t3, e2, s3, n5) {
  {
    const e3 = w2.subE(s3), i2 = e3.sqr(), r = s3.sqr(), o = t3[1].subE(t3[0]).mulE(i2).addE(t3[2].subE(t3[1]).mulE(new p2(2).mulE(e3).mulE(s3))).addE(t3[3].subE(t3[2]).mulE(r));
    n5.setE(o.mulE(new p2(3)));
  }
}
function ao(t3, e2, s3) {
  const n5 = new mi();
  return ro(t3, e2, s3, n5), n5;
}
function ho(t3, e2, s3) {
  const n5 = [ve.constructPoint2D(t3[0]), ve.constructPoint2D(t3[1]), ve.constructPoint2D(t3[2]), ve.constructPoint2D(t3[3])], i2 = new ve();
  return oo(n5, e2, s3, i2), i2;
}
function uo(t3, e2, s3) {
  const n5 = Ot(mi, 4);
  return t3.queryControlPoints(n5), ao(n5, e2, s3);
}
function mo(t3) {
  const e2 = t3.m_cp[0].sub(t3.getStartXY()), s3 = t3.m_cp[1].sub(t3.m_cp[0]), n5 = t3.getEndXY().sub(t3.getStartXY());
  e2.mulThis(3), s3.mulThis(3), n5.subThis(s3), s3.subThis(e2);
  return (3 * n5.x * (2 * s3.y + 5 * e2.y) - 3 * n5.y * (2 * s3.x + 5 * e2.x) + 10 * (s3.x * e2.y - s3.y * e2.x)) / 60;
}
function lo(t3) {
  const e2 = Ot(mi, 4);
  t3.queryControlPoints(e2);
  const s3 = co(e2);
  return s3 && (t3.m_cp[0].setCoordsPoint2D(e2[1]), t3.m_cp[1].setCoordsPoint2D(e2[2]), t3.afterCompletedModification()), s3;
}
function co(t3) {
  return De(t3);
}
function go(t3) {
  return we(t3);
}
function _o(t3, e2, s3) {
  const n5 = new mi(), i2 = new mi(), r = new mi(), o = new mi(), a2 = new mi();
  e2 <= 0.5 ? (k2(2, t3[0], t3[1], e2, n5), k2(2, t3[1], t3[2], e2, i2), k2(2, t3[2], t3[3], e2, r), k2(2, n5, i2, e2, o), k2(2, i2, r, e2, a2), k2(2, o, a2, e2, s3)) : (F(2, t3[0], t3[1], e2, n5), F(2, t3[1], t3[2], e2, i2), F(2, t3[2], t3[3], e2, r), F(2, n5, i2, e2, o), F(2, i2, r, e2, a2), F(2, o, a2, e2, s3));
}
function po(t3, e2, s3, i2) {
  n(e2 >= 0 && e2 <= 1);
  const r = new mi(), o = new mi(), a2 = new mi(), h2 = new mi(), u = new mi(), m3 = new mi();
  e2 <= 0.5 ? (k2(2, t3[0], t3[1], e2, r), k2(2, t3[1], t3[2], e2, o), k2(2, t3[2], t3[3], e2, a2), k2(2, r, o, e2, h2), k2(2, o, a2, e2, u), k2(2, h2, u, e2, m3)) : (F(2, t3[0], t3[1], e2, r), F(2, t3[1], t3[2], e2, o), F(2, t3[2], t3[3], e2, a2), F(2, r, o, e2, h2), F(2, o, a2, e2, u), F(2, h2, u, e2, m3));
  const l2 = t3[3].clone();
  s3 && (s3[0].assign(t3[0]), s3[1].assign(r), s3[2].assign(h2), s3[3].assign(m3)), i2 && (i2[0].assign(m3), i2[1].assign(u), i2[2].assign(a2), i2[3].assign(l2));
}
function fo(t3, e2, s3, i2) {
  if (n(e2 >= 0 && s3 <= 1 && e2 <= s3), e2 === s3) {
    const s4 = new mi();
    return Po(t3, e2, s4), i2[0].assign(s4), i2[1].assign(s4), i2[2].assign(s4), void i2[3].assign(s4);
  }
  if (0 === e2 && 1 === s3) {
    for (let e3 = 0; e3 < 4; ++e3) i2[e3].assign(t3[e3]);
    return;
  }
  const r = Ot(mi, 4);
  po(t3, s3, r, null), po(r, s3 > 0 ? e2 / s3 : 0, null, r), Po(t3, e2, r[0]), Po(t3, s3, r[3]), i2[0].setCoordsPoint2D(r[0]), i2[1].setCoordsPoint2D(r[1]), i2[2].setCoordsPoint2D(r[2]), i2[3].setCoordsPoint2D(r[3]);
}
function Po(t3, e2, s3, n5) {
  if (n5) {
    if (e2 < 0) {
      return void _s2(new pm({ start: t3[0], end: t3[0].add(Co(t3, 0).getUnitVector()) }), e2, s3);
    }
    if (e2 > 1) {
      return void _s2(new pm({ start: t3[3], end: t3[3].add(Co(t3, 1).getUnitVector()) }), e2 - 1, s3);
    }
  }
  if (e2 <= 0.5) {
    const n6 = new mi();
    k2(2, t3[0], t3[1], e2, n6);
    const i2 = new mi();
    k2(2, t3[1], t3[2], e2, i2);
    const r = new mi();
    k2(2, t3[2], t3[3], e2, r);
    const o = new mi();
    k2(2, n6, i2, e2, o);
    const a2 = new mi();
    k2(2, i2, r, e2, a2), k2(2, o, a2, e2, s3);
  } else {
    const n6 = new mi();
    F(2, t3[0], t3[1], e2, n6);
    const i2 = new mi();
    F(2, t3[1], t3[2], e2, i2);
    const r = new mi();
    F(2, t3[2], t3[3], e2, r);
    const o = new mi();
    F(2, n6, i2, e2, o);
    const a2 = new mi();
    F(2, i2, r, e2, a2), F(2, o, a2, e2, s3);
  }
}
function yo(t3, e2, s3) {
  if (e2.value() <= 0.5) {
    const n5 = new ve();
    O(2, ve.constructPoint2D(t3[0]), ve.constructPoint2D(t3[1]), e2, n5);
    const i2 = new ve();
    O(2, ve.constructPoint2D(t3[1]), ve.constructPoint2D(t3[2]), e2, i2);
    const r = new ve();
    O(2, ve.constructPoint2D(t3[2]), ve.constructPoint2D(t3[3]), e2, r);
    const o = new ve();
    O(2, n5, i2, e2, o);
    const a2 = new ve();
    O(2, i2, r, e2, a2), O(2, o, a2, e2, s3);
  } else {
    const n5 = new ve();
    G2(2, ve.constructPoint2D(t3[0]), ve.constructPoint2D(t3[1]), e2, n5);
    const i2 = new ve();
    G2(2, ve.constructPoint2D(t3[1]), ve.constructPoint2D(t3[2]), e2, i2);
    const r = new ve();
    G2(2, ve.constructPoint2D(t3[2]), ve.constructPoint2D(t3[3]), e2, r);
    const o = new ve();
    G2(2, n5, i2, e2, o);
    const a2 = new ve();
    G2(2, i2, r, e2, a2), G2(2, o, a2, e2, s3);
  }
}
function xo(t3, e2, s3) {
  const n5 = Ot(mi, 4);
  t3.queryControlPoints(n5), yo(n5, e2, s3);
}
function Co(t3, e2) {
  const s3 = Us(e2, 0, 1);
  let n5 = ao(t3, 1, s3);
  return n5.isZero() && (n5 = ao(t3, 2, s3), n5.isZero() ? n5 = ao(t3, 3, s3) : 1 === s3 && n5.negateThis()), n5;
}
function vo(t3, e2, s3) {
  const n5 = Ot(mi, 4);
  t3.queryControlPoints(n5), bo(n5, e2, s3);
}
function bo(t3, e2, s3) {
  e2.value() < 0 && e2.set(0, e2.eps()), e2.value() > 1 && e2.set(1, e2.eps()), s3.setE(ho(t3, 1, e2));
}
function Eo(t3, e2, s3, n5, i2) {
  if (i2) {
    if (0 !== am(e2, s3)) return t3 ? 4 : 2;
  } else if (Ae(e2, s3)) return 1;
  return 0 !== To(t3, e2, s3, null, null, null, n5, void 0 !== i2 && i2, true, false) ? 4 : 0;
}
function So(t3, e2, s3, n5, i2) {
  if (i2) {
    if (0 !== am(e2, s3)) return t3 ? 4 : 2;
  } else if (Ae(e2, s3)) return 1;
  return 0 !== Io(t3, e2, s3, null, null, null, n5, void 0 !== i2 && i2, true, false) ? 4 : 0;
}
function Do(t3, e2, s3, n5, i2) {
  if (i2) {
    if (0 !== am(e2, s3)) return 2;
  } else if (Ae(e2, s3)) return 1;
  return 0 !== Mo(t3, e2, s3, null, null, null, n5, void 0 !== i2 && i2, true, false) ? 4 : 0;
}
function wo(t3, e2, s3, n5, i2) {
  if (i2) {
    if (0 !== am(e2, s3)) return t3 ? 4 : 2;
  } else if (Ae(e2, s3)) return 1;
  return 0 !== Yo(t3, e2, s3, null, null, null, n5, void 0 !== i2 && i2, true, false) ? 4 : 0;
}
function Ao(t3, e2, s3, n5, i2) {
  if (i2) {
    if (0 !== am(e2, s3)) return t3 ? 4 : 2;
  } else if (Ae(e2, s3)) return 1;
  return 0 !== No(t3, e2, s3, null, null, null, n5, i2 ?? false, true, false) ? 4 : 0;
}
function To(t3, e2, s3, n5, i2, r, o, a2, h2, u) {
  if (null !== i2 && (i2.length = 0), null != r && (r.length = 0), null !== n5 && (n5.length = 0), s3.isDegenerate(0)) {
    const t4 = [0, 0, 0], a3 = e2.intersectPoint(s3.getStartXY(), t4, o);
    if (a3 > 0) {
      if (null !== i2) for (let e3 = 0; e3 < a3; e3++) i2.push(t4[e3]);
      if (null !== r) for (let t5 = 0; t5 < a3; t5++) r.push(0);
      if (null != n5) for (let s4 = 0; s4 < a3; s4++) {
        const i3 = new mi();
        e2.queryCoord2D(t4[s4], i3), n5.push(i3);
      }
    }
    return a3;
  }
  const m3 = Oe(e2, s3);
  if (Qe(e2, s3, o = Math.max(o, m3))) return 0;
  const l2 = Ot(mi, 4);
  Br(e2, l2);
  const c = s3.getEndXY();
  c.subThis(s3.getStartXY());
  const g2 = c.clone();
  g2.leftPerpendicularThis();
  let d2 = 3 * l2[3].dotProduct(g2), _ = 2 * l2[2].dotProduct(g2), p3 = l2[1].dotProduct(g2);
  const f3 = Yt(15, Number.NaN), P5 = Yt(15, Number.NaN);
  let y2 = sn(d2, _, p3, x2.unit(), false, f3);
  y2 < 0 && (f3[0] = 0, f3[1] = 1, y2 = 2);
  let x4, C3 = 0;
  for (let E2 = 0, S3 = C3; E2 < y2; ++E2) {
    const t4 = e2.getCoord2D(f3[E2 + S3]);
    P5[C3] = s3.getClosestCoordinate(t4, false), mi.distance(t4, s3.getCoord2D(P5[C3])) <= o && (f3[C3] = f3[E2 + S3], C3++);
  }
  if (l2[0].subThis(s3.getStartXY()), Math.abs(c.x) >= Math.abs(c.y)) {
    const t4 = c.y / c.x;
    d2 = l2[3].y - l2[3].x * t4, _ = l2[2].y - l2[2].x * t4, p3 = l2[1].y - l2[1].x * t4, x4 = l2[0].y - l2[0].x * t4;
  } else {
    const t4 = c.x / c.y;
    d2 = l2[3].x - l2[3].y * t4, _ = l2[2].x - l2[2].y * t4, p3 = l2[1].x - l2[1].y * t4, x4 = l2[0].x - l2[0].y * t4;
  }
  const v3 = e2.getEndXY().equals(s3.getStartXY()) || e2.getEndXY().equals(s3.getEndXY()), b2 = [0, 0, 0];
  y2 = nn(d2, _, p3, x4, x2.unit(), v3, b2);
  for (let E2 = 0, S3 = C3; E2 < y2; ++E2) {
    f3[E2 + S3] = b2[E2];
    const t4 = e2.getCoord2D(f3[E2 + S3]);
    P5[C3] = s3.getClosestCoordinate(t4, false);
    mi.distance(t4, s3.getCoord2D(P5[C3])) <= o && (f3[C3] = f3[E2 + S3], C3++);
  }
  y2 = e2.intersectPoint(s3.getStartXY(), b2, o);
  for (let E2 = 0; E2 < y2; E2++) f3[C3] = b2[E2], P5[C3++] = 0;
  y2 = e2.intersectPoint(s3.getEndXY(), b2, o);
  for (let E2 = 0; E2 < y2; E2++) f3[C3] = b2[E2], P5[C3++] = 1;
  return 0 !== s3.intersectPoint(e2.getStartXY(), b2, o) && (P5[C3] = b2[0], f3[C3++] = 0), 0 !== s3.intersectPoint(e2.getEndXY(), b2, o) && (P5[C3] = b2[0], f3[C3++] = 1), 0 === C3 ? 0 : cm(t3, e2, s3, f3, P5, C3, n5, i2, r, o, a2, h2, u);
}
function Io(t3, e2, s3, n5, i2, r, o, a2, h2, u) {
  if (Eu(s3)) {
    return To(t3, e2, new pm({ start: s3.getStartXY(), end: s3.getEndXY() }), n5, i2, r, o, a2, h2, u);
  }
  const m3 = Oe(e2, s3);
  if (Qe(e2, s3, o = Math.max(o, m3))) return 0;
  const l2 = [], c = [], g2 = [], d2 = Ot(mi, 4);
  {
    e2.queryControlPoints(d2);
    const t4 = Ot(mi, 4), n6 = new x3();
    s3.canonicToWorldTransformation(n6);
    const i3 = new x3();
    i3.setInvert(n6), i3.transformPoints2D(d2, 4, t4);
    const r2 = Ot(Ee, 4);
    Zr(t4, r2);
    const h3 = [r2[0].x, r2[1].x, r2[2].x, r2[3].x], u2 = [r2[0].y, r2[1].y, r2[2].y, r2[3].y], m4 = Ot(si, 3);
    m4[0].setDouble(s3.getSemiMinorAxis()), m4[0].sqrThis(), m4[1].setDouble(s3.getSemiMajorAxis()), m4[1].sqrThis(), m4[2].setThis(m4[0]), m4[2].mulThis(m4[1]), m4[2].negateThis();
    const _2 = qn(h3, 3, u2, 3, null, 0, m4, true, x2.unit(), x2.unit(), c, a2);
    if (_2 > 0) {
      let t5 = 0;
      for (let n7 = 0; n7 < _2; n7++) {
        const i4 = new mi();
        e2.queryCoord2D(c[n7], i4);
        const r3 = s3.getClosestCoordinate(i4, false), a3 = new mi();
        s3.queryCoord2D(r3, a3);
        mi.distance(i4, a3) <= o && (l2.push(i4.clone()), c[t5] = c[n7], g2.push(r3), t5++);
      }
      c.length = t5, l2.length = t5;
    }
  }
  const _ = [0, 1];
  for (let p3 = 0; p3 < 2; p3++) {
    const t4 = 0 === p3 ? s3.getStartXY() : s3.getEndXY(), e3 = [0];
    Lo(d2, t4, x2.unit(), false, -1, 1, e3);
    const n6 = new mi();
    Po(d2, e3[0], n6);
    mi.distance(t4, n6) <= o && (c.push(e3[0]), g2.push(_[p3]), l2.push(n6.clone()));
  }
  for (let p3 = 0; p3 < 2; p3++) {
    const t4 = [0, 3];
    {
      const e3 = s3.getClosestCoordinate(d2[t4[p3]], false), n6 = new mi();
      s3.queryCoord2D(e3, n6);
      mi.distance(d2[t4[p3]], n6) <= o && (c.push(_[p3]), g2.push(e3), l2.push(n6.clone()));
    }
  }
  return cm(t3, e2, s3, c, g2, c.length, n5, i2, r, o, a2, h2, u);
}
function Mo(t3, e2, s3, i2, r, o, a2, h2, u, m3) {
  const l2 = Ot(mi, 4);
  e2.queryControlPoints(l2);
  const c = Ot(mi, 4);
  if (s3.queryControlPoints(c), Ke(l2, c, 4) < 0) return Mo(t3, s3, e2, i2, o, r, a2, h2, u, !m3);
  const g2 = Oe(e2, s3);
  if (Qe(e2, s3, a2 = Math.max(a2, g2))) return 0;
  if (ea(e2, s3, i2, r, o, a2, h2, u, m3)) return 2;
  const d2 = new x2(0, 1), _ = new x2(0, 1);
  {
    const t4 = new pe();
    Fo(l2, new x2(0, 1), t4);
    const e3 = new pe();
    Fo(c, new x2(0, 1), e3);
    const s4 = Math.max(t4.maxDim(), e3.maxDim());
    if (t4.inflate(3 * a2), e3.inflate(3 * a2), !t4.intersectW(e3)) return 0;
    if (t4.maxDim() < 0.1 * s4) {
      if (Oo(l2, t4, d2), d2.isEmpty()) return 0;
      if (Oo(c, t4, _), _.isEmpty()) return 0;
      fo(l2, d2.vmin, d2.vmax, l2), fo(c, _.vmin, _.vmax, c);
    }
  }
  const p3 = dm(l2, 3, c, 3, a2);
  if (0 === p3) return 0;
  const f3 = [], P5 = [], y2 = [];
  let x4 = false;
  if (-1 === p3) {
    const t4 = Ot(Ee, 4);
    Zr(l2, t4);
    const e3 = [t4[0].x, t4[1].x, t4[2].x, t4[3].x], s4 = [t4[0].y, t4[1].y, t4[2].y, t4[3].y], n5 = Ot(Ee, 4);
    Zr(c, n5);
    const i3 = [], r2 = [], o2 = Yn(e3, 3, s4, 3, null, 0, [n5[0].x, n5[1].x, n5[2].x, n5[3].x], 3, [n5[0].y, n5[1].y, n5[2].y, n5[3].y], 3, null, 0, true, x2.unit(), x2.unit(), i3, r2, u);
    if (o2 > 0) for (let h3 = 0; h3 < o2; h3++) {
      const t5 = new mi();
      Po(c, r2[h3], t5);
      const e4 = new mi();
      Po(l2, i3[h3], e4);
      mi.distance(e4, t5) <= a2 && (f3.push(e4.clone()), y2.push(r2[h3]), P5.push(i3[h3]));
    }
    else -1 === o2 && (x4 = true);
  }
  for (let n5 = 0; n5 < 2; n5++) {
    const t4 = 0 === n5 ? l2 : c, e3 = 0 === n5 ? c : l2;
    for (let s4 = 0; s4 < 2; s4++) {
      const i3 = 0 === s4 ? 0 : 3, r2 = [0];
      Lo(e3, t4[i3], x2.unit(), false, -1, 1, r2);
      const o2 = new mi();
      Po(e3, r2[0], o2);
      mi.distance(t4[i3], o2) <= a2 && (0 === n5 ? (P5.push(0 === i3 ? 0 : 1), y2.push(r2[0])) : (y2.push(0 === i3 ? 0 : 1), P5.push(r2[0])), f3.push(o2.clone()));
    }
  }
  if (0 === P5.length && x4) {
    const t4 = e2.calculateUpperLength2D() > s3.calculateUpperLength2D();
    {
      const i3 = [0, 0];
      if (2 === Go(t4 ? e2 : s3, i3, true) && (n(x2.unit().containsCoordinate(i3[0])), !x2.unit().containsCoordinate(i3[1]))) {
        const e3 = new mi();
        Po(t4 ? l2 : c, i3[0], e3);
        const s4 = [0, 0];
        1 === Lo(t4 ? c : l2, e3, x2.unit(), false, -1, 2, s4) && (f3.push(e3.clone()), P5.push(t4 ? i3[0] : s4[0]), y2.push(t4 ? s4[0] : i3[0]));
      }
    }
  }
  if (0 === P5.length) return 0;
  if (!d2.equalsRange(0, 1)) for (let n5 = 0; n5 < P5.length; ++n5) P5[n5] = ia.recalculateParentT(d2.vmin, d2.vmax, P5[n5]);
  if (!_.equalsRange(0, 1)) for (let n5 = 0; n5 < y2.length; ++n5) y2[n5] = ia.recalculateParentT(_.vmin, _.vmax, y2[n5]);
  return cm(t3, e2, s3, P5, y2, P5.length, i2, r, o, a2, h2, u, m3);
}
function Yo(t3, e2, s3, i2, r, o, a2, h2, u, m3) {
  const l2 = Oe(e2, s3);
  if (s3.isDegenerateToLineHelper(l2)) {
    const n5 = new pm({ start: s3.getStartXY(), end: s3.getEndXY() }), l3 = To(t3, e2, n5, i2, r, o, a2, h2, u, m3);
    if (o) for (let t4 = 0; t4 < l3; ++t4) {
      const e3 = n5.getCoord2D(o[t4]);
      o[t4] = s3.getClosestCoordinate(e3, false);
    }
    return l3;
  }
  if (Qe(e2, s3, a2 = Math.max(a2, l2))) return 0;
  const c = Ot(mi, 4);
  e2.queryControlPoints(c);
  const g2 = Ot(mi, 3);
  s3.queryControlPoints(g2);
  const d2 = new x2(0, 1), _ = new x2(0, 1), p3 = [0, 0, 0];
  s3.queryWeights(p3);
  const f3 = [1, fh(p3), 1];
  {
    const t4 = new pe();
    Fo(c, new x2(0, 1), t4);
    const e3 = new pe();
    Wa(g2, f3, new x2(0, 1), e3);
    const s4 = Math.max(t4.maxDim(), e3.maxDim());
    if (t4.inflate(3 * a2), e3.inflate(3 * a2), !t4.intersectW(e3)) return 0;
    if (t4.maxDim() < 0.1 * s4) {
      if (Oo(c, t4, d2), d2.isEmpty()) return 0;
      if (ph(g2, f3, t4, _), _.isEmpty()) return 0;
      fo(c, d2.vmin, d2.vmax, c), Qa(g2, f3, _.vmin, _.vmax, g2, f3);
    }
  }
  const P5 = dm(c, 3, g2, 2, a2);
  if (0 === P5) return 0;
  const y2 = [], x4 = [], C3 = [];
  if (-1 === P5) {
    const t4 = Ot(Ee, 4);
    Zr(c, t4);
    const e3 = [t4[0].x, t4[1].x, t4[2].x, t4[3].x], s4 = [t4[0].y, t4[1].y, t4[2].y, t4[3].y], n5 = Ot(si, 3), i3 = Ot(si, 3), r2 = Ot(si, 3);
    hh(g2, f3, n5, i3, r2);
    const o2 = [], h3 = [], m4 = Yn(n5, 2, i3, 2, r2, 2, e3, 3, s4, 3, null, 0, true, x2.unit(), x2.unit(), h3, o2, u);
    if (m4 > 0) for (let u2 = 0; u2 < m4; u2++) {
      const t5 = new mi();
      Po(c, o2[u2], t5);
      const e4 = new mi();
      _h(g2, f3, h3[u2], e4);
      mi.distance(t5, e4) <= a2 && (y2.push(t5.clone()), x4.push(o2[u2]), C3.push(h3[u2]));
    }
  }
  for (let v3 = 0; v3 < 2; v3++) {
    let t4, e3;
    0 === v3 ? (t4 = c, e3 = g2) : (e3 = c, t4 = g2);
    for (let s4 = 0; s4 < 2; s4++) {
      const i3 = 0 === s4 ? 0 : t4.length - 1, r2 = [0], o2 = new mi();
      if (0 === v3) {
        const s5 = za(e3, f3, t4[i3], x2.unit(), false, -1, 1, r2);
        n(1 === s5), _h(e3, f3, r2[0], o2);
      } else {
        const s5 = Lo(e3, t4[i3], x2.unit(), false, -1, 1, r2);
        n(1 === s5), Po(e3, r2[0], o2);
      }
      mi.distance(t4[i3], o2) <= a2 && (0 === v3 ? (x4.push(0 === i3 ? 0 : 1), C3.push(r2[0])) : (C3.push(0 === i3 ? 0 : 1), x4.push(r2[0])), y2.push(o2.clone()));
    }
  }
  if (0 === x4.length) return 0;
  if (!d2.equalsRange(0, 1)) for (let n5 = 0; n5 < x4.length; ++n5) x4[n5] = ia.recalculateParentT(d2.vmin, d2.vmax, x4[n5]);
  if (!_.equalsRange(0, 1)) for (let n5 = 0; n5 < C3.length; ++n5) C3[n5] = Sn.recalculateParentT(_.vmin, _.vmax, C3[n5]);
  for (let n5 = 0; n5 < C3.length; ++n5) C3[n5] = Ph(p3, C3[n5]);
  return cm(t3, e2, s3, x4, C3, x4.length, i2, r, o, a2, h2, u, m3);
}
function No(t3, e2, s3, i2, r, o, a2, h2, u, m3) {
  const l2 = Oe(e2, s3);
  if (Qe(e2, s3, a2 = Math.max(a2, l2))) return 0;
  const c = Ot(mi, 4);
  e2.queryControlPoints(c);
  const g2 = Ot(mi, 3);
  s3.queryControlPoints(g2);
  const d2 = dm(c, 3, g2, 2, a2);
  if (0 === d2) return 0;
  const _ = [], p3 = [], f3 = [];
  if (-1 === d2) {
    const t4 = Ot(Ee, 4);
    Zr(c, t4);
    const n5 = [t4[0].x, t4[1].x, t4[2].x, t4[3].x], i3 = [t4[0].y, t4[1].y, t4[2].y, t4[3].y], r2 = Ot(Ee, 3);
    Wi(g2, r2);
    const o2 = Yn([r2[0].x, r2[1].x, r2[2].x], 2, [r2[0].y, r2[1].y, r2[2].y], 2, null, 0, n5, 3, i3, 3, null, 0, true, x2.unit(), x2.unit(), f3, p3, h2);
    if (o2 > 0) {
      let t5 = 0;
      for (let n6 = 0; n6 < o2; n6++) {
        const i4 = new mi();
        e2.queryCoord2D(p3[n6], i4);
        const r3 = new mi();
        s3.queryCoord2D(f3[n6], r3);
        mi.distance(i4, r3) <= a2 && (_.push(i4.clone()), p3[t5] = p3[n6], f3[t5] = f3[n6], t5++);
      }
      p3.length = t5, _.length = t5;
    }
  }
  for (let P5 = 0; P5 < 2; P5++) {
    let t4, e3;
    0 === P5 ? (t4 = c, e3 = g2) : (e3 = c, t4 = g2);
    for (let s4 = 0; s4 < 2; s4++) {
      const i3 = 0 === s4 ? 0 : t4.length - 1, r2 = [0], o2 = new mi();
      if (0 === P5) vi(e3, t4[i3], r2), ji(e3, r2[0], o2);
      else {
        const s5 = Lo(e3, t4[i3], x2.unit(), false, -1, 1, r2);
        n(1 === s5), Po(e3, r2[0], o2);
      }
      mi.distance(t4[i3], o2) <= a2 && (0 === P5 ? (p3.push(0 === i3 ? 0 : 1), f3.push(r2[0])) : (f3.push(0 === i3 ? 0 : 1), p3.push(r2[0])), _.push(o2.clone()));
    }
  }
  return cm(t3, e2, s3, p3, f3, p3.length, i2, r, o, a2, h2, u, m3);
}
function Xo(t3, e2, s3, r, o) {
  const a2 = new pe();
  if (qo(t3, x2.unit(), a2), a2.inflate(r), !a2.isIntersectingPoint2D(e2)) return 0;
  const h2 = Qr(t3);
  let u = 0, m3 = h2.specialPoints[0];
  const l2 = [];
  for (let i2 = 1, c = h2.specialPoints.length; i2 < c; ++i2) {
    const s4 = h2.specialPoints[i2], r2 = no(t3, e2, m3, s4);
    if (0 === l2.length) l2.push(r2);
    else if (r2.t === r2.tmin) n(l2.at(-1).d <= r2.d), l2.at(-1).tmax = r2.tmax;
    else if (l2.at(-1).t === l2.at(-1).tmax) {
      n(l2.at(-1).d >= r2.d);
      const t4 = l2.at(-1).tmin;
      l2[l2.length - 1] = r2, l2.at(-1).tmin = t4;
    } else l2.push(r2);
    m3 = s4;
  }
  for (const n5 of l2) if (n5.d <= r) {
    const t4 = n5.t;
    s3 ? (u >= s3.length && A(""), s3[u] = t4, u++) : u++;
  }
  return u;
}
function qo(t3, e2, s3) {
  const n5 = Ot(mi, 4);
  t3.queryControlPoints(n5), Fo(n5, e2, s3);
}
function Fo(t3, e2, s3) {
  if (e2.equalsRange(0, 1)) return void s3.setFromPoints(t3, 4);
  const n5 = Ot(mi, 4);
  fo(t3, e2.vmin, e2.vmax, n5), s3.setFromPoints(n5, 4);
}
var Vo = class {
  constructor(t3, e2, s3) {
    this.dbgCounter = 0, this.controlPoints = t3, this.point = e2.clone(), this.maxDistance = s3;
  }
  getMaxDerivative() {
    return 6;
  }
  getValue(t3, e2) {
    switch (t3) {
      case 0: {
        const t4 = new mi();
        Po(this.controlPoints, e2, t4);
        const s3 = ao(this.controlPoints, 1, e2);
        return 2 * t4.sub(this.point).dotProduct(s3);
      }
      case 1: {
        const t4 = new mi();
        Po(this.controlPoints, e2, t4);
        const s3 = ao(this.controlPoints, 1, e2), n5 = ao(this.controlPoints, 2, e2);
        return 2 * (t4.sub(this.point).dotProduct(n5) + s3.dotProduct(s3));
      }
      case 2: {
        const t4 = new mi();
        Po(this.controlPoints, e2, t4);
        const s3 = ao(this.controlPoints, 1, e2), n5 = ao(this.controlPoints, 2, e2), i2 = ao(this.controlPoints, 3, e2);
        return 2 * (t4.sub(this.point).dotProduct(i2) + 3 * s3.dotProduct(n5));
      }
      case 3: {
        const t4 = ao(this.controlPoints, 1, e2), s3 = ao(this.controlPoints, 2, e2), n5 = ao(this.controlPoints, 3, e2);
        return 2 * (4 * t4.dotProduct(n5) + 3 * s3.sqrLength());
      }
      case 4: {
        const t4 = ao(this.controlPoints, 2, e2), s3 = ao(this.controlPoints, 3, e2);
        return 2 * (10 * t4.dotProduct(s3));
      }
      case 5: {
        const t4 = ao(this.controlPoints, 3, e2);
        return 2 * (10 * t4.dotProduct(t4));
      }
      default:
        return 0;
    }
  }
  getError(t3) {
    return 0;
  }
  isInterestingInterval(t3, e2) {
    if (t3 >= 0 && e2 <= 1) {
      const s3 = Ot(mi, 4);
      fo(this.controlPoints, t3, e2, s3);
      const n5 = new pe();
      if (n5.setFromPoints(s3, 4), Math.sqrt(n5.sqrMinDistance(this.point)) > this.maxDistance) return false;
    }
    return true;
  }
};
function Lo(t3, e2, s3, i2, r, o, a2) {
  D(x2.unit().contains(s3) && o > 0, "getClosestCoordinate"), (r < 0 || Number.isNaN(r)) && (r = Number.MAX_VALUE);
  const h2 = [], u = new mi();
  Po(t3, s3.vmin, u);
  let m3 = mi.distance(u, e2);
  if (m3 <= r && h2.push(new mi(s3.vmin, m3)), s3.vmin !== s3.vmax && (Po(t3, s3.vmax, u), m3 = mi.distance(u, e2), m3 <= r && h2.push(new mi(s3.vmax, m3))), s3.width() > 0) {
    const n5 = Yt(18, Number.NaN), i3 = tn(new Vo(t3, e2, r), s3, 18, n5);
    for (let s4 = 0; s4 < i3; s4++) Po(t3, n5[s4], u), m3 = mi.distance(u, e2), m3 > r || h2.push(new mi(n5[s4], m3));
  }
  if (i2) {
    n(s3.equals(x2.unit()));
    {
      Po(t3, -1, u, true);
      const s4 = new mi();
      Po(t3, 0, s4);
      const n5 = new pm({ start: u, end: s4 }), i3 = n5.getClosestCoordinate(e2, true);
      i3 < 1 && (u.assign(n5.getCoord2D(i3)), m3 = mi.distance(u, e2), m3 <= r && h2.push(new mi(i3 - 1, m3)));
    }
    {
      Po(t3, 2, u, true);
      const n5 = new mi();
      Po(t3, s3.vmax, n5);
      const i3 = new pm({ start: n5, end: u }), o2 = i3.getClosestCoordinate(e2, true);
      o2 > 0 && (u.assign(i3.getCoord2D(o2)), m3 = mi.distance(u, e2), m3 <= r && h2.push(new mi(1 + o2, m3)));
    }
  }
  if (!h2.length) return 0;
  h2.sort((t4, e3) => t4.compare(e3));
  let l2 = 0;
  const c = h2[0].x;
  if (a2[l2++] = c, l2 < o) {
    const e3 = Rt2(t3, 4, false).total(), s4 = h2[0].y;
    for (let t4 = 1, n5 = h2.length; t4 < n5; t4++) if (h2[t4].y > s4 + e3) {
      h2.length = t4;
      break;
    }
    h2.sort((t4, e4) => Ct(t4.x, e4.x)), l2 = 0, a2[l2++] = h2[0].x;
    for (let t4 = 1, n5 = h2.length; t4 < n5; t4++) h2[t4].x !== a2[l2 - 1] && l2 < o && (a2[l2++] = h2[t4].x);
  }
  return l2;
}
function Ro(t3, e2, s3, n5, i2, r, o) {
  const a2 = Ot(mi, 4);
  return t3.queryControlPoints(a2), Lo(a2, e2, s3, n5, i2, r, o);
}
function zo(t3) {
  return t3.getStartXY().norm(1) + t3.getEndXY().norm(1) + t3.m_cp[0].norm(1) + t3.m_cp[1].norm(1);
}
function Bo(t3) {
  return t3[0].norm(1) + t3[1].norm(1) + t3[2].norm(1) + t3[3].norm(1);
}
function ko(t3, e2, s3) {
  if (n(s3 >= 2), 2 === s3) {
    const n5 = new mi();
    Y(e2[0], e2[s3 - 1], 1 / 3, n5);
    const i3 = new mi();
    return Y(e2[0], e2[s3 - 1], 2 / 3, i3), void t3.construct(e2[0], n5, i3, e2[s3 - 1]);
  }
  const i2 = e2[0], r = e2[s3 - 1], o = [0, 0], a2 = Ro(t3, i2, x2.unit(), false, Number.NaN, 2, o), h2 = [0, 0], u = Ro(t3, r, x2.unit(), false, Number.NaN, 2, h2), m3 = [];
  for (let n5 = 0; n5 < a2; n5++) for (let a3 = 0; a3 < u; a3++) {
    const u2 = o[n5], l3 = h2[a3], c2 = u2 > l3, g3 = (n6, o2) => {
      const a4 = Yt(s3 - 2, Number.NaN), h3 = () => {
        let t4 = 0;
        for (let n7 = 1, i3 = s3 - 1; n7 < i3; n7++) {
          t4 += mi.distance(e2[n7 - 1], e2[n7]);
          const s4 = t4;
          a4[n7 - 1] = s4;
        }
        t4 += mi.distance(e2[s3 - 2], e2[s3 - 1]), c2 && a4.reverse();
        for (let e3 = 1, n7 = s3 - 1; e3 < n7; e3++) a4[e3 - 1] /= t4, c2 && (a4[e3 - 1] = 1 - a4[e3 - 1]);
      };
      let m4 = false, g4 = false;
      {
        const e3 = new fm();
        c2 ? (t3.queryCut(l3, u2, e3, true), n6.assign(e3.get().getControlPoint2()), o2.assign(e3.get().getControlPoint1())) : (t3.queryCut(u2, l3, e3, true), n6.assign(e3.get().getControlPoint1()), o2.assign(e3.get().getControlPoint2())), i2.equals(n6) && (m4 = true), r.equals(o2) && (g4 = true);
      }
      h3();
      let d4 = Number.MAX_VALUE;
      const _2 = n6.clone(), p4 = o2.clone();
      for (let t4 = 0; t4 < 5; t4++) {
        d4 = sa(true, false, i2, _2, p4, r, m4, g4, a4, s3 - 2, e2, s3);
      }
      for (let t4 = 0; t4 < 30; t4++) {
        const t5 = _2.clone();
        p4.clone();
        const n7 = sa(true, true, i2, _2, p4, r, m4, g4, a4, s3 - 2, e2, s3);
        if (d4 <= n7 && t5.equals(_2) && t5.equals(p4)) break;
        d4 = n7;
      }
      h3();
      let f3 = false, P5 = Number.MAX_VALUE;
      const y2 = n6.clone(), x4 = o2.clone();
      for (let t4 = 0; t4 < 30; t4++) {
        const t5 = y2.clone();
        x4.clone();
        const n7 = sa(f3, true, i2, y2, x4, r, m4, g4, a4, s3 - 2, e2, s3);
        if (P5 <= n7 && t5.equals(y2) && t5.equals(x4)) break;
        f3 = true, P5 = n7;
      }
      return P5 < d4 ? (n6.assign(y2), o2.assign(x4)) : (n6.assign(_2), o2.assign(p4), P5 = d4), P5;
    }, d3 = new mi(), _ = new mi(), p3 = [g3(d3, _), mi.distance(i2, d3) + mi.distance(d3, _) + mi.distance(_, r), d3.x, d3.y, _.x, _.y];
    m3.splice(m3.length, 0, ...p3);
  }
  let l2 = m3[0], c = m3[1], g2 = 0;
  for (let n5 = 6; n5 < m3.length; n5 += 6) m3[n5] < l2 && (l2 = m3[n5], c = m3[n5 + 1], g2 = n5);
  let d2 = g2;
  for (let n5 = 0; n5 < m3.length; n5 += 6) n5 !== g2 && m3[n5 + 1] < c && Math.abs(l2 - m3[n5]) < 10 * l2 && (c = m3[n5 + 1], d2 = n5);
  t3.construct(i2, new mi(m3[d2 + 2], m3[d2 + 3]), new mi(m3[d2 + 4], m3[d2 + 5]), r);
}
function Go(t3, e2, s3 = false) {
  const n5 = Ot(mi, 4);
  t3.queryControlPoints(n5);
  const i2 = Ot(Ee, 4);
  let r, o, a2;
  Zr(n5, i2, true);
  const h2 = i2[3].x.isZero(), u = i2[3].y.isZero();
  if (h2 || u) if (h2 && !u) {
    if (i2[2].x.isZero()) return 0;
    r = i2[1].x.div(i2[2].x).negate(), o = i2[2].y.div(i2[3].y), a2 = i2[1].y.div(i2[3].y);
  } else {
    if (h2 || !u) return 0;
    if (i2[2].y.isZero()) return 0;
    r = i2[1].y.div(i2[2].y).negate(), o = i2[2].x.div(i2[3].x), a2 = i2[1].x.div(i2[3].x);
  }
  else {
    i2[2].x.divThis(i2[3].x), i2[1].x.divThis(i2[3].x), i2[2].y.divThis(i2[3].y), i2[1].y.divThis(i2[3].y);
    const t4 = i2[2].x.sub(i2[2].y);
    if (t4.isZero()) return 0;
    r = i2[1].x.sub(i2[1].y).div(t4).negate(), o = i2[2].x.clone(), a2 = i2[1].x.clone();
  }
  if (!s3 && r.abs().value() > 2) return 0;
  const m3 = [0, 0], l2 = t3.getStartXY().equals(t3.getEndXY()), c = sn(1, -r.toDouble(), r.add(o).mul(r).add(a2).toDouble(), x2.unit(), l2, m3);
  if (0 === c) return 0;
  if (m3[0] >= 0 && m3[0] <= 1) {
    const t4 = r.toDouble() - m3[0];
    if (s3 || t4 >= 0 && t4 <= 1) return e2[0] = m3[0], e2[1] = t4, e2[0] > e2[1] && (e2[1] = Pt(e2[0], e2[0] = e2[1])), 2;
  }
  if (2 === c && m3[1] >= 0 && m3[1] <= 1) {
    const t4 = r.toDouble() - m3[1];
    if (s3 || t4 >= 0 && t4 <= 1) return e2[0] = m3[1], e2[1] = t4, e2[0] > e2[1] && (e2[1] = Pt(e2[0], e2[0] = e2[1])), 2;
  }
  return 0;
}
function Wo(t3, e2, s3) {
  const n5 = t3[1].mulE(e2[2]).subThisE(t3[2].mulE(e2[1])), i2 = t3[1].mulE(e2[3]).subThisE(t3[3].mulE(e2[1])).mulThis(3), r = t3[2].mulE(e2[3]).subThisE(t3[3].mulE(e2[2])).mulThis(3), o = Ot(p2, 2);
  let a2 = gn(r, i2, n5, new x2(0, 1), false, o);
  a2 < 0 && (a2 = 0);
  let h2 = 0;
  for (let u = 0; u < a2; u++) Vs(o[u].value(), 0, 1) || (s3[h2].setE(o[u]), h2++);
  return h2;
}
function jo(t3, e2) {
  e2[0].set(0);
  let s3 = 1;
  const i2 = Ot(p2, 4);
  Wr(t3, i2, true);
  const r = Ot(p2, 4);
  jr(t3, r, true);
  {
    const t4 = i2[3].mul(3), n5 = i2[2].mul(2), r2 = i2[1].clone(), o = Ot(p2, 2);
    let a2 = gn(t4, n5, r2, new x2(0, 1), false, o);
    a2 < 0 && (a2 = 0);
    for (let i3 = 0; i3 < a2; i3++) Vs(o[i3].value(), 0, 1) || (e2[s3] = o[i3], s3++);
  }
  {
    const t4 = r[3].mul(3), n5 = r[2].mul(2), i3 = r[1].clone(), o = Ot(p2, 2);
    let a2 = gn(t4, n5, i3, new x2(0, 1), false, o);
    a2 < 0 && (a2 = 0);
    for (let r2 = 0; r2 < a2; r2++) Vs(o[r2].value(), 0, 1) || (e2[s3] = o[r2], s3++);
  }
  if (s3 += Wo(i2, r, e2.slice(s3)), e2[s3].set(1), s3++, s3 > 2) {
    Zt(e2, 0, s3, (t4, e3) => {
      const s4 = t4.value(), n6 = e3.value();
      return s4 < n6 ? -1 : s4 > n6 ? 1 : 0;
    });
    let n5 = 0;
    const i3 = e2[0].clone();
    let r2 = 0;
    const o = Bo(t3) * Qs(), a2 = new mi();
    _o(t3, e2[0].value(), a2);
    for (let h2 = 1; h2 < s3; h2++) {
      const s4 = new mi();
      if (_o(t3, e2[h2].value(), s4), e2[h2].eq(i3) || s4.isEqualPoint2D(a2, o)) {
        if (0 !== n5) {
          if (0 === e2[h2].eps()) i3.setE(e2[h2]), r2 = 0;
          else if (0 !== r2) {
            const t4 = H(1 / e2[h2].eps()), s5 = 1 / r2, n6 = t4 + s5;
            i3.set((e2[h2].value() * t4 + i3.value() * s5) / n6), r2 = 1 / n6, i3.setError(Math.sqrt(r2));
          }
          e2[n5].setE(i3), _o(t3, i3.value(), a2);
        }
      } else n5++, e2[n5].setE(e2[h2]), i3.setE(e2[h2]), _o(t3, i3.value(), a2), r2 = H(e2[h2].eps());
    }
    n5++, s3 = n5;
  }
  return 1 === s3 && (s3 = 2, e2[1].set(1)), n(0 === e2[0].value()), n(1 === e2[s3 - 1].value()), s3;
}
function Zo(t3, e2, s3, n5, i2) {
  const r = Ot(p2, 4), o = Ot(p2, 3), a2 = new x2(0, 1);
  let h2 = 0;
  if (e2) {
    if (jr(t3, r, false), h2 = dn(r[3], r[2], r[1], r[0].sub(s3), a2, false, o), n5) for (let u = 0; u < h2; u++) {
      const e3 = new mi();
      Po(t3, o[u].value(), e3), n5[u] = e3.x;
    }
  } else if (Wr(t3, r, false), h2 = dn(r[3], r[2], r[1], r[0].sub(s3), a2, false, o), n5) for (let u = 0; u < h2; u++) {
    const e3 = new mi();
    Po(t3, o[u].value(), e3), n5[u] = e3.y;
  }
  if (i2) for (let u = 0; u < h2; u++) i2[u] = o[u].value();
  else n5 && Zt(n5, 0, h2, Ct);
  return h2;
}
function Ho(t3, e2, s3, n5) {
  const i2 = Uo(t3, e2, s3, n5.getEnvelope2D());
  if (i2.isEmpty()) return new x2(i2);
  const r = Ot(mi, s3);
  for (let a2 = 0; a2 < s3; ++a2) n5.xyRot(t3[a2], r[a2]);
  const o = Uo(r, e2, s3, n5.getRotatedEnvelope2D());
  return i2.intersect(new x2(o)), new x2(i2);
}
function Uo(t3, e2, s3, n5) {
  const i2 = Ot(mi, s3);
  for (let a2 = 0; a2 < s3; ++a2) i2[a2] = new mi(a2 / (s3 - 1), 0);
  const r = (t4, e3, s4, n6) => {
    const i3 = 0.1, r2 = new p2(e3.x).subE(new p2(t4.x)).divE(new p2(e3.y).subE(new p2(t4.y))).mulE(new p2(s4).subE(new p2(t4.y))).addE(new p2(t4.x));
    if (r2.eps() > i3) {
      const n7 = (e3.x - t4.x) / (e3.y - t4.y) * (s4 - t4.y) + t4.x;
      r2.set(n7, Qs());
    }
    if (r2.lt(new p2(0)) || r2.gt(new p2(1))) return false;
    let o2 = r2.value() - r2.eps();
    o2 = Us(o2, 0, 1);
    let a2 = r2.value() + r2.eps();
    return a2 = Us(a2, 0, 1), n6.mergeCoordinate(o2), n6.mergeCoordinate(a2), true;
  }, o = [];
  {
    const e3 = (t4, e4) => {
      o.length = s3;
      const n6 = xr(i2, s3, o, true), a3 = new x2();
      a3.setEmpty();
      const h3 = (s4) => s4.y < t4 ? -1 : s4.y > e4 ? 1 : 0;
      let u = i2[o[0]], m3 = h3(u);
      0 === m3 && a3.mergeCoordinate(u.x);
      for (let s4 = 1; s4 <= n6; ++s4) {
        const l2 = i2[o[s4 % n6]], c = h3(l2);
        0 === c && a3.mergeCoordinate(l2.x);
        let g2 = 0;
        c !== m3 && (g2 = c * m3 === 0 ? 1 === c || 1 === m3 ? 2 : 1 : 3, 1 & g2 && r(u, l2, t4, a3), 2 & g2 && r(u, l2, e4, a3)), u = l2, m3 = c;
      }
      return a3;
    };
    for (let n6 = 0; n6 < s3; ++n6) i2[n6].y = t3[n6].x;
    const a2 = e3(n5.xmin, n5.xmax);
    if (a2.isEmpty()) return new x2(a2);
    for (let n6 = 0; n6 < s3; ++n6) i2[n6].y = t3[n6].y;
    const h2 = e3(n5.ymin, n5.ymax);
    return a2.intersect(new x2(h2)), new x2(a2);
  }
}
function Oo(t3, e2, s3) {
  s3.setEmpty(), s3.merge(Ho(t3, null, 4, e2));
}
function Qo(t3, e2, s3) {
  s3.length = 0;
  {
    const e3 = new p2();
    io(t3, e3);
    const n6 = new ve();
    if (vo(t3, e3, n6), n6.isZero()) return e3.isZero() || e3.eq(new p2(1)) ? 0 : (s3.push(e3.value()), 1);
  }
  const n5 = Ot(p2, 4);
  kr(t3, n5, true);
  const i2 = Ot(p2, 4);
  Gr(t3, i2, true);
  const r = Ot(p2, 6), o = n5[3].negate().mulE(i2[1]).addE(n5[2].mulE(i2[2]).mul(2)).addE(n5[1].mulE(i2[3])), a2 = n5[3].negate().mulE(i2[1]).subE(n5[2].mulE(i2[2]).mul(2)).addE(n5[1].mulE(i2[3])), h2 = n5[2].mulE(n5[2]).subE(i2[2].mulE(i2[2]));
  r[0] = i2[1].mulE(i2[1]).mulE(o).addE(n5[1].mulE(n5[1]).mulE(a2)).addE(n5[1].mulE(i2[1]).mulE(h2).mul(2)).mul(6), r[1] = n5[2].mulE(i2[1]).subE(n5[1].mulE(i2[2])).mulE(n5[2].mulE(n5[2]).addE(n5[1].mulE(n5[3]).mul(2)).addE(i2[2].mulE(i2[2])).addE(i2[1].mulE(i2[3]).mul(2))).mul(24);
  const u = n5[1].mulE(i2[2]).mulE(i2[2]).mulE(i2[3]), m3 = n5[2].mulE(n5[2]).mulE(n5[3]).mulE(i2[1]).subE(u).mul(156), l2 = n5[3].mulE(i2[1]).subE(n5[1].mulE(i2[3])), c = n5[3].mulE(i2[1]).subE(n5[1].mulE(i2[3])), g2 = n5[1].mulE(n5[3]).mulE(c).addE(i2[1].mulE(i2[3]).mulE(l2)).mul(72), d2 = i2[1].mulE(i2[3]).subE(n5[1].mulE(n5[3])), _ = n5[2].mulE(i2[2]).mulE(d2).mul(120), p3 = n5[1].mulE(n5[2]).mulE(n5[2]).mulE(i2[3]), f3 = n5[3].mulE(i2[1]).mulE(i2[2]).mulE(i2[2]).subE(p3).mul(36);
  r[2] = m3.addE(g2).addE(_).addE(f3);
  const P5 = n5[2].mulE(n5[3]).mulE(n5[3]).mulE(i2[1]).subE(n5[1].mulE(i2[2]).mulE(i2[3]).mulE(i2[3])).mul(360), y2 = n5[2].mulE(i2[2]).mulE(n5[2].mulE(n5[3]).subE(i2[2].mulE(i2[3]))).addE(n5[3].mulE(i2[2]).mulE(i2[2]).mulE(i2[2])).subE(n5[2].mulE(n5[2]).mulE(n5[2]).mulE(i2[3])).mul(24), x4 = n5[2].mulE(i2[1]).mulE(i2[3]).mulE(i2[3]).subE(n5[1].mulE(n5[3]).mulE(n5[3]).mulE(i2[2])).mul(72), C3 = n5[3].mulE(i2[3]).mulE(i2[1].mulE(i2[2]).subE(n5[1].mulE(n5[2]))).mul(288);
  r[3] = P5.addE(y2).addE(x4).addE(C3), r[4] = i2[3].mulE(i2[3]).addE(n5[3].mulE(n5[3])).mulE(n5[3].mulE(i2[1]).subE(n5[1].mulE(i2[3]))).mul(270).addE(n5[3].mulE(i2[2]).subE(n5[2].mulE(i2[3]))).mulE(n5[2].mulE(n5[3]).addE(i2[2].mulE(i2[3]))).mul(180), r[5] = n5[3].mulE(i2[2]).subE(n5[2].mulE(i2[3])).mulE(n5[3].mulE(n5[3]).addE(i2[3].mulE(i2[3]))).mul(216);
  const v3 = Ot(p2, 5), b2 = _n(r, 5, new x2(0, 1), false, v3, 5);
  if (b2 > 0) {
    let n6 = Math.abs(t3.getCurvature(0)), i3 = 0;
    const r2 = Math.abs(t3.getCurvature(1));
    (r2 > n6 || !Number.isFinite(r2)) && (i3 = 1);
    for (let e3 = 0; e3 < b2; e3++) {
      const s4 = Math.abs(t3.getCurvature(v3[e3].value()));
      t3.getCoord2D(v3[e3].value()), (s4 > n6 || !Number.isFinite(s4)) && (n6 = s4, i3 = v3[e3].value());
    }
    if ((!Number.isFinite(n6) || 1 / n6 < e2) && !Vs(i3, 0, 1)) {
      const e3 = t3.getCoord2D(i3);
      if (!e3.equals(t3.getStartXY()) && !e3.equals(t3.getEndXY())) return s3.push(i3), 1;
    }
  }
  if (!t3.isClosed()) {
    const e3 = [0, 0], n6 = Go(t3, e3, false);
    for (let t4 = 0; t4 < n6; t4++) e3[t4] > 0 && e3[t4] < 1 && s3.push(e3[t4]);
    return s3.length;
  }
  return 0;
}
var Ko = class {
  constructor(t3, e2) {
    this.b = t3, this.len = e2;
  }
  getMaxDerivative() {
    return 1;
  }
  getValue(t3, e2) {
    return 0 === t3 ? this.len - Hr(this.b, e2, false) : 0;
  }
  getError(t3) {
    return 0;
  }
};
function Jo(t3, e2, s3, i2, r, o, a2) {
  for (; ; ) {
    const h2 = mi.distance(e2[0], e2[3]), u = mi.distance(e2[0], e2[1]) + mi.distance(e2[1], e2[2]) + mi.distance(e2[2], e2[3]);
    if (u - h2 <= i2 + s3 * u) return t3 + Q(h2, u, 0.5);
    const m3 = (t4) => ao(e2, 1, t4).length();
    {
      n(a2 < 12);
      let h3 = m3(0), l3 = m3(1);
      r[0] += 2, h3 > l3 && (l3 = Pt(h3, h3 = l3), e2[3] = Pt(e2[0], e2[0] = e2[3]), e2[2] = Pt(e2[1], e2[1] = e2[2]));
      let c2 = h3 / (h3 + l3), g3 = 1, d3 = u;
      for (; c2 < 1 / 32 && d3 >= 32 * (i2 + s3 * d3); ) {
        g3 /= 4;
        const t4 = m3(g3);
        r[0]++, c2 = h3 / (t4 + h3);
        const s4 = new mi();
        if (Po(e2, 0.5 * g3, s4), d3 = mi.distance(s4, e2[0]), d3 <= i2) {
          const t5 = new mi();
          Po(e2, g3, t5), d3 += mi.distance(t5, s4);
        }
      }
      if (1 !== g3) {
        const n5 = Ot(mi, 4);
        po(e2, g3, e2, n5), t3 = Jo(t3, n5, s3, i2, r, 0, a2 + 1), o++, a2++;
        continue;
      }
    }
    const l2 = 8;
    r[0] += l2;
    const c = hr(l2, m3, 0, 1), g2 = 16;
    r[0] += g2;
    const d2 = hr(g2, m3, 0, 1);
    let _ = Math.abs(c - d2) > i2 + s3 * u;
    if (!_) return t3 + d2;
    if (o < 3) {
      const n5 = Ot(mi, 4);
      po(e2, 0.5, e2, n5), t3 = Jo(t3, n5, s3, i2, r, o + 1, a2 + 1), o++, a2++;
      continue;
    }
    const p3 = 32;
    r[0] += p3;
    const f3 = hr(p3, m3, 0, 1);
    if (_ = Math.abs(d2 - f3) > i2 + s3 * u, !_) return t3 + f3;
    const P5 = 64;
    r[0] += P5;
    const y2 = hr(P5, m3, 0, 1);
    if (_ = Math.abs(f3 - y2) > i2 + s3 * u, !_) return t3 + y2;
    const x4 = 128;
    r[0] += x4;
    const C3 = hr(x4, m3, 0, 1);
    return _ = Math.abs(y2 - C3) > i2 + s3 * u, t3 + C3;
  }
}
function $o(t3, e2, s3, n5, i2) {
  if (s3 === e2) return 0;
  const r = Ot(mi, 4);
  t3.queryControlPoints(r);
  const o = Ot(mi, 4);
  fo(r, e2, s3, o);
  return Jo(0, o, n5, i2, [0], 0, 0);
}
function ta(t3, e2, s3, n5, i2) {
  let r = true;
  const o = Kn(5, e2, s3, n5, i2, (e3) => {
    const s4 = uo(t3, 1, e3);
    return (r ? t3.getCoordX(e3) - t3.getStartX() : t3.getCoordY(e3) - t3.getStartY()) * s4.length();
  });
  r = false;
  const a2 = Kn(5, e2, s3, n5, i2, (e3) => {
    const s4 = uo(t3, 1, e3);
    return (r ? t3.getCoordX(e3) - t3.getStartX() : t3.getCoordY(e3) - t3.getStartY()) * s4.length();
  });
  return new mi(o, a2);
}
function ea(t3, e2, s3, n5, i2, r, o, a2, h2) {
  const u = Ot(mi, 4);
  t3.queryControlPoints(u);
  const m3 = Ot(mi, 4);
  if (e2.queryControlPoints(m3), u[0].equals(m3[0])) {
    if (u[1].equals(m3[1]) && u[2].equals(m3[2]) && u[3].equals(m3[3])) return s3 && (s3.length = 0, s3.push(u[0]), s3.push(u[3])), n5 && (n5.length = 0, n5.push(0), n5.push(1)), i2 && (i2.length = 0, i2.push(0), i2.push(1)), true;
    if (!u[0].equals(m3[3])) return false;
  }
  return !!(u[0].equals(m3[3]) && u[1].equals(m3[2]) && u[2].equals(m3[1]) && u[3].equals(m3[0])) && (n5 && (n5.length = 0, n5.push(0), n5.push(1), h2 && (n5[1] = Pt(n5[0], n5[0] = n5[1]))), i2 && (i2.length = 0, i2.push(1), i2.push(0), h2 && (i2[1] = Pt(i2[0], i2[0] = i2[1]))), s3 && (s3.length = 0, s3.push(u[0]), s3.push(u[3]), h2 && (s3[1] = Pt(s3[0], s3[0] = s3[1]))), true);
}
function sa(t3, e2, s3, i2, r, o, a2, h2, u, m3, l2, c) {
  n(m3 + 2 === c);
  let g2 = 0, d2 = 0, _ = 0, p3 = 0, f3 = 0, P5 = 0, y2 = 0;
  const x4 = (t4, e3) => {
    const n5 = 1 - e3, a3 = s3.mul($(n5)), h3 = i2.mul(3 * e3 * n5 * n5), u2 = r.mul(3 * e3 * e3 * n5), m4 = o.mul($(e3));
    return a3.add(h3).add(u2).add(m4).sub(l2[t4]).sqrLength();
  };
  for (let n5 = 1, v3 = c - 1; n5 < v3; n5++) {
    let e3 = u[n5 - 1];
    if (t3) {
      n5 > 2 ? (e3 = Us(2 * u[n5 - 2] - u[n5 - 3], 0, 1), u[n5 - 1] = e3) : 2 === n5 && (e3 = Us(2 * u[n5 - 2], 0, 1), u[n5 - 1] = e3);
      const t4 = (t5, e4, n6) => {
        let a4 = -1;
        for (let h4 = 0; !(Math.abs(e4 - a4) < 1e-12) && 10 !== h4; h4++) {
          const h5 = e4 * e4, u2 = 1 - e4, m5 = u2 * u2, c3 = m5 * u2, g3 = s3.x - 2 * i2.x + r.x, d3 = s3.x - 3 * i2.x + 3 * r.x - o.x, _2 = s3.y - 2 * i2.y + r.y, p4 = s3.y - 3 * i2.y + 3 * r.y - o.y, f4 = s3.x - i2.x - 2 * g3 * e4 + d3 * h5, P6 = -l2[t5].x + s3.x * c3 + e4 * (3 * i2.x * m5 + e4 * (3 * r.x * u2 + o.x * e4)), y3 = s3.y - i2.y - 2 * _2 * e4 + p4 * h5, x5 = -l2[t5].y + s3.y * c3 + e4 * (3 * i2.y * m5 + e4 * (3 * r.y * u2 + o.y * e4)), C5 = -6 * (f4 * P6 + y3 * x5), v5 = 6 * (3 * H(f4) - (-2 * g3 + 2 * d3 * e4) * P6) + 6 * (3 * H(y3) - (-2 * _2 + 2 * p4 * e4) * x5);
          if (a4 = e4, 0 === v5) break;
          e4 = Us(e4 - C5 / v5, n6, 1);
        }
        return a4;
      };
      {
        const e4 = x4(n5, u[n5 - 1]);
        let s4 = t4(n5, u[n5 - 1], 0), i3 = x4(n5, s4);
        if (1.01 * e4 < i3) {
          const e5 = n5 > 1 ? u[n5 - 2] : 0, r2 = t4(n5, 0.3 * (u[n5 - 1] - e5) + e5, 0), o2 = x4(n5, r2);
          o2 < i3 && (i3 = o2, s4 = r2);
        }
        e4 > i3 && (u[n5 - 1] = s4);
      }
    }
    const a3 = u[n5 - 1], h3 = a3 * a3, m4 = h3 * a3, c2 = 1 - a3, C4 = c2 * c2, v4 = C4 * c2;
    g2 += 3 * h3 * C4 * C4, d2 += 3 * m4 * v4, _ += 3 * h3 * h3 * C4;
    const b2 = -(v4 * s3.x + m4 * o.x - l2[n5].x);
    p3 += b2 * a3 * C4, f3 += b2 * h3 * c2;
    const E2 = -(v4 * s3.y + m4 * o.y - l2[n5].y);
    P5 += E2 * a3 * C4, y2 += E2 * h3 * c2;
  }
  if (e2) {
    const t4 = g2 * _ - d2 * d2;
    Math.abs(t4) >= 1e-12 * (Math.abs(g2 * _) + Math.abs(d2 * d2)) + 1e-10 ? (a2 || (i2.x = (p3 * _ - f3 * d2) / t4, i2.y = (P5 * _ - y2 * d2) / t4), h2 || (r.x = (g2 * f3 - d2 * p3) / t4, r.y = (g2 * y2 - d2 * P5) / t4)) : (Y(s3, o, 0.3, i2), Y(s3, o, 0.6, r));
  }
  let C3 = 0;
  for (let n5 = 1, v3 = c - 1; n5 < v3; n5++) C3 += x4(n5, u[n5 - 1]);
  return C3;
}
var na = z3;
var ia = class _ia extends gs {
  constructor(t3) {
    t3 && t3.cp ? (super({ start: t3.cp[0], end: t3.cp[3], vd: t3.vd }), this.m_cp = Ot(mi, 2), this.m_cp[0].assign(t3.cp[1]), this.m_cp[1].assign(t3.cp[2])) : void 0 === t3 || jt(t3, "vd") ? (super({ vd: t3?.vd, XStart: 0, YStart: 0, XEnd: 0, YEnd: 0 }), this.m_cp = Ot(mi, 2), this.m_cp[0].setCoords(0, 0), this.m_cp[1].setCoords(0, 0)) : t3.from ? (super({ start: t3.from, end: t3.to, vd: t3.vd }), this.m_cp = Ot(mi, 2), this.m_cp[0].assign(t3.cp1), this.m_cp[1].assign(t3.cp2)) : (super({ XStart: 0, YStart: 0, XEnd: 0, YEnd: 0, vd: t3.vd }), b("unrecognized constructor params"), this.m_cp = Ot(mi, 2), this.m_cp[0].setCoords(0, 0), this.m_cp[1].setCoords(0, 0)), this.m_cachedValues = 0;
  }
  getBoundary() {
    return Js2(this);
  }
  construct(t3, e2, s3, n5) {
    this.m_XStart = t3.x, this.m_YStart = t3.y, this.m_XEnd = n5.x, this.m_YEnd = n5.y, this.m_cp[0].assign(e2), this.m_cp[1].assign(s3), this.afterCompletedModification();
  }
  constructPoints(t3) {
    this.m_XStart = t3[0].x, this.m_YStart = t3[0].y, this.m_XEnd = t3[3].x, this.m_YEnd = t3[3].y, this.m_cp[0].assign(t3[1]), this.m_cp[1].assign(t3[2]), this.afterCompletedModification();
  }
  constructFromQuadratic(t3) {
    const e2 = Ot(mi, 4);
    Ji(t3, e2), this.constructPoints(e2);
  }
  constructFromQuadraticSegment(t3) {
    this.dropAllAttributes(), this.assignVertexDescription(t3.getDescription()), this.m_XStart = t3.getStartX(), this.m_YStart = t3.getStartY(), this.m_XEnd = t3.getEndX(), this.m_YEnd = t3.getEndY(), L2(2, t3.getStartXY(), t3.getControlPoint1(), 2 / 3, this.m_cp[0]), L2(2, t3.getControlPoint1(), t3.getEndXY(), 1 / 3, this.m_cp[1]), this.afterCompletedModification(), Ze(this, t3);
  }
  getGeometryType() {
    return a.enumBezier;
  }
  queryEnvelope(t3) {
    if (2 !== t3.m_EnvelopeType) return void n(0);
    if (t3.setCoords(this.getStartXY()), t3.mergeNe(this.getEndXY()), t3.contains(this.m_cp[0]) && t3.contains(this.m_cp[1])) return;
    const e2 = Kr(this);
    if (null !== e2) {
      const s4 = new mi();
      for (const n5 of e2.specialPoints) this.queryCoord2D(n5, s4), t3.mergeNe(s4);
      return;
    }
    const s3 = Ot(p2, 8), i2 = Ot(mi, 4);
    this.queryControlPoints(i2);
    const r = jo(i2, s3), o = new mi();
    for (let n5 = 1; n5 < r - 1; n5++) this.queryCoord2D(s3[n5].value(), o), t3.mergeNe(o);
  }
  applyTransformation(t3) {
    if (1 === t3.m_TransformationType) {
      const e2 = Ot(mi, 4);
      return this.queryControlPoints(e2), t3.transformPoints2D(e2, 4, e2), this.setStartXY(e2[0]), this.m_cp[0].assign(e2[1]), this.m_cp[1].assign(e2[2]), this.setEndXY(e2[3]), void $r(this);
    }
    n(0);
  }
  createInstance() {
    return new _ia({ vd: this.m_description });
  }
  calculateLength2D() {
    return Hr(this, 1, false);
  }
  calculateLowerLength2D() {
    return mi.distance(this.getStartXY(), this.getEndXY());
  }
  calculateUpperLength2D() {
    return mi.distance(this.getStartXY(), this.m_cp[0]) + mi.distance(this.m_cp[0], this.m_cp[1]) + mi.distance(this.getEndXY(), this.m_cp[1]);
  }
  queryCoord2D(t3, e2) {
    return this.queryCoord2DExtends(t3, e2, true);
  }
  queryCoord2DMP(t3, e2) {
    n(0);
  }
  queryCoord2DExtends(t3, e2, s3) {
    const n5 = Ot(mi, 4);
    this.queryControlPoints(n5), Po(n5, t3, e2, s3);
  }
  queryCoord2DE(t3, e2) {
    xo(this, t3, e2);
  }
  getCoordX(t3) {
    if (t3 < 0 || t3 > 1) {
      const e3 = new mi();
      return this.queryCoord2DExtends(t3, e3, true), e3.x;
    }
    const e2 = Q(this.getStartX(), this.m_cp[0].x, t3), s3 = Q(this.m_cp[0].x, this.m_cp[1].x, t3), n5 = Q(this.m_cp[1].x, this.getEndX(), t3), i2 = Q(e2, s3, t3), r = Q(s3, n5, t3);
    return Q(i2, r, t3);
  }
  getCoordY(t3) {
    if (t3 < 0 || t3 > 1) {
      const e3 = new mi();
      return this.queryCoord2DExtends(t3, e3, true), e3.y;
    }
    const e2 = Q(this.getStartY(), this.m_cp[0].y, t3), s3 = Q(this.m_cp[0].y, this.m_cp[1].y, t3), n5 = Q(this.m_cp[1].y, this.getEndY(), t3), i2 = Q(e2, s3, t3), r = Q(s3, n5, t3);
    return Q(i2, r, t3);
  }
  cut(t3, e2, s3) {
    const n5 = new fm();
    return this.queryCut(t3, e2, n5, s3), n5.releaseSegment();
  }
  queryCut(t3, e2, s3, n5) {
    const i2 = s3.createCubicBezier();
    if (this.cutBezierIgnoreAttributes(t3, e2, i2), n5) return;
    i2.assignVertexDescription(this.m_description);
    const r = this.m_description.getAttributeCount();
    if (r > 1) {
      for (let e3 = 1; e3 < r; e3++) {
        const s4 = this.m_description.getSemantics(e3), n6 = na.getComponentCount(s4);
        for (let e4 = 0; e4 < n6; e4++) {
          const n7 = this.getAttributeAsDbl(t3, s4, e4);
          i2.setStartAttribute(s4, e4, n7);
        }
      }
      for (let t4 = 1; t4 < r; t4++) {
        const s4 = this.m_description.getSemantics(t4), n6 = na.getComponentCount(s4);
        for (let t5 = 0; t5 < n6; t5++) {
          const n7 = this.getAttributeAsDbl(e2, s4, t5);
          i2.setEndAttribute(s4, t5, n7);
        }
      }
    }
  }
  queryDerivative(t3, e2) {
    vo(this, t3, e2);
  }
  cutBezierIgnoreAttributes(e2, s3, n5) {
    (e2 < 0 || s3 > 1 || e2 > s3) && P("Cubic_bezier.cut_bezier_ignore_attributes");
    const i2 = Ot(mi, 4);
    this.queryControlPoints(i2);
    const r = Ot(mi, 4);
    fo(i2, e2, s3, r), n5.setControlPoints(r);
  }
  splitBezierIgnoreAttributes(e2, s3, n5) {
    this === s3 && this === n5 && P("Cubic_bezier.split_bezier_ignore_attributes");
    const i2 = Ot(mi, 4);
    this.queryControlPoints(i2);
    const r = Ot(mi, 4), o = Ot(mi, 4);
    po(i2, e2, r, o), s3 && s3.setControlPoints(r), n5 && n5.setControlPoints(o);
  }
  getAttributeAsDbl(t3, e2, s3) {
    if (0 === e2) return 0 === s3 ? this.getCoordX(t3) : this.getCoordY(t3);
    if (0 === t3) return this.getStartAttributeAsDbl(e2, s3);
    if (1 === t3) return this.getEndAttributeAsDbl(e2, s3);
    const n5 = this.getStartAttributeAsDbl(e2, s3), i2 = this.getEndAttributeAsDbl(e2, s3), r = this.calculateLength2D(), o = r > 0 ? this.tToLength(t3) / r : 0, a2 = na.getInterpolation(e2);
    return It(a2, n5, i2, o, na.getDefaultValue(e2));
  }
  getClosestCoordinate(t3, e2) {
    const s3 = [Number.NaN];
    return Ro(this, t3, x2.unit(), e2, -1, 1, s3), s3[0];
  }
  getClosestCoordinateOnInterval(t3, e2, s3 = -1) {
    const n5 = [Number.NaN];
    return 0 === Ro(this, t3, e2, false, s3, 1, n5) ? Number.NaN : n5[0];
  }
  getYMonotonicParts(t3, e2 = false) {
    return this.getMonotonicParts(t3, e2);
  }
  getMonotonicParts(e2, s3) {
    e2.length < 2 && P("");
    const i2 = Qr(this);
    if (2 === i2.specialPointsCount() && this.isMonotoneQuickAndDirty()) return 0;
    let r = 0;
    n(e2.length >= i2.specialPointsCount() - 1);
    for (let t3 = 1, n5 = i2.specialPointsCount(); t3 < n5; ++t3) this.queryCut(i2.specialPoints[t3 - 1], i2.specialPoints[t3], e2[r], s3), r++;
    for (let t3 = 0; t3 < r; ++t3) {
      lo(e2[t3].get());
    }
    return r;
  }
  intersectionWithAxis2D(t3, e2, s3, n5) {
    const i2 = Ot(mi, 4);
    return this.queryControlPoints(i2), Zo(i2, t3, e2, s3, n5);
  }
  intersectionOfYMonotonicWithAxisX(t3, e2) {
    if (this.m_YStart === this.m_YEnd) return t3 === this.m_YStart ? e2 : Number.NaN;
    if (t3 === this.m_YStart) return this.m_XStart;
    if (t3 === this.m_YEnd) return this.m_XEnd;
    const s3 = [0, 0], i2 = this.intersectionWithAxis2D(true, t3, s3, null);
    return n(2 !== i2), -1 === i2 ? e2 : s3[0];
  }
  isCurve() {
    return true;
  }
  isDegenerate(t3) {
    return Te(this, t3);
  }
  isDegenerate3D(t3, e2) {
    return n(0), false;
  }
  queryLooseEnvelope(t3) {
    if (2 === t3.m_EnvelopeType) return t3.setCoords({ pt: this.getStartXY() }), t3.mergeNe(this.m_cp[0]), t3.mergeNe(this.m_cp[1]), void t3.mergeNe(this.getEndXY());
    n(0);
  }
  clone(t3) {
    const e2 = this.createInstance();
    return this.copyTo(e2), e2;
  }
  queryInterval(t3, e2) {
    if (0 === t3) {
      const t4 = n3.constructEmpty();
      this.queryEnvelope(t4);
      const s3 = x2.constructEmpty();
      return 0 === e2 ? t4.queryIntervalX(s3) : t4.queryIntervalY(s3), s3;
    }
    return super.queryInterval(t3, e2);
  }
  queryLooseEnvelopeOnInterval(t3, e2) {
    const s3 = Ot(mi, 4);
    this.queryControlPoints(s3), fo(s3, t3.vmin, t3.vmax, s3), e2.setFromPoints(s3, 4);
  }
  changeEndPoints2D(t3, e2) {
    if (t3.isEqual(this.m_XStart, this.m_YStart) && e2.isEqual(this.m_XEnd, this.m_YEnd)) return;
    const s3 = this.m_cp[0].isEqual(this.m_XStart, this.m_YStart), n5 = this.m_cp[0].isEqual(this.m_XEnd, this.m_YEnd), i2 = this.m_cp[1].isEqual(this.m_XStart, this.m_YStart), r = this.m_cp[1].isEqual(this.m_XEnd, this.m_YEnd);
    this.setStartXY(t3), this.setEndXY(e2), s3 ? this.m_cp[0].setCoordsPoint2D(t3) : n5 && this.m_cp[0].setCoordsPoint2D(e2), r ? this.m_cp[1].setCoordsPoint2D(e2) : i2 && this.m_cp[1].setCoordsPoint2D(t3), this.normalizeAfterEndpointChange();
  }
  tToLength(t3) {
    return Hr(this, t3, true);
  }
  lengthToT(t3) {
    return Ur(this, t3);
  }
  calculateWeightedAreaCentroid2D(t3) {
    const e2 = Ot(mi, 4);
    Br(this, e2);
    const s3 = e2[3], n5 = e2[2], i2 = e2[1], r = new mi();
    r.x = (5 * s3.x * s3.x * (7 * n5.y + 16 * i2.y) + s3.x * (-35 * s3.y * n5.x + 40 * n5.x * n5.y - 80 * s3.y * i2.x + 140 * n5.x * i2.y + 112 * i2.x * i2.y) - 2 * (s3.y * (20 * n5.x * n5.x + 70 * n5.x * i2.x + 56 * i2.x * i2.x) - 7 * (4 * n5.x + 5 * i2.x) * (-n5.y * i2.x + n5.x * i2.y))) / 840, r.y = (-5 * s3.y * s3.y * (7 * n5.x + 16 * i2.x) + s3.y * (5 * s3.x * (7 * n5.y + 16 * i2.y) - 4 * (10 * n5.x * n5.y + 35 * n5.y * i2.x + 28 * i2.x * i2.y)) + 2 * (-7 * (4 * n5.y + 5 * i2.y) * (n5.y * i2.x - n5.x * i2.y) + s3.x * (20 * n5.y * n5.y + 70 * n5.y * i2.y + 56 * i2.y * i2.y))) / 840;
    const o = mo(this);
    return r.x += (e2[0].x - t3.x) * o, r.y += (e2[0].y - t3.y) * o, r;
  }
  calculateWeightedCentroid2D() {
    const t3 = new mi();
    return this.isDegenerate(0) ? (t3.setCoords(0, 0), t3) : zr(this) ? (t3.assign(this.getCoord2D(0.5).mul(this.calculateLength2D())), t3) : (t3.assign(Or(this, 1)), t3);
  }
  getControlPoint1() {
    return this.m_cp[0].clone();
  }
  setControlPoint1(t3) {
    this.m_cp[0].setCoordsPoint2D(t3), this.afterCompletedModification();
  }
  getControlPoint2() {
    return this.m_cp[1].clone();
  }
  setControlPoint2(t3) {
    this.m_cp[1].setCoordsPoint2D(t3), this.afterCompletedModification();
  }
  queryControlPoints(t3) {
    t3[0].assign(this.getStartXY()), t3[1].assign(this.m_cp[0]), t3[2].assign(this.m_cp[1]), t3[3].assign(this.getEndXY());
  }
  queryControlPointsHelper(t3) {
    return this.queryControlPoints(t3), 4;
  }
  setControlPoints(e2) {
    for (let s3 = 0; s3 < 4; s3++) e2[s3].isNAN() && P("NAN control points in bezier are not supported");
    this.m_XStart = e2[0].x, this.m_YStart = e2[0].y, this.m_cp[0].setCoordsPoint2D(e2[1]), this.m_cp[1].setCoordsPoint2D(e2[2]), this.m_XEnd = e2[3].x, this.m_YEnd = e2[3].y, this.afterCompletedModification();
  }
  getTangent(t3) {
    const e2 = Ot(mi, 4);
    return this.queryControlPoints(e2), Co(e2, t3);
  }
  getDerivative(t3) {
    const e2 = Ot(mi, 4);
    return this.queryControlPoints(e2), ao(e2, 1, t3);
  }
  getCurvature(t3) {
    const e2 = uo(this, 1, t3), s3 = uo(this, 2, t3), n5 = e2.sqrLength();
    if (0 === n5) return Number.NaN;
    e2.divThis(Math.sqrt(n5));
    return e2.crossProduct(s3) / n5;
  }
  isIntersectingPoint(t3, e2, s3) {
    if (s3 && (t3.equals(this.getStartXY()) || t3.equals(this.getEndXY()))) return false;
    const n5 = new n3();
    if (this.queryLooseEnvelope(n5), n5.inflateCoords(e2, e2), !n5.contains(t3)) return false;
    const i2 = this.getClosestCoordinate(t3, false), r = new mi();
    this.queryCoord2D(i2, r);
    return mi.distance(r, t3) <= e2;
  }
  isIntersectingPoint3D(t3, e2, s3, i2, r = 1) {
    return n(0), false;
  }
  isMonotoneQuickAndDirty() {
    const t3 = Ot(mi, 4);
    return this.queryControlPoints(t3), go(t3);
  }
  getMonotonicPartParams(e2, s3) {
    const i2 = Qr(this), r = i2.specialPointsCount();
    if (n($e.s_maxMonotonicPartParams >= r), !s3) return i2.specialPointsCount();
    e2 < r && P("");
    for (let t3 = 0; t3 < r; t3++) s3[t3] = i2.specialPoints[t3];
    return r;
  }
  normalizeAfterEndpointChange() {
    return false;
  }
  orientBottomUp() {
    if (this.m_YEnd < this.m_YStart || this.m_YEnd === this.m_YStart && this.m_XEnd < this.m_XStart) {
      this.m_XEnd = Pt(this.m_XStart, this.m_XStart = this.m_XEnd), this.m_YEnd = Pt(this.m_YStart, this.m_YStart = this.m_YEnd);
      for (let t3 = 0, e2 = this.m_description.getTotalComponentCount() - 2; t3 < e2; t3++) this.m_attributes[t3 + e2] = Pt(this.m_attributes[t3], this.m_attributes[t3] = this.m_attributes[t3 + e2]);
      this.m_cp[1] = Pt(this.m_cp[0], this.m_cp[0] = this.m_cp[1]), this.m_cachedValues = null;
    }
  }
  findMinDeriv() {
    const t3 = new p2();
    return io(this, t3), t3.value();
  }
  isLine() {
    return false;
  }
  isDegenerateToLineHelper(t3) {
    const e2 = Ot(mi, 4);
    this.queryControlPoints(e2);
    const s3 = e2[3].sub(e2[0]), n5 = s3.length();
    if (mi.distance(e2[0], e2[1]) + mi.distance(e2[2], e2[1]) + mi.distance(e2[2], e2[3]) - n5 > t3) return false;
    const i2 = t3;
    let r = e2[1].clone();
    r.subThis(e2[0]);
    let o = Math.abs(r.crossProduct(s3)) / n5;
    return !(o > i2) && (r = e2[2].clone(), r.subThis(e2[1]), o = Math.abs(r.crossProduct(s3)) / n5, !(o > i2));
  }
  copyIgnoreAttributes(t3) {
    const e2 = Ot(mi, 4);
    this.queryControlPoints(e2), t3.setControlPoints(e2);
  }
  calculateArea2DHelper() {
    return mo(this);
  }
  absNorm() {
    return zo(this);
  }
  queryEnvelopeW(t3, e2) {
    qo(this, t3, e2);
  }
  setSegmentFromCoordsForStitcher(t3, e2) {
    ko(this, t3, e2);
  }
  writeInBufferStream(t3, e2) {
    const s3 = new Float64Array(4);
    return this.writeInBuffer_(s3), t3.writeRangeFromArray(e2, s3.length, s3, true, 1), e2 + s3.length;
  }
  writeInBuffer_(t3) {
    return t3[0] = this.m_cp[0].x, t3[1] = this.m_cp[0].y, t3[2] = this.m_cp[1].x, t3[3] = this.m_cp[1].y, 4;
  }
  readFromBufferStream(t3, e2) {
    const s3 = new Float64Array(4);
    t3.queryRange(e2, s3.length, s3, true, 1), this.readFromBuffer_(s3);
  }
  readFromBuffer_(t3) {
    this.m_cp = Ot(mi, 2), this.m_cp[0].x = t3[0], this.m_cp[0].y = t3[1], this.m_cp[1].x = t3[2], this.m_cp[1].y = t3[3], this.m_cachedValues = null;
  }
  snapControlPoints(t3) {
    const e2 = Ot(mi, 4);
    this.queryControlPoints(e2);
    const s3 = (e3, s4, n6) => {
      let i3 = false;
      if (mi.sqrDistance(e3, n6) <= t3) {
        i3 = !e3.equals(n6), e3.setCoordsPoint2D(n6);
        mi.sqrDistance(s4, n6) <= t3 && (i3 ||= !s4.equals(n6), s4.setCoordsPoint2D(n6));
      }
      return i3;
    }, n5 = s3(e2[1], e2[2], e2[0]), i2 = s3(e2[2], e2[1], e2[3]);
    return (n5 || i2) && this.setControlPoints(e2), n5 || i2;
  }
  needsSnapControlPoints(t3) {
    if (!t3) return false;
    const e2 = Ot(mi, 4);
    this.queryControlPoints(e2);
    const s3 = (e3, s4, n6) => {
      let i3 = false;
      if (mi.sqrDistance(e3, n6) <= t3) {
        i3 = !e3.equals(n6), e3.setCoordsPoint2D(n6);
        mi.sqrDistance(s4, n6) <= t3 && (i3 ||= !s4.equals(n6), s4.setCoordsPoint2D(n6));
      }
      return i3;
    }, n5 = s3(e2[1], e2[2], e2[0]), i2 = s3(e2[2], e2[1], e2[3]);
    return n5 || i2;
  }
  calculateSpecialPointsForCracking(t3, e2) {
    return Qo(this, t3, e2);
  }
  ensureXYMonotone() {
    return lo(this);
  }
  setCoordsForIntersector(t3, e2, s3) {
    eo(this, t3, e2, s3);
  }
  copyToImpl(t3) {
    const e2 = t3;
    e2.m_cp[0].assign(this.m_cp[0]), e2.m_cp[1].assign(this.m_cp[1]), Jr(e2, Kr(this));
  }
  reverseImpl() {
    this.m_cp[1] = Pt(this.m_cp[0], this.m_cp[0] = this.m_cp[1]);
  }
  equalsImpl(t3) {
    const e2 = t3, s3 = 0, n5 = 1;
    return !!this.m_cp[0].equals(e2.m_cp[s3]) && !!this.m_cp[1].equals(e2.m_cp[n5]);
  }
  equalsImplTol(t3, e2) {
    const s3 = t3, n5 = 0, i2 = 1;
    return !!this.m_cp[0].isEqualPoint2D(s3.m_cp[n5], e2) && !!this.m_cp[1].isEqualPoint2D(s3.m_cp[i2], e2);
  }
  swapImpl(t3) {
    const e2 = t3;
    e2.m_cp[0] = Pt(this.m_cp[0], this.m_cp[0] = e2.m_cp[0]), e2.m_cp[1] = Pt(this.m_cp[1], this.m_cp[1] = e2.m_cp[1]), to(this, e2);
  }
  afterCompletedModification() {
    $r(this);
  }
  isIntersecting(t3, e2, s3) {
    return 0 !== rm(false, this, t3, e2, s3);
  }
  intersect(t3, e2, s3, n5, i2) {
    return um(false, this, t3, e2, s3, n5, i2);
  }
  intersectPoint(t3, e2, s3) {
    return Xo(this, t3, e2, s3);
  }
  endPointModified() {
    $r(this);
  }
  clearEndPointModified() {
  }
};
ia.type = a.enumBezier;
var ra = class {
  constructor() {
    this.length = Number.NaN, this.area = Number.NaN, this.centroidX = Number.NaN, this.centroidY = 0, this.specialPoints = [], this.specialPointsLength = [];
  }
  specialPointsCount() {
    return this.specialPoints.length;
  }
};
function oa(t3, e2, s3, i2, r, o, a2, h2) {
  for (; ; ) {
    const u = mi.distance(e2[0], e2[2]), m3 = mi.distance(e2[0], e2[1]) + mi.distance(e2[1], e2[2]);
    if (m3 - u <= r + i2 * m3) return t3 + Q(u, m3, 0.5);
    const l2 = Ot(mi, 4), c = (t4) => {
      fa(e2, s3, 1, t4, l2);
      return l2[1].length();
    };
    if (0 === a2 && h2 < 8) {
      n(h2 < 8);
      let u2 = c(0), l3 = c(1);
      o[0] += 2, u2 > l3 && (l3 = Pt(u2, u2 = l3), e2[2] = Pt(e2[0], e2[0] = e2[2]), s3[2] = Pt(s3[0], s3[0] = s3[2]));
      let g3 = u2 / (u2 + l3), d3 = 1, _2 = m3;
      for (; g3 < 1 / 32 && _2 >= r + i2 * _2; ) {
        d3 /= 4;
        const t4 = c(d3);
        o[0]++, g3 = u2 / (t4 + u2);
        const n5 = new mi();
        if (_h(e2, s3, 0.5 * d3, n5), _2 = mi.distance(n5, e2[0]), _2 <= r) {
          const t5 = new mi();
          _h(e2, s3, d3, t5), _2 += mi.distance(t5, n5);
        }
      }
      if (1 !== d3) {
        const n5 = Ot(mi, 3), u3 = [0, 0, 0];
        Oa(e2, s3, d3, e2, s3, n5, u3), t3 = oa(t3, n5, u3, i2, r, o, 0, h2 + 1), a2++, h2++;
        continue;
      }
    }
    let g2 = false;
    const d2 = 8;
    o[0] += d2;
    const _ = hr(d2, c, 0, 1), p3 = 16;
    o[0] += p3;
    const f3 = hr(p3, c, 0, 1);
    if (g2 = Math.abs(_ - f3) > r + i2 * m3, !g2) return t3 + f3;
    if (a2 < 8 && h2 < 9) {
      const n5 = Ot(mi, 3), u2 = [0, 0, 0];
      Oa(e2, s3, 0.5, e2, s3, n5, u2), t3 = oa(t3, n5, u2, i2, r, o, a2 + 1, h2 + 1), a2++, h2++;
      continue;
    }
    const P5 = 32;
    o[0] += P5;
    const y2 = hr(P5, c, 0, 1);
    if (g2 = Math.abs(f3 - y2) > r + i2 * m3, !g2) return t3 + y2;
    const x4 = 64;
    o[0] += x4;
    const C3 = hr(x4, c, 0, 1);
    if (g2 = Math.abs(y2 - C3) > r + i2 * m3, !g2) return t3 + C3;
    const v3 = 128;
    o[0] += v3;
    const b2 = hr(v3, c, 0, 1);
    return g2 = Math.abs(C3 - b2) > r + i2 * m3, t3 + b2;
  }
}
function aa(t3, e2, s3, n5, i2) {
  if (s3 === e2) return 0;
  const r = Ot(mi, 3), o = [0, 0, 0];
  t3.queryControlPoints(r), t3.queryWeights(o);
  const a2 = [0, 0, 0], h2 = Ot(mi, 3);
  Qa(r, o, e2, s3, h2, a2);
  return oa(0, h2, a2, n5, i2, [0], 0, 0);
}
var ha = class {
  constructor(t3, e2, s3) {
    this.controlPoints = Qt(t3, 3), this.weights = [0, 0, 0], Dt(this.weights, e2, 0, 0, 3), this.point = s3.clone();
  }
  getMaxDerivative() {
    return 3;
  }
  getValue(t3, e2) {
    if (0 === t3) {
      const t4 = new mi();
      _h(this.controlPoints, this.weights, e2, t4);
      const s3 = Ot(mi, 4);
      fa(this.controlPoints, this.weights, 1, e2, s3);
      return 2 * t4.sub(this.point).dotProduct(s3[1]);
    }
    if (1 === t3) {
      const t4 = new mi();
      _h(this.controlPoints, this.weights, e2, t4);
      const s3 = Ot(mi, 4);
      fa(this.controlPoints, this.weights, 2, e2, s3);
      return 2 * (t4.sub(this.point).dotProduct(s3[2]) + s3[1].dotProduct(s3[1]));
    }
    if (2 === t3) {
      const t4 = new mi();
      _h(this.controlPoints, this.weights, e2, t4);
      const s3 = Ot(mi, 4);
      fa(this.controlPoints, this.weights, 3, e2, s3);
      return 2 * (t4.sub(this.point).dotProduct(s3[3]) + 3 * s3[1].dotProduct(s3[2]));
    }
    return 0;
  }
  getError(t3) {
    return n(0), 0;
  }
};
function ua(t3, e2, s3, n5) {
  const i2 = Ba(0, 0, 0, 0, mi.getNAN()), r = Yt(18, Number.NaN), o = Ot(mi, 3);
  t3.queryControlPoints(o), o[2].subThis(e2), o[1].subThis(e2), o[0].subThis(e2);
  const a2 = [0, 0, 0];
  t3.queryWeights(a2);
  const h2 = [1, fh(a2), 1], u = yh(a2, s3), m3 = yh(a2, n5), l2 = tn(new ha(o, h2, new mi(0, 0)), x2.construct(u, m3), 18, r);
  _h(o, h2, u, i2.pt), i2.t = u, i2.d = mi.distance(i2.pt, new mi(0, 0));
  const c = new mi();
  _h(o, h2, m3, c);
  const g2 = mi.distance(c, new mi(0, 0));
  g2 < i2.d && (i2.d = g2, i2.t = m3, i2.pt.assign(c));
  for (let d2 = 0; d2 < l2; d2++) {
    _h(o, h2, r[d2], c);
    const t4 = mi.distance(c, new mi(0, 0));
    t4 < i2.d && (i2.d = t4, i2.t = Ph(a2, r[d2]), i2.pt.assign(c));
  }
  return i2;
}
function ma(t3, e2, s3, n5, i2) {
  let r = true;
  const o = Ot(mi, 4), a2 = Kn(5, e2, s3, n5, i2, (e3) => {
    pa(t3, 1, e3, o);
    return (r ? t3.getCoordX(e3) - t3.getStartX() : t3.getCoordY(e3) - t3.getStartY()) * o[1].length();
  });
  r = false;
  const h2 = Kn(5, e2, s3, n5, i2, (e3) => {
    pa(t3, 1, e3, o);
    return (r ? t3.getCoordX(e3) - t3.getStartX() : t3.getCoordY(e3) - t3.getStartY()) * o[1].length();
  });
  return new mi(a2, h2);
}
function la(t3) {
  t3.m_cachedValues = null;
}
function ca(t3, e2) {
  e2.m_cachedValues = Pt(t3.m_cachedValues, t3.m_cachedValues = e2.m_cachedValues);
}
function ga(t3) {
  if (t3.m_cachedValues) return t3.m_cachedValues;
  const e2 = new ra(), s3 = Ot(mi, 3);
  t3.queryControlPoints(s3);
  const n5 = [0, 0, 0];
  return t3.queryWeights(n5), da(s3, n5, e2.specialPoints), La(t3, e2), e2;
}
function da(t3, e2, s3) {
  if (0 === e2[1]) return s3.length = 0, s3.push(0), void s3.push(1);
  const n5 = Ot(p2, 8);
  n5[0].set(0);
  let i2 = 1;
  {
    const s4 = new p2(t3[1].x).subThis(t3[0].x).mulThis(e2[1]).mulThis(e2[0]), r = new p2(t3[2].x).subThis(t3[0].x).mulThis(e2[2]).mulThis(e2[0]), o = s4.subE(r).addThisE(new p2(t3[2].x).subThis(t3[1].x).mulThis(e2[2]).mulThis(e2[1]));
    r.subThisE(s4.mul(2));
    const a2 = Ot(p2, 2);
    let h2 = gn(o, r, s4, new x2(0, 1), false, a2);
    h2 < 0 && (h2 = 0);
    for (let t4 = 0; t4 < h2; t4++) Vs(a2[t4].value(), 0, 1) || (n5[i2] = a2[t4], i2++);
  }
  {
    const s4 = new p2(t3[1].y).subThis(t3[0].y).mulThis(e2[1]).mulThis(e2[0]), r = new p2(t3[2].y).subThis(t3[0].y).mulThis(e2[2]).mulThis(e2[0]), o = s4.subE(r).addThisE(new p2(t3[2].y).subThis(t3[1].y).mulThis(e2[2]).mulThis(e2[1]));
    r.subThisE(s4.mul(2));
    const a2 = Ot(p2, 2);
    let h2 = gn(o, r, s4, new x2(0, 1), false, a2);
    h2 < 0 && (h2 = 0);
    for (let t4 = 0; t4 < h2; t4++) Vs(a2[t4].value(), 0, 1) || (n5[i2] = a2[t4], i2++);
  }
  if (n5[i2].set(1), i2++, i2 > 2) {
    Zt(n5, 0, i2, (t5, e4) => Ct(t5.value(), e4.value()));
    let t4 = 0, e3 = n5[0].value(), s4 = 1;
    for (let r = 1; r < i2; r++) n5[r].eq(n5[r - 1]) ? (e3 += n5[r].value(), s4++) : (s4 > 1 && (e3 /= s4, n5[t4].set(e3)), t4++, n5[t4] = n5[r], e3 = n5[r].value(), s4 = 1);
    t4++, i2 = t4;
  }
  n5[0].set(0), n5[i2 - 1].set(1), s3.length = i2;
  for (let r = 0; r < i2; r++) s3[r] = n5[r].value();
}
function _a(t3, e2, s3) {
  if (s3) {
    if (e2 < 0) return e2;
    if (e2 > 1) return e2 - 1 + _a(t3, 1, false);
  }
  if (t3.isDegenerate(0)) return 0;
  const n5 = 1 === e2, i2 = ga(t3);
  if (n5 && !Number.isNaN(i2.length)) return i2.length;
  const r = Xa(t3), o = r / t3.calculateUpperLength2D();
  let a2 = 0, h2 = 0;
  for (let u = 1, m3 = i2.specialPointsCount(); u < m3; u++) {
    const s4 = i2.specialPoints[u];
    if (a2 += aa(t3, h2, Math.min(e2, s4), o, r), e2 <= s4) break;
    h2 = s4;
  }
  return n5 && (i2.length = a2), a2;
}
function pa(t3, e2, s3, n5) {
  const i2 = Ot(mi, 3);
  t3.queryControlPoints(i2);
  const r = [0, 0, 0];
  t3.queryWeights(r), fa(i2, r, e2, s3, n5);
}
function fa(t3, e2, s3, n5, i2) {
  const r = [t3[0], t3[1], t3[2]], o = [e2[0], e2[1], e2[2]], a2 = Ot(mi, 4);
  Pa(r, o, s3, n5, a2);
  for (let h2 = 0; h2 <= s3; h2++) i2[h2].setCoords(a2[h2].x, a2[h2].y);
}
function Pa(t3, e2, s3, i2, o) {
  n(s3 > 0);
  const a2 = [t3[0].clone(), t3[1].clone(), t3[2].clone()];
  if (!a2[0].isZero()) {
    for (let t4 = 1; t4 < 3; ++t4) a2[t4].subThis(a2[0]);
    a2[0].setCoords(0, 0);
  }
  const h2 = ya(a2, e2, 0, i2), u = Ca(e2, 0, i2), m3 = h2.divide(u);
  if (o[0].assign(m3), 0 === s3) return;
  const l2 = [e2[1] * e2[0], e2[2] * e2[0] * 0.5, e2[1] * e2[2]], c = [t3[1].sub(t3[0]), t3[2].sub(t3[0]), t3[2].sub(t3[1])], g2 = u * u, d2 = ya(c, l2, 0, i2).mul(2).divide(g2);
  if (o[1].assign(d2), 1 === s3) return;
  const _ = Ca(e2, 1, i2), p3 = 2 * u * _, f3 = ya(c, l2, 1, i2).mul(2).sub(d2.mul(p3)).divide(g2);
  if (o[2].assign(f3), 2 === s3) return;
  const P5 = ya(c, l2, 2, i2).mul(2), y2 = 2 * (_ * _ + u * Ca(e2, 2, i2)), x4 = P5.sub(f3.mul(p3).mul(2)).sub(d2.mul(y2)).divide(g2);
  o[3].assign(x4), 3 !== s3 && b("");
}
function ya(t3, e2, s3, n5) {
  if (0 === s3) {
    if (n5 <= 0.5) {
      const s4 = new mi();
      k2(2, t3[0].mul(e2[0]), t3[1].mul(e2[1]), n5, s4);
      const i2 = new mi();
      k2(2, t3[1].mul(e2[1]), t3[2].mul(e2[2]), n5, i2);
      const r = new mi();
      return k2(2, s4, i2, n5, r), r;
    }
    {
      const s4 = new mi();
      F(2, t3[0].mul(e2[0]), t3[1].mul(e2[1]), n5, s4);
      const i2 = new mi();
      F(2, t3[1].mul(e2[1]), t3[2].mul(e2[2]), n5, i2);
      const r = new mi();
      return F(2, s4, i2, n5, r), r;
    }
  }
  if (1 === s3) {
    const s4 = t3[1].mul(e2[1]), i2 = s4.sub(t3[0].mul(e2[0])).mul(1 - n5).add(t3[2].mul(e2[2]).sub(s4).mul(n5));
    return i2.mulThis(2), i2;
  }
  if (2 === s3) {
    const s4 = t3[1].mul(e2[1]), n6 = t3[2].mul(e2[2]).sub(s4).sub(s4.sub(t3[0].mul(e2[0])));
    return n6.mulThis(2), n6;
  }
  b("");
}
function xa(t3, e2, s3, n5) {
  if (n5.toDouble() <= 0.5) {
    const s4 = new ve();
    O(2, t3[0].mulE(e2[0]), t3[1].mulE(e2[1]), n5, s4);
    const i2 = new ve();
    O(2, t3[1].mulE(e2[1]), t3[2].mulE(e2[2]), n5, i2);
    const r = new ve();
    return O(2, s4, i2, n5, r), r;
  }
  {
    const s4 = new ve();
    G2(2, t3[0].mulE(e2[0]), t3[1].mulE(e2[1]), n5, s4);
    const i2 = new ve();
    G2(2, t3[1].mulE(e2[1]), t3[2].mulE(e2[2]), n5, i2);
    const r = new ve();
    return G2(2, s4, i2, n5, r), r;
  }
}
function Ca(t3, e2, s3) {
  if (0 === e2) {
    const e3 = Q(t3[0], t3[1], s3), n5 = Q(t3[1], t3[2], s3);
    return Q(e3, n5, s3);
  }
  if (1 === e2) {
    return 2 * ((1 - s3) * (t3[1] - t3[0]) + (t3[2] - t3[1]) * s3);
  }
  if (2 === e2) {
    return 2 * (t3[2] - t3[1] - (t3[1] - t3[0]));
  }
  b("");
}
function va(t3, e2, s3) {
  if (s3.toDouble() <= 0.5) {
    const e3 = A2(t3[0], t3[1], s3), n5 = A2(t3[1], t3[2], s3);
    return A2(e3, n5, s3);
  }
  {
    const e3 = P2(t3[0], t3[1], s3), n5 = P2(t3[1], t3[2], s3);
    return P2(e3, n5, s3);
  }
}
function ba(t3, e2, s3, n5, i2) {
  const r = [ve.constructPoint2D(t3[0]), ve.constructPoint2D(t3[1]), ve.constructPoint2D(t3[2])];
  r[2].subThisE(r[0]), r[1].subThisE(r[0]), r[0].setCoords(0, 0);
  Ea(r, [new p2(e2[0]), new p2(e2[1]), new p2(e2[2])], s3, n5, i2);
}
function Ea(t3, e2, s3, i2, r) {
  n(s3 > 0);
  const o = [t3[0].clone(), t3[1].clone(), t3[2].clone()];
  if (!o[0].isZero()) {
    for (let t4 = 1; t4 < 3; ++t4) o[t4].subThisE(o[0]);
    o[0] = ve.constructCoords(0, 0);
  }
  const a2 = xa(o, e2, 0, i2), h2 = va(e2, 0, i2), u = a2.divE(h2);
  r[0].setE(u);
  const m3 = [e2[1].mulE(e2[0]), e2[2].mulE(e2[0]).mul(0.5), e2[1].mulE(e2[2])], l2 = xa([t3[1].subE(t3[0]), t3[2].subE(t3[0]), t3[2].subE(t3[1])], m3, 0, i2).mul(2), c = h2.sqr(), g2 = l2.divE(c);
  r[1].setE(g2);
}
function Sa(t3, e2, s3) {
  const n5 = Ot(mi, 3);
  t3.queryControlPoints(n5);
  const i2 = Yt(3, Number.NaN);
  t3.queryWeights(i2), Da(n5, i2, e2, s3);
}
function Da(t3, e2, s3, n5) {
  s3.value() < 0 && s3.set(0, s3.eps()), s3.value() > 1 && s3.set(1, s3.eps());
  const i2 = Ot(ve, 4);
  ba(t3, e2, 1, s3, i2), n5.setE(i2[1]);
}
function wa(t3, e2, s3) {
  const n5 = Us(s3, 0, 1), i2 = Ot(mi, 4);
  if (fa(t3, e2, 3, n5, i2), i2[1].isZero()) {
    if (i2[2].isZero()) return i2[3];
    {
      const t4 = i2[2].clone();
      return 1 === n5 && t4.negateThis(), t4;
    }
  }
  return i2[1];
}
var Aa = class {
  constructor(t3, e2) {
    this.len = 0, this.b = t3, this.len = e2;
  }
  getMaxDerivative() {
    return 1;
  }
  getValue(t3, e2) {
    return 0 === t3 ? this.len - _a(this.b, e2, false) : 0;
  }
  getError(t3) {
    return n(0), 0;
  }
};
function Ta(t3, e2, s3) {
  const n5 = _a(t3, 1, false);
  if (e2 <= 0) return e2;
  if (e2 >= n5) return e2 - n5 + 1;
  const i2 = [0];
  return 1 !== tn(new Aa(t3, e2), x2.unit(), 1, i2) && b(""), i2[0];
}
function Ia(t3) {
  const e2 = Ot(mi, 3), s3 = [0, 0, 0];
  return t3.queryControlPoints(e2), t3.queryWeights(s3), Ma(e2, s3);
}
function Ma(t3, e2) {
  const s3 = fh(e2);
  if (1 === s3) {
    return fi(t3);
  }
  if (0 === s3) return 0;
  const i2 = [new mi(0, 0), t3[1].sub(t3[0]), t3[2].sub(t3[0])], r = i2[1].crossProduct(i2[2]);
  if (s3 < 1) {
    n(s3 > 0);
    const t4 = 1 - s3;
    let e3;
    if (t4 < 0.01) e3 = -1 / 3 + t4 * (2 / 15 + t4 * (3 / 35 + t4 * (16 / 315 + t4 * (20 / 693 + t4 * (16 / 1001 + t4 * (56 / 6435))))));
    else {
      const n5 = t4 * (1 + s3), i3 = Math.atan2(Math.sqrt(t4), Math.sqrt(1 + s3));
      e3 = s3 * (0.5 * s3 - J(n5) * i3) / n5;
    }
    return r * e3;
  }
  {
    const t4 = (s3 - 1) * (s3 + 1);
    return 0.25 * s3 / Math.pow(t4, 1.5) * (-2 * s3 * Math.sqrt(t4) * r - 4 * i2[1].y * i2[2].x * Math.atanh(Math.sqrt((s3 - 1) / (s3 + 1))) - i2[1].x * i2[2].y * Math.log(2 * s3 * (s3 - Math.sqrt(t4)) - 1));
  }
}
function Ya(t3, e2) {
  const s3 = fh(e2);
  if (1 === s3) {
    const e3 = Ot(mi, 3);
    zi(t3, e3);
    const s4 = e3[2].clone(), n5 = e3[1].clone(), i3 = new mi(), r2 = s4.y * n5.x - s4.x * n5.y;
    return i3.x = -(4 * s4.x + 5 * n5.x) * r2 / 60, i3.y = -(4 * s4.y + 5 * n5.y) * r2 / 60, i3;
  }
  if (0 === s3) return new mi(0, 0);
  n(s3 > 0);
  const i2 = t3[1].sub(t3[0]), r = t3[2].sub(t3[0]);
  if (s3 < 1) {
    const t4 = Math.sqrt(1 - s3), e3 = Math.sqrt(1 + s3), n5 = (i2.y * r.x - i2.x * r.y) * s3 / Math.pow(t4 * e3, 5) / 12, o = Math.atan2(t4, e3), a2 = s3 * t4 * e3, h2 = s3 * s3, u = i2.mul(2 * (2 + h2)), m3 = r.mul(2 * h2 - 5), l2 = u.add(m3).mul(a2), c = r.sub(i2.mul(2 * h2)).mul(6 * o);
    return l2.add(c).mul(n5);
  }
  {
    const t4 = Math.sqrt(s3 - 1), e3 = Math.sqrt(s3 + 1), n5 = (i2.y * r.x - i2.x * r.y) * s3 / Math.pow(t4 * e3, 5) / 12, o = Math.atanh(t4 / e3), a2 = s3 * t4 * e3, h2 = s3 * s3, u = i2.mul(4).sub(r.mul(5)), m3 = i2.add(r).mul(2 * h2), l2 = u.add(m3).mul(a2), c = r.sub(i2.mul(2 * h2)).mul(6 * o);
    return l2.add(c).mul(n5);
  }
}
function Na(t3) {
  const e2 = Ot(mi, 3), s3 = [0, 0, 0];
  return t3.queryControlPoints(e2), t3.queryWeights(s3), Ya(e2, s3);
}
function Xa(t3) {
  return qa(t3.calculateUpperLength2D());
}
function qa(t3) {
  return 256 * Qs() * t3;
}
function Fa(t3) {
  if (0 === t3.m_weights[1]) return true;
  const e2 = mi.distance(t3.getStartXY(), t3.getEndXY()), s3 = t3.calculateUpperLength2D();
  return s3 - e2 <= 8 * Number.EPSILON * s3;
}
function Va(t3) {
  return t3.m_cachedValues;
}
function La(t3, e2) {
  t3.m_cachedValues = e2;
}
function Ra(t3, e2, s3, n5, i2) {
  const r = Ot(mi, 3);
  t3.queryControlPoints(r);
  const o = [0, 0, 0];
  t3.queryWeights(o);
  const a2 = [0];
  return 1 === za(r, o, e2, x2.unit(), n5, i2, 1, a2) ? a2[0] : Number.NaN;
}
function za(t3, e2, s3, i2, r, o, a2, h2) {
  D(x2.unit().contains(i2) && a2 > 0, ""), (o < 0 || Number.isNaN(o)) && (o = Number.MAX_VALUE);
  const u = new Array(3);
  for (let n5 = 0; n5 < 3; ++n5) u[n5] = t3[n5].sub(s3);
  const m3 = fh(e2), l2 = Ee.constructPoint2D(u[0]), c = Ee.constructPoint2D(u[1]), g2 = Ee.constructPoint2D(u[2]), d2 = si.constructDouble(m3), p3 = d2.clone();
  p3.ldexpThis(1);
  const f3 = l2.dotProduct(c.sub(l2)).mul(d2), P5 = d2.mul(d2.addDouble(2)), y2 = g2.sub(c.mul(P5.ldexp(1))), x4 = c.sqrLength().mul(d2.mul(d2).ldexp(1)).add(l2.sqrLength().mul(d2.ldexp(2).subDouble(1))).add(l2.dotProduct(y2)), C3 = g2.sub(c.mul(p3)).add(l2.mul(p3.subDouble(1))), v3 = c.mul(d2).sub(l2).dotProduct(C3).mulDouble(3), b2 = c.dotProduct(g2).mul(d2.subDouble(3).mul(d2)).ldexp(1), E2 = c.sqrLength().mul(d2.mul(d2).ldexp(2)), S3 = l2.sqrLength().mul(d2.ldexp(2).subDouble(3)), D3 = l2.dotProduct(g2.sub(c.mul(d2.mulDouble(3).subDouble(1)).mul(d2))).ldexp(1), w4 = g2.sqrLength().addThis(b2).addThis(E2).addThis(S3).addThis(D3), A4 = l2.add(g2).sub(c.mul(p3)), T3 = d2.subDouble(1), I4 = g2.sub(l2).dotProduct(A4).mul(T3), M2 = new mi(0, 0), Y3 = [];
  let N2 = new mi();
  _h(u, e2, i2.vmin, N2);
  let X3 = mi.distance(N2, M2);
  if (X3 <= o && Y3.push(new mi(i2.vmin, X3)), i2.vmin !== i2.vmax && (_h(u, e2, i2.vmax, N2), X3 = mi.distance(N2, M2), X3 <= o && Y3.push(new mi(i2.vmax, X3))), i2.width() > 0) {
    const t4 = u[2].isZero(), s4 = Ot(si, 4), n5 = Rn(I4, w4, v3, x4, f3, 58, i2, t4, s4);
    for (let r2 = 0; r2 < n5; r2++) {
      if (!i2.containsExclusiveCoordinate(s4[r2].toDouble())) continue;
      let t5 = s4[r2].toDouble();
      t5 = Ph(e2, t5);
      const n6 = new mi();
      _h(u, e2, t5, n6), X3 = mi.distance(n6, M2), X3 <= o && Y3.push(new mi(t5, X3));
    }
  }
  if (r) {
    n(i2.equals(x2.unit()));
    {
      _h(u, e2, -1, N2, true);
      const t4 = new mi();
      _h(u, e2, 0, t4);
      const s4 = new pm({ start: N2, end: t4 }), n5 = s4.getClosestCoordinate(M2, true);
      n5 < 1 && (N2 = s4.getCoord2D(n5), X3 = mi.distance(N2, M2), X3 <= o && Y3.push(new mi(n5 - 1, X3)));
    }
    {
      _h(u, e2, 2, N2, true);
      const t4 = new mi();
      _h(u, e2, i2.vmax, t4);
      const s4 = new pm({ start: t4, end: N2 }), n5 = s4.getClosestCoordinate(M2, true);
      n5 > 0 && (N2 = s4.getCoord2D(n5), X3 = mi.distance(N2, M2), X3 <= o && Y3.push(new mi(1 + n5, X3)));
    }
  }
  if (!Y3.length) return 0;
  Y3.sort((t4, e3) => t4.compare(e3));
  let q2 = 0;
  const F3 = Y3[0].x;
  if (h2[q2++] = F3, q2 < a2) {
    const t4 = Rt2(u, 4, false).total(), e3 = Y3[0].y;
    for (let s4 = 1, n5 = Y3.length; s4 < n5; s4++) if (Y3[s4].y > e3 + t4) {
      Y3.length = s4;
      break;
    }
    Y3.sort((t5, e4) => Ct(t5.x, e4.x)), q2 = 0, h2[q2++] = Y3[0].x;
    for (let s4 = 1, n5 = Y3.length; s4 < n5; s4++) Y3[s4].x !== h2[q2 - 1] && q2 < a2 && (h2[q2++] = Y3[s4].x);
  }
  return q2;
}
function Ba(t3, e2, s3, n5, i2) {
  return { tmin: t3, tmax: e2, t: s3, d: n5, pt: i2.clone() };
}
function ka(t3, e2, s3, i2, r) {
  const o = new pe();
  if (Ga(t3, x2.unit(), o), o.inflate(i2), !o.isIntersectingPoint2D(e2)) return 0;
  const a2 = ga(t3);
  let h2 = 0;
  const u = [];
  let m3 = a2.specialPoints[0];
  for (let l2 = 1, c = a2.specialPoints.length; l2 < c; ++l2) {
    const s4 = a2.specialPoints[l2], i3 = ua(t3, e2, m3, s4);
    if (0 === u.length) u.push(i3);
    else if (i3.t === i3.tmin) n(u.at(-1).d <= i3.d), u.at(-1).tmax = i3.tmax;
    else if (u.at(-1).t === u.at(-1).tmax) {
      n(u.at(-1).d >= i3.d);
      const t4 = u.at(-1).tmin;
      u[u.length - 1] = i3, u.at(-1).tmin = t4;
    } else u.push(i3);
    m3 = s4;
  }
  for (const n5 of u) if (n5.d <= i2) {
    const t4 = n5.t;
    s3 ? (s3[h2] = t4, h2++) : h2++;
  }
  return h2;
}
function Ga(t3, e2, s3) {
  const n5 = Ot(mi, 3);
  t3.queryControlPoints(n5);
  const i2 = [0, 0, 0];
  t3.queryWeights(i2), Wa(n5, i2, e2, s3);
}
function Wa(t3, e2, s3, n5) {
  if (s3.equalsRange(0, 1)) return void n5.setFromPoints(t3, 3);
  const i2 = Ot(mi, 3), r = [0, 0, 0];
  Qa(t3, e2, s3.vmin, s3.vmax, i2, r), n5.setFromPoints(i2, 3);
}
function ja(t3) {
  const e2 = fs(t3[0].y, t3[1].y), s3 = fs(t3[1].y, t3[2].y);
  if (e2 >= 0 && s3 >= 0 || e2 <= 0 && s3 <= 0) {
    const e3 = fs(t3[0].x, t3[1].x), s4 = fs(t3[1].x, t3[2].x);
    if (e3 >= 0 && s4 >= 0 || e3 <= 0 && s4 <= 0) return true;
  }
  return false;
}
function Za(t3) {
  const e2 = Ot(mi, 3);
  t3.queryControlPoints(e2);
  const s3 = Ha(e2);
  return s3 && (t3.m_cp.setCoordsPoint2D(e2[1]), t3.afterCompletedModification()), s3;
}
function Ha(t3) {
  let e2 = false;
  for (let s3 = 0; s3 < 2; s3++) {
    const n5 = fs(t3[0][s3], t3[2][s3]);
    n5 > 0 ? (fs(t3[0][s3], t3[1][s3]) < 0 && (t3[1][s3] = t3[0][s3], e2 = true), fs(t3[1][s3], t3[2][s3]) < 0 && (t3[1][s3] = t3[2][s3], e2 = true)) : n5 < 0 ? (fs(t3[0][s3], t3[1][s3]) > 0 && (t3[1][s3] = t3[0][s3], e2 = true), fs(t3[1][s3], t3[2][s3]) > 0 && (t3[1][s3] = t3[2][s3], e2 = true)) : t3[1][s3] !== t3[0][s3] && (t3[1][s3] = t3[0][s3], e2 = true);
  }
  return e2;
}
function Ua(e2, s3, n5) {
  void 0 === n5 && (n5 = s3, s3 = 0);
  const i2 = new mi();
  if (s3 < 0 || n5 > 1) return i2.setNAN(), i2;
  if (s3 > n5 && P("calculate_sub_weighted_centroid"), s3 === n5 || e2.isDegenerate(0)) return i2.setCoords(0, 0), i2;
  const r = ga(e2), o = Xa(e2), a2 = o / e2.calculateUpperLength2D();
  let h2 = s3, u = 0;
  for (let t3 = 1, m3 = r.specialPointsCount(); t3 < m3; t3++) if (s3 < r.specialPoints[t3]) {
    u = t3 - 1;
    break;
  }
  i2.setCoords(0, 0);
  for (let t3 = u + 1, m3 = r.specialPointsCount(); t3 < m3; t3++) {
    const s4 = Math.min(r.specialPoints[t3], n5), u2 = ma(e2, h2, s4, a2, o);
    if (i2.addThis(u2), h2 = s4, n5 <= r.specialPoints[t3]) break;
  }
  return i2.add(e2.getStartXY().mul(e2.calculateLength2D()));
}
function Oa(t3, e2, s3, i2, r, o, a2) {
  n(s3 >= 0 && s3 <= 1 && i2 !== o && r !== a2), n(e2[0] > 0 && e2[2] > 0 && e2[1] >= 0);
  const h2 = [1, fh(e2), 1], u = yh(e2, s3), m3 = Qt(t3, 3), l2 = Ot(X, 3);
  uh(m3, h2, l2);
  const c = Ot(X, 3), g2 = Ot(X, 3);
  xh(l2, u, i2 ? c : null, o ? g2 : null), Ch(e2, s3, r, a2);
  const d2 = ja(m3);
  if (i2) {
    for (let t4 = 0; t4 < 3; ++t4) dh(c[t4], i2[t4]);
    bh(m3, i2), d2 && Ha(i2);
  }
  if (o) {
    for (let t4 = 0; t4 < 3; ++t4) dh(g2[t4], o[t4]);
    bh(m3, o), d2 && Ha(o);
  }
}
function Qa(t3, e2, s3, i2, r, o) {
  if (n(s3 >= 0 && i2 <= 1 && s3 <= i2), s3 === i2) {
    const n5 = new mi(), i3 = mh(t3, e2, s3, n5);
    return vh(t3, n5), r[0].assign(n5), r[1].assign(n5), r[2].assign(n5), o[0] = i3, o[1] = i3, void (o[2] = i3);
  }
  if (0 === s3 && 1 === i2) return r[0].assign(t3[0]), r[1].assign(t3[1]), r[2].assign(t3[2]), o[0] = e2[0], o[1] = e2[1], void (o[2] = e2[2]);
  const a2 = Ot(X, 3);
  {
    const n5 = [1, fh(e2), 1], r2 = yh(e2, s3), o2 = yh(e2, i2);
    uh(t3, n5, a2), xh(a2, o2, a2, null);
    xh(a2, r2 >= o2 ? 1 : r2 / o2, null, a2);
  }
  const h2 = [0, 0, 0];
  Ch(e2, i2, h2, null), Ch(h2, s3 / i2, null, h2);
  const u = ja(t3), m3 = Ot(mi, 3);
  dh(a2[1], m3[1]), _h(t3, e2, s3, m3[0]), _h(t3, e2, i2, m3[2]), bh(t3, m3);
  for (let n5 = 0; n5 < 3; ++n5) r[n5].assign(m3[n5]), o[n5] = h2[n5];
  u && Ha(r);
}
function Ka(t3, e2, s3) {
  const n5 = fh(e2), i2 = [1, n5, 1], r = 4 * n5 / (3 * (1 + n5));
  s3[0].assign(t3[0]), s3[3].assign(t3[2]), Y(t3[0], t3[1], r, s3[1]), Y(t3[2], t3[1], r, s3[2]), new ia({ cp: s3 }), new Sn({ points: t3, weight: n5 });
  let o = 0, a2 = 0.1, h2 = 0;
  for (let u = 0; u < 9; u++, a2 += 0.1) {
    const e3 = new mi();
    _h(t3, i2, a2, e3);
    const n6 = new mi();
    Po(s3, a2, n6);
    const r2 = mi.sqrDistance(e3, n6);
    r2 > o && (o = r2, h2 = a2);
  }
  {
    const e3 = new mi();
    _h(t3, i2, h2, e3);
    const n6 = [0];
    Lo(s3, e3, x2.unit(), false, -1, 1, n6);
    const r2 = new mi();
    return Po(s3, n6[0], r2), o = mi.sqrDistance(e3, r2), Math.sqrt(o);
  }
}
function Ja(t3, e2, s3, n5) {
  if (e2.isEqual(t3.m_XStart, t3.m_YStart) && s3.isEqual(t3.m_XEnd, t3.m_YEnd)) return;
  const i2 = !!n5 && t3.isMonotoneQuickAndDirty(), r = new x3(), o = Ot(mi, 3);
  o[0].setCoords(t3.m_XStart, t3.m_YStart), o[2].setCoords(t3.m_XEnd, t3.m_YEnd);
  const a2 = new mi();
  a2.setSub(o[2], o[0]), a2.leftPerpendicularThis(), o[1].setAdd(o[0], a2);
  const h2 = Ot(mi, 3);
  h2[0].setCoordsPoint2D(e2), h2[2].setCoordsPoint2D(s3), a2.setSub(h2[2], h2[0]), a2.leftPerpendicularThis(), h2[1].setAdd(h2[0], a2), r.setFromTwoTriangles(o, h2) ? r.transformInPlace(t3.m_cp) : Y(e2, s3, 0.5, t3.m_cp), t3.changeEndPoints2D(e2, s3), i2 && Za(t3);
}
function $a(t3, e2, s3, n5, i2) {
  if (i2) {
    if (0 !== am(e2, s3)) return t3 ? 4 : 2;
  } else if (Ae(e2, s3)) return 1;
  return 0 !== nh(t3, e2, s3, null, null, null, n5, void 0 !== i2 && i2, true, false) ? 4 : 0;
}
function th(t3, e2, s3, n5, i2) {
  if (i2) {
    if (0 !== am(e2, s3)) return t3 ? 4 : 2;
  } else if (Ae(e2, s3)) return 1;
  return 0 !== ih(t3, e2, s3, null, null, null, n5, i2 ?? false, true, false) ? 4 : 0;
}
function eh(t3, e2, s3, n5, i2) {
  if (i2) {
    const n6 = am(e2, s3);
    if (0 !== n6) {
      if (t3) {
        if (1 === n6) {
          if (e2.m_weights[0] === s3.m_weights[0] && e2.m_weights[1] === s3.m_weights[1] && e2.m_weights[2] === s3.m_weights[2]) return 2;
        } else if (e2.m_weights[0] === s3.m_weights[2] && e2.m_weights[1] === s3.m_weights[1] && e2.m_weights[2] === s3.m_weights[0]) return 2;
        return 4;
      }
      return 2;
    }
  } else if (Ae(e2, s3)) return 1;
  return 0 !== rh(t3, e2, s3, null, null, null, n5, void 0 !== i2 && i2, true, false) ? 4 : 0;
}
function sh(t3, e2, s3, n5, i2) {
  if (i2) {
    if (0 !== am(e2, s3)) return t3 ? 4 : 2;
  } else if (Ae(e2, s3)) return 1;
  return 0 !== oh(t3, e2, s3, null, null, null, n5, i2 ?? false, true, false) ? 4 : 0;
}
function nh(t3, e2, s3, i2, r, o, a2, h2, u, m3) {
  if (null !== r && (r.length = 0), null !== o && (o.length = 0), null !== i2 && (i2.length = 0), s3.isDegenerate(0)) {
    const t4 = [0, 0], n5 = e2.intersectPoint(s3.getStartXY(), t4, a2);
    if (n5 > 0) {
      if (null !== r) for (let e3 = 0; e3 < n5; e3++) r.push(t4[e3]);
      if (null != o) for (let t5 = 0; t5 < n5; t5++) o.push(0);
      if (null != i2) for (let s4 = 0; s4 < n5; s4++) {
        const n6 = new mi();
        e2.queryCoord2D(t4[s4], n6), i2.push(n6);
      }
    }
    return n5;
  }
  const l2 = Oe(e2, s3);
  if (a2 = Math.max(a2, l2), e2.isDegenerateToLineHelper(l2)) {
    const t4 = new pm({ start: e2.getStartXY(), end: e2.getEndXY() }), n5 = Ds2(t4, s3, i2, r, o, a2, h2, m3);
    if (r) for (let s4 = 0; s4 < n5; ++s4) {
      const n6 = t4.getCoord2D(r[s4]);
      r[s4] = e2.getClosestCoordinate(n6, false);
    }
    return n5;
  }
  if (Qe(e2, s3, a2)) return 0;
  const c = Ot(mi, 3);
  e2.queryControlPoints(c);
  const g2 = [0, 0, 0];
  e2.queryWeights(g2);
  const d2 = [1, fh(g2), 1], _ = s3.getEndXY().sub(s3.getStartXY()), p3 = _.clone();
  p3.leftPerpendicularThis();
  const f3 = c[0].clone(), P5 = c[1].clone(), y2 = c[2].clone(), x4 = P5.sub(f3), C3 = y2.sub(f3), v3 = y2.sub(P5), b2 = d2[0], E2 = d2[1], S3 = d2[2], D3 = b2 * E2, w4 = b2 * S3, A4 = E2 * S3, T3 = x4.dotProduct(p3) * D3, I4 = C3.dotProduct(p3) * w4;
  let M2 = T3, Y3 = I4 - 2 * T3, N2 = v3.dotProduct(p3) * A4 + I4 - I4;
  const X3 = Yt(13, Number.NaN), q2 = Yt(13, Number.NaN);
  let F3 = sn(N2, Y3, M2, x2.unit(), false, X3);
  F3 < 0 && (X3[0] = 0, X3[1] = 1, F3 = 2);
  let V4 = 0;
  for (let n5 = 0, k4 = V4; n5 < F3; ++n5) {
    const t4 = new mi();
    _h(c, d2, X3[n5 + k4], t4), q2[V4] = s3.getClosestCoordinate(t4, false);
    mi.distance(t4, s3.getCoord2D(q2[V4])) <= a2 && (X3[V4] = X3[n5 + k4], V4++);
  }
  const L4 = Ot(mi, 3), R4 = Ot(mi, 3);
  if (e2.queryControlPoints(R4), R4[0].subThis(s3.getStartXY()), R4[1].subThis(s3.getStartXY()), R4[2].subThis(s3.getStartXY()), ah(R4, d2, L4, false), Math.abs(_.x) >= Math.abs(_.y)) {
    const t4 = _.y / _.x;
    N2 = L4[2].y - L4[2].x * t4, Y3 = L4[1].y - L4[1].x * t4, M2 = L4[0].y - L4[0].x * t4;
  } else {
    const t4 = _.x / _.y;
    N2 = L4[2].x - L4[2].y * t4, Y3 = L4[1].x - L4[1].y * t4, M2 = L4[0].x - L4[0].y * t4;
  }
  const z4 = e2.getEndXY().equals(s3.getStartXY()) || e2.getEndXY().equals(s3.getEndXY()), B4 = [0, 0];
  F3 = sn(N2, Y3, M2, x2.unit(), z4, B4);
  for (let n5 = 0, k4 = V4; n5 < F3; ++n5) {
    X3[n5 + k4] = B4[n5];
    const t4 = new mi();
    _h(c, d2, X3[n5 + k4], t4), q2[V4] = s3.getClosestCoordinate(t4, false);
    mi.distance(t4, s3.getCoord2D(q2[V4])) <= a2 && (X3[V4] = X3[n5 + k4], V4++);
  }
  n(V4 < X3.length + 4);
  for (let n5 = 0; n5 < V4; n5++) X3[n5] = Ph(g2, X3[n5]);
  F3 = e2.intersectPoint(s3.getStartXY(), B4, a2);
  for (let n5 = 0; n5 < F3; n5++) X3[V4] = B4[n5], q2[V4++] = 0;
  F3 = e2.intersectPoint(s3.getEndXY(), B4, a2);
  for (let n5 = 0; n5 < F3; n5++) X3[V4] = B4[n5], q2[V4++] = 1;
  F3 = s3.intersectPoint(e2.getStartXY(), B4, a2);
  for (let n5 = 0; n5 < F3; n5++) q2[V4] = B4[n5], X3[V4++] = 0;
  F3 = s3.intersectPoint(e2.getEndXY(), B4, a2);
  for (let n5 = 0; n5 < F3; n5++) q2[V4] = B4[n5], X3[V4++] = 1;
  return 0 === V4 ? 0 : cm(t3, e2, s3, X3, q2, V4, i2, r, o, a2, h2, u, m3);
}
function ih(t3, e2, s3, n5, i2, r, o, a2, h2, u) {
  if (Eu(s3)) {
    return nh(t3, e2, new pm({ start: s3.getStartXY(), end: s3.getEndXY() }), n5, i2, r, o, a2, h2, u);
  }
  const m3 = Oe(e2, s3);
  if (Qe(e2, s3, o = Math.max(o, m3))) return 0;
  const l2 = [], c = [], g2 = Ot(mi, 4);
  {
    e2.queryControlPoints(g2);
    const t4 = Ot(mi, 4), n6 = new x3();
    s3.canonicToWorldTransformation(n6);
    const i3 = new x3();
    i3.setInvert(n6), i3.transformPoints2D(g2, 4, t4);
    const r2 = Ot(si, 3), h3 = Ot(si, 3), u2 = Ot(si, 3), m4 = [0, 0, 0];
    e2.queryWeights(m4), hh(t4, m4, r2, h3, u2);
    const d3 = Ot(si, 3);
    d3[0].setDouble(s3.getSemiMinorAxis()), d3[0].sqrThis(), d3[1].setDouble(s3.getSemiMajorAxis()), d3[1].sqrThis(), d3[2].setThis(d3[0]), d3[2].mulThis(d3[1]), d3[2].negateThis();
    const _ = qn(r2, 2, h3, 2, u2, 2, d3, true, x2.unit(), x2.unit(), l2, a2);
    if (_ > 0) {
      let t5 = 0;
      for (let n7 = 0; n7 < _; n7++) {
        const i4 = new mi();
        e2.queryCoord2D(l2[n7], i4);
        const r3 = s3.getClosestCoordinate(i4, false), a3 = new mi();
        s3.queryCoord2D(r3, a3);
        mi.distance(i4, a3) <= o && (l2[t5] = l2[n7], c.push(r3), t5++);
      }
      l2.length = t5;
    }
  }
  const d2 = [0, 1];
  for (let _ = 0; _ < 2; _++) {
    const t4 = 0 === _ ? s3.getStartXY() : s3.getEndXY(), n6 = Ra(e2, t4, x2.unit(), false, -1), i3 = new mi();
    e2.queryCoord2D(n6, i3);
    mi.distance(t4, i3) <= o && (l2.push(n6), c.push(d2[_]));
  }
  for (let _ = 0; _ < 2; _++) {
    const t4 = [0, 3];
    {
      const e3 = s3.getClosestCoordinate(g2[t4[_]], false), n6 = new mi();
      s3.queryCoord2D(e3, n6);
      mi.distance(g2[t4[_]], n6) <= o && (l2.push(d2[_]), c.push(e3));
    }
  }
  return cm(t3, e2, s3, l2, c, l2.length, n5, i2, r, o, a2, h2, u);
}
function rh(t3, e2, s3, i2, r, o, a2, h2, u, m3) {
  const l2 = Ot(mi, 3);
  e2.queryControlPoints(l2);
  const c = Ot(mi, 3);
  if (s3.queryControlPoints(c), Ke(l2, c, 3) < 0) return rh(t3, s3, e2, i2, o, r, a2, h2, u, !m3);
  const g2 = Oe(e2, s3);
  if (e2.isDegenerateToLineHelper(g2)) {
    const n5 = new pm({ start: e2.getStartXY(), end: e2.getEndXY() }), l3 = nh(t3, s3, n5, i2, o, r, a2, h2, u, !m3);
    if (r) for (let t4 = 0; t4 < l3; ++t4) {
      const s4 = n5.getCoord2D(r[t4]);
      r[t4] = e2.getClosestCoordinate(s4, false);
    }
    return l3;
  }
  if (s3.isDegenerateToLineHelper(g2)) {
    const n5 = new pm({ start: s3.getStartXY(), end: s3.getEndXY() }), l3 = nh(t3, e2, n5, i2, r, o, a2, h2, u, m3);
    if (o) for (let t4 = 0; t4 < l3; ++t4) {
      const e3 = n5.getCoord2D(o[t4]);
      o[t4] = s3.getClosestCoordinate(e3, false);
    }
    return l3;
  }
  if (Qe(e2, s3, a2 = Math.max(a2, g2))) return 0;
  const d2 = Yt(3, Number.NaN);
  e2.queryWeights(d2);
  const _ = Yt(3, Number.NaN);
  s3.queryWeights(_);
  const p3 = [1, fh(d2), 1], f3 = [1, fh(_), 1], P5 = new x2(0, 1), y2 = new x2(0, 1);
  {
    const t4 = pe.constructEmpty();
    Wa(l2, p3, new x2(0, 1), t4);
    const e3 = pe.constructEmpty();
    Wa(c, f3, new x2(0, 1), e3);
    const s4 = Math.max(t4.maxDim(), e3.maxDim());
    if (t4.inflate(3 * a2), e3.inflate(3 * a2), !t4.intersectW(e3)) return 0;
    if (t4.maxDim() < 0.1 * s4) {
      if (ph(l2, p3, t4, P5), ph(c, f3, t4, y2), P5.isEmpty() || y2.isEmpty()) return 0;
      Qa(l2, p3, P5.vmin, P5.vmax, l2, p3), Qa(c, f3, y2.vmin, y2.vmax, c, f3);
    }
  }
  const x4 = dm(l2, 2, c, 2, a2);
  if (0 === x4) return 0;
  const C3 = [], v3 = [];
  if (-1 === x4) {
    const t4 = Ot(si, 3), e3 = Ot(si, 3), s4 = Ot(si, 3);
    hh(l2, p3, t4, e3, s4);
    const n5 = Ot(si, 3), i3 = Ot(si, 3), r2 = Ot(si, 3);
    hh(c, f3, n5, i3, r2);
    const o2 = [], g3 = [], d3 = Yn(t4, 2, e3, 2, s4, 2, n5, 2, i3, 2, r2, 2, true, x2.unit(), x2.unit(), o2, g3, h2, u, m3);
    if (d3 > 0) for (let h3 = 0; h3 < d3; h3++) {
      const t5 = new mi();
      _h(c, f3, g3[h3], t5);
      const e4 = new mi();
      _h(l2, p3, o2[h3], e4);
      mi.distance(e4, t5) <= a2 && (C3.push(o2[h3]), v3.push(g3[h3]));
    }
  }
  for (let b2 = 0; b2 < 2; b2++) {
    let t4, e3, s4;
    0 === b2 ? (t4 = l2, e3 = c, s4 = f3) : (t4 = c, e3 = l2, s4 = p3);
    for (let i3 = 0; i3 < 2; i3++) {
      const r2 = 0 === i3 ? 0 : t4.length - 1, o2 = new mi(), h3 = [0], u2 = za(e3, s4, t4[r2], x2.unit(), false, -1, 1, h3);
      n(1 === u2), _h(e3, s4, h3[0], o2), mi.distance(t4[r2], o2) <= a2 && (0 === b2 ? (C3.push(0 === r2 ? 0 : 1), v3.push(h3[0])) : (v3.push(0 === r2 ? 0 : 1), C3.push(h3[0])));
    }
  }
  if (0 === C3.length) return 0;
  if (!P5.equalsRange(0, 1)) for (let n5 = 0; n5 < C3.length; ++n5) C3[n5] = Sn.recalculateParentT(P5.vmin, P5.vmax, C3[n5]);
  if (!y2.equalsRange(0, 1)) for (let n5 = 0; n5 < v3.length; ++n5) v3[n5] = Sn.recalculateParentT(y2.vmin, y2.vmax, v3[n5]);
  for (let n5 = 0; n5 < C3.length; ++n5) C3[n5] = Ph(d2, C3[n5]);
  for (let n5 = 0; n5 < v3.length; ++n5) v3[n5] = Ph(_, v3[n5]);
  return cm(t3, e2, s3, C3, v3, C3.length, i2, r, o, a2, h2, u, m3);
}
function oh(t3, e2, s3, n5, i2, r, o, a2, h2, u) {
  if (e2.isLine()) {
    return Vi(t3, s3, new pm({ start: e2.getStartXY(), end: e2.getEndXY() }), n5, r, i2, o, a2, h2, !u);
  }
  if (s3.isLine()) {
    return nh(t3, e2, new pm({ start: s3.getStartXY(), end: s3.getEndXY() }), n5, i2, r, o, a2, h2, u);
  }
  const m3 = Oe(e2, s3);
  if (Qe(e2, s3, o = Math.max(o, m3))) return 0;
  const l2 = Ot(mi, 3);
  e2.queryControlPoints(l2);
  const c = Ot(mi, 3);
  s3.queryControlPoints(c);
  const g2 = dm(l2, 2, c, 2, o);
  if (0 === g2) return 0;
  const d2 = [], _ = [];
  if (-1 === g2) {
    const t4 = Ot(si, 3), n6 = Ot(si, 3), i3 = Ot(si, 3), r2 = [0, 0, 0];
    e2.queryWeights(r2), hh(l2, r2, t4, n6, i3);
    const m4 = Ot(Ee, 3);
    Wi(c, m4);
    const g3 = Yn(t4, 2, n6, 2, i3, 2, [m4[0].x, m4[1].x, m4[2].x], 2, [m4[0].y, m4[1].y, m4[2].y], 2, null, 0, true, x2.unit(), x2.unit(), d2, _, a2, h2, u);
    if (g3 > 0) {
      let t5 = 0;
      for (let n7 = 0; n7 < g3; n7++) {
        const i4 = new mi();
        s3.queryCoord2D(_[n7], i4);
        const r3 = new mi();
        e2.queryCoord2D(d2[n7], r3), mi.distance(r3, i4) <= o && (d2[t5] = d2[n7], _[t5] = _[n7], t5++);
      }
      d2.length = t5, _.length = t5;
    }
  }
  for (let p3 = 0; p3 < 2; p3++) {
    let t4;
    t4 = 0 === p3 ? l2 : c;
    for (let n6 = 0; n6 < 2; n6++) {
      const i3 = 0 === n6 ? 0 : t4.length - 1;
      let r2;
      const a3 = new mi();
      0 === p3 ? (r2 = Ci(s3, t4[i3], x2.unit(), false), s3.queryCoord2D(r2, a3)) : (r2 = Ra(e2, t4[i3], x2.unit(), false, -1), e2.queryCoord2D(r2, a3)), mi.distance(t4[i3], a3) <= o && (0 === p3 ? (d2.push(0 === i3 ? 0 : 1), _.push(r2)) : (_.push(0 === i3 ? 0 : 1), d2.push(r2)));
    }
  }
  return cm(t3, e2, s3, d2, _, d2.length, n5, i2, r, o, a2, h2, u);
}
function ah(t3, e2, s3, n5 = false) {
  const i2 = Ot(mi, 3);
  n5 ? (i2[0].setCoordsPoint2D(t3[0]), i2[1].setCoordsPoint2D(t3[1]), i2[1].subThis(i2[0]), i2[2].setCoordsPoint2D(t3[2]), i2[2].subThis(i2[0]), i2[0].setCoords(0, 0)) : (i2[0].setCoordsPoint2D(t3[0]), i2[1].setCoordsPoint2D(t3[1]), i2[2].setCoordsPoint2D(t3[2])), i2[0].mulThis(e2[0]), i2[1].mulThis(e2[1]), i2[2].mulThis(e2[2]), s3[1].setCoords(i2[1].x - i2[0].x, i2[1].y - i2[0].y), s3[2].setCoordsPoint2D(i2[2].sub(i2[1])), s3[2].subThis(s3[1]), s3[1].x *= 2, s3[1].y *= 2, s3[0].setCoordsPoint2D(i2[0]);
}
function hh(t3, e2, s3, n5, i2) {
  const r = si.constructDouble(e2[0]), o = si.constructDouble(e2[1]), a2 = si.constructDouble(e2[2]);
  s3[0].setDouble(t3[0].x), s3[0].mulThis(r), s3[1].setDouble(t3[1].x), s3[1].mulThis(o), s3[2].setDouble(t3[2].x), s3[2].mulThis(a2), s3[2].subThis(s3[1]), s3[1].subThis(s3[0]), s3[2].subThis(s3[1]), s3[1].ldexpThis(1), n5[0].setDouble(t3[0].y), n5[0].mulThis(r), n5[1].setDouble(t3[1].y), n5[1].mulThis(o), n5[2].setDouble(t3[2].y), n5[2].mulThis(a2), n5[2].subThis(n5[1]), n5[1].subThis(n5[0]), n5[2].subThis(n5[1]), n5[1].ldexpThis(1), i2[0].setDouble(e2[0]), i2[1].setDouble(e2[1]), i2[2].setThis(i2[1]), i2[2].ldexpThis(1), i2[2].negateThis(), i2[2].addThis(i2[0]), i2[2].addDoubleThis(e2[2]), i2[1].subThis(i2[0]), i2[1].ldexpThis(1);
}
function uh(t3, e2, s3) {
  for (let n5 = 0; n5 < 3; ++n5) s3[n5].setCoordsPoint2DZ(t3[n5].mul(e2[n5]), e2[n5]);
}
function mh(t3, e2, s3, n5) {
  if (0 === s3) return n5.assign(t3[0]), e2[0];
  if (1 === s3) return n5.assign(t3[2]), e2[2];
  const i2 = [t3[0].x * e2[0], t3[1].x * e2[1], t3[2].x * e2[2]], r = [t3[0].y * e2[0], t3[1].y * e2[1], t3[2].y * e2[2]], o = [e2[0], e2[1], e2[2]], a2 = s3;
  let h2, u, m3;
  if (s3 <= 0.5) {
    const t4 = V(i2[0], i2[1], a2), e3 = V(i2[1], i2[2], a2);
    h2 = Q(t4, e3, a2);
    const s4 = V(r[0], r[1], a2), n6 = V(r[1], r[2], a2);
    u = Q(s4, n6, a2);
    const l2 = V(o[0], o[1], a2), c = V(o[1], o[2], a2);
    m3 = V(l2, c, a2);
  } else {
    const t4 = U2(i2[0], i2[1], a2), e3 = U2(i2[1], i2[2], a2);
    h2 = U2(t4, e3, a2);
    const s4 = U2(r[0], r[1], a2), n6 = U2(r[1], r[2], a2);
    u = U2(s4, n6, a2);
    const l2 = U2(o[0], o[1], a2), c = U2(o[1], o[2], a2);
    m3 = U2(l2, c, a2);
  }
  return h2 /= m3, u /= m3, n5.setCoords(h2, u), vh(t3, n5), m3;
}
function lh(t3, e2, s3) {
  const n5 = Ot(mi, 3);
  t3.queryControlPoints(n5);
  const i2 = [0, 0, 0];
  t3.queryWeights(i2);
  ch([ve.constructPoint2D(n5[0]), ve.constructPoint2D(n5[1]), ve.constructPoint2D(n5[2])], [new p2(i2[0]), new p2(i2[1]), new p2(i2[2])], e2, s3);
}
function ch(t3, e2, s3, n5) {
  if (0 === s3.value()) return void n5.setE(t3[0]);
  if (1 === s3.value()) return void n5.setE(t3[2]);
  const i2 = [t3[0].x.mulE(e2[0]), t3[1].x.mulE(e2[1]), t3[2].x.mulE(e2[2])], r = [t3[0].y.mulE(e2[0]), t3[1].y.mulE(e2[1]), t3[2].y.mulE(e2[2])], o = [e2[0].clone(), e2[1].clone(), e2[2].clone()], a2 = new p2(), h2 = new p2(), u = new p2();
  if (s3.value() <= 0.5) {
    const t4 = A2(i2[0], i2[1], s3), e3 = A2(i2[1], i2[2], s3);
    a2.setE(A2(t4, e3, s3));
    const n6 = A2(r[0], r[1], s3), m4 = A2(r[1], r[2], s3);
    h2.setE(A2(n6, m4, s3));
    const l2 = A2(o[0], o[1], s3), c = A2(o[1], o[2], s3);
    u.setE(A2(l2, c, s3));
  } else {
    const t4 = P2(i2[0], i2[1], s3), e3 = P2(i2[1], i2[2], s3);
    a2.setE(P2(t4, e3, s3));
    const n6 = P2(r[0], r[1], s3), m4 = P2(r[1], r[2], s3);
    h2.setE(P2(n6, m4, s3));
    const l2 = P2(o[0], o[1], s3), c = P2(o[1], o[2], s3);
    u.setE(P2(l2, c, s3));
  }
  a2.divThisE(u), h2.divThisE(u);
  const m3 = new mi(a2.value(), h2.value());
  vh([t3[0].value(), t3[1].value(), t3[2].value()], m3), n5.x.set(m3.x, a2.eps()), n5.y.set(m3.y, h2.eps());
}
function gh(t3, e2, s3, n5) {
  const i2 = s3.lte(ni) ? si.lerpLo : si.lerpHi, [r, o, a2] = [e2.map((e3, s4) => t3[s4].x.mul(e3)), e2.map((e3, s4) => t3[s4].y.mul(e3)), e2].map(([t4, e3, n6]) => i2(i2(t4, e3, s3), i2(e3, n6, s3), s3)), h2 = new mi(r.divThis(a2).value(), o.divThis(a2).value());
  vh(t3.map((t4) => t4.asPoint2D()), h2), n5.x = si.constructDouble(h2.x), n5.y = si.constructDouble(h2.y);
}
function dh(t3, e2) {
  return e2.setCoords(t3.x / t3.z, t3.y / t3.z), t3.z;
}
function _h(t3, e2, s3, n5, i2) {
  if (i2) {
    if (s3 < 0) {
      return void _s2(new pm({ start: t3[0], end: t3[0].add(wa(t3, e2, 0).getUnitVector()) }), s3, n5);
    }
    if (s3 > 1) {
      return void _s2(new pm({ start: t3[2], end: t3[2].add(wa(t3, e2, 1).getUnitVector()) }), s3 - 1, n5);
    }
  }
  mh(t3, e2, s3, n5);
}
function ph(t3, e2, s3, n5) {
  n5.setEmpty();
  const i2 = [];
  i2.push(new x2(0, 1));
  const r = 0.5 * Math.max(s3.width(), s3.height());
  for (; i2.length; ) {
    const o = i2.at(-1);
    i2.pop();
    const a2 = new pe();
    if (Wa(t3, e2, o, a2), a2.isIntersectingW(s3)) {
      const t4 = Math.max(a2.width(), a2.height());
      if (s3.containsW(a2) || t4 <= r || o.width() < 1e-12) n5.merge(o);
      else {
        const t5 = o.getCenter();
        i2.push(x2.construct(o.vmin, t5)), i2.push(x2.construct(t5, o.vmax));
      }
    }
  }
}
function fh(t3) {
  return t3[1] / Math.sqrt(t3[0] * t3[2]);
}
function Ph(t3, e2) {
  const s3 = Math.sqrt(t3[2] / t3[0]);
  return e2 / Q(s3, 1, e2);
}
function yh(t3, e2) {
  const s3 = Math.sqrt(t3[0] / t3[2]);
  return e2 / Q(s3, 1, e2);
}
function xh(t3, e2, s3, i2) {
  n(e2 >= 0 && e2 <= 1);
  new X().setCoordsPoint3D(t3[0]);
  new X().setCoordsPoint3D(t3[1]);
  new X().setCoordsPoint3D(t3[2]);
  const r = new X(), o = new X(), a2 = new X();
  L2(3, t3[0], t3[1], e2, r), L2(3, t3[1], t3[2], e2, o), L2(3, r, o, e2, a2);
  const h2 = t3[2].clone();
  s3 && (s3[0].assign(t3[0]), s3[1].assign(r), s3[2].assign(a2)), i2 && (i2[0].assign(a2), i2[1].assign(o), i2[2].assign(h2));
}
function Ch(t3, e2, s3, i2) {
  const r = [t3[0], t3[1], t3[2]];
  n(e2 >= 0 && e2 <= 1 && s3 !== i2);
  const o = Q(r[0], r[1], e2), a2 = Q(r[1], r[2], e2), h2 = Q(o, a2, e2);
  s3 && (s3[0] = r[0], s3[1] = o, s3[2] = h2), i2 && (i2[0] = h2, i2[1] = a2, i2[2] = r[2]);
}
function vh(t3, e2) {
  const s3 = x2.constructEmpty();
  s3.vmin = s3.vmax = t3[0].x, s3.mergeNeCoordinate(t3[1].x), s3.mergeNeCoordinate(t3[2].x), e2.x = Us(e2.x, s3.vmin, s3.vmax), s3.vmin = s3.vmax = t3[0].y, s3.mergeNeCoordinate(t3[1].y), s3.mergeNeCoordinate(t3[2].y), e2.y = Us(e2.y, s3.vmin, s3.vmax);
}
function bh(t3, e2) {
  const s3 = new x2();
  s3.vmin = s3.vmax = t3[0].x, s3.mergeNeCoordinate(t3[1].x), s3.mergeNeCoordinate(t3[2].x), e2[0].x = Us(e2[0].x, s3.vmin, s3.vmax), e2[1].x = Us(e2[1].x, s3.vmin, s3.vmax), e2[2].x = Us(e2[2].x, s3.vmin, s3.vmax), s3.vmin = s3.vmax = t3[0].y, s3.mergeNeCoordinate(t3[1].y), s3.mergeNeCoordinate(t3[2].y), e2[0].y = Us(e2[0].y, s3.vmin, s3.vmax), e2[1].y = Us(e2[1].y, s3.vmin, s3.vmax), e2[2].y = Us(e2[2].y, s3.vmin, s3.vmax);
}
var Eh = Jt / 180;
var Sh = 180 / Jt;
function Dh(t3) {
  let e2 = t3;
  return e2 >= -360 && e2 < 720 ? (e2 < 0 ? e2 += 360 : e2 >= 360 && (e2 -= 360), e2) : (e2 = ct(e2, 360), e2 < 0 && (e2 += 360), e2);
}
function wh(t3) {
  let e2 = t3;
  return e2 = Dh(e2), e2 > 180 && (e2 -= 360), e2;
}
function Ah(t3) {
  return t3 * Eh;
}
function Th(t3) {
  return t3 * Sh;
}
function Ih(t3) {
  const e2 = $s();
  let s3 = t3;
  return s3 >= -e2 && s3 < 2 * e2 ? (s3 < 0 && (s3 += e2), s3 >= e2 && (s3 -= e2), s3) : (s3 = ct(s3, e2), s3 < 0 && (s3 += e2), s3);
}
function Mh(t3) {
  const e2 = Hs();
  let s3 = t3;
  return s3 > -e2 && s3 <= e2 || (s3 = Ih(s3), s3 > e2 && (s3 -= $s())), s3;
}
function Yh(t3, e2) {
  return wh(e2 - t3);
}
var Nh = z3;
var Xh = class _Xh extends gs {
  constructor(t3) {
    if (void 0 === t3 || jt(t3, "vd")) return super({ vd: t3?.vd, XStart: 0, YStart: 0, XEnd: 0, YEnd: 0 }), this.m_semiMajorAxis = 0, this.m_minorMajorRatio = 1, this.m_rotation = 0, this.m_cosr = 1, this.m_sinr = 0, this.m_center = new mi(0, 0), this.m_sweepAngle = 0, this.m_startAngle = 0, this.m_interior = new mi(0, 0), void (this.m_bits = 0);
    if (t3.copy) return super(t3), void (this !== t3.copy && (this.m_center = new mi(0, 0), this.m_interior = new mi(0, 0), t3.copy.copyToImpl(this)));
    if (t3.move) super(t3), this.m_semiMajorAxis = t3.move.m_semiMajorAxis, this.m_minorMajorRatio = t3.move.m_minorMajorRatio, this.m_rotation = t3.move.m_rotation, this.m_cosr = t3.move.m_cosr, this.m_sinr = t3.move.m_sinr, this.m_center = t3.move.m_center.clone(), this.m_sweepAngle = t3.move.m_sweepAngle, this.m_startAngle = t3.move.m_startAngle, this.m_interior = t3.move.m_interior.clone(), this.m_bits = t3.move.m_bits, this.m_cachedValues = t3.move.m_cachedValues, t3.move.m_cachedValues = null;
    else {
      if (t3.fromPoint) return super({ XStart: 0, YStart: 0, XEnd: 0, YEnd: 0 }), this.m_center = new mi(0, 0), this.m_interior = new mi(0, 0), void this.constructCircularArcThreePoint(t3.fromPoint, t3.toPoint, t3.interiorPoint);
      if (t3.center) return super({ XStart: 0, YStart: 0, XEnd: 0, YEnd: 0 }), this.m_center = new mi(0, 0), this.m_interior = new mi(0, 0), void this.constructCircleRadius(t3.radius, t3.center, t3.bIsCounterClockwise);
      if (t3.semiMajorAxis) return super({ XStart: 0, YStart: 0, XEnd: 0, YEnd: 0 }), void this.constructEllipticArcEndPoints(t3.fromPoint, t3.toPoint, t3.semiMajorAxis, t3.minorMajorRatio, t3.axisXRotationRad, t3.bBigArc, t3.bIsCounterClockwise);
    }
  }
  getBoundary() {
    return Js2(this);
  }
  assignCopy(t3) {
    return this !== t3 && t3.copyTo(this), this;
  }
  constructCircleRadius(t3, e2, s3 = false) {
    return this.constructEllipse(t3, 1, e2, 0, s3), this.setProjectionBehavior(0), this.afterCompletedModification(), this;
  }
  constructCircleCenterAndPoint(t3, e2, s3 = false) {
    const n5 = mi.distance(t3, e2);
    return this.constructEllipticArcEndPointsCenter(e2, e2, n5, 1, 0, true, s3, t3), this.setProjectionBehavior(0), this.afterCompletedModification(), this;
  }
  constructTwoPointCircle(t3, e2, s3 = false) {
    const n5 = mi.lerp(t3, e2, 0.5);
    return this.constructCircleCenterAndPoint(n5, t3, s3), this;
  }
  constructLineEllipticArc(t3, e2) {
    return bu(this, t3, e2, 1), this;
  }
  constructLineCircularArc(t3, e2) {
    return bu(this, t3, e2, 0), this;
  }
  constructEllipse(t3, e2, s3, n5, i2 = false) {
    this.m_semiMajorAxis = Math.abs(t3), this.m_minorMajorRatio = Math.abs(e2), this.m_minorMajorRatio > 1 && (this.m_semiMajorAxis *= this.m_minorMajorRatio, this.m_minorMajorRatio = 1 / this.m_minorMajorRatio);
    const r = new mi(0, this.m_minorMajorRatio * this.m_semiMajorAxis), o = Math.cos(n5), a2 = Math.sin(n5);
    return r.rotateDirect(o, a2), r.addThis(s3), this.constructEllipticArcEndPointsCenter(r, r, this.m_semiMajorAxis, this.m_minorMajorRatio, n5, true, i2, s3), this;
  }
  inflate(t3) {
    if (this.isDegenerateToLine()) return;
    let e2 = this.getSemiMinorAxis() + t3;
    if (e2 = e2 <= 0 ? 0 : (this.getSemiMajorAxis() + t3) / this.getSemiMajorAxis(), this.isCircular()) {
      const t4 = new x3();
      t4.setShiftCoords(-this.m_center.x, -this.m_center.y), t4.scale(e2, e2), t4.shiftCoords(this.m_center.x, this.m_center.y), this.applyTransformation(t4);
    } else {
      const t4 = new x3();
      this.canonicToWorldTransformation(t4);
      const s3 = t4.clone();
      s3.invertPreciseThis(), s3.scale(e2, e2), s3.multiply(t4), this.applyTransformation(s3);
    }
  }
  constructEnclosingCircle(t3, e2, s3 = false) {
    return ju(this, t3, e2, s3), this;
  }
  constructThreePointCircle(t3, e2, s3, n5 = false) {
    if (t3.equals(e2) || e2.equals(s3) || t3.equals(s3)) {
      const i2 = t3.clone(), r = e2.clone(), o = s3.clone();
      return i2.equals(r) && r.assign(o), this.constructTwoPointCircle(i2, r, n5);
    }
    {
      const i2 = mi.calculateCircleCenterFromThreePoints(t3, e2, s3);
      if (!i2.isFinite() || !Number.isFinite(mi.distance(t3, i2))) {
        const n6 = mi.distance(t3, e2), i3 = mi.distance(t3, s3);
        this.constructLineCircularArc(t3, n6 >= i3 ? e2 : s3);
      }
      return this.constructCircleCenterAndPoint(i2, t3, n5);
    }
  }
  constructCircularArcThreePoint(t3, e2, s3) {
    const n5 = new p2(t3.x), i2 = new p2(e2.x), r = new p2(s3.x), o = new p2(t3.y), a2 = new p2(e2.y), h2 = new p2(s3.y), u = new p2(0.5), m3 = i2.subE(n5), l2 = a2.subE(o), c = r.subE(n5), g2 = h2.subE(o), d2 = m3.mulE(g2).subThisE(l2.mulE(c));
    if (d2.scaleError(10), d2.isZero()) {
      if (!m3.isZero() || !l2.isZero()) return bu(this, t3, e2, 0), this;
      {
        const n6 = t3.clone().addThis(e2).mulThis(0.5).addThis(s3).mulThis(0.5), i3 = s3.sub(n6).length();
        this.constructEllipticArcEndPointsCenter(t3, e2, i3, 1, 0, true, false, n6), this.m_interior.assign(s3);
      }
      return this.setProjectionBehavior(0), this;
    }
    const _ = m3.sqr().addThisE(l2.sqr()).mulThisE(u), p3 = c.sqr().addThisE(g2.sqr()).mulThisE(u), f3 = _.mulE(g2).subThisE(p3.mulE(l2)), P5 = m3.mulE(p3).subThisE(c.mulE(_));
    f3.divThisE(d2), P5.divThisE(d2);
    const y2 = f3.sqr().addThisE(P5.sqr());
    y2.sqrtThis();
    const x4 = f3.addE(n5), C3 = P5.addE(o);
    let v3 = t3.x - x4.value(), b2 = t3.y - C3.value();
    const E2 = Math.atan2(b2, v3);
    v3 = e2.x - x4.value(), b2 = e2.y - C3.value();
    const S3 = Math.atan2(b2, v3);
    v3 = s3.x - x4.value(), b2 = s3.y - C3.value();
    const D3 = Math.atan2(b2, v3);
    let w4 = D3 - 2 * Hs();
    for (; w4 < E2; ) w4 += 2 * Hs();
    let A4 = S3 - 2 * Hs();
    for (; A4 < w4; ) A4 += 2 * Hs();
    let T3 = D3 + 2 * Hs();
    for (; T3 > E2; ) T3 -= 2 * Hs();
    let I4, M2 = S3 + 2 * Hs();
    for (; M2 > T3; ) M2 -= 2 * Hs();
    I4 = A4 - E2 < E2 - M2 ? A4 - E2 : M2 - E2;
    const Y3 = new mi(x4.value(), C3.value());
    return this.constructEllipticArcEndPointsCenter(t3, e2, y2.value(), 1, 0, Math.abs(I4) > Hs(), I4 > 0, Y3), this.m_interior.assign(s3), this.setProjectionBehavior(0), this.afterCompletedModification(), this;
  }
  constructCircularArc(t3, e2, s3, n5) {
    return this.constructEllipticArcGeneral(t3, 1, e2, s3, n5, 0), this.setProjectionBehavior(0), this.afterCompletedModification(), this;
  }
  constructEllipticArcEndPoints(t3, e2, s3, n5, i2, r, o) {
    return vu(this, t3, e2, s3, n5, i2, r, o);
  }
  constructEllipticArcEndPointsCenter(t3, e2, s3, n5, i2, r, o, a2) {
    return vu(this, t3, e2, s3, n5, i2, r, o, a2);
  }
  constructEllipticArcGeneral(t3, e2, s3, n5, i2, r) {
    this.m_semiMajorAxis = Math.abs(t3), this.m_minorMajorRatio = Math.abs(e2), this.m_minorMajorRatio > 1 && (this.m_semiMajorAxis *= this.m_minorMajorRatio, this.m_minorMajorRatio = 1 / this.m_minorMajorRatio);
    const o = Mh(r), a2 = Math.cos(o), h2 = Math.sin(o), u = new mi(this.m_semiMajorAxis, this.m_minorMajorRatio * this.m_semiMajorAxis), m3 = mi.getNAN(), l2 = Mh(n5);
    m3.x = u.x * Math.cos(l2), m3.y = u.y * Math.sin(l2), m3.rotateDirect(a2, h2), m3.addThis(s3);
    const c = js(i2, $s());
    let g2 = c;
    Math.abs(g2) === $s() && (g2 = 0);
    const d2 = mi.getNAN();
    return d2.x = u.x * Math.cos(l2 + g2), d2.y = u.y * Math.sin(l2 + g2), d2.rotateDirect(a2, h2), d2.addThis(s3), this.constructEllipticArcEndPointsCenter(m3, d2, this.m_semiMajorAxis, this.m_minorMajorRatio, o, Math.abs(c) > Hs(), c > 0, s3);
  }
  constructEllipticArcAsNURB(e2, s3, n5, i2) {
    (i2 >= 1 || i2 < 0) && P("construct_elliptic_arc_as_NURB: weight"), s3.isFinite() || P("construct_elliptic_arc_as_NURB: control_point");
    return ku([e2, s3, n5], i2 * i2, null, false, this), this;
  }
  constructCanonic(t3) {
    return this.assignCopy(t3), t3.isDegenerateToLine() || t3.m_center.isEqual(0, 0) && 0 === this.m_rotation || (this.m_XStart = t3.getSemiMajorAxis() * Math.cos(t3.m_startAngle), this.m_YStart = t3.getSemiMinorAxis() * Math.sin(t3.m_startAngle), this.m_XEnd = t3.getSemiMajorAxis() * Math.cos(t3.getEndAngle()), this.m_YEnd = t3.getSemiMinorAxis() * Math.sin(t3.getEndAngle()), this.m_center.setCoords(0, 0), this.m_rotation = 0, this.m_cosr = 1, this.m_sinr = 0, Hu(this), this.afterCompletedModification(), t3 !== this && Ze(this, t3)), this;
  }
  isCircular() {
    return 1 === this.m_minorMajorRatio && 0 === this.m_rotation && !this.isDegenerateToLine();
  }
  isDegenerateToLineHelper(t3) {
    if (this.isLine()) return true;
    if (this.isMajor()) return false;
    const e2 = this.getEndXY().sub(this.getStartXY()).length();
    return !(this.calculateLength2D() - e2 > t3);
  }
  isDegenerateToLine() {
    return Eu(this);
  }
  getCenter() {
    return this.m_center.clone();
  }
  setCenter(t3) {
    if (!this.m_center.isNAN()) {
      const e2 = t3.sub(this.m_center);
      this.m_XStart += e2.x, this.m_YStart += e2.y, this.m_XEnd += e2.x, this.m_YEnd += e2.y, this.m_interior.addThis(e2), this.m_center.assign(t3), this.endPointModified(), this.normalizeAfterEndpointChange();
    }
  }
  getAxisXRotation() {
    return this.m_rotation;
  }
  getSemiAxes() {
    return mi.construct(this.m_semiMajorAxis, this.m_semiMajorAxis * this.m_minorMajorRatio);
  }
  getSemiMajorAxis() {
    return this.m_semiMajorAxis;
  }
  getSemiMinorAxis() {
    return this.m_semiMajorAxis * this.m_minorMajorRatio;
  }
  getMinorMajorRatio() {
    return this.m_minorMajorRatio;
  }
  isClockwise() {
    return !Xu(this);
  }
  isMajor() {
    return Fu(this);
  }
  getSweepAngle() {
    return this.m_sweepAngle;
  }
  getStartAngle() {
    return this.m_startAngle;
  }
  getEndAngle() {
    return this.m_startAngle + this.m_sweepAngle;
  }
  getGeometryType() {
    return a.enumEllipticArc;
  }
  queryEnvelope(t3) {
    if (4 === t3.m_EnvelopeType) {
      t3.setEmpty(), t3.assignVertexDescription(this.m_description);
      const e2 = n3.constructEmpty();
      this.queryEnvelope(e2), t3.setEnvelope(e2);
      for (let s3 = 1, n5 = this.m_description.getAttributeCount(); s3 < n5; s3++) {
        const e3 = this.m_description.getSemantics(s3);
        for (let n6 = 0, i2 = Nh.getComponentCount(e3); s3 < i2; s3++) {
          const s4 = this.queryInterval(e3, n6);
          t3.setIntervalEnvelope(e3, n6, s4);
        }
      }
    } else 2 === t3.m_EnvelopeType ? Ju(this, x2.unit(), t3) : z("3d not impl");
  }
  applyTransformation(t3) {
    Au(this, t3, false, null, null);
  }
  createInstance() {
    return new _Xh();
  }
  calculateLength2D() {
    return pu(this, 0, 1);
  }
  queryControlPointsHelper(t3) {
    b("");
  }
  queryCoord2D(t3, e2) {
    if (Eu(this)) ps(t3, this.getStartXY(), this.getEndXY(), e2);
    else if (0 === t3) e2.assign(mi.construct(this.m_XStart, this.m_YStart));
    else if (1 === t3) e2.assign(mi.construct(this.m_XEnd, this.m_YEnd));
    else {
      const s3 = cu(this, t3), n5 = new mi(this.m_semiMajorAxis * Math.cos(s3), this.getSemiMinorAxis() * Math.sin(s3));
      n5.rotateDirect(this.m_cosr, this.m_sinr), n5.addThis(this.m_center), e2.assign(n5);
    }
  }
  queryCoord2DE(t3, e2) {
    nu(this, t3, e2);
  }
  queryCoord2DMP(t3, e2) {
    z("");
  }
  getCoordX(t3) {
    const e2 = new mi();
    return this.queryCoord2D(t3, e2), e2.x;
  }
  getCoordY(t3) {
    const e2 = new mi();
    return this.queryCoord2D(t3, e2), e2.y;
  }
  cut(t3, e2, s3) {
    const n5 = new fm();
    return this.queryCut(t3, e2, n5, s3), n5.releaseSegment();
  }
  queryCut(t3, e2, s3, n5) {
    const i2 = s3.createEllipticArc();
    n5 && i2.dropAllAttributes();
    let r = 0 === t3 && 1 === e2;
    if (r && !n5) return void this.copyTo(i2);
    const o = mi.getNAN();
    this.queryCoord2D(t3, o);
    const a2 = mi.getNAN();
    if (this.queryCoord2D(e2, a2), !r) {
      if (o.equals(a2)) e2 - t3 > 0.5 && this.isMajor() && this.isClosed() ? (r = true, t3 = 0, e2 = 1) : 1 === e2 ? t3 = e2 : e2 = t3;
      else if (t3 > 0 && o.isEqual(this.m_XStart, this.m_YStart) && (t3 = 0), e2 < 1 && a2.isEqual(this.m_XEnd, this.m_YEnd) && (e2 = 1), r = 0 === t3 && 1 === e2, r && !n5) return void this.copyTo(i2);
    }
    if (i2.m_center.assign(this.m_center), i2.m_semiMajorAxis = this.m_semiMajorAxis, i2.m_minorMajorRatio = this.m_minorMajorRatio, i2.m_interior.assign(this.m_interior), i2.m_rotation = this.m_rotation, i2.m_cosr = this.m_cosr, i2.m_sinr = this.m_sinr, i2.m_sweepAngle = this.m_sweepAngle, i2.m_startAngle = this.m_startAngle, i2.m_bits = this.m_bits, qe(i2, o.x, o.y), Ve(i2, a2.x, a2.y), r) return void Iu(i2, fu(this));
    i2.m_startAngle = cu(this, t3), i2.m_sweepAngle = cu(this, e2) - i2.m_startAngle, i2.m_startAngle = au(i2.m_startAngle), qu(i2, Math.abs(i2.m_sweepAngle) > Hs()), n5 && i2.assignVertexDescription(this.m_description), Hu(i2), mu(i2);
    const h2 = this.m_description.getAttributeCount();
    if (h2 > 1 && !n5) {
      for (let e3 = 1; e3 < h2; e3++) {
        const s4 = this.m_description.getSemantics(e3), n6 = Nh.getComponentCount(s4);
        for (let e4 = 0; e4 < n6; e4++) {
          const n7 = this.getAttributeAsDbl(t3, s4, e4);
          i2.setStartAttribute(s4, e4, n7);
        }
      }
      for (let t4 = 1; t4 < h2; t4++) {
        const s4 = this.m_description.getSemantics(t4), n6 = Nh.getComponentCount(s4);
        for (let t5 = 0; t5 < n6; t5++) {
          const n7 = this.getAttributeAsDbl(e2, s4, t5);
          i2.setEndAttribute(s4, t5, n7);
        }
      }
    }
    i2.afterCompletedModification();
  }
  queryDerivative(t3, e2) {
    sm(this, t3, e2);
  }
  cutArcIgnoreAttributes(t3, e2, s3) {
    let n5 = 0 === t3 && 1 === e2;
    const i2 = new mi();
    this.queryCoord2D(t3, i2);
    const r = new mi();
    this.queryCoord2D(e2, r), n5 || (i2.equals(r) ? e2 - t3 > 0.5 && this.isMajor() && this.isClosed() ? (n5 = true, t3 = 0, e2 = 1) : 1 === e2 ? t3 = e2 : e2 = t3 : (t3 > 0 && i2.isEqual(this.m_XStart, this.m_YStart) && (t3 = 0), e2 < 1 && r.isEqual(this.m_XEnd, this.m_YEnd) && (e2 = 1), n5 = 0 === t3 && 1 === e2)), s3.m_center.assign(this.m_center), s3.m_semiMajorAxis = this.m_semiMajorAxis, s3.m_minorMajorRatio = this.m_minorMajorRatio, s3.m_interior.assign(this.m_interior), s3.m_rotation = this.m_rotation, s3.m_cosr = this.m_cosr, s3.m_sinr = this.m_sinr, s3.m_sweepAngle = this.m_sweepAngle, s3.m_startAngle = this.m_startAngle, s3.m_bits = this.m_bits, qe(s3, i2.x, i2.y), Ve(s3, r.x, r.y), n5 ? Iu(s3, fu(this)) : (s3.m_startAngle = cu(this, t3), s3.m_sweepAngle = cu(this, e2) - s3.m_startAngle, s3.m_startAngle = au(s3.m_startAngle), qu(s3, Math.abs(s3.m_sweepAngle) > Math.PI), Hu(s3), s3.afterCompletedModification());
  }
  changeEndPoints2D(t3, e2) {
    yu(this, t3, e2, false);
  }
  getAttributeAsDbl(t3, e2, s3) {
    if (0 === e2) return 0 === s3 ? this.getCoordX(t3) : this.getCoordY(t3);
    if (0 === t3) return this.getStartAttributeAsDbl(e2, s3);
    if (1 === t3) return this.getEndAttributeAsDbl(e2, s3);
    const n5 = this.calculateLength2D(), i2 = n5 > 0 ? this.tToLength(t3) / n5 : 0, r = Nh.getInterpolation(e2), o = this.getStartAttributeAsDbl(e2, s3), a2 = this.getEndAttributeAsDbl(e2, s3);
    return It(r, o, a2, i2, Nh.getDefaultValue(e2));
  }
  getClosestCoordinate(t3, e2) {
    return $u(this, t3, x2.unit(), e2);
  }
  getClosestCoordinateOnInterval(t3, e2, s3 = -1) {
    return $u(this, t3, e2, false);
  }
  getYMonotonicParts(e2, s3 = false) {
    e2.length < 2 && P("");
    const i2 = this.getSemiAxes(), r = Math.atan2(i2.y * this.m_cosr, i2.x * this.m_sinr), o = r + Hs(), a2 = Yt(3, Number.NaN);
    let h2 = 0;
    if (a2[0] = lu(this, r), a2[0] > 0 && a2[0] < 1 && h2++, a2[1] = lu(this, o), a2[1] > 0 && a2[1] < 1 && (a2[h2] = a2[1], h2++), 0 === h2) return 0;
    a2[h2] = 1, h2++, n(e2.length >= h2);
    let u = 0;
    for (let t3 = 0; t3 < h2; t3++) {
      const n5 = a2[t3];
      this.queryCut(u, n5, e2[t3], s3), u = n5;
    }
    return h2;
  }
  getMonotonicParts(e2, s3) {
    if (e2.length < 4 && P(""), this.isDegenerateToLine()) return e2[0].createEllipticArc().assignCopy(this), s3 && e2[0].get().dropAllAttributes(), 1;
    const i2 = this.getSemiAxes(), r = Yt(4, Number.NaN);
    r[0] = Math.atan2(i2.y * this.m_cosr, i2.x * this.m_sinr), r[1] = r[0] + Hs(), r[2] = Math.atan2(-i2.y * this.m_sinr, i2.x * this.m_cosr), r[3] = r[2] + Hs();
    const o = Yt(5, Number.NaN);
    let a2 = 0;
    for (let t3 = 0; t3 < 4; t3++) o[a2] = lu(this, r[t3]), o[a2] > 0 && o[a2] < 1 && a2++;
    if (0 === a2) return 0;
    zt(o, a2), o[a2 - 1] < 1 && (o[a2] = 1, a2++), n(e2.length >= a2);
    let h2 = 0;
    for (let t3 = 0; t3 < a2; t3++) {
      const n5 = o[t3];
      this.queryCut(h2, n5, e2[t3], s3), h2 = n5;
    }
    return a2;
  }
  intersectionWithAxis2D(t3, e2, s3, n5) {
    if (Eu(this)) {
      return new pm({ start: this.getStartXY(), end: this.getEndXY() }).intersectionWithAxis2D(t3, e2, s3, n5);
    }
    let i2, r;
    const o = new p2(e2), a2 = this.getSemiAxes();
    if (t3) {
      if (e2 > this.m_center.y + a2.x || e2 < this.m_center.y - a2.x) return 0;
      i2 = new p2(a2.x).mulThis(this.m_sinr), r = new p2(a2.y).mulThis(this.m_cosr), o.subThis(this.m_center.y);
    } else {
      if (e2 > this.m_center.x + a2.x || e2 < this.m_center.x - a2.x) return 0;
      i2 = new p2(a2.x).mulThis(this.m_cosr), r = new p2(a2.y).mulThis(-this.m_sinr), o.subThis(this.m_center.x);
    }
    const h2 = i2.sqr(), u = r.sqr(), m3 = h2.addE(u), l2 = r.mulE(o).mulThis(-2), c = o.sqr().subThisE(h2), g2 = l2.sqr().subThisE(m3.mulE(c).mulThis(4)), d2 = i2.mulE(o).mulThis(-2), _ = o.sqr().subThisE(u), p3 = d2.sqr().subThisE(m3.mulE(_).mulThis(4));
    let f3 = g2.eps() * Math.abs(p3.value()) <= p3.eps() * Math.abs(g2.value());
    f3 ? i2.isZero() && (f3 = false) : r.isZero() && (f3 = true), f3 || (l2.setE(d2), c.setE(_));
    const P5 = Ot(p2, 2);
    let y2 = gn(m3, l2, c, x2.construct(-1, 1), false, P5);
    if (0 === y2) return 0;
    const x4 = [0, 0];
    let C3 = 0;
    for (let v3 = 0; v3 < y2; v3++) {
      const t4 = new p2(), e3 = new p2();
      f3 ? (t4.setE(P5[v3]), e3.setE(o.subE(r.mulE(P5[v3])).divThisE(i2))) : (e3.setE(P5[v3]), t4.setE(o.subE(i2.mulE(P5[v3])).divThisE(r)));
      const s4 = lu(this, Math.atan2(t4.value(), e3.value()));
      s4 >= 0 && s4 <= 1 && (x4[C3] = s4, C3++);
    }
    return y2 = C3, 0 === y2 ? 0 : (2 === y2 && x4[0] > x4[1] && (x4[1] = Pt(x4[0], x4[0] = x4[1])), n5 && Dt(n5, x4, 0, 0, y2), s3 && (s3[0] = t3 ? this.getCoordX(x4[0]) : this.getCoordY(x4[0]), y2 > 1 && (s3[1] = t3 ? this.getCoordX(x4[1]) : this.getCoordY(x4[1]), !n5 && s3[0] > s3[1] && (s3[1] = Pt(s3[0], s3[0] = s3[1])))), y2);
  }
  intersectionOfYMonotonicWithAxisX(t3, e2) {
    if (this.m_YStart === this.m_YEnd) return t3 === this.m_YStart ? e2 : Number.NaN;
    if (t3 === this.m_YStart) return this.m_XStart;
    if (t3 === this.m_YEnd) return this.m_XEnd;
    const s3 = [0, 0];
    return -1 === this.intersectionWithAxis2D(true, t3, s3, null) ? e2 : s3[0];
  }
  isCurve() {
    return true;
  }
  isDegenerate(t3) {
    return Te(this, t3);
  }
  isDegenerate3D(t3, e2) {
    return n(0), false;
  }
  queryLooseEnvelope(t3) {
    3 !== t3.m_EnvelopeType ? this.queryLooseEnvelopeOnInterval(new x2(0, 1), t3) : z("3d not impl");
  }
  clone(t3) {
    const e2 = new _Xh();
    return this.copyTo(e2), e2;
  }
  queryInterval(t3, e2) {
    if (0 === t3) {
      if (Eu(this)) return 0 === e2 ? x2.construct(this.getStartX(), this.getEndX()) : x2.construct(this.getStartY(), this.getEndY());
      let t4;
      const s3 = this.getSemiAxes();
      t4 = 0 === e2 ? Math.atan2(-s3.y * this.m_sinr, s3.x * this.m_cosr) : Math.atan2(s3.y * this.m_cosr, s3.x * this.m_sinr);
      const n5 = t4 + Math.PI, i2 = [0, 0];
      i2[0] = lu(this, t4), i2[1] = lu(this, n5);
      const r = 0 === e2 ? x2.construct(this.getStartX(), this.getEndX()) : x2.construct(this.getStartY(), this.getEndY()), o = new mi();
      for (let a2 = 0; a2 < 2; a2++) {
        const t5 = i2[a2];
        t5 > 0 && t5 < 1 && (this.queryCoord2D(t5, o), r.mergeNeCoordinate(0 === e2 ? o.x : o.y));
      }
      return r;
    }
    return super.queryInterval(t3, e2);
  }
  queryLooseEnvelopeOnInterval(t3, e2) {
    const s3 = new x2(0, 1);
    if (s3.intersect(t3), s3.isEmpty()) return void e2.setEmpty();
    if (Eu(this)) return e2.setCoords(this.getCoord2D(s3.vmin)), void e2.mergeNe(this.getCoord2D(s3.vmax));
    const n5 = this.getCoord2D(s3.vmin), i2 = this.getCoord2D(s3.vmax);
    if (1 === this.m_minorMajorRatio && Math.abs(this.m_sweepAngle) * s3.width() <= Wt) {
      let t4 = mi.lerp(n5, i2, 0.5);
      const s4 = t4.sub(this.m_center);
      return s4.normalize(), t4 = t4.add(s4.mul(0.5 * mi.distance(n5, i2))), e2.setCoords(n5), e2.mergeNe(i2), void e2.mergeNe(t4);
    }
    Ju(this, s3, e2);
  }
  tToLength(t3) {
    return Eu(this) ? t3 * mi.distance(this.getStartXY(), this.getEndXY()) : 1 === this.m_minorMajorRatio ? Math.abs(this.getSweepAngle() * t3) * this.m_semiMajorAxis : Su(this, t3);
  }
  parametricAngleToT(t3) {
    return lu(this, t3);
  }
  tToParametricAngle(t3) {
    return cu(this, t3);
  }
  lengthToT(t3) {
    if (Eu(this)) {
      const e2 = mi.distance(this.getStartXY(), this.getEndXY());
      return 0 === e2 ? 0 : t3 / e2;
    }
    if (1 === this.m_minorMajorRatio) {
      const e2 = Math.abs(this.getSweepAngle()) * this.m_semiMajorAxis;
      return 0 === e2 ? 0 : t3 / e2;
    }
    return Du(this, t3);
  }
  calculateWeightedAreaCentroid2D(t3) {
    if (Eu(this)) {
      const t4 = new mi();
      return t4.setCoords(0, 0), t4;
    }
    const e2 = Zu(this), s3 = this.getStartXY().sub(this.m_center), n5 = this.getEndXY().sub(this.m_center), i2 = this.m_semiMajorAxis, r = this.getSemiMinorAxis(), o = this.m_startAngle + this.m_sweepAngle, a2 = new mi();
    a2.x = i2 * r * (i2 * this.m_cosr * (-Math.sin(o) + Math.sin(this.m_startAngle)) + r * (-Math.cos(o) + Math.cos(this.m_startAngle)) * this.m_sinr) / 3, a2.y = i2 * r * (r * (Math.cos(o) - Math.cos(this.m_startAngle)) * this.m_cosr + i2 * (-Math.sin(o) + Math.sin(this.m_startAngle)) * this.m_sinr) / 3;
    const h2 = n5.add(s3).mul(n5.crossProduct(s3) / 6);
    return a2.x -= h2.x, a2.y -= h2.y, a2.add(this.m_center.sub(t3).mul(e2));
  }
  calculateWeightedCentroid2D() {
    const t3 = new mi();
    if (this.isDegenerate(0)) return t3.setCoords(0, 0), t3;
    if (Eu(this)) return t3.assign(this.getCoord2D(0.5).mul(this.calculateLength2D())), t3;
    let e2 = this.m_startAngle, s3 = this.m_startAngle + this.m_sweepAngle;
    if (s3 < e2) {
      const t4 = e2;
      e2 = s3, s3 = t4;
    }
    const n5 = Math.sin(e2), i2 = Math.sin(s3), r = Math.cos(e2), o = Math.cos(s3);
    if (1 === this.m_minorMajorRatio) {
      const e3 = this.getSemiMajorAxis(), s4 = e3 * e3, a2 = s4 * (i2 - n5), h2 = s4 * (r - o);
      t3.setCoords(a2, h2);
    } else {
      const e3 = this.getSemiMajorAxis(), s4 = this.getSemiMinorAxis(), a2 = e3 * e3, h2 = s4 * s4, u = e3 * s4, m3 = a2 - h2, l2 = m3 / h2, c = m3 / a2, g2 = Math.sqrt(l2), d2 = Math.sqrt(c), _ = 0.5 * u * (Math.asinh(g2 * i2) / g2 + i2 * Math.sqrt(1 + l2 * i2 * i2)) - 0.5 * u * (Math.asinh(g2 * n5) / g2 + n5 * Math.sqrt(1 + l2 * n5 * n5)), p3 = -0.5 * u * (Math.asin(d2 * o) / d2 + o * Math.sqrt(1 - c * o * o)) - -0.5 * u * (Math.asin(d2 * r) / d2 + r * Math.sqrt(1 - c * r * r));
      t3.setCoords(_, p3);
    }
    return t3.rotateDirect(this.m_cosr, this.m_sinr), t3.assign(t3.add(this.m_center.mul(this.calculateLength2D()))), t3;
  }
  isIntersectingPoint(t3, e2, s3) {
    if (s3 && (t3.isEqualPoint2D(this.getStartXY()) || t3.isEqualPoint2D(this.getEndXY()))) return false;
    if (!Eu(this)) {
      const s4 = mi.distance(t3, this.m_center), n6 = this.getSemiAxes();
      if (s4 < n6.x - e2 || s4 > n6.y + e2) return false;
    }
    const n5 = this.getClosestCoordinate(t3, false), i2 = new mi();
    this.queryCoord2D(n5, i2);
    return mi.distance(i2, t3) <= e2;
  }
  isIntersectingPoint3D(t3, e2, s3, i2, r = 1) {
    return n(0), false;
  }
  getTangent(t3) {
    if (Eu(this)) return this.getEndXY().sub(this.getStartXY());
    {
      const e2 = cu(this, t3), s3 = new mi();
      return s3.setCoords(-this.m_semiMajorAxis * Math.sin(e2), this.getSemiMinorAxis() * Math.cos(e2)), this.m_rotation && s3.rotateDirect(this.m_cosr, this.m_sinr), s3.scale(this.getSweepAngle()), s3;
    }
  }
  getDerivative(t3) {
    if (Eu(this)) return this.getEndXY().sub(this.getStartXY());
    {
      const e2 = cu(this, t3), s3 = new mi();
      return s3.setCoords(-this.m_semiMajorAxis * Math.sin(e2), this.getSemiMinorAxis() * Math.cos(e2)), this.m_rotation && s3.rotateDirect(this.m_cosr, this.m_sinr), s3.scale(this.getSweepAngle()), s3;
    }
  }
  normalizeAfterEndpointChange() {
    return !!Lu(this) && (Eu(this) ? (Ru(this), false) : zu(this, false));
  }
  projectionBehavior() {
    return (4 & this.m_bits) >> 2;
  }
  setProjectionBehavior(t3) {
    this.m_bits = -5 & this.m_bits | t3 << 2;
  }
  convertToCanonic(t3) {
    const e2 = new mi(t3.x, t3.y);
    return e2.subThis(this.m_center), e2.rotateReverse(this.m_cosr, this.m_sinr), e2;
  }
  convertFromCanonic(t3) {
    const e2 = new mi(t3.x, t3.y);
    return e2.rotateDirect(this.m_cosr, this.m_sinr), e2.addThis(this.m_center), e2;
  }
  canonicToWorldTransformation(t3) {
    t3.setRotate(this.m_cosr, this.m_sinr), t3.shiftCoords(this.m_center.x, this.m_center.y);
  }
  getCurvature(t3) {
    const e2 = cu(this, t3), s3 = new mi(), n5 = this.getSemiMinorAxis();
    s3.setCoords(-this.m_semiMajorAxis * Math.sin(e2), n5 * Math.cos(e2));
    const i2 = new mi();
    i2.setCoords(-this.m_semiMajorAxis * Math.cos(e2), -n5 * Math.sin(e2)), this.m_rotation && (s3.rotateDirect(this.m_cosr, this.m_sinr), i2.rotateDirect(this.m_cosr, this.m_sinr));
    const r = s3.sqrLength();
    if (0 === r) return Number.NaN;
    const o = Math.sqrt(r);
    s3.divThis(o);
    return s3.crossProduct(i2) / r;
  }
  getMonotonicPartParams(e2, s3) {
    const n5 = Yt(6, Number.NaN);
    n5[0] = 0;
    let i2 = 1;
    if (this.isDegenerateToLine()) n5[1] = 1, i2 = 2;
    else {
      const t3 = this.getSemiAxes(), e3 = Yt(4, Number.NaN);
      this.m_rotation ? (e3[0] = Math.atan2(t3.y * this.m_cosr, t3.x * this.m_sinr), e3[1] = e3[0] + Math.PI, e3[2] = Math.atan2(-t3.y * this.m_sinr, t3.x * this.m_cosr), e3[3] = e3[2] + Math.PI) : (e3[0] = 0, e3[1] = Math.PI, e3[2] = 0.5 * Math.PI, e3[3] = Ws());
      for (let s4 = 0; s4 < 4; s4++) {
        const t4 = lu(this, e3[s4]);
        t4 > 0 && t4 < 1 && (n5[i2] = t4, i2++);
      }
      i2 > 2 && zt(n5, i2), n5[i2] = 1, i2++;
    }
    if (s3) {
      e2 < i2 && P("");
      for (let t3 = 0; t3 < i2; t3++) s3[t3] = n5[t3];
    }
    return i2;
  }
  calculateLowerLength2D() {
    const t3 = mi.distance(this.getStartXY(), this.getEndXY());
    if (this.isDegenerateToLine()) return t3;
    const e2 = Math.abs(this.m_sweepAngle) * this.getSemiMinorAxis();
    return Math.max(e2, t3);
  }
  calculateUpperLength2D() {
    const t3 = mi.distance(this.getStartXY(), this.getEndXY());
    if (this.isDegenerateToLine()) return t3;
    const e2 = Math.abs(this.m_sweepAngle) * this.getSemiMajorAxis();
    return Math.max(e2, t3);
  }
  orientBottomUp() {
    if (this.m_YEnd < this.m_YStart || this.m_YEnd === this.m_YStart && this.m_XEnd < this.m_XStart) {
      this.m_XEnd = Pt(this.m_XStart, this.m_XStart = this.m_XEnd), this.m_YEnd = Pt(this.m_YStart, this.m_YStart = this.m_YEnd);
      for (let t3 = 0, e2 = this.m_description.getTotalComponentCount() - 2; t3 < e2; t3++) this.m_attributes[t3 + e2] = Pt(this.m_attributes[t3], this.m_attributes[t3] = this.m_attributes[t3 + e2]);
      this.m_startAngle = this.m_startAngle + this.m_sweepAngle, this.m_sweepAngle = -this.m_sweepAngle;
    }
  }
  isLine() {
    return Eu(this);
  }
  copyIgnoreAttributes(t3) {
    t3.m_XStart = this.m_XStart, t3.m_YStart = this.m_YStart, t3.m_XEnd = this.m_XEnd, t3.m_YEnd = this.m_YEnd, t3.m_center.assign(this.m_center), t3.m_semiMajorAxis = this.m_semiMajorAxis, t3.m_minorMajorRatio = this.m_minorMajorRatio, t3.m_interior.assign(this.m_interior), t3.m_rotation = this.m_rotation, t3.m_cosr = this.m_cosr, t3.m_sinr = this.m_sinr, t3.m_sweepAngle = this.m_sweepAngle, t3.m_startAngle = this.m_startAngle, t3.m_bits = this.m_bits, Mu(t3);
  }
  calculateArea2DHelper() {
    return Zu(this);
  }
  absNorm() {
    let t3 = this.getStartXY().norm(1) + this.getEndXY().norm(1);
    return this.isDegenerateToLine() || (t3 += this.m_center.norm(1), t3 += this.m_semiMajorAxis), t3;
  }
  queryEnvelopeW(t3, e2) {
    if (e2.setCoords(this.getCoord2D(t3.vmin)), e2.mergeNe(this.getCoord2D(t3.vmax)), Eu(this)) return;
    const s3 = this.getSemiAxes(), n5 = Yt(8, Number.NaN);
    {
      const t4 = Math.atan2(-s3.y * this.m_sinr, s3.x * this.m_cosr), e3 = t4 + Math.PI, i3 = Math.atan2(s3.y * this.m_cosr, s3.x * this.m_sinr), r = i3 + Math.PI;
      n5[0] = lu(this, t4), n5[1] = lu(this, e3), n5[2] = lu(this, i3), n5[3] = lu(this, r);
    }
    {
      const t4 = this.m_cosr + this.m_sinr, e3 = this.m_cosr - this.m_sinr, i3 = Math.atan2(-s3.y * t4, s3.x * e3), r = i3 + Math.PI, o = Math.atan2(s3.y * e3, s3.x * t4), a2 = o + Math.PI;
      n5[4] = lu(this, i3), n5[5] = lu(this, r), n5[6] = lu(this, o), n5[7] = lu(this, a2);
    }
    const i2 = mi.getNAN();
    for (let r = 0; r < 8; r++) {
      const s4 = n5[r];
      t3.containsExclusiveCoordinate(s4) && (this.queryCoord2D(s4, i2), e2.mergeNe(i2));
    }
  }
  setSegmentFromCoordsForStitcher(t3, e2) {
    xu(this, t3, e2);
  }
  writeInBufferStream(t3, e2) {
    const s3 = new Float64Array(10);
    return s3[0] = this.m_bits, s3[1] = this.m_semiMajorAxis, s3[2] = this.m_minorMajorRatio, s3[3] = this.m_rotation, s3[4] = this.m_center.x, s3[5] = this.m_center.y, s3[6] = this.m_sweepAngle, s3[7] = this.m_startAngle, s3[8] = this.m_interior.x, s3[9] = this.m_interior.y, t3.writeRangeFromArray(e2, s3.length, s3, true, 1), e2 + s3.length;
  }
  readFromBufferStream(t3, e2) {
    const s3 = new Float64Array(10);
    t3.queryRange(e2, s3.length, s3, true, 1), this.m_bits = s3[0], this.m_semiMajorAxis = s3[1], this.m_minorMajorRatio = s3[2], this.m_rotation = s3[3], this.m_center.x = s3[4], this.m_center.y = s3[5], this.m_sweepAngle = s3[6], this.m_startAngle = s3[7], this.m_interior.x = s3[8], this.m_interior.y = s3[9], this.m_cosr = Math.cos(this.m_rotation), this.m_sinr = Math.sin(this.m_rotation), this.m_cachedValues = null;
  }
  snapControlPoints(t3) {
    return false;
  }
  needsSnapControlPoints(t3) {
    return false;
  }
  calculateSpecialPointsForCracking(t3, e2) {
    return b("should not1; be called"), 0;
  }
  ensureXYMonotone() {
    if (Eu(this)) return false;
    if (this.getStartXY().equals(this.getEndXY())) return bu(this, this.getStartXY(), this.getEndXY(), this.projectionBehavior()), true;
    const t3 = Ot(mi, 3);
    let e2 = Bu(this, t3);
    if (Ha(t3)) {
      let s3 = false;
      if (0 === this.projectionBehavior()) {
        const n5 = new n3();
        n5.setCoords({ pt: t3[0] }), n5.mergeNe(t3[2]);
        const i2 = new mi();
        i2.setSub(t3[2], t3[0]), i2.leftPerpendicularThis(), i2.normalize(), i2.scale(mi.distance(t3[2], t3[0]));
        const r = mi.lerp(t3[2], t3[0], 0.5), o = r.sub(i2), a2 = r.add(i2);
        n5.clipLine(o, a2);
        const h2 = mi.getClosestCoordinate(o, a2, t3[1], false);
        t3[1] = mi.lerp(o, a2, h2);
        const u = t3[2].sub(t3[1]), m3 = t3[0].sub(t3[1]), l2 = u.crossProduct(m3), c = u.dotProduct(m3);
        e2 = Js() - Math.abs(0.5 * Math.atan2(l2, c)), s3 = true;
      }
      return ku(t3, e2 * e2, null, s3, this), true;
    }
    return false;
  }
  setCoordsForIntersector(t3, e2, s3) {
    yu(this, t3, e2, s3);
  }
  getInteriorPoint() {
    return this.m_interior.clone();
  }
  copyToImpl(t3) {
    const e2 = t3;
    e2.m_center.assign(this.m_center), e2.m_semiMajorAxis = this.m_semiMajorAxis, e2.m_minorMajorRatio = this.m_minorMajorRatio, e2.m_interior.assign(this.m_interior), e2.m_rotation = this.m_rotation, e2.m_cosr = this.m_cosr, e2.m_sinr = this.m_sinr, e2.m_sweepAngle = this.m_sweepAngle, e2.m_startAngle = this.m_startAngle, e2.m_bits = this.m_bits, Iu(e2, fu(this));
  }
  reverseImpl() {
    Nu(this, !Xu(this)), mu(this), (0 !== this.projectionBehavior() || this.getStartXY().equals(this.getEndXY())) && Hu(this);
  }
  equalsImpl(t3) {
    const e2 = t3;
    if (this.m_bits !== e2.m_bits) return false;
    if (this.m_semiMajorAxis !== e2.m_semiMajorAxis) return false;
    if (this.m_minorMajorRatio !== e2.m_minorMajorRatio) return false;
    if (!(this.m_center.isEqualPoint2D(e2.m_center) || this.m_center.isNAN() && e2.m_center.isNAN())) return false;
    if (this.m_rotation !== e2.m_rotation) return false;
    if (!this.m_interior.equals(e2.m_interior)) return false;
    const s3 = e2.m_sweepAngle;
    if (this.m_sweepAngle !== s3) return false;
    const n5 = e2.m_startAngle;
    return this.m_startAngle === n5;
  }
  equalsImplTol(t3, e2) {
    const s3 = t3;
    if (this.m_bits !== s3.m_bits) return false;
    if (this.m_center.isNAN() && s3.m_center.isNAN()) return true;
    if (this.m_center.isNAN() !== s3.m_center.isNAN()) return false;
    if (!this.getSemiAxes().isEqualPoint2D(s3.getSemiAxes(), e2)) return false;
    if (!this.m_center.isEqualPoint2D(s3.m_center, e2)) return false;
    const n5 = Math.abs(Ah(wh(Th(this.m_rotation - s3.m_rotation)))), i2 = Math.abs(Hs() - n5), r = Math.min(n5, i2);
    if (this.m_semiMajorAxis * Math.abs(r) > e2) return false;
    const o = this.getCoord2D(0.5), a2 = s3.getCoord2D(0.5);
    return !!o.isEqualPoint2D(a2, e2);
  }
  swapImpl(t3) {
    const e2 = t3;
    this.m_center = Pt(e2.m_center, e2.m_center = this.m_center), this.m_semiMajorAxis = Pt(e2.m_semiMajorAxis, e2.m_semiMajorAxis = this.m_semiMajorAxis), this.m_minorMajorRatio = Pt(e2.m_minorMajorRatio, e2.m_minorMajorRatio = this.m_minorMajorRatio), this.m_interior = Pt(e2.m_interior, e2.m_interior = this.m_interior), this.m_rotation = Pt(e2.m_rotation, e2.m_rotation = this.m_rotation), this.m_cosr = Pt(e2.m_cosr, e2.m_cosr = this.m_cosr), this.m_sinr = Pt(e2.m_sinr, e2.m_sinr = this.m_sinr), this.m_sweepAngle = Pt(e2.m_sweepAngle, e2.m_sweepAngle = this.m_sweepAngle), this.m_startAngle = Pt(e2.m_startAngle, e2.m_startAngle = this.m_startAngle), this.m_bits = Pt(e2.m_bits, e2.m_bits = this.m_bits), Yu(this, e2);
  }
  afterCompletedModification() {
    Ru(this), Mu(this);
  }
  intersect(t3, e2, s3, n5, i2) {
    return um(false, this, t3, e2, s3, n5, i2);
  }
  intersectPoint(t3, e2, s3) {
    if (e2.length < 2 && A(""), Eu(this)) {
      return new pm({ start: this.getStartXY(), end: this.getEndXY() }).intersectPoint(t3, e2, s3);
    }
    {
      const e3 = mi.distance(t3, this.m_center);
      if (e3 > this.m_semiMajorAxis + s3 || e3 < this.getSemiMinorAxis() - s3) return 0;
    }
    const n5 = this.getClosestCoordinate(t3, false), r = mi.getNAN();
    return this.queryCoord2D(n5, r), mi.distance(r, t3) <= s3 ? Vs(n5, 0, 1) && (this.queryCoord2D(0 === n5 ? 1 : 0, r), mi.distance(r, t3) <= s3) ? (e2 && (e2[0] = 0, e2[1] = 1), 2) : (e2 && (e2[0] = n5), 1) : 0;
  }
  isIntersecting(t3, e2, s3) {
    return 0 !== rm(false, this, t3, e2, s3);
  }
  endPointModified() {
    this.m_bits |= 8, Mu(this);
  }
  clearEndPointModified() {
    Ru(this);
  }
};
function Fh(t3, e2, s3, n5) {
  const i2 = [];
  return Lh(e2, i2), Rh(t3, i2, e2, s3);
}
function Lh(t3, e2) {
  e2.length = t3;
  for (let s3 = 0; s3 < e2.length; ++s3) e2[s3] = s3;
  t3 > 3 && ns(t3, e2);
}
function Rh(t3, e2, s3, n5, i2) {
  let r = 0;
  const o = [0, 0, 0];
  let a2 = 0;
  const h2 = 3;
  let u = 0;
  for (let m3 = 0; m3 < h2; ++m3) {
    let i3 = false;
    for (; u < s3; ) {
      const s4 = t3.at(e2[u]);
      let l2 = 1;
      if (3 === r ? l2 = mi.inCircleRobust(t3.at(n5[0]), t3.at(n5[1]), t3.at(n5[2]), s4) : 2 === r ? l2 = mi.inCircleRobust3Point(t3.at(n5[0]), t3.at(n5[1]), s4) : 1 === r && s4.equals(t3.at(n5[0])) && (l2 = 0), l2 <= 0) {
        if (l2 < 0 && m3 + 1 < h2) {
          e2[a2] = Pt(e2[u], e2[u] = e2[a2]);
          for (let t4 = 0; t4 < r; t4++) if (n5[t4] === e2[u]) {
            o[t4] = u;
            break;
          }
          a2++;
        }
        u++;
        continue;
      }
      i3 = true;
      let c = 0;
      for (let t4 = 0; t4 < r; t4++) o[t4] > u && (n5[c] = n5[t4], o[c] = o[t4], c++);
      r = c, n5[r] = e2[u], o[r] = u, r++, r < 3 ? u = a2 : (1 === mi.orientationRobust(t3.at(n5[0]), t3.at(n5[1]), t3.at(n5[2])) && (n5[2] = Pt(n5[0], n5[0] = n5[2]), o[2] = Pt(o[0], o[0] = o[2])), u++);
    }
    if (!i3) break;
    if (m3 + 1 < h2) {
      a2 = 0;
      let s4 = false;
      for (let t4 = 0; t4 < r; t4++) for (let e3 = t4 + 1; e3 < r; e3++) o[t4] > o[e3] && (o[e3] = Pt(o[t4], o[t4] = o[e3]), n5[e3] = Pt(n5[t4], n5[t4] = n5[e3]), s4 = true);
      for (let t4 = 0; t4 < r; t4++) e2[o[t4]] = Pt(e2[t4], e2[t4] = e2[o[t4]]), o[t4] = t4;
      s4 && 3 === r && 1 === mi.orientationRobust(t3.at(n5[0]), t3.at(n5[1]), t3.at(n5[2])) && (n5[2] = Pt(n5[0], n5[0] = n5[2]), o[2] = Pt(o[0], o[0] = o[2]));
    }
    u = r;
  }
  return r;
}
function zh(t3, e2, s3, n5, i2, r) {
  return new jh(0, 0, 0, null, false, ds()).densifyEx(t3, e2, s3, n5, false, r);
}
function kh(t3, i2, r, o, a2, h2, u, m3) {
  h2 && (h2.length = 0), u && (u.length = 0);
  const l2 = t3.getGeometryType();
  if (l2 === a.enumLine) return h2 && (h2.push(t3.getStartXY()), h2.push(mi.getNAN()), h2.push(mi.getNAN()), h2.push(t3.getEndXY())), u && (u.push(0), u.push(1)), 1;
  if (l2 === a.enumBezier) {
    if (!o) return h2 && (h2.push(t3.getStartXY()), h2.push(t3.getControlPoint1()), h2.push(t3.getControlPoint2()), h2.push(t3.getEndXY())), u && (u.push(0), u.push(1)), 1;
    const e2 = Yt(9, Number.NaN);
    let s3 = t3.getMonotonicPartParams(e2.length, e2);
    if (e2.length = s3, s3 = Zh(t3, r, e2), 2 === s3 && a2 && (e2[1] = 0.5, e2.push(1), s3 = 3), u && u.splice(0, 0, ...e2.slice(0, s3)), h2) {
      const n5 = new fm();
      for (let i3 = 1; i3 < s3; i3++) {
        const s4 = e2[i3 - 1], r2 = e2[i3];
        t3.queryCut(s4, r2, n5, true);
        const o2 = n5.get();
        lo(o2), 1 === i3 && h2.push(o2.getStartXY()), h2.push(o2.getControlPoint1()), h2.push(o2.getControlPoint2()), h2.push(o2.getEndXY());
      }
    }
    return s3 - 1;
  }
  if (l2 === a.enumEllipticArc) {
    const e2 = t3;
    if (e2.isDegenerateToLine() || e2.isDegenerate(0)) return h2 && (h2.push(t3.getStartXY()), h2.push(mi.getNAN()), h2.push(mi.getNAN()), h2.push(t3.getEndXY())), u && (u.push(0), u.push(1)), 1;
    if (o && (a2 || !e2.isMonotoneQuickAndDirty())) {
      const s3 = Yt(6, Number.NaN);
      let m4 = e2.getMonotonicPartParams(s3.length, s3);
      s3.length = m4, m4 = Zh(t3, r, s3), 2 === m4 && a2 && (s3[1] = 0.5, s3.push(1), m4 = 3);
      let l3 = 0;
      if (m4 > 2) {
        const t4 = new fm(), a3 = u || [];
        let c = 0;
        for (let g2 = 1; g2 < m4; g2++) {
          const d2 = s3[c], _ = s3[g2];
          if (e2.queryCut(d2, _, t4, true), t4.get().isDegenerate(0)) continue;
          const p3 = a3.length, f3 = Qh(1 === g2, t4.get(), i2, r, o, h2, u);
          n(f3 > 0), l3 += f3;
          const P5 = g2 === m4 - 1, y2 = s3[c], x4 = t4.get().getSweepAngle() / e2.getSweepAngle();
          for (let t5 = p3, s4 = a3.length; t5 < s4; t5++) if (a3[t5] = !P5 || t5 + 1 < s4 ? y2 + a3[t5] * x4 : 1, h2) {
            const s5 = 3 * t5, n5 = e2.getCoord2D(a3[t5]);
            if (h2[s5].setCoordsPoint2D(n5), s5 > 0) {
              co(h2.slice(s5 - 3));
            }
          }
          c = g2;
        }
        return l3;
      }
    }
    return Qh(true, e2, i2, r, o, h2, u);
  }
  if (l2 === a.enumRationalBezier2) {
    const e2 = t3;
    if (o && (a2 || !e2.isMonotoneQuickAndDirty())) {
      const s3 = Yt(6, Number.NaN);
      let n5 = e2.getMonotonicPartParams(s3.length, s3);
      s3.length = n5, n5 = Zh(t3, r, s3), 2 === n5 && a2 && (s3[1] = 0.5, s3.push(1), n5 = 3);
      let o2 = 0;
      if (n5 > 2) {
        const t4 = new fm(), a3 = u || [];
        for (let m4 = 1; m4 < n5; m4++) {
          const l3 = s3[m4 - 1], c = s3[m4];
          e2.queryCut(l3, c, t4, true);
          const g2 = a3.length;
          o2 += Jh(1 === m4, t4.get(), i2, r, false, h2, u);
          const d2 = m4 === n5 - 1, _ = s3[m4 - 1];
          for (let t5 = g2, s4 = a3.length; t5 < s4; t5++) if (a3[t5] = !d2 || t5 + 1 < s4 ? _ + a3[t5] : 1, h2) {
            const s5 = 3 * t5, n6 = e2.getCoord2D(a3[t5]);
            if (h2[s5].setCoordsPoint2D(n6), s5 > 0) {
              Ai(h2.slice(s5 - 3));
            }
          }
        }
        return o2;
      }
    }
    return Jh(true, e2, i2, r, o, h2, u);
  }
  if (l2 === a.enumBezier2) {
    const e2 = t3, s3 = Ot(mi, 3);
    e2.queryControlPoints(s3);
    const n5 = new ia();
    n5.constructFromQuadratic(s3);
    const m4 = kh(n5, i2, r, o, a2, h2, u);
    if (null != h2 && null != u) {
      const t4 = 3;
      for (let s4 = 1, n6 = 0; s4 < m4; ++s4, n6 += t4) {
        const i3 = new mi();
        e2.queryCoord2D(u[s4], i3);
        const r2 = h2[n6 + t4];
        if (!i3.equals(r2) && (h2[n6 + t4].setCoordsPoint2D(i3), o)) {
          co(h2.slice(n6, n6 + 4));
        }
      }
    }
    return m4;
  }
  z("");
}
function Wh(t3, s3, i2, r, o, a2, h2, u, m3) {
  const l2 = t3.getGeometryType();
  if (a2 && (a2.length = 0, h2.length = 0), u && (u.length = 0), l2 === a.enumEllipticArc) {
    const e2 = t3;
    if (e2.isDegenerateToLine() || e2.isDegenerate(0)) return a2 && (a2.push(t3.getStartXY()), a2.push(mi.getNAN()), a2.push(t3.getEndXY()), h2.push(Number.NaN), h2.push(Number.NaN), h2.push(Number.NaN)), u && (u.push(0), u.push(1)), 1;
  }
  const c = Yt(9, Number.NaN);
  let g2;
  if (o) g2 = t3.getMonotonicPartParams(c.length, c), c.length = g2, g2 = Zh(t3, i2, c);
  else {
    if (g2 = 2, c[0] = 0, c[1] = 1, l2 === Xh.type) {
      const e2 = t3.getSweepAngle();
      if (e2 > 0.9 * Math.PI) {
        const t4 = 2 * Math.PI / 3;
        Math.min(3, Math.trunc(e2 / t4 + 0.5)) > 2 ? (c[0] = 0, c[1] = 1 / 3, c[2] = 2 / 3, c[3] = 1, g2 = 4) : (c[0] = 0, c[1] = 0.5, c[2] = 1, g2 = 3);
      }
    } else n(l2 === Sn.type);
    c.length = g2;
  }
  if (2 === g2 && r && (c[1] = 0.5, c.push(1), g2 = 3), a2) {
    const s4 = new fm();
    let n5 = 1;
    for (; n5 < g2; ) {
      const i3 = c[n5 - 1], r2 = c[n5];
      t3.queryCut(i3, r2, s4, true);
      const u2 = Ot(mi, 3), m4 = [1, 1, 1];
      if (l2 === a.enumEllipticArc) {
        const t4 = s4.get();
        if (Math.abs(t4.getSweepAngle()) > 0.9 * Math.PI) {
          const t5 = (r2 - i3) / 3;
          c.splice(n5, 0, i3 + t5), c.splice(n5 + 1, 0, i3 + 2 * t5), g2 += 2;
          continue;
        }
        m4[1] = Bu(t4, u2);
      } else {
        const t4 = s4.get();
        t4.queryControlPoints(u2), t4.queryWeights(m4);
      }
      o && Ha(u2), 1 === n5 && (a2.push(u2[0].clone()), h2.push(m4[0])), a2.push(u2[1].clone()), a2.push(u2[2].clone()), h2.push(m4[1]), h2.push(m4[2]), n5++;
    }
  }
  return u && (u.length = g2, Dt(u, c, 0, 0, g2)), g2 - 1;
}
Xh.type = a.enumEllipticArc;
var jh = class _jh {
  static constructDefault(t3) {
    return new _jh(0, 0, 0, t3, false, ds());
  }
  constructor(t3, e2, s3, n5, i2, r) {
    this.m_segmentBuffer = null, this.m_dummyPoint = new ee(), this.m_progressCounter = 0, this.m_progressTracker = n5, this.m_bSetDensifyFlag = i2, this.m_maxLength = t3, this.m_maxDeviation = e2, this.m_maxAngle = s3 > Js() ? Js() : s3, this.m_cosMaxAngle = Math.cos(this.m_maxAngle), this.m_bOnlyCurveDensify = this.m_maxAngle > 0 || this.m_maxDeviation > 0, this.m_maxSegmentsPerCurve = r, D(this.m_maxSegmentsPerCurve > 0, "this.m_maxSegmentsPerCurve > 0"), this.m_minStep = 1 / this.m_maxSegmentsPerCurve;
  }
  densify(t3) {
    return this.densifyGeom(t3);
  }
  densifySegment(t3, e2) {
    this.densifySegmentEx(t3, null, true, false, e2);
  }
  densifyEx(t3, e2, s3, n5, i2, r) {
    return this.m_maxLength = e2, this.m_maxDeviation = s3, this.m_maxAngle = n5 > Js() ? Js() : n5, this.m_cosMaxAngle = Math.cos(this.m_maxAngle), this.m_bOnlyCurveDensify = this.m_maxAngle > 0 || this.m_maxDeviation > 0, this.m_bSetDensifyFlag = i2, this.m_maxSegmentsPerCurve = r, D(this.m_maxSegmentsPerCurve > 0, "this.m_maxSegmentsPerCurve > 0"), this.m_minStep = 1 / this.m_maxSegmentsPerCurve, this.densifyGeom(t3);
  }
  densifyGeom(t3) {
    if (t3.isEmpty() || t3.getDimension() < 1) return t3;
    const s3 = t3.getGeometryType();
    return g(s3) ? t3 : h(s3) ? this.densifyMultiPath(t3) : f(s3) ? this.densifySegmentImpl(t3) : s3 === a.enumEnvelope ? this.densifyEnvelope(t3) : void b("");
  }
  densifySegmentEx(t3, s3, n5, i2, r) {
    const o = t3.getGeometryType();
    if (!(this.m_maxLength > 0 || this.m_bOnlyCurveDensify && o !== a.enumLine) && (!i2 || n5)) return void (s3 ? o === a.enumLine ? s3.addSegment(t3, n5) : (n5 && (t3.queryStart(this.m_dummyPoint), s3.startPathPoint(this.m_dummyPoint)), t3.queryEnd(this.m_dummyPoint), s3.lineToPoint(this.m_dummyPoint)) : (n5 && r.push(0), r.push(1)));
    if (o === a.enumBezier) return void this.densifyCubicBezier(t3, s3, n5, i2, r);
    if (o === a.enumRationalBezier2) return void this.densifyRationalBezier2(t3, s3, n5, i2, r);
    if (o === a.enumBezier2) return void this.densifyBezier2(t3, s3, n5, i2, r);
    if (o === a.enumEllipticArc && !t3.isLine() && t3.getMinorMajorRatio() < 0.25) return void this.densifyEllipticArc(t3, s3, n5, i2, r);
    let a2 = 1;
    this.m_maxLength > 0 && (a2 = this.calculateLengthSubdivisionStep(t3, this.m_maxLength)), this.m_maxDeviation > 0 && (a2 = Math.min(a2, this.calculateDeviationSubdivisionStep(t3, this.m_maxDeviation))), this.m_maxAngle > 0 && (a2 = Math.min(a2, this.calculateAngularSubdivisionStep(t3, this.m_maxAngle))), this.densifySegmentByLength(t3, a2, s3, n5, i2, r);
  }
  densifyMultiPath(t3) {
    if (!t3.hasNonLinearSegments()) {
      if (1 === t3.getDescription().getAttributeCount()) return this.densifyMultiPathLinear(t3);
      if (!(this.m_maxLength > 0)) return t3;
    }
    const s3 = t3.createInstance();
    if (s3.getGeometryType() === a.enumPolygon) {
      s3.setFillRule(t3.getFillRule());
    }
    s3.reserve(t3.getPointCount());
    const n5 = t3.getImpl().querySegmentIterator();
    for (; n5.nextPath(); ) {
      let t4 = true;
      for (; n5.hasNextSegment(); ) {
        const e2 = n5.nextSegment(), i2 = n5.isClosingSegment();
        this.densifySegmentEx(e2, s3, t4, i2, null), i2 && s3.closePathWithLine(), t4 = false;
      }
    }
    return s3;
  }
  densifySegmentImpl(t3) {
    const e2 = new Os2({ vd: t3.getDescription() }), s3 = [0];
    return this.densifySegmentEx(t3, e2, true, false, s3), e2;
  }
  densifyEnvelope(t3) {
    const e2 = new ur({ vd: t3.getDescription() });
    e2.addEnvelope(t3, false);
    const s3 = n3.constructEmpty();
    t3.queryEnvelope(s3);
    const n5 = s3.width(), i2 = s3.height();
    return !(this.m_maxLength > 0) || n5 <= this.m_maxLength && i2 <= this.m_maxLength ? e2 : this.densifyMultiPath(e2);
  }
  densifyMultiPathLinear(t3) {
    if (!(this.m_maxLength > 0)) return t3;
    const s3 = t3.createInstance();
    if (s3.getGeometryType() === a.enumPolygon) {
      s3.setFillRule(t3.getFillRule());
    }
    s3.reserve(t3.getPointCount());
    const n5 = s3.getImpl(), i2 = t3.getImpl(), r = i2.getAttributeStreamRef(0), o = new pm();
    for (let e2 = 0, a2 = i2.getPathCount(); e2 < a2; e2++) {
      const t4 = i2.isClosedPath(e2);
      if (0 === i2.getPathSize(e2)) continue;
      const a3 = i2.getPathStart(e2), h2 = r.readPoint2D(2 * a3), u = h2.clone();
      n5.startPath(h2);
      for (let m3 = a3 + 1, l2 = i2.getPathEnd(e2); m3 < l2; m3++) {
        const t5 = r.readPoint2D(2 * m3), e3 = mi.distance(u, t5);
        if (e3 > this.m_maxLength) {
          let s4 = Math.ceil(e3 / this.m_maxLength);
          s4 > ds() && (s4 = ds());
          const i3 = 1 / s4;
          let r2, a4, h3;
          u.compare(t5) < 0 ? (o.setStartXY(u), o.setEndXY(t5), r2 = 0, a4 = 1) : (o.setStartXY(t5), o.setEndXY(u), r2 = s4 - 2, a4 = -1);
          for (let t6 = 0, e4 = s4 - 1; t6 < e4; t6++, r2 += a4) {
            this.progress_(), h3 = i3 * (r2 + 1);
            const t7 = new mi();
            o.queryCoord2D(h3, t7), n5.lineTo(t7), this.m_bSetDensifyFlag && n5.setAttributeNoCurves(10, n5.getPointCount() - 1, 0, 1);
          }
        } else this.progress_();
        s3.lineTo(t5), u.assign(t5);
      }
      if (t4) {
        const t5 = mi.distance(u, h2);
        if (t5 > this.m_maxLength) {
          const e3 = h2;
          let s4 = Math.ceil(t5 / this.m_maxLength);
          s4 > ds() && (s4 = ds());
          const i3 = 1 / s4;
          let r2, a4;
          u.compare(e3) < 0 ? (o.setStartXY(u), o.setEndXY(e3), r2 = 0, a4 = 1) : (o.setStartXY(e3), o.setEndXY(u), r2 = s4 - 2, a4 = -1);
          const m3 = new mi(0, 0);
          let l2;
          for (let t6 = 0, h3 = s4 - 1; t6 < h3; t6++, r2 += a4) this.progress_(), l2 = i3 * (r2 + 1), o.queryCoord2D(l2, m3), n5.lineTo(m3), this.m_bSetDensifyFlag && n5.setAttributeNoCurves(10, n5.getPointCount() - 1, 0, 1);
        }
        n5.closePathWithLine();
      }
    }
    return s3;
  }
  densifySegmentByLength(t3, i2, r, o, a2, h2) {
    n(t3.getGeometryType() !== a.enumBezier);
    let u = t3.getStartXY().compare(t3.getEndXY());
    if (0 === u && i2 < 1) {
      t3.getGeometryType() === a.enumEllipticArc ? u = t3.getSweepAngle() < 0 ? 1 : -1 : z("densify segment by length");
    }
    let m3 = 0;
    if (o && (r ? (t3.queryStart(this.m_dummyPoint), r.startPathPoint(this.m_dummyPoint)) : h2.push(0), ++m3), i2 * this.m_maxSegmentsPerCurve < 1 && (i2 = 1 / this.m_maxSegmentsPerCurve), i2 < 1) {
      this.m_segmentBuffer || (this.m_segmentBuffer = new fm());
      let e2 = Math.ceil(1 / i2);
      e2 > ds() && (e2 = ds()), i2 = 1 / e2, this.m_segmentBuffer.create(t3.getGeometryType());
      let s3, n5, o2, a3 = t3;
      u < 0 ? (s3 = 0, n5 = 1) : (t3.copyTo(this.m_segmentBuffer.get()), this.m_segmentBuffer.get().reverse(), s3 = e2 - 2, n5 = -1, a3 = this.m_segmentBuffer.get());
      const l2 = e2 - 1;
      for (let t4 = 0; t4 < l2; t4++, s3 += n5) o2 = i2 * (s3 + 1), r ? (a3.queryCoord(o2, this.m_dummyPoint), r.lineToPoint(this.m_dummyPoint), this.m_bSetDensifyFlag && 1 !== o2 && 0 !== o2 && r.setAttribute(10, r.getPointCount() - 1, 0, 1)) : h2.push(u > 0 ? 1 - o2 : o2), this.progress_();
      o2 = 1, m3 += l2;
    }
    (!a2 || a2 && o && m3 < 2) && (r ? (t3.queryEnd(this.m_dummyPoint), r.lineToPoint(this.m_dummyPoint)) : h2.push(1));
  }
  densifyCubicBezier(t3, e2, s3, n5, i2) {
    const r = new ia();
    let o = t3;
    const a2 = t3.calculateUpperLength2D();
    let h2 = t3.getStartXY().compare(t3.getEndXY());
    if (0 === h2 && a2 > 0) {
      const e3 = Ot(mi, 4);
      t3.queryControlPoints(e3), h2 = e3[1].compare(e3[2]), 0 === h2 && (h2 = e3[1].compare(e3[0]));
    }
    h2 > 0 && (t3.copyTo(r), r.reverse(), o = r);
    let u = 0;
    s3 && (e2 ? (t3.queryStart(this.m_dummyPoint), e2.startPathPoint(this.m_dummyPoint)) : i2.push(0), ++u);
    const m3 = [], l2 = [], c = Math.trunc(Math.log2(this.m_maxSegmentsPerCurve));
    let g2 = true, d2 = 0;
    if (h2 > 0) for (m3.push([o.getStartXY(), o.getControlPoint1(), o.getControlPoint2(), o.getEndXY(), new mi(0, 1)]), l2.push(0); m3.length; ) {
      this.progress_();
      const t4 = m3.at(-1), r2 = l2.at(-1), a3 = t4[4].x, h3 = t4[4].y;
      if (r2 < c && this.bezierNeedsSplit(t4)) {
        g2 && (d2 = o.findMinDeriv(), g2 = false);
        let e3 = 0.5 * (a3 + h3);
        Math.abs(d2 - e3) < 0.4 * (h3 - a3) && (e3 = d2);
        const s4 = (e3 - a3) / (h3 - a3), n6 = t4[0].mul(1 - s4).add(t4[1].mul(s4)), i3 = t4[1].mul(1 - s4).add(t4[2].mul(s4)), u2 = t4[2].mul(1 - s4).add(t4[3].mul(s4)), c2 = n6.mul(1 - s4).add(i3.mul(s4)), _ = i3.mul(1 - s4).add(u2.mul(s4)), p3 = c2.mul(1 - s4).add(_.mul(s4)), f3 = t4[3];
        t4[1] = n6, t4[2] = c2, t4[3] = p3, t4[4].setCoords(a3, e3);
        const P5 = [p3, _, u2, f3, new mi(e3, h3)];
        m3.push(P5), l2[l2.length - 1] = r2 + 1, l2.push(r2 + 1);
        continue;
      }
      m3.pop(), l2.pop(), (m3.length > 0 || !n5 || n5 && s3 && u < 2) && (e2 ? (o.queryCoord(a3, this.m_dummyPoint), e2.lineToPoint(this.m_dummyPoint), this.m_bSetDensifyFlag && 1 !== a3 && 0 !== a3 && e2.setAttribute(10, e2.getPointCount() - 1, 0, 1)) : i2.push(1 - a3), ++u);
    }
    else for (m3.push([o.getStartXY(), o.getControlPoint1(), o.getControlPoint2(), o.getEndXY(), new mi(0, 1)]), l2.push(0); m3.length; ) {
      this.progress_();
      const t4 = m3.at(-1), r2 = l2.at(-1), a3 = t4[4].x, h3 = t4[4].y;
      if (r2 < c && this.bezierNeedsSplit(t4)) {
        g2 && (d2 = o.findMinDeriv(), g2 = false);
        let e3 = 0.5 * (a3 + h3);
        Math.abs(d2 - e3) < 0.4 * (h3 - a3) && (e3 = d2);
        const s4 = (e3 - a3) / (h3 - a3), n6 = t4[0].mul(1 - s4).add(t4[1].mul(s4)), i3 = t4[1].mul(1 - s4).add(t4[2].mul(s4)), u2 = t4[2].mul(1 - s4).add(t4[3].mul(s4)), c2 = n6.mul(1 - s4).add(i3.mul(s4)), _ = i3.mul(1 - s4).add(u2.mul(s4)), p3 = c2.mul(1 - s4).add(_.mul(s4)), f3 = t4[0];
        t4[0] = p3, t4[1] = _, t4[2] = u2, t4[4].setCoords(e3, h3);
        const P5 = [f3, n6, c2, p3, new mi(a3, e3)];
        m3.push(P5), l2[l2.length - 1] = r2 + 1, l2.push(r2 + 1);
        continue;
      }
      m3.pop(), l2.pop(), (m3.length > 0 || !n5 || n5 && s3 && u < 2) && (e2 ? (o.queryCoord(h3, this.m_dummyPoint), e2.lineToPoint(this.m_dummyPoint), this.m_bSetDensifyFlag && 1 !== h3 && 0 !== h3 && e2.setAttribute(10, e2.getPointCount() - 1, 0, 1)) : i2.push(h3), ++u);
    }
  }
  densifyRationalBezier2(t3, e2, s3, n5, i2) {
    const r = new Sn();
    let o = t3;
    const a2 = t3.calculateUpperLength2D();
    let h2 = t3.getStartXY().compare(t3.getEndXY());
    0 === h2 && a2 > 0 && (h2 = 0), h2 > 0 && (t3.copyTo(r), r.reverse(), o = r);
    let u = 0;
    s3 && (e2 ? (t3.queryStart(this.m_dummyPoint), e2.startPathPoint(this.m_dummyPoint)) : i2.push(0), ++u);
    const m3 = Math.trunc(Math.log2(this.m_maxSegmentsPerCurve)), l2 = new Sn(), c = [], g2 = [];
    for (c.push(new x2(0, 1)), g2.push(0); c.length; ) {
      this.progress_();
      const t4 = c.at(-1).clone(), r2 = g2.at(-1);
      if (r2 < m3 && this.rationalBezier2NeedsSplit(o, l2, t4.vmin, t4.vmax)) {
        const e3 = t4.getCenter();
        h2 > 0 ? (c.at(-1).vmax = e3, c.push(new x2(e3, t4.vmax))) : (c.at(-1).vmin = e3, c.push(new x2(t4.vmin, e3))), g2[g2.length - 1] = r2 + 1, g2.push(r2 + 1);
        continue;
      }
      if (c.pop(), g2.pop(), c.length > 0 || !n5 || n5 && s3 && u < 2) {
        const s4 = h2 > 0 ? t4.vmin : t4.vmax;
        e2 ? (o.queryCoord(s4, this.m_dummyPoint), e2.lineToPoint(this.m_dummyPoint), this.m_bSetDensifyFlag && 1 !== s4 && 0 !== s4 && e2.setAttribute(10, e2.getPointCount() - 1, 0, 1)) : i2.push(h2 > 0 ? 1 - s4 : s4), ++u;
      }
    }
  }
  densifyBezier2(t3, e2, s3, n5, i2) {
    const r = new wn();
    let o = t3;
    const a2 = t3.calculateUpperLength2D();
    let h2 = t3.getStartXY().compare(t3.getEndXY());
    0 === h2 && a2 > 0 && (h2 = 0), h2 > 0 && (t3.copyTo(r), r.reverse(), o = r);
    let u = 0;
    s3 && (e2 ? (t3.queryStart(this.m_dummyPoint), e2.startPathPoint(this.m_dummyPoint)) : i2.push(0), ++u);
    const m3 = Math.ceil(Math.log2(this.m_maxSegmentsPerCurve)), l2 = new wn(), c = [], g2 = [];
    for (c.push(new x2(0, 1)), g2.push(0); c.length; ) {
      this.progress_();
      const t4 = c.at(-1).clone(), r2 = g2.at(-1);
      if (r2 < m3 && this.bezier2NeedsSplit(o, l2, t4.vmin, t4.vmax)) {
        const e3 = t4.getCenter();
        h2 > 0 ? (c.at(-1).vmax = e3, c.push(new x2(e3, t4.vmax))) : (c.at(-1).vmin = e3, c.push(new x2(t4.vmin, e3))), g2[g2.length - 1] = r2 + 1, g2.push(r2 + 1);
        continue;
      }
      if (c.pop(), g2.pop(), c.length > 0 || !n5 || n5 && s3 && u < 2) {
        const s4 = h2 > 0 ? t4.vmin : t4.vmax;
        e2 ? (o.queryCoord(s4, this.m_dummyPoint), e2.lineToPoint(this.m_dummyPoint), this.m_bSetDensifyFlag && 1 !== s4 && 0 !== s4 && e2.setAttribute(10, e2.getPointCount() - 1, 0, 1)) : i2.push(h2 > 0 ? 1 - s4 : s4), ++u;
      }
    }
  }
  densifyEllipticArc(t3, e2, s3, n5, i2) {
    const r = new Xh();
    let o = t3;
    const a2 = t3.calculateUpperLength2D();
    let h2 = t3.getStartXY().compare(t3.getEndXY());
    0 === h2 && a2 > 0 && (h2 = t3.isClockwise() ? 0 : 1), h2 > 0 && (t3.copyTo(r), r.reverse(), o = r);
    let u = 0;
    s3 && (e2 ? (t3.queryStart(this.m_dummyPoint), e2.startPathPoint(this.m_dummyPoint)) : i2.push(0), ++u);
    const m3 = Math.trunc(Math.log2(this.m_maxSegmentsPerCurve)), l2 = new Xh(), c = [], g2 = [];
    for (c.push(new x2(0, 1)), g2.push(0); c.length; ) {
      this.progress_();
      const t4 = c.at(-1).clone(), r2 = g2.at(-1);
      if (r2 < m3 && this.ellipticArcNeedsSplit(o, l2, t4.vmin, t4.vmax)) {
        const e3 = t4.getCenter();
        h2 > 0 ? (c.at(-1).vmax = e3, c.push(new x2(e3, t4.vmax))) : (c.at(-1).vmin = e3, c.push(new x2(t4.vmin, e3))), g2[g2.length - 1] = r2 + 1, g2.push(r2 + 1);
        continue;
      }
      if (c.pop(), g2.pop(), c.length > 0 || !n5 || n5 && s3 && u < 2) {
        const s4 = h2 > 0 ? t4.vmin : t4.vmax;
        e2 ? (o.queryCoord(s4, this.m_dummyPoint), e2.lineToPoint(this.m_dummyPoint), this.m_bSetDensifyFlag && 1 !== s4 && 0 !== s4 && e2.setAttribute(10, e2.getPointCount() - 1, 0, 1)) : i2.push(h2 > 0 ? 1 - s4 : s4), ++u;
      }
    }
  }
  calculateLengthSubdivisionStep(t3, n5) {
    const i2 = t3.calculateUpperLength2D();
    if (!t3.isCurve()) return i2 ? n5 / i2 : 1;
    if (t3.getGeometryType() === a.enumEllipticArc) {
      const e2 = t3;
      if (e2.isCircular() || e2.isDegenerate(0) || e2.isDegenerateToLine()) {
        let t4 = n5 / i2;
        return t4 < this.m_minStep && (t4 = this.m_minStep), t4;
      }
      return n5 / i2 * e2.getSemiAxes().y / e2.getSemiAxes().x;
    }
    t3.getGeometryType() === a.enumBezier && z(""), z("");
  }
  calculateDeviationSubdivisionStep(t3, n5) {
    if (!t3.isCurve()) return 1;
    if (t3.getGeometryType() === a.enumEllipticArc) {
      const e2 = t3;
      if (e2.isDegenerate(0) || e2.isDegenerateToLine()) return 1;
      {
        const s3 = e2.getSemiMajorAxis(), i2 = 1 - n5 / s3;
        let r = Math.PI / 2;
        if (i2 > 0) {
          const t4 = 4 * Math.sqrt(n5 / s3 * 0.5);
          r = Math.min(Math.PI / 2, Math.abs(t4));
        }
        r = Math.max(r, 2 * Math.PI / this.m_maxSegmentsPerCurve);
        const o = r * s3;
        return this.calculateLengthSubdivisionStep(t3, o);
      }
    }
    z("");
  }
  calculateAngularSubdivisionStep(t3, n5) {
    if (!t3.isCurve()) return 1;
    if (t3.getGeometryType() === a.enumEllipticArc) {
      const e2 = t3;
      return e2.isDegenerate(0) || e2.isDegenerateToLine() ? 1 : this.calculateLengthSubdivisionStep(t3, n5 * e2.getSemiMinorAxis());
    }
    z("");
  }
  rationalBezier2NeedsSplit(t3, e2, s3, n5) {
    t3.cutBezierIgnoreAttributes(s3, n5, e2);
    let i2 = false;
    if (this.m_maxLength > 0) {
      if (e2.calculateUpperLength2D() > this.m_maxLength) return i2 = true, true;
    }
    const r = Ot(mi, 3);
    e2.queryControlPoints(r);
    const o = [0, 0, 0];
    return e2.queryWeights(o), !i2 && this.m_maxDeviation > 0 && (i2 = !_jh.checkRationalBezier2MaxDeviation(r, o, this.m_maxDeviation)), !i2 && this.m_maxAngle > 0 && (i2 = !_jh.checkRationalBezier2MaxAngle(r, o, this.m_cosMaxAngle)), i2;
  }
  bezier2NeedsSplit(t3, e2, s3, n5) {
    t3.cutBezierIgnoreAttributes(s3, n5, e2);
    let i2 = false;
    if (this.m_maxLength > 0) {
      if (e2.calculateUpperLength2D() > this.m_maxLength) return i2 = true, true;
    }
    const r = Ot(mi, 3);
    return e2.queryControlPoints(r), !i2 && this.m_maxDeviation > 0 && (i2 = !_jh.checkBezier2MaxDeviation(r, this.m_maxDeviation)), !i2 && this.m_maxAngle > 0 && (i2 = !_jh.checkBezier2MaxAngle(r, this.m_cosMaxAngle)), i2;
  }
  ellipticArcNeedsSplit(t3, e2, s3, n5) {
    t3.cutArcIgnoreAttributes(s3, n5, e2);
    let i2 = false;
    if (this.m_maxLength > 0) {
      if (e2.calculateUpperLength2D() > this.m_maxLength) return i2 = true, true;
    }
    return !i2 && this.m_maxDeviation > 0 && (i2 = !_jh.checkEllipticArcMaxDeviation(e2, this.m_maxDeviation)), !i2 && this.m_maxAngle > 0 && (i2 = !_jh.checkEllipticArcMaxAngle(e2, this.m_cosMaxAngle)), i2;
  }
  bezierNeedsSplit(t3) {
    let e2 = false;
    if (this.m_maxLength > 0) {
      if (mi.distance(t3[0], t3[1]) + mi.distance(t3[1], t3[2]) + mi.distance(t3[2], t3[3]) > this.m_maxLength) return e2 = true, true;
    }
    return !e2 && this.m_maxDeviation > 0 && (e2 = !_jh.checkBezierMaxDeviation(t3, this.m_maxDeviation)), !e2 && this.m_maxAngle > 0 && (e2 = !_jh.checkBezierMaxAngle(t3, this.m_cosMaxAngle)), e2;
  }
  progress_() {
  }
  static checkBezierMaxDeviation(t3, e2) {
    const s3 = t3[3].sub(t3[0]);
    if (s3.sqrLength() > 0) {
      const n5 = s3.clone();
      n5.leftPerpendicularThis(), n5.normalize();
      const i2 = n5.dotProduct(t3[0].sub(t3[1])), r = n5.dotProduct(t3[0].sub(t3[2]));
      if (Math.max(Math.abs(i2), Math.abs(r)) <= e2) {
        const e3 = new mi();
        Po(t3, 0.5, e3, false);
        const n6 = e3.sub(t3[0]).dotProduct(s3);
        return n6 >= 0 && n6 <= s3.sqrLength();
      }
      return false;
    }
    return Math.max(t3[0].sub(t3[1]).sqrLength(), t3[0].sub(t3[2]).sqrLength()) <= e2 * e2;
  }
  static checkBezierMaxAngle(t3, e2) {
    if (t3[0].equals(t3[3])) return !(!t3[0].equals(t3[1]) || !t3[1].equals(t3[2]));
    const s3 = t3[3].sub(t3[0]);
    s3.normalize();
    {
      const n5 = t3[1].sub(t3[0]), i2 = n5.dotProduct(s3);
      if (i2 < 0) return false;
      if (n5.length() * e2 > i2) return false;
    }
    {
      const n5 = t3[2].sub(t3[0]), i2 = n5.dotProduct(s3);
      if (i2 < 0) return false;
      if (n5.length() * e2 > i2) return false;
    }
    {
      const n5 = t3[2].sub(t3[1]), i2 = n5.dotProduct(s3);
      if (i2 < 0) return false;
      if (n5.length() * e2 > i2) return false;
    }
    return true;
  }
  static checkRationalBezier2MaxDeviation(t3, e2, s3) {
    if (0 === e2[1]) return false;
    const n5 = t3[2].sub(t3[0]);
    if (n5.sqrLength() > 0) {
      const e3 = n5.clone();
      e3.leftPerpendicularThis(), e3.normalize();
      const i2 = e3.dotProduct(t3[0].sub(t3[1]));
      if (Math.abs(i2) <= s3) {
        const e4 = t3[1].sub(t3[0]).dotProduct(n5);
        return e4 >= 0 && e4 <= n5.sqrLength();
      }
      return false;
    }
    return t3[0].sub(t3[1]).sqrLength() <= s3 * s3;
  }
  static checkRationalBezier2MaxAngle(t3, e2, s3) {
    if (0 === e2[1]) return false;
    if (t3[0].equals(t3[2])) return !!t3[0].equals(t3[1]);
    const n5 = t3[2].sub(t3[0]);
    n5.normalize();
    {
      const e3 = t3[1].sub(t3[0]), i2 = e3.dotProduct(n5);
      if (i2 < 0) return false;
      if (e3.length() * s3 > i2) return false;
    }
    return true;
  }
  static checkBezier2MaxDeviation(t3, e2) {
    const s3 = t3[2].sub(t3[0]);
    if (s3.sqrLength() > 0) {
      const n5 = s3.clone();
      n5.leftPerpendicularThis(), n5.normalize();
      const i2 = n5.dotProduct(t3[0].sub(t3[1]));
      if (Math.abs(i2) <= e2) {
        const e3 = t3[1].sub(t3[0]).dotProduct(s3);
        return e3 >= 0 && e3 <= s3.sqrLength();
      }
      return false;
    }
    return t3[0].sub(t3[1]).sqrLength() <= e2 * e2;
  }
  static checkBezier2MaxAngle(t3, e2) {
    if (t3[0].equals(t3[2])) return !!t3[0].equals(t3[1]);
    const s3 = t3[2].sub(t3[0]);
    s3.normalize();
    {
      const n5 = t3[1].sub(t3[0]), i2 = n5.dotProduct(s3);
      if (i2 < 0) return false;
      if (n5.length() * e2 > i2) return false;
    }
    return true;
  }
  static checkEllipticArcMaxDeviation(t3, e2) {
    if (Math.abs(t3.getSweepAngle()) < Math.PI) {
      const s4 = t3.getEndXY().sub(t3.getStartXY()), n6 = [0, 0];
      if (1 === tm(t3, s4, n6)) {
        const s5 = t3.getCoord2D(n6[0]), i2 = mi.getClosestCoordinate(t3.getStartXY(), t3.getEndXY(), s5), r = new mi();
        Y(t3.getStartXY(), t3.getEndXY(), i2, r);
        return mi.distance(s5, r) <= e2;
      }
    }
    const s3 = t3.getCoord2D(0.5), n5 = new mi();
    Y(t3.getEndXY(), t3.getStartXY(), 0.5, n5);
    return mi.distance(s3, n5) <= e2;
  }
  static checkEllipticArcMaxAngle(t3, e2) {
    const s3 = t3.getTangent(0), n5 = t3.getTangent(1), i2 = s3.dotProduct(n5);
    return !(i2 < 0) && !(s3.length() * n5.length() * e2 > i2);
  }
  static checkTypeForReplace(t3, s3) {
    return t3.getGeometryType() === s3 && (s3 !== a.enumEllipticArc || t3.isCircular());
  }
};
function Zh(t3, e2, s3) {
  const n5 = s3.length;
  if (e2 <= 0 || n5 <= 2) return n5;
  let i2 = 0;
  const r = Yt(n5 - 1, Number.NaN);
  for (let o = 1, a2 = n5; o < a2; o++) {
    const e3 = t3.tToLength(s3[o]);
    r[o - 1] = e3 - i2, i2 = e3;
  }
  for (; r.length > 1; ) {
    const t4 = r.findIndex((t5) => t5 <= 2 * e2);
    if (-1 === t4) break;
    let n6 = t4 + 1, i3 = t4 + 1;
    if (t4 > 0) {
      const e3 = t4 - 1;
      (i3 === r.length || r[e3] > r[i3]) && (i3 = e3, n6--);
    }
    r[i3] += r[t4], r.splice(t4, 1), s3.splice(n6, 1);
  }
  return s3.length;
}
function Qh(t3, e2, s3, n5, i2, r, o, a2) {
  const h2 = e2.clone();
  h2.dropAllAttributes();
  const u = (t4, e3, s4, n6) => (e3 && (t4 && e3.push(n6.getStartXY()), e3.push(mi.getNAN()), e3.push(mi.getNAN()), e3.push(n6.getEndXY())), s4 && (t4 && s4.push(0), s4.push(1)), 1);
  if (h2.isDegenerateToLine() || h2.isDegenerate(0)) return u(t3, r, o, e2);
  const m3 = h2.getStartXY(), l2 = h2.getEndXY(), c = h2.getSemiAxes(), g2 = new x3();
  if (h2.isCircular()) g2.setIdentity();
  else {
    const t4 = h2.getAxisXRotation();
    g2.setScaleCoords(1, h2.getMinorMajorRatio()), g2.rotateAngle(t4);
  }
  const d2 = h2.getCenter();
  g2.shift(d2);
  const _ = g2.clone();
  _.invertThis(), h2.applyTransformation(_);
  const p3 = h2.getSweepAngle();
  if (0 === p3) return u(t3, r, o, e2);
  const f3 = n3.constructEmpty();
  f3.setCoords({ center: d2, width: 2 * c.x, height: 2 * c.x });
  const P5 = 0.05 * f3.calculateToleranceFromEnvelope(), y2 = Math.max(s3 / c.x, P5 / c.x);
  let x4 = 4 * Math.pow(y2 / 0.0741, 1 / 6);
  x4 = Math.min(x4, Math.PI / 2);
  const C3 = Ih(h2.getStartAngle());
  let v3 = p3 > 0 ? Math.floor(C3 / x4) : Math.ceil(C3 / x4);
  v3 *= x4;
  const b2 = p3 > 0 ? x4 : -x4;
  v3 + b2 === C3 && (v3 += b2);
  let E2 = 4 / 3 * Math.tan(Math.abs(x4) / 4);
  p3 > 0 && (E2 = -E2), o && t3 && o.push(0);
  const S3 = x4 / Math.abs(p3);
  let D3 = (v3 - C3) / p3;
  const w4 = m3.clone(), A4 = new mi();
  h2.queryCoord2D(0, A4);
  const T3 = A4.clone(), I4 = 1 - 0.01 * S3;
  let M2 = 0, Y3 = 0;
  for (; D3 < 1; ) {
    let s4;
    if (D3 += S3, Y3 > 0 && D3 < I4) s4 = E2;
    else {
      D3 >= I4 && (D3 = 1);
      const t4 = (D3 - Y3) * p3;
      s4 = 4 / 3 * Math.tan(Math.abs(t4) / 4), p3 > 0 && (s4 = -s4);
    }
    h2.queryCoord2D(D3, A4);
    const a3 = new mi();
    g2.queryTransform(A4, a3);
    const u2 = e2.getClosestCoordinate(a3, false);
    if (e2.queryCoord2D(u2, a3), 1 !== D3 && (mi.distance(w4, a3) <= 2 * n5 || mi.distance(a3, l2) <= 2 * n5)) continue;
    w4.setCoordsPoint2D(a3);
    const c2 = Ot(mi, 4);
    c2[0].assign(T3), c2[3].assign(A4), c2[1].rightPerpendicularOther(T3), c2[1].scaleAddThis(s4, T3), c2[2].leftPerpendicularOther(A4), c2[2].scaleAddThis(s4, A4), g2.transformPoints2D(c2, 3, c2), c2[3].assign(a3), 0 === Y3 && c2[0].setCoordsPoint2D(m3), 1 === D3 && c2[3].setCoordsPoint2D(l2), i2 && co(c2);
    let d3 = true;
    for (let t4 = 1; t4 < 4; t4++) if (!c2[t4].isEqualPoint2D(c2[0])) {
      d3 = false;
      break;
    }
    d3 || (o && o.push(u2), r && (0 === Y3 && t3 && r.push(c2[0].clone()), r.push(c2[1].clone()), r.push(c2[2].clone()), r.push(c2[3].clone())), M2++), Y3 = D3, T3.setCoordsPoint2D(A4);
  }
  return M2;
}
function Jh(t3, e2, s3, n5, i2, r, o, a2) {
  e2.clone().dropAllAttributes();
  const h2 = new n3();
  e2.queryLooseEnvelope(h2);
  const u = 0.05 * h2.calculateToleranceFromEnvelope(), m3 = Math.max(s3, u);
  o && t3 && o.push(0);
  let l2 = 0;
  const c = Ot(mi, 3);
  e2.queryControlPoints(c);
  const g2 = [0, 0, 0];
  e2.queryWeights(g2);
  const d2 = [], _ = Yt(9, Number.NaN);
  let p3 = 0;
  i2 ? (p3 = e2.getMonotonicPartParams(_.length, _), _.length = p3, p3 = Zh(e2, n5, _)) : (_.length = 2, p3 = 2, _[0] = 0, _[1] = 1);
  let f3 = 0, P5 = t3;
  for (let y2 = 1; y2 < p3; y2++) {
    const t4 = _[y2];
    for (d2.length = 0, d2.push(t4), d2.push(f3); d2.length > 1; ) {
      const t5 = d2.at(-1);
      d2.pop();
      const e3 = d2.at(-1), s4 = Ot(mi, 3), n6 = [0, 0, 0];
      Qa(c, g2, t5, e3, s4, n6);
      const i3 = Ot(mi, 4), a3 = Ka(s4, n6, i3), h3 = 16, u2 = d2.length > h3;
      m3 >= a3 || u2 ? (o.push(e3), r && (P5 && (r.push(i3[0]), P5 = false), r.push(i3[1]), r.push(i3[2]), r.push(i3[3])), l2++) : (d2.push(0.5 * (t5 + e3)), d2.push(t5));
    }
    f3 = t4;
  }
  return l2;
}
function eu() {
  return { e2: 0, completeE: 0 };
}
var su = class {
  constructor(t3, e2) {
    this.m_arc = t3, this.m_sqrChordLength = e2;
  }
  getMaxDerivative() {
    return 1;
  }
  getValue(t3, e2) {
    return 0 === t3 ? mi.sqrDistance(this.m_arc.getCoord2D(e2), this.m_arc.getCoord2D(1 - e2)) - this.m_sqrChordLength : 0;
  }
  getError(t3) {
    return 0;
  }
};
function nu(t3, e2, s3) {
  if (Eu(t3)) {
    return void Cs(new pm({ start: t3.getStartXY(), end: t3.getEndXY() }), e2, s3);
  }
  if (0 === e2.value()) s3.set(t3.getStartXY());
  else if (1 === e2.value()) s3.set(t3.getEndXY());
  else {
    const n5 = new p2();
    gu(t3, e2, n5);
    const i2 = new p2(), r = new p2();
    p2.st_cosAndSin(n5, i2, r);
    const o = ve.constructCoordsE(new p2(t3.m_semiMajorAxis).mulThisE(i2), new p2(t3.m_semiMajorAxis).mulThis(t3.m_minorMajorRatio).mulThisE(r)), a2 = new p2(t3.m_rotation);
    p2.st_cosAndSin(a2, i2, r), o.rotateDirect(i2, r), o.addThisE(ve.constructPoint2D(t3.m_center)), s3.setE(o);
  }
}
function iu(t3, e2) {
  return t3.convertToCanonic(e2);
}
function ru(t3, e2) {
  const s3 = new x2(t3.getStartAngle(), t3.getEndAngle());
  s3.normalize();
  const n5 = $s(), i2 = ct(e2, n5);
  if (i2 < s3.vmin) {
    let t4 = i2 + n5;
    for (; t4 < s3.vmin; ) t4 += n5;
    return s3.containsCoordinate(t4) ? t4 : s3.vmin - i2 < t4 - s3.vmax ? i2 : t4;
  }
  if (i2 > s3.vmax) {
    let t4 = i2 - n5;
    for (; t4 > s3.vmax; ) t4 -= n5;
    return s3.containsCoordinate(t4) || s3.vmin - t4 < i2 - s3.vmax ? t4 : i2;
  }
  return i2;
}
function ou(t3, e2, s3, n5) {
  let i2 = t3.m_startAngle, r = t3.m_sweepAngle;
  const o = 1e-12;
  for (; i2 > Hs(); ) i2 -= 2 * Hs();
  for (; i2 <= -Hs(); ) i2 += 2 * Hs();
  if (!Number.isNaN(e2)) {
    for (; e2 > Hs(); ) e2 -= 2 * Hs();
    for (; e2 <= -Hs(); ) e2 += 2 * Hs();
    !s3 && e2 > i2 && (e2 -= 2 * Hs()), s3 && e2 < i2 && (e2 += 2 * Hs()), r = e2 - i2, Math.abs(r) < o && !n5 && (r = s3 ? 2 * Hs() : -2 * Hs()), Math.abs(r) > 2 * Hs() - o && n5 && (r = 0);
  }
  Math.abs(r) > 2 * Hs() - o && (r = r >= 0 ? 2 * Hs() : -2 * Hs(), t3.setEndXY(t3.getStartXY())), Math.abs(r) < o && (r = 0, t3.setEndXY(t3.getStartXY())), n5 = Math.abs(r) <= Hs(), r && (s3 = r > 0), t3.m_startAngle = au(i2), t3.m_sweepAngle = r, qu(t3, !n5), Nu(t3, s3);
}
function au(t3) {
  let e2 = t3, s3 = false;
  return e2 <= -Hs() ? (e2 += $s(), s3 = true) : e2 > Hs() && (e2 -= $s(), s3 = true), e2 <= -Hs() ? (e2 = ct(e2, $s()), e2 <= -Hs() && (e2 += $s()), s3 = true) : e2 > Hs() && (e2 = ct(e2, $s()), e2 > Hs() && (e2 -= $s()), s3 = true), s3 && (e2 > Hs() || e2 <= -Hs()) && (e2 = Hs()), e2;
}
function hu(t3, e2, s3) {
  const n5 = s3, i2 = n5.getSemiAxes();
  let r = new mi(i2.x * Math.cos(t3[0]), i2.y * Math.sin(t3[0]));
  return r = n5.convertFromCanonic(r), mi.sqrDistance(r, n5.getStartXY());
}
function uu(t3, e2, s3) {
  const n5 = s3, i2 = n5.getSemiAxes(), r = t3[0] + n5.getStartAngle();
  let o = new mi(i2.x * Math.cos(r), i2.y * Math.sin(r));
  return o = n5.convertFromCanonic(o), mi.sqrDistance(o, n5.getEndXY());
}
function mu(t3) {
  if (t3.m_center.isNAN()) return t3.m_startAngle = 0, void (t3.m_sweepAngle = 0);
  const e2 = t3.getStartXY(), s3 = t3.getEndXY(), n5 = e2.equals(s3), i2 = Fu(t3), r = Xu(t3), o = t3.projectionBehavior();
  if (n5) {
    const s4 = t3.convertToCanonic(e2), n6 = new mi(t3.m_semiMajorAxis, t3.m_semiMajorAxis * t3.m_minorMajorRatio);
    s4.x /= n6.x, s4.y /= n6.y, t3.m_startAngle = au(Math.atan2(s4.y, s4.x)), t3.m_sweepAngle = i2 ? r ? $s() : -$s() : 0;
  } else {
    const n6 = t3.convertToCanonic(e2), a2 = new mi(t3.m_semiMajorAxis, t3.m_semiMajorAxis * t3.m_minorMajorRatio);
    n6.x /= a2.x, n6.y /= a2.y;
    const h2 = t3.convertToCanonic(s3);
    h2.x /= a2.x, h2.y /= a2.y, t3.m_startAngle = Math.atan2(n6.y, n6.x), t3.m_sweepAngle = mi.calculateAngle(n6, h2), r ? t3.m_sweepAngle < 0 && (t3.m_sweepAngle += $s()) : t3.m_sweepAngle > 0 && (t3.m_sweepAngle -= $s()), t3.m_startAngle = au(t3.m_startAngle);
    let u = hu([t3.m_startAngle], 1, t3);
    if (u = Math.sqrt(u), u > 0.25 * Ue(t3)) {
      const e3 = t3.m_startAngle - 1e-4, s4 = t3.m_startAngle + 1e-4, n7 = [0];
      rn(hu, t3, 1, [t3.m_startAngle], [e3], [s4], 1e-14, n7), t3.m_startAngle = au(n7[0]);
    }
    if (u = uu([t3.m_sweepAngle], 1, t3), u = Math.sqrt(u), u > 0.25 * Ue(t3)) {
      const e3 = t3.m_sweepAngle - 1e-4, s4 = t3.m_sweepAngle + 1e-4, n7 = [0];
      rn(uu, t3, 1, [t3.m_sweepAngle], [e3], [s4], 1e-14, n7), t3.m_sweepAngle = n7[0];
    }
    const m3 = Math.abs(t3.m_sweepAngle) > Hs();
    if (qu(t3, m3), i2 !== m3 && !i2 && Math.abs(t3.m_sweepAngle) > 1.5 * Hs()) return void bu(t3, e2, s3, o);
    if (0 === t3.m_sweepAngle || r !== t3.m_sweepAngle > 0) return void bu(t3, e2, s3, o);
  }
}
function lu(t3, e2) {
  return (ru(t3, e2) - t3.getStartAngle()) / t3.getSweepAngle();
}
function cu(t3, e2) {
  return t3.m_startAngle + e2 * t3.m_sweepAngle;
}
function gu(t3, e2, s3) {
  s3.assign(new p2(t3.m_startAngle).addE(e2.mulE(new p2(t3.m_sweepAngle))));
}
function du(t3, e2) {
  const s3 = new p2(t3.m_cosr).sqrThis(), n5 = new p2(t3.m_sinr).sqrThis(), i2 = new p2(t3.m_minorMajorRatio), r = new p2(1 / t3.m_minorMajorRatio), o = i2.mulE(s3).addThisE(r.mulE(n5)), a2 = i2.subE(r).mulThis(2 * t3.m_cosr * t3.m_sinr), h2 = i2.mulE(n5).addThisE(r.mulE(s3));
  e2[0] = o, e2[1] = a2, e2[2] = h2, e2[3] = new p2(-t3.m_semiMajorAxis).mulThis(t3.m_semiMajorAxis).mulThis(t3.m_minorMajorRatio);
}
function _u(t3, e2) {
  const s3 = new be();
  s3.a11.setE(t3[0]), s3.a12 = p2.st_mulByPower2(t3[1], 0.5), s3.a21.setE(s3.a12), s3.a22.setE(t3[2]);
  const n5 = [mi.getNAN(), mi.getNAN()], i2 = [new p2(), new p2()];
  s3.eigenSymmetric(i2, n5);
  const r = t3[3].clone();
  r.negateThis(), r.invThis(), i2[0].mulThisE(r), i2[1].mulThisE(r), i2[0].sqrtThis().invThis(), i2[1].sqrtThis().invThis(), e2.x = i2[0].toDouble(), e2.y = i2[1].toDouble();
  return Math.atan2(n5[0].y, n5[0].x);
}
function pu(t3, e2, s3) {
  if (Eu(t3)) return (s3 - e2) * mi.distance(t3.getStartXY(), t3.getEndXY());
  if (1 === t3.m_minorMajorRatio) return Math.abs(t3.getSweepAngle() * (e2 - s3)) * t3.m_semiMajorAxis;
  const n5 = Su(t3, e2);
  return Su(t3, s3) - n5;
}
function fu(t3) {
  return t3.m_cachedValues;
}
function Pu(t3) {
  if (t3.m_cachedValues) return t3.m_cachedValues;
  const e2 = eu();
  return e2.e2 = Cu(t3), e2.completeE = ft(e2.e2), t3.m_cachedValues = e2, e2;
}
function yu(t3, e2, s3, n5) {
  if (!e2.isEqual(t3.m_XStart, t3.m_YStart) || !s3.isEqual(t3.m_XEnd, t3.m_YEnd)) {
    if (Eu(t3)) return t3.m_XStart = e2.x, t3.m_YStart = e2.y, t3.m_XEnd = s3.x, t3.m_YEnd = s3.y, Hu(t3), void t3.afterCompletedModification();
    if (n5 && Math.abs(t3.getSweepAngle()) <= 1.01 * Js()) {
      const n6 = Ot(mi, 3), i2 = Bu(t3, n6);
      if (ja(n6)) {
        n6[0].assign(e2), n6[2].assign(s3), Ha(n6);
        if (0 === t3.projectionBehavior()) {
          let e3 = 0, s4 = 2;
          mi.sqrDistance(n6[1], n6[0]) < mi.sqrDistance(n6[1], n6[2]) && (s4 = Pt(e3, e3 = s4));
          const i3 = n6[s4].sub(n6[e3]), r = i3.length();
          i3.divThis(r);
          const o = n6[1].sub(n6[e3]), a2 = o.length(), h2 = o.dotProduct(i3) / a2, u = o.crossProduct(i3) / a2, m3 = new mi();
          Y(n6[e3], n6[s4], 0.5, m3);
          const l2 = 0.5 * r / u * Us(1 - h2, 0, 1), c = n6[1].side(n6[e3], n6[s4]), g2 = i3.clone();
          c ? g2.leftPerpendicularThis() : g2.rightPerpendicularThis();
          const d2 = m3.sub(g2.mul(l2));
          t3.constructCircularArcThreePoint(n6[0], n6[2], d2);
        } else ku(n6, i2 * i2, null, false, t3);
        return;
      }
    }
    0 === t3.projectionBehavior() ? nm(t3, e2, s3) : im(t3, e2, s3);
  }
}
function xu(t3, e2, s3) {
  const n5 = 0 === t3.projectionBehavior();
  if (s3 <= 2) return void bu(t3, e2[0], e2[s3 - 1], n5 ? 0 : 1);
  if (n5) {
    t3.constructCircularArcThreePoint(e2[0], e2[s3 - 1], e2[Math.trunc(s3 / 2)]);
    const n6 = new mi();
    return t3.queryCoord2D(0.5, n6), void t3.m_interior.setCoordsPoint2D(n6);
  }
  const i2 = t3.getSemiMajorAxis(), r = t3.getMinorMajorRatio(), o = t3.getAxisXRotation(), a2 = t3.getCenter(), h2 = new Array(4);
  h2[0] = t3.isMajor(), h2[1] = !h2[0], h2[2] = h2[0], h2[3] = !h2[0];
  const u = new Array(4);
  u[0] = t3.isClockwise(), u[1] = u[0], u[2] = !u[0], u[3] = !u[0];
  const m3 = Math.trunc(s3 < 5 ? 1 : (s3 + 4) / 5), l2 = Ot(Xh, 4), c = Yt(4, Number.NaN);
  let g2 = 0;
  for (let d2 = 0; d2 < 4; d2++) {
    l2[d2].constructEllipticArcEndPointsCenter(e2[0], e2[s3 - 1], i2, r, o, h2[d2], u[d2], a2), c[d2] = 0;
    let t4 = 0;
    for (let n6 = m3; n6 < s3 - 1; n6 += m3) {
      const s4 = l2[d2].getClosestCoordinate(e2[n6], false);
      c[d2] += mi.sqrDistance(l2[d2].getCoord2D(s4), e2[n6]), t4++;
    }
    c[d2] /= t4, c[d2] < c[g2] && (g2 = d2);
  }
  t3.assignCopy(l2[g2]);
}
function Cu(t3) {
  return 1 - H(t3.m_minorMajorRatio);
}
function vu(t3, e2, s3, n5, i2, r, o, a2, h2) {
  return t3.m_bits = 0, t3.m_rotation = r, Xe(t3, e2), Fe(t3, s3), t3.m_cosr = Math.cos(r), t3.m_sinr = Math.sin(r), qu(t3, o), Nu(t3, a2), void 0 !== h2 ? t3.m_center.assign(h2) : t3.m_center.setNAN(), t3.setProjectionBehavior(1), t3.m_semiMajorAxis = n5, t3.m_minorMajorRatio = i2, zu(t3, void 0 === h2);
}
function bu(t3, e2, s3, n5) {
  t3.m_bits = 0, t3.m_rotation = 0, Xe(t3, e2), Fe(t3, s3), t3.m_interior.assign(e2.add(s3).mul(0.5)), t3.m_startAngle = 0, t3.m_sweepAngle = 0, t3.m_cosr = 1, t3.m_sinr = 0, qu(t3, false), Nu(t3, false), t3.m_center.setNAN(), t3.m_semiMajorAxis = 1, t3.m_minorMajorRatio = 0, t3.setProjectionBehavior(n5), t3.afterCompletedModification();
}
function Eu(t3) {
  return t3.m_center.isNAN();
}
function Su(t3, e2) {
  if (0 === e2) return 0;
  const s3 = Pu(t3), n5 = cu(t3, e2), i2 = Js(), r = wu(t3), o = _t(n5 + i2, s3.e2, s3.completeE), a2 = t3.m_semiMajorAxis * (o - r);
  return Math.abs(a2);
}
function Du(t3, e2) {
  if (Eu(t3)) {
    const s4 = mi.distance(t3.getStartXY(), t3.getEndXY());
    return 0 === s4 ? 0 : e2 / s4;
  }
  if (1 === t3.m_minorMajorRatio) {
    const s4 = Math.abs(t3.getSweepAngle() * t3.m_semiMajorAxis);
    return 0 === s4 ? 0 : e2 / s4;
  }
  if (0 === e2) return 0;
  const s3 = t3.getSweepAngle();
  if (0 === s3) return 0.5;
  const n5 = Pu(t3), i2 = Js(), r = wu(t3);
  s3 < 0 && (e2 = -e2);
  const o = e2 / t3.m_semiMajorAxis + r;
  let a2 = vt(o, n5.e2, n5.completeE);
  a2 -= i2, a2 -= t3.getStartAngle();
  return a2 / s3;
}
function wu(t3) {
  const e2 = Pu(t3);
  return _t(t3.getStartAngle() + Js(), e2.e2, e2.completeE);
}
function Au(t3, e2, s3, i2, r) {
  if (2 === e2.m_TransformationType) return void n(0);
  if (n(!Lu(t3)), e2.isIdentity() && (!i2 || i2.equals(t3.getStartXY()) && r.equals(t3.getEndXY()))) return;
  Mu(t3);
  let o = mi.getNAN(), a2 = mi.getNAN();
  if (null === i2 ? (o.x = t3.m_XStart, o.y = t3.m_YStart, e2.transformInPlace(o), a2.x = t3.m_XEnd, a2.y = t3.m_YEnd, e2.transformInPlace(a2)) : (o = i2, a2 = r), Eu(t3)) return t3.m_XStart = o.x, t3.m_YStart = o.y, t3.m_XEnd = a2.x, void (t3.m_YEnd = a2.y);
  const h2 = t3.m_center.clone();
  if (e2.transformInPlace(h2), s3 || e2.isUniformNoRotation()) {
    let s4 = Xu(t3);
    e2.isReflective() && (s4 = !s4);
    if (0 === t3.projectionBehavior()) {
      if (!o.equals(a2)) {
        const s5 = t3.m_interior.clone();
        return e2.transformInPlace(s5), void t3.constructCircularArcThreePoint(o, a2, s5);
      }
      return void Tu(t3, o, a2, h2, s4, false);
    }
    const n5 = new mi(t3.m_cosr, t3.m_sinr);
    e2.transformWithoutTranslateInPlace(n5);
    const i3 = Math.atan2(n5.y, n5.x), r2 = t3.getSemiAxes();
    e2.transformWithoutTranslateInPlace(r2);
    const u = t3.m_center.clone();
    return e2.transformInPlace(u), void t3.constructEllipticArcEndPointsCenter(o, a2, r2.x, r2.y / r2.x, i3, t3.isMajor(), s4, u);
  }
  {
    {
      const s5 = new Array(4);
      du(t3, s5);
      const n6 = new be();
      n6.a11.setE(s5[0]), n6.a12.setE(s5[1]), n6.a12.mulThisByPower2(0.5), n6.a21.setE(n6.a12), n6.a22.setE(s5[2]);
      if (!n6.det().isZero()) {
        const i4 = new be();
        if (i4.a11.set(e2.xx), i4.a12.set(e2.xy), i4.a21.set(e2.yx), i4.a22.set(e2.yy), i4.invertThis()) {
          const r3 = i4.clone();
          r3.transposeThis();
          const u2 = n6.clone();
          u2.mulThis(i4), u2.mulLeftThis(r3);
          if (!u2.det().isZero()) {
            const n7 = Ot(p2, 4);
            n7[0].setE(u2.a11), n7[1].setE(u2.a12), n7[1].mulThisByPower2(2), n7[2].setE(u2.a22), n7[3].setE(s5[3]);
            const i5 = mi.getNAN(), r4 = _u(n7, i5);
            let m3 = Xu(t3);
            return e2.isReflective() && (m3 = !m3), void t3.constructEllipticArcEndPointsCenter(o, a2, i5.x, i5.y / i5.x, r4, t3.isMajor(), m3, h2);
          }
        }
      }
    }
    const s4 = [mi.getNAN(), mi.getNAN(), mi.getNAN()];
    s4[0].setCoords(t3.getSemiMajorAxis(), 0), s4[0].rotateDirect(t3.m_cosr, t3.m_sinr), s4[1].setCoords(t3.getSemiMajorAxis(), t3.getSemiMinorAxis()), s4[1].rotateDirect(t3.m_cosr, t3.m_sinr), s4[2].setCoords(0, t3.getSemiMinorAxis()), s4[2].rotateDirect(t3.m_cosr, t3.m_sinr);
    let n5 = t3.isClockwise();
    n5 && (s4[2] = Pt(s4[0], s4[0] = s4[2]));
    const i3 = 0.5;
    e2.transformWithoutTranslateArray(s4, 3, s4), e2.isReflective() && (n5 = !n5);
    const r2 = new mi(0, 0), u = t3.createInstance();
    ku(s4, i3, r2, false, u), t3.constructEllipticArcEndPointsCenter(o, a2, u.getSemiMajorAxis(), u.getMinorMajorRatio(), u.getAxisXRotation(), t3.isMajor(), !n5, h2);
  }
}
function Tu(t3, e2, s3, n5, i2, r) {
  const o = 0.5 * (n5.sub(e2).length() + n5.sub(s3).length());
  t3.m_center.assign(n5), t3.m_startAngle = Math.atan2(e2.y - t3.m_center.y, e2.x - t3.m_center.x);
  ou(t3, Math.atan2(s3.y - t3.m_center.y, s3.x - t3.m_center.x), i2, r);
  const a2 = t3.constructEllipticArcEndPointsCenter(e2, s3, o, 1, 0, Math.abs(t3.m_sweepAngle) > Math.PI, t3.m_sweepAngle > 0, n5);
  return t3.setProjectionBehavior(0), a2;
}
function Iu(t3, e2) {
  t3.m_cachedValues = e2;
}
function Mu(t3) {
  t3.m_cachedValues = null;
}
function Yu(t3, e2) {
  e2.m_cachedValues = Pt(t3.m_cachedValues, t3.m_cachedValues = e2.m_cachedValues);
}
function Nu(t3, e2) {
  const s3 = e2 ? 1 : 0;
  t3.m_bits = -2 & t3.m_bits | s3;
}
function Xu(t3) {
  return !!(1 & t3.m_bits);
}
function qu(t3, e2) {
  const s3 = e2 ? 1 : 0;
  t3.m_bits = -3 & t3.m_bits | s3 << 1;
}
function Fu(t3) {
  return !!(2 & t3.m_bits);
}
function Vu(t3) {
  if (t3.m_center.isNAN()) return false;
  const e2 = 8, s3 = new ve();
  s3.setWithEps(t3.getStartXY(), e2), s3.subThisE(new ve().setWithEps(t3.m_center, e2));
  const n5 = new p2();
  n5.setWithEps(t3.m_rotation, e2);
  const i2 = new p2(), r = new p2();
  p2.st_cosAndSin(n5, i2, r), s3.rotateReverse(i2, r);
  const o = new ve();
  o.setWithEps(t3.getEndXY()), o.subThisE(ve.constructPoint2D(t3.m_center)), o.rotateReverse(i2, r);
  const a2 = new p2();
  a2.setWithEps(t3.m_semiMajorAxis, e2);
  const h2 = a2.clone(), u = new p2();
  u.setWithEps(t3.m_minorMajorRatio), h2.mulThisE(u), s3.x.divThisE(a2), s3.y.divThisE(h2), o.x.divThisE(a2), o.y.divThisE(h2);
  const m3 = s3.x.sqr().addThisE(s3.y.sqr()).subThisE(w2), l2 = o.x.sqr().addThisE(o.y.sqr()).subThisE(w2);
  return !m3.isZero() || !l2.isZero();
}
function Lu(t3) {
  return !!(8 & t3.m_bits);
}
function Ru(t3) {
  t3.m_bits &= -9;
}
function zu(t3, e2) {
  Ru(t3);
  const s3 = t3.getStartXY(), i2 = t3.getEndXY();
  let r = false;
  const o = Fu(t3), a2 = Xu(t3), h2 = t3.projectionBehavior(), u = s3.equals(i2);
  let m3 = 0 === t3.m_minorMajorRatio || 0 === t3.m_semiMajorAxis;
  if (Number.isNaN(t3.m_minorMajorRatio) && (0 === t3.m_semiMajorAxis ? t3.m_minorMajorRatio = 1 : v("NAN minor major ratio and non-zero major axis")), m3 ||= e2 ? u : t3.m_center.isNAN(), m3) return bu(t3, s3, i2, h2), true;
  t3.m_semiMajorAxis = Math.abs(t3.m_semiMajorAxis), t3.m_minorMajorRatio = Math.abs(t3.m_minorMajorRatio), t3.m_minorMajorRatio > 1 && (t3.m_semiMajorAxis *= t3.m_minorMajorRatio, t3.m_minorMajorRatio = 1 / t3.m_minorMajorRatio);
  const l2 = new mi(t3.m_semiMajorAxis, t3.m_semiMajorAxis * t3.m_minorMajorRatio);
  if (n(l2.y > 0 && l2.x >= l2.y), u) {
    const e3 = t3.convertToCanonic(s3);
    n(!l2.isZero()), e3.x /= l2.x, e3.y /= l2.y;
    const i3 = Math.sqrt(H(e3.x) + H(e3.y));
    if (r = 1 !== i3, t3.m_semiMajorAxis *= i3, l2.mulThis(i3), t3.m_startAngle = au(Math.atan2(e3.y, e3.x)), !o) return t3.m_interior.assign(s3), t3.m_sweepAngle = 0, t3.afterCompletedModification(), r;
    t3.m_sweepAngle = a2 ? $s() : -$s();
  } else {
    let e3 = t3.m_center.isNAN() || Vu(t3);
    if (!e3) {
      const n5 = t3.convertToCanonic(s3);
      n5.x /= l2.x, n5.y /= l2.y;
      const r2 = new mi(1, 0);
      t3.m_startAngle = mi.calculateAngle(r2, n5);
      const o2 = t3.convertToCanonic(i2);
      o2.x /= l2.x, o2.y /= l2.y, t3.m_sweepAngle = mi.calculateAngle(n5, o2), e3 = !Wu(t3);
    }
    if (e3) {
      r = true;
      const e4 = s3.sub(i2).mulThis(0.5);
      e4.rotateReverse(t3.m_cosr, t3.m_sinr);
      let n5 = H(e4.x / l2.x) + H(e4.y / l2.y);
      n5 > 1 && (n5 = Math.sqrt(n5), t3.m_semiMajorAxis *= n5, l2.mulThis(n5));
      const h3 = new mi(0, 0);
      {
        const t4 = l2.x * l2.x, s4 = l2.y * l2.y, n6 = t4 * e4.y * e4.y + s4 * e4.x * e4.x, i3 = t4 * s4 - n6;
        if (i3 > 0) {
          const t5 = Math.sqrt(i3 / n6);
          h3.setCoords(l2.x * e4.y / l2.y, -l2.y * e4.x / l2.x), h3.mulThis(t5), o === a2 && h3.negateThis();
        }
      }
      {
        const e5 = new mi(h3.x, h3.y);
        e5.rotateDirect(t3.m_cosr, t3.m_sinr), e5.addThis(s3.add(i2).mulThis(0.5)), t3.m_center.assign(e5);
      }
    }
    if (mu(t3), !Wu(t3)) return bu(t3, s3, i2, h2), true;
  }
  return Hu(t3), t3.afterCompletedModification(), r;
}
function Bu(t3, e2) {
  n(Math.abs(t3.getSweepAngle()) < 15 * Math.PI / 16);
  const s3 = t3.getSemiMajorAxis(), i2 = t3.getSemiMinorAxis();
  let r;
  if (0 === s3) return e2[0].setCoordsPoint2D(t3.getStartXY()), e2[1].setCoordsPoint2D(t3.getStartXY()), e2[2].setCoordsPoint2D(t3.getStartXY()), r = 1, r;
  if (0 === i2) return e2[0].setCoordsPoint2D(t3.getStartXY()), e2[2].setCoordsPoint2D(t3.getEndXY()), e2[1] = mi.lerp(e2[0], e2[2], 0.5), r = 1, r;
  const o = t3.getSweepAngle(), a2 = t3.getStartAngle(), h2 = a2 + o, u = new mi(-s3 * Math.sin(a2), i2 * Math.cos(a2)), m3 = new mi(-s3 * Math.sin(h2), i2 * Math.cos(h2));
  u.normalize(), m3.normalize(), u.rotateDirect(t3.m_cosr, t3.m_sinr), m3.rotateDirect(t3.m_cosr, t3.m_sinr), e2[0].setCoordsPoint2D(t3.getStartXY()), e2[2].setCoordsPoint2D(t3.getEndXY()), e2[1].setSub(e2[2], e2[0]);
  const l2 = u.crossProduct(m3);
  e2[1].assign(u.mul(e2[1].crossProduct(m3) / l2)), e2[1].addThis(e2[0]);
  return r = Math.cos(0.5 * o), r;
}
function ku(t3, e2, s3, i2, r) {
  if (i2) {
    const s4 = 0.5, n5 = Math.sqrt(e2), i3 = H(1 - s4) + 2 * n5 * s4 * (1 - s4) + H(s4), o2 = t3[0].mul(H(1 - s4)).add(t3[1].mul(2 * n5 * s4 * (1 - s4))).add(t3[2].mul(H(s4))).divThis(i3);
    return r.constructCircularArcThreePoint(t3[0], t3[2], o2), true;
  }
  const o = t3[0].sub(t3[1]), a2 = t3[2].sub(t3[1]), h2 = o.crossProduct(a2), u = o.dotProduct(a2), m3 = e2;
  n(m3 <= 1), n(m3 > 0);
  const l2 = 0.5 / (1 - m3), c = o.sqrLength(), g2 = u, d2 = a2.sqrLength(), _ = H(h2), p3 = o.sub(a2).sqrLength();
  if (0 === _) return bu(r, t3[0], t3[2], 1), false;
  if (u <= -Math.sqrt(c) * Math.sqrt(d2)) return bu(r, t3[0], t3[2], 1), false;
  const f3 = [0, 0], P5 = new x2();
  P5.setInfinite();
  const y2 = sn(2 * _, -(p3 / m3 + 4 * g2), 2 * (1 - m3) / m3, P5, false, f3);
  if (0 === y2) return bu(r, t3[0], t3[2], 1), false;
  1 === y2 && (f3[1] = f3[0]);
  const x4 = Math.sqrt(l2 / f3[0]), C3 = Math.sqrt(l2 / f3[1]), v3 = 0.5 / m3;
  let b2 = v3 - d2 * f3[0], E2 = v3 - c * f3[0];
  Math.abs(b2) > Math.abs(E2) ? E2 = g2 * f3[0] - v3 + 1 : b2 = g2 * f3[0] - v3 + 1;
  const S3 = o.mul(b2).add(a2.mul(E2)), D3 = S3.norm(1) < 1e-15 * x4 ? 0 : Math.atan2(S3.y, S3.x) + Math.PI, w4 = o.add(a2), A4 = s3 ? s3.clone() : t3[1].add(w4.mul(l2)), T3 = t3[0].sub(A4), I4 = t3[2].sub(A4), M2 = T3.crossProduct(I4) < 0, Y3 = false;
  new Xh();
  return r.constructEllipticArcEndPointsCenter(t3[0], t3[2], x4, C3 / x4, D3, Y3, !M2, A4);
}
function Gu(t3, e2, s3, n5, i2) {
  return ku(t3, e2, s3, n5, i2);
}
function Wu(t3) {
  const e2 = Ue(t3);
  let s3 = false;
  {
    const n6 = new mi(t3.m_semiMajorAxis * Math.cos(t3.m_startAngle), t3.getSemiMinorAxis() * Math.sin(t3.m_startAngle));
    n6.rotateDirect(t3.m_cosr, t3.m_sinr), n6.addThis(t3.m_center);
    s3 = mi.distance(t3.getStartXY(), n6) > e2;
  }
  let n5 = false;
  if (!s3) {
    const s4 = new mi(t3.m_semiMajorAxis * Math.cos(t3.m_startAngle + t3.m_sweepAngle), t3.getSemiMinorAxis() * Math.sin(t3.m_startAngle + t3.m_sweepAngle));
    s4.rotateDirect(t3.m_cosr, t3.m_sinr), s4.addThis(t3.m_center);
    n5 = mi.distance(t3.getEndXY(), s4) > e2;
  }
  return !s3 && !n5;
}
function ju(e2, s3, n5, i2) {
  0 === n5 && P("construct_enclosing_circle");
  const o = [0, 0, 0], a2 = Fh(s3, n5, o);
  if (1 === a2) e2.constructCircleRadius(0, s3[o[0]], i2);
  else if (2 === a2) {
    const t3 = mi.lerp(s3[o[0]], s3[o[1]], 0.5), n6 = mi.distance(s3[o[0]], t3), r = mi.distance(s3[o[1]], t3);
    e2.constructCircleRadius(Math.max(n6, r), t3, i2);
  } else if (3 === a2) {
    const t3 = mi.calculateCircleCenterFromThreePoints(s3[o[0]], s3[o[1]], s3[o[2]]), n6 = mi.distance(s3[o[0]], t3), r = mi.distance(s3[o[1]], t3), a3 = mi.distance(s3[o[2]], t3);
    e2.constructCircleRadius(Math.max(n6, r, a3), t3, i2);
  } else b("unexpected");
}
function Zu(t3) {
  if (Eu(t3)) return 0;
  if (t3.isDegenerate(0)) return 0;
  const e2 = t3.m_semiMajorAxis, s3 = t3.getSemiMinorAxis(), n5 = e2 * e2 + s3 * s3, i2 = t3.getStartAngle(), r = t3.getEndAngle(), o = t3.m_center.y - t3.m_YStart, a2 = t3.m_cosr, h2 = t3.m_sinr;
  let u = 1, m3 = 0;
  t3.m_rotation && (u = (a2 - h2) * (a2 + h2), m3 = 2 * a2 * h2);
  const l2 = ((-0.5 * (r - i2) + 0.25 * u * (2 * Math.cos(r + i2) * Math.sin(r - i2))) * s3 + -2 * Math.sin(0.5 * (r + i2)) * Math.sin(0.5 * (r - i2)) * a2 * o) * e2 / n5;
  let c = 0;
  if (t3.m_rotation) {
    c = 0.125 * (-2 * Math.sin(r + i2) * Math.sin(r - i2)) * m3 - s3 * o / n5 * (2 * Math.cos(0.5 * (r + i2)) * Math.sin(0.5 * (r - i2))) * h2;
  }
  return n5 * (l2 + c) + -0.5 * (t3.m_XEnd - t3.m_XStart) * (t3.m_YEnd - t3.m_YStart);
}
function Hu(t3) {
  t3.queryCoord2D(0.5, t3.m_interior);
}
function Uu(t3, e2, s3, n5, i2) {
  if (i2) {
    if (0 !== am(e2, s3)) return 2;
  } else if (Ae(e2, s3)) return 1;
  return 0 !== Qu(t3, e2, s3, null, null, null, n5, void 0 !== i2 && i2, true, false) ? 4 : 0;
}
function Ou(t3, e2, s3, n5, i2) {
  if (i2) {
    if (0 !== am(e2, s3)) return 2;
  } else if (Ae(e2, s3)) return 1;
  return 0 !== Ku(t3, e2, s3, null, null, null, n5, void 0 !== i2 && i2, true, false) ? 4 : 0;
}
function Qu(t3, e2, s3, i2, r, o, a2, h2, u, m3) {
  if (Eu(e2)) {
    return Ds2(new pm({ start: e2.getStartXY(), end: e2.getEndXY() }), s3, i2, r, o, a2, h2, m3);
  }
  null !== r && (r.length = 0), null !== o && (o.length = 0), null !== i2 && (i2.length = 0);
  const l2 = Oe(e2, s3);
  if (Qe(e2, s3, a2 = Math.max(l2, a2))) return 0;
  const c = s3.getStartXY();
  c.subThis(e2.m_center);
  const g2 = s3.getEndXY();
  g2.subThis(e2.m_center), c.rotateReverse(e2.m_cosr, e2.m_sinr), g2.rotateReverse(e2.m_cosr, e2.m_sinr);
  const d2 = g2.clone();
  d2.subThis(c);
  const _ = e2.m_semiMajorAxis, p3 = 1 / _, f3 = e2.getSemiMinorAxis(), P5 = 1 / f3, y2 = d2.clone();
  y2.leftPerpendicularThis();
  const x4 = Math.atan2(f3 * y2.y, _ * y2.x), C3 = Yt(16, Number.NaN), v3 = Yt(16, Number.NaN);
  let b2 = 0;
  const E2 = [x4, x4 + Math.PI];
  for (let n5 = 0; n5 < 2; ++n5) {
    const t4 = lu(e2, E2[n5]);
    if (t4 >= 0 && t4 <= 1) {
      C3[b2] = t4;
      const n6 = e2.getCoord2D(C3[b2]);
      v3[b2] = s3.getClosestCoordinate(n6, false), mi.distance(n6, s3.getCoord2D(v3[b2])) <= a2 && b2++;
    }
  }
  const S3 = c.x * p3, D3 = c.y * P5, w4 = d2.x * p3, A4 = d2.y * P5;
  let T3 = sn(w4 * w4 + A4 * A4, 2 * (S3 * w4 + D3 * A4), S3 * S3 + D3 * D3 - 1, x2.unit(), false, v3);
  n(T3 >= 0);
  for (let n5 = 0; n5 < T3; n5++) {
    const t4 = d2.mul(v3[n5]).add(c);
    t4.x *= p3, t4.y *= P5;
    const i3 = lu(e2, Math.atan2(t4.y, t4.x));
    if (i3 >= 0 && i3 <= 1) {
      C3[b2] = i3;
      const t5 = e2.getCoord2D(i3);
      v3[b2] = s3.getClosestCoordinate(t5, false), mi.distance(t5, s3.getCoord2D(v3[b2])) <= a2 && b2++;
    }
  }
  n(b2 < C3.length + 4);
  const I4 = Yt(16, Number.NaN);
  T3 = e2.intersectPoint(s3.getStartXY(), I4, a2);
  for (let n5 = 0; n5 < T3; n5++, b2++) C3[b2] = I4[n5], v3[b2] = 0;
  T3 = e2.intersectPoint(s3.getEndXY(), I4, a2);
  for (let n5 = 0; n5 < T3; n5++, b2++) C3[b2] = I4[n5], v3[b2] = 1;
  T3 = s3.intersectPoint(e2.getStartXY(), I4, a2);
  for (let n5 = 0; n5 < T3; n5++, b2++) C3[b2] = 0, v3[b2] = I4[n5];
  T3 = s3.intersectPoint(e2.getEndXY(), I4, a2);
  for (let n5 = 0; n5 < T3; n5++, b2++) C3[b2] = 1, v3[b2] = I4[n5];
  return 0 === b2 ? 0 : cm(t3, e2, s3, C3, v3, b2, i2, r, o, a2, h2, u, m3);
}
function Ku(t3, e2, s3, i2, r, o, a2, h2, u, m3) {
  if (Eu(e2)) {
    const n5 = new pm({ start: e2.getStartXY(), end: e2.getEndXY() });
    return Qu(t3, s3, n5, i2, o, r, a2, h2, u, true);
  }
  if (Eu(s3)) {
    const n5 = new pm({ start: s3.getStartXY(), end: s3.getEndXY() });
    return Qu(t3, e2, n5, i2, r, o, a2, h2, u, m3);
  }
  const l2 = Oe(e2, s3);
  a2 = Math.max(a2, l2);
  let c = false;
  {
    const t4 = e2.getSemiAxes(), i3 = e2.getCenter(), m4 = s3.getSemiAxes(), l3 = s3.getCenter(), g3 = mi.distance(l3, i3), d3 = t4.x + m4.x;
    if (g3 > d3 + a2) return 0;
    if (t4.y > m4.x) {
      if (g3 + m4.x + a2 < t4.y) return 0;
    } else if (m4.y > t4.x && g3 + t4.x + a2 < m4.y) return 0;
    if (u && !h2) {
      const i4 = 1 === e2.m_minorMajorRatio && e2.isClosed() && e2.isMajor(), a3 = 1 === s3.m_minorMajorRatio && s3.isClosed() && s3.isMajor();
      if (i4 && a3 && (c = true, g3 <= d3)) {
        if (Math.max(t4.x, m4.x) <= Math.min(t4.x, m4.x) + g3) return n(!r && !o), 1;
      }
    }
  }
  if (!c && Qe(e2, s3, a2)) return 0;
  const g2 = [], d2 = [], _ = false, p3 = false, f3 = Wh(e2, 0, 0, _, p3, g2, d2, null), P5 = [], y2 = [], x4 = Wh(s3, 0, 0, _, p3, P5, y2, null);
  if (1 === f3 && 1 === x4) {
    const t4 = new Sn({ points: g2, weights: d2 }), n5 = new Sn({ points: P5, weights: y2 }), l3 = [], c2 = [], _2 = rh(false, t4, n5, i2, null === r ? null : l3, null === o ? null : c2, a2, h2, u, m3);
    if (_2 > 0 && null !== r || null !== o) {
      r && (r.length = 0), o && (o.length = 0);
      for (let i3 = 0; i3 < _2; ++i3) {
        if (r) if (Vs(l3[i3], 0, 1)) r.push(l3[i3]);
        else {
          const s4 = t4.tToLength(l3[i3]), n6 = e2.lengthToT(s4);
          r.push(n6);
        }
        if (o) if (Vs(c2[i3], 0, 1)) o.push(c2[i3]);
        else {
          const t5 = n5.tToLength(c2[i3]), e3 = s3.lengthToT(t5);
          o.push(e3);
        }
      }
    }
    return _2;
  }
  let C3 = [];
  const v3 = [];
  let b2 = 0;
  const E2 = u && !h2;
  for (let n5 = 0; n5 < f3; n5++) {
    const t4 = new Sn({ points: g2.slice(2 * n5, 2 * n5 + 3), weights: d2.slice(2 * n5, 2 * n5 + 3) });
    let i3 = 0;
    for (let r2 = 0; r2 < x4; r2++) {
      v3.length <= r2 && v3.push(new Sn({ points: P5.slice(2 * r2, 2 * r2 + 3), weights: y2.slice(2 * r2, 2 * r2 + 3) }));
      const o2 = [], h3 = [], u2 = E2 ? null : o2, m4 = E2 ? null : h3, l3 = rh(false, t4, v3[r2], null, u2, m4, a2, false, E2, false);
      if (l3 > 0 && E2) return 1;
      for (let a3 = 0; a3 < l3; ++a3) {
        if (0 === o2[a3] && 0 === n5) o2[a3] = 0;
        else if (1 === o2[a3] && n5 === f3 - 1) o2[a3] = 1;
        else {
          const s4 = t4.tToLength(o2[a3]) + b2, n6 = e2.lengthToT(s4);
          o2[a3] = n6;
        }
        if (0 === h3[a3] && 0 === r2) h3[a3] = 0;
        else if (1 === h3[a3] && r2 === x4 - 1) h3[a3] = 1;
        else {
          const t5 = v3[r2].tToLength(h3[a3]) + i3, e3 = s3.lengthToT(t5);
          h3[a3] = e3;
        }
        C3.push($t(o2[a3], h3[a3]));
      }
      i3 += v3[r2].calculateLength2D();
    }
    b2 += t4.calculateLength2D();
  }
  if (0 === C3.length) return 0;
  if (h2 && (C3 = C3.filter((t4) => !Vs(t4.first, 0, 1) || !Vs(t4.second, 0, 1) || !e2.getCoord2D(t4.first).equals(s3.getCoord2D(t4.second)))), u) return C3.length;
  const S3 = [], D3 = [];
  for (const n5 of C3) S3.push(n5.first), D3.push(n5.second);
  return cm(t3, e2, s3, S3, D3, S3.length, i2, r, o, a2, h2, u, m3);
}
function Ju(t3, e2, s3) {
  if (s3.setCoords(t3.getCoord2D(e2.vmin)), s3.mergeNe(t3.getCoord2D(e2.vmax)), Eu(t3)) return;
  const n5 = t3.getSemiAxes(), i2 = [0, 0, 0, 0];
  {
    const e3 = Math.atan2(-n5.y * t3.m_sinr, n5.x * t3.m_cosr), s4 = e3 + Math.PI, r2 = Math.atan2(n5.y * t3.m_cosr, n5.x * t3.m_sinr), o = r2 + Math.PI;
    i2[0] = lu(t3, e3), i2[1] = lu(t3, s4), i2[2] = lu(t3, r2), i2[3] = lu(t3, o);
  }
  const r = new mi();
  for (let o = 0; o < 4; o++) {
    const n6 = i2[o];
    e2.containsExclusiveCoordinate(n6) && (t3.queryCoord2D(n6, r), s3.mergeNe(r));
  }
}
function $u(t3, e2, s3, i2, r) {
  if (0 === t3.m_semiMajorAxis) return s3.vmin;
  let o = mi.getNAN();
  t3.queryCoord2D(s3.vmin, o);
  let a2 = mi.getNAN();
  if (t3.queryCoord2D(s3.vmax, a2), Eu(t3)) {
    return new pm({ start: o, end: a2 }).getClosestCoordinate(e2, i2);
  }
  const h2 = iu(t3, e2);
  if (o = iu(t3, o), a2 = iu(t3, a2), 1 === t3.m_minorMajorRatio) {
    if (h2.isEqual(0, 0)) return s3.vmin;
    const e3 = lu(t3, Math.atan2(h2.y, h2.x));
    if (i2 || s3.containsCoordinate(e3)) return e3;
    return mi.distance(h2, o) <= mi.distance(h2, a2) ? s3.vmin : s3.vmax;
  }
  const u = t3.getSemiMajorAxis(), m3 = t3.getSemiMinorAxis(), l2 = (u - m3) * (u + m3), c = H(l2), g2 = h2.x, d2 = h2.y, _ = H(m3 * d2), p3 = m3 * l2 * d2 * 2, f3 = [new p2(_), new p2(p3), new p2(c - H(u * g2) - _), new p2(-p3), new p2(-c)], P5 = Ot(p2, 4), y2 = _n(f3, 4, new x2(-1, 1), false, P5, 4);
  let x4 = s3.vmin, C3 = mi.sqrDistance(h2, o);
  {
    const t4 = mi.sqrDistance(h2, a2);
    t4 < C3 && (x4 = s3.vmax, C3 = t4);
  }
  n(!i2);
  let v3 = Yt(8, Number.NaN);
  for (let n5 = 0; n5 < y2; ++n5) {
    const e3 = P5[n5].value(), s4 = Math.sqrt(1 - e3 * e3), i3 = Math.atan2(e3, s4), r2 = Math.atan2(e3, -s4);
    v3[2 * n5] = lu(t3, i3), v3[2 * n5 + 1] = lu(t3, r2);
  }
  v3 = v3.slice(0, 2 * y2), qt(v3);
  for (let n5 = 0, b2 = 2 * y2; n5 < b2; ++n5) if (v3[n5] > s3.vmin && v3[n5] < s3.vmax) {
    const s4 = mi.sqrDistance(e2, t3.getCoord2D(v3[n5]));
    C3 > s4 && (C3 = s4, x4 = v3[n5]);
  }
  return x4;
}
function tm(t3, e2, s3) {
  n(!Eu(t3));
  const i2 = new x3();
  i2.setRotateAngle(-t3.getAxisXRotation());
  const r = new mi();
  i2.queryTransform(e2, r);
  const o = Math.atan2(-r.x * t3.getMinorMajorRatio(), r.y), a2 = o + Hs();
  let h2 = lu(t3, o), u = lu(t3, a2);
  u < h2 && (u = Pt(h2, h2 = u));
  let m3 = 0;
  return h2 >= 0 && h2 <= 1 && (s3[m3++] = h2), u >= 0 && u <= 1 && (s3[m3++] = u), m3;
}
function em(t3, e2, s3) {
  return t3.m_semiMajorAxis === e2.m_semiMajorAxis && (t3.isMajor() !== e2.isMajor() && (!!t3.m_center.equals(e2.m_center) && (t3.m_sinr === e2.m_sinr && (t3.m_cosr === e2.m_cosr && (t3.m_minorMajorRatio === e2.m_minorMajorRatio && (s3 ? t3.isClockwise() !== e2.isClockwise() : t3.isClockwise() === e2.isClockwise()))))));
}
function sm(t3, e2, s3) {
  if (Eu(t3)) s3.setE(ve.constructPoint2D(t3.getEndXY()).subE(ve.constructPoint2D(t3.getStartXY())));
  else {
    const n5 = new p2();
    gu(t3, e2, n5);
    const i2 = new ve();
    if (i2.setCoordsE(new p2(t3.m_semiMajorAxis).negate().mulE(new p2().setSin(n5)), new p2(t3.getSemiMinorAxis()).mulE(new p2().setCos(n5))), t3.m_rotation) {
      const e3 = new p2(t3.m_rotation);
      i2.rotateDirect(new p2().setCos(e3), new p2().setSin(e3));
    }
    i2.scaleThis(new p2(t3.getSweepAngle())), s3.setE(i2);
  }
}
function nm(t3, e2, s3, n5) {
  const i2 = t3.getStartXY(), r = t3.getEndXY(), o = i2.equals(r), a2 = e2.equals(s3);
  if (!o && !a2) {
    const n6 = new x3();
    n6.setShiftCoords(-t3.m_XStart, -t3.m_YStart);
    const o2 = mi.distance(e2, s3), a3 = mi.distance(i2, r), h3 = o2 / a3;
    n6.scale(h3, h3);
    const u2 = r.sub(i2);
    u2.divThis(a3);
    const m4 = s3.sub(e2);
    m4.divThis(o2);
    const l3 = u2.crossProduct(m4), c2 = m4.dotProduct(u2);
    return n6.rotate(c2, l3), n6.shiftCoords(e2.x, e2.y), void Au(t3, n6, true, e2, s3);
  }
  const h2 = new mi();
  if (t3.queryCoord2D(0.5, h2), a2) {
    if (o) {
      const n6 = t3.m_center.add(e2.sub(i2));
      t3.constructEllipticArcEndPointsCenter(e2, s3, t3.getSemiMajorAxis(), 1, 0, true, !t3.isClockwise(), n6), t3.setProjectionBehavior(0);
    } else if (t3.isMajor()) {
      const n6 = h2.sub(e2).getUnitVector().mul(2 * t3.getSemiMajorAxis()).add(e2);
      t3.constructCircularArcThreePoint(e2, s3, n6);
    } else t3.constructCircularArcThreePoint(e2, s3, e2);
    return;
  }
  const u = e2.add(s3).mul(0.5), m3 = s3.sub(e2);
  m3.rightPerpendicularThis();
  const l2 = u.add(m3), c = mi.getClosestCoordinate(u, l2, t3.getCenter(), true), g2 = new mi();
  Y(u, l2, c, g2);
  const d2 = mi.distance(e2, g2);
  t3.constructEllipticArcEndPointsCenter(e2, s3, d2, 1, 0, true, !t3.isClockwise(), g2), t3.setProjectionBehavior(0);
}
function im(t3, e2, s3, i2) {
  const r = t3.getStartXY(), o = t3.getEndXY(), a2 = r.equals(o), h2 = e2.equals(s3);
  if (!a2 && !h2) {
    const n5 = new x3();
    return n5.initializeFromTwoPoints(r, o, e2, s3), Au(t3, n5, true, e2, s3), t3.endPointModified(), void t3.normalizeAfterEndpointChange();
  }
  if (!t3.isMajor()) return void bu(t3, e2, s3, 1);
  if (a2 && h2) {
    const n5 = t3.m_center.add(e2.sub(r));
    return void t3.constructEllipticArcEndPointsCenter(e2, s3, t3.getSemiMajorAxis(), t3.getMinorMajorRatio(), t3.getAxisXRotation(), true, !t3.isClockwise(), n5);
  }
  if (!a2) {
    const n5 = 0.5 * ($s() - Math.abs(t3.getSweepAngle())), i3 = (t3.getSweepAngle() + n5 * K(t3.getSweepAngle())) / t3.getSweepAngle(), r2 = new mi();
    t3.queryCoord2D(i3, r2), t3.constructEllipticArcEndPointsCenter(r2, r2, t3.getSemiMajorAxis(), t3.getMinorMajorRatio(), t3.getAxisXRotation(), true, !t3.isClockwise(), t3.getCenter());
    const o2 = t3.getCenter().add(e2.sub(r2));
    return void t3.constructEllipticArcEndPointsCenter(e2, s3, t3.getSemiMajorAxis(), t3.getMinorMajorRatio(), t3.getAxisXRotation(), true, !t3.isClockwise(), o2);
  }
  const u = mi.sqrDistance(e2, s3);
  let m3 = 0.25, l2 = 0.75;
  if (u < mi.sqrDistance(t3.getCoord2D(0.25), t3.getCoord2D(0.75))) {
    const e3 = [0], s4 = tn(new su(t3, u), x2.construct(0, 0.25), 1, e3);
    s4 > 0 && (n(1 === s4), m3 = e3[0], l2 = 1 - e3[0]);
  }
  const c = t3.getCoord2D(m3), g2 = t3.getCoord2D(l2);
  n(!c.equals(g2)), t3.constructEllipticArcEndPointsCenter(c, g2, t3.getSemiMajorAxis(), t3.getMinorMajorRatio(), t3.getAxisXRotation(), true, !t3.isClockwise(), t3.m_center), im(t3, e2, s3);
}
function rm(t3, e2, s3, n5, i2) {
  return om(t3, false, e2, s3, n5, i2);
}
function om(t3, s3, n5, i2, o, a2) {
  const h2 = n5.getGeometryType(), u = i2.getGeometryType(), m3 = Math.max(o, Oe(n5, i2));
  if (h2 === a.enumLine && u === a.enumLine) return Ss2(n5, i2, m3, a2);
  let l2 = n5, c = i2, g2 = n5.getStartXY(), d2 = n5.getEndXY();
  if (g2.compare(d2) > 0 && (l2 = n5.clone().reverse()), g2 = i2.getStartXY(), d2 = i2.getEndXY(), g2.compare(d2) > 0 && (c = i2.clone().reverse()), s3) {
    if (n5.equals(i2)) return 2;
    if (Ne(n5, i2, m3)) return 4;
  }
  switch (h2) {
    case a.enumLine:
      switch (u) {
        case a.enumEllipticArc:
          return Uu(t3, c, l2, m3, a2);
        case a.enumBezier:
          return Eo(t3, c, l2, m3, a2);
        case a.enumRationalBezier2:
          return $a(t3, c, l2, m3, a2);
        case a.enumBezier2:
          return Xi(t3, c, l2, m3, a2);
        default:
          b("");
      }
      break;
    case a.enumEllipticArc:
      switch (u) {
        case a.enumLine:
          return Uu(t3, l2, c, m3, a2);
        case a.enumEllipticArc:
          return Ou(t3, l2, c, m3, a2);
        case a.enumBezier:
          return So(t3, c, l2, m3, a2);
        case a.enumRationalBezier2:
          return th(t3, c, l2, m3, a2);
        case a.enumBezier2:
          return qi(t3, c, l2, m3, a2);
        default:
          b("");
      }
      break;
    case a.enumBezier:
      switch (u) {
        case a.enumLine:
          return Eo(t3, l2, c, m3, a2);
        case a.enumEllipticArc:
          return So(t3, l2, c, m3, a2);
        case a.enumBezier:
          return Do(t3, l2, c, m3, a2);
        case a.enumRationalBezier2:
          return wo(t3, l2, c, m3, a2);
        case a.enumBezier2:
          return Ao(t3, l2, c, m3, a2);
        default:
          b("");
      }
      break;
    case a.enumRationalBezier2:
      switch (u) {
        case a.enumLine:
          return $a(t3, l2, c, m3, a2);
        case a.enumEllipticArc:
          return th(t3, l2, c, m3, a2);
        case a.enumBezier:
          return wo(t3, c, l2, m3, a2);
        case a.enumRationalBezier2:
          return eh(t3, l2, c, m3, a2);
        case a.enumBezier2:
          return sh(t3, l2, c, m3, a2);
        default:
          b("");
      }
      break;
    case a.enumBezier2:
      switch (u) {
        case a.enumLine:
          return Xi(t3, l2, c, m3, a2);
        case a.enumEllipticArc:
          return qi(t3, l2, c, m3, a2);
        case a.enumBezier:
          return Ao(t3, c, l2, m3, a2);
        case a.enumRationalBezier2:
          return sh(t3, c, l2, m3, a2);
        case a.enumBezier2:
          return Fi(t3, l2, c, m3, a2);
        default:
          b("");
      }
      break;
    default:
      b("");
  }
}
function am(t3, s3, n5 = true) {
  if (!n5 && !hm(t3, s3)) return 0;
  const i2 = t3.isLine() && s3.isLine();
  if (t3.getStartXY().equals(s3.getStartXY()) && t3.getEndXY().equals(s3.getEndXY())) {
    const n6 = 1;
    if (i2) return n6;
    const r = t3.getGeometryType();
    if (r !== s3.getGeometryType()) return 0;
    if (r === a.enumBezier) {
      const e2 = t3, i3 = s3;
      return e2.getControlPoint1().equals(i3.getControlPoint1()) && e2.getControlPoint2().equals(i3.getControlPoint2()) ? n6 : 0;
    }
    if (r === a.enumEllipticArc) {
      return em(t3, s3, false) ? n6 : 0;
    }
    if (r === a.enumRationalBezier2) {
      const e2 = t3, i3 = s3;
      if (e2.getControlPoint1().equals(i3.getControlPoint1()) && e2.getStandardFormWeight() === i3.getStandardFormWeight()) return n6;
    } else if (r === a.enumBezier2) {
      const e2 = s3;
      if (t3.getControlPoint1().equals(e2.getControlPoint1())) return n6;
    }
    return 0;
  }
  if (t3.getStartXY().equals(s3.getEndXY()) && t3.getEndXY().equals(s3.getStartXY())) {
    const n6 = -1;
    if (i2) return n6;
    const r = t3.getGeometryType();
    if (r !== s3.getGeometryType()) return 0;
    if (r === a.enumBezier) {
      const e2 = t3, i3 = s3;
      return e2.getControlPoint1().equals(i3.getControlPoint2()) && e2.getControlPoint2().equals(i3.getControlPoint1()) ? n6 : 0;
    }
    if (r === a.enumEllipticArc) {
      return em(t3, s3, true) ? n6 : -1;
    }
    if (r === a.enumRationalBezier2) {
      const e2 = t3, i3 = s3;
      if (e2.getControlPoint1().equals(i3.getControlPoint1()) && e2.getStandardFormWeight() === i3.getStandardFormWeight()) return n6;
    } else if (r === a.enumBezier2) {
      const e2 = s3;
      if (t3.getControlPoint1().equals(e2.getControlPoint1())) return n6;
    }
    return 0;
  }
  return 0;
}
function hm(t3, s3) {
  const n5 = t3.getGeometryType();
  return n5 === s3.getGeometryType() && (n5 !== a.enumEllipticArc || t3.projectionBehavior() === s3.projectionBehavior());
}
function um(s3, n5, i2, o, a2, h2, u) {
  !a2 && h2 && P("");
  const m3 = n5.getGeometryType(), l2 = i2.getGeometryType(), c = Math.max(u, Oe(n5, i2));
  if (o && (o.length = 0), a2 && (a2.length = 0), h2 && (h2.length = 0), m3 === a.enumLine && l2 === a.enumLine) return Ds2(n5, i2, o, a2, h2, c, false, false);
  let g2 = n5, d2 = i2, _ = n5.getStartXY(), p3 = n5.getEndXY(), f3 = false, P5 = false;
  _.compare(p3) > 0 && (g2 = n5.clone(true).reverse(), f3 = true), _ = i2.getStartXY(), p3 = i2.getEndXY(), _.compare(p3) > 0 && (d2 = i2.clone(true).reverse(), P5 = true);
  let y2 = 0;
  switch (m3) {
    case a.enumLine:
      switch (l2) {
        case a.enumEllipticArc:
          y2 = Qu(s3, d2, g2, o, h2, a2, c, false, false, true);
          break;
        case a.enumBezier:
          y2 = To(s3, d2, g2, o, h2, a2, c, false, false, true);
          break;
        case a.enumRationalBezier2:
          y2 = nh(s3, d2, g2, o, h2, a2, c, false, false, true);
          break;
        case a.enumBezier2:
          y2 = Vi(s3, d2, g2, o, h2, a2, c, false, false, true);
          break;
        default:
          b("");
      }
      break;
    case a.enumEllipticArc:
      switch (l2) {
        case a.enumLine:
          y2 = Qu(s3, g2, d2, o, a2, h2, c, false, false, false);
          break;
        case a.enumEllipticArc:
          y2 = Ku(s3, g2, d2, o, a2, h2, c, false, false, false);
          break;
        case a.enumBezier:
          y2 = Io(s3, d2, g2, o, h2, a2, c, false, false, true);
          break;
        case a.enumRationalBezier2:
          y2 = ih(s3, d2, g2, o, h2, a2, c, false, false, true);
          break;
        case a.enumBezier2:
          y2 = Li(s3, d2, g2, o, h2, a2, c, false, false, true);
          break;
        default:
          b("");
      }
      break;
    case a.enumRationalBezier2:
      switch (l2) {
        case a.enumLine:
          y2 = nh(s3, g2, d2, o, a2, h2, c, false, false, false);
          break;
        case a.enumEllipticArc:
          y2 = ih(s3, g2, d2, o, a2, h2, c, false, false, false);
          break;
        case a.enumBezier:
          y2 = Yo(s3, d2, g2, o, h2, a2, c, false, false, true);
          break;
        case a.enumRationalBezier2:
          y2 = rh(s3, g2, d2, o, a2, h2, c, false, false, false);
          break;
        case a.enumBezier2:
          y2 = oh(s3, g2, d2, o, a2, h2, c, false, false, false);
          break;
        default:
          b("");
      }
      break;
    case a.enumBezier2:
      switch (l2) {
        case a.enumLine:
          y2 = Vi(s3, g2, d2, o, a2, h2, c, false, false, false);
          break;
        case a.enumEllipticArc:
          y2 = Li(s3, g2, d2, o, a2, h2, c, false, false, false);
          break;
        case a.enumBezier:
          y2 = No(s3, d2, g2, o, h2, a2, c, false, false, true);
          break;
        case a.enumRationalBezier2:
          y2 = oh(s3, d2, g2, o, h2, a2, c, false, false, true);
          break;
        case a.enumBezier2:
          y2 = Ri(s3, g2, d2, o, a2, h2, c, false, false, false);
          break;
        default:
          b("");
      }
      break;
    case a.enumBezier:
      switch (l2) {
        case a.enumLine:
          y2 = To(s3, g2, d2, o, a2, h2, c, false, false, false);
          break;
        case a.enumEllipticArc:
          y2 = Io(s3, g2, d2, o, a2, h2, c, false, false, false);
          break;
        case a.enumBezier:
          y2 = Mo(s3, g2, d2, o, a2, h2, c, false, false, false);
          break;
        case a.enumRationalBezier2:
          y2 = Yo(s3, g2, d2, o, a2, h2, c, false, false, false);
          break;
        case a.enumBezier2:
          y2 = No(s3, g2, d2, o, a2, h2, c, false, false, false);
          break;
        default:
          b("");
      }
      break;
    default:
      b("");
  }
  if (f3) {
    if (a2) {
      for (let t3 = 0; t3 < y2; t3++) a2[t3] = 1 - a2[t3];
      a2.reverse();
    }
    o && o.reverse(), h2 && h2.reverse();
  }
  if (P5 && h2) for (let t3 = 0; t3 < y2; t3++) h2[t3] = 1 - h2[t3];
  return y2;
}
function mm(t3, e2, s3) {
  if (e2 === s3) return 0;
  e2 > s3 && (s3 = Pt(e2, e2 = s3));
  return t3.cut(e2, s3, true).calculateUpperLength2D();
}
function lm(t3, e2, s3, n5, i2) {
  const r = [], o = [], a2 = [];
  for (let u = 0, m3 = i2; u < m3; u++) r.push(t3.calculateSubLengthFromStart(s3[u])), o.push(e2.calculateSubLengthFromStart(n5[u])), Vs(s3[u], 0, 1) && Vs(n5[u], 0, 1) && t3.getCoord2D(s3[u]).equals(e2.getCoord2D(n5[u])) && a2.push(u);
  if (0 === a2.length || a2.length === i2) return;
  a2.sort((t4, e3) => s3[t4] < s3[e3] ? -1 : s3[t4] > s3[e3] ? 1 : n5[t4] < n5[e3] ? -1 : n5[t4] > n5[e3] ? 1 : 0);
  let h2 = -1;
  for (const u of a2) {
    if (h2 >= 0 && s3[u] === s3[h2] && s3[u] === s3[h2]) {
      h2 = u;
      continue;
    }
    h2 = u;
    const a3 = [];
    a3.length = i2;
    for (let t4 = 0; t4 < a3.length; ++t4) a3[t4] = t4;
    a3.sort((t4, e3) => {
      const s4 = r[u], n6 = o[u], i3 = r[t4] - s4, a4 = o[t4] - n6, h3 = i3 * i3 + a4 * a4, m3 = r[e3] - s4, l2 = o[e3] - n6, c = m3 * m3 + l2 * l2;
      return h3 < c ? -1 : h3 > c ? 1 : 0;
    });
    for (let r2 = 0; r2 < i2; r2++) {
      const i3 = a3[r2];
      if (i3 === u || s3[i3] === s3[u] && n5[i3] === n5[u] || Vs(s3[i3], 0, 1) && Vs(n5[i3], 0, 1)) continue;
      const o2 = (s4, n6, i4, r3) => {
        const o3 = new ve(), a4 = new p2();
        a4.setWithEps(1);
        const h4 = new p2();
        h4.set(n6, a4.eps()), t3.queryCoord2DE(h4, o3);
        const u2 = new ve();
        t3.queryCoord2DE(new p2(s4), u2);
        let m4 = false;
        return o3.eq(u2) && (h4.set(r3, a4.eps()), e2.queryCoord2DE(h4, o3), e2.queryCoord2DE(new p2(i4), u2), m4 = o3.eq(u2)), !m4;
      }, h3 = mi.getNAN();
      t3.queryCoord2D(s3[i3], h3);
      const m3 = mi.getNAN();
      e2.queryCoord2D(n5[i3], m3);
      if (0 === mi.distance(h3, m3) && o2(s3[u], s3[i3], n5[u], n5[i3])) break;
      const l2 = new x2(n5[i3], n5[u]);
      l2.normalizeNoNAN();
      const c = new x2(s3[i3], s3[u]);
      c.normalizeNoNAN();
      let g2 = -1, d2 = Number.POSITIVE_INFINITY, _ = Number.POSITIVE_INFINITY, p3 = s3[i3];
      h3.assign(t3.getCoord2D(p3));
      for (let r3 = 0; r3 < 5; r3++) {
        const r4 = e2.getClosestCoordinateOnInterval(h3, l2, -1);
        m3.assign(e2.getCoord2D(r4));
        const a4 = mi.distance(h3, m3);
        if (p3 = t3.getClosestCoordinateOnInterval(m3, c, -1), p3 === s3[u] && r4 === n5[u]) {
          g2 = 1;
          break;
        }
        h3.assign(t3.getCoord2D(p3));
        const f3 = mi.distance(m3, h3);
        if (!(f3 < _ && a4 < d2)) {
          g2 = 0;
          break;
        }
        if (0 === f3 && 0 === a4) {
          o2(s3[u], s3[i3], n5[u], n5[i3]) ? (s3[i3] = p3, n5[i3] = r4, g2 = 0) : g2 = 1;
          break;
        }
        _ = f3, d2 = a4;
      }
      if (-1 === g2 && (g2 = Vs(s3[i3], 0, 1) || Vs(n5[i3], 0, 1) ? 0 : 1), 1 !== g2) break;
      s3[i3] = s3[u], n5[i3] = n5[u];
    }
  }
}
function cm(t3, e2, s3, n5, i2, r, o, a2, h2, u, m3, l2, c) {
  if (!r) return 0;
  const g2 = (t4, e3) => {
    for (let s4 = 0; s4 < r; ++s4) {
      let n6 = e3[s4];
      if (Vs(n6, 0, 1)) {
        n6 = Xs(n6);
        continue;
      }
      const i3 = t4.getCoord2D(n6);
      n6 < 0.5 ? i3.equals(t4.getStartXY()) && mm(t4, 0, n6) <= Ue(t4) && (e3[s4] = 0) : i3.equals(t4.getEndXY()) && mm(t4, n6, 1) <= Ue(t4) && (e3[s4] = 1);
    }
  };
  g2(e2, n5), g2(s3, i2), lm(e2, s3, n5, i2, r);
  const d2 = [];
  for (let f3 = 0, P5 = r; f3 < P5; f3++) d2.push(f3);
  const _ = (t4, e3) => c ? Rt(i2[t4], n5[t4], i2[e3], n5[e3]) : Rt(n5[t4], i2[t4], n5[e3], i2[e3]);
  if (d2.length > 1) {
    d2.sort(_);
    const t4 = Math.max(Ue(e2), Ue(s3));
    let r2 = 0;
    for (let o2 = 1, a3 = d2.length; o2 < a3; o2++) {
      const a4 = n5[d2[r2]], h3 = n5[d2[o2]], u2 = i2[d2[r2]], m4 = i2[d2[o2]];
      if (a4 !== h3 || u2 !== m4) {
        if (mm(e2, a4, h3) <= t4 && mm(s3, u2, m4) <= t4 && !(Vs(a4, 0, 1) && Vs(u2, 0, 1) || Vs(h3, 0, 1) && Vs(m4, 0, 1))) {
          const t5 = mi.distance(e2.getCoord2D(a4), s3.getCoord2D(u2)), n6 = mi.distance(e2.getCoord2D(h3), s3.getCoord2D(m4));
          if (t5 <= n6) continue;
          if (n6 < t5) {
            d2[r2] = d2[o2];
            continue;
          }
          continue;
        }
        r2++, d2[r2] = d2[o2];
      }
    }
    if (d2.length = r2 + 1, 1 === d2.length && 0 !== d2[0] && (n5[0] = n5[d2[0]], i2[0] = i2[d2[0]], d2[0] = 0), d2.length > 2) {
      const t5 = x2.constructEmpty(), r3 = x2.constructEmpty();
      t5.setCoords(n5[d2[0]], n5[d2.at(-1)]), r3.setCoords(i2[d2[0]], i2[d2.at(-1)]);
      let o2 = true;
      for (let e3 = 1, s4 = d2.length - 1; e3 < s4; e3++) if (!t5.containsCoordinate(n5[d2[e3]]) || !r3.containsCoordinate(i2[d2[e3]])) {
        o2 = false;
        break;
      }
      if (o2) {
        const n6 = [0.5, 0.2, 0.7, 0.1, 0.3, 0.4, 0.6, 0.8, 0.9];
        for (let i3 = 0; i3 < n6.length; i3++) {
          let a3 = Q(t5.vmin, t5.vmax, n6[i3]);
          const h3 = e2.getCoord2D(a3);
          if (!s3.isCloserThanDistance(h3, r3, u)) {
            o2 = false;
            break;
          }
          a3 = Q(r3.vmin, r3.vmax, n6[i3]);
          const m4 = s3.getCoord2D(a3);
          if (!e2.isCloserThanDistance(m4, t5, u)) {
            o2 = false;
            break;
          }
        }
      }
      o2 && (d2[1] = d2.at(-1), d2.length = 2);
    }
  }
  if (1 === d2.length && t3) {
    const t4 = 0, r2 = 0;
    Ye(e2, s3, n5[0], i2[0], u, 1, [t4], [r2]) && (d2.push(1), n5[1] = t4, i2[1] = r2, d2.sort(_));
  }
  if (m3 && 1 === d2.length) {
    let t4 = true;
    for (let r2 = 0, o2 = d2.length; r2 < o2; r2++) {
      if (Vs(n5[d2[r2]], 0, 1) && Vs(i2[d2[r2]], 0, 1)) {
        if (0 === mi.distance(e2.getCoord2D(n5[d2[r2]]), s3.getCoord2D(i2[d2[r2]]))) continue;
      }
      t4 = false;
      break;
    }
    if (t4) return 0;
  }
  let p3 = 0;
  for (let f3 = 0, P5 = d2.length; f3 < P5; f3++) {
    if (a2 && a2.push(n5[d2[f3]]), h2 && h2.push(i2[d2[f3]]), o) {
      const t4 = mi.getNAN();
      e2.queryCoord2D(n5[d2[f3]], t4), o.push(t4);
    }
    p3++;
  }
  return p3;
}
function gm(t3, e2, s3, n5, i2, r, o, a2, h2) {
  if (Vs(s3, 0, 1) && Vs(n5, 0, 1)) {
    if (0 === mi.distance(t3.getCoord2D(s3), e2.getCoord2D(n5))) {
      const u = 1e-12, m3 = new ve(), l2 = Number.EPSILON;
      if (t3.queryDerivative(new p2(s3, l2), m3), m3.isTrueZero()) {
        const e3 = 1 === s3 ? -1e-12 : u;
        t3.queryDerivative(new p2(s3, l2).add(e3), m3);
      }
      1 === s3 && m3.negateThis();
      const c = new ve();
      if (e2.queryDerivative(new p2(n5, l2), c), c.isTrueZero()) {
        const t4 = 1 === s3 ? -1e-12 : u;
        e2.queryDerivative(new p2(n5, l2).add(t4), c);
      }
      1 === n5 && c.negateThis(), m3.isZero() || m3.normalize(), c.isZero() || c.normalize();
      const g2 = m3.dotProduct(c), d2 = m3.crossProduct(c);
      d2.scaleError(3);
      const _ = () => {
        if (h2) return 1e-3;
        {
          const s4 = t3.calculateUpperLength2D(), n6 = e2.calculateUpperLength2D();
          return Math.min(0.01 * i2 / Math.min(s4, n6), 1e-10);
        }
      };
      if (g2.ge(I2) && (d2.isZero() || Math.abs(d2.value()) < _())) {
        return Me(t3, e2, s3, n5, i2, r, o, a2);
      }
    }
  }
  return 0;
}
function dm(t3, e2, s3, i2, r) {
  let o = -1, a2 = -1, h2 = -1, u = -1;
  {
    const n5 = [0, e2], r2 = [e2, 0], m3 = [0, i2], l2 = [i2, 0];
    for (let e3 = 0; e3 < 2 && -1 === o; ++e3) for (let i3 = 0; i3 < 2; ++i3) if (t3[n5[e3]].equals(s3[m3[i3]])) {
      o = n5[e3], a2 = r2[e3], h2 = m3[i3], u = l2[i3];
      break;
    }
  }
  if (-1 === o) {
    const n5 = new pe();
    n5.setFromPoints(t3, e2 + 1);
    const o2 = new pe();
    return o2.setFromPoints(s3, i2 + 1), o2.inflate(r), n5.isIntersectingW(o2) ? -1 : 0;
  }
  {
    const m3 = Yt(e2 + 1, Number.NaN), l2 = xr(t3, e2 + 1, m3);
    n(l2 > 1);
    let c = 0, g2 = 0;
    for (let t4 = 0; t4 < l2; ++t4) o === m3[t4] && (g2 = t4, c++), a2 === m3[t4] && c++;
    if (2 !== c) return -1;
    const d2 = Yt(i2 + 1, Number.NaN), _ = xr(s3, i2 + 1, d2);
    n(_ > 1), c = 0;
    let p3 = 0;
    for (let t4 = 0; t4 < _; ++t4) h2 === d2[t4] && (p3 = t4, c++), u === d2[t4] && c++;
    if (2 !== c) return -1;
    const f3 = t3[m3[(g2 + l2 - 1) % l2]], P5 = t3[m3[(g2 + 1) % l2]], y2 = s3[d2[(p3 + _ - 1) % _]], x4 = s3[d2[(p3 + 1) % _]], C3 = t3[o], v3 = [f3, P5, y2, x4], b2 = [0, 1, 2, 3];
    b2.sort((t4, e3) => mi.compareVectorsOrigin(C3, v3[t4], v3[e3]));
    let E2 = b2[0];
    for (let t4 = 1; t4 < 4; t4++) {
      if (b2[t4] !== (E2 + 1) % 4) return -1;
      E2 = b2[t4];
    }
    {
      const t4 = f3.sub(C3), e3 = x4.sub(C3), s4 = e3.dotProduct(t4);
      if (s4 > 0) {
        const n5 = e3.crossProduct(t4), i3 = Math.abs(Math.atan2(n5, s4)), o2 = i3 * t4.length(), a3 = i3 * e3.length();
        if (o2 <= r || a3 <= r) return -1;
      }
    }
    {
      const t4 = P5.sub(C3), e3 = y2.sub(C3), s4 = e3.dotProduct(t4);
      if (s4 > 0) {
        const n5 = e3.crossProduct(t4), i3 = Math.abs(Math.atan2(n5, s4)), o2 = i3 * t4.length(), a3 = i3 * e3.length();
        if (o2 <= r || a3 <= r) return -1;
      }
    }
    return 1;
  }
}
var _m = z3;
var pm = class _pm extends ds2 {
  constructor(t3) {
    super(t3 || { XStart: 0, YStart: 0, XEnd: 0, YEnd: 0 });
  }
  assignMove(t3) {
    return this !== t3 && (this.m_description = t3.m_description, t3.m_description = null, this.m_attributes = t3.m_attributes, t3.m_attributes = null, this.m_XStart = t3.m_XStart, t3.m_XStart = Number.NaN, this.m_YStart = t3.m_YStart, this.m_XEnd = t3.m_XEnd, t3.m_XEnd = Number.NaN, this.m_YEnd = t3.m_YEnd), this;
  }
  assignCopy(t3) {
    return this !== t3 && t3.copyTo(this), this;
  }
  calculateLowerLength3D() {
    return n(0), 0;
  }
  calculateUpperLength3D() {
    return n(0), 0;
  }
  changeEndPoints3D(t3, e2) {
    n(0);
  }
  getClosestCoordinate3D(t3, e2, s3) {
    return n(0), 0;
  }
  getBoundary() {
    return Js2(this);
  }
  getAttributeAsDbl(t3, e2, s3) {
    if (0 === e2) return 0 === s3 ? fs2(this, t3) : Ps2(this, t3);
    const n5 = _m.getInterpolation(e2), i2 = this.getStartAttributeAsDbl(e2, s3), r = this.getEndAttributeAsDbl(e2, s3);
    return It(n5, i2, r, t3, _m.getDefaultValue(e2));
  }
  constructFromCoords(t3, e2, s3, n5) {
    this.dropAllAttributes(), this.setStartXYCoords(t3, e2), this.setEndXYCoords(s3, n5);
  }
  construct(t3, e2) {
    this.dropAllAttributes(), this.setStartXY(t3), this.setEndXY(e2);
  }
  construct3D(t3, e2) {
    n(0);
  }
  constructPoint(t3, e2) {
    this.assignVertexDescription(t3.getDescription()), this.mergeVertexDescription(e2.getDescription()), this.setStart(t3), this.setEnd(e2);
  }
  getGeometryType() {
    return _pm.type;
  }
  queryEnvelope(t3) {
    if (4 === t3.m_EnvelopeType) {
      t3.setEmpty(), t3.assignVertexDescription(this.m_description);
      const e2 = n3.constructEmpty();
      this.queryEnvelope(e2), t3.setEnvelope(e2);
      for (let s3 = 1, n5 = this.m_description.getAttributeCount(); s3 < n5; s3++) {
        const e3 = this.m_description.getSemantics(s3);
        for (let n6 = 0, i2 = _m.getComponentCount(e3); s3 < i2; s3++) {
          const s4 = this.queryInterval(e3, n6);
          t3.setIntervalEnvelope(e3, n6, s4);
        }
      }
    } else 2 === t3.m_EnvelopeType ? t3.setCoords({ xmin: this.m_XStart, ymin: this.m_YStart, xmax: this.m_XEnd, ymax: this.m_YEnd }) : 3 === t3.m_EnvelopeType ? (t3.setEmpty(), t3.mergeCoords(this.m_XStart, this.m_YStart, We(this, 0, 1, 0)), t3.mergeCoords(this.m_XEnd, this.m_YEnd, We(this, 1, 1, 0))) : z("env type not impl");
  }
  applyTransformation(t3) {
    n(t3 instanceof x3);
    const e2 = new mi();
    e2.x = this.m_XStart, e2.y = this.m_YStart, t3.transformInPlace(e2), this.m_XStart = e2.x, this.m_YStart = e2.y, e2.x = this.m_XEnd, e2.y = this.m_YEnd, t3.transformInPlace(e2), this.m_XEnd = e2.x, this.m_YEnd = e2.y;
  }
  createInstance() {
    return new _pm({ vd: this.m_description });
  }
  calculateLength2D() {
    return Math.sqrt(Xs2(this));
  }
  calculateLength3D(t3) {
    return n(0), 0;
  }
  changeEndPoints2D(t3, e2) {
    this.setStartXY(t3), this.setEndXY(e2), this.normalizeAfterEndpointChange();
  }
  queryControlPointsHelper(t3) {
    return n(t3.length >= 2), t3[0] = this.getStartXY(), t3[1] = this.getEndXY(), 2;
  }
  queryCoord2D(t3, e2) {
    return _s2(this, t3, e2);
  }
  queryCoord3D(t3, e2) {
    n(0);
  }
  getCoordZ(t3) {
    return ys(this, t3);
  }
  queryCoord2DE(t3, e2) {
    Cs(this, t3, e2);
  }
  queryCoord2DMP(t3, e2) {
    e2.assignPoint2D(this.getStartXY());
    const s3 = Ee.constructPoint2D(this.getEndXY());
    s3.subThis(e2), s3.mulThis(si.constructDouble(t3)), e2.addThis(s3);
  }
  getCoordX(t3) {
    return fs2(this, t3);
  }
  getCoordY(t3) {
    return Ps2(this, t3);
  }
  cut(t3, e2, s3) {
    const n5 = new fm();
    return this.queryCut(t3, e2, n5, s3), n5.releaseSegment();
  }
  queryCut(t3, e2, s3, n5) {
    const i2 = s3.createLine();
    n5 && i2.assignVertexDescription(this.m_description);
    const r = mi.getNAN();
    if (_s2(this, t3, r), i2.setStartXYCoords(r.x, r.y), _s2(this, e2, r), i2.setEndXYCoords(r.x, r.y), !n5) for (let o = 1, a2 = this.m_description.getAttributeCount(); o < a2; o++) {
      const s4 = this.m_description.getSemantics(o), n6 = _m.getComponentCount(s4);
      for (let r2 = 0; r2 < n6; r2++) {
        const n7 = this.getAttributeAsDbl(t3, s4, r2);
        i2.setStartAttribute(s4, r2, n7);
        const o2 = this.getAttributeAsDbl(e2, s4, r2);
        i2.setEndAttribute(s4, r2, o2);
      }
    }
  }
  queryDerivative(t3, e2) {
    xs(this, t3, e2);
  }
  getClosestCoordinate(t3, e2) {
    return mi.getClosestCoordinate(this.getStartXY(), this.getEndXY(), t3, e2);
  }
  getClosestCoordinateOnInterval(t3, e2, s3 = -1) {
    const n5 = new mi();
    this.queryCoord2D(e2.vmin, n5);
    const i2 = new mi();
    this.queryCoord2D(e2.vmax, i2);
    const r = mi.getClosestCoordinate(n5, i2, t3, false);
    return $e.recalculateParentT(e2.vmin, e2.vmax, r);
  }
  intersectionOfYMonotonicWithAxisX(t3, e2) {
    const s3 = this.m_YEnd - this.m_YStart;
    if (!s3) return t3 === this.m_YEnd ? e2 : Number.NaN;
    const n5 = (t3 - this.m_YStart) / s3;
    let i2 = fs2(this, n5);
    return 1 === n5 && (i2 = this.m_XEnd), i2;
  }
  isCurve() {
    return false;
  }
  isMonotoneQuickAndDirty() {
    return true;
  }
  isDegenerate(t3) {
    const e2 = this.m_XStart - this.m_XEnd, s3 = this.m_YStart - this.m_YEnd;
    return Math.sqrt(e2 * e2 + s3 * s3) <= t3;
  }
  isDegenerate3D(t3, e2) {
    return n(0), false;
  }
  queryLooseEnvelope(t3) {
    this.queryEnvelope(t3);
  }
  clone(t3) {
    const e2 = new _pm();
    return this.copyTo(e2), e2;
  }
  tToLength(t3) {
    return t3 * this.calculateLength2D();
  }
  lengthToT(t3) {
    const e2 = this.calculateLength2D();
    return 0 !== e2 ? t3 / e2 : 0;
  }
  calculateWeightedAreaCentroid2D(t3) {
    const e2 = new mi();
    return e2.setCoords(0, 0), e2;
  }
  calculateWeightedCentroid2D() {
    return this.getCoord2D(0.5).mul(this.calculateLength2D());
  }
  getTangent(t3) {
    const e2 = mi.getNAN();
    return e2.setSub(this.getEndXY(), this.getStartXY()), e2;
  }
  getDerivative(t3) {
    const e2 = new mi();
    return e2.setSub(this.getEndXY(), this.getStartXY()), e2;
  }
  getCurvature(t3) {
    return 0;
  }
  isIntersectingPoint(t3, e2, s3) {
    return Is(this, t3, e2, s3) >= 0;
  }
  isIntersectingPoint3D(t3, e2, s3, i2, r = 1) {
    return n(0), false;
  }
  getYMonotonicParts(t3, e2) {
    return 0;
  }
  getMonotonicParts(t3, e2) {
    return 0;
  }
  getMonotonicPartParams(e2, s3) {
    return s3 && (e2 < 2 && P(""), s3[0] = 0, s3[1] = 1), 2;
  }
  intersectionWithAxis2D(t3, e2, s3, n5) {
    if (t3) {
      const t4 = this.m_YEnd - this.m_YStart;
      if (!t4) return e2 === this.m_YEnd ? -1 : 0;
      const i2 = (e2 - this.m_YStart) / t4;
      return i2 < 0 || i2 > 1 ? 0 : (s3 && (s3[0] = fs2(this, i2)), n5 && (n5[0] = i2), 1);
    }
    {
      const t4 = this.m_XEnd - this.m_XStart;
      if (!t4) return e2 === this.m_XEnd ? -1 : 0;
      const i2 = (e2 - this.m_XStart) / t4;
      return i2 < 0 || i2 > 1 ? 0 : (s3 && (s3[0] = Ps2(this, i2)), n5 && (n5[0] = i2), 1);
    }
  }
  calculateUpperLength2D() {
    return this.calculateLength2D();
  }
  calculateLowerLength2D() {
    return this.calculateLength2D();
  }
  normalizeAfterEndpointChange() {
    return false;
  }
  queryLooseEnvelopeOnInterval(t3, e2) {
    if (2 === e2.m_EnvelopeType) {
      let s3 = Us(t3.vmin, 0, 1);
      const n5 = new mi();
      return this.queryCoord2D(s3, n5), e2.setCoords({ pt: n5 }), s3 = Us(t3.vmax, 0, 1), this.queryCoord2D(s3, n5), void e2.mergeNe(n5);
    }
    z("3d dst not impl");
  }
  orientBottomUp() {
    Es(this);
  }
  isLine() {
    return true;
  }
  isDegenerateToLineHelper(t3) {
    return true;
  }
  copyIgnoreAttributes(t3) {
    t3.setStartXY(this.getStartXY()), t3.setEndXY(this.getEndXY()), t3.normalizeAfterEndpointChange();
  }
  calculateArea2DHelper() {
    return 0;
  }
  absNormXYZ(t3) {
    return bs2(this, t3);
  }
  absNorm() {
    return this.getStartXY().norm(1) + this.getEndXY().norm(1);
  }
  queryEnvelopeW(t3, e2) {
    e2.setCoords(this.getCoord2D(t3.vmin)), e2.mergeNe(this.getCoord2D(t3.vmax));
  }
  setSegmentFromCoordsForStitcher(t3, e2) {
    vs2(this, t3[0], t3[e2 - 1]);
  }
  writeInBufferStream(t3, e2) {
    return n(0), 0;
  }
  readFromBufferStream(t3, e2) {
    n(0);
  }
  snapControlPoints(t3) {
    return false;
  }
  needsSnapControlPoints(t3) {
    return false;
  }
  calculateSpecialPointsForCracking(t3, e2) {
    return 0;
  }
  ensureXYMonotone() {
    return false;
  }
  setCoordsForIntersector(t3, e2, s3) {
    vs2(this, t3, e2);
  }
  static isIntersectingLineLine(t3, e2, s3, n5) {
    return Ss2(t3, e2, s3, n5);
  }
  static isIntersectingLineLine_(t3, e2, s3, n5) {
    return Ss2(t3, e2, s3, n5);
  }
  copyToImpl(t3) {
  }
  reverseImpl() {
  }
  equalsImpl(t3) {
    return true;
  }
  equalsImplTol(t3, e2) {
    return true;
  }
  swapImpl(t3) {
  }
  afterCompletedModification() {
  }
  endPointModified() {
  }
  clearEndPointModified() {
  }
  intersect(t3, e2, s3, n5, i2) {
    return um(false, this, t3, e2, s3, n5, i2);
  }
  intersectPoint(t3, e2, s3) {
    e2.length < 1 && A("");
    const n5 = Is(this, t3, s3, false);
    return n5 >= 0 ? (e2 && (e2[0] = n5), 1) : 0;
  }
  isIntersecting(t3, e2, s3) {
    return 0 !== rm(false, this, t3, e2, s3);
  }
};
pm.type = a.enumLine;
var fm = class _fm {
  constructor(t3) {
    this.m_seg = null, this.m_curves = null, this.m_lineBuffer = new pm(), this.m_mask = 0, this.m_active = 0, void 0 !== t3 && (t3.copy ? t3.copy.copyTo(this, false) : t3.move ? this.assignMove(t3.move) : t3.segment ? this.copyFrom(t3.segment, !!t3.bIgnoreAttributes) : b("bad constructor params"));
  }
  assignCopy(t3) {
    return t3 instanceof _fm ? this !== t3 && t3.copyTo(this, false) : this.copyFrom(t3, false), this;
  }
  assignMove(t3) {
    if (t3 instanceof _fm) {
      if (this === t3) return this;
      this.reset(), 1 & t3.m_mask && (this.m_lineBuffer = t3.m_lineBuffer, t3.m_lineBuffer = null, this.m_mask = 1), this.m_curves = t3.m_curves, this.m_mask = t3.m_mask, this.m_active = t3.m_active, t3.reset(), this.m_seg = this.activeSegment(), t3.m_seg = null;
    } else {
      if (this.m_seg === t3) return this;
      this.create(t3.getGeometryType()), this.m_seg.swap(t3);
    }
    return this;
  }
  activeSegment() {
    switch (this.m_active) {
      case 0:
        return null;
      case 1:
        return this.line();
      case 2:
        return this.arc();
      case 4:
        return this.bezier3();
      case 8:
        return this.bezier2();
      case 16:
        return this.rbezier2();
      default:
        b("");
    }
  }
  get() {
    return this.m_seg;
  }
  reset() {
    1 & this.m_mask && (this.m_lineBuffer = null), this.m_mask > 1 && (this.m_curves = null), this.m_mask = 0, this.m_active = 0;
  }
  empty() {
    return null === this.m_seg;
  }
  copyTo(t3, e2) {
    this !== t3 && (this.empty() ? t3.m_seg = null : t3.copyFrom(this.m_seg, e2));
  }
  copyToWithZ(t3, e2) {
    n(0);
  }
  createImpl(s3) {
    switch (s3) {
      case a.enumLine:
        1 & this.m_mask || (this.m_lineBuffer = new pm(), this.m_mask |= 1, this.m_active = 1);
        break;
      case a.enumEllipticArc:
        2 & this.m_mask || (this.m_curves = new Xh(), this.m_mask = 1 & this.m_mask | 2, this.m_active = 2);
        break;
      case a.enumBezier:
        4 & this.m_mask || (this.m_curves = new ia(), this.m_mask = 1 & this.m_mask | 4, this.m_active = 4);
        break;
      case a.enumBezier2:
        8 & this.m_mask || (this.m_curves = new wn(), this.m_mask = 1 & this.m_mask | 8, this.m_active = 8);
        break;
      case a.enumRationalBezier2:
        16 & this.m_mask || (this.m_curves = new Sn(), this.m_mask = 1 & this.m_mask | 16, this.m_active = 16);
        break;
      default:
        P("");
    }
  }
  create(s3) {
    s3 === a.enumLine ? this.createLine() : s3 === a.enumEllipticArc ? this.createEllipticArc() : s3 === a.enumBezier ? this.createCubicBezier() : s3 === a.enumRationalBezier2 ? this.createQuadraticRationalBezier() : s3 === a.enumBezier2 ? this.createQuadraticBezier() : P("Segment_buffer.create");
  }
  copyFrom(t3, e2) {
    this.m_seg !== t3 && (this.create(t3.getGeometryType()), e2 ? t3.copyIgnoreAttributes(this.m_seg) : t3.copyTo(this.m_seg));
  }
  copyFromWithZ(t3, e2) {
    n(0);
  }
  line() {
    return this.m_lineBuffer;
  }
  arc() {
    return this.m_curves;
  }
  bezier3() {
    return this.m_curves;
  }
  bezier2() {
    return this.m_curves;
  }
  rbezier2() {
    return this.m_curves;
  }
  createLine() {
    return this.createImpl(a.enumLine), this.m_seg = this.line(), this.line();
  }
  createEllipticArc() {
    return this.createImpl(a.enumEllipticArc), this.m_seg = this.arc(), this.arc();
  }
  createCubicBezier() {
    return this.createImpl(a.enumBezier), this.m_seg = this.bezier3(), this.bezier3();
  }
  createQuadraticRationalBezier() {
    return this.createImpl(a.enumRationalBezier2), this.m_seg = this.rbezier2(), this.rbezier2();
  }
  createQuadraticBezier() {
    return this.createImpl(a.enumBezier2), this.m_seg = this.bezier2(), this.bezier2();
  }
  releaseSegment() {
    if (this.m_seg = null, 0 === this.m_active && b("releaseSegment"), 1 & this.m_active) {
      const t4 = this.line();
      return this.m_mask -= 1, this.m_active = 0, this.m_lineBuffer = null, t4;
    }
    let t3;
    return 2 & this.m_active ? t3 = this.arc() : 4 & this.m_active ? t3 = this.bezier3() : 8 & this.m_active ? t3 = this.bezier2() : 16 & this.m_active ? t3 = this.rbezier2() : b("releaseSegment"), this.m_mask -= this.m_active, this.m_active = 0, this.m_curves = null, t3;
  }
  equals(t3) {
    return t3 instanceof _fm ? this === t3 || (this.empty() ? t3.empty() : !t3.empty() && this.get().equals(t3.get())) : (z("seg comparison not yet impl"), false);
  }
};

// node_modules/@arcgis/core/chunks/OperatorClip.js
function f2(e2, t3, s3, i2, n5) {
  return v2(e2, t3, null, s3, i2, n5);
}
function v2(e2, s3, o, x4, p3, c) {
  const l2 = e2.getGeometryType();
  if (l2 === a.enumPoint) {
    const t3 = e2.getXY();
    return s3.contains(t3) ? e2 : e2.createInstance();
  }
  if (l2 === a.enumEnvelope) {
    const t3 = n3.constructEmpty();
    if (e2.queryEnvelope(t3), t3.intersect(s3)) {
      const s4 = e2.clone();
      return s4.setEnvelope(t3), s4;
    }
    return e2.createInstance();
  }
  if (e2.isEmpty()) return e2;
  if (s3.isEmpty()) return e2.createInstance();
  const _ = s3.clone();
  {
    const t3 = new n3();
    if (e2.queryLooseEnvelope(t3), _.containsEnvelope(t3)) return e2;
    if (!_.isIntersecting(t3)) return e2.createInstance();
    0 === p3 && (t3.intersect(_), t3.inflate(Math.max(0.1 * t3.maxDimension(), 1)), t3.intersect(_), _.assign(t3));
  }
  let u = x4;
  if ((null !== o || Number.isNaN(u)) && (u = At(o, _, false).total()), l2 === a.enumGeometryCollection) {
    const t3 = e2, s4 = e2.createInstance();
    for (let e3 = 0, i2 = t3.getGeometryCount(); e3 < i2; e3++) {
      const i3 = t3.getGeometry(e3);
      if (i3.isEmpty()) continue;
      const n5 = f2(i3, _, u, p3, c);
      n5.isEmpty() || (n5 === i3 ? s4.addGeometry(n5.clone()) : s4.addGeometry(n5));
    }
    return s4;
  }
  y(l2) || P("Clip: geometry not supported");
  const g2 = e2.getImpl().getAccelerators();
  if (null !== g2) {
    const e3 = g2.getRasterizedGeometry();
    n(null === e3);
  }
  switch (l2) {
    case a.enumMultiPoint: {
      const t3 = e2;
      let s4;
      const i2 = t3.getPointCount(), n5 = t3.getImpl().getAttributeStreamRef(0);
      let h2 = 0;
      for (let e3 = 0; e3 < i2; e3++) {
        const i3 = n5.readPoint2D(2 * e3);
        _.contains(i3) || (0 === h2 && (s4 = t3.createInstance()), h2 < e3 && s4.addPoints(t3, h2, e3), h2 = e3 + 1);
      }
      return h2 > 0 && s4.addPoints(t3, h2, i2), 0 === h2 ? t3 : (n(null !== s4), s4);
    }
    case a.enumPolygon:
    case a.enumPolyline:
      return P4(e2, _, u, p3, c);
    default:
      b("");
  }
}
function d(e2, t3, s3, i2, n5, r) {
  const h2 = new E(t3, r), m3 = new n3();
  return e2.queryLooseEnvelope(m3), t3.containsEnvelope(m3) ? e2 : t3.isIntersecting(m3) ? h2.clipPolesOut(e2, n5) : e2.createInstance();
}
function P4(e2, t3, s3, i2, n5) {
  return new E(t3, n5).clipMultiPath2(e2, s3, i2);
}
var E = class _E {
  constructor(e2, t3) {
    this.m_shape = new Pr(), this.m_geometry = cr, this.m_verticesOnExtentIndex = -1, this.m_verticesOnExtent = [], this.m_progressCounter = 0, this.m_extent = new n3(e2), this.m_progressTracker = t3;
  }
  progress_() {
  }
  clipMultiPath2(e2, t3, s3) {
    return e2.getGeometryType() === a.enumPolygon ? this.clipPolygonOrProjectedPolyline2(e2, s3) : this.clipPolyline(e2, t3);
  }
  clipPolygonOrProjectedPolyline2(e2, t3) {
    const s3 = e2.getGeometryType() === a.enumPolyline;
    if (0 === this.m_extent.width() || 0 === this.m_extent.height()) return e2.createInstance();
    const n5 = n3.constructEmpty();
    e2.queryLooseEnvelope(n5), this.m_geometry = s3 ? this.m_shape.addGeometry(e2) : this.m_shape.addGeometry(e2, this.m_extent);
    const h2 = n3.constructEmpty(), m3 = n3.constructEmpty(), o = new mi(), c = new mi(), g2 = Yt(9, Number.NaN), y2 = Yt(9, Number.NaN), f3 = Ot(mi, 9);
    let v3 = null;
    const d2 = new pm(), P5 = [];
    let I4 = false;
    for (let i2 = 0; !I4 && i2 < 4; i2++) {
      let e3 = false;
      const t4 = !!(1 & i2);
      let a2 = 0;
      switch (i2) {
        case 0:
          a2 = this.m_extent.xmin, e3 = n5.xmin <= a2 && n5.xmax >= a2;
          break;
        case 1:
          a2 = this.m_extent.ymin, e3 = n5.ymin <= a2 && n5.ymax >= a2;
          break;
        case 2:
          a2 = this.m_extent.xmax, e3 = n5.xmin <= a2 && n5.xmax >= a2;
          break;
        case 3:
          a2 = this.m_extent.ymax, e3 = n5.ymin <= a2 && n5.ymax >= a2;
      }
      if (e3) {
        I4 = true;
        for (let e4 = this.m_shape.getFirstPath(this.m_geometry); e4 !== cr; ) {
          let n6 = true, p3 = -1, l2 = -1;
          const _ = this.m_shape.getFirstVertex(e4);
          let u = _;
          do {
            this.progress_(), v3 = this.m_shape.getSegment(u);
            let e5 = v3;
            if (null === e5) {
              const t5 = this.m_shape.getNextVertex(u);
              if (t5 === cr) {
                n(s3), 0 === p3 && P5.push(u);
                break;
              }
              this.m_shape.queryXY(u, o), d2.setStartXY(o), this.m_shape.queryXY(t5, c), d2.setEndXY(c), e5 = d2;
            }
            e5.queryLooseEnvelope(h2);
            let _2 = _E.checkSegmentIntersection(h2, i2, a2);
            e5.isCurve() && 0 === _2 && e5.isCurve() && (d2.setStartXY(e5.getStartXY()), d2.setEndXY(e5.getEndXY()), this.m_shape.replaceCurveWithLine(u), e5 = d2, d2.queryEnvelope(h2), _2 = _E.checkSegmentIntersection(h2, i2, a2));
            let V5 = 0, X3 = cr;
            if (-1 === _2) {
              const s4 = e5.intersectionWithAxis2D(t4, a2, g2, y2);
              if (s4 > 0) {
                let i3 = null;
                if (e5.isCurve()) {
                  i3 = f3, n(s4 <= 9);
                  for (let e6 = 0; e6 < s4; e6++) t4 ? f3[e6].setCoords(g2[e6], a2) : f3[e6].setCoords(a2, g2[e6]);
                  V5 = this.m_shape.splitSegmentAxisAware(u, y2, s4, i3, t4 ? 1 : 0);
                } else V5 = this.m_shape.splitSegmentAxisAware(u, y2, s4, null, -1);
              } else V5 = 0;
              V5 += 1;
              let h3 = u, x4 = this.m_shape.getNextVertex(h3);
              e5 = null;
              for (let e6 = 0; e6 < V5; e6++) {
                this.m_shape.queryXY(h3, o), this.m_shape.queryXY(x4, c), v3 = this.m_shape.getSegment(h3);
                let e7 = v3;
                null === e7 && (d2.setStartXY(o), d2.setEndXY(c), e7 = d2), e7.queryEnvelope(m3);
                let s5 = _E.checkSegmentIntersection(m3, i2, a2);
                if (e7.isCurve() && 0 === s5 && (this.m_shape.replaceCurveWithLine(h3), d2.setStartXY(o), d2.setEndXY(c), e7 = d2, e7.queryEnvelope(m3), s5 = _E.checkSegmentIntersection(m3, i2, a2)), -1 === s5) {
                  if (t4) {
                    Math.abs(o.y - a2) < Math.abs(c.y - a2) ? (o.y = a2, this.m_shape.setXY(h3, o)) : (c.y = a2, this.m_shape.setXY(x4, c));
                  } else {
                    Math.abs(o.x - a2) < Math.abs(c.x - a2) ? (o.x = a2, this.m_shape.setXY(h3, o)) : (c.x = a2, this.m_shape.setXY(x4, c));
                  }
                  v3 = this.m_shape.getSegment(h3), e7 = v3, null === e7 && (d2.setStartXY(o), d2.setEndXY(c), e7 = d2), e7.queryEnvelope(m3), s5 = _E.checkSegmentIntersection(m3, i2, a2), -1 === s5 && (s5 = _E.checkSegmentIntersectionLoose(m3, i2, a2));
                }
                const r = p3;
                p3 = s5, -1 === l2 && (l2 = p3), 0 === r && 1 === p3 || 1 === r && 0 === p3 || 0 === r && 0 === p3 && P5.push(h3), 1 === p3 && (I4 = false, n6 = false), h3 = x4, X3 = h3, x4 = this.m_shape.getNextVertex(x4);
              }
            }
            if (0 === V5) {
              const e6 = p3;
              p3 = _2, -1 === l2 && (l2 = p3), 0 === e6 && p3 >= 1 || e6 >= 1 && 0 === p3 || 0 === e6 && 0 === p3 && P5.push(u), 1 === p3 && (I4 = false, n6 = false), X3 = this.m_shape.getNextVertex(u);
            }
            if (u = X3, P5.length >= 256) {
              for (let e6 = 1, t5 = P5.length - 1; e6 < t5; e6++) {
                const t6 = P5[e6];
                s3 ? this.m_shape.snapVertexForPoleClipping(t6, a2) : this.m_shape.removeVertex(t6, false);
              }
              P5[1] = P5.at(-1), P5.length = 2;
            }
          } while (u !== _);
          if (!n6) {
            0 !== l2 || !s3 && 0 !== p3 && 2 !== p3 || P5.push(_);
            for (let e5 = 0, t5 = P5.length; e5 < t5; e5++) {
              const t6 = P5[e5];
              s3 ? this.m_shape.snapVertexForPoleClipping(t6, a2) : this.m_shape.removeVertex(t6, false);
            }
          }
          P5.length = 0, e4 = n6 || 0 === this.m_shape.getPathSize(e4) ? this.m_shape.removePath(e4) : this.m_shape.getNextPath(e4);
        }
      }
    }
    if (I4) return e2.createInstance();
    v3 = null, s3 ? this.removeSpikesAlongPoles() : this.resolveBoundaryOverlaps(), t3 > 0 && this.densifyAlongClipExtent(t3);
    const V4 = this.m_shape.getGeometry(this.m_geometry);
    if (V4.getGeometryType() === a.enumPolygon) {
      V4.setFillRule(e2.getFillRule());
    }
    return V4;
  }
  clipPolyline(e2, t3) {
    const s3 = n3.constructEmpty(), i2 = n3.constructEmpty(), n5 = Yt(9, Number.NaN), r = Yt(9, Number.NaN), h2 = new fm();
    let m3 = e2;
    const o = n3.constructEmpty();
    e2.queryLooseEnvelope(o);
    for (let a2 = 0; a2 < 4; a2++) {
      let t4 = false;
      const x4 = !!(1 & a2);
      let p3 = 0;
      switch (a2) {
        case 0:
          p3 = this.m_extent.xmin, t4 = o.xmin <= p3 && o.xmax >= p3;
          break;
        case 1:
          p3 = this.m_extent.ymin, t4 = o.ymin <= p3 && o.ymax >= p3;
          break;
        case 2:
          p3 = this.m_extent.xmax, t4 = o.xmin <= p3 && o.xmax >= p3;
          break;
        case 3:
          p3 = this.m_extent.ymax, t4 = o.ymin <= p3 && o.ymax >= p3;
      }
      if (!t4) continue;
      const c = m3;
      m3 = e2.createInstance();
      const l2 = c.getImpl().querySegmentIterator();
      l2.resetToFirstPath();
      const _ = new mi(), g2 = new mi();
      for (; l2.nextPath(); ) {
        let e3 = -1, t5 = true;
        for (; l2.hasNextSegment(); ) {
          this.progress_();
          const o2 = l2.nextSegment(), c2 = o2.isDegenerate(0);
          o2.queryLooseEnvelope(s3);
          const u = _E.checkSegmentIntersection(s3, a2, p3);
          if (-1 === u) {
            const s4 = o2.intersectionWithAxis2D(x4, p3, n5, r);
            let l3 = 0;
            _.assign(o2.getStartXY());
            for (let u2 = 0; u2 <= s4; u2++) {
              const y2 = u2 < s4 ? r[u2] : 1;
              if (l3 === y2) continue;
              o2.queryCut(l3, y2, h2, false);
              const f3 = h2.get();
              let v3 = false;
              if (f3.getStartXY().equals(_) || (f3.setStartXY(_), v3 = true), u2 < s4 && (x4 ? (g2.x = n5[u2], g2.y = p3) : (g2.x = p3, g2.y = n5[u2]), f3.getEndXY().equals(g2) || (f3.setEndXY(g2), v3 = true)), v3 && f3.normalizeAfterEndpointChange(), !c2 && f3.isDegenerate(0)) continue;
              f3.queryEnvelope(i2);
              let d2 = _E.checkSegmentIntersection(i2, a2, p3);
              if (-1 === d2) {
                const e4 = f3.getStartXY(), t6 = f3.getEndXY();
                if (v3 = false, x4) {
                  Math.abs(e4.y - p3) < Math.abs(t6.y - p3) ? (e4.y = p3, f3.setStartXY(e4), e4.equals(f3.getStartXY()) || (f3.setStartXY(e4), v3 = true)) : (t6.y = p3, t6.equals(f3.getEndXY()) || (f3.setEndXY(t6), v3 = true));
                } else {
                  Math.abs(e4.x - p3) < Math.abs(t6.x - p3) ? (e4.x = p3, e4.equals(f3.getStartXY()) || (f3.setStartXY(e4), v3 = true)) : (t6.x = p3, t6.equals(f3.getEndXY()) || (f3.setEndXY(t6), v3 = true));
                }
                v3 && f3.normalizeAfterEndpointChange(), f3.queryEnvelope(i2), d2 = _E.checkSegmentIntersection(i2, a2, p3), -1 === d2 && (d2 = _E.checkSegmentIntersectionLoose(i2, a2, p3));
              }
              _.assign(f3.getEndXY()), l3 = y2, e3 = d2, e3 >= 1 ? (m3.addSegment(f3, t5), t5 = false) : t5 = true;
            }
          } else e3 = u, e3 >= 1 ? (m3.addSegment(o2, t5), t5 = false) : t5 = true;
        }
      }
    }
    return m3;
  }
  static checkSegmentIntersection(e2, t3, s3) {
    switch (t3) {
      case 0:
        return e2.xmin < s3 && e2.xmax <= s3 ? 0 : e2.xmin >= s3 ? e2.xmax === s3 ? 2 : 1 : -1;
      case 1:
        return e2.ymin < s3 && e2.ymax <= s3 ? 0 : e2.ymin >= s3 ? e2.ymax === s3 ? 2 : 1 : -1;
      case 2:
        return e2.xmin >= s3 && e2.xmax > s3 ? 0 : e2.xmax <= s3 ? e2.xmin === s3 ? 2 : 1 : -1;
      case 3:
        return e2.ymin >= s3 && e2.ymax > s3 ? 0 : e2.ymax <= s3 ? e2.ymin === s3 ? 2 : 1 : -1;
    }
    return b(""), 0;
  }
  static checkSegmentIntersectionLoose(e2, t3, s3) {
    switch (t3) {
      case 0: {
        const t4 = Math.abs(e2.xmin - s3), i2 = Math.abs(e2.xmax - s3);
        return e2.xmin < s3 ? t4 > i2 ? 0 : 1 : (b(""), 1);
      }
      case 1: {
        const t4 = Math.abs(e2.ymin - s3), i2 = Math.abs(e2.ymax - s3);
        return e2.ymin < s3 ? t4 > i2 ? 0 : 1 : (b(""), 1);
      }
      case 2: {
        const t4 = Math.abs(e2.xmin - s3), i2 = Math.abs(e2.xmax - s3);
        return e2.xmax > s3 ? t4 < i2 ? 0 : 1 : (b(""), 1);
      }
      case 3: {
        const t4 = Math.abs(e2.ymin - s3), i2 = Math.abs(e2.ymax - s3);
        return e2.ymax > s3 ? t4 < i2 ? 0 : 1 : (b(""), 1);
      }
    }
    return b(""), 0;
  }
  resolveBoundaryOverlaps() {
    this.m_verticesOnExtentIndex = -1, this.splitSegments(false, this.m_extent.xmin), this.splitSegments(false, this.m_extent.xmax), this.splitSegments(true, this.m_extent.ymin), this.splitSegments(true, this.m_extent.ymax), this.m_verticesOnExtent.length = 0, this.m_verticesOnExtentIndex = this.m_shape.createUserIndex();
    const e2 = new mi();
    for (let t3 = this.m_shape.getFirstPath(this.m_geometry); t3 !== cr; t3 = this.m_shape.getNextPath(t3)) {
      let s3 = this.m_shape.getFirstVertex(t3);
      for (let i2 = 0, n5 = this.m_shape.getPathSize(t3); i2 < n5; i2++, s3 = this.m_shape.getNextVertex(s3)) this.progress_(), this.m_shape.queryXY(s3, e2), this.m_extent.xmin !== e2.x && this.m_extent.xmax !== e2.x && this.m_extent.ymin !== e2.y && this.m_extent.ymax !== e2.y || (this.m_shape.setUserIndex(s3, this.m_verticesOnExtentIndex, this.m_verticesOnExtent.length), this.m_verticesOnExtent.push(s3));
    }
    this.dbgCheckPathFirst(), this.resolveOverlaps(false, this.m_extent.xmin), this.dbgCheckPathFirst(), this.resolveOverlaps(false, this.m_extent.xmax), this.dbgCheckPathFirst(), this.resolveOverlaps(true, this.m_extent.ymin), this.dbgCheckPathFirst(), this.resolveOverlaps(true, this.m_extent.ymax), this.fixPaths();
  }
  densifyAlongClipExtent(e2) {
    const t3 = new mi(0, 0), s3 = new mi(0, 0), i2 = Yt(2048, Number.NaN);
    for (let n5 = this.m_shape.getFirstPath(this.m_geometry); n5 !== cr; n5 = this.m_shape.getNextPath(n5)) {
      const m3 = this.m_shape.getFirstVertex(n5);
      let a2 = m3;
      do {
        const n6 = this.m_shape.getNextVertex(a2);
        this.m_shape.queryXY(a2, t3);
        let m4 = -1;
        if (t3.x === this.m_extent.xmin ? (this.m_shape.queryXY(n6, s3), s3.x === this.m_extent.xmin && (m4 = 1)) : t3.x === this.m_extent.xmax && (this.m_shape.queryXY(n6, s3), s3.x === this.m_extent.xmax && (m4 = 1)), t3.y === this.m_extent.ymin ? (this.m_shape.queryXY(n6, s3), s3.y === this.m_extent.ymin && (m4 = 0)) : t3.y === this.m_extent.ymax && (this.m_shape.queryXY(n6, s3), s3.y === this.m_extent.ymax && (m4 = 0)), -1 === m4) {
          a2 = n6;
          continue;
        }
        if (this.isCurve(a2)) {
          a2 = n6;
          continue;
        }
        const o = t3.clone(), x4 = new mi(0, 0);
        if (m4) {
          const i3 = t3.y - this.m_extent.ymin;
          x4.y = K(s3.y - t3.y), o.y = e2 * B2(Math.floor(Math.abs(i3) / e2), i3) + this.m_extent.ymin, x4.y < 0 && (o.y += e2);
        } else {
          const i3 = t3.x - this.m_extent.xmin;
          x4.x = K(s3.x - t3.x), o.x = e2 * B2(Math.floor(Math.abs(i3) / e2), i3) + this.m_extent.xmin, x4.x < 0 && (o.x += e2);
        }
        const p3 = m4 ? s3.y - t3.y : s3.x - t3.x, c = Math.abs(p3);
        if (c / e2 > 65536 && b(""), c > 0) {
          const s4 = Math.trunc(c / e2) + 2;
          i2.length < s4 && (i2.length = s4);
          let n7 = 0;
          for (let h2 = 0; ; h2++) {
            const s5 = o.add(x4.mul(h2 * e2)), a3 = (m4 ? s5.y - t3.y : s5.x - t3.x) / p3;
            if (a3 >= 1) break;
            a3 <= 0 || (n(n7 <= i2.length), i2[n7] = a3, n7++);
          }
          0 !== n7 && this.m_shape.splitSegment(a2, i2, n7);
        }
        a2 = n6;
      } while (a2 !== m3);
    }
  }
  splitSegments(e2, t3) {
    let s3 = -1;
    const i2 = new mi(), n5 = [];
    for (let _ = this.m_shape.getFirstPath(this.m_geometry); _ !== cr; _ = this.m_shape.getNextPath(_)) {
      let r2 = this.m_shape.getFirstVertex(_), h3 = cr;
      for (let m4 = 0, a3 = this.m_shape.getPathSize(_); m4 < a3; m4++, r2 = h3) if (this.progress_(), h3 = this.m_shape.getNextVertex(r2), this.m_shape.queryXY(r2, i2), (e2 ? i2.y === t3 : i2.x === t3) && (this.m_shape.queryXY(h3, i2), e2 ? i2.y === t3 : i2.x === t3)) {
        if (this.isCurve(r2)) continue;
        -1 === s3 && (s3 = this.m_shape.createUserIndex()), 1 !== this.m_shape.getUserIndex(r2, s3) && (n5.push(r2), this.m_shape.setUserIndex(r2, s3, 1)), 1 !== this.m_shape.getUserIndex(h3, s3) && (n5.push(h3), this.m_shape.setUserIndex(h3, s3, 1));
      }
    }
    if (-1 !== s3 && this.m_shape.removeUserIndex(s3), n5.length < 3) return;
    n5.sort((e3, t4) => this.compareVertices(e3, t4));
    const r = new mi(), h2 = new mi(), m3 = new mi();
    h2.setNAN();
    let a2 = -1;
    let o = [], p3 = [];
    const c = this.m_shape.createUserIndex(), l2 = this.m_shape.createUserIndex();
    for (let x4 = 0, _ = n5.length; x4 < _; x4++) {
      const s4 = n5[x4];
      if (this.m_shape.queryXY(s4, i2), !i2.isEqualPoint2D(h2)) {
        if (-1 === a2) {
          a2 = x4, h2.setCoordsPoint2D(i2);
          continue;
        }
        for (let i3 = a2; i3 < x4; i3++) {
          const s6 = n5[i3], m4 = this.m_shape.getNextVertex(s6), a3 = this.m_shape.getPrevVertex(s6);
          let x5 = false;
          this.m_shape.queryXY(m4, r), h2.compare(r) < 0 && (e2 ? r.y === t3 : r.x === t3) && (this.isCurve(s6) || (o.push(s6), x5 = true, this.m_shape.setUserIndex(s6, l2, 1))), this.m_shape.queryXY(a3, r), h2.compare(r) < 0 && (e2 ? r.y === t3 : r.x === t3) && (this.isCurve(a3) || (x5 || o.push(s6), this.m_shape.setUserIndex(s6, c, 1)));
        }
        for (let e3 = 0, t4 = o.length; e3 < t4; e3++) {
          const t5 = o[e3], s6 = this.m_shape.getUserIndex(t5, c), n6 = this.m_shape.getUserIndex(t5, l2);
          if (1 === s6) {
            const e4 = this.m_shape.getPrevVertex(t5);
            this.m_shape.queryXY(e4, m3);
            let s7 = 0;
            if (!m3.isEqualPoint2D(i2)) {
              const n7 = mi.distance(h2, m3);
              s7 = mi.distance(m3, i2) / n7, 0 === s7 ? s7 = Number.EPSILON : 1 === s7 && (s7 = 1 - Number.EPSILON), this.m_shape.splitSegment(e4, [s7], 1);
              const r2 = this.m_shape.getPrevVertex(t5);
              this.m_shape.setXY(r2, i2), p3.push(r2), this.m_shape.setUserIndex(r2, c, 1), this.m_shape.setUserIndex(r2, l2, -1);
            }
          }
          if (1 === n6) {
            const e4 = this.m_shape.getNextVertex(t5);
            this.m_shape.queryXY(e4, m3);
            let s7 = 0;
            if (!m3.isEqualPoint2D(i2)) {
              const e5 = mi.distance(h2, m3);
              s7 = mi.distance(h2, i2) / e5, 0 === s7 ? s7 = Number.EPSILON : 1 === s7 && (s7 = 1 - Number.EPSILON), this.m_shape.splitSegment(t5, [s7], 1);
              const n7 = this.m_shape.getNextVertex(t5);
              this.m_shape.setXY(n7, i2), p3.push(n7), this.m_shape.setUserIndex(n7, c, -1), this.m_shape.setUserIndex(n7, l2, 1);
            }
          }
        }
        const s5 = o;
        o = p3, p3 = s5, p3.length = 0, a2 = x4, h2.setCoordsPoint2D(i2);
      }
    }
    this.m_shape.removeUserIndex(c), this.m_shape.removeUserIndex(l2);
  }
  resolveOverlaps(e2, t3) {
    const s3 = new mi(), i2 = [];
    let n5 = -1;
    for (let r = 0, o = this.m_verticesOnExtent.length; r < o; r++) {
      this.progress_();
      const h3 = this.m_verticesOnExtent[r];
      if (h3 === cr) continue;
      const m4 = this.m_shape.getNextVertex(h3);
      if (this.m_shape.queryXY(h3, s3), (e2 ? s3.y === t3 : s3.x === t3) && (this.m_shape.queryXY(m4, s3), e2 ? s3.y === t3 : s3.x === t3)) {
        if (this.isCurve(h3)) continue;
        -1 === n5 && (n5 = this.m_shape.createUserIndex()), -2 !== this.m_shape.getUserIndex(h3, n5) && (i2.push(h3), this.m_shape.setUserIndex(h3, n5, -2)), -2 !== this.m_shape.getUserIndex(m4, n5) && (i2.push(m4), this.m_shape.setUserIndex(m4, n5, -2));
      }
    }
    if (0 === i2.length) return void (-1 !== n5 && this.m_shape.removeUserIndex(n5));
    n(-1 !== n5), i2.sort((e3, t4) => this.compareVertices(e3, t4));
    for (let r = 0, o = i2.length; r < o; r++) {
      const e3 = i2[r];
      this.m_shape.setUserIndex(e3, n5, r);
    }
    const h2 = new mi(), m3 = new mi();
    m3.setNAN();
    let a2 = -1;
    for (let r = 0, o = i2.length; r < o; r++) {
      this.progress_();
      const o2 = i2[r];
      if (o2 !== cr && (this.m_shape.queryXY(o2, s3), !s3.isEqualPoint2D(m3))) {
        if (-1 !== a2) for (; ; ) {
          let s4 = false;
          const o3 = r;
          for (let p3 = a2; p3 < o3; p3++) {
            const a3 = i2[p3];
            if (a3 === cr) continue;
            let o4 = cr;
            const c = this.m_shape.getNextVertex(a3);
            this.m_shape.queryXY(c, h2), m3.compare(h2) < 0 && (e2 ? h2.y === t3 : h2.x === t3) && (this.isCurve(a3) || (o4 = c));
            let l2 = cr;
            const _ = this.m_shape.getPrevVertex(a3);
            if (this.m_shape.queryXY(_, h2), m3.compare(h2) < 0 && (e2 ? h2.y === t3 : h2.x === t3) && (this.isCurve(_) || (l2 = _)), o4 === cr || l2 === cr) {
              if (o4 !== cr || l2 !== cr) {
                for (let c2 = p3 + 1; c2 < r; c2++) {
                  const r2 = i2[c2];
                  if (r2 === cr) continue;
                  const p4 = this.m_shape.getNextVertex(r2);
                  let _2 = cr;
                  this.m_shape.queryXY(p4, h2), m3.compare(h2) < 0 && (e2 ? h2.y === t3 : h2.x === t3) && (this.isCurve(r2) || (_2 = p4));
                  const u = this.m_shape.getPrevVertex(r2);
                  let g2 = cr;
                  if (this.m_shape.queryXY(u, h2), m3.compare(h2) < 0 && (e2 ? h2.y === t3 : h2.x === t3) && (this.isCurve(u) || (g2 = u)), _2 !== cr && g2 !== cr) {
                    this.beforeRemoveVertex(r2, i2, n5), this.m_shape.removeVertex(r2, false), this.beforeRemoveVertex(_2, i2, n5), this.m_shape.removeVertex(_2, false), s4 = true;
                    break;
                  }
                  if (o4 !== cr && g2 !== cr) {
                    this.removeOverlap(i2, a3, o4, r2, g2, n5), s4 = true;
                    break;
                  }
                  if (l2 !== cr && _2 !== cr) {
                    this.removeOverlap(i2, r2, _2, a3, l2, n5), s4 = true;
                    break;
                  }
                }
                if (s4) break;
              }
            } else this.beforeRemoveVertex(a3, i2, n5), this.m_shape.removeVertex(a3, false), this.beforeRemoveVertex(o4, i2, n5), this.m_shape.removeVertex(o4, false), s4 = true;
          }
          if (!s4) break;
        }
        a2 = r, m3.setCoordsPoint2D(s3);
      }
    }
    this.m_shape.removeUserIndex(n5);
  }
  beforeRemoveVertex(e2, t3, s3) {
    let i2 = this.m_shape.getUserIndex(e2, s3);
    n(i2 >= 0), t3[i2] = cr, i2 = this.m_shape.getUserIndex(e2, this.m_verticesOnExtentIndex), n(i2 >= 0), this.m_verticesOnExtent[i2] = cr;
    const n5 = this.m_shape.getPathFromVertex(e2);
    if (n5 !== cr) {
      this.m_shape.getFirstVertex(n5) === e2 && (this.m_shape.setFirstVertex(n5, cr), this.m_shape.setLastVertex(n5, cr));
    }
  }
  removeOverlap(e2, t3, s3, i2, n5, r) {
    this.m_shape.setNextVertex(t3, i2), this.m_shape.setPrevVertex(i2, t3), this.m_shape.setPrevVertex(s3, n5), this.m_shape.setNextVertex(n5, s3), this.beforeRemoveVertex(i2, e2, r), this.m_shape.removeVertexInternal(i2, false), this.beforeRemoveVertex(n5, e2, r), this.m_shape.removeVertexInternal(n5, true);
  }
  removeSpikesAlongPoles() {
    this.removeSpikesOnPole(this.m_extent.ymin), this.removeSpikesOnPole(this.m_extent.ymax);
  }
  removeSpikesOnPole(e2) {
    for (let t3 = this.m_shape.getFirstPath(this.m_geometry); t3 !== cr; t3 = this.m_shape.getNextPath(t3)) {
      const s3 = this.m_shape.getPathSize(t3);
      if (s3 < 3) continue;
      let i2 = this.m_shape.getFirstVertex(t3);
      const n5 = new mi();
      this.m_shape.queryXY(i2, n5);
      let r = n5.y === e2 && !this.isCurve(i2);
      i2 = this.m_shape.getNextVertex(i2);
      const h2 = new mi();
      this.m_shape.queryXY(i2, h2);
      let m3 = h2.y === e2 && !this.isCurve(i2);
      i2 = this.m_shape.getNextVertex(i2);
      const a2 = new mi();
      for (let t4 = 0, o = s3 - 2; t4 < o; t4++, i2 = this.m_shape.getNextVertex(i2)) {
        this.progress_(), this.m_shape.queryXY(i2, a2);
        const t5 = a2.y === e2;
        if (m3 && r && t5) {
          if ((h2.x - n5.x) * (a2.x - h2.x) <= 0) {
            this.m_shape.removeVertex(this.m_shape.getPrevVertex(i2), false), h2.setCoordsPoint2D(a2), m3 = t5 && !this.isCurve(i2);
            continue;
          }
        }
        n5.setCoordsPoint2D(h2), r = m3, h2.setCoordsPoint2D(a2), m3 = t5 && !this.isCurve(i2);
      }
    }
  }
  fixPaths() {
    for (let n5 = 0, r = this.m_verticesOnExtent.length; n5 < r; n5++) {
      const e3 = this.m_verticesOnExtent[n5];
      e3 !== cr && this.m_shape.setPathToVertex(e3, cr);
    }
    const e2 = this.m_shape.hasCurves();
    let t3 = 0, s3 = 0;
    for (let n5 = this.m_shape.getFirstPath(this.m_geometry); n5 !== cr; ) {
      const e3 = this.m_shape.getFirstVertex(n5);
      if (e3 === cr || n5 !== this.m_shape.getPathFromVertex(e3)) {
        const e4 = n5;
        n5 = this.m_shape.getNextPath(n5), this.m_shape.setFirstVertex(e4, cr), this.m_shape.removePathOnly(e4);
        continue;
      }
      let i3 = e3, r = 0;
      do {
        this.m_shape.setPathToVertex(i3, n5), r++, i3 = this.m_shape.getNextVertex(i3);
      } while (i3 !== e3);
      this.m_shape.setRingAreaValid(n5, false), this.m_shape.setLastVertex(n5, this.m_shape.getPrevVertex(e3)), this.m_shape.setPathSize(n5, r), s3 += r, t3++, n5 = this.m_shape.getNextPath(n5);
    }
    for (let n5 = 0, h2 = this.m_verticesOnExtent.length; n5 < h2; n5++) {
      let i3 = this.m_verticesOnExtent[n5];
      if (i3 === cr) continue;
      let h3 = this.m_shape.getPathFromVertex(i3);
      if (h3 !== cr) continue;
      h3 = this.m_shape.insertPath(this.m_geometry, cr);
      let m3 = false, a2 = 0;
      const o = i3;
      do {
        this.m_shape.setPathToVertex(i3, h3), a2++, e2 && a2 <= 2 && (m3 ||= this.isCurve(i3)), i3 = this.m_shape.getNextVertex(i3);
      } while (i3 !== o);
      if (m3 ? 0 === a2 : a2 <= 2) {
        let e3 = this.m_shape.getUserIndex(o, this.m_verticesOnExtentIndex);
        n(e3 >= 0), this.m_verticesOnExtent[e3] = cr;
        const t4 = this.m_shape.removeVertex(o, false);
        2 === a2 && (e3 = this.m_shape.getUserIndex(t4, this.m_verticesOnExtentIndex), e3 >= 0 && (this.m_verticesOnExtent[e3] = cr), this.m_shape.removeVertex(t4, false));
        const s4 = h3;
        h3 = this.m_shape.getNextPath(h3), this.m_shape.setFirstVertex(s4, cr), this.m_shape.removePathOnly(s4);
        continue;
      }
      this.m_shape.setClosedPath(h3, true), this.m_shape.setPathSize(h3, a2), this.m_shape.setFirstVertex(h3, o), this.m_shape.setLastVertex(h3, this.m_shape.getPrevVertex(o)), this.m_shape.setRingAreaValid(h3, false), s3 += a2, t3++;
    }
    this.m_shape.setGeometryPathCount(this.m_geometry, t3), this.m_shape.setGeometryVertexCount(this.m_geometry, s3);
    let i2 = 0;
    for (let n5 = this.m_shape.getFirstGeometry(); n5 !== cr; n5 = this.m_shape.getNextGeometry(n5)) i2 += this.m_shape.getPointCount(n5);
    this.m_shape.setTotalPointCount(i2);
  }
  dbgCheckPathFirst() {
  }
  isCurve(e2) {
    return null !== this.m_shape.getSegment(e2);
  }
  compareVertices(e2, t3) {
    const s3 = new mi();
    this.m_shape.queryXY(e2, s3);
    const i2 = new mi();
    this.m_shape.queryXY(t3, i2);
    return s3.compare(i2);
  }
  clipPolesOut(e2, t3) {
    return this.clipPolygonOrProjectedPolyline2(e2, t3);
  }
};
var I3 = class {
  getOperatorType() {
    return 10004;
  }
  supportsCurves() {
    return true;
  }
  accelerateGeometry(e2, t3, s3) {
    return false;
  }
  canAccelerateGeometry(e2) {
    return false;
  }
  executeMany(e2, t3, s3, i2) {
    return new V3(e2, t3, s3, i2);
  }
  execute(e2, t3, s3, i2) {
    return X2(e2, t3, s3, i2);
  }
};
var V3 = class extends t {
  constructor(e2, s3, i2, n5) {
    super(), this.m_progressTracker = n5, this.m_index = -1, e2 || P(""), this.m_envelope = s3, this.m_inputGeometryCursor = e2, this.m_spatialRefImpl = i2, this.m_tolerance = At(i2, s3, false).total();
  }
  next() {
    let e2;
    return (e2 = this.m_inputGeometryCursor.next()) ? (j(e2), this.m_index = this.m_inputGeometryCursor.getGeometryID(), f2(e2, this.m_envelope, this.m_tolerance, 0, this.m_progressTracker)) : null;
  }
  getGeometryID() {
    return this.m_index;
  }
  tock() {
    return true;
  }
  getRank() {
    return 1;
  }
};
function X2(e2, t3, s3, i2) {
  return v2(e2, t3, s3, Number.NaN, 0, i2);
}

// node_modules/@arcgis/core/chunks/OperatorDensify.js
var n4 = jh;
var i = class extends t {
  constructor(e2, t3, r, s3, i2, m3) {
    super(), this.m_densificator = new n4(t3, r, s3, m3, false, i2), this.m_index = -1, this.m_inputGeoms = e2;
  }
  tock() {
    return true;
  }
  getRank() {
    return 1;
  }
  next() {
    let e2 = null;
    for (; e2 = this.m_inputGeoms.next(); ) return j(e2), this.m_index = this.m_inputGeoms.getGeometryID(), this.densify(e2);
    return null;
  }
  getGeometryID() {
    return this.m_index;
  }
  densify(e2) {
    return this.m_densificator.densify(e2);
  }
};
var m2 = class {
  getOperatorType() {
    return 10202;
  }
  accelerateGeometry(e2, t3, r) {
    return false;
  }
  canAccelerateGeometry(e2) {
    return false;
  }
  supportsCurves() {
    return true;
  }
  executeMany(e2, t3, r, s3, n5, m3 = 12e3) {
    return new i(e2, t3, r, s3, m3, n5);
  }
  execute(e2, t3, s3, n5, i2, m3 = 12e3) {
    return zh(e2, t3, s3, n5, i2, m3);
  }
};

// node_modules/@arcgis/core/chunks/UnitFactory.js
var ss2 = class _ss {
  constructor(e2) {
    if (this.m_geom = this.m_sr = null, e2) {
      if (e2.move) return this.m_geom = e2.move.m_geom, e2.move.m_geom = null, this.m_sr = e2.move.m_sr, void (e2.move.m_sr = null);
      if (e2.copy) return this.m_geom = e2.copy.m_geom ? e2.copy.m_geom.clone() : null, void (this.m_sr = e2.copy.m_sr);
      e2.geom && (this.m_geom = e2.geom), e2.sr && (this.m_sr = e2.sr);
    }
  }
  getGeometry() {
    return this.m_geom;
  }
  getSpatialReference() {
    return this.m_sr;
  }
  setGeometry(e2) {
    this.m_geom = e2;
  }
  setSpatialReference(e2) {
    this.m_sr = e2;
  }
  equals(e2, t3) {
    const s3 = e2;
    return !(!this.m_sr && s3.m_sr) && (!(this.m_sr && !s3.m_sr) && (!(!this.m_geom && s3.m_geom) && (!(this.m_geom && !s3.m_geom) && (!(this.m_sr && s3.m_sr && !this.m_sr.equals(s3.m_sr)) && !(this.m_geom && s3.m_geom && !this.m_geom.equals(s3.m_geom, t3))))));
  }
  clone() {
    let e2 = null;
    return this.m_geom && (e2 = this.m_geom.clone()), new _ss({ geom: e2, sr: this.m_sr });
  }
  hasGeom() {
    return !!this.m_geom;
  }
};
var ns2 = class {
  constructor(e2) {
    this.m_factor = 1, this.m_wkid = 0, this.m_peUnit = null, e2 && (this.m_peUnit = e2, this.m_factor = e2.getUnitFactor(), this.m_wkid = e2.getCode(), this.m_wkid < 0 && (this.m_wkid = 0));
  }
  getName() {
    return this.m_peUnit ? this.m_peUnit.getName() : "";
  }
  getID() {
    return this.m_wkid;
  }
  getConversionFactor(t3) {
    return this.getUnitType() !== t3.getUnitType() && P("unit type mismatch"), this.getUnitToBaseFactor() / t3.getUnitToBaseFactor();
  }
  getUnitToBaseFactor() {
    return this.m_factor;
  }
  getHashCode() {
    return As(Zs(this.getUnitType()), Zs(this.getUnitToBaseFactor()));
  }
  equals(e2) {
    return !!e2 && (this.getUnitType() === e2.getUnitType() && this.getUnitToBaseFactor() === e2.getUnitToBaseFactor() && this.getID() === e2.getID() && this.getName() === e2.getName());
  }
  static isValidWkid(e2) {
    return false;
  }
};
var rs2 = { 330: 104878, 500: 104879, 1300: 104899, 1450: 104986, 2230: 104988, 3800: 104978, 5e3: 104919, 6200: 104906, 8200: 104909, 9500: 104927, 9600: 104977, 1e4: [104911, 104936], 11e3: 104941, 11080: 104872, 11100: 104907, 12e3: 104920, 12400: 104995, 13e3: 104948, 14e3: [104923, 104989], 15e3: [104913, 104954], 15100: 104976, 16e3: [104926, 104931], 18e3: [104922, 104982], 21e3: 104947, 21500: 104877, 27e3: [104950, 104957], 29e3: 104964, 3e4: 104921, 31e3: 104949, 33e3: 104946, 4e4: [104914, 104967], 40600: 104897, 41900: 104937, 42e3: 104951, 43100: 104993, 49300: 104924, 50100: 104939, 54e3: 104955, 58200: 104981, 59500: 104930, 74e3: 104961, 77e3: 104956, 79e3: 104962, 83500: 104910, 85e3: 104917, 88800: 104934, 89200: 104985, 96e3: 104997, 104e3: 104963, 106500: 104898, 11e4: 104938, 133e3: 104932, 135e3: 104983, 17e4: 104965, 198200: 104987, 198630: 104935, 208e3: 104966, 235800: 104952, 249400: 104929, 252100: 104980, 255e3: 104973, 47e4: 104972, 529800: 104942, 531e3: 104996, 56e4: 104928, 561400: 104979, 578900: 104945, 584700: 104959, 593e3: 104970, 606e3: 104999, 718e3: 104933, 745700: 104984, 761400: 104953, 763500: 104994, 764e3: 104940, 788900: 104958, 1188300: 104998, 1195e3: 104969, 1352600: 104968, 1560800: 104874, 1562090: 104915, 1737400: 104903, 1821460: 104918, 1821490: 104876, 2409300: 104912, 2410300: 104873, 2439400: 104974, 2439700: 104900, 2575e3: 104943, 2631200: 104875, 2632345: 104916, 3393400: 104904, 3396190: [104905, 104971], 6051e3: 104901, 6051800: 104902, 637e4: 104128, 6370997: [4052, 37008], 6371e3: 4035, 6371007: 4047, 6371228: [4053, 10346], 6376045: [8042, 8043], 6376523: [4027, 4901, 4902], 6376896: 37007, 6378135: [4122, 4322, 4324, 4720, 4985, 4987], 6378136: [4740, 4923, 7678, 7680, 9474, 9475, 104017, 104018], 6378137: [3823, 3824, 3888, 3889, 4017, 4019, 4023, 4031, 4040, 4046, 4055, 4074, 4075, 4080, 4081, 4121, 4126, 4130, 4133, 4140, 4141, 4148, 4151, 4152, 4163, 4166, 4167, 4170, 4171, 4172, 4173, 4176, 4180, 4189, 4190, 4258, 4269, 4283, 4318, 4319, 4326, 4463, 4466, 4469, 4470, 4480, 4482, 4483, 4490, 4557, 4558, 4612, 4617, 4619, 4624, 4627, 4659, 4661, 4667, 4669, 4670, 4674, 4686, 4687, 4693, 4694, 4702, 4737, 4742, 4747, 4749, 4750, 4755, 4756, 4757, 4758, 4759, 4761, 4762, 4763, 4764, 4765, 4883, 4885, 4887, 4889, 4893, 4895, 4898, 4907, 4909, 4921, 4925, 4927, 4929, 4931, 4933, 4935, 4937, 4939, 4941, 4943, 4945, 4947, 4949, 4951, 4953, 4955, 4957, 4959, 4961, 4963, 4965, 4967, 4971, 4975, 4977, 4979, 4981, 4983, 4989, 4997, 4999, 5012, 5013, 5245, 5246, 5251, 5252, 5263, 5264, 5323, 5324, 5340, 5342, 5353, 5354, 5359, 5360, 5364, 5365, 5370, 5371, 5372, 5373, 5380, 5381, 5392, 5393, 5488, 5489, 5545, 5546, 5592, 5593, 5885, 5886, 6134, 6135, 6310, 6311, 6318, 6319, 6321, 6322, 6324, 6325, 6364, 6365, 6667, 6668, 6705, 6706, 6782, 6783, 6980, 6982, 6983, 6987, 6989, 6990, 7034, 7035, 7036, 7037, 7038, 7039, 7040, 7041, 7042, 7072, 7073, 7084, 7085, 7086, 7087, 7133, 7135, 7136, 7138, 7139, 7372, 7373, 7657, 7659, 7661, 7663, 7665, 7685, 7686, 7797, 7798, 7816, 7843, 7844, 7880, 7881, 7885, 7886, 7900, 7901, 7902, 7903, 7904, 7905, 7906, 7907, 7908, 7909, 7910, 7911, 7912, 7915, 7917, 7919, 7921, 7923, 7925, 7927, 7929, 7931, 8085, 8086, 8231, 8232, 8235, 8237, 8239, 8240, 8244, 8246, 8248, 8249, 8251, 8252, 8254, 8255, 8399, 8403, 8426, 8427, 8449, 8542, 8544, 8545, 8684, 8685, 8698, 8699, 8817, 8818, 8860, 8888, 8899, 8900, 8901, 8902, 8906, 8907, 8916, 8918, 8920, 8922, 8924, 8926, 8928, 8930, 8932, 8934, 8936, 8938, 8940, 8942, 8944, 8946, 8948, 8949, 8972, 8973, 8974, 8975, 8976, 8977, 8978, 8979, 8980, 8981, 8982, 8983, 8984, 8985, 8986, 8987, 8988, 8989, 8990, 8991, 8992, 8993, 8994, 8995, 8996, 8997, 8998, 8999, 9e3, 9002, 9003, 9005, 9006, 9008, 9009, 9011, 9012, 9013, 9014, 9016, 9017, 9018, 9019, 9053, 9054, 9055, 9056, 9057, 9059, 9060, 9061, 9062, 9063, 9064, 9065, 9066, 9067, 9068, 9069, 9071, 9072, 9074, 9075, 9139, 9140, 9147, 9148, 9152, 9153, 9183, 9184, 9293, 9294, 9299, 9308, 9309, 9332, 9333, 9364, 9372, 9379, 9380, 9384, 9453, 9469, 9470, 9546, 9547, 9695, 9696, 9701, 9702, 9739, 9754, 9755, 9758, 9763, 9776, 9777, 9778, 9779, 9781, 9782, 9783, 9784, 9866, 9871, 9939, 9964, 9969, 9974, 9989, 9990, 10175, 10177, 10178, 10185, 10191, 10196, 10204, 10209, 10214, 10219, 10224, 10229, 10237, 10272, 10277, 10283, 10284, 10298, 10299, 10300, 10304, 10305, 10307, 10309, 10310, 10311, 10312, 10327, 10328, 10413, 10414, 10468, 10474, 10475, 10570, 10571, 10605, 10606, 10623, 10628, 10638, 10639, 10670, 10671, 10672, 10673, 10689, 10690, 10724, 10725, 10738, 10739, 10761, 10762, 10780, 10781, 10784, 10785, 10799, 10800, 20033, 20040, 20041, 20045, 20046, 104009, 104010, 104011, 104012, 104013, 104014, 104015, 104016, 104019, 104020, 104021, 104022, 104024, 104027, 104028, 104050, 104100, 104107, 104108, 104110, 104111, 104114, 104115, 104116, 104117, 104118, 104119, 104120, 104121, 104122, 104123, 104124, 104129, 104133, 104134, 104137, 104141, 104142, 104143, 104144, 104145, 104179, 104180, 104181, 104182, 104183, 104184, 104185, 104186, 104199, 104223, 104257, 104258, 104259, 104260, 104286, 104287, 104602, 104613, 104644, 104645, 104646, 104647, 104653, 104804, 104896, 104991], 6378140: 4610, 6378145: [4025, 4276, 4760, 4891, 37001], 6378150: 37003, 6378155: [37004, 37207], 6378160: [3821, 4003, 4021, 4036, 4202, 4203, 4237, 4238, 4291, 4618, 4708, 5527, 37231, 104023, 104136], 6378166: 37002, 6378200: [4020, 4229, 4286, 4303, 4706], 6378245: [4024, 4147, 4164, 4178, 4179, 4191, 4200, 4205, 4214, 4284, 4317, 4555, 4676, 4677, 4678, 4991, 4993, 5560, 5561, 37257, 104135], 6378270: [4732, 37005, 37229], 6378273: [4054, 10345], 6378300: [4029, 4168, 4174], 6378388: [4022, 4123, 4153, 4154, 4158, 4159, 4160, 4161, 4165, 4181, 4182, 4183, 4184, 4185, 4192, 4194, 4195, 4196, 4199, 4204, 4207, 4208, 4215, 4218, 4221, 4224, 4225, 4230, 4231, 4233, 4235, 4236, 4247, 4248, 4249, 4254, 4255, 4259, 4264, 4265, 4271, 4272, 4274, 4285, 4287, 4288, 4292, 4297, 4309, 4311, 4313, 4316, 4472, 4475, 4611, 4614, 4615, 4616, 4621, 4622, 4623, 4625, 4626, 4628, 4629, 4630, 4631, 4632, 4633, 4636, 4637, 4639, 4641, 4642, 4643, 4644, 4645, 4646, 4658, 4660, 4662, 4663, 4664, 4665, 4668, 4672, 4673, 4684, 4688, 4689, 4690, 4691, 4692, 4698, 4704, 4705, 4707, 4709, 4710, 4711, 4712, 4714, 4715, 4716, 4718, 4719, 4721, 4722, 4724, 4725, 4727, 4728, 4729, 4730, 4733, 4734, 4735, 4739, 4741, 4753, 4754, 4802, 4803, 4806, 4809, 4810, 4823, 4824, 4900, 5524, 6883, 8428, 8430, 8431, 9248, 9251, 9253, 9403, 9893, 10158, 10249, 10252, 10635, 10636, 10735, 10736, 10758, 37201, 37204, 37205, 37212, 37213, 37214, 37215, 37216, 37217, 37218, 37219, 37221, 37222, 37224, 37226, 37227, 37230, 37232, 37233, 37234, 37235, 37237, 37238, 37241, 37242, 37245, 37246, 37247, 37249, 37250, 37251, 37253, 37259, 104104, 104106, 104125, 104126, 104127, 104130, 104138, 104248], 6378523: 104786, 24764e3: 104960, 25559e3: 104944, 60268e3: 104925, 71492e3: 104908, 6957e5: 104975, 6377397155e-3: [3819, 3906, 4004, 4120, 4124, 4125, 4149, 4150, 4156, 4162, 4211, 4219, 4257, 4262, 4280, 4289, 4294, 4295, 4301, 4306, 4308, 4312, 4314, 4613, 4666, 4745, 4746, 4801, 4804, 4805, 4808, 4813, 4814, 4815, 4818, 4820, 4904, 5132, 5228, 5229, 5681, 5830, 8351, 9267, 10268, 37255, 104101, 104102, 104105, 104131, 104648, 104696, 104697, 104990, 104992], 6377563396e-3: [4001, 4188, 4277, 4278, 4279], 6377340189e-3: [4002, 4299, 4300], 6377492018e-3: [4005, 4273, 4817], 6377483865280418e-9: [4006, 4293], 6378293645208759e-9: [4007, 4157, 4302, 4738, 5464], 63782064e-1: [4008, 4127, 4128, 4129, 4135, 4136, 4137, 4138, 4139, 4169, 4216, 4242, 4253, 4267, 4608, 4609, 4638, 4675, 4683, 4695, 4717, 4723, 4726, 4995, 5451, 5467, 37220, 37239, 37243, 37252, 37260, 104e3, 104109, 104112, 104113, 104132], 6378450047e-3: [4009, 4268], 6378300789e-3: [4010, 4281], 63782492e-1: [4011, 4014, 4155, 4193, 4206, 4213, 4223, 4226, 4227, 4228, 4252, 4261, 4266, 4275, 4282, 4296, 4304, 4310, 4315, 4671, 4807, 4811, 4816, 4821, 37223, 37225, 104139, 104140, 104261, 104304], 6378249145e-3: [4012, 4013, 4132, 4134, 4142, 4143, 4175, 4197, 4198, 4201, 4209, 4210, 4212, 4220, 4222, 4232, 4234, 4246, 4250, 4251, 4256, 4260, 4263, 4270, 4305, 4307, 4600, 4601, 4602, 4603, 4604, 4605, 4606, 4607, 4620, 4679, 4680, 4696, 4697, 4699, 4700, 4701, 4703, 4713, 4731, 4736, 4743, 4744, 4812, 4819, 6881, 6882, 6892, 6894, 8694, 37206, 37208, 37211, 37228, 37240, 37254, 104025, 104026, 104103, 104305], 6377276345e-3: [4015, 4131, 4144, 4239, 4240, 4244, 4682, 5233, 6207, 37202, 104256, 104664, 104693], 6377298556e-3: [4016, 4298], 6377304063e-3: [4018, 4245], 63782983e-1: [4028, 4903], 63781362e-1: 4032, 63781363e-1: 4033, 6378249144808011e-9: [4034, 4241], 209229318e-1: [4042, 4243], 6377301243e-3: [4044, 4145, 37203], 6377299151e-3: [4045, 4146], 637701927e-2: [4657, 10256, 10260, 10265], 63783063696e-4: [4748, 4752], 6377295664e-3: [4751, 37006], 63781365e-1: [7682, 7683], 63710087714e-4: 104047, 6378418941e-3: [104700, 104726, 104760], 6378586581e-3: [104701, 104743], 6378505809e-3: 104702, 6378544823e-3: 104703, 6378490569e-3: 104704, 6378470757e-3: [104705, 104776], 6378403701e-3: [104706, 104750], 6378434181e-3: [104707, 104724, 104739, 104764], 6378454907e-3: 104708, 6378400653e-3: 104709, 6378567378e-3: 104710, 6378546957e-3: [104711, 104717, 104780], 6378476853e-3: [104712, 104736], 6378411321e-3: [104713, 104728], 6378647541e-3: [104714, 104715], 6378514953e-3: [104716, 104782], 6378421989e-3: [104718, 104770], 6378481425e-3: [104719, 104753, 104774, 104781], 6378518001e-3: [104720, 104725], 6378521049e-3: [104721, 104723, 104731, 104745, 104748], 6378464661e-3: 104722, 6378436619e-3: 104727, 6378574389e-3: [104729, 104730], 6378472281e-3: [104732, 104756], 6378498189e-3: [104733, 104746], 6378449421e-3: [104734, 104766], 6378525621e-3: [104735, 104754], 6378466185e-3: 104737, 6378496665e-3: 104738, 6378643579e-3: 104740, 6378559758e-3: 104741, 6378414369e-3: [104742, 104763, 104772], 6378441801e-3: 104744, 6378502761e-3: [104747, 104759, 104773, 104775], 6378617061e-3: 104749, 6378624681e-3: [104751, 104765], 6378468623e-3: 104752, 6378445763e-3: [104755, 104758, 104761], 6378670401e-3: 104757, 6378438753e-3: 104762, 6378543909e-3: 104767, 6378605783e-3: 104768, 6378540861e-3: 104769, 6378443325e-3: [104771, 104784], 6378548481e-3: 104777, 6378463746e-3: 104778, 6378426561e-3: 104779, 6378453688e-3: 104783, 6378530193e-3: 104785, 6378376271e-3: [104800, 104828], 637847192e-2: 104801, 6378472931e-3: 104802, 6378411351e-3: 104803, 6378380991e-3: 104805, 637841496e-2: 104806, 637834509e-2: [104807, 104819, 104844, 104870], 6378412542e-3: 104808, 6378470401e-3: 104809, 6378376331e-3: 104810, 6378379031e-3: 104811, 6378407621e-3: 104812, 6378376811e-3: [104813, 104827], 637831392e-2: 104814, 637841493e-2: 104815, 6378413021e-3: 104816, 6378380381e-3: 104817, 6378530851e-3: 104818, 6378591521e-3: 104820, 6378378881e-3: 104821, 6378408481e-3: [104822, 104832], 6378375601e-3: [104823, 104838], 6378408041e-3: 104824, 6378655071e-3: 104825, 6378409151e-3: 104826, 63783157e-1: [104829, 104840, 104845, 104851], 637828586e-2: [104830, 104835, 104859], 6378379301e-3: 104831, 6378560121e-3: 104833, 6378531821e-3: 104834, 63785006e-1: 104836, 6378376041e-3: 104837, 6378406601e-3: 104839, 6378438991e-3: 104841, 637834542e-2: 104842, 637859386e-2: 104843, 6378381271e-3: [104846, 104847], 6378413671e-3: 104848, 6378344377e-3: 104849, 6378563891e-3: 104850, 6378408091e-3: 104852, 6378377671e-3: 104853, 6378472751e-3: 104854, 6378412511e-3: 104855, 6378407281e-3: 104856, 6378534451e-3: 104857, 6378406051e-3: 104858, 6378532921e-3: 104860, 6378380091e-3: 104861, 6378408941e-3: 104862, 6378624171e-3: 104863, 6378377411e-3: 104864, 6378474591e-3: 104865, 6378407141e-3: 104866, 6378376871e-3: 104867, 6378375251e-3: 104868, 6378405971e-3: 104869, 6378437651e-3: 104871 };
function is() {
  for (const e2 in rs2) delete rs2[e2];
}
var os = class extends ns2 {
  constructor(e2) {
    if ("number" == typeof e2) return super(), this.m_factor = e2, void (this.m_wkid = 0);
    super(e2);
  }
  getUnitType() {
    return 1;
  }
  convertFromRadians(e2) {
    return e2 / this.getUnitToBaseFactor();
  }
  convertToRadians(e2) {
    return e2 * this.getUnitToBaseFactor();
  }
};
function as(e2) {
  return new bu2();
}
function hs2(t3) {
  return t3.getType() === bc.PE_TYPE_LINUNIT ? new bu2(t3) : t3.getType() === bc.PE_TYPE_ANGUNIT ? new os(t3) : void P("peUnit");
}
function ms2(t3) {
  const s3 = Hc(null);
  return t3.getType() === bc.PE_TYPE_PROJCS || t3.getType() === bc.PE_TYPE_GEOGCS ? s3.reset(t3.getUnit()) : P("PE_coord_sys"), s3.get() || b("cannot create units from coord sys"), hs2(s3.get());
}
var ls3 = class _ls {
  constructor(t3, s3, n5) {
    void 0 === t3 ? (this.x = new p2(), this.y = new p2(), this.z = new p2()) : t3 instanceof X ? (this.x = new p2(t3.x), this.y = new p2(t3.y), this.z = new p2(t3.z)) : t3 instanceof p2 ? (this.x = t3.clone(), this.y = s3.clone(), this.z = n5.clone()) : P("EPoint3D constructor");
  }
  dotProduct(e2) {
    return this.x.mulE(e2.x).addE(this.y.mulE(e2.y)).addE(this.z.mulE(e2.z));
  }
  crossProduct(e2) {
    return new _ls(this.y.mulE(e2.z).subE(this.z.mulE(e2.y)), this.z.mulE(e2.x).subE(this.x.mulE(e2.z)), this.x.mulE(e2.y).subE(this.y.mulE(e2.x)));
  }
  crossProductVector(e2) {
    const t3 = this.y.mulE(e2.z).subE(e2.y.mulE(this.z)), s3 = e2.x.mulE(this.z).subE(this.x.mulE(e2.z)), n5 = this.x.mulE(e2.y).subE(e2.x.mulE(this.y));
    return new _ls(t3, s3, n5);
  }
  sqrLength() {
    return this.x.mulE(this.x).addE(this.y.mulE(this.y)).addE(this.z.mulE(this.z));
  }
  length() {
    return this.sqrLength().sqrt();
  }
  static distance(e2, t3) {
    return e2.sub(t3).length();
  }
  negate() {
    return new _ls(this.x.negate(), this.y.negate(), this.z.negate());
  }
  add(e2) {
    return new _ls(this.x.addE(e2.x), this.y.addE(e2.y), this.z.addE(e2.z));
  }
  sub(e2) {
    return new _ls(this.x.subE(e2.x), this.y.subE(e2.y), this.z.subE(e2.z));
  }
  subThis(e2) {
    return this.x.subThisE(e2.x), this.y.subThisE(e2.y), this.z.subThisE(e2.z), this;
  }
  addThis(e2) {
    return this.x.addThisE(e2.x), this.y.addThisE(e2.y), this.z.addThisE(e2.z), this;
  }
  mul(e2) {
    return new _ls(this.x.mulE(e2), this.y.mulE(e2), this.z.mulE(e2));
  }
  div(e2) {
    return new _ls(this.x.divE(e2), this.y.divE(e2), this.z.divE(e2));
  }
  eq(e2) {
    return this.x.eq(e2.x) && this.y.eq(e2.y) && this.z.eq(e2.z);
  }
  isZero() {
    return this.x.isZero() && this.y.isZero() && this.z.isZero();
  }
  value() {
    return X.construct(this.x.value(), this.y.value(), this.z.value());
  }
};
var gs2 = class {
  constructor(e2) {
    if (this.m_origin = new X(), this.m_normal = new X(), this.m_axisX = new X(), this.m_axisY = new X(), !e2) return this.m_origin = new X(), this.m_normal = new X(0, 0, 1), this.m_axisX = new X(1, 0, 0), void (this.m_axisY = new X(0, 1, 0));
    e2.pt0 && e2.pt1 && e2.pt2 ? this.setFromPoints(e2.pt0, e2.pt1, e2.pt2) : n(0, `unimplemented constructor options ${JSON.stringify(e2)}`);
  }
  assign(e2) {
    return n(0), this;
  }
  set(e2, t3, s3, n5) {
    n(0);
  }
  setFromPoints(e2, t3, s3) {
    let n5 = t3.sub(e2);
    const r = s3.sub(e2);
    this.m_normal = n5.crossProductVector(r);
    let i2 = true;
    if (this.m_normal.isZero()) {
      if (i2 = false, n5.isZero() && (n5 = r), n5.isZero()) {
        const t4 = 0, s4 = 1;
        return this.m_normal.setCoords(t4, t4, s4), this.m_axisX.setCoords(s4, t4, t4), this.m_axisY.setCoords(t4, s4, t4), this.m_origin = e2, false;
      }
      this.m_axisX = n5.getUnitVector(), this.m_normal = this.m_axisX.createAPerpendicular();
    } else this.m_normal.normalizeThis(), this.m_axisX = n5.getUnitVector();
    return this.m_axisY = this.m_normal.crossProductVector(this.m_axisX), this.m_origin = e2, i2;
  }
  getCoord(e2, t3) {
    return n(0), {};
  }
  getCoord2D(e2) {
    return n(0), {};
  }
  getCoordX(e2, t3) {
    return n(0), 0;
  }
  getCoordY(e2, t3) {
    return n(0), 0;
  }
  getCoordZ(e2, t3) {
    return n(0), 0;
  }
  setPreferredAxisX(e2) {
    n(0);
  }
  getOrigin() {
    return n(0), {};
  }
  getNormal() {
    return n(0), {};
  }
  getAxisX() {
    return this.m_axisX.clone();
  }
  getAxisY() {
    return this.m_axisY.clone();
  }
  setAxisX(e2, t3 = false) {
    n(0);
  }
  setAxisY(e2, t3 = false) {
    n(0);
  }
  recalculateAxisY() {
    n(0);
  }
  setOrigin(e2) {
    n(0);
  }
  setNormal(e2, t3) {
    n(0);
  }
  intersect(e2, t3) {
    return n(0), false;
  }
  intersectLine(e2) {
    return n(0), 0;
  }
  intersectLineEx(e2, t3) {
    return n(0), 0;
  }
  closestCoordinate(e2) {
    const t3 = e2.sub(this.m_origin), s3 = new mi();
    return s3.x = t3.dotProduct(this.m_axisX), s3.y = t3.dotProduct(this.m_axisY), s3;
  }
  projectVector(e2) {
    return n(0), {};
  }
  signedDistance(e2) {
    return n(0), 0;
  }
  distance(e2) {
    return n(0), 0;
  }
};
function us2(e2, t3) {
  return false;
}
function cs3(e2, t3, s3, n5, r = 100, i2 = us2) {
  let a2, h2, m3, l2, g2, u, c, _, d2;
  n(n5 > 0);
  let p3, f3, x4, y2 = 0, P5 = 0;
  const E2 = Os();
  t3 > s3 && (s3 = Pt(t3, t3 = s3));
  const S3 = e2(t3), C3 = e2(s3);
  S3 < C3 ? (a2 = h2 = m3 = t3, l2 = g2 = u = S3) : (a2 = h2 = m3 = s3, l2 = g2 = u = C3);
  let I4 = 0;
  for (; I4 < r && (x4 = 0.5 * (s3 - t3), d2 = t3 + x4, p3 = n5 * (Math.abs(a2) + 0.25), f3 = 2 * p3, !(i2(a2, l2) || Math.abs(a2 - d2) <= f3 - x4)); ++I4) {
    if (Math.abs(P5) > p3) {
      const e3 = (a2 - h2) * (l2 - u);
      let n6 = (a2 - m3) * (l2 - g2), r2 = (a2 - m3) * n6 - (a2 - h2) * e3;
      n6 = 2 * (n6 - e3), n6 > 0 && (r2 = -r2), n6 = Math.abs(n6);
      const i3 = P5;
      P5 = y2, Math.abs(r2) >= Math.abs(n6 * i3 * 0.5) || r2 <= n6 * (t3 - a2) || r2 >= n6 * (s3 - a2) ? (P5 = a2 >= d2 ? t3 - a2 : s3 - a2, y2 = Os() * P5) : (y2 = r2 / n6, _ = a2 + y2, (_ - t3 < f3 || s3 - _ < f3) && (y2 = d2 - a2 < 0 ? -Math.abs(p3) : Math.abs(p3)));
    } else P5 = a2 >= d2 ? t3 - a2 : s3 - a2, y2 = P5 * E2;
    _ = a2 + y2, c = e2(_), c < l2 ? (_ >= a2 ? t3 = a2 : s3 = a2, m3 = h2, h2 = a2, a2 = _, u = g2, g2 = l2, l2 = c) : (_ < a2 ? t3 = _ : s3 = _, c <= g2 || h2 === a2 ? (m3 = h2, h2 = _, u = g2, g2 = c) : (c <= u || m3 === a2 || m3 === h2) && (m3 = _, u = c));
  }
  return $t(a2, l2);
}
function _s3(e2, t3, s3) {
  if (e2 > s3) {
    e2 -= Math.ceil((e2 - s3) / Kt) * Kt;
  } else if (e2 < t3) {
    e2 += Math.ceil((t3 - e2) / Kt) * Kt;
  }
  return e2;
}
function ds3(e2, t3, s3) {
  return ps2(e2, t3, s3, 0);
}
function ps2(e2, t3, s3, n5) {
  const r = s3.x, i2 = s3.y;
  return xs2(e2, t3, Math.cos(r), Math.sin(r), Math.cos(i2), Math.sin(i2), n5);
}
function fs3(e2, t3, s3, n5, r, i2) {
  return xs2(e2, t3, s3, n5, r, i2, 0);
}
function xs2(e2, t3, s3, n5, r, i2, o) {
  const a2 = e2 / Math.sqrt(1 - t3 * i2 * i2), h2 = a2 + o, m3 = h2 * r * s3, l2 = h2 * r * n5, g2 = (a2 * (1 - t3) + o) * i2;
  return X.construct(m3, l2, g2);
}
function ys2(e2, t3, s3) {
  const n5 = new p2(), r = new p2(), i2 = new p2(), o = new p2();
  n5.setCos(s3.x), r.setSin(s3.x), i2.setCos(s3.y), o.setSin(s3.y);
  const a2 = o.negate().mulE(o.mul(t3)).add(1).sqrt(), h2 = new p2(e2).divE(a2), m3 = h2.mulE(i2).mulE(n5), l2 = h2.mulE(i2).mulE(r), g2 = h2.mul(1 - t3).mulE(o);
  return new ls3(m3, l2, g2);
}
function Ps3(e2, t3, s3) {
  const n5 = s3.x, r = s3.y, i2 = s3.z, o = Math.atan2(r, n5), a2 = Math.sqrt(n5 * n5 + r * r), h2 = Math.atan2(i2, (1 - t3) * a2);
  return mi.construct(o, h2);
}
function Es2(e2, t3, s3) {
  const n5 = 1 - t3, r = e2 / Math.sqrt(H(s3.x) + H(s3.y) + H(s3.z) / n5);
  return s3.mul(r);
}
function Ss3(e2, t3, s3, n5, r) {
  const i2 = ds3(e2, t3, s3), o = ds3(e2, t3, n5);
  return Ps3(e2, t3, X.lerp(i2, o, r));
}
function bs3(e2, t3, s3, n5) {
  const r = { stack: [], error: void 0, hasError: false };
  try {
    const i2 = __addDisposableResource(r, new Cc(), false);
    return Dc.geodeticDistance(e2, t3, s3.x, s3.y, n5.x, n5.y, i2, null, null, bc.PE_LINETYPE_GEODESIC), i2.val;
  } catch (i2) {
    r.error = i2, r.hasError = true;
  } finally {
    __disposeResources(r);
  }
}
function ws2(e2, t3, s3, n5, r) {
  switch (n(s3.isFinite() && n5.isFinite()), r) {
    case 0:
      return bs3(e2, t3, s3, n5);
    case 1:
      return Ts(e2, t3, s3);
    case 2:
    case 3: {
      const r2 = ds3(e2, t3, s3), i2 = ds3(e2, t3, n5);
      return X.distance(r2, i2);
    }
    default:
      z("");
  }
}
function vs3(e2, t3, s3, n5, r, i2 = 0, o) {
  if (2 === i2 || 3 === i2) return Ns2(e2, t3, s3, n5, r, 3 === i2, o);
  const a2 = Ps3(e2, t3, s3), h2 = (s4) => {
    const o2 = Ps3(e2, t3, X.lerp(n5, r, s4));
    return ws2(e2, t3, a2, o2, i2);
  }, m3 = X.distance(n5, r);
  if (m3 > 0) {
    const s4 = Os3(e2, m3), { first: i3, second: a3 } = cs3(h2, 0, 1, s4);
    return o && o.assign(Es2(e2, t3, X.lerp(n5, r, i3))), $t(i3, a3);
  }
  {
    const e3 = h2(0);
    return o && o.assign(n5), $t(0.5, e3);
  }
}
function Ns2(e2, t3, s3, n5, r, i2 = false, o) {
  const a2 = Es2(e2, t3, s3);
  if (i2) {
    const i3 = new gs2({ pt0: new X(0, 0, 0), pt1: n5, pt2: r }), h3 = i3.closestCoordinate(s3), m4 = i3.closestCoordinate(n5), l2 = i3.closestCoordinate(r), g2 = mi.getClosestCoordinate(m4, l2, h3), u = Es2(e2, t3, X.lerp(n5, r, g2)), c = X.distance(u, a2);
    return o && o.assign(u), $t(g2, c);
  }
  const h2 = (s4) => {
    const i3 = Es2(e2, t3, X.lerp(n5, r, s4));
    return X.distance(i3, a2);
  }, m3 = X.distance(n5, r);
  if (m3 > 0) {
    const s4 = Os3(e2, m3), { first: i3, second: a3 } = cs3(h2, 0, 1, s4);
    return o && o.assign(Es2(e2, t3, X.lerp(n5, r, i3))), $t(i3, a3);
  }
  {
    const e3 = X.distance(s3, n5);
    return o && o.assign(s3), $t(0.5, e3);
  }
}
function Ts(e2, t3, s3, n5) {
  const r = { stack: [], error: void 0, hasError: false };
  try {
    const n6 = __addDisposableResource(r, new Cc(), false);
    return Dc.greatEllipticDistance(e2, t3, s3.x, s3.y, s3.x, s3.y, n6, null, null), n6.val;
  } catch (i2) {
    r.error = i2, r.hasError = true;
  } finally {
    __disposeResources(r);
  }
}
function Gs3(e2, t3, s3, n5, r) {
  if (Math.abs(s3.x - n5.x) > Math.PI) return Number.NaN;
  if (Math.abs(s3.y) > Wt || Math.abs(n5.y) > Wt) return Number.NaN;
  if ((Math.abs(s3.y) === Wt || Math.abs(n5.y) === Wt) && s3.x !== n5.x) return Number.NaN;
  const { first: i2, second: o } = R2(s3.x, n5.x);
  let a2 = r;
  a2 = _s3(a2, i2, o);
  if (!x2.construct(s3.x, n5.x).containsCoordinate(a2)) return Number.NaN;
  const h2 = ve.constructPoint2D(s3), m3 = ve.constructPoint2D(n5), l2 = ys2(1, t3, h2), g2 = ys2(1, t3, m3), u = l2.crossProductVector(g2);
  if (u.z.isZero()) {
    return s3.y;
  }
  const c = u.x.divE(u.z.negate()), _ = u.y.divE(u.z.negate()), d2 = c.mulE(c).addE(_.mulE(_)).sqrt();
  if (d2.isZero() || c.isZero() && _.isZero()) {
    return s3.y;
  }
  const p3 = Math.atan2(_.value(), c.value());
  let f3 = Math.atan2(d2.value() * Math.cos(p3 - a2), 1 - t3);
  const x4 = ds3(1, t3, mi.construct(a2, f3)), y2 = X.construct(x4.x, x4.y, -x4.z), P5 = u.value().dotProduct(x4), E2 = u.value().dotProduct(y2);
  return Math.abs(E2) < Math.abs(P5) && (f3 = -f3), f3;
}
function Ds3(e2, t3, s3, n5, r, i2) {
  if (i2[0] = Number.NaN, i2[1] = Number.NaN, Math.abs(s3.x - n5.x) > Math.PI) return 0;
  if (Math.abs(s3.y) > Wt || Math.abs(n5.y) > Wt) return 0;
  if ((Math.abs(s3.y) === Wt || Math.abs(n5.y) === Wt) && s3.x !== n5.x) return 0;
  if (Math.abs(r) >= Wt) return 0;
  if (s3.y > 0 && n5.y > 0 && s3.y > r && n5.y > r || s3.y < 0 && n5.y < 0 && s3.y < r && n5.y < r) return 0;
  const o = ve.constructPoint2D(s3), a2 = ve.constructPoint2D(n5), h2 = ys2(1, t3, o), m3 = ys2(1, t3, a2), l2 = h2.crossProductVector(m3);
  if (l2.z.isZero()) {
    return x2.construct(s3.y, n5.y).containsCoordinate(r) ? (i2[0] = s3.x, 1) : 0;
  }
  const g2 = l2.x.divE(l2.z.negate()), u = l2.y.divE(l2.z.negate()), c = g2.mulE(g2).addE(u.mulE(u)).sqrt();
  if (c.isZero() || g2.isZero() && u.isZero()) return 0 === r ? (i2[0] = s3.x, i2[1] = n5.x, 2) : 0;
  const _ = (1 - t3) * Math.tan(r) / c.value();
  if (Math.abs(_) > 1) return 0;
  const d2 = Math.acos(_), p3 = Math.atan2(u.value(), g2.value()), f3 = p3 - d2;
  let x4 = p3 + d2;
  const y2 = Math.min(s3.x, n5.x), P5 = Math.max(s3.x, n5.x);
  _s3(f3, y2, P5), 0 !== r ? _s3(x4, y2, P5) : x4 = f3;
  let E2 = 0;
  return y2 <= f3 && f3 <= P5 && (i2[E2] = f3, E2++), x4 !== f3 && y2 <= x4 && x4 <= P5 && (i2[E2] = x4, E2++), E2;
}
function Vs3(e2, t3) {
  t3[0] > 0.5 * Math.PI ? (e2[0] += Math.PI, t3[0] = Math.PI - t3[0]) : t3[0] < 0.5 * -Math.PI && (e2[0] -= Math.PI, t3[0] = -Math.PI - t3[0]), n(t3[0] >= 0.5 * -Math.PI && t3[0] <= 0.5 * Math.PI);
}
function Fs2(e2, t3) {
  return e2 * Math.sqrt(1 - t3);
}
function Hs3(e2) {
  return 1 - e2;
}
function ks2(e2, t3, s3, n5, r) {
  n5 = Us(n5, -Wt, Wt), r = Us(r, -Wt, Wt);
  const i2 = Wt - 0.03;
  let o;
  o = n5 > i2 && r > i2 || n5 < -i2 && r < -i2 ? As3(e2, n5, r) : Ms2(e2, r) - Ms2(e2, n5);
  return 0.5 * (s3 - t3) * o * Hs3(e2);
}
function As3(e2, t3, s3) {
  let n5 = 1;
  if (t3 < 0 && (n5 = -1, t3 = -t3, s3 = -s3), 0 !== e2) {
    const r = e2 * e2, i2 = r * e2, o = [1, (1 + 11 * e2) / 12, (1 + 118 * e2 + 241 * r) / 360, (1 + 1089 * e2 + 10419 * r + 8651 * i2) / 20160, (1 + 9836 * e2 + 318246 * r + 1027436 * i2 + 458881 * (i2 * e2)) / 1814400], a2 = (t4) => {
      let s4 = 0;
      const n6 = H(t4) / (e2 - 1);
      for (let e3 = o.length - 1; e3 >= 0; --e3) s4 = o[e3] + s4 * n6;
      return s4 *= -H(t4 / (1 - e2)), s4;
    }, h2 = a2(Wt - t3);
    return (a2(Wt - s3) - h2) * n5;
  }
  {
    const e3 = Wt - t3, r = Wt - s3, i2 = -4 * H(Math.sin(e3 / 2));
    return (-4 * H(Math.sin(r / 2)) - i2) * n5;
  }
}
function Ms2(e2, t3) {
  if (0 === t3) return 0;
  const s3 = Math.sin(t3);
  let n5 = s3, r = s3;
  if (0 !== e2) {
    n5 /= 1 - e2 * s3 * s3;
    const t4 = Math.sqrt(e2);
    r = s3 * z2(t4 * s3);
  }
  return n5 + r;
}
function qs3(e2, t3) {
  return (1 - t3) * e2;
}
function Bs3(e2, t3, s3) {
  const n5 = s3 / (2 * qs3(e2, t3)), r = n5 * n5;
  return s3 * (1 - r * (0.16666666666666666 - 0.008333333333333333 * r));
}
function Os3(e2, t3) {
  if (0 !== t3) {
    const s3 = e2 * rs() / t3;
    return Math.min(s3, 1e-10);
  }
  return 0;
}
var Ys3 = class _Ys {
  constructor(e2) {
    this.m_currentShift = 63n, this.m_currentElt = 0n, this.m_iCurrentElt = -1, this.m_parent = e2, this.m_aiSetElts = e2.m_bits.flatMap((e3, t3) => t3);
  }
  next() {
    if (this.m_currentShift++, 64n === this.m_currentShift) {
      if (this.m_iCurrentElt++, this.m_iCurrentElt === this.m_aiSetElts.length) return _Ys.npos();
      this.m_currentShift = 0n, this.m_currentElt = this.m_parent.m_bits[this.m_aiSetElts[this.m_iCurrentElt]];
    }
    for (; this.m_currentShift < 63n && !(this.m_currentElt & 1n << this.m_currentShift); ) this.m_currentShift++;
    return this.m_currentElt & 1n << this.m_currentShift ? 64 * this.m_aiSetElts[this.m_iCurrentElt] + Number(this.m_currentShift) : this.next();
  }
  static npos() {
    return Number.MAX_SAFE_INTEGER;
  }
};
function Rs2(e2) {
  return 1n << (0x3fn & BigInt(e2));
}
function Xs3(e2) {
  return e2 >> 6;
}
var Ls3 = class {
  constructor(e2) {
    this.m_bits = [], void 0 !== e2 && e2.copy && (this.m_bits = e2.copy.m_bits.slice());
  }
  assignMove() {
    return this;
  }
  assignCopy() {
    return this;
  }
  hasBit(e2) {
    const t3 = Rs2(e2), s3 = Xs3(e2);
    return void 0 !== this.m_bits[s3] && !!(this.m_bits[s3] & t3);
  }
  setBit(e2) {
    const t3 = Rs2(e2), s3 = Xs3(e2);
    void 0 === this.m_bits[s3] && (this.m_bits[s3] = 0n), this.m_bits[s3] |= t3;
  }
  clearBit(e2) {
  }
  flipBit(e2) {
    const t3 = Rs2(e2), s3 = Xs3(e2);
    return void 0 === this.m_bits[s3] && (this.m_bits[s3] = 0n), this.m_bits[s3] ^= t3, 0n !== (this.m_bits[s3] & t3);
  }
  clear() {
    this.m_bits.length = 0;
  }
  isZero() {
    let e2 = 0;
    return this.m_bits.forEach((t3) => {
      e2 |= t3 ? 2 : 1;
    }), !(2 & e2);
  }
  equals(e2) {
    if (this === e2) return true;
    if (this.m_bits.length !== e2.m_bits.length) return false;
    let t3 = 0;
    return this.m_bits.forEach((s3, n5) => {
      t3 |= s3 === e2.m_bits[n5] ? 2 : 1;
    }), !(1 & t3) && (e2.m_bits.forEach((e3, s3) => {
      t3 |= e3 === this.m_bits[s3] ? 2 : 1;
    }), !(1 & t3));
  }
  notEquals(e2) {
    return !this.equals(e2);
  }
  assignOr(e2) {
    return e2.m_bits.forEach((e3, t3) => {
      void 0 === this.m_bits[t3] ? this.m_bits[t3] = e3 : this.m_bits[t3] |= e3;
    }), this;
  }
  assignSubtract(e2) {
    return e2.m_bits.forEach((e3, t3) => {
      void 0 !== this.m_bits[t3] && (this.m_bits[t3] &= ~e3);
    }), this;
  }
  assignAnd(e2) {
    return e2.m_bits.forEach((e3, t3) => {
      void 0 !== this.m_bits[t3] && (this.m_bits[t3] &= e3);
    }), this;
  }
  assignXor(e2) {
    return e2.m_bits.forEach((e3, t3) => {
      void 0 === this.m_bits[t3] ? this.m_bits[t3] = e3 : this.m_bits[t3] ^= e3;
    }), this;
  }
  getHashCode() {
    return this.m_bits.reduce((e2, t3) => Ps(e2, t3), Zs(0));
  }
  getUnorderedBitIterator() {
    return new Ys3(this);
  }
};
var zs3 = class {
  constructor(e2, t3) {
    this.m_map = /* @__PURE__ */ new Map(), this.m_hf = e2, this.m_ef = t3;
  }
  add(e2) {
    const t3 = this.m_hf(e2);
    if (!this.m_map.has(t3)) return this.m_map.set(t3, e2), this;
    const s3 = this.m_map.get(t3);
    return s3 instanceof Array ? s3.find((t4) => this.m_ef(t4, e2)) || s3.push(e2) : this.m_ef(s3, e2) || this.m_map.set(t3, [s3, e2]), this;
  }
  clear() {
    this.m_map.clear();
  }
  delete(e2) {
    return false;
  }
  has(e2) {
    const t3 = this.m_hf(e2);
    if (!this.m_map.has(t3)) return false;
    const s3 = this.m_map.get(t3);
    return s3 instanceof Array ? void 0 !== s3.find((t4) => this.m_ef(t4, e2)) : this.m_ef(s3, e2);
  }
  get(e2) {
    const t3 = this.m_hf(e2), s3 = this.m_map.get(t3);
    if (void 0 !== s3) return s3 instanceof Array ? s3.find((t4) => this.m_ef(t4, e2)) : s3;
  }
  get size() {
    let e2 = 0;
    for (const t3 of this.m_map.values()) e2 += t3 instanceof Array ? t3.length : 1;
    return e2;
  }
  forEach(e2, t3) {
  }
  [Symbol.iterator]() {
    return (/* @__PURE__ */ new Set())[Symbol.iterator]();
  }
  entries() {
    return (/* @__PURE__ */ new Set()).entries();
  }
  keys() {
    return (/* @__PURE__ */ new Set()).keys();
  }
  values() {
    return (/* @__PURE__ */ new Set()).values();
  }
  get [Symbol.toStringTag]() {
    return "ValueSet";
  }
};
var Ws3 = class extends dt {
  constructor(e2) {
    super(), this.m_bufferLeft = new fm(), this.m_bufferRight = new fm(), this.m_intervalLeft = x2.constructEmpty(), this.m_intervalRight = x2.constructEmpty(), this.m_yScanline = Number.NaN, this.m_helper = e2;
  }
  compare(e2, t3, s3) {
    const n5 = t3, r = e2.getElement(s3);
    this.m_helper.querySegmentXY(n5, this.m_bufferLeft), this.m_helper.querySegmentXY(r, this.m_bufferRight);
    const i2 = this.m_bufferLeft.get(), o = this.m_bufferRight.get();
    if (this.m_intervalLeft.setCoords(i2.getStartX(), i2.getEndX()), this.m_intervalRight.setCoords(o.getStartX(), o.getEndX()), this.m_intervalLeft.vmax < this.m_intervalRight.vmin) return -1;
    if (this.m_intervalLeft.vmin > this.m_intervalRight.vmax) return 1;
    const a2 = i2.getStartY() === i2.getEndY(), h2 = o.getStartY() === o.getEndY();
    if (a2 || h2) {
      if (a2 && h2) return 0;
      if (i2.getStartY() === o.getStartY() && i2.getStartX() === o.getStartX()) return a2 ? 1 : -1;
      if (i2.getEndY() === o.getEndY() && i2.getEndX() === o.getEndX()) return a2 ? -1 : 1;
    }
    let m3 = i2.intersectionOfYMonotonicWithAxisX(this.m_yScanline, this.m_intervalLeft.vmin), l2 = o.intersectionOfYMonotonicWithAxisX(this.m_yScanline, this.m_intervalRight.vmin);
    if (m3 === l2) {
      const e3 = i2.getEndY(), t4 = o.getEndY(), s4 = Math.min(e3, t4);
      let n6 = 0.5 * (s4 + this.m_yScanline);
      n6 === this.m_yScanline && (n6 = s4), m3 = i2.intersectionOfYMonotonicWithAxisX(n6, this.m_intervalLeft.vmin), l2 = o.intersectionOfYMonotonicWithAxisX(n6, this.m_intervalRight.vmin);
    }
    return m3 < l2 ? -1 : m3 > l2 ? 1 : 0;
  }
  setY(e2) {
    this.m_yScanline = e2;
  }
};
var js3 = class {
  constructor(e2) {
    this.m_segmentBuffer = new fm(), this.m_point = mi.getNAN(), this.m_parent = e2;
  }
  setPointXY(e2) {
    this.m_point.assign(e2);
  }
  compare(e2, t3) {
    const s3 = e2.getElement(t3);
    this.m_parent.querySegmentXY(s3, this.m_segmentBuffer);
    const n5 = this.m_segmentBuffer.get(), r = new x2();
    if (r.setCoords(n5.getStartX(), n5.getEndX()), this.m_point.x < r.vmin) return -1;
    if (this.m_point.x > r.vmax) return 1;
    const i2 = n5.intersectionOfYMonotonicWithAxisX(this.m_point.y, this.m_point.x);
    return this.m_point.x < i2 ? -1 : this.m_point.x > i2 ? 1 : 0;
  }
};
var Zs3;
var Ks2;
function Qs3(e2, t3) {
  return { parentage: e2, rank: t3 };
}
function Js3(e2, t3) {
  const s3 = e2.length;
  if (s3 !== t3.length) return false;
  const n5 = e2[0].parentage;
  if (n5 !== t3[0].parentage) return false;
  if (-1 === n5) return true;
  for (let r = 1; r < s3; ++r) if (e2[r].parentage !== t3[r].parentage) return false;
  return true;
}
function $s3(e2, t3, s3) {
  s3.length = 0;
  let n5 = false;
  {
    let r = e2.getHalfEdgeVertexIterator(t3);
    for (; r !== cr; ) {
      const t4 = e2.getVertexFromVertexIterator(r), i2 = e2.getShape().getSegmentRank(t4), o = e2.getShape().getSegmentParentage(t4);
      n5 ||= o >= 0, s3.push(Qs3(o, i2)), r = e2.incrementVertexIterator(r);
    }
  }
  {
    let r = e2.getHalfEdgeVertexIterator(e2.getHalfEdgeTwin(t3));
    for (; r !== cr; ) {
      const t4 = e2.getVertexFromVertexIterator(r), i2 = e2.getShape().getSegmentRank(t4), o = e2.getShape().getSegmentParentage(t4);
      n5 ||= o >= 0, s3.push(Qs3(o, i2)), r = e2.incrementVertexIterator(r);
    }
  }
  n5 && s3.sort((e3, t4) => e3.rank > t4.rank ? -1 : e3.rank < t4.rank ? 1 : e3.parentage < t4.parentage ? -1 : e3.parentage > t4.parentage ? 1 : 0), -1 === s3[0].parentage && (s3.length = 1);
}
function en2() {
  return new zs3((e2) => e2.getHashCode(), (e2, t3) => e2.equals(t3));
}
!(function(e2) {
  e2[e2.enumInputModeBuildGraph = 0] = "enumInputModeBuildGraph", e2[e2.enumInputModeSimplifyAlternate = 1] = "enumInputModeSimplifyAlternate", e2[e2.enumInputModeSimplifyWinding = 2] = "enumInputModeSimplifyWinding";
})(Zs3 || (Zs3 = {})), (function(e2) {
  e2[e2.enumSegmentParentageBreakNode = 1] = "enumSegmentParentageBreakNode", e2[e2.enumPathBreakNode = 2] = "enumPathBreakNode";
})(Ks2 || (Ks2 = {}));
var tn2 = class _tn {
  constructor() {
    this.m_shape = null, this.m_clusterData = new at(8), this.m_clusterVertices = new at(2), this.m_firstCluster = cr, this.m_lastCluster = cr, this.m_halfEdgeData = new at(8), this.m_chainData = new at(8), this.m_chainAreas = null, this.m_chainPerimeters = null, this.m_universeChain = -1, this.m_simplifiedGeometry = -1, this.m_edgeIndices = [], this.m_clusterIndices = [], this.m_chainIndices = [], this.m_bBuildGeometryParentageSets = false, this.m_chainBitSetIndex = -1, this.m_edgeBitSetIndex = -1, this.m_edgeBitSetIndexLeft = -1, this.m_emptyBitSet = null, this.m_geometryMapID = null, this.m_uniqueBitSets = null, this.m_chainBitSets = [], this.m_edgeBitSets = [], this.m_checkDirtyPlanesweepTolerance = Number.NaN, this.m_geometryIDIndex = -1, this.m_clusterIndex = -1, this.m_halfEdgeIndex = -1, this.m_tmpHalfEdgeParentageIndex = -1, this.m_tmpHalfEdgeParentageIndexLeft = -1, this.m_tmpHalfEdgeWindingNumberIndex = -1, this.m_tmpHalfEdgeOddEvenNumberIndex = -1, this.m_segmentParentageIndex = -1, this.m_segmentIndexHe = -1, this.m_clusterBreakNodeIndex = -1, this.m_universeGeomID = -1, this.m_pointCount = 0, this.m_progressCounter = 0, this.m_bBuildChains = true, this.m_bDirtyCheckFailed = false;
  }
  setCheckDirtyPlanesweepTolerance(e2) {
    this.m_checkDirtyPlanesweepTolerance = e2;
  }
  dirtyCheckFailed() {
    return this.m_bDirtyCheckFailed;
  }
  getShape() {
    return this.m_shape;
  }
  setEditShape(e2, t3, s3 = true, n5 = false) {
    n5 ? this.setEditShapeImpl3D_(e2, Zs3.enumInputModeBuildGraph, null, t3, false) : this.setEditShapeImpl_(e2, Zs3.enumInputModeBuildGraph, null, t3, s3);
  }
  setAndSimplifyEditShapeAlternate(e2, t3, n5 = null, r = false) {
    const i2 = [];
    i2.push(t3), this.m_simplifiedGeometry = t3, r ? this.setEditShapeImpl3D_(e2, Zs3.enumInputModeSimplifyAlternate, i2, n5, false) : this.setEditShapeImpl_(e2, Zs3.enumInputModeSimplifyAlternate, i2, n5, e2.getGeometryType(t3) === a.enumPolygon);
  }
  setAndSimplifyEditShapeWinding(e2, t3, s3 = null) {
    const n5 = [];
    n5.push(t3), this.m_simplifiedGeometry = t3, this.setEditShapeImpl_(e2, Zs3.enumInputModeSimplifyWinding, n5, s3, true);
  }
  removeShape() {
    null !== this.m_shape && (-1 !== this.m_geometryIDIndex && (this.m_shape.removeGeometryUserIndex(this.m_geometryIDIndex), this.m_geometryIDIndex = -1), -1 !== this.m_clusterIndex && (this.m_shape.removeUserIndex(this.m_clusterIndex), this.m_clusterIndex = -1), -1 !== this.m_halfEdgeIndex && (this.m_shape.removeUserIndex(this.m_halfEdgeIndex), this.m_halfEdgeIndex = -1), -1 !== this.m_tmpHalfEdgeParentageIndex && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndex), this.m_tmpHalfEdgeParentageIndex = -1), -1 !== this.m_tmpHalfEdgeParentageIndexLeft && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndexLeft), this.m_tmpHalfEdgeParentageIndexLeft = -1), -1 !== this.m_tmpHalfEdgeWindingNumberIndex && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeWindingNumberIndex), this.m_tmpHalfEdgeWindingNumberIndex = -1), -1 !== this.m_tmpHalfEdgeOddEvenNumberIndex && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeOddEvenNumberIndex), this.m_tmpHalfEdgeOddEvenNumberIndex = -1), -1 !== this.m_segmentParentageIndex && (this.deleteUserIndexForHalfEdges(this.m_segmentParentageIndex), this.m_segmentParentageIndex = -1), -1 !== this.m_segmentIndexHe && (this.deleteUserIndexForHalfEdges(this.m_segmentIndexHe), this.m_segmentIndexHe = -1), -1 !== this.m_clusterBreakNodeIndex && (this.deleteUserIndexForClusters(this.m_clusterBreakNodeIndex), this.m_clusterBreakNodeIndex = -1), this.deleteEdgeBitSets_(), this.deleteChainBitSets_(), this.m_emptyBitSet = null, this.m_geometryMapID = null, this.m_shape = null, this.m_clusterData.deleteAll(true), this.m_clusterVertices.deleteAll(true), this.m_firstCluster = cr, this.m_lastCluster = cr, this.m_halfEdgeData.deleteAll(true), this.m_edgeIndices.length = 0, this.m_clusterIndices.length = 0, this.m_chainIndices.length = 0, this.m_chainData.deleteAll(true), this.m_universeChain = cr, this.m_chainAreas = null);
  }
  getClusterHalfEdge(e2) {
    return this.m_clusterData.getField(e2, 2);
  }
  queryXY(e2, t3) {
    const s3 = this.getClusterVertexIndex_(e2);
    t3.assign(this.m_shape.getXYWithIndex(s3));
  }
  queryXYZ(e2, t3) {
    n(0);
  }
  getClusterParentage(e2) {
    return this.m_clusterData.getField(e2, 1);
  }
  getFirstCluster() {
    return this.m_firstCluster;
  }
  getPrevCluster(e2) {
    return this.m_clusterData.getField(e2, 3);
  }
  getNextCluster(e2) {
    return this.m_clusterData.getField(e2, 4);
  }
  getClusterChain(e2) {
    return this.m_clusterData.getField(e2, 6);
  }
  getClusterVertexIterator(e2) {
    return this.m_clusterData.getField(e2, 7);
  }
  incrementVertexIterator(e2) {
    return this.m_clusterVertices.getField(e2, 1);
  }
  getVertexFromVertexIterator(e2) {
    return this.m_clusterVertices.getField(e2, 0);
  }
  getClusterUserIndex(e2, t3) {
    const s3 = this.getClusterIndex_(e2), n5 = this.m_clusterIndices[t3];
    return n5.size() <= s3 ? -1 : n5.read(s3);
  }
  setClusterUserIndex(e2, t3, s3) {
    const n5 = this.getClusterIndex_(e2), r = this.m_clusterIndices[t3];
    r.size() <= n5 && r.resize(this.m_clusterData.size(), -1), r.write(n5, s3);
  }
  hasClusterUserIndexFlags(e2, t3, s3) {
    if (-1 === t3) return false;
    const n5 = this.getClusterUserIndex(e2, t3);
    return -1 !== n5 && 0 !== (s3 & n5);
  }
  setClusterUserIndexFlags(e2, t3, s3) {
    const n5 = this.getClusterIndex_(e2), r = this.m_clusterIndices[t3];
    r.size() <= n5 && r.resize(this.m_clusterData.size(), -1);
    let i2 = r.read(n5);
    -1 === i2 && (i2 = 0), r.write(n5, s3 | i2);
  }
  clearClusterUserIndexFlags(e2, t3, s3) {
    const n5 = this.getClusterIndex_(e2), r = this.m_clusterIndices[t3];
    r.size() <= n5 && r.resize(this.m_clusterData.size(), -1);
    let i2 = r.read(n5);
    -1 === i2 && (i2 = 0), r.write(n5, ~s3 & i2);
  }
  createUserIndexForClusters(e2 = -1) {
    const t3 = new st2(this.m_clusterData.capacity(), e2);
    for (let s3 = 0, n5 = this.m_clusterIndices.length; s3 < n5; s3++) if (null === this.m_clusterIndices[s3]) return this.m_clusterIndices[s3] = t3, s3;
    this.m_clusterIndices.push(t3);
    return this.m_clusterIndices.length - 1;
  }
  deleteUserIndexForClusters(e2) {
    this.m_clusterIndices[e2] = null;
  }
  getHalfEdgeOrigin(e2) {
    return this.m_halfEdgeData.getField(e2, 1);
  }
  getHalfEdgeTo(e2) {
    return this.getHalfEdgeOrigin(this.getHalfEdgeTwin(e2));
  }
  getHalfEdgeTwin(e2) {
    return this.m_halfEdgeData.getField(e2, 4);
  }
  getHalfEdgePrev(e2) {
    return this.m_halfEdgeData.getField(e2, 5);
  }
  getHalfEdgeNext(e2) {
    return this.m_halfEdgeData.getField(e2, 6);
  }
  getHalfEdgeChain(e2) {
    return this.m_halfEdgeData.getField(e2, 2);
  }
  getHalfEdgeFaceParentage(e2) {
    return this.getChainParentage(this.getHalfEdgeChain(e2));
  }
  getHalfEdgeVertexIterator(e2) {
    return this.m_halfEdgeData.getField(e2, 7);
  }
  getHalfEdgeFromXY(e2, t3) {
    this.queryXY(this.getHalfEdgeOrigin(e2), t3);
  }
  getHalfEdgeToXY(e2, t3) {
    this.queryXY(this.getHalfEdgeTo(e2), t3);
  }
  isHalfEdgeCurve(e2) {
    if (-1 !== this.m_segmentIndexHe) {
      return -1 !== this.getHalfEdgeUserIndex(e2, this.m_segmentIndexHe);
    }
    return false;
  }
  getHalfEdgeFromXYZ(e2, t3) {
    n(0);
  }
  getHalfEdgeToXYZ(e2, t3) {
    n(0);
  }
  getHalfEdgeParentage(e2) {
    return this.m_halfEdgeData.getField(e2, 3) & _tn.c_EdgeParentageMask;
  }
  getHalfEdgeUserIndex(e2, t3) {
    const s3 = this.getHalfEdgeIndex_(e2), n5 = this.m_edgeIndices[t3];
    return n5.size() <= s3 ? -1 : n5.read(s3);
  }
  setHalfEdgeUserIndex(e2, t3, s3) {
    const n5 = this.getHalfEdgeIndex_(e2), r = this.m_edgeIndices[t3];
    r.size() <= n5 && r.resize(this.m_halfEdgeData.size(), -1), r.write(n5, s3);
  }
  createUserIndexForHalfEdges(e2) {
    void 0 === e2 && (e2 = -1);
    const t3 = new st2(this.m_halfEdgeData.capacity(), e2);
    for (let n5 = 0, r = this.m_edgeIndices.length; n5 < r; n5++) if (null === this.m_edgeIndices[n5]) return this.m_edgeIndices[n5] = t3, n5;
    this.m_edgeIndices.push(t3);
    const s3 = this.m_edgeIndices.length - 1;
    return n(s3 >= 0 && s3 <= Number.MAX_SAFE_INTEGER), s3;
  }
  deleteUserIndexForHalfEdges(e2) {
    this.m_edgeIndices[e2] = null;
  }
  deleteEdgesBreakFaces_(e2) {
    for (let t3 = 0, s3 = e2.length; t3 < s3; t3++) {
      const s4 = e2[t3], n5 = this.getHalfEdgeChain(s4), r = this.getHalfEdgeTwin(s4), i2 = this.getHalfEdgeChain(r);
      this.setChainHalfEdge_(n5, cr), this.setChainHalfEdge_(i2, cr), this.updateVertexToHalfEdgeConnection_(s4, true), this.deleteEdgeImpl_(s4);
    }
  }
  doesHalfEdgeBelongToAPolygonInterior(e2, t3) {
    return n(0), false;
  }
  doesHalfEdgeBelongToAPolygonExterior(e2, t3) {
    return n(0), false;
  }
  doesHalfEdgeBelongToAPolygonBoundary(e2, t3) {
    return n(0), false;
  }
  doesHalfEdgeBelongToAPolylineInterior(e2, t3) {
    return n(0), false;
  }
  doesHalfEdgeBelongToAPolylineExterior(e2, t3) {
    return n(0), false;
  }
  doesClusterBelongToAPolygonInterior(e2, t3) {
    return n(0), false;
  }
  doesClusterBelongToAPolygonExterior(e2, t3) {
    return n(0), false;
  }
  doesClusterBelongToAPolygonBoundary(e2, t3) {
    return n(0), false;
  }
  getFirstChain() {
    return this.m_universeChain;
  }
  getChainHalfEdge(e2) {
    return this.m_chainData.getField(e2, 1);
  }
  getChainParentage(e2) {
    return this.m_chainData.getField(e2, 2);
  }
  getChainParent(e2) {
    return this.m_chainData.getField(e2, 3);
  }
  getChainFirstIsland(e2) {
    return this.m_chainData.getField(e2, 4);
  }
  getChainNextInParent(e2) {
    return this.m_chainData.getField(e2, 5);
  }
  getChainNext(e2) {
    return this.m_chainData.getField(e2, 7);
  }
  getChainArea(e2) {
    const t3 = this.getChainIndex_(e2);
    let s3 = this.m_chainAreas.read(t3);
    return Number.isNaN(s3) && (this.updateChainAreaAndPerimeter_(e2), s3 = this.m_chainAreas.read(t3)), s3;
  }
  getChainPerimeter(e2) {
    return n(0), 0;
  }
  getChainUserIndex(e2, t3) {
    const s3 = this.getChainIndex_(e2), n5 = this.m_chainIndices[t3];
    return n5.size() <= s3 ? -1 : n5.read(s3);
  }
  setChainUserIndex(e2, t3, s3) {
    const n5 = this.getChainIndex_(e2), r = this.m_chainIndices[t3];
    r.size() <= n5 && r.resize(this.m_chainData.size(), -1), r.write(n5, s3);
  }
  createUserIndexForChains() {
    const e2 = new st2(this.m_chainData.capacity(), -1);
    for (let t3 = 0, s3 = this.m_chainIndices.length; t3 < s3; t3++) if (null === this.m_chainIndices[t3]) return this.m_chainIndices[t3] = e2, t3;
    this.m_chainIndices.push(e2);
    return this.m_chainIndices.length - 1;
  }
  deleteUserIndexForChains(e2) {
    this.m_chainIndices[e2] = null;
  }
  extractPolygonFromChainAndIslands(e2, t3, n5, r) {
    const i2 = t3 === cr ? e2.createGeometry(a.enumPolygon) : t3, o = new fm();
    this.extractPolygonPathFromChain_(e2, i2, n5, r, o);
    for (let s3 = this.getChainFirstIsland(n5); s3 !== cr; s3 = this.getChainNextInParent(s3)) this.extractPolygonPathFromChain_(e2, i2, s3, r, o);
    return i2;
  }
  getGeometryID(e2) {
    const t3 = this.m_shape.getGeometryUserIndex(e2, this.m_geometryIDIndex);
    return n(t3 >= 0), 1 << Math.min(t3, 31);
  }
  getClusterFromVertex(e2) {
    return this.m_shape.getUserIndex(e2, this.m_clusterIndex);
  }
  getHalfEdgeFromVertex(e2) {
    return this.m_shape.getUserIndex(e2, this.m_halfEdgeIndex);
  }
  buildGeometryParentageSets() {
    this.m_bBuildGeometryParentageSets = true;
  }
  getChainBitSet(e2) {
    if (n(this.m_bBuildGeometryParentageSets), -1 === this.m_chainBitSetIndex) return this.getEmptySet();
    const t3 = this.getChainUserIndex(e2, this.m_chainBitSetIndex);
    n(t3 >= 0);
    let s3 = this.m_chainBitSets.at(t3);
    return s3 || (s3 = this.getEmptySet()), s3;
  }
  getChainBoundaryBitSet(e2) {
    n(this.m_bBuildGeometryParentageSets);
    const t3 = new Ls3(), s3 = (e3) => {
      const s4 = this.getChainHalfEdge(e3);
      let n5 = s4;
      do {
        const e4 = this.getEdgeBitSet_(n5);
        null !== e4 && t3.assignOr(e4);
        const s5 = this.getEdgeBitSet_(this.getHalfEdgeTwin(n5));
        null !== s5 && t3.assignOr(s5), n5 = this.getHalfEdgeNext(n5);
      } while (n5 !== s4);
    };
    s3(e2);
    for (let n5 = this.getChainFirstIsland(e2); n5 !== cr; n5 = this.getChainNextInParent(n5)) s3(e2);
    return t3;
  }
  getChainPolygons(e2) {
    return n(0), [];
  }
  getGeometriesFromBits(e2) {
    if (!this.m_bBuildGeometryParentageSets || null === e2) return [];
    if (null === this.m_geometryMapID) {
      this.m_geometryMapID = /* @__PURE__ */ new Map();
      for (let e3 = this.m_shape.getFirstGeometry(); e3 !== cr; e3 = this.m_shape.getNextGeometry(e3)) this.m_geometryMapID.set(this.m_shape.getGeometryUserIndex(e3, this.m_geometryIDIndex), e3);
    }
    const t3 = [], s3 = e2.getUnorderedBitIterator();
    for (let n5 = s3.next(); n5 !== Ys3.npos(); n5 = s3.next()) n(this.m_geometryMapID.has(n5)), t3.push(this.m_geometryMapID.get(n5));
    return t3;
  }
  getVertexDominant(e2, t3) {
    if (t3 === cr) return e2;
    const s3 = this.getClusterFromVertex(e2);
    return this.getVertexDominantFromCluster(s3, t3);
  }
  getVertexDominantFromCluster(e2, t3) {
    if (t3 !== cr) {
      let s3 = cr;
      for (let n5 = this.getClusterVertexIterator(e2); n5 !== cr; n5 = this.incrementVertexIterator(n5)) {
        const e3 = this.getVertexFromVertexIterator(n5);
        s3 === cr && (s3 = e3);
        const r = this.m_shape.getPathFromVertex(e3);
        if (this.m_shape.getGeometryFromPath(r) === t3) {
          s3 = e3;
          break;
        }
      }
      return s3;
    }
    {
      const t4 = this.getClusterVertexIterator(e2);
      if (t4 !== cr) {
        return this.getVertexFromVertexIterator(t4);
      }
      return cr;
    }
  }
  isBreakNode(e2) {
    return this.hasClusterUserIndexFlags(e2, this.m_clusterBreakNodeIndex, Ks2.enumSegmentParentageBreakNode);
  }
  setBreakNode(e2, t3) {
    n(-1 !== this.m_clusterBreakNodeIndex), t3 ? this.setClusterUserIndexFlags(e2, this.m_clusterBreakNodeIndex, Ks2.enumSegmentParentageBreakNode) : this.clearClusterUserIndexFlags(e2, this.m_clusterBreakNodeIndex, Ks2.enumSegmentParentageBreakNode);
  }
  isStrongPathNode(e2) {
    return this.hasClusterUserIndexFlags(e2, this.m_clusterBreakNodeIndex, Ks2.enumPathBreakNode);
  }
  setStrongPathNode(e2, t3) {
    if (-1 === this.m_clusterBreakNodeIndex) {
      if (!t3) return;
      this.m_clusterBreakNodeIndex = this.createUserIndexForClusters();
    }
    t3 ? this.setClusterUserIndexFlags(e2, this.m_clusterBreakNodeIndex, Ks2.enumPathBreakNode) : this.clearClusterUserIndexFlags(e2, this.m_clusterBreakNodeIndex, Ks2.enumPathBreakNode);
  }
  getSegmentParentage(e2) {
    if (-1 === this.m_segmentParentageIndex) return -1;
    const t3 = this.getHalfEdgeUserIndex(e2, this.m_segmentParentageIndex);
    return t3 >= 0 ? t3 : -1;
  }
  isCrossroadAhead(e2) {
    const t3 = this.getHalfEdgeNext(e2);
    if (this.isStrongPathNode(this.getHalfEdgeOrigin(t3))) return true;
    const s3 = this.getHalfEdgeTwin(t3), n5 = this.getHalfEdgeNext(s3);
    return e2 !== this.getHalfEdgeTwin(n5);
  }
  isCrossroadBehind(e2) {
    return n(0), false;
  }
  getHalfEdgeConnector(e2, t3) {
    const s3 = this.getClusterHalfEdge(e2);
    if (s3 === cr) return cr;
    let n5 = s3, r = cr, i2 = cr;
    do {
      if (this.getHalfEdgeTo(n5) === t3) return n5;
      if (r === cr) {
        if (r = this.getClusterHalfEdge(t3), r === cr) return cr;
        i2 = r;
      }
      if (this.getHalfEdgeTo(i2) === e2) return n5 = this.getHalfEdgeTwin(i2), n5;
      n5 = this.getHalfEdgeNext(this.getHalfEdgeTwin(n5)), i2 = this.getHalfEdgeNext(this.getHalfEdgeTwin(i2));
    } while (n5 !== s3 && i2 !== r);
    return cr;
  }
  querySegmentXY(e2, t3) {
    if (-1 !== this.m_segmentIndexHe) {
      let s4 = this.getHalfEdgeUserIndex(e2, this.m_segmentIndexHe);
      if (-1 !== s4) {
        if (-2 !== s4) {
          const e3 = this.m_shape.getSegmentFromIndex(s4);
          t3.copyFrom(e3, true);
        } else {
          s4 = this.getHalfEdgeUserIndex(this.getHalfEdgeTwin(e2), this.m_segmentIndexHe);
          const n6 = this.m_shape.getSegmentFromIndex(s4);
          t3.copyFrom(n6, true), t3.get().reverse();
        }
        return;
      }
    }
    t3.createLine();
    const s3 = t3.get(), n5 = mi.getNAN();
    this.getHalfEdgeFromXY(e2, n5), s3.setStartXY(n5), this.getHalfEdgeToXY(e2, n5), s3.setEndXY(n5);
  }
  isCurveEdge(e2) {
    if (-1 !== this.m_segmentIndexHe) {
      return -1 !== this.getHalfEdgeUserIndex(e2, this.m_segmentIndexHe);
    }
    return false;
  }
  compareEdgeAnglesCurveHelper_(e2, t3, s3) {
    const n5 = new fm(), r = new fm();
    this.querySegmentXY(e2, n5), this.querySegmentXY(t3, r);
    const i2 = n5.get(), a2 = r.get();
    if (i2.equals(a2)) return 0;
    const h2 = new mi();
    this.getHalfEdgeFromXY(e2, h2);
    const m3 = new mi();
    this.getHalfEdgeToXY(e2, m3);
    const l2 = new mi();
    this.getHalfEdgeToXY(t3, l2), n(!m3.isEqualPoint2D(l2));
    return Ie(i2, a2);
  }
  compareEdgeAnglesHelper_(e2, t3, s3) {
    if (e2 === t3) return 0;
    if (this.isHalfEdgeCurve(e2) || this.isHalfEdgeCurve(t3)) return this.compareEdgeAnglesCurveHelper_(e2, t3, s3);
    const n5 = mi.getNAN();
    this.getHalfEdgeToXY(e2, n5);
    const r = mi.getNAN();
    if (this.getHalfEdgeToXY(t3, r), n5.isEqualPoint2D(r)) return 0;
    const i2 = mi.getNAN();
    this.getHalfEdgeFromXY(e2, i2);
    const o = mi.getNAN();
    o.setSub(n5, i2);
    const a2 = mi.getNAN();
    if (a2.setSub(r, i2), !s3 || a2.y >= 0 && o.y > 0) {
      return mi.compareVectors(o, a2);
    }
    return 0;
  }
  compareEdgeAngles_(e2, t3) {
    return this.compareEdgeAnglesHelper_(e2, t3, false);
  }
  compareEdgeAnglesForPair_(e2, t3) {
    return this.compareEdgeAnglesHelper_(e2, t3, true);
  }
  compareEdgeAngles3D_(e2, t3) {
    return n(0), 0;
  }
  compareEdgeAnglesForPair3D_(e2, t3) {
    return n(0), 0;
  }
  dbgDumpChains_() {
  }
  dbgDumpChainToPolygon_(e2, t3) {
  }
  deleteEdgeInternal_(e2) {
    const t3 = this.getHalfEdgeChain(e2), s3 = this.getHalfEdgeTwin(e2), n5 = this.getHalfEdgeChain(s3);
    n(n5 === t3), n(e2 === this.getHalfEdgeNext(s3) || s3 === this.getHalfEdgeNext(e2));
    let r = this.getHalfEdgeNext(e2);
    r === s3 && (r = this.getHalfEdgeNext(r), r === e2 && (r = cr));
    const i2 = this.getChainIndex_(t3), a2 = this.m_chainAreas.read(i2);
    Number.isNaN(a2) || (this.setChainArea_(t3, Number.NaN), this.setChainPerimeter_(t3, Number.NaN));
    const h2 = this.getChainHalfEdge(t3);
    h2 !== e2 && h2 !== s3 || this.setChainHalfEdge_(t3, r), this.updateVertexToHalfEdgeConnection_(e2, true), this.deleteEdgeImpl_(e2);
  }
  getFirstUnvisitedHalfEdgeOnCluster_(e2, t3, s3) {
    let n5 = t3 !== cr ? t3 : this.getClusterHalfEdge(e2);
    if (n5 === cr) return cr;
    const r = n5;
    for (; ; ) {
      if (1 !== this.getHalfEdgeUserIndex(n5, s3)) return n5;
      const e3 = this.getHalfEdgeNext(this.getHalfEdgeTwin(n5));
      if (e3 === r) return cr;
      n5 = e3;
    }
  }
  removeSpikes_() {
    let e2 = false;
    const t3 = this.createUserIndexForHalfEdges();
    for (let s3 = this.getFirstCluster(); s3 !== cr; s3 = this.getNextCluster(s3)) {
      let n5 = cr;
      for (; ; ) {
        let r = this.getFirstUnvisitedHalfEdgeOnCluster_(s3, n5, t3);
        if (r === cr) break;
        n5 = this.getHalfEdgeNext(this.getHalfEdgeTwin(r));
        let i2 = r;
        for (; ; ) {
          const s4 = this.getHalfEdgeNext(i2), o = this.getHalfEdgePrev(i2), a2 = this.getHalfEdgeTwin(i2);
          if (o === a2) {
            if (this.deleteEdgeInternal_(i2), e2 = true, n5 !== i2 && n5 !== a2 || (n5 = cr), i2 === r || o === r) {
              if (r = s4, i2 === r || o === r) break;
              i2 = s4;
              continue;
            }
          } else this.setHalfEdgeUserIndex(i2, t3, 1);
          if (i2 = s4, i2 === r) break;
        }
      }
    }
    return this.deleteUserIndexForHalfEdges(t3), e2;
  }
  progress_(e2, t3 = false) {
  }
  newCluster_() {
    const e2 = this.m_clusterData.newElement();
    return this.m_clusterData.setField(e2, 1, 0), e2;
  }
  newHalfEdgePair_() {
    const e2 = this.m_halfEdgeData.newElement();
    this.m_halfEdgeData.setField(e2, 2, 0), this.m_halfEdgeData.setField(e2, 3, 0);
    const t3 = this.m_halfEdgeData.newElement();
    return this.m_halfEdgeData.setField(t3, 2, 0), this.m_halfEdgeData.setField(t3, 3, 0), this.setHalfEdgeTwin_(e2, t3), this.setHalfEdgeTwin_(t3, e2), e2;
  }
  newChain_() {
    const e2 = this.m_chainData.newElement();
    return this.m_chainData.setField(e2, 2, 0), e2;
  }
  deleteChain_(e2) {
    return n(0), 0;
  }
  getClusterIndex_(e2) {
    return this.m_clusterData.elementToIndex(e2);
  }
  setClusterVertexIterator_(e2, t3) {
    this.m_clusterData.setField(e2, 7, t3);
  }
  setClusterHalfEdge_(e2, t3) {
    this.m_clusterData.setField(e2, 2, t3);
  }
  setClusterParentage_(e2, t3) {
    this.m_clusterData.setField(e2, 1, t3);
  }
  setPrevCluster_(e2, t3) {
    this.m_clusterData.setField(e2, 3, t3);
  }
  setNextCluster_(e2, t3) {
    this.m_clusterData.setField(e2, 4, t3);
  }
  setClusterVertexIndex_(e2, t3) {
    this.m_clusterData.setField(e2, 5, t3);
  }
  getClusterVertexIndex_(e2) {
    return this.m_clusterData.getField(e2, 5);
  }
  setClusterChain_(e2, t3) {
    this.m_clusterData.setField(e2, 6, t3);
  }
  addClusterToExteriorChain_(e2, t3) {
    this.setClusterChain_(t3, e2);
  }
  getHalfEdgeIndex_(e2) {
    return this.m_halfEdgeData.elementToIndex(e2);
  }
  setHalfEdgeOrigin_(e2, t3) {
    this.m_halfEdgeData.setField(e2, 1, t3);
  }
  setHalfEdgeTwin_(e2, t3) {
    this.m_halfEdgeData.setField(e2, 4, t3);
  }
  setHalfEdgePrev_(e2, t3) {
    this.m_halfEdgeData.setField(e2, 5, t3);
  }
  setHalfEdgeNext_(e2, t3) {
    this.m_halfEdgeData.setField(e2, 6, t3);
  }
  setHalfEdgeChain_(e2, t3) {
    this.m_halfEdgeData.setField(e2, 2, t3);
  }
  setHalfEdgeParentage_(e2, t3) {
    this.m_halfEdgeData.setField(e2, 3, t3);
  }
  getHalfEdgeParentageMask_(e2) {
    return this.m_halfEdgeData.getField(e2, 3);
  }
  setHalfEdgeVertexIterator_(e2, t3) {
    this.m_halfEdgeData.setField(e2, 7, t3);
  }
  updateVertexToHalfEdgeConnectionHelper_(e2, t3) {
    const s3 = t3 ? cr : e2;
    for (let n5 = this.getHalfEdgeVertexIterator(e2); n5 !== cr; n5 = this.incrementVertexIterator(n5)) {
      const e3 = this.getVertexFromVertexIterator(n5);
      this.m_shape.setUserIndex(e3, this.m_halfEdgeIndex, s3);
    }
  }
  updateVertexToHalfEdgeConnection_(e2, t3) {
    e2 !== cr && (this.updateVertexToHalfEdgeConnectionHelper_(e2, t3), this.updateVertexToHalfEdgeConnectionHelper_(this.getHalfEdgeTwin(e2), t3));
  }
  getChainIndex_(e2) {
    return this.m_chainData.elementToIndex(e2);
  }
  setChainHalfEdge_(e2, t3) {
    this.m_chainData.setField(e2, 1, t3);
  }
  setChainParentage_(e2, t3) {
    this.m_chainData.setField(e2, 2, t3);
  }
  setChainParent_(e2, t3) {
    this.m_chainData.setField(e2, 3, t3);
    const s3 = this.getChainFirstIsland(t3);
    this.setChainNextInParent_(e2, s3), this.setChainFirstIsland_(t3, e2);
  }
  setChainFirstIsland_(e2, t3) {
    this.m_chainData.setField(e2, 4, t3);
  }
  setChainNextInParent_(e2, t3) {
    this.m_chainData.setField(e2, 5, t3);
  }
  setChainPrev_(e2, t3) {
    this.m_chainData.setField(e2, 6, t3);
  }
  setChainNext_(e2, t3) {
    this.m_chainData.setField(e2, 7, t3);
  }
  setChainArea_(e2, t3) {
    const s3 = this.getChainIndex_(e2);
    this.m_chainAreas.write(s3, t3);
  }
  setChainPerimeter_(e2, t3) {
    const s3 = this.getChainIndex_(e2);
    this.m_chainPerimeters.write(s3, t3);
  }
  updateChainAreaAndPerimeter_(e2) {
    const t3 = this.m_shape.hasCurves(), s3 = new n2(0), n5 = new n2(0), r = this.getChainHalfEdge(e2), i2 = mi.getNAN(), o = mi.getNAN(), a2 = mi.getNAN();
    this.getHalfEdgeFromXY(r, i2), o.setCoordsPoint2D(i2);
    let h2 = r;
    do {
      this.getHalfEdgeToXY(h2, a2), t3 && this.isCurveEdge(h2) || n5.pe(mi.distance(o, a2));
      this.getHalfEdgeChain(this.getHalfEdgeTwin(h2)) !== e2 && s3.pe((a2.x - i2.x - (o.x - i2.x)) * (a2.y - i2.y + (o.y - i2.y)) * 0.5), o.setCoordsPoint2D(a2), h2 = this.getHalfEdgeNext(h2);
    } while (h2 !== r);
    if (t3) {
      const t4 = new fm();
      h2 = r;
      do {
        this.getHalfEdgeToXY(h2, a2);
        const r2 = this.isCurveEdge(h2);
        r2 && (this.querySegmentXY(h2, t4), n5.pe(t4.get().calculateLength2D()));
        if (this.getHalfEdgeChain(this.getHalfEdgeTwin(h2)) !== e2 && r2) {
          const e3 = t4.get().calculateArea2DHelper();
          s3.pe(e3);
        }
        h2 = this.getHalfEdgeNext(h2);
      } while (h2 !== r);
    }
    const m3 = this.getChainIndex_(e2);
    this.m_chainAreas.write(m3, s3.getResult()), this.m_chainPerimeters.write(m3, n5.getResult());
  }
  getChainTopmostEdge_(e2) {
    return n(0), 0;
  }
  planeSweepParentage_(e2, t3) {
    const s3 = new Ws3(this), n5 = new ct2();
    n5.setCapacity(Math.trunc(this.m_pointCount / 2)), n5.setComparator(s3);
    const r = [], i2 = this.createUserIndexForHalfEdges();
    let o = null;
    const a2 = mi.getNAN();
    for (let h2 = this.getFirstCluster(); h2 !== cr; h2 = this.getNextCluster(h2)) {
      this.progress_(t3);
      const m3 = this.getClusterHalfEdge(h2);
      if (m3 !== cr) {
        if (r.length = 0, !this.tryOptimizedInsertion_(n5, i2, r, h2, m3)) {
          this.queryXY(h2, a2), s3.setY(a2.y);
          let e3 = m3;
          do {
            const t4 = this.getHalfEdgeUserIndex(e3, i2);
            -1 !== t4 && (n5.deleteNode(t4), this.setHalfEdgeUserIndex(e3, i2, at.impossibleIndex2())), e3 = this.getHalfEdgeNext(this.getHalfEdgeTwin(e3));
          } while (m3 !== e3);
          e3 = m3;
          do {
            if (-1 === this.getHalfEdgeUserIndex(e3, i2)) {
              const t4 = n5.addElement(e3);
              r.push(t4);
            }
            e3 = this.getHalfEdgeNext(this.getHalfEdgeTwin(e3));
          } while (m3 !== e3);
        }
        for (let t4 = r.length - 1; t4 >= 0; t4--) {
          const s4 = r[t4], o2 = n5.getElement(s4), a3 = this.getHalfEdgeTwin(o2);
          this.setHalfEdgeUserIndex(a3, i2, s4), this.planeSweepParentagePropagateParentage_(n5, s4, e2);
        }
      } else if (this.getClusterChain(h2) === cr) {
        null === o && (o = new js3(this)), this.queryXY(h2, a2), o.setPointXY(a2);
        const e3 = n5.searchLowerBound(o);
        let t4 = this.m_universeChain;
        if (-1 !== e3) {
          let s4 = n5.getElement(e3);
          this.getHalfEdgeChain(s4) === this.getHalfEdgeChain(this.getHalfEdgeTwin(s4)) && (s4 = this.getLeftSkipPolylines_(n5, e3)), s4 !== cr && (t4 = this.getHalfEdgeChain(s4));
        }
        this.addClusterToExteriorChain_(t4, h2);
      }
    }
    this.deleteUserIndexForHalfEdges(i2);
  }
  planeSweepParentagePropagateParentage_(e2, t3, s3) {
    const n5 = e2.getElement(t3), r = this.getHalfEdgeChain(n5);
    if (this.getChainParent(r) !== cr) return;
    const i2 = this.getLeftSkipPolylines_(e2, t3), a2 = this.getHalfEdgeTwin(n5), h2 = this.getHalfEdgeChain(a2);
    let m3 = this.getChainParent(r), l2 = this.getChainParent(h2);
    if (i2 === cr) m3 === cr && (h2 === r ? (this.setChainParent_(h2, this.m_universeChain), l2 = this.m_universeChain, m3 = l2) : (l2 === cr && (this.setChainParent_(h2, this.m_universeChain), l2 = this.m_universeChain), this.setChainParent_(r, h2), m3 = h2));
    else {
      const e3 = this.getHalfEdgeChain(i2);
      if (l2 === cr) {
        if (this.getChainArea(e3) <= 0) {
          const t4 = this.getChainParent(e3);
          this.setChainParent_(h2, t4), l2 = t4;
        } else this.setChainParent_(h2, e3), l2 = e3;
        h2 === r && (m3 = l2);
      }
    }
    m3 === cr && (this.trySetChainParentFromTwin_(r, h2), m3 = this.getChainParent(r)), n(m3 !== cr), s3 === Zs3.enumInputModeBuildGraph ? this.propagateParentageBuildGraph_(e2, t3, n5, i2) : s3 === Zs3.enumInputModeSimplifyWinding ? this.propagateParentageWinding_(e2, t3, n5, i2, a2, r, h2) : s3 === Zs3.enumInputModeSimplifyAlternate && this.propagateParentageAlternate_(e2, t3, n5, i2, a2, r, h2);
  }
  propagateParentageBuildGraph_(e2, t3, s3, n5) {
    let r, i2 = t3;
    n5 === cr ? (i2 = e2.getNext(i2), r = this.getHalfEdgeChain(s3)) : r = this.getHalfEdgeChain(n5);
    let o = null, a2 = this.getChainParentage(r);
    for (this.m_bBuildGeometryParentageSets && (o = this.getChainBitSet(r)); -1 !== i2; i2 = e2.getNext(i2)) {
      const t4 = e2.getElement(i2), s4 = this.getHalfEdgeTwin(t4);
      r = this.getHalfEdgeChain(t4);
      const n6 = this.getHalfEdgeChain(s4);
      if (this.m_bBuildGeometryParentageSets) {
        let e3 = this.getChainBitSet(n6);
        e3 = new Ls3({ copy: e3 }), e3.assignOr(o), this.setChainBitSet_(n6, e3);
        let s5 = this.getChainBitSet(r);
        const i3 = this.getLeftEdgeBitSet_(t4), a3 = new Ls3({ copy: o });
        if (a3.assignSubtract(i3), a3.isZero()) break;
        s5 = new Ls3({ copy: s5 }), s5.assignOr(a3), this.setChainBitSet_(r, s5), o = s5;
      }
      const h2 = this.getChainParentage(n6), m3 = h2 | a2;
      m3 !== h2 && this.setChainParentage_(n6, m3);
      let l2 = this.getChainParentage(r);
      const g2 = a2 & ~this.getHalfEdgeUserIndex(t4, this.m_tmpHalfEdgeParentageIndexLeft);
      if (g2 && (l2 |= g2, this.setChainParentage_(r, l2)), 0 === g2) break;
      a2 = l2;
    }
  }
  propagateParentageWinding_(e2, t3, s3, n5, r, i2, a2) {
    if (i2 === a2) return;
    let h2 = this.getHalfEdgeUserIndex(s3, this.m_tmpHalfEdgeWindingNumberIndex);
    h2 += this.getHalfEdgeUserIndex(r, this.m_tmpHalfEdgeWindingNumberIndex);
    let m3 = 0;
    const l2 = [], g2 = [];
    g2.push(0);
    for (let u = e2.getFirst(); u !== t3; u = e2.getNext(u)) {
      const t4 = e2.getElement(u), s4 = this.getHalfEdgeTwin(t4), n6 = this.getHalfEdgeChain(t4), r2 = this.getHalfEdgeChain(s4);
      if (n6 !== r2) {
        let e3 = this.getHalfEdgeUserIndex(t4, this.m_tmpHalfEdgeWindingNumberIndex);
        e3 += this.getHalfEdgeUserIndex(s4, this.m_tmpHalfEdgeWindingNumberIndex), m3 += e3;
        let i3 = false;
        0 !== l2.length && l2.at(-1) === r2 && (g2.pop(), l2.pop(), i3 = true), n(this.getChainParent(r2) !== cr), i3 && this.getChainParent(r2) === n6 || (g2.push(m3), l2.push(n6));
      }
    }
    if (m3 += h2, 0 !== l2.length && l2.at(-1) === a2 && (g2.pop(), l2.pop()), 0 !== m3) {
      if (0 === g2.at(-1)) {
        const e3 = this.m_simplifiedGeometry, t4 = this.getGeometryID(e3);
        this.setChainParentage_(i2, t4);
      }
    } else if (0 !== g2.at(-1)) {
      const e3 = this.m_simplifiedGeometry, t4 = this.getGeometryID(e3);
      this.setChainParentage_(i2, t4);
    }
  }
  propagateParentageAlternate_(e2, t3, s3, n5, r, i2, o) {
    const a2 = this.m_simplifiedGeometry, h2 = this.getGeometryID(a2);
    if (n5 === cr) {
      this.setChainParentage_(o, this.m_universeGeomID);
      1 & this.getHalfEdgeUserIndex(s3, this.m_tmpHalfEdgeOddEvenNumberIndex) ? this.setChainParentage_(i2, h2) : this.setChainParentage_(i2, this.m_universeGeomID);
    } else {
      const e3 = this.getChainParentage(o);
      if (0 === e3) {
        const e4 = this.getHalfEdgeChain(n5), t4 = this.getChainParentage(e4);
        this.setChainParentage_(o, t4);
        1 & this.getHalfEdgeUserIndex(s3, this.m_tmpHalfEdgeOddEvenNumberIndex) ? this.setChainParentage_(i2, t4 === h2 ? this.m_universeGeomID : h2) : this.setChainParentage_(i2, t4);
      } else {
        1 & this.getHalfEdgeUserIndex(s3, this.m_tmpHalfEdgeOddEvenNumberIndex) ? this.setChainParentage_(i2, e3 === h2 ? this.m_universeGeomID : h2) : this.setChainParentage_(i2, e3);
      }
    }
  }
  tryOptimizedInsertion_(e2, t3, s3, n5, r) {
    let i2 = r, o = -1, a2 = cr, h2 = 0;
    do {
      if (2 === h2) return false;
      const e3 = this.getHalfEdgeUserIndex(i2, t3);
      if (-1 !== e3) {
        if (-1 !== o) return false;
        o = e3;
      } else {
        if (a2 !== cr) return false;
        a2 = i2;
      }
      h2++, i2 = this.getHalfEdgeNext(this.getHalfEdgeTwin(i2));
    } while (r !== i2);
    return a2 !== cr && -1 !== o && (this.setHalfEdgeUserIndex(e2.getElement(o), t3, at.impossibleIndex2()), e2.setElement(o, a2), s3.push(o), true);
  }
  trySetChainParentFromTwin_(e2, t3) {
    const s3 = this.getChainArea(e2);
    if (0 === s3) return false;
    const n5 = this.getChainArea(t3);
    if (s3 > 0 && n5 < 0 || s3 < 0 && n5 > 0) return this.setChainParent_(e2, t3), true;
    {
      const s4 = this.getChainParent(t3);
      if (s4 !== cr) return this.setChainParent_(e2, s4), true;
    }
    return false;
  }
  createHalfEdges_(e2, t3) {
    this.m_halfEdgeIndex = this.m_shape.createUserIndex();
    for (let n5 = 0, r = t3.size(); n5 < r; n5++) {
      const r2 = t3.read(n5), o = this.m_shape.getUserIndex(r2, this.m_clusterIndex), a2 = this.m_shape.getPathFromVertex(r2), h2 = this.m_shape.getGeometryFromPath(a2), m3 = this.m_shape.getGeometryType(h2);
      if (h(m3)) {
        const t4 = this.m_shape.getNextVertex(r2);
        if (t4 === cr) continue;
        const n6 = this.m_shape.getUserIndex(t4, this.m_clusterIndex);
        if (o === n6) continue;
        const i2 = this.newHalfEdgePair_(), a3 = this.getHalfEdgeTwin(i2), l2 = this.m_clusterVertices.newElement();
        this.m_clusterVertices.setField(l2, 0, r2), this.m_clusterVertices.setField(l2, 1, -1), this.setHalfEdgeVertexIterator_(i2, l2), this.m_shape.setUserIndex(r2, this.m_halfEdgeIndex, i2), this.setHalfEdgeOrigin_(i2, o);
        const g2 = this.getClusterHalfEdge(o);
        if (g2 === cr) this.setClusterHalfEdge_(o, i2), this.setHalfEdgePrev_(i2, a3), this.setHalfEdgeNext_(a3, i2);
        else {
          const e3 = this.getHalfEdgePrev(g2);
          this.setHalfEdgePrev_(g2, a3), this.setHalfEdgeNext_(a3, g2), this.setHalfEdgeNext_(e3, i2), this.setHalfEdgePrev_(i2, e3);
        }
        this.setHalfEdgeOrigin_(a3, n6);
        const u = this.getClusterHalfEdge(n6);
        if (u === cr) this.setClusterHalfEdge_(n6, a3), this.setHalfEdgeNext_(i2, a3), this.setHalfEdgePrev_(a3, i2);
        else {
          const e3 = this.getHalfEdgePrev(u);
          this.setHalfEdgePrev_(u, i2), this.setHalfEdgeNext_(i2, u), this.setHalfEdgeNext_(e3, a3), this.setHalfEdgePrev_(a3, e3);
        }
        const c = this.getGeometryID(h2);
        if (e2 === Zs3.enumInputModeBuildGraph) {
          const e3 = m3 === a.enumPolygon ? c : 0;
          if (this.setHalfEdgeUserIndex(a3, this.m_tmpHalfEdgeParentageIndex, 0), this.setHalfEdgeUserIndex(i2, this.m_tmpHalfEdgeParentageIndex, e3), this.setHalfEdgeUserIndex(a3, this.m_tmpHalfEdgeParentageIndexLeft, e3), this.setHalfEdgeUserIndex(i2, this.m_tmpHalfEdgeParentageIndexLeft, 0), this.m_bBuildGeometryParentageSets) {
            const e4 = new Ls3(), t5 = this.m_shape.getGeometryUserIndex(h2, this.m_geometryIDIndex);
            e4.setBit(t5), this.setEdgeBitSet_(i2, e4), this.setEdgeBitSet_(a3, null), this.setLeftEdgeBitSet_(a3, e4), this.setLeftEdgeBitSet_(i2, null);
          }
        } else if (e2 === Zs3.enumInputModeSimplifyWinding) {
          const e3 = this.m_shape.getXY(r2), s3 = this.m_shape.getXY(t4);
          let n7 = 0, o2 = 0;
          e3.compare(s3) < 0 ? n7 = 1 : o2 = -1, this.setHalfEdgeUserIndex(i2, this.m_tmpHalfEdgeWindingNumberIndex, n7), this.setHalfEdgeUserIndex(a3, this.m_tmpHalfEdgeWindingNumberIndex, o2);
        } else e2 === Zs3.enumInputModeSimplifyAlternate && (this.setHalfEdgeUserIndex(i2, this.m_tmpHalfEdgeOddEvenNumberIndex, 1), this.setHalfEdgeUserIndex(a3, this.m_tmpHalfEdgeOddEvenNumberIndex, 1));
        const _ = m3 === a.enumPolygon ? _tn.c_EdgeBitMask : 0;
        this.setHalfEdgeParentage_(i2, c | _), this.setHalfEdgeParentage_(a3, c | _);
      }
    }
    if (this.m_shape.hasCurves()) {
      this.m_segmentIndexHe = this.createUserIndexForHalfEdges();
      for (let e3 = 0, s3 = t3.size(); e3 < s3; e3++) {
        const s4 = t3.read(e3);
        if (this.m_shape.getSegment(s4)) {
          const e4 = this.m_shape.getUserIndex(s4, this.m_halfEdgeIndex);
          e4 !== cr && (this.setHalfEdgeUserIndex(e4, this.m_segmentIndexHe, this.m_shape.getVertexIndex(s4)), this.setHalfEdgeUserIndex(this.getHalfEdgeTwin(e4), this.m_segmentIndexHe, -2));
        }
      }
    }
  }
  mergeVertexListsOfEdges_(e2, t3) {
    {
      const s4 = this.getHalfEdgeVertexIterator(t3);
      if (s4 !== cr) {
        const n6 = this.getHalfEdgeVertexIterator(e2);
        this.m_clusterVertices.setField(s4, 1, n6), this.setHalfEdgeVertexIterator_(e2, s4), this.setHalfEdgeVertexIterator_(t3, cr);
      }
    }
    const s3 = this.getHalfEdgeTwin(e2), n5 = this.getHalfEdgeTwin(t3);
    {
      const e3 = this.getHalfEdgeVertexIterator(n5);
      if (e3 !== cr) {
        const t4 = this.getHalfEdgeVertexIterator(s3);
        this.m_clusterVertices.setField(e3, 1, t4), this.setHalfEdgeVertexIterator_(s3, e3), this.setHalfEdgeVertexIterator_(n5, cr);
      }
    }
    if (-1 !== this.m_segmentIndexHe) {
      let r = this.getHalfEdgeUserIndex(e2, this.m_segmentIndexHe);
      if (-1 !== r) {
        if (-2 === r) {
          const s4 = this.getHalfEdgeUserIndex(t3, this.m_segmentIndexHe);
          this.setHalfEdgeUserIndex(e2, this.m_segmentIndexHe, s4);
        }
        if (r = this.getHalfEdgeUserIndex(s3, this.m_segmentIndexHe), -2 === r) {
          const e3 = this.getHalfEdgeUserIndex(n5, this.m_segmentIndexHe);
          this.setHalfEdgeUserIndex(s3, this.m_segmentIndexHe, e3);
        }
      }
    }
  }
  sortHalfEdgesByAngle_(e2) {
    const t3 = [];
    for (let s3 = this.getFirstCluster(); s3 !== cr; s3 = this.getNextCluster(s3)) {
      t3.length = 0;
      const n5 = this.getClusterHalfEdge(s3);
      if (n5 !== cr) {
        let r = n5;
        do {
          t3.push(r), r = this.getHalfEdgeNext(this.getHalfEdgeTwin(r));
        } while (r !== n5);
        if (t3.length > 1) {
          let r2 = true;
          t3.length > 2 ? (t3.sort((e3, t4) => this.compareEdgeAngles_(e3, t4)), t3.push(t3[0])) : this.compareEdgeAnglesForPair_(t3[0], t3[1]) > 0 ? t3[1] = Pt(t3[0], t3[0] = t3[1]) : r2 = false;
          let i2 = t3[0], o = i2, a2 = this.getHalfEdgeTo(o), h2 = this.getHalfEdgeTwin(o), m3 = cr;
          for (let s4 = 1, n6 = t3.length; s4 < n6; s4++) {
            const n7 = t3[s4], r3 = this.getHalfEdgeTwin(n7), l2 = this.getHalfEdgeOrigin(r3);
            if (l2 !== a2 || n7 === o) this.updateVertexToHalfEdgeConnection_(m3, false), m3 = cr, o = n7, a2 = l2, h2 = r3;
            else {
              if (e2 === Zs3.enumInputModeBuildGraph) {
                const e3 = this.getHalfEdgeParentageMask_(o) | this.getHalfEdgeParentageMask_(n7);
                if (this.setHalfEdgeParentage_(o, e3), this.setHalfEdgeParentage_(h2, e3), this.setHalfEdgeUserIndex(o, this.m_tmpHalfEdgeParentageIndex, this.getHalfEdgeUserIndex(o, this.m_tmpHalfEdgeParentageIndex) | this.getHalfEdgeUserIndex(n7, this.m_tmpHalfEdgeParentageIndex)), this.setHalfEdgeUserIndex(h2, this.m_tmpHalfEdgeParentageIndex, this.getHalfEdgeUserIndex(h2, this.m_tmpHalfEdgeParentageIndex) | this.getHalfEdgeUserIndex(r3, this.m_tmpHalfEdgeParentageIndex)), this.setHalfEdgeUserIndex(o, this.m_tmpHalfEdgeParentageIndexLeft, this.getHalfEdgeUserIndex(o, this.m_tmpHalfEdgeParentageIndexLeft) | this.getHalfEdgeUserIndex(n7, this.m_tmpHalfEdgeParentageIndexLeft)), this.setHalfEdgeUserIndex(h2, this.m_tmpHalfEdgeParentageIndexLeft, this.getHalfEdgeUserIndex(h2, this.m_tmpHalfEdgeParentageIndexLeft) | this.getHalfEdgeUserIndex(r3, this.m_tmpHalfEdgeParentageIndexLeft)), this.m_bBuildGeometryParentageSets) {
                  let e4, t4, s5;
                  e4 = this.getEdgeBitSet_(o), t4 = this.getEdgeBitSet_(n7), s5 = new Ls3({ copy: e4 }), s5.assignOr(t4), this.setEdgeBitSet_(o, s5), e4 = this.getEdgeBitSet_(h2), t4 = this.getEdgeBitSet_(r3), s5 = new Ls3({ copy: e4 }), s5.assignOr(t4), this.setEdgeBitSet_(h2, s5), e4 = this.getLeftEdgeBitSet_(o), t4 = this.getLeftEdgeBitSet_(n7), s5 = new Ls3({ copy: e4 }), s5.assignOr(t4), this.setLeftEdgeBitSet_(o, s5), e4 = this.getLeftEdgeBitSet_(h2), t4 = this.getLeftEdgeBitSet_(r3), s5 = new Ls3({ copy: e4 }), s5.assignOr(t4), this.setLeftEdgeBitSet_(h2, s5);
                }
              } else if (-1 !== this.m_tmpHalfEdgeWindingNumberIndex) {
                const e3 = this.getHalfEdgeUserIndex(o, this.m_tmpHalfEdgeWindingNumberIndex) + this.getHalfEdgeUserIndex(n7, this.m_tmpHalfEdgeWindingNumberIndex), t4 = this.getHalfEdgeUserIndex(h2, this.m_tmpHalfEdgeWindingNumberIndex) + this.getHalfEdgeUserIndex(r3, this.m_tmpHalfEdgeWindingNumberIndex);
                this.setHalfEdgeUserIndex(o, this.m_tmpHalfEdgeWindingNumberIndex, e3), this.setHalfEdgeUserIndex(h2, this.m_tmpHalfEdgeWindingNumberIndex, t4);
              } else if (-1 !== this.m_tmpHalfEdgeOddEvenNumberIndex) {
                const e3 = this.getHalfEdgeUserIndex(o, this.m_tmpHalfEdgeOddEvenNumberIndex) + this.getHalfEdgeUserIndex(n7, this.m_tmpHalfEdgeOddEvenNumberIndex), t4 = this.getHalfEdgeUserIndex(h2, this.m_tmpHalfEdgeOddEvenNumberIndex) + this.getHalfEdgeUserIndex(r3, this.m_tmpHalfEdgeOddEvenNumberIndex);
                this.setHalfEdgeUserIndex(o, this.m_tmpHalfEdgeOddEvenNumberIndex, e3), this.setHalfEdgeUserIndex(h2, this.m_tmpHalfEdgeOddEvenNumberIndex, t4);
              }
              this.mergeVertexListsOfEdges_(o, n7), this.deleteEdgeImpl_(n7), m3 = o, t3[s4] = cr, n7 === i2 && (t3[0] = cr, i2 = cr);
            }
          }
          if (this.updateVertexToHalfEdgeConnection_(m3, false), m3 = cr, !r2) {
            i2 = cr;
            for (let e3 = 0, s4 = t3.length; e3 < s4; e3++) {
              const s5 = t3[e3];
              if (s5 !== cr) {
                i2 = s5;
                break;
              }
            }
            n5 !== i2 && this.setClusterHalfEdge_(s3, i2);
            continue;
          }
          i2 = cr;
          for (let e3 = 0, s4 = t3.length; e3 < s4; e3++) {
            const s5 = t3[e3];
            if (s5 === cr) continue;
            if (i2 === cr) {
              i2 = s5, o = i2, a2 = this.getHalfEdgeTo(o), h2 = this.getHalfEdgeTwin(o);
              continue;
            }
            if (s5 === o) continue;
            const n6 = this.getHalfEdgeTwin(s5), r3 = this.getHalfEdgeOrigin(n6);
            this.setHalfEdgeNext_(h2, s5), this.setHalfEdgePrev_(s5, h2), o = s5, a2 = r3, h2 = n6;
          }
          this.setClusterHalfEdge_(s3, i2);
        }
      }
    }
  }
  sortHalfEdgesByAngle3D_(e2) {
    n(0);
  }
  buildChains_(e2) {
    this.m_universeChain = this.newChain_(), this.setChainHalfEdge_(this.m_universeChain, cr);
    let t3 = this.m_universeChain;
    const s3 = this.createUserIndexForHalfEdges();
    for (let n5 = this.getFirstCluster(); n5 !== cr; n5 = this.getNextCluster(n5)) {
      const e3 = this.getClusterHalfEdge(n5);
      if (e3 !== cr) {
        let n6 = e3;
        do {
          if (1 !== this.getHalfEdgeUserIndex(n6, s3)) {
            const e4 = this.newChain_();
            this.setChainHalfEdge_(e4, n6), this.setChainPrev_(e4, t3), this.setChainNext_(t3, e4);
            let r = null;
            this.m_bBuildGeometryParentageSets && (r = new Ls3()), t3 = e4;
            let i2 = 0, o = n6;
            do {
              -1 !== this.m_tmpHalfEdgeParentageIndex && (i2 |= this.getHalfEdgeUserIndex(o, this.m_tmpHalfEdgeParentageIndex)), this.m_bBuildGeometryParentageSets && r.assignOr(this.getEdgeBitSet_(o)), this.setHalfEdgeChain_(o, e4), this.setHalfEdgeUserIndex(o, s3, 1), o = this.getHalfEdgeNext(o);
            } while (o !== n6);
            this.m_bBuildGeometryParentageSets && this.setChainBitSet_(e4, r), this.setChainParentage_(e4, i2);
          }
          n6 = this.getHalfEdgeNext(this.getHalfEdgeTwin(n6));
        } while (n6 !== e3);
      }
    }
    this.m_chainAreas = new nt(this.m_chainData.size(), Number.NaN), this.m_chainPerimeters = new nt(this.m_chainData.size(), Number.NaN), this.setChainArea_(this.m_universeChain, Number.POSITIVE_INFINITY), this.setChainPerimeter_(this.m_universeChain, Number.POSITIVE_INFINITY), this.deleteUserIndexForHalfEdges(s3);
  }
  simplify_(e2) {
    n(0);
  }
  simplifyAlternate_() {
    n(0);
  }
  simplifyWinding_() {
    n(0);
  }
  setEditShapeImpl_(e2, t3, s3, n5, r) {
    this.removeShape(), this.m_bBuildChains = r, this.m_shape = e2, this.m_geometryIDIndex = this.m_shape.createGeometryUserIndex();
    let i2 = this.m_shape.getTotalPointCount();
    if (s3) {
      i2 = 0;
      for (let e3 = 0, t4 = s3.length; e3 < t4; e3++) i2 += this.m_shape.getPointCount(s3[e3]);
    }
    const o = new st2(0);
    let a2 = 0, h2 = 0;
    {
      let e3 = null != s3 ? s3[0] : this.m_shape.getFirstGeometry(), t4 = 1;
      for (; e3 !== cr; ) {
        this.m_shape.setGeometryUserIndex(e3, this.m_geometryIDIndex, h2++);
        for (let t5 = this.m_shape.getFirstPath(e3); t5 !== cr; t5 = this.m_shape.getNextPath(t5)) {
          let e4 = this.m_shape.getFirstVertex(t5);
          for (let s4 = 0, n6 = this.m_shape.getPathSize(t5); s4 < n6; s4++) o.add(e4), e4 = this.m_shape.getNextVertex(e4);
        }
        l(this.m_shape.getGeometryType(e3)) || (a2 += this.m_shape.getPathCount(e3)), null != s3 ? (e3 = t4 < s3.length ? s3[t4] : cr, t4++) : e3 = this.m_shape.getNextGeometry(e3);
      }
    }
    this.m_universeGeomID = 1 << Math.min(h2, 31), this.m_pointCount = o.size(), this.m_shape.sortVerticesSimpleByY(o, 0, this.m_pointCount), this.m_clusterVertices.setCapacity(this.m_pointCount), this.progress_(n5, true), this.m_clusterData.setCapacity(this.m_pointCount + 10), this.m_halfEdgeData.setCapacity(2 * this.m_pointCount + 32), this.m_chainData.setCapacity(Math.max(32, a2)), this.m_clusterIndex = this.m_shape.createUserIndex();
    const m3 = mi.getNAN();
    let l2 = 0;
    const g2 = mi.getNAN();
    for (let u = 0; u <= this.m_pointCount; u++) {
      if (u < this.m_pointCount) {
        const e3 = o.read(u);
        this.m_shape.queryXY(e3, g2);
      } else g2.setNAN();
      if (!m3.isEqualPoint2D(g2)) {
        if (l2 < u) {
          const e3 = this.newCluster_();
          let t4 = cr, s4 = -1;
          for (let n6 = l2; n6 < u; n6++) {
            s4 = o.read(n6), this.m_shape.setUserIndex(s4, this.m_clusterIndex, e3);
            const r2 = this.m_clusterVertices.newElement();
            this.m_clusterVertices.setField(r2, 0, s4), this.m_clusterVertices.setField(r2, 1, t4), t4 = r2;
            const i3 = this.m_shape.getPathFromVertex(s4), a3 = this.m_shape.getGeometryFromPath(i3), h3 = this.getGeometryID(a3);
            this.setClusterParentage_(e3, this.getClusterParentage(e3) | h3);
          }
          this.setClusterVertexIterator_(e3, t4), this.setClusterVertexIndex_(e3, this.m_shape.getVertexIndex(s4)), this.m_lastCluster !== cr && this.setNextCluster_(this.m_lastCluster, e3), this.setPrevCluster_(e3, this.m_lastCluster), this.m_lastCluster = e3, this.m_firstCluster === cr && (this.m_firstCluster = e3);
        }
        l2 = u, m3.setCoordsPoint2D(g2);
      }
    }
    if (this.m_shape.hasSegmentParentage()) {
      -1 === this.m_clusterBreakNodeIndex && (this.m_clusterBreakNodeIndex = this.createUserIndexForClusters());
      for (let e3 = 0; e3 < this.m_pointCount; e3++) {
        const t4 = o.read(e3);
        if (this.m_shape.getSegmentParentageBreakVertex(t4)) {
          const e4 = this.getClusterFromVertex(t4);
          this.setBreakNode(e4, true);
        }
      }
    }
    this.progress_(n5, true);
    {
      let e3 = null != s3 ? s3[0] : this.m_shape.getFirstGeometry(), t4 = 1;
      for (; e3 !== cr; ) {
        for (let t5 = this.m_shape.getFirstPath(e3); t5 !== cr; t5 = this.m_shape.getNextPath(t5)) {
          if (this.m_shape.isStrongPathStart(t5)) {
            const e4 = this.m_shape.getFirstVertex(t5), s4 = this.getClusterFromVertex(e4);
            this.setStrongPathNode(s4, true);
          }
          if (this.m_shape.isStrongPathEnd(t5)) {
            const e4 = this.m_shape.isClosedPath(t5) ? this.m_shape.getFirstVertex(t5) : this.m_shape.getLastVertex(t5), s4 = this.getClusterFromVertex(e4);
            this.setStrongPathNode(s4, true);
          }
        }
        null != s3 ? (e3 = t4 < s3.length ? s3[t4] : cr, t4++) : e3 = this.m_shape.getNextGeometry(e3);
      }
    }
    if (t3 === Zs3.enumInputModeBuildGraph && (this.m_tmpHalfEdgeParentageIndex = this.createUserIndexForHalfEdges(), this.m_tmpHalfEdgeParentageIndexLeft = this.createUserIndexForHalfEdges()), t3 === Zs3.enumInputModeSimplifyWinding && (this.m_tmpHalfEdgeWindingNumberIndex = this.createUserIndexForHalfEdges()), t3 === Zs3.enumInputModeSimplifyAlternate && (this.m_tmpHalfEdgeOddEvenNumberIndex = this.createUserIndexForHalfEdges()), this.createHalfEdges_(t3, o), this.dbgNavigate_(), this.sortHalfEdgesByAngle_(t3), !Number.isNaN(this.m_checkDirtyPlanesweepTolerance) && !this.checkStructureAfterDirtySweep_()) return this.m_bDirtyCheckFailed = true, void this.cleanSetEditShapeImpl_();
    this.buildChains_(t3), -1 !== this.m_tmpHalfEdgeParentageIndex && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndex), this.m_tmpHalfEdgeParentageIndex = -1), this.m_bBuildChains && this.planeSweepParentage_(t3, n5), -1 !== this.m_tmpHalfEdgeParentageIndexLeft && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndexLeft), this.m_tmpHalfEdgeParentageIndexLeft = -1), this.dbgChkChainParents_(), this.dbgDumpChains_(), this.mergeSegmentParentage_(), this.dbgNavigate_(), this.dbgDumpChains_(), this.cleanSetEditShapeImpl_();
  }
  setEditShapeImpl3D_(e2, t3, s3, n5, r) {
    n(0);
  }
  cleanSetEditShapeImpl_() {
    -1 !== this.m_tmpHalfEdgeParentageIndex && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndex), this.m_tmpHalfEdgeParentageIndex = -1), -1 !== this.m_tmpHalfEdgeParentageIndexLeft && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndexLeft), this.m_tmpHalfEdgeParentageIndexLeft = -1), -1 !== this.m_tmpHalfEdgeWindingNumberIndex && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeWindingNumberIndex), this.m_tmpHalfEdgeWindingNumberIndex = -1), -1 !== this.m_tmpHalfEdgeOddEvenNumberIndex && (this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeOddEvenNumberIndex), this.m_tmpHalfEdgeOddEvenNumberIndex = -1);
  }
  cleanSetEditShapeImpl3D_() {
    n(0);
  }
  dbgNavigate_() {
  }
  dbgChkChainParents_() {
  }
  deleteEdgeImpl_(e2) {
    const t3 = this.getHalfEdgeNext(e2), s3 = this.getHalfEdgePrev(e2), n5 = this.getHalfEdgeTwin(e2), r = this.getHalfEdgeNext(n5), i2 = this.getHalfEdgePrev(n5);
    t3 !== n5 && (this.setHalfEdgeNext_(i2, t3), this.setHalfEdgePrev_(t3, i2)), s3 !== n5 && (this.setHalfEdgeNext_(s3, r), this.setHalfEdgePrev_(r, s3));
    const o = this.getHalfEdgeOrigin(e2);
    this.getClusterHalfEdge(o) === e2 && (r !== e2 ? this.setClusterHalfEdge_(o, r) : this.setClusterHalfEdge_(o, cr));
    const a2 = this.getHalfEdgeOrigin(n5);
    this.getClusterHalfEdge(a2) === n5 && (t3 !== n5 ? this.setClusterHalfEdge_(a2, t3) : this.setClusterHalfEdge_(a2, cr)), this.m_halfEdgeData.deleteElement(e2), this.m_halfEdgeData.deleteElement(n5);
  }
  getLeftSkipPolylines_(e2, t3) {
    let s3 = t3;
    for (; ; ) {
      if (s3 = e2.getPrev(s3), -1 === s3) return cr;
      {
        const t4 = e2.getElement(s3);
        if (this.getHalfEdgeChain(t4) !== this.getHalfEdgeChain(this.getHalfEdgeTwin(t4))) return t4;
      }
    }
  }
  checkStructureAfterDirtySweep_() {
    const e2 = H(this.m_checkDirtyPlanesweepTolerance), t3 = new mi(), s3 = new mi(), n5 = new mi(), r = new mi(), i2 = new mi();
    for (let o = this.getFirstCluster(); o !== cr; o = this.getNextCluster(o)) {
      const a2 = this.getClusterHalfEdge(o);
      if (a2 !== cr) {
        let o2 = a2;
        this.getHalfEdgeFromXY(o2, t3), this.getHalfEdgeToXY(o2, s3), n5.setSub(s3, t3);
        let h2 = n5.sqrLength();
        do {
          const a3 = o2;
          if (o2 = this.getHalfEdgeNext(this.getHalfEdgeTwin(o2)), o2 !== a3) {
            this.getHalfEdgeToXY(o2, r), i2.setSub(r, t3);
            const a4 = i2.sqrLength(), m3 = i2.crossProduct(n5), l2 = m3 * m3 / (a4 * h2);
            if (Math.min(a4, h2) * l2 <= e2) {
              if (i2.dotProduct(n5) >= 0) return false;
            }
            n5.assign(i2), h2 = a4, s3.assign(r);
          }
        } while (o2 !== a2);
      }
    }
    return true;
  }
  extractPolygonPathFromChain_(e2, t3, s3, n5, r) {
    const i2 = this.m_shape.hasSegmentParentage(), o = this.getChainHalfEdge(s3);
    let a2 = o, h2 = cr;
    const m3 = new ee();
    do {
      const o2 = this.getHalfEdgeTwin(a2);
      if (this.getHalfEdgeChain(o2) !== s3) {
        let s4 = cr;
        const o3 = this.getHalfEdgeOrigin(a2);
        if (n5 === cr) {
          const e3 = this.getClusterVertexIterator(o3);
          s4 = this.getVertexFromVertexIterator(e3);
        } else for (let e3 = this.getClusterVertexIterator(o3); e3 !== cr; e3 = this.incrementVertexIterator(e3)) {
          const t4 = this.getVertexFromVertexIterator(e3);
          s4 === cr && (s4 = t4);
          const r2 = this.m_shape.getPathFromVertex(t4);
          if (this.m_shape.getGeometryFromPath(r2) === n5) {
            s4 = t4;
            break;
          }
        }
        let l2;
        if (h2 === cr && (h2 = e2.insertPath(t3, cr), e2.setClosedPath(h2, true)), this.m_shape === e2 ? l2 = e2.addVertex(h2, s4) : (this.m_shape.queryPoint(s4, m3), l2 = e2.addPoint(h2, m3)), this.isHalfEdgeCurve(a2) && (this.querySegmentXY(a2, r), e2.setSegmentToIndex(e2.getVertexIndex(l2), r.get().clone())), i2) {
          const t4 = this.getSegmentParentage(a2);
          e2.setSegmentParentageAndBreak(l2, t4, this.isBreakNode(o3));
        }
      }
      a2 = this.getHalfEdgeNext(a2);
    } while (a2 !== o);
  }
  mergeSegmentParentage_() {
    if (!this.m_shape.hasSegmentParentage()) return;
    n(-1 !== this.m_clusterBreakNodeIndex), n(-1 === this.m_segmentParentageIndex);
    for (let n5 = this.getFirstCluster(); n5 !== cr; n5 = this.getNextCluster(n5)) {
      let e3 = 0;
      const t4 = this.getClusterHalfEdge(n5);
      if (t4 !== cr) {
        let s4 = t4;
        do {
          e3++, s4 = this.getHalfEdgeNext(this.getHalfEdgeTwin(s4));
        } while (s4 !== t4 && e3 < 3);
      }
      2 !== e3 && this.setBreakNode(n5, true);
    }
    let e2 = [], t3 = [];
    this.m_segmentParentageIndex = this.createUserIndexForHalfEdges();
    const s3 = this.createUserIndexForHalfEdges();
    for (let n5 = this.getFirstCluster(); n5 !== cr; n5 = this.getNextCluster(n5)) {
      const r = this.getClusterHalfEdge(n5);
      if (r !== cr) {
        let n6 = false, i2 = r;
        do {
          let r2 = i2;
          for (; -1 === this.getHalfEdgeUserIndex(r2, s3); ) {
            const i3 = this.getHalfEdgeNext(r2), o = this.getHalfEdgeTwin(r2);
            $s3(this, r2, t3);
            const a2 = t3.at(-1).parentage;
            if (!n6) {
              const t4 = this.getHalfEdgeOrigin(r2);
              if (!this.isBreakNode(t4)) {
                const t5 = this.getHalfEdgePrev(r2);
                r2 !== t5 && ($s3(this, t5, e2), n6 = true);
              }
            }
            if (n6 && !Js3(t3, e2)) {
              const e3 = this.getHalfEdgeOrigin(r2);
              this.setBreakNode(e3, true);
            }
            e2 = Pt(t3, t3 = e2), n6 = true;
            const h2 = this.getHalfEdgeOrigin(i3);
            this.isBreakNode(h2) && (n6 = false), this.setHalfEdgeUserIndex(r2, this.m_segmentParentageIndex, a2), this.setHalfEdgeUserIndex(o, this.m_segmentParentageIndex, a2), this.setHalfEdgeUserIndex(r2, s3, 1), this.setHalfEdgeUserIndex(o, s3, 1), r2 = i3;
          }
          i2 = this.getHalfEdgeNext(this.getHalfEdgeTwin(i2));
        } while (i2 !== r);
      }
    }
    this.deleteUserIndexForHalfEdges(s3);
  }
  registerNewBitSet(e2) {
    if (null === this.m_uniqueBitSets && (this.m_uniqueBitSets = en2(), this.m_uniqueBitSets.add(this.getEmptySet())), null === e2) return this.getEmptySet();
    return this.m_uniqueBitSets.has(e2) ? this.m_uniqueBitSets.get(e2) : (this.m_uniqueBitSets.add(e2), e2);
  }
  getLeftEdgeBitSet_(e2) {
    const t3 = this.getHalfEdgeUserIndex(e2, this.m_edgeBitSetIndexLeft);
    return n(t3 >= 0), n(this.m_edgeBitSets.at(t3)), this.m_edgeBitSets.at(t3);
  }
  getEdgeBitSet_(e2) {
    const t3 = this.getHalfEdgeUserIndex(e2, this.m_edgeBitSetIndex);
    return n(t3 >= 0), this.m_edgeBitSets.at(t3);
  }
  setEdgeBitSet_(e2, t3) {
    n(this.m_bBuildGeometryParentageSets), t3 = this.registerNewBitSet(t3), -1 === this.m_edgeBitSetIndex && (this.m_edgeBitSetIndex = this.createUserIndexForHalfEdges());
    const s3 = this.getHalfEdgeUserIndex(e2, this.m_edgeBitSetIndex);
    -1 !== s3 ? this.m_edgeBitSets[s3] = t3 : (this.setHalfEdgeUserIndex(e2, this.m_edgeBitSetIndex, this.m_edgeBitSets.length), this.m_edgeBitSets.push(t3));
  }
  setLeftEdgeBitSet_(e2, t3) {
    n(this.m_bBuildGeometryParentageSets), t3 = this.registerNewBitSet(t3), -1 === this.m_edgeBitSetIndexLeft && (this.m_edgeBitSetIndexLeft = this.createUserIndexForHalfEdges());
    const s3 = this.getHalfEdgeUserIndex(e2, this.m_edgeBitSetIndexLeft);
    -1 !== s3 ? this.m_edgeBitSets[s3] = t3 : (this.setHalfEdgeUserIndex(e2, this.m_edgeBitSetIndexLeft, this.m_edgeBitSets.length), this.m_edgeBitSets.push(t3));
  }
  setChainBitSet_(e2, t3) {
    n(this.m_bBuildGeometryParentageSets), t3 = this.registerNewBitSet(t3), -1 === this.m_chainBitSetIndex && (this.m_chainBitSetIndex = this.createUserIndexForChains());
    const s3 = this.getChainUserIndex(e2, this.m_chainBitSetIndex);
    -1 !== s3 ? this.m_chainBitSets[s3] = t3 : (this.setChainUserIndex(e2, this.m_chainBitSetIndex, this.m_chainBitSets.length), this.m_chainBitSets.push(t3));
  }
  getEmptySet() {
    return this.m_emptyBitSet || (this.m_emptyBitSet = new Ls3()), this.m_emptyBitSet;
  }
  deleteEdgeBitSets_() {
    -1 !== this.m_edgeBitSetIndex && (this.deleteUserIndexForHalfEdges(this.m_edgeBitSetIndex), this.m_edgeBitSetIndex = -1), -1 !== this.m_edgeBitSetIndexLeft && (this.deleteUserIndexForHalfEdges(this.m_edgeBitSetIndexLeft), this.m_edgeBitSetIndexLeft = -1), this.m_edgeBitSets.length = 0, this.m_uniqueBitSets = null;
  }
  deleteChainBitSets_() {
    -1 !== this.m_chainBitSetIndex && (this.deleteUserIndexForChains(this.m_chainBitSetIndex), this.m_chainBitSetIndex = -1, this.m_chainBitSets.length = 0);
  }
  dbgPrintEdge_(e2) {
  }
  dbgVerifyEdgeSegment(e2) {
  }
};
tn2.c_EdgeParentageMask = ~(1 << 31), tn2.c_EdgeBitMask = 1 << 31;
var sn2 = class _sn {
  freeNode_(e2) {
    this.m_listNodes.deleteElement(e2);
  }
  newNode_() {
    return this.m_listNodes.newElement();
  }
  freeList_(e2) {
    this.m_lists.deleteElement(e2);
  }
  newList_() {
    return this.m_lists.newElement();
  }
  Init_(e2) {
    n(0);
  }
  constructor(e2) {
    this.m_listNodes = new at(2), this.m_listOfLists = _sn.st_nullNode(), this.m_bAllowNavigationBetweenLists = true, void 0 === e2 && (e2 = true), this.m_bAllowNavigationBetweenLists = e2, this.m_lists = new at(this.m_bAllowNavigationBetweenLists ? 4 : 2);
  }
  createList() {
    const e2 = this.newList_();
    return this.m_bAllowNavigationBetweenLists && (this.m_lists.setField(e2, 3, this.m_listOfLists), this.m_listOfLists !== _sn.st_nullNode() && this.m_lists.setField(this.m_listOfLists, 2, e2), this.m_listOfLists = e2), e2;
  }
  deleteList(e2) {
    let t3 = this.getFirst(e2);
    for (; t3 !== _sn.st_nullNode(); ) {
      const e3 = t3;
      t3 = this.getNext(t3), this.freeNode_(e3);
    }
    if (this.m_bAllowNavigationBetweenLists) {
      const t4 = this.m_lists.getField(e2, 2), s3 = this.m_lists.getField(e2, 3);
      t4 !== _sn.st_nullNode() ? this.m_lists.setField(t4, 3, s3) : this.m_listOfLists = s3, s3 !== _sn.st_nullNode() && this.m_lists.setField(s3, 2, t4);
    }
    this.freeList_(e2);
  }
  reserveLists(e2) {
    this.m_lists.setCapacity(e2);
  }
  addElement(e2, t3) {
    this.m_lists.getField(e2, 0);
    const s3 = this.m_lists.getField(e2, 1), n5 = this.newNode_();
    return s3 !== _sn.st_nullNode() ? (this.m_listNodes.setField(s3, 1, n5), this.m_lists.setField(e2, 1, n5)) : (this.m_lists.setField(e2, 0, n5), this.m_lists.setField(e2, 1, n5)), this.m_listNodes.setField(n5, 0, t3), n5;
  }
  reserveNodes(e2) {
    this.m_listNodes.setCapacity(e2);
  }
  deleteElementDirect(e2, t3, s3) {
    t3 !== _sn.st_nullNode() ? (this.m_listNodes.setField(t3, 1, this.m_listNodes.getField(s3, 1)), this.m_lists.getField(e2, 1) === s3 && this.m_lists.setField(e2, 1, t3)) : (this.m_lists.setField(e2, 0, this.m_listNodes.getField(s3, 1)), this.m_lists.getField(e2, 1) === s3 && this.m_lists.setField(e2, 1, _sn.st_nullNode())), this.freeNode_(s3);
  }
  deleteElementSearch(e2, t3) {
    let s3 = -1, n5 = this.getFirst(e2);
    for (; n5 !== t3; ) s3 = n5, n5 = this.getNext(n5);
    this.deleteElementDirect(e2, s3, t3);
  }
  concatenateLists(e2, t3) {
    const s3 = this.m_lists.getField(e2, 1), n5 = this.m_lists.getField(t3, 0);
    if (n5 !== _sn.st_nullNode() && (s3 !== _sn.st_nullNode() ? (this.m_listNodes.setField(s3, 1, n5), this.m_lists.setField(e2, 1, this.m_lists.getField(t3, 1))) : (this.m_lists.setField(e2, 0, n5), this.m_lists.setField(e2, 1, this.m_lists.getField(t3, 1)))), this.m_bAllowNavigationBetweenLists) {
      const e3 = this.m_lists.getField(t3, 2), s4 = this.m_lists.getField(t3, 3);
      e3 !== _sn.st_nullNode() ? this.m_lists.setField(e3, 3, s4) : this.m_listOfLists = s4, s4 !== _sn.st_nullNode() && this.m_lists.setField(s4, 2, e3);
    }
    return this.freeList_(t3), e2;
  }
  getElement(e2) {
    return this.m_listNodes.getField(e2, 0);
  }
  getData(e2) {
    return this.getElement(e2);
  }
  setElement(e2, t3) {
    n(0);
  }
  getNext(e2) {
    return this.m_listNodes.getField(e2, 1);
  }
  getFirst(e2) {
    return this.m_lists.getField(e2, 0);
  }
  getFirstElement(e2) {
    const t3 = this.getFirst(e2);
    return this.getElement(t3);
  }
  static st_nullNode() {
    return -1;
  }
  clear() {
    this.m_listNodes.deleteAll(true), this.m_lists.deleteAll(true), this.m_listOfLists = _sn.st_nullNode();
  }
  isEmpty(e2) {
    return n(0), false;
  }
  getNodeCount() {
    return this.m_listNodes.size();
  }
  getListCount() {
    return this.m_lists.size();
  }
  getFirstList() {
    return this.m_listOfLists;
  }
  getNextList(e2) {
    return this.m_lists.getField(e2, 3);
  }
};
function nn2(e2 = -1) {
  return { m_value: e2, m_line: new pm(), m_segment: null, m_segmentInfo: new fr(-1), m_env: new x2(0, 0), m_dxdy: 55555555, m_bHorizontal: false, m_bCurve: false };
}
var rn2 = 67;
var on2 = class extends dt {
  constructor(e2, t3, s3) {
    super(true), this.m_bIntersectionDetected = false, this.m_nonSimpleResult = new e(), this.m_tempSimpleEdge1 = nn2(), this.m_tempSimpleEdge2 = nn2(), this.m_prev1 = cr, this.m_prev2 = cr, this.m_vertex1 = cr, this.m_vertex2 = cr, this.m_currentNode = -1, this.m_prevX1 = Number.NaN, this.m_prevX2 = Number.NaN, this.m_prevY = Number.NaN, this.m_prevX = 0, this.m_sweepY = Number.NaN, this.m_sweepX = 0, this.m_ptSweep = new mi(), this.m_simpleEdgesCache = [], this.m_simpleEdgesRecycle = [], this.m_cOutstandingConstructedEdges = 0, this.m_shape = e2, this.m_bShapeHasSegments = this.m_shape.hasCurves(), this.m_tolerance = t3, this.m_tolerance10 = 10 * t3, this.m_bIsSimple = s3;
    const n5 = Math.trunc(Math.min(3 * e2.getTotalPointCount() / 2, rn2)), r = Math.min(7, n5);
    this.m_simpleEdgesCache.length = r;
  }
  tryGetCachedEdge_(e2) {
    const t3 = this.m_simpleEdgesCache[(e2 & vs()) % this.m_simpleEdgesCache.length];
    return t3 && t3.m_value === e2 ? t3 : null;
  }
  tryDeleteCachedEdge_(e2) {
    const t3 = (e2 & vs()) % this.m_simpleEdgesCache.length, s3 = this.m_simpleEdgesCache[t3];
    s3 && s3.m_value === e2 && (this.m_simpleEdgesRecycle.push(s3), this.m_simpleEdgesCache[t3] = null);
  }
  tryCreateCachedEdge_(e2) {
    const t3 = (e2 & vs()) % this.m_simpleEdgesCache.length;
    let s3 = this.m_simpleEdgesCache[t3];
    return s3 ? null : (0 === this.m_simpleEdgesRecycle.length ? (s3 = nn2(), this.m_cOutstandingConstructedEdges++) : s3 = this.m_simpleEdgesRecycle.pop(), s3.m_value = e2, this.m_simpleEdgesCache[t3] = s3, s3);
  }
  initSimpleEdge_(e2, t3) {
    this.m_bShapeHasSegments && this.initSimpleEdgeHelper_(e2, t3) || e2.m_bCurve || (this.m_shape.queryLineConnector(t3, e2.m_line, true), e2.m_segment = e2.m_line, e2.m_env.setCoordsNoNAN(e2.m_line.getStartX(), e2.m_line.getEndX()), e2.m_env.vmax += this.m_tolerance, e2.m_line.orientBottomUp(), e2.m_bHorizontal = e2.m_line.getEndY() === e2.m_line.getStartY(), e2.m_bHorizontal || (e2.m_dxdy = (e2.m_line.getEndX() - e2.m_line.getStartX()) / (e2.m_line.getEndY() - e2.m_line.getStartY())));
  }
  initSimpleEdgeHelper_(e2, t3) {
    if (e2.m_segment = this.m_shape.getSegment(t3), e2.m_segmentInfo = this.m_shape.getOriginalSegmentInfo(t3), e2.m_bCurve = null !== e2.m_segment, e2.m_bCurve) {
      const t4 = e2.m_segment.clone();
      return t4.orientBottomUp(), e2.m_segment = t4, e2.m_env = e2.m_segment.queryInterval(0, 0), e2.m_env.vmax += this.m_tolerance, true;
    }
    return false;
  }
  compareTwoSegments_(e2, t3) {
    const s3 = e2.getStartXY(), n5 = e2.getEndXY(), r = t3.getStartXY(), i2 = t3.getEndXY();
    if (this.m_ptSweep.setCoords(this.m_sweepX, this.m_sweepY), s3.isEqualPoint2D(r) && this.m_sweepY === s3.y) {
      this.m_ptSweep.assign(n5.compare(i2) < 0 ? n5 : i2);
      const s4 = e2.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y, this.m_ptSweep.x), r2 = t3.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y, this.m_ptSweep.x);
      if (Math.abs(s4 - r2) > this.m_tolerance) return s4 < r2 ? -1 : 1;
    }
    const o = s3.compare(r) < 0 ? r : s3, a2 = n5.compare(i2) < 0 ? n5 : i2;
    let h2 = 0, m3 = 0;
    for (let l2 = 1; l2 < 5; l2++) {
      Y(o, a2, l2 / 5, this.m_ptSweep);
      const s4 = e2.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y, this.m_ptSweep.x), n6 = t3.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y, this.m_ptSweep.x), r2 = Math.abs(s4 - n6);
      r2 > h2 && (h2 = r2, m3 = s4 < n6 ? -1 : 1);
    }
    return 0 === m3 ? this.errorCracking() : m3;
  }
  compareNonHorizontal_(e2, t3) {
    if (e2.m_line.getStartY() === t3.m_line.getStartY() && e2.m_line.getStartX() === t3.m_line.getStartX()) return e2.m_line.getEndY() === t3.m_line.getEndY() && e2.m_line.getEndX() === t3.m_line.getEndX() ? this.m_bIsSimple ? this.errorCoincident() : 0 : this.compareNonHorizontalUpperEnd_(e2, t3);
    if (e2.m_line.getEndY() === t3.m_line.getEndY() && e2.m_line.getEndX() === t3.m_line.getEndX()) return this.compareNonHorizontalLowerEnd_(e2, t3);
    const s3 = this.compareNonHorizontalLowerEnd_(e2, t3), n5 = this.compareNonHorizontalUpperEnd_(e2, t3);
    return s3 < 0 && n5 < 0 ? -1 : s3 > 0 && n5 > 0 ? 1 : this.errorCracking();
  }
  compareHorizontal1Case1_(e2, t3) {
    if (e2.getEndX() > t3.getEndX()) {
      if (t3.getEndX() > t3.getStartX() && t3.getEndY() - t3.getStartY() < 2 * this.m_tolerance && e2.isIntersectingPoint(t3.getEndXY(), this.m_tolerance, true)) return this.errorCracking();
    } else {
      if ((t3.getEndY() - t3.getStartY()) / (t3.getEndX() - t3.getStartX()) * (e2.getEndX() - e2.getStartX()) < this.m_tolerance10 && t3.isIntersectingPoint(e2.getEndXY(), this.m_tolerance, true)) return this.errorCracking();
    }
    return 1;
  }
  compareHorizontal1Case2_(e2, t3) {
    if (e2.getStartX() < t3.getStartX()) {
      if (t3.getEndX() > t3.getStartX() && t3.getEndY() - t3.getStartY() < 2 * this.m_tolerance && e2.isIntersectingPoint(t3.getEndXY(), this.m_tolerance, true)) return this.errorCracking();
    } else {
      if ((t3.getEndY() - t3.getStartY()) / (t3.getEndX() - t3.getStartX()) * (e2.getStartX() - e2.getEndX()) < this.m_tolerance10 && t3.isIntersectingPoint(e2.getStartXY(), this.m_tolerance, true)) return this.errorCracking();
    }
    return -1;
  }
  compareHorizontal1Case3_(e2, t3) {
    const s3 = mi.getNAN();
    s3.setSub(t3.getEndXY(), t3.getStartXY()), s3.rightPerpendicularThis(), s3.normalize();
    const n5 = mi.getNAN();
    n5.setSub(e2.getStartXY(), t3.getStartXY());
    const r = mi.getNAN();
    r.setSub(e2.getEndXY(), t3.getStartXY());
    const i2 = n5.dotProduct(s3), o = r.dotProduct(s3), a2 = Math.abs(i2), h2 = Math.abs(o);
    if (a2 < h2) {
      if (a2 < this.m_tolerance10 && t3.isIntersectingPoint(e2.getStartXY(), this.m_tolerance, true)) return this.errorCracking();
    } else if (h2 < this.m_tolerance10 && t3.isIntersectingPoint(e2.getEndXY(), this.m_tolerance, true)) return this.errorCracking();
    return i2 < 0 && o < 0 ? -1 : i2 > 0 && o > 0 ? 1 : this.errorCracking();
  }
  compareHorizontal1_(e2, t3) {
    return e2.getStartY() === t3.getStartY() && e2.getStartX() === t3.getStartX() ? this.compareHorizontal1Case1_(e2, t3) : e2.getEndY() === t3.getEndY() && e2.getEndX() === t3.getEndX() ? this.compareHorizontal1Case2_(e2, t3) : this.compareHorizontal1Case3_(e2, t3);
  }
  compareHorizontal2_(e2, t3) {
    return e2.getEndY() === t3.getEndY() && e2.getEndX() === t3.getEndX() && e2.getStartY() === t3.getStartY() && e2.getStartX() === t3.getStartX() ? this.m_bIsSimple ? this.errorCoincident() : 0 : this.errorCracking();
  }
  compareNonHorizontalLowerEnd_(e2, t3) {
    let s3 = 1;
    if (e2.m_line.getStartY() < t3.m_line.getStartY()) {
      s3 = -1;
      const n6 = e2;
      e2 = t3, t3 = n6;
    }
    const n5 = e2.m_line, r = t3.m_line, i2 = n5.getStartX() - r.getStartX(), o = t3.m_dxdy * (n5.getStartY() - r.getStartY()), a2 = this.m_tolerance10;
    return i2 < o - a2 ? -s3 : i2 > o + a2 ? s3 : r.isIntersectingPoint(n5.getStartXY(), this.m_tolerance, true) ? this.errorCracking() : i2 < o ? -s3 : s3;
  }
  compareNonHorizontalUpperEnd_(e2, t3) {
    let s3 = 1;
    if (t3.m_line.getEndY() < e2.m_line.getEndY()) {
      s3 = -1;
      const n6 = e2;
      e2 = t3, t3 = n6;
    }
    const n5 = e2.m_line, r = t3.m_line, i2 = n5.getEndX() - r.getStartX(), o = t3.m_dxdy * (n5.getEndY() - r.getStartY()), a2 = this.m_tolerance10;
    return i2 < o - a2 ? -s3 : i2 > o + a2 ? s3 : r.isIntersectingPoint(n5.getEndXY(), this.m_tolerance, true) ? this.errorCracking() : i2 < o ? -s3 : s3;
  }
  errorCoincident() {
    this.m_bIntersectionDetected = true;
    const e2 = 7;
    return this.m_nonSimpleResult = new e(e2, this.m_vertex1, this.m_vertex2), -1;
  }
  errorCracking() {
    if (this.m_bIntersectionDetected = true, this.m_bIsSimple) {
      const e2 = 6;
      this.m_nonSimpleResult = new e(e2, this.m_vertex1, this.m_vertex2);
    } else this.m_prev1 = cr, this.m_prev2 = cr, this.m_vertex1 = cr, this.m_vertex2 = cr;
    return -1;
  }
  compareSegments_(e2, t3, s3, n5) {
    if (s3.m_env.vmax < n5.m_env.vmin) return -1;
    if (n5.m_env.vmax < s3.m_env.vmin) return 1;
    if (!s3.m_bCurve && !n5.m_bCurve) {
      let e3 = s3.m_bHorizontal ? 1 : 0;
      return e3 |= n5.m_bHorizontal ? 2 : 0, 0 === e3 ? this.compareNonHorizontal_(s3, n5) : 1 === e3 ? this.compareHorizontal1_(s3.m_line, n5.m_line) : 2 === e3 ? -1 * this.compareHorizontal1_(n5.m_line, s3.m_line) : this.compareHorizontal2_(s3.m_line, n5.m_line);
    }
    if (this.m_bIntersectionDetected) return -1;
    const r = this.m_prevY === this.m_sweepY && this.m_prevX === this.m_sweepX;
    let i2, o;
    if (r && e2 === this.m_prev1 ? i2 = this.m_prevX1 : (i2 = Number.NaN, this.m_prev1 = cr), r && t3 === this.m_prev2 ? o = this.m_prevX2 : (o = Number.NaN, this.m_prev2 = cr), this.m_prevY = this.m_sweepY, this.m_prevX = this.m_sweepX, Number.isNaN(i2)) {
      this.m_prev1 = e2;
      const t4 = s3.m_segment.intersectionOfYMonotonicWithAxisX(this.m_sweepY, this.m_sweepX);
      i2 = t4, this.m_prevX1 = t4;
    }
    if (Number.isNaN(o)) {
      this.m_prev2 = t3;
      const e3 = n5.m_segment.intersectionOfYMonotonicWithAxisX(this.m_sweepY, this.m_sweepX);
      o = e3, this.m_prevX2 = e3;
    }
    const a2 = om(true, true, s3.m_segment, n5.m_segment, this.m_tolerance, true);
    return 0 !== a2 ? 2 === a2 ? this.m_bIsSimple ? this.errorCoincident() : s3.m_segmentInfo.equals(n5.m_segmentInfo) ? 0 : this.errorCracking() : this.errorCracking() : Math.abs(i2 - o) <= this.m_tolerance ? this.compareTwoSegments_(s3.m_segment, n5.m_segment) : i2 < o ? -1 : i2 > o ? 1 : 0;
  }
  clearIntersectionDetectedFlag() {
    this.m_bIntersectionDetected = false;
  }
  intersectionDetected() {
    return this.m_bIntersectionDetected;
  }
  getLastComparedNode() {
    return this.m_currentNode;
  }
  getResult() {
    return this.m_nonSimpleResult;
  }
  setSweepY(e2, t3) {
    this.m_sweepY = e2, this.m_sweepX = t3, this.m_prev1 = cr, this.m_prev2 = cr, this.m_vertex1 = cr, this.m_vertex2 = cr;
  }
  compare(e2, t3, s3) {
    if (this.m_bIntersectionDetected) return -1;
    const n5 = e2.getElement(s3), r = t3;
    return this.m_currentNode = s3, this.compareSegments(r, r, n5, n5);
  }
  compareSegments(e2, t3, s3, n5) {
    let r = this.tryGetCachedEdge_(e2);
    null === r ? this.m_vertex1 === t3 ? r = this.m_tempSimpleEdge1 : (this.m_vertex1 = t3, r = this.tryCreateCachedEdge_(e2), null === r && (r = this.m_tempSimpleEdge1, this.m_tempSimpleEdge1.m_value = e2), this.initSimpleEdge_(r, t3)) : this.m_vertex1 = t3;
    let i2 = this.tryGetCachedEdge_(s3);
    return null === i2 ? this.m_vertex2 === n5 ? i2 = this.m_tempSimpleEdge2 : (this.m_vertex2 = n5, i2 = this.tryCreateCachedEdge_(s3), null === i2 && (i2 = this.m_tempSimpleEdge2, this.m_tempSimpleEdge2.m_value = s3), this.initSimpleEdge_(i2, n5)) : this.m_vertex2 = n5, this.compareSegments_(t3, n5, r, i2);
  }
  onDelete(e2) {
    this.tryDeleteCachedEdge_(e2);
  }
  onSet(e2) {
    this.tryDeleteCachedEdge_(e2);
  }
  onEndSearch(e2) {
    this.tryDeleteCachedEdge_(e2);
  }
  onAddUniqueElementFailed(e2) {
    this.tryDeleteCachedEdge_(e2);
  }
};
var an2 = class {
  constructor(e2, t3) {
    this.m_bIntersectionDetected = false, this.m_pointOfInterest = mi.getNAN(), this.m_line1 = new pm(), this.m_seg1 = null, this.m_env = x2.constructEmpty(), this.m_vertex1 = -1, this.m_currentNode = -1, this.m_minDist = Number.MAX_VALUE, this.m_shape = e2, this.m_tolerance = t3;
  }
  getCurrentNode() {
    return this.m_currentNode;
  }
  clearIntersectionDetectedFlag() {
    this.m_bIntersectionDetected = false, this.m_minDist = Number.MAX_VALUE;
  }
  intersectionDetected() {
    return this.m_bIntersectionDetected;
  }
  setPoint(e2) {
    this.m_pointOfInterest.assign(e2);
  }
  compare(e2, t3) {
    const s3 = e2.getElement(t3);
    return this.compareVertex(e2, t3, s3);
  }
  compareVertex(e2, t3, s3) {
    let n5, r = this.m_shape.getSegment(s3), i2 = true;
    if (null == r) this.m_shape.queryLineConnector(s3, this.m_line1, true), this.m_env.setCoordsNoNAN(this.m_line1.getStartX(), this.m_line1.getEndX()), r = this.m_line1, n5 = this.m_line1.getStartY() === this.m_line1.getEndY();
    else {
      const e3 = n3.constructEmpty();
      r.queryLooseEnvelope(e3), e3.queryIntervalX(this.m_env), n5 = 0 === e3.height(), i2 = false;
    }
    if (this.m_pointOfInterest.x + this.m_tolerance < this.m_env.vmin) return -1;
    if (this.m_pointOfInterest.x - this.m_tolerance > this.m_env.vmax) return 1;
    if (n5) return this.m_currentNode = t3, this.m_bIntersectionDetected = true, 0;
    let o = 0;
    if (i2) {
      Es(this.m_line1);
      const e3 = this.m_line1.getStartXY(), t4 = new mi();
      t4.setSub(this.m_line1.getEndXY(), e3), t4.rightPerpendicularThis();
      const s4 = new mi();
      s4.setSub(this.m_pointOfInterest, e3), o = t4.dotProduct(s4), o /= t4.length();
    } else {
      o = r.intersectionOfYMonotonicWithAxisX(this.m_pointOfInterest.y, this.m_pointOfInterest.x) - this.m_pointOfInterest.x;
    }
    if (o < 10 * -this.m_tolerance) return -1;
    if (o > 10 * this.m_tolerance) return 1;
    if (r.isIntersectingPoint(this.m_pointOfInterest, this.m_tolerance)) {
      Math.abs(o) < this.m_minDist && (this.m_currentNode = t3, this.m_minDist = o), this.m_bIntersectionDetected = true;
    }
    return o < 0 ? -1 : o > 0 ? 1 : 0;
  }
};
var hn2 = class _hn {
  constructor(e2, t3) {
    this.m_lists = new sn2(false), this.m_hash = t3, this.m_hashBuckets = new Int32Array(e2), this.m_hashBuckets.fill(_hn.st_nullNode()), this.m_bitFilter = new Int32Array(10 * e2 + 31 >> 5);
  }
  reserveElements(e2) {
    this.m_lists.reserveLists(Math.min(this.m_hashBuckets.length, e2)), this.m_lists.reserveNodes(e2);
  }
  addElement(e2, t3) {
    void 0 === t3 && (t3 = this.m_hash.getHash(e2));
    const s3 = t3 % (this.m_bitFilter.length << 5);
    this.m_bitFilter[s3 >> 5] |= 1 << (31 & s3);
    const n5 = t3 % this.m_hashBuckets.length;
    let r = this.m_hashBuckets[n5];
    r === sn2.st_nullNode() && (r = this.m_lists.createList(), this.m_hashBuckets[n5] = r);
    return this.m_lists.addElement(r, e2);
  }
  deleteElement(t3, s3) {
    void 0 === s3 && (s3 = this.m_hash.getHash(t3));
    const n5 = s3 % this.m_hashBuckets.length, r = this.m_hashBuckets[n5];
    r === sn2.st_nullNode() && P("");
    let i2 = this.m_lists.getFirst(r), o = sn2.st_nullNode();
    for (; i2 !== sn2.st_nullNode(); ) {
      const e2 = this.m_lists.getData(i2), s4 = this.m_lists.getNext(i2);
      e2 === t3 ? (this.m_lists.deleteElementDirect(r, o, i2), this.m_lists.getFirst(r) === sn2.st_nullNode() && (this.m_lists.deleteList(r), this.m_hashBuckets[n5] = sn2.st_nullNode())) : o = i2, i2 = s4;
    }
  }
  getFirstInBucket(e2) {
    const t3 = e2 % (this.m_bitFilter.length << 5);
    if (!(this.m_bitFilter[t3 >> 5] & 1 << (31 & t3))) return sn2.st_nullNode();
    const s3 = e2 % this.m_hashBuckets.length, n5 = this.m_hashBuckets[s3];
    return n5 === sn2.st_nullNode() ? sn2.st_nullNode() : this.m_lists.getFirst(n5);
  }
  getNextInBucket(e2) {
    return this.m_lists.getNext(e2);
  }
  findNode(e2) {
    const t3 = this.m_hash.getHash(e2);
    let s3 = this.getFirstInBucket(t3);
    for (; s3 !== sn2.st_nullNode(); ) {
      const t4 = this.m_lists.getData(s3);
      if (this.m_hash.equal(t4, e2)) return s3;
      s3 = this.m_lists.getNext(s3);
    }
    return sn2.st_nullNode();
  }
  deleteNode(t3) {
    const s3 = this.getElement(t3), n5 = this.m_hash.getHash(s3) % this.m_hashBuckets.length, r = this.m_hashBuckets[n5];
    r === sn2.st_nullNode() && P(""), this.m_lists.deleteElementSearch(r, t3), this.m_lists.getFirst(r) === sn2.st_nullNode() && (this.m_lists.deleteList(r), this.m_hashBuckets[n5] = sn2.st_nullNode());
  }
  getElement(e2) {
    return this.m_lists.getData(e2);
  }
  static st_nullNode() {
    return sn2.st_nullNode();
  }
  clear() {
    n(0);
  }
  size() {
    return this.m_lists.getNodeCount();
  }
  dbgPrintBucketHistogram() {
  }
};
function mn2(e2, t3, s3, n5, r) {
  const i2 = new fn2(r);
  return i2.m_shape = e2, i2.m_sqrTolerance = t3 * t3, i2.m_cellSize = 2 * t3, i2.m_invCellSize = 1 / i2.m_cellSize, i2.m_geometry = s3, i2.m_bTrackChanges = n5, i2.m_bHasSegmentParentage = e2.hasSegmentParentage(), i2.clusterNonReciprocal();
}
function ln2(e2, t3, s3, n5, r) {
  const i2 = e2 - s3, o = t3 - n5;
  return i2 * i2 + o * o <= r;
}
function gn2() {
  return { pt: new mi(), weight: 0, rank: 0, bMerged: false };
}
function un2(e2, t3, s3, n5, r, i2) {
  const o = gn2(), a2 = s3 + r;
  let h2 = false, m3 = e2.x;
  e2.x !== t3.x && (n5 === i2 && (m3 = (e2.x * s3 + t3.x * r) / a2), h2 = true);
  let l2 = e2.y;
  return e2.y !== t3.y && (n5 === i2 && (l2 = (e2.y * s3 + t3.y * r) / a2), h2 = true), n5 !== i2 ? n5 > i2 ? (o.rank = n5, o.weight = s3, o.pt = e2) : (o.rank = i2, o.weight = r, o.pt = t3) : (o.pt.setCoords(m3, l2), o.weight = a2, o.rank = n5), o.bMerged = h2, o;
}
function cn2(e2, t3, s3, n5, r, i2, o, a2, h2) {
  const m3 = e2.equals(t3);
  if (n5 > i2) return o.assignCopy(e2), h2[0] = n5, a2[0] = s3, m3;
  if (i2 > n5) return o = t3, h2[0] = i2, a2[0] = r, m3;
  o.assignCopy(e2);
  const l2 = un2(e2.getXY(), t3.getXY(), s3, n5, r, i2);
  return o.setXY(l2.pt), a2[0] = l2.weight, h2[0] = l2.rank, m3;
}
function dn2(e2, t3) {
  const s3 = qs(e2);
  return zs(s3, t3);
}
var pn2 = class {
  constructor(e2, t3, s3, n5, r) {
    this.m_workPt = new mi(), this.m_shape = e2, this.m_sqrTolerance = s3, this.m_invCellSize = n5, this.m_origin = t3.clone(), this.m_hashValues = r;
  }
  getHash(e2) {
    return this.m_shape.getUserIndex(e2, this.m_hashValues);
  }
  calculateHashFromVertex(e2) {
    this.m_shape.queryXY(e2, this.m_workPt);
    const t3 = this.m_workPt.x - this.m_origin.x, s3 = Math.trunc(t3 * this.m_invCellSize + 0.5), n5 = this.m_workPt.y - this.m_origin.y;
    return dn2(s3, Math.trunc(n5 * this.m_invCellSize + 0.5));
  }
  equal(e2, t3) {
    return n(0), false;
  }
};
var fn2 = class {
  constructor(e2) {
    this.m_origin = mi.getNAN(), this.m_sqrTolerance = 0, this.m_cellSize = 0, this.m_invCellSize = 0, this.m_geometry = cr, this.m_bucketArray = Yt(4, Number.NaN), this.m_bucketHash = Yt(4, Number.NaN), this.m_dbgCandidateCheckCount = 0, this.m_nsr = new e(), this.m_hashValues = -1, this.m_newClusters = -1, this.m_bTrackChanges = false, this.m_bHasSegmentParentage = false, this.m_shape = null, this.m_clusters = new sn2(), this.m_hashFunction = null, this.m_hashTable = null, this.m_progressCounter = 0, this.m_progressTracker = e2;
  }
  progress_() {
  }
  collectClusterCandidates(e2, t3) {
    const s3 = mi.getNAN();
    this.m_shape.queryXY(e2, s3);
    const n5 = (s3.x - this.m_origin.x) * this.m_invCellSize, r = (s3.y - this.m_origin.y) * this.m_invCellSize, i2 = Math.trunc(n5), o = Math.trunc(r);
    let a2 = 0;
    for (let h2 = 0; h2 <= 1; h2 += 1) for (let e3 = 0; e3 <= 1; e3 += 1) {
      const t4 = dn2(i2 + h2, o + e3), s4 = this.m_hashTable.getFirstInBucket(t4);
      s4 !== hn2.st_nullNode() && (this.m_bucketArray[a2] = s4, this.m_bucketHash[a2] = t4, a2++);
    }
    for (let h2 = a2 - 1; h2 >= 1; h2--) {
      const e3 = this.m_bucketArray[h2];
      for (let t4 = h2 - 1; t4 >= 0; t4--) if (e3 === this.m_bucketArray[t4]) {
        this.m_bucketHash[t4] = -1, a2--, h2 !== a2 && (this.m_bucketHash[h2] = this.m_bucketHash[a2], this.m_bucketArray[h2] = this.m_bucketArray[a2]);
        break;
      }
    }
    for (let h2 = 0; h2 < a2; h2++) this.collectNearestNeighbourCandidates(e2, this.m_bucketHash[h2], s3, this.m_bucketArray[h2], t3);
  }
  collectNearestNeighbourCandidates(e2, t3, s3, n5, r) {
    const i2 = mi.getNAN();
    for (let o = n5; o !== hn2.st_nullNode(); o = this.m_hashTable.getNextInBucket(o)) {
      const n6 = this.m_hashTable.getElement(o);
      e2 === n6 || -1 !== t3 && this.m_shape.getUserIndex(n6, this.m_hashValues) !== t3 || (this.m_shape.queryXY(n6, i2), ln2(s3.x, s3.y, i2.x, i2.y, this.m_sqrTolerance) && r.push(o));
    }
  }
  mergeClusters(e2, t3, s3) {
    let n5 = this.m_shape.getUserIndex(e2, this.m_newClusters);
    const r = this.m_shape.getUserIndex(t3, this.m_newClusters);
    -1 === n5 && (n5 = this.m_clusters.createList(), this.m_clusters.addElement(n5, e2), this.m_shape.setUserIndex(e2, this.m_newClusters, n5)), -1 === r ? this.m_clusters.addElement(n5, t3) : this.m_clusters.concatenateLists(n5, r), this.m_shape.setUserIndex(t3, this.m_newClusters, at.impossibleIndex2());
    const i2 = this.mergeVertices(e2, t3);
    if (s3) {
      const t4 = this.m_hashFunction.calculateHashFromVertex(e2);
      this.m_shape.setUserIndex(e2, this.m_hashValues, t4);
    }
    return i2;
  }
  mergeVertices(e2, t3) {
    const s3 = mi.getNAN();
    this.m_shape.queryXY(e2, s3);
    const n5 = mi.getNAN();
    this.m_shape.queryXY(t3, n5);
    const r = this.m_shape.getRank(e2), i2 = this.m_shape.getRank(t3), o = this.m_shape.getWeight(e2), a2 = this.m_shape.getWeight(t3);
    let h2, m3, l2, g2, u = false;
    if (r === i2 ? (h2 = r, m3 = o + a2, l2 = s3.x, s3.x !== n5.x && (l2 = (s3.x * o + n5.x * a2) / m3, u = true), g2 = s3.y, s3.y !== n5.y && (g2 = (s3.y * o + n5.y * a2) / m3, u = true)) : (r > i2 ? (l2 = s3.x, g2 = s3.y, m3 = o, h2 = r) : (l2 = n5.x, g2 = n5.y, m3 = a2, h2 = i2), u = !s3.equals(n5)), u && (this.m_shape.setXYMonotonic(e2, l2, g2), this.m_bTrackChanges && this.m_shape.setGeometryModifiedWithVertex(e2, true), this.m_bHasSegmentParentage)) {
      const s4 = this.m_shape.getSegmentParentageBreakVertex(e2) || this.m_shape.getSegmentParentageBreakVertex(t3);
      this.m_shape.setSegmentParentageBreakVertex(e2, s4), this.m_shape.setSegmentParentageBreakVertex(t3, s4);
    }
    return this.m_shape.setWeight(e2, m3), this.m_shape.setRank(e2, h2), u;
  }
  needsClustering() {
    const e2 = { stack: [], error: void 0, hasError: false };
    try {
      __addDisposableResource(e2, kt(() => {
        this.m_hashTable = null, this.m_hashFunction = null, this.m_shape.removeUserIndex(this.m_hashValues), this.m_shape.removeUserIndex(this.m_newClusters);
      }), false);
      const t3 = this.m_shape.getSelectedCount(), s3 = this.m_shape.getEnvelope2D(this.m_progressTracker);
      this.m_origin.assign(s3.getLowerLeft());
      const n5 = Math.max(s3.height(), s3.width()) / (ds() - 1);
      this.m_cellSize < n5 && (this.m_cellSize = n5, this.m_invCellSize = 1 / this.m_cellSize), this.m_clusters.clear(), this.m_clusters.reserveLists(this.m_shape.getSelectedCount() / 3 + 1), this.m_clusters.reserveNodes(this.m_shape.getSelectedCount() / 3 + 1), this.m_hashValues = this.m_shape.createUserIndex(), this.m_newClusters = this.m_shape.createUserIndex(), this.m_hashFunction = new pn2(this.m_shape, this.m_origin, this.m_sqrTolerance, this.m_invCellSize, this.m_hashValues), this.m_hashTable = new hn2(4 * t3 / 3, this.m_hashFunction), this.m_hashTable.reserveElements(this.m_shape.getSelectedCount());
      let r = false;
      for (let e3 = 0; e3 < 2; e3++) {
        const t4 = [], s4 = this.m_shape.queryVertexIteratorOnSelection(this.m_geometry);
        for (let n6 = s4.next(); n6 !== cr; n6 = s4.next()) {
          if (this.progress_(), e3 > 0 && this.m_shape.getUserIndex(n6, this.m_newClusters) === at.impossibleIndex2()) continue;
          let s5;
          if (0 === e3 ? (s5 = this.m_hashFunction.calculateHashFromVertex(n6), this.m_shape.setUserIndex(n6, this.m_hashValues, s5)) : s5 = this.m_shape.getUserIndex(n6, this.m_hashValues), this.collectClusterCandidates(n6, t4), 0 !== t4.length) {
            for (let e4 = 0, s6 = t4.length; e4 < s6; e4++) {
              this.progress_();
              const s7 = t4[e4], i2 = this.m_hashTable.getElement(s7);
              if (this.m_hashTable.deleteNode(s7), !this.m_shape.isEqualXY(n6, i2)) return this.m_nsr = new e(5, this.m_shape.getVertexIndex(n6), this.m_shape.getVertexIndex(i2)), r = true, r;
              this.mergeClusters(n6, i2, false);
            }
            t4.length = 0;
          }
          0 === e3 && this.m_hashTable.addElement(n6, s5);
        }
      }
      return r;
    } catch (t3) {
      e2.error = t3, e2.hasError = true;
    } finally {
      __disposeResources(e2);
    }
  }
  clusterNonReciprocal() {
    const e2 = this.m_shape.getSelectedCount(), t3 = this.m_shape.getEnvelope2D(this.m_progressTracker);
    this.m_origin = t3.getLowerLeft();
    const s3 = Math.max(t3.height(), t3.width()) / (ds() - 1);
    this.m_cellSize < s3 && (this.m_cellSize = s3, this.m_invCellSize = 1 / this.m_cellSize), this.m_clusters.clear(), this.m_clusters.reserveLists(Math.trunc(this.m_shape.getSelectedCount() / 3 + 1)), this.m_clusters.reserveNodes(Math.trunc(this.m_shape.getSelectedCount() / 3 + 1)), this.m_hashValues = this.m_shape.createUserIndex(), this.m_newClusters = this.m_shape.createUserIndex(), this.m_hashFunction = new pn2(this.m_shape, this.m_origin, this.m_sqrTolerance, this.m_invCellSize, this.m_hashValues), this.m_hashTable = new hn2(Math.trunc(4 * e2 / 3), this.m_hashFunction), this.m_hashTable.reserveElements(this.m_shape.getSelectedCount());
    let n5 = false;
    {
      const e3 = this.m_shape.queryVertexIteratorOnSelection(this.m_geometry);
      for (let t4 = e3.next(); t4 !== cr; t4 = e3.next()) {
        this.progress_();
        const e4 = this.m_hashFunction.calculateHashFromVertex(t4);
        this.m_shape.setUserIndex(t4, this.m_hashValues, e4), this.m_hashTable.addElement(t4, e4);
      }
    }
    {
      const e3 = [], t4 = this.m_shape.queryVertexIteratorOnSelection(this.m_geometry);
      for (let s4 = t4.next(); s4 !== cr; s4 = t4.next()) {
        if (this.m_shape.getUserIndex(s4, this.m_newClusters) === at.impossibleIndex2()) continue;
        let t5 = this.m_shape.getUserIndex(s4, this.m_hashValues);
        this.m_hashTable.deleteElement(s4, t5);
        let r = false;
        for (; this.collectClusterCandidates(s4, e3), 0 !== e3.length; ) {
          let t6 = 0;
          for (let n6 = 0, r2 = e3.length; n6 < r2; n6++) {
            this.progress_();
            const i2 = e3[n6], o = this.m_hashTable.getElement(i2);
            this.m_hashTable.deleteNode(i2);
            const a2 = n6 + 1 === r2;
            t6 |= this.mergeClusters(s4, o, a2) ? 1 : 0;
          }
          if (r ||= 0 !== t6, n5 ||= 0 !== t6, e3.length = 0, !t6) break;
        }
        r && (t5 = this.m_shape.getUserIndex(s4, this.m_hashValues)), this.m_hashTable.addElement(s4, t5);
      }
      e3.length = 0;
    }
    return n5 && this.applyClusterPositions_(), this.m_hashTable = null, this.m_hashFunction = null, this.m_shape.removeUserIndex(this.m_hashValues), this.m_shape.removeUserIndex(this.m_newClusters), n5;
  }
  applyClusterPositions_() {
    const e2 = mi.getNAN();
    for (let t3 = this.m_clusters.getFirstList(); t3 !== sn2.st_nullNode(); t3 = this.m_clusters.getNextList(t3)) {
      let s3 = this.m_clusters.getFirst(t3);
      const n5 = this.m_clusters.getElement(s3);
      this.m_shape.queryXY(n5, e2);
      const r = this.m_shape.getRank(n5), i2 = this.m_shape.getWeight(n5);
      for (s3 = this.m_clusters.getNext(s3); s3 !== sn2.st_nullNode(); s3 = this.m_clusters.getNext(s3)) {
        const t4 = this.m_clusters.getElement(s3);
        if (this.m_bTrackChanges ? this.m_shape.isEqualXYPoint2D(t4, e2) || (this.m_shape.setXYMonotonicPoint2D(t4, e2), this.m_shape.setGeometryModifiedWithVertex(t4, true)) : this.m_shape.setXYMonotonicPoint2D(t4, e2), this.m_bHasSegmentParentage) {
          const e3 = this.m_shape.getSegmentParentageBreakVertex(n5) || this.m_shape.getSegmentParentageBreakVertex(t4);
          this.m_shape.setSegmentParentageBreakVertex(n5, e3), this.m_shape.setSegmentParentageBreakVertex(t4, e3);
        }
        this.m_shape.setWeight(t4, i2), this.m_shape.setRank(t4, r);
      }
    }
  }
};
var xn2 = class _xn {
  constructor() {
    this.m_inputParts = [], this.m_resultParts1 = [], this.m_resultParts2 = [], this.m_resultSegments = [], this.m_freeSegments = [], this.m_inputSegments = [], this.m_param1 = [], this.m_param2 = [], this.m_tolerance = 0, this.m_toleranceZ = 0, this.m_point = new ee(), this.m_pointWeight = 1, this.m_maxDensifyLimit = 0, this.m_pointRank = 0, this.m_changed1 = false, this.m_changed2 = false, this.m_adaptiveDensify = false;
  }
  clear() {
    this.freeAllResultSegments(), this.m_inputSegments.length = 0, this.m_inputParts.length = 0, this.m_resultParts1.length = 0, this.m_resultParts2.length = 0, this.m_param1.length = 0, this.m_param2.length = 0, this.m_adaptiveDensify = false, this.m_changed1 = false, this.m_changed2 = false;
  }
  newIntersectionPart_(e2, t3, s3, n5, r, i2, o, a2, h2, m3) {
    return Pn2(e2, t3, s3, n5, r, i2, o, a2, h2, m3);
  }
  pushSegment(e2, t3, s3, n5, r, i2, o, a2, h2, m3) {
    return this.m_inputParts.push(this.newIntersectionPart_(this.m_inputSegments.length, t3, s3, n5, r, i2, o, a2, h2, m3)), this.m_inputSegments.push(e2), this.m_inputParts.length - 1;
  }
  getResultSegmentCount(e2) {
    return this.m_adaptiveDensify ? 0 === e2 ? this.m_param1.length - 1 : this.m_param2.length - 1 : 0 === e2 ? this.m_resultParts1.length : this.m_resultParts2.length;
  }
  getResultPart_(e2, t3) {
    return 0 === e2 ? this.m_resultParts1[t3] : this.m_resultParts2[t3];
  }
  getResultSegment(e2, t3) {
    return this.m_resultSegments[this.getResultPart_(e2, t3).segmentIndex].get();
  }
  getSegmentChanged(e2) {
    return 0 === e2 ? this.m_changed1 : this.m_changed2;
  }
  getResultSegmentStartPointWeight(e2, t3) {
    return this.getResultPart_(e2, t3).weightStart;
  }
  getResultSegmentStartPointRank(e2, t3) {
    return this.getResultPart_(e2, t3).rankStart;
  }
  getResultSegmentSegmentParentage(e2, t3) {
    return this.getResultPart_(e2, t3).segmentParentage;
  }
  getResultSegmentStartPointIsBreak(e2, t3) {
    return this.getResultPart_(e2, t3).u.bBreakStart;
  }
  getResultSegmentEndPointWeight(e2, t3) {
    return this.getResultPart_(e2, t3).weightEnd;
  }
  getResultSegmentEndPointRank(e2, t3) {
    return this.getResultPart_(e2, t3).rankEnd;
  }
  getResultSegmentEndPointIsBreak(e2, t3) {
    return this.getResultPart_(e2, t3).u.bBreakEnd;
  }
  getResultSegmentInteriorRank(e2, t3) {
    return this.getResultPart_(e2, t3).rankInterior;
  }
  getResultSegmentInteriorWeight(e2, t3) {
    return this.getResultPart_(e2, t3).weightInterior;
  }
  getResultPoint() {
    return this.m_point;
  }
  getResultPointWeight() {
    return this.m_pointWeight;
  }
  getResultPointRank() {
    return this.m_pointRank;
  }
  getResultPointChanged() {
    return this.m_changed2;
  }
  intersectLines(e2, t3) {
    2 !== this.m_inputSegments.length && b(""), this.m_changed1 = false, this.m_changed2 = false, this.m_tolerance = e2;
    const s3 = H(e2 * _xn.c_smallToleranceFactor);
    let n5 = false;
    const i2 = this.m_inputParts[0], o = this.m_inputParts[1], a2 = this.m_inputSegments[i2.segmentIndex], h2 = this.m_inputSegments[o.segmentIndex];
    if (t3 || 5 & rm(true, a2, h2, e2, true)) {
      const t4 = um(true, a2, h2, null, this.m_param1, this.m_param2, e2);
      0 === t4 && b("");
      const m3 = new Array(t4);
      for (let e3 = 0; e3 < t4; ++e3) m3[e3] = mi.getNAN();
      const l2 = new Float64Array(t4), g2 = new Int32Array(t4), u = new Array(t4), c = new Array(t4);
      for (let e3 = 0; e3 < t4; ++e3) u[e3] = En2(), c[e3] = En2();
      for (let e3 = 0; e3 < t4; e3++) {
        const t5 = this.m_param1[e3], r = this.m_param2[e3];
        let _2, d3 = i2.rankInterior, p4 = i2.weightInterior;
        0 === t5 ? (d3 = i2.rankStart, p4 = i2.weightStart, _2 = i2.u.bBreakStart) : 1 === t5 ? (d3 = i2.rankEnd, p4 = i2.weightEnd, _2 = i2.u.bBreakEnd) : (this.m_changed1 = true, _2 = false);
        let f4, x5 = o.rankInterior, y3 = o.weightInterior;
        0 === r ? (x5 = o.rankStart, y3 = o.weightStart, f4 = o.u.bBreakStart) : 1 === r ? (x5 = o.rankEnd, y3 = o.weightEnd, f4 = o.u.bBreakEnd) : (this.m_changed2 = true, f4 = false);
        const P6 = d3, E2 = x5;
        let S3 = 1, C3 = 0, I4 = mi.getNAN();
        if (P6 === E2) {
          const n6 = a2.getCoord2D(t5), i3 = h2.getCoord2D(r);
          S3 = p4 + y3;
          C3 = d3, Y(n6, i3, y3 / S3, I4);
          const o2 = mi.sqrDistance(I4, n6), m4 = mi.sqrDistance(I4, i3);
          u[e3].bBigMove = o2 > s3, c[e3].bBigMove = m4 > s3, this.m_changed1 || n6.equals(I4) || (this.m_changed1 = true), this.m_changed2 || i3.equals(I4) || (this.m_changed2 = true);
        } else if (P6 > E2) {
          I4 = a2.getCoord2D(t5);
          const n6 = h2.getCoord2D(r);
          S3 = p4, C3 = d3;
          const i3 = mi.sqrDistance(I4, n6);
          u[e3].bBigMove = false, c[e3].bBigMove = i3 > s3, this.m_changed2 || n6.equals(I4) || (this.m_changed2 = true);
        } else {
          I4 = h2.getCoord2D(r), S3 = y3, C3 = x5;
          const n6 = a2.getCoord2D(t5), i3 = mi.sqrDistance(I4, n6);
          u[e3].bBigMove = i3 > s3, c[e3].bBigMove = false, this.m_changed1 || n6.equals(I4) || (this.m_changed1 = true);
        }
        m3[e3].assign(I4), l2[e3] = S3, g2[e3] = C3, u[e3].bIsBreak = _2 || f4, c[e3].bIsBreak = _2 || f4, n5 ||= u[e3].bBigMove || c[e3].bBigMove;
      }
      const _ = i2.rankInterior, d2 = i2.weightInterior;
      let p3 = 0, f3 = -1;
      for (let s4 = 0; s4 <= t4; s4++) {
        const n6 = s4 < t4 ? this.m_param1[s4] : 1;
        if (n6 !== p3) {
          const r = this.allocResultSegment(), o2 = this.m_resultSegments[r];
          let h3, c2, x5, y3;
          a2.queryCut(p3, n6, o2, false), o2.get().snapControlPoints(e2 * e2);
          let P6 = false, E2 = false, S3 = false, C3 = false, I4 = false, b2 = mi.getNAN(), w4 = mi.getNAN();
          -1 !== f3 ? (c2 = g2[f3], h3 = l2[f3], P6 = u[f3].bBigMove, b2.assign(m3[f3]), S3 = u[f3].bIsBreak, I4 = true) : (h3 = i2.weightStart, c2 = i2.rankStart, b2 = o2.get().getStartXY(), S3 = i2.u.bBreakStart), s4 < t4 ? (y3 = g2[s4], x5 = l2[s4], E2 = u[s4].bBigMove, w4.assign(m3[s4]), C3 = u[s4].bIsBreak, I4 = true) : (x5 = i2.weightEnd, y3 = i2.rankEnd, w4 = o2.get().getEndXY(), C3 = i2.u.bBreakEnd), I4 && o2.get().setCoordsForIntersector(b2, w4, true), this.m_resultParts1.push(this.newIntersectionPart_(r, h3, c2, x5, y3, d2, _, S3, C3, i2.segmentParentage));
          const v3 = this.m_resultParts1.at(-1);
          v3.u.bBigMoveStart = P6, v3.u.bBigMoveEnd = E2, p3 = n6, f3 = s4;
        } else -1 === f3 && (f3 = s4);
      }
      const x4 = Yt(t4, 0);
      for (let e3 = 0; e3 < t4; e3++) x4[e3] = e3;
      t4 > 2 ? (x4.sort((e3, t5) => this.m_param2[e3] < this.m_param2[t5] ? -1 : this.m_param2[e3] > this.m_param2[t5] ? 1 : 0), qt(this.m_param2)) : 2 === t4 && this.m_param2[0] > this.m_param2[1] && (this.m_param2[1] = Pt(this.m_param2[0], this.m_param2[0] = this.m_param2[1]), x4[1] = Pt(x4[0], x4[0] = x4[1]));
      const y2 = o.rankInterior, P5 = o.weightInterior;
      p3 = 0, f3 = -1;
      for (let s4 = 0; s4 <= t4; s4++) {
        const n6 = s4 < t4 ? this.m_param2[s4] : 1;
        if (n6 !== p3) {
          const r = this.allocResultSegment(), i3 = this.m_resultSegments[r];
          let a3, u2, _2, d3;
          h2.queryCut(p3, n6, i3, false), i3.get().snapControlPoints(e2 * e2);
          let E2 = mi.getNAN(), S3 = mi.getNAN(), C3 = false, I4 = false, b2 = false, w4 = false, v3 = false;
          if (-1 !== f3) {
            const e3 = x4[f3];
            a3 = l2[e3], u2 = g2[e3], E2.assign(m3[e3]), b2 = c[e3].bBigMove, C3 = c[e3].bIsBreak, v3 = true;
          } else a3 = o.weightStart, u2 = o.rankStart, E2 = i3.get().getStartXY(), C3 = o.u.bBreakStart;
          if (s4 !== t4) {
            const e3 = x4[s4];
            _2 = l2[e3], d3 = g2[e3], S3.assign(m3[e3]), w4 = c[e3].bBigMove, I4 = c[e3].bIsBreak, v3 = true;
          } else _2 = o.weightEnd, d3 = o.rankEnd, S3 = i3.get().getEndXY(), I4 = o.u.bBreakEnd;
          v3 && i3.get().setCoordsForIntersector(E2, S3, true), this.m_resultParts2.push(this.newIntersectionPart_(r, a3, u2, _2, d3, P5, y2, C3, I4, o.segmentParentage));
          const N2 = this.m_resultParts2.at(-1);
          N2.u.bBigMoveStart = b2, N2.u.bBigMoveEnd = w4, p3 = n6, f3 = s4;
        } else -1 === f3 && (f3 = s4);
      }
      return n5 ? 3 : 2;
    }
    return 0;
  }
  intersectLines3D(e2, t3, s3, n5) {
    return n(0), 1;
  }
  intersect2D(e2, t3) {
    const n5 = this.m_inputParts[0], r = this.m_inputParts[1], i2 = this.m_inputSegments[n5.segmentIndex].getGeometryType(), o = this.m_inputSegments[r.segmentIndex].getGeometryType();
    if (i2 !== a.enumLine || o !== a.enumLine) {
      return new bn2(this).intersectCurves(e2, t3);
    }
    return this.intersectLines(e2, t3);
  }
  intersect2DEx(e2, t3, s3, n5, i2) {
    this.m_point.assignCopy(t3), 1 !== this.m_inputSegments.length && b(""), this.m_tolerance = e2, this.m_changed1 = false, this.m_changed2 = false;
    const o = H(e2 * _xn.c_smallToleranceFactor);
    let a2 = false;
    const h2 = this.m_inputParts[0], m3 = this.m_inputSegments[h2.segmentIndex];
    if (i2 || m3.isIntersectingPoint(t3.getXY(), e2, true)) {
      this.m_param1 = Yt(16, Number.NaN);
      const r = m3.getClosestCoordinate(t3.getXY(), false);
      this.m_param1[0] = r;
      let i3 = h2.rankInterior, l2 = h2.weightInterior;
      0 === r ? (i3 = h2.rankStart, l2 = h2.weightStart) : 1 === r ? (i3 = h2.rankEnd, l2 = h2.weightEnd) : this.m_changed1 = true;
      let g2 = i3;
      const u = s3, c = n5;
      g2 === u && m3.isCurve() && (g2 = u + 1);
      let _ = 1, d2 = 0;
      const p3 = new mi();
      if (g2 === u) {
        const e3 = m3.getCoord2D(r), s4 = t3.getXY();
        _ = l2 + c, d2 = i3;
        Y(e3, s4, c / _, p3), this.m_changed1 || e3.equals(p3) || (this.m_changed1 = true), this.m_changed2 || s4.equals(p3) || (this.m_changed2 = true);
        a2 = mi.sqrDistance(p3, e3) > o;
      } else if (g2 > u) p3.assign(m3.getCoord2D(r)), _ = l2, d2 = i3, this.m_changed2 || p3.equals(t3.getXY()) || (this.m_changed2 = true);
      else {
        p3.assign(m3.getCoord2D(r)), _ = c, d2 = u, this.m_changed1 || p3.equals(t3.getXY()) || (this.m_changed1 = true);
        a2 = mi.sqrDistance(p3, t3.getXY()) > o;
      }
      let f3 = 0, x4 = -1;
      const y2 = 1;
      for (let t4 = 0; t4 <= y2; t4++) {
        const s4 = t4 < y2 ? this.m_param1[0] : 1;
        if (s4 !== f3) {
          const n6 = this.allocResultSegment(), r2 = this.m_resultSegments[n6];
          m3.queryCut(f3, s4, r2), r2.get().snapControlPoints(e2 * e2);
          let i4 = h2.weightStart, o2 = h2.weightEnd, a3 = h2.rankStart, l3 = h2.rankEnd;
          const g3 = h2.rankInterior, u2 = h2.weightInterior;
          let c2 = h2.u.bBreakStart, P5 = h2.u.bBreakEnd;
          -1 !== x4 && (i4 = _, a3 = d2, c2 = true, r2.get().setCoordsForIntersector(p3, r2.get().getEndXY(), true)), t4 !== y2 && (o2 = _, l3 = d2, P5 = true, r2.get().setCoordsForIntersector(r2.get().getStartXY(), p3, true)), f3 = s4, this.m_resultParts1.push(this.newIntersectionPart_(n6, i4, a3, o2, l3, u2, g3, c2, P5, h2.segmentParentage));
        }
        x4 = t4;
      }
      return this.m_point.setXY(p3), this.m_pointWeight = _, this.m_pointRank = d2, a2 ? 3 : 2;
    }
    return 0;
  }
  intersect3D(e2, t3, s3, n5) {
    return n(0), 1;
  }
  intersect3DEx(e2, t3, s3, n5, r, i2, a2) {
    return n(0), 1;
  }
  getTolerance() {
    return this.m_tolerance;
  }
  freeAllResultSegments() {
    this.m_resultSegments.length = 0, this.m_freeSegments.length = 0;
  }
  freeResultSegment(e2) {
    this.m_freeSegments.push(e2);
  }
  allocResultSegment() {
    if (this.m_freeSegments.length) {
      return this.m_freeSegments.pop();
    }
    const e2 = new fm(), t3 = this.m_resultSegments.length;
    return this.m_resultSegments.push(e2), t3;
  }
  allocResultSegmentFromBuffer(e2) {
    if (this.m_freeSegments.length) {
      return this.m_freeSegments.pop();
    }
    const t3 = new fm({ copy: e2 }), s3 = this.m_resultSegments.length;
    return this.m_resultSegments.push(t3), s3;
  }
  allocResultSegmentFromSegment(e2) {
    if (this.m_freeSegments.length) {
      return this.m_freeSegments.pop();
    }
    const t3 = new fm({ segment: e2 }), s3 = this.m_resultSegments.length;
    return this.m_resultSegments.push(t3), s3;
  }
};
function yn2(e2, t3) {
  return { bBigMoveStart: false, bBigMoveEnd: false, bBreakStart: e2, bBreakEnd: t3 };
}
function Pn2(e2, t3, s3, n5, r, i2, o, a2, h2, m3) {
  return { segmentIndex: e2, weightStart: t3, rankStart: s3, weightEnd: n5, rankEnd: r, weightInterior: i2, rankInterior: o, segmentParentage: m3, u: yn2(a2, h2) };
}
function En2() {
  return { bBigMove: false, bIsBreak: false };
}
xn2.maxWeight = 0.1 * Number.MAX_VALUE, xn2.c_smallToleranceFactor = 0.01, xn2.c_maxGeometryTypeToRankDelta = 8;
var Sn2 = class {
  constructor() {
    this.start = null, this.end = null, this.equalEdge = null, this.segmentIndex = -1, this.segmentParentage = -1, this.weight = 0, this.rank = 0;
  }
  hasSegment() {
    return this.segmentIndex >= 0;
  }
  transferAttributes(e2, t3, s3) {
    if (1 === t3.getDescription().getAttributeCount()) return;
    const n5 = e2.parent.m_resultSegments[this.segmentIndex].get().getStartXY(), r = e2.parent.m_resultSegments[this.segmentIndex].get().getEndXY(), i2 = new ee();
    t3.queryStart(i2), s3 ? (i2.setXY(n5), e2.parent.m_resultSegments[this.segmentIndex].get().setStart(i2)) : (i2.setXY(r), e2.parent.m_resultSegments[this.segmentIndex].get().setEnd(i2)), t3.queryEnd(i2), s3 ? (i2.setXY(r), e2.parent.m_resultSegments[this.segmentIndex].get().setEnd(i2)) : (i2.setXY(n5), e2.parent.m_resultSegments[this.segmentIndex].get().setStart(i2));
  }
  copyFromWhenOverlap(e2, t3, s3) {
    this.equalEdge = t3, t3.equalEdge = this, this.segmentIndex = e2.parent.allocResultSegmentFromBuffer(e2.parent.m_resultSegments[t3.segmentIndex]), this.segmentParentage = t3.segmentParentage, this.weight = t3.weight, this.rank = t3.rank, s3 ? (this.start.copyFrom(t3.start), this.end.copyFrom(t3.end)) : (this.start.copyFrom(t3.end), this.end.copyFrom(t3.start), e2.parent.m_resultSegments[this.segmentIndex].get().reverse());
  }
  getEnd() {
    return this.end;
  }
  getNextInChain() {
    return this.end.nextInChain;
  }
  getPrevInChain() {
    return this.start.prevInChain;
  }
};
var Cn2 = class {
  constructor() {
    this.hash = 0, this.pt = new mi(), this.prevInChain = null, this.nextInChain = null, this.prevInHash = null, this.nextInHash = null, this.prevEqual = null, this.nextEqual = null, this.weight = 0, this.rank = 0, this.bBigMove = false, this.bIsBreak = false;
  }
  copyFrom(e2) {
    this.pt.assign(e2.pt), this.weight = e2.weight, this.rank = e2.rank, this.bBigMove = e2.bBigMove, this.bIsBreak = e2.bIsBreak;
  }
  nextNode() {
    return this.nextInChain ? this.nextInChain.end : null;
  }
  prevNode() {
    return this.prevInChain ? this.prevInChain.start : null;
  }
  equalListHead() {
    let e2 = this;
    for (; null !== e2.prevEqual; e2 = e2.prevEqual) ;
    return e2;
  }
};
function In2(e2, t3, s3, n5) {
  return { edge1: e2, edge2: t3, recursion: s3, bIsIntersecting: n5 };
}
var bn2 = class {
  constructor(e2) {
    this.m_pairs = [], this.m_chainOrigin1 = null, this.m_chainOrigin2 = null, this.m_newNodes = [], this.m_hashTableOfEquals = [], this.m_hashTableOfEqualsSize = 0, this.m_origin = new mi(), this.m_cell = new mi(), this.parent = e2;
  }
  addSegment(e2, t3, s3, n5, r, i2, a2, h2, m3, l2, g2) {
    const u = this.newNode(this.parent.m_resultSegments[e2].get().getStartXY(), s3, n5, m3), c = this.newNode(this.parent.m_resultSegments[e2].get().getEndXY(), r, i2, l2);
    this.newEdge(u, c, e2, a2, h2, g2), null === this.m_chainOrigin1 ? this.m_chainOrigin1 = u : null === this.m_chainOrigin2 ? this.m_chainOrigin2 = u : n(0);
  }
  intersectCurvesHelper(e2, t3, n5, i2, a2) {
    const h2 = this.getSegment(e2).get(), m3 = this.getSegment(t3).get();
    if (h2.isDegenerate(0) || m3.isDegenerate(0)) return 0;
    const l2 = this.tryOverlapIntersectCurves(e2, t3, n5, i2);
    if (0 !== l2) return l2;
    const g2 = H(0.01 * n5);
    let u = false, c = this.processSharpCorners(h2, m3, n5, a2 > 4);
    const _ = c > 0;
    if (!_) {
      if (!(i2 || 5 & om(true, false, h2, m3, n5, true))) return 0;
      c = um(true, h2, m3, null, this.parent.m_param1, this.parent.m_param2, n5);
    }
    0 === c && b("");
    const d2 = h2.getGeometryType(), p3 = m3.getGeometryType(), f3 = Ot(mi, c), x4 = Ot(mi, c), y2 = Yt(c, Number.NaN), P5 = Yt(c, Number.NaN), E2 = Yt(c, Number.NaN), S3 = Yt(c, Number.NaN), C3 = Ut(En2, c), I4 = Ut(En2, c);
    let b2 = false, w4 = false;
    for (let s3 = 0; s3 < c; s3++) {
      const r = this.parent.m_param1[s3], i3 = this.parent.m_param2[s3];
      let o = e2.rank, a3 = e2.weight, l3 = true, c2 = false;
      0 === r ? (o = e2.start.rank, a3 = e2.start.weight, c2 = e2.start.bIsBreak) : 1 === r ? (o = e2.end.rank, a3 = e2.end.weight, c2 = e2.end.bIsBreak) : (b2 = true, l3 = false);
      let v4 = t3.rank, N3 = t3.weight, T4 = false, G5 = true;
      0 === i3 ? (v4 = t3.start.rank, N3 = t3.start.weight, T4 = t3.start.bIsBreak) : 1 === i3 ? (v4 = t3.end.rank, N3 = t3.end.weight, T4 = t3.end.bIsBreak) : (w4 = true, G5 = false);
      let D4 = o, V5 = v4;
      if (D4 === V5 && (D4 *= xn2.c_maxGeometryTypeToRankDelta, V5 *= xn2.c_maxGeometryTypeToRankDelta, D4 += wn2(d2, h2, false), V5 += wn2(p3, m3, false)), l3 && G5 && V5 === D4) {
        const e3 = h2.getCoord2D(r), t4 = m3.getCoord2D(i3);
        e3.equals(t4) && (V5 = D4 - 1);
      }
      let F4 = 1, H4 = 0, k5 = 1, A5 = 0;
      const M2 = new mi(), U4 = new mi(), q2 = h2.getCoord2D(r), B4 = m3.getCoord2D(i3);
      if (_ && mi.distance(q2, B4) > n5) M2.setCoordsPoint2D(q2), U4.setCoordsPoint2D(B4), F4 = a3, k5 = N3, H4 = o, A5 = v4, C3[s3].bBigMove = false, I4[s3].bBigMove = false, c2 = true, T4 = true;
      else if (D4 === V5) {
        k5 = F4 = a3 + N3, A5 = H4 = o;
        Y(q2, B4, N3 / F4, M2), U4.setCoordsPoint2D(M2);
        const e3 = mi.sqrDistance(M2, q2), t4 = mi.sqrDistance(M2, B4);
        C3[s3].bBigMove = e3 > g2, I4[s3].bBigMove = t4 > g2, b2 || q2.equals(M2) || (b2 = true), w4 || B4.equals(U4) || (w4 = true);
      } else if (D4 > V5) {
        M2.setCoordsPoint2D(q2), U4.setCoordsPoint2D(M2), k5 = F4 = a3, A5 = H4 = o;
        const e3 = mi.sqrDistance(M2, B4);
        C3[s3].bBigMove = false, I4[s3].bBigMove = e3 > g2, w4 || B4.equals(U4) || (w4 = true);
      } else {
        U4.setCoordsPoint2D(B4), M2.setCoordsPoint2D(U4), k5 = F4 = N3, A5 = H4 = v4;
        const e3 = mi.sqrDistance(M2, q2);
        C3[s3].bBigMove = e3 > g2, I4[s3].bBigMove = false, b2 || q2.equals(M2) || (b2 = true);
      }
      f3[s3].assign(M2), x4[s3].assign(U4), y2[s3] = F4, P5[s3] = k5, E2[s3] = H4, S3[s3] = A5, C3[s3].bIsBreak = c2 || T4, I4[s3].bIsBreak = c2 || T4, u ||= C3[s3].bBigMove || I4[s3].bBigMove, s3 > 0 && (r !== this.parent.m_param1[s3 - 1] && i3 !== this.parent.m_param2[s3 - 1] || (E2[s3] <= E2[s3 - 1] ? (f3[s3].assign(x4[s3 - 1]), y2[s3] = P5[s3 - 1], E2[s3] = S3[s3 - 1], x4[s3].assign(x4[s3 - 1]), P5[s3] = P5[s3 - 1], S3[s3] = S3[s3 - 1], C3[s3].bBigMove ||= C3[s3 - 1].bBigMove, I4[s3].bBigMove ||= I4[s3 - 1].bBigMove, C3[s3].bIsBreak ||= C3[s3 - 1].bIsBreak, I4[s3].bIsBreak ||= I4[s3 - 1].bIsBreak) : (f3[s3 - 1].assign(f3[s3]), y2[s3 - 1] = y2[s3], E2[s3 - 1] = E2[s3], x4[s3 - 1].assign(x4[s3]), P5[s3 - 1] = P5[s3], S3[s3 - 1] = S3[s3], C3[s3 - 1].bBigMove ||= C3[s3].bBigMove, I4[s3 - 1].bBigMove ||= I4[s3].bBigMove, C3[s3 - 1].bIsBreak ||= C3[s3].bIsBreak, I4[s3 - 1].bIsBreak ||= I4[s3].bIsBreak)));
    }
    if (!(b2 || w4 || 2 !== c || d2 === a.enumLine && p3 === a.enumLine)) {
      if (this.processDoublyConnectedEdges(e2, t3, a2 + 1, n5)) return this.parent.m_changed1 = true, this.parent.m_changed2 = true, 2;
      n(0);
    }
    this.parent.m_changed1 ||= b2, this.parent.m_changed2 ||= w4;
    let v3 = e2, N2 = e2.end.weight, T3 = e2.end.rank, G4 = e2.end.bBigMove, D3 = e2.end.bIsBreak, V4 = 0, F3 = -1;
    for (let s3 = 0; s3 <= c; s3++) {
      const t4 = s3 < c ? this.parent.m_param1[s3] : 1;
      if (t4 !== V4) {
        const r = this.parent.allocResultSegment(), i3 = this.parent.m_resultSegments[r];
        let o, a3, m4, l3;
        h2.queryCut(V4, t4, i3, false), i3.get().snapControlPoints(n5 * n5);
        let g3 = false, u2 = false, _2 = false, d3 = false;
        const p4 = new mi(), x5 = new mi();
        -1 !== F3 ? (a3 = E2[F3], o = y2[F3], _2 = C3[F3].bBigMove, g3 = C3[F3].bIsBreak, p4.assign(f3[F3])) : (o = e2.start.weight, a3 = e2.start.rank, _2 = e2.start.bBigMove, g3 = e2.start.bIsBreak, p4.assign(i3.get().getStartXY())), s3 < c ? (l3 = E2[s3], m4 = y2[s3], d3 = C3[s3].bBigMove, u2 = C3[s3].bIsBreak, x5.assign(f3[s3])) : (m4 = N2, l3 = T3, d3 = G4, u2 = D3, x5.assign(i3.get().getEndXY()));
        let P6 = v3;
        t4 < 1 && (this.splitEdgeInPlace(v3), P6 = v3.getNextInChain()), this.updateSegmentOnly(v3, r), 0 === v3.start.hash || v3.start.pt.equals(p4) || (this.m_newNodes.push(v3.start), this.removeNodeFromHash(v3.start), v3.start.hash = 0), 0 === v3.end.hash || v3.end.pt.equals(x5) || (this.m_newNodes.push(v3.end), this.removeNodeFromHash(v3.end), v3.end.hash = 0), v3.start.pt.assign(p4), v3.end.pt.assign(x5), v3.start.bBigMove ||= _2, v3.end.bBigMove ||= d3, v3.start.bIsBreak ||= g3, v3.end.bIsBreak ||= u2, v3.start.weight = o, v3.start.rank = a3, v3.end.weight = m4, v3.end.rank = l3, v3 = P6, V4 = t4, F3 = s3;
      } else -1 === F3 && (F3 = s3);
    }
    const H3 = v3.getNextInChain(), k4 = [];
    k4.length = c;
    for (let s3 = 0; s3 < c; s3++) k4[s3] = s3;
    c > 2 ? (k4.sort((e3, t4) => Ct(this.parent.m_param2[e3], this.parent.m_param2[t4])), this.parent.m_param2.sort(Ct)) : 2 === c && this.parent.m_param2[0] > this.parent.m_param2[1] && (this.parent.m_param2[1] = Pt(this.parent.m_param2[0], this.parent.m_param2[0] = this.parent.m_param2[1]), k4[1] = Pt(k4[0], k4[0] = k4[1])), v3 = t3, N2 = t3.end.weight, T3 = t3.end.rank, G4 = t3.end.bBigMove, D3 = t3.end.bIsBreak, V4 = 0, F3 = -1;
    for (let s3 = 0; s3 <= c; s3++) {
      const e3 = s3 < c ? this.parent.m_param2[s3] : 1;
      if (e3 !== V4) {
        const r = this.parent.allocResultSegment(), i3 = this.parent.m_resultSegments[r];
        let o, a3, h3, l3;
        m3.queryCut(V4, e3, i3, false), i3.get().snapControlPoints(n5 * n5);
        const g3 = new mi(), u2 = new mi();
        let _2 = false, d3 = false, p4 = false, f4 = false;
        if (-1 !== F3) {
          const e4 = k4[F3];
          o = P5[e4], a3 = S3[e4], g3.assign(x4[e4]), p4 = I4[e4].bBigMove, _2 = I4[e4].bIsBreak;
        } else o = t3.start.weight, a3 = t3.start.rank, p4 = t3.start.bBigMove, _2 = t3.start.bIsBreak, g3.assign(i3.get().getStartXY());
        if (s3 !== c) {
          const e4 = k4[s3];
          h3 = P5[e4], l3 = S3[e4], u2.assign(x4[e4]), f4 = I4[e4].bBigMove, d3 = I4[e4].bIsBreak;
        } else h3 = N2, l3 = T3, f4 = G4, d3 = D3, u2.assign(i3.get().getEndXY());
        let y3 = v3;
        e3 < 1 && (this.splitEdgeInPlace(v3), y3 = v3.getNextInChain()), this.updateSegmentOnly(v3, r), 0 === v3.start.hash || v3.start.pt.equals(g3) || (this.m_newNodes.push(v3.start), this.removeNodeFromHash(v3.start), v3.start.hash = 0), 0 === v3.end.hash || v3.end.pt.equals(u2) || (this.m_newNodes.push(v3.end), this.removeNodeFromHash(v3.end), v3.end.hash = 0), v3.start.pt.assign(g3), v3.end.pt.assign(u2), v3.start.bBigMove ||= p4, v3.end.bBigMove ||= f4, v3.start.bIsBreak ||= _2, v3.end.bIsBreak ||= d3, v3.start.weight = o, v3.start.rank = a3, v3.end.weight = h3, v3.end.rank = l3, v3 = y3, V4 = e3, F3 = s3;
      } else -1 === F3 && (F3 = s3);
    }
    const A4 = v3.getNextInChain();
    return this.postProcessResultPartsForCurves(e2, H3, t3, A4, a2 + 1), u ? 3 : 2;
  }
  intersectCurves(e2, t3) {
    2 !== this.parent.m_inputSegments.length && b(""), this.parent.m_changed1 = false, this.parent.m_changed2 = false, this.parent.m_tolerance = e2, this.m_hashTableOfEqualsSize = 0, this.m_hashTableOfEquals = Vt(16);
    const s3 = n3.constructEmpty();
    for (let r = 0; r < 2; r++) {
      const e3 = this.parent.allocResultSegmentFromSegment(this.parent.m_inputSegments[this.parent.m_inputParts[r].segmentIndex]), t4 = n3.constructEmpty();
      this.parent.m_inputSegments[this.parent.m_inputParts[r].segmentIndex].queryLooseEnvelope(t4), s3.mergeEnvelope2D(t4);
      const n6 = this.parent.m_inputParts[r];
      this.addSegment(e3, 0, n6.weightStart, n6.rankStart, n6.weightEnd, n6.rankEnd, n6.weightInterior, n6.rankInterior, n6.u.bBreakStart, n6.u.bBreakEnd, n6.segmentParentage);
    }
    s3.inflateCoords(100 * e2, 100 * e2), this.m_origin.assign(s3.getLowerLeft()), this.m_cell.setCoords(2 * e2, 2 * e2), this.m_pairs.push(In2(this.m_chainOrigin1.nextInChain, this.m_chainOrigin2.nextInChain, 0, t3));
    let n5 = 0, i2 = true;
    for (; this.m_pairs.length; ) {
      const t4 = this.m_pairs.at(-1);
      this.m_pairs.pop(), n(t4.recursion >= 0), n(t4.recursion <= 256), this.clusterNodes(e2);
      const s4 = this.intersectCurvesHelper(t4.edge1, t4.edge2, e2, t4.bIsIntersecting, t4.recursion);
      i2 && (i2 = false, n5 = s4);
    }
    for (let r = 0; r < 2; r++) {
      const e3 = 0 === r ? this.parent.m_resultParts1 : this.parent.m_resultParts2;
      for (let t4 = (0 === r ? this.m_chainOrigin1 : this.m_chainOrigin2).nextInChain; null != t4; t4 = t4.getNextInChain()) e3.push(this.parent.newIntersectionPart_(t4.segmentIndex, t4.start.weight, t4.start.rank, t4.end.weight, t4.end.rank, t4.weight, t4.rank, t4.start.bIsBreak, t4.end.bIsBreak, t4.segmentParentage)), e3.at(-1).u.bBigMoveStart = t4.start.bBigMove, e3.at(-1).u.bBigMoveEnd = t4.end.bBigMove;
    }
    return n5;
  }
  tryOverlapIntersectCurves(e2, t3, s3, n5) {
    const r = this.parent.m_resultSegments[e2.segmentIndex].get(), i2 = this.parent.m_resultSegments[t3.segmentIndex].get(), a2 = r.getStartXY().equals(i2.getStartXY()) && r.getEndXY().equals(i2.getEndXY()), h2 = r.getStartXY().equals(i2.getEndXY()) && r.getEndXY().equals(i2.getStartXY());
    if (!a2 && !h2) return 0;
    const m3 = am(r, i2, true);
    if (0 !== m3 && hm(r, i2) && e2.segmentParentage === t3.segmentParentage) {
      let e3 = false;
      if (m3 > 0) e3 = r.equals(i2);
      else {
        n(-1 === m3);
        const t4 = new fm({ segment: i2 });
        t4.get().reverse(), e3 = r.equals(t4.get());
      }
      if (e3) return 1;
    }
    const l2 = s3 * xn2.c_smallToleranceFactor;
    let g2 = false;
    if (0 === m3) {
      const e3 = [0.5, 0.25, 0.75, 0.125, 0.375, 0.625, 0.875, 0.5625, 0.3125];
      for (let t4 = 0, n6 = e3.length; t4 < n6; ++t4) {
        const n7 = e3[t4], o = new mi();
        r.queryCoord2D(n7, o);
        const a3 = i2.getClosestCoordinate(o, false), h3 = new mi();
        i2.queryCoord2D(a3, h3);
        const m4 = mi.distance(o, h3);
        if (m4 > s3) return 0;
        g2 ||= m4 > l2;
      }
      for (let t4 = 0, n6 = e3.length; t4 < n6; ++t4) {
        const n7 = e3[t4], o = new mi();
        i2.queryCoord2D(n7, o);
        const a3 = r.getClosestCoordinate(o, false), h3 = new mi();
        r.queryCoord2D(a3, h3);
        const m4 = mi.distance(o, h3);
        if (m4 > s3) return 0;
        g2 ||= m4 > l2;
      }
    }
    let u = e2.rank, c = t3.rank;
    return u === c && (u *= xn2.c_maxGeometryTypeToRankDelta, c *= xn2.c_maxGeometryTypeToRankDelta, u += wn2(r.getGeometryType(), r, true), c += wn2(i2.getGeometryType(), i2, true)), u > c ? (t3.copyFromWhenOverlap(this, e2, a2), t3.transferAttributes(this, r, a2)) : c > u ? (e2.copyFromWhenOverlap(this, t3, a2), e2.transferAttributes(this, i2, a2)) : e2.segmentParentage <= t3.segmentParentage ? (e2.weight = e2.weight + t3.weight, t3.copyFromWhenOverlap(this, e2, a2), t3.transferAttributes(this, r, a2)) : (t3.weight = e2.weight + t3.weight, e2.copyFromWhenOverlap(this, t3, a2), e2.transferAttributes(this, i2, a2)), g2 ? 3 : 2;
  }
  postProcessResultPartsForCurves(e2, t3, s3, n5, i2) {
    i2 === bs() && b("curve_helper");
    for (let r = e2; r !== t3; r = r.getNextInChain()) this.updateSegmentToNodes(r);
    for (let r = s3; r !== n5; r = r.getNextInChain()) this.updateSegmentToNodes(r);
    for (let o = e2; o !== t3; o = o.getNextInChain()) {
      const e3 = o.end.pt.sub(o.start.pt);
      for (let t4 = s3; t4 !== n5; t4 = t4.getNextInChain()) {
        let s4 = 0;
        if (o.start.pt.equals(t4.start.pt) && o.end.pt.equals(t4.end.pt) ? s4 = 1 : o.start.pt.equals(t4.end.pt) && o.end.pt.equals(t4.start.pt) && (s4 = -1), !s4) {
          let s5 = o.start.pt.equals(t4.start.pt) ? 1 : 0;
          if (s5 || (s5 = o.end.pt.equals(t4.end.pt) ? 2 : 0, s5 || (s5 = o.end.pt.equals(t4.start.pt) ? 3 : 0, s5 || (s5 = o.start.pt.equals(t4.end.pt) ? 4 : 0))), s5) {
            const n7 = t4.end.pt.sub(t4.start.pt), a3 = e3.dotProduct(n7);
            let h3;
            switch (s5) {
              case 1:
              case 2:
                h3 = a3 > 0;
                break;
              case 3:
              case 4:
                h3 = a3 < 0;
                break;
              default:
                b("post_process_result_parts_for_curves_");
            }
            h3 && this.m_pairs.push(In2(o, t4, i2, false));
          }
          continue;
        }
        const n6 = this.parent.m_resultSegments[o.segmentIndex], a2 = this.parent.m_resultSegments[t4.segmentIndex], h2 = [0.5, 0.25, 0.75];
        for (let e4 = 0, t5 = h2.length; e4 < t5; ++e4) {
          const t6 = h2[e4], r = new mi();
          n6.get().queryCoord2D(t6, r);
          const i3 = a2.get().getClosestCoordinate(r, false), o2 = new mi();
          a2.get().queryCoord2D(i3, o2);
          if (mi.distance(r, o2) > this.parent.m_tolerance) {
            s4 = 0;
            break;
          }
        }
        if (!s4) {
          this.m_pairs.push(In2(o, t4, i2, false));
          continue;
        }
        for (let e4 = 0, t5 = h2.length; e4 < t5; ++e4) {
          const t6 = h2[e4], r = new mi();
          a2.get().queryCoord2D(t6, r);
          const i3 = n6.get().getClosestCoordinate(r, false), o2 = new mi();
          n6.get().queryCoord2D(i3, o2);
          if (mi.distance(r, o2) > this.parent.m_tolerance) {
            s4 = 0;
            break;
          }
        }
        if (!s4) {
          this.m_pairs.push(In2(o, t4, i2, false));
          continue;
        }
        o.equalEdge = t4, t4.equalEdge = o;
        let m3 = o.rank, l2 = t4.rank;
        m3 === l2 && (m3 *= xn2.c_maxGeometryTypeToRankDelta, l2 *= xn2.c_maxGeometryTypeToRankDelta, m3 += wn2(n6.get().getGeometryType(), n6.get(), true), l2 += wn2(a2.get().getGeometryType(), a2.get(), true)), m3 > l2 || m3 === l2 && o.segmentParentage <= t4.segmentParentage ? (n6.copyTo(a2, false), t4.segmentParentage = o.segmentParentage, -1 === s4 && a2.get().reverse()) : (a2.copyTo(n6, false), o.segmentParentage = t4.segmentParentage, -1 === s4 && n6.get().reverse());
        break;
      }
    }
    this.updateAttachedEdgesAfterNodeChange(e2.start), t3 && this.updateAttachedEdgesAfterNodeChange(t3.start), this.updateAttachedEdgesAfterNodeChange(s3.start), n5 && this.updateAttachedEdgesAfterNodeChange(n5.start);
  }
  processDoublyConnectedEdges(e2, t3, s3, n5) {
    s3 === bs() && b("curve_helper");
    const i2 = this.getSegment(e2).get(), o = this.getSegment(t3).get(), a2 = i2.getStartXY().equals(o.getStartXY()) && i2.getEndXY().equals(o.getEndXY()) ? 1 : i2.getEndXY().equals(o.getStartXY()) && i2.getStartXY().equals(o.getEndXY()) ? -1 : 0;
    if (0 !== a2) {
      const r = new fm();
      i2.queryCut(0, 0.5, r), r.get().snapControlPoints(n5 * n5);
      const h2 = new fm();
      i2.queryCut(0.5, 1, h2), h2.get().snapControlPoints(n5 * n5), this.splitEdgeInPlace(e2), e2.end.pt = r.get().getEndXY(), e2.segmentIndex = this.parent.allocResultSegmentFromBuffer(r), e2.getNextInChain().segmentIndex = this.parent.allocResultSegmentFromBuffer(h2);
      let m3 = o.getClosestCoordinate(e2.end.pt, false);
      return Math.abs(m3 - 0.5) > 0.2 && (m3 = 0.5), o.queryCut(0, m3, r), r.get().snapControlPoints(n5 * n5), o.queryCut(m3, 1, h2), h2.get().snapControlPoints(n5 * n5), this.splitEdgeInPlace(t3), t3.end.pt = r.get().getEndXY(), t3.segmentIndex = this.parent.allocResultSegmentFromBuffer(r), t3.getNextInChain().segmentIndex = this.parent.allocResultSegmentFromBuffer(h2), a2 > 0 ? (this.m_pairs.push(In2(e2, t3, s3, false)), this.m_pairs.push(In2(e2.getNextInChain(), t3.getNextInChain(), s3, false))) : (this.m_pairs.push(In2(e2, t3.getNextInChain(), s3, false)), this.m_pairs.push(In2(e2.getNextInChain(), t3, s3, false))), true;
    }
    return false;
  }
  newNode(e2, t3, s3, n5) {
    const r = new Cn2();
    return this.m_newNodes.push(r), r.pt = e2, r.rank = s3, r.weight = t3, r.bIsBreak = n5, r;
  }
  newEdge(e2, t3, s3, n5, r, i2) {
    const o = new Sn2();
    return o.start = e2, o.end = t3, e2.nextInChain = o, t3.prevInChain = o, o.segmentIndex = s3, o.segmentParentage = i2, o.rank = r, o.weight = n5, o;
  }
  splitEdgeInPlace(e2) {
    e2.segmentIndex = -1;
    const t3 = new Sn2(), s3 = new Cn2();
    this.m_newNodes.push(s3), s3.pt.setNAN(), s3.nextInChain = t3, s3.prevInChain = e2, s3.prevInHash = null, s3.nextInHash = null, s3.prevEqual = null, s3.nextEqual = null, s3.weight = e2.weight, s3.rank = e2.rank, s3.bIsBreak = false, s3.bBigMove = false, t3.start = s3, t3.segmentIndex = -1, t3.end = e2.end, t3.end.prevInChain = t3, t3.rank = e2.rank, t3.weight = e2.weight, t3.segmentParentage = e2.segmentParentage, e2.end = s3, e2.equalEdge && (e2.equalEdge.equalEdge = null), e2.equalEdge = null;
  }
  updateSegmentOnly(e2, t3) {
    e2.segmentIndex = t3;
  }
  updateAttachedEdgesAfterNodeChange(e2) {
    for (let t3 = e2.equalListHead(); null !== t3; t3 = t3.nextEqual) this.updateAttachedEdgesAfterNodeChangeImpl(t3);
  }
  updateAttachedEdgesAfterNodeChangeImpl(e2) {
    const t3 = e2.prevInChain;
    if (t3 && t3.hasSegment()) {
      const s4 = this.getSegment(t3).get();
      e2.pt.equals(s4.getEndXY()) || (s4.setCoordsForIntersector(t3.start.pt, t3.end.pt, false), s4.ensureXYMonotone());
    }
    const s3 = e2.nextInChain;
    if (s3 && s3.hasSegment()) {
      const t4 = this.getSegment(s3).get();
      e2.pt.equals(t4.getStartXY()) || (t4.setCoordsForIntersector(s3.start.pt, s3.end.pt, false), t4.ensureXYMonotone());
    }
  }
  updateSegmentToNodes(e2) {
    const t3 = this.getSegment(e2).get();
    e2.start.pt.equals(t3.getStartXY()) && e2.end.pt.equals(t3.getEndXY()) || (t3.setCoordsForIntersector(e2.start.pt, e2.end.pt, false), t3.ensureXYMonotone()), this.updateAttachedEdgesAfterNodeChange(e2.start), this.updateAttachedEdgesAfterNodeChange(e2.end);
  }
  getSegment(e2) {
    return this.parent.m_resultSegments[e2.segmentIndex];
  }
  clusterNodes(e2) {
    let t3 = false;
    const s3 = [], n5 = [], r = [];
    for (let i2 = 0, o = this.m_newNodes.length; i2 < o; i2++) {
      const e3 = this.m_newNodes[i2];
      if (null === e3) continue;
      let t4 = e3;
      for (let s4 = i2 + 1; s4 < o; s4++) {
        const n6 = this.m_newNodes[s4];
        null !== n6 && (e3.pt.equals(n6.pt) && (t4.nextInHash = n6, n6.prevInHash = t4, t4 = n6, this.m_newNodes[s4] = null));
      }
    }
    for (let i2 = 0, o = this.m_newNodes.length; i2 < o; i2++) {
      const o2 = this.m_newNodes[i2];
      if (null == o2) continue;
      for (o2.hash = this.calculateHash(o2.pt); ; ) {
        const i3 = Vt(4), a3 = this.hashTableBinsToCheck(o2, i3);
        for (let t4 = 0; t4 < a3; t4++) if (null !== i3[t4]) for (let a4 = i3[t4]; null !== a4; ) {
          const t5 = a4.nextInHash;
          mi.distance(o2.pt, a4.pt) <= e2 && (s3.push(a4), this.removeNodeFromHash(a4), a4.hash = 0, r.push(a4), n5.push(a4)), a4 = t5;
        }
        let h3 = false;
        for (const e3 of s3) if (!o2.pt.equals(e3.pt)) {
          const s4 = un2(o2.pt, e3.pt, o2.weight, o2.rank, e3.weight, e3.rank);
          o2.pt.assign(s4.pt), o2.weight = s4.weight, o2.rank = s4.rank, h3 = true, t3 = true;
        }
        if (s3.length = 0, !h3) break;
        o2.hash = this.calculateHash(o2.pt);
      }
      r.push(o2), n5.push(o2);
      for (let e3 = o2.nextInHash; null !== e3; ) {
        e3.prevInHash = null;
        const t4 = e3.nextInHash;
        e3.nextInHash = null, r.push(e3), n5.push(e3), e3 = t4;
      }
      const a2 = o2.hash;
      let h2 = null, m3 = null;
      for (const e3 of n5) o2 !== e3 && (e3.hash = a2, e3.pt.assign(o2.pt), e3.rank = o2.rank, e3.weight = o2.weight), e3.prevInHash = h2, h2 && (h2.nextInHash = e3), e3.prevEqual = m3, e3.nextEqual = null, m3 && (m3.nextEqual = e3), m3 = e3, h2 = e3;
      const l2 = a2 % this.m_hashTableOfEquals.length;
      h2.nextInHash = this.m_hashTableOfEquals[l2], null !== this.m_hashTableOfEquals[l2] && (this.m_hashTableOfEquals[l2].prevInHash = h2), this.m_hashTableOfEquals[l2] = n5[0], this.m_hashTableOfEqualsSize += n5.length, n5.length = 0, this.rehashIfNeeded();
    }
    if (this.m_newNodes.length = 0, t3) for (const i2 of r) this.updateAttachedEdgesAfterNodeChange(i2);
  }
  rehashIfNeeded() {
    if (2 * this.m_hashTableOfEqualsSize > this.m_hashTableOfEquals.length) {
      const e2 = this.m_hashTableOfEquals;
      this.m_hashTableOfEquals = Vt(2 * e2.length), this.m_hashTableOfEqualsSize = 0;
      for (const t3 of e2) {
        let e3 = t3;
        for (; e3; ) {
          const t4 = e3.nextInHash;
          e3.nextInHash = null, e3.prevInHash = null, this.addNodeToHashImpl(e3), e3 = t4;
        }
      }
    }
  }
  addNodeToHashImpl(e2) {
    const t3 = e2.hash % this.m_hashTableOfEquals.length, s3 = this.m_hashTableOfEquals[t3];
    e2.nextInHash = s3, null !== s3 && (s3.prevInHash = e2), this.m_hashTableOfEquals[t3] = e2, this.m_hashTableOfEqualsSize++;
  }
  removeNodeFromHash(e2) {
    const t3 = e2.hash % this.m_hashTableOfEquals.length, s3 = e2.prevInHash, n5 = e2.nextInHash;
    s3 ? s3.nextInHash = n5 : this.m_hashTableOfEquals[t3] = n5, n5 && (n5.prevInHash = s3), this.m_hashTableOfEqualsSize--, e2.prevInHash = null, e2.nextInHash = null;
  }
  hashTableBinsToCheck(e2, t3) {
    const s3 = (e2.pt.x - this.m_origin.x) / this.m_cell.x, n5 = (e2.pt.y - this.m_origin.y) / this.m_cell.y, r = ds() - 1, i2 = Math.round(Us(s3, -2147483646, r)), o = Math.round(Us(n5, -2147483646, r));
    let a2 = i2 | o << 32;
    a2 = Zs(a2), t3[0] = this.m_hashTableOfEquals[a2 % this.m_hashTableOfEquals.length];
    let h2 = i2 + 1 | o << 32;
    h2 = Zs(h2);
    let m3 = 1;
    t3[1] = this.m_hashTableOfEquals[h2 % this.m_hashTableOfEquals.length], t3[1] !== t3[0] && (m3 = 2);
    let l2 = i2 + 1 | o + 1 << 32;
    l2 = Zs(l2), t3[m3] = this.m_hashTableOfEquals[l2 % this.m_hashTableOfEquals.length];
    for (let u = 0; u < m3; u++) if (t3[m3] === t3[u]) {
      m3--;
      break;
    }
    m3++;
    let g2 = i2 | o + 1 << 32;
    g2 = Zs(g2), t3[m3] = this.m_hashTableOfEquals[g2 % this.m_hashTableOfEquals.length];
    for (let u = 0; u < m3; u++) if (t3[m3] === t3[u]) {
      m3--;
      break;
    }
    return m3++, m3;
  }
  calculateHash(e2) {
    const t3 = (e2.x - this.m_origin.x) / this.m_cell.x, s3 = (e2.y - this.m_origin.y) / this.m_cell.y, n5 = ds() - 1;
    let r = Math.round(Us(t3, -2147483646, n5)) | Math.round(Us(s3, -2147483646, n5)) << 32;
    return r = Zs(r), 0 === r && (r = 1), r;
  }
  processSharpCorners(e2, t3, s3, n5) {
    if (this.parent.m_param1.length = 0, this.parent.m_param2.length = 0, e2.getStartXY().equals(t3.getStartXY())) {
      const r = [0, 0], i2 = [0, 0], o = gm(e2, t3, 0, 0, s3, 2, r, i2, n5);
      if (o) {
        this.parent.m_param1.push(0), this.parent.m_param2.push(0);
        for (let e3 = 0; e3 < o; e3++) this.parent.m_param1.push(r[e3]), this.parent.m_param2.push(i2[e3]);
        return o + 1;
      }
    }
    if (e2.getEndXY().equals(t3.getEndXY())) {
      const r = [0, 0], i2 = [0, 0], o = gm(e2, t3, 1, 1, s3, 2, r, i2, n5);
      if (o) {
        for (let e3 = 0; e3 < o; e3++) this.parent.m_param1.push(r[e3]), this.parent.m_param2.push(i2[e3]);
        return this.parent.m_param1.push(1), this.parent.m_param2.push(1), o + 1;
      }
    }
    if (e2.getStartXY().equals(t3.getEndXY())) {
      const r = [0, 0], i2 = [0, 0], o = gm(e2, t3, 0, 1, s3, 2, r, i2, n5);
      if (o) {
        this.parent.m_param1.push(0), this.parent.m_param2.push(1);
        for (let e3 = 0; e3 < o; e3++) this.parent.m_param1.push(r[e3]), this.parent.m_param2.push(i2[e3]);
        return o + 1;
      }
    }
    if (e2.getEndXY().equals(t3.getStartXY())) {
      const r = [0, 0], i2 = [0, 0], o = gm(e2, t3, 1, 0, s3, 2, r, i2, n5);
      if (o) {
        for (let e3 = 0; e3 < o; e3++) this.parent.m_param1.push(r[e3]), this.parent.m_param2.push(i2[e3]);
        return this.parent.m_param1.push(1), this.parent.m_param2.push(0), o + 1;
      }
    }
    return 0;
  }
};
function wn2(e2, t3, n5) {
  let i2 = 0;
  switch (e2) {
    case a.enumLine:
      i2 = 0;
      break;
    case a.enumBezier:
      i2 = 2;
      break;
    case a.enumRationalBezier2:
      i2 = 3;
      break;
    case a.enumBezier2:
      i2 = 1;
      break;
    case a.enumEllipticArc:
      i2 = 0 === t3.projectionBehavior() ? 5 : 4;
      break;
    default:
      b("");
  }
  return n5 ? 5 - i2 : i2;
}
var vn2 = class extends on2 {
  constructor(e2) {
    super(e2.m_shape, e2.m_tolerance, false), this.m_parent = e2;
  }
  compare(e2, t3, s3) {
    if (this.m_bIntersectionDetected) return -1;
    const n5 = e2.getElement(s3), r = this.m_parent.getEdgeOriginVertices(t3), i2 = this.m_parent.m_edgeVertices.getFirstElement(r), o = this.m_parent.getEdgeOriginVertices(n5), a2 = this.m_parent.m_edgeVertices.getFirstElement(o);
    return this.m_currentNode = s3, this.compareSegments(t3, i2, n5, a2);
  }
};
var Nn2 = class extends an2 {
  constructor(e2) {
    super(e2.m_shape, e2.m_tolerance), this.m_parent = e2;
  }
  compare(e2, t3) {
    if (this.m_bIntersectionDetected) return -1;
    const s3 = e2.getElement(t3), n5 = this.m_parent.getEdgeOriginVertices(s3), r = this.m_parent.m_edgeVertices.getFirstElement(n5);
    return this.m_currentNode = t3, this.compareVertex(e2, t3, r);
  }
};
var Tn2 = class extends dt {
  constructor(e2) {
    super(), this.pt1 = mi.getNAN(), this.pt2 = mi.getNAN(), this.m_shape = e2;
  }
  compare(e2, t3, s3) {
    this.m_shape.queryXY(t3, this.pt1);
    const n5 = e2.getElement(s3);
    return this.m_shape.queryXY(n5, this.pt2), this.pt1.compare(this.pt2);
  }
};
var Gn2 = class {
  constructor(e2) {
    this.m_point = mi.getNAN(), this.m_pt = mi.getNAN(), this.m_shape = e2;
  }
  setPoint(e2) {
    this.m_point.setCoordsPoint2D(e2);
  }
  compare(e2, t3) {
    const s3 = e2.getElement(t3);
    return this.m_shape.queryXY(s3, this.m_pt), this.m_point.compare(this.m_pt);
  }
};
var Dn2 = class {
  constructor(e2, t3) {
    this.m_shape = null, this.m_progressTracker = null, this.m_edges = new at(8), this.m_clusters = new at(5), this.m_clusterVertices = new sn2(false), this.m_edgeVertices = new sn2(false), this.m_helperPoint = new ee(), this.m_eventQ = new ct2(), this.m_sweepStructure = new ct2(), this.m_bComplications = false, this.m_sweepComparator = null, this.m_tempEdgeBuffer = [], this.m_modifiedClusters = [], this.m_edgesToInsertInSweepStructure = [], this.m_prevNeighbour = -1, this.m_nextNeighbour = -1, this.m_bContinuingSegmentChainOptimization = false, this.m_progressCounter = 0, this.m_segmentIntersector = new xn2(), this.m_segBuf1 = new fm(), this.m_segBuf2 = new fm(), this.m_sweepPoint = new mi(0, 0), this.m_tolerance = 0, this.m_toleranceSqr = 0, this.m_sweepPointCluster = -1, this.m_vertexClusterIndex = -1, this.m_bCracked = false, this.m_bSweepPointClusterWasModified = false, this.m_progressTracker = e2, this.m_bTrackChanges = t3;
  }
  hadComplications() {
    return this.m_bComplications;
  }
  sweep(e2, t3) {
    const s3 = new x3();
    s3.setSwapCoordinates(), e2.applyTransformation(s3), this.setEditShape_(e2), this.m_bCracked = false, this.m_tolerance = t3, this.m_toleranceSqr = t3 * t3;
    let n5 = this.sweepImpl_();
    return e2.applyTransformation(s3), n5 || (this.fillEventQueuePass2(), n5 = this.sweepImpl_() || n5), this.m_shape.removeUserIndex(this.m_vertexClusterIndex), this.m_shape = null, this.m_bCracked;
  }
  sweepVertical(e2, t3) {
    this.setEditShape_(e2), this.m_bCracked = false, this.m_tolerance = t3, this.m_toleranceSqr = t3 * t3, this.m_bComplications = false;
    let s3 = this.sweepImpl_();
    if (!this.m_bComplications) {
      const n5 = e2.filterClosePoints(t3, true, false, this.m_bTrackChanges, cr);
      this.m_bComplications = 1 === n5, s3 ||= 1 === n5;
    }
    return -1 !== this.m_vertexClusterIndex && (this.m_shape.removeUserIndex(this.m_vertexClusterIndex), this.m_vertexClusterIndex = -1), this.m_shape = null, s3;
  }
  getEdgeCluster(e2, t3) {
    return this.m_edges.getField(e2, 0 + t3);
  }
  setEdgeCluster_(e2, t3, s3) {
    this.m_edges.setField(e2, 0 + t3, s3);
  }
  getEdgeOriginVertices(e2) {
    return this.m_edges.getField(e2, 2);
  }
  setEdgeOriginVertices_(e2, t3) {
    this.m_edges.setField(e2, 2, t3);
  }
  getNextEdgeEx(e2, t3) {
    return this.m_edges.getField(e2, 3 + t3);
  }
  setNextEdgeEx_(e2, t3, s3) {
    this.m_edges.setField(e2, 3 + t3, s3);
  }
  getEdgeSweepNode(e2) {
    return this.m_edges.getField(e2, 7);
  }
  setEdgeSweepNode_(e2, t3) {
    this.m_edges.setField(e2, 7, t3);
  }
  getNextEdge(e2, t3) {
    const s3 = this.getEdgeEnd(e2, t3);
    return this.m_edges.getField(e2, 3 + s3);
  }
  setNextEdge_(e2, t3, s3) {
    const n5 = this.getEdgeEnd(e2, t3);
    this.m_edges.setField(e2, 3 + n5, s3);
  }
  getPrevEdge(e2, t3) {
    const s3 = this.getEdgeEnd(e2, t3);
    return this.m_edges.getField(e2, 5 + s3);
  }
  setPrevEdge_(e2, t3, s3) {
    const n5 = this.getEdgeEnd(e2, t3);
    this.m_edges.setField(e2, 5 + n5, s3);
  }
  getClusterVertices(e2) {
    return this.m_clusters.getField(e2, 0);
  }
  setClusterVertices_(e2, t3) {
    this.m_clusters.setField(e2, 0, t3);
  }
  getClusterSweepEdgeList(e2) {
    return this.m_clusters.getField(e2, 2);
  }
  setClusterSweepEdgeList_(e2, t3) {
    this.m_clusters.setField(e2, 2, t3);
  }
  getClusterFirstEdge(e2) {
    return this.m_clusters.getField(e2, 1);
  }
  setClusterFirstEdge_(e2, t3) {
    this.m_clusters.setField(e2, 1, t3);
  }
  getClusterEventQNode(e2) {
    return this.m_clusters.getField(e2, 3);
  }
  setClusterEventQNode_(e2, t3) {
    this.m_clusters.setField(e2, 3, t3);
  }
  newCluster_(e2) {
    const t3 = this.m_clusters.newElement(), s3 = this.m_clusterVertices.createList();
    return this.setClusterVertices_(t3, s3), e2 !== cr && (this.m_clusterVertices.addElement(s3, e2), this.m_shape.setUserIndex(e2, this.m_vertexClusterIndex, t3)), t3;
  }
  deleteCluster_(e2) {
    this.m_clusters.deleteElement(e2);
  }
  addVertexToCluster_(e2, t3) {
    const s3 = this.getClusterVertices(e2);
    this.m_clusterVertices.addElement(s3, t3), this.m_shape.setUserIndex(t3, this.m_vertexClusterIndex, e2);
  }
  newEdge_(e2) {
    const t3 = this.m_edges.newElement(), s3 = this.m_edgeVertices.createList();
    return this.setEdgeOriginVertices_(t3, s3), -1 !== e2 && this.m_edgeVertices.addElement(s3, e2), t3;
  }
  addVertexToEdge_(e2, t3) {
    const s3 = this.getEdgeOriginVertices(e2);
    this.m_edgeVertices.addElement(s3, t3);
  }
  deleteEdge_(e2) {
    this.m_edges.deleteElement(e2);
    const t3 = this.m_edgesToInsertInSweepStructure.findIndex((t4) => t4 === e2);
    t3 >= 0 && St(this.m_edgesToInsertInSweepStructure, t3);
  }
  addEdgeToCluster(e2, t3) {
    -1 === this.getEdgeCluster(e2, 0) ? this.setEdgeCluster_(e2, 0, t3) : -1 === this.getEdgeCluster(e2, 1) ? this.setEdgeCluster_(e2, 1, t3) : b(""), this.addEdgeToClusterImpl_(e2, t3);
  }
  addEdgeToClusterImpl_(e2, t3) {
    const s3 = this.getClusterFirstEdge(t3);
    if (-1 !== s3) {
      const n5 = this.getNextEdge(s3, t3);
      this.setPrevEdge_(n5, t3, e2), this.setNextEdge_(e2, t3, n5), this.setNextEdge_(s3, t3, e2), this.setPrevEdge_(e2, t3, s3);
    } else this.setPrevEdge_(e2, t3, e2), this.setNextEdge_(e2, t3, e2), this.setClusterFirstEdge_(t3, e2);
  }
  getEdgeEnd(e2, t3) {
    return this.getEdgeCluster(e2, 0) === t3 ? 0 : 1;
  }
  mergeClusters_(e2, t3) {
    this.dbgCheckCluster_(e2), this.dbgCheckCluster_(t3);
    const s3 = this.getClusterEventQNode(t3);
    -1 !== s3 && (this.m_eventQ.deleteNode(s3), this.setClusterEventQNode_(t3, -1));
    let n5 = this.getClusterFirstEdge(e2), r = this.getClusterFirstEdge(t3);
    if (-1 !== r) {
      let s4 = r, i3 = r, o2 = false;
      do {
        this.dbgCheckEdge_(s4), o2 = false;
        const n6 = this.getEdgeEnd(s4, t3), a2 = this.getNextEdgeEx(s4, n6);
        if (this.getEdgeCluster(s4, n6 + 1 & 1) === e2) {
          this.disconnectEdge_(s4);
          const e3 = this.getEdgeOriginVertices(s4);
          if (this.m_edgeVertices.deleteList(e3), this.deleteEdge_(s4), s4 === a2) {
            r = -1;
            break;
          }
          r === s4 && (r = this.getClusterFirstEdge(t3), i3 = a2, o2 = true);
        }
        s4 = a2;
      } while (s4 !== i3 || o2);
      if (-1 !== r) {
        do {
          const n6 = this.getEdgeEnd(s4, t3), r2 = this.getNextEdgeEx(s4, n6);
          this.setEdgeCluster_(s4, n6, e2), s4 = r2;
        } while (s4 !== i3);
        if (n5 = this.getClusterFirstEdge(e2), -1 !== n5) {
          const t4 = this.getNextEdge(n5, e2), s5 = this.getNextEdge(r, e2);
          t4 === n5 ? (this.setClusterFirstEdge_(e2, r), this.addEdgeToClusterImpl_(n5, e2), this.setClusterFirstEdge_(e2, n5)) : s5 === r && this.addEdgeToClusterImpl_(r, e2), this.setNextEdge_(r, e2, t4), this.setPrevEdge_(t4, e2, r), this.setNextEdge_(n5, e2, s5), this.setPrevEdge_(s5, e2, n5);
        } else this.setClusterFirstEdge_(e2, r);
      }
    }
    const i2 = this.getClusterVertices(e2), o = this.getClusterVertices(t3);
    for (let a2 = this.m_clusterVertices.getFirst(o); -1 !== a2; a2 = this.m_clusterVertices.getNext(a2)) {
      const t4 = this.m_clusterVertices.getElement(a2);
      this.m_shape.setUserIndex(t4, this.m_vertexClusterIndex, e2);
    }
    this.m_clusterVertices.concatenateLists(i2, o), this.deleteCluster_(t3), this.dbgCheckCluster_(e2);
  }
  mergeEdges_(e2, t3) {
    this.dbgCheckEdge_(e2), this.dbgCheckEdge_(t3);
    const s3 = this.getEdgeCluster(e2, 0), n5 = this.getEdgeCluster(e2, 1), r = this.getEdgeCluster(t3, 0), i2 = this.getEdgeCluster(t3, 1), o = this.getEdgeOriginVertices(e2), a2 = this.getEdgeOriginVertices(t3);
    if (this.m_edgeVertices.concatenateLists(o, a2), t3 === this.getClusterFirstEdge(s3) && this.setClusterFirstEdge_(s3, e2), t3 === this.getClusterFirstEdge(n5) && this.setClusterFirstEdge_(n5, e2), this.disconnectEdge_(t3), this.deleteEdge_(t3), !(s3 === r && n5 === i2 || n5 === r && s3 === i2)) {
      const e3 = this.getClusterXY(s3), t4 = this.getClusterXY(r);
      e3.isEqualPoint2D(t4) ? (s3 !== r && this.mergeClusters_(s3, r), n5 !== i2 && this.mergeClusters_(n5, i2)) : (n5 !== r && this.mergeClusters_(n5, r), s3 !== i2 && this.mergeClusters_(s3, i2));
    }
    this.dbgCheckEdge_(e2);
  }
  disconnectEdge_(e2) {
    const t3 = this.getEdgeCluster(e2, 0), s3 = this.getEdgeCluster(e2, 1);
    this.disconnectEdgeFromCluster_(e2, t3), this.disconnectEdgeFromCluster_(e2, s3);
  }
  disconnectEdgeFromCluster_(e2, t3) {
    const s3 = this.getNextEdge(e2, t3), n5 = this.getPrevEdge(e2, t3), r = this.getClusterFirstEdge(t3);
    s3 !== e2 ? (this.setNextEdge_(n5, t3, s3), this.setPrevEdge_(s3, t3, n5), r === e2 && this.setClusterFirstEdge_(t3, s3)) : this.setClusterFirstEdge_(t3, -1);
  }
  applyIntersectorToEditShape_(e2, t3, s3) {
    let n5 = this.m_edgeVertices.getFirst(e2);
    const r = this.m_edgeVertices.getElement(n5), i2 = this.getClusterFromVertex(r), o = this.m_shape.getNextVertex(r), a2 = this.getClusterFromVertex(o), h2 = this.m_shape.getXY(r), m3 = this.m_shape.getXY(o);
    let l2 = false, g2 = false;
    const u = t3.getResultSegment(s3, 0).getStartXY(), c = t3.getResultSegment(s3, t3.getResultSegmentCount(s3) - 1).getEndXY();
    h2.equals(u) || (l2 = true), m3.equals(c) || (g2 = true), this.m_shape.splitSegmentWithIntersector(r, t3, s3, true, true);
    const _ = this.m_bTrackChanges && t3.getSegmentChanged(s3);
    for (_ && this.m_shape.setGeometryModifiedWithVertex(r, true), n5 = this.m_edgeVertices.getNext(n5); -1 !== n5; n5 = this.m_edgeVertices.getNext(n5)) {
      const e3 = this.m_edgeVertices.getElement(n5), r2 = this.getClusterFromVertex(e3) === i2;
      this.m_shape.splitSegmentWithIntersector(e3, t3, s3, r2, true), _ && this.m_shape.setGeometryModifiedWithVertex(e3, true);
    }
    if (l2 && this.updateClusterXY(true, i2, u, t3.getResultSegmentStartPointWeight(s3, 0), t3.getResultSegmentStartPointRank(s3, 0)), g2) {
      const e3 = t3.getResultSegmentCount(s3) - 1;
      this.updateClusterXY(true, a2, c, t3.getResultSegmentEndPointWeight(s3, e3), t3.getResultSegmentEndPointRank(s3, e3));
    }
  }
  createEdgesAndClustersFromSplitEdge_(e2, t3, s3) {
    this.dbgCheckNewEdgesArray_();
    const n5 = this.getEdgeOriginVertices(e2), r = this.getEdgeCluster(e2, 0), i2 = this.getEdgeCluster(e2, 1);
    let o = this.newEdge_(-1);
    this.m_edgesToInsertInSweepStructure.push(o);
    const a2 = at.impossibleIndex3();
    this.setEdgeSweepNode_(o, a2), this.m_tempEdgeBuffer.push(o), this.addEdgeToCluster(o, r);
    const h2 = t3.getResultSegmentCount(s3);
    for (let m3 = 1; m3 < h2; m3++) {
      const e3 = this.newCluster_(-1);
      this.m_modifiedClusters.push(e3), this.m_tempEdgeBuffer.push(e3), this.addEdgeToCluster(o, e3);
      const t4 = this.newEdge_(-1);
      this.m_edgesToInsertInSweepStructure.push(t4), this.setEdgeSweepNode_(t4, a2), this.m_tempEdgeBuffer.push(t4), this.addEdgeToCluster(t4, e3), o = t4;
    }
    this.addEdgeToCluster(o, i2);
    for (let m3 = this.m_edgeVertices.getFirst(n5); -1 !== m3; m3 = this.m_edgeVertices.getNext(m3)) {
      let e3 = this.m_edgeVertices.getElement(m3);
      if (this.getClusterFromVertex(e3) === r) {
        let t4 = 0;
        const s4 = this.m_tempEdgeBuffer.length;
        do {
          if (t4 > 0) {
            const s6 = this.m_tempEdgeBuffer[t4 - 1];
            this.addVertexToCluster_(s6, e3);
          }
          const s5 = this.m_tempEdgeBuffer[t4];
          t4 += 2, this.addVertexToEdge_(s5, e3), e3 = this.m_shape.getNextVertex(e3);
        } while (t4 < s4);
      } else {
        let t4 = this.m_tempEdgeBuffer.length - 1;
        do {
          if (t4 < this.m_tempEdgeBuffer.length - 2) {
            const s5 = this.m_tempEdgeBuffer[t4 + 1];
            this.addVertexToCluster_(s5, e3);
          }
          const s4 = this.m_tempEdgeBuffer[t4];
          t4 -= 2, this.addVertexToEdge_(s4, e3), e3 = this.m_shape.getNextVertex(e3);
        } while (t4 >= 0);
      }
    }
    this.m_tempEdgeBuffer.length = 0, this.dbgCheckNewEdgesArray_();
  }
  getVertexFromClusterIndex(e2) {
    const t3 = this.getClusterVertices(e2);
    return this.m_clusterVertices.getFirstElement(t3);
  }
  getClusterFromVertex(e2) {
    return this.m_shape.getUserIndex(e2, this.m_vertexClusterIndex);
  }
  processSplitHelper1_(e2, t3, s3) {
    const n5 = this.getEdgeCluster(t3, 0), r = this.getClusterXY(n5), i2 = this.getEdgeCluster(t3, 1), o = this.getClusterXY(i2), a2 = s3.getResultSegmentCount(e2);
    let h2 = s3.getResultSegment(e2, 0);
    const m3 = h2.getStartXY();
    if (!r.isEqualPoint2D(m3)) {
      if (!this.m_bComplications) {
        r.compare(this.m_sweepPoint) * m3.compare(this.m_sweepPoint) < 0 && (this.m_bComplications = true);
      }
      this.getAffectedEdges(n5, this.m_tempEdgeBuffer), this.m_modifiedClusters.push(n5);
    }
    if (!this.m_bComplications && a2 > 1) {
      const e3 = r.compare(o), t4 = h2.getEndXY();
      (r.compare(t4) !== e3 || t4.compare(o) !== e3 || t4.compare(this.m_sweepPoint) < 0) && (this.m_bComplications = true);
    }
    h2 = s3.getResultSegment(e2, a2 - 1);
    const l2 = h2.getEndXY();
    if (!o.isEqualPoint2D(l2)) {
      if (!this.m_bComplications) {
        o.compare(this.m_sweepPoint) * l2.compare(this.m_sweepPoint) < 0 && (this.m_bComplications = true);
      }
      this.getAffectedEdges(i2, this.m_tempEdgeBuffer), this.m_modifiedClusters.push(i2);
    }
    this.m_tempEdgeBuffer.push(t3);
    for (let g2 = 0, u = this.m_tempEdgeBuffer.length; g2 < u; g2++) {
      const e3 = this.m_tempEdgeBuffer[g2], s4 = this.getEdgeSweepNode(e3);
      at.isValidElement(s4) && (this.m_sweepStructure.deleteNode(s4), this.setEdgeSweepNode_(e3, -1));
      const n6 = at.impossibleIndex3();
      e3 !== t3 && this.getEdgeSweepNode(e3) !== n6 && (this.m_edgesToInsertInSweepStructure.push(e3), this.setEdgeSweepNode_(e3, n6));
    }
    this.m_tempEdgeBuffer.length = 0;
  }
  checkAndFixIntersection_(e2, t3) {
    const s3 = this.m_sweepStructure.getElement(e2);
    return this.m_sweepComparator.compare(this.m_sweepStructure, s3, t3), !!this.m_sweepComparator.intersectionDetected() && (this.m_sweepComparator.clearIntersectionDetectedFlag(), this.fixIntersection_(e2, t3), true);
  }
  fixIntersection_(e2, t3) {
    this.m_bCracked = true;
    const s3 = this.m_sweepStructure.getElement(e2), n5 = this.m_sweepStructure.getElement(t3);
    let r = null, i2 = null;
    const o = this.getEdgeOriginVertices(s3), a2 = this.m_edgeVertices.getFirstElement(o), h2 = this.getEdgeOriginVertices(n5), m3 = this.m_edgeVertices.getFirstElement(h2);
    this.m_shape.querySegment(a2, this.m_segBuf1, false, false), r = this.m_segBuf1.get();
    const l2 = this.m_shape.getNextVertex(a2), g2 = this.m_shape.getWeight(a2), u = this.m_shape.getSegmentParentageBreakVertex(a2), c = this.m_shape.getWeight(l2), _ = this.m_shape.getSegmentParentageBreakVertex(l2), d2 = this.m_shape.getSegmentWeight(a2), p3 = this.m_shape.getRank(a2), f3 = this.m_shape.getRank(l2), x4 = this.m_shape.getSegmentRank(a2), y2 = this.m_shape.getSegmentParentage(a2);
    this.m_shape.querySegment(m3, this.m_segBuf2, false, false), i2 = this.m_segBuf2.get();
    const P5 = this.m_shape.getNextVertex(m3), E2 = this.m_shape.getWeight(m3), S3 = this.m_shape.getSegmentParentageBreakVertex(m3), C3 = this.m_shape.getWeight(P5), I4 = this.m_shape.getSegmentParentageBreakVertex(P5), b2 = this.m_shape.getSegmentWeight(m3), w4 = this.m_shape.getRank(m3), v3 = this.m_shape.getRank(P5), N2 = this.m_shape.getSegmentRank(m3), T3 = this.m_shape.getSegmentParentage(m3);
    this.m_segmentIntersector.pushSegment(r, g2, p3, c, f3, d2, x4, u, _, y2), this.m_segmentIntersector.pushSegment(i2, E2, w4, C3, v3, b2, N2, S3, I4, T3), 3 === this.m_segmentIntersector.intersect2D(this.m_tolerance, true) && (this.m_bComplications = true), this.splitEdge_(s3, n5, -1, this.m_segmentIntersector), this.m_segmentIntersector.clear();
  }
  fixIntersectionPointSegment_(e2, t3) {
    this.m_bCracked = true;
    const s3 = this.m_sweepStructure.getElement(t3);
    let n5 = null;
    const r = this.getEdgeOriginVertices(s3), i2 = this.m_edgeVertices.getFirstElement(r);
    this.m_shape.querySegment(i2, this.m_segBuf1, false, false), n5 = this.m_segBuf1.get();
    const o = this.m_shape.getNextVertex(i2), a2 = this.m_shape.getWeight(i2), h2 = this.m_shape.getSegmentParentageBreakVertex(i2), m3 = this.m_shape.getWeight(o), l2 = this.m_shape.getSegmentParentageBreakVertex(o), g2 = this.m_shape.getSegmentWeight(i2), u = this.m_shape.getRank(i2), c = this.m_shape.getRank(o), _ = this.m_shape.getSegmentRank(i2), d2 = this.m_shape.getSegmentParentage(i2), p3 = this.getClusterFirstVertex(e2);
    this.m_segmentIntersector.pushSegment(n5, a2, u, m3, c, g2, _, h2, l2, d2), this.m_shape.queryPoint(p3, this.m_helperPoint);
    const f3 = this.m_shape.getWeight(p3), x4 = this.m_shape.getRank(p3);
    this.m_segmentIntersector.intersect2DEx(this.m_tolerance, this.m_helperPoint, x4, f3, true), this.splitEdge_(s3, -1, e2, this.m_segmentIntersector), this.m_segmentIntersector.clear();
  }
  insertNewEdges_() {
    if (0 === this.m_edgesToInsertInSweepStructure.length) return true;
    this.dbgCheckNewEdgesArray_();
    let e2 = true, t3 = 0;
    const s3 = this.m_edgesToInsertInSweepStructure.length, n5 = Math.max(2 * s3 + 200, this.m_sweepStructure.size() + 200);
    for (; this.m_edgesToInsertInSweepStructure.length; ) {
      if (this.m_edgesToInsertInSweepStructure.length > Math.max(100, this.m_shape.getTotalPointCount()) || t3 > n5) {
        this.m_edgesToInsertInSweepStructure.length = 0, this.m_bComplications = true, e2 = false;
        break;
      }
      const s4 = this.m_edgesToInsertInSweepStructure.at(-1);
      this.m_edgesToInsertInSweepStructure.pop(), this.setEdgeSweepNode_(s4, -1);
      const r = this.isEdgeOnSweepLine_(s4);
      at.isValidElement(r) ? (this.insertNewEdgeToSweepStructure_(s4, r), t3++) : r !== at.impossibleIndex2() && (e2 = false), this.m_bContinuingSegmentChainOptimization = false;
    }
    return e2;
  }
  insertNewEdgeToSweepStructure_(e2, t3) {
    let s3;
    if (this.m_bContinuingSegmentChainOptimization ? (s3 = this.m_sweepStructure.addElementAtPosition(this.m_prevNeighbour, this.m_nextNeighbour, e2, true, true), this.m_bContinuingSegmentChainOptimization = false) : s3 = this.m_sweepStructure.addUniqueElement(e2), -1 === s3) {
      const t4 = this.m_sweepStructure.getDuplicateElement(), s4 = this.m_sweepStructure.getElement(t4);
      return this.mergeEdges_(s4, e2), false;
    }
    if (this.setEdgeSweepNode_(e2, s3), this.m_sweepComparator.intersectionDetected()) {
      this.m_sweepComparator.clearIntersectionDetectedFlag();
      const e3 = this.m_sweepComparator.getLastComparedNode();
      return this.m_prevNeighbour === e3 && (this.m_prevNeighbour = -1), this.m_nextNeighbour === e3 && (this.m_nextNeighbour = -1), this.fixIntersection_(e3, s3), true;
    }
    return false;
  }
  isEdgeOnSweepLine_(e2) {
    const t3 = this.getEdgeCluster(e2, 0), s3 = this.getEdgeCluster(e2, 1), n5 = this.getClusterXY(t3), r = this.getClusterXY(s3);
    if (mi.sqrDistance(n5, r) <= this.m_toleranceSqr) return this.m_bComplications = true, -1;
    const i2 = n5.compare(this.m_sweepPoint), o = r.compare(this.m_sweepPoint);
    return i2 <= 0 && o > 0 ? s3 : o <= 0 && i2 > 0 ? t3 : i2 > 0 && o > 0 ? at.impossibleIndex2() : -1;
  }
  fillEventQueue() {
    const e2 = new st2(0), t3 = this.m_shape.queryVertexIteratorOnSelection();
    for (let r = t3.next(); r !== cr; r = t3.next()) -1 !== this.m_shape.getUserIndex(r, this.m_vertexClusterIndex) && e2.add(r);
    this.m_shape.sortVerticesSimpleByY(e2, 0, e2.size()), this.progress_(true), this.m_eventQ.clear(), this.m_eventQ.setCapacity(e2.size()), this.m_eventQ.setComparator(new Tn2(this.m_shape));
    const s3 = mi.getNAN();
    s3.setNAN();
    let n5 = -1;
    for (let r = 0, i2 = e2.size(); r < i2; r++) {
      const t4 = e2.read(r);
      if (this.m_shape.getXY(t4).isEqualPoint2D(s3)) {
        const e3 = this.m_shape.getUserIndex(t4, this.m_vertexClusterIndex);
        this.mergeClusters_(n5, e3);
        continue;
      }
      n5 = this.getClusterFromVertex(t4), this.m_shape.queryXY(t4, s3);
      const i3 = this.m_eventQ.addBiggestElement(t4);
      this.setClusterEventQNode_(n5, i3);
    }
  }
  fillEventQueuePass2() {
    const e2 = new st2(0);
    for (let t3 = this.m_eventQ.getFirst(); -1 !== t3; t3 = this.m_eventQ.getNext(t3)) {
      const s3 = this.m_eventQ.getElement(t3);
      e2.add(s3);
    }
    this.m_eventQ.clear(), this.m_shape.sortVerticesSimpleByY(e2, 0, e2.size()), this.progress_(true);
    for (let t3 = 0, s3 = e2.size(); t3 < s3; t3++) {
      const s4 = e2.read(t3), n5 = this.getClusterFromVertex(s4), r = this.m_eventQ.addBiggestElement(s4);
      this.setClusterEventQNode_(n5, r);
    }
  }
  getAffectedEdges(e2, t3) {
    const s3 = this.getClusterFirstEdge(e2);
    if (-1 === s3) return;
    let n5 = s3;
    do {
      const s4 = this.getEdgeSweepNode(n5);
      at.isValidElement(s4) && t3.push(n5), n5 = this.getNextEdge(n5, e2);
    } while (n5 !== s3);
  }
  updateClusterXY(e2, t3, s3, n5, r) {
    const i2 = this.getClusterVertices(t3);
    for (let o = this.m_clusterVertices.getFirst(i2); -1 !== o; o = this.m_clusterVertices.getNext(o)) {
      const t4 = this.m_clusterVertices.getElement(o);
      this.m_shape.setXYMonotonicPoint2D(t4, s3), this.m_shape.setWeight(t4, n5), this.m_shape.setRank(t4, r), e2 && this.m_bTrackChanges && this.m_shape.setGeometryModifiedWithVertex(t4, true), this.m_shape.setSegmentParentageBreakVertex(t4, true);
    }
  }
  splitEdge_(e2, t3, s3, n5) {
    this.dbgCheckEdge_(e2), -1 !== t3 && this.dbgCheckEdge_(t3), this.disconnectEdge_(e2), -1 !== t3 && this.disconnectEdge_(t3), this.processSplitHelper1_(0, e2, n5), -1 !== t3 && this.processSplitHelper1_(1, t3, n5), -1 !== s3 && n5.getResultPointChanged() && this.m_modifiedClusters.push(s3);
    for (let o = 0, a2 = this.m_modifiedClusters.length; o < a2; o++) {
      const e3 = this.m_modifiedClusters[o], t4 = this.getClusterEventQNode(e3);
      -1 !== t4 && (this.m_eventQ.deleteNode(t4), this.setClusterEventQNode_(e3, -1));
    }
    const r = this.getEdgeOriginVertices(e2), i2 = -1 !== t3 ? this.getEdgeOriginVertices(t3) : -1;
    if (this.applyIntersectorToEditShape_(r, n5, 0), -1 !== i2) this.applyIntersectorToEditShape_(i2, n5, 1);
    else {
      const e3 = n5.getResultPoint().getXY();
      this.updateClusterXY(n5.getResultPointChanged(), s3, e3, n5.getResultPointWeight(), n5.getResultPointRank());
    }
    this.createEdgesAndClustersFromSplitEdge_(e2, n5, 0), -1 !== t3 && this.createEdgesAndClustersFromSplitEdge_(t3, n5, 1), this.m_edgeVertices.deleteList(r), this.deleteEdge_(e2), -1 !== t3 && (this.m_edgeVertices.deleteList(i2), this.deleteEdge_(t3));
    for (let o = 0, a2 = this.m_modifiedClusters.length; o < a2; o++) {
      const e3 = this.m_modifiedClusters[o];
      e3 === this.m_sweepPointCluster && (this.m_bSweepPointClusterWasModified = true);
      let t4 = this.getClusterEventQNode(e3);
      if (-1 === t4) {
        const s4 = this.getClusterFirstVertex(e3);
        if (t4 = this.m_eventQ.addUniqueElement(s4), -1 === t4) {
          const t5 = this.m_eventQ.getDuplicateElement(), s5 = this.m_eventQ.getElement(t5), n6 = this.getClusterFromVertex(s5);
          this.mergeClusters_(n6, e3);
        } else this.setClusterEventQNode_(e3, t4);
      }
    }
    this.m_modifiedClusters.length = 0;
  }
  getClusterXY(e2) {
    const t3 = this.getClusterFirstVertex(e2);
    return this.m_shape.getXY(t3);
  }
  getClusterFirstVertex(e2) {
    const t3 = this.getClusterVertices(e2);
    return this.m_clusterVertices.getFirstElement(t3);
  }
  dbgCheckEdge_(e2) {
  }
  dbgCheckCluster_(e2) {
  }
  dbgCheckNewEdgesArray_() {
  }
  dbgSaveSweepStructure_(e2) {
  }
  sweepImpl_() {
    this.progress_(true), this.m_bSweepPointClusterWasModified = false, this.m_sweepPointCluster = -1, null === this.m_sweepComparator && (this.m_sweepStructure.disableBalancing(), this.m_sweepComparator = new vn2(this), this.m_sweepStructure.setComparator(this.m_sweepComparator));
    const e2 = [];
    let t3 = null, s3 = null;
    this.m_prevNeighbour = -1, this.m_nextNeighbour = -1, this.m_bContinuingSegmentChainOptimization = false;
    const n5 = at.impossibleIndex2(), r = at.impossibleIndex3();
    for (let i2 = this.m_eventQ.getFirst(); -1 !== i2; ) {
      this.progress_(), this.dbgCheckSweepStructure_(), this.m_bContinuingSegmentChainOptimization = false, this.m_prevNeighbour = -1, this.m_nextNeighbour = -1;
      const o = this.m_eventQ.getElement(i2);
      this.m_sweepPointCluster = this.getClusterFromVertex(o), this.m_shape.queryXY(o, this.m_sweepPoint), this.m_sweepComparator.setSweepY(this.m_sweepPoint.y, this.m_sweepPoint.x);
      let a2 = false;
      {
        const t4 = this.getClusterFirstEdge(this.m_sweepPointCluster);
        if (a2 = -1 === t4, !a2) {
          let s4 = t4;
          do {
            const t5 = this.getEdgeSweepNode(s4);
            -1 === t5 ? (this.m_edgesToInsertInSweepStructure.push(s4), this.setEdgeSweepNode_(s4, r)) : t5 !== r && e2.push(t5), s4 = this.getNextEdge(s4, this.m_sweepPointCluster);
          } while (s4 !== t4);
        }
      }
      if (!this.m_sweepStructure.isAutoBalancing() && (this.m_sweepStructure.getMaxDepthEver() > 4 || this.m_edgesToInsertInSweepStructure.length > 10) && this.m_sweepStructure.enableBalancing(), e2.length > 0) {
        this.m_bContinuingSegmentChainOptimization = 1 === e2.length && 1 === this.m_edgesToInsertInSweepStructure.length;
        for (let r2 = 0, i3 = e2.length; r2 < i3; r2++) {
          const t5 = this.m_sweepStructure.getElement(e2[r2]);
          this.setEdgeSweepNode_(t5, n5);
        }
        let t4 = n5, s4 = n5;
        for (let r2 = 0, i3 = e2.length; r2 < i3; r2++) {
          const i4 = e2[r2];
          if (t4 === n5) {
            const e3 = this.m_sweepStructure.getPrev(i4);
            if (-1 !== e3) {
              const s5 = this.m_sweepStructure.getElement(e3);
              this.getEdgeSweepNode(s5) !== n5 && (t4 = e3);
            } else t4 = -1;
          }
          if (s4 === n5) {
            const e3 = this.m_sweepStructure.getNext(i4);
            if (-1 !== e3) {
              const t5 = this.m_sweepStructure.getElement(e3);
              this.getEdgeSweepNode(t5) !== n5 && (s4 = e3);
            } else s4 = -1;
          }
          if (t4 !== n5 && s4 !== n5) break;
        }
        for (let n6 = 0, r2 = e2.length; n6 < r2; n6++) {
          const t5 = e2[n6], s5 = this.m_sweepStructure.getElement(t5);
          this.m_sweepStructure.deleteNode(t5), this.setEdgeSweepNode_(s5, -1);
        }
        e2.length = 0, this.m_prevNeighbour = t4, this.m_nextNeighbour = s4, -1 !== t4 && -1 !== s4 ? this.m_bContinuingSegmentChainOptimization || this.checkAndFixIntersection_(t4, s4) : -1 === t4 && -1 === s4 && (this.m_bContinuingSegmentChainOptimization = false);
      } else a2 && (null === t3 && (t3 = new Nn2(this)), t3.setPoint(this.m_sweepPoint), this.m_sweepStructure.searchUpperBound(t3), t3.intersectionDetected() && (t3.clearIntersectionDetectedFlag(), this.fixIntersectionPointSegment_(this.m_sweepPointCluster, t3.getCurrentNode())));
      const h2 = this.m_bContinuingSegmentChainOptimization;
      !this.insertNewEdges_() && h2 && -1 !== this.m_prevNeighbour && -1 !== this.m_nextNeighbour && this.checkAndFixIntersection_(this.m_prevNeighbour, this.m_nextNeighbour), this.m_bSweepPointClusterWasModified ? (this.m_bSweepPointClusterWasModified = false, null === s3 && (s3 = new Gn2(this.m_shape)), s3.setPoint(this.m_sweepPoint), i2 = this.m_eventQ.searchUpperBound(s3)) : i2 = this.m_eventQ.getNext(i2);
    }
    return this.m_bCracked;
  }
  setEditShape_(e2) {
    this.m_shape = e2, this.m_vertexClusterIndex = this.m_shape.createUserIndex(), this.m_edges.setCapacity(e2.getSelectedCount() + 32), this.m_clusters.setCapacity(e2.getSelectedCount()), this.m_clusterVertices.reserveLists(e2.getSelectedCount()), this.m_clusterVertices.reserveNodes(e2.getSelectedCount()), this.m_edgeVertices.reserveLists(e2.getSelectedCount() + 32), this.m_edgeVertices.reserveNodes(e2.getSelectedCount() + 32);
    for (let t3 = this.m_shape.getFirstGeometry(); t3 !== cr; t3 = this.m_shape.getNextGeometry(t3)) {
      if (h(this.m_shape.getGeometryType(t3))) for (let s3 = this.m_shape.getFirstPath(t3); s3 !== cr; s3 = this.m_shape.getNextPath(s3)) {
        const t4 = this.m_shape.getPathSize(s3), n5 = this.m_shape.getFirstVertex(s3);
        if (n5 === cr) continue;
        let r = this.m_shape.getNextVertex(n5);
        if (r === cr || r === n5) continue;
        let i2 = -1;
        e2.selected(n5) && (i2 = this.newCluster_(n5));
        let o = -1;
        -1 !== i2 && e2.selected(r) && (o = this.newEdge_(n5), this.addEdgeToCluster(o, i2));
        let a2 = o;
        for (let e3 = 0, s4 = t4 - 2; e3 < s4; e3++) {
          const e4 = this.m_shape.getNextVertex(r);
          let t5 = -1;
          if (this.m_shape.selected(r)) {
            const s5 = this.newCluster_(r);
            -1 !== a2 && this.addEdgeToCluster(a2, s5), this.m_shape.selected(e4) && (t5 = this.newEdge_(r), this.addEdgeToCluster(t5, s5));
          }
          a2 = t5, r = e4;
        }
        if (this.m_shape.isClosedPath(s3)) {
          const e3 = this.m_shape.getNextVertex(r);
          if (this.m_shape.selected(r)) {
            const t5 = this.newCluster_(r);
            if (-1 !== a2 && this.addEdgeToCluster(a2, t5), this.m_shape.selected(e3)) {
              const e4 = this.newEdge_(r);
              this.addEdgeToCluster(e4, t5), this.addEdgeToCluster(e4, i2);
            }
          }
        } else {
          let e3 = -1;
          this.m_shape.selected(r) && (e3 = this.newCluster_(r), -1 !== a2 && this.addEdgeToCluster(a2, e3));
        }
      }
      else for (let e3 = this.m_shape.getFirstPath(t3); e3 !== cr; e3 = this.m_shape.getNextPath(e3)) {
        let t4 = this.m_shape.getFirstVertex(e3);
        for (let s3 = 0, n5 = this.m_shape.getPathSize(e3); s3 < n5; s3++) this.m_shape.selected(t4) && this.newCluster_(t4), t4 = this.m_shape.getNextVertex(t4);
      }
    }
    this.fillEventQueue();
  }
  progress_(e2 = false) {
  }
  dbgCheckSweepStructure_() {
  }
};
function Vn2(e2, t3, s3, n5) {
  s3 > 0 && mn2(e2, s3, t3, false, n5);
  new Hn2(n5).executeImpl_(e2, t3);
}
function Fn2(e2, t3, s3) {
  return { vertex0: e2, vertex1: t3, dir: s3 };
}
var Hn2 = class {
  constructor(e2) {
    this.m_shape = null, this.m_spikes = [], this.m_points = new st2(0), this.m_pointsIndex = -1, this.m_dissolvedEdges = 0, this.m_progressTracker = e2;
  }
  executeImpl_(e2, t3) {
    if (this.m_shape = e2, e2.getPathCount(t3) < 2 && e2.getPointCount(t3) < 6) return;
    this.m_points.resize(0);
    for (let o = e2.getFirstPath(t3); o !== cr; o = e2.getNextPath(o)) {
      let t4 = e2.getFirstVertex(o);
      for (let s4 = 0, n6 = e2.getPathSize(o); s4 < n6; s4++, t4 = e2.getNextVertex(t4)) this.m_points.add(t4);
    }
    this.m_pointsIndex = e2.createUserIndex();
    for (let o = 0, g2 = this.m_points.size(); o < g2; ++o) e2.setUserIndex(this.m_points.read(o), this.m_pointsIndex, o);
    e2.sortVerticesSimpleByY(this.m_points, 0, this.m_points.size());
    let s3 = this.m_points.read(0);
    const n5 = e2.getXY(s3);
    let r = 1, i2 = 0;
    const a2 = [];
    for (let o = 1; o < this.m_points.size(); o++) {
      const t4 = this.m_points.read(o);
      if (t4 === cr) continue;
      if (-1 === e2.getUserIndex(t4, this.m_pointsIndex)) continue;
      const h3 = e2.getXY(t4);
      if (h3.isEqualPoint2D(n5)) r++;
      else {
        if (r > 1) {
          for (let t5 = i2; t5 < o; t5++) {
            const s4 = this.m_points.read(t5);
            if (-1 === e2.getUserIndex(s4, this.m_pointsIndex)) continue;
            const r2 = e2.getNextVertex(s4), i3 = e2.getPrevVertex(s4);
            if (s4 !== r2 && !e2.isEqualXYPoint2D(r2, n5)) {
              const e3 = Fn2(s4, r2, 1);
              a2.push(e3);
            }
            if (s4 !== i3 && i3 !== r2 && !e2.isEqualXYPoint2D(i3, n5)) {
              const e3 = Fn2(s4, i3, -1);
              a2.push(e3);
            }
          }
          a2.length > 0 && this.processBunch_(a2, n5);
        }
        s3 = t4, n5.assign(h3), r = 1, i2 = o;
      }
    }
    if (0 === this.m_dissolvedEdges) return e2.removeUserIndex(this.m_pointsIndex), void (this.m_pointsIndex = -1);
    let h2 = e2.getPointCount(t3);
    for (let o = 0; o < this.m_points.size(); o++) {
      const t4 = this.m_points.read(o);
      if (t4 === cr) continue;
      if (-1 !== e2.getUserIndex(t4, this.m_pointsIndex)) {
        e2.setUserIndex(t4, this.m_pointsIndex, -1);
        continue;
      }
      const s4 = e2.getPathFromVertex(t4);
      e2.getFirstVertex(s4) === t4 && e2.setFirstVertex(s4, cr), e2.freeVertex(t4), this.m_points.write(o, cr), h2--;
    }
    const m3 = e2.createPathUserIndex();
    let l2 = e2.getPathCount(t3);
    for (let g2 = 0, u = this.m_points.size(); g2 < u; ++g2) {
      if (this.m_points.read(g2) === cr) continue;
      let s4 = this.m_points.read(g2);
      if (-1 !== e2.getUserIndex(s4, this.m_pointsIndex)) continue;
      let n6 = e2.getPathFromVertex(s4), r2 = -1;
      if (2 === e2.getPathUserIndex(n6, m3)) {
        n6 = cr;
        for (let t4 = e2.getNextVertex(s4); t4 !== s4; t4 = e2.getNextVertex(t4)) {
          const r3 = e2.getPathFromVertex(t4);
          if (2 !== e2.getPathUserIndex(r3, m3)) {
            n6 = r3, s4 = t4;
            break;
          }
        }
        n6 === cr && (n6 = e2.insertPath(t3, cr), e2.setClosedPath(n6, true), l2++), n(n6 !== cr);
      }
      e2.setPathUserIndex(n6, m3, 2), r2 = e2.getFirstVertex(n6);
      let i3 = 0, a3 = false, h3 = s4;
      do {
        r2 === h3 && (a3 = true), e2.setUserIndex(h3, this.m_pointsIndex, 1);
        const t4 = e2.getPathFromVertex(h3);
        t4 !== n6 && (2 !== e2.getPathUserIndex(t4, m3) && (e2.setPathUserIndex(t4, m3, 1), e2.setFirstVertex(t4, cr)), e2.setPathToVertex(h3, n6)), i3++, h3 = e2.getNextVertex(h3);
      } while (h3 !== s4);
      a3 || e2.setFirstVertex(n6, s4), e2.setPathSize(n6, i3);
    }
    for (let o = e2.getFirstPath(t3); o !== cr; ) {
      const t4 = e2.getNextPath(o);
      1 !== e2.getPathUserIndex(o, m3) && e2.getFirstVertex(o) !== cr || (e2.removePathOnly(o), l2--), o = t4;
    }
    e2.setGeometryVertexCount(t3, h2), e2.setGeometryPathCount(t3, l2), e2.removePathUserIndex(m3), e2.removeUserIndex(this.m_pointsIndex), this.m_pointsIndex = -1, e2.dbgVerifyVertexCounts(), e2.filterClosePoints(0, true, false, false, t3);
  }
  processBunch_(e2, t3) {
    e2.sort((e3, s4) => {
      const n6 = this.m_shape.getXY(e3.vertex1).sub(t3), r2 = this.m_shape.getXY(s4.vertex1).sub(t3), i3 = mi.compareVectors(n6, r2);
      return 0 === i3 ? e3.dir < s4.dir ? -1 : 1 : i3;
    });
    let s3 = 0;
    const n5 = this.m_shape.getXY(e2[0].vertex1);
    let r = 1;
    const i2 = this.m_shape.hasCurves();
    for (let o = 1, a2 = e2.length; o < a2; o++) {
      const t4 = this.m_shape.getXY(e2[o].vertex1);
      if (!(t4.isEqualPoint2D(n5) && (r++, o + 1 < a2))) {
        if (2 === r) {
          const t5 = e2[s3], n6 = e2[s3 + 1], r2 = t5.dir;
          if (r2 !== n6.dir) {
            let e3 = true;
            if (i2 && (e3 = !this.m_shape.isCurve(1 === t5.dir ? t5.vertex0 : t5.vertex1) && !this.m_shape.isCurve(1 === n6.dir ? n6.vertex0 : n6.vertex1)), e3) {
              if (1 === r2) {
                const e4 = t5.vertex0, s4 = n6.vertex0;
                this.m_shape.setNextVertex(e4, s4), this.m_shape.setPrevVertex(s4, e4), this.m_shape.getPrevVertex(e4) === s4 && (this.m_shape.setUserIndex(e4, this.m_pointsIndex, -1), this.m_shape.setUserIndex(s4, this.m_pointsIndex, -1));
                const r3 = t5.vertex1, i3 = n6.vertex1;
                this.m_shape.setPrevVertex(r3, i3), this.m_shape.setNextVertex(i3, r3), this.m_shape.getNextVertex(r3) === i3 && (this.m_shape.setUserIndex(r3, this.m_pointsIndex, -1), this.m_shape.setUserIndex(i3, this.m_pointsIndex, -1));
              } else {
                const e4 = t5.vertex0, s4 = n6.vertex0;
                this.m_shape.setPrevVertex(e4, s4), this.m_shape.setNextVertex(s4, e4), this.m_shape.getNextVertex(e4) === s4 && (this.m_shape.setUserIndex(e4, this.m_pointsIndex, -1), this.m_shape.setUserIndex(s4, this.m_pointsIndex, -1));
                const r3 = t5.vertex1, i3 = n6.vertex1;
                this.m_shape.setNextVertex(r3, i3), this.m_shape.setPrevVertex(i3, r3), this.m_shape.getPrevVertex(r3) === i3 && (this.m_shape.setUserIndex(r3, this.m_pointsIndex, -1), this.m_shape.setUserIndex(i3, this.m_pointsIndex, -1));
              }
              this.m_dissolvedEdges += 2;
            }
          }
        }
        n5.assign(t4), s3 = o, r = 1;
      }
    }
    e2.length = 0;
  }
};
function kn2(e2) {
  for (let t3 = e2.getFirstGeometry(); t3 !== cr; t3 = e2.getNextGeometry(t3)) if (h(e2.getGeometryType(t3))) return true;
  return false;
}
function An2(e2, t3, s3, n5) {
  if (!kn2(e2)) return false;
  const r = new Bn2(n5);
  r.m_shape = e2, r.m_tolerance = t3, r.m_bTrackChanges = s3;
  let i2 = false;
  const o = e2.hasCurves() ? 5 : 15;
  return i2 = e2.getTotalPointCount() < o ? r.crackBruteForce_() : r.crackerPlaneSweep_(), i2;
}
function Mn2(e2, t3, s3, n5, r) {
  if (!kn2(t3)) return false;
  let i2 = new Bn2(r);
  if (i2.m_shape = t3, i2.m_tolerance = s3, i2.m_bAllowCoincident = e2, i2.m_bNeedsNonSimpleResult = null !== n5, i2.needsCrackingImpl_()) return n5 && n5.assign(i2.m_nonSimpleResult), true;
  const o = new x3();
  o.setSwapCoordinates(), t3.applyTransformation(o), i2 = new Bn2(r), i2.m_shape = t3, i2.m_tolerance = s3, i2.m_bAllowCoincident = e2, i2.m_bNeedsNonSimpleResult = null !== n5;
  const a2 = i2.needsCrackingImpl_();
  return t3.applyTransformation(o), !!a2 && (n5 && n5.assign(i2.m_nonSimpleResult), true);
}
function Un2(e2, t3, s3, n5) {
  const r = t3.getGeometryType();
  if (h(r)) {
    return new Bn2(n5).crackAWithBMultiPath_(e2, t3, s3);
  }
  z("crack_A_with_B");
}
function qn2(e2, t3) {
  return { t: e2, index: t3 };
}
var Bn2 = class _Bn {
  crackBruteForce_() {
    let e2 = this.crackBruteForceImpl_();
    if (!e2 && this.m_shape.hasCurves()) {
      const t3 = new x3();
      t3.setSwapCoordinates(), this.m_shape.applyTransformation(t3), e2 = this.crackBruteForceImpl_(), this.m_shape.applyTransformation(t3);
    }
    return e2;
  }
  crackBruteForceImpl_() {
    let e2 = false;
    const t3 = new fm(), s3 = new fm(), n5 = n3.constructEmpty(), r = n3.constructEmpty(), i2 = false, a2 = new ee(), h2 = new xn2(), m3 = this.m_shape.getTotalPointCount(), l2 = m3 * m3 * 2, g2 = this.m_shape.queryVertexIteratorOnSelection();
    for (let u = g2.next(); u !== cr; u = g2.next()) {
      const m4 = this.m_shape.getGeometryType(g2.currentGeometry());
      let c = 1, _ = 1, p3 = 1, f3 = 0, x4 = 0, y2 = 0;
      const P5 = this.m_shape.getSegmentParentage(u);
      let E2 = false, S3 = false, C3 = null, I4 = false;
      if (l(m4)) c = this.m_shape.getWeight(u), f3 = this.m_shape.getRank(u);
      else {
        if (C3 = this.getSegment_(u, t3), null === C3) continue;
        const e3 = this.m_shape.getVertexIndex(u);
        c = this.m_shape.getWeightWithIndex(e3), f3 = this.m_shape.getRankWithIndex(e3), p3 = this.m_shape.getSegmentWeightWithIndex(e3), y2 = this.m_shape.getSegmentRankWithIndex(e3), E2 = this.m_shape.getSegmentParentageBreakVertex(u);
        {
          const e4 = this.m_shape.getNextVertex(u);
          _ = this.m_shape.getWeight(e4), x4 = this.m_shape.getRank(e4), S3 = this.m_shape.getSegmentParentageBreakVertex(e4);
        }
        if (C3.queryLooseEnvelope(n5), n5.inflateCoords(this.m_tolerance, this.m_tolerance), C3.isDegenerate(this.m_tolerance)) {
          if (!C3.isDegenerate(0)) continue;
          I4 = true, C3 = null;
        }
      }
      const b2 = new pr({ copy: g2 });
      let w4 = b2.next();
      w4 !== cr && (w4 = b2.next());
      let v3 = 0;
      for (; w4 !== cr; w4 = b2.next()) {
        if (0 !== v3) {
          v3--;
          continue;
        }
        if (this.m_shape.getTotalPointCount() > l2) return e2;
        this.progress_();
        const m5 = this.m_shape.getGeometryType(b2.currentGeometry());
        let N2 = null, T3 = false, G4 = 0, D3 = 0, V4 = 0, F3 = 0, H3 = 0, k4 = 0, A4 = false, U4 = false;
        const q2 = this.m_shape.getSegmentParentage(w4);
        if (l(m5)) G4 = this.m_shape.getWeight(w4), F3 = this.m_shape.getRank(w4);
        else {
          if (N2 = this.getSegment_(w4, s3), null === N2) continue;
          const e3 = this.m_shape.getVertexIndex(w4);
          G4 = this.m_shape.getWeightWithIndex(e3), F3 = this.m_shape.getRankWithIndex(e3), V4 = this.m_shape.getSegmentWeightWithIndex(e3), k4 = this.m_shape.getSegmentRankWithIndex(e3), A4 = this.m_shape.getSegmentParentageBreakVertex(w4);
          {
            const e4 = this.m_shape.getNextVertex(w4);
            D3 = this.m_shape.getWeight(e4), H3 = this.m_shape.getRank(e4), U4 = this.m_shape.getSegmentParentageBreakVertex(e4);
          }
          if (N2.queryLooseEnvelope(r), N2.isDegenerate(this.m_tolerance)) {
            if (!N2.isDegenerate(0)) continue;
            T3 = true, N2 = null;
          }
        }
        let B4 = 0, O3 = 0;
        if (null !== C3 && null !== N2) {
          if (n5.isIntersectingNe(r)) {
            0 !== om(true, true, C3, N2, this.m_tolerance, true) && (h2.pushSegment(C3, c, f3, _, x4, p3, y2, E2, S3, P5), h2.pushSegment(N2, G4, F3, D3, H3, V4, k4, A4, U4, q2), h2.intersect2D(this.m_tolerance, true), e2 ||= h2.getSegmentChanged(0) || h2.getSegmentChanged(1), B4 = h2.getResultSegmentCount(0), O3 = h2.getResultSegmentCount(1), B4 + O3 > 0 && (this.m_shape.splitSegmentWithIntersector(u, h2, 0, true, true), this.m_shape.splitSegmentWithIntersector(w4, h2, 1, true, true), this.m_bTrackChanges && (h2.getSegmentChanged(0) && this.m_shape.setGeometryModifiedWithVertex(u, true), h2.getSegmentChanged(1) && this.m_shape.setGeometryModifiedWithVertex(w4, true))), O3 > 1 && (v3 += O3 - 1), h2.clear());
          }
        } else if (null !== C3) {
          const t4 = this.m_shape.getXY(w4);
          if (n5.contains(t4)) {
            if (h2.pushSegment(C3, c, f3, _, x4, p3, y2, E2, S3, P5), this.m_shape.queryPoint(w4, a2), h2.intersect2DEx(this.m_tolerance, a2, F3, G4, i2), e2 ||= h2.getSegmentChanged(0) || h2.getResultPointChanged(), B4 = h2.getResultSegmentCount(0), B4 > 0) if (this.m_bTrackChanges && (h2.getSegmentChanged(0) && this.m_shape.setGeometryModifiedWithVertex(u, true), h2.getSegmentChanged(1) && this.m_shape.setGeometryModifiedWithVertex(w4, true)), this.m_shape.splitSegmentWithIntersector(u, h2, 0, true, true), T3) {
              let e3 = cr;
              for (let t5 = this.m_shape.getNextVertex(w4); t5 !== cr && t5 !== w4 && (N2 = this.getSegment_(t5, s3), e3 = t5, null != N2 && N2.isDegenerate(0)); t5 = this.m_shape.getNextVertex(t5)) ;
              for (let t5 = w4; t5 !== cr && (this.m_shape.setPoint(t5, h2.getResultPoint(), true), t5 !== e3); t5 = this.m_shape.getNextVertex(t5)) ;
            } else this.m_shape.setPoint(w4, h2.getResultPoint(), true);
            h2.clear();
          }
        } else {
          if (null === N2) continue;
          {
            const t4 = this.m_shape.getXY(u);
            if (r.inflateCoords(this.m_tolerance, this.m_tolerance), r.contains(t4)) {
              if (h2.pushSegment(N2, G4, F3, D3, H3, V4, k4, A4, U4, q2), this.m_shape.queryPoint(u, a2), h2.intersect2DEx(this.m_tolerance, a2, f3, c, i2), e2 ||= h2.getSegmentChanged(0) || h2.getResultPointChanged(), O3 = h2.getResultSegmentCount(0), O3 > 0) if (this.m_bTrackChanges && (h2.getSegmentChanged(0) && this.m_shape.setGeometryModifiedWithVertex(w4, true), h2.getSegmentChanged(1) && this.m_shape.setGeometryModifiedWithVertex(u, true)), this.m_shape.splitSegmentWithIntersector(w4, h2, 0, true, true), v3 += O3 - 1, I4) {
                let e3 = cr;
                for (let t5 = this.m_shape.getNextVertex(u); t5 !== cr && t5 !== u && (N2 = this.getSegment_(t5, s3), e3 = t5, null != N2 && N2.isDegenerate(0)); t5 = this.m_shape.getNextVertex(t5)) ;
                for (let t5 = u; t5 !== cr && (this.m_shape.setPoint(t5, h2.getResultPoint(), true), t5 !== e3); t5 = this.m_shape.getNextVertex(t5)) ;
              } else this.m_shape.setPoint(u, h2.getResultPoint(), true);
              h2.clear();
            }
          }
        }
        if (B4 + O3 !== 0 && 0 !== B4) {
          let e3 = false;
          for (; C3 = this.getSegment_(u, t3), null != C3 && (C3.queryEnvelope(n5), C3.isDegenerate(this.m_tolerance)); ) {
            if (!(B4 > 1)) {
              e3 = true;
              break;
            }
            u = g2.next(), B4--, n(u !== cr);
          }
          if (e3) break;
        }
      }
    }
    return e2;
  }
  crackerPlaneSweep_() {
    return this.planesweep_();
  }
  planesweep_() {
    return new Dn2(this.m_progressTracker, this.m_bTrackChanges).sweep(this.m_shape, this.m_tolerance);
  }
  needsCrackingImpl_() {
    let e2 = false;
    const t3 = new st2(0);
    t3.resize(this.m_shape.getSelectedCount());
    const s3 = this.m_shape.queryVertexIteratorOnSelection();
    for (let r = 0, g2 = s3.next(); g2 !== cr; ++r, g2 = s3.next()) t3.write(r, g2);
    this.m_shape.sortVerticesSimpleByY(t3, 0, t3.size()), t3.add(cr);
    const n5 = this.m_shape.createUserIndex(), i2 = this.m_shape.createUserIndex();
    this.m_sweepComparator = new on2(this.m_shape, this.m_tolerance, !this.m_bAllowCoincident), this.m_sweepStructure.setComparator(this.m_sweepComparator);
    let o = null;
    const a2 = [], h2 = [];
    let m3 = 0;
    const l2 = new mi();
    for (let g2 = t3.read(m3++); g2 !== cr; ) {
      this.m_shape.queryXY(g2, l2);
      let s4 = false;
      do {
        let e3 = this.m_shape.getNextVertex(g2), r = this.m_shape.getPrevVertex(g2);
        s4 ||= e3 !== cr || r !== cr, e3 === cr || this.m_shape.selected(e3) || (e3 = cr), r === cr || this.m_shape.selected(r) || (r = cr), e3 !== cr && this.m_shape.compareVerticesSimpleY(g2, e3) < 0 && (h2.push(g2), h2.push(e3)), r !== cr && this.m_shape.compareVerticesSimpleY(g2, r) < 0 && (h2.push(r), h2.push(r));
        const o2 = this.m_shape.getUserIndex(g2, n5);
        -1 !== o2 && (a2.push(o2), this.m_shape.setUserIndex(g2, n5, -1));
        const l3 = this.m_shape.getUserIndex(g2, i2);
        -1 !== l3 && (a2.push(l3), this.m_shape.setUserIndex(g2, i2, -1)), g2 = t3.read(m3++);
      } while (g2 !== cr && this.m_shape.isEqualXYPoint2D(g2, l2));
      if (!s4 && (null === o && (o = new an2(this.m_shape, this.m_tolerance)), o.setPoint(l2), this.m_sweepStructure.searchUpperBound(o), o.intersectionDetected())) {
        e2 = true, this.m_bNeedsNonSimpleResult && (b("needsCrackingIMpl_"), this.m_nonSimpleResult = new e(6, -1, -1));
        break;
      }
      let u = 1 === a2.length && 2 === h2.length;
      const c = 32;
      a2.length > c && qt(a2);
      let _ = -1, d2 = -1;
      if (!u) for (let t4 = 0, n6 = a2.length; t4 < n6; t4++) {
        const s5 = a2[t4], n7 = this.m_sweepStructure.getPrev(s5);
        if (-1 !== n7 && -1 === a2.indexOf(n7)) if (-1 === _) _ = n7;
        else {
          if (e2 = true, !this.m_bNeedsNonSimpleResult) break;
          this.m_nonSimpleResult = new e(6, -1, -1);
        }
        const r = this.m_sweepStructure.getNext(s5);
        if (-1 !== r && -1 === a2.indexOf(r)) if (-1 === d2) d2 = r;
        else {
          if (e2 = true, !this.m_bNeedsNonSimpleResult) break;
          this.m_nonSimpleResult = new e(6, -1, -1);
        }
        if (-1 !== _ && -1 !== d2) break;
      }
      if (e2 && !this.m_bNeedsNonSimpleResult) break;
      if (this.m_sweepComparator.setSweepY(l2.y, l2.x), !u) {
        for (let e3 = 0, t4 = a2.length; e3 < t4; e3++) {
          const t5 = a2[e3];
          this.m_sweepStructure.deleteNode(t5);
        }
        a2.length = 0;
      }
      if (!u && -1 !== _ && -1 !== d2 && this.checkForIntersections_(_, d2)) {
        e2 = true, this.m_bNeedsNonSimpleResult && (this.m_nonSimpleResult = this.m_sweepComparator.getResult());
        break;
      }
      for (let t4 = 0, r = h2.length; t4 < r; t4 += 2) {
        const s5 = h2[t4], r2 = h2[t4 + 1];
        let o2;
        if (u ? (o2 = this.m_sweepStructure.replaceElementAtPosition(a2[0], s5, true, true), a2.length = 0, u = false) : o2 = this.m_sweepStructure.addElement(s5), this.m_sweepComparator.intersectionDetected()) {
          this.m_bNeedsNonSimpleResult && (this.m_nonSimpleResult = this.m_sweepComparator.getResult()), e2 = true;
          break;
        }
        -1 === this.m_shape.getUserIndex(r2, n5) ? this.m_shape.setUserIndex(r2, n5, o2) : this.m_shape.setUserIndex(r2, i2, o2);
      }
      if (e2) break;
      h2.length = 0;
    }
    return this.m_shape.removeUserIndex(n5), this.m_shape.removeUserIndex(i2), e2;
  }
  checkForIntersections_(e2, t3) {
    const s3 = this.m_sweepStructure.getElement(e2);
    this.m_sweepComparator.compare(this.m_sweepStructure, s3, t3);
    const n5 = this.m_sweepComparator.intersectionDetected();
    return this.m_sweepComparator.clearIntersectionDetectedFlag(), n5;
  }
  getSegment_(e2, t3) {
    return _Bn.st_getSegment(this.m_shape, e2, t3);
  }
  static st_getSegment(e2, t3, s3) {
    return e2.querySegment(t3, s3, false, false) ? s3.get() : null;
  }
  dbgPrintSweepEdge(e2) {
  }
  dbgPrintSweepStructure() {
  }
  dbgSaveSweepStructure(e2 = null) {
  }
  dbgCheckSweepStructure() {
  }
  progress_(e2 = false) {
    this.m_progressCounter++;
  }
  crackAWithBMultiPath_(e2, t3, n5) {
    const r = n3.constructEmpty();
    e2.queryLooseEnvelope(r);
    const i2 = n3.constructEmpty();
    if (t3.queryLooseEnvelope(i2), i2.inflateCoords(n5, n5), !i2.isIntersecting(r)) return e2;
    const a2 = e2.getImpl(), h2 = a2.getAccelerators();
    let l2 = null, g2 = null;
    h2 && (g2 = h2.getQuadTree()), On2(e2, w(t3)) && (l2 = Wt2(a2, i2), g2 = l2);
    const u = g2 ? g2.getIteratorForQT() : null, c = t3.querySegmentIterator(), _ = e2.querySegmentIterator(), d2 = Yt(15, Number.NaN), p3 = [];
    for (; c.nextPath(); ) for (; c.hasNextSegment(); ) {
      const e3 = c.nextSegment();
      if (g2) {
        u.resetIterator(e3, n5);
        for (let t4 = u.next(); -1 !== t4; t4 = u.next()) {
          this.progress_();
          const s3 = g2.getElement(t4);
          if (_.resetToVertex(s3, -1), _.hasNextSegment()) {
            const t5 = _.nextSegment().intersect(e3, null, d2, null, n5);
            for (let e4 = 0; e4 < t5; e4++) {
              const t6 = d2[e4];
              if (0 === t6 || 1 === t6) continue;
              const s4 = qn2(t6, _.getStartPointIndex());
              p3.push(s4);
            }
          }
        }
      } else {
        const t4 = n3.constructEmpty();
        if (e3.queryLooseEnvelope(t4), t4.inflateCoords(n5, n5), !r.isIntersecting(t4)) continue;
        for (_.resetToFirstPath(); _.nextPath(); ) for (; _.hasNextSegment(); ) {
          const s3 = _.nextSegment(), r2 = n3.constructEmpty();
          if (s3.queryLooseEnvelope(r2), !r2.isIntersecting(t4)) continue;
          const i3 = s3.intersect(e3, null, d2, null, n5);
          for (let e4 = 0; e4 < i3; e4++) {
            const t5 = d2[e4];
            if (0 === t5 || 1 === t5) continue;
            const s4 = qn2(t5, _.getStartPointIndex());
            p3.push(s4);
          }
        }
      }
    }
    if (0 === p3.length) return e2;
    p3.sort((e3, t4) => e3.index < t4.index ? -1 : e3.index > t4.index ? 1 : e3.t < t4.t ? -1 : e3.t > t4.t ? 1 : 0);
    const f3 = e2.createInstance();
    if (f3.getGeometryType() === a.enumPolygon) {
      f3.setFillRule(e2.getFillRule());
    }
    for (_.resetToFirstPath(); _.nextPath() && !_.hasNextSegment(); ) ;
    n(_.hasNextSegment());
    let x4 = _.nextSegment();
    const y2 = new fm();
    let P5 = -1;
    for (let s3 = 0, m3 = p3.length; s3 < m3; ) {
      const e3 = p3[s3].index;
      let t4 = s3 + 1;
      for (; t4 < m3 && p3[t4].index === e3; ) ++t4;
      for (; _.getStartPointIndex() < e3; ) {
        this.progress_();
        const e4 = _.hasNextSegment(), t5 = _.getPathIndex();
        if ((e4 || !_.isClosingSegment() || _.isCurve()) && (n(null !== x4), f3.addSegment(x4, P5 !== t5)), P5 = t5, !e4) {
          for (_.isPathClosed(); _.nextPath() && !_.hasNextSegment(); ) ;
          n(_.hasNextSegment());
        }
        x4 = _.nextSegment();
      }
      let n6 = 0;
      for (let i3 = s3; i3 < t4; i3++) {
        const e4 = p3[i3].t;
        if (e4 === n6) continue;
        n(null !== x4), x4.queryCut(n6, e4, y2), n6 = e4;
        const t5 = _.getPathIndex();
        f3.addSegment(y2.get(), P5 !== t5), P5 = t5;
      }
      const r2 = _.hasNextSegment();
      if ((r2 || !_.isClosingSegment() || _.isCurve()) && (n(null != x4), x4.queryCut(n6, 1, y2), f3.addSegment(y2.get(), false)), r2) x4 = _.nextSegment();
      else {
        for (; _.nextPath() && !_.hasNextSegment(); ) ;
        x4 = _.hasNextSegment() ? _.nextSegment() : null;
      }
      s3 = t4;
    }
    if (null !== x4) {
      const e3 = _.getPathIndex();
      (_.hasNextSegment() || !_.isClosingSegment() || _.isCurve()) && f3.addSegment(x4, P5 !== e3), P5 = e3;
    }
    let E2 = _.hasNextSegment();
    for (; ; ) {
      if (!E2) {
        for (; _.nextPath() && (E2 = _.hasNextSegment(), !E2); ) ;
        if (!E2) break;
      }
      x4 = _.nextSegment();
      const e3 = _.getPathIndex();
      E2 = _.hasNextSegment();
      (E2 || !_.isClosingSegment() || _.isCurve()) && f3.addSegment(x4, P5 !== e3), P5 = e3;
    }
    return f3;
  }
  constructor(e2) {
    this.m_shape = null, this.m_progressTracker = null, this.m_nonSimpleResult = new e(), this.m_tolerance = 0, this.m_sweepComparator = null, this.m_progressCounter = 0, this.m_bTrackChanges = false, this.m_bNeedsNonSimpleResult = false, this.m_bAllowCoincident = true, this.m_sweepStructure = new ct2(), this.m_progressTracker = e2;
  }
};
function On2(e2, t3) {
  const s3 = e2.getPointCount();
  if (s3 < 16) return false;
  const n5 = 1;
  return 2 * s3 + 1 * (Math.log(s3) / Math.log(2)) * t3 < n5 * s3 * t3;
}
Bn2.s_bForceBruteForce = true;
var Yn2 = class {
  constructor(e2, t3) {
    this.m_monotoneParts = Ot(fm, 16), this.m_xOrds = Yt(16, Number.NaN), this.m_inputPoint = mi.getNAN(), this.m_miny = 0, this.m_maxy = 0, this.m_windnum = 0, this.m_bAlternate = e2, this.m_tolerance = t3, this.m_toleranceSqr = t3 * t3, this.m_bTestBorder = !!t3, this.m_bBreak = false;
  }
  _DoOne(e2) {
    if (!this.m_bTestBorder && (this.m_bAlternate && this.m_inputPoint.equals(e2.getStartXY()) || this.m_inputPoint.equals(e2.getEndXY()))) return void (this.m_bBreak = true);
    if (e2.getStartY() === this.m_inputPoint.y && e2.getStartY() === e2.getEndY()) {
      if (this.m_bAlternate && !this.m_bTestBorder) {
        const t4 = Math.min(e2.getStartX(), e2.getEndX()), s4 = Math.max(e2.getStartX(), e2.getEndX());
        this.m_inputPoint.x > t4 && this.m_inputPoint.x < s4 && (this.m_bBreak = true);
      }
      return;
    }
    let t3 = false;
    const s3 = Math.max(e2.getStartX(), e2.getEndX());
    if (this.m_inputPoint.x > s3) t3 = true;
    else if (this.m_inputPoint.x >= Math.min(e2.getStartX(), e2.getEndX())) {
      const n5 = e2.intersectionOfYMonotonicWithAxisX(this.m_inputPoint.y, s3);
      t3 = !Number.isNaN(n5) && n5 <= this.m_inputPoint.x;
    }
    if (t3) {
      if (this.m_inputPoint.y === e2.getStartY()) {
        if (this.m_inputPoint.y < e2.getEndY()) return;
      } else if (this.m_inputPoint.y === e2.getEndY() && this.m_inputPoint.y < e2.getStartY()) return;
      this.m_bAlternate ? this.m_windnum ^= 1 : this.m_windnum += e2.getStartY() > e2.getEndY() ? 1 : -1;
    }
  }
  _Result() {
    return !!this.m_windnum;
  }
  testBorder(e2) {
    const t3 = e2.getClosestCoordinate(this.m_inputPoint, false), s3 = e2.getCoord2D(t3);
    return mi.sqrDistance(s3, this.m_inputPoint) <= this.m_toleranceSqr;
  }
  setInputPoint(e2) {
    this.m_inputPoint.setCoordsPoint2D(e2), this.m_miny = e2.y - this.m_tolerance, this.m_maxy = e2.y + this.m_tolerance;
  }
  processSegment(e2) {
    const t3 = e2.queryInterval(0, 1);
    if (t3.vmin > this.m_maxy || t3.vmax < this.m_miny) return false;
    if (this.m_bTestBorder && this.testBorder(e2)) return true;
    if (t3.vmin > this.m_inputPoint.y || t3.vmax < this.m_inputPoint.y) return false;
    let s3 = 0;
    if (e2.isCurve() && (0 === this.m_monotoneParts.length && (this.m_monotoneParts.length = 128), s3 = e2.getMonotonicParts(this.m_monotoneParts, true), n(this.m_monotoneParts.length >= s3)), s3 > 0) for (let n5 = 0; n5 < s3; n5++) {
      const e3 = this.m_monotoneParts[n5].get(), t4 = x2.construct(e3.getStartY(), e3.getEndY());
      if (!(t4.vmin > this.m_inputPoint.y || t4.vmax < this.m_inputPoint.y) && (this._DoOne(e3), this.m_bBreak)) return true;
    }
    else if (this._DoOne(e2), this.m_bBreak) return true;
    return false;
  }
  result() {
    return n(0), 2;
  }
};
function Rn2(e2, t3, s3, n5) {
  const r = new n3();
  e2.queryLooseEnvelope(r), r.inflateCoords(n5, n5);
  const i2 = 0 === e2.getFillRule(), o = new Yn2(i2, n5);
  o.setInputPoint(s3);
  const a2 = r.clone();
  a2.xmax = s3.x + n5, a2.ymin = s3.y - n5, a2.ymax = s3.y + n5;
  const h2 = e2.getImpl().querySegmentIterator(), m3 = t3.getIterator(a2, n5);
  for (let l2 = m3.next(); -1 !== l2; l2 = m3.next()) if (h2.resetToVertex(t3.getElement(l2), -1), h2.hasNextSegment()) {
    const e3 = h2.nextSegment();
    if (o.processSegment(e3)) return -1;
  }
  return o._Result() ? 1 : 0;
}
function Xn2(e2, t3, s3) {
  const n5 = 0 === e2.getFillRule(), r = new Yn2(n5, s3);
  r.setInputPoint(t3);
  const i2 = e2.getImpl().querySegmentIterator();
  for (; i2.nextPath(); ) for (; i2.hasNextSegment(); ) {
    const e3 = i2.nextSegment();
    if (r.processSegment(e3)) return -1;
  }
  return r._Result() ? 1 : 0;
}
function Ln2(e2, t3, s3) {
  return t3.isEmpty() ? 0 : zn2(e2, t3.getXY(), s3);
}
function zn2(e2, t3, s3) {
  if (e2.isEmpty()) return 0;
  const n5 = n3.constructEmpty();
  if (e2.queryLooseEnvelope(n5), n5.inflateCoords(s3, s3), !n5.contains(t3)) return 0;
  const r = e2.getImpl().getAccelerators();
  if (r) {
    r.getRasterizedGeometry() && n(0);
    const n6 = r.getQuadTree();
    if (n6) return Rn2(e2, n6, t3, s3);
  }
  return Xn2(e2, t3, s3);
}
function Wn2(e2, t3) {
  const s3 = e2.getPointCount();
  if (s3 < 16) return false;
  const n5 = 1;
  return 2 * s3 + 1 * (Math.log(s3) / Math.log(2)) * t3 < n5 * s3 * t3;
}
function jn2(e2, t3, s3, n5, r) {
  const i2 = new $n2(r);
  return i2.m_shape = e2, i2.m_geometry = t3, i2.m_sortedVertices = s3, i2.m_bFixSelfTangency = n5, i2.fixRingOrientation_();
}
var Kn2 = class {
  getDirection_(e2) {
    return this.m_shape.getNextVertex(this.getEnd1(e2)) === this.getEnd2(e2);
  }
  getEnd_(e2) {
    const t3 = this.getEnd1(e2), s3 = this.getEnd2(e2);
    return this.m_shape.getNextVertex(t3) === s3 ? s3 : t3;
  }
  constructor(e2) {
    this.m_end1Nodes = [], this.m_end2Nodes = [], this.m_directions = [], this.m_shape = e2, this.m_firstFree = -1;
  }
  getSegment(e2) {
    return this.m_shape.getSegment(this.getStart(e2));
  }
  isBottomUp(e2) {
    let t3 = this.getEnd1(e2), s3 = this.getEnd2(e2);
    this.m_shape.getPrevVertex(t3) === s3 && (s3 = Pt(t3, t3 = s3));
    const n5 = mi.getNAN(), r = mi.getNAN();
    return this.m_shape.queryXY(t3, n5), this.m_shape.queryXY(s3, r), n(!n5.equals(r)), n5.y < r.y;
  }
  getStart(e2) {
    const t3 = this.getEnd1(e2), s3 = this.getEnd2(e2);
    return this.m_shape.getNextVertex(t3) === s3 ? t3 : s3;
  }
  getEnd1(e2) {
    return this.m_end1Nodes[e2];
  }
  getEnd2(e2) {
    return this.m_end2Nodes[e2];
  }
  freeEdge(e2) {
    this.m_end1Nodes[e2] = this.m_firstFree, this.m_firstFree = e2;
  }
  newEdge(e2) {
    if (-1 !== this.m_firstFree) {
      const t4 = this.m_firstFree;
      return this.m_firstFree = this.m_end1Nodes[t4], this.m_end1Nodes[t4] = e2, this.m_end2Nodes[t4] = this.m_shape.getNextVertex(e2), t4;
    }
    const t3 = this.m_end1Nodes.length;
    return this.m_end1Nodes.push(e2), this.m_end2Nodes.push(this.m_shape.getNextVertex(e2)), t3;
  }
  getShape() {
    return this.m_shape;
  }
  getPath(e2) {
    return this.m_shape.getPathFromVertex(this.getEnd1(e2));
  }
};
var Qn2 = class extends dt {
  constructor(e2) {
    super(), this.m_line1 = new pm(), this.m_line2 = new pm(), this.m_leftElm = -1, this.m_leftx = 0, this.m_seg1 = null, this.m_helper = e2;
  }
  compare(e2, t3, s3) {
    const n5 = e2.getElement(s3), r = this.m_helper.m_edges;
    let i2;
    if (this.m_leftElm === t3) i2 = this.m_leftx;
    else {
      if (this.m_seg1 = r.getSegment(t3), this.m_seg1) i2 = this.m_seg1.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline, 0);
      else {
        r.getShape().queryLineConnector(r.getStart(t3), this.m_line1, true), this.m_seg1 = this.m_line1, i2 = this.m_line1.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline, 0);
      }
      this.m_leftx = i2, this.m_leftElm = t3;
    }
    let o, a2 = r.getSegment(n5);
    if (a2) o = a2.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline, 0);
    else {
      r.getShape().queryLineConnector(r.getStart(n5), this.m_line2, true), a2 = this.m_line2, o = this.m_line2.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline, 0);
    }
    if (i2 === o) {
      const e3 = r.isBottomUp(t3), s4 = r.isBottomUp(n5), h2 = e3 ? this.m_seg1.getEndY() : this.m_seg1.getStartY(), m3 = s4 ? a2.getEndY() : a2.getStartY(), l2 = Math.min(h2, m3);
      let g2 = 0.5 * (l2 + this.m_helper.m_yScanline);
      g2 === this.m_helper.m_yScanline && (g2 = l2), i2 = this.m_seg1.intersectionOfYMonotonicWithAxisX(g2, 0), o = a2.intersectionOfYMonotonicWithAxisX(g2, 0), i2 === o && k("");
    }
    return i2 < o ? -1 : i2 > o ? 1 : 0;
  }
  reset() {
    this.m_leftElm = -1;
  }
};
var Jn2 = class {
  constructor(e2) {
    this.m_node = -1, this.m_index = 0, this.m_sortedVertices = e2.m_sortedVertices, this.m_sortedVerticesArray = e2.m_sortedVerticesArray, this.m_sortedVertices && (this.m_node = this.m_sortedVertices.getFirst(this.m_sortedVertices.getFirstList()));
  }
  next() {
    if (this.m_sortedVertices) {
      const e2 = this.m_node;
      if (-1 === e2) return cr;
      const t3 = this.m_sortedVertices.getData(e2);
      return this.m_node = this.m_sortedVertices.getNext(e2), t3;
    }
    if (this.m_index < this.m_sortedVerticesArray.size()) {
      const e2 = this.m_sortedVerticesArray.read(this.m_index);
      return this.m_index++, e2;
    }
    return cr;
  }
};
var $n2 = class {
  constructor(e2) {
    this.m_edges = null, this.m_shape = null, this.m_AET = new ct2(), this.m_yScanline = 0, this.m_geometry = cr, this.m_unknownRingOrientationCount = -1, this.m_sortedVertices = null, this.m_sortedVerticesArray = null, this.m_unknownNodes = [], this.m_node1UserIndex = -1, this.m_node2UserIndex = -1, this.m_pathOrientationIndex = -1, this.m_pathParentageIndex = -1, this.m_pathParentsIndex = -1, this.m_progressCounter = 0, this.m_bFixSelfTangency = false, this.m_progressTracker = e2, this.m_AET.disableBalancing(), this.m_sweepComparator = new Qn2(this), this.m_AET.setComparator(this.m_sweepComparator);
  }
  fixRingOrientation_() {
    const e2 = this.fixRingOrientationImplMain_();
    return -1 === this.m_pathOrientationIndex || this.fixRingOrientationImplSimplify_(), e2;
  }
  fixRingOrientationForMp2sp_() {
    return this.fixRingOrientationImplMain_(), -1 === this.m_pathOrientationIndex ? -1 : this.fixRingOrientationImplMp2sp_();
  }
  processBunchForRingOrientationTest_(e2) {
    return this.processBunchForRingOrientationTestOddEven_(e2);
  }
  processBunchForRingOrientationTestOddEven_(e2) {
    let t3 = false;
    if (this.m_edges || (this.m_edges = new Kn2(this.m_shape)), this.m_unknownNodes.length = 0, this.processBunchForRingOrientationRemoveEdges_(e2), !this.m_AET.isAutoBalancing()) {
      let t4 = 0;
      for (let s3 = 0, n5 = e2.length; s3 < n5; s3++) {
        -1 !== e2[s3] && t4++;
      }
      (t4 > 10 || this.m_AET.getMaxDepthEver() > 4) && this.m_AET.enableBalancing();
    }
    for (let s3 = 0, n5 = e2.length; s3 < n5; s3++) {
      const t4 = e2[s3];
      t4 !== cr && this.insertEdge_(t4, -1);
    }
    for (let s3 = 0; s3 < this.m_unknownNodes.length && this.m_unknownRingOrientationCount > 0; s3++) {
      const e3 = this.m_unknownNodes[s3], n5 = this.m_AET.getElement(e3), r = this.m_edges.getPath(n5), i2 = this.m_shape.getPathUserIndex(r, this.m_pathOrientationIndex);
      let a2 = cr;
      if (0 === i2) {
        let s4 = this.m_AET.getPrev(e3), n6 = e3, r2 = false;
        for (; s4 !== ct2.st_nullNode(); ) {
          const e4 = this.m_AET.getElement(s4), t4 = this.m_edges.getPath(e4);
          if (0 !== this.m_shape.getPathUserIndex(t4, this.m_pathOrientationIndex)) {
            a2 = t4;
            break;
          }
          n6 = s4, s4 = this.m_AET.getPrev(s4);
        }
        if (s4 === ct2.st_nullNode()) r2 = true, s4 = n6;
        else {
          const e4 = this.m_AET.getElement(s4);
          r2 = this.m_edges.isBottomUp(e4), s4 = this.m_AET.getNext(s4), r2 = !r2;
        }
        do {
          const e4 = this.m_AET.getElement(s4), i3 = this.m_edges.getPath(e4);
          if (0 === this.m_shape.getPathUserIndex(i3, this.m_pathOrientationIndex)) {
            if (r2 !== this.m_edges.isBottomUp(e4)) {
              const e5 = this.m_shape.getFirstVertex(i3);
              this.m_shape.reverseRingInternal(e5), this.m_shape.setLastVertex(i3, this.m_shape.getPrevVertex(e5)), t3 = true;
            }
            if (this.m_shape.setPathUserIndex(i3, this.m_pathOrientationIndex, r2 ? 3 : 2), !r2) {
              let e5 = this.m_shape.getPathUserIndex(a2, this.m_pathOrientationIndex);
              2 === e5 ? (a2 = this.m_shape.getPathUserIndex(a2, this.m_pathParentsIndex), e5 = this.m_shape.getPathUserIndex(a2, this.m_pathOrientationIndex), n(3 === e5)) : n(3 === e5);
              const t4 = this.m_shape.getPathUserIndex(a2, this.m_pathParentageIndex);
              this.m_shape.setPathUserIndex(a2, this.m_pathParentageIndex, i3), this.m_shape.setPathUserIndex(i3, this.m_pathParentageIndex, t4), this.m_shape.setPathUserIndex(i3, this.m_pathParentsIndex, a2);
            }
            if (this.m_unknownRingOrientationCount--, !this.m_unknownRingOrientationCount) return t3;
          }
          a2 = i3, n6 = s4, s4 = this.m_AET.getNext(s4), r2 = !r2;
        } while (n6 !== e3);
      }
    }
    return t3;
  }
  processBunchForRingOrientationRemoveEdges_(e2) {
    for (let t3 = 0, s3 = e2.length; t3 < s3; t3++) {
      const s4 = e2[t3], n5 = this.m_shape.getUserIndex(s4, this.m_node1UserIndex), r = this.m_shape.getUserIndex(s4, this.m_node2UserIndex);
      if (-1 !== n5) {
        const e3 = this.m_AET.getElement(n5);
        this.m_edges.freeEdge(e3), this.m_shape.setUserIndex(s4, this.m_node1UserIndex, -1);
      }
      if (-1 !== r) {
        const e3 = this.m_AET.getElement(r);
        this.m_edges.freeEdge(e3), this.m_shape.setUserIndex(s4, this.m_node2UserIndex, -1);
      }
      let i2 = -1;
      -1 !== n5 && -1 !== r ? (this.m_AET.deleteNode(n5), this.m_AET.deleteNode(r), e2[t3] = cr) : i2 = -1 !== n5 ? n5 : r, -1 !== i2 && (this.insertEdge_(s4, i2) || this.m_AET.deleteNode(i2), e2[t3] = cr);
    }
  }
  dbgVerifyRingOrientation_() {
  }
  insertEdge_(e2, t3) {
    const s3 = mi.getNAN(), n5 = mi.getNAN();
    this.m_shape.queryXY(e2, s3);
    const r = this.m_shape.getNextVertex(e2);
    this.m_shape.queryXY(r, n5);
    let i2 = false;
    if (s3.y < n5.y) {
      i2 = true;
      const s4 = this.m_edges.newEdge(e2);
      let n6;
      -1 === t3 ? n6 = this.m_AET.addElement(s4) : (n6 = t3, this.m_AET.setElement(n6, s4));
      -1 === this.m_shape.getUserIndex(r, this.m_node1UserIndex) ? this.m_shape.setUserIndex(r, this.m_node1UserIndex, n6) : this.m_shape.setUserIndex(r, this.m_node2UserIndex, n6);
      const o2 = this.m_shape.getPathFromVertex(e2);
      0 === this.m_shape.getPathUserIndex(o2, this.m_pathOrientationIndex) && this.m_unknownNodes.push(n6);
    }
    const o = this.m_shape.getPrevVertex(e2);
    if (this.m_shape.queryXY(o, n5), s3.y < n5.y) {
      i2 = true;
      const s4 = this.m_edges.newEdge(o);
      let n6;
      -1 === t3 ? n6 = this.m_AET.addElement(s4) : (n6 = t3, this.m_AET.setElement(n6, s4));
      -1 === this.m_shape.getUserIndex(o, this.m_node1UserIndex) ? this.m_shape.setUserIndex(o, this.m_node1UserIndex, n6) : this.m_shape.setUserIndex(o, this.m_node2UserIndex, n6);
      const r2 = this.m_shape.getPathFromVertex(e2);
      0 === this.m_shape.getPathUserIndex(r2, this.m_pathOrientationIndex) && this.m_unknownNodes.push(n6);
    }
    return i2;
  }
  fixRingSelfTangency_() {
    const e2 = [], t3 = [];
    let s3 = -1, n5 = -1;
    const r = new mi();
    let i2 = cr, a2 = cr, h2 = -1;
    const m3 = new Jn2(this);
    for (let o = m3.next(); o !== cr; o = m3.next()) {
      const m4 = new mi();
      this.m_shape.queryXY(o, m4);
      const l2 = this.m_shape.getPathFromVertex(o);
      if (r.equals(m4) && a2 === l2) {
        if (-1 === n5 && (s3 = this.m_shape.createPathUserIndex(), this.m_shape.fillPathUserIndexForGeometry(this.m_geometry, s3, -1), n5 = this.m_shape.createUserIndex(), this.m_shape.fillUserIndexForGeometry(this.m_geometry, n5, -1)), -1 === h2) {
          h2 = t3.length, this.m_shape.setUserIndex(i2, n5, h2), t3.push(1);
          -1 === this.m_shape.getPathUserIndex(l2, s3) && (this.m_shape.setPathUserIndex(l2, s3, i2), e2.push(l2));
        }
        this.m_shape.setUserIndex(o, n5, h2), t3[t3.length - 1]++;
      } else h2 = -1, r.assign(m4);
      i2 = o, a2 = l2;
    }
    if (0 === e2.length) return false;
    n(-1 !== s3);
    for (let o = 0, l2 = e2.length; o < l2; o++) {
      const r2 = e2[o];
      let i3 = this.m_shape.getPathUserIndex(r2, s3);
      const a3 = this.m_shape.getUserIndex(i3, n5), h3 = [], m4 = [];
      h3.push(i3), m4.push(a3);
      for (let e3 = this.m_shape.getNextVertex(i3); e3 !== i3; e3 = this.m_shape.getNextVertex(e3)) {
        const s4 = e3, r3 = this.m_shape.getUserIndex(s4, n5);
        if (-1 !== r3) {
          if (0 === m4.length) {
            m4.push(r3), h3.push(s4);
            continue;
          }
          if (m4.at(-1) === r3) {
            const o2 = h3.at(-1);
            this.m_shape.peelALoopIntoAPath(o2, s4), this.m_shape.setUserIndex(e3, n5, -1), t3[r3]--, 1 === t3[r3] && (t3[r3] = 0, m4.pop(), h3.pop()), i3 = o2, e3 = o2;
          } else h3.push(e3), m4.push(r3);
        }
      }
    }
    return this.m_shape.removePathUserIndex(s3), this.m_shape.removeUserIndex(n5), this.m_shape.dbgVerifyVertexCounts(), true;
  }
  progress_(e2 = false) {
  }
  fixRingOrientationImplMain_() {
    const e2 = { stack: [], error: void 0, hasError: false };
    try {
      let t3, s3 = false;
      const n5 = __addDisposableResource(e2, kt(() => {
        this.m_sortedVerticesArray = null;
      }), false);
      if (null === this.m_sortedVertices) {
        const e3 = this.m_shape.getPointCount(this.m_geometry);
        t3 = new st2(0);
        for (let s4 = this.m_shape.getFirstPath(this.m_geometry); s4 !== cr; s4 = this.m_shape.getNextPath(s4)) {
          let e4 = this.m_shape.getFirstVertex(s4);
          for (let n6 = 0, r2 = this.m_shape.getPathSize(s4); n6 < r2; n6++) t3.add(e4), e4 = this.m_shape.getNextVertex(e4);
        }
        this.m_shape.sortVerticesSimpleByY(t3, 0, e3), this.progress_(true), this.m_sortedVerticesArray = t3;
      } else n5.bForget = true;
      if (this.m_bFixSelfTangency && (s3 = this.fixRingSelfTangency_()), 1 === this.m_shape.getPathCount(this.m_geometry)) {
        const e3 = this.m_shape.getFirstPath(this.m_geometry), t4 = this.m_shape.getRingArea(e3);
        if (this.m_shape.setExterior(e3, true), t4 < 0) {
          const t5 = this.m_shape.getFirstVertex(e3);
          return this.m_shape.reverseRingInternal(t5), this.m_shape.setLastVertex(e3, this.m_shape.getPrevVertex(t5)), true;
        }
        return false;
      }
      this.m_shape.dbgVerifyCurves(), this.m_pathOrientationIndex = this.m_shape.createPathUserIndex(), this.m_pathParentageIndex = this.m_shape.createPathUserIndex(), this.m_pathParentsIndex = this.m_shape.createPathUserIndex();
      for (let e3 = this.m_shape.getFirstPath(this.m_geometry); e3 !== cr; e3 = this.m_shape.getNextPath(e3)) this.m_shape.setPathUserIndex(e3, this.m_pathOrientationIndex, 0), this.m_shape.setPathUserIndex(e3, this.m_pathParentageIndex, -1), this.m_shape.setPathUserIndex(e3, this.m_pathParentsIndex, -1);
      const r = [];
      this.m_yScanline = Number.NaN;
      const i2 = mi.getNAN();
      this.m_unknownRingOrientationCount = this.m_shape.getPathCount(this.m_geometry), this.m_node1UserIndex = this.m_shape.createUserIndexUninitialized(), this.m_shape.fillUserIndexForGeometry(this.m_geometry, this.m_node1UserIndex, -1), this.m_node2UserIndex = this.m_shape.createUserIndexUninitialized(), this.m_shape.fillUserIndexForGeometry(this.m_geometry, this.m_node2UserIndex, -1);
      const o = new Jn2(this);
      for (let e3 = o.next(); e3 !== cr && (this.progress_(), this.m_shape.queryXY(e3, i2), i2.y !== this.m_yScanline && r.length && (s3 = this.processBunchForRingOrientationTest_(r) || s3, this.m_sweepComparator.reset(), r.length = 0), r.push(e3), this.m_yScanline = i2.y, 0 !== this.m_unknownRingOrientationCount); e3 = o.next()) ;
      return this.m_unknownRingOrientationCount > 0 && (s3 = this.processBunchForRingOrientationTest_(r) || s3, r.length = 0), this.m_shape.removeUserIndex(this.m_node1UserIndex), this.m_shape.removeUserIndex(this.m_node2UserIndex), this.dbgVerifyRingOrientation_(), s3;
    } catch (t3) {
      e2.error = t3, e2.hasError = true;
    } finally {
      __disposeResources(e2);
    }
  }
  fixRingOrientationImplSimplify_() {
    const e2 = [];
    for (let t3 = this.m_shape.getFirstPath(this.m_geometry); t3 !== cr; ) if (this.progress_(), 3 === this.m_shape.getPathUserIndex(t3, this.m_pathOrientationIndex)) {
      this.m_shape.setExterior(t3, true);
      for (let r = this.m_shape.getPathUserIndex(t3, this.m_pathParentageIndex); r !== cr; ) {
        const s4 = this.m_shape.getPathUserIndex(r, this.m_pathParentageIndex);
        e2.push(r), this.m_shape.setExterior(r, false), this.m_shape.setPathUserIndex(r, this.m_pathParentageIndex, t3), r = s4;
      }
      let s3 = t3, n5 = e2.length;
      for (let e3 = this.m_shape.getNextPath(t3); n5 > 0 && e3 !== cr; e3 = this.m_shape.getNextPath(e3), --n5) {
        if (this.m_shape.getPathUserIndex(e3, this.m_pathParentageIndex) !== t3) {
          s3 = cr;
          break;
        }
        s3 = e3;
      }
      if (0 !== n5) {
        s3 = t3;
        for (let t4 = 0, n6 = e2.length; t4 < n6; t4++) {
          const n7 = e2[t4];
          this.m_shape.setPathUserIndex(n7, this.m_pathParentageIndex, U3), this.m_shape.movePath(this.m_geometry, this.m_shape.getNextPath(s3), n7), s3 = n7;
        }
      }
      e2.length = 0, t3 = this.m_shape.getNextPath(s3);
    } else t3 = this.m_shape.getNextPath(t3);
    this.m_shape.removePathUserIndex(this.m_pathOrientationIndex), this.m_shape.removePathUserIndex(this.m_pathParentageIndex), this.m_shape.removePathUserIndex(this.m_pathParentsIndex);
  }
  fixRingOrientationImplMp2sp_() {
    const e2 = this.m_shape.createPathUserIndex();
    let t3 = 0;
    const s3 = [];
    for (let n5 = this.m_shape.getFirstPath(this.m_geometry); n5 !== cr; ) if (this.progress_(), 3 === this.m_shape.getPathUserIndex(n5, this.m_pathOrientationIndex)) {
      this.m_shape.setExterior(n5, true), this.m_shape.setPathUserIndex(n5, e2, t3), t3++;
      for (let e3 = this.m_shape.getPathUserIndex(n5, this.m_pathParentageIndex); e3 !== cr; ) {
        const t4 = this.m_shape.getPathUserIndex(e3, this.m_pathParentageIndex);
        s3.push(e3), this.m_shape.setExterior(e3, false), this.m_shape.setPathUserIndex(e3, this.m_pathParentageIndex, n5), e3 = t4;
      }
      let r = n5, i2 = s3.length, o = t3;
      for (let t4 = this.m_shape.getNextPath(n5); i2 > 0 && t4 !== cr; t4 = this.m_shape.getNextPath(t4), --i2) {
        if (this.m_shape.getPathUserIndex(t4, this.m_pathParentageIndex) !== n5) {
          r = cr;
          break;
        }
        r = t4, this.m_shape.setPathUserIndex(t4, e2, -o), o++;
      }
      if (0 !== i2) {
        r = n5, o = t3;
        for (let t4 = 0, n6 = s3.length; t4 < n6; t4++) {
          const n7 = s3[t4];
          this.m_shape.setPathUserIndex(n7, e2, -o), o++, this.m_shape.setPathUserIndex(n7, this.m_pathParentageIndex, U3);
        }
        r = n5;
      }
      t3 = o, s3.length = 0, n5 = this.m_shape.getNextPath(r);
    } else n5 = this.m_shape.getNextPath(n5);
    return this.m_shape.removePathUserIndex(this.m_pathOrientationIndex), this.m_shape.removePathUserIndex(this.m_pathParentageIndex), this.m_shape.removePathUserIndex(this.m_pathParentsIndex), e2;
  }
};
function er2(e2, t3, s3, n5, r, i2) {
  const o = new tr2(i2);
  return o.m_shape = e2, o.m_geometry = t3, o.m_knownSimpleResult = s3, o.m_bFixSelfTangency = n5, o.m_polylineDegeneracies = r, o.m_bHasSegmentParentage = e2.hasSegmentParentage(), o.m_bHasSegments = e2.hasCurves(), o.simplify_();
}
var tr2 = class {
  constructor(e2) {
    this.m_shape = null, this.m_geometry = cr, this.m_sortedVertices = new pt(), this.m_bunchEdgeEndPoints = [], this.m_bunchEdgeCenterPoints = [], this.m_bunchEdgeIndices = [], this.m_sorterSegmentBuffer1 = null, this.m_sorterSegmentBuffer2 = null, this.m_knownSimpleResult = -1, this.m_sortedVerticesListIndex = -1, this.m_polylineDegeneracies = cr, this.m_userIndexSortedIndexToVertex = -1, this.m_userIndexSortedAngleIndexToVertex = -1, this.m_nextVertexToProcess = -1, this.m_firstCoincidentVertex = -1, this.m_progressCounter = 0, this.m_bFixSelfTangency = false, this.m_bHasSegmentParentage = false, this.m_bHasSegments = false, this.m_progressTracker = e2;
  }
  compareAngles_(e2, t3) {
    return this.m_bHasSegments ? this.compareAnglesCurves_(e2, t3) : this.compareAnglesLines_(e2, t3);
  }
  compareAnglesLines_(e2, t3) {
    const s3 = this.m_bunchEdgeEndPoints[e2], n5 = new mi();
    this.m_shape.queryXY(s3, n5);
    const r = new mi(), i2 = this.m_bunchEdgeEndPoints[t3];
    if (this.m_shape.queryXY(i2, r), n5.equals(r)) return 0;
    const o = this.m_bunchEdgeCenterPoints[e2], a2 = new mi();
    this.m_shape.queryXY(o, a2);
    const h2 = this.m_bunchEdgeCenterPoints[t3], m3 = new mi();
    this.m_shape.queryXY(h2, m3);
    const l2 = new mi();
    l2.setSub(n5, a2);
    const g2 = new mi();
    g2.setSub(r, m3), (l2.isZero() || g2.isZero()) && k("");
    return mi.compareVectors(l2, g2);
  }
  compareAnglesCurves_(e2, t3) {
    const s3 = this.m_bunchEdgeEndPoints[e2], n5 = this.m_bunchEdgeEndPoints[t3], r = this.m_bunchEdgeCenterPoints[e2], i2 = this.m_bunchEdgeCenterPoints[t3], o = this.m_shape.getNextVertex(r) === s3, a2 = this.m_shape.getNextVertex(i2) === n5, h2 = o ? this.m_shape.isCurve(r) : this.m_shape.isCurve(s3), m3 = a2 ? this.m_shape.isCurve(i2) : this.m_shape.isCurve(n5);
    if (!h2 && !m3) return this.compareAnglesLines_(e2, t3);
    this.m_sorterSegmentBuffer1 || (this.m_sorterSegmentBuffer1 = new fm()), this.m_sorterSegmentBuffer2 || (this.m_sorterSegmentBuffer2 = new fm()), o ? this.m_shape.querySegment(r, this.m_sorterSegmentBuffer1, false, true) : (this.m_shape.querySegment(s3, this.m_sorterSegmentBuffer1, false, true), this.m_sorterSegmentBuffer1.get().reverse()), a2 ? this.m_shape.querySegment(i2, this.m_sorterSegmentBuffer2, false, true) : (this.m_shape.querySegment(n5, this.m_sorterSegmentBuffer2, false, true), this.m_sorterSegmentBuffer2.get().reverse());
    return Ie(this.m_sorterSegmentBuffer1.get(), this.m_sorterSegmentBuffer2.get());
  }
  beforeRemoveVertex_(e2, t3) {
    const s3 = this.m_shape.getUserIndex(e2, this.m_userIndexSortedIndexToVertex);
    if (this.m_nextVertexToProcess === s3 && (this.m_nextVertexToProcess = this.m_sortedVertices.getNext(this.m_nextVertexToProcess)), this.m_firstCoincidentVertex === s3 && (this.m_firstCoincidentVertex = this.m_sortedVertices.getNext(this.m_firstCoincidentVertex)), this.m_sortedVertices.deleteElement(this.m_sortedVerticesListIndex, s3), this.removeAngleSortInfo_(e2), t3) {
      const t4 = this.m_shape.getPathFromVertex(e2);
      if (t4 !== cr) {
        if (this.m_shape.getFirstVertex(t4) === e2) {
          const s4 = this.m_shape.getNextVertex(e2);
          if (s4 !== e2) {
            if (this.m_shape.getPathFromVertex(s4) === t4) return void this.m_shape.setFirstVertex(t4, s4);
            {
              const s5 = this.m_shape.getPrevVertex(e2);
              if (s5 !== e2) {
                if (this.m_shape.getPathFromVertex(s5) === t4) return void this.m_shape.setFirstVertex(t4, s5);
              }
            }
          }
          this.m_shape.setFirstVertex(t4, cr), this.m_shape.setLastVertex(t4, cr);
        }
      }
    }
  }
  processBunch_() {
    let e2 = false;
    const t3 = new mi(0, 0);
    for (; ; ) {
      this.m_bunchEdgeEndPoints.length = 0, this.m_bunchEdgeCenterPoints.length = 0, this.m_bunchEdgeIndices.length = 0;
      let s3 = this.m_firstCoincidentVertex, n5 = 0, r = true;
      for (; s3 !== this.m_nextVertexToProcess; ) {
        const e3 = this.m_sortedVertices.getData(s3);
        r && (this.m_shape.queryXY(e3, t3), r = false);
        const i3 = this.m_shape.getPrevVertex(e3), o = this.m_shape.getNextVertex(e3);
        this.m_shape.getUserIndex(i3, this.m_userIndexSortedAngleIndexToVertex) !== U3 && (this.m_bunchEdgeEndPoints.push(i3), this.m_shape.setUserIndex(i3, this.m_userIndexSortedAngleIndexToVertex, U3), this.m_bunchEdgeCenterPoints.push(e3), this.m_bunchEdgeIndices.push(n5++));
        this.m_shape.getUserIndex(o, this.m_userIndexSortedAngleIndexToVertex) !== U3 && (this.m_bunchEdgeEndPoints.push(o), this.m_shape.setUserIndex(o, this.m_userIndexSortedAngleIndexToVertex, U3), this.m_bunchEdgeCenterPoints.push(e3), this.m_bunchEdgeIndices.push(n5++)), s3 = this.m_sortedVertices.getNext(s3);
      }
      if (this.m_bunchEdgeEndPoints.length < 2) {
        1 === this.m_bunchEdgeEndPoints.length && this.m_shape.setUserIndex(this.m_bunchEdgeEndPoints[0], this.m_userIndexSortedAngleIndexToVertex, -1);
        break;
      }
      this.m_bunchEdgeIndices.sort((e3, t4) => this.compareAngles_(e3, t4));
      for (let e3 = 0, t4 = this.m_bunchEdgeIndices.length; e3 < t4; e3++) {
        const t5 = this.m_bunchEdgeIndices[e3], s4 = this.m_bunchEdgeEndPoints[t5];
        this.m_shape.setUserIndex(s4, this.m_userIndexSortedAngleIndexToVertex, e3);
      }
      const i2 = this.processCrossOvers_(t3);
      for (let e3 = 0, t4 = this.m_bunchEdgeIndices.length; e3 < t4; e3++) {
        const t5 = this.m_bunchEdgeIndices[e3];
        if (-1 === t5) continue;
        const s4 = this.m_bunchEdgeEndPoints[t5];
        this.m_shape.setUserIndex(s4, this.m_userIndexSortedAngleIndexToVertex, -1);
      }
      if (!i2) break;
      e2 = true;
    }
    return e2;
  }
  processCrossOvers_(e2) {
    let t3 = false, s3 = true;
    for (; s3; ) {
      s3 = false;
      let n5 = 0;
      -1 === this.m_bunchEdgeIndices[n5] && (n5 = this.getNextEdgeIndex_(n5));
      let r = this.getNextEdgeIndex_(n5);
      for (let i2 = 0, o = this.m_bunchEdgeIndices.length; i2 < o && -1 !== n5 && -1 !== r && n5 !== r; i2++) {
        const i3 = this.m_bunchEdgeIndices[n5], o2 = this.m_bunchEdgeIndices[r], a2 = this.m_bunchEdgeEndPoints[i3], h2 = this.m_bunchEdgeEndPoints[o2];
        let m3 = this.m_shape.getNextVertex(a2), l2 = false;
        this.m_shape.isEqualXYPoint2D(m3, e2) || (m3 = this.m_shape.getPrevVertex(a2), l2 = true);
        let g2 = this.m_shape.getNextVertex(h2), u = false;
        this.m_shape.isEqualXYPoint2D(g2, e2) || (g2 = this.m_shape.getPrevVertex(h2), u = true);
        const c = l2 ? this.m_shape.getPrevVertex(m3) : this.m_shape.getNextVertex(m3), _ = u ? this.m_shape.getPrevVertex(g2) : this.m_shape.getNextVertex(g2);
        let d2 = false;
        (this.removeSpike_(m3) || this.removeSpike_(g2) || this.removeSpike_(a2) || this.removeSpike_(h2) || this.removeSpike_(c) || this.removeSpike_(_)) && (d2 = true), m3 !== g2 && (!d2 && this.m_shape.isEqualXY(a2, h2) && (d2 = this.resolveOverlap_(l2, u, m3, a2, g2, h2)), !d2 && this.m_shape.isEqualXY(c, _) && (d2 = this.resolveOverlap_(!l2, !u, m3, c, g2, _)), !d2 && this.m_shape.isEqualXY(a2, _) && (d2 = this.resolveOverlap_(l2, !u, m3, a2, g2, _)), !d2 && this.m_shape.isEqualXY(c, h2) && (d2 = this.resolveOverlap_(!l2, u, m3, c, g2, h2))), d2 && (t3 = true), s3 ||= d2, n5 = d2 ? this.getNextEdgeIndex_(n5) : r, r = this.getNextEdgeIndex_(n5);
      }
    }
    if (!t3) {
      let s4 = 0;
      -1 === this.m_bunchEdgeIndices[s4] && (s4 = this.getNextEdgeIndex_(s4));
      let n5 = this.getNextEdgeIndex_(s4);
      for (let r = 0, i2 = this.m_bunchEdgeIndices.length; r < i2 && -1 !== s4 && -1 !== n5 && s4 !== n5; r++) {
        const r2 = this.m_bunchEdgeIndices[s4], i3 = this.m_bunchEdgeIndices[n5], o = this.m_bunchEdgeEndPoints[r2], a2 = this.m_bunchEdgeEndPoints[i3];
        let h2 = this.m_shape.getNextVertex(o);
        this.m_shape.isEqualXYPoint2D(h2, e2) || (h2 = this.m_shape.getPrevVertex(o));
        let m3 = this.m_shape.getNextVertex(a2);
        this.m_shape.isEqualXYPoint2D(m3, e2) || (m3 = this.m_shape.getPrevVertex(a2));
        const l2 = this.getDirection_(h2, o), g2 = this.getDirection_(m3, a2), u = l2 ? this.m_shape.getPrevVertex(h2) : this.m_shape.getNextVertex(h2), c = g2 ? this.m_shape.getPrevVertex(m3) : this.m_shape.getNextVertex(m3), _ = this.detectAndResolveCrossOver_(l2, g2, o, h2, u, a2, m3, c);
        1 !== _ ? 0 === _ ? (s4 = this.getNextEdgeIndex_(s4), n5 = this.getNextEdgeIndex_(s4)) : (s4 = this.getPrevEdgeIndex_(s4), n5 = this.getNextEdgeIndex_(s4)) : t3 = true;
      }
    }
    return t3;
  }
  simplify_() {
    if (this.m_shape.getGeometryType(this.m_geometry) === a.enumPolygon && 1 === this.m_shape.getFillRule(this.m_geometry)) {
      new Ka2(this.m_progressTracker).planarSimplifyNoCrackingAndCluster(this.m_bFixSelfTangency, this.m_shape, this.m_geometry, 0);
    }
    let e2 = false;
    this.m_userIndexSortedIndexToVertex = -1, this.m_userIndexSortedAngleIndexToVertex = -1, this.m_userIndexSortedAngleIndexToVertex = this.m_shape.createUserIndexUninitialized();
    const t3 = this.m_shape.getPointCount(this.m_geometry), n5 = new st2(0);
    this.m_shape.dbgVerifyMonotone();
    for (let s3 = this.m_shape.getFirstPath(this.m_geometry); s3 !== cr; s3 = this.m_shape.getNextPath(s3)) {
      let e3 = this.m_shape.getFirstVertex(s3);
      for (let t4 = 0, r = this.m_shape.getPathSize(s3); t4 < r; t4++) this.m_shape.setUserIndex(e3, this.m_userIndexSortedAngleIndexToVertex, -1), n5.add(e3), e3 = this.m_shape.getNextVertex(e3);
    }
    this.m_shape.sortVerticesSimpleByY(n5, 0, t3), this.progress_(true), this.m_userIndexSortedIndexToVertex = this.m_shape.createUserIndexUninitialized(), this.m_sortedVertices.reserveNodes(t3), this.m_sortedVerticesListIndex = this.m_sortedVertices.createList(0);
    for (let s3 = 0; s3 < t3; s3++) {
      const e3 = n5.read(s3), t4 = this.m_sortedVertices.addElement(this.m_sortedVerticesListIndex, e3);
      this.m_shape.setUserIndex(e3, this.m_userIndexSortedIndexToVertex, t4);
    }
    this.m_nextVertexToProcess = -1, this.cleanupSpikes_() && (e2 = true);
    let i2 = 0, o = false;
    do {
      o = false, this.m_nextVertexToProcess = -1, this.m_firstCoincidentVertex = this.m_sortedVertices.getFirst(this.m_sortedVerticesListIndex);
      const t4 = new mi(0, 0);
      this.m_firstCoincidentVertex !== pt.st_nullNode() && this.m_shape.queryXY(this.m_sortedVertices.getData(this.m_firstCoincidentVertex), t4);
      let s3 = 0, n6 = this.m_firstCoincidentVertex;
      for (; n6 !== pt.st_nullNode() && (n6 = this.m_sortedVertices.getNext(n6), n6 !== pt.st_nullNode()); ) {
        this.progress_();
        const e3 = this.m_sortedVertices.getData(n6), r = mi.getNAN();
        if (this.m_shape.queryXY(e3, r), t4.equals(r)) s3++;
        else {
          if (s3 > 0) {
            this.m_nextVertexToProcess = n6;
            const e4 = this.processBunch_();
            n6 = this.m_nextVertexToProcess, n6 !== pt.st_nullNode() && this.m_shape.queryXY(this.m_sortedVertices.getData(n6), r), e4 && (o = true);
          }
          t4.setCoordsPoint2D(r), this.m_firstCoincidentVertex = n6, s3 = 0;
        }
      }
      if (this.m_nextVertexToProcess = -1, s3 > 0) {
        this.processBunch_() && (o = true);
      }
      i2++ > 10 && b(""), o && this.fixOrphanVertices_(), this.cleanupSpikes_() && (o = true), e2 ||= o;
    } while (o);
    return this.m_shape.dbgVerifyMonotone(), this.m_shape.dbgVerifyCurves(), this.m_shape.removeUserIndex(this.m_userIndexSortedIndexToVertex), this.m_shape.removeUserIndex(this.m_userIndexSortedAngleIndexToVertex), e2 = jn2(this.m_shape, this.m_geometry, this.m_sortedVertices, this.m_bFixSelfTangency, this.m_progressTracker) || e2, this.m_shape.dbgVerifyCurves(), e2;
  }
  getDirection_(e2, t3) {
    return this.m_shape.getNextVertex(t3) !== e2;
  }
  detectAndResolveCrossOver_(e2, t3, s3, n5, r, i2, o, a2) {
    if (n5 === o) return this.removeAngleSortInfo_(s3), this.removeAngleSortInfo_(i2), -1;
    const h2 = this.m_shape.getUserIndex(s3, this.m_userIndexSortedAngleIndexToVertex), m3 = this.m_shape.getUserIndex(r, this.m_userIndexSortedAngleIndexToVertex), l2 = this.m_shape.getUserIndex(i2, this.m_userIndexSortedAngleIndexToVertex), g2 = this.m_shape.getUserIndex(a2, this.m_userIndexSortedAngleIndexToVertex), u = Yt(8, Number.NaN), c = Yt(4, Number.NaN);
    u[0] = 0, c[0] = h2, u[1] = 0, c[1] = m3, u[2] = 1, c[2] = l2, u[3] = 1, c[3] = g2;
    for (let d2 = 1; d2 < 4; d2++) {
      const e3 = c[d2], t4 = u[d2];
      let s4 = d2 - 1;
      for (; s4 >= 0 && c[s4] > e3; ) c[s4 + 1] = c[s4], u[s4 + 1] = u[s4], s4--;
      c[s4 + 1] = e3, u[s4 + 1] = t4;
    }
    let _ = 0;
    if (u[0] && (_ |= 1), u[1] && (_ |= 2), u[2] && (_ |= 4), u[3] && (_ |= 8), 5 !== _ && 10 !== _) return 0;
    if (e2 !== t3 && (a2 = Pt(i2, i2 = a2)), e2) this.m_shape.setNextVertex(a2, n5), this.m_shape.setPrevVertex(n5, a2), this.m_shape.setNextVertex(r, o), this.m_shape.setPrevVertex(o, r), this.m_bHasSegmentParentage && (this.m_shape.setSegmentParentageBreakVertex(n5, true), this.m_shape.setSegmentParentageBreakVertex(o, true));
    else {
      if (this.m_shape.setPrevVertex(a2, n5), this.m_shape.setNextVertex(n5, a2), this.m_shape.setPrevVertex(r, o), this.m_shape.setNextVertex(o, r), this.m_bHasSegmentParentage) {
        const e3 = this.m_shape.getSegmentParentage(n5), t4 = this.m_shape.getSegmentParentage(o);
        this.m_shape.setSegmentParentageAndBreak(n5, t4, true), this.m_shape.setSegmentParentageAndBreak(o, e3, true);
      }
      if (this.m_bHasSegments) {
        const e3 = this.m_shape.getVertexIndex(n5), t4 = this.m_shape.getVertexIndex(o), s4 = this.m_shape.getSegmentFromIndex(e3);
        this.m_shape.setSegmentToIndex(e3, null);
        const r2 = this.m_shape.getSegmentFromIndex(t4);
        this.m_shape.setSegmentToIndex(t4, null), this.m_shape.setSegmentToIndex(e3, r2), this.m_shape.setSegmentToIndex(t4, s4);
      }
    }
    return 1;
  }
  resolveOverlap_(e2, t3, s3, n5, r, i2) {
    return this.resolveOverlapOddEven_(e2, t3, s3, n5, r, i2);
  }
  resolveOverlapOddEven_(e2, t3, s3, n5, r, i2) {
    if (e2 !== t3) {
      e2 || (r = Pt(s3, s3 = r), i2 = Pt(n5, n5 = i2));
      const t4 = this.m_shape.getNextVertex(r), o = this.m_shape.getNextVertex(s3);
      if (this.m_shape.setNextVertex(s3, t4), this.m_shape.setPrevVertex(t4, s3), this.m_shape.setNextVertex(r, o), this.m_shape.setPrevVertex(o, r), this.m_bHasSegments) {
        const e3 = this.m_shape.getVertexIndex(s3), t5 = this.m_shape.getVertexIndex(r), n6 = this.m_shape.getSegmentFromIndex(e3);
        this.m_shape.setSegmentToIndex(e3, null);
        const i3 = this.m_shape.getSegmentFromIndex(t5);
        this.m_shape.setSegmentToIndex(t5, null), this.m_shape.setSegmentToIndex(e3, i3), this.m_shape.setSegmentToIndex(t5, n6);
      }
      if (this.m_bHasSegmentParentage) {
        const e3 = this.m_shape.getSegmentParentage(s3), t5 = this.m_shape.getSegmentParentage(r);
        this.m_shape.setSegmentParentageAndBreak(s3, t5, true), this.m_shape.setSegmentParentageAndBreak(r, e3, true), this.m_shape.setSegmentParentageBreakVertex(n5, true), this.m_shape.setSegmentParentageBreakVertex(i2, true);
      }
      this.removeSpike_(r);
    } else {
      const o = e2 ? s3 : n5, a2 = t3 ? r : i2, h2 = e2 ? n5 : s3, m3 = t3 ? i2 : r;
      let l2 = null;
      if (this.m_bHasSegments) {
        const e3 = this.m_shape.getVertexIndex(m3);
        l2 = this.m_shape.getSegmentFromIndex(e3), this.m_shape.setSegmentToIndex(e3, null);
        const t4 = this.m_shape.getVertexIndex(a2);
        this.m_shape.setSegmentToIndex(t4, null);
        const s4 = this.m_shape.getVertexIndex(o);
        this.m_shape.setSegmentToIndex(s4, null);
      }
      let g2 = -1;
      this.m_bHasSegmentParentage && (g2 = this.m_shape.getSegmentParentage(m3));
      let u = false;
      this.m_shape.setNextVertex(o, a2), this.m_shape.setNextVertex(a2, o), this.m_shape.setPrevVertex(h2, m3), this.m_shape.setPrevVertex(m3, h2);
      let c = m3;
      for (; c !== a2; ) {
        const e3 = this.m_shape.getPrevVertex(c), t4 = this.m_shape.getNextVertex(c);
        if (this.m_shape.setPrevVertex(c, t4), this.m_shape.setNextVertex(c, e3), u ||= c === o, this.m_bHasSegments && c !== o) {
          const e4 = this.m_shape.getVertexIndex(t4), s4 = l2;
          l2 = this.m_shape.getSegmentFromIndex(e4), null !== s4 && s4.reverse(), this.m_shape.setSegmentToIndex(e4, s4);
        }
        if (this.m_bHasSegmentParentage) {
          const e4 = this.m_shape.getSegmentParentage(t4);
          this.m_shape.setSegmentParentagePreserveBreak(t4, g2), g2 = e4;
        }
        c = t4;
      }
      let _ = null;
      if (!u) {
        const e3 = this.m_shape.getPrevVertex(a2), t4 = this.m_shape.getNextVertex(a2);
        if (this.m_shape.setPrevVertex(a2, t4), this.m_shape.setNextVertex(a2, e3), this.m_bHasSegments) {
          const e4 = this.m_shape.getVertexIndex(a2);
          _ = this.m_shape.getSegmentFromIndex(e4), this.m_shape.setSegmentToIndex(e4, null);
        }
      }
      let d2 = -1, p3 = -1;
      if (this.m_bHasSegmentParentage && (d2 = u ? this.m_shape.getSegmentParentage(o) : this.m_shape.getSegmentParentage(a2), p3 = this.m_shape.getSegmentParentage(h2)), this.transferVertexData_(a2, o), this.beforeRemoveVertex_(a2, true), this.m_shape.removeVertexInternal(a2, true), this.removeAngleSortInfo_(o), this.transferVertexData_(m3, h2), this.beforeRemoveVertex_(m3, true), this.m_shape.removeVertexInternal(m3, true), this.removeAngleSortInfo_(h2), this.m_bHasSegmentParentage && (this.m_shape.setSegmentParentageAndBreak(o, d2, true), this.m_shape.setSegmentParentageAndBreak(h2, p3, true)), _) {
        const e3 = this.m_shape.getVertexIndex(o);
        this.m_shape.setSegmentToIndex(e3, _);
      }
    }
    return true;
  }
  cleanupSpikes_() {
    let e2 = false;
    for (let t3 = this.m_shape.getFirstPath(this.m_geometry); t3 !== cr; ) {
      const s3 = this.m_shape.getNextPath(t3);
      let n5 = this.m_shape.getFirstVertex(t3);
      for (let r = 0, i2 = this.m_shape.getPathSize(t3); r < i2 && i2 > 1; ) {
        this.progress_();
        const { v: s4, bModified: o } = this.checkAndCleanupSpike_(t3, n5);
        if (s4 === cr) break;
        o ? (e2 = true, n5 = s4, r = 0, i2 = this.m_shape.getPathSize(t3)) : (n5 = s4, r++);
      }
      t3 = s3;
    }
    return e2;
  }
  checkAndCleanupSpike_(e2, t3) {
    const s3 = { v: cr, bModified: false };
    let n5 = this.m_shape.getPrevVertex(t3), r = this.m_shape.getNextVertex(t3), i2 = cr, o = cr;
    for (; this.m_shape.isEqualXY(n5, r) && (i2 = n5, o = r, r !== t3); ) n5 = this.m_shape.getPrevVertex(n5), r = this.m_shape.getNextVertex(r);
    if (i2 === cr) return s3.v = r, s3;
    s3.bModified = true;
    for (let a2 = this.m_shape.getNextVertex(i2); this.beforeRemoveVertex_(a2, false), a2 !== o; a2 = this.m_shape.getNextVertex(a2)) ;
    if (i2 === t3) return this.m_polylineDegeneracies !== cr ? this.m_shape.movePath(this.m_polylineDegeneracies, cr, e2) : this.m_shape.removePath(e2), s3.v = cr, s3;
    {
      const e3 = this.m_shape.peelALoopIntoAPath(i2, o);
      this.m_polylineDegeneracies !== cr ? this.m_shape.movePath(this.m_polylineDegeneracies, cr, e3) : this.m_shape.removePath(e3);
    }
    return s3.v = i2, s3;
  }
  removeSpike_(e2) {
    let t3 = this.m_shape.getPrevVertex(e2), s3 = this.m_shape.getNextVertex(e2), n5 = cr, r = cr;
    for (; this.m_shape.isEqualXY(t3, s3) && (n5 = t3, r = s3, s3 !== e2); ) t3 = this.m_shape.getPrevVertex(t3), s3 = this.m_shape.getNextVertex(s3);
    if (n5 === cr) return false;
    if (this.m_shape.peelALoop(n5, r), this.m_bHasSegmentParentage && (this.m_shape.setSegmentParentageBreakVertex(n5, true), this.m_shape.setSegmentParentageBreakVertex(r, true)), this.removeAngleSortInfo_(n5), this.m_polylineDegeneracies === cr) for (let i2 = this.m_shape.getNextVertex(r); ; ) {
      const e3 = this.m_shape.getNextVertex(i2);
      if (this.removeAngleSortInfo_(i2), this.beforeRemoveVertex_(i2, true), this.m_shape.setSegmentToIndex(this.m_shape.getVertexIndex(i2), null), this.m_shape.removeVertexInternal(i2, false), i2 === r) break;
      i2 = e3;
    }
    else {
      for (let t4 = r; ; ) {
        const e4 = this.m_shape.getNextVertex(t4);
        if (this.removeAngleSortInfo_(t4), this.beforeRemoveVertex_(t4, false), t4 = e4, t4 === r) break;
      }
      const e3 = [false];
      this.m_shape.insertClosedPath(this.m_polylineDegeneracies, cr, r, r, e3);
    }
    return true;
  }
  fixOrphanVertices_() {
    let e2 = 0;
    for (let n5 = this.m_sortedVertices.getFirst(this.m_sortedVertices.getFirstList()); -1 !== n5; n5 = this.m_sortedVertices.getNext(n5)) {
      const e3 = this.m_sortedVertices.getData(n5);
      this.m_shape.setPathToVertex(e3, cr);
    }
    let t3 = 0;
    for (let n5 = this.m_shape.getFirstPath(this.m_geometry); n5 !== cr; ) {
      const s4 = this.m_shape.getFirstVertex(n5);
      if (s4 === cr || this.m_shape.getPathFromVertex(s4) !== cr) {
        const e3 = n5;
        n5 = this.m_shape.getNextPath(n5), this.m_shape.removePathOnly(e3);
        continue;
      }
      this.m_shape.setPathToVertex(s4, n5);
      let r = 1;
      for (let e3 = this.m_shape.getNextVertex(s4); e3 !== s4; e3 = this.m_shape.getNextVertex(e3)) this.m_shape.setPathToVertex(e3, n5), r++;
      this.m_shape.setRingAreaValid(n5, false), this.m_shape.setPathSize(n5, r), this.m_shape.setLastVertex(n5, this.m_shape.getPrevVertex(s4)), t3 += r, e2++, n5 = this.m_shape.getNextPath(n5);
    }
    for (let n5 = this.m_sortedVertices.getFirst(this.m_sortedVertices.getFirstList()); -1 !== n5; n5 = this.m_sortedVertices.getNext(n5)) {
      const s4 = this.m_sortedVertices.getData(n5);
      if (this.m_shape.getPathFromVertex(s4) !== cr) continue;
      const r = [false], i2 = this.m_shape.insertClosedPath(this.m_geometry, cr, s4, s4, r);
      t3 += this.m_shape.getPathSize(i2), e2++;
    }
    this.m_shape.setGeometryPathCount(this.m_geometry, e2), this.m_shape.setGeometryVertexCount(this.m_geometry, t3);
    let s3 = 0;
    for (let n5 = this.m_shape.getFirstGeometry(); n5 !== cr; n5 = this.m_shape.getNextGeometry(n5)) s3 += this.m_shape.getPointCount(n5);
    this.m_shape.setTotalPointCount(s3);
  }
  getNextEdgeIndex_(e2) {
    if (-1 === e2) return -1;
    for (let t3 = 0, s3 = this.m_bunchEdgeIndices.length - 1; t3 < s3; t3++) if (e2 = (e2 + 1) % this.m_bunchEdgeIndices.length, -1 !== this.m_bunchEdgeIndices[e2]) return e2;
    return -1;
  }
  getPrevEdgeIndex_(e2) {
    if (-1 === e2) return -1;
    for (let t3 = 0, s3 = this.m_bunchEdgeIndices.length - 1; t3 < s3; t3++) if (e2 = (this.m_bunchEdgeIndices.length + e2 - 1) % this.m_bunchEdgeIndices.length, -1 !== this.m_bunchEdgeIndices[e2]) return e2;
    return -1;
  }
  transferVertexData_(e2, t3) {
    const s3 = this.m_shape.getUserIndex(t3, this.m_userIndexSortedIndexToVertex), n5 = this.m_shape.getUserIndex(t3, this.m_userIndexSortedAngleIndexToVertex);
    this.m_shape.transferAllDataToTheVertex(e2, t3), this.m_shape.setUserIndex(t3, this.m_userIndexSortedIndexToVertex, s3), this.m_shape.setUserIndex(t3, this.m_userIndexSortedAngleIndexToVertex, n5);
  }
  removeAngleSortInfo_(e2) {
    const t3 = this.m_shape.getUserIndex(e2, this.m_userIndexSortedAngleIndexToVertex);
    -1 !== t3 && (this.m_bunchEdgeIndices[t3] = -1, this.m_shape.setUserIndex(e2, this.m_userIndexSortedAngleIndexToVertex, -1));
  }
  progress_(e2 = false) {
  }
};
function sr2(t3, n5, r, i2, o, a2 = true) {
  switch (ir2(i2)) {
    case 0:
      break;
    case 1:
      P("relation string length has to be 9 characters");
      break;
    default:
      P("relation string");
  }
  if (a2) {
    const e2 = xr2(i2, t3.getDimension(), n5.getDimension());
    if (0 !== e2) return kr2(t3, n5, r, e2, o);
  }
  let h2 = 0;
  if ("number" == typeof r) h2 = r;
  else {
    const e2 = n3.constructEmpty();
    t3.queryEnvelope(e2);
    const s3 = n3.constructEmpty();
    n5.queryEnvelope(s3);
    const i3 = n3.constructEmpty();
    i3.setCoords({ env2D: e2 }), i3.mergeEnvelope2D(s3), h2 = zt2(r, i3, false);
  }
  const m3 = Tr2(t3, h2), l2 = Tr2(n5, h2);
  if (m3.isEmpty() || l2.isEmpty()) return fr2(m3, l2, i2);
  const g2 = m3.getGeometryType(), u = l2.getGeometryType();
  let c = false;
  switch (g2) {
    case a.enumPolygon:
      switch (u) {
        case a.enumPolygon:
          c = or2(m3, l2, h2, i2, o);
          break;
        case a.enumPolyline:
          c = ar2(m3, l2, h2, i2, o);
          break;
        case a.enumPoint:
          c = ur2(m3, l2, h2, i2);
          break;
        case a.enumMultiPoint:
          c = hr2(m3, l2, h2, i2, o);
      }
      break;
    case a.enumPolyline:
      switch (u) {
        case a.enumPolygon:
          c = ar2(l2, m3, h2, Gr2(i2), o);
          break;
        case a.enumPolyline:
          c = mr2(m3, l2, h2, i2, o);
          break;
        case a.enumPoint:
          c = cr2(m3, l2, h2, i2, o);
          break;
        case a.enumMultiPoint:
          c = lr2(m3, l2, h2, i2, o);
      }
      break;
    case a.enumPoint:
      switch (u) {
        case a.enumPolygon:
          c = ur2(l2, m3, h2, Gr2(i2));
          break;
        case a.enumPolyline:
          c = cr2(l2, m3, h2, Gr2(i2), o);
          break;
        case a.enumPoint:
          c = dr2(m3, l2, h2, i2);
          break;
        case a.enumMultiPoint:
          c = _r2(l2, m3, h2, Gr2(i2));
      }
      break;
    case a.enumMultiPoint:
      switch (u) {
        case a.enumPolygon:
          c = hr2(l2, m3, h2, Gr2(i2), o);
          break;
        case a.enumPolyline:
          c = lr2(l2, m3, h2, Gr2(i2), o);
          break;
        case a.enumMultiPoint:
          c = gr2(m3, l2, h2, i2, o);
          break;
        case a.enumPoint:
          c = _r2(m3, l2, h2, i2);
      }
      break;
    default:
      c = false;
  }
  return c;
}
function nr2(e2, t3, s3, n5) {
  const r = new vr2();
  r.resetMatrix_(), r.setPredicates_("T*****F**"), r.setAreaAreaPredicates_();
  const i2 = n3.constructEmpty(), o = n3.constructEmpty();
  e2.queryEnvelope(i2), t3.queryEnvelope(o);
  let a2 = false;
  if (qr2(i2, o, s3) && (r.areaAreaDisjointPredicates_(e2, t3), a2 = true), a2 || Br2(e2, t3), a2) {
    return pr2(r.m_matrix, r.m_scl);
  }
  let h2 = new Pr(), m3 = h2.addGeometry(e2), l2 = h2.addGeometry(t3), g2 = null, u = 0;
  if (e2.hasNonLinearSegments() || t3.hasNonLinearSegments()) {
    g2 = new fa2();
    const e3 = _a2(s3, h2.getEnvelope2D(n5));
    u = pa2(e3, 0), aa2(h2, e3, s3, 12e3, g2, null, n5);
  }
  ya2(h2, new Et2(s3, 0).add(u), n5, false, false);
  const c = h2.getGeometry(l2).getBoundary();
  if (h2.filterClosePoints(0, true, true, false, cr), er2(h2, m3, -1, false, cr, n5), 0 === h2.getPointCount(m3)) return false;
  er2(h2, l2, -1, false, cr, n5), r.setEditShape_(h2, n5);
  const _ = 0 === h2.getPointCount(l2);
  if (!_) {
    r.computeMatrixTopoGraphHalfEdges_(m3, l2), r.m_topoGraph.removeShape();
    const e3 = pr2(r.m_matrix, r.m_scl);
    if (!e3) return e3;
  }
  const d2 = h2.getGeometry(m3);
  h2 = new Pr(), m3 = h2.addGeometry(d2), l2 = h2.addGeometry(c), r.setEditShape_(h2, n5), r.m_predicateCount = 0, r.resetMatrix_(), r.setPredicates_(_ ? "T*****F**" : "******F**"), r.setAreaLinePredicates_(), r.computeMatrixTopoGraphHalfEdges_(m3, l2), r.m_topoGraph.removeShape();
  return pr2(r.m_matrix, r.m_scl);
}
function rr2(e2, t3, s3, n5) {
  const r = new vr2();
  r.resetMatrix_(), r.setPredicates_("T*****F**"), r.setAreaLinePredicates_();
  const i2 = n3.constructEmpty(), o = n3.constructEmpty();
  e2.queryEnvelope(i2), t3.queryEnvelope(o);
  let a2 = false;
  if (qr2(i2, o, s3) && (r.areaLineDisjointPredicates_(e2, t3), a2 = true), a2 || Br2(e2, t3), a2) {
    return pr2(r.m_matrix, r.m_scl);
  }
  const h2 = new Pr(), m3 = h2.addGeometry(e2), l2 = h2.addGeometry(t3);
  if (r.setEditShapeCrackAndCluster_(h2, new Et2(s3, 0), n5), 0 === h2.getPointCount(m3)) return false;
  r.computeMatrixTopoGraphHalfEdges_(m3, l2), r.m_topoGraph.removeShape();
  return pr2(r.m_matrix, r.m_scl);
}
function ir2(e2) {
  if (9 !== e2.length) return 1;
  for (let t3 = 0; t3 < 9; t3++) {
    const s3 = e2[t3];
    if ("*" !== s3 && "T" !== s3 && "F" !== s3 && "0" !== s3 && "1" !== s3 && "2" !== s3) return 2;
  }
  return 0;
}
function or2(e2, t3, s3, n5, r) {
  const i2 = new vr2();
  i2.resetMatrix_(), i2.setPredicates_(n5), i2.setAreaAreaPredicates_();
  const o = n3.constructEmpty(), a2 = n3.constructEmpty();
  e2.queryEnvelope(o), t3.queryEnvelope(a2);
  let h2 = false;
  if (qr2(o, a2, s3) && (i2.areaAreaDisjointPredicates_(e2, t3), h2 = true), h2 || Br2(e2, t3), !h2) {
    const n6 = new Pr(), o2 = n6.addGeometry(e2), a3 = n6.addGeometry(t3);
    i2.setEditShapeCrackAndCluster_(n6, new Et2(s3, 0), r), i2.computeMatrixTopoGraphHalfEdges_(o2, a3), i2.m_topoGraph.removeShape();
  }
  return pr2(i2.m_matrix, i2.m_scl);
}
function ar2(e2, t3, s3, n5, r) {
  const i2 = new vr2();
  i2.resetMatrix_(), i2.setPredicates_(n5), i2.setAreaLinePredicates_();
  const o = n3.constructEmpty(), a2 = n3.constructEmpty();
  e2.queryEnvelope(o), t3.queryEnvelope(a2);
  let h2 = false;
  if (qr2(o, a2, s3) && (i2.areaLineDisjointPredicates_(e2, t3), h2 = true), h2 || Br2(e2, t3), !h2) {
    const n6 = new Pr(), o2 = n6.addGeometry(e2), a3 = n6.addGeometry(t3);
    i2.setEditShapeCrackAndCluster_(n6, new Et2(s3, 0), r), i2.m_clusterIndexB = i2.m_topoGraph.createUserIndexForClusters(), wr2(a3, i2.m_topoGraph, i2.m_clusterIndexB), i2.computeMatrixTopoGraphHalfEdges_(o2, a3), i2.m_topoGraph.deleteUserIndexForClusters(i2.m_clusterIndexB), i2.m_topoGraph.removeShape();
  }
  return pr2(i2.m_matrix, i2.m_scl);
}
function hr2(e2, t3, s3, n5, r) {
  const i2 = new vr2();
  i2.resetMatrix_(), i2.setPredicates_(n5), i2.setAreaPointPredicates_();
  const o = n3.constructEmpty(), a2 = n3.constructEmpty();
  e2.queryEnvelope(o), t3.queryEnvelope(a2);
  let h2 = false;
  if (qr2(o, a2, s3) && (i2.areaPointDisjointPredicates_(e2), h2 = true), h2 || Br2(e2, t3), !h2) {
    const n6 = new Pr(), o2 = n6.addGeometry(e2), a3 = n6.addGeometry(t3);
    i2.setEditShapeCrackAndCluster_(n6, new Et2(s3, 0), r), i2.computeMatrixTopoGraphClusters_(o2, a3), i2.m_topoGraph.removeShape();
  }
  return pr2(i2.m_matrix, i2.m_scl);
}
function mr2(e2, t3, s3, n5, r) {
  const i2 = new vr2();
  i2.resetMatrix_(), i2.setPredicates_(n5), i2.setLineLinePredicates_();
  const o = n3.constructEmpty(), a2 = n3.constructEmpty();
  e2.queryEnvelope(o), t3.queryEnvelope(a2);
  let h2 = false;
  if (qr2(o, a2, s3) && (i2.lineLineDisjointPredicates_(e2, t3), h2 = true), h2 || Br2(e2, t3), !h2) {
    const n6 = new Pr(), o2 = n6.addGeometry(e2), a3 = n6.addGeometry(t3);
    i2.setEditShapeCrackAndCluster_(n6, new Et2(s3, 0), r), i2.m_clusterIndexA = i2.m_topoGraph.createUserIndexForClusters(), i2.m_clusterIndexB = i2.m_topoGraph.createUserIndexForClusters(), wr2(o2, i2.m_topoGraph, i2.m_clusterIndexA), wr2(a3, i2.m_topoGraph, i2.m_clusterIndexB), i2.computeMatrixTopoGraphHalfEdges_(o2, a3), i2.m_topoGraph.deleteUserIndexForClusters(i2.m_clusterIndexA), i2.m_topoGraph.deleteUserIndexForClusters(i2.m_clusterIndexB), i2.m_topoGraph.removeShape();
  }
  return pr2(i2.m_matrix, i2.m_scl);
}
function lr2(e2, t3, s3, n5, r) {
  const i2 = new vr2();
  i2.resetMatrix_(), i2.setPredicates_(n5), i2.setLinePointPredicates_();
  const o = n3.constructEmpty(), a2 = n3.constructEmpty();
  e2.queryEnvelope(o), t3.queryEnvelope(a2);
  let h2 = false;
  if (qr2(o, a2, s3) && (i2.linePointDisjointPredicates_(e2), h2 = true), h2 || Br2(e2, t3), !h2) {
    const n6 = new Pr(), o2 = n6.addGeometry(e2), a3 = n6.addGeometry(t3);
    i2.setEditShapeCrackAndCluster_(n6, new Et2(s3, 0), r), i2.m_clusterIndexA = i2.m_topoGraph.createUserIndexForClusters(), wr2(o2, i2.m_topoGraph, i2.m_clusterIndexA), i2.computeMatrixTopoGraphClusters_(o2, a3), i2.m_topoGraph.deleteUserIndexForClusters(i2.m_clusterIndexA), i2.m_topoGraph.removeShape();
  }
  return pr2(i2.m_matrix, i2.m_scl);
}
function gr2(e2, t3, s3, n5, r) {
  const i2 = new vr2();
  i2.resetMatrix_(), i2.setPredicates_(n5), i2.setPointPointPredicates_();
  const o = new n3(), a2 = new n3();
  e2.queryEnvelope(o), t3.queryEnvelope(a2);
  let h2 = false;
  if (qr2(o, a2, s3) && (i2.pointPointDisjointPredicates_(), h2 = true), !h2) {
    const n6 = new Pr(), o2 = n6.addGeometry(e2), a3 = n6.addGeometry(t3);
    i2.setEditShapeCrackAndCluster_(n6, new Et2(s3, 0), r), i2.computeMatrixTopoGraphClusters_(o2, a3), i2.m_topoGraph.removeShape();
  }
  return pr2(i2.m_matrix, i2.m_scl);
}
function ur2(e2, t3, s3, n5, r) {
  const i2 = new vr2();
  i2.resetMatrix_(), i2.setPredicates_(n5), i2.setAreaPointPredicates_();
  const o = n3.constructEmpty();
  e2.queryEnvelope(o);
  const a2 = t3.getXY();
  let h2 = false;
  if (Or2(a2, o, s3) && (i2.areaPointDisjointPredicates_(e2), h2 = true), !h2) {
    const t4 = Lo2(e2, a2, s3);
    if (1 === t4) i2.m_matrix[0] = 0, i2.m_matrix[2] = 2, i2.m_matrix[3] = -1, i2.m_matrix[5] = 1, i2.m_matrix[6] = -1;
    else if (2 === t4) {
      i2.m_matrix[6] = -1;
      if (0 !== e2.calculateArea2D()) i2.m_matrix[0] = -1, i2.m_matrix[3] = 0, i2.m_matrix[2] = 2, i2.m_matrix[5] = 1;
      else {
        i2.m_matrix[0] = 0, i2.m_matrix[3] = -1, i2.m_matrix[5] = -1;
        const t5 = n3.constructEmpty();
        e2.queryEnvelope(t5), i2.m_matrix[2] = t5.height() || t5.width() ? 1 : -1;
      }
    } else i2.areaPointDisjointPredicates_(e2);
  }
  return pr2(i2.m_matrix, n5);
}
function cr2(e2, t3, s3, n5, r) {
  const i2 = new vr2();
  i2.resetMatrix_(), i2.setPredicates_(n5), i2.setLinePointPredicates_();
  const o = n3.constructEmpty();
  e2.queryEnvelope(o);
  let a2 = false;
  if (Or2(t3.getXY(), o, s3) && (i2.linePointDisjointPredicates_(e2), a2 = true), !a2) {
    let n6 = null, o2 = false, a3 = false;
    if (i2.m_performPredicates[0] || i2.m_performPredicates[6]) {
      !kr2(e2, t3, s3, 4, r) ? (i2.m_performPredicates[0] && (n6 = Js2(e2), a3 = !kr2(n6, t3, s3, 4, r), o2 = true, i2.m_matrix[0] = a3 ? -1 : 0), i2.m_matrix[6] = -1) : (i2.m_matrix[0] = -1, i2.m_matrix[6] = 0);
    }
    if (i2.m_performPredicates[3] && (null !== n6 && n6.isEmpty() ? i2.m_matrix[3] = -1 : (o2 || (null == n6 && (n6 = Js2(e2)), a3 = !kr2(n6, t3, s3, 4, r), o2 = true), i2.m_matrix[3] = a3 ? 0 : -1)), i2.m_performPredicates[5]) if (null !== n6 && n6.isEmpty()) i2.m_matrix[5] = -1;
    else if (o2 && !a3) i2.m_matrix[5] = 0;
    else {
      null === n6 && (n6 = Js2(e2));
      const o3 = kr2(n6, t3, s3, 3, r);
      i2.m_matrix[5] = o3 ? -1 : 0;
    }
    if (i2.m_performPredicates[2]) {
      if (0 !== e2.calculateLength2D()) i2.m_matrix[2] = 1;
      else {
        const n7 = new cs2({ vd: e2.getDescription() });
        n7.addPoints(e2, 0, e2.getPointCount());
        const o3 = kr2(n7, t3, s3, 3, r);
        i2.m_matrix[2] = o3 ? -1 : 0;
      }
    }
  }
  return pr2(i2.m_matrix, i2.m_scl);
}
function _r2(e2, t3, s3, n5, r) {
  const i2 = new vr2();
  i2.resetMatrix_(), i2.setPredicates_(n5), i2.setPointPointPredicates_();
  const o = n3.constructEmpty();
  e2.queryEnvelope(o);
  const a2 = t3.getXY(), h2 = new mi();
  let m3 = false;
  if (Or2(a2, o, s3) && (i2.pointPointDisjointPredicates_(), m3 = true), !m3) {
    let t4 = false, n6 = true;
    const r2 = s3 * s3;
    for (let s4 = 0; s4 < e2.getPointCount() && (e2.queryXY(s4, h2), mi.sqrDistance(h2, a2) <= r2 ? t4 = true : n6 = false, !t4 || n6); s4++) ;
    t4 ? (i2.m_matrix[0] = 0, i2.m_matrix[2] = n6 ? -1 : 0, i2.m_matrix[6] = -1) : (i2.m_matrix[0] = -1, i2.m_matrix[2] = 0, i2.m_matrix[6] = 0);
  }
  return pr2(i2.m_matrix, n5);
}
function dr2(e2, t3, s3, n5, r) {
  const i2 = e2.getXY(), o = t3.getXY(), a2 = Yt(9, -1);
  mi.sqrDistance(i2, o) <= s3 * s3 ? a2[0] = 0 : (a2[2] = 0, a2[6] = 0), a2[8] = 2;
  return pr2(a2, n5);
}
function pr2(e2, t3) {
  for (let s3 = 0; s3 < 9; s3++) switch (t3[s3]) {
    case "T":
      if (-1 === e2[s3]) return false;
      break;
    case "F":
      if (-1 !== e2[s3]) return false;
      break;
    case "0":
      if (0 !== e2[s3]) return false;
      break;
    case "1":
      if (1 !== e2[s3]) return false;
      break;
    case "2":
      if (2 !== e2[s3]) return false;
  }
  return true;
}
function fr2(e2, t3, n5) {
  const r = Yt(9, -1);
  if (e2.isEmpty() && t3.isEmpty()) return pr2(r, n5);
  let o, a2 = false;
  e2.isEmpty() ? (o = t3, a2 = true) : o = e2, r[0] = -1, r[1] = -1, r[3] = -1, r[4] = -1, r[6] = -1, r[7] = -1, r[8] = 2;
  const h2 = o.getGeometryType();
  if (h(h2)) if (h2 === a.enumPolygon) {
    if (0 !== o.calculateArea2D()) r[2] = 2, r[5] = 1;
    else {
      r[5] = -1;
      const e3 = n3.constructEmpty();
      o.queryEnvelope(e3), r[2] = e3.height() || e3.width() ? 1 : 0;
    }
  } else {
    const e3 = 0 !== o.calculateLength2D();
    r[2] = e3 ? 1 : 0, r[5] = Ks(o) ? 0 : -1;
  }
  else r[2] = 0, r[5] = -1;
  return a2 && Nr2(r), pr2(r, n5);
}
function xr2(e2, t3, s3) {
  return yr2(e2) ? 3 : Pr2(e2) ? 4 : Er2(e2, t3, s3) ? 8 : Sr2(e2, t3, s3) ? 16 : Ir2(e2) ? 64 : Cr2(e2) ? 1 : br2(e2, t3, s3) ? 32 : 0;
}
function yr2(e2) {
  return "T*F**FFF*" === e2;
}
function Pr2(e2) {
  return "FF*FF****" === e2;
}
function Er2(e2, t3, s3) {
  return (0 !== t3 || 0 !== s3) && (2 === t3 && 2 === s3 ? "F***T****" === e2 : (2 === t3 || 1 === t3) && 0 === s3 && "F**T*****" === e2);
}
function Sr2(e2, t3, s3) {
  return t3 > s3 ? "T*****T**" === e2 : 1 === t3 && 1 === s3 && "0********" === e2;
}
function Cr2(e2) {
  return "T*****FF*" === e2;
}
function Ir2(e2) {
  return "T**FF*FF*" === e2;
}
function br2(e2, t3, s3) {
  return t3 === s3 && (1 !== t3 ? "T*T***T**" === e2 : "1*T***T**" === e2);
}
function wr2(e2, t3, s3) {
  const n5 = t3.getGeometryID(e2);
  for (let r = t3.getFirstCluster(); r !== cr; r = t3.getNextCluster(r)) {
    if (0 === (t3.getClusterParentage(r) & n5)) continue;
    const e3 = t3.getClusterHalfEdge(r);
    if (e3 === cr) {
      t3.setClusterUserIndex(r, s3, 0);
      continue;
    }
    let i2 = e3, o = 0;
    do {
      const e4 = i2;
      0 !== (t3.getHalfEdgeParentage(e4) & n5) && o++, i2 = t3.getHalfEdgeNext(t3.getHalfEdgeTwin(e4));
    } while (i2 !== e3);
    t3.setClusterUserIndex(r, s3, o);
  }
}
var vr2 = class {
  nullFunc() {
    return b("should not be called"), false;
  }
  constructor() {
    this.m_clusterIndexA = -1, this.m_clusterIndexB = -1, this.m_visitedIndex = -1, this.m_topoGraph = new tn2(), this.m_matrix = Yt(9, 0), this.m_maxDim = Yt(9, 0), this.m_performPredicates = Yt(9, false), this.m_scl = "", this.m_predicateCount = 0, this.m_predicatesHalfEdge = this.nullFunc, this.m_predicatesCluster = this.nullFunc;
  }
  resetMatrix_() {
    this.m_matrix.fill(-2), this.m_maxDim.fill(-2);
  }
  setPredicates_(e2) {
    this.m_scl = e2;
    for (let t3 = 0; t3 < 9; t3++) "*" !== this.m_scl[t3] ? (this.m_performPredicates[t3] = true, this.m_predicateCount++) : this.m_performPredicates[t3] = false;
  }
  setRemainingPredicatesToFalse_() {
    for (let e2 = 0; e2 < 9; e2++) this.m_performPredicates[e2] && -2 === this.m_matrix[e2] && (this.m_matrix[e2] = -1, this.m_performPredicates[e2] = false);
  }
  isPredicateKnown_(e2) {
    return -2 !== this.m_matrix[e2] && (-1 === this.m_matrix[e2] ? (this.m_performPredicates[e2] = false, this.m_predicateCount--, true) : "T" !== this.m_scl[e2] && "F" !== this.m_scl[e2] ? !(this.m_matrix[e2] < this.m_maxDim[e2]) && (this.m_performPredicates[e2] = false, this.m_predicateCount--, true) : (this.m_performPredicates[e2] = false, this.m_predicateCount--, true));
  }
  setAreaAreaPredicates_() {
    this.m_predicatesHalfEdge = this.areaAreaPredicates_, this.m_maxDim[0] = 2, this.m_maxDim[1] = 1, this.m_maxDim[2] = 2, this.m_maxDim[3] = 1, this.m_maxDim[4] = 1, this.m_maxDim[5] = 1, this.m_maxDim[6] = 2, this.m_maxDim[7] = 1, this.m_maxDim[8] = 2, this.m_performPredicates[8] && (this.m_matrix[8] = 2, this.m_performPredicates[8] = false, this.m_predicateCount--);
  }
  setAreaLinePredicates_() {
    this.m_predicatesHalfEdge = this.areaLinePredicates_, this.m_predicatesCluster = this.areaPointPredicates_, this.m_maxDim[0] = 1, this.m_maxDim[1] = 0, this.m_maxDim[2] = 2, this.m_maxDim[3] = 1, this.m_maxDim[4] = 0, this.m_maxDim[5] = 1, this.m_maxDim[6] = 1, this.m_maxDim[7] = 0, this.m_maxDim[8] = 2, this.m_performPredicates[8] && (this.m_matrix[8] = 2, this.m_performPredicates[8] = false, this.m_predicateCount--);
  }
  setLineLinePredicates_() {
    this.m_predicatesHalfEdge = this.lineLinePredicates_, this.m_predicatesCluster = this.linePointPredicates_, this.m_maxDim[0] = 1, this.m_maxDim[1] = 0, this.m_maxDim[2] = 1, this.m_maxDim[3] = 0, this.m_maxDim[4] = 0, this.m_maxDim[5] = 0, this.m_maxDim[6] = 1, this.m_maxDim[7] = 0, this.m_maxDim[8] = 2, this.m_performPredicates[8] && (this.m_matrix[8] = 2, this.m_performPredicates[8] = false, this.m_predicateCount--);
  }
  setAreaPointPredicates_() {
    this.m_predicatesCluster = this.areaPointPredicates_, this.m_maxDim[0] = 0, this.m_maxDim[1] = -1, this.m_maxDim[2] = 2, this.m_maxDim[3] = 0, this.m_maxDim[4] = -1, this.m_maxDim[5] = 1, this.m_maxDim[6] = 0, this.m_maxDim[7] = -1, this.m_maxDim[8] = 2, this.m_performPredicates[1] && (this.m_matrix[1] = -1, this.m_performPredicates[1] = false, this.m_predicateCount--), this.m_performPredicates[4] && (this.m_matrix[4] = -1, this.m_performPredicates[4] = false, this.m_predicateCount--), this.m_performPredicates[7] && (this.m_matrix[7] = -1, this.m_performPredicates[7] = false, this.m_predicateCount--), this.m_performPredicates[8] && (this.m_matrix[8] = 2, this.m_performPredicates[8] = false, this.m_predicateCount--);
  }
  setLinePointPredicates_() {
    this.m_predicatesCluster = this.linePointPredicates_, this.m_maxDim[0] = 0, this.m_maxDim[1] = -1, this.m_maxDim[2] = 1, this.m_maxDim[3] = 0, this.m_maxDim[4] = -1, this.m_maxDim[5] = 0, this.m_maxDim[6] = 0, this.m_maxDim[7] = -1, this.m_maxDim[8] = 2, this.m_performPredicates[1] && (this.m_matrix[1] = -1, this.m_performPredicates[1] = false, this.m_predicateCount--), this.m_performPredicates[4] && (this.m_matrix[4] = -1, this.m_performPredicates[4] = false, this.m_predicateCount--), this.m_performPredicates[7] && (this.m_matrix[7] = -1, this.m_performPredicates[7] = false, this.m_predicateCount--), this.m_performPredicates[8] && (this.m_matrix[8] = 2, this.m_performPredicates[8] = false, this.m_predicateCount--);
  }
  setPointPointPredicates_() {
    this.m_predicatesCluster = this.pointPointPredicates_, this.m_maxDim[0] = 0, this.m_maxDim[1] = -1, this.m_maxDim[2] = 0, this.m_maxDim[3] = -1, this.m_maxDim[4] = -1, this.m_maxDim[5] = -1, this.m_maxDim[6] = 0, this.m_maxDim[7] = -1, this.m_maxDim[8] = 2, this.m_performPredicates[1] && (this.m_matrix[1] = -1, this.m_performPredicates[1] = false, this.m_predicateCount--), this.m_performPredicates[3] && (this.m_matrix[3] = -1, this.m_performPredicates[3] = false, this.m_predicateCount--), this.m_performPredicates[4] && (this.m_matrix[4] = -1, this.m_performPredicates[4] = false, this.m_predicateCount--), this.m_performPredicates[5] && (this.m_matrix[5] = -1, this.m_performPredicates[5] = false, this.m_predicateCount--), this.m_performPredicates[7] && (this.m_matrix[7] = -1, this.m_performPredicates[7] = false, this.m_predicateCount--), this.m_performPredicates[8] && (this.m_matrix[8] = 2, this.m_performPredicates[8] = false, this.m_predicateCount--);
  }
  areaAreaDisjointPredicates_(e2, t3) {
    this.m_matrix[0] = -1, this.m_matrix[1] = -1, this.m_matrix[3] = -1, this.m_matrix[4] = -1, this.areaGeomContainsOrDisjointPredicates_(e2, this.m_performPredicates[2] ? 2 : -1, this.m_scl[2], this.m_performPredicates[5] ? 5 : -1, this.m_scl[5]), this.areaGeomContainsOrDisjointPredicates_(t3, this.m_performPredicates[6] ? 6 : -1, this.m_scl[6], this.m_performPredicates[7] ? 7 : -1, this.m_scl[7]);
  }
  areaGeomContainsOrDisjointPredicates_(e2, t3, s3, n5, r) {
    const i2 = -1 !== t3, o = -1 !== n5;
    if (i2 || o) {
      if (!("T" !== s3 && "F" !== s3 && i2 || "T" !== r && "F" !== r && o) || 0 !== e2.calculateArea2D()) i2 && (this.m_matrix[t3] = 2), o && (this.m_matrix[n5] = 1);
      else if (o && (this.m_matrix[n5] = -1), i2) {
        const s4 = n3.constructEmpty();
        e2.queryEnvelope(s4), this.m_matrix[t3] = s4.height() || s4.width() ? 1 : 0;
      }
    }
  }
  areaAreaContainsPredicates_(e2) {
    this.m_matrix[2] = 2, this.m_matrix[3] = -1, this.m_matrix[4] = -1, this.m_matrix[5] = 1, this.m_matrix[6] = -1, this.m_matrix[7] = -1, this.areaGeomContainsOrDisjointPredicates_(e2, this.m_performPredicates[0] ? 0 : -1, this.m_scl[0], this.m_performPredicates[1] ? 1 : -1, this.m_scl[1]);
  }
  areaAreaWithinPredicates_(e2) {
    this.areaAreaContainsPredicates_(e2), Nr2(this.m_matrix);
  }
  areaLineDisjointPredicates_(e2, t3) {
    if (this.m_matrix[0] = -1, this.m_matrix[1] = -1, this.m_matrix[3] = -1, this.m_matrix[4] = -1, this.m_performPredicates[6]) {
      const e3 = this.m_scl[6], s3 = "T" === e3 || "F" === e3 || 0 !== t3.calculateLength2D();
      this.m_matrix[6] = s3 ? 1 : 0;
    }
    if (this.m_performPredicates[7]) {
      const e3 = Ks(t3);
      this.m_matrix[7] = e3 ? 0 : -1;
    }
    this.areaGeomContainsOrDisjointPredicates_(e2, this.m_performPredicates[2] ? 2 : -1, this.m_scl[2], this.m_performPredicates[5] ? 5 : -1, this.m_scl[5]);
  }
  areaLineContainsPredicates_(e2, t3) {
    if (this.m_performPredicates[0]) {
      const e3 = this.m_scl[0], s3 = "T" === e3 || "F" === e3 || 0 !== t3.calculateLength2D();
      this.m_matrix[0] = s3 ? 1 : 0;
    }
    if (this.m_performPredicates[1]) {
      const e3 = Ks(t3);
      this.m_matrix[1] = e3 ? 0 : -1;
    }
    this.m_matrix[2] = 2, this.m_matrix[3] = -1, this.m_matrix[4] = -1, this.m_matrix[5] = 1, this.m_matrix[6] = -1, this.m_matrix[7] = -1;
  }
  areaPointDisjointPredicates_(e2) {
    this.m_matrix[0] = -1, this.m_matrix[3] = -1, this.m_matrix[6] = 0, this.areaGeomContainsOrDisjointPredicates_(e2, this.m_performPredicates[2] ? 2 : -1, this.m_scl[2], this.m_performPredicates[5] ? 5 : -1, this.m_scl[5]);
  }
  areaPointContainsPredicates_(e2) {
    this.m_matrix[0] = 0, this.m_matrix[2] = 2, this.m_matrix[3] = -1, this.m_matrix[5] = 1, this.m_matrix[6] = -1;
  }
  lineLineDisjointPredicates_(e2, t3) {
    if (this.m_matrix[0] = -1, this.m_matrix[1] = -1, this.m_matrix[3] = -1, this.m_matrix[4] = -1, this.m_performPredicates[2]) {
      const t4 = this.m_scl[2], s3 = "T" === t4 || "F" === t4 || 0 !== e2.calculateLength2D();
      this.m_matrix[2] = s3 ? 1 : 0;
    }
    if (this.m_performPredicates[5]) {
      const t4 = Ks(e2);
      this.m_matrix[5] = t4 ? 0 : -1;
    }
    if (this.m_performPredicates[6]) {
      const e3 = this.m_scl[6], s3 = "T" === e3 || "F" === e3 || 0 !== t3.calculateLength2D();
      this.m_matrix[6] = s3 ? 1 : 0;
    }
    if (this.m_performPredicates[7]) {
      const e3 = Ks(t3);
      this.m_matrix[7] = e3 ? 0 : -1;
    }
  }
  linePointDisjointPredicates_(e2) {
    if (this.m_matrix[0] = -1, this.m_matrix[3] = -1, this.m_performPredicates[2]) {
      const t3 = this.m_scl[2], s3 = "T" === t3 || "F" === t3 || 0 !== e2.calculateLength2D();
      this.m_matrix[2] = s3 ? 1 : 0;
    }
    if (this.m_performPredicates[5]) {
      const t3 = Ks(e2);
      this.m_matrix[5] = t3 ? 0 : -1;
    }
    this.m_matrix[6] = 0;
  }
  pointPointDisjointPredicates_() {
    this.m_matrix[0] = -1, this.m_matrix[2] = 0, this.m_matrix[6] = 0;
  }
  areaAreaPredicates_(e2, t3, s3) {
    let n5 = true;
    if (this.m_performPredicates[0]) {
      this.interiorAreaInteriorArea_(e2, t3, s3);
      const r = this.isPredicateKnown_(0);
      n5 &&= r;
    }
    if (this.m_performPredicates[1]) {
      this.interiorAreaBoundaryArea_(e2, t3, 1);
      const s4 = this.isPredicateKnown_(1);
      n5 &&= s4;
    }
    if (this.m_performPredicates[2]) {
      this.interiorAreaExteriorArea_(e2, t3, s3, 2);
      const r = this.isPredicateKnown_(2);
      n5 &&= r;
    }
    if (this.m_performPredicates[3]) {
      this.interiorAreaBoundaryArea_(e2, s3, 3);
      const t4 = this.isPredicateKnown_(3);
      n5 &&= t4;
    }
    if (this.m_performPredicates[4]) {
      this.boundaryAreaBoundaryArea_(e2, t3, s3);
      const r = this.isPredicateKnown_(4);
      n5 &&= r;
    }
    if (this.m_performPredicates[5]) {
      this.boundaryAreaExteriorArea_(e2, t3, s3, 5);
      const r = this.isPredicateKnown_(5);
      n5 &&= r;
    }
    if (this.m_performPredicates[6]) {
      this.interiorAreaExteriorArea_(e2, s3, t3, 6);
      const r = this.isPredicateKnown_(6);
      n5 &&= r;
    }
    if (this.m_performPredicates[7]) {
      this.boundaryAreaExteriorArea_(e2, s3, t3, 7);
      const r = this.isPredicateKnown_(7);
      n5 &&= r;
    }
    return n5;
  }
  areaLinePredicates_(e2, t3, s3) {
    let n5 = true;
    if (this.m_performPredicates[0]) {
      this.interiorAreaInteriorLine_(e2, t3, s3);
      const r = this.isPredicateKnown_(0);
      n5 &&= r;
    }
    if (this.m_performPredicates[1]) {
      this.interiorAreaBoundaryLine_(e2, t3, s3, this.m_clusterIndexB);
      const r = this.isPredicateKnown_(1);
      n5 &&= r;
    }
    if (this.m_performPredicates[2]) {
      this.interiorAreaExteriorLine_(e2, t3, s3);
      const r = this.isPredicateKnown_(2);
      n5 &&= r;
    }
    if (this.m_performPredicates[3]) {
      this.boundaryAreaInteriorLine_(e2, t3, s3, this.m_clusterIndexB);
      const r = this.isPredicateKnown_(3);
      n5 &&= r;
    }
    if (this.m_performPredicates[4]) {
      this.boundaryAreaBoundaryLine_(e2, t3, s3, this.m_clusterIndexB);
      const r = this.isPredicateKnown_(4);
      n5 &&= r;
    }
    if (this.m_performPredicates[5]) {
      this.boundaryAreaExteriorLine_(e2, t3, s3);
      const r = this.isPredicateKnown_(5);
      n5 &&= r;
    }
    if (this.m_performPredicates[6]) {
      this.exteriorAreaInteriorLine_(e2, t3);
      const s4 = this.isPredicateKnown_(6);
      n5 &&= s4;
    }
    if (this.m_performPredicates[7]) {
      this.exteriorAreaBoundaryLine_(e2, t3, s3, this.m_clusterIndexB);
      const r = this.isPredicateKnown_(7);
      n5 &&= r;
    }
    return n5;
  }
  lineLinePredicates_(e2, t3, s3) {
    let n5 = true;
    if (this.m_performPredicates[0]) {
      this.interiorLineInteriorLine_(e2, t3, s3, this.m_clusterIndexA, this.m_clusterIndexB);
      const r = this.isPredicateKnown_(0);
      n5 &&= r;
    }
    if (this.m_performPredicates[1]) {
      this.interiorLineBoundaryLine_(e2, t3, s3, this.m_clusterIndexA, this.m_clusterIndexB, 1);
      const r = this.isPredicateKnown_(1);
      n5 &&= r;
    }
    if (this.m_performPredicates[2]) {
      this.interiorLineExteriorLine_(e2, t3, s3, 2);
      const r = this.isPredicateKnown_(2);
      n5 &&= r;
    }
    if (this.m_performPredicates[3]) {
      this.interiorLineBoundaryLine_(e2, s3, t3, this.m_clusterIndexB, this.m_clusterIndexA, 3);
      const r = this.isPredicateKnown_(3);
      n5 &&= r;
    }
    if (this.m_performPredicates[4]) {
      this.boundaryLineBoundaryLine_(e2, t3, s3, this.m_clusterIndexA, this.m_clusterIndexB);
      const r = this.isPredicateKnown_(4);
      n5 &&= r;
    }
    if (this.m_performPredicates[5]) {
      this.boundaryLineExteriorLine_(e2, t3, s3, this.m_clusterIndexA, 5);
      const r = this.isPredicateKnown_(5);
      n5 &&= r;
    }
    if (this.m_performPredicates[6]) {
      this.interiorLineExteriorLine_(e2, s3, t3, 6);
      const r = this.isPredicateKnown_(6);
      n5 &&= r;
    }
    if (this.m_performPredicates[7]) {
      this.boundaryLineExteriorLine_(e2, s3, t3, this.m_clusterIndexB, 7);
      const r = this.isPredicateKnown_(7);
      n5 &&= r;
    }
    return n5;
  }
  areaPointPredicates_(e2, t3, s3) {
    let n5 = true;
    if (this.m_performPredicates[0]) {
      this.interiorAreaInteriorPoint_(e2, t3);
      const s4 = this.isPredicateKnown_(0);
      n5 &&= s4;
    }
    if (this.m_performPredicates[2]) {
      this.interiorAreaExteriorPoint_(e2, t3);
      const s4 = this.isPredicateKnown_(2);
      n5 &&= s4;
    }
    if (this.m_performPredicates[3]) {
      this.boundaryAreaInteriorPoint_(e2, t3, s3);
      const r = this.isPredicateKnown_(3);
      n5 &&= r;
    }
    if (this.m_performPredicates[5]) {
      this.boundaryAreaExteriorPoint_(e2, t3);
      const s4 = this.isPredicateKnown_(5);
      n5 &&= s4;
    }
    if (this.m_performPredicates[6]) {
      this.exteriorAreaInteriorPoint_(e2, t3);
      const s4 = this.isPredicateKnown_(6);
      n5 &&= s4;
    }
    return n5;
  }
  linePointPredicates_(e2, t3, s3) {
    let n5 = true;
    if (this.m_performPredicates[0]) {
      this.interiorLineInteriorPoint_(e2, t3, s3, this.m_clusterIndexA);
      const r = this.isPredicateKnown_(0);
      n5 &&= r;
    }
    if (this.m_performPredicates[2]) {
      this.interiorLineExteriorPoint_(e2, t3, s3, this.m_clusterIndexA);
      const r = this.isPredicateKnown_(2);
      n5 &&= r;
    }
    if (this.m_performPredicates[3]) {
      this.boundaryLineInteriorPoint_(e2, t3, s3, this.m_clusterIndexA);
      const r = this.isPredicateKnown_(3);
      n5 &&= r;
    }
    if (this.m_performPredicates[5]) {
      this.boundaryLineExteriorPoint_(e2, t3, s3, this.m_clusterIndexA);
      const r = this.isPredicateKnown_(5);
      n5 &&= r;
    }
    if (this.m_performPredicates[6]) {
      this.exteriorLineInteriorPoint_(e2, t3, s3);
      const r = this.isPredicateKnown_(6);
      n5 &&= r;
    }
    return n5;
  }
  pointPointPredicates_(e2, t3, s3) {
    let n5 = true;
    if (this.m_performPredicates[0]) {
      this.interiorPointInteriorPoint_(e2, t3, s3);
      const r = this.isPredicateKnown_(0);
      n5 &&= r;
    }
    if (this.m_performPredicates[2]) {
      this.interiorPointExteriorPoint_(e2, t3, s3, 2);
      const r = this.isPredicateKnown_(2);
      n5 &&= r;
    }
    if (this.m_performPredicates[6]) {
      this.interiorPointExteriorPoint_(e2, s3, t3, 6);
      const r = this.isPredicateKnown_(6);
      n5 &&= r;
    }
    return n5;
  }
  interiorAreaInteriorArea_(e2, t3, s3) {
    if (2 === this.m_matrix[0]) return;
    const n5 = this.m_topoGraph.getHalfEdgeFaceParentage(e2);
    0 !== (n5 & t3) && 0 !== (n5 & s3) && (this.m_matrix[0] = 2);
  }
  interiorAreaBoundaryArea_(e2, t3, s3) {
    if (1 === this.m_matrix[s3]) return;
    const n5 = this.m_topoGraph.getHalfEdgeFaceParentage(e2), r = this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(e2));
    0 !== (n5 & t3) && 0 !== (r & t3) && (this.m_matrix[s3] = 1);
  }
  interiorAreaExteriorArea_(e2, t3, s3, n5) {
    if (2 === this.m_matrix[n5]) return;
    const r = this.m_topoGraph.getHalfEdgeFaceParentage(e2);
    0 !== (r & t3) && 0 === (r & s3) && (this.m_matrix[n5] = 2);
  }
  boundaryAreaBoundaryArea_(e2, t3, s3) {
    if (1 === this.m_matrix[4]) return;
    const n5 = this.m_topoGraph.getHalfEdgeParentage(e2);
    if (0 === (n5 & t3) || 0 === (n5 & s3)) {
      if (0 !== this.m_matrix[4] && 1 !== this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(e2)), this.m_visitedIndex)) {
        const n6 = this.m_topoGraph.getHalfEdgeTo(e2), r = this.m_topoGraph.getClusterParentage(n6);
        if (0 !== (r & t3) && 0 !== (r & s3)) return void (this.m_matrix[4] = 0);
      }
    } else this.m_matrix[4] = 1;
  }
  boundaryAreaExteriorArea_(e2, t3, s3, n5) {
    if (1 === this.m_matrix[n5]) return;
    const r = this.m_topoGraph.getHalfEdgeFaceParentage(e2), i2 = this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(e2));
    0 === (r & s3) && 0 === (i2 & s3) && (this.m_matrix[n5] = 1);
  }
  interiorAreaInteriorLine_(e2, t3, s3) {
    if (1 === this.m_matrix[0]) return;
    const n5 = this.m_topoGraph.getHalfEdgeFaceParentage(e2), r = this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(e2));
    0 !== (n5 & t3) && 0 !== (r & t3) && (this.m_matrix[0] = 1);
  }
  interiorAreaBoundaryLine_(e2, t3, s3, n5) {
    if (0 !== this.m_matrix[1] && 1 !== this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(e2)), this.m_visitedIndex)) {
      const r = this.m_topoGraph.getHalfEdgeTo(e2), i2 = this.m_topoGraph.getClusterParentage(r);
      if (0 === (i2 & t3)) {
        if (0 !== (this.m_topoGraph.getHalfEdgeFaceParentage(e2) & t3)) {
          const e3 = this.m_topoGraph.getClusterUserIndex(r, n5);
          if (0 !== (i2 & s3) && e3 % 2 != 0) return void (this.m_matrix[1] = 0);
        }
      }
    }
  }
  interiorAreaExteriorLine_(e2, t3, s3) {
    if (2 === this.m_matrix[2]) return;
    0 !== (this.m_topoGraph.getHalfEdgeParentage(e2) & t3) && (this.m_matrix[2] = 2);
  }
  boundaryAreaInteriorLine_(e2, t3, s3, n5) {
    if (1 === this.m_matrix[3]) return;
    const r = this.m_topoGraph.getHalfEdgeParentage(e2);
    if (0 === (r & t3) || 0 === (r & s3)) {
      if (0 !== this.m_matrix[3] && 1 !== this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(e2)), this.m_visitedIndex)) {
        const r2 = this.m_topoGraph.getHalfEdgeTo(e2), i2 = this.m_topoGraph.getClusterParentage(r2);
        if (0 !== (i2 & t3)) {
          const e3 = this.m_topoGraph.getClusterUserIndex(r2, n5);
          if (0 !== (i2 & s3) && e3 % 2 == 0) return void (this.m_matrix[3] = 0);
        }
      }
    } else this.m_matrix[3] = 1;
  }
  boundaryAreaBoundaryLine_(e2, t3, s3, n5) {
    if (0 !== this.m_matrix[4] && 1 !== this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(e2)), this.m_visitedIndex)) {
      const r = this.m_topoGraph.getHalfEdgeTo(e2), i2 = this.m_topoGraph.getClusterParentage(r);
      if (0 !== (i2 & t3)) {
        const e3 = this.m_topoGraph.getClusterUserIndex(r, n5);
        if (0 !== (i2 & s3) && e3 % 2 != 0) return void (this.m_matrix[4] = 0);
      }
    }
  }
  boundaryAreaExteriorLine_(e2, t3, s3) {
    if (1 === this.m_matrix[5]) return;
    const n5 = this.m_topoGraph.getHalfEdgeParentage(e2);
    0 !== (n5 & t3) && 0 === (n5 & s3) && (this.m_matrix[5] = 1);
  }
  exteriorAreaInteriorLine_(e2, t3) {
    if (1 === this.m_matrix[6]) return;
    const s3 = this.m_topoGraph.getHalfEdgeFaceParentage(e2), n5 = this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(e2));
    0 === (s3 & t3) && 0 === (n5 & t3) && (this.m_matrix[6] = 1);
  }
  exteriorAreaBoundaryLine_(e2, t3, s3, n5) {
    if (0 !== this.m_matrix[7] && 1 !== this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(e2)), this.m_visitedIndex)) {
      const r = this.m_topoGraph.getHalfEdgeTo(e2), i2 = this.m_topoGraph.getClusterParentage(r);
      if (0 === (i2 & t3)) {
        if (0 === (this.m_topoGraph.getHalfEdgeFaceParentage(e2) & t3)) {
          const e3 = this.m_topoGraph.getClusterUserIndex(r, n5);
          if (0 !== (i2 & s3) && e3 % 2 != 0) return void (this.m_matrix[7] = 0);
        }
      }
    }
  }
  interiorLineInteriorLine_(e2, t3, s3, n5, r) {
    if (1 === this.m_matrix[0]) return;
    const i2 = this.m_topoGraph.getHalfEdgeParentage(e2);
    if (0 === (i2 & t3) || 0 === (i2 & s3)) {
      if (0 !== this.m_matrix[0] && 1 !== this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(e2)), this.m_visitedIndex)) {
        const i3 = this.m_topoGraph.getHalfEdgeTo(e2), o = this.m_topoGraph.getClusterParentage(i3);
        if (0 !== (o & t3) && 0 !== (o & s3)) {
          const e3 = this.m_topoGraph.getClusterUserIndex(i3, n5), t4 = this.m_topoGraph.getClusterUserIndex(i3, r);
          if (e3 % 2 == 0 && t4 % 2 == 0) return void (this.m_matrix[0] = 0);
        }
      }
    } else this.m_matrix[0] = 1;
  }
  interiorLineBoundaryLine_(e2, t3, s3, n5, r, i2) {
    if (0 !== this.m_matrix[i2] && 1 !== this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(e2)), this.m_visitedIndex)) {
      const o = this.m_topoGraph.getHalfEdgeTo(e2), a2 = this.m_topoGraph.getClusterParentage(o);
      if (0 !== (a2 & t3) && 0 !== (a2 & s3)) {
        const e3 = this.m_topoGraph.getClusterUserIndex(o, n5), t4 = this.m_topoGraph.getClusterUserIndex(o, r);
        if (e3 % 2 == 0 && t4 % 2 != 0) return void (this.m_matrix[i2] = 0);
      }
    }
  }
  interiorLineExteriorLine_(e2, t3, s3, n5) {
    if (1 === this.m_matrix[n5]) return;
    const r = this.m_topoGraph.getHalfEdgeParentage(e2);
    0 !== (r & t3) && 0 === (r & s3) && (this.m_matrix[n5] = 1);
  }
  boundaryLineBoundaryLine_(e2, t3, s3, n5, r) {
    if (0 !== this.m_matrix[4] && 1 !== this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(e2)), this.m_visitedIndex)) {
      const i2 = this.m_topoGraph.getHalfEdgeTo(e2), o = this.m_topoGraph.getClusterParentage(i2);
      if (0 !== (o & t3) && 0 !== (o & s3)) {
        const e3 = this.m_topoGraph.getClusterUserIndex(i2, n5), t4 = this.m_topoGraph.getClusterUserIndex(i2, r);
        if (e3 % 2 != 0 && t4 % 2 != 0) return void (this.m_matrix[4] = 0);
      }
    }
  }
  boundaryLineExteriorLine_(e2, t3, s3, n5, r) {
    if (0 !== this.m_matrix[r] && 1 !== this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(e2)), this.m_visitedIndex)) {
      const t4 = this.m_topoGraph.getHalfEdgeTo(e2);
      if (0 === (this.m_topoGraph.getClusterParentage(t4) & s3)) {
        if (this.m_topoGraph.getClusterUserIndex(t4, n5) % 2 != 0) return void (this.m_matrix[r] = 0);
      }
    }
  }
  interiorAreaInteriorPoint_(e2, t3) {
    if (0 === this.m_matrix[0]) return;
    if (0 === (this.m_topoGraph.getClusterParentage(e2) & t3)) {
      const s3 = this.m_topoGraph.getClusterChain(e2);
      if (0 !== (this.m_topoGraph.getChainParentage(s3) & t3)) return void (this.m_matrix[0] = 0);
    }
  }
  interiorAreaExteriorPoint_(e2, t3) {
    if (2 === this.m_matrix[2]) return;
    0 !== (this.m_topoGraph.getClusterParentage(e2) & t3) && (this.m_matrix[2] = 2);
  }
  boundaryAreaInteriorPoint_(e2, t3, s3) {
    if (0 === this.m_matrix[3]) return;
    const n5 = this.m_topoGraph.getClusterParentage(e2);
    0 === (n5 & t3) || 0 === (n5 & s3) || (this.m_matrix[3] = 0);
  }
  boundaryAreaExteriorPoint_(e2, t3) {
    if (1 === this.m_matrix[5]) return;
    0 !== (this.m_topoGraph.getClusterParentage(e2) & t3) && (this.m_matrix[5] = 1);
  }
  exteriorAreaInteriorPoint_(e2, t3) {
    if (0 === this.m_matrix[6]) return;
    if (0 === (this.m_topoGraph.getClusterParentage(e2) & t3)) {
      const s3 = this.m_topoGraph.getClusterChain(e2);
      if (0 === (this.m_topoGraph.getChainParentage(s3) & t3)) return void (this.m_matrix[6] = 0);
    }
  }
  interiorLineInteriorPoint_(e2, t3, s3, n5) {
    if (0 === this.m_matrix[0]) return;
    const r = this.m_topoGraph.getClusterParentage(e2);
    if (0 !== (r & t3) && 0 !== (r & s3)) {
      if (this.m_topoGraph.getClusterUserIndex(e2, n5) % 2 == 0) return void (this.m_matrix[0] = 0);
    }
  }
  interiorLineExteriorPoint_(e2, t3, s3, n5) {
    if (1 === this.m_matrix[2]) return;
    if (-1 === this.m_topoGraph.getClusterHalfEdge(e2)) {
      if (0 !== this.m_matrix[2]) {
        if (0 === (this.m_topoGraph.getClusterParentage(e2) & s3)) return void (this.m_matrix[2] = 0);
      }
    } else this.m_matrix[2] = 1;
  }
  boundaryLineInteriorPoint_(e2, t3, s3, n5) {
    if (0 === this.m_matrix[3]) return;
    const r = this.m_topoGraph.getClusterParentage(e2);
    if (0 !== (r & t3) && 0 !== (r & s3)) {
      if (this.m_topoGraph.getClusterUserIndex(e2, n5) % 2 != 0) return void (this.m_matrix[3] = 0);
    }
  }
  boundaryLineExteriorPoint_(e2, t3, s3, n5) {
    if (0 === this.m_matrix[5]) return;
    const r = this.m_topoGraph.getClusterParentage(e2);
    if (0 !== (r & t3) && 0 === (r & s3)) {
      if (this.m_topoGraph.getClusterUserIndex(e2, n5) % 2 != 0) return void (this.m_matrix[5] = 0);
    }
  }
  exteriorLineInteriorPoint_(e2, t3, s3) {
    if (0 === this.m_matrix[6]) return;
    const n5 = this.m_topoGraph.getClusterParentage(e2);
    0 !== (n5 & t3) || 0 === (n5 & s3) || (this.m_matrix[6] = 0);
  }
  interiorPointInteriorPoint_(e2, t3, s3) {
    if (0 === this.m_matrix[0]) return;
    const n5 = this.m_topoGraph.getClusterParentage(e2);
    0 === (n5 & t3) || 0 === (n5 & s3) || (this.m_matrix[0] = 0);
  }
  interiorPointExteriorPoint_(e2, t3, s3, n5) {
    if (0 === this.m_matrix[n5]) return;
    const r = this.m_topoGraph.getClusterParentage(e2);
    0 === (r & t3) || 0 !== (r & s3) || (this.m_matrix[n5] = 0);
  }
  computeMatrixTopoGraphHalfEdges_(e2, t3) {
    let s3 = false;
    const n5 = this.m_topoGraph.getGeometryID(e2), r = this.m_topoGraph.getGeometryID(t3);
    this.m_visitedIndex = this.m_topoGraph.createUserIndexForHalfEdges();
    for (let i2 = this.m_topoGraph.getFirstCluster(); i2 !== cr; i2 = this.m_topoGraph.getNextCluster(i2)) {
      const e3 = this.m_topoGraph.getClusterHalfEdge(i2);
      if (e3 === cr) {
        if (null !== this.m_predicatesCluster && (s3 = this.m_predicatesCluster(i2, n5, r), s3)) break;
        continue;
      }
      let t4 = e3;
      do {
        let e4 = t4;
        if (1 !== this.m_topoGraph.getHalfEdgeUserIndex(e4, this.m_visitedIndex)) do {
          if (s3 = this.m_predicatesHalfEdge(e4, n5, r), s3) break;
          this.m_topoGraph.setHalfEdgeUserIndex(e4, this.m_visitedIndex, 1), e4 = this.m_topoGraph.getHalfEdgeNext(e4);
        } while (e4 !== t4 && !s3);
        if (s3) break;
        t4 = this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(e4));
      } while (t4 !== e3);
      if (s3) break;
    }
    s3 || this.setRemainingPredicatesToFalse_(), this.m_topoGraph.deleteUserIndexForHalfEdges(this.m_visitedIndex);
  }
  computeMatrixTopoGraphClusters_(e2, t3) {
    let s3 = false;
    const n5 = this.m_topoGraph.getGeometryID(e2), r = this.m_topoGraph.getGeometryID(t3);
    for (let i2 = this.m_topoGraph.getFirstCluster(); i2 !== cr && (s3 = this.m_predicatesCluster(i2, n5, r), !s3); i2 = this.m_topoGraph.getNextCluster(i2)) ;
    s3 || this.setRemainingPredicatesToFalse_();
  }
  setEditShape_(e2, t3) {
    this.m_topoGraph.setEditShape(e2, t3);
  }
  setEditShapeCrackAndCluster_(e2, t3, n5) {
    let r = 0;
    if (e2.hasCurves()) {
      const s3 = new fa2(), i2 = e2.getEnvelope2D(n5), o = _a2(t3.total(), i2);
      r = pa2(o, 0), aa2(e2, o, t3.total(), 12e3, s3, null, n5), s3.clearStitcher(e2);
    }
    ya2(e2, t3.add(r), n5, false, false), e2.filterClosePoints(0, true, true, false, cr);
    for (let i2 = e2.getFirstGeometry(); i2 !== cr; i2 = e2.getNextGeometry(i2)) e2.getGeometryType(i2) === a.enumPolygon && er2(e2, i2, -1, false, cr, n5);
    this.setEditShape_(e2, n5);
  }
};
function Nr2(e2) {
  const t3 = e2[1], s3 = e2[2], n5 = e2[5];
  e2[1] = e2[3], e2[2] = e2[6], e2[5] = e2[7], e2[3] = t3, e2[6] = s3, e2[7] = n5;
}
function Tr2(e2, t3, r) {
  const i2 = e2.getGeometryType();
  if (f(i2)) {
    const t4 = new Os2({ vd: e2.getDescription() });
    return t4.addSegment(e2, true), t4;
  }
  if (i2 === a.enumEnvelope) {
    const s3 = e2, n5 = n3.constructEmpty();
    if (e2.queryEnvelope(n5), n5.height() <= t3 && n5.width() <= t3) {
      const t4 = new ee({ vd: e2.getDescription() });
      return s3.getCenter(t4), t4;
    }
    if (n5.height() <= t3 || n5.width() <= t3) {
      const t4 = new Os2({ vd: e2.getDescription() }), n6 = new ee();
      return s3.queryCornerByVal(0, n6), t4.startPathPoint(n6), s3.queryCornerByVal(2, n6), t4.lineToPoint(n6), t4;
    }
    const r2 = new ur({ vd: e2.getDescription() });
    return r2.addEnvelope(s3, false), r2;
  }
  return e2;
}
function Gr2(e2) {
  return `${e2[0]}${e2[3]}${e2[6]}${e2[1]}${e2[4]}${e2[7]}${e2[2]}${e2[5]}${e2[8]}`;
}
var Dr2 = class {
  nullFunc() {
    return b("should not be called"), false;
  }
  constructor(e2, t3, s3, n5 = false) {
    this.m_bDone = false, this.m_tolerance = 0, this.m_elementHandle = -1, this.m_query = n3.constructEmpty(), this.m_envInter = n3.constructEmpty(), this.m_quadTree = null, this.m_intersector = null, this.m_function = this.nullFunc;
    const r = e2.getAccelerators();
    let o = null;
    null != r && (o = n5 ? r.getQuadTreeForPaths() : r.getQuadTree());
    const a2 = t3.getAccelerators();
    let h2 = null;
    if (null != a2 && (h2 = n5 ? a2.getQuadTreeForPaths() : a2.getQuadTree()), null === o && null === h2 && !n5) {
      const n6 = e2.getPointCount(), r2 = t3.getPointCount();
      if (n6 > 10 && r2 > 10) {
        const a3 = n3.constructEmpty(), m3 = n3.constructEmpty(), l2 = n3.constructEmpty();
        e2.queryLooseEnvelope(a3), t3.queryLooseEnvelope(m3), a3.inflateCoords(s3, s3), m3.inflateCoords(s3, s3), l2.setCoords({ env2D: a3 }), l2.intersect(m3), n6 >= r2 ? o = h(e2.getGeometryType()) ? Wt2(e2, l2) : Jt2(e2, l2) : h2 = h(t3.getGeometryType()) ? Wt2(t3, l2) : Jt2(t3, l2);
      }
    }
    this.construct_(e2, o, t3, h2, s3, n5);
  }
  next() {
    if (this.m_bQuadTree) {
      if (this.m_bDone) return false;
      for (; this.m_function(); ) ;
      return !this.m_bDone;
    }
    return !!this.m_intersector && this.m_intersector.next();
  }
  getRedElement() {
    return this.m_bQuadTree ? this.m_bSwapElements ? this.m_quadTree.getElement(this.m_elementHandle) : h(this.m_queryType) ? this.m_bPaths ? this.m_pathIndex : this.m_segIter.getStartPointIndex() : this.m_pointIndex : this.m_bSwapElements ? this.m_intersector.getBlueElement(this.m_intersector.getHandleB()) : this.m_intersector.getRedElement(this.m_intersector.getHandleA());
  }
  getBlueElement() {
    return this.m_bQuadTree ? this.m_bSwapElements ? h(this.m_queryType) ? this.m_bPaths ? this.m_pathIndex : this.m_segIter.getStartPointIndex() : this.m_pointIndex : this.m_quadTree.getElement(this.m_elementHandle) : this.m_bSwapElements ? this.m_intersector.getRedElement(this.m_intersector.getHandleA()) : this.m_intersector.getBlueElement(this.m_intersector.getHandleB());
  }
  getRedEnvelope() {
    return this.m_bPaths || C(""), this.m_bQuadTree ? this.m_bSwapElements ? this.m_quadTree.getElementExtent(this.m_elementHandle) : this.m_query : this.m_bSwapElements ? this.m_intersector.getBlueEnvelope(this.m_intersector.getHandleB()) : this.m_intersector.getRedEnvelope(this.m_intersector.getHandleA());
  }
  getBlueEnvelope() {
    return this.m_bPaths || C(""), this.m_bQuadTree ? this.m_bSwapElements ? this.m_query : this.m_quadTree.getElementExtent(this.m_elementHandle) : this.m_bSwapElements ? this.m_intersector.getRedEnvelope(this.m_intersector.getHandleA()) : this.m_intersector.getBlueEnvelope(this.m_intersector.getHandleB());
  }
  construct_(e2, t3, n5, r, o, a2) {
    const h2 = n3.constructEmpty(), m3 = n3.constructEmpty();
    e2.queryLooseEnvelope(h2), n5.queryLooseEnvelope(m3), h2.inflateCoords(o, o), m3.inflateCoords(o, o), this.m_envInter.setCoords({ env2D: h2 }), this.m_envInter.intersect(m3), this.m_multiVertexImplA = e2, this.m_multiVertexImplB = n5;
    const l2 = e2.getGeometryType(), g2 = n5.getGeometryType();
    this.m_bPaths = a2, this.m_pathIndex = -1, this.m_pointIndex = -1, this.m_bSwapElements = false, this.m_queryType = a.enumUnknown, this.m_bQuadTree = false, null !== t3 && (this.m_bDone = false, this.m_tolerance = o, this.m_quadTree = t3, this.m_qtIter = this.m_quadTree.getIteratorForQT(), this.m_bQuadTree = true, this.m_bSwapElements = true, h(g2) ? (this.m_queryType = g2, this.m_function = this.nextPath_, a2 ? this.m_pathIndex = n5.getPathCount() : this.m_segIter = n5.querySegmentIterator()) : (this.m_queryType = g2, this.m_function = this.nextPoint_, this.m_pointIndex = n5.getPointCount())), this.m_bQuadTree || null !== r && (this.m_bDone = false, this.m_tolerance = o, this.m_quadTree = r, this.m_qtIter = this.m_quadTree.getIteratorForQT(), this.m_bQuadTree = true, this.m_bSwapElements = false, h(l2) ? (this.m_queryType = l2, this.m_function = this.nextPath_, a2 ? this.m_pathIndex = e2.getPathCount() : this.m_segIter = e2.querySegmentIterator()) : (this.m_queryType = l2, this.m_function = this.nextPoint_, this.m_pointIndex = e2.getPointCount())), this.m_bQuadTree || (a2 && h(l2) && h(g2) ? this.m_intersector = Gt2(e2, n5, o) : h(l2) && h(g2) ? (this.m_intersector = Xt2(e2, n5, o), this.m_bSwapElements = false) : h(l2) && !h(g2) ? (this.m_intersector = Ut2(e2, n5, o), this.m_bSwapElements = false) : !h(l2) && h(g2) ? (this.m_intersector = Ut2(n5, e2, o), this.m_bSwapElements = true) : (this.m_intersector = Zt2(e2, n5, o), this.m_bSwapElements = false));
  }
  nextPath_() {
    return this.m_bPaths ? -1 === --this.m_pathIndex ? (this.m_bDone = true, false) : (this.m_bSwapElements ? this.m_multiVertexImplB.queryPathEnvelope(this.m_pathIndex, this.m_query) : this.m_multiVertexImplA.queryPathEnvelope(this.m_pathIndex, this.m_query), this.m_qtIter.resetIterator(this.m_query, this.m_tolerance), this.m_function = this.iterate_, true) : this.m_segIter.nextPath() ? (this.m_function = this.nextSegment_, true) : (this.m_bDone = true, false);
  }
  nextSegment_() {
    if (!this.m_segIter.hasNextSegment()) return this.m_function = this.nextPath_, true;
    const e2 = this.m_segIter.nextSegment(), t3 = new n3();
    return e2.queryLooseEnvelope(t3), !t3.isIntersecting(this.m_envInter) || (this.m_qtIter.resetIterator(e2, this.m_tolerance), this.m_function = this.iterate_, true);
  }
  nextPoint_() {
    if (-1 === --this.m_pointIndex) return this.m_bDone = true, false;
    const e2 = new mi();
    if (this.m_bSwapElements) {
      const t3 = this.m_multiVertexImplB.getXY(this.m_pointIndex);
      e2.setCoordsPoint2D(t3);
    } else {
      const t3 = this.m_multiVertexImplA.getXY(this.m_pointIndex);
      e2.setCoordsPoint2D(t3);
    }
    return !this.m_envInter.contains(e2) || (this.m_qtIter.resetIterator(n3.construct(e2.x, e2.y, e2.x, e2.y), this.m_tolerance), this.m_function = this.iterate_, true);
  }
  iterate_() {
    return this.m_elementHandle = this.m_qtIter.next(), -1 === this.m_elementHandle && (h(this.m_queryType) ? (this.m_function = this.m_bPaths ? this.nextPath_ : this.nextSegment_, true) : (this.m_function = this.nextPoint_, true));
  }
};
function Vr2(e2) {
  return 2 === e2 ? 1 : 1 === e2 ? 2 : 128 === e2 ? 64 : 64 === e2 ? 128 : e2;
}
function Fr2(e2, t3, s3) {
  let n5;
  if (e2 instanceof oc || null === e2) {
    const r = n3.constructEmpty();
    r.setCoords({ pt: t3 }), r.mergeEnvelope2D(s3), n5 = zt2(e2, r, false);
  } else n5 = e2;
  return n5;
}
function Hr2(e2, t3, s3) {
  let n5;
  if (e2 instanceof oc || null === e2) {
    const r = n3.constructEmpty();
    r.setCoords({ env2D: t3 }), r.mergeEnvelope2D(s3), n5 = zt2(e2, r, false);
  } else n5 = e2;
  return n5;
}
function kr2(e2, r, i2, o, a2) {
  if (e2.isEmpty() || r.isEmpty()) return 4 === o;
  j(e2), j(r);
  let h2 = e2.getGeometryType(), m3 = r.getGeometryType();
  if (h2 === a.enumEnvelope) {
    if (m3 === a.enumEnvelope) return Ar2(e2, r, i2, o);
    if (m3 === a.enumPoint) return Mr2(r, e2, i2, Vr2(o));
  } else if (h2 === a.enumPoint) {
    if (m3 === a.enumEnvelope) return Mr2(e2, r, i2, o);
    if (m3 === a.enumPoint) return Ur2(e2, r, i2, o);
  }
  const l2 = n3.constructEmpty();
  e2.queryEnvelope(l2);
  const g2 = n3.constructEmpty();
  r.queryEnvelope(g2);
  const u = Hr2(i2, l2, g2);
  if (qr2(l2, g2, u)) return 4 === o;
  let c = false, _ = null, d2 = null, p3 = null, f3 = null;
  switch (f(h2) ? (_ = new Os2({ vd: e2.getDescription() }), _.addSegment(e2, true), p3 = _, h2 = a.enumPolyline) : p3 = e2, f(m3) ? (d2 = new Os2({ vd: r.getDescription() }), d2.addSegment(r, true), f3 = d2, m3 = a.enumPolyline) : f3 = r, h2 !== a.enumEnvelope && m3 !== a.enumEnvelope ? (p3.getDimension() < f3.getDimension() || h2 === a.enumPoint && m3 === a.enumMultiPoint) && (o = Vr2(o)) : h2 !== a.enumPolygon && m3 !== a.enumEnvelope && (o = Vr2(o)), h2) {
    case a.enumPolygon:
      switch (m3) {
        case a.enumPolygon:
          c = Yr2(p3, f3, u, o, a2);
          break;
        case a.enumPolyline:
          c = Rr2(p3, f3, u, o, a2);
          break;
        case a.enumPoint:
          c = Xr2(p3, f3, u, o);
          break;
        case a.enumMultiPoint:
          c = Lr2(p3, f3, u, o);
          break;
        case a.enumEnvelope:
          c = zr2(p3, f3, u, o, a2);
      }
      break;
    case a.enumPolyline:
      switch (m3) {
        case a.enumPolygon:
          c = Rr2(f3, p3, u, o, a2);
          break;
        case a.enumPolyline:
          c = Wr2(p3, f3, u, o, a2);
          break;
        case a.enumPoint:
          c = jr2(p3, f3, u, o);
          break;
        case a.enumMultiPoint:
          c = Zr2(p3, f3, u, o);
          break;
        case a.enumEnvelope:
          c = Kr2(p3, f3, u, o, a2);
      }
      break;
    case a.enumPoint:
      switch (m3) {
        case a.enumPolygon:
          c = Xr2(f3, p3, u, o);
          break;
        case a.enumPolyline:
          c = jr2(f3, p3, u, o);
          break;
        case a.enumMultiPoint:
          c = Jr2(f3, p3, u, o);
      }
      break;
    case a.enumMultiPoint:
      switch (m3) {
        case a.enumPolygon:
          c = Lr2(f3, p3, u, o);
          break;
        case a.enumPolyline:
          c = Zr2(f3, p3, u, o);
          break;
        case a.enumMultiPoint:
          c = Qr2(p3, f3, u, o);
          break;
        case a.enumPoint:
          c = Jr2(p3, f3, u, o);
          break;
        case a.enumEnvelope:
          c = $r2(p3, f3, u, o);
      }
      break;
    case a.enumEnvelope:
      switch (m3) {
        case a.enumPolygon:
          c = zr2(f3, p3, u, o, a2);
          break;
        case a.enumPolyline:
          c = Kr2(f3, p3, u, o, a2);
          break;
        case a.enumMultiPoint:
          c = $r2(f3, p3, u, o);
      }
  }
  return c;
}
function Ar2(e2, t3, s3, n5, r) {
  if (e2.isEmpty() || t3.isEmpty()) return 4 === n5;
  const i2 = n3.constructEmpty();
  e2.queryEnvelope(i2);
  const o = n3.constructEmpty();
  t3.queryEnvelope(o);
  const a2 = Hr2(s3, i2, o);
  switch (n5) {
    case 4:
      return qr2(i2, o, a2);
    case 2:
      return go2(o, i2, a2, false);
    case 128:
      return go2(o, i2, a2, true);
    case 1:
      return go2(i2, o, a2, false);
    case 64:
      return go2(i2, o, a2, true);
    case 3:
      return ho2(i2, o, a2);
    case 8:
      return mo2(i2, o, a2);
    case 32:
      return lo2(i2, o, a2);
    case 16:
      return false;
  }
  return false;
}
function Mr2(e2, t3, s3, n5, r) {
  if (e2.isEmpty() || t3.isEmpty()) return 4 === n5;
  const i2 = e2.getXY(), o = n3.constructEmpty();
  t3.queryEnvelope(o);
  const a2 = Fr2(s3, i2, o);
  switch (n5) {
    case 4:
      return Or2(i2, o, a2);
    case 2:
    case 128:
      return ao2(i2, o, a2);
    case 1:
    case 64:
      return false;
    case 3:
      return io2(i2, o, a2);
    case 8:
      return oo2(i2, o, a2);
  }
  return false;
}
function Ur2(e2, t3, s3, n5, r) {
  if (e2.isEmpty() || t3.isEmpty()) return 4 === n5;
  const i2 = e2.getXY(), o = t3.getXY();
  let a2;
  if (s3 instanceof oc || null === s3) {
    const e3 = n3.constructEmpty();
    e3.setCoords({ pt: i2 }), e3.merge(o), a2 = zt2(s3, e3, false);
  } else a2 = s3;
  switch (n5) {
    case 4:
      return no2(i2, o, a2);
    case 2:
    case 128:
      return ro2(o, i2, a2);
    case 1:
    case 64:
      return ro2(i2, o, a2);
    case 3:
      return so2(i2, o, a2);
  }
  return false;
}
function qr2(e2, t3, s3) {
  const n5 = n3.constructEmpty();
  return n5.setCoords({ env2D: t3 }), n5.inflateCoords(s3, s3), !e2.isIntersecting(n5);
}
function Br2(e2, t3, s3, n5 = false) {
  const r = e2.getGeometryType(), i2 = t3.getGeometryType();
  if (y(r)) {
    const t4 = e2.getImpl().getAccelerators();
    if (null !== t4) {
      const e3 = t4.getRasterizedGeometry();
      n(null === e3);
    }
  }
  if (y(i2)) {
    const e3 = t3.getImpl().getAccelerators();
    if (null !== e3) {
      const t4 = e3.getRasterizedGeometry();
      n(null === t4);
    }
  }
  return 0;
}
function Or2(e2, t3, s3, n5) {
  const r = n3.constructEmpty();
  return r.setCoords({ env2D: t3 }), r.inflateCoords(s3, s3), !r.contains(e2);
}
function Yr2(e2, t3, s3, n5, r) {
  switch (n5) {
    case 4:
      return ti2(e2, t3, s3);
    case 2:
      return ri2(t3, e2, s3, r);
    case 128:
      return ii3(t3, e2, s3);
    case 1:
      return ri2(e2, t3, s3, r);
    case 64:
      return ii3(e2, t3, s3);
    case 3:
      return ei3(e2, t3, s3, r);
    case 8:
      return si3(e2, t3, s3);
    case 32:
      return ni3(e2, t3, s3, r);
  }
  return false;
}
function Rr2(e2, t3, s3, n5, r) {
  switch (n5) {
    case 4:
      return oi3(e2, t3, s3);
    case 1:
      return mi3(e2, t3, s3, r);
    case 64:
      return li2(e2, t3, s3);
    case 8:
      return ai3(e2, t3, s3, r);
    case 16:
      return hi3(e2, t3, s3);
  }
  return false;
}
function Xr2(e2, t3, s3, n5, r) {
  switch (n5) {
    case 4:
      return gi2(e2, t3, s3);
    case 1:
    case 64:
      return ci2(e2, t3, s3);
    case 8:
      return ui2(e2, t3, s3);
  }
  return false;
}
function Lr2(e2, t3, s3, n5, r) {
  switch (n5) {
    case 4:
      return _i2(e2, t3, s3);
    case 1:
      return fi2(e2, t3, s3, false);
    case 64:
      return fi2(e2, t3, s3, true);
    case 8:
      return di2(e2, t3, s3);
    case 16:
      return pi2(e2, t3, s3);
  }
  return false;
}
function zr2(e2, t3, s3, n5, r) {
  if (yi2(e2, t3, s3)) return 4 === n5;
  if (4 === n5) return false;
  switch (n5) {
    case 2:
      return Si2(e2, t3, s3, false);
    case 128:
      return Si2(e2, t3, s3, true);
    case 1:
      return Ci2(e2, t3, s3, false, r);
    case 64:
      return Ci2(e2, t3, s3, true, r);
    case 3:
      return xi2(e2, t3, s3, r);
    case 8:
      return Pi2(e2, t3, s3, r);
    case 32:
      return Ei2(e2, t3, s3, r);
    case 16:
      return false;
  }
  return false;
}
function Wr2(e2, t3, s3, n5, r) {
  switch (n5) {
    case 4:
      return bi2(e2, t3, s3);
    case 2:
      return Ti2(t3, e2, s3, r);
    case 128:
      return Gi2(t3, e2, s3, r);
    case 1:
      return Ti2(e2, t3, s3, r);
    case 64:
      return Gi2(e2, t3, s3, r);
    case 3:
      return Ii2(e2, t3, s3, r);
    case 8:
      return wi2(e2, t3, s3, r);
    case 32:
      return Ni2(e2, t3, s3, r);
    case 16:
      return vi2(e2, t3, s3, r);
  }
  return false;
}
function jr2(e2, t3, s3, n5, r) {
  switch (n5) {
    case 4:
      return Di2(e2, t3, s3);
    case 1:
    case 64:
      return Fi2(e2, t3, s3);
    case 8:
      return Vi2(e2, t3, s3);
  }
  return false;
}
function Zr2(e2, t3, s3, n5, r) {
  switch (n5) {
    case 4:
      return Hi2(e2, t3, s3);
    case 1:
    case 64:
      return Mi2(e2, t3, s3);
    case 8:
      return ki2(e2, t3, s3);
    case 16:
      return Ai2(e2, t3, s3);
  }
  return false;
}
function Kr2(e2, t3, s3, n5, r) {
  if (qi2(e2, t3, s3)) return 4 === n5;
  if (4 === n5) return false;
  switch (n5) {
    case 2:
      return Oi2(e2, t3, s3, false);
    case 128:
      return Oi2(e2, t3, s3, true);
    case 1:
    case 64:
    case 32:
      return false;
    case 3:
      return Ui2(e2, t3, s3);
    case 8:
      return Bi2(e2, t3, s3, r);
    case 16:
      return Yi2(e2, t3, s3);
  }
  return false;
}
function Qr2(e2, t3, s3, n5, r) {
  switch (n5) {
    case 4:
      return Xi2(e2, t3, s3);
    case 2:
    case 128:
      return zi2(t3, e2, s3);
    case 1:
    case 64:
      return zi2(e2, t3, s3);
    case 3:
      return Ri2(e2, t3, s3);
    case 32:
      return Li2(e2, t3, s3);
  }
  return false;
}
function Jr2(e2, t3, s3, n5, r) {
  switch (n5) {
    case 4:
      return ji2(e2, t3, s3);
    case 2:
    case 128:
      return Zi2(e2, t3, s3);
    case 1:
    case 64:
      return Ki(e2, t3, s3);
    case 3:
      return Wi2(e2, t3, s3);
  }
  return false;
}
function $r2(e2, t3, s3, n5, r) {
  switch (n5) {
    case 4:
      return Ji2(e2, t3, s3);
    case 2:
      return eo2(e2, t3, s3, false);
    case 128:
      return eo2(e2, t3, s3, true);
    case 1:
    case 64:
      return false;
    case 3:
      return Qi(e2, t3, s3);
    case 8:
      return $i2(e2, t3, s3);
    case 16:
      return to2(e2, t3, s3);
  }
  return false;
}
function ei3(e2, t3, s3, n5) {
  const r = n3.constructEmpty(), i2 = n3.constructEmpty();
  if (e2.queryEnvelope(r), t3.queryEnvelope(i2), !ho2(r, i2, s3)) return false;
  if (Br2(e2, t3), yo2(e2, t3, s3)) return true;
  const o = e2.calculateLength2D(), a2 = t3.calculateLength2D(), h2 = Math.max(e2.getPointCount(), t3.getPointCount());
  if (Math.abs(o - a2) > 4 * h2 * s3) return false;
  if (e2.hasNonLinearSegments() || t3.hasNonLinearSegments()) {
    return sr2(e2, t3, s3, "**F**FFF*", n5, false);
  }
  return So2(e2, t3, s3, true);
}
function ti2(e2, t3, s3, n5) {
  Br2(e2, t3, s3, true);
  return 1 === uo2(e2, t3, s3, true);
}
function si3(e2, t3, s3, n5) {
  return Br2(e2, t3), Go2(e2, t3, s3, null);
}
function ni3(e2, t3, s3, n5) {
  return Br2(e2, t3), Do2(e2, t3, s3, n5);
}
function ri2(e2, t3, s3, n5) {
  const r = n3.constructEmpty(), i2 = n3.constructEmpty();
  return e2.queryEnvelope(r), t3.queryEnvelope(i2), !!po2(r, i2, s3) && (Br2(e2, t3), Vo2(e2, t3, s3, n5));
}
function ii3(e2, t3, s3, n5) {
  const r = n3.constructEmpty(), i2 = n3.constructEmpty();
  return e2.queryEnvelope(r), t3.queryEnvelope(i2), !!po2(r, i2, s3) && (Br2(e2, t3), 2 === uo2(e2, t3, s3, false));
}
function oi3(e2, t3, s3, n5) {
  Br2(e2, t3, s3, true);
  return 1 === uo2(e2, t3, s3, true);
}
function ai3(e2, t3, s3, n5) {
  return Br2(e2, t3), Fo2(e2, t3, s3, n5);
}
function hi3(e2, t3, s3, n5) {
  return Br2(e2, t3), Ho2(e2, t3, s3, null);
}
function mi3(e2, t3, s3, n5) {
  const r = n3.constructEmpty(), i2 = n3.constructEmpty();
  return e2.queryEnvelope(r), t3.queryEnvelope(i2), !!po2(r, i2, s3) && (Br2(e2, t3), ko2(e2, t3, s3, n5));
}
function li2(e2, t3, s3, n5) {
  const r = n3.constructEmpty(), i2 = n3.constructEmpty();
  return e2.queryEnvelope(r), t3.queryEnvelope(i2), !!po2(r, i2, s3) && (Br2(e2, t3), 2 === uo2(e2, t3, s3, false));
}
function gi2(e2, t3, s3, n5) {
  return 0 === Xo2(e2, t3, s3);
}
function ui2(e2, t3, s3, n5) {
  return Mo2(e2, t3.getXY(), s3);
}
function ci2(e2, t3, s3, n5) {
  return Ao2(e2, t3.getXY(), s3);
}
function _i2(e2, t3, s3, n5, r) {
  Br2(e2, t3);
  return 1 === co2(e2, t3, s3);
}
function di2(e2, t3, s3, n5) {
  Br2(e2, t3);
  const r = n3.constructEmpty();
  e2.queryEnvelope(r), r.inflateCoords(s3, s3);
  const i2 = new mi();
  let o = false;
  const a2 = e2.getImpl(), h2 = new ur();
  let m3 = e2, l2 = false;
  for (let g2 = 0; g2 < t3.getPointCount(); g2++) {
    if (t3.queryXY(g2, i2), r.contains(i2)) {
      const e3 = Lo2(m3, i2, s3);
      if (2 === e3) o = true;
      else if (1 === e3) return false;
    }
    l2 || (!Wn2(e2, t3.getPointCount() - 1) || null !== a2.getAccelerators() && null !== a2.getAccelerators().getQuadTree() ? m3 = e2 : (e2.copyTo(h2), h2.getImpl().buildQuadTreeAccelerator(1), m3 = h2), l2 = true);
  }
  return !!o;
}
function pi2(e2, t3, s3, n5) {
  Br2(e2, t3);
  const r = new n3(), i2 = new n3(), o = new n3();
  e2.queryEnvelope(r), t3.queryEnvelope(o), i2.setCoords({ env2D: r }), i2.inflateCoords(s3, s3);
  let a2 = false, h2 = false;
  const m3 = new mi(), l2 = e2.getImpl(), g2 = new ur();
  let u = e2, c = false;
  for (let _ = 0; _ < t3.getPointCount(); _++) {
    if (t3.queryXY(_, m3), i2.contains(m3)) {
      const e3 = Lo2(u, m3, s3);
      0 === e3 ? h2 = true : 1 === e3 && (a2 = true);
    } else h2 = true;
    if (a2 && h2) return true;
    c || (!Wn2(e2, t3.getPointCount() - 1) || null !== l2.getAccelerators() && null !== l2.getAccelerators().getQuadTree() ? u = e2 : (e2.copyTo(g2), g2.getImpl().buildQuadTreeAccelerator(1), u = g2), c = true);
  }
  return false;
}
function fi2(e2, t3, s3, n5, r) {
  const i2 = n3.constructEmpty(), o = n3.constructEmpty();
  if (e2.queryEnvelope(i2), t3.queryEnvelope(o), !po2(i2, o, s3)) return false;
  Br2(e2, t3);
  let a2 = false;
  const h2 = new mi(), m3 = e2.getImpl(), l2 = new ur();
  let g2 = e2, u = false;
  for (let c = 0; c < t3.getPointCount(); c++) {
    if (t3.queryXY(c, h2), !i2.contains(h2)) return false;
    const r2 = Lo2(g2, h2, s3);
    if (1 === r2) a2 = true;
    else if (0 === r2) return false;
    if (n5 && 2 === r2) return false;
    u || (!Wn2(e2, t3.getPointCount() - 1) || null !== m3.getAccelerators() && null !== m3.getAccelerators().getQuadTree() ? g2 = e2 : (e2.copyTo(l2), l2.getImpl().buildQuadTreeAccelerator(1), g2 = l2), u = true);
  }
  return a2;
}
function xi2(e2, t3, s3, n5) {
  const r = new n3(), i2 = new n3();
  if (e2.queryEnvelope(r), t3.queryEnvelope(i2), !ho2(r, i2, s3)) return false;
  const o = new ur();
  return o.addEnvelope(t3, false), ei3(e2, o, s3, n5);
}
function yi2(e2, t3, s3, n5) {
  Br2(e2, t3);
  const r = n3.constructEmpty(), i2 = n3.constructEmpty();
  if (e2.queryEnvelope(r), t3.queryEnvelope(i2), po2(i2, r, s3)) return false;
  return 0 === Lo2(e2, i2.getLowerLeft(), 0) && (!i2.contains(e2.getXY(0)) && !To2(e2, i2, s3));
}
function Pi2(e2, t3, s3, n5) {
  Br2(e2, t3);
  const r = new n3(), i2 = new n3();
  if (e2.queryEnvelope(r), t3.queryEnvelope(i2), po2(i2, r, s3)) return false;
  if (i2.height() <= s3 || i2.width() <= s3) return false;
  const o = new ur();
  return o.addEnvelope(t3, false), Go2(e2, o, s3, n5);
}
function Ei2(e2, t3, s3, n5) {
  Br2(e2, t3);
  const r = new n3(), i2 = new n3();
  if (e2.queryEnvelope(r), t3.queryEnvelope(i2), po2(i2, r, s3)) return false;
  if (i2.height() <= s3 || i2.width() <= s3) return false;
  const o = new ur();
  return o.addEnvelope(t3, false), Do2(e2, o, s3, n5);
}
function Si2(e2, t3, s3, n5, r) {
  const i2 = n3.constructEmpty(), o = n3.constructEmpty();
  return e2.queryEnvelope(i2), t3.queryEnvelope(o), n5 ? fo2(o, i2, s3) : po2(o, i2, s3);
}
function Ci2(e2, t3, s3, n5, r) {
  const i2 = n3.constructEmpty(), o = n3.constructEmpty();
  if (e2.queryEnvelope(i2), t3.queryEnvelope(o), !po2(i2, o, s3)) return false;
  Br2(e2, t3);
  const a2 = new ur();
  return a2.addEnvelope(t3, false), n5 ? 2 === uo2(e2, a2, s3, false) : Vo2(e2, a2, s3, r);
}
function Ii2(e2, t3, s3, n5) {
  const r = n3.constructEmpty(), i2 = n3.constructEmpty();
  if (e2.queryEnvelope(r), t3.queryEnvelope(i2), !ho2(r, i2, s3)) return false;
  if (Br2(e2, t3), yo2(e2, t3, s3)) return true;
  if (e2.hasNonLinearSegments() || t3.hasNonLinearSegments()) {
    return sr2(e2, t3, s3, "**F**FFF*", n5, false);
  }
  return So2(e2, t3, s3, false);
}
function bi2(e2, t3, s3, n5) {
  Br2(e2, t3);
  const r = e2.getImpl(), i2 = t3.getImpl();
  return !new Dr2(r, i2, s3, true).next() || !Io2(e2, t3, s3);
}
function wi2(e2, t3, s3, n5) {
  Br2(e2, t3);
  const r = [], i2 = bo2(e2, t3, s3, r);
  if (-2 === i2) {
    const r2 = n3.constructEmpty(), i3 = n3.constructEmpty(), o2 = n3.constructEmpty();
    let a3, h3;
    if (e2.queryEnvelope(r2), t3.queryEnvelope(i3), r2.inflateCoords(1e3 * s3, 1e3 * s3), i3.inflateCoords(1e3 * s3, 1e3 * s3), o2.setCoords({ env2D: r2 }), o2.intersect(i3), e2.getPointCount() > 10) {
      if (a3 = f2(e2, o2, s3, 0, n5), a3.isEmpty()) return false;
    } else a3 = e2;
    if (t3.getPointCount() > 10) {
      if (h3 = f2(t3, o2, s3, 0, n5), h3.isEmpty()) return false;
    } else h3 = t3;
    return sr2(a3, h3, s3, "F********", n5, false);
  }
  if (0 !== i2) return false;
  const o = new cs2();
  for (let m3 = 0; m3 < r.length; m3 += 2) {
    const e3 = r[m3], t4 = r[m3 + 1];
    o.addXY(e3, t4);
  }
  const a2 = e2.getBoundary(), h2 = t3.getBoundary();
  return a2.addPoints(h2, 0, h2.getPointCount()), !a2.isEmpty() && zi2(a2, o, s3);
}
function vi2(e2, t3, s3, n5) {
  Br2(e2, t3);
  const r = [], i2 = bo2(e2, t3, s3, r);
  if (-2 === i2) {
    const r2 = n3.constructEmpty(), i3 = n3.constructEmpty(), o2 = n3.constructEmpty();
    let a3, h3;
    if (e2.queryEnvelope(r2), t3.queryEnvelope(i3), r2.inflateCoords(1e3 * s3, 1e3 * s3), i3.inflateCoords(1e3 * s3, 1e3 * s3), o2.setCoords({ env2D: r2 }), o2.intersect(i3), e2.getPointCount() > 10) {
      if (a3 = f2(e2, o2, s3, 0, n5), a3.isEmpty()) return false;
    } else a3 = e2;
    if (t3.getPointCount() > 10) {
      if (h3 = f2(t3, o2, s3, 0, n5), h3.isEmpty()) return false;
    } else h3 = t3;
    return sr2(a3, h3, s3, "0********", n5, false);
  }
  if (0 !== i2) return false;
  const o = new cs2();
  for (let m3 = 0; m3 < r.length; m3 += 2) {
    const e3 = r[m3], t4 = r[m3 + 1];
    o.addXY(e3, t4);
  }
  const a2 = e2.getBoundary(), h2 = t3.getBoundary();
  return a2.addPoints(h2, 0, h2.getPointCount()), !!a2.isEmpty() || !zi2(a2, o, s3);
}
function Ni2(e2, t3, s3, n5) {
  Br2(e2, t3);
  const r = n3.constructEmpty(), i2 = n3.constructEmpty();
  e2.queryEnvelope(r), t3.queryEnvelope(i2);
  const o = xo2(r, i2, s3), a2 = xo2(i2, r, s3), h2 = e2.hasNonLinearSegments(), m3 = t3.hasNonLinearSegments(), l2 = bo2(e2, t3, s3, null);
  if (-1 === l2) return false;
  if (1 === l2) {
    if (o && a2) return true;
    if (!h2 && !m3) return o && !a2 ? !Co2(t3, e2, s3, false) : a2 && !o ? !Co2(e2, t3, s3, false) : !Co2(e2, t3, s3, false) && !Co2(t3, e2, s3, false);
  }
  const g2 = n3.constructEmpty(), u = n3.constructEmpty(), c = n3.constructEmpty();
  let _, d2;
  g2.setCoords({ env2D: r }), g2.inflateCoords(1e3 * s3, 1e3 * s3), u.setCoords({ env2D: i2 }), u.inflateCoords(1e3 * s3, 1e3 * s3), c.setCoords({ env2D: g2 }), c.intersect(u);
  let p3 = "";
  if (p3 += "1*", o) {
    if (t3.getPointCount() > 10) {
      if (d2 = f2(t3, c, s3, 0, n5), d2.isEmpty()) return false;
    } else d2 = t3;
    p3 += "****";
  } else d2 = t3, p3 += "T***";
  if (a2) {
    if (e2.getPointCount() > 10) {
      if (_ = f2(e2, c, s3, 0, n5), _.isEmpty()) return false;
    } else _ = e2;
    p3 += "***";
  } else _ = e2, p3 += "T**";
  return sr2(_, d2, s3, p3, n5, false);
}
function Ti2(e2, t3, s3, n5) {
  const r = n3.constructEmpty(), i2 = n3.constructEmpty();
  if (e2.queryEnvelope(r), t3.queryEnvelope(i2), !po2(r, i2, s3)) return false;
  if (Br2(e2, t3), e2.hasNonLinearSegments() || t3.hasNonLinearSegments()) {
    return sr2(e2, t3, s3, "******FF*", n5, false);
  }
  return Co2(t3, e2, s3, false);
}
function Gi2(e2, t3, s3, n5) {
  const r = n3.constructEmpty(), i2 = n3.constructEmpty();
  if (e2.queryEnvelope(r), t3.queryEnvelope(i2), !po2(r, i2, s3)) return false;
  Br2(e2, t3);
  return sr2(e2, t3, s3, "T**FF*FF*", n5, false);
}
function Di2(e2, t3, s3, n5) {
  Br2(e2, t3);
  return !vo2(e2, t3.getXY(), s3);
}
function Vi2(e2, t3, s3, n5) {
  Br2(e2, t3);
  return qo2(e2, t3.getXY(), s3);
}
function Fi2(e2, t3, s3, n5) {
  Br2(e2, t3);
  return No2(e2, t3.getXY(), s3);
}
function Hi2(e2, t3, s3, n5) {
  return Br2(e2, t3), !wo2(e2, t3, s3, false);
}
function ki2(e2, t3, s3, n5) {
  Br2(e2, t3);
  const r = e2.getImpl(), i2 = t3.getImpl(), o = new cs2(), a2 = new Dr2(r, i2, s3, false), h2 = r.querySegmentIterator();
  let m3 = false;
  for (; a2.next(); ) {
    const e3 = a2.getRedElement(), t4 = a2.getBlueElement();
    h2.resetToVertex(e3, -1);
    const n6 = h2.nextSegment(), r2 = i2.getXY(t4);
    n6.isIntersectingPoint(r2, s3) && (m3 = true, o.addPoint2D(r2));
  }
  if (!m3) return false;
  const l2 = e2.getBoundary();
  return !l2.isEmpty() && zi2(l2, o, s3);
}
function Ai2(e2, t3, s3, n5) {
  Br2(e2, t3);
  const r = e2.getImpl(), i2 = t3.getImpl(), o = i2.getPointCount(), a2 = Yt(o, false), h2 = new Dr2(r, i2, s3, false), m3 = r.querySegmentIterator();
  let l2 = false;
  for (; h2.next(); ) {
    const e3 = h2.getRedElement(), t4 = h2.getBlueElement();
    m3.resetToVertex(e3, -1);
    const n6 = m3.nextSegment(), r2 = i2.getXY(t4);
    n6.isIntersectingPoint(r2, s3) && (l2 = true, a2[t4] = true);
  }
  if (!l2) return false;
  let g2 = false;
  for (let _ = 0; _ < o; _++) if (!a2[_]) {
    g2 = true;
    break;
  }
  if (!g2) return false;
  const u = e2.getBoundary();
  if (u.isEmpty()) return true;
  const c = new cs2();
  for (let _ = 0; _ < o; _++) a2[_] && c.addPoint2D(i2.getXY(_));
  return !zi2(u, c, s3);
}
function Mi2(e2, t3, s3, n5, r) {
  const i2 = n3.constructEmpty(), o = n3.constructEmpty();
  if (e2.queryEnvelope(i2), t3.queryEnvelope(o), !po2(i2, o, s3)) return false;
  Br2(e2, t3);
  const a2 = wo2(e2, t3, s3, true);
  if (!a2) return a2;
  const h2 = e2.getBoundary();
  return h2.isEmpty() ? a2 : !zi2(h2, t3, s3);
}
function Ui2(e2, t3, s3, n5) {
  const r = new n3(), i2 = new n3();
  return e2.queryEnvelope(r), t3.queryEnvelope(i2), !(i2.height() > s3 && i2.width() > s3) && ho2(r, i2, s3);
}
function qi2(e2, t3, s3, n5) {
  const r = n3.constructEmpty(), i2 = n3.constructEmpty();
  e2.queryEnvelope(r), t3.queryEnvelope(i2);
  const o = Bo2(i2, r, s3);
  return 0 === o ? !To2(e2, i2, s3) : 4 === o;
}
function Bi2(e2, t3, n5, i2) {
  const o = new n3(), a2 = new n3();
  if (e2.queryEnvelope(o), t3.queryEnvelope(a2), a2.height() <= n5 || a2.width() <= n5) return false;
  const h2 = new n3(), m3 = new n3();
  if (h2.setCoords({ env2D: a2 }), m3.setCoords({ env2D: a2 }), h2.inflateCoords(n5, n5), m3.inflateCoords(-n5, -n5), m3.containsEnvelope(o) || !o.isIntersecting(h2)) return false;
  const l2 = e2.getImpl().querySegmentIterator();
  l2.stripAttributes();
  const g2 = e2.getImpl().getAccelerators();
  let u = null, c = null;
  null !== g2 && (u = g2.getQuadTree(), null !== u && (c = u.getIterator(a2, n5))), c || l2.nextPath() || b("relational_operations");
  let _ = false, d2 = null;
  const p3 = new mi(), f3 = new mi(), x4 = e2.hasNonLinearSegments();
  let y2 = false;
  for (; ; ) {
    if (null !== c) {
      const e3 = c.next();
      if (-1 === e3) break;
      l2.resetToVertex(u.getElement(e3), -1), d2 = l2.nextSegment();
    } else {
      for (; !l2.hasNextSegment() && l2.nextPath(); ) ;
      if (!l2.hasNextSegment()) break;
      d2 = l2.nextSegment();
    }
    if (x4 && d2.getGeometryType() !== a.enumLine) {
      const e3 = new n3();
      if (d2.queryEnvelope(e3), m3.containsEnvelope(e3)) return false;
      if (h2.isIntersecting(e3)) {
        y2 = true;
        break;
      }
    } else {
      p3.assign(d2.getStartXY()), f3.assign(d2.getEndXY());
      let e3 = m3.clipLine(p3, f3);
      if (0 !== e3) return false;
      _ || (e3 = h2.clipLine(p3, f3), 0 !== e3 && (_ = true));
    }
  }
  if (!y2) return _;
  const P5 = new ur();
  return P5.addEnvelope(a2, false), ai3(P5, e2, n5, i2);
}
function Oi2(e2, t3, n5, i2, o) {
  const a2 = n3.constructEmpty(), h2 = n3.constructEmpty();
  if (e2.queryEnvelope(a2), t3.queryEnvelope(h2), h2.height() <= n5 || h2.width() <= n5) return false;
  if (i2) return fo2(h2, a2, n5);
  if (!po2(h2, a2, n5)) return false;
  const m3 = n3.constructEmpty();
  m3.setCoords({ env2D: h2 }), m3.inflateCoords(-n5, -n5);
  const l2 = n3.constructEmpty();
  if (l2.setCoords({ env2D: h2 }), l2.inflateCoords(n5, n5), m3.containsEnvelope(a2)) return true;
  const g2 = e2.getImpl().querySegmentIterator();
  g2.stripAttributes(), g2.nextPath() || b("relational_operations");
  let u, c, _, d2, p3, f3, x4 = false;
  const y2 = e2.hasNonLinearSegments();
  for (y2 && (_ = new pm(), d2 = new pm(), p3 = new pm(), f3 = new pm(), m3.querySide(0, _), m3.querySide(1, d2), m3.querySide(2, p3), m3.querySide(3, f3)); ; ) {
    for (; !g2.hasNextSegment() && g2.nextPath(); ) ;
    if (!g2.hasNextSegment()) break;
    const e3 = g2.nextSegment();
    if (y2 && e3.getGeometryType() !== a.enumLine) {
      if (e3.isIntersecting(_, n5)) {
        x4 = true;
        break;
      }
      if (e3.isIntersecting(d2, n5)) {
        x4 = true;
        break;
      }
      if (e3.isIntersecting(p3, n5)) {
        x4 = true;
        break;
      }
      if (e3.isIntersecting(f3, n5)) {
        x4 = true;
        break;
      }
    } else {
      u = e3.getStartXY(), c = e3.getEndXY();
      if (0 !== m3.clipLine(u, c)) {
        x4 = true;
        break;
      }
    }
  }
  return x4;
}
function Yi2(e2, t3, n5, r) {
  const i2 = new n3(), a2 = new n3();
  if (e2.queryEnvelope(i2), t3.queryEnvelope(a2), a2.height() <= n5 || a2.width() <= n5) return false;
  const h2 = new n3();
  if (h2.setCoords({ env2D: a2 }), h2.inflateCoords(n5, n5), h2.containsEnvelope(i2)) return false;
  const m3 = true, l2 = new n3();
  if (l2.setCoords({ env2D: a2 }), l2.inflateCoords(-n5, -n5), !l2.isIntersecting(i2)) return false;
  const g2 = e2.getImpl().querySegmentIterator();
  g2.stripAttributes();
  const u = e2.getImpl().getAccelerators();
  let c = null, _ = null;
  if (null !== u && (c = u.getQuadTree(), null !== c && (_ = c.getIterator(a2, n5))), !_) {
    const e3 = g2.nextPath();
    n(e3);
  }
  let d2 = false, p3 = null;
  const f3 = new mi(), x4 = new mi();
  let y2 = null, P5 = null, E2 = null, S3 = null;
  for (e2.hasNonLinearSegments() && (y2 = new pm(), P5 = new pm(), E2 = new pm(), S3 = new pm(), l2.querySide(0, y2), l2.querySide(1, P5), l2.querySide(2, E2), l2.querySide(3, S3)); ; ) {
    if (null !== _) {
      const e3 = _.next();
      if (-1 === e3) break;
      g2.resetToVertex(c.getElement(e3), -1), p3 = g2.nextSegment();
    } else {
      for (; !g2.hasNextSegment() && g2.nextPath(); ) ;
      if (!g2.hasNextSegment()) break;
      p3 = g2.nextSegment();
    }
    if (p3.getGeometryType() === a.enumLine) {
      f3.assign(p3.getStartXY()), x4.assign(p3.getEndXY());
      if (0 !== l2.clipLine(f3, x4)) {
        d2 = true;
        break;
      }
    } else {
      if (y2.isIntersecting(p3, n5)) {
        d2 = true;
        break;
      }
      if (P5.isIntersecting(p3, n5)) {
        d2 = true;
        break;
      }
      if (E2.isIntersecting(p3, n5)) {
        d2 = true;
        break;
      }
      if (S3.isIntersecting(p3, n5)) {
        d2 = true;
        break;
      }
    }
  }
  return d2 && m3;
}
function Ri2(e2, t3, s3, n5) {
  const r = n3.constructEmpty(), i2 = n3.constructEmpty();
  return e2.queryEnvelope(r), t3.queryEnvelope(i2), !!ho2(r, i2, s3) && (!!Po2(e2, t3, s3) || Eo2(e2, t3, s3, false, true, false));
}
function Xi2(e2, t3, s3, n5) {
  const r = e2, i2 = t3, o = new Dr2(r, i2, s3, false), a2 = s3 * s3, h2 = new mi(), m3 = new mi();
  for (; o.next(); ) {
    const e3 = o.getRedElement(), t4 = o.getBlueElement();
    if (r.queryXY(e3, h2), i2.queryXY(t4, m3), mi.sqrDistance(h2, m3) <= a2) return false;
  }
  return true;
}
function Li2(e2, t3, s3, n5) {
  return Eo2(e2, t3, s3, false, false, true);
}
function zi2(e2, t3, s3, n5) {
  const r = n3.constructEmpty(), i2 = n3.constructEmpty();
  return e2.queryEnvelope(r), t3.queryEnvelope(i2), !!po2(r, i2, s3) && Eo2(t3, e2, s3, true, false, false);
}
function Wi2(e2, t3, s3, n5) {
  const r = n3.constructEmpty(), i2 = n3.constructEmpty();
  return e2.queryEnvelope(r), t3.queryEnvelope(i2), ho2(r, i2, s3);
}
function ji2(e2, t3, s3, n5) {
  return Uo2(e2, t3.getXY(), s3);
}
function Zi2(e2, t3, s3, n5) {
  return Wi2(e2, t3, s3);
}
function Ki(e2, t3, s3, n5) {
  return !ji2(e2, t3, s3);
}
function Qi(e2, t3, s3, n5) {
  const r = new n3(), i2 = new n3();
  return e2.queryEnvelope(r), t3.queryEnvelope(i2), !(i2.height() > s3 || i2.width() > s3) && ho2(r, i2, s3);
}
function Ji2(e2, t3, s3, n5) {
  const r = n3.constructEmpty(), i2 = n3.constructEmpty();
  if (e2.queryEnvelope(r), t3.queryEnvelope(i2), po2(i2, r, s3)) return false;
  const o = n3.constructEmpty();
  o.setCoords({ env2D: i2 }), o.inflateCoords(s3, s3);
  const a2 = new mi();
  for (let h2 = 0; h2 < e2.getPointCount(); h2++) if (e2.queryXY(h2, a2), o.contains(a2)) return false;
  return true;
}
function $i2(e2, t3, s3, n5) {
  const r = new n3(), i2 = new n3(), o = new n3();
  if (t3.queryEnvelope(r), r.height() <= s3 || r.width() <= s3) return false;
  i2.setCoords({ env2D: r }), o.setCoords({ env2D: r }), i2.inflateCoords(s3, s3), o.inflateCoords(-s3, -s3);
  const a2 = new mi();
  let h2 = false;
  for (let m3 = 0; m3 < e2.getPointCount(); m3++) if (e2.queryXY(m3, a2), i2.contains(a2)) {
    if (o.containsExclusive(a2)) return false;
    h2 = true;
  }
  return h2;
}
function eo2(e2, t3, s3, n5, r) {
  const i2 = n3.constructEmpty(), o = n3.constructEmpty();
  if (e2.queryEnvelope(i2), t3.queryEnvelope(o), o.height() <= s3 || o.width() <= s3) return false;
  if (n5) return fo2(o, i2, s3);
  if (!po2(o, i2, s3)) return false;
  let a2 = false;
  const h2 = n3.constructEmpty(), m3 = n3.constructEmpty();
  h2.setCoords({ env2D: o }), m3.setCoords({ env2D: o }), h2.inflateCoords(-s3, -s3), m3.inflateCoords(s3, s3);
  const l2 = new mi();
  for (let g2 = 0; g2 < e2.getPointCount(); g2++) {
    if (e2.queryXY(g2, l2), !m3.contains(l2)) return false;
    h2.containsExclusive(l2) && (a2 = true);
  }
  return a2;
}
function to2(e2, t3, s3, n5) {
  const r = new n3(), i2 = new n3();
  if (e2.queryEnvelope(r), t3.queryEnvelope(i2), po2(i2, r, s3)) return false;
  if (i2.height() <= s3 || i2.width() <= s3) return false;
  const o = new n3(), a2 = new n3();
  o.setCoords({ env2D: i2 }), o.inflateCoords(-s3, -s3), a2.setCoords({ env2D: i2 }), a2.inflateCoords(s3, s3);
  const h2 = new mi();
  let m3 = false, l2 = false;
  for (let g2 = 0; g2 < e2.getPointCount(); g2++) if (e2.queryXY(g2, h2), !m3 && o.containsExclusive(h2) && (m3 = true), l2 || a2.contains(h2) || (l2 = true), m3 && l2) return true;
  return false;
}
function so2(e2, t3, s3, n5) {
  return mi.sqrDistance(e2, t3) <= s3 * s3;
}
function no2(e2, t3, s3, n5) {
  return mi.sqrDistance(e2, t3) > s3 * s3;
}
function ro2(e2, t3, s3, n5) {
  return so2(e2, t3, s3);
}
function io2(e2, t3, s3, n5) {
  const r = new n3();
  return r.setCoords({ pt: e2 }), ho2(r, t3, s3);
}
function oo2(e2, t3, s3, n5) {
  if (t3.height() <= s3 || t3.width() <= s3) return false;
  const r = new n3(), i2 = new n3();
  return r.setCoords({ env2D: t3 }), r.inflateCoords(s3, s3), !!r.contains(e2) && (i2.setCoords({ env2D: t3 }), i2.inflateCoords(-s3, -s3), !i2.containsExclusive(e2));
}
function ao2(e2, t3, s3, n5) {
  if (t3.height() <= s3 || t3.width() <= s3) return false;
  const r = n3.constructEmpty();
  r.setCoords({ env2D: t3 }), r.inflateCoords(-s3, -s3);
  return r.containsExclusive(e2);
}
function ho2(e2, t3, s3, n5) {
  return po2(e2, t3, s3) && po2(t3, e2, s3);
}
function mo2(e2, t3, s3, n5) {
  if (e2.height() <= s3 || e2.width() <= s3 || t3.height() <= s3 || t3.width() <= s3) return false;
  const r = new n3();
  return r.setCoords({ env2D: e2 }), r.inflateCoords(-s3, -s3), r.intersect(t3), !(!r.isEmpty() && r.height() > s3 && r.width() > s3) && (r.setCoords({ env2D: e2 }), r.inflateCoords(s3, s3), r.intersect(t3), !r.isEmpty());
}
function lo2(e2, t3, s3, n5) {
  if (e2.height() <= s3 || e2.width() <= s3 || t3.height() <= s3 || t3.width() <= s3) return false;
  if (po2(e2, t3, s3)) return false;
  if (po2(t3, e2, s3)) return false;
  const r = new n3();
  return r.setCoords({ env2D: e2 }), r.inflateCoords(-s3, -s3), r.intersect(t3), !r.isEmpty() && (r.height() > s3 || r.width() > s3);
}
function go2(e2, t3, s3, n5, r) {
  if (e2.height() <= s3 || e2.width() <= s3) return false;
  if (n5) return fo2(e2, t3, s3);
  if (!po2(e2, t3, s3)) return false;
  const i2 = n3.constructEmpty();
  return i2.setCoords({ env2D: e2 }), i2.inflateCoords(-s3, -s3), i2.intersect(t3), !i2.isEmpty();
}
function uo2(e2, t3, n5, r, i2) {
  const o = new mi(), a2 = new mi(), h2 = n3.constructEmpty(), m3 = n3.constructEmpty(), l2 = e2.getImpl(), g2 = t3.getImpl(), u = g2.getGeometryType(), c = new Dr2(l2, g2, n5, true);
  if (!c.next()) return 1;
  if (Io2(e2, t3, n5)) return r ? 4 : 0;
  const _ = new ur();
  let d2 = e2;
  const p3 = new ur();
  let f3 = null;
  u === a.enumPolygon && (f3 = t3);
  const x4 = u === a.enumPolygon ? Yt(l2.getPathCount(), false) : [], y2 = Yt(g2.getPathCount(), false);
  let P5 = false, E2 = false, S3 = false, I4 = false, b2 = false, w4 = false;
  do {
    if (S3 && b2 || I4 && w4) break;
    if (S3 && I4) break;
    const i3 = c.getRedElement(), C3 = c.getBlueElement();
    if (!y2[C3] && (a2.assign(t3.getXY(t3.getPathStart(C3))), h2.setCoords({ env2D: c.getRedEnvelope() }), h2.inflateCoords(n5, n5), h2.contains(a2))) {
      if (0 !== Lo2(d2, a2, 0)) {
        if (I4 = true, r) return 4;
      } else w4 = true;
      y2[C3] = true;
    }
    if (u === a.enumPolygon && !x4[i3] && (o.assign(e2.getXY(e2.getPathStart(i3))), m3.setCoords({ env2D: c.getBlueEnvelope() }), m3.inflateCoords(n5, n5), m3.contains(o))) {
      if (0 !== Lo2(f3, o, 0)) {
        if (S3 = true, r) return 4;
      } else b2 = true;
      x4[i3] = true;
    }
    if (P5 || (!Wn2(e2, t3.getPathCount() - 1) || null !== l2.getAccelerators() && null !== l2.getAccelerators().getQuadTree() ? d2 = e2 : (e2.copyTo(_), _.getImpl().buildQuadTreeAccelerator(1), d2 = _), P5 = true), u === a.enumPolygon && !E2) {
      const s3 = t3;
      !Wn2(s3, e2.getPathCount() - 1) || null !== g2.getAccelerators() && null !== g2.getAccelerators().getQuadTree() ? f3 = t3 : (s3.copyTo(p3), p3.getImpl().buildQuadTreeAccelerator(1), f3 = p3), E2 = true;
    }
  } while (c.next());
  if (!S3 && !I4) return 1;
  if (!b2 || !w4) {
    if (u === a.enumPolygon) {
      for (let e3 = 0, t4 = l2.getPathCount(); e3 < t4; e3++) if (!x4[e3]) {
        b2 = true;
        break;
      }
    }
    for (let e3 = 0, t4 = g2.getPathCount(); e3 < t4; e3++) if (!y2[e3]) {
      w4 = true;
      break;
    }
  }
  return S3 && b2 || I4 && w4 || S3 && I4 ? 4 : I4 ? 2 : 3;
}
function co2(e2, t3, s3, n5, r) {
  const i2 = n3.constructEmpty();
  e2.queryEnvelope(i2), i2.inflateCoords(s3, s3);
  const o = new mi(), a2 = e2.getImpl(), h2 = new ur();
  let m3 = e2, l2 = false, g2 = false, u = false;
  for (let c = 0; c < t3.getPointCount(); c++) {
    if (t3.queryXY(c, o), i2.contains(o)) {
      const e3 = Lo2(m3, o, s3);
      if (1 === e3) return g2 = true, 4;
      if (2 === e3) return 4;
      u = true;
    } else u = true;
    l2 || (!Wn2(e2, t3.getPointCount() - 1) || null !== a2.getAccelerators() && null != a2.getAccelerators().getQuadTree() ? m3 = e2 : (e2.copyTo(h2), h2.getImpl().buildQuadTreeAccelerator(1), m3 = h2), l2 = true);
  }
  return g2 ? u ? 4 : 2 : 1;
}
function _o2(e2, t3, n5, r, i2) {
  r[0] = false;
  const a2 = e2.getImpl(), h2 = t3.getImpl(), m3 = a2.querySegmentIterator(), l2 = h2.querySegmentIterator(), g2 = [0, 0], u = [0, 0], c = new Dr2(a2, h2, n5);
  let _ = false;
  for (; c.next(); ) {
    const e3 = c.getRedElement(), t4 = c.getBlueElement();
    m3.resetToVertex(e3, -1), l2.resetToVertex(t4, -1);
    const s3 = m3.nextSegment(), i3 = l2.nextSegment();
    let o = 0;
    if (Oo2(s3, i3) ? !_ && i3.isIntersecting(s3, n5) && (_ = true) : o = i3.intersect(s3, null, u, g2, n5), 0 !== o && (_ = true, 1 === o)) {
      const e4 = g2[0], t5 = u[0];
      if (e4 > 0 && e4 < 1 && t5 > 0 && t5 < 1) return r[0] = true, false;
    }
  }
  if (!_) {
    r[0] = true;
    const i3 = n3.constructEmpty();
    e2.queryEnvelope(i3), i3.inflateCoords(n5, n5);
    const m4 = new ur();
    let l3 = e2, g3 = false;
    for (let s3 = 0, n6 = t3.getPathCount(); s3 < n6; s3++) if (t3.getPathSize(s3) > 0) {
      const n7 = n3.constructEmpty();
      if (t3.queryPathEnvelope(s3, n7), !i3.isIntersecting(n7)) return false;
      {
        const e3 = zn2(l3, t3.getXY(t3.getPathStart(s3)), 0);
        if (n(-1 !== e3), 0 === e3) return false;
      }
      g3 || (!Wn2(e2, t3.getPathCount() - 1) || null !== a2.getAccelerators() && null !== a2.getAccelerators().getQuadTree() ? l3 = e2 : (e2.copyTo(m4), m4.getImpl().buildQuadTreeAccelerator(1), l3 = m4), g3 = true);
    }
    if (1 === e2.getPathCount() || t3.getGeometryType() === a.enumPolyline) return true;
    const u2 = t3, c2 = n3.constructEmpty();
    u2.queryEnvelope(c2), c2.inflateCoords(n5, n5);
    const _2 = new ur();
    let d2 = u2, p3 = false;
    for (let t4 = 0, s3 = e2.getPathCount(); t4 < s3; t4++) if (e2.getPathSize(t4) > 0) {
      const s4 = n3.constructEmpty();
      if (e2.queryPathEnvelope(t4, s4), c2.isIntersecting(s4)) {
        const s5 = zn2(d2, e2.getXY(e2.getPathStart(t4)), 0);
        if (n(-1 !== s5), 1 === s5) return false;
      }
      p3 || (!Wn2(u2, e2.getPathCount() - 1) || null !== h2.getAccelerators() && null !== h2.getAccelerators().getQuadTree() ? d2 = u2 : (u2.copyTo(_2), _2.getImpl().buildQuadTreeAccelerator(1), d2 = _2), p3 = true);
    }
    return true;
  }
  return false;
}
function po2(e2, t3, s3) {
  const n5 = n3.constructEmpty();
  return n5.setCoords({ env2D: e2 }), n5.inflateCoords(s3, s3), n5.containsEnvelope(t3);
}
function fo2(e2, t3, s3) {
  const n5 = n3.constructEmpty();
  return n5.setCoords({ env2D: t3 }), n5.inflateCoords(s3, s3), e2.containsExclusiveEnvelope(n5);
}
function xo2(e2, t3, s3) {
  const n5 = n3.constructEmpty();
  return n5.setCoords({ env2D: t3 }), n5.inflateCoords(s3, s3), !n5.contains(e2.getLowerLeft()) || (!n5.contains(e2.getLowerRight()) || (!n5.contains(e2.getUpperLeft()) || !n5.contains(e2.getUpperRight())));
}
function yo2(e2, t3, s3, n5) {
  if (e2.getPathCount() !== t3.getPathCount() || e2.getPointCount() !== t3.getPointCount()) return false;
  if (e2.hasNonLinearSegments() || t3.hasNonLinearSegments()) return e2.equals(t3);
  const r = new mi(), i2 = new mi();
  let o = true;
  const a2 = s3 * s3;
  for (let h2 = 0; h2 < e2.getPathCount(); h2++) {
    if (e2.getPathEnd(h2) !== t3.getPathEnd(h2)) {
      o = false;
      break;
    }
    for (let s4 = e2.getPathStart(h2); s4 < t3.getPathEnd(h2); s4++) if (e2.queryXY(s4, r), t3.queryXY(s4, i2), mi.sqrDistance(r, i2) > a2) {
      o = false;
      break;
    }
    if (!o) break;
  }
  return !!o;
}
function Po2(e2, t3, s3, n5) {
  if (e2.getPointCount() !== t3.getPointCount()) return false;
  const r = new mi(), i2 = new mi();
  let o = true;
  const a2 = s3 * s3;
  for (let h2 = 0; h2 < e2.getPointCount(); h2++) if (e2.queryXY(h2, r), t3.queryXY(h2, i2), mi.sqrDistance(r, i2) > a2) {
    o = false;
    break;
  }
  return !!o;
}
function Eo2(e2, t3, s3, n5, r, i2, o) {
  const a2 = e2.getImpl(), h2 = t3.getImpl(), m3 = a2.getPointCount(), l2 = h2.getPointCount(), g2 = Yt(m3, false), u = r || i2 ? Yt(l2, false) : [], c = s3 * s3, _ = new Dr2(a2, h2, s3);
  for (; _.next(); ) {
    const e3 = _.getRedElement(), t4 = _.getBlueElement(), s4 = a2.getXY(e3), n6 = h2.getXY(t4);
    mi.sqrDistance(s4, n6) <= c && (g2[e3] = true, (r || i2) && (u[t4] = true));
  }
  let d2 = false, p3 = false;
  for (let y2 = 0; y2 < m3; y2++) {
    const e3 = g2[y2];
    if (d2 ||= !e3, p3 ||= e3, (r || n5) && d2) return false;
  }
  if (n5) return true;
  let f3 = false, x4 = false;
  for (let y2 = 0; y2 < l2; y2++) {
    const e3 = u[y2];
    if (f3 ||= !e3, x4 ||= e3, r && f3) return false;
  }
  return !!r || d2 && p3 && f3 && x4;
}
function So2(e2, t3, s3, n5) {
  return Co2(e2, t3, s3, n5) && Co2(t3, e2, s3, n5);
}
function Co2(e2, t3, s3, n5) {
  if (N(e2), N(t3), t3.isEmpty()) return false;
  let i2 = true;
  const o = Yt(2, Number.NaN), a2 = Yt(2, Number.NaN), h2 = [], m3 = new Ro2();
  let l2;
  const g2 = n3.constructEmpty(), u = n3.constructEmpty(), c = n3.constructEmpty();
  e2.queryEnvelope(g2), t3.queryEnvelope(u), g2.inflateCoords(s3, s3), u.inflateCoords(s3, s3), c.setCoords({ env2D: g2 }), c.intersect(u);
  const _ = e2.getImpl().querySegmentIterator(), d2 = t3.getImpl().querySegmentIterator(), p3 = t3.getImpl().getAccelerators();
  let f3 = null, y2 = null, P5 = null, E2 = null;
  if (null !== p3 && (f3 = p3.getQuadTree(), y2 = p3.getQuadTreeForPaths(), null !== y2 && (E2 = y2.getIteratorForQT())), null === f3) {
    const s4 = e2.getPointCount(), n6 = t3.getPointCount();
    s4 > 10 && n6 > 10 && (f3 = Wt2(t3.getImpl(), c));
  }
  for (null !== f3 && (P5 = f3.getIteratorForQT()); _.nextPath(); ) for (; _.hasNextSegment(); ) {
    let e3 = _.nextSegment();
    if (e3.queryEnvelope(g2), !g2.isIntersecting(c)) return i2 = false, false;
    if (null !== E2 && (E2.resetIterator(g2, s3), -1 === E2.next())) continue;
    let t4 = 0, p4 = null;
    if (null != P5) P5.resetIterator(e3, s3);
    else if (d2.resetToFirstPath(), !d2.nextPath()) return i2 = false, false;
    do {
      if (t4 = 0, null !== P5) {
        const n6 = P5.next();
        if (-1 === n6) return i2 = false, false;
        d2.resetToVertex(f3.getElement(n6), -1), p4 = d2.nextSegment(), t4 = e3.intersect(p4, null, o, a2, s3);
      } else {
        for (; !d2.hasNextSegment(); ) if (!d2.nextPath()) return i2 = false, false;
        p4 = d2.nextSegment(), p4.queryEnvelope(u), u.inflateCoords(s3, s3), g2.isIntersecting(u) && (t4 = e3.intersect(p4, null, o, a2, s3));
      }
    } while (2 !== t4 || 0 !== o[0] || n5 && !(a2[0] <= a2[1]));
    let x4 = Number.NaN, y3 = false;
    do {
      let n6 = false;
      if (1 === o[1]) {
        if (!_.hasNextSegment()) {
          y3 = true;
          break;
        }
        e3 = _.nextSegment(), n6 = true;
      }
      if (1 === a2[1] && a2[0] <= a2[1]) {
        if (-1 === x4) break;
        if (x4 = 1, !d2.hasNextSegment()) break;
        p4 = d2.nextSegment(), n6 = true;
      }
      if (0 === a2[1] && a2[0] > a2[1]) {
        if (1 === x4) break;
        if (Number.isNaN(x4)) {
          if (!d2.hasPreviousSegment()) break;
          d2.previousSegment(), x4 = -1;
        }
        if (!d2.hasPreviousSegment()) break;
        p4 = d2.previousSegment(), n6 = true;
      }
      if (!n6) break;
      t4 = e3.intersect(p4, null, o, a2, s3);
    } while (2 === t4 && (!n5 || a2[0] <= a2[1]));
    if (y3) continue;
    const S3 = e3.calculateLength2D();
    e3.queryEnvelope(g2), h2.length = 0, m3.m_overlapEvents.length = 0;
    let C3 = false, I4 = false, b2 = 0;
    const w4 = zt2(null, g2, true);
    for (null !== P5 ? P5.resetIterator(e3, s3) : (d2.resetToFirstPath(), d2.nextPath() || b("relational_operations")); ; ) {
      if (t4 = 0, null !== P5) {
        const n6 = P5.next();
        if (-1 === n6) break;
        d2.resetToVertex(f3.getElement(n6), -1), p4 = d2.nextSegment(), t4 = e3.intersect(p4, null, o, a2, s3);
      } else {
        for (; !d2.hasNextSegment() && d2.nextPath(); ) ;
        if (!d2.hasNextSegment()) break;
        p4 = d2.nextSegment(), p4.queryEnvelope(u), u.inflateCoords(s3, s3), g2.isIntersecting(u) && (t4 = e3.intersect(p4, null, o, a2, s3));
      }
      if (2 === t4 && (!n5 || a2[0] <= a2[1])) {
        const e4 = _.getStartPointIndex(), t5 = _.getPathIndex(), n6 = d2.getStartPointIndex(), r = d2.getPathIndex();
        if (l2 = Yo2(e4, t5, o[0], o[1], n6, r, a2[0], a2[1]), m3.m_overlapEvents.push(l2), h2.push(h2.length), !(C3 || l2.m_scalarA0 < b2 && l2.m_scalarA1 < b2)) {
          if (0 === b2 && S3 * (l2.m_scalarA0 - b2) > s3) C3 = true;
          else if (0 !== b2 && S3 * (l2.m_scalarA0 - b2) > w4) C3 = true;
          else if (b2 = l2.m_scalarA1, S3 * (1 - b2) <= s3 || 1 === b2) {
            I4 = true;
            break;
          }
        }
      }
    }
    if (!I4) {
      if (!C3) return i2 = false, false;
      h2.length > 1 && h2.sort((e4, t5) => m3.compareOverlapEvents(e4, t5)), b2 = 0;
      for (let e4 = 0; e4 < m3.m_overlapEvents.length; e4++) if (l2 = m3.m_overlapEvents[h2[e4]], !(l2.m_scalarA0 < b2 && l2.m_scalarA1 < b2)) {
        if (0 === b2 && S3 * (l2.m_scalarA0 - b2) > s3) return i2 = false, false;
        if (0 !== b2 && S3 * (l2.m_scalarA0 - b2) > w4) return i2 = false, false;
        if (b2 = l2.m_scalarA1, S3 * (1 - b2) <= s3 || 1 === b2) break;
      }
      if (S3 * (1 - b2) > s3) return i2 = false, false;
      h2.length = 0, m3.m_overlapEvents.length = 0;
    }
  }
  return i2;
}
function Io2(e2, t3, s3) {
  const n5 = e2.getImpl(), r = t3.getImpl(), i2 = n5.querySegmentIterator(), o = r.querySegmentIterator(), a2 = new Dr2(n5, r, s3);
  for (; a2.next(); ) {
    const e3 = a2.getRedElement(), t4 = a2.getBlueElement();
    i2.resetToVertex(e3, -1), o.resetToVertex(t4, -1);
    const n6 = i2.nextSegment();
    if (o.nextSegment().isIntersecting(n6, s3)) return true;
  }
  return false;
}
function bo2(e2, t3, s3, n5) {
  const r = e2.getImpl(), i2 = t3.getImpl(), o = r.querySegmentIterator(), a2 = i2.querySegmentIterator(), h2 = Yt(2, Number.NaN), m3 = new Dr2(r, i2, s3);
  let l2 = false, g2 = -1;
  for (; m3.next(); ) {
    const e3 = m3.getRedElement(), t4 = m3.getBlueElement();
    o.resetToVertex(e3, -1), a2.resetToVertex(t4, -1);
    const r2 = o.nextSegment(), i3 = a2.nextSegment();
    let u = 0;
    if (Oo2(r2, i3)) {
      if (i3.isIntersecting(r2, s3)) return -2;
    } else u = r2.intersect(i3, null, h2, null, s3);
    if (u) {
      if (2 === u) {
        const e4 = r2.calculateLength2D(), t5 = h2[0];
        if (e4 * (h2[1] - t5) > s3) return g2 = 1, g2;
        l2 = true;
      } else if (g2 = 0, n5) {
        const e4 = h2[0], t5 = new mi();
        r2.queryCoord2D(e4, t5), n5.push(t5.x), n5.push(t5.y);
      }
    }
  }
  return l2 ? -2 : g2;
}
function wo2(e2, t3, s3, n5) {
  const r = e2.getImpl(), i2 = t3, o = i2.getPointCount(), a2 = n5 ? Yt(o, false) : [], h2 = new Dr2(r, i2, s3, false), m3 = r.querySegmentIterator();
  for (; h2.next(); ) {
    const e3 = h2.getRedElement(), t4 = h2.getBlueElement();
    m3.resetToVertex(e3, -1);
    const r2 = m3.nextSegment(), o2 = i2.getXY(t4);
    if (r2.isIntersectingPoint(o2, s3)) {
      if (!n5) return true;
      a2[t4] = true;
    }
  }
  if (!n5) return false;
  for (let l2 = 0; l2 < o; l2++) if (!a2[l2]) return false;
  return true;
}
function vo2(e2, t3, s3) {
  const n5 = new mi(), r = s3 * s3, i2 = e2.querySegmentIterator(), o = e2.getImpl().getAccelerators();
  if (null !== o) {
    const e3 = o.getQuadTree();
    if (null !== e3) {
      const o2 = n3.constructEmpty();
      o2.setCoords({ pt: t3 });
      const a3 = e3.getIterator(o2, s3);
      for (let s4 = a3.next(); -1 !== s4; s4 = a3.next()) if (i2.resetToVertex(e3.getElement(s4), -1), i2.hasNextSegment()) {
        const e4 = i2.nextSegment(), s5 = e4.getClosestCoordinate(t3, false);
        if (e4.queryCoord2D(s5, n5), mi.sqrDistance(t3, n5) <= r) return true;
      }
      return false;
    }
  }
  const a2 = n3.constructEmpty();
  for (; i2.nextPath(); ) for (; i2.hasNextSegment(); ) {
    const e3 = i2.nextSegment();
    if (e3.queryEnvelope(a2), a2.inflateCoords(s3, s3), !a2.contains(t3)) continue;
    const o2 = e3.getClosestCoordinate(t3, false);
    if (e3.queryCoord2D(o2, n5), mi.sqrDistance(t3, n5) <= r) return true;
  }
  return false;
}
function No2(e2, t3, s3) {
  return vo2(e2, t3, s3) && !qo2(e2, t3, s3);
}
function To2(e2, t3, n5, r) {
  const i2 = e2.querySegmentIterator(), o = e2.getImpl().getAccelerators(), a2 = e2.hasNonLinearSegments();
  let h2 = null, m3 = null, l2 = null, g2 = null;
  if (null !== o) {
    const e3 = o.getQuadTree();
    if (null !== e3) {
      const r2 = e3.getIterator(t3, n5);
      a2 && (h2 = new pm(), m3 = new pm(), l2 = new pm(), g2 = new pm(), t3.querySide(0, h2), t3.querySide(1, m3), t3.querySide(2, l2), t3.querySide(3, g2));
      const o2 = n3.constructEmpty();
      o2.setCoords({ env2D: t3 }), o2.inflateCoords(n5, n5);
      for (let a3 = r2.next(); -1 !== a3; a3 = r2.next()) if (i2.resetToVertex(e3.getElement(a3), -1), i2.hasNextSegment()) {
        const e4 = i2.nextSegment();
        if (e4.getGeometryType() === a.enumLine) {
          const t4 = e4.getStartXY(), s3 = e4.getEndXY();
          if (o2.clipLine(t4, s3)) return true;
          continue;
        }
        if (t3.contains(e4.getStartXY()) || t3.contains(e4.getEndXY())) return true;
        if (e4.isIntersecting(h2, n5)) return true;
        if (e4.isIntersecting(m3, n5)) return true;
        if (e4.isIntersecting(l2, n5)) return true;
        if (e4.isIntersecting(g2, n5)) return true;
      }
      return false;
    }
  }
  if (a2) {
    h2 = new pm(), m3 = new pm(), l2 = new pm(), g2 = new pm(), t3.querySide(0, h2), t3.querySide(1, m3), t3.querySide(2, l2), t3.querySide(3, g2);
    const s3 = e2.querySegmentIterator();
    for (; s3.nextPath(); ) for (; s3.hasNextSegment(); ) {
      const e3 = s3.nextSegment();
      if (t3.contains(e3.getStartXY()) || t3.contains(e3.getEndXY())) return true;
      if (e3.isIntersecting(h2, n5)) return true;
      if (e3.isIntersecting(m3, n5)) return true;
      if (e3.isIntersecting(l2, n5)) return true;
      if (e3.isIntersecting(g2, n5)) return true;
    }
  } else {
    const s3 = n3.constructEmpty();
    s3.setCoords({ env2D: t3 }), s3.inflateCoords(n5, n5);
    const r2 = e2.getImpl(), i3 = r2.getAttributeStreamRef(0), o2 = new mi();
    for (let e3 = 0, t4 = r2.getPathCount(); e3 < t4; e3++) {
      let t5 = true;
      const n6 = new mi(), a3 = new mi(), h3 = new mi(), m4 = r2.getPathStart(e3), l3 = new mi();
      for (let g3 = m4, u = r2.getPathEnd(e3); g3 < u; g3++) if (t5) i3.queryPoint2D(2 * g3, n6), l3.assign(n6), t5 = false;
      else {
        if (i3.queryPoint2D(2 * g3, o2), a3.setCoordsPoint2D(n6), h3.setCoordsPoint2D(o2), s3.clipLine(a3, h3)) return true;
        n6.assign(o2);
      }
      if (r2.isClosedPath(e3) && !t5 && (a3.setCoordsPoint2D(n6), h3.setCoordsPoint2D(l3), s3.clipLine(a3, h3))) return true;
    }
  }
  return false;
}
function Go2(e2, t3, s3, n5) {
  const r = e2.getImpl(), i2 = t3.getImpl(), o = [0], a2 = Ht2(r.getIsSimple(0, o)) && Ht2(i2.getIsSimple(0, o)), h2 = r.querySegmentIterator(), m3 = i2.querySegmentIterator(), l2 = Yt(2, 0), g2 = Yt(2, 0), u = new Dr2(r, i2, s3);
  let c = false;
  for (; u.next(); ) {
    const e3 = u.getRedElement(), t4 = u.getBlueElement();
    h2.resetToVertex(e3, -1), m3.resetToVertex(t4, -1);
    const n6 = h2.nextSegment(), r2 = m3.nextSegment();
    let i3 = 0;
    if (Oo2(n6, r2)) {
      if (r2.isIntersecting(n6, s3)) {
        c = true;
        break;
      }
    } else i3 = r2.intersect(n6, null, g2, l2, s3);
    if (2 === i3) {
      const e4 = l2[0], t5 = l2[1], r3 = n6.calculateLength2D();
      if (a2 && (t5 - e4) * r3 > s3) return false;
      c = true;
    } else if (i3) {
      const e4 = l2[0], t5 = g2[0];
      if (e4 > 0 && e4 < 1 && t5 > 0 && t5 < 1) return false;
      c = true;
    }
  }
  if (!c) return false;
  const _ = n3.constructEmpty(), d2 = n3.constructEmpty(), p3 = n3.constructEmpty();
  let f3, x4;
  if (e2.queryEnvelope(_), t3.queryEnvelope(d2), _.inflateCoords(1e3 * s3, 1e3 * s3), d2.inflateCoords(1e3 * s3, 1e3 * s3), p3.setCoords({ env2D: _ }), p3.intersect(d2), e2.getPointCount() > 10) {
    if (f3 = f2(e2, p3, s3, 0, n5), f3.isEmpty()) return false;
  } else f3 = e2;
  if (t3.getPointCount() > 10) {
    if (x4 = f2(t3, p3, s3, 0, n5), x4.isEmpty()) return false;
  } else x4 = t3;
  return sr2(f3, x4, s3, "F********", n5, false);
}
function Do2(e2, t3, s3, n5) {
  const r = e2.getImpl(), i2 = t3.getImpl(), o = [0], a2 = Ht2(r.getIsSimple(0, o)) && Ht2(i2.getIsSimple(0, o)), h2 = n3.constructEmpty(), m3 = n3.constructEmpty(), l2 = n3.constructEmpty();
  e2.queryEnvelope(h2), t3.queryEnvelope(m3);
  let g2 = false;
  const u = xo2(h2, m3, s3), c = xo2(m3, h2, s3), _ = r.querySegmentIterator(), d2 = i2.querySegmentIterator(), p3 = Yt(2, Number.NaN), f3 = Yt(2, Number.NaN), x4 = new Dr2(r, i2, s3);
  for (; x4.next(); ) {
    const e3 = x4.getRedElement(), t4 = x4.getBlueElement();
    _.resetToVertex(e3, -1), d2.resetToVertex(t4, -1);
    const n6 = _.nextSegment(), r2 = d2.nextSegment();
    let i3 = 0;
    if (Oo2(n6, r2)) {
      if (r2.isIntersecting(n6, s3)) break;
    } else i3 = r2.intersect(n6, null, f3, p3, s3);
    if (2 === i3) {
      const e4 = p3[0], t5 = p3[1], r3 = n6.calculateLength2D();
      if (a2 && (t5 - e4) * r3 > s3 && (g2 = true, u && c)) return true;
    } else if (i3) {
      const e4 = p3[0], t5 = f3[0];
      if (e4 > 0 && e4 < 1 && t5 > 0 && t5 < 1) return true;
    }
  }
  const y2 = n3.constructEmpty(), P5 = n3.constructEmpty();
  let E2, S3;
  y2.setCoords({ env2D: h2 }), y2.inflateCoords(1e3 * s3, 1e3 * s3), P5.setCoords({ env2D: m3 }), P5.inflateCoords(1e3 * s3, 1e3 * s3), l2.setCoords({ env2D: y2 }), l2.intersect(P5);
  let I4 = "";
  if (I4 += g2 ? "**" : "T*", u) {
    if (t3.getPointCount() > 10) {
      if (S3 = f2(t3, l2, s3, 0, n5), S3.isEmpty()) return false;
    } else S3 = t3;
    I4 += "****";
  } else S3 = t3, I4 += "T***";
  if (c) {
    if (e2.getPointCount() > 10) {
      if (E2 = f2(e2, l2, s3, 0, n5), E2.isEmpty()) return false;
    } else E2 = e2;
    I4 += "***";
  } else E2 = e2, I4 += "T**";
  return sr2(E2, S3, s3, I4, n5, false);
}
function Vo2(e2, t3, s3, n5) {
  const r = [false], i2 = _o2(e2, t3, s3, r);
  if (r[0]) return i2;
  const o = n3.constructEmpty();
  let a2;
  if (t3.queryEnvelope(o), o.inflateCoords(1e3 * s3, 1e3 * s3), e2.getPointCount() > 10) {
    if (a2 = f2(e2, o, s3, 0, n5), a2.isEmpty()) return false;
  } else a2 = e2;
  return nr2(a2, t3, s3, n5);
}
function Fo2(e2, t3, s3, n5) {
  const r = e2.getImpl(), i2 = t3.getImpl(), o = r.querySegmentIterator(), a2 = i2.querySegmentIterator(), h2 = Yt(2, Number.NaN), m3 = Yt(2, Number.NaN), l2 = new Dr2(r, i2, s3);
  let g2 = false;
  for (; l2.next(); ) {
    const e3 = l2.getRedElement(), t4 = l2.getBlueElement();
    o.resetToVertex(e3, -1), a2.resetToVertex(t4, -1);
    const n6 = o.nextSegment(), r2 = a2.nextSegment();
    let i3 = 0;
    if (Oo2(n6, r2) ? !g2 && r2.isIntersecting(n6, s3) && (g2 = true) : i3 = r2.intersect(n6, null, m3, h2, s3), 2 === i3) g2 = true;
    else if (i3) {
      const e4 = h2[0], t5 = m3[0];
      if (e4 > 0 && e4 < 1 && t5 > 0 && t5 < 1) return false;
      g2 = true;
    }
  }
  if (!g2) return false;
  const u = n3.constructEmpty(), c = n3.constructEmpty(), _ = n3.constructEmpty();
  let d2, p3;
  if (e2.queryEnvelope(u), t3.queryEnvelope(c), u.inflateCoords(1e3 * s3, 1e3 * s3), c.inflateCoords(1e3 * s3, 1e3 * s3), _.setCoords({ env2D: u }), _.intersect(c), e2.getPointCount() > 10) {
    if (d2 = f2(e2, _, s3, 0, n5), d2.isEmpty()) return false;
  } else d2 = e2;
  if (t3.getPointCount() > 10) {
    if (p3 = f2(t3, _, s3, 0, n5), p3.isEmpty()) return false;
  } else p3 = t3;
  return sr2(d2, p3, s3, "F********", n5, false);
}
function Ho2(e2, t3, s3, n5) {
  const r = e2.getImpl(), i2 = t3.getImpl(), o = r.querySegmentIterator(), a2 = i2.querySegmentIterator(), h2 = Yt(2, Number.NaN), m3 = Yt(2, Number.NaN), l2 = new Dr2(r, i2, s3);
  let g2 = false;
  for (; l2.next(); ) {
    const e3 = l2.getRedElement(), t4 = l2.getBlueElement();
    o.resetToVertex(e3, -1), a2.resetToVertex(t4, -1);
    const n6 = o.nextSegment(), r2 = a2.nextSegment();
    let i3 = 0;
    if (Oo2(n6, r2) ? !g2 && r2.isIntersecting(n6, s3) && (g2 = true) : i3 = r2.intersect(n6, null, m3, h2, s3), 2 === i3) g2 = true;
    else if (i3) {
      const e4 = h2[0], t5 = m3[0];
      if (e4 > 0 && e4 < 1 && t5 > 0 && t5 < 1) return true;
      g2 = true;
    }
  }
  if (!g2) return false;
  const u = n3.constructEmpty(), c = n3.constructEmpty(), _ = n3.constructEmpty(), d2 = n3.constructEmpty(), p3 = n3.constructEmpty();
  if (e2.queryEnvelope(u), t3.queryEnvelope(c), xo2(c, u, s3)) {
    let r2, i3;
    if (_.setCoords({ env2D: u }), _.inflateCoords(1e3 * s3, 1e3 * s3), d2.setCoords({ env2D: c }), d2.inflateCoords(1e3 * s3, 1e3 * s3), p3.setCoords({ env2D: _ }), p3.intersect(d2), e2.getPointCount() > 10) {
      if (r2 = f2(e2, p3, s3, 0, n5), r2.isEmpty()) return false;
    } else r2 = e2;
    if (t3.getPointCount() > 10) {
      if (i3 = f2(t3, p3, s3, 0, n5), i3.isEmpty()) return false;
    } else i3 = t3;
    return sr2(r2, i3, s3, "T********", n5, false);
  }
  return sr2(e2, t3, s3, "T*****T**", n5, false);
}
function ko2(e2, t3, s3, n5) {
  const r = [false], i2 = _o2(e2, t3, s3, r);
  if (r[0]) return i2;
  const o = n3.constructEmpty();
  let a2;
  if (t3.queryEnvelope(o), o.inflateCoords(1e3 * s3, 1e3 * s3), e2.getPointCount() > 10) {
    if (a2 = f2(e2, o, s3, 0, n5), a2.isEmpty()) return false;
  } else a2 = e2;
  return rr2(a2, t3, s3, n5);
}
function Ao2(e2, t3, s3, n5) {
  return 1 === Lo2(e2, t3, s3);
}
function Mo2(e2, t3, s3, n5) {
  return 2 === Lo2(e2, t3, s3);
}
function Uo2(e2, t3, s3, n5) {
  const r = new mi(), i2 = s3 * s3;
  for (let o = 0; o < e2.getPointCount(); o++) if (e2.queryXY(o, r), mi.sqrDistance(r, t3) <= i2) return false;
  return true;
}
function qo2(e2, t3, s3) {
  const n5 = e2.getBoundary();
  return !n5.isEmpty() && !Uo2(n5, t3, s3);
}
function Bo2(e2, t3, s3) {
  const n5 = n3.constructEmpty();
  return n5.setCoords({ env2D: e2 }), n5.inflateCoords(s3, s3), n5.containsEnvelope(t3) ? 1073741824 : n5.isIntersecting(t3) ? e2.isIntersecting(t3) ? e2.xmin < t3.xmin && t3.xmax < e2.xmax ? t3.ymin < e2.ymin && t3.ymax > e2.ymax ? 0 : 1073741824 : e2.ymin < t3.ymin && t3.ymax < e2.ymax ? t3.xmin < e2.xmin && t3.xmax > e2.xmax ? 0 : 1073741824 : 0 : 0 : 4;
}
function Oo2(e2, t3) {
  return e2.getGeometryType() !== a.enumLine || t3.getGeometryType() !== a.enumLine;
}
function Yo2(e2, t3, s3, n5, r, i2, o, a2) {
  return { m_ivertexA: e2, m_ipathA: t3, m_scalarA0: s3, m_scalarA1: n5, m_ivertexB: r, m_ipathB: i2, m_scalarB0: o, m_scalarB1: a2 };
}
var Ro2 = class {
  constructor() {
    this.m_overlapEvents = [];
  }
  compareOverlapEvents(e2, t3) {
    const s3 = this.m_overlapEvents[e2], n5 = this.m_overlapEvents[t3];
    if (s3.m_ipathA < n5.m_ipathA) return -1;
    if (s3.m_ipathA === n5.m_ipathA) {
      if (s3.m_ivertexA < n5.m_ivertexA) return -1;
      if (s3.m_ivertexA === n5.m_ivertexA) {
        if (s3.m_scalarA0 < n5.m_scalarA0) return -1;
        if (s3.m_scalarA0 === n5.m_scalarA0) {
          if (s3.m_scalarA1 < n5.m_scalarA1) return -1;
          if (s3.m_scalarA1 === n5.m_scalarA1 && s3.m_ivertexB < n5.m_ivertexB) return -1;
        }
      }
    }
    return 1;
  }
};
function Xo2(e2, t3, s3) {
  const n5 = Ln2(e2, t3, s3);
  return n5 ? 1 === n5 ? 1 : 2 : 0;
}
function Lo2(e2, t3, s3) {
  const n5 = zn2(e2, t3, s3);
  return n5 ? 1 === n5 ? 1 : 2 : 0;
}
function zo2(e2, t3, s3, n5, r) {
  for (let i2 = 0; i2 < s3; i2++) r[i2] = Lo2(e2, t3[i2], n5);
}
function Wo2(e2, t3, n5, r, i2) {
  if (e2.getGeometryType() === a.enumPolygon) zo2(e2, t3, n5, r, i2);
  else if (e2.getGeometryType() === a.enumEnvelope) {
    const s3 = n3.constructEmpty();
    e2.queryEnvelope(s3), Zo2(s3, t3, n5, r, i2);
  } else C("");
}
function jo2(e2, t3, r, i2, o) {
  const a2 = e2.getGeometryType();
  a2 === a.enumPolyline ? $o2(e2, t3, r, i2, o) : f(a2) ? Jo2() : C("");
}
function Zo2(e2, t3, s3, n5, r) {
  if (e2.isEmpty()) {
    for (let e3 = 0; e3 < s3; e3++) r[e3] = 0;
    return;
  }
  const i2 = e2.clone();
  i2.inflateCoords(0.5 * -n5, 0.5 * -n5);
  const o = e2.clone();
  o.inflateCoords(0.5 * n5, 0.5 * n5);
  for (let a2 = 0; a2 < s3; a2++) i2.contains(t3[a2]) ? r[a2] = 1 : o.contains(t3[a2]) ? r[a2] = 2 : r[a2] = 0;
}
function Qo2(e2, t3, s3) {
  if (s3.reset(), t3 < 3) return;
  const n5 = e2[0].clone(), r = n5.x, i2 = n5.y, o = e2[1].clone(), a2 = new mi();
  for (let h2 = 2; h2 < t3; h2++) a2.assign(e2[h2]), s3.pe((a2.x - n5.x) * (o.y - i2)), n5.assign(o), o.assign(a2);
  s3.pe((r - n5.x) * (o.y - i2));
}
function Jo2(e2, t3, s3, n5, r) {
  n(0);
}
function $o2(e2, t3, s3, n5, r) {
  const i2 = e2.getImpl(), a2 = i2.getAccelerators();
  let h2 = null;
  a2 && (h2 = a2.getRasterizedGeometry());
  let m3 = s3;
  for (let l2 = 0; l2 < s3; l2++) r[l2] = 1, h2 && n(0);
  if (m3) {
    if (a2) {
      let e4 = null;
      null !== a2 && null !== a2.getQuadTree() && (e4 = a2.getQuadTree());
      const o = i2.getPointCount();
      if (null === e4 && o > 20 && o * s3 > 4 * o + Math.log(o) * s3 && (e4 = Wt2(i2)), e4) {
        let o2 = null;
        const a3 = i2.querySegmentIterator(), h3 = new n3();
        for (let i3 = 0; i3 < s3 && m3; i3++) if (1 === r[i3]) {
          h3.setCoords(t3[i3]), null === o2 ? o2 = e4.getIterator(h3, n5) : o2.resetIterator(h3, n5);
          let s4 = -1;
          for (let h4 = o2.next(); -1 !== h4; h4 = o2.next()) {
            a3.resetToVertex(e4.getElement(h4), s4), s4 = a3.getPathIndex();
            if (a3.nextSegment().isIntersectingPoint(t3[i3], n5)) {
              r[i3] = 2, m3--;
              break;
            }
            r[i3] = 0;
          }
        }
        return;
      }
    }
    const e3 = i2.querySegmentIterator();
    for (; e3.nextPath() && m3; ) for (; e3.hasNextSegment() && m3; ) {
      const i3 = e3.nextSegment();
      for (let e4 = 0; e4 < s3 && m3; e4++) 1 === r[e4] && i3.isIntersectingPoint(t3[e4], n5) && (r[e4] = 2, m3--);
    }
  }
  for (let o = 0; o < s3; o++) 1 === r[o] && (r[o] = 0);
}
function ea2(e2, t3, s3, n5, r) {
  const i2 = Ue(t3), o = Math.max(4 * i2, s3);
  return new oa2(t3, null, o, Number.NaN, r).approximateWithCirclesImpl(e2, n5);
}
function ta2() {
  return Number.isNaN(this.radius.value());
}
function sa2() {
  return { ptStart: new mi(), ptEnd: new mi(), center: new ve(), radius: new p2(), fcenter: new Ee(), fradius2: new si(), maxError: Number.NaN, isLine: ta2 };
}
var na2 = 5;
var ra2 = 1 / 8;
function ia2(e2, t3, s3, n5) {
  return { pt: e2.clone(), t: t3, err: s3, checkCount: n5 };
}
var oa2 = class _oa {
  constructor(e2, t3, s3, n5, r) {
    this.m_left = e2, this.m_tracker = r, this.m_eps = s3, this.m_trackerCounter = 0, this.m_tolerance = n5, this.m_circleCheckCounter = 0, this.m_bReversedLeft = false, this.m_leftArc = sa2();
  }
  closeToCircularArc(e2, t3, s3, n5, r, i2) {
    if (this.m_circleCheckCounter++, i2.maxError = 0, !_oa.checkSweepAngle(e2, t3)) return false;
    if (i2.ptStart.setCoordsPoint2D(s3), i2.ptEnd.setCoordsPoint2D(r), e2.isCircular()) {
      const t4 = e2;
      return i2.fradius2 = si.constructDouble(t4.getSemiMajorAxis()).mulDouble(t4.getSemiMajorAxis()), i2.radius.set(t4.getSemiMajorAxis()), i2.fcenter.assignPoint2D(t4.getCenter()), i2.center.set(t4.getCenter()), true;
    }
    const o = i2.ptEnd.sub(i2.ptStart).clone();
    o.leftPerpendicularThis(), o.normalize();
    if (Math.abs(o.dotProduct(n5.sub(i2.ptStart))) <= this.m_eps) return !!this.confirmIsLine(i2, o) && (i2.radius.set(Number.NaN), i2.center.setCoords(0, 0), true);
    {
      const s4 = i2.ptEnd.sub(i2.ptStart), r2 = n5.sub(i2.ptStart), o2 = s4.crossProduct(r2);
      if (0 === o2) return false;
      const a3 = 0.5 * s4.sqrLength(), h3 = 0.5 * r2.sqrLength();
      let m4 = a3 * r2.y - h3 * s4.y;
      m4 /= o2;
      let l3 = s4.x * h3 - r2.x * a3;
      l3 /= o2;
      const g3 = Math.sqrt(m4 * m4 + l3 * l3);
      if (4 * Number.EPSILON * g3 > this.m_eps) return false;
      const u2 = m4 + i2.ptStart.x, c2 = l3 + i2.ptStart.y;
      i2.radius.set(g3), i2.center.setCoords(u2, c2);
      const _2 = this.maxCircleApproximationError(e2, t3, i2);
      if (_2 > this.m_eps) return i2.maxError = _2, false;
    }
    const a2 = new Ee().assignPoint2D(i2.ptStart), h2 = new Ee().assignPoint2D(i2.ptEnd).sub(a2), m3 = new Ee().assignPoint2D(n5).sub(a2), l2 = h2.crossProduct(m3);
    if (l2.isZero()) return false;
    const g2 = h2.sqrLength().mulDouble(0.5), u = m3.sqrLength().mulDouble(0.5), c = g2.mul(m3.y).sub(u.mul(h2.y)), _ = h2.x.mul(u).sub(m3.x.mul(g2)), d2 = c.mul(c).add(_.mul(_)), p3 = l2.clone();
    p3.invertThis(), i2.fradius2 = d2.mul(p3).mul(p3), i2.fcenter.setCoords(c.mul(p3).add(a2.x), _.mul(p3).add(a2.y)), i2.center.setWithEps(i2.fcenter.asPoint2D()), i2.radius.setWithEps(Math.sqrt(i2.fradius2.toDouble()));
    const f3 = ve.constructPoint2D(i2.ptStart).subE(i2.center), x4 = ve.constructPoint2D(i2.ptEnd).subE(i2.center);
    if (!f3.dotProduct(x4).gt(I2)) return false;
    const y2 = this.maxCircleApproximationError(e2, t3, i2);
    return i2.maxError = y2, y2 <= this.m_eps;
  }
  static checkSweepAngle(e2, t3) {
    if (e2.getGeometryType() === a.enumEllipticArc) {
      const s3 = e2, n5 = cu(s3, t3.vmin), r = cu(s3, t3.vmax);
      return !(Math.abs(r - n5) > 0.5 * Wt);
    }
    return true;
  }
  confirmIsLine(e2, t3) {
    const s3 = e2.ptEnd.sub(e2.ptStart);
    return !(Math.abs(t3.dotProduct(s3.mul(0.25))) > this.m_eps) && !(Math.abs(t3.dotProduct(s3.mul(0.75))) > this.m_eps);
  }
  maxCircleApproximationError(e2, t3, n5) {
    const r = [0.25, 0.75], i2 = [0.1, 0.25, 0.75, 0.9];
    let o, a2;
    e2.getGeometryType() === a.enumEllipticArc ? (o = r, a2 = r.length) : (o = i2, a2 = i2.length);
    let h2 = 0;
    for (let s3 = 0; s3 < a2; ++s3) {
      const r2 = new mi();
      e2.queryCoord2D(Q(t3.vmin, t3.vmax, o[s3]), r2);
      const i3 = r2.sub(n5.center.value()).length(), a3 = Math.abs(i3 - n5.radius.value());
      a3 > h2 && (h2 = a3);
    }
    return h2;
  }
  approximateWithCirclesImpl(e2, t3) {
    let s3 = 1;
    t3 && t3.push(0);
    const n5 = Yt(9, Number.NaN);
    let r;
    e2 ? r = this.m_left.getMonotonicPartParams(n5.length, n5) : (n5[0] = 0, n5[1] = 1, r = 2);
    const i2 = [], o = [], a2 = new mi(0, 0);
    for (let h2 = 1; h2 < r; h2++) {
      const e3 = new x2(n5[h2 - 1], n5[h2]);
      for (this.m_bReversedLeft = !_oa.goodOrientation(this.m_left, e3), this.m_bReversedLeft ? (i2.push(ia2(a2, e3.vmin, 0, 0)), i2.push(ia2(a2, e3.vmax, 0, 0))) : (i2.push(ia2(a2, e3.vmax, 0, 0)), i2.push(ia2(a2, e3.vmin, 0, 0))), i2[0].pt = this.m_left.getCoord2D(i2[0].t), i2[1].pt = this.m_left.getCoord2D(i2[1].t); i2.length > 1; ) {
        this.progress_();
        const e4 = i2.at(-1);
        let n6 = e4.checkCount, r2 = e4.err;
        const a3 = e4.pt.clone(), h3 = e4.t, m3 = i2[i2.length - 2].t, l2 = 0.5 * (h3 + m3), g2 = this.m_left.getCoord2D(l2);
        if (r2 <= this.m_eps || n6 >= na2) {
          const e5 = new x2();
          if (e5.setCoords(h3, m3), this.closeToCircularArc(this.m_left, e5, a3, g2, i2[i2.length - 2].pt, this.m_leftArc)) {
            t3 && (this.m_bReversedLeft ? o.push(h3) : t3.push(m3)), s3++, i2.pop();
            continue;
          }
          n6 = 0, r2 = this.m_leftArc.maxError;
        }
        e4.t = l2, e4.pt.setCoordsPoint2D(g2), r2 *= ra2, n6++, e4.err = r2, e4.checkCount = n6, i2.push(ia2(a3, h3, r2, n6));
      }
      this.m_bReversedLeft && t3 && (t3.length = t3.length + o.length, Dt(t3, o.reverse(), t3.length - o.length, 0, o.length), o.length = 0), i2.length = 0;
    }
    return s3;
  }
  approximateWithCirclesImplPolyline(e2) {
    const t3 = new Os2(), s3 = [];
    if (!this.approximateWithCirclesImpl(true, s3)) return t3;
    let n5 = 0;
    const r = this.m_left.getStartXY();
    t3.startPath(r);
    for (let i2 = 1; i2 < s3.length; ++i2) if (e2) t3.lineTo(this.m_left.getCoord2D(s3[i2]));
    else {
      const e3 = new mi();
      this.m_left.queryCoord2D(s3[i2], e3);
      const o = new mi();
      this.m_left.queryCoord2D(0.5 * (s3[i2] + n5), o);
      const a2 = new Xh();
      a2.constructCircularArcThreePoint(r, e3, o), t3.addSegment(a2, false), r.assign(e3), n5 = s3[i2];
    }
    return t3;
  }
  static goodOrientation(e2, t3) {
    const s3 = e2.getCoord2D(t3.vmin), n5 = e2.getCoord2D(t3.vmax);
    return s3.compare(n5) < 0;
  }
  progress_(e2 = false) {
  }
};
function aa2(e2, t3, s3, n5, r, i2, o) {
  ma2(e2, t3, s3, r, i2, o), Ca2(e2, s3, o);
}
function ha2(e2, t3, n5, r) {
  if (!h(e2.getGeometryType())) return e2;
  const o = e2.getImpl();
  if (!o.hasNonLinearSegments()) return e2;
  const a2 = e2.createInstance();
  if (a2.getGeometryType() === a.enumPolygon) {
    a2.setFillRule(e2.getFillRule());
  }
  new Pr();
  const h2 = new ee(), m3 = new fm(), l2 = [], g2 = [], u = [], c = e2.getDescription().getAttributeCount() > 1, _ = o.querySegmentIterator();
  for (; _.nextPath(); ) {
    let e3 = true;
    for (; _.hasNextSegment(); ) {
      const r2 = _.isClosingSegment(), i2 = _.nextSegment();
      if (!i2.isCurve()) {
        a2.addSegment(i2, e3, r2), e3 = false;
        continue;
      }
      let o2, d2 = false;
      const p3 = true, f3 = true;
      switch (i2.getGeometryType()) {
        case a.enumEllipticArc:
        case a.enumRationalBezier2:
          o2 = Wh(i2, t3, n5, p3, f3, g2, u, l2), d2 = true;
          break;
        default:
          o2 = kh(i2, t3, n5, true, p3, g2, l2);
      }
      const x4 = d2 ? 2 : 3;
      g2[1].isNAN() ? (m3.createLine(), m3.get().construct(g2[0], g2[x4])) : d2 ? (m3.createQuadraticRationalBezier(), m3.get().constructArrayWeights(g2, u)) : (m3.createCubicBezier(), m3.get().constructPoints(g2)), c && e3 && (i2.queryCoord(l2[0], h2), m3.get().setStart(h2)), c && (i2.queryCoord(l2[1], h2), m3.get().setEnd(h2)), a2.addSegment(m3.get(), e3, r2 && 1 === o2), e3 = false;
      for (let e4 = 1, t4 = o2, s3 = x4; e4 < t4; ++e4, s3 += x4) g2[s3 + 1].isNAN() ? (m3.createLine(), m3.get().construct(g2[s3], g2[s3 + x4])) : d2 ? (m3.createQuadraticRationalBezier(), m3.get().constructArrayWeights(g2.slice(s3), u.slice(s3))) : (m3.createCubicBezier(), m3.get().constructPoints(g2.slice(s3))), c && (i2.queryCoord(l2[e4 + 1], h2), m3.get().setEnd(h2)), a2.addSegment(m3.get(), false, r2 && e4 + 1 === t4);
    }
  }
  return a2;
}
function ma2(e2, t3, s3, n5, r, i2) {
  e2.hasCurves() ? (e2.setCurveStitcherPointer(n5), n5.m_impl = new xa2(i2, false, null), n5.m_impl.buildMonotonicCurveParentage(e2, t3, s3, r)) : n5.m_impl = null;
}
function la2(e2, t3, s3, n5, r, i2, o, a2) {
  e2.hasCurves() ? (e2.setCurveStitcherPointer(i2), i2.m_impl = new xa2(a2, true, r), i2.m_impl.buildMonotonicCurveParentage(e2, t3, s3, o), Ca2(e2, s3, a2)) : i2.m_impl = null;
}
function ga2(e2) {
  if (!e2.hasSegmentParentage()) return;
  const t3 = e2.queryVertexIteratorOnSelection();
  for (let s3 = t3.next(); s3 !== cr; s3 = t3.next()) if (!e2.getSegmentParentageBreakVertex(s3)) {
    e2.getPathFromVertex(s3);
    const t4 = e2.getPrevVertex(s3), n5 = t4 !== cr ? e2.getSegmentParentage(t4) : -1, r = e2.getSegmentParentage(s3);
    -1 !== r && -1 !== n5 && r !== n5 && e2.setSegmentParentageBreakVertex(s3, true);
  }
}
function ua2(e2) {
  if (!e2.hasSegmentParentage()) return;
  ga2(e2);
  const t3 = new st2(0), s3 = e2.queryVertexIteratorOnSelection();
  for (let o = s3.next(); o !== cr; o = s3.next()) t3.add(o);
  if (0 === t3.size()) return;
  e2.sortVerticesSimpleByY(t3, 0, t3.size()), t3.add(cr);
  const n5 = mi.getNAN();
  e2.queryXY(t3.read(0), n5);
  let r = 0;
  const i2 = mi.getNAN();
  for (let o = 1, a2 = t3.size(); o < a2; o++) {
    {
      const s4 = t3.read(o);
      s4 !== cr ? e2.queryXY(s4, i2) : i2.setNAN();
    }
    if (!i2.isEqualPoint2D(n5)) {
      if (o - r > 1) {
        let s4 = false;
        for (let n6 = r; n6 < o; ++n6) {
          const r2 = t3.read(n6);
          if (e2.getSegmentParentageBreakVertex(r2)) {
            s4 = true;
            break;
          }
        }
        if (!s4) {
          const n6 = (t4, s5, n7) => {
            const r2 = e2.getPrevVertex(t4), i4 = e2.getNextVertex(t4);
            r2 !== cr ? s5.assign(e2.getXY(r2)) : s5.setNAN(), i4 !== cr ? n7.assign(e2.getXY(i4)) : n7.setNAN();
          }, i3 = new mi(), a3 = new mi();
          n6(t3.read(r), i3, a3);
          for (let e3 = r + 1; e3 < o; ++e3) {
            const r2 = t3.read(e3);
            if (r2 === cr) continue;
            const o2 = new mi(), h2 = new mi();
            n6(r2, o2, h2);
            const m3 = (e4, t4) => !!(e4.equals(t4) || e4.isNAN() && t4.isNAN());
            if (!(m3(o2, i3) && m3(h2, a3) || m3(h2, i3) && m3(o2, a3))) {
              s4 = true;
              break;
            }
          }
        }
        if (s4) for (let n6 = r; n6 < o; ++n6) e2.setSegmentParentageBreakVertex(t3.read(n6), true);
      }
      n5.setCoordsPoint2D(i2), r = o;
    }
  }
}
function ca2(e2, t3) {
  let s3 = t3.isEmpty() ? e2 : At(null, t3, true).total();
  return s3 > e2 && (s3 = e2), 0.125 * s3;
}
function _a2(e2, t3) {
  return t3 || (t3 = n3.constructEmpty()), ca2(e2, t3);
}
function da2(e2, t3) {
  return 0.125 * e2;
}
function pa2(e2, t3) {
  return 3 * e2 + 3 * t3;
}
var fa2 = class {
  constructor() {
    this.m_impl = null;
  }
  stitchCurves(e2, t3, s3, n5) {
    this.m_impl && (this.m_impl.stitchCurves(e2, t3, s3), n5 && this.clearStitcher(e2));
  }
  clearStitcher(e2) {
    this.m_impl && (this.m_impl.clearStitcher(e2), this.m_impl = null);
  }
  getOriginalVertexIndex(e2, t3) {
    return this.m_impl.getOriginalVertexIndex(e2, t3);
  }
  getOriginalSegmentTypeInfo(e2) {
    return this.m_impl.getOriginalSegmentTypeInfo(e2);
  }
};
var xa2 = class _xa {
  constructor(e2, t3, s3) {
    this.m_originalPlanarSegments = [], this.m_progressTracker = null, this.m_nsr = null, this.m_progressTracker = e2, this.m_nsr = s3, this.m_tolerance = 0, this.m_originalVertexIndex = -1, this.m_type = 1, this.m_progressCounter = 0, this.m_bIsSimple = t3, this.m_densificationDeviation = NaN, this.m_maxSegmentsPerCurve = -1;
  }
  buildMonotonicCurveParentage(e2, t3, n5, r) {
    const i2 = false, a2 = true;
    if (!e2.hasCurves()) return;
    n(!e2.hasSegmentParentage()), this.m_originalPlanarSegments.length = 0, this.m_bIsSimple && (this.m_originalVertexIndex = e2.createUserIndex()), this.m_tolerance = n5;
    const h2 = new ee(), m3 = new fm(), l2 = [], g2 = [], u = [];
    for (let c = e2.getFirstGeometry(); c !== cr; c = e2.getNextGeometry(c)) for (let r2 = e2.getFirstPath(c); r2 !== cr; r2 = e2.getNextPath(r2)) {
      let c2 = e2.getPathSize(r2), _ = e2.getFirstVertex(r2), d2 = 0, p3 = -1;
      for (let f3 = 0; f3 < c2; f3++) {
        let x4 = e2.getNextVertex(_);
        if (!e2.querySegment(_, m3, true, false)) {
          _ = x4;
          continue;
        }
        if (0 === d2) {
          p3 = e2.getVertexIndex(_);
          const t4 = _xa.regularizeCurve(e2, m3.get(), _, n5);
          if (t4 >= 0) {
            this.m_nsr && 0 === this.m_nsr.m_reason && this.m_nsr.assign(new e(13, p3, -1)), d2 = t4, c2 = e2.getPathSize(r2), x4 = e2.getNextVertex(_);
            const s3 = e2.querySegment(_, m3, true, false);
            n(s3);
          }
        } else d2--;
        const y2 = e2.getVertexIndex(_);
        let P5;
        -1 !== this.m_originalVertexIndex && e2.setUserIndex(_, this.m_originalVertexIndex, p3), e2.setSegmentToIndex(y2, null);
        let E2 = false;
        switch (m3.get().getGeometryType()) {
          case a.enumEllipticArc:
          case a.enumRationalBezier2:
            P5 = Wh(m3.get(), t3, n5, i2, a2, g2, u, l2), E2 = true;
            break;
          default: {
            const e3 = !this.m_bIsSimple || !m3.get().isMonotoneQuickAndDirty();
            P5 = kh(m3.get(), t3, n5, e3, i2, g2, l2);
          }
        }
        const S3 = this.m_originalPlanarSegments.length;
        if (e2.setSegmentParentageAndBreak(_, S3, true), !g2[1].isNAN()) {
          let t4 = null;
          t4 = E2 ? new Sn({ points: g2, weights: u }) : new ia({ cp: g2 }), t4.snapControlPoints(n5 * n5), e2.setSegmentToIndex(y2, t4);
        }
        const C3 = E2 ? 2 : 3;
        for (let t4 = 1, s3 = P5, i3 = C3; t4 < s3; ++t4, i3 += C3) {
          m3.get().queryCoord(l2[t4], h2);
          const s4 = e2.insertVertex(r2, x4, h2);
          if (-1 !== this.m_originalVertexIndex && e2.setUserIndex(s4, this.m_originalVertexIndex, p3), !g2[i3 + 1].isNAN()) if (E2) {
            const t5 = new Sn({ points: g2.slice(i3), weights: u.slice(i3) });
            t5.snapControlPoints(n5 * n5), e2.setSegmentToIndex(e2.getVertexIndex(s4), t5);
          } else {
            const t5 = new ia({ cp: g2.slice(i3) });
            t5.snapControlPoints(n5 * n5), e2.setSegmentToIndex(e2.getVertexIndex(s4), t5);
          }
          e2.setSegmentParentageAndBreak(s4, S3, false);
        }
        P5 > 1 && (f3 += P5 - 1, c2 = e2.getPathSize(r2)), this.m_originalPlanarSegments.push(m3.releaseSegment()), _ = x4;
      }
    }
  }
  buildLinearSegmentParentage(e2, t3, s3, n5, r) {
    if (this.m_type = 0, this.m_densificationDeviation = t3, this.m_maxSegmentsPerCurve = n5, !e2.hasCurves()) return;
    n(!e2.hasSegmentParentage()), this.m_tolerance = s3, this.m_originalPlanarSegments = [], this.m_bIsSimple && (this.m_originalVertexIndex = e2.createUserIndex());
    const i2 = new ee(), a2 = new fm(), h2 = new jh(0, t3, 0, this.m_progressTracker, false, n5), m3 = [];
    for (let l2 = e2.getFirstGeometry(); l2 !== cr; l2 = e2.getNextGeometry(l2)) for (let t4 = e2.getFirstPath(l2); t4 !== cr; t4 = e2.getNextPath(t4)) {
      let n6 = e2.getPathSize(t4), r2 = e2.getFirstVertex(t4);
      for (let l3 = 0; l3 < n6; l3++) {
        let l4 = e2.getNextVertex(r2);
        if (!e2.querySegment(r2, a2, true, false)) {
          r2 = l4;
          continue;
        }
        if (_xa.regularizeCurve(e2, a2.get(), r2, s3) >= 0) {
          n6 = e2.getPathSize(t4), l4 = e2.getNextVertex(r2);
          const s4 = e2.querySegment(r2, a2, true, false);
          n(s4);
        }
        const g2 = e2.getVertexIndex(r2);
        -1 !== this.m_originalVertexIndex && e2.setUserIndex(r2, this.m_originalVertexIndex, g2), e2.setSegmentToIndex(g2, null), m3.length = 0, h2.densifySegment(a2.get(), m3), this.progress_();
        const u = this.m_originalPlanarSegments.length;
        e2.setSegmentParentageAndBreak(r2, u, true);
        for (let s4 = 1, n7 = m3.length - 1; s4 < n7; ++s4) {
          a2.get().queryCoord(m3[s4], i2);
          const n8 = e2.insertVertex(t4, l4, i2);
          e2.setSegmentParentageAndBreak(n8, u, false), -1 !== this.m_originalVertexIndex && e2.setUserIndex(n8, this.m_originalVertexIndex, g2);
        }
        this.m_originalPlanarSegments.push(a2.releaseSegment()), r2 = l4;
      }
    }
    e2.clearSegments();
  }
  stitchCurves(e2, t3, s3) {
    _xa.st_stitchCurvesImpl(this, e2, t3, s3, false);
  }
  clearStitcher(e2) {
    this.m_originalPlanarSegments.length = 0, -1 !== this.m_originalVertexIndex && (e2.removeUserIndex(this.m_originalVertexIndex), this.m_originalVertexIndex = -1), e2.deleteSegmentParentage();
  }
  static st_verifyParentage(e2) {
    _xa.st_stitchCurvesImpl(null, e2, cr, 0, true);
  }
  getOriginalVertexIndex(e2, t3) {
    return -1 !== this.m_originalVertexIndex && t3 !== cr ? e2.getUserIndex(t3, this.m_originalVertexIndex) : -1;
  }
  getOriginalSegmentTypeInfo(e2) {
    if (-1 !== e2) {
      const t3 = this.m_originalPlanarSegments[e2];
      switch (t3.getGeometryType()) {
        case a.enumEllipticArc:
          return 0 === t3.projectionBehavior() ? 0 : 1;
        case a.enumBezier:
          return 2;
        case a.enumBezier2:
          return 3;
        case a.enumLine:
          return -1;
        case a.enumRationalBezier2:
          return 4;
        default:
          z("");
      }
    }
    return -1;
  }
  progress_(e2 = false) {
    this.m_progressCounter++;
  }
  processSpanSmartTe_(e2, t3, s3, n5, r, i2, a2) {
    if (t3 === s3 && 0 === n5) return n(e2.getNextVertex(t3) === cr), e2.setSegmentToIndex(e2.getVertexIndex(t3), null), void e2.setSegmentParentageAndBreak(t3, -1);
    const h2 = e2.getNextVertex(t3), m3 = e2.getXY(t3), l2 = e2.getXY(s3);
    let g2, u = 0;
    {
      let t4 = 2, r2 = m3;
      for (let n6 = h2; n6 !== s3; n6 = e2.getNextVertex(n6)) {
        const s4 = e2.getXY(n6);
        u += mi.distance(s4, r2), r2 = s4, t4++;
      }
      u += mi.distance(l2, r2), n(t4 === n5);
    }
    if (null === r) return e2.setSegmentToIndex(e2.getVertexIndex(t3), null), void e2.removeVertices(h2, s3);
    const c = a2;
    let _ = r.getClosestCoordinate(m3, false), d2 = r.getClosestCoordinate(l2, false);
    const p3 = r.calculateLength2D();
    let f3 = r.tToLength(_), x4 = r.tToLength(d2);
    const y2 = Math.abs(f3) > 10 * c && Math.abs(f3 - p3) > 10 * c, P5 = Math.abs(x4) > 10 * c && Math.abs(x4 - p3) > 10 * c, E2 = (e3) => {
      const t4 = e3.calculateLength2D();
      return Math.abs(t4 - u) > Math.max(0.2 * u, 4 * c) ? null : e3;
    };
    let S3 = r.isClosed();
    if (!S3) {
      const e3 = mi.distance(r.getStartXY(), r.getEndXY());
      e3 <= c && p3 > 5 * e3 && (S3 = true);
    }
    if (S3) {
      let i3, a3, h3 = new mi();
      if (2 === n5) h3 = mi.lerp(m3, l2, 0.5), i3 = r.getClosestCoordinate(h3, false), a3 = r.tToLength(i3);
      else {
        let s4 = e2.getNextNthVertex(t3, (n5 - 1) / 2);
        h3 = e2.getXY(s4), i3 = r.getClosestCoordinate(h3, false), a3 = r.tToLength(i3);
        let o = Math.abs(a3) > 10 * c && Math.abs(a3 - p3) > 10 * c;
        if (!o && (n5 - 1 >= 4 && (s4 = e2.getNextNthVertex(t3, (n5 - 1) / 4), i3 = r.getClosestCoordinate(h3, false), a3 = r.tToLength(i3), o = Math.abs(a3) > 10 * c && Math.abs(a3 - p3) > 10 * c), !o)) return;
      }
      let u2 = false;
      const S4 = f3 === x4;
      if (S4) {
        const s4 = 0;
        let i4 = 2, o = 4;
        n5 - 1 <= 4 && (i4 = s4 + 1, o = s4 + 2);
        const a4 = m3, h4 = e2.getXY(e2.getNextNthVertex(t3, i4)), l3 = e2.getXY(e2.getNextNthVertex(t3, o));
        u2 = -mi.orientationNonRobust(a4, h4, l3) * K(r.calculateArea2DHelper()) > 0;
      } else P5 ? y2 ? u2 = a3 > f3 : a3 < x4 ? (f3 = 0, _ = 0) : (f3 = p3, _ = 1) : a3 > f3 ? (x4 = p3, d2 = 1) : (x4 = 0, d2 = 0);
      if (S4) g2 = r.clone(), g2.dropAllAttributes(), u2 || g2.reverse(), n(m3.equals(l2));
      else {
        let e3 = false;
        _ > d2 && (e3 = true, [_, d2] = [d2, _]), g2 = r.cut(_, d2, true), g2.getDescription().getAttributeCount(), e3 && g2.reverse();
      }
      g2.setCoordsForIntersector(m3, l2, false), g2 = E2(g2), g2 && (this.removeSpanBetween(e2, t3, s3), e2.setSegmentToIndex(e2.getVertexIndex(t3), g2));
    } else if (y2 || P5) {
      if (!y2 || !P5) {
        if (mi.distance(r.getStartXY(), r.getEndXY()) < 10 * c) {
          const n7 = [$t(_, d2), $t(_, d2), $t(_, d2)];
          y2 ? (n7[1].second = 0, n7[2].second = 1) : (n7[1].first = 1, n7[2].first = 0);
          const i3 = [null, null, null], o = [0, 0, 0];
          let a3 = Number.MAX_VALUE, h3 = 0;
          for (let e3 = 0; e3 < 3; e3++) {
            let t4 = false;
            if (n7[e3].first > n7[e3].second) {
              t4 = true;
              const s5 = n7[e3].first;
              n7[e3].first = n7[e3].second, n7[e3].second = s5;
            }
            i3[e3] = r.cut(n7[e3].first, n7[e3].second, true), i3[e3].dropAllAttributes(), t4 && i3[e3].reverse(), i3[e3].setCoordsForIntersector(m3, l2, false), o[e3] = i3[e3].calculateLength2D();
            const s4 = Math.abs(u - o[e3]);
            s4 < a3 && (a3 = s4, h3 = e3);
          }
          return g2 = i3[h3], g2 = E2(g2), void (g2 && (this.removeSpanBetween(e2, t3, s3), e2.setSegmentToIndex(e2.getVertexIndex(t3), g2)));
        }
      }
      let n6 = false;
      _ > d2 && (n6 = true, [_, d2] = [d2, _]), g2 = r.cut(_, d2, true), g2.dropAllAttributes(), n6 && g2.reverse(), g2.setCoordsForIntersector(m3, l2, false), g2 = E2(g2), g2 && (this.removeSpanBetween(e2, t3, s3), e2.setSegmentToIndex(e2.getVertexIndex(t3), g2));
    } else {
      if (g2 = r.clone(), g2.dropAllAttributes(), f3 > x4 && g2.reverse(), u < Math.max(0.75 * p3, p3 - this.m_densificationDeviation * (n5 - 1))) {
        const e3 = _ > d2 ? d2 : _, t4 = g2.tToLength(e3) + u;
        let s4 = g2.lengthToT(t4);
        s4 = Us(s4, e3, 1), g2 = g2.cut(e3, s4, true);
      }
      g2.setCoordsForIntersector(m3, l2, false), g2 = E2(g2), g2 && (this.removeSpanBetween(e2, t3, s3), e2.setSegmentToIndex(e2.getVertexIndex(t3), g2));
    }
  }
  processSpanCurves_(e2, t3, s3, n5, r, i2, a2) {
    if (t3 === s3 && 0 === n5) return n(e2.getNextVertex(t3) === cr), e2.setSegmentToIndex(e2.getVertexIndex(t3), null), void e2.setSegmentParentageAndBreak(t3, -1);
    const h2 = e2.getNextVertex(t3);
    {
      let t4 = 2;
      for (let n6 = h2; n6 !== s3; n6 = e2.getNextVertex(n6)) t4++;
      n(t4 === n5);
    }
    if (null === r) return e2.setSegmentToIndex(e2.getVertexIndex(t3), null), void e2.removeVertices(h2, s3);
    const m3 = e2.getXY(t3), l2 = e2.getXY(s3);
    if (r.isClosed()) {
      if (m3.isEqualPoint2D(l2) && m3.isEqualPoint2D(r.getStartXY())) {
        let o;
        if (o = this.verifySegmentFitnessCurves(e2, t3, s3, n5, r, i2, a2)) {
          const n6 = r.clone();
          return n6.dropAllAttributes(), o < 0 && n6.reverse(), this.removeSpanBetween(e2, t3, s3), void e2.setSegmentToIndex(e2.getVertexIndex(t3), n6);
        }
      }
    } else if (m3.isEqualPoint2D(r.getStartXY())) {
      if (l2.isEqualPoint2D(r.getEndXY())) {
        const h3 = r.clone();
        h3.dropAllAttributes();
        const m4 = this.verifySegmentFitnessCurves(e2, t3, s3, n5, h3, i2, a2);
        if (m4) return n(m4 > 0), this.removeSpanBetween(e2, t3, s3), void e2.setSegmentToIndex(e2.getVertexIndex(t3), h3);
      }
    } else if (l2.isEqualPoint2D(r.getStartXY()) && m3.isEqualPoint2D(r.getEndXY())) {
      const h3 = r.getReversed();
      h3.dropAllAttributes();
      const m4 = this.verifySegmentFitnessCurves(e2, t3, s3, n5, h3, i2, a2);
      if (m4) return n(m4 > 0), this.removeSpanBetween(e2, t3, s3), void e2.setSegmentToIndex(e2.getVertexIndex(t3), h3);
    }
    this.processSpanSplitSegmentCurves(e2, t3, s3, n5, r, i2, a2);
  }
  processSpan_(e2, t3, s3, n5, r, i2, o) {
    return 0 === this.m_type ? void this.processSpanSmartTe_(e2, t3, s3, n5, r, i2, o) : void this.processSpanCurves_(e2, t3, s3, n5, r, i2, o);
  }
  processSpanSplitSegmentCurves(e2, t3, s3, n5, r, i2, o) {
    if (r.isLine()) return;
    if (this.fitSegmentToSpanCurves(e2, t3, s3, n5, r, i2, o)) return;
    const a2 = o * o;
    let h2 = n5, m3 = t3;
    const l2 = e2.getXY(t3);
    let g2 = r.getClosestCoordinate(l2, false);
    const u = r.getCoord2D(g2);
    let c = false;
    const _ = mi.sqrDistance(l2, u);
    if (_ > a2) {
      const n6 = e2.getNextVertex(t3);
      if (this.approximateSpanSectionCurves(e2, t3, r, i2, o), n6 === s3) return;
      m3 = n6, c = true, h2 -= 1;
    }
    let d2 = s3;
    const p3 = e2.getXY(s3);
    g2 = r.getClosestCoordinate(p3, false);
    const f3 = r.getCoord2D(g2);
    let x4 = false;
    const y2 = mi.sqrDistance(p3, f3);
    if (y2 > a2) {
      const t4 = e2.getPrevVertex(s3);
      if (this.approximateSpanSectionCurves(e2, t4, r, i2, o), t4 === m3) return;
      d2 = t4, x4 = true, h2 -= 1;
    }
    if ((c || x4) && this.fitSegmentToSpanCurves(e2, m3, d2, h2, r, i2, o)) return;
    let P5 = false;
    if (!c && _ > 0) {
      const s4 = e2.getNextVertex(t3);
      if (this.approximateSpanSectionCurves(e2, t3, r, i2, o), s4 === d2) return;
      m3 = s4, c = true, P5 = true, h2 -= 1;
    }
    if (!x4 && y2 > 0) {
      const t4 = e2.getPrevVertex(s3);
      if (this.approximateSpanSectionCurves(e2, t4, r, i2, o), t4 === m3) return;
      d2 = t4, x4 = true, P5 = true, h2 -= 1;
    }
    if (P5 && this.fitSegmentToSpanCurves(e2, m3, d2, h2, r, i2, o)) return;
    let E2 = m3;
    for (; ; ) {
      const t4 = e2.getNextVertex(E2);
      if (this.approximateSpanSectionCurves(e2, E2, r, i2, o), E2 = t4, E2 === d2) return;
    }
  }
  fitSegmentToSpanCurves(e2, t3, s3, n5, r, i2, o) {
    const a2 = [];
    a2.push(e2.getXY(t3));
    let h2 = t3;
    const m3 = new fm();
    for (; ; ) {
      e2.querySegment(h2, m3, false, true);
      const t4 = [0.1, 0.25, 0.4, 0.5, 0.6, 0.75, 0.9, 1];
      let r2 = 0;
      for (const e3 of t4) {
        (2 === n5 || 1 & r2) && a2.push(m3.get().getCoord2D(e3)), r2++;
      }
      if (h2 = e2.getNextVertex(h2), h2 === s3) break;
    }
    const l2 = (() => {
      let e3 = a2[0].compare(a2.at(-1));
      if (0 === e3) {
        const t4 = new n2(0);
        Qo2(a2, a2.length, t4), e3 = t4.getResult() >= 0 ? -1 : 1;
      }
      return e3 > 0;
    })();
    l2 && a2.reverse();
    const g2 = r.clone();
    if (g2.dropAllAttributes(), l2 && g2.reverse(), g2.setSegmentFromCoordsForStitcher(a2, a2.length), l2 && g2.reverse(), g2.snapControlPoints(this.m_tolerance * this.m_tolerance), this.verifySegmentFitnessCurves(e2, t3, s3, n5, g2, i2, o)) {
      this.removeSpanBetween(e2, t3, s3);
      const n6 = e2.getVertexIndex(t3);
      return e2.setSegmentToIndex(n6, g2), true;
    }
    return false;
  }
  approximateSpanSectionCurves(e2, t3, n5, i2, o) {
    const a2 = new fm();
    if (!e2.querySegment(t3, a2, true, false)) return;
    const h2 = n5.getGeometryType();
    if (h2 !== a2.get().getGeometryType()) {
      if (h2 === a.enumEllipticArc) {
        if (a2.get().getGeometryType() !== a.enumRationalBezier2) return;
        if (0 === n5.projectionBehavior()) {
          const s3 = [];
          ea2(false, a2.get(), o, s3, this.m_progressTracker);
          const n6 = e2.getNextVertex(t3), r = e2.getPathFromVertex(t3), i3 = new ee();
          let h3 = t3;
          for (let t4 = 1, o2 = s3.length; t4 < o2; t4++) {
            const o3 = s3[t4], m3 = a2.get().getCoord2D(s3[t4 - 1]), l2 = a2.get().getCoord2D(Q(s3[t4 - 1], o3, 0.5));
            a2.get().queryCoord(o3, i3);
            const g2 = i3.getXY(), u = new Xh();
            u.constructCircularArcThreePoint(m3, g2, l2);
            let c = cr;
            o3 < 1 && (c = e2.insertVertex(r, n6, i3)), e2.setSegmentToIndex(e2.getVertexIndex(h3), u), h3 = c;
          }
          return;
        }
        {
          const s3 = Ot(mi, 3);
          a2.get().queryControlPoints(s3);
          const n6 = [0, 0, 0];
          a2.get().queryWeights(n6);
          const r = fh(n6), i3 = new Xh();
          return Gu(s3, r * r, null, false, i3), void e2.setSegmentToIndex(e2.getVertexIndex(t3), i3);
        }
      }
      b("approximate_span_section_");
    }
  }
  verifySegmentFitnessCurves(e2, t3, s3, n5, r, i2, o) {
    const a2 = e2.getXY(t3), h2 = e2.getXY(s3);
    if (!a2.isEqualPoint2D(r.getStartXY()) || !h2.isEqualPoint2D(r.getEndXY())) return 0;
    let m3 = 0;
    if (r.isClosed()) {
      const e3 = r.getCoord2D(0.1).sub(a2);
      m3 = r.getCoord2D(0.7).sub(a2).crossProduct(e3) >= 0 ? 1 : -1;
    }
    const l2 = Yt($e.s_maxMonotonicPartParams, Number.NaN);
    let g2 = r.getMonotonicPartParams(l2.length, l2);
    g2--;
    const u = new pm(), c = [1, 0.5, 0.75, 0.25];
    let _ = 0, d2 = t3;
    const p3 = a2.clone();
    for (; ; ) {
      const t4 = e2.getNextVertex(d2);
      let n6 = e2.getSegment(d2);
      null === n6 && (e2.queryLineConnector(d2, u, true), n6 = u);
      for (let e3 = t4 === s3 ? 1 : 0; e3 < c.length; e3++) {
        const t5 = n6.getCoord2D(c[e3]);
        if (!r.isCloserThanDistance(t5, x2.unit(), o)) return 0;
      }
      if (g2 > 1) for (let e3 = 1; e3 < g2; ) {
        const t5 = r.getCoord2D(l2[e3]);
        n6.isCloserThanDistance(t5, x2.unit(), o) ? (l2[g2 - 1] = Pt(l2[e3], l2[e3] = l2[g2 - 1]), g2--) : e3++;
      }
      if (m3) {
        const e3 = n6.getCoord2D(0.25);
        _ += e3.sub(a2).crossProduct(p3.sub(a2)), p3.assign(e3), e3.assign(n6.getCoord2D(0.75)), _ += e3.sub(a2).crossProduct(p3.sub(a2)), p3.assign(e3);
      }
      if (d2 = t4, d2 === s3) return g2 > 1 ? 0 : m3 ? _ < 0 ? -m3 : m3 : 1;
    }
  }
  removeSpanBetween(e2, t3, s3) {
    e2.setSegmentToIndex(e2.getVertexIndex(t3), null);
    const n5 = e2.getNextVertex(t3);
    n5 !== s3 && e2.removeVertices(n5, s3);
  }
  static st_stitchCurvesImpl(e2, t3, s3, n5, r) {
    if (!t3.hasSegmentParentage()) return;
    ga2(t3);
    let i2 = s3 === cr ? t3.getFirstGeometry() : s3;
    for (; i2 !== cr; ) if (p(t3.getGeometryType(i2))) {
      for (let s4 = t3.getFirstPath(i2); s4 !== cr; s4 = t3.getNextPath(s4)) {
        let i3 = t3.getPathSize(s4);
        const a2 = t3.isClosedPath(s4);
        a2 && (i3 += 1);
        let h2 = t3.getFirstVertex(s4);
        const m3 = t3.getSegmentParentage(h2);
        if (a2) {
          if (-1 !== m3 && !t3.getSegmentParentageBreakVertex(h2)) {
            let e3 = t3.getPrevVertex(h2);
            const s5 = h2;
            for (let n6 = 0; ; n6++) {
              const r2 = t3.getSegmentParentage(e3);
              if (m3 !== r2) {
                n(-1 === r2);
                break;
              }
              if (h2 = e3, t3.getSegmentParentageBreakVertex(e3)) break;
              if (e3 === s5) {
                h2 = s5, t3.setSegmentParentageBreakVertex(h2, true);
                break;
              }
              e3 = t3.getPrevVertex(e3), n(n6 < i3);
            }
          }
        } else n(-1 === m3 || t3.getSegmentParentageBreakVertex(h2));
        let l2 = h2;
        for (let s5 = 0; s5 < i3 && l2 !== cr; ) {
          const a3 = t3.getSegmentParentage(l2);
          if (-1 === a3) {
            if (s5++, l2 = t3.getNextVertex(l2), l2 === h2) break;
            continue;
          }
          let m4 = 0, g2 = cr;
          const u = l2;
          m4 = 1;
          let c = t3.getNextVertex(u);
          for (; s5 < i3 && c !== cr; ) {
            s5++, g2 = c, m4++;
            const e3 = t3.getSegmentParentage(c);
            if (-1 === e3 || t3.getSegmentParentageBreakVertex(c)) break;
            n(e3 === a3), c = t3.getNextVertex(c);
          }
          if (g2 === cr) {
            n(0);
            break;
          }
          if (!r) {
            const s6 = e2.m_originalPlanarSegments[a3];
            e2.processSpan_(t3, u, g2, m4, s6, a3, n5);
          }
          if (l2 = g2, l2 === h2) break;
        }
      }
      if (s3 !== cr) break;
      i2 = t3.getNextGeometry(i2);
    } else i2 = s3 === cr ? t3.getNextGeometry(i2) : cr;
  }
  static st_stitchCurvesFromLinesImpl(e2, t3, s3, n5, r) {
    let i2 = s3 === cr ? t3.getFirstGeometry() : s3;
    for (; i2 !== cr; ) {
      for (let s4 = t3.getFirstPath(i2); s4 !== cr; s4 = t3.getNextPath(s4)) {
        let i3 = t3.getPathSize(s4);
        t3.isClosedPath(s4) && (i3 += 1);
        let a2 = true, h2 = false;
        const m3 = t3.getFirstVertex(s4);
        let l2 = m3;
        for (let s5 = 0; s5 < i3 && l2 !== cr; ) {
          let g2 = t3.getSegmentParentage(l2);
          if (-1 === g2 || a2) {
            a2 = false, s5++, l2 = t3.getNextVertex(l2), h2 = true;
            continue;
          }
          let u, c, _ = 0;
          if (h2 ? (u = t3.getPrevVertex(l2), c = l2, n(u !== cr), n(c !== u), n(-1 === t3.getSegmentParentage(u) || m3 === u)) : (u = l2, c = t3.getNextVertex(u), s5++, n(c !== cr), n(c !== u), g2 = t3.getSegmentParentage(c)), _ = 2, h2 = false, -1 === g2 || t3.getSegmentParentageBreakVertex(c)) {
            l2 = c;
            continue;
          }
          let d2 = t3.getNextVertex(c);
          for (s5++; s5 < i3 && d2 !== cr; ) {
            c = d2, _++;
            const e3 = t3.getSegmentParentage(d2);
            if (-1 === e3 || t3.getSegmentParentageBreakVertex(d2)) break;
            n(e3 === g2), s5++, d2 = t3.getNextVertex(d2);
          }
          if (!r) {
            const s6 = e2.m_originalPlanarSegments[g2];
            e2.processSpan_(t3, u, c, _, s6, g2, n5);
          }
          l2 = c;
        }
      }
      if (s3 !== cr) break;
      i2 = t3.getNextGeometry(i2);
    }
  }
  static st_stitchCurvesFromCurvesImpl(e2, t3, s3, n5, r) {
    let i2 = s3 === cr ? t3.getFirstGeometry() : s3;
    for (; i2 !== cr; ) if (p(t3.getGeometryType(i2))) {
      for (let s4 = t3.getFirstPath(i2); s4 !== cr; s4 = t3.getNextPath(s4)) {
        let i3 = t3.getPathSize(s4);
        const a2 = t3.isClosedPath(s4);
        a2 && (i3 += 1);
        let h2 = t3.getFirstVertex(s4);
        if (a2) {
          if (-1 !== t3.getSegmentParentage(h2)) {
            let e3 = h2;
            for (let n6 = 0; !t3.getSegmentParentageBreakVertex(e3); n6++) {
              if (n6 === i3) {
                h2 = t3.getFirstVertex(s4), t3.setSegmentParentageBreakVertex(e3, true);
                break;
              }
              e3 = t3.getPrevVertex(e3);
            }
          }
        } else n(-1 === t3.getSegmentParentage(h2) || t3.getSegmentParentageBreakVertex(h2));
        let m3 = h2;
        for (let s5 = 0; s5 < i3 && m3 !== cr; ) {
          const a3 = t3.getSegmentParentage(m3);
          if (-1 === a3) {
            s5++, m3 = t3.getNextVertex(m3);
            continue;
          }
          let h3 = 0, l2 = cr;
          const g2 = m3;
          h3 = 1;
          let u = t3.getNextVertex(g2);
          for (; s5 < i3 && u !== cr; ) {
            s5++, l2 = u, h3++;
            const e3 = t3.getSegmentParentage(u);
            if (-1 === e3 || t3.getSegmentParentageBreakVertex(u)) break;
            n(e3 === a3), u = t3.getNextVertex(u);
          }
          if (l2 === cr) break;
          if (!r) {
            const s6 = e2.m_originalPlanarSegments[a3];
            e2.processSpan_(t3, g2, l2, h3, s6, a3, n5);
          }
          m3 = l2;
        }
      }
      if (s3 !== cr) break;
      i2 = t3.getNextGeometry(i2);
    } else i2 = s3 === cr ? t3.getNextGeometry(i2) : cr;
  }
  static regularizeCurve(e2, t3, s3, n5) {
    let r = t3.snapControlPoints(n5 * n5);
    if (r) {
      const n6 = e2.getVertexIndex(s3), r2 = t3.clone();
      e2.setSegmentToIndex(n6, r2);
    }
    if (t3.getGeometryType() === ia.type) {
      const i2 = [], o = t3.calculateSpecialPointsForCracking(n5, i2);
      if (o > 0) {
        const a2 = [];
        if (o > 1) {
          for (let e3 = 0; e3 < o; e3++) if (a2.push(t3.getCoord2D(i2[e3])), e3 > 0) {
            const t4 = (Math.abs(a2[e3].x) + Math.abs(a2[e3].y)) * Ls(), s4 = mi.distance(a2[e3 - 1], a2[e3]);
            if (s4 < t4 && s4 > 0) {
              const t5 = new mi();
              Y(a2[e3 - 1], a2[e3], 0.5, t5), a2[e3 - 1] = t5, a2[e3] = t5;
            }
          }
        }
        e2.splitSegment(s3, i2, o), r = e2.snapControlPoints(s3, o + 1, n5 * n5) || r;
        for (let t4 = 0; t4 < o; t4++) s3 = e2.getNextVertex(s3), e2.setSegmentParentageBreakVertex(s3, true);
        return o;
      }
    }
    return r ? 0 : -1;
  }
};
function ya2(e2, t3, s3, n5, r) {
  return new ba2(e2, s3, t3, n5, r).do_();
}
function Pa2(e2, t3, s3) {
  const n5 = Ft2(e2);
  return ln2(t3.getX(), t3.getY(), s3.getX(), s3.getY(), H(n5));
}
function Ea2(e2, t3, s3 = 1, n5 = 1, r = 1, i2 = 1) {
  if (n5 > i2) return e2;
  if (i2 > n5) return t3;
  const o = [0], a2 = [0], h2 = new ee();
  return cn2(e2, t3, s3, n5, r, i2, h2, a2, o), h2;
}
function Ca2(e2, t3, s3) {
  return ba2.fixCurveTwoPointLoops(e2, t3, s3);
}
function Ia2(e2) {
  return Ft2(e2);
}
var ba2 = class _ba {
  constructor(e2, t3, s3, n5, r) {
    this.m_shape = e2, this.m_progressTracker = t3, this.m_tolerance = s3, this.m_bFilterDegenerateSegments = n5, this.m_bTrackChanges = r, this.m_progressCounter = 0;
  }
  do_() {
    const e2 = new Et2(this.m_tolerance.tolerance, this.m_tolerance.resolution), t3 = 1e-5, s3 = 1e-6, n5 = Ia2(e2);
    let i2 = Pt2(e2);
    const o = i2 * (1 + t3);
    i2 *= 1 + s3;
    let a2 = false;
    const h2 = this.m_shape.getTotalPointCount() + 10 > 30 ? 1e3 : (this.m_shape.getTotalPointCount() + 10) * (this.m_shape.getTotalPointCount() + 10), m3 = this.m_shape.hasPointFeatures();
    for (let l2 = 0; ; l2++) {
      this.m_shape.dbgCheckSelection(), l2 > h2 && b("crack_and_cluster_iteration_exceeded"), this.m_shape.dbgVerifyMonotone();
      let e3 = -1;
      0 === l2 && (e3 = this.firstCrack_(), a2 ||= e3 > 0);
      const t4 = this.cluster_(n5);
      if (this.m_shape.dbgVerifyMonotone(), a2 ||= t4, this.m_bFilterDegenerateSegments) {
        const e4 = 0 !== this.m_shape.filterClosePoints(n5, true, false, this.m_bTrackChanges, cr);
        a2 ||= e4, this.m_shape.dbgVerifyMonotone();
      }
      const s4 = this.m_shape.snapControlPointsOnSelection(o * o);
      a2 ||= s4, this.m_shape.dbgCheckSelection();
      let g2 = false;
      if ((0 === l2 && -1 === e3 || m3 || Mn2(true, this.m_shape, i2, null, this.m_progressTracker)) && (g2 = this.crack_(o), a2 ||= g2, this.m_shape.dbgVerifyMonotone()), !g2 && !_ba.fixCurveTwoPointLoops(this.m_shape, n5, this.m_progressTracker)) {
        this.m_shape.dbgVerifyMonotone();
        break;
      }
    }
    return a2 && ua2(this.m_shape), a2;
  }
  cluster_(e2) {
    return mn2(this.m_shape, e2, cr, this.m_bTrackChanges, this.m_progressTracker);
  }
  crack_(e2) {
    return An2(this.m_shape, e2, this.m_bTrackChanges, this.m_progressTracker);
  }
  static fixCurveTwoPointLoops(e2, t3, s3) {
    if (!e2.hasCurves()) return false;
    e2.dbgVerifyCurves();
    const n5 = e2.createUserIndexUninitialized(), r = new st2(0), i2 = e2.queryVertexIteratorOnSelection();
    for (let o = i2.next(); o !== cr; o = i2.next()) r.add(o), e2.setUserIndex(o, n5, -1);
    if (0 === r.size()) return false;
    r.add(cr), e2.sortVerticesSimpleByY(r, 0, r.size() - 1);
    let a2 = 0;
    const h2 = e2.getXY(r.read(a2)), m3 = new mi(Number.NaN, Number.NaN), l2 = [];
    for (let o = 1, g2 = r.size(); o < g2; ++o) {
      const t4 = r.read(o), s4 = t4 !== cr ? e2.getXY(t4) : m3;
      if (s4.equals(h2)) continue;
      const i3 = [];
      for (let m4 = a2; m4 < o; m4++) {
        const t5 = r.read(m4), s5 = e2.getPrevVertex(t5);
        if (s5 !== cr && -1 === e2.getUserIndex(s5, n5)) {
          const t6 = wa2(e2.getXY(s5), e2.getSegment(s5));
          0 !== mi.sqrDistance(h2, t6.otherPt) && (t6.vert = s5, t6.dir = -1, i3.push(t6)), e2.setUserIndex(s5, n5, 1);
        }
        const o2 = e2.getNextVertex(t5);
        if (o2 !== cr && -1 === e2.getUserIndex(t5, n5)) {
          const s6 = wa2(e2.getXY(o2), e2.getSegment(t5));
          0 !== mi.sqrDistance(h2, s6.otherPt) && (s6.vert = t5, s6.dir = 1, i3.push(s6)), e2.setUserIndex(t5, n5, 1);
        }
      }
      if (i3.length > 1) {
        i3.sort((e4, t6) => Ta2(e4, t6));
        const e3 = wa2(m3.clone(), null);
        i3.push(e3);
        let t5 = 0;
        for (let s5 = 1, n6 = i3.length; s5 < n6; s5++) if (!i3[s5].otherPt.equals(i3[s5 - 1].otherPt)) {
          if (s5 - t5 > 1 && null !== i3[t5].seg) {
            let e4 = false;
            const n7 = t5;
            for (let r2 = t5 + 1; r2 < s5; r2++) if (!va2(i3[n7], i3[r2])) {
              e4 = true;
              break;
            }
            if (e4) for (let r2 = t5; r2 < s5 && null !== i3[r2].seg; r2++) l2.push(i3[r2].vert);
          }
          t5 = s5;
        }
      }
      a2 = o, h2.setCoordsPoint2D(s4);
    }
    for (const g2 of l2) {
      const s4 = e2.getSegment(g2);
      n(null !== s4);
      const n6 = e2.getXY(g2), r2 = e2.getXY(e2.getNextVertex(g2));
      if (mi.distance(n6, r2) < 3 * t3) e2.setSegmentToIndex(e2.getVertexIndex(g2), null);
      else {
        const t4 = s4.lengthToT(0.5 * s4.calculateLength2D());
        e2.splitSegment(g2, [t4], 1);
      }
    }
    return e2.removeUserIndex(n5), l2.length > 0;
  }
  firstCrack_() {
    const e2 = this.m_shape.getEnvelope2D(this.m_progressTracker), t3 = At(null, e2, true).total();
    if (4 * t3 < this.m_tolerance.total()) {
      let e3 = false;
      const s3 = 1.1 * t3, n5 = t3, r = this.cluster_(s3);
      e3 ||= r;
      let i2 = 0;
      this.m_bFilterDegenerateSegments && (i2 = this.m_shape.filterClosePoints(0, true, false, this.m_bTrackChanges, cr));
      const o = this.crack_(n5);
      return e3 ||= o, e3 ? 1 : i2 ? 2 : 0;
    }
    return -1;
  }
  progress_(e2 = false) {
    this.m_progressCounter++, !e2 && 4095 & this.m_progressCounter || (this.m_progressCounter = 0);
  }
};
function wa2(e2, t3) {
  return { otherPt: e2, seg: t3, vert: -1, dir: 0 };
}
function va2(e2, t3) {
  if (n(e2.otherPt.equals(t3.otherPt)), null === e2.seg) return null === t3.seg;
  if (null === t3.seg) return false;
  const n5 = e2.seg.getGeometryType();
  if (n5 !== t3.seg.getGeometryType()) return false;
  if (n5 === a.enumBezier) {
    const s3 = e2.seg, n6 = t3.seg;
    let r = s3.getControlPoint1(), i2 = s3.getControlPoint2();
    -1 === e2.dir && (i2 = Pt(r, r = i2));
    let o = n6.getControlPoint1(), a2 = n6.getControlPoint2();
    return -1 === t3.dir && (a2 = Pt(o, o = a2)), r.equals(o) && i2.equals(a2);
  }
  if (n5 === a.enumRationalBezier2) {
    const s3 = e2.seg, n6 = t3.seg, r = s3.getControlPoint1(), i2 = n6.getControlPoint1();
    if (!r.equals(i2)) return false;
    const o = [0, 0, 0];
    s3.queryWeights(o), -1 === e2.dir && (o[2] = Pt(o[0], o[0] = o[2]));
    const a2 = [0, 0, 0];
    return n6.queryWeights(a2), -1 === t3.dir && (a2[2] = Pt(a2[0], a2[0] = a2[2])), o[0] === a2[0] && o[1] === a2[1] && o[2] === a2[2];
  }
  b("");
}
function Na2(e2, t3) {
  if (null === e2.seg || null === t3.seg) return null !== e2.seg ? -1 : null !== t3.seg ? 1 : 0;
  const s3 = e2.seg.getGeometryType(), n5 = t3.seg.getGeometryType();
  return s3 < n5 ? -1 : s3 > n5 ? 1 : 0;
}
function Ta2(e2, t3) {
  const s3 = e2.otherPt.compare(t3.otherPt);
  return 0 !== s3 ? s3 : Na2(e2, t3);
}
var Ga2 = h;
var Da2 = f;
var Va2 = m;
function Fa2(e2) {
  switch (e2) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 3:
      return 3;
    case 4:
      return 4;
    case 0:
      return 0;
    default:
      n(0, "unrecognized cut side");
  }
  return 3;
}
function Ha2() {
  return { unsplitBehavior: 0, allCrossRoadsImpassable: false, ogcRule: false };
}
function Aa2(e2, t3, n5, r, i2, o, a2) {
  const h2 = new Ka2(i2);
  h2.m_bOGCOutput = true;
  const m3 = e2.getGeometryType() === a.enumPolygon && 1 === e2.getFillRule() && !Ht2(r);
  return h2.planarSimplifyImpl_(e2, t3, m3, n5, r, i2, o, a2);
}
function Ma2(e2, t3, s3, n5, r, i2, o, a2) {
  return new Ka2(i2).planarSimplifyImpl_(e2, t3, s3, n5, r, i2, o, a2);
}
function Ua2(e2, t3, s3, n5) {
  const r = new Ka2(n5), i2 = new Pr(), a2 = i2.addGeometry(t3), h2 = r.planarSimplifyNoCrackingAndCluster(e2, i2, a2, s3);
  n(h2, "planar_simplify_no_cracking_and_cluster");
  return i2.getGeometry(a2);
}
function qa2(e2, t3, s3, n5, r, i2, a2) {
  return n(0), {};
}
function Ba2(e2, t3, s3, n5) {
  return n(0), {};
}
function Oa2(e2, t3, s3) {
  return Ja2(e2, t3, s3);
}
function Ya2(e2, t3, n5, r) {
  if (e2.isEmpty() || t3.isEmpty() || e2.getDimension() > t3.getDimension()) return $a2(eh2(e2), e2, t3, "-");
  const i2 = new n3();
  e2.queryEnvelope(i2);
  const o = new n3();
  t3.queryEnvelope(o);
  const a2 = new n3();
  a2.setCoords({ env2D: i2 }), a2.mergeEnvelope2D(o);
  const h2 = At(n5, a2, true), m3 = o.clone(), l2 = Ft2(h2);
  if (m3.inflateCoords(l2, l2), !i2.isIntersecting(m3)) return $a2(eh2(e2), e2, t3, "-");
  const g2 = new Ka2(r), u = new Pr(), c = u.addGeometry(eh2(e2)), _ = u.addGeometry(eh2(t3));
  let d2 = 0, p3 = 0, f3 = null;
  if (u.hasCurves()) {
    f3 = new fa2();
    const e3 = u.getEnvelope2D(r);
    p3 = da2(h2.total());
    const t4 = _a2(h2.total(), e3);
    d2 = pa2(t4, p3), aa2(u, t4, h2.total(), 12e3, f3, null, r);
  }
  g2.setEditShapeCrackAndCluster(u, h2.add(d2));
  const x4 = g2.difference(c, _);
  null !== f3 && f3.stitchCurves(u, x4, p3, true);
  const y2 = $a2(u.getGeometry(x4), e2, t3, "-");
  return Ga2(y2.getGeometryType()) && (y2.getImpl().setIsSimple(4, h2.total()), y2.getGeometryType() === a.enumPolygon && y2.getImpl().updateOGCFlagsProtected()), y2;
}
function Ra2(e2, t3, n5, r) {
  if (e2.getDimension() > t3.getDimension()) return $a2(eh2(e2), e2, t3, "^");
  if (e2.getDimension() < t3.getDimension()) return $a2(eh2(t3), e2, t3, "^");
  if (e2.isEmpty()) return $a2(eh2(t3), e2, t3, "^");
  if (t3.isEmpty()) return $a2(eh2(e2), e2, t3, "^");
  const i2 = new n3();
  e2.queryEnvelope(i2);
  const o = new n3();
  t3.queryEnvelope(o);
  const a2 = new n3();
  a2.setCoords({ env2D: i2 }), a2.mergeEnvelope2D(o);
  const h2 = At(n5, a2, true), m3 = new Ka2(r), l2 = new Pr(), g2 = l2.addGeometry(eh2(e2)), u = l2.addGeometry(eh2(t3));
  let c = 0, _ = null;
  if (l2.hasCurves()) {
    _ = new fa2();
    const e3 = l2.getEnvelope2D(r);
    c = da2(h2.total());
    aa2(l2, _a2(h2.total(), e3), h2.total(), 12e3, _, null, r);
  }
  m3.setEditShapeCrackAndCluster(l2, h2);
  const d2 = m3.symmetricDifference(g2, u);
  null !== _ && _.stitchCurves(l2, d2, c, true);
  const p3 = $a2(l2.getGeometry(d2), e2, t3, "^");
  return Ga2(p3.getGeometryType()) && (p3.getImpl().setIsSimple(4, h2.total()), p3.getGeometryType() === a.enumPolygon && p3.getImpl().updateOGCFlagsProtected()), p3;
}
function Xa2(e2, t3, s3) {
  return Qa2(e2, t3, s3, true);
}
function La2(e2, t3, s3) {
  return e2.isEmpty() || t3.isEmpty() ? e2.createInstance() : Pa2(s3, e2, t3) ? new ee({ copy: Ea2(e2, t3) }) : e2.createInstance();
}
function za2(e2, t3, n5, r) {
  const i2 = n3.constructEmpty();
  e2.queryEnvelope(i2);
  const o = n3.constructEmpty();
  t3.queryEnvelope(o);
  const a2 = n3.constructEmpty();
  a2.setCoords({ env2D: i2 }), a2.mergeEnvelope2D(o);
  const h2 = At(n5, a2, true), m3 = new n3(o), l2 = Ft2(h2);
  if (m3.inflateCoords(l2, l2), !i2.isIntersecting(m3)) {
    if (e2.getDimension() <= t3.getDimension()) return $a2(eh2(e2.createInstance()), e2, t3, "&");
    if (e2.getDimension() > t3.getDimension()) return $a2(eh2(t3.createInstance()), e2, t3, "&");
  }
  const g2 = new Ka2(r), u = new Pr(), c = u.addGeometry(eh2(e2)), _ = u.addGeometry(eh2(t3));
  let d2 = 0, p3 = 0, f3 = null;
  if (u.hasCurves()) {
    f3 = new fa2();
    const e3 = u.getEnvelope2D(r);
    p3 = da2(h2.total());
    const t4 = _a2(h2.total(), e3);
    d2 = pa2(t4, p3), aa2(u, t4, h2.total(), 12e3, f3, null, r);
  }
  g2.setEditShapeCrackAndCluster(u, h2.add(d2));
  const x4 = g2.intersection(c, _);
  null !== f3 && f3.stitchCurves(u, x4, p3, true);
  const y2 = $a2(u.getGeometry(x4), e2, t3, "&");
  return Ga2(y2.getGeometryType()) && (y2.getImpl().setIsSimple(4, h2.total()), y2.getGeometryType() === a.enumPolygon && y2.getImpl().updateOGCFlagsProtected()), y2;
}
function Wa2(e2, t3, n5, r) {
  const i2 = new Array(3), o = n3.constructEmpty();
  e2.queryEnvelope(o);
  const a2 = n3.constructEmpty();
  t3.queryEnvelope(a2);
  const h2 = n3.constructEmpty();
  h2.setCoords({ env2D: o }), h2.mergeEnvelope2D(a2);
  const m3 = At(n5, h2, true), l2 = new n3(a2), g2 = Ft2(m3);
  if (l2.inflateCoords(g2, g2), !o.isIntersecting(l2)) {
    if (e2.getDimension() <= t3.getDimension()) {
      const s3 = $a2(eh2(e2.createInstance()), e2, t3, "&");
      return i2[s3.getDimension()] = s3, i2;
    }
    if (e2.getDimension() > t3.getDimension()) {
      const s3 = $a2(eh2(t3.createInstance()), e2, t3, "&");
      return i2[s3.getDimension()] = s3, i2;
    }
  }
  const u = new Ka2(r), c = new Pr(), _ = c.addGeometry(eh2(e2)), d2 = c.addGeometry(eh2(t3));
  let p3 = 0, f3 = 0, x4 = null;
  if (c.hasCurves()) {
    x4 = new fa2();
    const e3 = c.getEnvelope2D(r);
    f3 = da2(m3.total());
    const t4 = _a2(m3.total(), e3);
    p3 = pa2(t4, f3), aa2(c, t4, m3.total(), 12e3, x4, null, r);
  }
  u.setEditShapeCrackAndCluster(c, m3.add(p3)), c.dbgVerifyCurves();
  const y2 = u.intersectionEx(_, d2);
  for (const P5 of y2) {
    null !== x4 && x4.stitchCurves(c, P5, f3, false);
    const n6 = $a2(c.getGeometry(P5), e2, t3, "&");
    Ga2(n6.getGeometryType()) && (n6.getImpl().setIsSimple(4, m3.total()), n6.getGeometryType() === a.enumPolygon && n6.getImpl().updateOGCFlagsProtected()), i2[n6.getDimension()] = n6;
  }
  return null !== x4 && x4.clearStitcher(c), i2;
}
function ja2(t3, s3, n5, r, i2, o = false) {
  0 === s3 && P("not enough geometries to dissolve");
  let a2 = 0;
  for (let e2 = 0, d2 = s3; e2 < d2; e2++) a2 = Math.max(t3[e2].getDimension(), a2);
  if (2 === a2 || 1 === a2) return new Ka2(r).dissolveMultiPaths_(a2, false, t3, s3, n5, i2, o);
  let h2 = 0, m3 = -1;
  for (let e2 = 0, d2 = s3; e2 < d2; e2++) t3[e2].getDimension() === a2 && (-1 === m3 && (m3 = e2), t3[e2].isEmpty() || (m3 = e2, h2++));
  if (h2 < 2) return eh2(t3[m3]);
  const l2 = G3.constructEmpty(), g2 = new Pr();
  let u = cr;
  for (let e2 = 0, d2 = s3; e2 < d2; e2++) if (t3[e2].getDimension() === a2 && !t3[e2].isEmpty()) {
    u === cr ? u = g2.addGeometry(eh2(t3[e2])) : g2.appendGeometry(u, eh2(t3[e2]));
    const s4 = G3.constructEmpty();
    t3[e2].queryLooseEnvelope(s4), l2.mergeEnv3D(s4);
  }
  const c = At(n5, l2.getEnvelope2D(), true), _ = new Ka2(r);
  if (o) {
    const e2 = qt2(n5, l2.getEnvelopeZs(), true);
    return _.planarSimplify3DImpl_(g2, c, e2, 0, true);
  }
  return _.m_bOGCOutput = true, _.planarSimplifyMultiPoints(g2, c, false, -1);
}
function Za2(t3, s3, n5, r, i2, o = false) {
  s3 < 2 && P("not enough geometries to dissolve");
  let a2 = 0;
  for (let e2 = 0, p3 = s3; e2 < p3; e2++) a2 = Math.max(t3[e2].getDimension(), a2);
  if (2 === a2 || 1 === a2) return new Ka2(r).dissolveMultiPaths_(a2, true, t3, s3, n5, i2, o);
  const h2 = G3.constructEmpty(), m3 = new Pr();
  let l2 = cr, g2 = 0, u = -1;
  for (let e2 = 0, p3 = s3; e2 < p3; e2++) if (t3[e2].getDimension() === a2 && (-1 === u && (u = e2), !t3[e2].isEmpty())) {
    u = e2, l2 === cr ? l2 = m3.addGeometry(eh2(t3[e2])) : m3.appendGeometry(l2, eh2(t3[e2]));
    const s4 = G3.constructEmpty();
    t3[e2].queryLooseEnvelope(s4), h2.mergeEnv3D(s4), g2++;
  }
  if (g2 < 2) return eh2(t3[u]);
  const c = 0 === a2 ? n5 : null, _ = At(c, h2.getEnvelope2D(), true), d2 = new Ka2(r);
  if (o) {
    const e2 = qt2(c, h2.getEnvelopeZs(), true);
    return d2.m_bOGCOutput = true, d2.planarSimplify3DImpl_(m3, _, e2, 0, true);
  }
  return d2.planarSimplifyMultiPoints(m3, _, true, -1);
}
var Ka2 = class {
  constructor(e2) {
    this.m_topoGraph = null, this.m_maskLookup = [], this.m_dummyPt1 = mi.getNAN(), this.m_dummyPt2 = mi.getNAN(), this.m_fromEdgeForPolylines = cr, this.m_progressCounter = 0, this.m_bOGCOutput = false, this.m_progressTracker = e2;
  }
  linesToPolygonsImpl(e2, t3) {
    let s3 = 0, n5 = 0, r = null;
    if (e2.hasCurves()) {
      r = new fa2();
      const i3 = e2.getEnvelope2D(this.m_progressTracker);
      n5 = da2(t3.total());
      const o2 = _a2(t3.total(), i3);
      s3 = pa2(o2, n5), aa2(e2, o2, t3.total(), 12e3, r, null, this.m_progressTracker);
    }
    this.setEditShapeCrackAndCluster(e2, t3.add(s3));
    const i2 = this.m_topoGraph.createUserIndexForChains(), o = this.m_topoGraph.getFirstChain();
    this.m_topoGraph.setChainUserIndex(o, i2, 1);
    for (let h2 = this.m_topoGraph.getChainFirstIsland(o); h2 !== cr; h2 = this.m_topoGraph.getChainNextInParent(h2)) this.m_topoGraph.setChainUserIndex(h2, i2, 1);
    const a2 = [];
    for (let h2 = this.m_topoGraph.getFirstChain(); h2 !== cr; h2 = this.m_topoGraph.getChainNext(h2)) {
      if (1 === this.m_topoGraph.getChainUserIndex(h2, i2)) continue;
      this.m_topoGraph.setChainUserIndex(h2, i2, 1);
      for (let e3 = this.m_topoGraph.getChainFirstIsland(h2); e3 !== cr; e3 = this.m_topoGraph.getChainNextInParent(e3)) this.m_topoGraph.setChainUserIndex(e3, i2, 1);
      if (0 === this.m_topoGraph.getChainArea(h2)) continue;
      const t4 = this.m_topoGraph.extractPolygonFromChainAndIslands(e2, cr, h2, cr);
      null != r && r.stitchCurves(e2, t4, n5, false);
      const s4 = e2.getGeometry(t4);
      a2.push(s4);
    }
    return new s(a2);
  }
  autoCompleteImpl(e2, t3, s3) {
    let n5 = 0, r = 0, i2 = null;
    if (e2.hasCurves()) {
      i2 = new fa2();
      const t4 = e2.getEnvelope2D(this.m_progressTracker);
      r = da2(s3.total());
      const o2 = _a2(s3.total(), t4);
      n5 = pa2(o2, r), aa2(e2, o2, s3.total(), 12e3, i2, null, this.m_progressTracker);
    }
    this.setEditShapeCrackAndCluster(e2, s3.add(n5));
    const o = this.m_topoGraph.getGeometryID(t3), a2 = this.m_topoGraph.createUserIndexForChains(), h2 = this.m_topoGraph.getFirstChain();
    this.m_topoGraph.setChainUserIndex(h2, a2, 1);
    for (let l2 = this.m_topoGraph.getChainFirstIsland(h2); l2 !== cr; l2 = this.m_topoGraph.getChainNextInParent(l2)) this.m_topoGraph.setChainUserIndex(l2, a2, 1);
    const m3 = [];
    for (let l2 = this.m_topoGraph.getFirstChain(); l2 !== cr; l2 = this.m_topoGraph.getChainNext(l2)) {
      if (1 === this.m_topoGraph.getChainUserIndex(l2, a2)) continue;
      this.m_topoGraph.setChainUserIndex(l2, a2, 1);
      for (let e3 = this.m_topoGraph.getChainFirstIsland(l2); e3 !== cr; e3 = this.m_topoGraph.getChainNextInParent(e3)) this.m_topoGraph.setChainUserIndex(e3, a2, 1);
      if (0 !== this.m_topoGraph.getChainParentage(l2)) continue;
      const t4 = this.m_topoGraph.getChainHalfEdge(l2);
      let s4 = t4, n6 = false;
      do {
        const e3 = this.m_topoGraph.getHalfEdgeTwin(s4);
        if (this.m_topoGraph.getHalfEdgeChain(e3) !== l2 && 0 !== (this.m_topoGraph.getHalfEdgeParentage(s4) & o)) {
          n6 = true;
          break;
        }
        s4 = this.m_topoGraph.getHalfEdgeNext(s4);
      } while (s4 !== t4);
      if (!n6) continue;
      if (0 === this.m_topoGraph.getChainArea(l2)) continue;
      const h3 = this.m_topoGraph.extractPolygonFromChainAndIslands(e2, cr, l2, cr);
      null !== i2 && i2.stitchCurves(e2, h3, r, false);
      const g2 = e2.getGeometry(h3);
      m3.push(g2);
    }
    return new s(m3);
  }
  setEditShape(e2, t3 = false) {
    null === this.m_topoGraph && (this.m_topoGraph = new tn2()), this.m_topoGraph.setEditShape(e2, this.m_progressTracker, true, t3);
  }
  setEditShapeCrackAndCluster(e2, t3) {
    ya2(e2, t3, this.m_progressTracker, true, false);
    for (let n5 = e2.getFirstGeometry(); n5 !== cr; n5 = e2.getNextGeometry(n5)) e2.getGeometryType(n5) === a.enumPolygon && er2(e2, n5, -1, this.m_bOGCOutput, cr, this.m_progressTracker);
    this.setEditShape(e2);
  }
  setHalfEdgeOrientations_(e2, t3) {
    const s3 = this.m_topoGraph.getShape();
    for (let n5 = s3.getFirstGeometry(); n5 !== cr; n5 = s3.getNextGeometry(n5)) if (n5 === t3) for (let t4 = s3.getFirstPath(n5); t4 !== cr; t4 = s3.getNextPath(t4)) {
      let n6 = s3.getFirstVertex(t4);
      if (n6 === cr) continue;
      let r = s3.getNextVertex(n6);
      for (; r !== cr; ) {
        const t5 = this.m_topoGraph.getClusterFromVertex(n6), i2 = this.m_topoGraph.getClusterFromVertex(r), o = this.m_topoGraph.getHalfEdgeConnector(t5, i2);
        if (o !== cr) {
          const t6 = this.m_topoGraph.getHalfEdgeTwin(o);
          this.m_topoGraph.setHalfEdgeUserIndex(o, e2, 1), this.m_topoGraph.setHalfEdgeUserIndex(t6, e2, 2);
        }
        n6 = r, r = s3.getNextVertex(n6);
      }
    }
  }
  flushVertices_(e2, t3) {
    const s3 = this.m_topoGraph.getShape(), n5 = s3.hasSegmentParentage(), r = new fm(), i2 = s3.insertPath(e2, cr);
    t3.push(t3[0]);
    const o = t3.length;
    let a2 = cr;
    for (let h2 = 0; h2 < o; h2++) {
      const e3 = t3[h2];
      if (a2 = s3.addVertex(i2, e3), !n5) continue;
      const m3 = this.m_topoGraph.getClusterFromVertex(e3);
      if (h2 > 0 && this.m_topoGraph.isBreakNode(m3) && s3.setSegmentParentageBreakVertex(a2, true), h2 < o - 1) {
        const e4 = this.m_topoGraph.getHalfEdgeConnector(m3, this.m_topoGraph.getClusterFromVertex(t3[h2 + 1])), n6 = this.m_topoGraph.getSegmentParentage(e4);
        s3.setSegmentParentageAndBreak(a2, n6, h2 > 0 || this.m_topoGraph.isBreakNode(m3)), this.m_topoGraph.isHalfEdgeCurve(e4) && (this.m_topoGraph.querySegmentXY(e4, r), s3.setSegmentToIndex(s3.getVertexIndex(a2), r.get().clone()));
      }
    }
    if (n5) {
      const e3 = this.m_topoGraph.getClusterFromVertex(t3[o - 1]);
      this.m_topoGraph.isBreakNode(e3) && s3.setSegmentParentageBreakVertex(a2, true);
    }
    s3.setClosedPath(i2, true);
  }
  processPolygonCuts_(e2, t3, n5, r) {
    const i2 = this.m_topoGraph.getGeometryID(n5), o = this.m_topoGraph.getGeometryID(r), a2 = [], h2 = this.m_topoGraph.getShape(), m3 = this.m_topoGraph.createUserIndexForHalfEdges();
    for (let l2 = this.m_topoGraph.getFirstCluster(); l2 !== cr; l2 = this.m_topoGraph.getNextCluster(l2)) {
      const n6 = this.m_topoGraph.getClusterHalfEdge(l2);
      if (n6 === cr) continue;
      let r2 = n6;
      do {
        if (1 !== this.m_topoGraph.getHalfEdgeUserIndex(r2, m3)) {
          let n7 = r2, l3 = r2, g2 = false, u = 0;
          do {
            if (this.m_topoGraph.setHalfEdgeUserIndex(n7, m3, 1), !g2) {
              if (0 !== (this.m_topoGraph.getHalfEdgeParentage(n7) & o)) {
                0 !== (this.m_topoGraph.getHalfEdgeFaceParentage(n7) & i2) && (l3 = n7, g2 = true);
              }
            }
            if (g2) {
              const t4 = this.m_topoGraph.getHalfEdgeOrigin(n7), s3 = this.m_topoGraph.getClusterVertexIterator(t4), r3 = this.m_topoGraph.getVertexFromVertexIterator(s3);
              if (a2.push(r3), -1 !== e2) {
                if (0 !== (this.m_topoGraph.getHalfEdgeParentage(n7) & o)) {
                  u |= this.m_topoGraph.getHalfEdgeUserIndex(n7, e2);
                }
              }
            }
            n7 = this.m_topoGraph.getHalfEdgeNext(n7);
          } while (n7 !== l3);
          if (g2 && this.m_topoGraph.getChainArea(this.m_topoGraph.getHalfEdgeChain(l3)) > 0) {
            const e3 = h2.createGeometry(a.enumPolygon);
            this.flushVertices_(e3, a2), -1 !== t3 && h2.setGeometryUserIndex(e3, t3, u);
          }
          a2.length = 0;
        }
        r2 = this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(r2));
      } while (r2 !== n6);
    }
    this.m_topoGraph.deleteUserIndexForHalfEdges(m3);
  }
  cutPolygonPolyline_(e2, t3, s3, n5) {
    this.m_topoGraph.removeSpikes_();
    let r = -1;
    -1 !== e2 && (r = this.m_topoGraph.createUserIndexForHalfEdges(), this.setHalfEdgeOrientations_(r, s3)), this.processPolygonCuts_(r, e2, t3, s3), -1 !== r && (this.m_topoGraph.deleteUserIndexForHalfEdges(r), r = -1);
    const i2 = this.m_topoGraph.getShape();
    for (let o = i2.getFirstGeometry(); o !== cr; o = i2.getNextGeometry(o)) o !== t3 && o !== s3 && n5.push(o);
    n5.sort((e3, t4) => {
      const s4 = i2.getFirstPath(e3), n6 = i2.getRingArea(s4), r2 = i2.getFirstPath(t4), o = i2.getRingArea(r2);
      return n6 < o ? -1 : n6 > o ? 1 : 0;
    });
  }
  cut(e2, t3, s3, n5, i2) {
    const o = this.m_topoGraph.getShape().getGeometryType(s3), a2 = this.m_topoGraph.getShape().getGeometryType(n5), m3 = m(o), l2 = m(a2);
    if (2 !== m3 || 1 !== l2) {
      if (1 === m3 && 1 === l2) {
        return void new sh2(this, e2, t3, s3, n5, i2).Do();
      }
      b("");
    } else this.cutPolygonPolyline_(t3, s3, n5, i2);
  }
  progress_(e2 = false) {
  }
  isGoodParentage(e2) {
    return e2 >= 0 && e2 < this.m_maskLookup.length && this.m_maskLookup[e2];
  }
  normalizeInputGeometry(t3) {
    const r = t3.getGeometryType();
    if (r === a.enumEnvelope) {
      const e2 = new ur({ vd: t3.getDescription() });
      return t3.isEmpty() || e2.addEnvelope(t3, false), e2;
    }
    if (r === a.enumPoint) {
      const e2 = new cs2({ vd: t3.getDescription() });
      return t3.isEmpty() || e2.add(t3), e2;
    }
    if (f(r)) {
      const e2 = new Os2({ vd: t3.getDescription() });
      return t3.isEmpty() || e2.addSegment(t3, true), e2;
    }
    return r !== a.enumMultiPoint && r !== a.enumPolyline && r !== a.enumPolygon && P("Unexpected geometry type"), t3;
  }
  dissolveNonSimplePolygons(e2, t3, s3, n5) {
    n(t3 > 0);
    const r = new Pr();
    let i2 = 0, a2 = -1;
    for (let o = 0, h2 = t3; o < h2; o++) 2 === e2[o].getDimension() && (-1 === a2 && (a2 = o), e2[o].isEmpty() || (i2++, r.addGeometry(e2[o])));
    return 0 === i2 ? (n(a2 >= 0), this.normalizeInputGeometry(e2[a2])) : this.planarSimplifyPolygons(r, s3, true, false, -1, true);
  }
  dissolveMultiPaths_(e2, t3, r, a2, h2, l2, g2) {
    n(e2 >= 1 && e2 <= 2), n(a2 > 0);
    const u = 8 & l2 ? 1 : 2, c = G3.constructEmpty();
    let _ = 0, d2 = -1, p3 = true;
    for (let n5 = 0, i2 = a2; n5 < i2; n5++) if (r[n5].getDimension() === e2 && (-1 === d2 && (d2 = n5), !r[n5].isEmpty())) {
      d2 = n5, _++;
      const t4 = G3.constructEmpty();
      if (r[n5].queryLooseEnvelope(t4), c.mergeEnv3D(t4), 2 === e2 && p3 && r[n5].getGeometryType() === a.enumPolygon) if (16 & l2) {
        const e3 = [0], t5 = r[n5].getImpl().getIsSimple(0, e3), s3 = this.m_bOGCOutput ? 5 === t5 : Ot2(t5);
        p3 &&= s3;
      } else {
        const e3 = Vt2(r[n5], 0);
        p3 &&= e3;
      }
    }
    if (_ < 2 && (n(d2 >= 0), 0 === _ || !(16 & l2))) return this.normalizeInputGeometry(r[d2]);
    if (!p3) {
      const e3 = At(t3 ? null : h2, c.getEnvelope2D(), true);
      return this.dissolveNonSimplePolygons(r, a2, e3, l2);
    }
    const f3 = r.slice(0, a2), x4 = At(h2, c.getEnvelope2D(), true), y2 = 10 * Ft2(x4);
    let P5 = new Et2(0, 0);
    if (g2 && (P5 = qt2(h2, c.getEnvelopeZs(), true)), 1 === _ && 1 === e2 && 2 === u && !t3) return g2 ? qa2() : this.m_bOGCOutput ? Aa2(f3[d2], x4, false, -1, this.m_progressTracker, u, false) : Ma2(f3[d2], x4, false, false, -1, this.m_progressTracker, u, false);
    const E2 = new yt();
    E2.startConstruction();
    let S3 = 2 === e2 ? 3 : 4, b2 = 0;
    for (let m3 = 0, I4 = a2; m3 < I4; m3++) {
      if (f3[m3].getDimension() !== e2 || f3[m3].isEmpty()) continue;
      let r2 = f3[m3].getGeometryType();
      if (r2 !== a.enumEnvelope) {
        if (f(r2) ? (f3[m3] = this.normalizeInputGeometry(f3[m3]), r2 = a.enumPolyline) : n(h(r2)), 1 === e2) {
          n(r2 === a.enumPolyline);
          let e3 = -1;
          if (g2) n(0, "3d not implemented yet");
          else {
            const t4 = [0];
            e3 = f3[m3].getImpl().getIsSimple(x4.total(), t4);
          }
          if (this.m_bOGCOutput ? 5 !== e3 : !Ot2(e3)) if (t3) S3 = -1;
          else {
            g2 ? n(0, "3d not implemented yet") : this.m_bOGCOutput ? f3[m3] = Aa2(f3[m3], x4, false, -1, this.m_progressTracker, u, false) : f3[m3] = Ma2(f3[m3], x4, false, false, -1, this.m_progressTracker, u, false);
            const e4 = [0];
            n(Ot2(f3[m3].getImpl().getIsSimple(x4.total(), e4)));
          }
        } else {
          n(r2 === a.enumPolygon);
          const e3 = [0], t4 = f3[m3].getImpl().getIsSimple(0, e3);
          n(Ht2(t4));
        }
        const a3 = f3[m3].getImpl();
        for (let e3 = 0, t4 = a3.getPathCount(); e3 < t4; e3++) {
          const t5 = n3.constructEmpty();
          a3.queryLoosePathEnvelope(e3, t5), t5.inflateCoords(y2, y2), E2.addEnvelope(b2, t5), b2++;
        }
      } else {
        n(r2 === a.enumEnvelope);
        const e3 = n3.constructEmpty();
        f3[m3].queryLooseEnvelope(e3), e3.inflateCoords(y2, y2), E2.addEnvelope(b2, e3), b2++, S3 = -1;
      }
    }
    E2.endConstruction();
    const w4 = b2, N2 = Yt(w4, -2147483647), T3 = Yt(w4, -1);
    let D3 = 0;
    d2 = -1, b2 = 0;
    for (let n5 = 0, m3 = a2; n5 < m3; n5++) {
      if (f3[n5].getDimension() !== e2) continue;
      if (-1 === d2 && (d2 = n5), f3[n5].isEmpty()) continue;
      d2 = n5, D3++;
      const t4 = f3[n5].getGeometryType();
      if (h(t4)) {
        for (let e3 = 0, t5 = f3[n5].getPathCount(); e3 < t5; e3++) T3[b2] = n5, N2[b2] = -e3 - 1, b2++;
      } else n(t4 === a.enumEnvelope), T3[b2] = n5, N2[b2] = -1, b2++;
    }
    if (D3 < 2 && 2 === e2) return n(d2 >= 0), this.normalizeInputGeometry(f3[d2]);
    let V4 = w4;
    for (; E2.next() && V4 > 0; ) {
      this.progress_();
      const e3 = E2.getHandleA(), t4 = E2.getHandleB(), s3 = E2.getElement(e3), n5 = E2.getElement(t4);
      T3[s3] !== T3[n5] && (N2[s3] < 0 && (V4--, N2[s3] = -(N2[s3] + 1)), N2[n5] < 0 && (V4--, N2[n5] = -(N2[n5] + 1)));
    }
    const F3 = new Pr();
    let H3 = false, k4 = 0;
    for (let n5 = 0, C3 = a2; n5 < C3; n5++) {
      if (f3[n5].getDimension() !== e2 || f3[n5].isEmpty()) continue;
      const t4 = f3[n5].getGeometryType(), r2 = k4;
      let a3 = 0, h3 = 0;
      const l3 = h(t4) ? f3[n5] : null;
      for (let e3 = r2, s3 = N2.length; e3 < s3 && T3[e3] === n5; e3++) N2[e3] >= 0 && (a3++, h3 += l3 ? l3.getPathSize(N2[e3]) : w(f3[n5])), k4++;
      if (h3 > 0.95 * w(f3[n5])) {
        F3.addGeometry(this.normalizeInputGeometry(f3[n5]));
        for (let e3 = r2; e3 < k4; e3++) N2[e3] < 0 && (N2[e3] = -(N2[e3] + 1));
      } else {
        if (0 === a3) {
          H3 = true;
          continue;
        }
        {
          H3 = true, n(h(t4)), n(null != l3);
          const e3 = new ur({ vd: f3[n5].getDescription() }), a4 = new Os2({ vd: f3[n5].getDescription() }), h4 = t4 === a.enumPolygon ? e3 : a4;
          for (let t5 = r2; t5 < k4; t5++) N2[t5] >= 0 && h4.addPath(l3, N2[t5], true);
          F3.addGeometry(h4);
        }
      }
    }
    let A4;
    if (F3.getFirstGeometry() !== cr) {
      const s3 = 2 === e2, n5 = t3 ? At(null, c.getEnvelope2D(), true) : x4;
      let r2 = new Et2(0, 0);
      if (g2 && (r2 = t3 ? qt2(null, c.getEnvelopeZs(), true) : P5), 2 === e2 && !(2 & l2)) {
        F3.collapseAllGeometriesToFirst();
        let e3 = 0, t4 = null;
        if (F3.hasCurves() && !F3.hasSegmentParentage()) {
          t4 = new fa2();
          const s4 = F3.getEnvelope2D(this.m_progressTracker);
          e3 = da2(n5.total());
          aa2(F3, _a2(n5.total(), s4), n5.total(), 12e3, t4, null, this.m_progressTracker);
        }
        Vn2(F3, F3.getFirstGeometry(), n5.total(), this.m_progressTracker), null !== t4 && t4.stitchCurves(F3, cr, e3, true);
      }
      if (g2) A4 = this.planarSimplify3DImpl_(F3, n5, r2, u, true);
      else if (2 === e2) A4 = this.planarSimplifyPolygons(F3, n5, s3, t3, -1, false);
      else {
        const e3 = Ha2();
        e3.ogcRule = this.m_bOGCOutput, e3.allCrossRoadsImpassable = true, e3.unsplitBehavior = u, A4 = this.planarSimplifyPolylines(F3, n5, t3, e3, -1);
      }
      if (!H3) {
        const e3 = [0];
        S3 = A4.getImpl().getIsSimple(n5.total(), e3);
      }
    } else n(H3), n(d2 >= 0), A4 = 2 === e2 ? new ur({ vd: f3[d2].getDescription() }) : new Os2({ vd: f3[d2].getDescription() });
    if (H3) {
      let e3 = 0;
      for (let t4 = 0, s3 = N2.length; t4 < s3; t4++) {
        const s4 = T3[t4];
        if (!(s4 < 0) && N2[t4] < 0) {
          const n5 = f3[s4].getGeometryType(), r2 = h(n5) ? f3[s4] : null;
          if (r2) {
            const s5 = -(N2[t4] + 1);
            e3 += r2.getPathSize(s5);
          } else e3 += 4;
        }
      }
      A4.reserve(A4.getPointCount() + e3);
      for (let t4 = 0, r2 = N2.length; t4 < r2; t4++) {
        const e4 = T3[t4];
        if (!(e4 < 0) && N2[t4] < 0) {
          const r3 = f3[e4].getGeometryType(), a3 = h(r3) ? f3[e4] : null;
          if (a3) {
            const e5 = -(N2[t4] + 1);
            A4.addPath(a3, e5, true);
          } else r3 === a.enumEnvelope ? A4.addEnvelope(f3[e4], false) : (n(f(r3)), A4.addSegment(f3[e4], true));
        }
      }
    }
    let U4 = 0;
    if (2 === e2 ? -1 !== S3 && (S3 = 3, U4 = t3 ? 0 : x4.total()) : (n(1 === e2), t3 || -1 === S3 || (U4 = x4.total())), g2 || A4.getImpl().setIsSimple(S3, U4), !t3 && H3) if (2 === e2) {
      if (!g2) return new Eh2().execute(A4, h2, false, this.m_progressTracker);
      n(0, "3d not yet implemented");
    } else 1 === e2 && 1 !== u && (A4 = g2 ? Ba2() : Ua2(this.m_bOGCOutput, A4, u, this.m_progressTracker), A4.getImpl().setIsSimple(S3, U4));
    return A4;
  }
  dissolveTopoGraphCommonEdges_() {
    const e2 = this.m_topoGraph.createUserIndexForHalfEdges(), t3 = [];
    for (let s3 = this.m_topoGraph.getFirstCluster(); s3 !== cr; s3 = this.m_topoGraph.getNextCluster(s3)) {
      const n5 = this.m_topoGraph.getClusterHalfEdge(s3);
      let r = n5;
      if (n5 !== cr) do {
        this.progress_();
        if (1 !== this.m_topoGraph.getHalfEdgeUserIndex(r, e2)) {
          const s4 = this.m_topoGraph.getHalfEdgeTwin(r);
          this.m_topoGraph.setHalfEdgeUserIndex(s4, e2, 1), this.m_topoGraph.setHalfEdgeUserIndex(r, e2, 1);
          const n6 = this.m_topoGraph.getHalfEdgeFaceParentage(r);
          if (this.isGoodParentage(n6)) {
            const e3 = this.m_topoGraph.getHalfEdgeFaceParentage(s4);
            this.isGoodParentage(e3) && t3.push(r);
          }
        }
        r = this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(r));
      } while (r !== n5);
    }
    this.m_topoGraph.deleteUserIndexForHalfEdges(e2), this.m_topoGraph.deleteEdgesBreakFaces_(t3);
  }
  chooseVertexByOrder(e2, t3, s3, n5) {
    let r = vs(), i2 = cr;
    for (let o = this.m_topoGraph.getClusterVertexIterator(e2); o !== cr; o = this.m_topoGraph.incrementVertexIterator(o)) {
      const e3 = this.m_topoGraph.getVertexFromVertexIterator(o), n6 = t3.getUserIndex(e3, s3);
      n6 >= 0 && n6 < r && (r = n6, i2 = e3);
    }
    n(i2 !== cr);
    let a2 = t3.getUserIndex(i2, n5);
    return a2 > 0 && (t3.setUserIndex(i2, n5, --a2), 0 === a2 && t3.setUserIndex(i2, s3, -1)), i2;
  }
  chooseVertexFromCluster_(e2, t3) {
    return this.m_topoGraph.getVertexDominantFromCluster(e2, t3);
  }
  chooseVertexFromVertexCluster_(e2, t3) {
    return this.m_topoGraph.getVertexDominant(e2, t3);
  }
  collectPolygonPathsPreservingFrom_(e2, t3, n5, r, i2) {
    const o = this.m_topoGraph.getShape();
    if (o.getGeometryType(e2) !== a.enumPolygon) return;
    const a2 = o.hasSegmentParentage(), h2 = new fm();
    for (let s3 = o.getFirstPath(e2); s3 !== cr; s3 = o.getNextPath(s3)) {
      const e3 = o.getFirstVertex(s3);
      this.m_topoGraph.getClusterFromVertex(e3);
      const m3 = this.m_topoGraph.getHalfEdgeFromVertex(e3);
      if (m3 === cr) continue;
      const l2 = this.m_topoGraph.getHalfEdgeUserIndex(m3, n5);
      if (1 === l2 || 2 === l2) continue;
      const g2 = this.m_topoGraph.getHalfEdgeFaceParentage(m3);
      if (!this.isGoodParentage(g2)) {
        this.m_topoGraph.setHalfEdgeUserIndex(m3, n5, 2);
        continue;
      }
      this.m_topoGraph.setHalfEdgeUserIndex(m3, n5, 1);
      const u = o.insertPath(t3, cr);
      o.setClosedPath(u, true);
      let c = m3, _ = e3, d2 = this.m_topoGraph.getClusterFromVertex(_), p3 = 1;
      do {
        this.progress_();
        const e4 = this.chooseVertexFromVertexCluster_(_, i2), t4 = o.addVertex(u, e4);
        if (this.m_topoGraph.isHalfEdgeCurve(c) && (this.m_topoGraph.querySegmentXY(c, h2), o.setSegmentToIndex(o.getVertexIndex(t4), h2.get().clone())), a2) {
          const e5 = this.m_topoGraph.getSegmentParentage(c);
          o.setSegmentParentageAndBreak(t4, e5, this.m_topoGraph.isBreakNode(d2));
        }
        let s4, m4;
        -1 !== r && this.m_topoGraph.setClusterUserIndex(d2, r, 1), this.m_topoGraph.setHalfEdgeUserIndex(c, n5, 1), c = this.m_topoGraph.getHalfEdgeNext(c);
        do {
          s4 = 1 === p3 ? o.getNextVertex(_) : o.getPrevVertex(_), m4 = s4 !== cr ? this.m_topoGraph.getClusterFromVertex(s4) : cr;
        } while (m4 === d2);
        const l3 = this.m_topoGraph.getHalfEdgeOrigin(c);
        if (l3 !== m4) {
          do {
            s4 = 1 === p3 ? o.getPrevVertex(_) : o.getNextVertex(_), m4 = s4 !== cr ? this.m_topoGraph.getClusterFromVertex(s4) : cr;
          } while (m4 === d2);
          if (l3 !== m4) {
            m4 = l3;
            const e5 = this.m_topoGraph.getClusterVertexIterator(m4);
            s4 = this.m_topoGraph.getVertexFromVertexIterator(e5);
          } else p3 = -p3;
        }
        d2 = m4, _ = s4;
      } while (c !== m3);
    }
  }
  topoOperationPolygonPolygonHelper_(e2, t3, s3, n5, r, i2) {
    this.progress_(true), e2 !== cr && this.collectPolygonPathsPreservingFrom_(e2, s3, r, i2, n5), t3 !== cr && this.collectPolygonPathsPreservingFrom_(t3, s3, r, i2, n5);
    const o = new fm(), a2 = this.m_topoGraph.getShape();
    a2.dbgVerifyCurves();
    const h2 = a2.hasSegmentParentage();
    for (let m3 = this.m_topoGraph.getFirstCluster(); m3 !== cr; m3 = this.m_topoGraph.getNextCluster(m3)) {
      const e3 = this.m_topoGraph.getClusterHalfEdge(m3);
      if (e3 === cr) continue;
      let t4 = e3;
      do {
        this.progress_();
        const e4 = this.m_topoGraph.getHalfEdgeUserIndex(t4, r);
        if (1 !== e4 && 2 !== e4) {
          const e5 = this.m_topoGraph.getHalfEdgeFaceParentage(t4);
          if (this.isGoodParentage(e5)) {
            const e6 = a2.insertPath(s3, cr);
            a2.setClosedPath(e6, true);
            let m4 = t4;
            do {
              const t5 = this.m_topoGraph.getHalfEdgeVertexIterator(m4);
              let s4 = cr;
              if (t5 !== cr) s4 = this.m_topoGraph.getVertexFromVertexIterator(t5);
              else {
                const e7 = this.m_topoGraph.getHalfEdgeVertexIterator(this.m_topoGraph.getHalfEdgeTwin(m4));
                s4 = this.m_topoGraph.getVertexFromVertexIterator(e7), s4 = a2.getNextVertex(s4);
              }
              const l2 = this.chooseVertexFromVertexCluster_(s4, n5), g2 = a2.addVertex(e6, l2);
              if (h2) {
                const e7 = this.m_topoGraph.getSegmentParentage(m4), t6 = this.m_topoGraph.getHalfEdgeOrigin(m4);
                a2.setSegmentParentageAndBreak(g2, e7, this.m_topoGraph.isBreakNode(t6));
              }
              if (this.m_topoGraph.isHalfEdgeCurve(m4) && (this.m_topoGraph.querySegmentXY(m4, o), a2.setSegmentToIndex(a2.getVertexIndex(g2), o.get().clone())), this.m_topoGraph.setHalfEdgeUserIndex(m4, r, 1), -1 !== i2) {
                const e7 = this.m_topoGraph.getClusterFromVertex(l2);
                this.m_topoGraph.setClusterUserIndex(e7, i2, 1);
              }
              m4 = this.m_topoGraph.getHalfEdgeNext(m4);
            } while (m4 !== t4);
          } else this.m_topoGraph.setHalfEdgeUserIndex(t4, r, 2);
        }
        t4 = this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(t4));
      } while (t4 !== e3);
    }
  }
  topoOperationPolygonPolygon_(e2, t3, n5, r = false) {
    this.dissolveTopoGraphCommonEdges_();
    const i2 = this.m_topoGraph.getShape(), o = i2.createGeometry(a.enumPolygon), a2 = this.m_topoGraph.createUserIndexForHalfEdges();
    return this.topoOperationPolygonPolygonHelper_(e2, t3, o, n5, a2, -1), this.m_topoGraph.deleteUserIndexForHalfEdges(a2), r || er2(i2, o, 3, this.m_bOGCOutput, cr, this.m_progressTracker), o;
  }
  topoOperationPolyline_(e2, t3) {
    const s3 = Ha2();
    return s3.allCrossRoadsImpassable = false, s3.ogcRule = t3, s3.unsplitBehavior = 0, this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(cr, e2, false, s3).first;
  }
  topoOperationMultiPoint_() {
    const e2 = this.m_topoGraph.getShape(), t3 = e2.createGeometry(a.enumMultiPoint), n5 = e2.insertPath(t3, cr);
    for (let s3 = this.m_topoGraph.getFirstCluster(); s3 !== cr; s3 = this.m_topoGraph.getNextCluster(s3)) {
      const t4 = this.m_topoGraph.getClusterParentage(s3);
      if (this.isGoodParentage(t4)) {
        let t5 = cr;
        for (let n6 = this.m_topoGraph.getClusterVertexIterator(s3); n6 !== cr; n6 = this.m_topoGraph.incrementVertexIterator(n6)) {
          const s4 = this.m_topoGraph.getVertexFromVertexIterator(n6);
          t5 === cr && (t5 = s4);
          const r = e2.getGeometryFromPath(e2.getPathFromVertex(s4)), i2 = this.m_topoGraph.getGeometryID(r);
          if (this.isGoodParentage(i2)) {
            t5 = s4;
            break;
          }
        }
        e2.addVertex(n5, t5);
      }
    }
    return t3;
  }
  intersection(e2, t3) {
    const s3 = this.m_topoGraph.getShape().getGeometryType(e2), n5 = this.m_topoGraph.getShape().getGeometryType(t3), i2 = m(s3), a2 = m(n5), m3 = this.m_topoGraph.getGeometryID(e2), l2 = this.m_topoGraph.getGeometryID(t3);
    n(m3 >= 0), n(l2 >= 0), this.m_maskLookup.length = 0, this.m_maskLookup.length = 1 + (m3 | l2), this.m_maskLookup[m3 | l2] = true;
    let g2 = cr;
    return this.m_topoGraph.getShape().getVertexDescription().getAttributeCount() > 1 && (g2 = e2), 2 === i2 && 2 === a2 ? this.topoOperationPolygonPolygon_(e2, t3, g2) : 1 === i2 && a2 > 0 || 1 === a2 && i2 > 0 ? this.topoOperationPolyline_(g2, this.m_bOGCOutput) : 0 === i2 || 0 === a2 ? this.topoOperationMultiPoint_() : void b("");
  }
  topoOperationPolygonPolygonEx(e2, t3, n5) {
    const r = this.m_topoGraph.getShape(), i2 = r.createGeometry(a.enumPolygon), o = r.createGeometry(a.enumPolyline), a2 = r.createGeometry(a.enumMultiPoint);
    this.dissolveTopoGraphCommonEdges_();
    let h2 = cr;
    const m3 = this.m_topoGraph.createUserIndexForHalfEdges(), l2 = this.m_topoGraph.createUserIndexForClusters();
    r.dbgVerifyCurves(), this.topoOperationPolygonPolygonHelper_(e2, t3, i2, n5, m3, l2), r.dbgVerifyCurves();
    const g2 = r.hasSegmentParentage(), u = new fm();
    for (let s3 = this.m_topoGraph.getFirstCluster(); s3 !== cr; s3 = this.m_topoGraph.getNextCluster(s3)) {
      const e3 = this.m_topoGraph.getClusterHalfEdge(s3);
      if (e3 === cr) continue;
      let t4 = e3;
      do {
        let e4 = this.m_topoGraph.getHalfEdgeUserIndex(t4, m3), i3 = this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(t4), m3), a3 = e4 | i3;
        if (2 === a3) {
          let h3 = this.m_topoGraph.getHalfEdgeParentage(t4);
          if (this.isGoodParentage(h3)) {
            const c2 = r.insertPath(o, cr);
            let _ = t4;
            const d2 = this.chooseVertexFromCluster_(s3, n5);
            let p3 = r.addVertex(c2, d2);
            if (g2) {
              const e5 = this.m_topoGraph.getSegmentParentage(t4), s4 = this.m_topoGraph.getHalfEdgeOrigin(t4);
              r.setSegmentParentageAndBreak(p3, e5, this.m_topoGraph.isBreakNode(s4));
            }
            this.m_topoGraph.isHalfEdgeCurve(t4) && (this.m_topoGraph.querySegmentXY(t4, u), r.setSegmentToIndex(r.getVertexIndex(p3), u.get().clone())), this.m_topoGraph.setClusterUserIndex(s3, l2, 1);
            do {
              this.progress_();
              const s4 = this.m_topoGraph.getHalfEdgeTo(_), o2 = this.chooseVertexFromCluster_(s4, n5);
              if (p3 = r.addVertex(c2, o2), g2) {
                const e5 = this.m_topoGraph.getSegmentParentage(t4), s5 = this.m_topoGraph.getHalfEdgeOrigin(t4);
                r.setSegmentParentageAndBreak(p3, e5, this.m_topoGraph.isBreakNode(s5));
              }
              if (this.m_topoGraph.setHalfEdgeUserIndex(_, m3, 1), this.m_topoGraph.setHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(_), m3, 1), this.m_topoGraph.setClusterUserIndex(s4, l2, 1), _ = this.m_topoGraph.getHalfEdgeNext(_), e4 = this.m_topoGraph.getHalfEdgeUserIndex(_, m3), i3 = this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(_), m3), a3 = e4 | i3, 2 !== a3) break;
              if (h3 = this.m_topoGraph.getHalfEdgeParentage(_), !this.isGoodParentage(h3)) {
                this.m_topoGraph.setHalfEdgeUserIndex(_, m3, 1), this.m_topoGraph.setHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(_), m3, 1);
                break;
              }
              this.m_topoGraph.isHalfEdgeCurve(t4) && _ !== t4 && (this.m_topoGraph.querySegmentXY(t4, u), r.setSegmentToIndex(r.getVertexIndex(p3), u.get().clone()));
            } while (_ !== t4);
          } else this.m_topoGraph.setHalfEdgeUserIndex(t4, m3, 1), this.m_topoGraph.setHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(t4), m3, 1);
        }
        t4 = this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(t4));
      } while (t4 !== e3);
    }
    for (let s3 = this.m_topoGraph.getFirstCluster(); s3 !== cr; s3 = this.m_topoGraph.getNextCluster(s3)) {
      this.progress_();
      if (1 === this.m_topoGraph.getClusterUserIndex(s3, l2)) continue;
      const e3 = this.m_topoGraph.getClusterParentage(s3);
      if (this.isGoodParentage(e3)) {
        h2 === cr && (h2 = r.insertPath(a2, cr));
        const e4 = this.m_topoGraph.getClusterVertexIterator(s3);
        let t4 = cr;
        if (e4 !== cr) {
          t4 = this.m_topoGraph.getVertexFromVertexIterator(e4);
          const s4 = this.chooseVertexFromVertexCluster_(t4, n5);
          r.addVertex(h2, s4);
        }
      }
    }
    this.m_topoGraph.deleteUserIndexForClusters(l2), this.m_topoGraph.deleteUserIndexForHalfEdges(m3), r.dbgVerifyCurves(), er2(r, i2, 3, this.m_bOGCOutput, cr, this.m_progressTracker);
    const c = [cr, cr, cr];
    return c[0] = a2, c[1] = o, c[2] = i2, c;
  }
  topoOperationPolylinePolylineOrPolygonEx(e2, t3) {
    const s3 = Ha2();
    return s3.allCrossRoadsImpassable = false, s3.ogcRule = t3, s3.unsplitBehavior = 0, this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(cr, e2, true, s3);
  }
  topoOperationMultiPoint() {
    const e2 = this.m_topoGraph.getShape(), t3 = e2.createGeometry(a.enumMultiPoint), n5 = e2.insertPath(t3, cr);
    for (let s3 = this.m_topoGraph.getFirstCluster(); s3 !== cr; s3 = this.m_topoGraph.getNextCluster(s3)) {
      const t4 = this.m_topoGraph.getClusterParentage(s3);
      if (this.isGoodParentage(t4)) {
        let t5 = cr;
        for (let n6 = this.m_topoGraph.getClusterVertexIterator(s3); n6 !== cr; n6 = this.m_topoGraph.incrementVertexIterator(n6)) {
          const s4 = this.m_topoGraph.getVertexFromVertexIterator(n6);
          t5 === cr && (t5 = s4);
          const r = e2.getGeometryFromPath(e2.getPathFromVertex(s4)), i2 = this.m_topoGraph.getGeometryID(r);
          if (this.isGoodParentage(i2)) {
            t5 = s4;
            break;
          }
        }
        e2.addVertex(n5, t5);
      }
    }
    return t3;
  }
  intersectionEx(e2, t3) {
    const s3 = this.m_topoGraph.getShape().getGeometryType(e2), n5 = this.m_topoGraph.getShape().getGeometryType(t3), i2 = Va2(s3), a2 = Va2(n5), h2 = this.m_topoGraph.getGeometryID(e2), m3 = this.m_topoGraph.getGeometryID(t3);
    n(h2 >= 0), n(m3 >= 0), this.m_maskLookup.length = 0, this.m_maskLookup.length = 1 + (h2 | m3), this.m_maskLookup[h2 | m3] = true;
    let l2 = cr;
    if (this.m_topoGraph.getShape().getVertexDescription().getAttributeCount() > 1 && (l2 = e2), 2 === i2 && 2 === a2) return this.topoOperationPolygonPolygonEx(e2, t3, l2);
    if (1 === i2 && a2 > 0 || 1 === a2 && i2 > 0) {
      const { first: e3, second: t4 } = this.topoOperationPolylinePolylineOrPolygonEx(l2, this.m_bOGCOutput);
      return [t4, e3];
    }
    if (0 === i2 || 0 === a2) {
      const e3 = [];
      return e3.push(this.topoOperationMultiPoint()), e3;
    }
    b("");
  }
  getCombinedHalfEdgeParentage(e2) {
    return this.m_topoGraph.getHalfEdgeParentage(e2) | this.m_topoGraph.getHalfEdgeFaceParentage(e2) | this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(e2));
  }
  prevailingDirection(e2, t3) {
    const s3 = this.getCombinedHalfEdgeParentage(t3), n5 = this.m_topoGraph.getHalfEdgeOrigin(t3), r = this.m_topoGraph.getHalfEdgeTo(t3);
    let i2 = 0, o = 0;
    for (let a2 = this.m_topoGraph.getClusterVertexIterator(n5); a2 !== cr; a2 = this.m_topoGraph.incrementVertexIterator(a2)) {
      const n6 = this.m_topoGraph.getVertexFromVertexIterator(a2), h2 = e2.getPathFromVertex(n6), m3 = e2.getGeometryFromPath(h2), l2 = this.m_topoGraph.getGeometryID(m3), g2 = e2.getFirstVertex(h2), u = 0 !== (l2 & s3);
      u && g2 === n6 && (this.m_fromEdgeForPolylines = t3);
      const c = e2.getNextVertex(n6);
      if (c !== cr && this.m_topoGraph.getClusterFromVertex(c) === r) {
        if (i2++, u) {
          if (this.m_fromEdgeForPolylines === cr && g2 === c) {
            const e3 = this.m_topoGraph.getHalfEdgeNext(t3);
            this.isGoodParentage(this.getCombinedHalfEdgeParentage(e3)) && (this.m_fromEdgeForPolylines = e3);
          }
          o++;
        }
      } else {
        const s4 = e2.getPrevVertex(n6);
        if (s4 !== cr && this.m_topoGraph.getClusterFromVertex(s4) === r && (i2--, u)) {
          if (this.m_fromEdgeForPolylines === cr && g2 === s4) {
            const e3 = this.m_topoGraph.getHalfEdgeNext(t3);
            this.isGoodParentage(this.getCombinedHalfEdgeParentage(e3)) && (this.m_fromEdgeForPolylines = e3);
          }
          o--;
        }
      }
    }
    this.m_topoGraph.queryXY(n5, this.m_dummyPt1), this.m_topoGraph.queryXY(r, this.m_dummyPt2);
    return (0 !== o ? o : i2) * mi.distance(this.m_dummyPt1, this.m_dummyPt2);
  }
  tryMoveThroughCrossroadBackwards(e2, t3) {
    const s3 = this.m_topoGraph.getHalfEdgePrev(e2), n5 = this.m_topoGraph.getHalfEdgeTwin(s3);
    if (!t3) {
      if (this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(e2))) return cr;
      const t4 = this.m_topoGraph.getHalfEdgeTwin(e2);
      if (n5 === this.m_topoGraph.getHalfEdgeNext(t4)) return s3;
    }
    let r = n5, i2 = cr;
    for (; r !== e2; ) {
      const e3 = this.getCombinedHalfEdgeParentage(r);
      if (this.isGoodParentage(e3)) {
        if (i2 !== cr) return cr;
        i2 = this.m_topoGraph.getHalfEdgeTwin(r);
      }
      r = this.m_topoGraph.getHalfEdgeTwin(this.m_topoGraph.getHalfEdgePrev(r));
    }
    return i2;
  }
  tryMoveThroughCrossroadForward(e2, t3) {
    const s3 = this.m_topoGraph.getHalfEdgeNext(e2), n5 = this.m_topoGraph.getHalfEdgeTwin(s3);
    if (!t3) {
      const t4 = this.m_topoGraph.getHalfEdgeTwin(e2);
      if (this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(t4))) return cr;
      if (n5 === this.m_topoGraph.getHalfEdgePrev(t4)) return s3;
    }
    let r = n5, i2 = cr;
    for (; r !== e2; ) {
      const e3 = this.getCombinedHalfEdgeParentage(r);
      if (this.isGoodParentage(e3)) {
        if (i2 !== cr) return cr;
        i2 = this.m_topoGraph.getHalfEdgeTwin(r);
      }
      r = this.m_topoGraph.getHalfEdgeTwin(this.m_topoGraph.getHalfEdgeNext(r));
    }
    return i2;
  }
  isOnALoop(e2, t3) {
    let s3 = e2;
    const n5 = 2 * this.m_topoGraph.getShape().getTotalPointCount() + 10;
    for (let r = 0; r < n5; r++) {
      if (1 === this.m_topoGraph.getHalfEdgeUserIndex(s3, t3)) return false;
      const n6 = this.m_topoGraph.getHalfEdgeNext(s3);
      if (n6 === this.m_topoGraph.getHalfEdgeTwin(s3)) return false;
      if (s3 = n6, s3 === e2) return true;
    }
    b("is_on_a_loop_");
  }
  restorePolylineParts(e2, t3, s3, n5, r, i2, a2, h2, m3, l2) {
    n(r === cr && i2 >= 0 && a2 >= 0 || -1 === i2 && -1 === a2), n(-1 === h2 && 1 !== l2.unsplitBehavior || -1 !== h2 && 1 === l2.unsplitBehavior);
    const g2 = l2.ogcRule, u = l2.allCrossRoadsImpassable, c = 1 === l2.unsplitBehavior, _ = 0 === l2.unsplitBehavior, d2 = this.m_topoGraph.getShape(), p3 = d2.hasSegmentParentage();
    let f3 = e2, x4 = this.m_topoGraph.getHalfEdgeTwin(f3);
    const y2 = new fm();
    this.m_fromEdgeForPolylines = cr;
    let P5 = this.prevailingDirection(d2, f3), E2 = f3, S3 = cr, C3 = false, I4 = false, b2 = false;
    if (!c) for (; ; ) {
      const t4 = this.m_topoGraph.getHalfEdgePrev(f3);
      if (t4 === x4) {
        b2 = true;
        break;
      }
      const n6 = this.m_topoGraph.getHalfEdgeNext(x4);
      if (this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(n6))) {
        C3 = true;
        break;
      }
      if (this.m_topoGraph.getHalfEdgeTwin(t4) !== n6) {
        if (u) {
          C3 = true;
          break;
        }
        if (f3 = this.tryMoveThroughCrossroadBackwards(f3, true), f3 === cr) {
          C3 = true;
          break;
        }
        x4 = this.m_topoGraph.getHalfEdgeTwin(f3);
      } else f3 = t4, x4 = n6;
      if (1 === this.m_topoGraph.getHalfEdgeUserIndex(f3, s3)) {
        b2 = true;
        break;
      }
      if (f3 === e2) {
        S3 = e2, I4 = true;
        break;
      }
      const r2 = this.getCombinedHalfEdgeParentage(f3);
      if (!this.isGoodParentage(r2)) break;
      E2 = f3, P5 += this.prevailingDirection(d2, f3);
    }
    if (S3 === cr) {
      for (f3 = e2, x4 = this.m_topoGraph.getHalfEdgeTwin(f3), S3 = f3; ; ) {
        const e3 = this.m_topoGraph.getHalfEdgeNext(f3), t5 = this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(e3));
        if (t5) {
          C3 = true;
          break;
        }
        if (e3 === x4) {
          b2 = true;
          break;
        }
        if (-1 !== h2) {
          const e4 = this.m_topoGraph.getHalfEdgeOrigin(x4);
          if (1 === this.m_topoGraph.getClusterUserIndex(e4, h2)) {
            C3 = true;
            break;
          }
        }
        const n6 = this.m_topoGraph.getHalfEdgePrev(x4);
        if (this.m_topoGraph.getHalfEdgeTwin(e3) !== n6) {
          if (t5 || u) {
            C3 = true;
            break;
          }
          if (f3 = this.tryMoveThroughCrossroadForward(f3, true), f3 === cr) {
            C3 = true;
            break;
          }
          x4 = this.m_topoGraph.getHalfEdgeTwin(f3);
        } else f3 = e3, x4 = n6;
        if (1 === this.m_topoGraph.getHalfEdgeUserIndex(f3, s3)) {
          b2 = true;
          break;
        }
        const r2 = this.getCombinedHalfEdgeParentage(f3);
        if (!this.isGoodParentage(r2)) break;
        S3 = f3, P5 += this.prevailingDirection(d2, f3);
      }
      const t4 = this.m_topoGraph.getHalfEdgeOrigin(E2);
      I4 = this.m_topoGraph.getHalfEdgeTo(S3) === t4;
    } else if (this.m_fromEdgeForPolylines !== cr) {
      E2 = e2, S3 = this.tryMoveThroughCrossroadBackwards(E2, false), n(S3 !== cr);
      const t4 = this.m_topoGraph.getHalfEdgeTwin(E2);
      this.m_topoGraph.getHalfEdgeNext(t4);
    }
    let w4 = I4;
    I4 || b2 || m3 && (w4 = this.isOnALoop(e2, s3), w4 || (w4 = this.isOnALoop(x4, s3)));
    const v3 = P5 >= 0;
    let N2 = false;
    w4 && C3 && (I4 ? (N2 = g2, v3 && (N2 || c || _) && E2 !== e2 && (n(!c), E2 = e2, N2 = false)) : (c || v3 && _) && (E2 = e2));
    let T3 = 0;
    for (f3 = E2; x4 = this.m_topoGraph.getHalfEdgeTwin(f3), this.m_topoGraph.setHalfEdgeUserIndex(f3, s3, 1), this.m_topoGraph.setHalfEdgeUserIndex(x4, s3, 1), T3++, f3 !== S3; ) f3 = u ? this.m_topoGraph.getHalfEdgeNext(f3) : this.tryMoveThroughCrossroadForward(f3, false);
    v3 || (S3 = Pt(E2, E2 = S3), S3 = this.m_topoGraph.getHalfEdgeTwin(S3), E2 = this.m_topoGraph.getHalfEdgeTwin(E2));
    let G4 = d2.insertPath(t3, cr);
    f3 = E2;
    const D3 = this.m_topoGraph.getHalfEdgeOrigin(E2);
    let V4;
    V4 = -1 !== i2 ? this.chooseVertexByOrder(D3, d2, i2, a2) : this.chooseVertexFromCluster_(D3, r), this.m_topoGraph.isStrongPathNode(D3) && d2.setStrongPathStart(G4, true);
    let H3 = d2.addVertex(G4, V4), k4 = H3;
    -1 !== n5 && this.m_topoGraph.setClusterUserIndex(D3, n5, 1);
    let A4 = 0;
    const U4 = N2 ? Math.trunc((T3 + 1) / 2) : -1;
    let q2 = cr, B4 = true, O3 = cr;
    for (; ; ) {
      if (p3) {
        const e4 = this.m_topoGraph.getSegmentParentage(f3), t4 = this.m_topoGraph.getHalfEdgeOrigin(f3);
        d2.setSegmentParentageAndBreak(k4, e4, B4 || this.m_topoGraph.isBreakNode(t4));
      }
      B4 = false, this.m_topoGraph.isHalfEdgeCurve(f3) && (this.m_topoGraph.querySegmentXY(f3, y2), d2.setSegmentToIndex(d2.getVertexIndex(k4), y2.get().clone())), q2 !== cr && -1 !== a2 && d2.addToUserIndex(q2, a2, -1);
      const e3 = u ? this.m_topoGraph.getHalfEdgeNext(f3) : this.tryMoveThroughCrossroadForward(f3, false), s4 = this.m_topoGraph.getHalfEdgeTo(f3);
      let o;
      if (o = -1 !== i2 ? this.chooseVertexByOrder(s4, d2, i2, a2) : this.chooseVertexFromCluster_(s4, r), H3 = d2.addVertex(G4, o), O3 = s4, -1 !== n5 && this.m_topoGraph.setClusterUserIndex(s4, n5, 1), p3 && this.m_topoGraph.isBreakNode(s4) && d2.setSegmentParentageBreakVertex(H3, true), q2 = o, A4++, N2 && A4 === U4 && (G4 = d2.insertPath(t3, cr), H3 = d2.addVertex(G4, o), B4 = true, -1 !== a2 && d2.addToUserIndex(o, a2, -1), q2 = cr), f3 === S3) break;
      f3 = e3, k4 = H3;
    }
    O3 !== cr && this.m_topoGraph.isStrongPathNode(O3) && d2.setStrongPathEnd(G4, true);
  }
  topoOperationPolylineSimplify_(e2, t3) {
    return this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(e2, cr, false, t3).first;
  }
  topoOperationPolylineSimplifyOrPolylineTopoHelper_(e2, t3, n5, r) {
    n(t3 === cr || e2 === cr);
    const i2 = this.m_topoGraph.getShape(), a2 = (t4) => t4 = e2 === cr ? t4 === cr ? i2.getFirstGeometry() : i2.getNextGeometry(t4) : t4 === cr ? e2 : cr, h2 = i2.createGeometry(a.enumPolyline);
    let m3 = -1;
    n5 && (m3 = this.m_topoGraph.createUserIndexForClusters());
    const l2 = this.m_topoGraph.createUserIndexForHalfEdges(), g2 = t3 === cr ? i2.createUserIndex() : -1, u = t3 === cr ? i2.createUserIndex() : -1;
    let c = -1;
    if (1 === r.unsplitBehavior) {
      c = this.m_topoGraph.createUserIndexForClusters();
      for (let e3 = a2(cr); e3 !== cr; e3 = a2(e3)) for (let t4 = i2.getFirstPath(e3); t4 !== cr; t4 = i2.getNextPath(t4)) {
        {
          const e4 = i2.getFirstVertex(t4), s3 = this.m_topoGraph.getClusterFromVertex(e4);
          this.m_topoGraph.setClusterUserIndex(s3, c, 1);
        }
        if (!i2.isClosedPath(t4)) {
          const e4 = i2.getLastVertex(t4), s3 = this.m_topoGraph.getClusterFromVertex(e4);
          this.m_topoGraph.setClusterUserIndex(s3, c, 1);
        }
      }
    }
    if (t3 === cr) {
      let e3 = 0;
      for (let t4 = a2(cr); t4 !== cr; t4 = a2(t4)) for (let s3 = i2.getFirstPath(t4); s3 !== cr; s3 = i2.getNextPath(s3)) {
        if (i2.isClosedPath(s3)) {
          let t5 = i2.getFirstVertex(s3);
          for (let n6 = 0, r2 = i2.getPathSize(s3); n6 < r2; n6++, t5 = i2.getNextVertex(t5)) i2.setUserIndex(t5, g2, e3++), i2.setUserIndex(t5, u, 2);
        } else {
          const t5 = i2.getFirstVertex(s3);
          i2.setUserIndex(t5, g2, e3++), i2.setUserIndex(t5, u, 1);
          let n6 = i2.getNextVertex(t5);
          for (let r2 = 1, o = i2.getPathSize(s3) - 1; r2 < o; ++r2) i2.setUserIndex(n6, g2, e3++), i2.setUserIndex(n6, u, 2), n6 = i2.getNextVertex(n6);
          i2.setUserIndex(n6, g2, e3++), i2.setUserIndex(n6, u, 1);
        }
      }
    }
    for (let s3 = a2(cr); s3 !== cr; s3 = a2(s3)) for (let e3 = i2.getFirstPath(s3); e3 !== cr; e3 = i2.getNextPath(e3)) {
      let s4 = i2.getFirstVertex(e3);
      for (let n6 = 0, o = i2.getPathSize(e3); n6 < o; n6++, s4 = i2.getNextVertex(s4)) {
        const e4 = this.m_topoGraph.getHalfEdgeFromVertex(s4);
        if (e4 === cr) continue;
        if (1 === this.m_topoGraph.getHalfEdgeUserIndex(e4, l2)) continue;
        const i3 = this.getCombinedHalfEdgeParentage(e4);
        if (this.isGoodParentage(i3)) {
          const s5 = 0 === n6;
          this.restorePolylineParts(e4, h2, l2, m3, t3, g2, u, c, s5, r);
        }
      }
    }
    let _ = cr;
    if (n5) {
      _ = i2.createGeometry(a.enumMultiPoint);
      let e3 = cr;
      for (let s3 = this.m_topoGraph.getFirstCluster(); s3 !== cr; s3 = this.m_topoGraph.getNextCluster(s3)) {
        this.progress_();
        if (1 !== this.m_topoGraph.getClusterUserIndex(s3, m3)) {
          const n6 = this.m_topoGraph.getClusterParentage(s3);
          if (this.isGoodParentage(n6)) {
            e3 === cr && (e3 = i2.insertPath(_, cr));
            const n7 = this.m_topoGraph.getClusterVertexIterator(s3);
            if (n7 !== cr) {
              let r2;
              this.m_topoGraph.getVertexFromVertexIterator(n7), r2 = -1 !== g2 ? this.chooseVertexByOrder(s3, i2, g2, u) : this.chooseVertexFromCluster_(s3, t3), i2.addVertex(e3, r2);
            }
          }
        }
      }
    }
    return -1 !== u && i2.removeUserIndex(u), -1 !== g2 && i2.removeUserIndex(g2), -1 !== m3 && i2.removeUserIndex(m3), this.m_topoGraph.deleteUserIndexForHalfEdges(l2), $t(h2, _);
  }
  difference(e2, t3) {
    const s3 = this.m_topoGraph.getShape().getGeometryType(e2), n5 = this.m_topoGraph.getShape().getGeometryType(t3), i2 = m(s3), o = m(n5);
    if (i2 > o) return e2;
    const a2 = this.m_topoGraph.getGeometryID(e2), m3 = this.m_topoGraph.getGeometryID(t3);
    if (this.m_maskLookup.length = 0, this.m_maskLookup.length = 1 + (a2 | m3), this.m_maskLookup[a2] = true, 2 === i2 && 2 === o) {
      let s4 = cr;
      return this.m_topoGraph.getShape().getVertexDescription().getAttributeCount() > 1 && (s4 = e2), this.topoOperationPolygonPolygon_(e2, t3, s4);
    }
    if (1 === i2 && 2 === o) {
      const t4 = Ha2();
      return t4.allCrossRoadsImpassable = false, t4.ogcRule = this.m_bOGCOutput, t4.unsplitBehavior = 0, this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(e2, cr, false, t4).first;
    }
    if (1 === i2 && 1 === o) {
      const t4 = Ha2();
      return t4.allCrossRoadsImpassable = true, t4.ogcRule = this.m_bOGCOutput, t4.unsplitBehavior = 0, this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(e2, cr, false, t4).first;
    }
    if (0 === i2) return this.topoOperationMultiPoint_();
    b("");
  }
  symmetricDifference(e2, t3) {
    const s3 = this.m_topoGraph.getShape().getGeometryType(e2), n5 = this.m_topoGraph.getShape().getGeometryType(t3), i2 = Va2(s3), a2 = Va2(n5), h2 = this.m_topoGraph.getGeometryID(e2), m3 = this.m_topoGraph.getGeometryID(t3);
    return n(h2 >= 0), n(m3 >= 0), this.m_maskLookup.length = 0, this.m_maskLookup.length = 1 + (h2 | m3), this.m_maskLookup[h2] = true, this.m_maskLookup[h2] = true, this.m_maskLookup[m3] = true, 2 === i2 && 2 === a2 ? this.topoOperationPolygonPolygon_(e2, t3, cr) : 1 === i2 && 1 === a2 ? this.topoOperationPolyline_(cr, this.m_bOGCOutput) : 0 === i2 && 0 === a2 ? this.topoOperationMultiPoint() : void b("");
  }
  planarSimplifyNoCrackingAndCluster(e2, t3, n5, i2) {
    this.m_bOGCOutput = e2, this.m_topoGraph = new tn2();
    const a2 = t3.getFillRule(n5), h2 = t3.getGeometryType(n5);
    if (1 !== a2 || h2 === a.enumMultiPoint ? this.m_topoGraph.setAndSimplifyEditShapeAlternate(t3, n5, this.m_progressTracker) : this.m_topoGraph.setAndSimplifyEditShapeWinding(t3, n5, this.m_progressTracker), this.m_topoGraph.dirtyCheckFailed()) return false;
    this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);
    const m3 = this.m_topoGraph.getGeometryID(n5);
    if (n(m3 >= 0), this.m_maskLookup.length = 0, this.m_maskLookup.length = m3 + 1, this.m_maskLookup[m3] = true, t3.getGeometryType(n5) === a.enumPolygon || 1 === a2 && t3.getGeometryType(n5) !== a.enumMultiPoint) {
      t3.setFillRule(n5, 0);
      const s3 = this.topoOperationPolygonPolygon_(n5, cr, cr);
      if (t3.swapGeometry(s3, n5), t3.removeGeometry(s3), 1 === a2 && this.m_bOGCOutput) return this.planarSimplifyNoCrackingAndCluster(e2, t3, n5, i2);
    } else if (t3.getGeometryType(n5) === a.enumPolyline) {
      const e3 = Ha2();
      e3.ogcRule = this.m_bOGCOutput, e3.allCrossRoadsImpassable = true, e3.unsplitBehavior = i2;
      const s3 = this.topoOperationPolylineSimplify_(t3.getFirstGeometry(), e3);
      t3.swapGeometry(s3, n5), t3.removeGeometry(s3);
    } else if (t3.getGeometryType(n5) === a.enumMultiPoint) {
      const e3 = this.topoOperationMultiPoint_();
      t3.swapGeometry(e3, n5), t3.removeGeometry(e3);
    } else b("");
    return true;
  }
  unsplitPolylineExact(e2) {
    return n(0), new Os2();
  }
  planarSimplifyPolylines(e2, t3, n5, r, i2) {
    for (let _ = e2.getFirstGeometry(); _ !== cr; _ = e2.getNextGeometry(_)) {
      const t4 = e2.getGeometryType(_);
      n(t4 === a.enumPolyline);
    }
    let a2 = 0, h2 = 0, m3 = null;
    if (e2.hasCurves() && !e2.hasSegmentParentage()) {
      m3 = new fa2();
      const s3 = e2.getEnvelope2D(this.m_progressTracker);
      h2 = da2(t3.total());
      const n6 = _a2(t3.total(), s3);
      a2 = pa2(n6, h2), aa2(e2, n6, t3.total(), 12e3, m3, null, this.m_progressTracker);
    }
    {
      const s3 = Ia2(t3.add(a2));
      e2.filterClosePoints(s3, false, false, false, cr);
    }
    if (this.m_topoGraph = new tn2(), 4 !== i2 && 5 !== i2) if (null === m3 && n5) {
      const s3 = new Dn2(this.m_progressTracker, false);
      s3.sweepVertical(e2, t3.total()), s3.hadComplications() ? (ya2(e2, t3, this.m_progressTracker, true, false), n5 = false) : this.m_topoGraph.setCheckDirtyPlanesweepTolerance(t3.total());
    } else ya2(e2, t3.add(a2), this.m_progressTracker, true, false), n5 = false;
    else n5 = false;
    e2.removeSelection(), e2.collapseAllGeometriesToFirst();
    const l2 = e2.getFirstGeometry();
    if (this.m_topoGraph.setAndSimplifyEditShapeAlternate(e2, l2, this.m_progressTracker), this.m_topoGraph.dirtyCheckFailed()) return n(n5 && null === m3), this.m_topoGraph.removeShape(), this.m_topoGraph = null, this.planarSimplifyPolylines(e2, t3, false, r, -1);
    this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);
    const g2 = this.m_topoGraph.getGeometryID(l2);
    n(g2 >= 0), this.m_maskLookup.length = 0, this.m_maskLookup.length = g2 + 1, this.m_maskLookup[g2] = true;
    const u = this.topoOperationPolylineSimplify_(e2.getFirstGeometry(), r);
    null !== m3 && m3.stitchCurves(e2, u, h2, true);
    const c = e2.getGeometry(u);
    return n5 || c.getImpl().setIsSimple(4, t3.total()), c;
  }
  planarSimplifyMultiPoints(e2, t3, n5, r) {
    for (let l2 = e2.getFirstGeometry(); l2 !== cr; l2 = e2.getNextGeometry(l2)) {
      const t4 = e2.getGeometryType(l2);
      n(t4 === a.enumMultiPoint);
    }
    this.m_topoGraph = new tn2(), 4 !== r && 5 !== r ? (ya2(e2, t3, this.m_progressTracker, true, false), n5 = false) : n5 = false, e2.removeSelection(), e2.collapseAllGeometriesToFirst();
    const i2 = e2.getFirstGeometry();
    if (this.m_topoGraph.setAndSimplifyEditShapeAlternate(e2, i2, this.m_progressTracker), this.m_topoGraph.dirtyCheckFailed()) return n(n5), this.m_topoGraph.removeShape(), this.m_topoGraph = null, this.planarSimplifyMultiPoints(e2, t3, false, -1);
    this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);
    const a2 = this.m_topoGraph.getGeometryID(i2);
    n(a2 >= 0), this.m_maskLookup.length = 0, this.m_maskLookup.length = a2 + 1, this.m_maskLookup[a2] = true;
    const h2 = this.topoOperationMultiPoint(), m3 = e2.getGeometry(h2);
    return n5 || m3.getImpl().setIsSimple(4, t3.total()), m3;
  }
  planarSimplifyPolygons(e2, t3, n5, r, i2, a2) {
    for (let f3 = e2.getFirstGeometry(); f3 !== cr; f3 = e2.getNextGeometry(f3)) {
      const t4 = e2.getGeometryType(f3);
      n(t4 === a.enumPolygon || t4 === a.enumPolyline && n5);
    }
    let h2 = 0, m3 = 0, l2 = null;
    if (e2.hasCurves() && !e2.hasSegmentParentage()) {
      l2 = new fa2();
      const s3 = e2.getEnvelope2D(this.m_progressTracker);
      m3 = da2(t3.total());
      const n6 = _a2(t3.total(), s3);
      h2 = pa2(n6, m3), aa2(e2, n6, t3.total(), 12e3, l2, null, this.m_progressTracker);
    }
    if (a2) {
      ya2(e2, t3.add(h2), this.m_progressTracker, true, false);
      for (let t4 = e2.getFirstGeometry(); t4 !== cr; t4 = e2.getNextGeometry(t4)) e2.getGeometryType(t4) === a.enumPolygon && er2(e2, t4, -1, false, cr, this.m_progressTracker);
    }
    if (this.m_topoGraph = new tn2(), a2 || 4 === i2 || 5 === i2) r = false;
    else if (null === l2 && r) {
      const s3 = new Dn2(this.m_progressTracker, false);
      s3.sweepVertical(e2, t3.total()), s3.hadComplications() ? (ya2(e2, t3, this.m_progressTracker, true, false), r = false) : this.m_topoGraph.setCheckDirtyPlanesweepTolerance(t3.total());
    } else ya2(e2, t3.add(h2), this.m_progressTracker, true, false), r = false;
    e2.removeSelection(), e2.collapseAllGeometriesToFirst();
    const g2 = e2.getFirstGeometry();
    if (n5 ? this.m_topoGraph.setAndSimplifyEditShapeWinding(e2, g2, this.m_progressTracker) : this.m_topoGraph.setAndSimplifyEditShapeAlternate(e2, g2, this.m_progressTracker), this.m_topoGraph.dirtyCheckFailed()) return n(r && null === l2), this.m_topoGraph.removeShape(), this.m_topoGraph = null, this.planarSimplifyPolygons(e2, t3, n5, false, -1, false);
    this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);
    const u = this.m_topoGraph.getGeometryID(g2);
    n(u >= 0), this.m_maskLookup.length = 0, this.m_maskLookup.length = u + 1, this.m_maskLookup[u] = true, e2.setFillRule(g2, 0);
    const c = this.m_bOGCOutput && n5, _ = c;
    let d2 = this.topoOperationPolygonPolygon_(g2, cr, cr, _);
    if (c) {
      this.m_topoGraph.removeShape(), this.m_topoGraph = null, e2.removeGeometry(g2), this.m_topoGraph = new tn2(), this.m_topoGraph.setAndSimplifyEditShapeAlternate(e2, d2, this.m_progressTracker);
      d2 = this.topoOperationPolygonPolygon_(d2, cr, cr, false);
    }
    null !== l2 && l2.stitchCurves(e2, d2, m3, true);
    const p3 = e2.getGeometry(d2);
    return p3.setFillRule(0), r ? p3.getImpl().setIsSimple(3, 0) : (p3.getImpl().setIsSimple(4, t3.total()), p3.getImpl().updateOGCFlagsProtected()), p3;
  }
  planarSimplify3DImpl_(e2, t3, s3, n5, r) {
    return n(0), {};
  }
  planarSimplifyImpl_(e2, t3, n5, i2, o, a2, h2, m3) {
    if (e2.isEmpty()) return e2.clone();
    const l2 = e2.getGeometryType(), g2 = new Pr(), u = g2.addGeometry(e2);
    if (Ht2(o) && l2 === a.enumPolygon && (n5 = false, g2.setFillRule(u, 0)), m3 && (e2.hasAttribute(1) && g2.replaceNaNs(1, 0), g2.removeNaNVertices()), l2 === a.enumPolygon || l2 === a.enumPolyline && n5) return this.planarSimplifyPolygons(g2, t3, n5, i2, o, false);
    if (l2 === Os2.type) {
      const e3 = Ha2();
      return e3.allCrossRoadsImpassable = true, e3.ogcRule = this.m_bOGCOutput, e3.unsplitBehavior = h2, this.planarSimplifyPolylines(g2, t3, i2, e3, o);
    }
    if (l2 === a.enumMultiPoint) return this.planarSimplifyMultiPoints(g2, t3, i2, o);
    b("what else?");
  }
};
function Qa2(e2, t3, s3, n5) {
  if (e2.isEmpty()) return e2.createInstance();
  if (t3.isEmpty()) return n5 ? e2.createInstance() : new ee({ copy: e2 });
  const i2 = [new mi()], o = [0], a2 = 2 === t3.getDimension();
  return 1 !== t3.getDimension() && 2 !== t3.getDimension() && b(""), i2[0] = e2.getXY(), a2 ? Wo2(t3, i2, 1, s3.total(), o) : jo2(t3, i2, 1, s3.total(), o), 0 === o[0] ? e2.createInstance() : e2;
}
function Ja2(e2, t3, s3, n5) {
  const i2 = e2.createInstance(), o = Ot(mi, 100), a2 = new Array(100), h2 = e2.getPointCount();
  let m3 = true;
  const l2 = 2 === t3.getDimension();
  1 !== t3.getDimension() && 2 !== t3.getDimension() && b("");
  for (let r = 0; r < h2; ) {
    const n6 = e2.queryCoordinates(o, o.length, r, -1) - r;
    l2 ? Wo2(t3, o, n6, s3.total(), a2) : jo2(t3, o, n6, s3.total(), a2);
    let h3 = 0;
    for (let t4 = 0; t4 < n6; t4++) {
      0 === a2[t4] && (m3 && (m3 = false, i2.addPoints(e2, 0, r)), h3 !== t4 && i2.addPoints(e2, r + h3, r + t4), h3 = t4 + 1);
    }
    m3 || h3 === n6 || i2.addPoints(e2, r + h3, r + n6), r += n6;
  }
  return m3 ? e2 : i2;
}
function $a2(e2, t3, n5, r) {
  const i2 = e2.getGeometryType();
  if (i2 === a.enumEnvelope) {
    const t4 = new ur({ vd: e2.getDescription() });
    return e2.isEmpty() || t4.addEnvelope(e2, false), t4;
  }
  if (i2 === a.enumPoint && ("|" === r || "^" === r)) {
    const t4 = new cs2({ vd: e2.getDescription() });
    return e2.isEmpty() || t4.add(e2), t4;
  }
  if (i2 === a.enumLine) {
    const t4 = new Os2({ vd: e2.getDescription() });
    return e2.isEmpty() || t4.addSegment(e2, true), t4;
  }
  if (i2 === a.enumMultiPoint && "-" === r && t3.getGeometryType() === a.enumPoint) {
    const t4 = new ee({ vd: e2.getDescription() });
    return e2.isEmpty() || e2.getPointByVal(0, t4), t4;
  }
  if (i2 === a.enumMultiPoint && "&" === r && t3.getGeometryType() === a.enumPoint) {
    const t4 = new ee({ vd: e2.getDescription() });
    return e2.isEmpty() || e2.getPointByVal(0, t4), t4;
  }
  return e2;
}
function eh2(t3) {
  const n5 = t3.getGeometryType();
  if (n5 === a.enumEnvelope) {
    const e2 = new ur({ vd: t3.getDescription() });
    return t3.isEmpty() || e2.addEnvelope(t3, false), e2;
  }
  if (n5 === a.enumPoint) {
    const e2 = new cs2({ vd: t3.getDescription() });
    return t3.isEmpty() || e2.add(t3), e2;
  }
  if (Da2(n5)) {
    const e2 = new Os2({ vd: t3.getDescription() });
    return t3.isEmpty() || e2.addSegment(t3, true), e2;
  }
  return n5 !== a.enumMultiPoint && n5 !== a.enumPolyline && n5 !== a.enumPolygon && P("Unexpected geometry type"), t3;
}
function th2(e2, t3, s3, n5) {
  const r = s3 === cr ? e2.getClusterHalfEdge(t3) : s3;
  let i2 = r;
  n(e2.getHalfEdgeOrigin(r) === t3);
  do {
    n5(i2), i2 = e2.getHalfEdgeNext(e2.getHalfEdgeTwin(i2));
  } while (i2 !== r);
}
var sh2 = class {
  constructor(e2, t3, s3, n5, r, i2) {
    this.m_rParent = e2, this.m_rTopoGraph = e2.m_topoGraph, this.m_rShape = this.m_rTopoGraph.getShape(), this.m_IDCuttee = this.m_rTopoGraph.getGeometryID(n5), this.m_IDCutter = this.m_rTopoGraph.getGeometryID(r), this.m_IDBoth = this.m_IDCuttee | this.m_IDCutter, this.m_bConsiderTouch = t3, this.m_sideIndex = s3, this.m_cuttee = n5, this.m_cutter = r, this.m_rCutHandles = i2, this.m_cutteeBreadcrumbsIndex = this.m_rShape.createUserIndexUninitialized(), this.m_clusterParentageIndex = this.m_rShape.createUserIndexUninitialized();
    for (let o = this.m_rShape.getFirstPath(this.m_cuttee); o !== cr; o = this.m_rShape.getNextPath(o)) {
      let e3 = 0;
      const t4 = this.m_rShape.getPathSize(o);
      for (let s4 = this.m_rShape.getFirstVertex(o); e3 < t4; e3++, s4 = this.m_rShape.getNextVertex(s4)) this.m_rShape.setUserIndex(s4, this.m_clusterParentageIndex, this.m_rTopoGraph.getClusterParentage(this.m_rTopoGraph.getClusterFromVertex(s4)));
    }
  }
  Do() {
    this.cutPolylinePolyline_(), this.m_rShape.removeUserIndex(this.m_cutteeBreadcrumbsIndex), this.m_rShape.removeUserIndex(this.m_clusterParentageIndex);
  }
  setTbd(e2) {
    return 8 | e2;
  }
  classifyStandardCut(e2, t3, s3, n5) {
    const r = this.m_rShape.getPrevVertex(e2), i2 = this.m_rShape.getNextVertex(e2), o = r === cr ? cr : this.m_rTopoGraph.getHalfEdgeConnector(t3, this.m_rTopoGraph.getClusterFromVertex(r)), a2 = i2 === cr ? cr : this.m_rTopoGraph.getHalfEdgeConnector(t3, this.m_rTopoGraph.getClusterFromVertex(i2)), h2 = this.m_rTopoGraph.getHalfEdgeConnector(t3, this.m_rTopoGraph.getClusterFromVertex(s3)), m3 = this.m_rTopoGraph.getHalfEdgeConnector(t3, this.m_rTopoGraph.getClusterFromVertex(n5));
    let l2 = 1, g2 = 32, u = 32;
    if (th2(this.m_rTopoGraph, t3, m3, (e3) => {
      e3 === h2 && (l2 = 2), e3 === o && (g2 = l2), e3 === a2 && (u = l2);
    }), this.m_bConsiderTouch) 32 !== g2 && this.m_rShape.setUserIndex(r, this.m_cutteeBreadcrumbsIndex, this.m_rShape.getUserIndex(r, this.m_cutteeBreadcrumbsIndex) | g2), 32 !== u && this.m_rShape.setUserIndex(e2, this.m_cutteeBreadcrumbsIndex, this.m_rShape.getUserIndex(e2, this.m_cutteeBreadcrumbsIndex) | u);
    else {
      if (32 === g2 || 32 === u) return 1;
      if (g2 === u && !(o === h2 || o === m3 || a2 === h2 || a2 === m3)) return 1;
      this.m_rShape.setUserIndex(r, this.m_cutteeBreadcrumbsIndex, this.m_rShape.getUserIndex(r, this.m_cutteeBreadcrumbsIndex) | g2), this.m_rShape.setUserIndex(e2, this.m_cutteeBreadcrumbsIndex, this.m_rShape.getUserIndex(e2, this.m_cutteeBreadcrumbsIndex) | u);
    }
    return 0;
  }
  classifyTouchCut(e2, t3, s3, n5) {
    const r = this.m_rShape.getPrevVertex(e2), i2 = this.m_rShape.getNextVertex(e2), o = r === cr ? cr : this.m_rTopoGraph.getHalfEdgeConnector(t3, this.m_rTopoGraph.getClusterFromVertex(r)), a2 = i2 === cr ? cr : this.m_rTopoGraph.getHalfEdgeConnector(t3, this.m_rTopoGraph.getClusterFromVertex(i2)), h2 = s3 === cr ? cr : this.m_rTopoGraph.getHalfEdgeConnector(t3, this.m_rTopoGraph.getClusterFromVertex(s3)), m3 = n5 === cr ? cr : this.m_rTopoGraph.getHalfEdgeConnector(t3, this.m_rTopoGraph.getClusterFromVertex(n5));
    if (!this.m_bConsiderTouch) {
      let t4;
      return (t4 = h2 === o || m3 === o) ? this.m_rShape.setUserIndex(e2, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(e2, this.m_cutteeBreadcrumbsIndex))) : (t4 = h2 === a2 || m3 === a2) && this.m_rShape.setUserIndex(r, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(r, this.m_cutteeBreadcrumbsIndex))), t4 ? 0 : 1;
    }
    if (o === cr) return this.m_rShape.setUserIndex(e2, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(e2, this.m_cutteeBreadcrumbsIndex))), 0;
    if (a2 === cr) return this.m_rShape.setUserIndex(r, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(r, this.m_cutteeBreadcrumbsIndex))), 0;
    if (o === a2) return this.m_rShape.setUserIndex(r, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(r, this.m_cutteeBreadcrumbsIndex))), this.m_rShape.setUserIndex(e2, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(e2, this.m_cutteeBreadcrumbsIndex))), 0;
    if (m3 !== cr) {
      if (o === m3) return this.m_rShape.setUserIndex(e2, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(e2, this.m_cutteeBreadcrumbsIndex))), 0;
      if (a2 === m3) return this.m_rShape.setUserIndex(r, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(r, this.m_cutteeBreadcrumbsIndex))), 0;
      let s4 = 1;
      th2(this.m_rTopoGraph, t3, m3, (t4) => {
        if (t4 === o) {
          const e3 = this.m_rShape.getUserIndex(r, this.m_cutteeBreadcrumbsIndex) | s4;
          this.m_rShape.setUserIndex(r, this.m_cutteeBreadcrumbsIndex, e3), s4 = 2;
        } else if (t4 === a2) {
          const t5 = this.m_rShape.getUserIndex(e2, this.m_cutteeBreadcrumbsIndex) | s4;
          this.m_rShape.setUserIndex(e2, this.m_cutteeBreadcrumbsIndex, t5), s4 = 2;
        }
      });
    } else {
      if (o === h2) return this.m_rShape.setUserIndex(e2, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(e2, this.m_cutteeBreadcrumbsIndex))), 0;
      if (a2 === h2) return this.m_rShape.setUserIndex(r, this.m_cutteeBreadcrumbsIndex, this.setTbd(this.m_rShape.getUserIndex(r, this.m_cutteeBreadcrumbsIndex))), 0;
      let s4 = 2;
      th2(this.m_rTopoGraph, t3, h2, (t4) => {
        if (t4 === o) {
          const e3 = this.m_rShape.getUserIndex(r, this.m_cutteeBreadcrumbsIndex) | s4;
          this.m_rShape.setUserIndex(r, this.m_cutteeBreadcrumbsIndex, e3), s4 = 1;
        } else if (t4 === a2) {
          const t5 = this.m_rShape.getUserIndex(e2, this.m_cutteeBreadcrumbsIndex) | s4;
          this.m_rShape.setUserIndex(e2, this.m_cutteeBreadcrumbsIndex, t5), s4 = 1;
        }
      });
    }
    return 0;
  }
  classifyCutVertex(e2, t3) {
    let s3 = 0, n5 = 0;
    for (let r = this.m_rTopoGraph.getClusterVertexIterator(t3); r !== cr; r = this.m_rTopoGraph.incrementVertexIterator(r)) {
      const i2 = this.m_rTopoGraph.getVertexFromVertexIterator(r);
      if (this.m_rShape.getGeometryFromVertex(i2) === this.m_cutter) {
        n5++;
        const r2 = this.m_rShape.getPrevVertex(i2), o = this.m_rShape.getNextVertex(i2);
        s3 += r2 === cr || o === cr ? this.classifyTouchCut(e2, t3, r2, o) : this.classifyStandardCut(e2, t3, r2, o);
      }
    }
    n5 && s3 === n5 && !this.m_bConsiderTouch && this.m_rShape.setUserIndex(e2, this.m_clusterParentageIndex, this.m_IDCuttee);
  }
  cutPolylinePolyline_() {
    this.m_rShape.getGeometryType(this.m_cuttee), this.m_rShape.getGeometryType(this.m_cutter), this.m_rParent.m_maskLookup.length = 0, this.m_rParent.m_maskLookup.length = this.m_IDBoth + 1, this.m_rParent.m_maskLookup[this.m_IDBoth] = true;
    for (let s3 = this.m_rShape.getFirstPath(this.m_cuttee); s3 !== cr; s3 = this.m_rShape.getNextPath(s3)) {
      const e3 = this.m_rShape.getPathSize(s3);
      let t4 = this.m_rShape.getFirstVertex(s3);
      for (let s4 = 0; s4 < e3; ++s4, t4 = this.m_rShape.getNextVertex(t4)) this.m_rShape.setUserIndex(t4, this.m_cutteeBreadcrumbsIndex, 0);
      t4 = this.m_rShape.getFirstVertex(s3);
      for (let s4 = 0; s4 < e3; ++s4, t4 = this.m_rShape.getNextVertex(t4)) {
        const e4 = this.m_rTopoGraph.getClusterFromVertex(t4);
        this.m_rTopoGraph.getClusterParentage(e4) === this.m_IDBoth && this.classifyCutVertex(t4, e4);
      }
    }
    const e2 = (e3, t4) => {
      let s3 = this.m_rShape.getUserIndex(e3, this.m_cutteeBreadcrumbsIndex);
      const n6 = this.m_rTopoGraph.getHalfEdgeConnector(this.m_rTopoGraph.getClusterFromVertex(e3), this.m_rTopoGraph.getClusterFromVertex(t4));
      return (this.m_rTopoGraph.getHalfEdgeParentage(n6) & this.m_IDBoth) === this.m_IDBoth && (s3 |= 4), s3;
    };
    for (let s3 = this.m_rShape.getFirstPath(this.m_cuttee); s3 !== cr; s3 = this.m_rShape.getNextPath(s3)) {
      let t4 = this.m_rShape.getFirstVertex(s3);
      const n6 = this.m_rShape.isClosedPath(s3), r2 = this.m_rShape.getPathSize(s3) + (n6 ? 1 : 0);
      let i3 = 1, o2 = 32;
      for (let s4 = this.m_rShape.getNextVertex(t4); i3 < r2; ++i3, t4 = s4, s4 = this.m_rShape.getNextVertex(s4)) {
        const n7 = e2(t4, s4);
        this.m_rShape.getUserIndex(t4, this.m_clusterParentageIndex) === this.m_IDBoth && (o2 = n7), 32 !== o2 && this.m_rShape.setUserIndex(t4, this.m_cutteeBreadcrumbsIndex, o2 | n7);
      }
      t4 = this.m_rShape.getLastVertex(s3);
      let a2 = 32;
      i3 = 1;
      for (let s4 = this.m_rShape.getPrevVertex(t4); i3 < r2; ++i3, t4 = s4, s4 = this.m_rShape.getPrevVertex(s4)) {
        const n7 = e2(s4, t4);
        this.m_rShape.getUserIndex(t4, this.m_clusterParentageIndex) === this.m_IDBoth && (a2 = n7), 32 !== a2 && this.m_rShape.setUserIndex(s4, this.m_cutteeBreadcrumbsIndex, a2 | n7);
      }
    }
    let t3 = cr, n5 = cr, r = 32;
    const i2 = this.m_rShape.hasSegmentParentage(), o = new fm();
    for (let a2 = this.m_rShape.getFirstPath(this.m_cuttee); a2 !== cr; a2 = this.m_rShape.getNextPath(a2)) {
      const e3 = this.m_rShape.isClosedPath(a2), h2 = this.m_rShape.getPathSize(a2) + (e3 ? 1 : 0);
      let m3 = 1, l2 = this.m_rShape.getFirstVertex(a2), g2 = cr, u = true;
      for (let a3 = this.m_rShape.getNextVertex(l2); m3 < h2; ++m3, a3 = this.m_rShape.getNextVertex(a3)) {
        let e4 = this.m_rShape.getUserIndex(l2, this.m_cutteeBreadcrumbsIndex);
        8 === e4 ? e4 = 3 : (e4 &= -9, 4 & e4 ? e4 = 4 : 3 & ~e4 || (e4 = 3)), e4 !== r ? (t3 !== cr && (g2 = this.m_rShape.addVertex(n5, l2), i2 && this.m_rTopoGraph.isBreakNode(this.m_rTopoGraph.getClusterFromVertex(l2)) && this.m_rShape.setSegmentParentageBreakVertex(g2, true), this.m_rCutHandles.push(t3), this.m_rShape.setGeometryUserIndex(t3, this.m_sideIndex, r)), t3 = this.m_rShape.createGeometry(a.enumPolyline), n5 = this.m_rShape.insertPath(t3, cr), r = e4, u = true) : this.m_rShape.getUserIndex(l2, this.m_clusterParentageIndex) === this.m_IDBoth && 4 !== e4 && (g2 = this.m_rShape.addVertex(n5, l2), i2 && this.m_rTopoGraph.isBreakNode(this.m_rTopoGraph.getClusterFromVertex(l2)) && this.m_rShape.setSegmentParentageBreakVertex(g2, true), n5 = this.m_rShape.insertPath(t3, cr), u = true), g2 = this.m_rShape.addVertex(n5, l2);
        const h3 = this.m_rTopoGraph.getClusterFromVertex(l2);
        !u && i2 && this.m_rTopoGraph.isBreakNode(h3) && this.m_rShape.setSegmentParentageBreakVertex(g2, true);
        const m4 = this.m_rTopoGraph.getHalfEdgeFromVertex(l2);
        if (i2) {
          const e5 = this.m_rTopoGraph.getSegmentParentage(m4);
          this.m_rShape.setSegmentParentageAndBreak(g2, e5, u || this.m_rTopoGraph.isBreakNode(h3));
        }
        this.m_rTopoGraph.isHalfEdgeCurve(m4) && (this.m_rTopoGraph.querySegmentXY(m4, o), this.m_rShape.setSegmentToIndex(this.m_rShape.getVertexIndex(g2), o.get().clone())), l2 = a3, u = false;
      }
      g2 = this.m_rShape.addVertex(n5, l2), i2 && this.m_rTopoGraph.isBreakNode(this.m_rTopoGraph.getClusterFromVertex(l2)) && this.m_rShape.setSegmentParentageBreakVertex(g2, true), this.m_rCutHandles.push(t3), this.m_rShape.setGeometryUserIndex(t3, this.m_sideIndex, r), t3 = cr, n5 = cr, r = 32;
    }
  }
};
function rh2(e2, t3, i2, o, a2) {
  if (o && (o.m_reason = 0, o.m_vertexIndex1 = -1, o.m_vertexIndex2 = -1), e2.isEmpty()) return 5;
  const h2 = e2.getGeometryType();
  if (h2 === a.enumPoint) return mh2(e2, o);
  const m3 = Bt2(t3, e2, false).total();
  if (h2 === a.enumEnvelope) {
    const t4 = e2, s3 = new n3();
    return t4.queryEnvelope(s3), s3.isDegenerate(m3) ? (o && (o.m_reason = 4, o.m_vertexIndex1 = -1, o.m_vertexIndex2 = -1), 0) : 5;
  }
  if (f(h2)) {
    const s3 = e2, n5 = new Os2({ vd: s3.getDescription() });
    return n5.addSegment(s3, true), oh2(n5, t3, i2, o, a2);
  }
  const l2 = [0], g2 = e2.getImpl().getIsSimple(m3, l2);
  let u = i2 ? -1 : g2;
  if (Ot2(u) || 0 === u) return u;
  const c = new Ph2(e2, t3, u, a2, false);
  h2 === a.enumMultiPoint || h2 === a.enumPolyline || h2 === a.enumPolygon ? u = c.isSimplePlanarImpl() : b("");
  return e2.getImpl().setIsSimple(u, m3), o && o.assign(c.m_nonSimpleResult), u;
}
function ih2(e2, t3, i2, o, a2) {
  if (o && (o.m_reason = 0, o.m_vertexIndex1 = -1, o.m_vertexIndex2 = -1), e2.isEmpty()) return 5;
  const h2 = e2.getGeometryType();
  if (h2 === a.enumPoint) return mh2(e2, o);
  const m3 = Bt2(t3, e2, false).total();
  if (h2 === a.enumEnvelope) {
    const t4 = e2, s3 = new n3();
    return t4.queryEnvelope(s3), s3.isDegenerate(m3) ? (o && (o.m_reason = 4, o.m_vertexIndex1 = -1, o.m_vertexIndex2 = -1), 0) : 5;
  }
  if (f(h2)) {
    const s3 = e2, n5 = new Os2({ vd: s3.getDescription() });
    return n5.addSegment(s3, true), ih2(n5, t3, i2, o, a2);
  }
  I(h2), y(h2) || z("OGC simplify is not implemented for this geometry type");
  const l2 = [0], u = e2.getImpl().getIsSimple(m3, l2);
  let c = i2 ? -1 : u;
  if (5 === c || 0 === c) return c;
  const d2 = new Ph2(e2, t3, c, a2, true);
  h2 === a.enumMultiPoint || h2 === a.enumPolyline || h2 === a.enumPolygon ? (c = d2.isSimplePlanarImpl(), Ot2(c) && (c = 5)) : b("");
  return e2.getImpl().setIsSimple(c, m3), o && o.assign(d2.m_nonSimpleResult), c;
}
function oh2(e2, t3, i2, o, a2) {
  if (o && (o.m_reason = 0, o.m_vertexIndex1 = -1, o.m_vertexIndex2 = -1), e2.isEmpty()) return 5;
  const h2 = e2.getGeometryType();
  if (h2 === a.enumPoint) return mh2(e2, o);
  const m3 = Bt2(t3, e2, false).total();
  if (h2 === a.enumEnvelope) {
    const t4 = e2, s3 = n3.constructEmpty();
    return t4.queryEnvelope(s3), s3.isDegenerate(m3) ? (o && (o.m_reason = 4, o.m_vertexIndex1 = -1, o.m_vertexIndex2 = -1), 0) : 5;
  }
  if (f(h2)) {
    const s3 = e2, n5 = new Os2({ vd: s3.getDescription() });
    return n5.addSegment(s3, true), oh2(n5, t3, i2, o, a2);
  }
  const l2 = [0], g2 = e2.getImpl().getIsSimple(m3, l2);
  let u = i2 ? -1 : g2;
  if (-1 !== u) return u;
  const c = new Ph2(e2, t3, u, a2, false);
  return h2 === a.enumMultiPoint ? u = c.multipointIsSimpleAsFeature() : h2 === a.enumPolyline ? u = c.polylineIsSimpleAsFeature() : h2 === a.enumPolygon ? u = c.polygonIsSimpleAsFeature() : b(""), e2.getImpl().setIsSimple(u, m3), o && o.assign(c.m_nonSimpleResult), u;
}
function ah2(e2, t3, i2, o) {
  if (e2.isEmpty()) return e2;
  const a2 = e2.getGeometryType();
  if (a2 === a.enumPoint) {
    const t4 = new e();
    if (mh2(e2, t4), 3 === t4.m_reason) {
      const t5 = e2.clone();
      return t5.replaceNaNs(1, 0), t5;
    }
    return 2 === t4.m_reason ? e2.createInstance() : e2;
  }
  if (a2 === a.enumEnvelope) {
    const s3 = Bt2(t3, e2, true).total(), n5 = e2, r = n3.constructEmpty();
    return n5.queryEnvelope(r), r.isDegenerate(s3) ? n5.createInstance() : e2;
  }
  if (f(a2)) {
    const s3 = e2, n5 = new Os2({ vd: s3.getDescription() });
    return n5.addSegment(s3, true), ah2(n5, t3, i2, o);
  }
  I(a2);
  const h2 = Bt2(t3, e2, false).total(), m3 = [0], l2 = e2.getImpl().getIsSimple(h2, m3), g2 = i2 ? -1 : l2;
  if (Ot2(g2)) {
    if (a2 === a.enumPolygon && 0 !== e2.getFillRule()) {
      const t4 = e2.clone();
      return t4.setFillRule(0), t4;
    }
    return e2;
  }
  if ((a2 === a.enumMultiPoint || a2 === a.enumPolyline) && g2 >= 1) return e2;
  const u = new Ph2(e2, t3, g2, o, false);
  let c;
  return a2 === a.enumMultiPoint ? c = u.multipointSimplifyAsFeature() : a2 === a.enumPolyline ? c = u.polylineSimplifyAsFeature() : a2 === a.enumPolygon ? c = u.polygonSimplifyAsFeature() : b(""), c;
}
function hh2(e2, t3, r, i2) {
  if (e2.isEmpty()) return e2;
  const o = e2.getGeometryType();
  if (o === a.enumPoint) {
    const t4 = new e();
    if (mh2(e2, t4), 3 === t4.m_reason) {
      const t5 = e2.clone();
      return t5.replaceNaNs(1, 0), t5;
    }
    return 2 === t4.m_reason ? e2.createInstance() : e2;
  }
  if (o === a.enumEnvelope) {
    const s3 = e2, n5 = new n3();
    s3.queryEnvelope(n5);
    const r2 = Bt2(t3, e2, true).total();
    return n5.isDegenerate(r2) ? s3.createInstance() : e2;
  }
  if (f(o)) {
    const s3 = e2, n5 = new Os2({ vd: s3.getDescription() });
    return n5.addSegment(s3, true), hh2(n5, t3, r, i2);
  }
  I(o), y(o) || z("OGC simplify is not implemented for this geometry type");
  const a2 = Bt2(t3, e2, false).total(), h2 = [0], m3 = e2.getImpl().getIsSimple(a2, h2), l2 = r ? -1 : m3;
  if (5 === l2) {
    if (o === a.enumPolygon && 0 !== e2.getFillRule()) {
      const t4 = e2.clone();
      return t4.setFillRule(0), t4;
    }
    return e2;
  }
  return Aa2(e2, Bt2(t3, e2, true), false, l2, i2, 0, true);
}
function mh2(e2, t3) {
  const s3 = e2.getX(), n5 = e2.getY();
  if (!Number.isFinite(s3) || !Number.isFinite(n5)) return t3 && (t3.m_reason = 2, t3.m_vertexIndex1 = -1, t3.m_vertexIndex2 = -1), 0;
  if (e2.hasAttribute(1)) {
    const s4 = e2.getZ();
    if (!Number.isFinite(s4)) return t3 && (t3.m_reason = Number.isNaN(s4) ? 3 : 2, t3.m_vertexIndex1 = -1, t3.m_vertexIndex2 = -1), 0;
  }
  return 5;
}
var lh2 = class {
  constructor() {
    this.m_segment = null, this.m_vertexIndex = -1, this.m_pathIndex = -1, this.m_flags = 0;
  }
  setReversed(e2) {
    this.m_flags &= -2, this.m_flags = this.m_flags | (e2 ? 1 : 0);
  }
  getReversed() {
    return !!(1 & this.m_flags);
  }
  getRightSide() {
    return this.getReversed() ? 0 : 1;
  }
};
function gh2() {
  return { x: -1, y: -1, ipath: -1, ivertex: -1, ipolygon: -1 };
}
function uh2(e2, t3, s3, n5, r) {
  return { x: e2, y: t3, ipath: s3, ivertex: n5, ipolygon: r };
}
function ch2(e2, t3) {
  return e2.x === t3.x && e2.y === t3.y && e2.ipath === t3.ipath && e2.ivertex === t3.ivertex && e2.ipolygon === t3.ipolygon;
}
function _h2(e2, t3) {
  e2.x = t3.x, e2.y = t3.y, e2.ipath = t3.ipath, e2.ivertex = t3.ivertex, e2.ipolygon = t3.ipolygon;
}
function dh2() {
  return { x: -1, y: -1, ipath: -1, ivertex: -1, bBoundary: false, bEndPoint: false };
}
function ph2(e2, t3, s3, n5, r, i2) {
  return { x: e2, y: t3, ipath: s3, ivertex: n5, bBoundary: r, bEndPoint: i2 };
}
function fh2(e2, t3) {
  e2.x = t3.x, e2.y = t3.y, e2.ipath = t3.ipath, e2.ivertex = t3.ivertex, e2.bBoundary = t3.bBoundary, e2.bEndPoint = t3.bEndPoint;
}
var xh2 = class extends dt {
  constructor(e2) {
    super(), this.m_helper = e2;
  }
  compare(e2, t3, s3) {
    const n5 = e2.getElement(s3), r = this.m_helper.m_xy.read(2 * t3) - this.m_helper.m_xy.read(2 * n5);
    return r < 0 ? -1 : r > 0 ? 1 : 0;
  }
};
var yh2 = class extends dt {
  constructor(e2) {
    super(), this.m_helper = e2;
  }
  compare(e2, t3, s3) {
    const n5 = e2.getElement(s3), r = this.m_helper.m_edges[t3], i2 = this.m_helper.m_edges[n5], o = r.getReversed(), a2 = i2.getReversed();
    let h2 = r.m_segment.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline, 0), m3 = i2.m_segment.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline, 0);
    if (h2 === m3) {
      const e3 = o ? r.m_segment.getStartY() : r.m_segment.getEndY(), t4 = a2 ? i2.m_segment.getStartY() : i2.m_segment.getEndY(), s4 = Math.min(e3, t4);
      let n6 = 0.5 * (s4 - this.m_helper.m_yScanline) + this.m_helper.m_yScanline;
      n6 === this.m_helper.m_yScanline && (n6 = s4), h2 = r.m_segment.intersectionOfYMonotonicWithAxisX(n6, 0), m3 = i2.m_segment.intersectionOfYMonotonicWithAxisX(n6, 0);
    }
    return h2 < m3 ? -1 : h2 > m3 ? 1 : 0;
  }
};
var Ph2 = class _Ph {
  constructor(e2, t3, s3, n5, r) {
    this.m_multiVertexGeom = null, this.m_edges = [], this.m_freeEdges = [], this.m_lineEdgesRecycle = [], this.m_newEdges = [], this.m_recycledSegIter = null, this.m_crossOverHelperList = new pt(), this.m_progressTracker = null, this.m_progressCounter = 0, this.m_AET = new ct2(), this.m_xyToNode1 = null, this.m_xyToNode2 = null, this.m_pathOrientations = null, this.m_pathParentage = null, this.m_xy = null, this.m_pairs = [], this.m_pairIndices = null, this.m_pathsForOGCTests = [], this.m_curveStitcher = null, this.m_editShape = null, this.m_multiPathStitcher = null, this.m_nonSimpleResult = new e(), this.m_progressCounter = 0, this.m_progressTracker = n5, this.m_geometry = e2, this.m_knownSimpleResult = s3, this.m_sr = t3;
    const i2 = Bt2(t3, e2, false);
    this.m_toleranceIsSimple = i2, this.m_toleranceIsSimpleClustering = Ft2(i2), this.m_toleranceIsSimpleCracking = Pt2(i2), this.m_toleranceSimplify = Bt2(t3, e2, true), this.m_description = this.m_geometry.getDescription(), this.m_attributeCount = this.m_description.getAttributeCount(), this.m_bOGCRestrictions = r, this.m_bPlanarSimplify = this.m_bOGCRestrictions, this.m_unknownOrientationPathCount = -1, this.m_yScanline = 0, this.m_progressCounter = 0;
  }
  isSimplePlanarImpl() {
    if (this.m_bPlanarSimplify = true, !this.checkStructure()) return 0;
    const e2 = this.m_geometry.getGeometryType();
    return h(e2) && !this.checkDegenerateSegments(false) ? 0 : this._CheckClustering() ? h(e2) ? this._CheckCracking() ? this.m_geometry.getGeometryType() === a.enumPolyline ? this.checkSelfIntersectionsPolylinePlanar() ? 4 : 0 : this._CheckSelfIntersections() ? this._CheckValidRingOrientation() : 0 : 0 : 5 : 0;
  }
  isSimplePlanarImpl3D() {
    return n(0), 7;
  }
  generateSortedPairs(e2) {
    let t3 = null;
    h(e2.getGeometryType()) && (t3 = e2);
    const s3 = (this.m_bPlanarSimplify || this.m_bOGCRestrictions) && null !== t3, n5 = e2.getPointCount();
    this.m_xy = e2.getAttributeStreamRef(0), this.m_pairs.length = 0, this.m_pairIndices = new st2(0), s3 && (this.m_pathsForOGCTests.length = 0);
    let r = 0;
    for (let i2 = 0; i2 < n5; i2++) if (this.m_pairs.push(2 * i2), this.m_pairs.push(2 * i2 + 1), this.m_pairIndices.add(2 * i2), this.m_pairIndices.add(2 * i2 + 1), s3) {
      for (; i2 >= t3.getPathEnd(r); ) r++;
      this.m_pathsForOGCTests.push(r);
    }
    const o = new ot(), a2 = { parent: this, workPt: new mi(), userSort(e3, t4, n6) {
      n6.sort(e3, t4, (e4, t5) => this.parent.compareVerticesForPlanarClustering(e4, t5, s3));
    }, getValue(e3) {
      const t4 = this.parent.m_pairs[e3], s4 = t4 >> 1;
      this.parent.m_xy.queryPoint2D(2 * s4, this.workPt);
      return this.workPt.y + (1 & t4 ? this.parent.m_toleranceIsSimpleClustering : -this.parent.m_toleranceIsSimpleClustering);
    } };
    o.sort(this.m_pairIndices, 0, 2 * n5, a2);
  }
  _TestToleranceDistancePlanar(e2, t3) {
    const s3 = this.m_xy.read(2 * e2), n5 = this.m_xy.read(2 * e2 + 1), r = this.m_xy.read(2 * t3), i2 = this.m_xy.read(2 * t3 + 1);
    if (!!ln2(s3, n5, r, i2, this.m_toleranceIsSimpleClustering * this.m_toleranceIsSimpleClustering)) {
      if (0 === this.m_geometry.getDimension()) return false;
      return s3 === r && n5 === i2;
    }
    return true;
  }
  checkStructure() {
    const e2 = this.m_geometry.getGeometryType();
    if (h(e2)) {
      const e3 = this.m_geometry.getImpl(), t3 = this.m_geometry.getGeometryType() === a.enumPolygon ? 3 : 2;
      for (let s3 = 0, n5 = e3.getPathCount(); s3 < n5; s3++) if (e3.getPathSize(s3) < t3) {
        if (e3.hasNonLinearSegments() && e3.hasNonLinearSegmentsPath(s3) && e3.getPathSize(s3) > 0) continue;
        return this.m_nonSimpleResult = new e(1, s3, 0), false;
      }
    }
    if (y(e2)) {
      const e3 = this.m_geometry.getImpl(), t3 = e3.getAttributeStreamRef(0);
      for (let s3 = 0, n5 = e3.getPointCount(); s3 < n5; s3++) {
        if (!t3.readPoint2D(2 * s3).isFinite()) return this.m_nonSimpleResult = new e(2, s3, 0), false;
      }
      if (this.m_geometry.hasAttribute(1)) {
        const t4 = e3.getAttributeStreamRef(1);
        for (let s3 = 0, n5 = e3.getPointCount(); s3 < n5; s3++) {
          const e4 = t4.read(s3);
          if (!Number.isFinite(e4)) return Number.isNaN(e4) ? this.m_nonSimpleResult = new e(3, s3, 0) : this.m_nonSimpleResult = new e(2, s3, 0), false;
        }
      }
    }
    return true;
  }
  checkDegenerateSegments(e2) {
    const t3 = this.m_geometry.getImpl(), s3 = t3.querySegmentIterator(), n5 = t3.hasAttribute(1), r = n5 ? wt2(this.m_sr, t3, false).total() : 0, i2 = t3.hasNonLinearSegments(), o = this.m_toleranceIsSimple.total();
    for (; s3.nextPath(); ) for (; s3.hasNextSegment(); ) {
      const t4 = s3.nextSegment();
      let a2 = t4.calculateLowerLength2D();
      if (!(a2 > o) && !(i2 && t4.isCurve() && (a2 = t4.calculateLength2D(), a2 > o))) {
        if (e2 && n5) {
          const e3 = t4.getStartAttributeAsDbl(1, 0), s4 = t4.getEndAttributeAsDbl(1, 0);
          if (Math.abs(s4 - e3) > r) continue;
        }
        return this.m_nonSimpleResult = new e(4, s3.getStartPointIndex(), -1), false;
      }
    }
    return true;
  }
  checkDegenerateSegments3D() {
    return n(0), false;
  }
  _CheckClustering() {
    const e2 = this.m_geometry.getImpl();
    this.generateSortedPairs(e2);
    const t3 = e2.getPointCount();
    this.m_AET.clear(), this.m_AET.setComparator(new xh2(this)), this.m_AET.setCapacity(t3);
    for (let s3 = 0, n5 = 2 * t3; s3 < n5; s3++) {
      this.progress_();
      const e3 = this.m_pairIndices.read(s3), t4 = this.m_pairs[e3], n6 = t4 >> 1;
      if (1 & t4) {
        const e4 = this.m_AET.search(n6), t5 = this.m_AET.getPrev(e4), s4 = this.m_AET.getNext(e4);
        if (this.m_AET.deleteNode(e4), t5 !== ct2.st_nullNode() && s4 !== ct2.st_nullNode() && !this._TestToleranceDistancePlanar(this.m_AET.getElement(t5), this.m_AET.getElement(s4))) return this.m_nonSimpleResult = new e(5, this.m_AET.getElement(t5), this.m_AET.getElement(s4)), false;
      } else {
        const e4 = this.m_AET.addElement(n6), t5 = this.m_AET.getPrev(e4);
        if (t5 !== ct2.st_nullNode() && !this._TestToleranceDistancePlanar(this.m_AET.getElement(t5), n6)) return this.m_nonSimpleResult = new e(5, n6, this.m_AET.getElement(t5)), false;
        const s4 = this.m_AET.getNext(e4);
        if (s4 !== ct2.st_nullNode() && !this._TestToleranceDistancePlanar(this.m_AET.getElement(s4), n6)) return this.m_nonSimpleResult = new e(5, n6, this.m_AET.getElement(s4)), false;
      }
    }
    return true;
  }
  _CheckCracking() {
    const e2 = this.m_geometry.getImpl(), t3 = e2.getPointCount();
    return !e2.hasNonLinearSegments() && t3 < 10 ? this._CheckCrackingBrute() : this._CheckCrackingPlanesweep();
  }
  _CheckCrackingPlanesweep() {
    if (this.m_editShape = new Pr(), this.m_editShape.addGeometry(this.m_geometry), this.m_editShape.hasCurves()) {
      this.m_curveStitcher = new fa2();
      const e3 = n3.constructEmpty();
      this.m_geometry.queryEnvelope(e3);
      const t3 = _a2(this.m_toleranceSimplify.total(), e3), s3 = new e();
      if (la2(this.m_editShape, t3, this.m_toleranceSimplify.total(), 12e3, s3, this.m_curveStitcher, null, this.m_progressTracker), 0 !== s3.m_reason) return this.m_editShape = null, this.m_nonSimpleResult.assign(s3), false;
    }
    const e2 = new e();
    return Mn2(false, this.m_editShape, this.m_toleranceIsSimpleCracking, e2, this.m_progressTracker) ? (null != this.m_curveStitcher ? (e2.m_vertexIndex1 = this.m_curveStitcher.getOriginalVertexIndex(this.m_editShape, e2.m_vertexIndex1), e2.m_vertexIndex2 = this.m_curveStitcher.getOriginalVertexIndex(this.m_editShape, e2.m_vertexIndex2), this.m_curveStitcher = null) : (e2.m_vertexIndex1 = this.m_editShape.getVertexIndex(e2.m_vertexIndex1), e2.m_vertexIndex2 = this.m_editShape.getVertexIndex(e2.m_vertexIndex2)), this.m_editShape = null, this.m_nonSimpleResult.assign(e2), false) : (null == this.m_curveStitcher && (this.m_editShape = null), true);
  }
  _CheckCrackingBrute() {
    const e2 = this.m_geometry.getImpl(), t3 = e2.querySegmentIterator(), s3 = e2.querySegmentIterator();
    for (; t3.nextPath(); ) for (; t3.hasNextSegment(); ) {
      const e3 = t3.nextSegment();
      if (!t3.isLastSegmentInPath() || !t3.isLastPath()) {
        s3.resetTo(t3);
        do {
          for (; s3.hasNextSegment(); ) {
            const n5 = s3.nextSegment(), r = rm(true, e3, n5, this.m_toleranceIsSimpleCracking, true);
            if (r) {
              const e4 = 2 === r ? 7 : 6;
              return this.m_nonSimpleResult = new e(e4, t3.getStartPointIndex(), s3.getStartPointIndex()), false;
            }
          }
        } while (s3.nextPath());
      }
    }
    return true;
  }
  _CheckSelfIntersections() {
    let e2 = this.m_geometry.getImpl();
    null !== this.m_curveStitcher && (this.m_multiPathStitcher = this.m_editShape.getGeometry(this.m_editShape.getFirstGeometry()), e2 = this.m_multiPathStitcher.getImpl(), this.generateSortedPairs(e2)), this.m_edges.length = 0, this.m_lineEdgesRecycle.length = 0, this.m_recycledSegIter = e2.querySegmentIterator(), this.m_recycledSegIter.setCirculator(true);
    const t3 = [], s3 = e2.getPointCount();
    let n5 = Number.NaN, r = 0;
    for (let i2 = 0, o = 2 * s3; i2 < o; i2++) {
      this.progress_();
      const e3 = this.m_pairIndices.read(i2), s4 = this.m_pairs[e3];
      if (1 & s4) continue;
      const o2 = s4 >> 1, a2 = this.m_xy.read(2 * o2), h2 = this.m_xy.read(2 * o2 + 1);
      if (t3.length && (a2 !== n5 || h2 !== r)) {
        if (!this.processBunchForSelfIntersectionTest(t3)) return false;
        t3.length = 0;
      }
      t3.push(o2), n5 = a2, r = h2;
    }
    return !!this.processBunchForSelfIntersectionTest(t3);
  }
  checkSelfIntersectionsPolylinePlanar() {
    const e2 = this.m_geometry.getImpl(), t3 = [];
    for (let o = 0, a2 = e2.getPathCount(); o < a2; o++) t3.push(e2.isClosedPathInXYPlane(o));
    const s3 = dh2();
    let n5, r, i2;
    {
      const o = this.m_pairIndices.read(0), a2 = this.m_pairs[o] >> 1, h2 = this.m_xy.readPoint2D(2 * a2), m3 = this.m_pathsForOGCTests[a2];
      n5 = t3[m3], r = e2.getPathStart(m3), i2 = e2.getPathEnd(m3) - 1, s3.bEndPoint = a2 === r || a2 === i2, this.m_bOGCRestrictions ? s3.bBoundary = !n5 && s3.bEndPoint : s3.bBoundary = s3.bEndPoint, s3.ipath = m3, s3.x = h2.x, s3.y = h2.y, s3.ivertex = a2;
    }
    for (let o = 1, a2 = this.m_pairIndices.size(); o < a2; o++) {
      const a3 = this.m_pairIndices.read(o), h2 = this.m_pairs[a3];
      if (1 & h2) continue;
      const m3 = h2 >> 1, l2 = this.m_xy.readPoint2D(2 * m3), g2 = this.m_pathsForOGCTests[m3];
      let u;
      g2 !== s3.ipath && (n5 = t3[g2], r = e2.getPathStart(g2), i2 = e2.getPathEnd(g2) - 1);
      const c = m3 === r || m3 === i2;
      u = this.m_bOGCRestrictions ? !n5 && c : c;
      const _ = ph2(l2.x, l2.y, g2, m3, u, c);
      if (_.x === s3.x && _.y === s3.y) {
        if (this.m_bOGCRestrictions) {
          if (!(_.bBoundary && s3.bBoundary || _.ipath === s3.ipath && _.bEndPoint && s3.bEndPoint)) return this.m_nonSimpleResult = new e(10, _.ivertex, s3.ivertex), false;
        } else if (!_.bEndPoint || !s3.bEndPoint) return this.m_nonSimpleResult = new e(7, _.ivertex, s3.ivertex), false;
      }
      fh2(s3, _);
    }
    return true;
  }
  checkSelfIntersectionsPolylinePlanar3D(e2) {
    return n(0), false;
  }
  checkSelfIntersectionsPolygonsOGC() {
    const e2 = this.m_geometry.getImpl(), t3 = [];
    let s3 = -1, n5 = false;
    for (let l2 = 0, g2 = e2.getPathCount(); l2 < g2; l2++) e2.isExteriorRingOGC(l2) && (n5 = false, s3++, l2 < g2 - 1 && (e2.isExteriorRingOGC(l2 + 1) || (n5 = true))), t3.push(n5 ? s3 : -1);
    const r = gh2();
    {
      const e3 = this.m_pairIndices.read(0), s4 = this.m_pairs[e3] >> 1, n6 = this.m_xy.readPoint2D(2 * s4), i3 = this.m_pathsForOGCTests[s4];
      r.ipath = i3, r.x = n6.x, r.y = n6.y, r.ivertex = s4, r.ipolygon = t3[i3];
    }
    const i2 = [];
    for (let l2 = 1, g2 = this.m_pairIndices.size(); l2 < g2; l2++) {
      const e3 = this.m_pairIndices.read(l2), s4 = this.m_pairs[e3];
      if (1 & s4) continue;
      const n6 = s4 >> 1, o2 = this.m_xy.readPoint2D(2 * n6), a3 = this.m_pathsForOGCTests[n6], h3 = uh2(o2.x, o2.y, a3, n6, t3[a3]);
      if (h3.x === r.x && h3.y === r.y) {
        if (h3.ipath === r.ipath) return this.m_nonSimpleResult = new e(11, h3.ivertex, r.ivertex), false;
        t3[h3.ipath] >= 0 && t3[h3.ipath] === t3[r.ipath] && (0 !== i2.length && ch2(i2.at(-1), r) || i2.push({ ...r }), i2.push(h3));
      }
      _h2(r, h3);
    }
    if (0 === i2.length) return true;
    const o = new pt(true);
    t3.fill(-1);
    let a2 = -1;
    const h2 = new mi();
    for (let l2 = 0, g2 = i2.length; l2 < g2; l2++) {
      const e3 = i2[l2];
      e3.x === h2.x && e3.y === h2.y || (a2 = o.createList(0), h2.x = e3.x, h2.y = e3.y);
      let s4 = t3[e3.ipath];
      -1 === s4 && (s4 = o.createList(2), t3[e3.ipath] = s4), o.addElement(s4, a2), o.addElement(a2, s4);
    }
    const m3 = [];
    for (let l2 = o.getFirstList(); -1 !== l2; l2 = o.getNextList(l2)) {
      const e3 = o.getListData(l2);
      if (1 & e3 || !(2 & e3)) continue;
      let s4 = -1;
      for (m3.push(l2), m3.push(-1); m3.length; ) {
        const e4 = m3.at(-1);
        m3.pop();
        const t4 = m3.at(-1);
        m3.pop();
        const n6 = o.getListData(t4);
        if (1 & n6) {
          s4 = 2 & n6 ? t4 : e4;
          break;
        }
        o.setListData(t4, 1 | n6);
        for (let s5 = o.getFirst(t4); -1 !== s5; s5 = o.getNext(s5)) {
          const n7 = o.getData(s5);
          n7 !== e4 && (m3.push(n7), m3.push(t4));
        }
      }
      if (-1 !== s4) {
        const e4 = t3.indexOf(s4);
        return this.m_nonSimpleResult = new e(12, e4, -1), false;
      }
    }
    return true;
  }
  _CheckValidRingOrientation() {
    const e2 = null !== this.m_multiPathStitcher ? this.m_multiPathStitcher.getImpl() : this.m_geometry.getImpl();
    if (e2.calculateArea2D() <= 0) return this.m_nonSimpleResult = new e(8, 1 === e2.getPathCount() ? 1 : -1, -1), 0;
    if (1 === e2.getPathCount()) return this.m_bOGCRestrictions && !this.checkSelfIntersectionsPolygonsOGC() ? 0 : 4;
    this.m_pathOrientations = new et(e2.getPathCount(), 0), this.m_pathParentage = new st2(e2.getPathCount(), -1);
    let t3 = -1, s3 = 0;
    for (let i2 = 0, o = e2.getPathCount(); i2 < o; i2++) {
      const n6 = e2.calculateRingArea2D(i2);
      if (this.m_pathOrientations.write(i2, n6 < 0 ? 0 : 8), n6 > 0) t3 = i2, s3 = n6;
      else {
        if (0 === n6) return this.m_nonSimpleResult = new e(8, i2, -1), 0;
        if ((t3 < 0 || s3 < Math.abs(n6)) && (this.m_nonSimpleResult = new e(9, i2, -1), this.m_bOGCRestrictions)) return 0;
        this.m_pathParentage.write(i2, t3);
      }
    }
    this.m_unknownOrientationPathCount = e2.getPathCount(), this.m_newEdges.length = 0;
    const n5 = e2.getPointCount();
    this.m_yScanline = Number.NaN;
    const r = [];
    this.m_xyToNode1 = new st2(n5, ct2.st_nullNode()), this.m_xyToNode2 = new st2(n5, ct2.st_nullNode()), this.m_freeEdges.length = 0, this.m_AET.clear(), this.m_AET.setComparator(new yh2(this));
    for (let i2 = 0, o = 2 * n5; this.m_unknownOrientationPathCount > 0 && i2 < o; i2++) {
      const e3 = this.m_pairIndices.read(i2), t4 = this.m_pairs[e3];
      if (1 & t4) continue;
      const s4 = t4 >> 1, n6 = this.m_xy.read(2 * s4 + 1);
      if (n6 !== this.m_yScanline && r.length) {
        if (!this.processBunchForRingOrientationTest(r)) return 0;
        r.length = 0;
      }
      r.push(s4), this.m_yScanline = n6;
    }
    return this.m_unknownOrientationPathCount > 0 && !this.processBunchForRingOrientationTest(r) ? 0 : this.m_bOGCRestrictions ? 0 !== this.m_nonSimpleResult.m_reason ? 0 : this.checkSelfIntersectionsPolygonsOGC() ? 5 : 0 : 0 === this.m_nonSimpleResult.m_reason ? 4 : 3;
  }
  processBunchForSelfIntersectionTest(e2) {
    if (1 === e2.length) return true;
    for (let o = 0, a2 = e2.length; o < a2; o++) {
      const t4 = e2[o];
      this.m_recycledSegIter.resetToVertex(t4, -1);
      const s4 = this.m_recycledSegIter.previousSegment();
      this.m_edges.push(this.createEdge(s4, t4, this.m_recycledSegIter.getPathIndex(), true)), this.m_recycledSegIter.nextSegment();
      const n6 = this.m_recycledSegIter.nextSegment();
      this.m_edges.push(this.createEdge(n6, t4, this.m_recycledSegIter.getPathIndex(), false));
    }
    this.m_edges.sort((e3, t4) => this.edgeAngleCompare(e3, t4));
    let t3 = this.m_crossOverHelperList.getFirstList();
    -1 === t3 && (t3 = this.m_crossOverHelperList.createList(0)), this.m_crossOverHelperList.reserveNodes(this.m_edges.length);
    for (let o = 0, a2 = this.m_edges.length; o < a2; o++) this.m_crossOverHelperList.addElement(t3, o);
    let s3 = true, n5 = -1, r = -1;
    for (; s3; ) {
      s3 = false;
      let e3 = this.m_crossOverHelperList.getFirst(t3);
      if (-1 === e3) break;
      let i3 = this.m_crossOverHelperList.getNext(e3);
      for (; -1 !== i3; ) {
        const o = this.m_crossOverHelperList.getData(e3), a2 = this.m_crossOverHelperList.getData(i3);
        if (n5 = this.m_edges[o].m_vertexIndex, r = this.m_edges[a2].m_vertexIndex, n5 !== r) e3 = i3, i3 = this.m_crossOverHelperList.getNext(e3);
        else if (s3 = true, this.m_crossOverHelperList.deleteElement(t3, e3), e3 = this.m_crossOverHelperList.getPrev(i3), i3 = this.m_crossOverHelperList.deleteElement(t3, i3), -1 === i3 || -1 === e3) break;
      }
    }
    const i2 = this.m_crossOverHelperList.getListSize(t3);
    if (this.m_crossOverHelperList.clear(t3), i2 > 0) return this.m_nonSimpleResult = new e(7, n5, r), false;
    for (let o = 0, a2 = e2.length; o < a2; o++) this.recycleEdge(this.m_edges[o]);
    return this.m_edges.length = 0, true;
  }
  processBunchForRingOrientationTest(e2) {
    for (let t3 = 0, s3 = e2.length; t3 < s3; t3++) {
      const s4 = e2[t3];
      let n5 = this.m_xyToNode1.read(s4);
      if (n5 !== ct2.st_nullNode()) {
        const e3 = this.m_AET.getElement(n5);
        this.m_freeEdges.push(e3), this.m_AET.deleteNode(n5), this.recycleEdge(this.m_edges[e3]), this.m_edges[e3] = null, this.m_xyToNode1.write(s4, ct2.st_nullNode());
      }
      if (n5 = this.m_xyToNode2.read(s4), n5 !== ct2.st_nullNode()) {
        const e3 = this.m_AET.getElement(n5);
        this.m_freeEdges.push(e3), this.m_AET.deleteNode(n5), this.recycleEdge(this.m_edges[e3]), this.m_edges[e3] = null, this.m_xyToNode2.write(s4, ct2.st_nullNode());
      }
    }
    for (let t3 = 0, s3 = e2.length; t3 < s3; t3++) {
      const s4 = e2[t3];
      this.m_recycledSegIter.resetToVertex(s4, -1);
      const n5 = this.m_recycledSegIter.previousSegment();
      if (n5.getStartY() > n5.getEndY()) {
        const e3 = this.m_recycledSegIter.getStartPointIndex(), t4 = this.createEdge(n5, s4, this.m_recycledSegIter.getPathIndex(), true);
        let r2;
        this.m_freeEdges.length > 0 ? (r2 = this.m_freeEdges.at(-1), this.m_freeEdges.pop(), this.m_edges[r2] = t4) : (r2 = this.m_edges.length, this.m_edges.push(t4));
        const i2 = this.m_AET.addElement(r2);
        this.m_xyToNode1.read(e3) === ct2.st_nullNode() ? this.m_xyToNode1.write(e3, i2) : this.m_xyToNode2.write(e3, i2), 3 & this.m_pathOrientations.read(this.m_recycledSegIter.getPathIndex()) || this.m_newEdges.push(i2);
      }
      this.m_recycledSegIter.nextSegment();
      const r = this.m_recycledSegIter.nextSegment();
      if (r.getStartY() < r.getEndY()) {
        const e3 = this.m_recycledSegIter.getEndPointIndex(), t4 = this.createEdge(r, s4, this.m_recycledSegIter.getPathIndex(), false);
        let n6;
        this.m_freeEdges.length > 0 ? (n6 = this.m_freeEdges.at(-1), this.m_freeEdges.pop(), this.m_edges[n6] = t4) : (n6 = this.m_edges.length, this.m_edges.push(t4));
        const i2 = this.m_AET.addElement(n6);
        this.m_xyToNode1.read(e3) === ct2.st_nullNode() ? this.m_xyToNode1.write(e3, i2) : this.m_xyToNode2.write(e3, i2), 3 & this.m_pathOrientations.read(this.m_recycledSegIter.getPathIndex()) || this.m_newEdges.push(i2);
      }
    }
    for (let t3 = 0, s3 = this.m_newEdges.length; t3 < s3 && this.m_unknownOrientationPathCount > 0; t3++) {
      const e3 = this.m_newEdges[t3], s4 = this.m_AET.getElement(e3), n5 = this.m_edges[s4].m_pathIndex;
      if (!(3 & this.m_pathOrientations.read(n5))) {
        let t4 = -1, s5 = this.m_AET.getPrev(e3), n6 = e3, r = 0;
        {
          let e4 = -1, i2 = null, o = -1, a2 = 0;
          for (; s5 !== ct2.st_nullNode() && (e4 = this.m_AET.getElement(s5), i2 = this.m_edges[e4], o = i2.m_pathIndex, a2 = this.m_pathOrientations.read(o), !(3 & a2)); ) n6 = s5, s5 = this.m_AET.getPrev(s5);
          s5 === ct2.st_nullNode() ? (r = 1, s5 = n6) : (t4 = 1 == (3 & a2) ? o : this.m_pathParentage.read(o), r = i2.getRightSide() ? 0 : 1, s5 = this.m_AET.getNext(s5));
        }
        do {
          const e4 = this.m_AET.getElement(s5), i2 = this.m_edges[e4], o = i2.m_pathIndex;
          let a2 = this.m_pathOrientations.read(o);
          if (!(3 & a2)) {
            if (r !== i2.getRightSide()) return this.m_nonSimpleResult = new e(8, o, -1), false;
            const e5 = r && !i2.getReversed() ? 1 : 2;
            if (a2 = -4 & a2 | e5, this.m_pathOrientations.write(o, a2), 2 === e5 && 0 === this.m_nonSimpleResult.m_reason) {
              const e6 = this.m_pathParentage.read(o);
              if (e6 !== t4 && (this.m_nonSimpleResult = new e(9, o, e6), this.m_bOGCRestrictions)) return false;
            }
            if (this.m_unknownOrientationPathCount--, !this.m_unknownOrientationPathCount) return true;
          }
          t4 = 1 == (3 & a2) ? o : this.m_pathParentage.read(o), n6 = s5, s5 = this.m_AET.getNext(s5), r = r ? 0 : 1;
        } while (n6 !== e3);
      }
    }
    return this.m_newEdges.length = 0, true;
  }
  createEdge(e2, t3, n5, r) {
    let i2;
    return e2.getGeometryType() === a.enumLine ? i2 = this.createEdgeLine(e2) : (i2 = new lh2(), i2.m_segment = e2.clone()), i2.m_vertexIndex = t3, i2.m_pathIndex = n5, i2.m_flags = 0, i2.setReversed(r), i2;
  }
  createEdgeLine(e2) {
    let t3;
    return this.m_lineEdgesRecycle.length > 0 ? (t3 = this.m_lineEdgesRecycle.at(-1), this.m_lineEdgesRecycle.pop(), e2.copyTo(t3.m_segment)) : (t3 = new lh2(), t3.m_segment = e2.clone()), t3;
  }
  recycleEdge(e2) {
    e2.m_segment.getGeometryType() === a.enumLine && this.m_lineEdgesRecycle.push(e2);
  }
  static isShortSegment(e2, t3, s3, n5) {
    let r = e2.calculateLowerLength2D();
    if (r <= s3) {
      let i2 = true;
      if (e2.isCurve() && (r = e2.calculateLength2D(), i2 = r <= s3), i2) {
        if (t3) {
          let t4 = e2.getEndAttributeAsDbl(1, 0);
          Number.isNaN(t4) && (t4 = 0);
          let s4 = e2.getStartAttributeAsDbl(1, 0);
          return Number.isNaN(s4) && (s4 = 0), Math.abs(s4 - t4) <= n5;
        }
        return true;
      }
      return false;
    }
    return false;
  }
  static isShortSegmentPoints(e2, t3, s3, n5, r) {
    if (s3) {
      const s4 = e2.getXYZ(), i2 = t3.getXYZ();
      return Mt(s4, i2, n5, r);
    }
    {
      const s4 = e2.getXY(), r2 = t3.getXY();
      return mi.sqrDistance(s4, r2) <= n5 * n5;
    }
  }
  removeDegenerateSegmentsFromCurvedPath(e2, t3, s3, n5) {
    const r = e2.hasAttribute(1), i2 = e2.querySegmentIterator();
    i2.resetToPath(t3), n(i2.nextPath());
    const a2 = this.m_toleranceSimplify.total();
    let h2 = false, m3 = true;
    const l2 = new ee(), g2 = new ee(), u = new mi();
    for (; i2.hasNextSegment(); ) {
      this.progress_();
      const e3 = i2.nextSegment();
      if (_Ph.isShortSegment(e3, r, a2, s3)) if (h2) {
        if (e3.queryEnd(g2), _Ph.isShortSegmentPoints(l2, g2, r, a2, s3)) continue;
        m3 && (n5.startPathPoint(l2), m3 = false), e3.queryEnd(l2), n5.lineToPoint(l2), h2 = false;
      } else u.assign(e3.getStartXY()), e3.queryStart(l2), h2 = true;
      else if (h2) if (e3.isCurve()) {
        const t4 = e3.clone();
        if (t4.setCoordsForIntersector(u, e3.getEndXY(), false), t4.setStart(l2), _Ph.isShortSegment(t4, r, a2, s3)) continue;
        n5.addSegment(t4, m3), m3 = false, h2 = false;
      } else {
        if (e3.queryEnd(g2), _Ph.isShortSegmentPoints(l2, g2, r, a2, s3)) continue;
        m3 && (n5.startPathPoint(l2), m3 = false), n5.lineToPoint(g2), h2 = false;
      }
      else n5.addSegment(e3, m3), m3 = false;
    }
    if (m3) return;
    if (!h2) return;
    e2.isClosedPath(t3) ? e2.getPointByVal(e2.getPathStart(t3), l2) : e2.getPointByVal(e2.getPathEnd(t3) - 1, l2);
    const c = n5.querySegmentIterator();
    c.resetToLastPath(), c.resetToLastSegment();
    const _ = n5.getDescription().getAttributeCount() > 1;
    for (n(c.previousPath()); c.hasPreviousSegment(); ) {
      const e3 = c.previousSegment();
      if (e3.isCurve()) {
        const t4 = e3.clone();
        if (t4.setCoordsForIntersector(e3.getStartXY(), l2.getXY(), false), !_Ph.isShortSegment(t4, r, a2, s3)) {
          _ && t4.setEnd(l2);
          const e4 = c.getEndPointIndex();
          for (let t5 = n5.getPointCount() - 1; t5 >= e4; t5--) n5.removePoint(t5);
          return void n5.addSegment(t4, false);
        }
      } else if (e3.queryStart(g2), !_Ph.isShortSegmentPoints(g2, l2, r, a2, s3)) {
        const e4 = c.getEndPointIndex();
        for (let t4 = n5.getPointCount() - 1; t4 >= e4; t4--) n5.removePoint(t4);
        return void n5.lineToPoint(l2);
      }
    }
    n5.removePath(n5.getPathCount() - 1);
  }
  multipointIsSimpleAsFeature() {
    if (!this.checkStructure()) return 0;
    const e2 = this.m_geometry.getImpl();
    this.m_multiVertexGeom = e2;
    const t3 = e2.getPointCount(), s3 = Yt(t3, 0);
    for (let n5 = 0; n5 < t3; n5++) s3[n5] = n5;
    s3.sort((e3, t4) => this.compareVerticesMultiPoint(e3, t4));
    for (let n5 = 1; n5 < t3; n5++) if (0 === this.compareVerticesMultiPoint(s3[n5 - 1], s3[n5])) return this.m_nonSimpleResult = new e(5, s3[n5 - 1], s3[n5]), 0;
    return 1;
  }
  polylineIsSimpleAsFeature() {
    return this.checkStructure() && this.checkDegenerateSegments(true) ? 1 : 0;
  }
  polygonIsSimpleAsFeature() {
    return this.isSimplePlanarImpl();
  }
  multipointSimplifyAsFeature() {
    let e2 = this.m_geometry.getImpl();
    const t3 = _Ph.hasNanZs(e2);
    let s3, n5 = this.m_geometry;
    t3 && (s3 = this.m_geometry.clone(), e2 = s3.getImpl(), s3.replaceNaNs(1, z3.getDefaultValue(1)), n5 = s3), this.m_multiVertexGeom = e2;
    const r = e2.getPointCount(), i2 = Yt(r, 0);
    for (let g2 = 0; g2 < r; g2++) i2[g2] = g2;
    i2.sort((e3, t4) => this.compareVerticesMultiPoint(e3, t4));
    const o = new Array(r);
    o.fill(false);
    let a2 = -1;
    for (let g2 = 0; g2 < r; g2++) {
      const t4 = i2[g2];
      e2.getXY(t4).isFinite() && ((a2 < 0 || 0 !== this.compareVerticesMultiPoint(a2, t4)) && (o[t4] = true), a2 = t4);
    }
    const h2 = this.m_geometry.createInstance();
    let m3 = 0, l2 = 0;
    for (let g2 = 0; g2 < r; g2++) o[g2] ? l2 = g2 + 1 : (m3 < l2 && h2.addPoints(n5, m3, l2), m3 = g2 + 1);
    return m3 < l2 && h2.addPoints(n5, m3, l2), h2.getImpl().setIsSimple(1, this.m_toleranceSimplify.total()), h2;
  }
  polylineSimplifyAsFeature() {
    const e2 = this.m_geometry.getImpl(), t3 = e2.querySegmentIterator(), s3 = e2.querySegmentIterator(), n5 = this.m_geometry.createInstance(), r = this.m_geometry, i2 = e2.hasAttribute(1), o = i2 ? wt2(this.m_sr, e2, true).total() : 0, a2 = [], h2 = [];
    let m3 = null;
    i2 && (m3 = e2.getAttributeStreamRef(1));
    const l2 = new ee(), g2 = e2.hasNonLinearSegments(), u = this.m_toleranceSimplify.total();
    for (; t3.nextPath(); ) {
      if (s3.nextPath(), e2.getPathSize(t3.getPathIndex()) < 2) continue;
      if (g2 && e2.hasNonLinearSegmentsPath(t3.getPathIndex())) {
        this.removeDegenerateSegmentsFromCurvedPath(e2, t3.getPathIndex(), o, n5);
        continue;
      }
      s3.resetToLastSegment();
      let c = 0, _ = 0, d2 = true, p3 = true;
      for (; t3.hasNextSegment(); ) {
        this.progress_();
        const n6 = t3.nextSegment(), r2 = s3.previousSegment();
        if (t3.getStartPointIndex() > s3.getStartPointIndex()) break;
        if (d2) {
          const s4 = t3.getStartPointIndex();
          e2.getXY(s4).isNAN() || (d2 = false, a2.push(s4));
        }
        if (p3) {
          const t4 = s3.getEndPointIndex();
          e2.getXY(t4).isNAN() || (h2.push(t4), p3 = false);
        }
        if (!d2) {
          const s4 = a2.at(-1), r3 = t3.getEndPointIndex();
          if (r3 - s4 > 1) {
            const t4 = new mi();
            t4.setSub(e2.getXY(s4), e2.getXY(r3)), c = t4.length();
          } else c = n6.calculateLength2D();
          if (c > u) a2.push(r3), c = 0;
          else if (i2) {
            let e3 = m3.read(s4);
            Number.isNaN(e3) && (e3 = 0);
            let t4 = m3.read(r3);
            Number.isNaN(t4) && (t4 = 0), Math.abs(t4 - e3) > o && (a2.push(r3), c = 0);
          }
        }
        if (!p3) {
          const t4 = h2.at(-1), n7 = s3.getStartPointIndex();
          if (n7 - t4 > 1) {
            const s4 = new mi();
            s4.setSub(e2.getXY(t4), e2.getXY(n7)), _ = s4.length();
          } else _ = r2.calculateLength2D();
          if (_ > u) h2.push(n7), _ = 0;
          else if (i2) {
            let e3 = m3.read(t4);
            Number.isNaN(e3) && (e3 = 0);
            let s4 = m3.read(n7);
            Number.isNaN(s4) && (s4 = 0), Math.abs(s4 - e3) > o && (h2.push(n7), _ = 0);
          }
        }
      }
      if (a2.length > 0 && h2.length > 0 && (a2.at(-1) < h2.at(-1) ? a2.length > h2.length ? a2.pop() : h2.pop() : (a2.at(-1) === h2.at(-1) || h2.pop(), h2.pop())), h2.length + a2.length >= 2) {
        let e3 = false;
        for (let t4 = 0, s4 = a2.length; t4 < s4; t4++) r.getPointByVal(a2[t4], l2), e3 ? n5.lineToPoint(l2) : (n5.startPathPoint(l2), e3 = true);
        for (let t4 = h2.length - 1; t4 > 0; t4--) r.getPointByVal(h2[t4], l2), e3 ? n5.lineToPoint(l2) : (n5.startPathPoint(l2), e3 = true);
        r.isClosedPath(t3.getPathIndex()) ? n5.closePathWithLine() : h2.length > 0 && (r.getPointByVal(h2[0], l2), n5.lineToPoint(l2));
      }
      a2.length = 0, h2.length = 0;
    }
    return i2 && n5.replaceNaNs(1, 0), n5.getImpl().setIsSimple(1, u), n5;
  }
  polygonSimplifyAsFeature() {
    return this.simplifyPlanar();
  }
  simplifyPlanar() {
    if (1 === this.m_geometry.getFillRule() && !Ht2(this.m_knownSimpleResult)) return Ma2(this.m_geometry, this.m_toleranceSimplify, true, false, this.m_knownSimpleResult, this.m_progressTracker, 0, true);
    const e2 = new Pr();
    if (e2.addGeometry(this.m_geometry), this.m_geometry.hasAttribute(1) && e2.replaceNaNs(1, 0), e2.removeNaNVertices(), 0 !== e2.getTotalPointCount()) {
      let t4 = null, n5 = 0, r = 0;
      if (e2.hasCurves()) {
        t4 = new fa2();
        const s3 = n3.constructEmpty();
        this.m_geometry.queryEnvelope(s3);
        const i2 = _a2(this.m_toleranceSimplify.total(), s3);
        n5 = da2(this.m_toleranceSimplify.total()), r = pa2(i2, n5), aa2(e2, i2, this.m_toleranceSimplify.total(), 12e3, t4, null, this.m_progressTracker);
      }
      if (!Ht2(this.m_knownSimpleResult)) {
        ya2(e2, this.m_toleranceSimplify.add(r), this.m_progressTracker, true, false);
      }
      this.m_geometry.getGeometryType() === a.enumPolygon && er2(e2, e2.getFirstGeometry(), this.m_knownSimpleResult, false, -1, this.m_progressTracker), null !== t4 && t4.stitchCurves(e2, e2.getFirstGeometry(), n5, true);
    }
    const t3 = e2.getGeometry(e2.getFirstGeometry());
    return t3.getGeometryType() === a.enumPolygon && (t3.getImpl().updateOGCFlagsProtected(), t3.setFillRule(0)), t3.getImpl().setIsSimple(4, this.m_toleranceSimplify.total()), t3;
  }
  progress_() {
  }
  static hasNanZs(e2) {
    if (e2.hasAttribute(1)) {
      const t3 = e2.getAttributeStreamRef(1);
      for (let s3 = 0, n5 = e2.getPointCount(); s3 < n5; s3++) {
        const e3 = t3.read(s3);
        if (Number.isNaN(e3)) return true;
      }
    }
    return false;
  }
  compareVerticesForPlanarClustering(e2, t3, s3) {
    if (e2 === t3) return 0;
    const n5 = this.m_pairs[e2], r = this.m_pairs[t3], i2 = n5 >> 1, o = r >> 1, a2 = this.m_xy.readPoint2D(2 * i2);
    a2.y += 1 & n5 ? this.m_toleranceIsSimpleClustering : -this.m_toleranceIsSimpleClustering;
    const h2 = this.m_xy.readPoint2D(2 * o);
    h2.y += 1 & r ? this.m_toleranceIsSimpleClustering : -this.m_toleranceIsSimpleClustering;
    const m3 = a2.compare(h2);
    if (0 === m3 && s3) {
      const e3 = this.m_pathsForOGCTests[i2] - this.m_pathsForOGCTests[o];
      return K(e3);
    }
    return m3;
  }
  compareVerticesMultiPoint(e2, t3) {
    if (e2 === t3) return 0;
    const s3 = this.m_multiVertexGeom.getXY(e2), n5 = this.m_multiVertexGeom.getXY(t3), r = !s3.isFinite(), i2 = !n5.isFinite();
    if (r || i2) return r < i2 ? -1 : r > i2 ? 1 : 0;
    if (s3.y < n5.y) return -1;
    if (s3.y > n5.y) return 1;
    if (s3.x < n5.x) return -1;
    if (s3.x > n5.x) return 1;
    for (let o = 1; o < this.m_attributeCount; o++) {
      const s4 = this.m_description.getSemantics(o), n6 = z3.getComponentCount(s4);
      for (let r2 = 0; r2 < n6; r2++) {
        const n7 = this.m_multiVertexGeom.getAttributeAsDbl(s4, e2, r2), i3 = this.m_multiVertexGeom.getAttributeAsDbl(s4, t3, r2), o2 = _s(n7, i3);
        if (0 !== o2) return o2;
      }
    }
    return 0;
  }
  edgeAngleCompare(e2, t3) {
    if (e2 === t3) return 0;
    const s3 = e2.m_segment.getTangent(e2.getReversed() ? 1 : 0);
    e2.getReversed() && s3.negateThis();
    const n5 = t3.m_segment.getTangent(t3.getReversed() ? 1 : 0);
    t3.getReversed() && n5.negateThis();
    const r = s3.getQuarter(), i2 = n5.getQuarter();
    if (i2 === r) {
      const e3 = s3.crossProduct(n5);
      return e3 < 0 ? 1 : e3 > 0 ? -1 : 0;
    }
    return r < i2 ? -1 : 1;
  }
};
var Eh2 = class {
  getOperatorType() {
    return 10103;
  }
  accelerateGeometry(e2, t3, s3) {
    return false;
  }
  canAccelerateGeometry(e2) {
    return false;
  }
  supportsCurves() {
    return true;
  }
  isSimpleAsFeature(e2, t3, s3, n5, r) {
    const i2 = oh2(e2, t3, s3, n5, r);
    return Yt2(e2.getGeometryType(), i2);
  }
  isSimplePlanarDONOTUSE(e2, t3, s3, n5, r) {
    const i2 = rh2(e2, t3, s3, n5, r);
    return Ot2(i2);
  }
  executeMany(e2, t3, s3, n5) {
    return new Sh2(e2, t3, s3, n5);
  }
  execute(e2, t3, s3, n5) {
    const i2 = new s([e2]), o = this.executeMany(i2, t3, s3, n5).next();
    return o || b("null geometry"), o;
  }
};
var Sh2 = class extends t {
  constructor(e2, t3, s3, n5) {
    super(), this.m_progressTracker = n5, this.m_bForceSimplify = s3, this.m_index = -1, this.m_inputGeometryCursor = e2, this.m_spatialReference = t3;
  }
  next() {
    const e2 = this.m_inputGeometryCursor.next();
    return e2 ? (this.m_index = this.m_inputGeometryCursor.getGeometryID(), this.simplify(e2)) : null;
  }
  getGeometryID() {
    return this.m_index;
  }
  tock() {
    return false;
  }
  getRank() {
    return 1;
  }
  simplify(t3) {
    if (t3 || P(""), t3.getGeometryType() === a.enumGeometryCollection) {
      const e2 = _e(t3, -1), s3 = new Eh2().executeMany(e2, this.m_spatialReference, this.m_bForceSimplify, this.m_progressTracker), n5 = t3.createInstance();
      for (let t4 = s3.next(); null != t4; t4 = s3.next()) n5.addGeometry(t4);
      return n5;
    }
    return ah2(t3, this.m_spatialReference, this.m_bForceSimplify, this.m_progressTracker);
  }
};
function Ch2(e2, t3, n5) {
  const r = new n3();
  e2.queryEnvelope(r);
  const i2 = new n3();
  t3.queryEnvelope(i2);
  const o = new n3(i2);
  if (o.inflate(2 * n5), !o.isIntersecting(r)) return 4;
  const a2 = e2.getGeometryType(), h2 = t3.getGeometryType();
  if (a2 === a.enumEnvelope && r.containsEnvelope(o)) return 1;
  if (h2 === a.enumEnvelope) {
    const e3 = new n3(r);
    if (e3.inflate(2 * n5), i2.containsEnvelope(e3)) return 2;
  }
  return 0;
}
var Ih2 = class _Ih {
  constructor(e2, t3, n5, r) {
    this.m_intersectorGeom = null, this.m_sr = null, this.m_dimensionMask = -1, this.m_progressTracker = null, this.m_intersectorGeomType = a.enumUnknown, this.m_geomIntersectorEmptyGeom = null, this.m_intersectorGeom = e2, this.m_sr = t3, this.m_dimensionMask = n5, this.m_progressTracker = r, this.m_intersectorGeomType = e2.getGeometryType();
  }
  intersect(e2) {
    const t3 = this.tryFastImplementation(e2);
    if (null !== t3) return t3;
    const s3 = It2(this.m_intersectorGeom, e2), n5 = At(this.m_sr, s3, true).total(), r = n3.constructEmpty();
    this.m_intersectorGeom.queryEnvelope(r);
    const i2 = n3.constructEmpty();
    e2.queryEnvelope(i2), r.inflateCoords(2 * n5, 2 * n5), r.intersect(i2), r.inflateCoords(100 * n5, 100 * n5);
    const o = 0;
    let a2 = f2(this.m_intersectorGeom, r, o, 0, this.m_progressTracker), h2 = f2(e2, r, o, 0, this.m_progressTracker);
    return e2.getDimension() > this.m_intersectorGeom.getDimension() && (a2 = Pt(h2, h2 = a2)), za2(h2, a2, this.m_sr, this.m_progressTracker);
  }
  intersectEx(e2) {
    const t3 = this.tryFastImplementation(e2);
    if (null !== t3) {
      const s4 = [];
      return s4.length = 3, s4[t3.getDimension()] = t3, this.prepareVector(e2.getDescription(), this.m_dimensionMask, s4);
    }
    const s3 = It2(this.m_intersectorGeom, e2), n5 = At(this.m_sr, s3, true).total(), r = n3.constructEmpty();
    this.m_intersectorGeom.queryEnvelope(r);
    const i2 = n3.constructEmpty();
    e2.queryEnvelope(i2), r.inflateCoords(2 * n5, 2 * n5), r.intersect(i2), r.inflateCoords(100 * n5, 100 * n5);
    const o = 0;
    let a2 = f2(this.m_intersectorGeom, r, o, 0, this.m_progressTracker), h2 = f2(e2, r, o, 0, this.m_progressTracker);
    e2.getDimension() > this.m_intersectorGeom.getDimension() && (a2 = Pt(h2, h2 = a2));
    const m3 = Wa2(h2, a2, this.m_sr, this.m_progressTracker);
    return this.prepareVector(e2.getDescription(), this.m_dimensionMask, m3);
  }
  init(e2, t3, s3, n5 = null) {
    n(0);
  }
  static intersectPoints(e2, t3, s3) {
    const n5 = It2(e2, t3);
    return La2(e2, t3, At(s3, n5, true));
  }
  tryFastImplementation(e2) {
    const t3 = e2.getGeometryType();
    if (this.m_intersectorGeomType === a.enumPoint && t3 === a.enumPoint) {
      const t4 = _Ih.intersectPoints(e2, this.m_intersectorGeom, this.m_sr);
      if (-1 !== this.m_dimensionMask) {
        const e3 = new cs2({ vd: t4.getDescription() });
        return t4.isEmpty() || e3.add(t4), e3;
      }
      return t4;
    }
    if (t3 === a.enumEnvelope && this.m_intersectorGeomType === a.enumEnvelope && (-1 === this.m_dimensionMask || 4 === this.m_dimensionMask)) {
      const t4 = e2, s3 = this.m_intersectorGeom, n6 = new re({ copy: t4 });
      return n6.intersect(s3), n6;
    }
    const n5 = It2(e2, this.m_intersectorGeom), i2 = At(this.m_sr, n5, true), o = e2.isEmpty(), a2 = this.m_intersectorGeom.isEmpty();
    let m3 = o || a2;
    if (!m3) {
      const t4 = Ch2(this.m_intersectorGeom, e2, i2.total());
      if (4 === t4) m3 = true;
      else {
        if (2 & t4) return this.m_intersectorGeom;
        if (1 & t4) return e2;
      }
    }
    if (m3) {
      const n6 = m(t3), r = m(this.m_intersectorGeomType);
      return n6 < r ? _Ih.ReturnEmpty(e2, o) : n6 > r || 0 === n6 && t3 === a.enumMultiPoint && this.m_intersectorGeomType === a.enumPoint ? this.ReturnEmptyIntersector() : _Ih.ReturnEmpty(e2, o);
    }
    if (t3 === a.enumEnvelope && 0 === m(this.m_intersectorGeomType) || this.m_intersectorGeomType === a.enumEnvelope && 0 === m(t3)) {
      const n6 = t3 === a.enumEnvelope ? e2 : this.m_intersectorGeom, r = t3 === a.enumEnvelope ? this.m_intersectorGeom : e2, o2 = n3.constructEmpty();
      return n6.queryEnvelope(o2), f2(r, o2, i2.total(), 0, this.m_progressTracker);
    }
    if (0 === m(t3) && m(this.m_intersectorGeomType) > 0 || m(t3) > 0 && 0 === m(this.m_intersectorGeomType)) {
      if (t3 === a.enumMultiPoint) return Oa2(e2, this.m_intersectorGeom, i2);
      if (t3 === a.enumPoint) return Xa2(e2, this.m_intersectorGeom, i2);
      if (this.m_intersectorGeomType === a.enumMultiPoint) return Oa2(this.m_intersectorGeom, e2, i2);
      if (this.m_intersectorGeomType === a.enumPoint) return Xa2(this.m_intersectorGeom, e2, i2);
      b("");
    }
    return null;
  }
  ReturnEmptyIntersector() {
    return null === this.m_geomIntersectorEmptyGeom && (this.m_geomIntersectorEmptyGeom = this.m_intersectorGeom.createInstance()), this.m_geomIntersectorEmptyGeom;
  }
  static ReturnEmpty(e2, t3) {
    return t3 ? e2 : e2.createInstance();
  }
  prepareVector(e2, t3, s3) {
    let n5 = 0;
    return 1 & t3 ? (s3[0] || (s3[0] = new cs2({ vd: e2 })), n5++) : s3.shift(), 2 & t3 ? (s3[n5] || (s3[n5] = new Os2({ vd: e2 })), n5++) : s3.splice(n5, 1), 4 & t3 ? s3[n5] || (s3[n5] = new ur({ vd: e2 })) : s3.splice(n5, 1), new s(s3);
  }
};
var bh2 = class extends t {
  constructor(t3, s3, n5, r, i2) {
    super(), this.m_smallCursor = null, this.m_progressTracker = r, this.m_geomIntersector = s3.next(), this.m_intersector = new Ih2(this.m_geomIntersector, n5, i2, r), this.m_index = -1, this.m_inputGeoms = t3, this.m_dimensionMask = i2, -1 !== this.m_dimensionMask && (this.m_dimensionMask <= 0 || this.m_dimensionMask > 7) && P("bad dimension mask");
  }
  next() {
    if (!this.m_geomIntersector) return null;
    let e2;
    if (null !== this.m_smallCursor) {
      if (e2 = this.m_smallCursor.next(), e2) return e2;
      this.m_smallCursor = null;
    }
    for (; e2 = this.m_inputGeoms.next(); ) {
      if (j(e2), this.m_index = this.m_inputGeoms.getGeometryID(), -1 === this.m_dimensionMask) {
        return this.m_intersector.intersect(e2);
      }
      this.m_smallCursor = this.m_intersector.intersectEx(e2);
      return this.m_smallCursor.next();
    }
    return null;
  }
  getGeometryID() {
    return this.m_index;
  }
  tock() {
    return true;
  }
  getRank() {
    return 1;
  }
};
var wh2 = class {
  getOperatorType() {
    return 1e4;
  }
  accelerateGeometry(e2, t3, n5) {
    if (!this.canAccelerateGeometry(e2)) return false;
    Bt2(t3, e2, true);
    let r = 0;
    return e2.getGeometryType() !== a.enumPolygon && e2.getGeometryType() !== a.enumPolyline || !Ls2(e2) || 0 === n5 || (r |= e2.getImpl().buildQuadTreeAccelerator(n5) ? 1 : 0), !!r;
  }
  canAccelerateGeometry(e2) {
    return Ls2(e2);
  }
  supportsCurves() {
    return true;
  }
  executeMany(e2, t3, s3, n5, r = -1) {
    return new bh2(e2, t3, s3, n5, r);
  }
  execute(e2, t3, n5, i2) {
    if (e2.getGeometryType() === a.enumPoint && t3.getGeometryType() === a.enumPoint) return Ih2.intersectPoints(e2, t3, n5);
    const o = new s([e2]), a2 = new s([t3]), h2 = this.executeMany(o, a2, n5, i2, -1).next();
    return h2 || b("null output"), h2;
  }
};
function vh2(e2, t3, s3) {
  return t3.m_projector.project(e2, s3);
}
function Nh2(e2, t3, s3, n5, r) {
  e2.m_projector.transformInPlaceZ(t3, null, s3, n5, null, r);
  const i2 = n5.slice(0, s3).filter((e3) => !e3.isNAN());
  for (let o = 0, a2 = i2.length; o < a2; ++o) n5[o].assign(i2[o]);
  return i2.length;
}
function Th2(e2, t3, s3, n5, r) {
  return e2.m_projector.transformInPlaceZ(t3, null, s3, n5, null, r);
}
function Gh(t3, r, o, a2) {
  if (t3 && r && r.isPannable() || P("fold_into_360_range_geodetic"), t3.isEmpty()) return t3;
  if (4 === o) return Dh2(t3, r, a2);
  let h2 = t3;
  const m3 = h2.getGeometryType();
  if (h(m3)) {
    h2 = Al(t3, r);
    const e2 = new n3();
    h2.queryEnvelope(e2);
    const s3 = At(r, e2, false).total(), n5 = r.getPannableExtent();
    let i2 = Math.floor((e2.xmin - n5.xmin) / n5.width()) * n5.width() + n5.xmin, a3 = h2;
    for (; i2 < e2.xmax; ) i2 > e2.xmin + s3 && i2 < e2.xmax - s3 && (a3 = Hl(a3, r, o, true, i2)), i2 += n5.width();
    h2 = a3;
  } else {
    if (m3 === a.enumEnvelope) {
      const e2 = new ur({ vd: h2.getDescription() });
      return e2.addEnvelope(h2, false), Gh(e2, r, o, a2);
    }
    if (f(m3)) {
      const e2 = new Os2({ vd: h2.getDescription() });
      return e2.addSegment(h2, true), Gh(e2, r, o, a2);
    }
  }
  return Dh2(h2, r, a2);
}
function Dh2(t3, r, i2) {
  if (t3 && r && r.isPannable() || P(""), t3.isEmpty()) return t3;
  let o;
  const a2 = t3.getGeometryType();
  if (a2 === a.enumEnvelope) {
    const e2 = new ur({ vd: t3.getDescription() });
    e2.addEnvelope(t3, false), o = e2;
  } else if (f(a2)) {
    const e2 = new Os2({ vd: t3.getDescription() });
    e2.addSegment(t3, true), o = e2;
  } else o = t3;
  const h2 = Al(o, r);
  return h2.isEmpty() ? h2 : vl(h2, r, 0, h2 !== t3, 0, i2);
}
function Vh(e2, t3, s3) {
  if (!t3.isPannable() || e2.isEmpty()) return e2;
  const n5 = t3.getPannableExtent().width(), r = 0.5 * n5, o = e2.queryInterval(0, 0);
  if (o.width() < r || !y(e2.getGeometryType())) {
    if (Number.isNaN(s3)) return e2;
    const t4 = o.getCenter();
    if (Math.abs(t4 - s3) <= r) return e2;
    {
      const r2 = new x3(), i2 = S((s3 - t4) / n5) * n5;
      r2.setShiftCoords(i2, 0);
      const o2 = e2.clone();
      return o2.applyTransformation(r2), o2;
    }
  }
  const a2 = e2.getGeometryType(), h2 = e2, m3 = h2.getAttributeStreamRef(0), l2 = e2.clone(), g2 = l2.getAttributeStreamRef(0);
  let u = 0, c = 0, d2 = 0, p3 = h(a2) ? 0 : -1;
  const f3 = x2.constructEmpty();
  let x4 = false;
  for (let _ = 0, y2 = h2.getPointCount(); _ < y2; _++) {
    const e3 = m3.read(2 * _);
    _ === c && (h(a2) ? (0 === p3 && Number.isNaN(s3) && (x4 = true), p3 > 0 && Number.isNaN(s3) && (s3 = f3.getCenter(), x4 = false), c = h2.getPathEnd(p3), p3++) : c = h2.getPointCount(), Number.isNaN(s3) ? d2 = e3 : (d2 = s3, u = 0));
    let t4 = e3 - d2;
    Math.abs(t4) > r && (t4 = S(t4 / n5) * n5, u -= t4, Math.abs(u) < 0.1 * n5 && (u = 0));
    const o2 = e3 + u;
    g2.write(2 * _, o2), x4 && f3.mergeCoordinate(o2), d2 = e3;
  }
  return l2.notifyModified(), l2;
}
var Fh2 = "missing implementation";
function Hh(e2, t3, s3, n5) {
  const i2 = t3.getCoordinateSystemType();
  if (0 === i2) {
    const n6 = new ac();
    return t3.queryPrecisionDescriptor(n6), kh2(e2, n6, t3, s3);
  }
  let o = e2;
  2 !== n5 && 3 !== n5 || !t3.isPannable() || (o = Dh2(o, t3, s3));
  const a2 = new ac();
  if (t3.queryPrecisionDescriptor(a2), o = kh2(o, a2, t3, s3), 0 === n5 || o.isEmpty()) return o;
  if (1 === i2) {
    if (1 === n5) {
      const e3 = new n3();
      o.queryLooseEnvelope(e3);
      const n6 = t3.getPannableExtent(), r = 0.01 * n6.width();
      return n6.xmin = e3.xmin - r, n6.xmax = e3.xmax + r, new I3().execute(o, n6, t3, s3);
    }
    return o;
  }
  if (2 === i2) {
    const e3 = t3.getPCSHorizon();
    if (1 === n5 || 2 === n5) {
      const n6 = new wh2().execute(o, e3, t3, s3);
      return n6 === e3 ? n6.clone() : n6;
    }
    return o;
  }
  if (3 === i2) return o;
  b(Fh2);
}
function kh2(e2, t3, s3, n5) {
  const r = t3.getXYGridRange(), i2 = e2.hasAttribute(1), o = e2.hasAttribute(2);
  let a2 = new x2(), h2 = new x2();
  i2 && (a2 = t3.getZGridRange()), o && (h2 = t3.getMGridRange());
  let m3 = new I3().execute(e2, r, s3, n5);
  if (i2) {
    const t4 = m3.queryInterval(1, 0);
    a2.contains(t4) || (e2 === m3 && (m3 = m3.clone()), $t2(m3, a2, 1, 0));
  }
  if (o) {
    const t4 = m3.queryInterval(2, 0);
    h2.contains(t4) || (e2 === m3 && (m3 = m3.clone()), $t2(m3, h2, 2, 0));
  }
  return m3;
}
var Ah2 = class {
  constructor(t3) {
    this.m_inputPCSHorizonClipOption = 0, this.m_outputPCSHorizonClipOption = 0, this.m_bDontGeonormalizePolygon = false, this.m_bClipOutCurvedPoles = false, this.m_bNormalizeOutputGeometry = false, this.m_bDontHackPolesInGeogToGeog = false, this.m_centralMeridianOfOutputGCS = 0, this.m_densificationStepInput = 0, t3 || P(""), this.m_projTransform = t3, this.m_bClipOutCurvedPoles = false;
    const s3 = this.m_projTransform.getExtendedParamsImpl();
    this.m_bNormalizeOutputGeometry = s3.normalizeResultGeometry, this.m_bNormalizeOutputGeometry && (s3.legacyHorizonClipping ? this.m_bNormalizeOutputGeometry = false : this.m_projTransform.getOutputSR().isPannable() || (this.m_bNormalizeOutputGeometry = false)), s3.clipWithInputHorizon ? (this.m_inputPCSHorizonClipOption = 0, !s3.legacyHorizonClipping && this.m_projTransform.getInputSR().isPannable() && (this.m_inputPCSHorizonClipOption = this.m_bNormalizeOutputGeometry ? 4 : 2)) : this.m_inputPCSHorizonClipOption = 1, s3.clipWithOutputHorizon ? (this.m_outputPCSHorizonClipOption = 0, !s3.legacyHorizonClipping && this.m_projTransform.getOutputSR().isPannable() && (this.m_outputPCSHorizonClipOption = this.m_bNormalizeOutputGeometry ? 4 : 2)) : this.m_outputPCSHorizonClipOption = 1, this.m_centralMeridianOfOutputGCS = s3.centralMeridianOfOutputGCS, this.m_densificationStepInput = s3.densificationStep;
    const n5 = this.m_projTransform.getExtendedParamsInternal();
    this.m_bDontGeonormalizePolygon = n5.hasFlag(2147483648), this.m_bDontHackPolesInGeogToGeog = n5.hasFlag(1073741824), this.m_bClipOutCurvedPoles = n5.hasFlag(536870912);
  }
  project(e2, t3) {
    if (this.m_projTransform.isIdentity() || e2.isEmpty()) return e2;
    const n5 = e2.getGeometryType();
    if (n5 === a.enumPoint) return this.projectPoint(e2, t3);
    const i2 = this.m_projTransform.getInputSR().getCoordinateSystemType(), o = this.m_projTransform.getOutputSR().getCoordinateSystemType(), a2 = this.m_projTransform.getInputSR(), h2 = this.m_projTransform.getOutputSR();
    if (0 === i2 && i2 === o) {
      const t4 = Uh(a2, h2), s3 = e2.clone();
      return s3.applyTransformation(t4), s3;
    }
    switch (n5) {
      case a.enumPolyline:
      case a.enumPolygon:
        return this.projectMultiPath(e2, t3);
      case a.enumMultiPoint:
        return this.projectMultiPoint(e2, t3);
      case a.enumEnvelope:
        return this.projectEnvelope(e2, t3);
      case a.enumGeometryCollection:
        return this.projectGeometryCollection(e2, t3);
      default:
        b("");
    }
  }
  projectPoint(e2, t3) {
    const s3 = [e2.getXY()];
    let n5, r = null;
    (n5 = e2.hasAttribute(1)) && (r = [e2.getZ()]), this.transformInPlaceZ(s3, r, 1, s3, r, null);
    const i2 = e2.clone();
    return i2.setXY(s3[0]), n5 && i2.setZ(r[0]), i2;
  }
  projectMultiPoint(e2, t3) {
    let s3 = new cs2({ copy: e2 });
    const n5 = this.m_projTransform.getInputSR(), r = this.m_projTransform.getOutputSR(), i2 = n5.getCoordinateSystemType(), a2 = r.getCoordinateSystemType();
    if (3 === i2 && n(0), s3 = Xl(s3, n5, this.m_inputPCSHorizonClipOption, t3), s3.isEmpty()) return s3;
    2 === i2 && $l(n5, 0, s3), gg(this.m_projTransform, s3, false);
    let h2 = 0;
    3 === a2 && n(0);
    const m3 = 2 === a2;
    return m3 ? h2 = r.getCentralMeridian() : Number.isNaN(this.m_centralMeridianOfOutputGCS) || (h2 = this.m_centralMeridianOfOutputGCS), m3 && 0 !== this.m_outputPCSHorizonClipOption || (s3 = vl(s3, Zu2(r), h2, false, 0, t3)), m3 && (s3 = Sl(s3, r, this.m_outputPCSHorizonClipOption, t3), Kl(r, s3, this.m_bNormalizeOutputGeometry), s3.isEmpty()), s3;
  }
  projectMultiPath(e2, t3) {
    const n5 = e2.getGeometryType();
    return n5 === a.enumPolygon ? this.projectPolygon(e2, t3) : n5 === a.enumPolyline ? this.projectPolyline(e2, t3) : void b("project_multi_path_");
  }
  projectEnvelope(e2, t3) {
    this.m_projTransform.getInputSR(), this.m_projTransform.getOutputSR();
    const s3 = this.m_projTransform.isVertical() && e2.hasAttribute(1);
    let n5 = x2.constructEmpty();
    if (s3 && (n5 = e2.queryInterval(1, 0)), n5.width() > 0) {
      const s4 = e2.clone();
      s4.setInterval(1, 0, n5.vmin, n5.vmin);
      const r = this.projectEnvelopeHelper(s4, t3);
      s4.setInterval(1, 0, n5.vmax, n5.vmax);
      const i2 = this.projectEnvelopeHelper(s4, t3);
      return r.merge(i2), r;
    }
    return this.projectEnvelopeHelper(e2, t3);
  }
  projectPolygon(e2, t3) {
    n(e2.getGeometryType() === a.enumPolygon), n(!this.m_projTransform.isIdentity()), n(!e2.isEmpty());
    const n5 = this.m_projTransform.getInputSR(), r = this.m_projTransform.getOutputSR(), i2 = n5.getCoordinateSystemType(), a2 = r.getCoordinateSystemType(), h2 = new ur({ copy: e2 });
    3 === i2 && n(0), 3 === a2 && n(0);
    const m3 = 2 === i2, l2 = 2 === a2, g2 = m3 ? n5.getGCS() : n5, u = l2 ? r.getGCS() : r, c = !l2 && !this.m_bDontHackPolesInGeogToGeog;
    let _ = false, d2 = Xl(h2, n5, this.m_inputPCSHorizonClipOption, t3);
    if (d2.isEmpty()) return d2;
    let p3 = this.m_densificationStepInput;
    const f3 = !Number.isNaN(p3);
    let x4;
    f3 && (d2 = new m2().execute(d2, p3, 0, 0, t3));
    let y2 = l2 ? r.getPCSInfo() : null, P5 = Number.NaN;
    m3 && (P5 = n5.getCentralMeridian());
    const E2 = null !== r.getGCSSplitLines();
    if (this.m_bDontGeonormalizePolygon) {
      const e3 = d2;
      if (m3 && (hg(n5, P5, e3), f3)) {
        const e4 = n5.getUnitsPerMillimeter();
        p3 *= n5.getGCS().getUnitsPerMillimeter() / e4;
      }
      if (cg(this.m_projTransform, e3, c), f3) {
        const e4 = n5.getGCS().getUnitsPerMillimeter();
        p3 *= r.getGCS().getUnitsPerMillimeter() / e4;
      }
      x4 = e3;
    } else {
      let e3 = new Os2({ vd: d2.getDescription() });
      if (e3.addAndExplicitlyOpenAllPaths(d2, false), m3) {
        if (hg(n5, P5, e3), f3) {
          const e4 = n5.getUnitsPerMillimeter();
          p3 *= n5.getGCS().getUnitsPerMillimeter() / e4;
        }
        if (this.m_bClipOutCurvedPoles) {
          const s4 = n5.getPCSInfo(), r2 = s4.getSouthPoleGeometry() === Nc.PE_POLE_LINE_CURVED, i4 = s4.getNorthPoleGeometry() === Nc.PE_POLE_LINE_CURVED;
          if (r2 || i4) {
            const s5 = n3.constructEmpty();
            e3.queryLooseEnvelope(s5), s5.inflateCoords(1, 1);
            const n6 = 89.9999 * g2.getOneDegreeGCSUnit();
            r2 && (s5.ymin = -n6), i4 && (s5.ymax = n6), e3 = d(e3, s5, g2, 0, 0, t3);
          }
        }
      }
      if (cg(this.m_projTransform, e3, c), f3) {
        const e4 = Zu2(n5).getUnitsPerMillimeter();
        p3 *= Zu2(r).getUnitsPerMillimeter() / e4;
      }
      let s3 = Number.NaN;
      l2 ? (y2 = r.getPCSInfo(), s3 = r.getCentralMeridian()) : Number.isNaN(this.m_centralMeridianOfOutputGCS) || (s3 = this.m_centralMeridianOfOutputGCS);
      let i3 = Mh2(n5) | Mh2(r), o = 10 * u.getTolerance(0);
      this.m_bDontHackPolesInGeogToGeog && (i3 = 3, o = 10 * u.getTolerance(0)), x4 = Vl(d2, n5, e3, u, s3, t3, i3, o, this.m_bNormalizeOutputGeometry), i3 = 0;
    }
    if (E2 && (n(!r.isPannable()), x4 = cl(x4, r, t3)), l2) {
      if (!_) {
        const e3 = u.getPannableExtent().width();
        if (x4.queryInterval(0, 0).width() >= e3 - 10 * u.getTolerance(0)) {
          const e4 = y2.getNorthPoleLocation(), t4 = y2.getSouthPoleLocation(), s3 = y2.getNorthPoleGeometry(), n6 = y2.getSouthPoleGeometry();
          let r2 = 0;
          s3 === Nc.PE_POLE_POINT && e4 !== Nc.PE_POLE_OUTSIDE_BOUNDARY && (r2 = 1), n6 === Nc.PE_POLE_POINT && t4 !== Nc.PE_POLE_OUTSIDE_BOUNDARY && (r2 |= 2), _ ||= 0 !== r2;
        }
      }
      x4 = Sl(x4, r, this.m_outputPCSHorizonClipOption, t3), f3 && (x4 = new m2().execute(x4, p3, 0, 0, t3)), Jl(r, x4, this.m_bNormalizeOutputGeometry);
    }
    return x4.isEmpty() || _ && (x4 = new Eh2().execute(x4, r, false, t3)), x4;
  }
  projectPolyline(e2, t3) {
    n(e2.getGeometryType() === a.enumPolyline), n(!this.m_projTransform.isIdentity()), n(!e2.isEmpty());
    const n5 = this.m_projTransform.getInputSR(), r = this.m_projTransform.getOutputSR(), i2 = n5.getCoordinateSystemType(), a2 = r.getCoordinateSystemType(), h2 = new Os2({ copy: e2 });
    3 === i2 && n(0), 3 === a2 && n(0);
    const m3 = 2 === i2, l2 = 2 === a2;
    m3 && n5.getGCS();
    const g2 = l2 ? r.getGCS() : r, u = !l2 && !this.m_bDontHackPolesInGeogToGeog;
    let c = Xl(h2, n5, this.m_inputPCSHorizonClipOption, t3);
    if (c.isEmpty()) return c;
    let _ = Number.NaN;
    m3 && (_ = n5.getCentralMeridian());
    const d2 = null !== r.getGCSSplitLines();
    let p3 = this.m_densificationStepInput;
    const f3 = !Number.isNaN(p3);
    let x4;
    if (f3 && (c = new m2().execute(c, p3, 0, 0, t3)), this.m_bDontGeonormalizePolygon) {
      if (m3 && (hg(n5, _, c), f3)) {
        const e3 = n5.getUnitsPerMillimeter();
        p3 *= n5.getGCS().getUnitsPerMillimeter() / e3;
      }
      if (cg(this.m_projTransform, c, u), f3) {
        const e3 = n5.getGCS().getUnitsPerMillimeter();
        p3 *= r.getGCS().getUnitsPerMillimeter() / e3;
      }
      x4 = c;
    } else {
      const e3 = new Os2({ vd: c.getDescription() });
      if (e3.addAndExplicitlyOpenAllPaths(c, false), m3 && (hg(n5, _, e3), f3)) {
        const e4 = n5.getUnitsPerMillimeter();
        p3 *= n5.getGCS().getUnitsPerMillimeter() / e4;
      }
      if (cg(this.m_projTransform, e3, u), f3) {
        const e4 = n5.getGCS().getUnitsPerMillimeter();
        p3 *= r.getGCS().getUnitsPerMillimeter() / e4;
      }
      let s3 = Number.NaN;
      l2 ? s3 = r.getCentralMeridian() : Number.isNaN(this.m_centralMeridianOfOutputGCS) || (s3 = this.m_centralMeridianOfOutputGCS);
      let i3 = Mh2(n5) | Mh2(r), o = 10 * g2.getTolerance(0);
      this.m_bDontHackPolesInGeogToGeog && (i3 = 3, o = 0), x4 = Fl(c, n5, e3, g2, s3, t3, i3, o, this.m_bNormalizeOutputGeometry), i3 = 0;
    }
    return d2 && (n(!r.isPannable()), x4 = cl(x4, r, t3)), l2 && (x4 = Sl(x4, r, this.m_outputPCSHorizonClipOption, t3), f3 && (x4 = new m2().execute(x4, p3, 0, 0, t3)), Jl(r, x4, this.m_bNormalizeOutputGeometry)), x4.isEmpty(), x4;
  }
  projectGeometryCollection(e2, t3) {
    return n(0), {};
  }
  projectEnvelopeHelper(e2, t3) {
    const s3 = (e2.height() + e2.width()) / 400;
    if (0 !== s3) {
      const n5 = new m2().execute(e2, s3, 0, 0, t3), r = this.projectMultiPath(n5, t3), i2 = new re({ vd: e2.getDescription() });
      if (r.isEmpty()) {
        const s4 = Math.min(e2.height(), e2.width()), r2 = Bt2(this.m_projTransform.getInputSR(), e2, true).total();
        if (s4 > 100 * r2) {
          const e3 = n3.constructEmpty(), t4 = At(this.m_projTransform.getOutputSR(), e3, true).total(), n6 = this.m_projTransform.getInputSR().getOneMeter() / this.m_projTransform.getOutputSR().getOneMeter();
          if (s4 > 100 * Math.max(r2, t4 * n6)) return i2;
        }
        const o = new Os2();
        o.addAndExplicitlyOpenAllPaths(n5, false);
        this.projectMultiPath(o, t3).queryEnvelope(i2);
        const a2 = new cs2({ vd: e2.getDescription() });
        a2.reserve(4);
        const h2 = new ee();
        for (let t4 = 0; t4 < 4; t4++) e2.queryCornerByVal(t4, h2), a2.add(h2);
        const m3 = this.projectMultiPoint(a2, t3), l2 = new re();
        return m3.queryEnvelope(l2), i2.merge(l2), i2;
      }
      return r.queryEnvelope(i2), i2;
    }
    {
      const s4 = e2.getCenterXY(), n5 = new ee(s4), r = this.projectPoint(n5, t3), i2 = new re({ vd: e2.getDescription() });
      if (r.isEmpty()) i2.setEmpty();
      else {
        e2.copyTo(i2);
        const t4 = r.getXY();
        i2.setCoords(t4.x, t4.y, t4.x, t4.y);
      }
      return i2;
    }
  }
  transformInPlace(e2, t3, s3, n5) {
    return n(0), 0;
  }
  transformInPlaceZ(e2, t3, s3, n5, r, i2) {
    if (this.m_projTransform.isIdentity()) return e2 !== n5 && Gt(n5, e2, s3), t3 !== r && Dt(r, t3, 0, 0, s3), s3;
    const a2 = this.m_projTransform, h2 = a2.getInputSR(), m3 = a2.getOutputSR(), l2 = h2.getCoordinateSystemType(), u = m3.getCoordinateSystemType();
    if (0 === l2 && l2 === u) {
      return Uh(h2, m3).transformPoints2D(e2, s3, n5), a2.isVertical() && n(0), s3;
    }
    3 === l2 && z("image: transform_in_place_"), 3 === u && z("image: transform_in_place_"), Ll(e2, s3, n5, h2, this.m_inputPCSHorizonClipOption), r !== t3 && Dt(r, t3, 0, 0, s3), 2 === l2 && mg(h2, 0, n5, s3), fg(this.m_projTransform, n5, r, s3, false);
    let c = 0;
    const _ = 2 === u;
    _ ? c = m3.getCentralMeridian() : Number.isNaN(this.m_centralMeridianOfOutputGCS) || (c = this.m_centralMeridianOfOutputGCS), _ && 0 !== this.m_outputPCSHorizonClipOption || Nl(n5, s3, m3.getGCS(), c), _ && (wl(n5, s3, m3, this.m_outputPCSHorizonClipOption), Wl(m3, n5, s3, false));
    let d2 = s3;
    for (let o = 0; o < s3; ++o) n5[o].isNAN() && (r && (r[o] = Number.NaN), d2--);
    return d2;
  }
};
function Mh2(e2) {
  if (2 !== e2.getCoordinateSystemType()) return 0;
  let t3 = 0;
  const s3 = e2.getPCSInfo(), n5 = s3.getNorthPoleLocation(), r = s3.getSouthPoleLocation(), i2 = s3.getNorthPoleGeometry(), o = s3.getSouthPoleGeometry();
  return i2 === Nc.PE_POLE_POINT && n5 !== Nc.PE_POLE_OUTSIDE_BOUNDARY && (t3 = 1), o === Nc.PE_POLE_POINT && r !== Nc.PE_POLE_OUTSIDE_BOUNDARY && (t3 |= 2), t3;
}
function Uh(e2, t3) {
  const s3 = e2.getHorzUnitFactor(), n5 = t3.getHorzUnitFactor();
  let r = 1, i2 = 1;
  const o = 20015077 / 180;
  1 === e2.getUnit().getUnitType() && (r = o), 1 === t3.getUnit().getUnitType() && (i2 = o);
  const a2 = s3 / n5 * (r !== i2 ? r / i2 : 1), h2 = new x3();
  return h2.setScaleCoords(a2, a2), h2;
}
var qh = class {
  getOperatorType() {
    return 10300;
  }
  supportsCurves() {
    return true;
  }
  accelerateGeometry(e2, t3, s3) {
    return false;
  }
  canAccelerateGeometry(e2) {
    return false;
  }
  executeMany(e2, t3, s3) {
    return !t3 || t3.isIdentity() ? e2 : new Bh(e2, t3, s3);
  }
  execute(e2, t3, s3) {
    return t3.isIdentity() ? e2 : vh2(e2, t3, s3);
  }
  transform(e2, t3, s3, n5, r = true) {
    return r ? Nh2(e2, t3, s3, n5, null) : Th2(e2, t3, s3, n5, null);
  }
  transform3D(e2, t3, s3, n5, r = true) {
    return n(0), 0;
  }
  foldInto360Range(e2, t3) {
    return Dh2(e2, t3, null);
  }
  foldInto360RangeGeodetic(e2, t3, s3) {
    return Gh(e2, t3, s3, null);
  }
  normalizeGeometryEx(e2, t3, s3, n5, r = 0) {
    return Tm(e2, t3, s3, n5, r);
  }
  normalizeGeometry(e2, t3, s3) {
    return Vh(e2, t3, s3);
  }
  clipToSpatialReference(e2, t3, s3, n5 = 0) {
    return Hh(e2, t3, s3, n5);
  }
};
var Bh = class extends t {
  constructor(t3, s3, n5) {
    super(), this.m_projTrans = s3, this.m_progressTracker = n5, this.m_index = -1, t3 || P(""), this.m_inputGeoms = t3;
  }
  next() {
    const e2 = this.m_inputGeoms.next();
    return null != e2 ? (N(e2), j(e2), this.m_index = this.m_inputGeoms.getGeometryID(), vh2(e2, this.m_projTrans, this.m_progressTracker)) : null;
  }
  getGeometryID() {
    return this.m_index;
  }
  tock() {
    return true;
  }
  getRank() {
    return 1;
  }
};
function Oh(r, a2, h2, m3, l2, g2, u = false) {
  r || P("Geometry.Geodetic_densify.densify");
  let c = r.getGeometryType();
  if (j(r), r.isEmpty() || l(c)) return r;
  const _ = new Wh2();
  _.m_sr = a2, _.m_gcs = a2.getGCS(), _.m_transform = _.m_gcs !== a2 ? a2.getSRToGCSTransform() : null, _.m_progressTracker = g2;
  const p3 = Hu2();
  let f3, x4, y2;
  if (_.m_gcs.querySpheroidData(p3), _.m_a = p3.majorSemiAxis, _.m_eSquared = p3.e2, _.m_rpu = _.m_gcs.getUnit().getUnitToBaseFactor(), _.m_gcsTolerance = _.m_gcs.getTolerance(0), _.m_radTolerance = _.m_gcsTolerance * _.m_rpu, _.m_maxLength = m3, _.m_maxDeviation = l2, _.m_curveType = h2, c === a.enumEnvelope) {
    const e2 = new ur({ vd: r.getDescription() });
    e2.addEnvelope(r, false), f3 = e2, c = a.enumPolygon;
  } else if (f(c)) {
    const e2 = new Os2({ vd: r.getDescription() });
    e2.addSegment(r, true), f3 = e2, c = a.enumPolyline;
  } else f3 = r;
  if (4 !== _.m_curveType) {
    if (n(h(c)), x4 = _.replaceCurvesWithLinesAndProjectToGCSAsMultiPoint_(f3), x4.isEmpty()) return x4;
    x4 = Yh2(_.m_rpu, x4);
    let e2 = _.geodeticDensify(x4);
    u || (e2 = new qh().foldInto360RangeGeodetic(e2, _.m_gcs, _.m_curveType)), y2 = _.m_transform && !_.m_transform.isIdentity() ? new qh().execute(e2, _.m_transform.getInverse(), g2) : e2;
  } else {
    let e2;
    if (n(h(c)), a2.isPannable()) e2 = Al(f3, a2);
    else {
      const t3 = a2.getPCSHorizon();
      e2 = new wh2().execute(f3, t3, a2, g2), e2 === t3 && (e2 = t3.clone());
    }
    if (x4 = e2, x4.isEmpty()) return x4;
    y2 = _.shapePreservingDensify(x4);
  }
  return y2;
}
function Yh2(e2, t3) {
  const s3 = new n3();
  if (t3.queryLooseEnvelope(s3), s3.width() * e2 < Math.PI) return t3;
  let n5 = false;
  const r = t3.querySegmentIterator(), i2 = new mi(), o = new mi();
  for (; r.nextPath(); ) for (; r.hasNextSegment(); ) {
    const t4 = r.nextSegment();
    if (i2.setCoordsPoint2D(t4.getStartXY()), o.setCoordsPoint2D(t4.getEndXY()), i2.scale(e2), o.scale(e2), Math.abs(i2.x - o.x) > Math.PI) {
      if (!Xh2(i2, o)) {
        n5 = true;
        break;
      }
      if (Math.abs(i2.x - o.x) > 2 * Math.PI) {
        n5 = true;
        break;
      }
    }
  }
  if (!n5) return t3;
  const a2 = t3.createInstance();
  a2.reserve(t3.getPointCount());
  const h2 = t3.getDescription().getAttributeCount() > 1, m3 = new mi(), l2 = new mi(), g2 = new mi(0, 0), u = new mi(0, 0), c = new ee();
  for (r.resetToFirstPath(); r.nextPath(); ) {
    let t4 = Number.NaN, s4 = 0;
    for (; r.hasNextSegment(); ) {
      const n6 = r.nextSegment();
      i2.setCoordsPoint2D(n6.getStartXY()), o.setCoordsPoint2D(n6.getEndXY()), i2.scale(e2), o.scale(e2), Number.isNaN(t4) ? (s4 = im2(i2.x, Number.NaN, s4), g2.setCoordsPoint2D(i2)) : g2.setCoordsPoint2D(u), t4 = g2.x;
      if (Xh2(i2, o)) {
        if (o.x - i2.x > 2 * Math.PI) for (; o.x - i2.x > 2 * Math.PI; ) o.x -= 2 * Math.PI;
        else if (o.x - i2.x < 2 * -Math.PI) for (; o.x - i2.x < 2 * -Math.PI; ) o.x += 2 * Math.PI;
        s4 = im2(o.x, Number.NaN, s4), u.setCoordsPoint2D(o);
      } else m3.setCoordsPoint2D(o), gm2(m3), s4 = im2(m3.x, t4, s4), u.setCoords(s4 + m3.x, m3.y);
      if (Math.abs(u.x - o.x) < 0.5 && u.setCoordsPoint2D(o), h2) {
        n6.queryCoord(0, c), l2.setCoordsPoint2D(g2), l2.scale(1 / e2), c.setXY(l2);
        r.isFirstSegmentInPath() ? a2.startPathPoint(c) : a2.lineToPoint(c), r.isLastSegmentInPath() && !r.isPathClosed() && (n6.queryCoord(1, c), l2.setCoordsPoint2D(u), l2.scale(1 / e2), c.setXY(l2), a2.lineToPoint(c));
      } else {
        r.isFirstSegmentInPath() && a2.insertPath2D(-1, null, 0, 0, true);
        const t5 = a2.getPathCount() - 1;
        l2.setCoordsPoint2D(g2), l2.scale(1 / e2), a2.insertPoint2D(t5, -1, l2), r.isLastSegmentInPath() && !r.isPathClosed() && (l2.setCoordsPoint2D(u), l2.scale(1 / e2), a2.insertPoint2D(t5, -1, l2));
      }
    }
  }
  return a2;
}
function Rh2(e2, t3, s3, n5, r, i2, o, a2, h2, m3, l2, g2) {
  const u = new mi(), c = new mi(), _ = n5.compare(r) > 0;
  nm2(_, n5, r, u, c);
  const d2 = Kh(e2, t3, s3, u, c, i2, o, a2, h2, m3, null, l2, g2);
  return _ && sm2(h2, m3, null, l2), d2;
}
function Xh2(e2, t3) {
  return !(!Pc(e2.y, Wt) || !Pc(t3.y, Wt)) || !(!Pc(e2.y, -Wt) || !Pc(t3.y, -Wt));
}
function Lh2(e2, t3) {
  return !(!Pc(e2.y, Wt) || Pc(t3.y, Wt)) || !(!Pc(e2.y, -Wt) || Pc(t3.y, -Wt));
}
function zh2(e2, t3) {
  return !(!Pc(t3.y, Wt) || Pc(e2.y, Wt)) || !(!Pc(t3.y, -Wt) || Pc(e2.y, -Wt));
}
var Wh2 = class {
  constructor() {
    this.m_sr = null, this.m_gcs = null, this.m_transform = null, this.m_progressTracker = null, this.m_a = 0, this.m_eSquared = 0, this.m_rpu = 0, this.m_gcsTolerance = 0, this.m_radTolerance = 0, this.m_maxLength = 0, this.m_maxDeviation = 0, this.m_curveType = 0;
  }
  geodeticDensify(e2) {
    const t3 = e2.createInstance(), s3 = e2.querySegmentIterator(), n5 = [], r = [], i2 = new fm(), o = e2.getDescription().getAttributeCount() > 1;
    for (; s3.nextPath(); ) {
      const e3 = [0];
      for (; s3.hasNextSegment(); ) {
        const a2 = s3.nextSegment(), h2 = a2.getStartXY(), m3 = a2.getEndXY();
        h2.scale(this.m_rpu), m3.scale(this.m_rpu);
        const l2 = new mi(), g2 = new mi(), u = h2.compare(m3) > 0;
        nm2(u, h2, m3, l2, g2), n5.length = 0, r.length = 0, this.m_maxLength > 0 ? Kh(this.m_a, this.m_eSquared, this.m_curveType, l2, g2, this.m_maxLength, this.m_maxDeviation, this.m_radTolerance, null, null, o ? r : null, n5, e3) : Qh2(), u && sm2(null, null, o ? r : null, n5), n5[0].setCoordsPoint2D(a2.getStartXY()), n5.at(-1).setCoordsPoint2D(a2.getEndXY());
        const c = 1 / this.m_rpu;
        for (let e4 = 1, t4 = n5.length - 1; e4 < t4; e4++) n5[e4].scale(c);
        if (o) {
          const e4 = rm2(u, a2, i2);
          Zh2(s3.isFirstSegmentInPath(), s3.isLastSegmentInPath() && !s3.isPathClosed(), a2, e4, r, n5, t3);
        } else jh2(s3.isFirstSegmentInPath(), s3.isLastSegmentInPath() && !s3.isPathClosed(), n5, t3);
      }
    }
    return t3;
  }
  shapePreservingDensify(e2) {
    const t3 = e2.createInstance(), s3 = e2.querySegmentIterator(), n5 = [], r = [], i2 = new fm(), o = e2.getDescription().getAttributeCount() > 1;
    for (; s3.nextPath(); ) for (; s3.hasNextSegment(); ) {
      const e3 = s3.nextSegment(), a2 = e3.getStartXY(), h2 = e3.getEndXY(), m3 = a2.compare(h2) > 0, l2 = rm2(m3, e3, i2);
      n5.length = 0, r.length = 0, tm2(this.m_a, this.m_eSquared, this.m_rpu, l2, this.m_sr, this.m_maxLength, this.m_maxDeviation, o ? r : null, n5), m3 && sm2(null, null, o ? r : null, n5), o ? Zh2(s3.isFirstSegmentInPath(), s3.isLastSegmentInPath() && !s3.isPathClosed(), e3, l2, r, n5, t3) : jh2(s3.isFirstSegmentInPath(), s3.isLastSegmentInPath() && !s3.isPathClosed(), n5, t3);
    }
    return t3;
  }
  replaceCurvesWithLinesAndProjectToGCSAsMultiPoint_(e2) {
    const t3 = e2.hasNonLinearSegments();
    if ((!this.m_transform || this.m_transform.isIdentity()) && (e2 = Al(e2, this.m_gcs), !t3)) return e2;
    const s3 = e2.createInstance();
    s3.reserveParts(e2.getPointCount(), e2.getPathCount());
    for (let n5 = 0, r = e2.getPathCount(); n5 < r; ++n5) {
      let t4 = new cs2();
      const r2 = e2.getPathStart(n5), i2 = e2.getPathEnd(n5);
      t4.addPoints(e2, r2, i2);
      const o = e2.isClosedPath(n5);
      let a2 = false;
      if (o && i2 - r2 === 1 && e2.hasNonLinearSegmentsPath(n5)) {
        const s4 = new ee();
        e2.getPointByVal(r2, s4), t4.add(s4), a2 = true;
      }
      if (this.m_transform && !this.m_transform.isIdentity()) {
        if (o && !a2) {
          const s4 = new ee();
          e2.getPointByVal(r2, s4), t4.add(s4);
        }
        if (t4 = new qh().execute(t4, this.m_transform, this.m_progressTracker), o && t4.getPointCount() > 1) {
          const e3 = t4.getXY(0), s4 = t4.getXY(t4.getPointCount() - 1);
          e3.equals(s4) && t4.removePoint(t4.getPointCount() - 1);
        }
      }
      t4.getPointCount() > 1 && (s3.addPathMultiPoint(t4, 0, -1, true), o && s3.closePathWithLine());
    }
    return s3;
  }
};
function jh2(e2, t3, s3, n5) {
  e2 && n5.insertPath2D(-1, null, 0, 0, true);
  const r = n5.getPathCount() - 1;
  n5.insertPointsFromPoints(r, -1, s3, 0, s3.length - 1, true), t3 && n5.insertPoint2D(r, -1, s3.at(-1));
}
function Zh2(e2, t3, s3, n5, r, i2, o) {
  o.reserve(o.getPointCount() + i2.length - 1);
  const a2 = new ee();
  if (s3.queryStart(a2), e2 ? o.startPathPoint(a2) : o.lineToPoint(a2), i2.length > 2) {
    const e3 = n5.calculateLength2D();
    for (let t4 = 1; t4 < i2.length - 1; t4++) {
      const s4 = n5.lengthToT(r[t4] * e3);
      n5.queryCoord(s4, a2), a2.setXY(i2[t4]), o.lineToPoint(a2);
    }
  }
  t3 && (s3.queryEnd(a2), o.lineToPoint(a2));
}
function Kh(e2, t3, s3, n5, r, i2, o, a2, h2, m3, l2, g2, u) {
  const c = { stack: [], error: void 0, hasError: false };
  try {
    const _ = __addDisposableResource(c, new Cc(), false), d2 = __addDisposableResource(c, new Cc(), false), p3 = __addDisposableResource(c, new Cc(), false);
    Dc.geodeticDistance(e2, t3, n5.x, n5.y, r.x, r.y, p3, _, d2, s3);
    const f3 = p3.val, x4 = _.val, y2 = d2.val;
    let P5 = x4, E2 = y2;
    P5 < 0 && (P5 += 2 * Math.PI), E2 < 0 && (E2 += 2 * Math.PI), h2 && (h2[0] = P5), m3 && (m3[0] = E2);
    let S3 = Number.NaN, C3 = Number.NaN;
    if (null !== l2) {
      const s4 = Vc.q90(e2, t3), r2 = Vc.q(e2, t3, n5.y);
      S3 = (s4 - r2) / f3, C3 = (s4 + r2) / f3;
    }
    const I4 = Lh2(n5, r), b2 = zh2(n5, r), w4 = I4 || b2, v3 = mm2(n5, r, a2), N2 = __addDisposableResource(c, new Ht(new Cc(), new Cc()), false), T3 = new mi(), G4 = new mi(), D3 = new mi();
    u[0] = im2(n5.x, Number.NaN, u[0]);
    let V4 = u[0];
    if (f3 <= i2) return g2.push(n5.clone()), u[0] = im2(r.x, Number.NaN, u[0]), null != l2 && l2.push(0), w4 ? (I4 && om2(n5, r, l2, g2), b2 && am2(n5, r, l2, g2)) : v3 ? hm2(n5, r, x4, S3, C3, l2, g2) : o > 0 && (G4.setCoords(n5.x - V4, n5.y), T3.setCoords(r.x - u[0], r.y), V4 = Jh2()), g2.push(r.clone()), f3;
    const F3 = 1 + Math.ceil(f3 / i2), H3 = f3 / (F3 - 1), k4 = new mi();
    g2.push(n5.clone()), k4.setCoordsPoint2D(n5), G4.setCoords(n5.x - u[0], n5.y), null !== l2 && l2.push(0);
    for (let i3 = 1; i3 < F3; i3++) {
      let h3;
      if (i3 < F3 - 1) {
        const r2 = i3 * H3;
        Dc.geodeticCoordinate(e2, t3, n5.x, n5.y, r2, x4, N2.at(0), N2.at(1), s3), T3.setCoords(N2.at(0).val, N2.at(1).val), u[0] = im2(T3.x, k4.x, u[0]), D3.setCoords(u[0] + T3.x, T3.y), h3 = i3 / (F3 - 1);
      } else u[0] = im2(r.x, Number.NaN, u[0]), T3.setCoords(r.x - u[0], r.y), D3.setCoordsPoint2D(r), h3 = 1;
      w4 ? (1 === i3 && I4 && om2(n5, D3, l2, g2), i3 === F3 - 1 && b2 && am2(k4, r, l2, g2)) : v3 ? lm2(k4, D3, a2) && (n5.x < r.x ? k4.x > D3.x && (u[0] += 2 * Math.PI, D3.setCoords(u[0] + T3.x, T3.y)) : k4.x < D3.x && (u[0] -= 2 * Math.PI, D3.setCoords(u[0] + T3.x, T3.y)), hm2(k4, D3, x4, S3, C3, l2, g2)) : o > 0 && Jh2(), g2.push(D3.clone()), null != l2 && l2.push(h3), k4.setCoordsPoint2D(D3), G4.setCoordsPoint2D(T3), V4 = u[0];
    }
    return f3;
  } catch (_) {
    c.error = _, c.hasError = true;
  } finally {
    __disposeResources(c);
  }
}
function Qh2(e2, t3, s3, n5, r, i2, a2, h2, m3, l2) {
  n(0);
}
function Jh2(e2, t3, s3, n5, r, i2, a2, h2, m3, l2, g2, u, c, _, d2) {
  return n(0), 0;
}
function $h(e2, t3, s3, n5) {
  const r = ds3(e2, t3, s3), i2 = ds3(e2, t3, n5);
  return X.distance(r, i2);
}
function em2(e2, t3, s3, n5, r, i2, a2, h2) {
  const m3 = new Array(), l2 = Ot(Array, 8);
  let g2 = 2, u = r.getCoord2D(i2);
  l2[0][0] = u.x, l2[0][1] = u.y, u = r.getCoord2D(a2), l2[1][0] = u.x, l2[1][1] = u.y;
  const c = (e3) => {
    if (null !== s3) {
      const t4 = wc.projToGeog(s3, e3, l2);
      n(t4 === e3);
    }
    for (const t4 of l2) t4[0] *= n5, t4[1] *= n5;
  };
  c(2), m3.push(ds3(e2, t3, new mi(l2[0][0], l2[0][1]))), m3.push(ds3(e2, t3, new mi(l2[1][0], l2[1][1])));
  let _ = X.distance(m3[0], m3[1]);
  if (_ > h2) return _;
  let d2 = 0;
  for (g2 = 3; g2 <= 17; ) {
    const s4 = 1 / (g2 - 1);
    let n6 = 0;
    for (let e3 = 1; e3 < g2; ++e3) if (1 & e3) {
      const t4 = Q(i2, a2, e3 * s4);
      r.queryCoord2D(t4, u), l2[n6][0] = u.x, l2[n6][1] = u.y, n6++;
    }
    c(n6);
    let p3 = 1;
    for (let r2 = 0; r2 < n6; ++r2) m3.splice(p3, 0, ds3(e2, t3, new mi(l2[r2][0], l2[r2][1]))), p3++;
    p3 = 0;
    let f3 = m3[p3];
    p3++;
    let x4 = 0;
    for (; p3 !== m3.length; ++p3) {
      const e3 = m3[p3];
      x4 += X.distance(f3, e3), f3 = e3;
    }
    if (x4 > h2) return x4;
    if (d2 = x4 - _, n(d2 >= 0 || Math.abs(d2) < 1e-14 * x4), d2 < 0 && (d2 = 0), _ = x4, x4 + d2 <= h2) return x4 + d2;
    g2 = 2 * g2 - 1;
  }
  return _ + d2;
}
function tm2(e2, t3, s3, n5, r, i2, a2, h2, m3) {
  const l2 = n5.isCurve(), g2 = Fs2(e2, t3) * Math.PI * 179 / 180;
  let u = i2;
  i2 > 0 && !(i2 > g2) || (u = g2);
  const c = a2, _ = c > 0;
  let d2 = Number.NaN;
  _ && (d2 = Bs3(e2, t3, c));
  const p3 = 1 === r.getCoordinateSystemType();
  let f3 = null;
  p3 || (f3 = r.getPECoordSys());
  const x4 = r.getTolerance(0), y2 = n5.getStartXY(), P5 = n5.getEndXY(), E2 = new mi(), S3 = new mi();
  if (p3) E2.setCoordsPoint2D(y2), E2.scale(s3), S3.setCoordsPoint2D(P5), S3.scale(s3);
  else {
    const e3 = [y2.x, y2.y, P5.x, P5.y];
    wc.projToGeog(f3, 2, e3), E2.setCoords(e3[0], e3[1]), E2.scale(s3), S3.setCoords(e3[2], e3[3]), S3.scale(s3);
  }
  let C3 = 0, I4 = 0;
  const b2 = [], w4 = [], v3 = [];
  b2.push(P5.clone()), w4.push(S3.clone()), v3.push(1), m3.push(y2.clone()), null !== h2 && h2.push(I4);
  const N2 = r.isPannable(), T3 = y2.clone(), G4 = [0.5, 0.33333333333333337, 0.6666666666666666, 0.16666666666666669, 0.8333333333333333];
  let D3 = 5;
  l2 || (_ ? (G4[0] = 0.5, G4[1] = 0.25, G4[2] = 0.75, D3 = 3) : D3 = 1), n(u > 0);
  const V4 = (e3) => {
    if (e3 = e3.clone(), null !== f3) {
      const t4 = [e3.x, e3.y];
      wc.projToGeog(f3, 1, t4), e3.setCoords(t4[0], t4[1]);
    }
    return e3.scale(s3), e3;
  };
  for (; w4.length > 0; ) {
    const i3 = b2.at(-1).clone();
    S3.assign(w4.at(-1));
    const a3 = v3.at(-1);
    let g3 = false, c2 = Number.NaN;
    const y3 = em2(e2, t3, f3, s3, n5, I4, a3, u);
    let P6 = u >= y3 && Math.abs(E2.y - S3.y) < 0.9 * Math.PI;
    p3 && P6 && (P6 = Math.abs(E2.x - S3.x) < 0.9 * Math.PI);
    const F3 = new mi(), H3 = new mi();
    let k4 = false;
    if (!_ && P6 && P6 && (k4 = true), n5.calculateSubLength(I4, a3) <= x4 && (k4 = true), !k4) for (let h3 = 0; h3 < D3; h3++) {
      const m4 = Q(I4, a3, G4[h3]), u2 = new mi();
      n5.queryCoord2D(m4, u2);
      const f4 = V4(u2);
      if (0 === h3 && (c2 = m4, F3.setCoordsPoint2D(u2), H3.setCoordsPoint2D(f4), !P6)) {
        g3 = true;
        break;
      }
      if (n(_), p3 && Math.abs(E2.x - f4.x) >= Math.PI) {
        g3 = true;
        break;
      }
      let x5 = new mi(), y4 = new mi();
      l2 ? (x5 = mi.lerp(T3, i3, G4[h3]), y4 = V4(x5)) : (x5 = u2.clone(), y4 = f4.clone());
      const C4 = Ss3(e2, t3, E2, S3, G4[h3]), b3 = C4.clone();
      if (p3 ? (b3.x /= s3, b3.y /= s3) : (b3.x /= s3, b3.y /= s3, Th2(r.getGCSToSRTransform(), [b3], 1, [b3], null)), b3.isNAN()) {
        const s4 = ds3(e2, t3, f4), n6 = ds3(e2, t3, E2), r2 = ds3(e2, t3, S3), { second: i4 } = vs3(e2, t3, s4, n6, r2, 2, null);
        if (i4 > d2) {
          g3 = true;
          break;
        }
      } else {
        if (N2) {
          const e3 = r.getPannableExtent().width(), t4 = Q(n5.getStartX(), n5.getEndX(), 0.5);
          for (; b3.x < t4 - 0.5 * e3; ) b3.x += e3;
          for (; b3.x >= t4 + 0.5 * e3; ) b3.x -= e3;
        }
        const s4 = n5.getClosestCoordinateOnInterval(b3, new x2(I4, a3), -1);
        let i4 = n5.getCoord2D(s4);
        i4 = V4(i4);
        let o = $h(e2, t3, i4, C4);
        if (o > d2) {
          if (o < 4 * d2) {
            const s5 = ds3(e2, t3, i4), n6 = ds3(e2, t3, E2), r2 = ds3(e2, t3, S3), { second: a4 } = vs3(e2, t3, s5, n6, r2, 2, null);
            o = a4;
          }
          if (o > d2) {
            g3 = true;
            break;
          }
        } else if (l2) {
          let s5 = ds3(e2, t3, f4);
          const n6 = ds3(e2, t3, E2), r2 = ds3(e2, t3, S3);
          let { second: i5 } = vs3(e2, t3, s5, n6, r2, 3, null);
          if (i5 <= d2) {
            s5 = ds3(e2, t3, y4);
            const { second: o2 } = vs3(e2, t3, s5, n6, r2, 3, null);
            i5 = o2;
          }
          if (i5 > d2) {
            g3 = true;
            break;
          }
        }
      }
    }
    g3 ? (b2.push(F3.clone()), w4.push(H3.clone()), v3.push(c2)) : (b2.pop(), w4.pop(), v3.pop(), m3.push(i3.clone()), C3 += y3, null !== h2 && h2.push(C3), T3.setCoordsPoint2D(i3), E2.setCoordsPoint2D(S3), I4 = a3);
  }
  if (null !== h2) {
    const e3 = 1 / C3;
    for (let t4 = 0; t4 < h2.length; t4++) h2[t4] *= e3;
  }
}
function sm2(e2, t3, s3, n5) {
  if (n5.reverse(), null !== s3 && s3.reverse(), e2) {
    const s4 = e2[0], n6 = t3[0];
    e2[0] = n6, t3[0] = s4;
  }
}
function nm2(e2, t3, s3, n5, r) {
  e2 ? (n5.setCoordsPoint2D(s3), r.setCoordsPoint2D(t3)) : (n5.setCoordsPoint2D(t3), r.setCoordsPoint2D(s3));
}
function rm2(e2, t3, s3) {
  return e2 ? (s3.create(t3.getGeometryType()), t3.copyTo(s3.get()), s3.get().reverse(), s3.get()) : t3;
}
function im2(e2, t3, s3) {
  if (Number.isNaN(t3)) {
    for (; s3 - e2 > Math.PI; ) s3 -= 2 * Math.PI;
    for (; e2 - s3 > Math.PI; ) s3 += 2 * Math.PI;
    return s3;
  }
  return s3 + e2 - t3 > Math.PI ? s3 -= 2 * Math.PI : t3 - (s3 + e2) > Math.PI && (s3 += 2 * Math.PI), s3;
}
function om2(e2, t3, s3, n5) {
  if (e2.y > 0) {
    const r = new mi();
    r.setCoords(t3.x, Wt), Pc(e2.x, r.x) || Pc(t3.y, r.y) || (n5.push(r), null !== s3 && s3.push(0));
  } else {
    const r = new mi();
    r.setCoords(t3.x, -Wt), Pc(e2.x, r.x) || Pc(t3.y, r.y) || (n5.push(r), null !== s3 && s3.push(0));
  }
}
function am2(e2, t3, s3, n5) {
  if (t3.y > 0) {
    const r = new mi();
    r.setCoords(e2.x, Wt), Pc(t3.x, r.x) || Pc(e2.y, r.y) || (n5.push(r), null !== s3 && s3.push(1));
  } else {
    const r = new mi();
    r.setCoords(e2.x, -Wt), Pc(t3.x, r.x) || Pc(e2.y, r.y) || (n5.push(r), null !== s3 && s3.push(1));
  }
}
function hm2(e2, t3, s3, n5, r, i2, o) {
  if (Sc(s3)) {
    if (Wt - e2.y > 0) {
      const t4 = new mi();
      t4.setCoords(e2.x, Wt), o.push(t4), null !== i2 && i2.push(n5);
    }
    if (Wt - t3.y > 0) {
      const e3 = new mi();
      e3.setCoords(t3.x, Wt), o.push(e3), null !== i2 && i2.push(n5);
    }
  } else {
    if (Wt + e2.y > 0) {
      const t4 = new mi();
      t4.setCoords(e2.x, -Wt), o.push(t4), null !== i2 && i2.push(r);
    }
    if (Wt + t3.y > 0) {
      const e3 = new mi();
      e3.setCoords(t3.x, -Wt), o.push(e3), null !== i2 && i2.push(r);
    }
  }
}
function mm2(e2, t3, s3) {
  return !(!lm2(e2, t3, s3) || Pc(e2.y, Wt) || Pc(e2.y, -Wt) || Pc(t3.y, Wt) || Pc(t3.y, -Wt));
}
function lm2(e2, t3, s3) {
  return Math.abs(Math.abs(e2.x - t3.x) - Math.PI) <= s3;
}
function gm2(e2) {
  if (e2.x < -Math.PI) for (; e2.x < -Math.PI; ) e2.x += 2 * Math.PI;
  else if (e2.x > Math.PI) for (; e2.x > Math.PI; ) e2.x -= 2 * Math.PI;
}
function um2(e2, t3, s3, n5) {
  const r = { stack: [], error: void 0, hasError: false };
  try {
    const i2 = [s3.x], o = [s3.y - n5], a2 = [s3.x], h2 = [s3.y + n5];
    Vs3(i2, o), Vs3(a2, h2);
    const m3 = __addDisposableResource(r, new Cc(), false), l2 = __addDisposableResource(r, new Cc(), false);
    Dc.greatEllipticDistance(e2, t3, s3.x, s3.y, i2[0], o[0], m3, null, null), Dc.greatEllipticDistance(e2, t3, s3.x, s3.y, a2[0], h2[0], l2, null, null);
    return Math.min(m3.val, l2.val);
  } catch (i2) {
    r.error = i2, r.hasError = true;
  } finally {
    __disposeResources(r);
  }
}
function cm2(e2, t3, s3, n5, r) {
  const i2 = new n3();
  s3.queryEnvelope(i2);
  const o = Bt2(null, s3, true).total();
  if (t3.xmin - i2.xmin <= o && i2.xmax - t3.xmax <= o) return s3;
  const a2 = t3.width();
  let h2 = 0;
  for (; t3.xmin + h2 * a2 < i2.xmin; ) h2++;
  for (; t3.xmin + h2 * a2 > i2.xmin; ) h2--;
  const m3 = h2 * a2, l2 = new x3();
  l2.setShiftCoords(-m3, 0);
  const g2 = s3;
  g2.applyTransformation(l2);
  const u = new n3();
  g2.queryEnvelope(u);
  let c = null;
  if (u.xmax > t3.xmax) {
    let s4 = 0;
    const n6 = new n3();
    n6.setCoords({ env2D: t3 }), n6.ymin -= 1, n6.ymax += 1;
    let i3 = g2;
    for (; n6.xmin < u.xmax; ) {
      u.xmax > n6.xmax && (i3 = Hl(i3, e2, 2, true, n6.xmax));
      const o2 = Dt2(i3, n6), h3 = At(null, o2, true).total(), m4 = f2(i3, n6, h3, Number.NaN, r);
      null === c ? c = m4 === i3 ? m4.clone() : m4 : (l2.setShiftCoords(-s4 * a2, 0), m4.applyTransformation(l2), c.add(m4, false)), s4++, n6.xmin = n6.xmax, n6.xmax = t3.xmax + s4 * a2;
    }
  } else c = g2;
  return c;
}
var _m2 = class {
  constructor(e2, t3) {
    this.m_basisX = new X(), this.m_basisY = new X(), this.m_normal = new X(), n(1 === e2.getCoordinateSystemType()), this.m_gcs = e2;
    const s3 = Hu2();
    e2.querySpheroidData(s3), this.m_a = s3.majorSemiAxis, this.m_e2 = s3.e2, this.m_rpu = e2.getUnit().getUnitToBaseFactor(), this.m_curvCenterRad = t3.mul(this.m_rpu);
    const n5 = this.m_curvCenterRad.x, r = this.m_curvCenterRad.y, i2 = Math.cos(n5), a2 = Math.sin(n5), h2 = Math.cos(r), m3 = Math.sin(r);
    this.m_cartCenter3D = fs3(this.m_a, this.m_e2, i2, a2, h2, m3), this.m_normal.setCoordsPoint3D(this.m_cartCenter3D), this.m_d = this.m_cartCenter3D.length(), this.m_normal.divThis(this.m_d), X.selectRightHandedBasisFromNormal(this.m_normal, this.m_basisX, this.m_basisY), this.m_northPolePcs = this.projectPoint(mi.construct(0, 0.5 * Math.PI / this.m_rpu)), this.m_southPolePcs = this.projectPoint(mi.construct(0, 0.5 * -Math.PI / this.m_rpu));
  }
  project(t3) {
    const s3 = t3.getGeometryType();
    if (y(s3)) {
      N(t3);
      const e2 = t3;
      return this.projectMultiVertex(e2);
    }
    P("Gnomonic.project");
  }
  unproject(t3, n5, r) {
    const o = t3.getGeometryType();
    if (y(o)) {
      N(t3);
      let e2 = t3;
      const a2 = [];
      if (o === a.enumPolygon) {
        const t4 = e2.getPathCount();
        for (let s3 = 0; s3 < t4; s3++) {
          const t5 = e2.calculateRingArea2D(s3);
          a2.push(t5);
        }
      }
      return this.unprojectMultiVertex(n5, e2), h(o) ? (Cm(this.m_gcs, 0, e2), dm2(a2, this.m_gcs, 0, e2, r)) : e2 = vl(e2, this.m_gcs, 0, true, 0, r), e2;
    }
    P("Gnomonic.unproject");
  }
  projectPoint(e2) {
    const t3 = e2.mul(this.m_rpu), s3 = ds3(this.m_a, this.m_e2, t3), n5 = this.m_normal.dotProduct(s3);
    if (n5 <= 0) return mi.construct(Number.NaN, Number.NaN);
    const r = this.m_d / n5, i2 = s3.mul(r).sub(this.m_cartCenter3D), o = new mi();
    return o.x = this.m_basisX.dotProduct(i2), o.y = this.m_basisY.dotProduct(i2), o;
  }
  unprojectPoint(e2) {
    const t3 = this.m_cartCenter3D.add(this.m_basisX.mul(e2.x).add(this.m_basisY.mul(e2.y)));
    return Ps3(this.m_a, this.m_e2, t3).divide(this.m_rpu);
  }
  projectMultiVertex(e2) {
    const t3 = e2.getImpl();
    let s3 = true;
    const n5 = new mi(), r = new mi();
    for (let i2 = 0, o = t3.getPointCount(); i2 < o; i2++) t3.queryXY(i2, n5), n5.y * this.m_rpu > 0.5 * Math.PI ? r.assign(this.m_northPolePcs) : n5.y * this.m_rpu < 0.5 * -Math.PI ? r.assign(this.m_southPolePcs) : r.assign(this.projectPoint(n5)), t3.setXYNoCurves(i2, r), r.isNAN() && (s3 = false);
    return t3.notifyModifiedFlags(2001), s3;
  }
  unprojectMultiVertex(e2, t3) {
    const s3 = t3.getImpl(), n5 = e2 * e2, r = !this.m_northPolePcs.isNAN(), i2 = !this.m_southPolePcs.isNAN();
    for (let o = 0, a2 = s3.getPointCount(); o < a2; o++) {
      const e3 = s3.getXY(o);
      let t4 = new mi();
      r && mi.sqrDistance(e3, this.m_northPolePcs) <= n5 ? (t4.setCoords(this.m_curvCenterRad.x, 0.5 * Math.PI), t4.scale(1 / this.m_rpu)) : i2 && mi.sqrDistance(e3, this.m_southPolePcs) <= n5 ? (t4.setCoords(this.m_curvCenterRad.x, 0.5 * -Math.PI), t4.scale(1 / this.m_rpu)) : t4 = this.unprojectPoint(e3), s3.setXYNoCurves(o, t4);
    }
    s3.notifyModifiedFlags(2001);
  }
};
function dm2(e2, t3, n5, r, i2) {
  const o = r.getGeometryType(), a2 = t3.getPannableExtent();
  let h2 = r, m3 = false, l2 = false;
  if (o === a.enumPolygon) {
    const s3 = new n3(), r2 = mi.construct(n5, 0);
    s3.setCoords({ env2D: a2 }), s3.centerAt(r2), m3 = pm2(e2, t3, s3, h2, i2);
    const o2 = Sm(t3, s3, h2, i2);
    o2 !== h2 && (l2 = true), h2 = o2;
  } else h2 = new qh().foldInto360RangeGeodetic(h2, t3, 2);
  o === a.enumPolygon && (m3 || l2) && (h2 = new Eh2().execute(h2, t3, false, i2)), h2 !== r && (r.setEmpty(), r.add(h2, false));
}
function pm2(e2, t3, s3, n5, r) {
  const i2 = fm2(s3, n5), o = xm(e2, t3, s3, n5, r);
  return i2 || o;
}
function fm2(e2, t3) {
  const s3 = new n3();
  t3.queryEnvelope(s3);
  const n5 = Pc(e2.ymax, s3.ymax), r = Pc(e2.ymin, s3.ymin), i2 = n5 || r;
  return !!i2 && (ym(e2, t3), i2);
}
function xm(e2, t3, s3, n5, r) {
  const i2 = [], o = [], a2 = 0.5 * s3.width();
  for (let g2 = 0; g2 < n5.getPathCount(); g2++) {
    const h3 = n5.getXY(n5.getPathStart(g2)), m4 = n5.getXY(n5.getPathEnd(g2) - 1), l3 = e2[g2] < 0;
    if (Math.abs(h3.x - m4.x) > a2) {
      const e3 = Pm(l3, t3, s3, g2, n5, r);
      i2.push(e3), o.push(g2);
    } else if (!l3) {
      if (n5.calculateRingArea2D(g2) < 0) {
        const e3 = Em(t3, s3, g2, n5, r);
        i2.push(e3), o.push(g2);
      }
    }
  }
  if (0 === i2.length) return false;
  const h2 = new ur({ vd: n5.getDescription() });
  let m3 = 0, l2 = o[m3];
  for (let g2 = 0; g2 < n5.getPathCount(); g2++) g2 === l2 ? (h2.add(i2[m3], false), m3++, m3 < o.length && (l2 = o[m3])) : h2.addPath(n5, g2, true);
  return n5.setEmpty(), n5.add(h2, false), true;
}
function ym(e2, t3) {
  const s3 = new ur(), n5 = new n3();
  for (let r = 0; r < t3.getPathCount(); r++) {
    t3.queryPathEnvelope(r, n5);
    let i2 = Pc(e2.ymax, n5.ymax), o = Pc(e2.ymin, n5.ymin);
    if (!(i2 || o)) {
      s3.addPath(t3, r, true);
      continue;
    }
    s3.insertPath2D(-1, null, 0, 0, true);
    const a2 = t3.getPathStart(r), h2 = t3.getPathEnd(r), m3 = h2 - a2;
    let l2 = -1;
    for (l2 = a2; l2 < h2; l2++) {
      const s4 = t3.getXY(l2);
      if (i2 = Pc(e2.ymax, s4.y), o = Pc(e2.ymin, s4.y), !i2 && !o) break;
    }
    let g2 = l2, u = false, c = Number.NaN;
    do {
      const n6 = t3.getXY(g2);
      i2 = Pc(e2.ymax, n6.y), o = Pc(e2.ymin, n6.y);
      const h3 = a2 + (g2 + 1 - a2) % m3;
      if (i2 || o) {
        let i3 = mi.construct(c, n6.y);
        s3.insertPoint2D(r, -1, i3);
        const o2 = t3.getXY(h3), a3 = Pc(e2.ymax, o2.y), m4 = Pc(e2.ymin, o2.y);
        a3 || m4 || (i3 = mi.construct(o2.x, n6.y), u ? s3.setXYNoCurves(s3.getPointCount() - 1, i3) : s3.insertPoint2D(r, -1, i3)), u = true;
      } else s3.insertPoint2D(r, -1, n6), c = n6.x, u = false;
      g2 = h3;
    } while (g2 !== l2);
  }
  t3.setEmpty(), t3.add(s3, false);
}
function Pm(e2, t3, s3, n5, r, i2) {
  const o = new ur(), a2 = new ur(), h2 = new x3(), m3 = r.getXY(r.getPathStart(n5)), l2 = r.getXY(r.getPathEnd(n5) - 1), g2 = s3.width(), u = 0.5 * g2, c = new n3();
  r.queryEnvelope(c);
  const _ = Math.ceil(c.width() / g2) + 1;
  let d2, p3;
  m3.x > l2.x ? (d2 = -g2, p3 = e2 ? s3.ymin : s3.ymax) : (d2 = g2, p3 = e2 ? s3.ymax : s3.ymin), h2.setShiftCoords(d2, 0), o.addPath(r, n5, true), a2.add(o, false);
  const f3 = new ee();
  for (let C3 = 0; C3 < _; C3++) a2.applyTransformation(h2), a2.getPointByVal(0, f3), o.lineToPoint(f3), o.addSegmentsFromPath(a2, 0, 0, a2.getSegmentCount() - 1, false);
  const x4 = o.getXY(0), y2 = o.getXY(o.getPointCount() - 1);
  x4.y = p3, y2.y = p3, o.lineTo(y2);
  const P5 = new mi();
  for (P5.setCoordsPoint2D(y2), P5.x -= 0.5 * d2; Math.abs(P5.x - x4.x) > u; ) o.lineTo(P5), P5.x -= 0.5 * d2;
  o.lineTo(x4);
  const E2 = s3.getCenter().x, S3 = new n3();
  o.queryEnvelope(S3);
  let I4 = 0;
  const b2 = S3.getCenter().x;
  b2 - E2 > u ? I4 = -Math.ceil((b2 - E2 - u) / g2) : E2 - b2 > u && (I4 = Math.ceil((E2 - b2 - u) / g2)), 0 !== I4 && (h2.setShiftCoords(I4 * g2, 0), o.applyTransformation(h2));
  const w4 = new Pr(), N2 = w4.addGeometry(o);
  kl(w4, N2, t3, 0, 2, true, s3.xmin), kl(w4, N2, t3, 0, 2, true, s3.xmax);
  const T3 = w4.getGeometry(N2), D3 = Dt2(T3, s3);
  D3.inflateCoords(0, 1);
  const V4 = At(null, D3, true);
  return f2(T3, s3, V4.total(), Number.NaN, i2);
}
function Em(e2, t3, s3, n5, r) {
  const i2 = t3.width(), o = 0.5 * i2, a2 = t3.getCenter().x, h2 = new n3();
  n5.queryPathEnvelope(s3, h2);
  let m3, l2 = 0, g2 = h2.getCenter().x;
  if (g2 - a2 > o ? l2 = -Math.ceil((g2 - a2 - o) / i2) : a2 - g2 > o && (l2 = Math.ceil((a2 - g2 - o) / i2)), 0 !== l2) {
    const e3 = new x3();
    e3.setShiftCoords(l2 * i2, 0), n5.getImpl().applyTransformationToPath(e3, s3), n5.queryPathEnvelope(s3, h2), g2 = h2.getCenter().x;
  }
  const u = new n3();
  t3.containsExclusiveEnvelope(h2) ? (m3 = false, u.setCoords({ env2D: t3 })) : (m3 = true, u.setCoords({ env2D: t3 }), u.xmin -= i2, u.xmax += i2);
  let c = n5.createInstance();
  c.addPathPoint2D(null, 0, true);
  const _ = new mi();
  if (_.setCoords(u.xmin, u.ymin), c.insertPoint2D(0, -1, _), _.setCoords(u.xmin, u.ymax), c.insertPoint2D(0, -1, _), _.setCoords(0.5 * (u.xmin + u.xmax), u.ymax), c.insertPoint2D(0, -1, _), _.setCoords(u.xmax, u.ymax), c.insertPoint2D(0, -1, _), _.setCoords(u.xmax, u.ymin), c.insertPoint2D(0, -1, _), _.setCoords(0.5 * (u.xmin + u.xmax), u.ymin), c.insertPoint2D(0, -1, _), m3) {
    c.addPath(n5, s3, true);
    const o2 = new x3();
    g2 < a2 ? o2.setShiftCoords(i2, 0) : o2.setShiftCoords(-i2, 0), n5.getImpl().applyTransformationToPath(o2, s3), c.addPath(n5, s3, true);
    const h3 = new Pr(), m4 = h3.addGeometry(c);
    kl(h3, m4, e2, 0, 2, true, t3.xmin), kl(h3, m4, e2, 0, 2, true, t3.xmax), c = h3.getGeometry(m4);
    const l3 = Dt2(c, t3);
    l3.inflateCoords(0, 1);
    const u2 = At(null, l3, true).total();
    c = f2(c, t3, u2, Number.NaN, r);
  } else c.addPath(n5, s3, true);
  return c;
}
function Sm(e2, t3, s3, n5) {
  const r = new n3();
  s3.queryEnvelope(r);
  const i2 = Bt2(null, s3, true).total();
  if (t3.xmin - r.xmin <= i2 && r.xmax - t3.xmax <= i2) return s3;
  const o = s3.createInstance();
  let a2 = s3.createInstance();
  const h2 = new n3(), m3 = s3.getPathCount();
  for (let l2 = 0; l2 < m3; l2++) s3.queryPathEnvelope(l2, h2), t3.xmin - h2.xmin <= i2 && h2.xmax - t3.xmax <= i2 ? o.addPath(s3, l2, true) : (a2.setEmpty(), a2.addPath(s3, l2, true), a2 = cm2(e2, t3, a2, true, n5), o.add(a2, true));
  return o;
}
function Cm(e2, t3, s3) {
  const n5 = e2.getPannableExtent(), r = mi.construct(t3, 0);
  n5.centerAt(r);
  const i2 = n5.width(), o = 0.5 * i2, a2 = new mi();
  a2.setNAN();
  let h2 = Number.NaN;
  for (let m3 = 0; m3 < s3.getPathCount(); m3++) for (let e3 = s3.getPathStart(m3); e3 < s3.getPathEnd(m3); e3++) {
    const t4 = s3.getXY(e3), r2 = Pc(t4.y, n5.ymax) || Pc(n5.ymin, t4.y);
    e3 === s3.getPathStart(m3) ? (a2.setNAN(), h2 = 0) : a2.isNAN() || r2 || (h2 = Im(t4.x, a2.x, o, i2, h2)), t4.x += h2, s3.setXYNoCurves(e3, t4), r2 || a2.setCoordsPoint2D(t4);
  }
  s3.getImpl().notifyModifiedFlags(2001);
}
function Im(e2, t3, s3, n5, r) {
  return r + e2 - t3 > s3 ? r -= n5 : t3 - (r + e2) > s3 && (r += n5), r;
}
function bm(e2, t3, s3, n5, r, i2) {
  const o = t3.getAttributeStreamRef(0), a2 = t3.getPointCount();
  let h2 = false;
  const m3 = new mi();
  for (let P5 = 0; P5 < a2; ++P5) {
    if (o.queryPoint2D(2 * P5, m3), 1 & i2 && m3.y >= s3) {
      h2 = true;
      break;
    }
    if (2 & i2 && m3.y <= -s3) {
      h2 = true;
      break;
    }
  }
  if (!h2) return false;
  let l2 = false;
  e2 && (l2 = t3.getImpl().isClosedPathInXYPlane(0));
  const g2 = new Pr(), u = g2.addGeometry(t3), c = g2.getFirstPath(u);
  let _ = -1, d2 = true;
  const p3 = new mi(), f3 = new ee();
  let x4 = cr;
  const y2 = Gm * r / 360;
  for (let P5 = g2.getFirstVertex(c); P5 !== cr; P5 = g2.getNextVertex(P5)) {
    g2.queryXY(P5, m3);
    let e3 = 1 & i2 && m3.y >= s3 ? 1 : 0;
    if (e3 |= 2 & i2 && m3.y <= -s3 ? 2 : 0, _ > 0 && _ !== e3) {
      if (p3.x !== m3.x) {
        const e4 = g2.getPrevVertex(P5);
        g2.queryPoint(e4, f3);
        const t4 = g2.insertVertex(c, P5, f3);
        p3.x = m3.x, g2.setXY(t4, p3);
      }
      if (l2) {
        let e4 = x4 !== cr ? g2.getNextVertex(x4) : g2.getFirstVertex(c);
        const t4 = g2.getPrevVertex(P5);
        for (; e4 !== t4; ) e4 = g2.removeVertex(e4, false);
        if (x4 !== cr) {
          const e5 = g2.getXY(x4), s4 = g2.getXY(t4);
          if (Math.abs(e5.x - s4.x) > y2) {
            g2.queryPoint(x4, f3);
            const n6 = g2.insertVertex(c, t4, f3);
            e5.x = Q(e5.x, s4.x, 0.5), g2.setXY(n6, e5);
          }
        }
      }
      x4 = cr;
    }
    if (e3 && (m3.y = B2(n5, m3.y), g2.setXY(P5, m3), !d2 && _ !== e3)) if (m3.x !== p3.x) {
      g2.queryPoint(P5, f3);
      const e4 = g2.insertVertex(c, P5, f3);
      g2.setXYCoords(e4, p3.x, m3.y), x4 = e4;
    } else x4 = P5;
    _ = e3, p3.assign(m3), d2 = false;
  }
  if (l2) {
    if (x4 !== cr) {
      let e4 = g2.getNextVertex(x4);
      for (; e4 !== cr; ) e4 = g2.removeVertex(e4, false);
    }
    const e3 = g2.getFirstVertex(c);
    let t4 = g2.getLastVertex(c);
    const s4 = g2.getXY(e3), n6 = g2.getXY(t4);
    if (!s4.equals(n6) && (g2.queryPoint(e3, f3), t4 = g2.insertVertex(c, cr, f3), Math.abs(s4.x - n6.x) > y2)) {
      const e4 = g2.insertVertex(c, t4, f3);
      s4.x = Q(s4.x, n6.x, 0.5), g2.setXY(e4, s4);
    }
  }
  return t3.assignCopy(g2.getGeometry(u)), true;
}
function wm(e2, t3) {
  let s3 = new ur({ vd: e2 });
  s3.addEnvelope(t3, false);
  const n5 = t3.width() / 180;
  return s3 = new m2().execute(s3, n5, 0, 0, null), s3;
}
function vm(e2, t3) {
  const s3 = e2.getPannableExtent();
  return Number.isNaN(t3) || s3.centerAtCoords(t3, 0), s3;
}
function Nm(e2, t3, s3) {
  const n5 = Hu2();
  t3.querySpheroidData(n5);
  const r = t3.getGCS() !== t3 ? t3.getSRToGCSTransform() : null, i2 = Ot(mi, 100), o = new X(0, 0, 0), a2 = e2.getPointCount(), h2 = t3.getGCS().getUnit().getUnitToBaseFactor();
  for (let u = 0, c = a2; u < c; ) {
    const t4 = Math.min(100, c - u);
    e2.queryCoordinates(i2, t4, u, u + t4), r && new qh().transform(r, i2, t4, i2, false);
    for (let e3 = 0; e3 < t4; e3++) {
      if (i2[e3].isNAN()) continue;
      i2[e3].scale(h2);
      const t5 = ds3(n5.majorSemiAxis, n5.e2, i2[e3]);
      o.addThis(t5);
    }
    u += t4;
  }
  const m3 = Ps3(n5.majorSemiAxis, n5.e2, o);
  m3.scale(1 / h2);
  const l2 = e2;
  if (!new _m2(t3.getGCS(), m3).project(l2)) return 0;
  s3.length = e2.getPathCount();
  const g2 = l2.calculateArea2D() < 0;
  for (let u = 0, c = e2.getPathCount(); u < c; u++) {
    const e3 = l2.calculateRingArea2D(u), t4 = g2 ? e3 < 0 : e3 > 0;
    s3[u] = t4;
  }
  return g2 ? -1 : 1;
}
function Tm(e2, t3, n5, i2, o) {
  if (!t3.isPannable() || e2.isEmpty()) return e2;
  const a2 = e2.getGeometryType();
  a2 === a.enumGeometryCollection && z("not yet impl for geometry collection");
  const h2 = t3.getPannableExtent();
  Number.isNaN(n5) && (n5 = h2.getCenterX());
  const m3 = h2.width(), l2 = 0.5 * m3, u = o > 0, c = e2.queryInterval(0, 0);
  if (!u && c.width() < l2 || !y(e2.getGeometryType())) {
    const t4 = c.getCenter();
    if (Math.abs(t4 - n5) <= l2) return e2;
    {
      const s3 = new x3(), r = S((n5 - t4) / m3) * m3;
      s3.setShiftCoords(r, 0);
      const i3 = e2.clone();
      return i3.applyTransformation(s3), i3;
    }
  }
  if (a2 === a.enumPolygon) {
    let s3 = new Os2({ vd: e2.getDescription() });
    s3.addAndExplicitlyOpenAllPaths(e2, false), u && (s3 = Oh(s3, t3, 2, o, Number.NaN, null, true));
    const r = [];
    if (!i2) {
      {
        let n6 = e2;
        u && (n6 = new ur(), n6.add(s3, false));
        const i3 = Nm(e2, t3, r);
        if (i3) i3 < 0 && s3.reverseAllPaths();
        else {
          const e3 = n6.getPathCount();
          for (let t4 = 0; t4 < e3; t4++) r.push(n6.calculateRingArea2D(t4) > 0);
        }
      }
      i2 = r;
    }
    return new Dm(null, i2, s3, null, t3, n5, 3, 0, null).geoNormalizePolygonGeometry(true);
  }
  if (a2 === a.enumPolyline) {
    let s3 = new Os2({ vd: e2.getDescription() });
    s3.addAndExplicitlyOpenAllPaths(e2, false), u && (s3 = Oh(s3, t3, 2, o, Number.NaN, null, true));
    return new Dm(null, null, s3, null, t3, n5, 3, 0, null).geoNormalizePolylineGeometry(true);
  }
  if (a2 === a.enumMultiPoint) {
    const t4 = e2, s3 = t4.getAttributeStreamRef(0);
    let r, i3 = null, o2 = n5, a3 = 0;
    const h3 = 0.1 * m3;
    for (let n6 = 0, g2 = t4.getPointCount(); n6 < g2; n6++) {
      const t5 = s3.read(2 * n6);
      let g3 = t5 - o2;
      if (Math.abs(g3) > l2 && (g3 = S(g3 / m3) * m3, a3 -= g3, Math.abs(a3) < h3 && (a3 = 0)), 0 !== a3) {
        i3 || (r = e2.clone(), i3 = r.getAttributeStreamRef(0));
        const s4 = t5 + a3;
        i3.write(2 * n6, s4);
      }
      o2 = t5;
    }
    return i3 ? (r.notifyModified(), r) : e2;
  }
  b("");
}
var Gm = 210;
var Dm = class {
  constructor(e2, t3, s3, n5, r, i2, a2, h2, m3) {
    this.m_bAdjustedAtPoles = 0, this.m_inputPoly = s3, this.m_progressTracker = m3, this.m_originalGeometry = e2, this.m_originalSR = n5, this.m_polygonRingFlags = t3, this.m_pannableSR = r, this.m_poleSnappingTolerance = h2, this.m_poleFlags = a2, this.m_bAdjustedAtPoles = 0, this.m_pannableExtent = vm(this.m_pannableSR, i2), this.m_centralLongitude = Number.isNaN(i2) ? this.m_pannableExtent.getCenterX() : i2, this.m_width360 = this.m_pannableExtent.width(), this.m_degree = this.m_width360 / 360, this.m_GCSLargeDelta = Gm * this.m_degree, n(null === this.m_originalGeometry && null === this.m_originalSR || null !== this.m_originalGeometry && null !== this.m_originalSR);
  }
  geonormalizeRing(e2, t3, s3, n5, i2, a2, h2) {
    let m3 = s3;
    const l2 = new Os2({ vd: this.m_inputPoly.getDescription() });
    l2.addPath(this.m_inputPoly, e2, true), 0 !== this.m_poleFlags && (this.m_bAdjustedAtPoles |= bm(true, l2, this.m_pannableExtent.ymax - this.m_poleSnappingTolerance, this.m_pannableExtent.ymax, this.m_pannableExtent.width(), this.m_poleFlags) ? 1 : 0, this.m_bAdjustedAtPoles && (m3 = false));
    let g2 = -1;
    m3 && (g2 = this.m_originalGeometry.getPathStart(e2));
    const u = l2.getAttributeStreamRef(0), c = l2.getPointCount();
    let _ = 0, d2 = u.read(0), p3 = 0;
    const f3 = 3 * this.m_pannableSR.getTolerance(0);
    let x4 = false;
    const y2 = new mi(), P5 = new mi();
    let E2 = false;
    const S3 = l2.hasNonLinearSegments(), C3 = new mi();
    for (let o = 1; o < c; ++o) {
      u.queryPoint2D(2 * o, C3);
      const e3 = C3.x;
      let t4 = e3 + _;
      const s4 = t4 - d2;
      if (C3.x = t4, Math.abs(s4) > this.m_GCSLargeDelta) {
        if (m3) {
          const e4 = g2 + o - 1, t5 = g2 + (o + 1 < c ? o : 0), r = a2.read(2 * e4), i3 = (a2.read(2 * t5) - r) * n5;
          Math.abs(s4 - i3) > 1 * this.m_degree && (m3 = false);
        }
        if (!m3) {
          _ -= B2(this.m_width360, t4 - d2), t4 = e3 + _, ++p3, E2 = 0 !== _, C3.x = t4;
        }
      } else x4 || bt(y2, P5, C3, f3) && (x4 = true);
      E2 && (S3 && b("error in geonormalize_ring_ for curves"), u.write(2 * o, t4)), d2 = t4, y2.setCoordsPoint2D(P5), P5.setCoordsPoint2D(C3);
    }
    p3 && l2.notifyModified();
    const b2 = l2.getXY(0), w4 = l2.getXY(c - 1);
    if (mi.distance(b2, w4) < f3) {
      const e3 = this.finalizeGeoNormalizeClosedRing(l2, x4, i2);
      h2.add(e3, false);
    } else {
      if (t3 < 0) if (null !== this.m_originalGeometry) {
        n(null !== this.m_originalGeometry);
        t3 = this.m_originalGeometry.calculateRingArea2D(e2) > 0 ? 1 : 0;
      } else t3 = 1;
      const s4 = this.finalizeGeoNormalizeOpenedRing(t3 > 0, l2);
      h2.add(s4, false);
    }
  }
  geoNormalizePolygonGeometry(e2) {
    n(this.m_originalSR && this.m_originalGeometry || !this.m_originalGeometry && !this.m_originalSR), n(this.m_pannableSR.isPannable());
    let t3 = null, s3 = Number.NaN;
    const n5 = !!this.m_originalSR && this.m_originalSR.isPannable();
    n5 && (t3 = this.m_originalGeometry.getAttributeStreamRef(0), s3 = this.m_width360 / this.m_originalSR.getPannableExtent().width()), this.m_bAdjustedAtPoles = 0;
    const r = new ur({ vd: this.m_inputPoly.getDescription() });
    for (let o = 0, _ = this.m_inputPoly.getPathCount(); o < _; ++o) {
      const i3 = this.m_polygonRingFlags ? this.m_polygonRingFlags[o] ? 1 : 0 : -1;
      this.geonormalizeRing(o, i3, n5, s3, e2, t3, r);
    }
    const i2 = this.m_pannableSR.getTolerance(0), a2 = this.m_pannableExtent.width() / 180;
    Ol(r, this.m_pannableExtent, 0.1 * i2, false);
    const h2 = n3.constructEmpty();
    if (h2.setCoords({ env2D: this.m_pannableExtent }), e2) {
      let e3 = true;
      for (let t4 = 0; t4 < 2; t4++) {
        e3 = true;
        const t5 = n3.constructEmpty();
        for (let s4 = 0, n6 = r.getPathCount(); s4 < n6; s4++) if (r.queryPathEnvelope(s4, t5), !(h2.xmin <= t5.xmin && h2.xmax >= t5.xmax || t5.xmin >= h2.xmax || t5.xmax <= h2.xmin)) {
          e3 = false;
          break;
        }
        if (e3) break;
        h2.move(0.5 * this.m_width360, 0);
      }
      e3 || h2.setCoords({ env2D: this.m_pannableExtent });
    }
    let m3 = f2(r, h2, i2, a2, this.m_progressTracker), l2 = r !== m3;
    const g2 = this.m_originalGeometry ? this.m_originalGeometry.calculateArea2D() : 1, u = m3.calculateArea2D();
    let c = 0;
    if (u > 0 && g2 < 0) c = 1;
    else if (u <= 0 && g2 > 0) if (0 === u) {
      if (this.m_originalSR) {
        let e3 = Number.NaN;
        2 === this.m_originalSR.getCoordinateSystemType() ? e3 = this.m_originalSR.getPCSHorizon().calculateArea2D() : 1 === this.m_originalSR.getCoordinateSystemType() && (e3 = this.m_originalSR.getPannableExtent().getArea()), g2 > 0.99 * e3 && (c = -1);
      }
    } else c = -1;
    if (0 !== c) {
      const e3 = wm(m3.getDescription(), h2);
      e3.add(m3, false), l2 = true, m3 = e3;
    }
    return l2 && (m3 = new Eh2().execute(m3, this.m_pannableSR, false, this.m_progressTracker)), m3;
  }
  geoNormalizePolylineGeometry(e2) {
    n(this.m_pannableSR.isPannable());
    let t3 = null;
    const s3 = this.m_originalSR && this.m_originalSR.isPannable();
    let n5 = 1;
    s3 && (n(this.m_originalGeometry), n5 = this.m_width360 / this.m_originalSR.getPannableExtent().width(), t3 = this.m_originalGeometry.getAttributeStreamRef(0));
    const i2 = this.m_pannableExtent.width(), a2 = i2 * Qs() * 4;
    let h2 = e2, m3 = Number.NaN;
    const l2 = x2.constructEmpty();
    this.m_bAdjustedAtPoles = 0;
    let g2 = new Os2({ vd: this.m_inputPoly.getDescription() });
    for (let _ = 0, d2 = this.m_inputPoly.getPathCount(); _ < d2; ++_) {
      let e3 = s3;
      const u2 = new Os2({ vd: this.m_inputPoly.getDescription() });
      u2.addPath(this.m_inputPoly, _, true);
      const c2 = this.m_inputPoly.isClosedPath(_);
      0 !== this.m_poleFlags && (this.m_bAdjustedAtPoles |= bm(c2, u2, this.m_pannableExtent.ymax - this.m_poleSnappingTolerance, this.m_pannableExtent.ymax, i2, this.m_poleFlags) ? 1 : 0, this.m_bAdjustedAtPoles && (e3 = false));
      let d3 = -1;
      const p3 = u2.getPointCount();
      let f3 = false;
      e3 && (d3 = this.m_originalGeometry.getPathStart(_), f3 = this.m_originalGeometry.isClosedPath(_));
      const x4 = u2.getAttributeStreamRef(0);
      let y2 = 0, P5 = x4.read(0), E2 = 0;
      const S3 = new mi(), b2 = new mi();
      let w4 = false;
      const v3 = u2.hasNonLinearSegments(), N2 = new mi();
      for (let s4 = 1; s4 < p3; ++s4) {
        x4.queryPoint2D(2 * s4, N2);
        const i3 = N2.x;
        let o = i3 + y2;
        const a3 = o - P5;
        if (N2.x = o, Math.abs(a3) > this.m_GCSLargeDelta) {
          if (e3) {
            const r = d3 + s4 - 1;
            let i4 = d3;
            (!f3 || s4 + 1 < p3) && (i4 += s4);
            const o2 = t3.read(2 * r), h3 = (t3.read(2 * i4) - o2) * n5;
            Math.abs(a3 - h3) > 1 * this.m_degree && (e3 = false);
          }
          if (!e3) {
            y2 -= B2(this.m_width360, o - P5), o = i3 + y2, ++E2, w4 = 0 !== y2, N2.x = o;
          }
        }
        w4 && (v3 && b("error in geonormalize_ring_ for curves"), x4.write(2 * s4, o)), P5 = o, S3.setCoordsPoint2D(b2), b2.setCoordsPoint2D(N2);
      }
      if (E2 && u2.notifyModified(), h2) {
        let e4 = false;
        if (!u2.isEmpty()) {
          const t4 = n3.constructEmpty();
          if (u2.queryEnvelope(t4), t4.width() >= i2 || t4.ymin <= this.m_pannableExtent.ymin || t4.ymax >= this.m_pannableExtent.ymax) e4 = true;
          else {
            if (Number.isNaN(m3)) {
              const e5 = this.m_centralLongitude - 0.5 * i2;
              m3 = t4.xmin, m3 += Math.round((e5 - t4.xmin) / i2) * i2, m3 > e5 && (m3 -= i2), n(m3 <= e5), m3 < e5 && (m3 += i2), n(m3 >= e5);
            }
            let s4 = Math.round((m3 - t4.xmin) / i2) * i2;
            if (t4.xmin + s4 > m3 + a2 && (s4 -= i2), t4.xmin + s4 < m3 - a2 && (s4 += i2), l2.mergeCoordinate(t4.xmin + s4), l2.mergeCoordinate(t4.xmax + s4), e4 = l2.width() >= i2, !e4) {
              const e5 = new x3();
              e5.setShiftCoords(s4, 0), u2.applyTransformation(e5);
            }
          }
        }
        g2.add(u2, false), e4 && (g2 = (() => {
          const e5 = new Os2({ vd: g2.getDescription() });
          for (let t4 = 0, s4 = g2.getPathCount(); t4 < s4; ++t4) {
            const s5 = new Os2({ vd: g2.getDescription() });
            s5.addPath(g2, t4, true);
            const n6 = vl(s5, this.m_pannableSR, this.m_centralLongitude, true, 0, this.m_progressTracker);
            e5.add(n6, false);
          }
          return e5;
        })(), h2 = false);
      } else {
        const e4 = vl(u2, this.m_pannableSR, this.m_centralLongitude, true, 0, this.m_progressTracker);
        g2.add(e4, false);
      }
    }
    if (h2) return g2;
    const u = this.m_pannableSR.getTolerance(0), c = this.m_pannableExtent.width() / 180;
    Ol(g2, this.m_pannableExtent, 0.1 * u, false);
    return f2(g2, this.m_pannableExtent, u, c, this.m_progressTracker);
  }
  finalizeGeoNormalizeOpenedRing(e2, t3) {
    const s3 = t3.getPointCount(), n5 = t3.getXY(0), r = t3.getXY(s3 - 1);
    {
      const e3 = Math.abs(r.x - n5.x), t4 = Math.round(e3 / this.m_width360) * this.m_width360;
      n(Math.abs(e3 - t4) < this.m_pannableSR.getTolerance(0));
    }
    const i2 = K(r.x - n5.x), a2 = n3.constructEmpty();
    t3.queryLooseEnvelope(a2);
    const h2 = this.m_pannableExtent.getCenterX();
    let m3 = 0, l2 = h2 - this.m_width360, g2 = h2 + this.m_width360;
    if (i2 >= 0) {
      let e3 = Math.ceil((l2 - a2.xmin) / this.m_width360);
      for (e3 *= this.m_width360; l2 > a2.xmin + e3; ) e3 += this.m_width360;
      for (; l2 < a2.xmax + e3; ) e3 -= this.m_width360;
      for (m3 = e3, a2.width() > 720 && (g2 = l2 + 360 * Math.ceil(a2.width() / 360)); g2 < a2.xmax; ) g2 += this.m_width360;
    } else {
      let e3 = Math.ceil((g2 - a2.xmax) / this.m_width360);
      for (e3 *= this.m_width360; g2 < a2.xmax + e3; ) e3 -= this.m_width360;
      for (; g2 > a2.xmin + e3; ) e3 += this.m_width360;
      for (m3 = e3, a2.width() > 720 && (l2 = g2 - 360 * Math.ceil(a2.width() / 360)); l2 > a2.xmin; ) l2 -= this.m_width360;
    }
    const u = Math.round(Math.abs(r.x - n5.x) / this.m_width360) * this.m_width360, c = i2 * u, _ = a2.clone();
    _.move(m3, 0);
    const d2 = new mi(0, 0), p3 = new x3();
    p3.setShiftCoords(m3, 0), t3.applyTransformation(p3);
    const f3 = new Os2({ vd: t3.getDescription() });
    f3.add(t3, false), d2.assign(t3.getXY(s3 - 1));
    let x4 = 0, y2 = f3.getXY(0).x;
    for (; i2 > 0 ? _.xmax < g2 : _.xmin > l2; ) _.move(c, 0), p3.xd = c, t3.applyTransformation(p3), y2 += c, this.m_pannableExtent.xmin <= y2 && this.m_pannableExtent.xmax >= y2 && (x4 = f3.getPointCount() - 1), t3.setXY(0, d2), d2.assign(t3.getXY(s3 - 1)), f3.addSegmentsFromPath(t3, 0, 0, s3 - 1, false);
    const P5 = new ur({ vd: f3.getDescription() });
    P5.add(f3, false);
    const E2 = f3.getXY(0), S3 = f3.getXY(f3.getPointCount() - 1), b2 = i2 < 0 ? e2 : !e2, w4 = P5.getPointCount() - 1;
    if (b2) {
      const e3 = new mi(S3.x, this.m_pannableExtent.ymax);
      P5.lineTo(e3);
      const t4 = new mi(this.m_pannableExtent.getCenterX(), this.m_pannableExtent.ymax);
      P5.lineTo(t4);
      const s4 = new mi(E2.x, this.m_pannableExtent.ymax);
      P5.lineTo(s4);
    } else {
      const e3 = new mi(S3.x, this.m_pannableExtent.ymin);
      P5.lineTo(e3);
      const t4 = new mi(this.m_pannableExtent.getCenterX(), this.m_pannableExtent.ymin);
      P5.lineTo(t4);
      const s4 = new mi(E2.x, this.m_pannableExtent.ymin);
      P5.lineTo(s4);
    }
    if (P5.interpolateAttributesPath(0, w4, 0), P5.getImpl().changeRingStartPoint(x4), u > this.m_width360) {
      const e3 = new ur({ copy: P5 });
      p3.setShiftCoords(this.m_width360, 0), e3.applyTransformation(p3), P5.add(e3, false);
    }
    return P5;
  }
  finalizeGeoNormalizeClosedRing(e2, t3, n5) {
    const r = new ur({ vd: e2.getDescription() });
    r.add(e2, false);
    const i2 = () => {
      const e3 = r.getPointCount() - 2;
      return r.getSegmentType(e3) !== a.enumLine;
    };
    if (r.hasNonLinearSegments() && i2()) {
      const e3 = new fm(), t4 = r.getPointCount() - 2;
      r.getSegmentBuffer(t4, e3, false), r.removePointFromPath(0, t4 + 1), r.closeLastPathWithSegment(e3.get());
    } else r.removePointFromPath(0, r.getPointCount() - 1);
    const o = n3.constructEmpty();
    r.queryLooseEnvelope(o);
    let a2 = Math.ceil((this.m_pannableExtent.xmin - o.xmin) / this.m_width360);
    for (a2 *= this.m_width360; this.m_pannableExtent.xmin > o.xmin + a2; ) a2 += this.m_width360;
    for (; this.m_pannableExtent.xmin < o.xmax + a2; ) a2 -= this.m_width360;
    if (a2 += this.m_width360, 0 !== a2) {
      o.move(a2, 0);
      const e3 = new x3();
      e3.setShiftCoords(a2, 0), r.applyTransformation(e3);
    }
    if (this.m_pannableExtent.xmin <= o.xmin && this.m_pannableExtent.xmax >= o.xmax) {
      if (t3) {
        const e4 = r.calculateArea2D(), t4 = new Eh2().execute(r, this.m_pannableSR, true, this.m_progressTracker);
        if (t4 !== r) {
          const s3 = t4.calculateArea2D();
          K(e4) !== K(s3) && t4.reverseAllPaths(), r.assignMove(t4);
        }
      }
      let e3;
      if (e3 = new ur(n5 ? { copy: r } : { move: r }), n5) for (; o.xmin < this.m_pannableExtent.xmax; ) {
        o.move(this.m_width360, 0);
        const t4 = new x3();
        t4.setShiftCoords(this.m_width360, 0), r.applyTransformation(t4), e3.add(r, false);
      }
      return e3;
    }
    let h2 = new ur({ vd: e2.getDescription() });
    h2.add(r, false);
    const m3 = t3 || o.width() > this.m_width360 - 10 * this.m_pannableSR.getTolerance(0);
    for (; o.xmin < this.m_pannableExtent.xmax; ) {
      o.move(this.m_width360, 0);
      const e3 = new x3();
      e3.setShiftCoords(this.m_width360, 0), r.applyTransformation(e3), h2.add(r, false);
    }
    if (m3) {
      const e3 = h2.calculateArea2D();
      h2.setFillRule(1), h2 = new Eh2().execute(h2, this.m_pannableSR, true, this.m_progressTracker);
      const t4 = h2.calculateArea2D();
      K(e3) !== K(t4) && h2.reverseAllPaths();
    }
    return h2;
  }
  geonormalize_ring_(e2, t3, s3, n5, r, i2, a2) {
    n(0);
  }
};
function Vm(e2) {
  n(0);
  const t3 = ou2(e2), s3 = new km();
  return s3.setVertProj_(t3), s3;
}
function Fm(e2, t3 = true) {
  return n(0), {};
}
function Hm(e2) {
  return Su2();
}
var km = class {
  constructor() {
    this.m_hashCode = 0, this.m_peVertSysVal = null, this.m_verticalUnit = new bu2(), this.m_verticalShift = 0, this.m_userVerticalWKID = 0, this.m_bIsDepth = false;
  }
  getType() {
    return n(0), 0;
  }
  getID() {
    return n(0), 0;
  }
  getLatestID() {
    return this.m_peVertSysVal ? this.m_peVertSysVal.getLatestID() : 0;
  }
  getOldID() {
    return this.m_peVertSysVal ? this.m_peVertSysVal.getOldID() : 0;
  }
  getText() {
    return n(0), "";
  }
  getTextExtended(e2) {
    return n(0), "";
  }
  getText2(e2) {
    return n(0), "";
  }
  getUnit() {
    return n(0), {};
  }
  equals(e2) {
    return n(0), false;
  }
  equalForProjection(e2) {
    return n(0), false;
  }
  getPeVertcsCopy() {
    return n(0), {};
  }
  getOneMeter() {
    return 1 / this.m_verticalUnit.getUnitToBaseFactor();
  }
  getUnitToBaseFactor() {
    return n(0), 0;
  }
  isDepth() {
    return n(0), false;
  }
  getVerticalShift() {
    return n(0), 0;
  }
  isCustomWkid() {
    return !!this.m_peVertSysVal && this.m_peVertSysVal.isCustomWkid();
  }
  getHashCode() {
    return this.m_hashCode;
  }
  setVertProj_(e2) {
    this.m_peVertSysVal = e2;
  }
  getPEVerticalCoordSys() {
    return this.m_peVertSysVal ? this.m_peVertSysVal.m_peVertcs : null;
  }
};
function Am(e2, t3, s3, n5, r) {
  if (e2.equals(t3)) return false;
  if (n5) {
    let s4 = 1, i3 = 0, o2 = 1, a2 = 1, h2 = 0, m3 = 1;
    Number.isNaN(e2.m_heightMetersPerUnit) || (s4 = e2.m_heightMetersPerUnit, i3 = e2.m_heightZ0, o2 = e2.m_heightSign, a2 = t3.m_heightMetersPerUnit, h2 = t3.m_heightZ0, m3 = t3.m_heightSign);
    const l2 = o2 * m3 * s4 / a2;
    for (let e3 = 0; e3 < r; e3++) n5[e3] = (n5[e3] - i3) * l2 + h2;
  }
  let i2 = 1, o = 0;
  if (Number.isNaN(e2.m_XYToRadians) || (i2 = e2.m_XYToRadians / t3.m_XYToRadians, o = e2.m_PrimeMeridianDegrees - t3.m_PrimeMeridianDegrees, 0 !== o && (o = Ah(o), o /= t3.m_XYToRadians)), Array.isArray(s3)) {
    const e3 = s3;
    for (let t4 = 0; t4 < r; t4++) e3[t4][0] = e3[t4][0] * i2 + o, e3[t4][1] = e3[t4][1] * i2;
  } else {
    const e3 = s3;
    for (let t4 = 0; t4 < r; t4++) {
      const s4 = t4 << 1;
      e3[s4] = e3[s4] * i2 + o, e3[s4 + 1] = e3[s4 + 1] * i2;
    }
  }
  return true;
}
function Mm() {
  return { m_heightMetersPerUnit: 0, m_heightSign: 0, m_heightZ0: 0, m_XYToRadians: 0, m_PrimeMeridianDegrees: 0, assign(e2) {
    this.m_heightMetersPerUnit = e2.m_heightMetersPerUnit, this.m_heightSign = e2.m_heightSign, this.m_heightZ0 = e2.m_heightZ0, this.m_XYToRadians = e2.m_XYToRadians, this.m_PrimeMeridianDegrees = e2.m_PrimeMeridianDegrees;
  }, equals(e2) {
    return ls(this.m_heightSign, e2.m_heightSign) && ls(this.m_heightMetersPerUnit, e2.m_heightMetersPerUnit) && ls(this.m_heightZ0, e2.m_heightZ0) && ls(this.m_XYToRadians, e2.m_XYToRadians) && ls(this.m_PrimeMeridianDegrees, e2.m_PrimeMeridianDegrees);
  }, initFromGcsAndVcsPe(e2, t3) {
    this.m_heightSign = 1, this.m_heightMetersPerUnit = Number.NaN, this.m_heightZ0 = 0, this.m_XYToRadians = Number.NaN, this.m_PrimeMeridianDegrees = Number.NaN, t3 && n(0), e2 && (this.m_XYToRadians = e2.getUnit().getUnitFactor(), this.m_PrimeMeridianDegrees = e2.getPrimem().getLongitude());
  }, initFromGcsAndVcs(e2, t3) {
    const s3 = e2 ? e2.getPECoordSys() : null, n5 = t3 ? t3.getPEVerticalCoordSys() : null;
    this.initFromGcsAndVcsPe(s3, n5);
  }, processUnitParams(e2) {
    Number.isNaN(this.m_heightMetersPerUnit) && (this.m_heightMetersPerUnit = e2.m_heightMetersPerUnit, this.m_heightSign = e2.m_heightSign, this.m_heightZ0 = e2.m_heightZ0), Number.isNaN(this.m_XYToRadians) && (this.m_XYToRadians = e2.m_XYToRadians, this.m_PrimeMeridianDegrees = e2.m_PrimeMeridianDegrees);
  } };
}
var Um = class {
  constructor(e2) {
    this.m_constantsLoaded = -1, this.m_isUsable = -1, this.m_inputSR = null, this.m_outputSR = null, this.m_inputSRHorz = null, this.m_outputSRHorz = null, this.m_inputVCS = null, this.m_outputVCS = null, this.m_hashCode = 0, this.m_areaOfUse = new re(), this.m_inputUnitParams = Mm(), this.m_outputUnitParams = Mm(), n(e2), this.m_geogTran = e2, this.m_vertTran = null, this.m_latestID = Ic.getCode(this.m_geogTran), this.m_latestID < 0 && (this.m_latestID = 0);
    const t3 = this.m_geogTran.getGeogcs1();
    Ic.getCode(t3);
    const s3 = this.m_geogTran.getGeogcs2();
    Ic.getCode(s3), this.initUnitParams();
  }
  getLatestId() {
    return this.m_latestID;
  }
  getText() {
    return this.m_geogTran ? this.m_geogTran.toString() : (n(0), "");
  }
  getGeogtran() {
    return this.m_geogTran;
  }
  getVerttran() {
    return null;
  }
  loadConstants(e2) {
    let t3 = this.m_constantsLoaded;
    if (-1 === t3) {
      if (!e2) {
        this.m_geogTran || b("vcs not impl");
        const t4 = this.m_geogTran.getParameters();
        null !== t4[bc.PE_PARM_ND] && (e2 = 0 === t4[bc.PE_PARM_ND].getValue());
      }
      t3 = this.m_geogTran.loadConstants() ? 1 : 0, this.m_constantsLoaded = t3;
    }
    return 0 !== t3;
  }
  isUsable() {
    let e2 = this.m_isUsable;
    return -1 === e2 && (this.m_geogTran ? this.m_isUsable = e2 = this.m_geogTran ? 1 : 0 : this.m_isUsable = e2 = this.m_vertTran ? 1 : 0), 1 === e2;
  }
  getInputSr(e2) {
    return this.updateSrs(), e2 ? this.m_inputSR : this.m_inputSRHorz;
  }
  getOutputSr(e2) {
    return this.updateSrs(), e2 ? this.m_outputSR : this.m_outputSRHorz;
  }
  getHashCode() {
    let e2 = this.m_hashCode;
    return 0 === e2 && (e2 = this.m_latestID > 0 ? Zs(this.m_latestID) : Ds(this.getText()), 0 === e2 && (e2 = 345), this.m_hashCode = e2), e2;
  }
  isGeogtran() {
    return null !== this.m_geogTran;
  }
  prepareOrThrow() {
  }
  getName() {
    return this.isGeogtran() ? this.getGeogtran().getName() : (z("vcs not impl"), "");
  }
  updateSrs() {
    if (this.m_inputSR || this.m_inputVCS) return;
    let e2, t3, s3, n5, r, i2;
    if (this.m_geogTran) {
      const o = this.m_geogTran.getGeogcs1(), a2 = ru2(o), h2 = this.m_geogTran.getGeogcs2(), m3 = ru2(h2);
      let l2 = -1, g2 = -1;
      l2 = a2.getVcsCode(), g2 = m3.getVcsCode(), s3 = Ru2(o, null, null, 1), n5 = Ru2(h2, null, null, 1), l2 > 0 && g2 > 0 ? (r = Vm(l2), i2 = Vm(g2), e2 = zu2(), t3 = zu2()) : (e2 = s3, t3 = n5);
    } else n(0);
    this.m_inputSR || this.m_inputVCS || (this.m_inputSR = e2, this.m_outputSR = t3, this.m_inputSRHorz = s3, this.m_outputSRHorz = n5, this.m_inputVCS = r, this.m_outputVCS = i2);
  }
  initUnitParams() {
    if (this.m_inputUnitParams.m_heightSign = 1, this.m_inputUnitParams.m_heightMetersPerUnit = Number.NaN, this.m_inputUnitParams.m_heightZ0 = 0, this.m_outputUnitParams.m_heightSign = 1, this.m_outputUnitParams.m_heightMetersPerUnit = Number.NaN, this.m_outputUnitParams.m_heightZ0 = 0, this.m_inputUnitParams.m_XYToRadians = Number.NaN, this.m_inputUnitParams.m_PrimeMeridianDegrees = Number.NaN, this.m_outputUnitParams.m_XYToRadians = Number.NaN, this.m_outputUnitParams.m_PrimeMeridianDegrees = Number.NaN, this.m_vertTran) n(0);
    else if (this.m_geogTran) {
      const e2 = this.m_geogTran;
      let t3 = e2.getGeogcs1();
      this.m_inputUnitParams.m_XYToRadians = t3.getUnit().getUnitFactor(), this.m_inputUnitParams.m_PrimeMeridianDegrees = t3.getPrimem().getLongitude(), t3 = e2.getGeogcs2(), this.m_outputUnitParams.m_XYToRadians = t3.getUnit().getUnitFactor(), this.m_outputUnitParams.m_PrimeMeridianDegrees = t3.getPrimem().getLongitude();
    }
  }
};
function qm(e2, t3, s3, n5, r, i2, o) {
  let a2 = null;
  if (t3) {
    a2 = t3.getPEVerticalCoordSys();
  }
  let h2 = null;
  if (e2) {
    h2 = e2.getPECoordSys();
  }
  let m3 = null;
  if (n5) {
    m3 = n5.getPEVerticalCoordSys();
  }
  let l2 = null;
  if (s3) {
    l2 = s3.getPECoordSys();
  }
  if (!(h2 || a2 || l2 || m3)) return false;
  const g2 = Mm();
  g2.initFromGcsAndVcsPe(h2, a2);
  const u = Mm();
  return u.initFromGcsAndVcsPe(l2, m3), Am(g2, u, r, i2, o);
}
function Bm(e2, t3, s3, n5, r, i2, o, a2) {
  const h2 = t3, m3 = e2, l2 = Mm();
  l2.initFromGcsAndVcsPe(m3, h2), a2.assign(n5 ? s3.m_outputUnitParams : s3.m_inputUnitParams), a2.processUnitParams(l2), l2.processUnitParams(a2), o > 0 && Am(l2, a2, r, i2, o);
}
function Om(e2, t3, s3, n5, r, i2, o, a2) {
  const h2 = Mm();
  h2.assign(s3 ? t3.m_inputUnitParams : t3.m_outputUnitParams), h2.processUnitParams(e2);
  let m3 = null, l2 = null;
  if (n5) {
    l2 = n5.getPECoordSys();
  }
  const g2 = Mm();
  g2.initFromGcsAndVcsPe(l2, m3), g2.processUnitParams(h2), h2.processUnitParams(g2), a2 > 0 && Am(h2, g2, i2, o, a2);
}
function Ym(e2, t3, s3, n5, r, i2, o, a2, h2) {
  const m3 = Mm(), l2 = Mm();
  m3.assign(s3 ? t3.m_inputUnitParams : t3.m_outputUnitParams), l2.assign(r ? n5.m_outputUnitParams : n5.m_inputUnitParams), m3.processUnitParams(e2), l2.processUnitParams(m3), m3.processUnitParams(l2), a2 > 0 && Am(m3, l2, i2, o, a2), h2.assign(l2);
}
function Rm(e2, t3, s3, n5, r, i2, o) {
  const a2 = t3.getVerttran(), h2 = t3.getGeogtran();
  if (o.assign(s3 ? t3.m_inputUnitParams : t3.m_outputUnitParams), o.processUnitParams(e2), i2 > 0) {
    t3.prepareOrThrow();
    const e3 = s3 ? bc.PE_TRANSFORM_2_TO_1 : bc.PE_TRANSFORM_1_TO_2;
    a2 ? dg() : pg(h2, i2, n5, r, e3);
  }
}
function Xm(e2, t3, s3, n5, r) {
  const i2 = e2.getVerttran(), o = e2.getGeogtran();
  if (r > 0) {
    e2.prepareOrThrow();
    const a2 = t3 ? bc.PE_TRANSFORM_2_TO_1 : bc.PE_TRANSFORM_1_TO_2;
    i2 ? dg() : pg(o, r, s3, n5, a2);
  }
}
var Lm = class {
  supportsCurves() {
    return true;
  }
  accelerateGeometry(e2, t3, s3) {
    return zm(e2, t3, s3);
  }
  canAccelerateGeometry(e2) {
    return Wm(e2);
  }
};
function zm(e2, t3, s3) {
  if (!Wm(e2)) return false;
  Lt2(t3, e2, false);
  let n5 = 0;
  const r = e2.getGeometryType();
  return h(r) && Ls2(e2) && 0 !== s3 && (n5 |= e2.getImpl().buildQuadTreeAccelerator(s3) ? 1 : 0), h(r) && Rs(e2) && 0 !== s3 && (n5 |= e2.getImpl().buildQuadTreeForPathsAccelerator(s3) ? 1 : 0), n5 > 0;
}
function Wm(e2) {
  return Ls2(e2) || Rs(e2);
}
var jm = class extends Lm {
  getOperatorType() {
    return 8;
  }
  execute(e2, t3, s3, n5) {
    return kr2(e2, t3, s3, 1, n5);
  }
};
function Zm(t3, r, i2, o) {
  if (t3.isEmpty() || r.isEmpty()) return t3;
  const a2 = t3.getDimension(), h2 = r.getDimension();
  if (a2 > h2) return t3;
  const m3 = t3.getGeometryType(), l2 = r.getGeometryType(), g2 = new n3(), u = new n3(), c = new n3();
  t3.queryEnvelope(g2), r.queryEnvelope(u), c.setCoords({ env2D: g2 }), c.mergeEnvelope2D(u);
  const _ = At(i2, c, true), d2 = Ft2(_), p3 = new n3();
  if (p3.setCoords({ env2D: g2 }), p3.inflateCoords(d2, d2), !p3.isIntersecting(u)) return t3;
  if (1 === a2 && 2 === h2) {
    const e2 = ol(t3, r, l2, i2, o);
    if (e2) return e2;
  }
  if (m3 === a.enumPoint) {
    let i3;
    switch (f(l2) ? (i3 = new Os2({ vd: r.getDescription() }), i3.addSegment(r, true)) : i3 = r, l2) {
      case a.enumPolygon:
        return Jm(t3, i3, _);
      case a.enumPolyline:
        return $m(t3, i3, _);
      case a.enumMultiPoint:
        return el(t3, i3, _);
      case a.enumEnvelope:
        return tl(t3, i3, _);
      case a.enumPoint:
        return sl(t3, i3, _);
      default:
        P("invalid shape type");
    }
  } else if (m3 === a.enumMultiPoint) switch (l2) {
    case a.enumPolygon:
      return nl(t3, r, _);
    case a.enumEnvelope:
      return rl(t3, r, _);
    case a.enumPoint:
      return il(t3, r, _);
  }
  const f3 = new n3(g2);
  f3.inflate(100 * _.total());
  return Ya2(t3, f2(r, f3, 0, 0, o), i2, o);
}
var Km = class {
  getOperatorType() {
    return 10002;
  }
  supportsCurves() {
    return true;
  }
  accelerateGeometry(e2, t3, s3) {
    return false;
  }
  canAccelerateGeometry(e2) {
    return false;
  }
  executeMany(e2, t3, s3, n5) {
    return new Qm(e2, t3, s3, n5);
  }
  execute(e2, t3, s3, n5) {
    return this.executeMany(new s([e2]), new s([t3]), s3, n5).next();
  }
};
var Qm = class extends t {
  constructor(e2, t3, s3, n5) {
    super(), this.m_progressTracker = n5, this.m_index = -1, this.m_inputGeoms = e2, this.m_spatialReference = s3;
    const r = t3.next();
    this.m_geomSubtractor = r || new ur();
  }
  next() {
    const e2 = this.m_inputGeoms.next();
    return e2 ? (j(e2), L(e2), this.m_index = this.m_inputGeoms.getGeometryID(), Zm(e2, this.m_geomSubtractor, this.m_spatialReference, this.m_progressTracker)) : null;
  }
  getGeometryID() {
    return this.m_index;
  }
  tock() {
    return true;
  }
  getRank() {
    return 1;
  }
};
function Jm(e2, t3, s3, n5) {
  return 0 === Xo2(t3, e2, s3.total()) ? e2 : e2.createInstance();
}
function $m(e2, t3, s3, n5) {
  const r = e2.getXY(), i2 = t3.querySegmentIterator(), o = Ft2(s3), a2 = o * o;
  for (; i2.nextPath(); ) for (; i2.hasNextSegment(); ) {
    const t4 = i2.nextSegment(), n6 = new n3();
    if (t4.queryEnvelope(n6), n6.inflateCoords(o, o), !n6.contains(r)) continue;
    if (t4.isIntersectingPoint(r, s3.total())) return e2.createInstance();
    let h2 = t4.getStartXY();
    if (mi.sqrDistance(r, h2) <= a2) return e2.createInstance();
    if (h2 = t4.getEndXY(), mi.sqrDistance(r, h2) <= a2) return e2.createInstance();
  }
  return e2;
}
function el(e2, t3, s3, n5) {
  const r = t3.getImpl().getAttributeStreamRef(0), i2 = t3.getPointCount(), o = e2.getXY(), a2 = Ft2(s3), h2 = a2 * a2, m3 = new mi();
  for (let l2 = 0; l2 < i2; l2++) {
    r.queryPoint2D(2 * l2, m3);
    if (mi.sqrDistance(m3, o) <= h2) return e2.createInstance();
  }
  return e2;
}
function tl(e2, t3, s3, n5) {
  const r = new n3();
  t3.queryEnvelope(r), r.inflate(s3.total());
  const i2 = e2.getXY();
  return r.contains(i2) ? e2.createInstance() : e2;
}
function sl(e2, t3, s3, n5) {
  const r = Ft2(s3), i2 = r * r, o = e2.getXY(), a2 = t3.getXY();
  return mi.sqrDistance(o, a2) <= i2 ? e2.createInstance() : e2;
}
function nl(e2, t3, s3, n5) {
  const r = new n3();
  t3.queryEnvelope(r), r.inflate(s3.total());
  const i2 = e2.getPointCount();
  let o = false;
  const a2 = Yt(i2, false), h2 = new mi();
  for (let l2 = 0; l2 < i2; l2++) {
    if (e2.queryXY(l2, h2), !r.contains(h2)) continue;
    0 !== Lo2(t3, h2, s3.total()) && (o = true, a2[l2] = true);
  }
  if (!o) return e2;
  const m3 = e2.createInstance();
  for (let l2 = 0; l2 < i2; l2++) a2[l2] || m3.addPoints(e2, l2, l2 + 1);
  return m3;
}
function rl(e2, t3, s3, n5) {
  const r = new n3();
  t3.queryEnvelope(r), r.inflate(s3.total());
  const i2 = e2.getPointCount();
  let o = false;
  const a2 = Yt(i2, false), h2 = new mi();
  for (let l2 = 0; l2 < i2; l2++) e2.queryXY(l2, h2), r.contains(h2) && (o = true, a2[l2] = true);
  if (!o) return e2;
  const m3 = e2.createInstance();
  for (let l2 = 0; l2 < i2; l2++) a2[l2] || m3.addPoints(e2, l2, l2 + 1);
  return m3;
}
function il(e2, t3, s3, n5) {
  const r = e2.getImpl().getAttributeStreamRef(0), i2 = e2.getPointCount(), o = t3.getXY();
  let a2 = false;
  const h2 = Yt(i2, false), m3 = Ft2(s3), l2 = m3 * m3, g2 = new mi();
  for (let c = 0; c < i2; c++) {
    r.queryPoint2D(2 * c, g2);
    mi.sqrDistance(g2, o) <= l2 && (a2 = true, h2[c] = true);
  }
  if (!a2) return e2;
  const u = e2.createInstance();
  for (let c = 0; c < i2; c++) h2[c] || u.addPoints(e2, c, c + 1);
  return u;
}
function ol(e2, t3, n5, r, i2) {
  const o = new re();
  e2.queryEnvelope(o);
  const a2 = new n3();
  t3.queryEnvelope(a2), o.merge(a2);
  const h2 = 0.1 * o.width(), m3 = 0.1 * o.height();
  o.inflateCoords(h2, m3);
  const l2 = new ur();
  l2.addEnvelope(o, false);
  const g2 = l2.getImpl();
  if (n5 === a.enumPolygon) {
    const e3 = t3.getImpl();
    g2.add(e3, true);
  } else g2.addEnvelope(t3, true);
  return new Ih2(l2, r, -1, i2).tryFastImplementation(e2);
}
var al = class {
  getOperatorType() {
    return 10001;
  }
  supportsCurves() {
    return true;
  }
  accelerateGeometry(e2, t3, s3) {
    return false;
  }
  canAccelerateGeometry(e2) {
    return false;
  }
  executeMany(e2, t3, s3, n5 = 0) {
    return new gl(e2, t3, s3, n5);
  }
  execute(e2, t3, s3, n5) {
    const i2 = new s([e2, t3]), o = new gl(i2, s3, n5, 0).next();
    return o || b("null output"), o;
  }
};
function hl() {
  return { geom: null, vertexCount: -1, bUnioned: false, location: new mi() };
}
function ml(e2, t3) {
  return mi.compareZorder(e2.location, t3.location) ? -1 : e2.location.equals(t3.location) ? 0 : 1;
}
var ll = class {
  constructor() {
    this.binVertexCount = 0, this.geometries = [];
  }
  addPair(e2) {
    this.binVertexCount += e2.vertexCount, this.geometries.push(e2);
  }
  sort() {
    this.geometries.sort((e2, t3) => ml(e2, t3));
  }
  geomCount() {
    return this.geometries.length;
  }
  geomPairs() {
    return this.geometries;
  }
  clear() {
    this.binVertexCount = 0, this.geometries.length = 0;
  }
  getBinVertexCount() {
    return this.binVertexCount;
  }
};
var gl = class _gl extends t {
  constructor(e2, t3, s3, n5, r = false) {
    super(), this.m_index = -1, this.m_currentDim = -1, this.m_bDone = false, this.m_unionBins = [], this.m_readyGeoms = Vt(4), this.m_dimGeomCounts = Yt(4, 0), this.m_addedGeoms = 0, this.m_maxDimension = -1, this.m_bHadGeometry = Yt(4, false), this.m_complexUnionGeoms = Vt(4), this.m_totalNonEmptyGeomCounters = Yt(4, 0), this.m_progressTracker = s3, this.m_bUnionAllDimensions = !!(4 & n5), this.m_bPreserveAllPathEnds = !!(8 & n5), this.m_inputGeoms = e2, this.m_spatialReference = t3, this.m_options = n5, this.m_bIs3D = r;
  }
  next() {
    if (this.m_bDone && this.m_currentDim === this.m_maxDimension) return null;
    for (; !this.step_(); ) ;
    if (-1 === this.m_maxDimension) return null;
    if (this.m_bUnionAllDimensions) {
      if (-1 === this.m_currentDim) {
        for (let e2 = 0; e2 <= this.m_maxDimension; e2++) if (this.m_bHadGeometry[e2]) {
          this.m_complexUnionGeoms[e2] = this.getResultGeometry(e2);
          for (let t3 = e2 + 1; t3 <= this.m_maxDimension; t3++) this.m_complexUnionGeoms[t3] = this.getResultGeometry(t3), this.m_bHadGeometry[t3] && !this.m_complexUnionGeoms[t3].isEmpty() && (this.m_bIs3D ? n(0) : this.m_complexUnionGeoms[e2] = new Km().execute(this.m_complexUnionGeoms[e2], this.m_complexUnionGeoms[t3], this.m_spatialReference, this.m_progressTracker));
        }
      }
      for (; this.m_currentDim++, (this.m_currentDim > this.m_maxDimension || this.m_currentDim < 0) && b(""), !this.m_bHadGeometry[this.m_currentDim]; ) ;
      if (this.m_index++, 0 === this.m_currentDim && this.m_complexUnionGeoms[this.m_currentDim].getGeometryType() === a.enumPoint) {
        const e2 = new cs2({ vd: this.m_complexUnionGeoms[this.m_currentDim].getDescription() });
        return this.m_complexUnionGeoms[this.m_currentDim].isEmpty() || e2.add(this.m_complexUnionGeoms[this.m_currentDim]), e2;
      }
      return this.m_complexUnionGeoms[this.m_currentDim];
    }
    return this.m_index = 0, this.m_currentDim = this.m_maxDimension, this.getResultGeometry(this.m_maxDimension);
  }
  getGeometryID() {
    return this.m_index;
  }
  getRank() {
    return 1;
  }
  tock() {
    return this.step_();
  }
  getResultGeometry(e2) {
    return this.m_readyGeoms[e2];
  }
  finishDim(e2, t3, n5) {
    let r = t3;
    if (!n5) return 16 & this.m_options ? (r = ja2([r], 1, this.m_spatialReference, this.m_progressTracker, this.m_options, this.m_bIs3D), r) : r;
    if (1 & this.m_options) return r;
    if (1 === e2) {
      if (!(8 & this.m_options) && (!!(16 & this.m_options) || this.m_totalNonEmptyGeomCounters[e2] > 1)) {
        r = ja2([r], 1, this.m_spatialReference, this.m_progressTracker, 16 | this.m_options, this.m_bIs3D);
        const e3 = [0], t4 = r.getImpl().getIsSimple(0, e3);
        n(this.m_bIs3D || Ot2(t4));
      } else 1 === this.m_totalNonEmptyGeomCounters[e2] && (this.m_bIs3D ? n(0) : r = new Eh2().execute(r, this.m_spatialReference, false, this.m_progressTracker));
    } else this.m_bIs3D ? n(0) : r = new Eh2().execute(r, this.m_spatialReference, false, this.m_progressTracker);
    if (0 === e2 && r.getGeometryType() === a.enumPoint) {
      const e3 = new cs2({ vd: r.getDescription() });
      r.isEmpty() || e3.add(r), r = e3;
    }
    return r;
  }
  static getLevel(e2) {
    const t3 = 4, s3 = w(e2);
    let n5 = s3 > 0 ? (Math.log(s3) - Math.log(32)) / Math.log(t3) : 0;
    return n5 < 0 && (n5 = 0), Math.floor(n5);
  }
  step_() {
    if (this.m_bDone) return true;
    let e2;
    if (this.m_inputGeoms ? (e2 = this.m_inputGeoms.next(), null === e2 ? (this.m_bDone = true, this.m_inputGeoms = null) : (this.checkAndThrow(e2), e2.isEmpty() || this.m_totalNonEmptyGeomCounters[e2.getDimension()]++)) : e2 = null, null !== e2) {
      const t3 = e2.getDimension();
      this.m_bHadGeometry[t3] = true, (t3 >= this.m_maxDimension || this.m_bUnionAllDimensions) && (this.addGeom(t3, false, e2), t3 > this.m_maxDimension && !this.m_bUnionAllDimensions && this.removeAllBinsWithLowerDimension(t3));
    }
    if (this.m_addedGeoms > 0) for (let t3 = 0; t3 <= this.m_maxDimension; t3++) {
      for (; this.m_dimGeomCounts[t3] > 1; ) {
        const e3 = this.collectGeometriesToUnion(t3);
        if (null === e3) break;
        {
          let s3;
          s3 = 1 & this.m_options ? ja2(e3, e3.length, this.m_spatialReference, this.m_progressTracker, this.m_options, this.m_bIs3D) : Za2(e3, e3.length, this.m_spatialReference, this.m_progressTracker, 8 | this.m_options, this.m_bIs3D), this.addGeom(t3, true, s3);
        }
      }
      if (this.m_bDone && (n(this.m_dimGeomCounts[t3] <= 1), 0 !== this.m_dimGeomCounts[t3])) {
        const e3 = this.m_unionBins[t3].entries().next().value, s3 = e3[1].geomPairs()[0].geom, n5 = e3[1].geomPairs()[0].bUnioned;
        this.m_unionBins[t3].clear(), this.m_readyGeoms[t3] = this.finishDim(t3, s3, n5);
      }
    }
    return this.m_bDone;
  }
  addGeom(e2, t3, s3) {
    const n5 = hl();
    n5.geom = s3;
    const r = w(s3);
    n5.vertexCount = r;
    const i2 = n3.constructEmpty();
    s3.queryEnvelope(i2), n5.location = r > 0 ? i2.getCenter() : new mi(0, 0);
    const o = _gl.getLevel(s3);
    if (e2 + 1 > this.m_unionBins.length) for (; this.m_unionBins.length < Math.max(2, e2 + 1); ) this.m_unionBins.push(/* @__PURE__ */ new Map());
    let a2 = null;
    const h2 = this.m_unionBins[e2].get(o);
    h2 && (a2 = h2), null === a2 && (a2 = new ll(), this.m_unionBins[e2].set(o, a2)), n5.bUnioned = t3, a2.addPair(n5), this.m_dimGeomCounts[e2]++, this.m_addedGeoms++, this.m_maxDimension = Math.max(this.m_maxDimension, e2);
  }
  removeAllBinsWithLowerDimension(e2) {
    for (let t3 = 0; t3 < e2; t3++) this.m_unionBins[t3].clear(), this.m_addedGeoms -= this.m_dimGeomCounts[t3], this.m_dimGeomCounts[t3] = 0;
  }
  collectGeometriesToUnion(e2) {
    if (1 & this.m_options && !this.m_bDone) return null;
    let t3 = null;
    const s3 = [];
    for (const n5 of this.m_unionBins[e2].keys()) s3.push(n5);
    qt(s3);
    for (let n5 = 0; n5 < s3.length; n5++) {
      if (-1 === s3[n5]) continue;
      const r = this.m_unionBins[e2].get(s3[n5]);
      {
        const i2 = 5e3, o = 4, a2 = r.getBinVertexCount() > i2 && r.geomCount() >= o;
        if (this.m_bDone || a2) {
          for (let r2 = 0; r2 < n5; r2++) {
            if (-1 === s3[r2]) continue;
            const n6 = this.m_unionBins[e2].get(s3[r2]);
            n6.sort(), this.m_dimGeomCounts[e2] -= n6.geomCount(), this.m_addedGeoms -= n6.geomCount();
            for (const e3 of n6.geomPairs()) t3 || (t3 = new Array()), t3.push(e3.geom);
            n6.clear(), this.m_unionBins[e2].delete(s3[r2]), s3[r2] = -1;
          }
          r.sort(), this.m_dimGeomCounts[e2] -= r.geomCount(), this.m_addedGeoms -= r.geomCount();
          for (const e3 of r.geomPairs()) t3 || (t3 = new Array()), t3.push(e3.geom);
          if (r.clear(), this.m_unionBins[e2].delete(s3[n5]), s3[n5] = -1, !this.m_bDone) break;
        }
      }
    }
    return t3;
  }
  checkAndThrow(s3) {
    this.m_bIs3D && (s3.getDimension() > 1 && B(), s3.hasAttribute(1) || P("Geometry must have Zs")), j(s3);
  }
};
var ul = class extends Lm {
  getOperatorType() {
    return 3;
  }
  execute(e2, t3, s3, n5 = null) {
    return kr2(e2, t3, s3, 4, n5);
  }
};
function cl(e2, t3, s3) {
  const n5 = t3.getGCSSplitLines();
  if (null === n5) return e2;
  const r = t3.getGCS(), i2 = r.getPannableExtent().width(), o = n3.constructEmpty();
  e2.queryLooseEnvelope(o);
  const a2 = x2.constructEmpty();
  o.queryIntervalX(a2);
  const h2 = n5.querySegmentIterator();
  let m3 = null;
  const l2 = new x3();
  for (; h2.nextPath(); ) for (; h2.hasNextSegment(); ) {
    const e3 = h2.nextSegment(), t4 = e3.queryInterval(0, 0), s4 = x2.constructEmpty();
    s4.setCoordsFromEnvelope(t4);
    let n6 = 0;
    for (; s4.vmax > a2.vmin; ) s4.move(-i2), n6--;
    for (; s4.vmin <= a2.vmax; ) {
      if (s4.isIntersecting(a2)) {
        null === m3 && (m3 = new Os2());
        const t5 = new pm({ start: e3.getStartXY(), end: e3.getEndXY() });
        0 !== n6 && (l2.setShiftCoords(n6 * i2, 0), t5.applyTransformation(l2)), m3.addSegment(t5, true);
      }
      s4.move(i2), ++n6;
    }
  }
  if (null !== m3) {
    const t4 = Bt2(r, m3, true);
    return Un2(e2, m3, Ft2(t4), s3);
  }
  return e2;
}
function _l(e2, t3, s3) {
  let n5 = e2.getName();
  return ic(n5) || (s3 || t3 > 0 ? (n5 = e2.toString(bc.PE_STR_NAME_CANON | bc.PE_STR_AUTH_NONE), n5 = yl(n5)) : n5 = e2.toString(bc.PE_STR_AUTH_TOP)), n5;
}
function dl(e2, t3, s3, n5) {
  return n(0), "";
}
function pl(t3, s3 = -1) {
  if ((s3 > 1 || s3 < -1) && P("verbosity"), -1 === s3) return t3.toString();
  {
    const e2 = 0 === s3 ? bc.PE_STR_AUTH_TOP : bc.PE_STR_AUTH_ALL;
    return t3.toString(e2);
  }
}
function fl(t3, s3) {
  (s3 > 1 || s3 < -1) && P("verbosity");
  let n5 = bc.PE_STR_FMT_WKT2;
  return -1 !== s3 && (n5 |= 0 === s3 ? bc.PE_STR_AUTH_TOP : bc.PE_STR_AUTH_ALL), t3.toString(n5);
}
function xl(e2) {
  return n(0), "";
}
function yl(e2) {
  return e2.toLocaleUpperCase("en-US");
}
function Pl(t3, n5, r) {
  const i2 = t3.getPCSHorizon();
  if (i2.getGeometryType() === a.enumPolygon) {
    const e2 = t3.getDefaultPrecisionSR().getTolerance(0), s3 = i2;
    for (let t4 = 0; t4 < r; t4++) 1 !== Lo2(s3, n5[t4], e2) && n5[t4].setNAN();
    return;
  }
  if (i2.getGeometryType() === a.enumEnvelope) {
    const e2 = i2;
    for (let t4 = 0; t4 < r; t4++) e2.contains(n5[t4]) || n5[t4].setNAN();
    return;
  }
  P("");
}
function El(e2, t3, s3, n5) {
  for (let r = 0; r < t3; r++) {
    if (e2[r].y < s3.ymin || e2[r].y > s3.ymax) {
      e2[r].setNAN();
      continue;
    }
    const t4 = e2[r].x;
    e2[r].x = Gl(t4, s3, n5);
  }
}
function Sl(e2, t3, n5, o) {
  if (e2.isEmpty() || 1 === n5) return e2;
  const a2 = e2.getGeometryType();
  if (a2 === a.enumPoint) {
    const s3 = e2, r = s3.getXY();
    return 0 === wl([r], 1, t3, n5) || r.isNAN() ? s3.setEmpty() : s3.setXY(r), e2;
  }
  if (a2 === a.enumMultiPoint) {
    const s3 = e2, r = e2.createInstance(), i2 = s3.getPointCount();
    r.reserve(i2);
    const o2 = s3.getAttributeStreamRef(0), a3 = s3.getDescription().getAttributeCount() > 1, h3 = new ee(), m4 = Float64Array.from(o2.getArray());
    if (wl(m4, i2, t3, n5) > 0) for (let e3 = 0, t4 = 2 * i2; e3 < t4; e3 += 2) Number.isNaN(m4[e3]) || (a3 ? (s3.getPointByVal(e3 >> 1, h3), h3.setXYCoords(m4[e3], m4[e3 + 1]), r.add(h3)) : r.addXY(m4[e3], m4[e3 + 1]));
    return r;
  }
  let h2 = e2;
  const m3 = t3.getOneDegreeGCSUnit(), l2 = 90 * m3, g2 = 180 * m3, u = 360 * m3, c = t3.getCentralMeridian(), _ = 0.5 * m3, d2 = n3.constructEmpty();
  h2.queryEnvelope(d2);
  const p3 = t3.getGCSHorizon(), f3 = t3.getGCSHorisonIsInclusive(), x4 = p3.getGeometryType() === a.enumEnvelope, y2 = n3.constructEmpty();
  p3.queryEnvelope(y2);
  const P5 = t3.getGCS();
  if (2 !== n5 && 4 !== n5 || (y2.xmin = c - g2, y2.xmax = y2.xmin + u), 4 === n5) {
    if (!(d2.width() > u - m3)) {
      const e3 = n3.constructEmpty();
      e3.setCoords({ xmin: d2.xmin - m3, ymin: y2.ymin, xmax: d2.xmax + m3, ymax: y2.ymax }), h2 = new I3().execute(h2, e3, P5, o);
      let t4 = Math.floor((c - d2.getCenterX()) / u);
      for (d2.move(t4 * u, 0); d2.xmin > y2.xmax; ) t4 -= 1, d2.move(-u, 0);
      for (; d2.xmin < y2.xmin; ) t4 += 1, d2.move(u, 0);
      if (0 !== t4) {
        const e4 = new x3();
        e4.setShiftCoords(t4 * u, 0), h2.applyTransformation(e4);
      }
      return h2;
    }
    n5 = 2;
  }
  if (2 === n5 && (y2.xmin = c - g2, y2.xmax = y2.xmin + u), d2.ymin < -l2 || d2.ymax > l2) {
    const e3 = n3.constructEmpty();
    if (e3.setCoords({ xmin: d2.xmin - m3, ymin: -l2, xmax: d2.xmax + m3, ymax: l2 }), h2 = new I3().execute(h2, e3, P5, o), h2.isEmpty()) return h2;
    h2.queryEnvelope(d2);
  }
  if (f3 && (y2.ymax < d2.ymin || y2.ymin > d2.ymax)) return h2.createInstance();
  d2.width() > u && (h2 = ql(h2, c - g2, u, P5, true, 0, true, o), h2.queryEnvelope(d2));
  let E2 = Ul(d2.xmin, d2.xmax, y2.xmin, y2.xmax, u);
  if (0 !== E2 && d2.move(E2, 0), d2.xmax > y2.xmax || d2.xmin < y2.xmin) {
    if (d2.xmax > y2.xmax) for (; d2.xmin >= y2.xmax; ) d2.move(-u, 0), E2 -= u;
    for (; d2.xmin < y2.xmax - u; ) d2.move(u, 0), E2 += u;
  }
  const S3 = Lt2(P5, p3, false);
  if (0 !== E2) {
    const e3 = new x3();
    e3.setShiftCoords(E2, 0), h2.applyTransformation(e3), E2 = 0;
  }
  if (f3) {
    if (x4 && y2.containsEnvelope(d2)) return h2;
    const e3 = new Array(2);
    for (let t4 = 0; t4 < 2; t4++) {
      let s3;
      if (x4 ? s3 = h(a2) ? f2(h2, y2, S3, _, o) : f2(h2, y2, S3, 0, o) : (s3 = new wh2().execute(h2, p3, P5, o), s3 === p3 && (s3 = s3.clone())), y2.xmin <= d2.xmin && y2.xmax >= d2.xmax) return s3;
      if (y2.xmin >= d2.xmin && y2.xmax <= d2.xmax) return s3;
      if (e3[t4] = s3, 0 === t4) {
        d2.move(-u, 0);
        const e4 = new x3();
        e4.setShiftCoords(-u, 0), h2.applyTransformation(e4);
      }
    }
    return h(a2) ? e3[0].add(e3[1], false) : b("intersect_with_GCS_horizon: unexpected geometry type"), e3[0];
  }
  {
    if (y2.ymax < d2.ymin || y2.ymin > d2.ymax) return h2;
    let e3 = 0;
    for (; !h2.isEmpty() && d2.xmax > y2.xmin; ) {
      if (0 !== e3) {
        const t4 = new x3();
        t4.setShiftCoords(e3, 0), h2.applyTransformation(t4);
      }
      if (!new ul().execute(h2, p3, P5, o)) {
        h2 = new Km().execute(h2, p3, P5, o), p3 === h2 && (h2 = h2.clone());
      }
      if (0 !== e3) {
        const t4 = new x3();
        t4.setShiftCoords(-e3, 0), h2.applyTransformation(t4);
      }
      e3 -= u, d2.move(-u, 0);
    }
    return h2;
  }
}
function Cl(e2, t3, s3, n5, r, i2) {
  const o = { stack: [], error: void 0, hasError: false };
  try {
    if (2 === i2) {
      return Gs3(e2, t3, s3, n5, r);
    }
    if (Math.abs(s3.x - n5.x) >= Math.PI || !Fg(s3.x, n5.x, r)) return Number.NaN;
    s3.x > n5.x && (n5 = Pt(s3, s3 = n5));
    const a2 = __addDisposableResource(o, new Cc(), false), h2 = __addDisposableResource(o, new Cc(), false), m3 = __addDisposableResource(o, new Cc(), false), l2 = s3.clone();
    Dc.geodeticDistance(e2, t3, s3.x, s3.y, n5.x, n5.y, h2, a2, null, i2);
    const g2 = h2.val;
    let u = 0, c = 1;
    for (; g2 * (c - u) > 1e-12 * e2; ) {
      const o2 = 0.5 * (u + c);
      if (Dc.geodeticCoordinate(e2, t3, s3.x, s3.y, g2 * o2, a2.val, h2, m3, i2), l2.x = h2.val, l2.y = m3.val, l2.x === r) return l2.y;
      if (Fg(s3.x, l2.x, r)) c = o2;
      else {
        if (!Fg(n5.x, l2.x, r)) return Number.NaN;
        u = o2;
      }
    }
    return l2.y;
  } catch (a2) {
    o.error = a2, o.hasError = true;
  } finally {
    __disposeResources(o);
  }
}
function Il(e2, t3) {
  let s3;
  if (Array.isArray(e2)) {
    const n5 = e2;
    s3 = new Float64Array(2 * t3);
    for (let e3 = 0, r = 0; e3 < t3; e3++, r += 2) s3[r] = n5[e3].x, s3[r + 1] = n5[e3].y;
  } else s3 = e2;
  return s3;
}
function bl(e2, t3, s3, n5) {
  for (let r = 0, i2 = 0; r < n5; r++, i2 += 2) t3[s3 + r].x = e2[i2], t3[s3 + r].y = e2[i2 + 1];
}
function wl(e2, t3, n5, r) {
  if (0 === t3 || 1 === r) return t3;
  const i2 = Il(e2, t3);
  if (2 === r) {
    const s3 = n5.getPannableExtentInGCS();
    let r2 = t3;
    for (let e3 = 0, n6 = 2 * t3; e3 < n6; e3 += 2) (i2[e3 + 1] > s3.ymax || i2[e3 + 1] < s3.ymin) && (i2[e3] = Number.NaN, r2--);
    return r2 ? (Bl(i2, t3, s3.xmin, s3.width(), true), e2 !== i2 && bl(i2, e2, 0, t3), r2) : (e2 !== i2 && bl(i2, e2, 0, t3), 0);
  }
  const o = n5.getOneDegreeGCSUnit(), a2 = 90 * o, h2 = 180 * o, m3 = 360 * o;
  let l2 = t3;
  for (let s3 = 0, p3 = 2 * t3; s3 < p3; s3 += 2) (i2[s3 + 1] > a2 || i2[s3 + 1] < -a2) && (i2[s3] = Number.NaN, l2--);
  if (!l2) return e2 !== i2 && bl(i2, e2, 0, t3), 0;
  const g2 = n3.constructEmpty();
  g2.setFromPoints(i2, t3);
  const u = n5.getGCSHorizon(), c = n5.getGCSHorisonIsInclusive(), _ = u.getGeometryType() === a.enumEnvelope, d2 = n3.constructEmpty();
  if (u.queryEnvelope(d2), c && (d2.ymax < g2.ymin || d2.ymin > g2.ymax)) return e2 !== i2 && bl(i2, e2, 0, t3), 0;
  if (c) {
    if (Bl(i2, t3, d2.getCenterX() - h2, m3, true), l2 = t3, _) for (let e3 = 0, s3 = 2 * t3; e3 < s3; e3 += 2) d2.containsCoords(i2[e3], i2[e3 + 1]) || (i2[e3] = Number.NaN, l2--);
    else {
      const e3 = Lt2(n5.getGCS(), u, false), s3 = new mi();
      for (let n6 = 0, r2 = 2 * t3; n6 < r2; n6 += 2) {
        s3.setCoords(i2[n6], i2[n6 + 1]);
        0 !== Lo2(u, s3, e3) || (i2[n6] = Number.NaN, l2--);
      }
    }
  } else {
    Bl(i2, t3, -h2, m3, true), l2 = t3;
    const e3 = Lt2(n5.getGCS(), u, false), s3 = new mi();
    for (let n6 = 0, r2 = 2 * t3; n6 < r2; n6 += 2) {
      s3.setCoords(i2[n6], i2[n6 + 1]), s3.isNAN() && l2--;
      const t4 = Ml(s3.x, d2.xmin, d2.xmax, m3);
      s3.x += t4;
      0 !== Lo2(u, s3, e3) && (i2[n6] = Number.NaN, l2--);
    }
  }
  return e2 !== i2 && bl(i2, e2, 0, t3), l2;
}
function vl(t3, s3, n5, r, i2, o) {
  if (s3.isPannable() || P("fold_into_360_degree_range"), t3.isEmpty()) return t3;
  let a2, h2;
  if (2 === s3.getCoordinateSystemType()) {
    const e2 = s3.getPannableExtent();
    h2 = e2.xmin, a2 = e2.width();
  } else {
    const e2 = s3.getOneDegreeGCSUnit();
    a2 = 360 * e2, h2 = n5 - 180 * e2;
  }
  return ql(t3, h2, a2, s3, r, i2, true, o);
}
function Nl(e2, t3, s3, n5) {
  let r, i2;
  if (2 === s3.getCoordinateSystemType()) {
    const e3 = s3.getPannableExtent();
    r = e3.xmin, i2 = e3.width();
  } else {
    const e3 = s3.getOneDegreeGCSUnit();
    i2 = 360 * e3, r = n5 - 180 * e3;
  }
  Bl(e2, t3, r, i2);
}
function Tl(e2, t3) {
  const s3 = t3.width();
  let n5 = ct(e2 - t3.vmin, s3);
  n5 < 0 && (n5 += s3);
  return t3.snapClip(n5 + t3.vmin);
}
function Gl(e2, t3, s3) {
  return e2 > t3.xmax && e2 - t3.xmax < s3 ? t3.xmax : e2 < t3.xmin && t3.xmin - e2 < s3 ? t3.xmin : e2;
}
function Dl(e2, t3, s3) {
  if (e2[0] < t3.vmin || e2[0] > t3.vmax || s3 && e2[0] === t3.vmax) {
    const s4 = t3.width();
    return e2[0] += Math.ceil((t3.vmin - e2[0]) / s4) * s4, e2[0] = t3.snapClip(e2[0]), true;
  }
  return false;
}
function Vl(e2, t3, s3, n5, r, i2, o, a2, h2) {
  return new Dm(e2, null, s3, t3, n5, r, o, a2, i2).geoNormalizePolygonGeometry(h2);
}
function Fl(e2, t3, s3, n5, r, i2, o, a2, h2) {
  return new Dm(e2, null, s3, t3, n5, r, o, a2, i2).geoNormalizePolylineGeometry(h2);
}
function Hl(e2, t3, s3, n5, r) {
  const i2 = new Pr(), o = i2.addGeometry(e2);
  return kl(i2, o, t3, Lt2(t3, e2, false), s3, n5, r), i2.getGeometry(o);
}
function kl(e2, t3, s3, n5, r, i2, a2) {
  const h2 = { stack: [], error: void 0, hasError: false };
  try {
    n(Uu2()), s3.isPannable() || C("insert_geodetic_points");
    const m3 = s3.getPannableExtent(), l2 = s3.getGCS(), g2 = Hu2();
    l2.querySpheroidData(g2);
    const c = l2.getUnit().getUnitToBaseFactor(), _ = g2.majorSemiAxis, d2 = g2.e2;
    let p3 = 0;
    const f3 = new x2();
    m3.queryIntervalX(f3);
    let x4 = null;
    const y2 = Yt(4, Number.NaN);
    2 === s3.getCoordinateSystemType() ? (x4 = s3.getPECoordSys(), i2 ? (y2[0] = Tl(a2, f3), y2[1] = m3.getCenterY(), wc.projToGeog(x4, 1, y2), p3 = y2[0] * c) : (y2[0] = m3.getCenterX(), y2[1] = a2, wc.projToGeog(x4, 1, y2), p3 = y2[1] * c)) : p3 = a2 * c, i2 || 0 === p3 || 2 === r || C("insert_geodetic_points: 1");
    const P5 = __addDisposableResource(h2, new Cc(), false), E2 = new mi(), S3 = new mi(), C3 = new mi(), I4 = new mi(), b2 = new mi(), w4 = new mi();
    for (let o = e2.getFirstPath(t3); o !== cr; o = e2.getNextPath(o)) {
      const t4 = e2.getFirstVertex(o);
      e2.queryXY(t4, C3);
      let h3 = false;
      const m4 = e2.getNextVertex(t4);
      for (let o2 = m4; o2 !== cr; o2 = e2.getNextVertex(o2)) {
        if (o2 === m4) {
          if (h3) break;
          h3 = true;
        }
        if (e2.queryXY(o2, I4), i2 && (n5 < a2 - C3.x && I4.x - a2 > n5 || n5 < a2 - I4.x && C3.x - a2 > n5) || !i2 && (0 !== a2 || n5 < -C3.y && I4.y > n5 || n5 < -I4.y && C3.y > n5)) do {
          if (Math.abs(C3.x - I4.x) >= 0.5 * f3.width()) break;
          2 === s3.getCoordinateSystemType() ? (y2[0] = Tl(C3.x, f3), y2[1] = C3.y, y2[2] = Tl(I4.x, f3), y2[3] = I4.y, ag(x4, 2, y2, 0), b2.x = y2[0] * c, b2.y = y2[1] * c, w4.y = y2[3] * c) : (b2.x = C3.x * c, b2.y = C3.y * c, w4.y = I4.y * c), w4.x = (I4.x - C3.x) * Math.PI * 2 / f3.width() + b2.x;
          let t5 = 0;
          const n6 = Ot(mi, 2);
          if (i2) {
            if (S3.x = p3, S3.y = Cl(_, d2, b2, w4, p3, r), Number.isNaN(S3.y)) break;
            n6[0] = S3, t5 = 1;
          } else if (2 === r) {
            const e3 = [0, 0];
            if (t5 = Ds3(_, d2, b2, w4, p3, e3), !t5) break;
            n6[0].x = e3[0], n6[0].y = p3, 2 === t5 && (n6[1].x = e3[1], n6[1].y = p3);
          } else {
            if (S3.x = Hg(_, d2, b2, w4, r), Number.isNaN(S3.x)) break;
            S3.y = 0, n6[0] = S3, t5 = 1;
          }
          let h4 = -1;
          for (let m5 = 0; m5 < t5; m5++) {
            Dc.geodeticDistance(_, d2, b2.x, b2.y, w4.x, w4.y, P5, null, null, r);
            const t6 = P5.val;
            Dc.geodeticDistance(_, d2, b2.x, b2.y, n6[m5].x, n6[m5].y, P5, null, null, r);
            const l3 = P5.val;
            2 === s3.getCoordinateSystemType() ? (y2[0] = n6[m5].x / c, y2[1] = n6[m5].y / c, wc.geogToProj(x4, 1, y2), i2 ? (E2.y = y2[1], E2.x = a2) : (E2.x = kg(y2[0], C3.x, I4.x, f3), E2.y = a2)) : i2 ? (E2.x = a2, E2.y = n6[m5].y / c) : (E2.x = kg(n6[m5].x / c, C3.x, I4.x, f3), E2.y = a2);
            const g3 = t6 > 0 ? Us(l3 / t6, 0, 1) : 0.5;
            if (0 === g3 || 1 === g3) continue;
            if (h4 > g3) continue;
            const u = e2.getPrevVertex(o2);
            e2.splitSegment(u, [g3], 1);
            const p4 = e2.getNextVertex(u);
            e2.setXYCoords(p4, E2.x, E2.y), h4 = g3;
          }
        } while (0);
        C3.setCoordsPoint2D(I4);
      }
    }
  } catch (m3) {
    h2.error = m3, h2.hasError = true;
  } finally {
    __disposeResources(h2);
  }
}
function Al(e2, t3) {
  n(t3.isPannable());
  const n5 = t3.getPannableExtent();
  if (e2.getGeometryType() === a.enumPoint) {
    const t4 = e2.getY();
    return n5.ymin <= t4 && t4 <= n5.ymax ? e2 : e2.createInstance();
  }
  const r = n3.constructEmpty();
  e2.queryEnvelope(r);
  const i2 = n3.constructEmpty();
  i2.setCoords({ env2D: n5 }), i2.xmin = r.xmin, i2.xmax = r.xmax, i2.inflateCoords(0.01 * i2.height(), 0);
  const a2 = zt2(t3, r, false);
  let h2;
  return h2 = i2.containsEnvelope(r) ? e2 : f2(e2, i2, a2, 0, null), h2;
}
function Ml(e2, t3, s3, n5) {
  return S((0.5 * (s3 + t3) - e2) / n5) * n5;
}
function Ul(e2, t3, s3, n5, r) {
  if (e2 >= s3 && t3 <= n5) return 0;
  return Ml(0.5 * (t3 + e2), s3, n5, r);
}
function ql(e2, t3, n5, r, i2, o, a2, h2) {
  const m3 = e2.getGeometryType(), l2 = x2.constructEmpty();
  l2.setCoords(t3, t3 + n5);
  const g2 = [0];
  if (m3 === a.enumPoint) {
    const t4 = e2;
    if (g2[0] = t4.getX(), Dl(g2, l2, a2)) {
      const t5 = i2 ? e2 : e2.clone();
      return t5.setX(g2[0]), t5;
    }
    return e2;
  }
  const u = n3.constructEmpty();
  if (e2.queryEnvelope(u), u.isEmpty()) return e2;
  if (m3 === a.enumMultiPoint) {
    const t4 = i2 ? e2 : e2.clone(), s3 = t4.getImpl(), n6 = s3.getAttributeStreamRef(0), r2 = 2 * s3.getPointCount();
    let o2 = false;
    for (let e3 = 0; e3 < r2; e3 += 2) g2[0] = n6.read(e3), Dl(g2, l2, a2) && (n6.write(e3, g2[0]), o2 = true);
    return o2 && s3.notifyModifiedFlags(2001), t4;
  }
  const c = x2.constructEmpty();
  if (u.queryIntervalX(c), l2.contains(c)) return l2.vmax, c.vmax, e2;
  const _ = n3.constructEmpty();
  if (_.setCoords({ env2D: u }), 0 === c.width()) {
    let t4 = c.vmin;
    t4 += Math.ceil((l2.vmin - t4) / n5) * n5, t4 = l2.snapClip(t4);
    const s3 = i2 ? e2 : e2.clone();
    return s3.setAttributeBasic(0, 0, t4), s3;
  }
  if (m3 === a.enumEnvelope) {
    const t4 = i2 ? e2 : e2.clone();
    return u.intersect(_), t4.setEnvelope(u), t4;
  }
  const d2 = 0.1 * Math.max(u.height(), u.width()) * 1;
  _.inflateCoords(0, d2);
  let p3 = e2;
  const f3 = r.getTolerance(0), x4 = new x3();
  for (; ; ) {
    const e3 = Math.floor((c.vmin - t3) / n5), i3 = Math.ceil((c.vmax - t3) / n5);
    if (!(i3 - e3 > 3)) break;
    {
      const a3 = Math.floor(0.5 * (i3 + e3));
      _.xmin = u.xmin - d2, _.xmax = t3 + n5 * a3;
      const l3 = f2(p3, _, f3, o, h2);
      _.xmin = _.xmax, _.xmax = u.xmax + d2;
      const g3 = f2(p3, _, f3, o, h2);
      x4.setShiftCoords((a3 - i3) * n5, 0), g3.applyTransformation(x4), m3 === a.enumPolygon ? p3 = new al().execute(l3, g3, r, h2) : (p3 = l3, p3.add(g3, false)), p3.queryEnvelope(u), u.queryIntervalX(c);
    }
  }
  _.xmin = t3, _.xmax = t3 + n5;
  const y2 = n3.constructEmpty();
  y2.setCoords({ env2D: _ }), y2.inflateCoords(f3, 0);
  const P5 = Math.floor((u.xmin - _.xmin) / n5) * n5;
  let E2;
  P5 ? (_.move(P5, 0), x4.setShiftCoords(-P5, 0)) : x4.setIdentity(), E2 = m3 === a.enumPolyline ? new Os2({ vd: p3.getDescription() }) : new ur({ vd: p3.getDescription() });
  const S3 = n3.constructEmpty(), b2 = n3.constructEmpty();
  for (; u.xmax > _.xmin; ) {
    const e3 = f2(p3, _, f3, 0, h2);
    e3.queryEnvelope(b2);
    let t4 = false;
    t4 = m3 === a.enumPolyline ? !e3.isEmpty() && (b2.width() > f3 || b2.height() > f3) : !e3.isEmpty() && (m3 !== a.enumPolygon || b2.width() > f3), t4 && (e3.applyTransformation(x4), e3.queryEnvelope(b2), E2.queryEnvelope(S3), S3.inflateCoords(f3, f3), S3.isIntersecting(b2) && m3 === a.enumPolygon ? E2 = new al().execute(E2, e3, r, h2) : E2.add(e3, false)), _.move(n5, 0), x4.shiftCoords(-n5, 0);
  }
  return E2;
}
function Bl(e2, t3, s3, n5, r = true) {
  const i2 = new x2();
  i2.setCoords(s3, s3 + n5);
  const o = [0];
  if (Array.isArray(e2)) {
    const s4 = e2;
    for (let e3 = 0; e3 < t3; e3++) i2.containsRightExclusive(s4[e3].x) || (o[0] = s4[e3].x, Dl(o, i2, r), s4[e3].x = o[0]);
  } else {
    const s4 = e2;
    for (let e3 = 0; e3 < t3; e3++) {
      const t4 = e3 << 1;
      i2.containsRightExclusive(s4[t4]) || (o[0] = s4[t4], Dl(o, i2, r), s4[t4] = o[0]);
    }
  }
}
function Ol(e2, t3, n5, a2 = true) {
  if (e2.isEmpty()) return;
  const h2 = e2.getGeometryType();
  if (!a2 || h2 !== a.enumPolygon) if (y(h2)) {
    let s3 = false;
    if (h(h2) && e2.hasNonLinearSegments()) {
      const r = e2.getImpl(), i2 = r.getAttributeStreamRef(0), a3 = r.getSegmentFlagsStreamRef();
      n(null !== a3);
      for (let e3 = 0, o = r.getPathCount(); e3 < o; e3++) {
        let o2 = true;
        const h3 = r.isClosedPath(e3), m3 = r.getPathEnd(e3);
        if (h3 && r.getPathSize(e3) > 0) {
          o2 = 1 === (31 & a3.read(m3 - 1));
        }
        for (let l2 = r.getPathStart(e3); l2 < m3; l2++) {
          if (1 === (31 & a3.read(l2))) {
            if (o2) {
              const e4 = i2.read(2 * l2), r2 = Gl(e4, t3, n5);
              r2 !== e4 && (s3 = true, i2.write(2 * l2, r2));
            }
            o2 = true;
          } else o2 = false;
        }
      }
    } else {
      const r = e2.getImpl(), i2 = r.getAttributeStreamRef(0);
      for (let e3 = 0, o = r.getPointCount(); e3 < o; e3++) {
        const r2 = i2.read(2 * e3), o2 = Gl(r2, t3, n5);
        o2 !== r2 && (s3 = true, i2.write(2 * e3, o2));
      }
    }
    s3 && e2.getImpl().notifyModifiedFlags(2001);
  } else if (h2 === a.enumEnvelope) {
    const s3 = e2, r = n3.constructEmpty();
    s3.queryEnvelope(r), r.xmin = Gl(r.xmin, t3, n5), r.xmax = Gl(r.xmax, t3, n5), s3.setEnvelope(r);
  } else if (h2 === a.enumPoint) {
    const s3 = e2;
    s3.setX(Gl(s3.getX(), t3, n5));
  } else b("");
}
function Yl(e2, t3, s3) {
  const n5 = new mi();
  return n5.x = Gl(e2.x, t3, s3), n5.y = e2.y, n5;
}
function Rl(e2, t3) {
  if (t3.isEmpty()) return 0;
  const s3 = e2.getPECoordSys();
  if (s3.getProjection().getCode() === bc.PE_PRJ_AZIMUTHAL_EQUIDISTANT) {
    const n5 = Hu2();
    e2.querySpheroidData(n5);
    const r = s3.getParameters();
    if (null === r[bc.PE_PARM_LAM0]) return 0;
    if (null === r[bc.PE_PARM_PHI0]) return 0;
    const i2 = [r[bc.PE_PARM_LAM0].getValue(), r[bc.PE_PARM_PHI0].getValue()];
    wc.geogToProj(s3, 1, i2);
    const o = new mi(i2[0], i2[1]), a2 = n3.constructEmpty();
    t3.queryEnvelope(a2);
    const h2 = Ot(mi, 4);
    a2.queryCorners(h2);
    let m3 = 0;
    const l2 = e2.getOneMeter();
    let g2 = Math.max(n5.majorSemiAxis, n5.minorSemiAxis) * Math.PI, u = Math.min(n5.majorSemiAxis, n5.minorSemiAxis) * Math.PI;
    u -= g2 / 180, g2 *= l2, u *= l2;
    for (let e3 = 0; e3 < 4; e3++) {
      const t4 = mi.distance(h2[e3], o);
      if (t4 > g2) m3++;
      else if (t4 > u) return -1;
    }
    if (0 === m3) return 1;
    if (4 === m3) {
      const e3 = n3.constructEmpty();
      return e3.setCoords({ center: o, width: g2, height: g2 }), a2.isIntersectingNe(e3) ? -1 : 0;
    }
    return -1;
  }
  return -1;
}
function Xl(e2, t3, n5, r) {
  const i2 = e2.getGeometryType();
  n(i2 === a.enumPolygon || i2 === a.enumPolyline || i2 === a.enumMultiPoint);
  const a2 = t3.getCoordinateSystemType();
  if (2 === a2) {
    let o = e2;
    if (0 === n5) {
      const n6 = Rl(t3, e2);
      if (0 === n6) return e2.createInstance();
      if (1 === n6) return e2;
      const i3 = t3.getPCSHorizon(), a3 = i3.getGeometryType(), h2 = t3.getDefaultPrecisionSR();
      if (a3 === a.enumEnvelope) {
        const s3 = n3.constructEmpty();
        i3.queryEnvelope(s3);
        const n7 = zt2(h2, s3, false);
        o = f2(e2, s3, n7, 5e4 * t3.getOneMeterPCSUnit(), r);
      } else new jm().execute(i3, e2, h2, r) || (o = new wh2().execute(o, i3, h2, r), o === i3 && (o = o.clone()));
    } else if (t3.isPannable()) {
      const e3 = n3.constructEmpty();
      o.queryEnvelope(e3);
      const a3 = t3.getPannableExtent();
      a3.containsEnvelope(e3) || (Ol(o, a3, t3.getTolerance(0)), 2 !== n5 && 4 !== n5 || (o = Al(o, t3)), 4 !== n5 ? o = vl(o, t3, 0, true, 1e5 * t3.getOneMeterPCSUnit(), r) : i2 === a.enumPolygon && e3.width() > 2 * a3.width() && (o = ql(o, -2 * a3.width(), 2 * a3.width(), t3, true, 0, true, r)));
    }
    return o;
  }
  if (n(1 === a2), i2 === a.enumMultiPoint) return Ol(e2, t3.getPannableExtent(), t3.getTolerance(0)), e2;
  {
    const n6 = n3.constructEmpty();
    e2.queryEnvelope(n6);
    let o = e2;
    const a3 = t3.getPannableExtent();
    if (n6.ymin < a3.ymin || n6.ymax > a3.ymax) {
      const e3 = Math.max(1, n6.calculateToleranceFromEnvelope()), s3 = new n3(n6.xmin - e3, a3.ymin, n6.xmax + e3, a3.ymax);
      if (o = new I3().execute(o, s3, t3, r), o.isEmpty()) return o;
    }
    return i2 === a.enumPolygon && n6.width() > 2 * a3.width() && (o = ql(o, -2 * a3.width(), 2 * a3.width(), t3, true, 0, true, r)), o;
  }
}
function Ll(e2, t3, s3, n5, r, i2) {
  const a2 = n5.getCoordinateSystemType();
  if (2 === a2) {
    if (0 === r) s3 !== e2 && Gt(s3, e2, t3), Pl(n5, s3, t3);
    else if (s3 !== e2 && Gt(s3, e2, t3), n5.isPannable()) {
      const e3 = n5.getTolerance(0);
      El(s3, t3, n5.getPannableExtent(), e3), Nl(s3, t3, n5, 0);
    }
  } else {
    n(1 === a2);
    const r2 = n5.getTolerance(0), i3 = n5.getPannableExtent();
    for (let n6 = 0; n6 < t3; n6++) s3[n6].assign(Yl(e2[n6], i3, r2));
  }
}
function zl(e2, t3) {
  const s3 = t3.getPointCount();
  if (!s3) return;
  const n5 = t3.getImpl(), r = n5.getAttributeStreamRef(0), i2 = e2;
  wc.geogToProj(i2, s3, r.getArray()), n5.notifyModifiedFlags(2001);
}
function Wl(e2, t3, s3, n5) {
  if (!s3) return;
  const r = e2.getPECoordSys();
  if (1 === s3) {
    if (t3[0].isNAN()) return;
    const s4 = [t3[0].x, t3[0].y];
    if (wc.geogToProj(r, 1, s4), n5) {
      const { first: n6, second: r2 } = e2.m_peCoordSysVal.getGeogToProjFactors();
      s4[0] = n6 * (t3[0].x - e2.getCentralMeridian()) + r2;
    }
    return void t3[0].setCoords(s4[0], s4[1]);
  }
  const i2 = e2.isPannable(), o = i2 ? e2.getPannableExtent().width() : 0, a2 = 179 * o / 360;
  let h2 = 0;
  i2 && (h2 = e2.getCentralMeridian());
  const m3 = 256, l2 = new Float64Array(2 * m3);
  for (let g2 = 0; g2 < s3; ) {
    for (let e3 = g2; e3 < s3 && t3[e3].isNAN(); ++e3) g2++;
    let u = Math.min(m3, s3 - g2);
    if (u > 0) {
      for (let e3 = 1, s4 = g2 + 1; e3 < u; ++e3, ++s4) if (t3[s4].isNAN()) {
        u = e3;
        break;
      }
      for (let e3 = 0; e3 < u; ++e3) {
        const s4 = e3 << 1;
        l2[s4] = t3[g2 + e3].x, l2[s4 + 1] = t3[g2 + e3].y;
      }
      if (wc.geogToProj(r, u, l2), n5) {
        const { first: s4, second: n6 } = e2.m_peCoordSysVal.getGeogToProjFactors();
        for (let e3 = 0; e3 < u; ++e3) {
          l2[e3 << 1] = s4 * (t3[g2 + e3].x - h2) + n6;
        }
      }
      if (i2) for (let e3 = 0, s4 = g2; e3 < u; e3++, s4++) {
        const n6 = e3 << 1, r2 = l2[n6], i3 = K(r2), m4 = t3[s4].x - h2;
        i3 * K(m4) < 0 && Math.abs(r2) > a2 && (l2[n6] -= i3 * o);
      }
      bl(l2, t3, g2, u), g2 += u;
    }
  }
}
function Zl(e2, t3, s3, n5) {
  const r = new cs2({ vd: t3.getDescription() });
  let i2;
  r.addPoints(t3, 0, -1), i2 = new qh().execute(r, e2, n5);
  const o = t3.getPointCount();
  if (s3.setEmpty(), e2.getInputSR().isPannable()) {
    if (o !== i2.getPointCount()) return false;
    const n6 = new n3();
    t3.queryEnvelope(n6);
    const r2 = new n3();
    i2.queryEnvelope(r2);
    const a2 = n6.width(), h2 = r2.width();
    if (0 !== a2 && 0 !== h2) {
      const t4 = h2 / a2, s4 = e2.getOutputSR().getPannableExtent().width() / e2.getInputSR().getPannableExtent().width();
      if (Math.abs(t4 / s4 - 1) > 1e-10) return false;
    } else if (0 !== a2 || 0 !== h2) return false;
    s3.add(t3, false);
    for (let e3 = 0; e3 < o; e3++) {
      const t4 = i2.getXY(e3);
      s3.setXY(e3, t4);
    }
    return true;
  }
  return false;
}
function Kl(e2, t3, s3) {
  n(!s3 || e2.isPannable());
  const n5 = t3.getPointCount();
  if (!n5) return;
  const r = t3.getImpl(), i2 = r.getAttributeStreamRef(0), a2 = e2.getPECoordSys();
  let h2 = 0;
  const m3 = i2.readRange(0, 2 * n5);
  let l2 = () => {
    wc.geogToProj(a2, n5, m3);
  };
  const g2 = e2.isPannable() && !s3, u = g2 ? e2.getPannableExtent().width() : 0, c = 179 * u / 360;
  if (e2.isPannable() && (h2 = e2.getCentralMeridian(), s3)) {
    const t4 = e2.m_peCoordSysVal.getGeogToProjFactors(), s4 = t4.first, r2 = t4.second;
    l2 = () => {
      wc.geogToProj(a2, n5, m3);
      for (let e3 = 0; e3 < n5; e3++) {
        const t5 = e3 << 1, n6 = i2.read(t5), o = s4 * (n6 - h2) + r2;
        m3[t5] = o;
      }
    };
  }
  if (l2(), g2) for (let o = 0; o < n5; o++) {
    const e3 = o << 1, t4 = m3[e3], s4 = K(t4), n6 = i2.read(e3) - h2;
    s4 * K(n6) < 0 && Math.abs(t4) > c && (m3[e3] += -s4 * u);
  }
  i2.writeRangeFromArray(0, 2 * n5, m3, true, 1), r.notifyModifiedFlags(2001);
}
function Ql(e2, t3, n5) {
  switch (t3.getGeometryType()) {
    case a.enumLine:
      return void Ig(e2, t3, n5);
    case a.enumBezier:
      return void Gg(e2, t3, n5);
    case a.enumEllipticArc:
      return void wg(e2, t3, n5);
    case a.enumBezier2:
      return void Dg();
    case a.enumRationalBezier2:
      return void Vg();
    default:
      b("");
  }
}
function Jl(e2, t3, s3) {
  if (!t3.hasNonLinearSegments()) return void Kl(e2, t3, s3);
  if (n(!s3 || e2.isPannable()), t3.isEmpty()) return;
  const n5 = 0, r = e2.getPECoordSys(), i2 = e2.isPannable(), a2 = i2 ? e2.getPannableExtent().width() : 0, h2 = 179 * a2 / 360;
  let m3 = 0;
  i2 && (m3 = e2.getCentralMeridian());
  const l2 = t3.createInstance();
  l2.reserveParts(t3.getPointCount(), t3.getPathCount());
  const g2 = t3.getImpl(), u = new fm();
  for (let o = 0, c = t3.getPathCount(); o < c; ++o) if (g2.hasNonLinearSegmentsPath(o)) {
    let t4 = true, n6 = -1;
    const r2 = g2.getPathStart(o), i3 = r2 + g2.getSegmentCountPath(o);
    g2.isClosedPath(o) && (n6 = i3 - 1);
    const a3 = new mi();
    for (let o2 = r2; o2 < i3; ++o2) {
      if (g2.getSegmentBuffer(o2, u, false), Ql(e2, u.get(), s3), !t4) {
        u.get().getStartXY().equals(a3) || u.get().moveTo(a3);
      }
      if (o2 !== n6) l2.addSegment(u.get(), t4);
      else {
        if (t4) {
          const e3 = new ee();
          u.get().queryStart(e3), l2.startPathPoint(e3);
        }
        l2.closeLastPathWithSegment(u.get());
      }
      a3.assign(u.get().getEndXY()), t4 = false;
    }
  } else {
    const e3 = 1024;
    let s4, u2 = g2.getPathSize(o), c2 = Math.min(u2, e3);
    l2.insertPath(-1, t3, o, true);
    const _ = g2.getAttributeStreamRef(0), d2 = l2.getAttributeStreamRef(0);
    for (let t4 = g2.getPathStart(o), l3 = g2.getPathEnd(o); t4 < l3; ) {
      if (s4 = _.readRange(t4, c2), wc.geogToProj(r, c2, s4), i2) for (let e4 = 0; e4 < c2; e4++) {
        const t5 = e4 << 1, r2 = s4[t5], i3 = K(r2), o2 = _.read(2 * (n5 + e4)) - m3;
        i3 * K(o2) < 0 && Math.abs(r2) > h2 && (s4[t5] += -i3 * a2);
      }
      d2.writeRangeFromArray(t4, c2, s4, true, 1), t4 += c2, u2 -= c2, c2 = Math.min(u2, e3);
    }
  }
  t3.assignMove(l2);
}
function $l(e2, t3, s3) {
  const n5 = 1e3;
  let r = s3.getPointCount();
  if (!r) return;
  const i2 = s3.getImpl(), o = i2.getAttributeStreamRef(0);
  let a2 = Math.min(r, n5), h2 = 0;
  const m3 = e2.getPECoordSys();
  Number.isNaN(t3) && (t3 = 0);
  const l2 = e2.isPannable(), g2 = e2.getOneDegreeGCSUnit(), u = 360 * g2, c = 179 * g2;
  let _;
  for (; r; ) {
    if (_ = o.readRange(2 * h2, 2 * a2), ag(m3, a2, _, t3), l2) for (let e3 = 0; e3 < a2; e3++) {
      const s4 = e3 << 1, n6 = _[s4] - t3, r2 = K(n6), i3 = o.read(2 * (h2 + e3));
      r2 * K(i3) < 0 && Math.abs(n6) > c && (_[s4] += -r2 * u);
    }
    o.writeRangeFromArray(2 * h2, 2 * a2, _, true, 1), h2 += a2, r -= a2, a2 = Math.min(r, n5);
  }
  i2.notifyModifiedFlags(2001);
}
function eg(e2, t3, n5) {
  switch (n5.getGeometryType()) {
    case a.enumLine:
      return void tg(e2, t3, n5);
    case a.enumBezier:
      return void rg(e2, t3, n5);
    case a.enumEllipticArc:
      return void sg(e2, t3, n5);
    case a.enumBezier2:
      return void ig();
    case a.enumRationalBezier2:
      return void og();
    default:
      b("");
  }
}
function tg(e2, t3, s3) {
  const n5 = [s3.getStartXY(), s3.getEndXY()];
  mg(e2, t3, n5, 2), s3.setStartXY(n5[0]), s3.setEndXY(n5[1]), s3.normalizeAfterEndpointChange();
}
function sg(e2, t3, s3) {
  if (0 === s3.projectionBehavior()) ng(e2, t3, s3);
  else {
    const n5 = s3.isClosed() && s3.isMajor(), r = [s3.getStartXY(), n5 ? s3.getCenter() : s3.getEndXY()], i2 = [r[0].clone(), r[1].clone()];
    vg(e2, t3, i2, 2);
    const o = new x3();
    o.initializeFromTwoPointsArray(r, i2), s3.applyTransformation(o);
    const a2 = n5 ? 0 : 1;
    s3.setCoordsForIntersector(i2[0], i2[a2], false);
  }
}
function ng(e2, t3, s3) {
  Ng(false, e2, t3, s3, false);
}
function rg(e2, t3, s3) {
  const n5 = Ot(mi, 4);
  s3.queryControlPoints(n5), vg(e2, t3, n5, 4), s3.setControlPoints(n5);
}
function ig(e2, t3, s3) {
  n(0);
}
function og(e2, t3, s3) {
  n(0);
}
function ag(e2, t3, s3, n5) {
  const r = wc.projToGeogCenter(e2, t3, s3, n5);
  for (let i2 = 0; i2 < t3; ++i2) {
    const e3 = i2 << 1;
    n(Number.isFinite(s3[e3] + s3[e3 + 1]));
  }
  return r;
}
function hg(e2, t3, s3) {
  if (!s3.hasNonLinearSegments()) return void $l(e2, t3, s3);
  if (s3.isEmpty()) return;
  const n5 = e2.getPECoordSys();
  Number.isNaN(t3) && (t3 = 0);
  const r = e2.isPannable(), i2 = e2.getOneDegreeGCSUnit(), o = 360 * i2, a2 = 179 * i2, h2 = s3.createInstance();
  h2.reserveParts(s3.getPointCount(), s3.getPathCount());
  const m3 = s3.getImpl(), l2 = new fm();
  for (let g2 = 0, u = s3.getPathCount(); g2 < u; ++g2) if (m3.hasNonLinearSegmentsPath(g2)) {
    let s4 = true, n6 = -1;
    const r2 = m3.getPathStart(g2), i3 = r2 + m3.getSegmentCountPath(g2);
    m3.isClosedPath(g2) && (n6 = i3 - 1);
    const o2 = new mi();
    for (let a3 = r2; a3 < i3; ++a3) {
      if (m3.getSegmentBuffer(a3, l2, false), eg(e2, t3, l2.get()), !s4) {
        l2.get().getStartXY().equals(o2) || l2.get().moveTo(o2);
      }
      if (a3 !== n6) h2.addSegment(l2.get(), s4);
      else {
        if (s4) {
          const e3 = new ee();
          l2.get().queryStart(e3), h2.startPathPoint(e3);
        }
        h2.closeLastPathWithSegment(l2.get());
      }
      o2.assign(l2.get().getEndXY()), s4 = false;
    }
  } else {
    const e3 = 1e3;
    let i3, l3 = m3.getPathSize(g2), u2 = Math.min(l3, e3);
    h2.insertPath(-1, s3, g2, true);
    const c = m3.getAttributeStreamRef(0), _ = h2.getAttributeStreamRef(0);
    for (let s4 = m3.getPathStart(g2), h3 = m3.getPathEnd(g2); s4 < h3; ) {
      if (i3 = c.readRange(2 * s4, 2 * u2), ag(n5, u2, i3, t3), r) for (let e4 = 0; e4 < u2; e4++) {
        const n6 = e4 << 1, r2 = i3[n6] - t3, h4 = K(r2), m4 = c.read(2 * s4);
        h4 * K(m4) < 0 && Math.abs(r2) > a2 && (i3[n6] += -h4 * o);
      }
      _.writeRangeFromArray(2 * s4, 2 * u2, i3, true, 1), s4 += u2, l3 -= u2, u2 = Math.min(l3, e3);
    }
  }
  s3.assignMove(h2);
}
function mg(e2, t3, s3, n5) {
  const r = e2.getPECoordSys();
  Number.isNaN(t3) && (t3 = 0);
  const i2 = e2.isPannable(), o = e2.getOneDegreeGCSUnit(), a2 = 360 * o, h2 = 179 * o, m3 = 256, l2 = new Float64Array(2 * m3);
  for (let g2 = 0; g2 < n5; ) {
    for (let t4 = g2; t4 < n5 && s3[t4].isNAN(); ++t4) g2++;
    let e3 = Math.min(m3, n5 - g2);
    if (e3 > 0) {
      for (let t4 = 1, n6 = g2 + 1; t4 < e3; ++t4, ++n6) if (s3[n6].isNAN()) {
        e3 = t4;
        break;
      }
      for (let t4 = 0; t4 < e3; t4++) {
        const e4 = t4 << 1;
        l2[e4] = s3[g2 + t4].x, l2[e4 + 1] = s3[g2 + t4].y;
      }
      if (ag(r, e3, l2, t3), i2) for (let n6 = 0, r2 = g2; n6 < e3; ++n6, ++r2) {
        const e4 = n6 << 1, i3 = s3[r2].x, o2 = l2[e4] - t3, m4 = K(o2);
        m4 * K(i3) < 0 && Math.abs(o2) > h2 && (l2[e4] -= m4 * a2);
      }
      for (let t4 = 0; t4 < e3; t4++) {
        const e4 = t4 << 1;
        s3[g2 + t4].x = l2[e4], s3[g2 + t4].y = l2[e4 + 1];
      }
      g2 += e3;
    }
  }
}
function lg(e2, t3, s3, n5) {
  n(0);
}
function gg(e2, t3, s3) {
  let n5 = t3.getPointCount();
  if (!n5) return false;
  const r = t3.getImpl(), i2 = r.getAttributeStreamRef(0);
  let o = null;
  const a2 = e2.getInputSR(), h2 = e2.getOutputSR();
  a2.getVCS(), h2.getVCS();
  const m3 = a2.getOneDegreeGCSUnit(), l2 = h2.getOneDegreeGCSUnit(), g2 = e2.isVertical();
  g2 && t3.hasAttribute(1) && (o = r.getAttributeStreamRef(1));
  const u = e2.getDatumTransformation(), c = !!u && 1 === u.getType();
  if (c || null === o || (lg(o.getArray()), o = null), !u || 0 === u.count()) {
    const e3 = a2.getGcsUnitFactor() / h2.getGcsUnitFactor(), t4 = (a2.getPrimeMeridian() - h2.getPrimeMeridian()) * l2, s4 = -90 * m3, o2 = 90 * m3;
    let g3 = 0;
    const u2 = i2.getArray(), c2 = [0];
    for (let r2 = 1, i3 = 2 * n5; r2 < i3; ) c2[0] = u2[r2], g3 |= Ys(c2, s4, o2) ? 1 : 0, u2[r2] = c2[0], r2 += 2;
    if (0 !== t4 || 1 !== e3) {
      g3 = 1;
      const s5 = i2.getArray();
      for (let r2 = 0, i3 = 2 * n5; r2 < i3; ) {
        let n6 = s5[r2];
        n6 *= e3, n6 += t4, s5[r2] = n6, s5[r2 + 1] *= e3, r2 += 2;
      }
    }
    return 0 !== g3 && r.notifyModifiedFlags(2001), !!g3;
  }
  const _ = 1e3;
  let d2 = Math.min(n5, _);
  const p3 = Yt(d2, Number.NaN), f3 = Yt(d2, Number.NaN);
  let x4 = null;
  null !== o && (x4 = new Float64Array(d2));
  let y2 = 0, P5 = Number.NaN, E2 = Number.NaN;
  const S3 = 360 * l2, C3 = l2 / m3;
  s3 && (E2 = 90 * l2, P5 = 89.9 * m3, f3.fill(0));
  let I4 = true, b2 = 0;
  for (; n5; ) {
    let e3 = false;
    const t4 = i2.readRange(2 * y2, 2 * d2);
    for (let s4 = 0; s4 < d2; s4++) p3[s4] = t4[s4 << 1];
    if (s3) for (let s4 = 0; s4 < d2; s4++) {
      const n6 = 1 + (s4 << 1), r3 = Math.abs(t4[n6]) - P5;
      if (r3 > 0) {
        const i3 = t4[n6];
        t4[n6] = B2(P5, i3), f3[s4] = B2(r3, i3), e3 = true;
      }
    }
    const r2 = t4[0];
    if (c) {
      const e4 = u;
      x4 && o.queryRange(y2, d2, x4, true, 1), e4.transform(false, t4, x4, d2), x4 && o.writeRangeFromArray(y2, d2, x4, true, 1);
    } else {
      u.transform(false, t4, d2);
    }
    I4 && (b2 = t4[0] - C3 * r2, I4 = false);
    for (let s4 = 0; s4 < d2; s4++) {
      const e4 = s4 << 1, n6 = t4[e4] - p3[s4] * C3 - b2;
      Math.abs(n6) > 200 && (t4[e4] += n6 > 0 ? -S3 : S3);
    }
    if (e3) {
      for (let e4 = 0; e4 < d2; e4++) if (f3[e4]) {
        const s4 = 1 + (e4 << 1);
        t4[s4] += C3 * f3[e4], t4[s4] > E2 ? t4[s4] = E2 : t4[s4] < -E2 && (t4[s4] = -E2);
      }
      f3.fill(0);
    }
    i2.writeRangeFromArray(2 * y2, 2 * d2, t4, true, 1), g2 && o && o.writeRangeFromArray(y2, d2, x4, true, 1), y2 += d2, n5 -= d2, d2 = Math.min(n5, _);
  }
  return r.notifyModifiedFlags(2001), true;
}
function ug(e2, t3, n5) {
  switch (t3.getGeometryType()) {
    case a.enumLine:
      return xg(e2, t3, n5);
    case a.enumBezier:
      return Eg(e2, t3, n5);
    case a.enumEllipticArc:
      return yg(e2, t3, n5);
    case a.enumBezier2:
      return Sg();
    case a.enumRationalBezier2:
      return Cg();
    default:
      b("");
  }
}
function cg(e2, t3, s3) {
  if (!t3.hasNonLinearSegments()) return gg(e2, t3, s3);
  if (t3.isEmpty()) return false;
  const n5 = t3.createInstance();
  n5.reserveParts(t3.getPointCount(), t3.getPathCount());
  const r = t3.getImpl(), i2 = new fm();
  for (let o = 0, a2 = t3.getPathCount(); o < a2; ++o) {
    let t4 = true, a3 = -1;
    const h2 = r.getPathStart(o), m3 = h2 + r.getSegmentCountPath(o);
    r.isClosedPath(o) && (a3 = m3 - 1);
    const l2 = new mi();
    for (let o2 = h2; o2 < m3; ++o2) {
      if (r.getSegmentBuffer(o2, i2, false), ug(e2, i2.get(), s3), !t4) {
        i2.get().getStartXY().equals(l2) || i2.get().moveTo(l2);
      }
      if (o2 !== a3) n5.addSegment(i2.get(), t4);
      else {
        if (t4) {
          const e3 = new ee();
          i2.get().queryStart(e3), n5.startPathPoint(e3);
        }
        n5.closeLastPathWithSegment(i2.get());
      }
      l2.assign(i2.get().getEndXY()), t4 = false;
    }
  }
  return t3.assignMove(n5), true;
}
function _g(e2, t3, s3, n5, r, i2) {
  if (e2.isIdentityGeogToGeog()) {
    const s4 = 90 * e2.getInputSR().getOneDegreeGCSUnit();
    let r2 = 0;
    const i3 = [0];
    for (let e3 = 0; e3 < n5; e3++) i3[0] = t3[e3].y, r2 |= Ys(i3, -s4, s4) ? 1 : 0, t3[e3].y = i3[0];
    return r2;
  }
  const o = e2.getInputSR(), a2 = e2.getOutputSR(), h2 = o.getVCS(), m3 = a2.getVCS(), l2 = o.getOneDegreeGCSUnit(), g2 = 90 * l2, u = a2.getOneDegreeGCSUnit(), c = e2.isVertical(), _ = e2.getDatumTransformation(), d2 = !!_ && 1 === _.getType();
  if (c || (s3 = null), !_ || 0 === _.count()) {
    let e3 = 0;
    const r2 = [0];
    for (let s4 = 0; s4 < n5; s4++) r2[0] = t3[s4].y, e3 |= Ys(r2, -g2, g2) ? 1 : 0, t3[s4].y = r2[0];
    return e3 |= qm(o.getGCS(), h2, a2.getGCS(), m3, t3, s3, n5) ? 1 : 0, e3;
  }
  d2 || null === s3 || lg();
  const p3 = 1024;
  let f3 = Math.min(n5, p3);
  const x4 = Yt(f3, Number.NaN), y2 = Yt(f3, Number.NaN);
  let P5 = 0, E2 = Number.NaN, S3 = Number.NaN;
  const C3 = 360 * u, I4 = u / l2;
  r && (S3 = 90 * u, E2 = 89.9 * l2);
  let b2 = true, w4 = 0, v3 = n5;
  for (; v3; ) {
    let e3 = false;
    for (let s4 = 0; s4 < f3; s4++) x4[s4] = t3[s4 + P5].x;
    if (r) for (let s4 = 0; s4 < f3; s4++) {
      const n7 = Math.abs(t3[s4 + P5].y) - E2;
      if (n7 > 0) {
        const r2 = t3[s4 + P5].y;
        t3[s4 + P5].y = B2(E2, r2), y2[s4] = B2(n7, r2), e3 = true;
      }
    }
    const n6 = t3[0].x;
    if (d2) {
      _.transform(false, t3, s3, f3);
    } else {
      _.transform(false, t3, f3);
    }
    b2 && (w4 = t3[0].x - I4 * n6, b2 = false);
    for (let s4 = 0; s4 < f3; s4++) {
      const e4 = t3[P5 + s4].x - x4[s4] * I4 - w4;
      Math.abs(e4) > 200 && (e4 > 0 ? t3[P5 + s4].x -= C3 : t3[P5 + s4].x += C3);
    }
    if (e3) {
      for (let e4 = 0; e4 < f3; e4++) y2[e4] && (t3[P5 + e4].y += I4 * y2[e4], t3[P5 + e4].y > S3 ? t3[P5 + e4].y = S3 : t3[P5 + e4].y < -S3 && (t3[P5 + e4].y = -S3));
      y2.fill(0, 0, f3);
    }
    P5 += f3, v3 -= f3, f3 = Math.min(v3, p3);
  }
  return 1;
}
function dg(e2, t3, s3, n5, r) {
  return n(0), 0;
}
function pg(e2, t3, s3, n5, r) {
  n(null === n5), n(t3 < 2147483647);
  const i2 = Array.isArray(s3);
  let a2;
  a2 = i2 ? ai(s3) : s3;
  const h2 = vc.geogToGeog(e2, t3, a2, null, r);
  return i2 && hi(a2, s3), h2;
}
function fg(e2, t3, s3, n5, r, i2) {
  let o = 0, a2 = true, h2 = 0;
  for (let m3 = 0; m3 < n5; ++m3) t3[m3].isNAN() ? a2 || (o |= _g(e2, t3.slice(h2, m3 - h2), s3 ? s3.slice(h2, m3 - h2) : null, m3 - h2, r), h2 = m3, a2 = true) : a2 && (h2 = m3, a2 = false);
  return a2 || (o |= _g(e2, 0 === h2 ? t3 : t3.slice(h2), s3 ? 0 === h2 ? s3 : s3.slice(h2) : null, n5 - h2, r)), 0 !== o;
}
function xg(e2, t3, s3) {
  const n5 = [t3.getStartXY(), t3.getEndXY()], r = [0, 0];
  let i2 = null;
  t3.hasAttribute(1) && (i2 = r, i2[0] = t3.getAttributeAsDbl(0, 1, 0), i2[1] = t3.getAttributeAsDbl(1, 1, 0));
  const o = fg(e2, n5, i2, 2, s3);
  return t3.setStartXY(n5[0]), t3.setEndXY(n5[1]), i2 && (t3.setStartAttribute(1, 0, i2[0]), t3.setEndAttribute(1, 0, i2[1])), t3.normalizeAfterEndpointChange(), o;
}
function yg(e2, t3, s3) {
  if (0 === t3.projectionBehavior()) return Pg(e2, t3, s3);
  const n5 = t3.getStartXY().equals(t3.getEndXY()), r = Ot(mi, 3), i2 = Ot(mi, 3), o = [0, 0, 0];
  let a2 = null;
  r[0].assign(t3.getStartXY()), r[1].assign(n5 ? t3.getCenter() : t3.getEndXY());
  let h2 = false;
  t3.hasAttribute(1) && (a2 = o, a2[0] = t3.getAttributeAsDbl(0, 1, 0), a2[1] = t3.getAttributeAsDbl(1, 1, 0), a2[2] = Q(a2[0], a2[1], 0.5), n5 && (a2[1] = a2[2])), i2[0].setCoordsPoint2D(r[0]), i2[1].setCoordsPoint2D(r[1]);
  const m3 = new x3();
  if (n5 || t3.isDegenerateToLine()) h2 = fg(e2, i2, a2, 2, s3), m3.initializeFromTwoPoints(r[0], r[1], i2[0], i2[1]);
  else {
    const n6 = new mi();
    t3.queryCoord2D(0.5, n6), r[2].setCoordsPoint2D(n6), i2[2].setCoordsPoint2D(n6), h2 = fg(e2, i2, a2, 3, s3), m3.setFromTwoTriangles(r, i2);
  }
  return m3.isIdentity() || (t3.applyTransformation(m3), t3.setStartXY(i2[0]), t3.setEndXY(n5 ? i2[0] : i2[1]), t3.normalizeAfterEndpointChange()), a2 && (t3.setStartAttribute(1, 0, a2[0]), t3.setEndAttribute(1, 0, n5 ? a2[0] : a2[1])), h2;
}
function Pg(e2, t3, s3) {
  const n5 = [t3.getStartXY(), t3.getEndXY(), t3.getInteriorPoint(), t3.getCenter()];
  let r = 4;
  t3.isDegenerateToLine() && (r = 2);
  const i2 = [0, 0, 0, 0];
  let o = null;
  if (t3.hasAttribute(1)) {
    o = i2, o[0] = t3.getAttributeAsDbl(0, 1, 0), o[1] = t3.getAttributeAsDbl(1, 1, 0);
    const e3 = Q(o[0], o[1], 0.5);
    o[2] = e3, o[3] = e3;
  }
  const a2 = t3.getStartXY().equals(t3.getEndXY()) && !t3.isDegenerateToLine(), h2 = fg(e2, n5, o, r, s3);
  return a2 ? t3.constructCircleCenterAndPoint(n5[3], n5[0], !t3.isClockwise()) : t3.isDegenerateToLine() ? t3.constructLineCircularArc(n5[0], n5[1]) : t3.constructCircularArcThreePoint(n5[0], n5[1], n5[2]), o && (t3.setStartAttribute(1, 0, o[0]), t3.setEndAttribute(1, 0, o[1])), h2;
}
function Eg(e2, t3, s3) {
  const n5 = Ot(mi, 4);
  t3.queryControlPoints(n5);
  const r = [0, 0, 0, 0];
  let i2 = null;
  t3.hasAttribute(1) && (i2 = r, i2[0] = t3.getAttributeAsDbl(0, 1, 0), i2[3] = t3.getAttributeAsDbl(1, 1, 0), i2[1] = Q(i2[0], i2[3], 0.5), i2[2] = i2[1]);
  const o = fg(e2, n5, i2 || null, n5.length, s3);
  return t3.setControlPoints(n5), i2 && (t3.setStartAttribute(1, 0, i2[0]), t3.setEndAttribute(1, 0, i2[3])), t3.normalizeAfterEndpointChange(), o;
}
function Sg(e2, t3, s3) {
  return n(0), false;
}
function Cg(e2, t3, s3) {
  return n(0), false;
}
function Ig(e2, t3, s3) {
  const n5 = [t3.getStartXY(), t3.getEndXY()];
  Wl(e2, n5, 2, s3), t3.setStartXY(n5[0]), t3.setEndXY(n5[1]), t3.normalizeAfterEndpointChange();
}
function bg(e2, t3, s3, n5) {
  Wl(e2, t3, s3, n5);
}
function wg(e2, t3, s3) {
  if (0 === t3.projectionBehavior()) Tg(e2, t3, s3);
  else {
    const n5 = t3.isClosed() && t3.isMajor(), r = [t3.getStartXY(), n5 ? t3.getCenter() : t3.getEndXY()], i2 = [r[0].clone(), r[1].clone()];
    bg(e2, i2, 2, s3);
    const o = new x3();
    o.initializeFromTwoPointsArray(r, i2), t3.applyTransformation(o);
    const a2 = n5 ? 0 : 1;
    t3.setCoordsForIntersector(i2[0], i2[a2], false);
  }
}
function vg(e2, t3, s3, n5) {
  mg(e2, t3, s3, n5);
  const r = new n3();
  r.setFromPoints(s3, n5);
  const i2 = e2.getOneDegreeGCSUnit(), o = 360 * i2, a2 = 180 * i2;
  if (r.width() > a2) {
    for (let e3 = 0; e3 < n5; e3++) for (; s3[e3].x < t3; ) s3[e3].x += o;
    if (r.setFromPoints(s3, n5), r.xmax > a2 + t3) for (let e3 = 0; e3 < n5; e3++) s3[e3].x -= o;
  }
}
function Ng(e2, t3, s3, n5, r) {
  const i2 = Ot(mi, 3);
  let o = 0, a2 = false, h2 = false;
  const m3 = n5.isDegenerateToLine();
  m3 ? (i2[0].assign(n5.getStartXY()), i2[1].assign(n5.getEndXY()), i2[2].setCoords(0, 0), o = 2) : n5.isClosed() && n5.isMajor() ? (a2 = true, h2 = !n5.isClockwise(), i2[0].assign(n5.getStartXY()), i2[1].assign(n5.getCenter()), i2[2].setCoords(0, 0), o = 2) : (i2[0].assign(n5.getStartXY()), i2[1].assign(n5.getEndXY()), i2[2].assign(n5.getInteriorPoint()), o = 3), e2 ? bg(t3, i2, o, r) : vg(t3, s3, i2, o), m3 ? n5.constructLineCircularArc(i2[0], i2[1]) : a2 ? n5.constructCircleCenterAndPoint(i2[1], i2[0], h2) : n5.constructCircularArcThreePoint(i2[0], i2[1], i2[2]);
}
function Tg(e2, t3, s3) {
  Ng(true, e2, 0, t3, s3);
}
function Gg(e2, t3, s3) {
  const n5 = Ot(mi, 4);
  t3.queryControlPoints(n5), bg(e2, n5, 4, s3), t3.setControlPoints(n5);
}
function Dg(e2, t3, s3) {
  n(0);
}
function Vg(e2, t3, s3) {
  n(0);
}
function Fg(e2, t3, s3) {
  const n5 = Th(e2), r = Th(t3), i2 = Yh(n5, r), o = Yh(n5, Th(s3));
  return 0 === o || (i2 > 0 && o > 0 && o <= i2 || i2 < 0 && o < 0 && o >= i2);
}
function Hg(e2, t3, s3, n5, r) {
  const i2 = { stack: [], error: void 0, hasError: false };
  try {
    const a2 = s3.clone(), h2 = n5.clone();
    if (2 === r) {
      const s4 = [0, 0];
      return Ds3(e2, t3, a2, h2, 0, s4), s4[0];
    }
    if (a2.y > h2.y) {
      const e3 = new mi();
      e3.assign(a2), a2.assign(h2), h2.assign(e3);
    }
    const m3 = __addDisposableResource(i2, new Cc(), false), l2 = __addDisposableResource(i2, new Cc(), false), g2 = __addDisposableResource(i2, new Cc(), false), u = new x2();
    if (u.setCoords(a2.y, h2.y), !u.containsCoordinate(0) || Math.abs(a2.x - h2.x) >= Math.PI) return Number.NaN;
    if (a2.x === h2.x) return a2.x;
    Dc.geodeticDistance(e2, t3, a2.x, a2.y, h2.x, h2.y, l2, m3, null, r);
    const c = l2.val;
    let _ = 0, d2 = 1;
    const p3 = a2.clone();
    for (; c * (d2 - _) > 1e-12 * e2; ) {
      const s4 = 0.5 * (_ + d2);
      if (Dc.geodeticCoordinate(e2, t3, a2.x, a2.y, c * s4, m3.val, l2, g2, r), p3.x = l2.val, p3.y = g2.val, u.setCoords(a2.y, p3.y), 0 === p3.y) return p3.x;
      if (u.containsCoordinate(0)) d2 = s4;
      else {
        if (u.setCoords(h2.y, p3.y), !u.containsCoordinate(0)) return n(false), Number.NaN;
        _ = s4;
      }
    }
    return p3.x;
  } catch (a2) {
    i2.error = a2, i2.hasError = true;
  } finally {
    __disposeResources(i2);
  }
}
function kg(e2, t3, s3, n5) {
  const r = new x2();
  r.setCoords(t3, s3);
  const i2 = n5.width();
  let o = Math.floor((e2 - t3) / i2) * i2 + e2;
  const a2 = r.getCenter();
  for (; Math.abs(o - a2) > Math.abs(o + i2 - a2); ) o += i2;
  return o;
}
var Ag = class extends t {
  constructor() {
    super(), this.m_geometryDeque = [], this.m_index = -1;
  }
  next() {
    if (this.m_geometryDeque.length > 0) {
      this.m_index++;
      const e2 = this.m_geometryDeque[0];
      return this.m_geometryDeque.shift(), e2;
    }
    return null;
  }
  getGeometryID() {
    return this.m_index;
  }
  tick(e2) {
    this.m_geometryDeque.push(e2);
  }
  tock() {
    return true;
  }
  getRank() {
    return 1;
  }
};
function Mg(e2, t3) {
  return e2 === t3 || null !== e2 && null !== t3 && (e2.m_csType === t3.m_csType && (0 === e2.m_WKID && 0 === t3.m_WKID ? e2.m_hashCode === t3.m_hashCode && e2.m_canonicalWkt === t3.m_canonicalWkt : e2.m_WKID === t3.m_WKID));
}
function Ug(e2, t3) {
  return e2 === t3 || null !== e2 && null !== t3 && (e2.m_csType === t3.m_csType && (0 === e2.m_WKID && 0 === t3.m_WKID ? 1 === e2.m_csType ? e2.m_peCoordSys.isEqual(t3.m_peCoordSys) : e2.m_peCoordSys === t3.m_peCoordSys : e2.m_WKID === t3.m_WKID));
}
var qg = class {
  constructor(t3, s3 = true) {
    this.m_PCSHorizon = null, this.m_GCSHorizon = null, this.m_GCSSplitLines = null, this.m_bGCSHorisonIsInclusive = false, this.m_oneMeterPCS = 0, this.m_oneDegreeGCS = 0, this.m_gcsUnitFactor = 0, this.m_northPole = mi.getNAN(), this.m_southPole = mi.getNAN(), this.m_polesUpdated = 0, this.m_domain = n3.constructEmpty(), this.m_primeMeridian = Number.NaN, this.m_geogToProjFactor = 1, this.m_geogToProjOffset = 0, this.m_geogToProjFactorsUpdated = 0, this.m_oneMillimeter = 0, this.m_centralMeridian = 0, this.m_pPCSInfoNoDomain = null, this.m_oldWKID = -1973, this.m_vcsWKID = -1, this.m_bIsPannable = false, this.m_bCached = false, this.m_pannableExtent = n3.constructEmpty(), this.m_pannableExtentGCS = n3.constructEmpty(), this.m_areaOfUse = null, this.m_canonicalWkt = "", this.m_peCoordSys = t3, this.m_WKID = Ic.getCode(t3), this.m_WKID <= 0 ? (this.m_WKID = 0, this.m_canonicalWkt = _l(t3, 0, true), this.m_hashCode = Ds(this.m_canonicalWkt)) : this.m_hashCode = Ss(this.m_WKID);
    const n5 = this.m_peCoordSys.getType();
    this.m_csType = n5 === bc.PE_TYPE_PROJCS ? 2 : 1, n(n5 === bc.PE_TYPE_PROJCS || n5 === bc.PE_TYPE_GEOGCS), n5 === bc.PE_TYPE_PROJCS && (t3.loadConstants() || P("PeProjcs.loadConstants failed"));
    const i2 = n5 === bc.PE_TYPE_GEOGCS ? this.m_peCoordSys : this.m_peCoordSys.getGeogcs();
    n5 !== bc.PE_TYPE_GEOGCS && Ic.getCode(i2), this.m_unit = ms2(t3), this.m_primeMeridian = i2.getPrimem().getLongitude();
    {
      const e2 = i2.getUnit().getUnitFactor();
      this.m_gcsUnitFactor = e2;
      let t4 = Math.PI / (180 * e2);
      Math.abs(t4 - 1) < 1e-10 && (t4 = 1), this.m_oneDegreeGCS = t4;
    }
    if (n5 === bc.PE_TYPE_PROJCS) {
      const e2 = this.m_peCoordSys, t4 = e2.getUnit().getUnitFactor();
      this.m_oneMeterPCS = 1 / t4, this.m_oneMillimeter = 1e-3 / t4, this.m_pPCSInfoNoDomain = Nc.generate(e2, Nc.PE_PCSINFO_OPTION_NONE), this.m_pPCSInfoNoDomain || b("cannot create pcs info"), this.m_bIsPannable = this.m_pPCSInfoNoDomain.isPannableRectangle(), this.m_centralMeridian = this.m_pPCSInfoNoDomain.getCentralMeridian();
    } else {
      this.m_bIsPannable = true, this.m_polesUpdated = 1, this.m_oneMeterPCS = 0;
      const e2 = 1 / i2.getUnit().getUnitFactor(), t4 = i2.getDatum().getSpheroid().getAxis();
      this.m_oneMillimeter = 1e-3 / t4 * e2, this.m_centralMeridian = 0;
    }
    this.m_bIsPannable && (this.updateGCSHorizon(), this.updatePCSHorizon(), this.updatePoles(), this.updateDomain(), this.updatePannableExtent(), this.updatePannableExtentGCS());
  }
  [Symbol.dispose]() {
  }
  getHashCode() {
    return this.m_hashCode;
  }
  getPCSHorizonPannable() {
    return this.m_PCSHorizon;
  }
  getGCSHorizonPannable() {
    return this.m_GCSHorizon;
  }
  getPCSInfo() {
    return n(this.m_pPCSInfoNoDomain), this.m_pPCSInfoNoDomain;
  }
  getCentralMeridian() {
    return this.m_centralMeridian;
  }
  updateGCSHorizon() {
    if (this.m_peCoordSys.getType() !== bc.PE_TYPE_PROJCS) return;
    let e2 = true;
    const t3 = this.m_peCoordSys, s3 = t3.getGeogcs(), n5 = t3.horizonGcsGenerate();
    if (!n5) return;
    n(n5.length > 0);
    const r = n5[0].getNump(), i2 = n5[0].getKind();
    let a2, h2;
    e2 = n5[0].getInclusive() > 0;
    const m3 = this.getOneDegreeGCSUnit(), l2 = 90 * m3, g2 = 360 * m3, u = 370 * m3, c = 180 * m3 * bc.PE_HORIZON_DELTA / Math.PI, _ = n3.constructEmpty();
    let d2 = null;
    if (r > 1) {
      for (let o = 1; o < r; o++) if (n5[o].getKind() === bc.PE_HORIZON_LINE) {
        d2 || (d2 = new Os2());
        const e3 = n5[o].getCoord();
        d2.startPathCoords(e3[0][0], e3[0][1]), d2.lineToCoords(e3[1][0], e3[1][1]);
      }
    }
    if (i2 === bc.PE_HORIZON_RECT) {
      const t4 = n5[0].getCoord();
      if (_.setFromPoints([new mi(t4[0][0], t4[0][1]), new mi(t4[1][0], t4[1][1])], 2), Math.abs(_.ymax - l2) < 1e-7 * c && (_.ymax = l2), Math.abs(_.ymin + l2) < 1e-7 * c && (_.ymin = -l2), _.width() > u) {
        const e3 = -400 * m3, t5 = e3 + 5 * g2;
        _.setCoords({ xmin: e3, ymin: _.ymin, xmax: t5, ymax: _.ymax });
      }
      const s4 = new re({ env2D: _ });
      this.m_GCSHorizon || (this.m_GCSHorizon = s4, this.m_bGCSHorisonIsInclusive = e2);
    } else {
      let t4 = this.getPCSInfo().isGcsHorizonMultiOverlap();
      const i3 = Ru2(s3, null, null, 1), u2 = [], c2 = new x2();
      for (let e3 = 0; e3 < r; e3++) {
        if (n5[e3].getKind() !== bc.PE_HORIZON_POLY) continue;
        a2 = n5[e3].getSize();
        const t5 = n5[e3].getCoord(), s4 = n3.constructEmpty();
        s4.setFromPoints(oi(t5), a2), u2.push(new x2(s4.xmin, s4.xmax)), s4.width(), c2.merge(u2.at(-1));
      }
      let _2 = false;
      const p3 = new x2();
      c2.width() > g2 && u2.length > 1 ? (p3.vmin = this.getCentralMeridian() - g2, p3.vmax = p3.vmin + 2 * g2, _2 = true, t4 = true) : (p3.vmin = c2.vmin, p3.vmax = p3.vmin + g2);
      const f3 = (e3) => {
        let t5 = 0;
        for (; u2[e3].vmin + t5 < p3.vmin; ) t5 += g2;
        for (; u2[e3].vmax + t5 - g2 > p3.vmin; ) t5 -= g2;
        return t5;
      };
      let x4 = new ur();
      if (t4) {
        const e3 = new Ag(), t5 = new al().executeMany(e3, i3, null);
        for (let s4 = 0; s4 < r; s4++) {
          if (n5[s4].getKind() !== bc.PE_HORIZON_POLY) continue;
          a2 = n5[s4].getSize();
          const r2 = n5[s4].getCoord();
          h2 = n5[s4].getInclusive() > 0;
          const i4 = new ur();
          if (i4.addPathPoint2D(oi(r2), a2 - 1, true), _2) {
            const t6 = f3(s4), n6 = u2[s4].clone();
            n6.move(t6);
            let r3 = t6;
            const o = new x3();
            do {
              o.setShiftCoords(r3, 0);
              const t7 = i4.clone();
              t7.applyTransformation(o), e3.tick(t7), e3.tock(), r3 += g2, n6.move(g2);
            } while (n6.vmin < p3.vmax);
          } else e3.tick(i4), t5.tock();
        }
        x4 = t5.next();
      } else {
        x4 = new ur();
        for (let t5 = 0; t5 < r; t5++) {
          if (n5[t5].getKind() !== bc.PE_HORIZON_POLY) continue;
          a2 = n5[t5].getSize();
          const s4 = n5[t5].getCoord();
          if (h2 = n5[t5].getInclusive() > 0, n(h2 === e2), _2) {
            const e3 = new ur();
            e3.addPathPoint2D(oi(s4), a2 - 1, true);
            const n6 = f3(t5), r2 = u2[t5].clone();
            r2.move(n6);
            let i4 = n6;
            const o = new x3();
            do {
              if (0 !== i4) {
                o.setShiftCoords(i4, 0);
                const t6 = new ur({ copy: e3 });
                t6.applyTransformation(o), x4.addPath(t6, 0, true);
              } else x4.addPath(e3, 0, true);
              i4 += g2, r2.move(g2);
            } while (r2.vmin < p3.vmax);
          } else x4.addPathPoint2D(oi(s4), a2 - 1, true);
        }
      }
      _2 && (x4 = new I3().execute(x4, new n3(p3.vmin, -l2 - m3, p3.vmax, l2 + m3), i3, null)), e2 ? new wh2().accelerateGeometry(x4, i3, 1) : new Km().accelerateGeometry(x4, i3, 1), new ul().accelerateGeometry(x4, i3, 1), null === this.m_GCSHorizon && (this.m_GCSHorizon = x4, this.m_bGCSHorisonIsInclusive = e2, this.m_GCSSplitLines = d2);
    }
  }
  updateAreaOfUse() {
    return null;
  }
  updatePCSHorizon() {
    if (this.m_peCoordSys.getType() !== bc.PE_TYPE_PROJCS) return;
    const e2 = this.m_peCoordSys.horizonPcsGenerate();
    if (!e2) return;
    let t3;
    this.getPCSInfo();
    const s3 = e2[0].getKind();
    e2[0].getInclusive();
    const n5 = n3.constructEmpty(), r = e2[0].getNump();
    let i2 = false;
    if (s3 === bc.PE_HORIZON_RECT) {
      const s4 = e2[0].getCoord();
      n5.setFromPoints(oi(s4), 2), t3 = new re({ env2D: n5 });
    } else {
      let s4 = -1;
      for (let t4 = 0; t4 < r; t4++) e2[t4].getKind() === bc.PE_HORIZON_POLY && (s4 = t4);
      n(s4 >= 0);
      const n6 = e2[s4].getSize() - 1, a2 = e2[s4].getCoord(), h2 = new ur();
      t3 = h2, h2.addPathPoint2D(oi(a2), n6, true), i2 = true;
    }
    if (this.getPCSInfo().isDensificationNeeded()) {
      n(s3 !== bc.PE_HORIZON_RECT);
      const e3 = 1e5 * this.getOneMeterPCSUnit();
      t3 = new m2().execute(t3, e3, 0, 0, null);
    }
    if (i2) {
      {
        const e3 = new re();
        t3.queryEnvelope(e3), t3.calculateArea2D(), t3.calculateLength2D(), t3.getExteriorRingCount();
      }
      new wh2().accelerateGeometry(t3, null, 1);
    }
    null === this.m_PCSHorizon && (this.m_PCSHorizon = t3);
  }
  updatePannableExtent() {
    const e2 = this.m_peCoordSys.getType();
    if (e2 === bc.PE_TYPE_PROJCS) {
      const e3 = this.m_peCoordSys, t3 = this.getPCSInfo().getCentralMeridian(), s3 = e3.getGeogcs();
      s3 || b("");
      const n5 = [t3 + 1 / s3.getUnit().getUnitFactor() * Math.PI, 0];
      wc.geogToProj(e3, 1, n5);
      const i2 = n5[0], o = e3.getParameters()[bc.PE_PARM_X0].getValue(), a2 = this.getPCSHorizon(), h2 = n3.constructEmpty();
      a2.queryEnvelope(h2);
      const m3 = Math.abs(i2 - o), l2 = m3 + o, g2 = -1 * m3 + o, u = h2.ymax, c = h2.ymin;
      this.m_pannableExtent.setCoords({ xmin: g2, ymin: c, xmax: l2, ymax: u });
    } else if (e2 === bc.PE_TYPE_GEOGCS) {
      const e3 = 1 / this.m_peCoordSys.getUnit().getUnitFactor() * Math.PI;
      this.m_pannableExtent.setCoords({ xmin: -e3, ymin: -e3 / 2, xmax: e3, ymax: e3 / 2 });
    } else b("");
  }
  updatePannableExtentGCS() {
    const e2 = this.m_peCoordSys.getType();
    if (e2 === bc.PE_TYPE_PROJCS) {
      const e3 = this.m_peCoordSys, t3 = this.m_centralMeridian, s3 = e3.getGeogcs();
      s3 || b("");
      const n5 = 1 / s3.getUnit().getUnitFactor() * Math.PI, i2 = this.getGCSHorizon(), o = n3.constructEmpty();
      i2.queryEnvelope(o), this.m_pannableExtentGCS.setCoords({ xmin: t3 - n5, ymin: o.ymin, xmax: t3 + n5, ymax: o.ymax });
    } else if (e2 === bc.PE_TYPE_GEOGCS) {
      const e3 = 1 / this.m_peCoordSys.getUnit().getUnitFactor() * Math.PI;
      this.m_pannableExtentGCS.setCoords({ xmin: -e3, ymin: -e3 / 2, xmax: e3, ymax: e3 / 2 });
    } else b("");
  }
  updateDomain() {
    if (1 === this.m_csType) {
      const e2 = 400 * this.getOneDegreeGCSUnit();
      this.m_domain = n3.construct(-e2, -e2, e2, e2);
    } else {
      n(2 === this.m_csType);
      const e2 = Nc.generate(this.m_peCoordSys, Nc.PE_PCSINFO_OPTION_DOMAIN);
      e2 || b("generate pcs info failed");
      const t3 = new n3(e2.getDomainMinx(), e2.getDomainMiny(), e2.getDomainMaxx(), e2.getDomainMaxy());
      this.m_domain.isEmpty() && this.m_domain.setCoords({ env2D: t3 });
    }
  }
  updatePoles() {
    if (this.m_peCoordSys.getType() === bc.PE_TYPE_PROJCS) {
      const e2 = 90 * this.getOneDegreeGCSUnit(), t3 = [[0, e2], [0, -e2]];
      wc.geogToProj(this.m_peCoordSys, 2, t3);
      const s3 = this.getPCSInfo().getNorthPoleLocation() !== Nc.PE_POLE_OUTSIDE_BOUNDARY, n5 = this.getPCSInfo().getSouthPoleLocation() !== Nc.PE_POLE_OUTSIDE_BOUNDARY;
      this.m_polesUpdated || (s3 && this.m_northPole.setCoords(t3[0][0], t3[0][1]), n5 && this.m_southPole.setCoords(t3[1][0], t3[1][1]), this.m_polesUpdated = 1);
    } else this.m_polesUpdated = 1;
  }
  updateGeogToProjFactors() {
    if (this.m_peCoordSys.getType() === bc.PE_TYPE_PROJCS) {
      const e2 = this.getOneDegreeGCSUnit(), t3 = this.m_pPCSInfoNoDomain.getCentralMeridian(), s3 = [0, 0, 0, 0];
      s3[0] = t3, s3[1] = 0, s3[2] = t3 + e2, s3[3] = 0;
      const n5 = wc.geogToProj(this.m_peCoordSys, 2, s3);
      n(2 === n5);
      const r = (s3[2] - s3[0]) / e2, i2 = s3[0];
      0 === this.m_geogToProjFactorsUpdated && (this.m_geogToProjFactor = r, this.m_geogToProjOffset = i2, this.m_geogToProjFactorsUpdated = 1);
    } else this.m_geogToProjFactorsUpdated = 1;
  }
  getOneMeterPCSUnit() {
    return this.m_oneMeterPCS;
  }
  getOneDegreeGCSUnit() {
    return this.m_oneDegreeGCS;
  }
  getGcsUnitFactor() {
    return this.m_gcsUnitFactor;
  }
  getUnitsPerMillimeter() {
    return this.m_oneMillimeter;
  }
  getGCSSplitLines() {
    return this.m_bIsPannable ? null : (this.m_GCSHorizon || this.updateGCSHorizon(), this.m_GCSSplitLines);
  }
  getGCSHorizon() {
    return this.m_bIsPannable ? this.getGCSHorizonPannable() : (null !== this.m_GCSHorizon || this.updateGCSHorizon(), this.m_GCSHorizon);
  }
  getGCSHorisonIsInclusive() {
    return this.m_bIsPannable || this.getGCSHorizon(), this.m_bGCSHorisonIsInclusive;
  }
  getPCSHorizon() {
    return this.m_bIsPannable ? this.getPCSHorizonPannable() : (null !== this.m_PCSHorizon || this.updatePCSHorizon(), this.m_PCSHorizon);
  }
  getPole(e2) {
    return this.m_bIsPannable || 0 !== this.m_polesUpdated || this.updatePoles(), e2 ? this.m_southPole : this.m_northPole;
  }
  getGeogToProjFactors() {
    return 0 === this.m_geogToProjFactorsUpdated && this.updateGeogToProjFactors(), $t(this.m_geogToProjFactor, this.m_geogToProjOffset);
  }
  getDomainXY() {
    if (this.m_bIsPannable) return this.m_domain.clone();
    let e2 = false;
    return e2 = this.m_domain.isEmpty(), e2 && this.updateDomain(), this.m_domain.clone();
  }
  getPrimeMeridian() {
    return this.m_primeMeridian;
  }
  getLatestID() {
    return this.m_WKID;
  }
  getOldID() {
    let e2 = this.m_oldWKID;
    if (e2 < 0) {
      if (e2 = 0, this.m_WKID > 0) {
        const t3 = [0], s3 = [0];
        qc(this.m_peCoordSys.getType(), this.m_WKID, t3, s3) || b("query_code_change"), e2 = t3[0];
      }
      this.m_oldWKID = e2;
    }
    return e2;
  }
  isCustomWkid() {
    return false;
  }
  isPannable() {
    return this.m_bIsPannable;
  }
  getPannableExtent() {
    return this.m_pannableExtent.clone();
  }
  getPannableExtentGCS() {
    return this.m_pannableExtentGCS.clone();
  }
  getAreaOfUse() {
    return null !== this.m_areaOfUse ? this.m_areaOfUse : this.updateAreaOfUse();
  }
  getVcsCode() {
    return 0;
  }
  saveMemory() {
  }
  getCSType() {
    return this.m_csType;
  }
  getUnit() {
    return this.m_unit;
  }
  setCached() {
    this.m_bCached = true;
  }
  getCached() {
    return this.m_bCached;
  }
  static equal(e2, t3) {
    return false;
  }
  static equal_for_projection(e2, t3) {
    return false;
  }
};
var Bg = class {
  constructor(e2, t3 = true) {
    this.m_oneMeter = 0, this.m_WKID = -1, this.m_oldWKID = -1, this.m_canonicalWkt = "not yet implemented", this.m_model = 0, this.m_unit = new bu2(), this.m_cached = false;
  }
  setCached(e2 = true) {
    this.m_cached = e2;
  }
  getCached() {
    return this.m_cached;
  }
  getOneMeterUnit() {
    return 0;
  }
  getLatestID() {
    return this.m_WKID;
  }
  getOldID() {
    let e2 = this.m_oldWKID;
    return e2 < 0 && (e2 = 0, this.m_WKID > 0 && (e2 = this.m_WKID), this.m_oldWKID = e2), e2;
  }
  getModel() {
    return 0;
  }
  isCustomWkid() {
    return false;
  }
  getVerticalUnit() {
    return this.m_unit;
  }
  static equal(e2, t3) {
    return false;
  }
  static equal_for_projection(e2, t3) {
    return false;
  }
};
function Og(e2, t3, s3) {
  return Yg(e2, t3, n3.constructEmpty());
}
function Yg(e2, t3, s3, n5) {
  return Xg(true, e2, t3, s3);
}
function Rg(e2, t3, s3, n5) {
  return Lg(true, e2, t3, s3, n5);
}
function Xg(e2, t3, s3, n5, r) {
  Uu2() || G("cannot create projection transformation");
  return t3.hasVCS() && s3.hasVCS() ? jg() : Zg(t3, s3, n5);
}
function Lg(e2, t3, s3, n5, r, i2) {
  return Uu2() || G("cannot create projection transformation"), new eu2(e2 ? 2 : 1, t3, s3, n5, r, i2);
}
function zg(t3, s3, n5, r, i2, o = false) {
  s3 && n5 || P(""), Uu2() || G("cannot obtain geotransformation list");
  if (1 === t3 && s3.hasVCS() && n5.hasVCS()) return z("hv xform not impl"), [];
  {
    const e2 = Qc(s3, n5, r, i2, o), t4 = [];
    for (const s4 of e2) t4.push(s4);
    return t4;
  }
}
function Wg() {
  return { centralMeridianOfOutputGCS: Number.NaN, densificationStep: Number.NaN, clipWithInputHorizon: true, clipWithOutputHorizon: true, legacyHorizonClipping: false, normalizeResultGeometry: false, equals(e2) {
    return ls(this.centralMeridianOfOutputGCS, e2.centralMeridianOfOutputGCS) && ls(this.densificationStep, e2.densificationStep) && this.clipWithInputHorizon === e2.clipWithInputHorizon && this.clipWithOutputHorizon === e2.clipWithOutputHorizon && this.legacyHorizonClipping === e2.legacyHorizonClipping && this.normalizeResultGeometry === e2.normalizeResultGeometry;
  } };
}
function jg(e2, t3, s3, n5) {
  return n(0), {};
}
function Zg(t3, s3, n5, r) {
  t3 && s3 || P("!inputSR || !outputSR");
  const i2 = t3.getLatestID(), o = s3.getLatestID();
  if (3857 === i2 && 4326 === o) {
    if (t3.m_bDefaultDescriptor && s3.m_bDefaultDescriptor) return pu2();
  } else if (4326 === i2 && 3857 === o && t3.m_bDefaultDescriptor && s3.m_bDefaultDescriptor) return fu2();
  const a2 = n3.constructEmpty();
  a2.setCoords({ env2D: n5 });
  const h2 = t3.getCoordinateSystemType(), m3 = s3.getCoordinateSystemType();
  if (0 === h2 || 0 === m3) return Kg(t3, s3);
  const l2 = t3.getGCS().getLatestID(), g2 = s3.getGCS().getLatestID();
  if (l2 > 0 && l2 === g2) return Kg(t3, s3);
  const u = new mu2(t3, s3, n5);
  {
    const e2 = gu2(u);
    if (e2) return e2;
  }
  const c = zg(0, t3, s3, a2, 1, true);
  return uu2(u, Kg(t3, s3, c.length ? c[0] : void 0));
}
function Kg(e2, t3, s3, n5, r) {
  return new eu2(1, e2, t3, s3, n5, r);
}
function Qg() {
  return { flagsMask: 0, setFlag(e2, t3) {
    t3 ? this.flagsMask |= e2 : this.flagsMask &= ~e2;
  }, hasFlag(e2) {
    return 0 !== (this.flagsMask & e2);
  } };
}
function Jg() {
  return { m_extendedParams: Wg(), m_extendedParamsInternal: Qg() };
}
function $g() {
  return Jg();
}
var eu2 = class _eu {
  constructor(t3, s3, n5, r, i2, a2) {
    let h2, m3;
    this.m_datumTran = null, this.m_bIdentity = true, this.m_bIdentityGeogToGeog = true, this.m_bVertical = false, this.m_bNormalize = false, s3 && n5 || P("!inputSR || !outputSR"), r && 0 === r.getType() && (r.m_bReadOnly = true), this.m_bNormalize = false, 1 !== t3 && (h2 = s3.getVCS(), m3 = n5.getVCS(), this.m_bVertical = null != h2 && null != m3), this.m_inputSR = s3, this.m_outputSR = n5, this.m_bIdentity = false, this.m_bIdentityGeogToGeog = false, n(!this.m_params), i2 && (this.m_params = Jg(), this.m_params.m_extendedParams = i2), a2 && (this.m_params || (this.m_params = Jg()), this.m_params.m_extendedParamsInternal = a2);
    let l2 = false;
    const g2 = null != r, u = s3.getCoordinateSystemType(), c = n5.getCoordinateSystemType();
    if (n5.isPannable() && 0 !== u && i2) {
      const e2 = i2.centralMeridianOfOutputGCS;
      if (!Number.isNaN(e2) && n5.isPannable()) {
        const t4 = n5.getPannableExtent(), s4 = t4.getCenterX();
        if (s4 !== e2) {
          const n6 = Math.ceil(t4.width());
          e2 + n6 !== s4 + n6 && (l2 = true);
        }
      }
    }
    const _ = i2 && i2.normalizeResultGeometry;
    if (s3.equals(n5)) return this.m_bIdentity = !l2, this.m_bIdentityGeogToGeog = true, void this.updateProjector();
    const d2 = !g2 && s3.equalForProjection(n5, this.m_bVertical);
    this.m_bIdentity = d2 && !l2, this.m_bIdentity ? this.m_bIdentityGeogToGeog = true : 0 !== u && 0 !== c && (_ && this.m_outputSR.isPannable() && (this.m_bNormalize = _), this.m_datumTran = r || null, this.m_bIdentityGeogToGeog = (!this.m_datumTran || 0 === this.m_datumTran.count()) && this.m_inputSR.getGCS().equalForProjection(this.m_outputSR.getGCS(), this.m_bVertical)), this.updateProjector();
  }
  getInputSR() {
    return this.m_inputSR;
  }
  getOutputSR() {
    return this.m_outputSR;
  }
  getDatumTransformation() {
    return this.m_datumTran;
  }
  getInverse() {
    const e2 = new _eu(1, this.m_outputSR, this.m_inputSR, this.m_datumTran?.createInverse());
    return e2.m_bIdentity = this.m_bIdentity, e2.m_bVertical = this.m_bVertical, e2.m_bIdentityGeogToGeog = this.m_bIdentityGeogToGeog, e2.updateProjector(), e2;
  }
  isIdentity() {
    return this.m_bIdentity;
  }
  getExtendedParams() {
    return this.m_params ? this.m_params.m_extendedParams : $g().m_extendedParams;
  }
  equals(e2) {
    return n(0), false;
  }
  isVertical() {
    return this.m_bVertical;
  }
  isMatchingTransformation(e2, t3) {
    return n(0), false;
  }
  getGeographicTransformations() {
    return this.m_datumTran;
  }
  getExtendedParamsImpl() {
    return this.m_params ? this.m_params.m_extendedParams : $g().m_extendedParams;
  }
  getExtendedParamsInternal() {
    return this.m_params ? this.m_params.m_extendedParamsInternal : $g().m_extendedParamsInternal;
  }
  isIdentityGeogToGeog() {
    return this.m_bIdentityGeogToGeog;
  }
  normalizeOutput() {
    return this.m_bNormalize;
  }
  updateProjector() {
    this.m_projector = new Ah2(this);
  }
};
var tu = /* @__PURE__ */ new Map();
var su2 = /* @__PURE__ */ new Map();
var nu2 = /* @__PURE__ */ new Map();
function ru2(e2) {
  let t3 = e2.getCode();
  if (t3 > 0) {
    const e3 = Iu2(t3);
    return e3 || Cu2(Ic.coordsys(t3));
  }
  const s3 = e2.getName();
  if (su2.has(s3)) {
    const t4 = su2.get(s3);
    if (t4 && t4.deref()) {
      const s4 = t4.deref();
      if (s4.m_peCoordSys.isEqual(e2)) return s4;
    }
  }
  return t3 = Ic.getCode(e2), Cu2(t3 > 0 ? Ic.coordsys(t3) : e2);
}
function iu2(e2) {
  e2 <= 0 && R(e2);
  {
    const t4 = Iu2(e2);
    if (t4) return t4;
  }
  const t3 = Hc(Ic.coordsys(e2));
  t3.get() || R(e2);
  const s3 = Cu2(t3.release());
  return s3.getLatestID() !== e2 && tu.set(e2, new WeakRef(s3)), s3;
}
function ou2(e2) {
  const t3 = new Bg({}, true);
  return t3.m_WKID = e2, t3;
}
function au2(e2) {
  const t3 = Hc(Ic.fromString(bc.PE_TYPE_COORDSYS, e2));
  return t3.get() || U(e2), ru2(t3.release());
}
function hu2(e2) {
  su2.delete(e2.m_peCoordSys.getName()), nu2.delete(_l(e2.m_peCoordSys, 0, false));
}
var mu2 = class {
  constructor(e2, t3, s3) {
    this.m_hashCode = -1, e2 && (this.m_inputSR = e2, this.m_outputSR = t3, this.m_env = s3.clone(), this.m_hashCode = this.m_inputSR.getHashCode(), this.m_hashCode = As(this.m_hashCode, this.m_outputSR.getHashCode()), this.m_env.isEmpty() || (this.m_hashCode = As(this.m_hashCode, Bs(this.m_env.xmin)), this.m_hashCode = As(this.m_hashCode, Bs(this.m_env.xmax)), this.m_hashCode = As(this.m_hashCode, Bs(this.m_env.ymin)), this.m_hashCode = As(this.m_hashCode, Bs(this.m_env.ymax))));
  }
  getHashCode() {
    return this.m_hashCode;
  }
  equals(e2) {
    return !(this.m_inputSR && !e2.m_inputSR || !this.m_inputSR && e2.m_inputSR) && (this.m_env.equals(e2.m_env) && this.m_inputSR.equals(e2.m_inputSR) && this.m_outputSR.equals(e2.m_outputSR));
  }
  clear() {
    this.m_inputSR = void 0, this.m_outputSR = void 0, this.m_hashCode = -1, this.m_env = void 0;
  }
};
var lu2 = /* @__PURE__ */ new Map();
function gu2(e2) {
  if (lu2.has(e2.getHashCode())) return lu2.get(e2.getHashCode());
}
function uu2(e2, t3) {
  return lu2.set(e2.getHashCode(), t3), t3;
}
var cu2;
var _u2;
var du2;
function pu2() {
  return cu2 || (cu2 = Rg(hc(), lc())), cu2;
}
function fu2() {
  return _u2 || (_u2 = pu2().getInverse()), _u2;
}
function xu2() {
  return du2 || (du2 = Ic.unit(9001)), du2;
}
function yu2(e2) {
  return null !== Hc(Ic.coordsys(e2)).get();
}
var Pu2 = /* @__PURE__ */ new Map();
function Eu2(e2) {
  if (Pu2.has(e2)) return Pu2.get(e2);
  {
    const t3 = yu2(e2);
    return Pu2.set(e2, t3), t3;
  }
}
function Su2(e2) {
  return false;
}
function Cu2(e2) {
  const t3 = Hc(e2), s3 = e2.getCode();
  if (s3 > 0) {
    const e3 = Iu2(s3);
    if (e3) return e3;
  }
  const n5 = e2.getName();
  let r = su2.get(n5);
  if (r) {
    const t4 = r.deref();
    if (t4 && t4.m_peCoordSys.isEqual(e2)) return t4;
  }
  const i2 = new qg(t3.release());
  if (s3 > 0) return i2.setCached(), tu.set(s3, new WeakRef(i2)), su2.set(n5, new WeakRef(i2)), i2;
  const o = _l(e2, 0, false);
  if (r = nu2.get(o), r) {
    const e3 = r.deref();
    if (e3) return e3;
  }
  return i2.setCached(), nu2.set(o, new WeakRef(i2)), i2;
}
function Iu2(e2) {
  const t3 = tu.get(e2);
  if (t3) return t3.deref();
}
var bu2 = class extends ns2 {
  constructor(e2) {
    return void 0 === e2 ? (super(), this.m_wkid = 9001, void (this.m_peUnit = null)) : "number" == typeof e2 ? (super(), this.m_factor = e2, void (this.m_wkid = 0)) : (super(e2), void (e2 || (this.m_factor = 1, this.m_wkid = 9001, this.m_peUnit = xu2())));
  }
  getUnitType() {
    return 0;
  }
  convertFromMeters(e2) {
    return e2 / this.getUnitToBaseFactor();
  }
  convertToMeters(e2) {
    return e2 * this.getUnitToBaseFactor();
  }
};
var wu2 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "b", "c", "d", "e", "f", "g", "h", "j", "k", "m", "n", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"];
function vu2(e2, t3, s3) {
  const n5 = Yt(t3, "R");
  let r = 0, i2 = 0;
  for (let o = 0; o < t3; o++) {
    let s4 = e2[r] >> i2 & 31;
    if (i2 += 5, i2 > 31) {
      const t4 = 37 - i2;
      s4 &= (1 << t4) - 1, i2 -= 32, r++, s4 |= (e2[r] & (1 << i2) - 1) << t4;
    }
    const a2 = wu2[s4];
    n5[t3 - 1 - o] = a2;
  }
  return s3 > t3 ? n5.push(..."0".repeat(s3 - t3)) : s3 < t3 && (n5.length = s3), n5.join("");
}
function Nu2(e2, t3, s3, n5, r) {
  n(n5 >> 5 < r.length);
  let i2 = t3, a2 = s3;
  for (let o = n5; o >= 0; o -= 2) {
    const t4 = 31 & o, s4 = 0.5 * (a2 + i2);
    e2 >= s4 ? (r[o >> 5] |= 1 << t4, i2 = s4) : a2 = s4;
  }
}
var Tu2 = /* @__PURE__ */ new Set();
var Gu2 = 2147483645n;
var Du2 = 9007199254740990n;
var Vu2 = "operation is not supported for unknown coordinate systems";
var Fu2;
function Hu2() {
  return { majorSemiAxis: 0, e2: 0, minorSemiAxis: 0, flattening: 0, isSphere() {
    return 0 === this.e2;
  } };
}
function ku2(e2, t3, s3) {
  e2.majorSemiAxis = t3, e2.minorSemiAxis = t3 * (1 - s3), e2.e2 = s3 * (2 - s3), e2.flattening = s3;
}
function Au2(e2) {
  if (Ic) return;
  Uc(e2);
  const t3 = Tu2;
  Tu2 = null, t3.forEach((e3) => {
    const t4 = e3.deref();
    t4 && t4.attachToPe();
  });
}
function Mu2(e2) {
  Mc(e2);
}
function Uu2() {
  return !!Ic;
}
function qu2() {
  return !!kc;
}
function Bu2() {
  return !!Ic || !!kc;
}
function Ou2(e2, t3, s3) {
  return n(Bu2()), dc(e2, void 0 === t3 ? 0 : t3, null, false);
}
function Yu2(e2, t3) {
  n(Bu2());
  const s3 = new oc();
  let n5;
  return Uu2() ? (n5 = au2(e2), s3.setHorzProj_(n5), s3.m_vertcs = null, s3.m_userWKID = n5.getLatestID()) : (n5 = Ac(e2), s3.m_unit = n5.isPCS ? new bu2(n5.metersOrRadiansPerUnit) : new os(n5.metersOrRadiansPerUnit)), uc(s3.m_precisionDescriptor, n5, null, 1), s3.m_bDefaultDescriptor = true, s3.m_userWKT = e2, s3.calculateHashCode(), s3.initDbgName(), s3;
}
function Ru2(e2, t3, s3, n5, r = true) {
  let i2 = null;
  return t3 && (i2 = Fm(t3, r)), Xu2(e2, i2, s3, n5, r);
}
function Xu2(t3, s3, n5, r, i2) {
  t3 || P("!PE_coord_sys");
  const o = new oc();
  let a2;
  return a2 = i2 ? ru2(t3) : new qg(t3, false), uc(o.m_precisionDescriptor, a2, s3, r), o.m_bDefaultDescriptor = true, o.setHorzProj_(a2), o.m_vertcs = s3, o.m_userWKID = a2.getLatestID(), o.calculateHashCode(), o.initDbgName(), o;
}
function Lu2(t3, s3, n5 = false) {
  3 === t3.getCoordinateSystemType() && P("image spatial reference cannot be altered");
  const r = new oc(), i2 = t3;
  return r.m_peCoordSysVal = i2.m_peCoordSysVal, r.m_vertcs = i2.m_vertcs, r.m_unit = i2.m_unit, r.m_precisionDescriptor.assign(s3), r.m_localZToXYFactor = i2.m_localZToXYFactor, (Number.isNaN(r.m_precisionDescriptor.m_falseX) || Number.isNaN(r.m_precisionDescriptor.m_falseY)) && (r.m_precisionDescriptor.m_falseX = i2.m_precisionDescriptor.m_falseX, r.m_precisionDescriptor.m_falseY = i2.m_precisionDescriptor.m_falseY), r.m_precisionDescriptor.snapPrecision(), r.m_precisionDescriptor.fixTolerance(), r.m_userWKID = i2.m_userWKID, r.m_precisionDescriptor.equals(i2.m_precisionDescriptor) ? r.m_bDefaultDescriptor = i2.m_bDefaultDescriptor : r.m_bDefaultDescriptor = false, n5 && (r.m_bDefaultDescriptor = true), r.calculateHashCode(), r.initDbgName(), r;
}
function zu2(e2, t3, s3) {
  return {};
}
function Wu2(t3, s3, n5) {
  void 0 === s3 && (s3 = 1), (s3 <= 0 || !Number.isFinite(s3)) && P(""), t3 || 1 === s3 || P("null Unit has to have z_to_xy_factor equal to 1");
  const r = new oc();
  r.m_unit = t3;
  const i2 = t3 || new bu2(9001);
  return _c(r.m_precisionDescriptor, i2, null, 1), r.m_bDefaultDescriptor = true, Number.isNaN(r.m_precisionDescriptor.m_falseX) && P("NAN false X/Y are not allowed here"), r.m_localZToXYFactor = s3, r.calculateHashCode(), r.initDbgName(), r;
}
function ju2(e2, t3) {
  return e2.snapGeometry(t3);
}
function Zu2(e2) {
  const t3 = e2.getCoordinateSystemType();
  return 1 === t3 ? e2 : (3 === t3 && n(0), e2.getGCS());
}
function Ku2(e2) {
  return n(Bu2()), qu2() ? Bc(e2) : Eu2(e2);
}
function Qu2(e2) {
  if (Uu2()) {
    return null !== Hc(Ic.fromString(bc.PE_TYPE_COORDSYS, e2)).get();
  }
  try {
    return Ac(e2), true;
  } catch (t3) {
  }
  return false;
}
var Ju2;
function $u2() {
  return Ju2 || (Ju2 = (() => {
    const e2 = Math.trunc(Math.random() * ds()), t3 = Date.now();
    return `|abba_000|${e2.toString(16)}|${t3.toString(16)}|`;
  })()), Ju2;
}
!(function(e2) {
  e2[e2.utmDefault = 0] = "utmDefault", e2[e2.utmNorthSouth = 1] = "utmNorthSouth";
})(Fu2 || (Fu2 = {}));
var ec;
var tc;
var sc;
var nc = 0;
function rc(e2 = "") {
  let t3 = `${$u2()}${nc++}`;
  return "" !== e2 && (t3 += `|${e2}`), t3;
}
function ic(e2) {
  return e2.startsWith($u2());
}
var oc = class _oc {
  destroy() {
    hu2(this.m_peCoordSysVal), 1 === this.getCoordinateSystemType() || 2 === this.getCoordinateSystemType() ? this.getPECoordSys().destroy() : b("SpatialReference.destroy");
  }
  constructor() {
    this.m_vertcs = null, this.m_peCoordSysVal = null, this.m_userWKID = 0, this.m_userWKT = null, this.m_geogSpatialReference = null, this.m_srToGcs = null, this.m_gcsToSr = null, this.m_defaultPrecisionSR = null, this.m_localZToXYFactor = -1, this.m_precisionDescriptor = new ac(), this.m_hashCode = 0, this.m_bDefaultDescriptor = false, gc(this.m_precisionDescriptor), Tu2 && Tu2.add(new WeakRef(this));
  }
  attachToPe() {
    (this.m_userWKID > 0 ? Ou2(this.m_userWKID) : Yu2(this.m_userWKT)).copyTo(this, false);
  }
  copyTo(e2, t3 = true) {
    (t3 || e2.m_bDefaultDescriptor) && (e2.m_bDefaultDescriptor = this.m_bDefaultDescriptor, e2.m_precisionDescriptor.assign(this.m_precisionDescriptor)), e2.m_defaultPrecisionSR = null, e2.m_gcsToSr = this.m_gcsToSr, e2.m_geogSpatialReference = this.m_geogSpatialReference, e2.m_hashCode = this.m_hashCode, e2.m_localZToXYFactor = this.m_localZToXYFactor, e2.m_peCoordSysVal = this.m_peCoordSysVal, e2.m_srToGcs = this.m_srToGcs, e2.m_userWKID = this.m_userWKID, e2.m_userWKT = this.m_userWKT, e2.m_vertcs = this.m_vertcs, e2.m_unit = this.m_unit;
  }
  getHashCode() {
    return this.m_hashCode;
  }
  getHashCodeHorizontal() {
    let e2 = 0;
    return e2 = this.m_peCoordSysVal ? this.m_peCoordSysVal.getHashCode() : this.m_unit ? this.m_unit.getHashCode() : 305419891, e2;
  }
  updateTransform(e2) {
    if (1 === this.getCoordinateSystemType()) return Rg(this, this, null);
    let t3 = e2 ? this.m_srToGcs : this.m_gcsToSr;
    if (t3) return t3;
    const s3 = this.getGCS(), n5 = this;
    t3 = e2 ? Rg(n5, s3, null) : Rg(s3, n5, null);
    const r = t3, i2 = e2 ? this.m_srToGcs : this.m_gcsToSr;
    return i2 || (e2 ? this.m_srToGcs = r : this.m_gcsToSr = r, t3);
  }
  getHashCodeVertical() {
    return this.m_vertcs ? this.m_vertcs.getHashCode() : 0;
  }
  calculateHashCode() {
    let e2 = this.getHashCodeHorizontal();
    const t3 = this.getHashCodeVertical(), s3 = this.m_precisionDescriptor.getHashCode();
    e2 = As(e2, t3), this.m_hashCode = As(e2, s3);
  }
  initDbgName() {
  }
  setHorzProj_(e2) {
    this.m_peCoordSysVal = e2, this.m_unit = this.m_peCoordSysVal.getUnit();
  }
  getTolerance(e2 = 0) {
    return this.m_precisionDescriptor.getTolerance(e2);
  }
  getResolution(e2 = 0) {
    return this.m_precisionDescriptor.getResolution(e2);
  }
  getPECoordSys() {
    return this.m_peCoordSysVal ? this.m_peCoordSysVal.m_peCoordSys : null;
  }
  getPCSInfo() {
    return this.throwIfNotGCSOrPCS(), n(this.m_peCoordSysVal), this.m_peCoordSysVal.getPCSInfo();
  }
  getCentralMeridian() {
    if (this.throwIfNotGCSOrPCS(), 1 === this.getCoordinateSystemType()) return 0;
    return this.getPCSInfo().getCentralMeridian();
  }
  getCoordinateSystemType() {
    const e2 = this.getPECoordSys();
    if (e2) {
      switch (e2.getType()) {
        case bc.PE_TYPE_GEOGCS:
          return 1;
        case bc.PE_TYPE_PROJCS:
          return 2;
        default:
          return 0;
      }
    } else {
      if ((this.m_userWKID > 0 || this.m_userWKT) && this.m_unit instanceof bu2) return 2;
      if (this.m_unit instanceof os) return 1;
    }
    return 0;
  }
  getID() {
    return this.m_userWKID;
  }
  getLatestID() {
    return this.m_peCoordSysVal ? this.m_peCoordSysVal.getLatestID() : this.m_userWKID;
  }
  getOldID() {
    return this.m_peCoordSysVal ? this.m_peCoordSysVal.getOldID() : this.m_userWKID;
  }
  getVerticalID() {
    return z("vcs not implemented"), 0;
  }
  getLatestVerticalID() {
    return this.m_vertcs ? this.m_vertcs.getLatestID() : 0;
  }
  getOldVerticalID() {
    return z("vcs not implemented"), 0;
  }
  getPEVerticalCoordSys() {
    return null;
  }
  getPole(e2) {
    return this.throwIfNotGCSOrPCS(), n(this.m_peCoordSysVal), this.m_peCoordSysVal.getPole(e2);
  }
  getText() {
    const e2 = this.getPECoordSys();
    return e2 ? pl(e2) : this.m_userWKT ?? "";
  }
  getTextExtended(e2) {
    const t3 = this.getPECoordSys();
    return t3 ? this.getPEVerticalCoordSys() ? dl(null, t3, this.getPEVerticalCoordSys()) : pl(t3, e2) : this.m_userWKT ?? "";
  }
  getText2(e2 = -1) {
    const t3 = this.getPECoordSys();
    return t3 ? fl(t3, e2) : this.m_userWKT ?? "";
  }
  getUnit() {
    return this.m_unit;
  }
  getUnitsPerMillimeter() {
    return this.m_peCoordSysVal ? this.m_peCoordSysVal.getUnitsPerMillimeter() : this.m_unit instanceof bu2 ? 1e-3 / this.m_unit.getUnitToBaseFactor() : this.m_unit instanceof os ? 1e-3 / (Ac(this.m_userWKT ?? this.m_userWKID).semiMajor * this.m_unit.getUnitToBaseFactor()) : (C("sr object not in valid state"), 0);
  }
  getAuthorityName() {
    return this.getPECoordSys() ? xl() : "";
  }
  getVerticalUnit() {
    return z("vcs not implemented"), {};
  }
  getVCS() {
    return this.m_vertcs;
  }
  hasVCS() {
    return false;
  }
  getGCSHorisonIsInclusive() {
    return this.throwIfNotGCSOrPCS(), n(this.m_peCoordSysVal), this.m_peCoordSysVal.getGCSHorisonIsInclusive();
  }
  getGCSHorizon() {
    return this.throwIfNotGCSOrPCS(), n(this.m_peCoordSysVal), this.m_peCoordSysVal.getGCSHorizon();
  }
  getGCS() {
    const e2 = this.getCoordinateSystemType();
    if (0 === e2) C(Vu2);
    else {
      if (1 === e2) return this;
      3 === e2 && C("image cs not supported");
    }
    if (this.m_geogSpatialReference) return this.m_geogSpatialReference;
    let t3;
    if (this === hc() || this === mc()) t3 = lc();
    else {
      n(this.m_peCoordSysVal);
      const e3 = this.m_peCoordSysVal.m_peCoordSys.getGeogcs();
      e3 || b(""), t3 = Ru2(e3, this.m_vertcs, null, this.m_precisionDescriptor.getPrecision(), this.m_peCoordSysVal.getCached());
    }
    return this.m_geogSpatialReference ? t3 = this.m_geogSpatialReference : this.m_geogSpatialReference = t3, t3;
  }
  getGCSSplitLines() {
    return this.throwIfNotGCSOrPCS(), n(this.m_peCoordSysVal), this.m_peCoordSysVal.getGCSSplitLines();
  }
  toGCS(t3, s3) {
    if (0 === t3.length) return 0;
    t3.length > s3.length && P("coordsSrc.size() > coordsDst.size()");
    const n5 = this.getCoordinateSystemType();
    if (0 === n5 && C(Vu2), 1 === n5) return Gt(s3, t3, t3.length), t3.length;
    n(this.m_peCoordSysVal);
    const r = this.getSRToGCSTransform();
    return new qh().transform(r, t3, t3.length, s3);
  }
  toGeohash(e2, t3 = 8) {
    const s3 = e2.clone();
    s3.scale(9102 === this.getGCS().getUnit().getID() ? 1 : this.getGCS().getUnit().getUnitToBaseFactor() / Math.PI * 180), s3.x < -180 ? (s3.x = ct(s3.x, 360), s3.x < -180 && (s3.x += 360)) : s3.x > 180 && (s3.x = ct(s3.x, 360), s3.x > 180 && (s3.x -= 360)), s3.y > 90 && (s3.y = 90), s3.y < -90 && (s3.y = -90);
    const n5 = 5 * t3, r = new Uint32Array(4);
    Nu2(s3.x, -180, 180, n5 - 1, r), Nu2(s3.y, -90, 90, n5 - 2, r);
    return vu2(r, t3, t3);
  }
  isPannable() {
    const e2 = this.getCoordinateSystemType();
    return 0 !== e2 && 3 !== e2 && (n(this.m_peCoordSysVal), this.m_peCoordSysVal.isPannable());
  }
  getPannableExtent() {
    return this.isPannable() || P("!is_pannable"), n(this.m_peCoordSysVal), this.m_peCoordSysVal.getPannableExtent();
  }
  getPannableExtentInGCS() {
    return this.isPannable() || P("!is_pannable"), n(this.m_peCoordSysVal), this.m_peCoordSysVal.getPannableExtentGCS();
  }
  throwIfNotGCSOrPCS() {
    const t3 = this.getCoordinateSystemType();
    1 !== t3 && 2 !== t3 && P("Not a GCS or PCS");
  }
  getDomainXY() {
    return this.throwIfNotGCSOrPCS(), n(this.m_peCoordSysVal), this.m_peCoordSysVal.getDomainXY();
  }
  getFullWorldExtent() {
    return this.throwIfNotGCSOrPCS(), this.isPannable() ? this.getPannableExtent() : this.getDomainXY();
  }
  queryPrecisionDescriptor(e2) {
    if (e2.assign(this.m_precisionDescriptor), Number.isNaN(e2.m_falseX)) if (Uu2() || G("cannot query precision descriptor"), n(null !== this.m_peCoordSysVal), 2 !== this.m_precisionDescriptor.m_precision) {
      const t3 = this.m_peCoordSysVal.getDomainXY();
      e2.m_falseX = t3.xmin, e2.m_falseY = t3.ymin;
    } else e2.m_falseX = -Number.MAX_VALUE, e2.m_falseY = -Number.MAX_VALUE;
  }
  queryPrecisionDescriptorWithoutFalseXY(e2) {
    e2.assign(this.m_precisionDescriptor), e2.m_falseX = Number.NaN, e2.m_falseY = Number.NaN;
  }
  queryDefaultPrecisionDescriptorWithoutFalseXY(e2) {
    if (this.m_bDefaultDescriptor) e2.assign(this.m_precisionDescriptor);
    else {
      const t3 = this.getCoordinateSystemType();
      0 === t3 ? _c(e2, this.m_unit, this.m_vertcs, this.m_precisionDescriptor.getPrecision()) : 3 === t3 ? z("image cs") : uc(e2, this.m_peCoordSysVal, this.m_vertcs, this.m_precisionDescriptor.getPrecision());
    }
    e2.m_falseX = Number.NaN, e2.m_falseY = Number.NaN;
  }
  horizontalEqual(e2) {
    return Mg(this.m_peCoordSysVal, e2.m_peCoordSysVal);
  }
  verticalEqual(e2) {
    return null !== this.m_vertcs == (null !== e2.m_vertcs) && (!this.m_vertcs || this.m_vertcs.equals(e2.m_vertcs));
  }
  equals(e2) {
    const t3 = e2;
    if (this === t3) return true;
    if (!this.horizontalEqual(t3) || !this.verticalEqual(t3)) return false;
    if (!t3.m_peCoordSysVal) {
      if (n(!this.m_peCoordSysVal), null !== this.m_unit != (null !== t3.m_unit)) return false;
      if (this.m_unit && !this.m_unit.equals(t3.m_unit)) return false;
      if (this.m_localZToXYFactor !== t3.m_localZToXYFactor) return false;
    }
    if (!this.m_bDefaultDescriptor || !t3.m_bDefaultDescriptor) {
      if (this.m_peCoordSysVal) {
        if (!this.m_precisionDescriptor.equalsWithoutFalseXY(t3.m_precisionDescriptor)) return false;
        n(t3.m_peCoordSysVal);
        let e3 = this.m_precisionDescriptor.m_falseX, s3 = this.m_precisionDescriptor.m_falseY;
        if (Number.isNaN(e3)) {
          const t4 = this.m_peCoordSysVal.getDomainXY();
          e3 = t4.xmin, s3 = t4.ymin;
        }
        let n5 = t3.m_precisionDescriptor.m_falseX, r = t3.m_precisionDescriptor.m_falseY;
        if (Number.isNaN(n5)) {
          const e4 = t3.m_peCoordSysVal.getDomainXY();
          n5 = e4.xmin, r = e4.ymin;
        }
        return e3 === n5 && s3 === r;
      }
      return this.m_precisionDescriptor.equals(t3.m_precisionDescriptor);
    }
    return true;
  }
  equalForProjection(e2, t3) {
    if (this === e2) return true;
    const s3 = this.getCoordinateSystemType(), n5 = e2.getCoordinateSystemType();
    if (0 === s3 || 0 === n5) return 0 === s3 && 0 === n5 ? (!t3 || this.getZToXYFactor() === e2.getZToXYFactor()) && (!this.getUnit() || !e2.getUnit() || this.getUnit().equals(e2.getUnit())) : 3 !== s3 && 3 !== n5 && (null === this.getUnit() || null === e2.getUnit() || (!t3 || this.getZToXYFactor() === e2.getZToXYFactor()) && this.getUnit().equals(e2.getUnit()));
    if (s3 !== n5) return false;
    if (3 === s3) return this.equals(e2);
    if (Ug(this.m_peCoordSysVal, e2.m_peCoordSysVal)) {
      if (!t3) return true;
      if (null !== this.m_vertcs == (null !== e2.m_vertcs)) return !this.m_vertcs || this.m_vertcs.equalForProjection(e2.m_vertcs);
    }
    return false;
  }
  equalHorizontal(e2) {
    return this.horizontalEqual(e2);
  }
  equalVertical(e2) {
    return n(0), false;
  }
  equalVerticalVCS(e2) {
    return n(0), false;
  }
  convergenceAngle(e2) {
    return n(0), 0;
  }
  getPeCoordsysCopy() {
    if (this.m_peCoordSysVal) {
      const e2 = this.m_peCoordSysVal.m_peCoordSys;
      return e2 || b("cannot clone coord sys"), e2;
    }
    return null;
  }
  getPeVertcsCopy() {
    return n(0), 0;
  }
  throwIfLocal() {
    0 === this.getCoordinateSystemType() && P(Vu2);
  }
  getPrimeMeridian() {
    return this.throwIfLocal(), n(this.m_peCoordSysVal), this.m_peCoordSysVal.getPrimeMeridian();
  }
  getSRToGCSTransform() {
    return this.updateTransform(true);
  }
  getGCSToSRTransform() {
    return this.updateTransform(false);
  }
  getOneMeter() {
    return 1e3 * this.getUnitsPerMillimeter();
  }
  getOneMeterPCSUnit() {
    return this.throwIfNotGCSOrPCS(), n(this.m_peCoordSysVal), this.m_peCoordSysVal.getOneMeterPCSUnit();
  }
  getDefaultPrecisionSR() {
    if (this.m_bDefaultDescriptor) return this;
    if (null === this.m_defaultPrecisionSR) {
      const e2 = new ac();
      this.queryDefaultPrecisionDescriptorWithoutFalseXY(e2), this.m_defaultPrecisionSR = Lu2(this, e2, true);
    }
    return this.m_defaultPrecisionSR;
  }
  getPCSHorizon() {
    return this.throwIfNotGCSOrPCS(), n(this.m_peCoordSysVal), this.m_peCoordSysVal.getPCSHorizon();
  }
  getHorzUnitFactor() {
    return this.m_unit ? this.m_unit.getUnitToBaseFactor() : 1;
  }
  querySpheroidData(e2) {
    this.throwIfNotGCSOrPCS(), n(this.m_peCoordSysVal);
    const t3 = this.getGCS().getPECoordSys().getDatum().getSpheroid(), s3 = t3.getFlattening();
    ku2(e2, t3.getAxis(), s3);
  }
  getAreaOfUse() {
    0 === this.getCoordinateSystemType() && C(""), n(this.m_peCoordSysVal);
    const e2 = this.m_peCoordSysVal.getAreaOfUse();
    return null === e2 ? new ss2() : new ss2({ geom: e2.clone(), sr: Ou2(4326) });
  }
  getZToXYFactor() {
    return 1;
  }
  isCustomWkid() {
    return false;
  }
  getOneDegreeGCSUnit() {
    return this.throwIfNotGCSOrPCS(), n(this.m_peCoordSysVal), this.m_peCoordSysVal.getOneDegreeGCSUnit();
  }
  getGcsUnitFactor() {
    return this.throwIfNotGCSOrPCS(), n(this.m_peCoordSysVal), this.m_peCoordSysVal.getGcsUnitFactor();
  }
  snapGeometry(e2) {
    if (e2.isEmpty()) return false;
    if (2 === this.m_precisionDescriptor.getPrecision()) return false;
    const t3 = e2.getGeometryType();
    if (y(t3)) return this.snapMultiVertex_(e2);
    if (t3 === a.enumPoint) return this.snapPoint_(e2);
    if (t3 === a.enumEnvelope) return this.snapEnvelope_(e2);
    if (f(t3)) return this.snapSegment_(e2);
    if (t3 === a.enumGeometryCollection) {
      const t4 = e2;
      let s3 = false;
      for (let e3 = 0, n5 = t4.getGeometryCount(); e3 < n5; ++e3) s3 = this.snapGeometry(t4.getGeometry(e3)) || s3;
      return s3;
    }
    b("what else?");
  }
  snapMultiVertex_(e2) {
    if (n(!e2.isEmpty()), n(2 !== this.m_precisionDescriptor.getPrecision()), h(e2.getGeometryType())) {
      const t4 = e2;
      if (t4.hasNonLinearSegments()) return this.snapGeometryWithCurves_(t4);
    }
    const t3 = e2.getImpl(), s3 = t3.getDescription();
    let n5 = false;
    for (let r = 0, i2 = s3.getAttributeCount(); r < i2; r++) {
      const e3 = s3.getSemantics(r), i3 = t3.getAttributeStreamRef(e3);
      n5 = this.snapAttributes(e3, i3, 0, t3.getPointCount()) || n5;
    }
    return n5 && t3.notifyModifiedFlags(2001), n5;
  }
  snapPoint_(e2) {
    return false;
  }
  snapEnvelope_(e2) {
    return false;
  }
  snapSegment_(e2) {
    n(!e2.isEmpty()), n(2 !== this.m_precisionDescriptor.getPrecision());
    const t3 = new ac();
    this.queryPrecisionDescriptor(t3);
    const s3 = e2.getStartXY(), n5 = new mi();
    n5.x = pc(s3.x, t3.getFalseX(), t3.getGridUnitsXY()), n5.y = pc(s3.y, t3.getFalseY(), t3.getGridUnitsXY());
    let r = !n5.equals(s3);
    const i2 = e2.getEndXY(), a2 = new mi();
    a2.x = pc(i2.x, t3.getFalseX(), t3.getGridUnitsXY()), a2.y = pc(i2.y, t3.getFalseY(), t3.getGridUnitsXY()), r ||= !a2.equals(i2), r && e2.changeEndPoints2D(n5, a2);
    const h2 = (t4, s4, n6) => {
      let r2 = false;
      {
        const i3 = e2.getStartAttributeAsDbl(t4, 0), o = pc(i3, s4, n6), a3 = !ls(o, i3);
        r2 ||= a3, a3 && e2.setStartAttribute(t4, 0, o);
      }
      {
        const i3 = e2.getEndAttributeAsDbl(t4, 0), o = pc(i3, s4, n6), a3 = !ls(o, i3);
        r2 ||= a3, a3 && e2.setEndAttribute(t4, 0, o);
      }
      return r2;
    };
    let m3 = r ? 1 : 0;
    return e2.hasAttribute(1) && (m3 |= h2(1, t3.getFalseZ(), t3.getGridUnitsZ()) ? 1 : 0), e2.hasAttribute(2) && (m3 |= h2(2, t3.getFalseM(), t3.getGridUnitsM()) ? 1 : 0), !!m3;
  }
  snapGeometryWithCurves_(e2) {
    n(!e2.isEmpty()), n(2 !== this.m_precisionDescriptor.getPrecision());
    const t3 = e2.createInstance(), s3 = new fm();
    let n5 = 0;
    for (let r = 0, i2 = e2.getPathCount(); r < i2; ++r) {
      const i3 = e2.getSegmentCountPath(r);
      if (0 === i3) {
        if (t3.addPath(e2, r, true), 1 === t3.getPathSize(r)) {
          const e3 = new ee();
          t3.getPointByVal(t3.getPointCount() - 1, e3), n5 |= this.snapGeometry(e3) ? 1 : 0, t3.setPointByVal(t3.getPointCount() - 1, e3);
        }
        continue;
      }
      const o = e2.isClosedPath(r);
      for (let a2 = 0, h2 = o ? i3 - 1 : i3; a2 < h2; ++a2) e2.getSegmentFromPath(r, a2, s3, false), n5 |= this.snapGeometry(s3.get()) ? 1 : 0, t3.addSegment(s3.get(), 0 === a2);
      o && (e2.getSegmentFromPath(r, i3 - 1, s3, false), n5 |= this.snapGeometry(s3.get()) ? 1 : 0, 1 === i3 ? t3.addPathFromClosedSegment(s3.get(), false) : t3.closeLastPathWithSegment(s3.get()));
    }
    return n5 && t3.copyTo(e2), !!n5;
  }
  snapAttributes(e2, t3, s3, n5) {
    let r = false;
    const i2 = new ac();
    if (this.queryPrecisionDescriptor(i2), 0 === e2) {
      const e3 = t3;
      for (let t4 = s3; t4 < n5; t4++) {
        const s4 = e3.read(2 * t4), n6 = _oc.s_SnapValue(s4, i2.getFalseX(), i2.getGridUnitsXY()), o = e3.read(2 * t4 + 1), a2 = _oc.s_SnapValue(o, i2.getFalseY(), i2.getGridUnitsXY());
        r = r || n6 !== s4 || a2 !== o, r && (e3.write(2 * t4, n6), e3.write(2 * t4 + 1, a2));
      }
    } else if (1 === e2) {
      const e3 = t3;
      for (let t4 = s3; t4 < n5; t4++) {
        const s4 = e3.read(t4), n6 = _oc.s_SnapValue(s4, i2.getFalseZ(), i2.getGridUnitsZ());
        r = r || !ls(n6, s4), r && e3.write(t4, n6);
      }
    } else if (2 === e2) {
      const e3 = t3;
      for (let t4 = s3; t4 < n5; t4++) {
        const s4 = e3.read(t4), n6 = _oc.s_SnapValue(s4, i2.getFalseM(), i2.getGridUnitsM());
        r = r || !ls(n6, s4), r && e3.write(t4, n6);
      }
    }
    return r;
  }
  static s_SnapValue(e2, t3, s3) {
    return S((e2 - t3) * s3) / s3 + t3;
  }
};
var ac = class _ac {
  constructor() {
    const e2 = Du2, t3 = 1e-4, s3 = 1e-3, n5 = t3 * Number(e2) * 0.5;
    this.m_precision = 1, this.m_falseX = -n5, this.m_falseY = -n5, this.m_unitsXY = Number(e2) / (2 * n5), this.m_falseM = -1e5, this.m_unitsM = 1 / t3, this.m_falseZ = -1e5, this.m_unitsZ = 1 / t3, this.m_toleranceXY = s3, this.m_toleranceM = s3, this.m_toleranceZ = s3;
  }
  getHashCode() {
    let e2 = 7777, t3 = 7777;
    return t3 = As(t3, this.m_falseM), t3 = As(t3, this.m_unitsM), e2 = As(e2, this.m_unitsXY), t3 = As(t3, this.m_toleranceXY), e2 = As(e2, this.m_falseZ), t3 = As(t3, this.m_toleranceZ), e2 = As(e2, this.m_unitsZ), t3 = As(t3, this.m_toleranceM), e2 = As(e2, this.m_precision), As(e2, t3);
  }
  clone() {
    const e2 = new _ac();
    return e2.m_falseX = this.m_falseX, e2.m_falseY = this.m_falseY, e2.m_unitsXY = this.m_unitsXY, e2.m_falseZ = this.m_falseZ, e2.m_unitsZ = this.m_unitsZ, e2.m_falseM = this.m_falseM, e2.m_unitsM = this.m_unitsM, e2.m_toleranceXY = this.m_toleranceXY, e2.m_toleranceZ = this.m_toleranceZ, e2.m_toleranceM = this.m_toleranceM, e2.m_precision = this.m_precision, e2;
  }
  assign(e2) {
    return this.m_falseX = e2.m_falseX, this.m_falseY = e2.m_falseY, this.m_unitsXY = e2.m_unitsXY, this.m_falseZ = e2.m_falseZ, this.m_unitsZ = e2.m_unitsZ, this.m_falseM = e2.m_falseM, this.m_unitsM = e2.m_unitsM, this.m_toleranceXY = e2.m_toleranceXY, this.m_toleranceZ = e2.m_toleranceZ, this.m_toleranceM = e2.m_toleranceM, this.m_precision = e2.m_precision, this;
  }
  initialize2D(e2, t3) {
  }
  getTolerance(e2) {
    switch (e2) {
      case 0:
        return this.m_toleranceXY;
      case 1:
        return this.m_toleranceZ;
      case 2:
        return this.m_toleranceM;
      default:
        return 0;
    }
  }
  getResolution(e2) {
    if (2 === this.m_precision) return 0;
    switch (e2) {
      case 0:
        return 1 / this.m_unitsXY;
      case 1:
        return 1 / this.m_unitsZ;
      case 2:
        return 1 / this.m_unitsM;
      default:
        return 0;
    }
  }
  getFalseX() {
    return this.m_falseX;
  }
  getFalseY() {
    return this.m_falseY;
  }
  getFalseZ() {
    return this.m_falseZ;
  }
  getFalseM() {
    return this.m_falseM;
  }
  getGridUnitsXY() {
    return this.m_unitsXY;
  }
  getGridUnitsZ() {
    return this.m_unitsZ;
  }
  getGridUnitsM() {
    return this.m_unitsM;
  }
  getPrecision() {
    return this.m_precision;
  }
  static getLimit32() {
    return 2147483645;
  }
  static getLimit64() {
    return 9007199254740990n;
  }
  static getLimitFloat() {
    return 0;
  }
  getXYGridRange() {
    const e2 = new n3();
    switch (this.m_precision) {
      case 0:
        {
          const t3 = _ac.getLimit32() / this.getGridUnitsXY();
          e2.setCoords({ xmin: this.getFalseX(), ymin: this.getFalseY(), xmax: this.getFalseX() + t3, ymax: this.getFalseY() + t3 });
        }
        break;
      case 1:
        {
          const t3 = Number(_ac.getLimit64()) / this.getGridUnitsXY();
          e2.setCoords({ xmin: this.getFalseX(), ymin: this.getFalseY(), xmax: this.getFalseX() + t3, ymax: this.getFalseY() + t3 });
        }
        break;
      case 2:
        e2.setCoords({ xmin: -Number.MAX_VALUE, ymin: -Number.MAX_VALUE, xmax: Number.MAX_VALUE, ymax: Number.MAX_VALUE });
        break;
      default:
        e2.setEmpty(), b("");
    }
    return e2;
  }
  getZGridRange() {
    const e2 = new x2();
    switch (this.m_precision) {
      case 0:
        {
          const t3 = _ac.getLimit32() / this.getGridUnitsZ();
          e2.setCoords(this.getFalseZ(), this.getFalseZ() + t3);
        }
        break;
      case 1:
        {
          const t3 = Number(_ac.getLimit64()) / this.getGridUnitsZ();
          e2.setCoords(this.getFalseZ(), this.getFalseZ() + t3);
        }
        break;
      case 2:
        e2.setCoords(-Number.MAX_VALUE, Number.MAX_VALUE);
        break;
      default:
        e2.setEmpty(), b("");
    }
    return e2;
  }
  getMGridRange() {
    const e2 = new x2();
    switch (this.m_precision) {
      case 0:
        {
          const t3 = _ac.getLimit32() / this.getGridUnitsM();
          e2.setCoords(this.getFalseM(), this.getFalseM() + t3);
        }
        break;
      case 1:
        {
          const t3 = Number(_ac.getLimit64()) / this.getGridUnitsM();
          e2.setCoords(this.getFalseM(), this.getFalseM() + t3);
        }
        break;
      case 2:
        e2.setCoords(-Number.MAX_VALUE, Number.MAX_VALUE);
        break;
      default:
        e2.setEmpty(), b("");
    }
    return e2;
  }
  setTolerance(t3, s3) {
    switch (s3 < 0 && P("tol < 0"), Number.isFinite(s3) || P("tol is not finite"), t3) {
      case 0:
        this.m_toleranceXY = s3;
        break;
      case 1:
        this.m_toleranceZ = s3;
        break;
      case 2:
        this.m_toleranceM = s3;
        break;
      default:
        P("cannot set tolerance for this attribute");
    }
  }
  setGridParams(t3, s3, n5) {
    Number.isFinite(t3) && Number.isFinite(s3) && Number.isFinite(n5) || P("grid params are not finite"), n5 < 1 && P("grid units cannot be smaller than 1.0"), this.m_falseX = t3, this.m_falseY = s3, this.m_unitsXY = n5;
  }
  setZParams(t3, s3) {
    Number.isFinite(t3) && Number.isFinite(s3) || P("grid params are not finite"), s3 < 1 && P("grid units cannot be smaller than 1.0"), this.m_falseZ = t3, this.m_unitsZ = s3;
  }
  setMParams(t3, s3) {
    Number.isFinite(t3) && Number.isFinite(s3) || P("grid params are not finite"), s3 < 1 && P("grid units cannot be smaller than 1.0"), this.m_falseM = t3, this.m_unitsM = s3;
  }
  setPrecision(e2) {
  }
  equals(e2) {
    return this === e2 || ls(this.m_falseX, e2.m_falseX) && ls(this.m_falseY, e2.m_falseY) && this.equalsWithoutFalseXY(e2);
  }
  snapPrecision() {
    if (2 === this.m_precision) return;
    const e2 = (e3, t4, s3, n5) => {
      if (!Number.isFinite(t4) || !Number.isFinite(s3)) return s3;
      if (s3 < 1) return 1;
      if (!n5) return s3;
      const r = Number(e3) / s3;
      return Math.trunc((t4 + r - t4) * s3) > e3 && (s3 = e3 / (t4 + r - t4)), Math.max(1, s3);
    }, t3 = Number(0 === this.m_precision ? Gu2 : Du2);
    this.m_unitsXY = e2(t3, this.m_falseX, this.m_unitsXY, true), this.m_unitsXY = e2(t3, this.m_falseY, this.m_unitsXY, true), this.m_unitsZ = e2(t3, this.m_falseZ, this.m_unitsZ, false), this.m_unitsM = e2(t3, this.m_falseM, this.m_unitsM, false);
  }
  verifyPrecision() {
    if (2 === this.m_precision) return true;
    const e2 = (e3, t4, s3, n5) => {
      if (s3 < 1) return false;
      if (!Number.isFinite(t4) || !Number.isFinite(s3)) return false;
      if (!n5) return true;
      const r = Number(e3) / s3;
      return !(BigInt((t4 + r - t4) * s3) > e3);
    }, t3 = 0 === this.m_precision ? Gu2 : Du2;
    return !!e2(t3, this.m_falseX, this.m_unitsXY, true) && (!!e2(t3, this.m_falseY, this.m_unitsXY, true) && (!!e2(t3, this.m_falseZ, this.m_unitsZ, false) && !!e2(t3, this.m_falseM, this.m_unitsM, false)));
  }
  fixTolerance() {
    2 !== this.m_precision && (this.m_toleranceXY = Math.max(2 / this.m_unitsXY, this.m_toleranceXY), this.m_toleranceZ = Math.max(2 / this.m_unitsZ, this.m_toleranceZ), this.m_toleranceM = Math.max(2 / this.m_unitsM, this.m_toleranceM), (Number.isNaN(this.m_falseX) || Number.isNaN(this.m_falseY)) && (this.m_falseX = this.m_falseY = Number.NaN));
  }
  equalsWithoutFalseXY(e2) {
    return this === e2 || this.m_unitsXY === e2.m_unitsXY && this.m_falseZ === e2.m_falseZ && this.m_unitsZ === e2.m_unitsZ && this.m_falseM === e2.m_falseM && this.m_unitsM === e2.m_unitsM && this.m_toleranceXY === e2.m_toleranceXY && this.m_toleranceZ === e2.m_toleranceZ && this.m_toleranceM === e2.m_toleranceM && this.m_precision === e2.m_precision;
  }
  setBestXyDomainFromEnvelope(e2, t3) {
  }
  setBestZDomainFromZRange(e2, t3, s3) {
  }
  setBestMDomainFromMRange(e2, t3, s3) {
  }
};
function hc() {
  return (!ec || Uu2() && null === ec.getPECoordSys()) && (ec = dc(3857, 0, null, true)), ec;
}
function mc() {
  return (!tc || Uu2() && null === tc.getPECoordSys()) && (tc = dc(102100, 0, null, true)), tc;
}
function lc() {
  return (!sc || Uu2() && null === sc.getPECoordSys()) && (sc = dc(4326, 0, null, true)), sc;
}
function gc(e2) {
  e2.m_falseX = 0, e2.m_falseY = 0, e2.m_unitsXY = 1, e2.m_falseZ = 0, e2.m_unitsZ = 1, e2.m_falseM = 0, e2.m_unitsM = 1, e2.m_toleranceXY = 100 * Qs(), e2.m_toleranceZ = 100 * Qs(), e2.m_toleranceM = 100 * Qs(), e2.m_precision = 2;
}
function uc(t3, s3, n5, r) {
  const i2 = s3 instanceof qg;
  gc(t3), t3.m_precision = r, t3.m_falseX = Number.NaN, t3.m_falseY = Number.NaN;
  const o = 1e-4, a2 = 1e-3, h2 = i2 ? s3.m_csType : s3.isPCS ? 2 : 1;
  if (1 === h2) {
    const e2 = (0 === r ? 1 / 18e5 : 1e-9) * (i2 ? s3.getOneDegreeGCSUnit() : Math.PI / s3.metersOrRadiansPerUnit / 180);
    t3.m_unitsXY = 1 / e2;
  } else if (2 === h2) {
    const e2 = (0 === r ? a2 : o) * (i2 ? s3.getOneMeterPCSUnit() : 1 / s3.metersOrRadiansPerUnit);
    t3.m_unitsXY = 1 / e2;
  } else P("unrecognized cs type");
  t3.m_falseM = -1e5, t3.m_unitsM = 1 / (0 === r ? a2 : o), t3.m_unitsM = Math.max(1, t3.m_unitsM), t3.m_unitsXY = Math.max(1, t3.m_unitsXY);
  let m3 = 0, l2 = 0;
  0 !== r && 1 !== r || (m3 = 2 / t3.m_unitsXY, l2 = 2 / t3.m_unitsM), t3.m_toleranceXY = Math.max(m3, i2 ? s3.getUnitsPerMillimeter() : 2 === h2 ? 1e-3 / s3.metersOrRadiansPerUnit : 1e-3 / (s3.semiMajor * s3.metersOrRadiansPerUnit)), t3.m_toleranceM = Math.max(a2, l2), cc(t3, n5);
}
function cc(e2, t3) {
  const s3 = 1e-4, n5 = 1e-3;
  if (e2.m_falseZ = -1e5, t3) {
    const r2 = (0 === e2.m_precision ? n5 : s3) * t3.getOneMeter();
    e2.m_unitsZ = 1 / r2;
  } else e2.m_unitsZ = 1 / (0 === e2.m_precision ? n5 : s3);
  e2.m_unitsZ = Math.max(1, e2.m_unitsZ);
  let r = 0;
  0 !== e2.m_precision && 1 !== e2.m_precision || (r = 2 / e2.m_unitsZ), e2.m_toleranceZ = Math.max(t3 ? t3.getOneMeter() * n5 : n5, r);
}
function _c(e2, t3, s3, n5) {
  gc(e2), e2.m_precision = n5;
  const r = 0 === n5 ? Gu2 : Du2, i2 = 1e-4, o = 1e-3;
  let a2 = 1, h2 = 1, m3 = 1e-3;
  t3 && (h2 = t3.getUnitToBaseFactor()), t3 && 1 === t3.getUnitType() ? (a2 = 400 * Math.PI / 180, m3 = 8983152841195215e-24 * Math.PI / 180 / h2) : (a2 = (0 === n5 ? o : i2) * Number(r) * 0.5, m3 = o / h2), a2 /= h2, e2.m_falseX = -a2, e2.m_falseY = -a2, e2.m_unitsXY = Number(r) / (2 * a2), e2.m_falseM = -1e5, e2.m_unitsM = 1 / (0 === n5 ? o : i2), e2.m_unitsM = Math.max(1, e2.m_unitsM), e2.snapPrecision();
  let l2 = 0, g2 = 0;
  0 !== e2.m_precision && 1 !== e2.m_precision || (g2 = 2 / e2.m_unitsM, l2 = 2 / e2.m_unitsXY), e2.m_toleranceXY = Math.max(l2, m3), e2.m_toleranceM = Math.max(o, g2), cc(e2, s3);
}
function dc(e2, t3, s3, n5) {
  if (!n5 && t3 <= 0) {
    if (3857 === e2) return hc();
    if (102100 === e2) return mc();
    if (4326 === e2) return lc();
  }
  const r = new oc();
  let i2, o = null;
  return Uu2() ? (i2 = iu2(e2), t3 > 0 ? o = null : t3 = 0, r.setHorzProj_(i2), r.m_vertcs = o) : (i2 = Ac(e2), r.m_unit = i2.isPCS ? new bu2(i2.metersOrRadiansPerUnit) : new os(i2.metersOrRadiansPerUnit)), uc(r.m_precisionDescriptor, i2, o, 1), r.m_bDefaultDescriptor = true, r.m_userWKID = e2, r.calculateHashCode(), r.initDbgName(), r;
}
function pc(e2, t3, s3) {
  return S((e2 - t3) * s3) / s3 + t3;
}
var fc = null;
var xc = 3552713678800501e-30;
function yc(e2, t3, s3) {
  return e2 === t3 || Math.abs(e2 - t3) <= s3 * (1 + (Math.abs(e2) + Math.abs(t3)) / 2);
}
function Pc(e2, t3) {
  return yc(e2, t3, xc);
}
function Ec(e2, t3) {
  return 0 === e2 || Math.abs(e2) <= t3;
}
function Sc(e2) {
  return Ec(e2, xc);
}
var Cc;
var Ic;
var bc;
var wc;
var vc;
var Nc;
var Tc;
var Gc;
var Dc;
var Vc;
var Fc;
function Hc(e2) {
  return { _this: e2, get() {
    return this._this;
  }, reset(e3) {
    this._this = e3;
  }, release() {
    const e3 = this._this;
    return this._this = null, e3;
  } };
}
var kc = null;
function Ac(e2) {
  n(kc);
  const t3 = kc(e2);
  return t3.semiMajor = t3.isPCS ? Number.NaN : Rc(e2), t3;
}
function Mc(e2) {
  kc = e2, n(kc);
}
function Uc(e2) {
  const t3 = e2;
  Ic = t3.PeFactory, n(Ic), Fc = t3.PeGCSExtent, n(Fc), Dc = t3.PeLineType, n(Dc), Vc = t3.PeMath, n(Vc), Cc = t3.PeDouble, n(Cc), bc = t3.PeDefs, n(bc), wc = t3.PeCSTransformations, n(wc), vc = t3.PeGTTransformations, n(vc), Nc = t3.PePCSInfo, n(Nc), Tc = t3.PeGTlistExtended, n(Tc), Ic.initialize(), Gc = t3.PeGTlistExtendedEntry, n(Gc), bc.PE_TYPE_ANGUNIT = 512, bc.PE_STR_AUTH_ALL = 2, Nc.PE_POLE_LINE_STRAIGHT = 2, Nc.PE_POLE_LINE_CURVED = 3, bc.PE_PARM_LAM0 = 2, bc.PE_PARM_PHI0 = 6, bc.PE_PRJ_AZIMUTHAL_EQUIDISTANT = 43032, bc.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA = 43033, bc.PE_PRJ_ALBERS = 43007, bc.PE_PRJ_CYLINDRICAL_EQAREA = 43034, bc.PE_TYPE_VERTCS = 8, bc.PE_LINETYPE_GEODESIC = 0, bc.PE_LINETYPE_LOXODROME = 1, bc.PE_LINETYPE_GREAT_ELLIPTIC = 2, bc.PE_LINETYPE_NORMAL_SECTION = 3, Tc.PE_GTLIST_OPTS_USABLE = 1, kc = null;
}
function qc(e2, t3, s3, n5) {
  return t3 <= 0 ? (s3[0] = 0, n5[0] = 0, false) : (s3[0] = t3, n5[0] = t3, true);
}
function Bc(e2) {
  n(qu2());
  return !!kc(e2).isPCS || Oc(e2);
}
function Oc(e2) {
  return Ic && C("pe has been loaded. no-pe methods should not be used at this point."), fc || Xc(), fc.has(e2);
}
var Yc = /(?:ELLIPSOID|SPHEROID)\["(?:\w|[-()])+",(\d+\.\d+)/;
function Rc(t3) {
  if (Ic && C("pe has been loaded. no-pe methods should not be used at this point."), "string" == typeof t3) {
    const s3 = t3.match(Yc);
    s3 && 2 === s3.length || P("bad gcs wkt");
    const n5 = Number.parseFloat(s3[1]);
    return Number.isFinite(n5) || P("bad gcs wkt"), n5;
  }
  return fc || Xc(), fc.has(t3) || C("gcs wkid not found"), fc.get(t3);
}
function Xc() {
  fc = /* @__PURE__ */ new Map();
  for (const e2 in rs2) {
    const t3 = Number.parseFloat(e2), s3 = rs2[e2];
    if (Array.isArray(s3)) for (const e3 of s3) fc.set(e3, t3);
    else fc.set(s3, t3);
  }
  is();
}
function Lc(e2, t3) {
  const s3 = Ic.geogtran(e2);
  s3 || R(e2);
  return new Kc(s3, t3);
}
function zc(e2, t3) {
  const s3 = Ic.fromString(bc.PE_TYPE_GEOGTRAN, e2);
  s3 || U(e2);
  return new Kc(s3, t3);
}
function Wc(e2, t3) {
  return new Kc(e2, t3);
}
var jc = Zs(0);
var Zc = Zs(1);
var Kc = class _Kc {
  constructor(e2, t3) {
    if (e2 instanceof _Kc) return this.m_geogTranWrapper = e2.m_geogTranWrapper, this.m_bInverted = t3 ? !e2.m_bInverted : e2.m_bInverted, void (this.m_hashCode = As(this.m_geogTranWrapper.getHashCode(), this.m_bInverted ? Zc : jc));
    this.m_geogTranWrapper = new Um(e2), this.m_bInverted = t3, this.m_hashCode = As(this.m_geogTranWrapper.getHashCode(), this.m_bInverted ? Zc : jc);
  }
  getID() {
    return this.m_geogTranWrapper.getLatestId();
  }
  getLatestID() {
    return this.m_geogTranWrapper.getLatestId();
  }
  getText() {
    return this.m_geogTranWrapper.getText();
  }
  getTextExtended(e2) {
    if (!this.m_geogTranWrapper.getGeogtran()) return "";
    if (-1 === e2) return this.m_geogTranWrapper.getGeogtran().toString();
    {
      const t3 = 0 === e2 ? bc.PE_STR_AUTH_TOP : bc.PE_STR_AUTH_ALL;
      return this.m_geogTranWrapper.getGeogtran().toString(t3);
    }
  }
  getText2(e2 = -1) {
    let t3 = bc.PE_STR_FMT_WKT2;
    return -1 !== e2 && (t3 |= 0 === e2 ? bc.PE_STR_AUTH_TOP : bc.PE_STR_AUTH_ALL), this.m_geogTranWrapper.getGeogtran().toString(t3);
  }
  getName() {
    return this.m_geogTranWrapper && this.m_geogTranWrapper.getGeogtran() ? this.m_geogTranWrapper.getGeogtran().getName() : "";
  }
  getInputSpatialReference() {
    return this.m_bInverted ? this.m_geogTranWrapper.getOutputSr(false) : this.m_geogTranWrapper.getInputSr(false);
  }
  getOutputSpatialReference() {
    return this.m_bInverted ? this.m_geogTranWrapper.getInputSr(false) : this.m_geogTranWrapper.getOutputSr(false);
  }
  getInverse() {
    return new _Kc(this, true);
  }
  isInverted() {
    return this.m_bInverted;
  }
  getHashCode() {
    return this.m_hashCode;
  }
  GetPeGeogtran() {
    return this.m_geogTranWrapper.getGeogtran();
  }
  equals(e2) {
    const t3 = e2;
    return t3 === this || this.m_bInverted === t3.m_bInverted && (this.GetPeGeogtran() === t3.GetPeGeogtran() || this.getID() === t3.getID() && !(0 === this.getID() && !this.GetPeGeogtran().isEqual(t3.GetPeGeogtran())));
  }
  referencesMissingData() {
    return !!this.m_geogTranWrapper && !this.m_geogTranWrapper.isUsable();
  }
  getWrapper() {
    return this.m_geogTranWrapper;
  }
};
function Qc(e2, t3, s3, n5, r) {
  const i2 = e2.getGCS(), a2 = t3.getGCS(), h2 = i2.getPECoordSys(), m3 = a2.getPECoordSys();
  let l2 = null;
  if (!s3.isEmpty()) {
    const t4 = s3.clone();
    if (!t4.isEmpty() && 2 === e2.getCoordinateSystemType()) {
      let s4 = new re({ env2D: t4 });
      const n6 = Rg(e2, i2, null);
      s4 = new qh().execute(s4, n6, null), s4.queryEnvelope(t4);
    }
    if (!t4.isEmpty()) {
      const e3 = h2.getPrimem().getLongitude(), s4 = h2.getUnit().getUnitFactor();
      l2 = new Fc(t4.xmin, t4.ymin, t4.xmax, t4.ymax, e3, s4);
    }
  }
  let g2 = n5;
  g2 >= ds() && (g2 = 0);
  const u = [];
  let c = Tc.PE_GTLIST_OPTS_COMMON;
  r || (c &= ~Tc.PE_GTLIST_OPTS_USABLE);
  for (let _ = 0; _ < 2; _++) {
    u.length = 0;
    const e3 = g2, t4 = Tc.getGTlist(h2, m3, 2, c, l2, e3);
    let s4 = false;
    if (t4 && t4.length > 0) for (let i3 = 0, a3 = t4.length; i3 < a3; i3++) {
      const e4 = $c([t4[i3]]);
      if (n(e4), r && e4.referencesMissingData()) s4 = true;
      else if (u.push(e4), n5 > 0 && u.length === n5) break;
    }
    if (!s4) break;
    0 === g2 || (g2 = 0);
  }
  return l2 && l2.destroy(), u;
}
function Jc() {
  return new e_([], null, null, null);
}
function $c(e2) {
  n(null !== e2);
  const t3 = new t_(), s3 = e2[0].getSteps();
  if (s3) {
    const n5 = e2[0].getEntries();
    for (let e3 = 0; e3 < s3; e3++) {
      const s4 = 0 !== n5[e3].getDirection(), r = Wc(n5[e3].getGeogtran(), s4);
      t3.add(r);
    }
    return t3.create();
  }
  return null;
}
var e_ = class {
  constructor(e2, t3, s3, n5) {
    this.m_bReadOnly = true, this.m_name = "", this.m_fastTrack = -1, this.m_bNameIsSet = false, this.m_transforms = e2, t3 && (this.m_name = t3, this.m_bNameIsSet = true), this.m_inputSr = s3, this.m_outputSr = n5;
  }
  getType() {
    return 0;
  }
  getName() {
    if (this.m_bNameIsSet) return this.m_name;
    if (0 === this.m_transforms.length) return "";
    let e2 = "";
    for (const t3 of this.m_transforms) e2.length > 0 && (e2 += " + "), t3.isInverted() && (e2 += "~"), e2 += t3.getName();
    return e2;
  }
  count() {
    return this.m_transforms.length;
  }
  createInverse() {
    return this.getInverse();
  }
  getHashCode() {
    let e2 = 1973;
    for (let t3 = 0; t3 < this.m_transforms.length; t3++) e2 = As(e2, this.m_transforms[t3].getHashCode());
    return e2;
  }
  equals(e2) {
    return n(0), false;
  }
  referencesMissingData() {
    if (0 === this.m_transforms.length) return false;
    for (const e2 of this.m_transforms) if (e2.referencesMissingData()) return true;
    return false;
  }
  isMatchingTransformation(e2, t3) {
    return n(0), false;
  }
  validateTransformation(e2, t3) {
    return n(0), false;
  }
  nameIsSet() {
    return n(0), false;
  }
  getInputSpatialReference() {
    return this.m_inputSr;
  }
  getOutputSpatialReference() {
    return this.m_outputSr;
  }
  getStep(e2) {
    return (e2 < 0 || e2 > this.count()) && A(""), this.m_transforms[e2];
  }
  getInverse() {
    const e2 = new t_();
    return e2.addSteps(this, true), e2.setInputSpatialReference(this.m_outputSr), e2.setOutputSpatialReference(this.m_inputSr), e2.create();
  }
  transform(e2, t3, s3) {
    if (0 === this.count()) return;
    let n5 = this.m_inputSr, r = this.m_outputSr;
    if (e2 && (r = Pt(n5, n5 = r)), 0 === this.m_transforms.length) return void qm(n5, null, r, null, t3, null, s3);
    let i2 = this.m_fastTrack;
    if (1 === i2) return void ss(e2, this.m_transforms, (n6) => {
      Xm(n6.getWrapper(), e2 !== n6.isInverted(), t3, null, s3);
    });
    const o = Mm();
    -1 === i2 && o.initFromGcsAndVcs(n5, null);
    const a2 = Mm();
    let h2 = e2 ? this.m_transforms.length - 1 : 0;
    const m3 = e2 ? -1 : 1;
    for (let g2 = 0, u = this.m_transforms.length; g2 < u; g2++, h2 += m3) {
      if (0 === g2) {
        const r3 = this.m_transforms[h2];
        Bm(n5.getPECoordSys(), null, r3.getWrapper(), e2 !== r3.isInverted(), t3, null, s3, a2), -1 === i2 && (o.equals(a2) || (i2 = 0)), o.assign(a2);
      } else {
        const n6 = this.m_transforms[h2 - m3], r3 = this.m_transforms[h2];
        Ym(o, n6.getWrapper(), e2 !== n6.isInverted(), r3.getWrapper(), e2 !== r3.isInverted(), t3, null, s3, a2), -1 === i2 && (o.equals(a2) || (i2 = 0)), o.assign(a2);
      }
      const r2 = this.m_transforms[h2];
      Rm(o, r2.getWrapper(), e2 !== r2.isInverted(), t3, null, s3, a2), o.assign(a2);
    }
    const l2 = this.m_transforms[h2 - m3];
    Om(o, l2.getWrapper(), e2 !== l2.isInverted(), r, null, t3, null, s3), -1 === i2 && (a2.initFromGcsAndVcs(r, null), o.equals(a2) || (i2 = 0)), this.m_fastTrack = 0 === i2 ? 0 : 1;
  }
};
var t_ = class {
  constructor() {
    this.m_transforms = [], this.m_inputGCS = null, this.m_outputGCS = null, this.m_name = "", this.m_bNameIsSet = false;
  }
  getInputSpatialReference() {
    return null !== this.m_inputGCS ? this.m_inputGCS : this.count() > 0 ? this.m_transforms[0].getInputSpatialReference() : null;
  }
  setInputSpatialReference(e2) {
    this.m_inputGCS = e2 ? e2.getGCS() : null;
  }
  getOutputSpatialReference() {
    return null !== this.m_outputGCS ? this.m_outputGCS : this.count() > 0 ? this.m_transforms.at(-1).getOutputSpatialReference() : null;
  }
  setOutputSpatialReference(e2) {
    this.m_outputGCS = e2 ? e2.getGCS() : null;
  }
  getName() {
    if (this.m_bNameIsSet) return this.m_name;
    if (0 === this.m_transforms.length) return "";
    let e2 = "";
    for (const t3 of this.m_transforms) e2.length > 0 && (e2 += " + "), t3.isInverted() && (e2 += "~"), e2 += t3.getName();
    return e2;
  }
  count() {
    return this.m_transforms.length;
  }
  getStep(e2) {
    return (e2 < 0 || e2 > this.count()) && A(""), this.m_transforms[e2];
  }
  setStep(e2, t3) {
    n(0);
  }
  add(e2) {
    this.m_transforms.push(e2);
  }
  addSteps(e2, t3) {
    if (t3) for (let s3 = e2.count() - 1; s3 >= 0; --s3) this.add(e2.getStep(s3).getInverse());
    else for (let s3 = 0; s3 < e2.count(); ++s3) this.add(e2.getStep(s3));
  }
  clear() {
    this.m_transforms = [], this.m_name = "", this.m_bNameIsSet = false, this.m_inputGCS = null, this.m_outputGCS = null;
  }
  remove(e2) {
    n(0);
  }
  create() {
    const e2 = this.getInputSpatialReference(), t3 = this.getOutputSpatialReference(), s3 = new e_(this.m_transforms, this.m_bNameIsSet ? this.m_name : null, e2, t3);
    return s3.m_bReadOnly = true, this.clear(), s3;
  }
};

export {
  X,
  Q2 as Q,
  j3 as j,
  J2 as J,
  K2 as K,
  $2 as $,
  Et2 as Et,
  Dt2 as Dt,
  It2 as It,
  Ct2 as Ct,
  Tt,
  At,
  Bt2 as Bt,
  zt2 as zt,
  Ft2 as Ft,
  Vt2 as Vt,
  kt2 as kt,
  ee,
  re,
  _e,
  ns,
  cs2 as cs,
  ks,
  Os2 as Os,
  Js2 as Js,
  Kn,
  ur,
  cr,
  Pr,
  yr,
  vr,
  Er,
  wr,
  ia,
  zh,
  jh,
  ou,
  Tu,
  Lu,
  Ru,
  pm,
  fm,
  f2 as f,
  I3 as I,
  m2 as m,
  ss2 as ss,
  as,
  cs3 as cs2,
  ds3 as ds,
  Ps3 as Ps,
  ks2,
  sr2 as sr,
  ir2 as ir,
  kr2 as kr,
  Lo2 as Lo,
  Wo2 as Wo,
  aa2 as aa,
  ha2 as ha,
  _a2 as _a,
  da2 as da,
  fa2 as fa,
  Fa2 as Fa,
  Ma2 as Ma,
  Ra2 as Ra,
  Ka2 as Ka,
  ih2 as ih,
  hh2 as hh,
  Eh2 as Eh,
  wh2 as wh,
  qh,
  Oh,
  Yh2 as Yh,
  Rh2 as Rh,
  Xh2 as Xh,
  Lh2 as Lh,
  zh2,
  um2 as um,
  cm2 as cm,
  _m2 as _m,
  Hm,
  Lm,
  zm,
  Wm,
  jm,
  Km,
  al,
  ul,
  Tl,
  kl,
  Al,
  ql,
  Xl,
  zl,
  Wl,
  Zl,
  mg,
  Ag,
  Og,
  Yg,
  Rg,
  Lg,
  zg,
  Wg,
  Qg,
  eu2 as eu,
  Hu2 as Hu,
  Au2 as Au,
  Mu2 as Mu,
  Uu2 as Uu,
  qu2 as qu,
  Bu2 as Bu,
  Ou2 as Ou,
  Yu2 as Yu,
  Ru2,
  Lu2,
  zu2 as zu,
  Wu2 as Wu,
  ju2 as ju,
  Zu2 as Zu,
  Ku2 as Ku,
  Qu2 as Qu,
  rc,
  ic,
  oc,
  ac,
  hc,
  mc,
  lc,
  Pc,
  Cc,
  Ic,
  bc,
  wc,
  Dc,
  Vc,
  Lc,
  zc,
  Jc,
  t_
};
//# sourceMappingURL=chunk-RKVVFTIZ.js.map
