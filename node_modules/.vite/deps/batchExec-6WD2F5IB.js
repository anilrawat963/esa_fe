import {
  _
} from "./chunk-IRBX64M6.js";
import "./chunk-4WTOIJXV.js";
import "./chunk-BBYMM7CM.js";
import "./chunk-EM7Y2JZC.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import {
  e
} from "./chunk-4DGC7CBY.js";
import {
  $,
  D,
  u3 as u
} from "./chunk-GNMPGHLQ.js";
import "./chunk-QY7XKUIV.js";
import "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/arcade/batchExec.js
function n(t, e2, s, i) {
  return new h(t, e2, s, i);
}
var o = class {
  constructor(t, s, i) {
    this._executor = t, this._data = s, this._impl = i, this._closed = false, this._resolver = $(), this._impl.open(this);
  }
  assertOpen() {
    if (this._closed) throw new Error("Batch closed.");
  }
  get data() {
    return this.assertOpen(), this._data;
  }
  get results() {
    return this._resolver.promise;
  }
  send() {
    try {
      this.assertOpen(), this._closed = true, this._executor.resume(this), this._impl.close(this), D(this._resolver, this._impl.execute(this._data));
    } catch (t) {
      this._resolver.reject(t);
    }
  }
};
var h = class {
  constructor(t, i, n2, o2) {
    if (this._runJob = i, this._maxRunning = n2, this._abortSignal = o2, this._jobIdSeq = 0, this._running = /* @__PURE__ */ new Set(), this._blocked = /* @__PURE__ */ new Set(), this._openBatches = /* @__PURE__ */ new Map(), this._state = "ready", this._runResolver = null, n2 < 1) throw new Error(`_maxRunning=${n2} but cannot be < 1`);
    this._todo = t[Symbol.iterator](), this._queue = new _({ concurrency: 1, process: async (t2) => {
      if ("start" === t2.type) {
        const { id: i2, args: r } = t2, n3 = $(), o3 = $(), h2 = { id: i2, interrupt: n3, finished: o3.promise };
        return D(o3, this._runJob(r, { id: i2, yieldFor: (t3) => this.yieldFor(h2, t3) }).then(() => {
          this._blocked.has(i2) && this._fail(new Error(`job ${i2} completed before resuming`)), this._running.delete(i2) || this._fail(new Error(`job ${i2} not running?`));
        })), await Promise.race([n3.promise, h2.finished]), void this._tryQueue();
      }
      if ("continue" === t2.type) return t2.job.interrupt = $(), "fulfilled" === t2.data.status ? t2.continuation.resolve(t2.data.value) : t2.continuation.reject(t2.data.reason), await Promise.race([t2.job.interrupt.promise, t2.job.finished]), void this._tryQueue();
    } });
  }
  openBatch(t, e2) {
    return new o(this, t, e2);
  }
  _fail(t, e2 = false) {
    if (this._runResolver?.reject(t), this._state = "stopped", !e2) throw t;
  }
  _schedule(t) {
    this._queue.push(t).catch((t2) => this._fail(t2, true));
  }
  _tryQueue() {
    if ("running" === this._state) if (this._abortSignal?.aborted) this._fail(u(), true);
    else {
      if (this._running.size < this._maxRunning) {
        const t = this._todo.next();
        if (!t.done) {
          const e2 = this._jobIdSeq++;
          return this._running.add(e2), void this._schedule({ type: "start", id: e2, args: t.value });
        }
      }
      if (0 === this._running.size) return this._runResolver?.resolve(), this._runResolver = null, void (this._state = "stopped");
      if (this._blocked.size === this._running.size) {
        let t = null, e2 = -1 / 0;
        for (const [s, i] of this._openBatches) i.size > e2 && (t = s, e2 = i.size);
        return null == t && this._fail(new Error("deadlock")), void t.send();
      }
    }
  }
  resume(t) {
    const e2 = this._openBatches.get(t);
    if (this._openBatches.delete(t), null != e2) for (const s of e2) this._blocked.delete(s) || this._fail(new Error(`job ${s} not suspended`));
  }
  async yieldFor(s, i) {
    i.assertOpen(), this._running.has(s.id) || this._fail(new Error(`job ${s.id} not running`)), this._blocked.has(s.id) && this._fail(new Error(`job ${s.id} already suspended`)), this._blocked.add(s.id), e(this._openBatches, i, () => /* @__PURE__ */ new Set()).add(s.id), null == s.interrupt && this._fail(new Error(`job ${s.id} hasn't resumed yet`)), s.interrupt.resolve(), s.interrupt = null;
    const r = $();
    let n2;
    try {
      n2 = { status: "fulfilled", value: await i.results };
    } catch (o2) {
      n2 = { status: "rejected", reason: o2 };
    }
    return this._schedule({ type: "continue", continuation: r, data: n2, job: s }), r.promise;
  }
  run() {
    "ready" !== this._state && this._fail(new Error(`executor not ready to start. state=${this._state}`));
    const t = $();
    return this._state = "running", this._runResolver = t, this._tryQueue(), t.promise;
  }
};
export {
  n as createBatchExecutor
};
//# sourceMappingURL=batchExec-6WD2F5IB.js.map
