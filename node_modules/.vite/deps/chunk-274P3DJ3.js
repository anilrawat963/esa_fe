import {
  o as o3
} from "./chunk-2WMZLC2C.js";
import {
  a as a3,
  d,
  n as n4,
  r as r2
} from "./chunk-HHDWMGJ3.js";
import {
  i as i2
} from "./chunk-WHHIH5YU.js";
import {
  f as f2
} from "./chunk-MEDXVTKR.js";
import {
  a,
  c as c3
} from "./chunk-5LMH6D7V.js";
import {
  a as a2,
  t as t2
} from "./chunk-BZLHV37L.js";
import {
  U as U2,
  o as o2
} from "./chunk-NDFIZYZY.js";
import {
  A,
  E,
  N as N2,
  c as c2,
  y
} from "./chunk-VYMBX5H5.js";
import {
  e as e2,
  r
} from "./chunk-K2OZ6WVC.js";
import {
  o
} from "./chunk-DTZUXJMD.js";
import {
  B,
  c,
  f,
  h as h2,
  n as n2
} from "./chunk-XLOINTMG.js";
import {
  n
} from "./chunk-75XOUSSS.js";
import {
  j,
  n as n3
} from "./chunk-LTPHDYPK.js";
import {
  e
} from "./chunk-3OVERDFX.js";
import {
  P as P2,
  T,
  s
} from "./chunk-SMWUT52Z.js";
import {
  h
} from "./chunk-AXZMNHTN.js";
import {
  D,
  N2 as N,
  P,
  U,
  ce,
  w
} from "./chunk-NMQNUPE4.js";
import {
  t
} from "./chunk-6KIXN4DJ.js";
import {
  i3 as i
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/geometry/support/meshUtils/projection.js
var b = "Projection may be possible after calling projection.load().";
function k(r3, t3, o4, e3) {
  r3.error(`Failed to project from (wkid:${t3.wkid}) to (wkid:${o4.wkid}).${e3 ? " " : ""}${e3}`);
}
function w2(r3, t3, o4, e3, n5, i3) {
  return U3(0, o2.fromTypedArray(r3), 0, U2.fromTypedArray(t3), o4, U2.fromTypedArray(e3), n5, o2.fromTypedArray(i3)) ? i3 : null;
}
function M(r3, t3, o4, e3, n5, i3) {
  return U3(1, o2.fromTypedArray(r3), 0, U2.fromTypedArray(t3), o4, U2.fromTypedArray(e3), n5, o2.fromTypedArray(i3)) ? i3 : null;
}
function V(r3, t3, o4, e3) {
  return o(r3, t3, 0, o4, e3, 0) ? o4 : null;
}
function x(r3, t3, o4, e3) {
  return o(r3, t3, 0, o4, e3, 0) ? o4 : null;
}
function v(t3, e3, n5) {
  return j(G, n5), n4(e3, t3, G), T(G) && d(e3, e3), e3;
}
function B2(t3, o4, n5) {
  return n3(G, n5), o3(o4, t3, G), T(G) && d(o4, o4, 4), o4;
}
function R(r3, o4, e3, n5) {
  const i3 = 0 === o4;
  return _(r3, o4, e3, (r4, o5) => {
    const e4 = Math.cos(s(r4));
    o5[0] = i3 ? e4 : 1 / e4, o5[1] = 1;
  }, n5);
}
function $(r3, t3, o4, e3) {
  const n5 = 0 === t3;
  return _(r3, t3, o4, (r4, t4) => {
    const o5 = Math.cosh(-r4 / t.radius);
    t4[0] = 1, t4[1] = n5 ? o5 : 1 / o5;
  }, e3);
}
function _(r3, t3, o4, e3, n5) {
  const i3 = 0 === t3 ? 3 : 4, f3 = [0, 0];
  for (let c4 = 0, s2 = 1; c4 < r3.length; c4 += i3, s2 += 3) {
    e3(o4[s2], f3);
    const t4 = r3[c4] * f3[0], a4 = r3[c4 + 1] * f3[1], m = r3[c4 + 2], u = 1 / Math.sqrt(t4 * t4 + a4 * a4 + m * m);
    n5[c4] = t4 * u, n5[c4 + 1] = a4 * u, n5[c4 + 2] = m * u, 4 === i3 && (n5[c4 + 3] = r3[c4 + 3]);
  }
  return n5;
}
function F(r3, t3, o4, e3, n5, i3) {
  if (!U3(0, o2.fromTypedArray(r3, 4 * Float32Array.BYTES_PER_ELEMENT), 1, U2.fromTypedArray(t3), o4, U2.fromTypedArray(e3), n5, o2.fromTypedArray(i3, 4 * Float32Array.BYTES_PER_ELEMENT))) return null;
  for (let f3 = 3; f3 < r3.length; f3 += 4) i3[f3] = r3[f3];
  return i3;
}
function P3(r3, t3, o4, e3, n5, i3) {
  if (!U3(1, o2.fromTypedArray(r3, 16), 1, U2.fromTypedArray(t3), o4, U2.fromTypedArray(e3), n5, o2.fromTypedArray(i3, 16))) return null;
  for (let f3 = 3; f3 < r3.length; f3 += 4) i3[f3] = r3[f3];
  return i3;
}
function S(r3, t3, n5, f3, c4) {
  switch (f2(f3, n5, q, f3), 1 === r3 && h2(q, q), t3) {
    case 0:
      return j(c4, q);
    case 1:
      return n3(c4, q);
  }
}
function U3(r3, t3, o4, e3, n5, i3, f3, a4) {
  if (!t3) return;
  const m = e3.count;
  if (L(n5)) for (let s2 = 0; s2 < m; s2++) i3.getVec(s2, N3), t3.getVec(s2, Y), N2(Y, Y, S(r3, o4, N3, f3, G)), a4.setVec(s2, Y);
  else for (let u = 0; u < m; u++) {
    i3.getVec(u, N3), t3.getVec(u, Y);
    const n6 = h(e3.get(u, 1));
    let m2 = Math.cos(n6);
    1 === o4 != (0 === r3) && (m2 = 1 / m2), S(r3, o4, N3, f3, G), 0 === r3 ? (G[0] *= m2, G[1] *= m2, G[2] *= m2, G[3] *= m2, G[4] *= m2, G[5] *= m2) : (G[0] *= m2, G[3] *= m2, G[6] *= m2, G[1] *= m2, G[4] *= m2, G[7] *= m2), N2(Y, Y, G), A(Y, Y), a4.setVec(u, Y);
  }
  return a4;
}
function L(r3) {
  return r3.isWGS84 || w(r3) || D(r3) || U(r3);
}
var N3 = n();
var Y = n();
var q = e2();
var G = e();

// node_modules/@arcgis/core/geometry/support/meshUtils/vertexSpaceConversion.js
var O = () => i.getLogger("esri.geometry.support.meshUtils.vertexSpaceConversion");
function P4(t3, n5, { vertexSpace: r3, spatialReference: e3 }) {
  if ("georeferenced" === r3.type) {
    const o5 = t3;
    if (!i2(n5, o5, e3)) return false;
    const { origin: i4 } = r3;
    return c2(t3, o5, i4), true;
  }
  const o4 = a(e3), i3 = t3;
  if (!i2(n5, i3, o4)) return false;
  const { origin: l } = r3, a4 = lt;
  if (!f2(e3, l, a4, o4)) return false;
  const c4 = h2(lt, a4);
  return null != c4 && (E(t3, i3, c4), true);
}
function q2(t3, n5, r3) {
  const { vertexSpace: e3, transform: o4, vertexAttributes: i3 } = t3, a4 = t2(e3) ? o4 : null, s2 = Y2(t3.spatialReference, r3, 3);
  if (a2(e3, n5) && (!a4 || B(a4.localMatrix, r)) && Z(s2)) {
    const { position: t4, normal: n6, tangent: e4 } = i3, o5 = r3?.allowBufferReuse;
    return { position: o5 ? t4 : t4.slice(), normal: o5 ? n6 : n6?.slice(), tangent: o5 ? e4 : e4?.slice() };
  }
  switch (t3.vertexSpace.type) {
    case "local":
      return "local" === n5.type ? J(t3, t3.vertexSpace, n5.origin, r3) : G2(t3, t3.vertexSpace, n5.origin, r3);
    case "georeferenced":
      return "local" === n5.type ? H(t3, t3.vertexSpace, n5.origin, r3) : z(t3, t3.vertexSpace, n5.origin, r3);
  }
}
function z({ vertexAttributes: t3, transform: n5, spatialReference: r3 }, { origin: e3 }, o4, i3) {
  const l = Y2(r3, i3, 3), a4 = e3 || !Z(l) ? n2(rt, n5?.localMatrix ?? r) : null;
  a4 && X(a4, r3, i3, 3);
  const { position: s2, normal: u, tangent: f3 } = a4 ? K(t3, a4) : t3, g = i3?.allowBufferReuse, x2 = g ? s2 : new Float64Array(s2.length);
  let h3 = s2;
  if (e3 && (h3 = a3(x2, h3, e3)), o4) {
    const t4 = y(it, o4);
    h3 = a3(x2, h3, t4);
  }
  return { position: h3 !== t3.position || g ? h3 : h3.slice(), normal: u !== t3.normal || g ? u : u?.slice(), tangent: f3 !== t3.tangent || g ? f3 : f3?.slice() };
}
function D2(t3, n5) {
  return n5?.useEllipsoid && P(t3) ? c3 : a(t3);
}
function G2({ spatialReference: t3, vertexAttributes: n5, transform: r3 }, { origin: e3 }, o4, i3) {
  const l = D2(t3, i3);
  if (!f2(t3, e3, rt, l)) return k(O(), t3, l), null;
  r3 && c(rt, rt, r3.localMatrix), X(rt, t3, i3, 1);
  const a4 = new Float64Array(n5.position.length), s2 = N4(n5.position, rt, t3, a4, l);
  if (!s2) return null;
  const c4 = Q(s2, t3, a4, l, n5.normal, rt);
  if (n5.normal && !c4) return null;
  const f3 = W(s2, t3, a4, l, n5.tangent, rt);
  if (n5.tangent && !f3) return null;
  if (o4) {
    const t4 = y(it, o4);
    a3(s2, s2, t4);
  }
  return { position: s2, normal: c4, tangent: f3 };
}
function H({ vertexAttributes: t3, spatialReference: n5, transform: r3 }, { origin: e3 }, i3, l) {
  const c4 = D2(n5, l);
  if (!f2(n5, i3, rt, c4)) return k(O(), n5, c4), null;
  const u = 1 / Y2(n5, l, 2);
  f(rt, rt, [u, u, u]);
  const f3 = h2(et, rt), { position: m, normal: p, tangent: g } = I(t3, e3, r3), x2 = new Float64Array(m.length), h3 = $2(m, n5, f3, x2, c4);
  if (!h3) return null;
  const v2 = j(ot, f3), j2 = _2(p, m, n5, x2, c4, v2, p !== t3.normal ? p : void 0);
  if (!j2 && p) return null;
  const w3 = tt(g, m, n5, x2, c4, v2, g !== t3.tangent ? g : void 0);
  return !w3 && g ? null : { position: h3, normal: j2, tangent: w3 };
}
function I(t3, n5, r3) {
  if (!n5) return t3;
  if (!r3) {
    const { position: r4, normal: e4, tangent: o4 } = t3;
    return { position: a3(new Float64Array(r4.length), r4, n5), tangent: o4, normal: e4 };
  }
  const e3 = K(t3, r3.localMatrix);
  return a3(e3.position, e3.position, n5), e3;
}
function J({ vertexAttributes: t3, spatialReference: n5, transform: r3 }, { origin: e3 }, o4, i3) {
  const l = D2(n5, i3);
  if (!f2(n5, e3, rt, l)) return k(O(), n5, l), null;
  if (r3 && c(rt, rt, r3.localMatrix), !f2(n5, o4, et, l)) return k(O(), l, n5), null;
  h2(et, et);
  const a4 = c(rt, et, rt);
  return X(a4, n5, i3, 3), K(t3, a4);
}
function K(t3, n5) {
  const r3 = new Float64Array(t3.position.length);
  r2(r3, t3.position, n5);
  const e3 = t3.normal ? new Float32Array(t3.normal.length) : null, o4 = t3.tangent ? new Float32Array(t3.tangent.length) : null;
  return e3 && t3.normal && v(t3.normal, e3, n5), o4 && t3.tangent && B2(t3.tangent, o4, n5), { position: r3, normal: e3, tangent: o4 };
}
function N4(t3, n5, r3, e3, o4) {
  r2(e3, t3, n5);
  const i3 = new Float64Array(t3.length);
  return x(e3, o4, i3, r3) ? i3 : (k(O(), o4, r3), null);
}
function Q(t3, n5, r3, e3, o4, i3) {
  if (null == o4) return null;
  const l = new Float32Array(o4.length);
  return v(o4, l, i3), M(l, t3, n5, r3, e3, l) ? l : (k(O(), e3, n5), null);
}
function W(t3, n5, r3, e3, o4, i3) {
  if (null == o4) return null;
  const l = new Float32Array(o4.length);
  return B2(o4, l, i3), P3(l, t3, n5, r3, e3, l) ? l : (k(O(), e3, n5), null);
}
function X(t3, n5, r3, e3) {
  const o4 = Y2(n5, r3, e3);
  Z(o4) || f(t3, t3, [o4, o4, o4]);
}
function Y2(t3, n5, r3) {
  const e3 = !!(1 & r3), o4 = !!(2 & r3), i3 = n5?.sourceUnit, l = n5?.targetUnit;
  if (!i3 && !l) return 1;
  let a4 = nt(i3, t3);
  e3 || !i3 || Z(a4) || (O().warn("source unit conversion not supported"), a4 = 1);
  let s2 = 1 / nt(l, t3);
  return o4 || !l || Z(s2) || (O().warn("target unit conversion not supported"), s2 = 1), a4 * s2;
}
function Z(t3) {
  return P2(t3, 1);
}
function $2(t3, n5, r3, e3, o4) {
  const i3 = V(t3, n5, e3, o4);
  if (!i3) return k(O(), n5, o4), null;
  const l = new Float64Array(i3.length);
  return r2(l, i3, r3), l;
}
function _2(t3, n5, r3, e3, o4, i3, l) {
  if (null == t3) return null;
  const a4 = l ?? new Float32Array(t3.length);
  return w2(t3, n5, r3, e3, o4, a4) ? (n4(a4, a4, i3), a4) : (k(O(), r3, o4), null);
}
function tt(t3, n5, r3, e3, o4, i3, l) {
  if (null == t3) return null;
  const a4 = l ?? new Float32Array(t3.length);
  return F(t3, n5, r3, e3, o4, a4) ? (n4(a4, a4, i3, 4), a4) : (k(O(), r3, o4), null);
}
function nt(t3, n5) {
  if (null == t3) return 1;
  const o4 = ce(n5);
  return 1 / N(o4, "meters", t3);
}
var rt = e2();
var et = e2();
var ot = e();
var it = n();
var lt = e2();

export {
  b,
  k,
  w2 as w,
  M,
  V,
  x,
  v,
  B2 as B,
  R,
  $,
  F,
  P3 as P,
  P4 as P2,
  q2 as q,
  nt
};
//# sourceMappingURL=chunk-274P3DJ3.js.map
