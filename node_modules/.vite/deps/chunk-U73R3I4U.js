import {
  Ie,
  be,
  e2 as e,
  we
} from "./chunk-MC6NAKKX.js";
import {
  F,
  N,
  P,
  W,
  b,
  x
} from "./chunk-DDOCCRD4.js";
import {
  h,
  n
} from "./chunk-THQO67BJ.js";

// node_modules/@arcgis/core/smartMapping/support/utils.js
var c = ",";
var v = { years: 365, months: 30, days: 1, hours: 1 / 24, minutes: 1 / 1440, seconds: 1 / 86400, milliseconds: 1 / 864e5 };
var T = /* @__PURE__ */ new Set(["integer", "small-integer"]);
var Z = null;
function U(t) {
  return Ie(t) || be(t) || we(t);
}
async function w(t) {
  const { field: e2, field2: n2, field3: o, normalizationField: r, valueExpression: i, fields: s } = t;
  let a = [];
  if (i) {
    if (!Z) {
      const { arcadeUtils: t2 } = await e();
      Z = t2;
    }
    a = Z.extractFieldNames(i);
  }
  return e2 && a.push(e2), n2 && a.push(n2), o && a.push(o), r && a.push(r), s && a.push(...s), a;
}
function S(t) {
  return String(t).padStart(2, "0");
}
function k(t, e2, n2) {
  let o;
  if ("date" === e2 || "number" === e2) {
    "number" === e2 && (t = new Date(t));
    o = `TIMESTAMP'${n2 ? t.getFullYear() : t.getUTCFullYear()}-${S((n2 ? t.getMonth() : t.getUTCMonth()) + 1)}-${S(n2 ? t.getDate() : t.getUTCDate())} ${S(n2 ? t.getHours() : t.getUTCHours())}:${S(n2 ? t.getMinutes() : t.getUTCMinutes())}:${S(n2 ? t.getSeconds() : t.getUTCSeconds())}'`;
  } else o = t;
  return o;
}
function C(t, e2, n2, o) {
  const { hasQueryEngine: r } = t, i = `(${k(n2, D(t, n2), r)} - ${k(e2, D(t, e2), r)})`;
  let s = v[o], a = "/";
  s < 1 && (s = 1 / s, a = "*");
  return { sqlExpression: 1 === s ? i : `(${i} ${a} ${s})`, sqlWhere: null };
}
function D(t, e2) {
  if (e2 instanceof Date) return "date";
  if ("number" == typeof e2) return "number";
  if ("string" == typeof e2) {
    const n2 = t.getField(e2);
    if ("<now>" === e2.toLowerCase()) return;
    if (Ie(n2)) return "field";
  }
}
function M(t, e2) {
  const n2 = e2 && t.getField(e2);
  return !!n2 && T.has(n2.type);
}
function N2(t) {
  return `cast(${t} as float)`;
}
function x2(s, a) {
  const { format: l, fieldFormat: u, timeZoneOptions: d, fieldType: c2 } = a ?? {}, p = u ? F(u) : null;
  let g, y;
  if (d && ({ timeZone: g, timeZoneName: y } = h(d.layerTimeZone, d.datesInUnknownTimezone, d.viewTimeZone, p || N(l || "short-date-short-time"), c2)), "string" == typeof s && isNaN(Date.parse("time-only" === c2 ? `1970-01-01T${s}Z` : s))) return s;
  switch (c2) {
    case "date-only": {
      const t = p || N(l || "short-date");
      return "string" == typeof s ? x(s, { ...t }) : b(s, { ...t, timeZone: n });
    }
    case "time-only": {
      const t = p || N(l || "short-time");
      return "string" == typeof s ? P(s, t) : b(s, { ...t, timeZone: n });
    }
    case "timestamp-offset": {
      if (!g && "string" == typeof s && new Date(s).toISOString() !== s) return s;
      const t = l || p || d ? p || N(l || "short-date-short-time") : void 0, r = t ? { ...t, timeZone: g, timeZoneName: y } : void 0;
      return "string" == typeof s ? W(s, r) : b(s, r);
    }
    default: {
      const t = l || p || d ? p || N(l || "short-date-short-time") : void 0;
      return b("string" == typeof s ? new Date(s) : s, t ? { ...t, timeZone: g, timeZoneName: y } : void 0);
    }
  }
}

export {
  c,
  U,
  w,
  C,
  M,
  N2 as N,
  x2 as x
};
//# sourceMappingURL=chunk-U73R3I4U.js.map
