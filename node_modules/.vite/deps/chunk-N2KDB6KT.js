import {
  E,
  I as I2,
  N as N2
} from "./chunk-2W3LGFFY.js";
import {
  d
} from "./chunk-5BM4D5UD.js";
import {
  u
} from "./chunk-DUZAVZR4.js";
import {
  Z
} from "./chunk-2HGIYEIL.js";
import {
  ft,
  lt,
  ut
} from "./chunk-XX3OKYJS.js";
import {
  e
} from "./chunk-OTCNIJ2H.js";
import {
  i as i2
} from "./chunk-AQFRVV3U.js";
import {
  n
} from "./chunk-THQO67BJ.js";
import {
  y
} from "./chunk-AXZMNHTN.js";
import {
  f
} from "./chunk-5T3MJDSR.js";
import {
  N
} from "./chunk-NMQNUPE4.js";
import {
  Bt,
  H2 as H,
  I,
  _
} from "./chunk-V2H77UEV.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/layers/ogc/ogcFeatureUtils.js
var F = () => i.getLogger("esri.layers.ogc.ogcFeatureUtils");
var I3 = "startindex";
var T = /* @__PURE__ */ new Set([I3, "offset"]);
var k = "http://www.opengis.net/def/crs/";
var x = `${k}OGC/1.3/CRS84`;
async function S(n2, o, a = {}, s2 = 5) {
  const { links: l } = n2, c = L(l, "items", "application/geo+json") || L(l, "http://www.opengis.net/def/rel/ogc/1.0/items", "application/geo+json");
  if (null == c) throw new s("ogc-feature-layer:missing-items-page", "Missing items url");
  const { apiKey: u2, customParameters: d2, signal: p } = a, g = _(c.href, n2.landingPage.url), w = { limit: s2, ...d2, token: u2 }, T2 = Bt(g, w), k2 = { accept: "application/geo+json" }, { data: x2 } = await H(T2, { signal: p, headers: k2 }), S2 = U(T2, s2, x2.links) ?? I3;
  E(x2);
  const v2 = I2(x2, { geometryType: o.geometryType }), O2 = o.fields || v2.fields || [], P2 = null != o.hasZ ? o.hasZ : v2.hasZ, q2 = v2.geometryType, N4 = o.objectIdField || v2.objectIdFieldName || "OBJECTID";
  let C2 = o.timeInfo;
  const R2 = O2.find(({ name: e2 }) => e2 === N4);
  if (R2) R2.editable = false, R2.nullable = false;
  else {
    if (!v2.objectIdFieldType) throw new s("ogc-feature-layer:missing-feature-id", "Collection geojson require a feature id as a unique identifier");
    O2.unshift({ name: N4, alias: N4, type: "number" === v2.objectIdFieldType ? "esriFieldTypeOID" : "esriFieldTypeString", editable: false, nullable: false });
  }
  if (N4 !== v2.objectIdFieldName) {
    const e2 = O2.find(({ name: e3 }) => e3 === v2.objectIdFieldName);
    e2 && (e2.type = "esriFieldTypeInteger");
  }
  O2 === v2.fields && v2.unknownFields.length > 0 && F().warn({ name: "ogc-feature-layer:unknown-field-types", message: "Some fields types couldn't be inferred from the features and were dropped", details: { unknownFields: v2.unknownFields } });
  for (const e2 of O2) {
    if (null == e2.name && (e2.name = e2.alias), null == e2.alias && (e2.alias = e2.name), "esriFieldTypeOID" !== e2.type && "esriFieldTypeGlobalID" !== e2.type && (e2.editable = null == e2.editable || !!e2.editable, e2.nullable = null == e2.nullable || !!e2.nullable), !e2.name) throw new s("ogc-feature-layer:invalid-field-name", "field name is missing", { field: e2 });
    if (!i2.jsonValues.includes(e2.type)) throw new s("ogc-feature-layer:invalid-field-type", `invalid type for field "${e2.name}"`, { field: e2 });
  }
  if (C2) {
    const e2 = new Z(O2);
    if (C2.startTimeField) {
      const t = e2.get(C2.startTimeField);
      t ? (C2.startTimeField = t.name, t.type = "esriFieldTypeDate") : C2.startTimeField = null;
    }
    if (C2.endTimeField) {
      const t = e2.get(C2.endTimeField);
      t ? (C2.endTimeField = t.name, t.type = "esriFieldTypeDate") : C2.endTimeField = null;
    }
    if (C2.trackIdField) {
      const t = e2.get(C2.trackIdField);
      t ? C2.trackIdField = t.name : (C2.trackIdField = null, F().warn({ name: "ogc-feature-layer:invalid-timeInfo-trackIdField", message: "trackIdField is missing", details: { timeInfo: C2 } }));
    }
    C2.timeReference ||= { timeZoneIANA: n }, C2.startTimeField || C2.endTimeField || (F().warn({ name: "ogc-feature-layer:invalid-timeInfo", message: "startTimeField and endTimeField are missing", details: { timeInfo: C2 } }), C2 = void 0);
  }
  return { drawingInfo: q2 ? u(q2) : null, extent: K(n2), geometryType: q2, fields: O2, hasZ: !!P2, objectIdField: N4, paginationParameter: S2, timeInfo: C2 };
}
async function v(n2, r = {}) {
  const { links: o, url: a } = n2, s2 = L(o, "data", "application/json") || L(o, "http://www.opengis.net/def/rel/ogc/1.0/data", "application/json");
  if (null == s2) throw new s("ogc-feature-layer:missing-collections-page", "Missing collections url");
  const { apiKey: l, customParameters: c, signal: u2 } = r, d2 = _(s2.href, a), { data: p } = await H(d2, { signal: u2, headers: { accept: "application/json" }, query: { ...c, token: l } });
  for (const e2 of p.collections) e2.landingPage = n2;
  return p;
}
async function O(n2, r = {}) {
  const { links: o, url: a } = n2, s2 = L(o, "conformance", "application/json") || L(o, "http://www.opengis.net/def/rel/ogc/1.0/conformance", "application/json");
  if (null == s2) throw new s("ogc-feature-layer:missing-conformance-page", "Missing conformance url");
  const { apiKey: l, customParameters: c, signal: u2 } = r, d2 = _(s2.href, a), { data: p } = await H(d2, { signal: u2, headers: { accept: "application/json" }, query: { ...c, token: l } });
  return p;
}
async function P(t, n2 = {}) {
  const { apiKey: i3, customParameters: r, signal: o } = n2, { data: a } = await H(t, { signal: o, headers: { accept: "application/json" }, query: { ...r, token: i3 } });
  return a.url = t, a;
}
async function q(t, n2 = {}) {
  const { links: r, url: o } = t, a = L(r, "service-desc", "application/vnd.oai.openapi+json;version=3.0");
  if (null == a) return F().warn("ogc-feature-layer:missing-openapi-page", "The OGC API-Features server does not have an OpenAPI page."), null;
  const { apiKey: s2, customParameters: l, signal: c } = n2, u2 = _(a.href, o), { data: d2 } = await H(u2, { signal: c, headers: { accept: "application/vnd.oai.openapi+json;version=3.0" }, query: { ...l, token: s2 } });
  return d2;
}
function N3(e2) {
  const t = /^http:\/\/www\.opengis.net\/def\/crs\/(?<authority>.*)\/(?<version>.*)\/(?<code>.*)$/i.exec(e2), n2 = t?.groups;
  if (!n2) return null;
  const { authority: i3, code: r } = n2;
  switch (i3.toLowerCase()) {
    case "ogc":
      switch (r.toLowerCase()) {
        case "crs27":
          return f.GCS_NAD_1927.wkid;
        case "crs83":
          return 4269;
        case "crs84":
        case "crs84h":
          return f.WGS84.wkid;
        default:
          return null;
      }
    case "esri":
    case "epsg": {
      const e3 = Number.parseInt(r, 10);
      return Number.isNaN(e3) ? null : e3;
    }
    default:
      return null;
  }
}
async function C(e2, t, n2) {
  const i3 = await R(e2, t, n2);
  return ft(i3);
}
async function R(n2, r, o) {
  const { collection: { links: c, landingPage: { url: f2 } }, layerDefinition: m, maxRecordCount: y2, queryParameters: { apiKey: b, customParameters: j }, spatialReference: F2, supportedCrs: I4 } = n2, T2 = L(c, "items", "application/geo+json") || L(c, "http://www.opengis.net/def/rel/ogc/1.0/items", "application/geo+json");
  if (!T2) throw new s("ogc-feature-layer:missing-items-page", "Missing items url");
  const { geometry: k2, num: x2, start: S2, timeExtent: v2, where: O2 } = r;
  if (r.objectIds) throw new s("ogc-feature-layer:query-by-objectids-not-supported", "Queries with object ids are not supported");
  const P2 = f.fromJSON(F2), q2 = r.outSpatialReference ?? P2, N4 = q2.isWGS84 ? null : $(q2, I4), C2 = Z2(k2, I4), R2 = D(v2), W2 = M(O2), G2 = x2 ?? (null == S2 ? y2 : 10), K2 = 0 === S2 ? void 0 : S2, { fields: U2, geometryType: A, hasZ: J, objectIdField: z, paginationParameter: E2 } = m, _2 = _(T2.href, f2), { data: B } = await H(_2, { ...o, query: { ...j, ...C2, crs: N4, datetime: R2, query: W2, limit: G2, [E2]: K2, token: b }, headers: { accept: "application/geo+json" } }), Q = N2(B, { geometryType: A, hasZ: J, objectIdField: z }), V = Q.length === G2 && !!L(B.links ?? [], "next", "application/geo+json"), H2 = new Z(U2);
  for (const e2 of Q) {
    const t = {};
    d(H2, t, e2.attributes, true);
    for (const e3 of H2.fields) e3.nullable && !(e3.name in t) && (t[e3.name] = null);
    t[z] = e2.attributes[z], e2.attributes = t;
  }
  if (!N4 && q2.isWebMercator) {
    for (const e2 of Q) if (null != e2.geometry && null != A) {
      const t = lt(e2.geometry, A, J, false);
      t.spatialReference = f.WGS84, e2.geometry = ut(y(t, q2));
    }
  }
  for (const e2 of Q) e2.objectId = e2.attributes[z];
  const X = N4 || !N4 && q2.isWebMercator ? q2.toJSON() : N, Y = new e();
  return Y.exceededTransferLimit = V, Y.features = Q, Y.fields = U2, Y.geometryType = A, Y.hasZ = J, Y.spatialReference = X, Y;
}
function W(e2) {
  return null != e2 && "extent" === e2.type;
}
function $(e2, t) {
  const { isWebMercator: n2, wkid: i3, latestWkid: r } = e2;
  if (!i3 && !r) return null;
  const o = n2 ? t[3857] ?? t[102100] ?? t[102113] ?? t[900913] : i3 && t[i3] || r && t[r];
  return o ? `${k}${o}` : null;
}
function G(e2) {
  if (!e2) return "";
  const { xmin: t, ymin: n2, xmax: i3, ymax: r } = e2;
  return `${t},${n2},${i3},${r}`;
}
function D(e2) {
  if (!e2) return null;
  const { start: t, end: n2 } = e2;
  return `${null != t ? t.toISOString() : ".."}/${null != n2 ? n2.toISOString() : ".."}`;
}
function M(e2) {
  return e2 && "1=1" !== e2 ? e2 : null;
}
function Z2(e2, t) {
  if (!W(e2)) return null;
  const { spatialReference: n2 } = e2;
  if (!n2 || n2.isWGS84) return { bbox: G(e2) };
  const i3 = $(n2, t);
  return null != i3 ? { bbox: G(e2), "bbox-crs": i3 } : n2.isWebMercator ? { bbox: G(y(e2, f.WGS84)) } : null;
}
function K(e2) {
  const t = e2.extent?.spatial;
  if (!t) return null;
  const n2 = t.bbox[0], i3 = 4 === n2.length, [r, o] = n2, s2 = i3 ? void 0 : n2[2];
  return { xmin: r, ymin: o, xmax: i3 ? n2[2] : n2[3], ymax: i3 ? n2[3] : n2[4], zmin: s2, zmax: i3 ? void 0 : n2[5], spatialReference: f.WGS84.toJSON() };
}
function L(e2, t, n2) {
  return e2.find(({ rel: e3, type: i3 }) => e3 === t && i3 === n2) ?? e2.find(({ rel: e3, type: n3 }) => e3 === t && !n3);
}
function U(e2, t, n2) {
  if (!n2) return;
  const i3 = L(n2, "next", "application/geo+json"), r = I(i3?.href)?.query;
  if (!r) return;
  const a = I(e2).query, s2 = Object.keys(a ?? {}), l = Object.entries(r).filter(([e3]) => !s2.includes(e3)).find(([e3, n3]) => T.has(e3.toLowerCase()) && Number.parseInt(n3, 10) === t), c = l?.[0];
  return c;
}

export {
  k,
  x,
  S,
  v,
  O,
  P,
  q,
  N3 as N,
  C,
  R
};
//# sourceMappingURL=chunk-N2KDB6KT.js.map
