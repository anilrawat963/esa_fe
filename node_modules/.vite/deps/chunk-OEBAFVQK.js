import {
  m
} from "./chunk-63LDVRFI.js";
import {
  _
} from "./chunk-C3FRY5U4.js";
import {
  u
} from "./chunk-CCQFL76O.js";
import {
  i3 as i
} from "./chunk-QY7XKUIV.js";
import {
  n
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/renderers/visualVariables/support/sizeVariableUtils.js
function n2(n3) {
  return n3 && "esri.renderers.visualVariables.SizeVariable" === n3.declaredClass;
}
function e(n3) {
  return null != n3 && !isNaN(n3) && isFinite(n3);
}
function i2(n3) {
  return n3.valueExpression ? "expression" : n3.field && "string" == typeof n3.field ? "field" : "unknown";
}
function l(n3, e2) {
  const l2 = e2 || i2(n3), a = n3.valueUnit || "unknown";
  return "unknown" === l2 ? "constant" : n3.stops ? "stops" : null != n3.minSize && null != n3.maxSize && null != n3.minDataValue && null != n3.maxDataValue ? "clamped-linear" : "unknown" === a ? null != n3.minSize && null != n3.minDataValue ? n3.minSize && n3.minDataValue ? "proportional" : "additive" : "identity" : "real-world-size";
}

// node_modules/@arcgis/core/renderers/visualVariables/support/visualVariableUtils.js
var s = () => i.getLogger("esri.renderers.visualVariables.support.visualVariableUtils");
var o = (e2) => s().warn(`The visualVariable should be an instance of esri.renderers.visualVariables.${e2}`);
var c = () => s().error("Use of arcade expressions requires an arcade context");
var u2 = new _();
var f = Math.PI;
var p = /^\s*(return\s+)?\$view\.scale\s*(;)?\s*$/i;
function d(n3, i3, t) {
  const a = "visualVariables" in n3 ? n3.visualVariables?.find((e2) => "color" === e2.type) : n3;
  if (!a) return;
  if ("esri.renderers.visualVariables.ColorVariable" !== a.declaredClass) return void o("ColorVariable");
  const l2 = "number" == typeof i3, s2 = l2 ? null : i3, u3 = s2?.attributes;
  let f2 = l2 ? i3 : null;
  const p2 = a.field, { ipData: d2, hasExpression: v2 } = a.cache;
  let m3 = a.cache.compiledFunc;
  if (!p2 && !v2) {
    const e2 = a.stops;
    return e2 && e2[0] && e2[0].color;
  }
  if ("number" != typeof f2) if (v2) {
    if (null == t?.arcade) return void c();
    const e2 = { viewingMode: t.viewingMode, scale: t.scale, spatialReference: t.spatialReference }, n4 = t.arcade.arcadeUtils, i4 = n4.getViewInfo(e2), r = n4.createExecContext(s2, i4, t.timeZone);
    if (!m3) {
      const e3 = n4.createSyntaxTree(a.valueExpression);
      m3 = n4.createFunction(e3), a.cache.compiledFunc = m3;
    }
    f2 = n4.executeFunction(m3, r);
  } else u3 && (f2 = u3[p2]);
  const h2 = a.normalizationField, b2 = null != u3 && null != h2 ? parseFloat(u3[h2]) : void 0;
  if (null != f2 && (!h2 || l2 || !isNaN(b2) && 0 !== b2)) {
    e(b2) && !l2 && (f2 /= b2);
    const n4 = R(f2, d2);
    if (n4) {
      const i4 = n4[0], r = n4[1], l3 = i4 === r ? a.stops[i4].color : u.blendColors(a.stops[i4].color, a.stops[r].color, n4[2], null != t ? t.color : void 0);
      return new u(l3);
    }
  }
}
function v(e2, n3, i3) {
  const t = "visualVariables" in e2 ? e2.visualVariables?.find((e3) => "opacity" === e3.type) : e2;
  if (!t) return;
  if ("esri.renderers.visualVariables.OpacityVariable" !== t.declaredClass) return void o("OpacityVariable");
  const a = "number" == typeof n3, l2 = a ? null : n3, s2 = l2?.attributes;
  let u3 = a ? n3 : null;
  const f2 = t.field, { ipData: p2, hasExpression: d2 } = t.cache;
  let v2 = t.cache.compiledFunc;
  if (!f2 && !d2) {
    const e3 = t.stops;
    return e3 && e3[0] && e3[0].opacity;
  }
  if ("number" != typeof u3) if (d2) {
    if (null == i3?.arcade) return void c();
    const e3 = { viewingMode: i3.viewingMode, scale: i3.scale, spatialReference: i3.spatialReference }, n4 = i3.arcade.arcadeUtils, a2 = n4.getViewInfo(e3), r = n4.createExecContext(l2, a2, i3.timeZone);
    if (!v2) {
      const e4 = n4.createSyntaxTree(t.valueExpression);
      v2 = n4.createFunction(e4), t.cache.compiledFunc = v2;
    }
    u3 = n4.executeFunction(v2, r);
  } else s2 && (u3 = s2[f2]);
  const m3 = t.normalizationField, h2 = null != s2 && null != m3 ? parseFloat(s2[m3]) : void 0;
  if (null != u3 && (!m3 || a || !isNaN(h2) && 0 !== h2)) {
    e(h2) && !a && (u3 /= h2);
    const e3 = R(u3, p2);
    if (e3) {
      const n4 = e3[0], i4 = e3[1];
      if (n4 === i4) return t.stops[n4].opacity;
      {
        const a2 = t.stops[n4].opacity;
        return a2 + (t.stops[i4].opacity - a2) * e3[2];
      }
    }
  }
}
function m2(e2, n3, i3) {
  const t = "visualVariables" in e2 ? e2.visualVariables?.find((e3) => "rotation" === e3.type) : e2;
  if (!t) return;
  if ("esri.renderers.visualVariables.RotationVariable" !== t.declaredClass) return void o("RotationVariable");
  const a = t.axis || "heading", r = "heading" === a && "arithmetic" === t.rotationType ? 90 : 0, l2 = "heading" === a && "arithmetic" === t.rotationType ? -1 : 1, s2 = "number" == typeof n3 ? null : n3, u3 = s2?.attributes, f2 = t.field, { hasExpression: p2 } = t.cache;
  let d2 = t.cache.compiledFunc, v2 = null;
  if (!f2 && !p2) return v2;
  if (p2) {
    if (null == i3?.arcade) return void c();
    const e3 = { viewingMode: i3.viewingMode, scale: i3.scale, spatialReference: i3.spatialReference }, n4 = i3.arcade.arcadeUtils, a2 = n4.getViewInfo(e3), r2 = n4.createExecContext(s2, a2, i3.timeZone);
    if (!d2) {
      const e4 = n4.createSyntaxTree(t.valueExpression);
      d2 = n4.createFunction(e4), t.cache.compiledFunc = d2;
    }
    v2 = n4.executeFunction(d2, r2);
  } else u3 && (v2 = u3[f2]);
  return v2 = "number" != typeof v2 || isNaN(v2) ? null : r + l2 * v2, v2;
}
function h(e2, n3, i3) {
  const t = "number" == typeof n3, a = t ? null : n3, l2 = a?.attributes;
  let s2 = t ? n3 : null;
  const { isScaleDriven: o2 } = e2.cache;
  let u3 = e2.cache.compiledFunc;
  if (o2) {
    const n4 = null != i3 ? i3.scale : void 0, t2 = null != i3 ? i3.view : void 0;
    s2 = null == n4 || "3d" === t2 ? b(e2) : n4;
  } else if (!t) switch (e2.inputValueType) {
    case "expression": {
      if (null == i3?.arcade) return void c();
      const n4 = { viewingMode: i3.viewingMode, scale: i3.scale, spatialReference: i3.spatialReference }, t2 = i3.arcade.arcadeUtils, r = t2.getViewInfo(n4), l3 = t2.createExecContext(a, r, i3.timeZone);
      if (!u3) {
        const n5 = t2.createSyntaxTree(e2.valueExpression);
        u3 = t2.createFunction(n5), e2.cache.compiledFunc = u3;
      }
      s2 = t2.executeFunction(u3, l3);
      break;
    }
    case "field":
      l2 && (s2 = l2[e2.field]);
      break;
    case "unknown":
      s2 = null;
  }
  if (!e(s2)) return null;
  if (t || !e2.normalizationField) return s2;
  const f2 = l2 ? parseFloat(l2[e2.normalizationField]) : null;
  return e(f2) && 0 !== f2 ? s2 / f2 : null;
}
function b(e2) {
  let n3 = null, i3 = null;
  const t = e2.stops;
  return t ? (n3 = t[0].value, i3 = t[t.length - 1].value) : (n3 = e2.minDataValue || 0, i3 = e2.maxDataValue || 0), (n3 + i3) / 2;
}
function V(e2, n3, i3) {
  const t = "visualVariables" in e2 ? e2.visualVariables?.find((e3) => "size" === e3.type) : e2;
  if (!t) return;
  if ("esri.renderers.visualVariables.SizeVariable" !== t.declaredClass) return void o("SizeVariable");
  const a = k(h(t, n3, i3), t, n3, i3, t.cache.ipData);
  return null == a || isNaN(a) ? void 0 : a;
}
function x(e2, n3, i3) {
  return null == e2 ? null : n2(e2) ? V(e2, n3, i3) : e(e2) ? e2 : null;
}
function y(e2, n3, i3) {
  return e(i3) && e2 > i3 ? i3 : e(n3) && e2 < n3 ? n3 : e2;
}
function w(e2, n3, i3, t) {
  const a = x(n3.minSize, i3, t) || n3.minDataValue;
  return null == e2 && null == a ? null : (e2 ?? 0) + (a ?? 0);
}
function g(e2, n3, i3) {
  const t = e2.stops;
  let a = t?.length && t[0].size;
  return null == a && (a = e2.minSize), x(a, n3, i3);
}
function z(e2, n3, i3, t) {
  const a = x(n3.minSize, i3, t);
  if (null == e2) return a;
  const { minDataValue: r, maxDataValue: l2 } = n3;
  if (null == r || null == l2) return null;
  const s2 = (e2 - r) / (l2 - r), o2 = x(n3.maxSize, i3, t), c2 = null != t ? t.shape : void 0;
  if (e2 <= r) return a;
  if (e2 >= l2) return o2;
  if (null == a || null == o2) return null;
  if ("area" === n3.scaleBy && c2) {
    const e3 = "circle" === c2, n4 = e3 ? f * (a / 2) ** 2 : a * a, i4 = n4 + s2 * ((e3 ? f * (o2 / 2) ** 2 : o2 * o2) - n4);
    return e3 ? 2 * Math.sqrt(i4 / f) : Math.sqrt(i4);
  }
  return a + s2 * (o2 - a);
}
function F(e2, n3, i3, t) {
  const a = x(n3.minSize, i3, t);
  if (null == e2 || null == a) return a;
  const r = null != t ? t.shape : void 0, { minDataValue: l2 } = n3;
  if (null == l2) return null;
  const s2 = e2 / l2, o2 = x(n3.maxSize, i3, t);
  let c2 = null;
  return c2 = "circle" === r ? 2 * Math.sqrt(s2 * (a / 2) ** 2) : "square" === r || "diamond" === r || "image" === r ? Math.sqrt(s2 * a ** 2) : s2 * a, y(c2, a, o2);
}
function S(e2, n3, i3, t, a) {
  if (null == e2) return null;
  const [r, l2, s2] = R(e2, a);
  if (r === l2) return x(n3.stops?.[r].size, i3, t);
  {
    const e3 = x(n3.stops?.[r].size, i3, t), a2 = x(n3.stops?.[l2].size, i3, t);
    return null == e3 || null == a2 ? null : e3 + (a2 - e3) * s2;
  }
}
function E(e2, n3, i3, t) {
  const r = (t?.resolution ?? 1) * m[n3.valueUnit], l2 = x(n3.minSize, i3, t), s2 = x(n3.maxSize, i3, t), { valueRepresentation: o2 } = n3;
  if (null == e2) return l2;
  let c2 = null;
  return c2 = "area" === o2 ? 2 * Math.sqrt(e2 / f) / r : "radius" === o2 || "distance" === o2 ? 2 * e2 / r : e2 / r, y(c2, l2, s2);
}
function M(e2) {
  return e2;
}
function k(e2, n3, i3, t, a) {
  switch (n3.transformationType) {
    case "additive":
      return w(e2, n3, i3, t);
    case "constant":
      return g(n3, i3, t);
    case "clamped-linear":
      return z(e2, n3, i3, t);
    case "proportional":
      return F(e2, n3, i3, t);
    case "stops":
      return S(e2, n3, i3, t, a);
    case "real-world-size":
      return E(e2, n3, i3, t);
    case "identity":
      return M(e2);
    case "unknown":
      return null;
  }
}
function C(e2, n3, i3) {
  const { isScaleDriven: t } = e2.cache;
  if (!(t && "3d" === i3 || n3)) return null;
  const a = { scale: n3, view: i3 };
  let r = x(e2.minSize, u2, a), l2 = x(e2.maxSize, u2, a);
  if (null != r || null != l2) {
    if (r > l2) {
      const e3 = l2;
      l2 = r, r = e3;
    }
    return { minSize: r, maxSize: l2 };
  }
}
function D(e2, n3, i3) {
  if (!e2.visualVariables) return;
  const t = [], a = [], r = [], l2 = [], s2 = [];
  for (const o2 of e2.visualVariables) switch (o2.type) {
    case "color":
      a.push(o2);
      break;
    case "opacity":
      r.push(o2);
      break;
    case "rotation":
      s2.push(o2);
      break;
    case "size":
      l2.push(o2);
  }
  return a.forEach((e3) => {
    const a2 = d(e3, n3, i3);
    t.push({ variable: e3, value: a2 });
  }), r.forEach((e3) => {
    const a2 = v(e3, n3, i3);
    t.push({ variable: e3, value: a2 });
  }), s2.forEach((e3) => {
    const a2 = m2(e3, n3, i3);
    t.push({ variable: e3, value: a2 });
  }), l2.forEach((e3) => {
    const a2 = V(e3, n3, i3);
    t.push({ variable: e3, value: a2 });
  }), t;
}
function R(e2, n3) {
  if (!n3) return;
  let i3 = 0, t = n3.length - 1;
  return n3.some((n4, a) => e2 < n4 ? (t = a, true) : (i3 = a, false)), [i3, t, (e2 - n3[i3]) / (n3[t] - n3[i3])];
}
function U(e2, n3, t) {
  const a = ["proportional", "proportional", "proportional"];
  for (const r of e2) {
    const e3 = r.useSymbolValue ? "symbol-value" : V(r, n3, t) ?? "proportional";
    switch (r.axis) {
      case "width":
        a[0] = e3;
        break;
      case "depth":
        a[1] = e3;
        break;
      case "height":
        a[2] = e3;
        break;
      case "width-and-depth":
        a[0] = e3, a[1] = e3;
        break;
      case "all":
      case void 0:
      case null:
        a[0] = e3, a[1] = e3, a[2] = e3;
        break;
      default:
        n(r.axis);
    }
  }
  return a;
}

export {
  n2 as n,
  i2 as i,
  l,
  p,
  d,
  v,
  m2 as m,
  V,
  x,
  k,
  C,
  D,
  U
};
//# sourceMappingURL=chunk-OEBAFVQK.js.map
