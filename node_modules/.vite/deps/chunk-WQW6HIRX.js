import {
  s
} from "./chunk-OJBEN6CV.js";
import {
  e2 as e,
  ke,
  ze
} from "./chunk-MC6NAKKX.js";
import {
  d
} from "./chunk-XL5QPCXN.js";
import {
  O
} from "./chunk-YDTPM7OQ.js";
import {
  b,
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  N
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/layers/support/TitleCreator.js
var p = "relationships/";
var u = "expression/";
var f = /<br\s*\/*>/gi;
var h = class extends b {
  constructor(e2) {
    super(e2), this._featureUtils = null, this.effectivePopupTemplate = null;
  }
  get _arcadeTask() {
    if (this.expressionsUsedInTitle.length > 0) {
      return this._get("_arcadeTask") || d(() => e());
    }
    return null;
  }
  get featureUtilsPromise() {
    return this._get("featureUtilsPromise") ?? import("./featureUtils-A7QFW4WK.js").then((e2) => this._featureUtils = e2);
  }
  get calculatedExpressions() {
    const e2 = new O();
    if (!this.expressionsUsedInTitle.length) return e2;
    if (!this._arcadeTask?.value) {
      for (const t of this.expressionsUsedInTitle ?? []) e2.push({ name: t.name, invalid: true });
      return e2;
    }
    for (const t of this.expressionsUsedInTitle) try {
      const s2 = this._arcadeTask.value.arcade.parseScript(t.expression, ["$layer", "$map", "$datastore"]);
      if (s2.isAsync) {
        e2.push({ name: t.name, invalid: true });
        break;
      }
      e2.push({ name: t.name, syntax: s2, invalid: false, func: this._arcadeTask.value.arcade.compileScript(s2, { vars: { $feature: "any" } }) });
    } catch {
      e2.push({ name: t.name, invalid: true });
      break;
    }
    return e2;
  }
  get expressionsUsedInTitle() {
    let e2 = this.effectivePopupTemplate?.title ?? "";
    return "string" != typeof e2 ? [] : (e2 = e2.toLowerCase(), this.effectivePopupTemplate?.expressionInfos?.filter((t) => e2.includes(`{expression/${t.name.toLowerCase()}}`)) ?? []);
  }
  get fieldInfoMap() {
    return this._featureUtils ? this._createFieldInfoMap(this._featureUtils.getAllFieldInfos(this.effectivePopupTemplate)) : null;
  }
  get hasBadExpressions() {
    return this.calculatedExpressions.some((e2) => true === e2.invalid);
  }
  get requiredFields() {
    const e2 = /* @__PURE__ */ new Set();
    if (this._arcadeTask?.value && !this.hasBadExpressions) for (const s2 of this.calculatedExpressions?.toArray() ?? []) try {
      const t2 = this._arcadeTask.value.arcade.extractFieldLiterals(s2.syntax);
      for (const s3 of t2) {
        const t3 = s3.split("."), i = this.fieldsIndex.get(t3.at(-1) ?? "");
        i && e2.add(i.name);
      }
    } catch {
    }
    const t = this._extractFieldNames(this.workingTitle);
    for (const s2 of t) {
      const t2 = this.fieldsIndex.get(s2);
      t2 && e2.add(t2.name);
    }
    return null != this.objectIdField && e2.add(this.objectIdField), e2;
  }
  get titleFromDisplayField() {
    let e2 = "";
    return this.displayField && (e2 = this.fieldsIndex.get(this.displayField)?.name ?? ""), e2 || (e2 = this.fieldsIndex.get(this.objectIdField)?.name ?? ""), e2 ? `{${e2}}` : "";
  }
  get workingTitle() {
    const e2 = this.effectivePopupTemplate ? this.effectivePopupTemplate.title : "";
    return "" === e2 || null == e2 || this.hasBadExpressions || "string" != typeof e2 ? this.titleFromDisplayField : e2;
  }
  async getTitle(e2, t, s2) {
    const i = t.getObjectId() ?? t.attributes[e2.objectIdField];
    return (await this.getTitles(e2, [t], s2)).get(i) ?? "";
  }
  async getTitles(e2, t, s2) {
    const i = /* @__PURE__ */ new Map(), r = s2?.timeZone ?? "system";
    try {
      const [{ substituteFieldsInLinksAndAttributes: o }] = await Promise.all([this.featureUtilsPromise, this._arcadeTask?.promise]);
      s2?.fetchMissingFields && (t = await this._checkAndReQueryGraphics(e2, t));
      const { fieldInfoMap: l, workingTitle: n } = this, c = n && l;
      t.forEach((t2) => {
        const d2 = t2.getObjectId() ?? t2.attributes[e2.objectIdField];
        let p2 = c ? o({ attributes: t2.attributes, expressionAttributes: null, fieldInfoMap: l, globalAttributes: this._createFormattedAttributes(e2, t2, r).global, layer: e2, text: n }) : "";
        s2?.removeHTML && (p2 = s.sanitize(p2).replaceAll(f, " ")), i.set(d2, p2);
      });
    } catch {
    }
    return i;
  }
  async _checkAndReQueryGraphics(e2, t) {
    const i = t.map((t2) => t2.getObjectId() ?? t2.attributes[e2.objectIdField]).filter(N);
    if (i.length !== t.length) return t;
    if (t.some((e3) => !ke(e3, this.requiredFields))) {
      const s2 = e2.createQuery();
      s2.where = "1=1", s2.outFields = [...this.requiredFields], s2.objectIds = i;
      const r = await e2.queryFeatures(s2);
      if (r?.features.length === t.length) return r.features;
    }
    return t;
  }
  _createFieldInfoMap(e2) {
    const t = /* @__PURE__ */ new Map();
    if (!e2) return t;
    for (const s2 of e2) {
      if (!s2.fieldName) continue;
      const e3 = this.fieldsIndex.get(s2.fieldName), i = e3?.name ?? s2.fieldName;
      s2.fieldName = i, t.set(i.toLowerCase(), s2);
    }
    return t;
  }
  _createFormattedAttributes(e2, t, s2 = "system") {
    const i = this.effectivePopupTemplate?.fieldInfos ?? [], r = {};
    if (!this._featureUtils) return {};
    if (!this.hasBadExpressions && this.calculatedExpressions.length > 0 && this._arcadeTask?.value) {
      const s3 = this._arcadeTask.value.Feature.createFromGraphicLikeObject(t.geometry, t.attributes, e2, null);
      for (const e3 of this.calculatedExpressions) try {
        r[`expression/${e3.name}`] = e3.func({ vars: { $feature: s3 } });
      } catch {
      }
    }
    const a2 = { ...t.attributes, ...r };
    return { global: this._featureUtils.formatAttributes({ fieldInfos: i, attributes: a2, graphic: t, timeZone: s2, layer: e2, fieldInfoMap: this.fieldInfoMap }), content: [] };
  }
  _extractFieldNames(e2) {
    return ze(e2).filter((e3) => !(e3.startsWith(p) || e3.startsWith(u)));
  }
};
__decorate([m({ readOnly: true })], h.prototype, "_arcadeTask", null), __decorate([m()], h.prototype, "_featureUtils", void 0), __decorate([m({ readOnly: true })], h.prototype, "featureUtilsPromise", null), __decorate([m({ readOnly: true })], h.prototype, "calculatedExpressions", null), __decorate([m()], h.prototype, "displayField", void 0), __decorate([m()], h.prototype, "effectivePopupTemplate", void 0), __decorate([m()], h.prototype, "expressionsUsedInTitle", null), __decorate([m()], h.prototype, "fieldsIndex", void 0), __decorate([m()], h.prototype, "fieldInfoMap", null), __decorate([m()], h.prototype, "fields", void 0), __decorate([m()], h.prototype, "objectIdField", void 0), __decorate([m()], h.prototype, "requiredFields", null), h = __decorate([a("esri.layers.support.TitleCreator")], h);

export {
  h
};
//# sourceMappingURL=chunk-WQW6HIRX.js.map
