import {
  d,
  g,
  w
} from "./chunk-7EPCZHGM.js";
import {
  n as n2
} from "./chunk-5XLI5DPS.js";
import {
  m as m2
} from "./chunk-QZQPB5XR.js";
import {
  l
} from "./chunk-T7F6Q6JJ.js";
import {
  f
} from "./chunk-5T3MJDSR.js";
import {
  n
} from "./chunk-XXLHAM2M.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  o
} from "./chunk-65HD3WXL.js";
import {
  s2 as s
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/layers/support/ParquetEncodingBase.js
var p = class extends l(n) {
  constructor(o2) {
    super(o2), this.type = null;
  }
};
__decorate([m({ type: ["wkb", "location"], nonNullable: true, readOnly: true, json: { read: false, write: { isRequired: true } } })], p.prototype, "type", void 0), p = __decorate([a("esri.layers.support.ParquetEncodingBase")], p);

// node_modules/@arcgis/core/layers/support/ParquetEncodingLocation.js
var i = class extends p {
  constructor(e) {
    super(e), this.type = "location", this.latitudeFieldName = null, this.longitudeFieldName = null;
  }
};
__decorate([m({ type: ["location"] })], i.prototype, "type", void 0), __decorate([m({ type: String, json: { name: "yField", write: { isRequired: true } } })], i.prototype, "latitudeFieldName", void 0), __decorate([m({ type: String, json: { name: "xField", write: { isRequired: true } } })], i.prototype, "longitudeFieldName", void 0), i = __decorate([a("esri.layers.support.ParquetEncodingLocation")], i);

// node_modules/@arcgis/core/layers/support/ParquetEncodingWkb.js
var s2 = class extends p {
  constructor(r) {
    super(r), this.type = "wkb", this.primaryFieldName = null;
  }
};
__decorate([m({ type: ["wkb"] })], s2.prototype, "type", void 0), __decorate([m({ type: ["counter-clockwise"], json: { write: true } })], s2.prototype, "orientation", void 0), __decorate([m({ type: String, json: { name: "field", write: { isRequired: true } } })], s2.prototype, "primaryFieldName", void 0), s2 = __decorate([a("esri.layers.support.ParquetEncodingWkb")], s2);

// node_modules/@arcgis/core/layers/support/parquetUtils.js
var c = new o({ esriGeometryPoint: "point", esriGeometryPolygon: "polygon", esriGeometryPolyline: "polyline", esriGeometryMultipoint: "multipoint" });
function p2(e) {
  return c.toJSON(e);
}
function f2(e) {
  return c.fromJSON(e);
}
async function y(e, o2 = {}) {
  if (e.urls.length < 1) throw new s("parquet:bad-input", "At least one url must be specified", e);
  if (e.geometryType && e.spatialReference && e.encoding && e.fields) return e;
  const r = await d(e.urls.getItemAt(0), { getCustomParameters: () => o2.customParameters }), l2 = w(r), s3 = { ...e, file: r };
  null == s3.fields && (s3.fields = r.fields().map((e2) => m2.fromJSON({ name: e2.name, alias: e2.name, type: e2.type }))), null == s3.encoding && (s3.encoding = g2(l2, s3.fields));
  const c2 = g(r);
  if (c2) switch (c2.mode) {
    case "z":
      s3.displayOptimization = { mode: "z" };
      break;
    case "xz": {
      const e2 = c2.multiscale;
      if (!e2) throw new s("parquet:bad-format", "XZ display optimization requires multiscale geometries");
      s3.displayOptimization = { mode: "xz", multiscale: e2 };
      break;
    }
  }
  if (!s3.encoding) return s3;
  switch (s3.encoding.type) {
    case "location":
      null == s3.spatialReference && (s3.spatialReference = f.WGS84), null == s3.geometryType && (s3.geometryType = "point");
      break;
    case "wkb": {
      if (!l2) return s3;
      const e2 = l2.primary_column, t = l2.columns[e2];
      if (s3.geometryType || (s3.geometryType = P(t)), s3.spatialReference || (s3.spatialReference = b(t)), s3.fields) for (const o3 of Object.keys(l2.columns)) s3.fields = s3.fields.filter((e3) => e3.name !== o3);
    }
  }
  return s3;
}
function g2(e, t) {
  if (null != e) {
    const t2 = e.primary_column, o3 = e.columns[t2];
    return new s2({ primaryFieldName: t2, orientation: "counterclockwise" === o3.orientation ? "counter-clockwise" : null });
  }
  const o2 = n2(t.map((e2) => e2.name));
  return o2.latitudeFieldName && o2.longitudeFieldName ? new i({ latitudeFieldName: o2.latitudeFieldName, longitudeFieldName: o2.longitudeFieldName }) : null;
}
function w2(e) {
  switch (e) {
    case "Point":
      return "point";
    case "Polygon":
    case "MultiPolygon":
      return "polygon";
    case "LineString":
      return "polyline";
    case "MultiPoint":
      return "multipoint";
    default:
      return null;
  }
}
function P(e) {
  const { geometry_types: o2 } = e, n3 = /* @__PURE__ */ new Set();
  for (const t of o2) {
    const e2 = w2(t);
    e2 && n3.add(e2);
  }
  if (n3.size > 1) throw new s("parquet:unsupported", "Parquet mixed geometry types are not supported", { geometryTypes: n3 });
  return 1 === n3.size ? n3.values().next().value : void 0;
}
function b(e) {
  const t = e.crs?.id?.code;
  return t && "number" == typeof t ? new f({ wkid: t }) : void 0;
}

export {
  p,
  i,
  s2 as s,
  c,
  p2,
  f2 as f,
  y
};
//# sourceMappingURL=chunk-ZOIMNPWT.js.map
