import {
  l as l4
} from "./chunk-L2YWECQ7.js";
import {
  H,
  Q
} from "./chunk-5RPEIJ7N.js";
import {
  B,
  D,
  a2 as a4,
  a3 as a5,
  b,
  c as c4,
  d,
  d2,
  f as f4,
  h,
  l2 as l5,
  m as m5,
  m2 as m6,
  n2,
  n3,
  r3 as r5,
  u as u2,
  u3,
  w as w2,
  w2 as w3,
  z
} from "./chunk-TNGDEFWZ.js";
import {
  M,
  a as a3,
  c as c3,
  f as f3,
  k,
  l as l3,
  m as m4,
  o as o3,
  r as r4,
  w,
  x
} from "./chunk-NQDCX3PB.js";
import {
  c,
  c2,
  f as f2,
  i,
  l as l2,
  r as r3,
  u
} from "./chunk-CJAJ4FML.js";
import {
  m as m3,
  p
} from "./chunk-DY7N5RAZ.js";
import {
  U
} from "./chunk-XTEXJOLG.js";
import {
  m as m2
} from "./chunk-QZQPB5XR.js";
import {
  l
} from "./chunk-PMGS7UDU.js";
import {
  f
} from "./chunk-GD4FJL3C.js";
import {
  r as r2
} from "./chunk-7H3U4IJR.js";
import {
  q
} from "./chunk-SMWUT52Z.js";
import {
  s as s2
} from "./chunk-WRA2WBYC.js";
import {
  o as o2
} from "./chunk-XWE6BM2U.js";
import {
  r
} from "./chunk-SOIZOFSB.js";
import {
  n
} from "./chunk-XXLHAM2M.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  o
} from "./chunk-65HD3WXL.js";
import {
  a,
  s2 as s
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/layers/support/rasterFunctions/BaseFunctionArguments.js
var e = class extends n {
  constructor() {
    super(...arguments), this.raster = void 0;
  }
};
__decorate([m({ json: { write: true } })], e.prototype, "raster", void 0), e = __decorate([a2("esri.layers.support.rasterFunctions.BaseFunctionArguments")], e);
var p2 = e;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ArithmeticFunctionArguments.js
var e2;
var a6 = e2 = class extends p2 {
  constructor() {
    super(...arguments), this.raster2 = void 0;
  }
  get rasters() {
    return [this.raster, this.raster2];
  }
  clone() {
    return new e2({ raster: this.raster, raster2: this.raster2, operation: this.operation });
  }
};
__decorate([m({ json: { write: true } })], a6.prototype, "operation", void 0), __decorate([m({ json: { write: true } })], a6.prototype, "raster2", void 0), __decorate([m({ readOnly: true })], a6.prototype, "rasters", null), a6 = e2 = __decorate([a2("esri.layers.support.rasterFunctions.ArithmeticFunctionArguments")], a6);
var i2 = a6;

// node_modules/@arcgis/core/layers/support/rasterFunctions/BaseRasterFunction.js
var a7 = /* @__PURE__ */ new Set(["slope", "aspect", "curvature", "hillshade", "shadedrelief", "statistics"]);
var u4 = class extends n {
  constructor() {
    super(...arguments), this.functionArguments = null, this.readingBufferSize = 0, this.id = -1, this.isNoopProcess = false, this.rawInputBandIds = [], this.rawSourceRasterInfos = null, this.isInputBandIdsSwizzled = false, this.swizzledBandSelection = [], this.isBranch = false, this.isRoot = false, this._bindingResult = null;
  }
  get supportsGPU() {
    return this._bindingResult.supportsGPU;
  }
  get flatWebGLFunctionChain() {
    const t6 = this.getWebGLProcessorDefinition();
    if (!t6) return null;
    const s11 = [t6], { parameters: e9 } = t6;
    let r11 = e9.rasters || e9.raster && [e9.raster];
    for (; r11?.length; ) {
      s11.unshift(...r11);
      const t7 = [];
      for (let s12 = 0; s12 < r11.length; s12++) {
        const { parameters: e10 } = r11[s12], i26 = e10.rasters || e10.raster && [e10.raster];
        i26?.length && t7.push(...i26);
      }
      r11 = t7;
    }
    for (let a29 = s11.length - 1; a29 >= 0; a29--) s11[a29].isNoopProcess && s11.splice(a29, 1);
    let i25 = false;
    for (let a29 = 0; a29 < s11.length; a29++) {
      const t7 = s11[a29];
      t7.id = s11.length - a29 - 1;
      const { rasters: e10 } = t7.parameters;
      i25 = i25 || null != e10 && e10.length > 1;
    }
    const n21 = s11.some(({ name: t7 }) => a7.has(t7.toLowerCase())), { rawSourceRasterInfos: o9 } = this;
    return { functions: s11, hasBranches: i25, hasFocalFunction: n21, isSourceSingleBand: 1 === o9?.[0]?.bandCount };
  }
  bind(t6, s11 = false, e9 = -1) {
    this.id = e9 + 1;
    const r11 = this._getRasterValues();
    let i25 = true;
    for (let n21 = 0; n21 < r11.length; n21++) {
      const e10 = r11[n21];
      if (null != e10 && this._isRasterFunctionValue(e10)) {
        const r12 = e10.bind(t6, s11, this.id + n21);
        if (!r12.success) return this._bindingResult = r12, r12;
        i25 = i25 && r12.supportsGPU;
      }
    }
    if (!this.rasterInfo || s11) {
      if (this.sourceRasterInfos = this._getSourceRasterInfos(t6), this._bindingResult = this._bindSourceRasters(), i25 &&= this._bindingResult.supportsGPU, this._bindingResult.success && (this._patchRasterInfo(), i25 && this.isRoot)) {
        this.processInputBandIds();
        this.swizzleInputBandIds(this.rawInputBandIds) || (i25 = this.rawInputBandIds.length <= 3);
      }
      return this._bindingResult.supportsGPU = i25, this._bindingResult;
    }
    return this._bindingResult = { success: true, supportsGPU: true }, this._bindingResult;
  }
  process(t6) {
    const s11 = this._getRasterValues(), e9 = 0 === s11.length ? t6.pixelBlocks ?? t6.primaryPixelBlocks : s11.map((s12) => this._readRasterValue(s12, t6));
    return this._processPixels({ ...t6, pixelBlocks: e9 });
  }
  processInputBandIds() {
    const t6 = this._getRasterValues().filter(this._isRasterFunctionValue);
    if (t6.length > 1) {
      const s12 = t6.map((t7) => t7.processInputBandIds());
      return this.rawInputBandIds = [...new Set(s12.flat())], this.rawInputBandIds;
    }
    const s11 = t6[0];
    if (s11) return this.rawInputBandIds = s11.processInputBandIds(), this.rawInputBandIds;
    const { bandCount: e9 } = this.sourceRasterInfos[0], r11 = Array.from({ length: e9 }, (t7, s12) => s12);
    return this.rawInputBandIds = this._getInputBandIds(r11), this.rawInputBandIds;
  }
  swizzleInputBandIds(t6) {
    const s11 = this._getRasterValues().filter(this._isRasterFunctionValue);
    let e9 = true;
    for (const r11 of s11) e9 = r11.swizzleInputBandIds(t6) && e9;
    return !!e9 && this._swizzleBandIds(t6);
  }
  getPrimaryRasters() {
    const t6 = [], s11 = [];
    return this._getPrimaryRasters(this, t6, s11), { rasters: t6, rasterIds: s11 };
  }
  getWebGLProcessorDefinition() {
    const t6 = this._getWebGLParameters(), { raster: s11, rasters: e9 } = this.functionArguments;
    return e9 && Array.isArray(e9) && e9.length ? (t6.rasters = e9.map((t7) => this._isRasterFunctionValue(t7) ? t7.getWebGLProcessorDefinition() : "number" == typeof t7 ? { name: "Constant", parameters: { value: t7 }, pixelType: "f32", id: -1, isNoopProcess: false } : { name: "Identity", parameters: { value: t7 }, pixelType: "f32", id: -1, isNoopProcess: false }), t6.rasters.some((t7) => null != t7) || (t6.rasters = null)) : this._isRasterFunctionValue(s11) && (t6.raster = s11.getWebGLProcessorDefinition()), { name: this.functionName, parameters: t6, pixelType: this.outputPixelType, id: this.id, isNoopProcess: this.isNoopProcess };
  }
  getClippingGeometries() {
    const t6 = [];
    "Clip" === this.functionName && t6.push(this.functionArguments);
    const { raster: s11, rasters: e9 } = this.functionArguments;
    if (e9 && Array.isArray(e9) && e9.length) e9.forEach((s12) => {
      if (this._isRasterFunctionValue(s12)) {
        const e10 = s12.getClippingGeometries();
        t6.push(...e10);
      }
    });
    else if (this._isRasterFunctionValue(s11)) {
      const e10 = s11.getClippingGeometries();
      t6.push(...e10);
    }
    return t6;
  }
  _getOutputPixelType(t6) {
    return "unknown" === this.outputPixelType ? t6 : this.outputPixelType ?? t6;
  }
  _getWebGLParameters() {
    return {};
  }
  _getInputBandIds(t6) {
    return t6;
  }
  _swizzleBandIds(t6) {
    return true;
  }
  _isInputRasterPrimaryOrConstant() {
    return !this._getRasterValues().some((t6) => t6 && "object" == typeof t6 && "rasterFunction" in t6 && t6.rasterFunction);
  }
  _removeStatsHistColormapVAT(t6) {
    t6.statistics = null, t6.histograms = null, t6.colormap = null, t6.attributeTable = null, t6.multidimensionalInfo?.variables.forEach((t7) => {
      t7.statistics = void 0, t7.histograms = void 0;
    });
  }
  _getRasterValues() {
    const { rasterArgumentNames: t6 } = this;
    return "rasters" === t6[0] ? this.functionArguments.rasters ?? [] : t6.flatMap((t7) => this.functionArguments[t7]);
  }
  _getSourceRasterInfos(t6) {
    const s11 = this._getRasterValues(), { rasterInfos: e9, rasterIds: r11 } = t6;
    if (0 === s11.length) return e9;
    const i25 = s11.map((t7) => t7 && "object" == typeof t7 && "bind" in t7 && t7.rasterInfo ? t7.rasterInfo : "string" == typeof t7 && r11.includes(t7) ? e9[r11.indexOf(t7)] : "number" != typeof t7 ? e9[0] : void 0), n21 = i25.find((t7) => t7) ?? e9[0];
    return i25.forEach((t7, s12) => {
      void 0 === t7 && (i25[s12] = n21);
    }), i25;
  }
  _getPrimaryRasterId(t6) {
    return t6?.rasterId;
  }
  _getPrimaryRasters(t6, s11 = [], e9 = []) {
    for (let r11 = 0; r11 < t6.sourceRasters.length; r11++) {
      const i25 = t6.sourceRasters[r11];
      if ("number" != typeof i25) if ("bind" in i25) this._getPrimaryRasters(i25, s11, e9);
      else {
        const t7 = i25, r12 = this._getPrimaryRasterId(t7);
        if (null == r12) continue;
        e9.includes(r12) || (this.mainPrimaryRasterId === r12 ? (s11.unshift(t7), e9.unshift(r12)) : (s11.push(t7), e9.push(r12)));
      }
    }
  }
  _isRasterFunctionValue(t6) {
    return null != t6 && "object" == typeof t6 && "getWebGLProcessorDefinition" in t6;
  }
  _readRasterValue(t6, s11) {
    const { primaryPixelBlocks: e9 } = s11;
    if (null == t6 || "$$" === t6) {
      const t7 = e9[0];
      return null == t7 ? null : t7.clone();
    }
    if ("string" == typeof t6) {
      const r11 = s11.primaryRasterIds.indexOf(t6);
      return -1 === r11 ? null : e9[r11];
    }
    if ("number" == typeof t6) {
      const s12 = e9[0];
      if (null == s12) return null;
      const { width: r11, height: i25, pixelType: o9 } = s12, a29 = new Float32Array(r11 * i25);
      a29.fill(t6);
      const u20 = this.sourceRasterInfos[0].bandCount, p18 = new Array(u20).fill(a29);
      return new c2({ width: r11, height: i25, pixelType: o9, pixels: p18 });
    }
    return t6.process(s11);
  }
  _patchRasterInfo() {
    const { rasterInfo: t6 } = this;
    if (!t6?.keyProperties) return;
    const { bandCount: s11, keyProperties: e9, statistics: r11, histograms: i25 } = t6, n21 = e9.BandProperties;
    n21 && n21.length !== s11 && (t6.keyProperties = { ...e9, BandProperties: void 0 }), r11 && r11.length !== s11 && (t6.statistics = r11.length > s11 ? r11.slice(0, s11) : null), i25 && i25.length !== s11 && (t6.histograms = i25.length > s11 ? i25.slice(0, s11) : null), e9.BAND_COUNT && Number(e9.BAND_COUNT) !== s11 && (t6.keyProperties = { ...e9, BAND_COUNT: "string" == typeof e9.BAND_COUNT ? String(s11) : s11 });
  }
};
__decorate([m({ json: { write: true } })], u4.prototype, "functionName", void 0), __decorate([m({ json: { write: true } })], u4.prototype, "functionArguments", void 0), __decorate([m()], u4.prototype, "rasterArgumentNames", void 0), __decorate([m({ json: { write: true } }), s2((t6) => t6?.toLowerCase())], u4.prototype, "outputPixelType", void 0), __decorate([m({ json: { write: true } })], u4.prototype, "mainPrimaryRasterId", void 0), __decorate([m()], u4.prototype, "sourceRasters", void 0), __decorate([m({ type: [m5], json: { write: true } })], u4.prototype, "sourceRasterInfos", void 0), __decorate([m({ json: { write: true } })], u4.prototype, "rasterInfo", void 0), __decorate([m({ json: { write: true } })], u4.prototype, "readingBufferSize", void 0), __decorate([m({ json: { write: true } })], u4.prototype, "id", void 0), __decorate([m()], u4.prototype, "isNoopProcess", void 0), __decorate([m()], u4.prototype, "supportsGPU", null), __decorate([m({ json: { write: true } })], u4.prototype, "rawInputBandIds", void 0), __decorate([m()], u4.prototype, "rawSourceRasterInfos", void 0), __decorate([m({ json: { write: true } })], u4.prototype, "isInputBandIdsSwizzled", void 0), __decorate([m({ json: { write: true } })], u4.prototype, "swizzledBandSelection", void 0), __decorate([m()], u4.prototype, "isBranch", void 0), __decorate([m()], u4.prototype, "isRoot", void 0), __decorate([m({ readOnly: true })], u4.prototype, "flatWebGLFunctionChain", null), __decorate([m()], u4.prototype, "_bindingResult", void 0), u4 = __decorate([a2("esri.layers.support.rasterFunctions.BaseRasterFunction")], u4);
var p3 = u4;

// node_modules/@arcgis/core/layers/support/rasterFunctionConstants.js
var D2 = { userDefined: -1, lineDetectionHorizontal: 0, lineDetectionVertical: 1, lineDetectionLeftDiagonal: 2, lineDetectionRightDiagonal: 3, gradientNorth: 4, gradientWest: 5, gradientEast: 6, gradientSouth: 7, gradientNorthEast: 8, gradientNorthWest: 9, smoothArithmeticMean: 10, smoothing3x3: 11, smoothing5x5: 12, sharpening3x3: 13, sharpening5x5: 14, laplacian3x3: 15, laplacian5x5: 16, sobelHorizontal: 17, sobelVertical: 18, sharpen: 19, sharpen2: 20, pointSpread: 21, none: 255 };
var d3 = { plus: 1, minus: 2, times: 3, sqrt: 4, power: 5, abs: 10, divide: 23, exp: 25, exp10: 26, exp2: 27, int: 30, float: 32, ln: 35, log10: 36, log2: 37, mod: 44, negate: 45, roundDown: 48, roundUp: 49, square: 53, floatDivide: 64, floorDivide: 65 };
var s3 = { bitwiseAnd: 11, bitwiseLeftShift: 12, bitwiseNot: 13, bitwiseOr: 14, bitwiseRightShift: 15, bitwiseXOr: 16, booleanAnd: 17, booleanNot: 18, booleanOr: 19, booleanXOr: 20, equalTo: 24, greaterThan: 28, greaterThanEqual: 29, lessThan: 33, lessThanEqual: 34, isNull: 31, notEqual: 46 };
var p4 = { acos: 6, asin: 7, atan: 8, atanh: 9, cos: 21, cosh: 22, sin: 51, sinh: 52, tan: 56, tanh: 57, acosh: 59, asinh: 60, atan2: 61 };
var c5 = { majority: 38, max: 39, mean: 40, med: 41, min: 42, minority: 43, range: 47, stddev: 54, sum: 55, variety: 58, majorityIgnoreNoData: 66, maxIgnoreNoData: 67, meanIgnoreNoData: 68, medIgnoreNoData: 69, minIgnoreNoData: 70, minorityIgnoreNoData: 71, rangeIgnoreNoData: 72, stddevIgnoreNoData: 73, sumIgnoreNoData: 74, varietyIgnoreNoData: 75 };
var B2 = { setNull: 50, conditional: 78 };
var m7 = { ...d3, ...s3, ...p4, ...c5, ...B2 };

// node_modules/@arcgis/core/layers/support/rasterFunctions/localUtils.js
var a8 = /* @__PURE__ */ new Map([[p4.acos, { domain: [0, Math.PI], isInteger: false }], [p4.asin, { domain: [-Math.PI / 2, Math.PI / 2], isInteger: false }], [p4.atan, { domain: [-Math.PI / 2, Math.PI / 2], isInteger: false }], [p4.cos, { domain: [-1, 1], isInteger: false }], [p4.sin, { domain: [-1, 1], isInteger: false }], [s3.booleanAnd, { domain: [0, 1], isInteger: true }], [s3.booleanNot, { domain: [0, 1], isInteger: true }], [s3.booleanOr, { domain: [0, 1], isInteger: true }], [s3.booleanXOr, { domain: [0, 1], isInteger: true }], [s3.equalTo, { domain: [0, 1], isInteger: true }], [s3.notEqual, { domain: [0, 1], isInteger: true }], [s3.greaterThan, { domain: [0, 1], isInteger: true }], [s3.greaterThanEqual, { domain: [0, 1], isInteger: true }], [s3.lessThan, { domain: [0, 1], isInteger: true }], [s3.lessThanEqual, { domain: [0, 1], isInteger: true }], [s3.isNull, { domain: [0, 1], isInteger: true }]]);
function l6(t6) {
  return a8.get(t6);
}
var c6 = [0, 2, 2, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 1, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 999, 999, 999, 999, 999, 999, 2, 1, 2, 999, 1, 1, 2, 1, 1, 1, 999, 999, 1, 1, 999, 1, 1, 2, 999, 999, 2, 2, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 3, 999, 3];
function f5(t6, e9 = false) {
  const n21 = t6.map((t7) => t7.mask), r11 = n21.filter((t7) => null != t7), o9 = t6[0].pixels[0].length;
  if (0 === r11.length || e9 && r11.length !== n21.length) return new Uint8Array(o9).fill(255);
  const s11 = r11[0], a29 = new Uint8Array(s11);
  if (1 === r11.length) return a29;
  if (!e9) {
    for (let t7 = 1; t7 < r11.length; t7++) {
      const e10 = r11[t7];
      for (let t8 = 0; t8 < a29.length; t8++) a29[t8] && (a29[t8] = e10[t8] ? 255 : 0);
    }
    return a29;
  }
  for (let l22 = 1; l22 < r11.length; l22++) {
    const t7 = r11[l22];
    for (let e10 = 0; e10 < a29.length; e10++) 0 === a29[e10] && (a29[e10] = t7[e10] ? 255 : 0);
  }
  return a29;
}
function i3(e9, n21, r11) {
  const [o9, s11] = e9, a29 = o9.length, l22 = c2.createEmptyBand(r11, a29);
  for (let t6 = 0; t6 < a29; t6++) n21 && !n21[t6] || (l22[t6] = o9[t6] + s11[t6]);
  return l22;
}
function u5(e9, n21, r11) {
  const [o9] = e9, s11 = o9.length, a29 = c2.createEmptyBand("f32", s11);
  return a29.set(o9), a29;
}
function h2(e9, n21, r11) {
  const [o9] = e9, s11 = o9.length, a29 = c2.createEmptyBand(r11, s11);
  for (let t6 = 0; t6 < s11; t6++) n21 && !n21[t6] || (a29[t6] = o9[t6] * o9[t6]);
  return a29;
}
function g(e9, n21, r11) {
  const [o9, s11] = e9, a29 = o9.length, l22 = c2.createEmptyBand(r11, a29);
  for (let t6 = 0; t6 < a29; t6++) n21 && !n21[t6] || (l22[t6] = o9[t6] - s11[t6]);
  return l22;
}
function p5(e9, n21, r11) {
  const [o9, s11] = e9, a29 = o9.length, l22 = c2.createEmptyBand(r11, a29);
  for (let t6 = 0; t6 < a29; t6++) n21 && !n21[t6] || (l22[t6] = o9[t6] * s11[t6]);
  return l22;
}
function m8(e9, n21, r11) {
  const [o9] = e9, s11 = o9.length, a29 = c2.createEmptyBand(r11, s11);
  for (let t6 = 0; t6 < s11; t6++) n21 && !n21[t6] || (a29[t6] = Math.sign(o9[t6]) * Math.floor(Math.abs(o9[t6])));
  return a29;
}
function d4(e9, n21, r11) {
  const [o9, s11] = e9, a29 = o9.length, l22 = c2.createEmptyBand(r11, a29);
  for (let t6 = 0; t6 < a29; t6++) n21 && !n21[t6] || (l22[t6] = o9[t6] / s11[t6]);
  return l22;
}
function y(t6, e9, n21) {
  return d4(t6, e9, "f32");
}
function E(e9, n21, r11) {
  const [o9, s11] = e9, a29 = o9.length, l22 = c2.createEmptyBand(r11, a29);
  for (let t6 = 0; t6 < a29; t6++) n21 && !n21[t6] || (l22[t6] = Math.floor(o9[t6] / s11[t6]));
  return l22;
}
function M2(e9, r11, o9, s11) {
  const a29 = e9[0], l22 = a29.length, c35 = c2.createEmptyBand(o9, l22);
  if (s11 === p4.atanh) {
    for (let t6 = 0; t6 < l22; t6++) if (r11[t6]) {
      const e10 = a29[t6];
      Math.abs(e10) >= 1 ? r11[t6] = 0 : c35[t6] = Math.atanh(e10);
    }
    return c35;
  }
  const f9 = s11 === p4.asin ? Math.asin : Math.acos;
  for (let t6 = 0; t6 < l22; t6++) if (r11[t6]) {
    const e10 = a29[t6];
    Math.abs(e10) > 1 ? r11[t6] = 0 : c35[t6] = f9(e10);
  }
  return c35;
}
function B3(e9, n21, r11, o9) {
  const [s11] = e9, a29 = s11.length, l22 = c2.createEmptyBand(r11, a29);
  for (let t6 = 0; t6 < a29; t6++) n21 && !n21[t6] || (l22[t6] = o9(s11[t6]));
  return l22;
}
function I(e9, n21, r11, o9) {
  const [s11, a29] = e9, l22 = s11.length, c35 = c2.createEmptyBand(r11, l22);
  for (let t6 = 0; t6 < l22; t6++) n21 && !n21[t6] || (c35[t6] = o9(s11[t6], a29[t6]));
  return c35;
}
function w4(e9, n21, r11) {
  const [o9, s11] = e9, a29 = o9.length, l22 = c2.createEmptyBand(r11, a29);
  for (let t6 = 0; t6 < a29; t6++) n21 && !n21[t6] || (l22[t6] = o9[t6] & s11[t6]);
  return l22;
}
function x2(e9, n21, r11) {
  const [o9, s11] = e9, a29 = o9.length, l22 = c2.createEmptyBand(r11, a29);
  for (let t6 = 0; t6 < a29; t6++) n21 && !n21[t6] || (l22[t6] = o9[t6] << s11[t6]);
  return l22;
}
function b2(e9, n21, r11) {
  const [o9] = e9, s11 = o9.length, a29 = c2.createEmptyBand(r11, s11);
  for (let t6 = 0; t6 < s11; t6++) n21 && !n21[t6] || (a29[t6] = ~o9[t6]);
  return a29;
}
function A(e9, n21, r11) {
  const [o9, s11] = e9, a29 = o9.length, l22 = c2.createEmptyBand(r11, a29);
  for (let t6 = 0; t6 < a29; t6++) n21 && !n21[t6] || (l22[t6] = o9[t6] | s11[t6]);
  return l22;
}
function P(e9, n21, r11) {
  const [o9, s11] = e9, a29 = o9.length, l22 = c2.createEmptyBand(r11, a29);
  for (let t6 = 0; t6 < a29; t6++) n21 && !n21[t6] || (l22[t6] = o9[t6] >> s11[t6]);
  return l22;
}
function T(e9, n21, r11) {
  const [o9, s11] = e9, a29 = o9.length, l22 = c2.createEmptyBand(r11, a29);
  for (let t6 = 0; t6 < a29; t6++) n21 && !n21[t6] || (l22[t6] = o9[t6] ^ s11[t6]);
  return l22;
}
function k2(e9, n21, r11) {
  const [o9, s11] = e9, a29 = o9.length, l22 = c2.createEmptyBand(r11, a29);
  for (let t6 = 0; t6 < a29; t6++) n21 && !n21[t6] || (l22[t6] = o9[t6] && s11[t6] ? 1 : 0);
  return l22;
}
function q2(e9, n21, r11) {
  const [o9] = e9, s11 = o9.length, a29 = c2.createEmptyBand(r11, s11);
  for (let t6 = 0; t6 < s11; t6++) n21 && !n21[t6] || (a29[t6] = o9[t6] ? 0 : 1);
  return a29;
}
function N(e9, n21, r11) {
  const [o9, s11] = e9, a29 = o9.length, l22 = c2.createEmptyBand(r11, a29);
  for (let t6 = 0; t6 < a29; t6++) n21 && !n21[t6] || (l22[t6] = o9[t6] || s11[t6] ? 1 : 0);
  return l22;
}
function U2(e9, n21, r11) {
  const [o9, s11] = e9, a29 = o9.length, l22 = c2.createEmptyBand(r11, a29);
  for (let t6 = 0; t6 < a29; t6++) n21 && !n21[t6] || (l22[t6] = (o9[t6] ? 1 : 0) ^ (s11[t6] ? 1 : 0));
  return l22;
}
function F(e9, n21, r11) {
  const [o9, s11] = e9, a29 = o9.length, l22 = c2.createEmptyBand(r11, a29);
  for (let t6 = 0; t6 < a29; t6++) n21 && !n21[t6] || (l22[t6] = o9[t6] === s11[t6] ? 1 : 0);
  return l22;
}
function j(e9, n21, r11, o9) {
  const [s11] = e9, a29 = s11.length, l22 = c2.createEmptyBand(r11, a29), c35 = o9 === Math.E;
  for (let t6 = 0; t6 < a29; t6++) n21 && !n21[t6] || (l22[t6] = c35 ? Math.exp(s11[t6]) : o9 ** s11[t6]);
  return l22;
}
function z2(t6, e9, n21) {
  return j(t6, e9, n21, 10);
}
function O(t6, e9, n21) {
  return j(t6, e9, n21, 2);
}
function C(t6, e9, n21) {
  return j(t6, e9, n21, Math.E);
}
function R(e9, n21, r11, o9) {
  const [s11] = e9, a29 = s11.length, l22 = c2.createEmptyBand(r11, a29);
  for (let t6 = 0; t6 < a29; t6++) n21 && !n21[t6] || (s11[t6] <= 0 ? n21[t6] = 0 : l22[t6] = o9(s11[t6]));
  return l22;
}
function S(t6, e9, n21) {
  return R(t6, e9, n21, Math.log10);
}
function X(t6, e9, n21) {
  return R(t6, e9, n21, Math.log2);
}
function v(t6, e9, n21) {
  return R(t6, e9, n21, Math.log);
}
function D3(e9, n21, r11) {
  const [o9, s11] = e9, a29 = o9.length, l22 = c2.createEmptyBand(r11, a29);
  for (let t6 = 0; t6 < a29; t6++) n21 && !n21[t6] || (l22[t6] = o9[t6] > s11[t6] ? 1 : 0);
  return l22;
}
function G(e9, n21, r11) {
  const [o9, s11] = e9, a29 = o9.length, l22 = c2.createEmptyBand(r11, a29);
  for (let t6 = 0; t6 < a29; t6++) n21 && !n21[t6] || (l22[t6] = o9[t6] >= s11[t6] ? 1 : 0);
  return l22;
}
function H2(e9, n21, r11) {
  const [o9, s11] = e9, a29 = o9.length, l22 = c2.createEmptyBand(r11, a29);
  for (let t6 = 0; t6 < a29; t6++) n21 && !n21[t6] || (l22[t6] = o9[t6] < s11[t6] ? 1 : 0);
  return l22;
}
function J(e9, n21, r11) {
  const [o9, s11] = e9, a29 = o9.length, l22 = c2.createEmptyBand(r11, a29);
  for (let t6 = 0; t6 < a29; t6++) n21 && !n21[t6] || (l22[t6] = o9[t6] <= s11[t6] ? 1 : 0);
  return l22;
}
function K(e9, n21, r11) {
  const [o9] = e9, s11 = o9.length, a29 = c2.createEmptyBand(r11, s11);
  if (!n21) return a29;
  for (let t6 = 0; t6 < s11; t6++) a29[t6] = n21[t6] ? 0 : 1;
  return a29;
}
function L(e9, n21, r11) {
  const [o9, s11] = e9, a29 = o9.length, l22 = c2.createEmptyBand(r11, a29);
  for (let t6 = 0; t6 < a29; t6++) n21 && !n21[t6] || (l22[t6] = o9[t6] % s11[t6]);
  return l22;
}
function Q2(e9, n21, r11) {
  const [o9] = e9, s11 = o9.length, a29 = c2.createEmptyBand(r11, s11);
  for (let t6 = 0; t6 < s11; t6++) n21 && !n21[t6] || (a29[t6] = -o9[t6]);
  return a29;
}
function V(e9, n21, r11) {
  const [o9, s11] = e9, a29 = o9.length, l22 = c2.createEmptyBand(r11, a29);
  for (let t6 = 0; t6 < a29; t6++) n21 && !n21[t6] || (l22[t6] = o9[t6] === s11[t6] ? 0 : 1);
  return l22;
}
function W(e9, n21, r11) {
  const [o9, s11] = e9, a29 = o9.length, l22 = c2.createEmptyBand(r11, a29), c35 = new Uint8Array(a29);
  for (let t6 = 0; t6 < a29; t6++) null != n21 && !n21[t6] || 0 !== o9[t6] || (l22[t6] = s11[t6], c35[t6] = 255);
  return { band: l22, mask: c35 };
}
function Y(e9, n21, r11) {
  const [o9, s11, a29] = e9, l22 = o9.length, c35 = c2.createEmptyBand(r11, l22);
  for (let t6 = 0; t6 < l22; t6++) n21 && !n21[t6] || (c35[t6] = o9[t6] ? s11[t6] : a29[t6]);
  return c35;
}
function Z(e9, n21, r11) {
  const o9 = e9.length;
  if (o9 < 2) return e9[0];
  const [s11] = e9, a29 = s11.length, l22 = c2.createEmptyBand(r11, a29);
  for (let t6 = 0; t6 < a29; t6++) if (!n21 || n21[t6]) {
    let n22 = s11[t6];
    for (let r12 = 1; r12 < o9; r12++) {
      const o10 = e9[r12][t6];
      n22 < o10 && (n22 = o10);
    }
    l22[t6] = n22;
  }
  return l22;
}
function $(e9, n21, r11) {
  const o9 = e9.length;
  if (o9 < 2) return e9[0];
  const [s11] = e9, a29 = s11.length, l22 = c2.createEmptyBand(r11, a29);
  for (let t6 = 0; t6 < a29; t6++) if (!n21 || n21[t6]) {
    let n22 = s11[t6];
    for (let r12 = 1; r12 < o9; r12++) {
      const o10 = e9[r12][t6];
      n22 > o10 && (n22 = o10);
    }
    l22[t6] = n22;
  }
  return l22;
}
function _(e9, n21, r11) {
  const o9 = e9.length;
  if (o9 < 2) return e9[0];
  const [s11] = e9, a29 = s11.length, l22 = c2.createEmptyBand(r11, a29);
  for (let t6 = 0; t6 < a29; t6++) if (!n21 || n21[t6]) {
    let n22 = s11[t6], r12 = n22;
    for (let s12 = 1; s12 < o9; s12++) {
      const o10 = e9[s12][t6];
      r12 < o10 ? r12 = o10 : n22 > o10 && (n22 = o10);
    }
    l22[t6] = r12 - n22;
  }
  return l22;
}
function tt(e9, n21, r11) {
  const o9 = e9.length;
  if (o9 < 2) return e9[0];
  const [s11] = e9, a29 = s11.length, l22 = c2.createEmptyBand(r11, a29);
  for (let t6 = 0; t6 < a29; t6++) if (!n21 || n21[t6]) {
    let n22 = 0;
    for (let r12 = 0; r12 < o9; r12++) n22 += e9[r12][t6];
    l22[t6] = n22 / o9;
  }
  return l22;
}
function et(e9, n21, r11) {
  const o9 = e9.length;
  if (o9 < 2) return e9[0];
  const [s11] = e9, a29 = s11.length, l22 = c2.createEmptyBand(r11, a29);
  for (let t6 = 0; t6 < a29; t6++) if (!n21 || n21[t6]) for (let n22 = 0; n22 < o9; n22++) {
    const r12 = e9[n22];
    l22[t6] += r12[t6];
  }
  return l22;
}
function nt(e9, n21, r11) {
  const o9 = e9.length;
  if (o9 < 2) return e9[0];
  const [s11] = e9, a29 = s11.length, l22 = c2.createEmptyBand(r11, a29);
  for (let t6 = 0; t6 < a29; t6++) if (!n21 || n21[t6]) {
    const n22 = new Float32Array(o9);
    let r12 = 0;
    for (let a30 = 0; a30 < o9; a30++) {
      const o10 = e9[a30];
      r12 += o10[t6], n22[a30] = o10[t6];
    }
    r12 /= o9;
    let s12 = 0;
    for (let t7 = 0; t7 < o9; t7++) s12 += (n22[t7] - r12) ** 2;
    l22[t6] = Math.sqrt(s12 / o9);
  }
  return l22;
}
function rt(e9, n21, r11) {
  const o9 = e9.length;
  if (o9 < 2) return e9[0];
  const s11 = Math.floor(o9 / 2), [a29] = e9, l22 = a29.length, c35 = c2.createEmptyBand(r11, l22), f9 = new Float32Array(o9), i25 = o9 % 2 == 1;
  for (let t6 = 0; t6 < l22; t6++) if (!n21 || n21[t6]) {
    for (let n22 = 0; n22 < o9; n22++) f9[n22] = e9[n22][t6];
    f9.sort(), c35[t6] = i25 ? f9[s11] : (f9[s11] + f9[s11 - 1]) / 2;
  }
  return c35;
}
function ot(e9, n21, r11) {
  const [o9, s11] = e9;
  if (null == s11) return o9;
  const a29 = o9.length, l22 = c2.createEmptyBand(r11, a29);
  for (let t6 = 0; t6 < a29; t6++) n21 && !n21[t6] || (l22[t6] = o9[t6] < s11[t6] ? o9[t6] : s11[t6]);
  return l22;
}
function st(e9, n21, r11) {
  const o9 = e9.length;
  if (o9 <= 2) return ot(e9, n21, r11);
  const s11 = e9[0].length, a29 = c2.createEmptyBand(r11, s11), l22 = /* @__PURE__ */ new Map();
  for (let t6 = 0; t6 < s11; t6++) if (!n21 || n21[t6]) {
    l22.clear();
    for (let a30 = 0; a30 < o9; a30++) {
      const n23 = e9[a30][t6];
      l22.set(n23, l22.has(n23) ? l22.get(n23) + 1 : 1);
    }
    let n22 = 0, r12 = 0;
    const s12 = [];
    for (const t7 of l22.keys()) n22 = l22.get(t7), n22 > r12 ? (r12 = n22, s12.length = 0, s12.push(t7)) : n22 === r12 && s12.push(t7);
    s12.length > 1 && s12.sort((t7, e10) => t7 - e10), a29[t6] = s12[0];
  }
  return a29;
}
function at(e9, n21, r11) {
  const o9 = e9.length;
  if (o9 <= 2) return ot(e9, n21, r11);
  const s11 = e9[0].length, a29 = c2.createEmptyBand(r11, s11), l22 = /* @__PURE__ */ new Map();
  for (let t6 = 0; t6 < s11; t6++) if (!n21 || n21[t6]) {
    l22.clear();
    for (let a30 = 0; a30 < o9; a30++) {
      const n23 = e9[a30][t6];
      l22.set(n23, l22.has(n23) ? l22.get(n23) + 1 : 1);
    }
    let n22 = 0, r12 = e9.length;
    const s12 = [];
    for (const t7 of l22.keys()) n22 = l22.get(t7), n22 < r12 ? (r12 = n22, s12.length = 0, s12.push(t7)) : n22 === r12 && s12.push(t7);
    s12.length > 1 && s12.sort((t7, e10) => t7 - e10), a29[t6] = s12[0];
  }
  return a29;
}
function lt(e9, n21, r11) {
  const o9 = e9.length;
  if (o9 < 2) return e9[0];
  const [s11] = e9, a29 = s11.length, l22 = c2.createEmptyBand(r11, a29), c35 = /* @__PURE__ */ new Set();
  for (let t6 = 0; t6 < a29; t6++) if (!n21 || n21[t6]) {
    let n22;
    c35.clear();
    for (let r12 = 0; r12 < o9; r12++) n22 = e9[r12][t6], c35.add(n22);
    l22[t6] = c35.size;
  }
  return l22;
}
var ct = /* @__PURE__ */ new Map();
var ft = /* @__PURE__ */ new Map();
var it = /* @__PURE__ */ new Map();
var ut = /* @__PURE__ */ new Map();
function ht() {
  ct.size || (ct.set(4, Math.sqrt), ct.set(6, Math.acos), ct.set(7, Math.asin), ct.set(8, Math.atan), ct.set(9, Math.atanh), ct.set(10, Math.abs), ct.set(21, Math.cos), ct.set(22, Math.cosh), ct.set(48, Math.floor), ct.set(49, Math.ceil), ct.set(51, Math.sin), ct.set(52, Math.sinh), ct.set(56, Math.tan), ct.set(57, Math.tanh), ct.set(59, Math.acosh), ct.set(60, Math.asinh), ct.set(65, Math.floor), ft.set(5, Math.pow), ft.set(61, Math.atan2), it.set(1, i3), it.set(2, g), it.set(3, p5), it.set(11, w4), it.set(12, x2), it.set(13, b2), it.set(14, A), it.set(15, P), it.set(16, T), it.set(17, k2), it.set(18, q2), it.set(19, N), it.set(20, U2), it.set(23, d4), it.set(24, F), it.set(25, C), it.set(26, z2), it.set(27, O), it.set(28, D3), it.set(29, G), it.set(30, m8), it.set(31, K), it.set(32, u5), it.set(33, H2), it.set(34, J), it.set(35, v), it.set(36, S), it.set(37, X), it.set(44, L), it.set(45, Q2), it.set(46, V), it.set(53, h2), it.set(64, y), it.set(65, E), it.set(76, Y), it.set(78, Y), ut.set(38, st), ut.set(39, Z), ut.set(40, tt), ut.set(41, rt), ut.set(42, $), ut.set(43, at), ut.set(47, _), ut.set(54, nt), ut.set(55, et), ut.set(58, lt), ut.set(66, st), ut.set(67, Z), ut.set(68, tt), ut.set(69, rt), ut.set(70, $), ut.set(71, at), ut.set(72, _), ut.set(73, nt), ut.set(74, et), ut.set(75, lt));
}
function gt(l22, c35, i25 = {}) {
  ht();
  let u20 = f5(l22, c35 >= 66 && c35 <= 75);
  const { outputPixelType: h6 = "f32" } = i25, g4 = !ut.has(c35) || i25.processAsMultiband, p18 = g4 ? l22[0].pixels.length : 1, m19 = [];
  for (let f9 = 0; f9 < p18; f9++) {
    const i26 = ut.has(c35) && !g4 ? l22.flatMap((t6) => t6.pixels) : l22.map((t6) => t6.pixels[f9]);
    let p19, d10 = true;
    if (c35 === B2.setNull) {
      const t6 = W(i26, u20, h6);
      p19 = t6.band, u20 = t6.mask, d10 = false;
    } else if (it.has(c35)) {
      p19 = it.get(c35)(i26, u20, "f64");
    } else if (ct.has(c35)) p19 = c35 === p4.asin || c35 === p4.acos || c35 === p4.atanh ? M2(i26, u20, "f64", c35) : B3(i26, u20, "f64", ct.get(c35));
    else if (ft.has(c35)) p19 = I(i26, u20, "f64", ft.get(c35));
    else if (ut.has(c35)) {
      p19 = ut.get(c35)(i26, u20, "f64");
    } else p19 = i26[0], d10 = false;
    if (d10 && c35 !== s3.isNull && !a8.has(c35)) {
      const e9 = c2.createEmptyBand(h6, p19.length);
      u20 || (u20 = new Uint8Array(p19.length).fill(255)), f2(p19, u20), c(p19, u20, h6, e9), p19 = e9;
    }
    m19.push(p19);
  }
  const d9 = l22[0];
  return new c2({ width: d9.width, height: d9.height, pixelType: h6, mask: c35 === s3.isNull ? null : u20, pixels: m19 });
}
function pt(t6, e9, n21) {
  return gt(t6, e9 = [null, 1, 2, 3, 23, 5, 44][e9] ?? 1, { outputPixelType: n21 });
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/ArithmeticFunction.js
var p6 = class extends p3 {
  constructor() {
    super(...arguments), this.functionName = "Arithmetic", this.functionArguments = null, this.rasterArgumentNames = ["raster", "raster2"];
  }
  _bindSourceRasters() {
    const { operation: t6 } = this.functionArguments;
    if (t6 < 1 || t6 > 6) return { success: false, supportsGPU: false, error: "unsupported operation" };
    const e9 = this.sourceRasterInfos[0].clone();
    this.outputPixelType = this._getOutputPixelType(e9.pixelType), e9.pixelType = this.outputPixelType, this._removeStatsHistColormapVAT(e9), this.rasterInfo = e9;
    return { success: true, supportsGPU: e9.bandCount <= 3 };
  }
  _processPixels(t6) {
    const { pixelBlocks: e9 } = t6;
    return null == e9?.[0] || null == e9?.[1] ? null : pt(e9, this.functionArguments.operation, this.outputPixelType);
  }
  _getWebGLParameters() {
    const { operation: t6 } = this.functionArguments, e9 = ["", "plus", "minus", "times", "divide", "power", "mod"][t6], r11 = this.outputPixelType ?? "f32";
    let [i25, n21] = u(r11);
    const u20 = r3(r11);
    return u20 && (i25 -= 1e-4, n21 += 1e-4), { imageCount: 2, operationName: e9, domainRange: [i25, n21], isOutputRounded: u20 };
  }
};
__decorate([m({ json: { write: true, name: "rasterFunction" } })], p6.prototype, "functionName", void 0), __decorate([m({ type: i2, json: { write: true, name: "rasterFunctionArguments" } })], p6.prototype, "functionArguments", void 0), __decorate([m()], p6.prototype, "rasterArgumentNames", void 0), p6 = __decorate([a2("esri.layers.support.rasterFunctions.ArithmeticFunction")], p6);
var a9 = p6;

// node_modules/@arcgis/core/layers/support/rasterFunctions/AspectFunctionArguments.js
var t;
var e3 = t = class extends p2 {
  clone() {
    return new t({ raster: this.raster });
  }
};
e3 = t = __decorate([a2("esri.layers.support.rasterFunctions.AspectFunctionArguments")], e3);
var c7 = e3;

// node_modules/@arcgis/core/layers/support/rasterFunctions/AspectFunction.js
var n4 = class extends p3 {
  constructor() {
    super(...arguments), this.functionName = "Aspect", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isGCS = false;
  }
  _bindSourceRasters() {
    const t6 = this.sourceRasterInfos[0];
    this.isGCS = t6.spatialReference?.isGeographic ?? false, this.outputPixelType = this._getOutputPixelType("f32");
    const s11 = t6.clone();
    return s11.pixelType = this.outputPixelType, this._removeStatsHistColormapVAT(s11), s11.statistics = [{ min: -1, max: 360, avg: 180, stddev: 30 }], s11.bandCount = 1, this.rasterInfo = s11, { success: true, supportsGPU: true };
  }
  _processPixels(t6) {
    const s11 = t6.pixelBlocks?.[0];
    if (null == s11) return null;
    const { extent: e9, primaryPixelSizes: r11 } = t6, o9 = r11?.[0], n21 = o9 ?? (e9 ? { x: e9.width / s11.width, y: e9.height / s11.height } : { x: 1, y: 1 });
    return u2(s11, { resolution: n21 });
  }
};
__decorate([m({ json: { write: true, name: "rasterFunction" } })], n4.prototype, "functionName", void 0), __decorate([m({ type: c7, json: { write: true, name: "rasterFunctionArguments" } })], n4.prototype, "functionArguments", void 0), __decorate([m()], n4.prototype, "rasterArgumentNames", void 0), __decorate([m({ json: { write: true } })], n4.prototype, "isGCS", void 0), n4 = __decorate([a2("esri.layers.support.rasterFunctions.AspectFunction")], n4);
var p7 = n4;

// node_modules/@arcgis/core/layers/support/rasterFunctions/customBandIndexUtils.js
var e4 = /* @__PURE__ */ new Set(["+", "-", "*", "/", "(", ")"]);
function t2(t6, r11) {
  (t6 = t6.replaceAll(" ", "")).startsWith("-") && (t6 = "0" + t6), t6.startsWith("+") && (t6 = t6.slice(1));
  const l22 = t6.split(""), o9 = [], s11 = [];
  let a29 = "";
  for (let i25 = 0; i25 < l22.length; i25++) {
    const t7 = l22[i25];
    e4.has(t7) ? (a29.length && s11.push(n5(a29, r11)), o9.push(t7), a29 = "") : a29 = a29.concat(t7);
  }
  return a29.length && s11.push(n5(a29, r11)), { ops: o9, nums: s11 };
}
function n5(e9, t6) {
  return e9.toLowerCase().startsWith("b") ? t6[parseInt(e9.slice(1), 10) - 1] : parseFloat(e9);
}
function r6(e9, t6, n21, r11) {
  if ("number" == typeof n21 && "number" == typeof r11) return n21 + r11;
  let l22, o9, s11;
  "number" == typeof n21 ? (s11 = r11, l22 = s11.length, o9 = new Float32Array(l22), o9.fill(n21)) : (l22 = n21.length, o9 = n21, r11.constructor === Number ? (s11 = new Float32Array(l22), s11.fill(r11)) : s11 = r11);
  const a29 = new Float32Array(l22);
  switch (t6) {
    case "+":
      for (let t7 = 0; t7 < l22; t7++) (null == e9 || e9[t7]) && (a29[t7] = o9[t7] + s11[t7]);
      break;
    case "-":
      for (let t7 = 0; t7 < l22; t7++) (null == e9 || e9[t7]) && (a29[t7] = o9[t7] - s11[t7]);
      break;
    case "*":
      for (let t7 = 0; t7 < l22; t7++) (null == e9 || e9[t7]) && (a29[t7] = o9[t7] * s11[t7]);
      break;
    case "/":
      for (let t7 = 0; t7 < l22; t7++) (null == e9 || e9[t7]) && s11[t7] && (a29[t7] = o9[t7] / s11[t7]);
      break;
    case "(":
    case ")":
      throw new Error("encountered error with custom band index equation");
  }
  return a29;
}
function l7(e9, t6) {
  e9.splice(t6, 1);
  let n21 = 0, r11 = 0;
  do {
    n21 = 0, r11 = 0;
    for (let t7 = 0; t7 < e9.length; t7++) if ("(" === e9[t7]) n21 = t7;
    else if (")" === e9[t7]) {
      r11 = t7;
      break;
    }
    r11 === n21 + 1 && e9.splice(n21, 2);
  } while (r11 === n21 + 1);
  return e9;
}
function o4(e9) {
  if (1 === e9.length) return { opIndex: 0, numIndex: 0 };
  let t6 = 0, n21 = 0;
  for (let s11 = 0; s11 < e9.length; s11++) if ("(" === e9[s11]) t6 = s11;
  else if (")" === e9[s11]) {
    n21 = s11;
    break;
  }
  const r11 = 0 === n21 ? e9 : e9.slice(t6 + 1, n21);
  let l22 = -1;
  for (let s11 = 0; s11 < r11.length; s11++) if ("*" === r11[s11] || "/" === r11[s11]) {
    l22 = s11;
    break;
  }
  if (l22 > -1) n21 > 0 && (l22 += t6 + 1);
  else {
    for (let e10 = 0; e10 < r11.length; e10++) if ("+" === r11[e10] || "-" === r11[e10]) {
      l22 = e10;
      break;
    }
    n21 > 0 && (l22 += t6 + 1);
  }
  let o9 = 0;
  for (let s11 = 0; s11 < l22; s11++) "(" === e9[s11] && o9++;
  return { opIndex: l22, numIndex: l22 - o9 };
}
function s4(e9, n21, s11) {
  let a29, { ops: i25, nums: f9 } = t2(s11, n21);
  if (0 === i25.length) {
    const e10 = 1 === f9.length ? f9[0] : n21[0];
    if (e10 instanceof Float32Array) return [e10];
    const t6 = new Float32Array(n21[0].length);
    return "number" == typeof e10 ? t6.fill(e10) : t6.set(e10), [t6];
  }
  for (; i25.length > 0; ) {
    const { numIndex: t6, opIndex: n22 } = o4(i25);
    if (a29 = r6(e9, i25[n22], f9[t6], f9[t6 + 1]), 1 === i25.length) break;
    i25 = l7(i25, n22), f9.splice(t6, 2, a29);
  }
  return [a29];
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/bandIndexUtils.js
var i4 = new o({ 0: "custom", 1: "ndvi", 2: "savi", 3: "tsavi", 4: "msavi", 5: "gemi", 6: "pvi", 7: "gvitm", 8: "sultan", 9: "vari", 10: "gndvi", 11: "sr", 12: "ndvi-re", 13: "sr-re", 14: "mtvi2", 15: "rtvi-core", 16: "ci-re", 17: "ci-g", 18: "ndwi", 19: "evi", 20: "iron-oxide", 21: "ferrous-minerals", 22: "clay-minerals", 23: "wndwi", 24: "bai", 25: "nbr", 26: "ndbi", 27: "ndmi", 28: "ndsi", 29: "mndwi" }, { useNumericKeys: true });
function s5(t6, i25) {
  if (!o3(t6)) return t6;
  const { equation: s11, method: l22 } = i25, c35 = i25.bandIndexes.map((t7) => t7 - 1), { pixels: U3, mask: q3 } = t6;
  let M4;
  switch (l22) {
    case "gndvi":
    case "nbr":
    case "ndbi":
    case "ndvi":
    case "ndvi-re":
    case "ndsi":
    case "ndmi":
    case "mndwi":
      M4 = u6(q3, U3[c35[0]], U3[c35[1]]);
      break;
    case "ndwi":
      M4 = u6(q3, U3[c35[1]], U3[c35[0]]);
      break;
    case "sr":
    case "sr-re":
    case "iron-oxide":
    case "ferrous-minerals":
    case "clay-minerals":
      M4 = f6(q3, U3[c35[0]], U3[c35[1]]);
      break;
    case "ci-g":
    case "ci-re":
      M4 = h3(q3, U3[c35[0]], U3[c35[1]]);
      break;
    case "savi":
      M4 = w5(q3, U3[c35[0]], U3[c35[1]], c35[2] + 1);
      break;
    case "tsavi":
      M4 = m9(q3, U3[c35[0]], U3[c35[1]], c35[2] + 1, c35[3] + 1, c35[4] + 1);
      break;
    case "msavi":
      M4 = d5(q3, U3[c35[0]], U3[c35[1]]);
      break;
    case "gemi":
      M4 = g2(q3, U3[c35[0]], U3[c35[1]]);
      break;
    case "pvi":
      M4 = y2(q3, U3[c35[0]], U3[c35[1]], c35[2] + 1, c35[3] + 1);
      break;
    case "gvitm":
      M4 = p8(q3, [U3[c35[0]], U3[c35[1]], U3[c35[2]], U3[c35[3]], U3[c35[4]], U3[c35[5]]]);
      break;
    case "sultan":
      M4 = b3(q3, [U3[c35[0]], U3[c35[1]], U3[c35[2]], U3[c35[3]], U3[c35[4]]]);
      break;
    case "vari":
      M4 = v2(q3, [U3[c35[0]], U3[c35[1]], U3[c35[2]]]);
      break;
    case "mtvi2":
      M4 = k3(q3, [U3[c35[0]], U3[c35[1]], U3[c35[2]]]);
      break;
    case "rtvi-core":
      M4 = A2(q3, [U3[c35[0]], U3[c35[1]], U3[c35[2]]]);
      break;
    case "evi":
      M4 = F2(q3, [U3[c35[0]], U3[c35[1]], U3[c35[2]]]);
      break;
    case "wndwi":
      M4 = x3(q3, [U3[c35[0]], U3[c35[1]], U3[c35[2]]], c35[3] ? c35[3] + 1 : 0.5);
      break;
    case "bai":
      M4 = j2(q3, U3[c35[0]], U3[c35[1]]);
      break;
    case "custom":
      M4 = s4(q3, U3, s11);
      break;
    default:
      return t6;
  }
  const { outputPixelType: B5 = "f32" } = i25, T3 = null != B5 && r3(B5);
  let I3;
  q3 ? (I3 = new Uint8Array(t6.width * t6.height), I3.set(q3)) : T3 && (I3 = new Uint8Array(t6.width * t6.height).fill(255)), T3 && (M4 = M4.map((t7) => {
    const e9 = c2.createEmptyBand(B5, t7.length);
    return c(t7, I3, B5, e9), e9;
  }));
  const P3 = new c2({ width: t6.width, height: t6.height, pixelType: B5, pixels: M4, mask: I3 });
  return P3.updateStatistics(), P3;
}
function l8(t6, e9, r11, a29) {
  const { mask: o9, pixels: i25, width: s11, height: l22 } = t6, c35 = i25[r11], u20 = i25[e9], f9 = u20.length, h6 = a29 ? new Uint8Array(f9) : new Float32Array(f9), w7 = a29 ? 100 : 1, m19 = a29 ? 100.5 : 0;
  for (let n21 = 0; n21 < f9; n21++) if (null == o9 || o9[n21]) {
    const t7 = c35[n21], e10 = u20[n21], r12 = t7 + e10;
    r12 && (h6[n21] = (t7 - e10) / r12 * w7 + m19);
  }
  const d9 = new c2({ width: s11, height: l22, mask: o9, pixelType: a29 ? "u8" : "f32", pixels: [h6] });
  return d9.updateStatistics(), d9;
}
function c8(t6) {
  const n21 = new Float32Array(9);
  return n21[3 * t6[0]] = 1, n21[3 * t6[1] + 1] = 1, n21[3 * t6[2] + 2] = 1, n21;
}
function u6(t6, n21, e9) {
  const r11 = e9.length, a29 = new Float32Array(r11);
  for (let o9 = 0; o9 < r11; o9++) if (null == t6 || t6[o9]) {
    const t7 = n21[o9], r12 = e9[o9], i25 = t7 + r12;
    i25 && (a29[o9] = (t7 - r12) / i25);
  }
  return [a29];
}
function f6(t6, n21, e9) {
  const r11 = e9.length, a29 = new Float32Array(r11);
  for (let o9 = 0; o9 < r11; o9++) if (null == t6 || t6[o9]) {
    const t7 = n21[o9], r12 = e9[o9];
    r12 && (a29[o9] = t7 / r12);
  }
  return [a29];
}
function h3(t6, n21, e9) {
  const r11 = n21.length, a29 = new Float32Array(r11);
  for (let o9 = 0; o9 < r11; o9++) if (null == t6 || t6[o9]) {
    const t7 = n21[o9], r12 = e9[o9];
    r12 && (a29[o9] = t7 / r12 - 1);
  }
  return [a29];
}
function w5(t6, n21, e9, r11) {
  const a29 = e9.length, o9 = new Float32Array(a29);
  for (let i25 = 0; i25 < a29; i25++) if (null == t6 || t6[i25]) {
    const t7 = e9[i25], a30 = n21[i25], s11 = a30 + t7 + r11;
    s11 && (o9[i25] = (a30 - t7) / s11 * (1 + r11));
  }
  return [o9];
}
function m9(t6, n21, e9, r11, a29, o9) {
  const i25 = e9.length, s11 = new Float32Array(i25), l22 = -a29 * r11 + o9 * (1 + r11 * r11);
  for (let c35 = 0; c35 < i25; c35++) if (null == t6 || t6[c35]) {
    const t7 = e9[c35], o10 = n21[c35], i26 = a29 * o10 + t7 + l22;
    i26 && (s11[c35] = r11 * (o10 - r11 * t7 - a29) / i26);
  }
  return [s11];
}
function d5(t6, n21, e9) {
  const r11 = e9.length, a29 = new Float32Array(r11);
  for (let o9 = 0; o9 < r11; o9++) if (null == t6 || t6[o9]) {
    const t7 = e9[o9], r12 = n21[o9], i25 = 2 * r12 + 1;
    a29[o9] = 0.5 * (i25 - Math.sqrt(i25 * i25 - 8 * (r12 - t7)));
  }
  return [a29];
}
function g2(t6, n21, e9) {
  const r11 = e9.length, a29 = new Float32Array(r11);
  for (let o9 = 0; o9 < r11; o9++) if (null == t6 || t6[o9]) {
    const t7 = e9[o9], r12 = n21[o9];
    if (1 !== t7 && r12 + t7 + 0.5 !== 0) {
      const n22 = (2 * (r12 * r12 - t7 * t7) + 1.5 * r12 + 0.5 * t7) / (r12 + t7 + 0.5);
      a29[o9] = n22 * (1 - 0.25 * n22) - (t7 - 0.125) / (1 - t7);
    }
  }
  return [a29];
}
function y2(t6, n21, e9, r11, a29) {
  const o9 = e9.length, i25 = new Float32Array(o9), s11 = 1 / Math.sqrt(1 + r11 * r11);
  for (let l22 = 0; l22 < o9; l22++) if (null == t6 || t6[l22]) {
    const t7 = e9[l22], o10 = n21[l22];
    i25[l22] = (o10 - r11 * t7 - a29) * s11;
  }
  return [i25];
}
function p8(t6, n21) {
  const [e9, r11, a29, o9, i25, s11] = n21, l22 = e9.length, c35 = new Float32Array(l22);
  for (let u20 = 0; u20 < l22; u20++) (null == t6 || t6[u20]) && (c35[u20] = -0.2848 * e9[u20] - 0.2435 * r11[u20] - 0.5436 * a29[u20] + 0.7243 * o9[u20] + 0.084 * i25[u20] - 0.18 * s11[u20]);
  return [c35];
}
function b3(t6, n21) {
  const [e9, r11, a29, o9, i25] = n21, s11 = e9.length, l22 = new Float32Array(s11), c35 = new Float32Array(s11), u20 = new Float32Array(s11);
  for (let f9 = 0; f9 < s11; f9++) (null == t6 || t6[f9]) && (l22[f9] = i25[f9] ? o9[f9] / i25[f9] * 100 : 0, c35[f9] = e9[f9] ? o9[f9] / e9[f9] * 100 : 0, u20[f9] = a29[f9] ? r11[f9] / a29[f9] * (o9[f9] / a29[f9]) * 100 : 0);
  return [l22, c35, u20];
}
function v2(t6, n21) {
  const [e9, r11, a29] = n21, o9 = e9.length, i25 = new Float32Array(o9);
  for (let s11 = 0; s11 < o9; s11++) if (null == t6 || t6[s11]) for (s11 = 0; s11 < o9; s11++) {
    const t7 = e9[s11], n22 = r11[s11], o10 = n22 + t7 - a29[s11];
    o10 && (i25[s11] = (n22 - t7) / o10);
  }
  return [i25];
}
function k3(t6, n21) {
  const [e9, r11, a29] = n21, o9 = e9.length, i25 = new Float32Array(o9);
  for (let s11 = 0; s11 < o9; s11++) if (null == t6 || t6[s11]) for (s11 = 0; s11 < o9; s11++) {
    const t7 = e9[s11], n22 = r11[s11], o10 = a29[s11], l22 = Math.sqrt((2 * t7 + 1) ** 2 - (6 * t7 - 5 * Math.sqrt(n22)) - 0.5);
    if (l22) {
      const e10 = 1.5 * (1.2 * (t7 - o10) - 2.5 * (n22 - o10));
      i25[s11] = e10 / l22;
    }
  }
  return [i25];
}
function A2(t6, n21) {
  const [e9, r11, a29] = n21, o9 = e9.length, i25 = new Float32Array(o9);
  for (let s11 = 0; s11 < o9; s11++) if (null == t6 || t6[s11]) for (s11 = 0; s11 < o9; s11++) {
    const t7 = e9[s11], n22 = r11[s11], o10 = a29[s11];
    i25[s11] = 100 * (t7 - n22) - 10 * (t7 - o10);
  }
  return [i25];
}
function F2(t6, n21) {
  const [e9, r11, a29] = n21, o9 = e9.length, i25 = new Float32Array(o9);
  for (let s11 = 0; s11 < o9; s11++) if (null == t6 || t6[s11]) for (s11 = 0; s11 < o9; s11++) {
    const t7 = e9[s11], n22 = r11[s11], o10 = t7 + 6 * n22 - 7.5 * a29[s11] + 1;
    o10 && (i25[s11] = 2.5 * (t7 - n22) / o10);
  }
  return [i25];
}
function x3(t6, n21, e9 = 0.5) {
  const [r11, a29, o9] = n21, i25 = a29.length, s11 = new Float32Array(i25);
  for (let l22 = 0; l22 < i25; l22++) if (null == t6 || t6[l22]) for (l22 = 0; l22 < i25; l22++) {
    const t7 = r11[l22], n22 = a29[l22], i26 = o9[l22], c35 = t7 + e9 * n22 + (1 - e9) * i26;
    c35 && (s11[l22] = (t7 - e9 * n22 - (1 - e9) * i26) / c35);
  }
  return [s11];
}
function j2(t6, n21, e9) {
  const r11 = e9.length, a29 = new Float32Array(r11);
  for (let o9 = 0; o9 < r11; o9++) if (null == t6 || t6[o9]) for (o9 = 0; o9 < r11; o9++) {
    const t7 = (0.1 - n21[o9]) ** 2 + (0.06 - e9[o9]) ** 2;
    t7 && (a29[o9] = 1 / t7);
  }
  return [a29];
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/BandArithmeticFunctionArguments.js
var i5;
var p9 = i5 = class extends p2 {
  constructor() {
    super(...arguments), this.method = "custom";
  }
  clone() {
    return new i5({ method: this.method, bandIndexes: this.bandIndexes, raster: a(this.raster) });
  }
};
__decorate([m({ json: { type: String, write: true } })], p9.prototype, "bandIndexes", void 0), __decorate([r2(i4)], p9.prototype, "method", void 0), p9 = i5 = __decorate([a2("esri.layers.support.rasterFunctions.BandArithmeticFunctionArguments")], p9);
var m10 = p9;

// node_modules/@arcgis/core/layers/support/rasterFunctions/BandArithmeticFunction.js
var c9 = /* @__PURE__ */ new Set(["vari", "mtvi2", "rtvi-core", "evi"]);
var u7 = class extends p3 {
  constructor() {
    super(...arguments), this.functionName = "BandArithmetic", this.functionArguments = null, this.rasterArgumentNames = ["raster"];
  }
  _bindSourceRasters() {
    this.outputPixelType = this._getOutputPixelType("f32");
    const e9 = this.sourceRasterInfos[0];
    if (e9.bandCount < 2) return { success: false, supportsGPU: false, error: "band-arithmetic-function: source raster has insufficient amount of raster bands" };
    const t6 = e9.clone();
    t6.pixelType = this.outputPixelType, t6.bandCount = "sultan" === this.functionArguments.method ? 3 : 1, this._removeStatsHistColormapVAT(t6), t6.keyProperties = { ...t6.keyProperties, BandProperties: void 0 }, this.rasterInfo = t6;
    return { success: true, supportsGPU: !["custom", "gvitm", "sultan"].includes(this.functionArguments.method) };
  }
  _processPixels(e9) {
    const t6 = e9.pixelBlocks?.[0];
    if (null == t6) return t6;
    const { method: s11, bandIndexes: i25 } = this.functionArguments, r11 = i25.split(" ").map((e10) => parseFloat(e10));
    if (this.rasterInfo.storageInfo.isBsqTile) {
      const { rawInputBandIds: e10 } = this, t7 = c9.has(this.functionArguments.method) ? 3 : 2, s12 = r11.slice(0, t7).map((t8) => e10.indexOf(t8 - 1));
      r11.splice(0, t7, ...s12);
    }
    return s5(t6, { method: s11, bandIndexes: r11, equation: i25, outputPixelType: this.outputPixelType });
  }
  _getWebGLParameters() {
    const e9 = this.functionArguments.bandIndexes.split(" ").map((e10) => parseFloat(e10) - 1);
    2 === e9.length && e9.push(0);
    const t6 = this.isInputBandIdsSwizzled ? [0, 1, 2] : e9;
    let s11, r11;
    const n21 = new Float32Array(3), { method: o9 } = this.functionArguments;
    switch (o9) {
      case "gndvi":
      case "nbr":
      case "ndbi":
      case "ndvi":
      case "ndvi-re":
      case "ndsi":
      case "ndmi":
      case "mndwi":
        s11 = c8([t6[0], t6[1], 0]), r11 = "ndxi";
        break;
      case "ndwi":
        s11 = c8([t6[1], t6[0], 0]), r11 = "ndxi";
        break;
      case "sr":
      case "sr-re":
      case "iron-oxide":
      case "ferrous-minerals":
      case "clay-minerals":
        s11 = c8([t6[0], t6[1], 0]), r11 = "sr";
        break;
      case "ci-g":
      case "ci-re":
        s11 = c8([t6[0], t6[1], 0]), r11 = "ci";
        break;
      case "savi":
        s11 = c8([t6[0], t6[1], 0]), r11 = "savi", n21[0] = e9[2] + 1;
        break;
      case "tsavi":
        s11 = c8([t6[0], t6[1], 0]), r11 = "tsavi", n21[0] = e9[2] + 1, n21[1] = e9[3] + 1, n21[2] = e9[4] + 1;
        break;
      case "msavi":
        s11 = c8([t6[0], t6[1], 0]), r11 = "msavi";
        break;
      case "gemi":
        s11 = c8([t6[0], t6[1], 0]), r11 = "gemi";
        break;
      case "pvi":
        s11 = c8([t6[0], t6[1], 0]), r11 = "tsavi", n21[0] = e9[2] + 1, n21[1] = e9[3] + 1;
        break;
      case "vari":
        s11 = c8([t6[0], t6[1], t6[2]]), r11 = "vari";
        break;
      case "mtvi2":
        s11 = c8([t6[0], t6[1], t6[2]]), r11 = "mtvi";
        break;
      case "rtvi-core":
        s11 = c8([t6[0], t6[1], t6[2]]), r11 = "rtvicore";
        break;
      case "evi":
        s11 = c8([t6[0], t6[1], t6[2]]), r11 = "evi";
        break;
      case "wndwi":
        s11 = c8([t6[0], t6[1], 0]), r11 = "wndwi", n21[0] = e9[3] ? e9[3] + 1 : 0.5;
        break;
      case "bai":
        s11 = c8([t6[1], t6[0], 0]), r11 = "bai";
        break;
      default:
        s11 = c8([0, 1, 2]), r11 = "custom";
    }
    return { bandIndexMat3: s11, indexType: r11, adjustments: n21, isOutputRounded: r3(this.outputPixelType) };
  }
  _getInputBandIds(e9) {
    if ("custom" === this.functionArguments.method) return e9;
    const t6 = this.functionArguments.bandIndexes.split(" ").map((e10) => parseFloat(e10) - 1), s11 = e9.length, i25 = t6.map((e10) => e10 >= s11 ? s11 - 1 : e10), r11 = c9.has(this.functionArguments.method) ? 3 : 2, n21 = i25.slice(0, r11).map((t7) => e9[t7]);
    return 2 === n21.length && n21.push(0), n21;
  }
  _swizzleBandIds(e9) {
    const t6 = this.functionArguments.bandIndexes.split(" ").map((e10) => parseFloat(e10) - 1);
    2 === t6.length && t6.push(0);
    const { method: s11 } = this.functionArguments, i25 = (["vari", "mtvi2", "rtvi-core", "evi"].includes(s11) ? t6.slice(0, 3) : "bai" === s11 || "ndwi" === s11 ? [t6[1], t6[0]] : t6.slice(0, 2)).map((t7) => e9.indexOf(t7));
    return i25[2] ??= i25[1], this.isInputBandIdsSwizzled = true, this.swizzledBandSelection = i25, false;
  }
};
__decorate([m({ json: { write: true, name: "rasterFunction" } })], u7.prototype, "functionName", void 0), __decorate([m({ type: m10, json: { write: true, name: "rasterFunctionArguments" } })], u7.prototype, "functionArguments", void 0), __decorate([m()], u7.prototype, "rasterArgumentNames", void 0), u7 = __decorate([a2("esri.layers.support.rasterFunctions.BandArithmeticFunction")], u7);
var m11 = u7;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ClipFunctionArguments.js
var c10;
var n6 = new o({ 1: "outside", 2: "inside" }, { useNumericKeys: true });
var m12 = c10 = class extends p2 {
  constructor() {
    super(...arguments), this.clippingType = "outside";
  }
  clone() {
    return new c10({ clippingGeometry: this.clippingGeometry.clone(), clippingType: this.clippingType });
  }
};
__decorate([m({ types: l, json: { read: f, write: true } })], m12.prototype, "clippingGeometry", void 0), __decorate([m({ json: { read: n6.read, write: n6.write } })], m12.prototype, "clippingType", void 0), m12 = c10 = __decorate([a2("esri.layers.support.rasterFunctions.ClipFunctionArguments")], m12);
var u8 = m12;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ClipFunction.js
var c11 = class extends p3 {
  constructor() {
    super(...arguments), this.functionName = "Clip", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isNoopProcess = true;
  }
  _bindSourceRasters() {
    const t6 = this.sourceRasterInfos[0].clone();
    this.outputPixelType = this._getOutputPixelType(t6.pixelType), t6.pixelType = this.outputPixelType, this.rasterInfo = t6;
    const { functionArguments: e9 } = this, { clippingGeometry: r11, clippingType: s11 } = e9;
    if (!r11) return { success: false, supportsGPU: false, error: "missing clipping geometry" };
    if ("outside" === s11) try {
      const { spatialReference: e10 } = t6, s12 = "extent" === r11.type ? H(r11, e10) : Q(r11, e10).extent;
      s12 && l4(t6, s12);
    } catch {
    }
    return { success: true, supportsGPU: true };
  }
  _processPixels(t6) {
    return t6.pixelBlocks?.[0];
  }
  _getWebGLParameters() {
    const { clippingGeometry: t6, clippingType: e9 } = this.functionArguments;
    return { clippingGeometry: t6.toJSON(), clippingType: e9 };
  }
};
__decorate([m({ json: { write: true, name: "rasterFunction" } })], c11.prototype, "functionName", void 0), __decorate([m({ type: u8, json: { write: true, name: "rasterFunctionArguments" } })], c11.prototype, "functionArguments", void 0), __decorate([m()], c11.prototype, "rasterArgumentNames", void 0), __decorate([m()], c11.prototype, "isNoopProcess", void 0), c11 = __decorate([a2("esri.layers.support.rasterFunctions.ClipFunction")], c11);
var u9 = c11;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ColormapFunctionArguments.js
var i6;
var u10 = i6 = class extends p2 {
  castColormapName(o9) {
    if (!o9) return null;
    const r11 = o9.toLowerCase();
    return n3.includes(r11) ? r11 : null;
  }
  readColorRamp(o9) {
    return p(o9);
  }
  readColorRampName(o9, r11) {
    if (!o9) return null;
    const e9 = m6.jsonValues.find((r12) => r12.toLowerCase() === o9.toLowerCase());
    return e9 ? m6.fromJSON(e9) : null;
  }
  clone() {
    return new i6({ colormap: a(this.colormap), colormapName: this.colormapName, colorRamp: this.colorRamp?.clone(), colorRampName: this.colorRampName });
  }
};
__decorate([m({ type: [[Number]], json: { write: true } })], u10.prototype, "colormap", void 0), __decorate([m({ type: String, json: { write: true } })], u10.prototype, "colormapName", void 0), __decorate([s2("colormapName")], u10.prototype, "castColormapName", null), __decorate([m({ types: m3, json: { write: true } })], u10.prototype, "colorRamp", void 0), __decorate([o2("colorRamp")], u10.prototype, "readColorRamp", null), __decorate([m({ type: m6.apiValues, json: { type: m6.jsonValues, write: m6.write } })], u10.prototype, "colorRampName", void 0), __decorate([o2("colorRampName")], u10.prototype, "readColorRampName", null), u10 = i6 = __decorate([a2("esri.layers.support.rasterFunctions.ColormapFunctionArguments")], u10);
var d6 = u10;

// node_modules/@arcgis/core/layers/support/rasterFunctions/colormaps.js
var t3 = [[36, 0, 255], [36, 0, 255], [36, 0, 255], [36, 0, 255], [112, 75, 3], [113, 76, 3], [114, 77, 3], [115, 77, 3], [116, 78, 3], [117, 79, 3], [118, 79, 3], [119, 80, 3], [121, 81, 4], [122, 82, 4], [123, 82, 4], [124, 83, 4], [125, 84, 4], [126, 84, 4], [127, 85, 4], [128, 86, 4], [129, 86, 4], [130, 87, 4], [131, 88, 4], [132, 89, 4], [133, 89, 4], [134, 90, 4], [135, 91, 4], [136, 91, 4], [137, 92, 4], [138, 93, 4], [139, 94, 4], [140, 94, 4], [142, 95, 5], [143, 96, 5], [144, 96, 5], [145, 97, 5], [146, 98, 5], [147, 99, 5], [148, 99, 5], [149, 100, 5], [150, 101, 5], [151, 101, 5], [152, 102, 5], [153, 103, 5], [154, 104, 5], [155, 104, 5], [156, 105, 5], [157, 106, 5], [158, 106, 5], [159, 107, 5], [160, 108, 5], [161, 108, 5], [162, 109, 5], [164, 110, 6], [165, 111, 6], [166, 111, 6], [167, 112, 6], [168, 113, 6], [169, 113, 6], [170, 114, 6], [171, 115, 6], [172, 116, 6], [173, 116, 6], [174, 117, 6], [245, 0, 0], [245, 5, 0], [245, 10, 0], [246, 15, 0], [246, 20, 0], [246, 25, 0], [246, 30, 0], [247, 35, 0], [247, 40, 0], [247, 45, 0], [247, 50, 0], [247, 55, 0], [248, 60, 0], [248, 65, 0], [248, 70, 0], [248, 75, 0], [249, 81, 0], [249, 86, 0], [249, 91, 0], [249, 96, 0], [250, 101, 0], [250, 106, 0], [250, 111, 0], [250, 116, 0], [250, 121, 0], [251, 126, 0], [251, 131, 0], [251, 136, 0], [251, 141, 0], [252, 146, 0], [252, 151, 0], [252, 156, 0], [252, 156, 0], [251, 159, 0], [250, 162, 0], [249, 165, 0], [248, 168, 0], [247, 171, 0], [246, 174, 0], [245, 177, 0], [245, 179, 0], [244, 182, 0], [243, 185, 0], [242, 188, 0], [241, 191, 0], [240, 194, 0], [239, 197, 0], [238, 200, 0], [237, 203, 0], [236, 206, 0], [235, 209, 0], [234, 212, 0], [233, 215, 0], [232, 218, 0], [231, 221, 0], [230, 224, 0], [230, 226, 0], [229, 229, 0], [228, 232, 0], [227, 235, 0], [226, 238, 0], [225, 241, 0], [224, 244, 0], [223, 247, 0], [165, 247, 0], [163, 244, 0], [161, 240, 0], [158, 237, 0], [156, 233, 1], [154, 230, 1], [152, 227, 1], [149, 223, 1], [147, 220, 1], [145, 216, 1], [143, 213, 1], [140, 210, 2], [138, 206, 2], [136, 203, 2], [134, 200, 2], [132, 196, 2], [129, 193, 2], [127, 189, 2], [125, 186, 3], [123, 183, 3], [120, 179, 3], [118, 176, 3], [116, 172, 3], [114, 169, 3], [111, 166, 3], [109, 162, 4], [107, 159, 4], [105, 155, 4], [103, 152, 4], [100, 149, 4], [98, 145, 4], [96, 142, 4], [94, 138, 5], [91, 135, 5], [89, 132, 5], [87, 128, 5], [85, 125, 5], [82, 121, 5], [80, 118, 5], [78, 115, 6], [76, 111, 6], [73, 108, 6], [71, 105, 6], [69, 101, 6], [67, 98, 6], [65, 94, 6], [62, 91, 7], [60, 88, 7], [58, 84, 7], [56, 81, 7], [53, 77, 7], [51, 74, 7], [49, 71, 7], [47, 67, 8], [44, 64, 8], [42, 60, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8]];
var o5 = [[36, 0, 255], [36, 0, 255], [36, 0, 255], [36, 0, 255], [245, 20, 0], [245, 24, 0], [245, 29, 0], [245, 31, 0], [247, 33, 0], [247, 33, 0], [247, 37, 0], [247, 41, 0], [247, 41, 0], [247, 41, 0], [247, 45, 0], [247, 45, 0], [247, 47, 0], [247, 49, 0], [247, 49, 0], [247, 54, 0], [247, 54, 0], [247, 56, 0], [247, 58, 0], [247, 58, 0], [250, 62, 0], [250, 62, 0], [250, 62, 0], [250, 67, 0], [250, 67, 0], [250, 67, 0], [250, 69, 0], [250, 71, 0], [250, 71, 0], [250, 75, 0], [250, 75, 0], [250, 78, 0], [250, 79, 0], [250, 79, 0], [250, 79, 0], [250, 81, 0], [250, 83, 0], [250, 83, 0], [250, 87, 0], [250, 87, 0], [250, 90, 0], [250, 92, 0], [252, 93, 0], [252, 93, 0], [252, 97, 0], [252, 97, 0], [252, 97, 0], [252, 97, 0], [252, 101, 0], [252, 101, 0], [252, 101, 0], [252, 101, 0], [252, 105, 0], [252, 105, 0], [252, 107, 0], [252, 109, 0], [252, 109, 0], [252, 113, 13], [255, 118, 20], [255, 119, 23], [255, 121, 25], [255, 126, 33], [255, 132, 38], [255, 133, 40], [255, 135, 43], [255, 141, 48], [255, 144, 54], [255, 150, 59], [255, 152, 61], [255, 153, 64], [255, 159, 69], [255, 163, 77], [255, 165, 79], [255, 168, 82], [255, 174, 87], [255, 176, 92], [255, 181, 97], [255, 183, 99], [255, 186, 102], [255, 191, 107], [255, 197, 115], [255, 201, 120], [255, 203, 123], [255, 205, 125], [255, 209, 130], [255, 214, 138], [255, 216, 141], [255, 218, 143], [255, 224, 150], [255, 228, 156], [255, 234, 163], [255, 236, 165], [255, 238, 168], [255, 243, 173], [255, 248, 181], [255, 252, 186], [253, 252, 186], [250, 252, 187], [244, 250, 180], [238, 247, 176], [234, 246, 173], [231, 245, 169], [223, 240, 163], [217, 237, 157], [211, 235, 150], [205, 233, 146], [200, 230, 142], [195, 227, 136], [189, 224, 132], [184, 222, 126], [180, 220, 123], [174, 217, 119], [169, 214, 114], [163, 212, 108], [160, 210, 105], [154, 207, 101], [148, 204, 96], [143, 201, 93], [138, 199, 88], [134, 197, 84], [130, 194, 81], [126, 191, 77], [117, 189, 70], [115, 186, 68], [112, 184, 64], [106, 181, 60], [100, 179, 55], [94, 176, 49], [92, 174, 47], [90, 173, 45], [81, 168, 37], [75, 166, 33], [71, 163, 28], [66, 160, 24], [62, 158, 21], [56, 156, 14], [51, 153, 0], [51, 153, 0], [51, 153, 0], [50, 150, 0], [50, 150, 0], [50, 150, 0], [50, 150, 0], [49, 148, 0], [49, 148, 0], [49, 148, 0], [48, 145, 0], [48, 145, 0], [48, 145, 0], [48, 145, 0], [48, 143, 0], [48, 143, 0], [48, 143, 0], [48, 143, 0], [47, 140, 0], [47, 140, 0], [47, 140, 0], [47, 140, 0], [46, 138, 0], [46, 138, 0], [46, 138, 0], [46, 138, 0], [45, 135, 0], [45, 135, 0], [45, 135, 0], [45, 135, 0], [44, 133, 0], [44, 133, 0], [44, 133, 0], [43, 130, 0], [43, 130, 0], [43, 130, 0], [43, 130, 0], [43, 130, 0], [43, 130, 0], [42, 128, 0], [42, 128, 0], [42, 128, 0], [42, 125, 0], [42, 125, 0], [42, 125, 0], [42, 125, 0], [41, 122, 0], [41, 122, 0], [41, 122, 0], [41, 122, 0], [40, 120, 0], [40, 120, 0], [40, 120, 0], [40, 120, 0], [40, 120, 0], [39, 117, 0], [39, 117, 0], [39, 117, 0], [39, 117, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0]];
function e5(t6, o9) {
  const e9 = [], n21 = [];
  for (let r11 = 0; r11 < t6.length - 1; r11++) e9.push({ type: "algorithmic", algorithm: "esriHSVAlgorithm", fromColor: t6[r11].slice(1), toColor: t6[r11 + 1].slice(1) }), n21.push(t6[r11 + 1][0] - t6[r11][0]);
  const s11 = t6[t6.length - 1][0];
  return w2({ type: "multipart", colorRamps: e9 }, { numColors: s11, weights: o9 = o9 ?? n21 });
}
function n7() {
  return e5([[0, 0, 191, 191], [51, 0, 0, 255], [102, 255, 0, 255], [153, 255, 0, 127], [204, 191, 63, 127], [256, 20, 20, 20]]);
}
function s6() {
  const r11 = e5([[0, 255, 255, 255], [70, 0, 255, 0], [80, 205, 173, 193], [100, 150, 150, 150], [110, 120, 51, 100], [130, 120, 100, 200], [140, 28, 3, 144], [160, 6, 0, 55], [180, 10, 25, 30], [201, 6, 7, 27]]);
  for (let t6 = r11.length; t6 < 256; t6++) r11.push([6, 27, 7]);
  return r11;
}
function l9() {
  return w2({ type: "algorithmic", algorithm: "esriHSVAlgorithm", fromColor: [0, 0, 0], toColor: [255, 255, 255] });
}
function i7() {
  const r11 = [];
  for (let t6 = 0; t6 < 256; t6++) {
    const t7 = [];
    for (let r12 = 0; r12 < 3; r12++) t7.push(Math.round(255 * Math.random()));
    r11.push(t7);
  }
  return r11;
}
function a10() {
  return e5([[0, 38, 41, 54], [69, 79, 82, 90], [131, 156, 156, 156], [256, 253, 253, 241]], [0.268, 0.238, 0.495]);
}
function c12(r11) {
  let e9;
  switch (r11) {
    case "elevation":
      e9 = n7();
      break;
    case "gray":
      e9 = l9();
      break;
    case "hillshade":
      e9 = a10();
      break;
    case "ndvi":
      e9 = t3;
      break;
    case "ndvi2":
      e9 = s6();
      break;
    case "ndvi3":
      e9 = o5;
      break;
    case "random":
      e9 = i7();
  }
  return e9 ? (e9 = e9.map((r12, t6) => [t6, ...r12]), e9) : null;
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/ColormapFunction.js
var m13 = class extends p3 {
  constructor() {
    super(...arguments), this.functionName = "Colormap", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isNoopProcess = true;
  }
  _bindSourceRasters() {
    const o9 = this.sourceRasterInfos[0];
    if (o9.bandCount > 1) return { success: false, supportsGPU: false, error: "colormap-function: source data must be single band" };
    let { colormap: r11, colormapName: t6, colorRamp: s11, colorRampName: e9 } = this.functionArguments;
    if (!r11?.length) if (s11) this.colorRamp = s11, r11 = B(s11, { interpolateAlpha: true });
    else if (e9) {
      const o10 = d2(e9);
      o10 && (r11 = B(o10), this.colorRamp = p(o10));
    } else t6 && (r11 = c12(t6));
    if (!r11?.length) return { success: false, supportsGPU: false, error: "colormap-function: missing colormap argument" };
    const p18 = this._getOutputPixelType(o9.pixelType);
    this.outputPixelType = p18.startsWith("f") ? "s32" : p18;
    const m19 = o9.clone();
    return m19.pixelType = this.outputPixelType, m19.colormap = r11, m19.bandCount = 1, this.rasterInfo = m19, { success: true, supportsGPU: true };
  }
  _processPixels(o9) {
    let r11 = o9.pixelBlocks?.[0];
    return !r11 || r3(r11.pixelType) || (r11 = r11.clone(), r11.clamp(this.outputPixelType)), r11;
  }
};
__decorate([m({ json: { write: true, name: "rasterFunction" } })], m13.prototype, "functionName", void 0), __decorate([m({ type: d6, json: { write: true, name: "rasterFunctionArguments" } })], m13.prototype, "functionArguments", void 0), __decorate([m()], m13.prototype, "rasterArgumentNames", void 0), __decorate([m()], m13.prototype, "isNoopProcess", void 0), __decorate([m({ json: { write: true } })], m13.prototype, "indexedColormap", void 0), __decorate([m()], m13.prototype, "colorRamp", void 0), m13 = __decorate([a2("esri.layers.support.rasterFunctions.ColormapFunction")], m13);
var u11 = m13;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ColormapToRGBFunctionArguments.js
var t4;
var e6 = t4 = class extends p2 {
  clone() {
    return new t4({ raster: this.raster });
  }
};
e6 = t4 = __decorate([a2("esri.layers.support.rasterFunctions.ColormapToRGBFunctionArguments")], e6);
var a11 = e6;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ColormapToRGBFunction.js
var a12 = class extends p3 {
  constructor() {
    super(...arguments), this.functionName = "ColormapToRGB", this.functionArguments = null, this.rasterArgumentNames = ["raster"];
  }
  _bindSourceRasters() {
    const t6 = this.sourceRasterInfos[0];
    if (t6.bandCount > 1 || !t6.colormap?.length) return { success: false, supportsGPU: false, error: "colormap-to-rgb-function: source data must be single band with a colormap" };
    const o9 = t6.clone();
    o9.pixelType = this.outputPixelType = this._getOutputPixelType("u8"), this._removeStatsHistColormapVAT(o9), o9.bandCount = 3, o9.statistics = [{ min: 0, max: 255, avg: 100, stddev: 20 }, { min: 0, max: 255, avg: 100, stddev: 20 }, { min: 0, max: 255, avg: 100, stddev: 20 }], this.rasterInfo = o9;
    const r11 = [...t6.colormap].sort((t7, o10) => t7[0] - o10[0]), { indexedColormap: e9, offset: s11 } = a3({ colormap: r11 });
    return e9 ? (this.lookup = { indexedColormap: e9, offset: s11 }, { success: true, supportsGPU: a5(e9) }) : { success: false, supportsGPU: false, error: "colormap-to-rgb-function: the colormap is not supported" };
  }
  _processPixels(t6) {
    let o9 = t6.pixelBlocks?.[0];
    if (!o9 || !this.lookup) return o9;
    o9 = o9.clone();
    const r11 = o9.pixels[0], s11 = o9.mask ?? new Uint8Array(r11.length).fill(255), n21 = new Uint8Array(r11.length), i25 = new Uint8Array(r11.length), p18 = new Uint8Array(r11.length), { indexedColormap: a29, offset: m19 } = this.lookup, u20 = a29.length;
    for (let e9 = 0; e9 < r11.length; e9++) if (s11[e9]) {
      let t7 = 4 * (r11[e9] - m19);
      t7 < 0 || t7 > u20 - 4 ? s11[e9] = 0 : (n21[e9] = a29[t7++], i25[e9] = a29[t7++], p18[e9] = a29[t7++]);
    }
    return o9.pixels = [n21, i25, p18], o9.statistics = [new l2(0, 255), new l2(0, 255), new l2(0, 255)], o9.pixelType = this.outputPixelType, o9;
  }
  _getWebGLParameters() {
    return this.lookup;
  }
};
__decorate([m({ json: { write: true, name: "rasterFunction" } })], a12.prototype, "functionName", void 0), __decorate([m({ type: a11, json: { write: true, name: "rasterFunctionArguments" } })], a12.prototype, "functionArguments", void 0), __decorate([m()], a12.prototype, "rasterArgumentNames", void 0), __decorate([m({ json: { write: true } })], a12.prototype, "lookup", void 0), a12 = __decorate([a2("esri.layers.support.rasterFunctions.ColormapToRGBFunction")], a12);
var m14 = a12;

// node_modules/@arcgis/core/layers/support/rasterFunctions/CompositeBandFunctionArguments.js
var a13;
var c13 = a13 = class extends p2 {
  constructor() {
    super(...arguments), this.rasters = [];
  }
  writeRasters(r11, s11) {
    s11.rasters = r11.map((r12) => "number" == typeof r12 || "string" == typeof r12 ? r12 : r12.toJSON());
  }
  clone() {
    return new a13({ rasters: a(this.rasters) });
  }
};
__decorate([m({ json: { write: true } })], c13.prototype, "rasters", void 0), __decorate([r("rasters")], c13.prototype, "writeRasters", null), c13 = a13 = __decorate([a2("esri.layers.support.rasterFunctions.CompositeBandFunctionArguments")], c13);
var i8 = c13;

// node_modules/@arcgis/core/layers/support/rasterFunctions/CompositeBandFunction.js
var i9 = class extends p3 {
  constructor() {
    super(...arguments), this.functionName = "CompositeBand", this.functionArguments = null, this.rasterArgumentNames = ["rasters"];
  }
  _bindSourceRasters() {
    const { sourceRasterInfos: t6 } = this, s11 = t6[0];
    this.outputPixelType = this._getOutputPixelType(s11.pixelType);
    const e9 = s11.clone();
    if (e9.attributeTable = null, e9.colormap = null, e9.pixelType = this.outputPixelType, e9.bandCount = t6.map(({ bandCount: t7 }) => t7).reduce((t7, s12) => t7 + s12), t6.every(({ statistics: t7 }) => null != t7 && t7.length)) {
      const s12 = [];
      t6.forEach(({ statistics: t7 }) => null != t7 && s12.push(...t7)), e9.statistics = s12;
    }
    if (t6.every(({ histograms: t7 }) => null != t7 && t7.length)) {
      const s12 = [];
      t6.forEach(({ histograms: t7 }) => null != t7 && s12.push(...t7)), e9.histograms = s12;
    }
    e9.multidimensionalInfo && e9.multidimensionalInfo.variables.forEach((s12) => {
      const e10 = t6.map((t7) => t7.multidimensionalInfo?.variables.find(({ name: t8 }) => t8 === s12.name)), r12 = e10.map((t7) => t7?.statistics?.length ? t7.statistics : null), o9 = e10.map((t7) => t7?.histograms?.length ? t7.histograms : null);
      s12.statistics = r12.every((t7) => null != t7) ? r12.flat() : null, s12.histograms = o9.every((t7) => null != t7) ? o9.flat() : null;
    }), e9.bandCount > 1 && (e9.colormap = null, e9.attributeTable = null);
    const r11 = t6.every((t7) => t7.keyProperties.BandProperties?.length) ? t6.flatMap((t7) => t7.keyProperties.BandProperties) : void 0;
    e9.keyProperties = { ...e9.keyProperties, BandProperties: r11 }, this.rasterInfo = e9;
    return { success: true, supportsGPU: e9.bandCount <= 3 };
  }
  _processPixels(t6) {
    const { pixelBlocks: s11 } = t6;
    if (!s11) return null;
    const e9 = s11?.[0];
    return null == e9 ? null : r4(s11);
  }
  _getWebGLParameters() {
    return { bandCount: this.rasterInfo.bandCount };
  }
};
__decorate([m({ json: { write: true, name: "rasterFunction" } })], i9.prototype, "functionName", void 0), __decorate([m({ type: i8, json: { write: true, name: "rasterFunctionArguments" } })], i9.prototype, "functionArguments", void 0), __decorate([m()], i9.prototype, "rasterArgumentNames", void 0), i9 = __decorate([a2("esri.layers.support.rasterFunctions.CompositeBandFunction")], i9);
var a14 = i9;

// node_modules/@arcgis/core/layers/support/rasterFunctions/changeDetectionUtils.js
var n8 = new o({ 0: "difference", 1: "relative-difference", 2: "categorical", 3: "euclidean-distance", 4: "angle-difference", 5: "band-with-most-change" }, { useNumericKeys: true });
var s7 = new o({ 0: "all", 1: "changed", 2: "unchanged" }, { useNumericKeys: true });
function i10(e9, n21, s11, i25) {
  const [f9, h6] = e9, m19 = r3(s11) && !r3(f9.pixelType) && !r3(h6.pixelType), p18 = [f9.mask, h6.mask].filter((e10) => e10), u20 = c2.combineBandMasks(p18), g4 = e9.map((e10) => e10.pixels[0]), { width: k5, height: x6 } = f9, b4 = c2.createEmptyBand(s11, k5 * x6);
  switch (n21) {
    case "difference":
    case "relative-difference":
      o6({ bands: g4, mask: u20, outBand: b4, isRoundingNeeded: m19, isRelative: "relative-difference" === n21 });
      break;
    case "categorical":
      c14({ bands: g4, mask: u20, outBand: b4, ...i25 });
      break;
    case "euclidean-distance":
      l10({ pixels: e9.map((e10) => e10.pixels), mask: u20, outBand: b4 });
      break;
    case "angle-difference":
      r7({ pixels: e9.map((e10) => e10.pixels), mask: u20, outBand: b4 });
      break;
    case "band-with-most-change":
      d7({ pixels: e9.map((e10) => e10.pixels), mask: u20, outBand: b4 });
  }
  const B5 = new c2({ width: k5, height: x6, pixels: [b4], pixelType: s11, mask: u20 });
  return B5.updateStatistics(), B5;
}
function o6(e9) {
  const { bands: [t6, a29], mask: n21, isRelative: s11, isRoundingNeeded: i25, outBand: o9 } = e9, c35 = t6.length;
  for (let l22 = 0; l22 < c35; l22++) if (!n21 || n21[l22]) {
    let e10 = t6[l22] - a29[l22];
    if (s11) {
      const n22 = Math.max(Math.abs(t6[l22]) - Math.abs(a29[l22]));
      e10 = n22 > 0 ? e10 / n22 : 0;
    }
    o9[l22] = i25 ? Math.round(e10) : e10;
  }
}
function c14(e9) {
  const { bands: [t6, a29], categoryIndexLookups: [n21, s11], classNames: [i25, o9], mask: c35, keepMethod: l22, outBand: r11 } = e9, d9 = t6.length, f9 = i25.length, h6 = o9.length, m19 = f9 * h6, p18 = m19 + 1, u20 = m19 + 2;
  for (let g4 = 0; g4 < d9; g4++) if (!c35 || c35[g4]) {
    const e10 = t6[g4], c36 = a29[g4], d10 = n21[e10], f10 = s11[c36], k5 = i25[d10], x6 = o9[f10];
    r11[g4] = null == d10 || null == f10 ? m19 : "changed" === l22 && k5 === x6 ? p18 : "unchanged" === l22 && k5 !== x6 ? u20 : d10 * h6 + f10;
  }
}
function l10(e9) {
  const { pixels: [t6, a29], mask: n21, outBand: s11 } = e9, i25 = t6[0].length, o9 = t6.length;
  for (let c35 = 0; c35 < i25; c35++) if (!n21 || n21[c35]) {
    let e10 = 0;
    for (let n22 = 0; n22 < o9; n22++) {
      const s12 = t6[n22][c35] - a29[n22][c35];
      e10 += s12 * s12;
    }
    s11[c35] = Math.sqrt(e10);
  }
}
function r7(e9) {
  const { pixels: [t6, a29], mask: n21, outBand: s11 } = e9, i25 = t6[0].length, o9 = t6.length;
  for (let c35 = 0; c35 < i25; c35++) if (!n21 || n21[c35]) {
    let e10 = 0, n22 = 0, i26 = 0;
    for (let s12 = 0; s12 < o9; s12++) {
      const o10 = t6[s12][c35], l23 = a29[s12][c35];
      e10 += o10 * l23, n22 += o10 * o10, i26 += l23 * l23;
    }
    const l22 = Math.sqrt(n22 * i26);
    s11[c35] = l22 ? Math.acos(e10 / l22) : 1.5707963267948966;
  }
}
function d7(e9) {
  const { pixels: [t6, a29], mask: n21, outBand: s11 } = e9, i25 = t6[0].length, o9 = t6.length;
  for (let c35 = 0; c35 < i25; c35++) if (!n21 || n21[c35]) {
    let e10 = 0, n22 = 0;
    for (let s12 = 0; s12 < o9; s12++) {
      const i26 = Math.abs(t6[s12][c35] - a29[s12][c35]);
      i26 > e10 && (e10 = i26, n22 = s12);
    }
    s11[c35] = n22;
  }
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/ComputeChangeFunctionArguments.js
var a15;
var c15 = a15 = class extends p2 {
  constructor() {
    super(...arguments), this.method = "difference", this.keepMethod = "all", this.raster2 = void 0;
  }
  get rasters() {
    return [this.raster, this.raster2];
  }
  clone() {
    return new a15({ raster: this.raster, raster2: this.raster2, method: this.method, keepMethod: this.keepMethod });
  }
};
__decorate([r2(n8)], c15.prototype, "method", void 0), __decorate([r2(s7)], c15.prototype, "keepMethod", void 0), __decorate([m({ json: { write: true } })], c15.prototype, "raster2", void 0), __decorate([m({ readOnly: true })], c15.prototype, "rasters", null), c15 = a15 = __decorate([a2("esri.layers.support.rasterFunctions.ComputeChangeFunctionArguments")], c15);
var n9 = c15;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ComputeChangeFunction.js
var l11 = class extends p3 {
  constructor() {
    super(...arguments), this.functionName = "ComputeChange", this.functionArguments = null, this.rasterArgumentNames = ["raster", "raster2"];
  }
  _bindSourceRasters() {
    const { method: e9 } = this.functionArguments, t6 = this.sourceRasterInfos[0].clone();
    if (this.outputPixelType = this._getOutputPixelType(t6.pixelType), t6.pixelType = this.outputPixelType, this._removeStatsHistColormapVAT(t6), "categorical" === e9) {
      const e10 = this.sourceRasterInfos.map((e11) => e11.attributeTable), s11 = this._getFieldNames(e10, "value"), r11 = e10.map((e11) => this._getClassFieldName(e11));
      if (null == s11[0] || null == s11[1] || null == r11[0] || null == r11[1]) return { success: false, supportsGPU: false, error: "both inputs must have proper attribute table with value and class fields" };
      this._updateAttributeTable(t6, s11, r11);
    }
    t6.bandCount = 1, this.rasterInfo = t6;
    return { success: true, supportsGPU: "difference" === e9 || "relative-difference" === e9 };
  }
  _processPixels(e9) {
    const { pixelBlocks: t6 } = e9;
    if (null == t6?.[0] || null == t6?.[1]) return null;
    const { method: s11 } = this.functionArguments;
    return i10(t6, s11, this.outputPixelType, this._categoryConfig);
  }
  _getWebGLParameters() {
    const e9 = this.outputPixelType ?? "f32";
    let [t6, s11] = u(e9);
    const r11 = r3(e9);
    return r11 && (t6 -= 1e-4, s11 += 1e-4), { method: this.functionArguments.method, domainRange: [t6, s11], isOutputRounded: r11 };
  }
  _updateAttributeTable(e9, t6, s11) {
    const n21 = this.sourceRasterInfos.map((e10) => e10.attributeTable), o9 = n21.map((e10, s12) => e10.features.map((e11) => e11.attributes[t6[s12]])), a29 = n21.map((e10, t7) => e10.features.map((e11) => e11.attributes[s11[t7]])), i25 = o9.map((e10) => {
      const t7 = [];
      return e10.forEach((e11, s12) => t7[e11] = s12), t7;
    }), { keepMethod: u20 } = this.functionArguments;
    this._categoryConfig = { categoryIndexLookups: i25, classNames: a29, keepMethod: u20 };
    const l22 = n21[0].clone();
    l22.fields = [new m2({ name: "OID", type: "oid" }), new m2({ name: "Value", type: "integer" }), new m2({ name: "ClassName", type: "string" }), new m2({ name: "Class_From", type: "string" }), new m2({ name: "Class_To", type: "string" })];
    const m19 = this._getFieldNames(n21, "red"), p18 = this._getFieldNames(n21, "green"), c35 = this._getFieldNames(n21, "blue"), d9 = [], g4 = 2 === m19.length && 2 === p18.length && 2 === c35.length;
    g4 && (d9.push(...n21.map((e10, t7) => e10.features.map((e11) => [e11.attributes[m19[t7]], e11.attributes[p18[t7]], e11.attributes[c35[t7]]]))), l22.fields.push(new m2({ name: "Red", type: "integer" }), new m2({ name: "Green", type: "integer" }), new m2({ name: "Blue", type: "integer" })));
    const h6 = l22.features[0].clone();
    h6.geometry = null;
    const f9 = [], [y3, C2] = o9.map((e10) => e10.length);
    let b4 = 1;
    for (let r11 = 0; r11 < y3; r11++) {
      const e10 = a29[0][r11];
      for (let t7 = 0; t7 < C2; t7++) {
        const s12 = a29[1][t7];
        if ("changed" === u20 && e10 === s12 || "unchanged" === u20 && e10 !== s12) continue;
        const n22 = h6.clone();
        n22.attributes = { OID: b4++, Value: r11 * C2 + t7, ClassName: e10 === s12 ? e10 : `${e10} -> ${s12}`, Class_From: e10, Class_To: s12 }, g4 && (n22.attributes.Red = d9[0][r11][0] + d9[1][t7][0] >> 1, n22.attributes.Green = d9[0][r11][1] + d9[1][t7][1] >> 1, n22.attributes.Blue = d9[0][r11][2] + d9[1][t7][2] >> 1), f9.push(n22);
      }
    }
    if ("changed" === u20) {
      const e10 = h6.clone();
      e10.attributes = { OID: b4++, Value: y3 * C2 + 1, ClassName: "No Change", Class_From: "Same", Class_To: "Same" }, f9.push(e10);
    } else if ("unchanged" === u20) {
      const e10 = h6.clone();
      e10.attributes = { OID: b4++, Value: y3 * C2 + 2, ClassName: "Changed", Class_From: "Any", Class_To: "Any" }, f9.push(e10);
    }
    l22.features = f9, e9.attributeTable = l22;
  }
  _getFieldNames(e9, t6) {
    return e9.map(({ fields: e10 }) => e10.find((e11) => e11.name.toLowerCase() === t6)?.name).filter((e10) => e10);
  }
  _getClassFieldName(e9) {
    const t6 = e9.fields.find((e10) => "string" === e10.type && e10.name.toLowerCase().startsWith("class")) ?? e9.fields.find((e10) => "string" === e10.type && e10.name.toLowerCase().includes("class") || e10.name.toLowerCase().includes("type") || e10.name.toLowerCase().includes("name")) ?? e9.fields.find((e10) => "string" === e10.type);
    return t6?.name;
  }
};
__decorate([m({ json: { write: true, name: "rasterFunction" } })], l11.prototype, "functionName", void 0), __decorate([m({ type: n9, json: { write: true, name: "rasterFunctionArguments" } })], l11.prototype, "functionArguments", void 0), __decorate([m()], l11.prototype, "rasterArgumentNames", void 0), __decorate([m({ json: { write: true } })], l11.prototype, "_categoryConfig", void 0), l11 = __decorate([a2("esri.layers.support.rasterFunctions.ComputeChangeFunction")], l11);
var m15 = l11;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ContrastBrightnessFunctionArguments.js
var e7;
var n10 = e7 = class extends p2 {
  constructor() {
    super(...arguments), this.contrastOffset = 0, this.brightnessOffset = 0;
  }
  clone() {
    return new e7({ contrastOffset: this.contrastOffset, brightnessOffset: this.brightnessOffset, raster: this.raster });
  }
};
__decorate([m({ json: { write: true } })], n10.prototype, "contrastOffset", void 0), __decorate([m({ json: { write: true } })], n10.prototype, "brightnessOffset", void 0), n10 = e7 = __decorate([a2("esri.layers.support.rasterFunctions.ContrastBrightnessFunctionArguments")], n10);
var i11 = n10;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ContrastBrightnessFunction.js
var u12 = class extends p3 {
  constructor() {
    super(...arguments), this.functionName = "ContrastBrightness", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.lookup = null;
  }
  _bindSourceRasters() {
    const { sourceRasterInfos: t6 } = this, s11 = t6[0];
    if ("u8" !== s11.pixelType) return { success: false, supportsGPU: false, error: "Only unsigned 8 bit raster is supported by ContrastBrightness function." };
    this.outputPixelType = this._getOutputPixelType("u8");
    const r11 = s11.clone();
    this._removeStatsHistColormapVAT(r11), this.rasterInfo = r11;
    const { contrastOffset: o9, brightnessOffset: e9 } = this.functionArguments;
    return this.lookup = u3(o9, e9), { success: true, supportsGPU: true };
  }
  _processPixels(t6) {
    const s11 = t6.pixelBlocks?.[0];
    return null == s11 ? null : f3(s11, { lut: s11.pixels.map(() => this.lookup), offset: 0, outputPixelType: "u8" });
  }
  _getWebGLParameters() {
    const { contrastOffset: t6, brightnessOffset: s11 } = this.functionArguments;
    return { contrastOffset: t6, brightnessOffset: s11 };
  }
};
__decorate([m({ json: { write: true, name: "rasterFunction" } })], u12.prototype, "functionName", void 0), __decorate([m({ type: i11, json: { write: true, name: "rasterFunctionArguments" } })], u12.prototype, "functionArguments", void 0), __decorate([m()], u12.prototype, "rasterArgumentNames", void 0), __decorate([m({ json: { write: true } })], u12.prototype, "lookup", void 0), u12 = __decorate([a2("esri.layers.support.rasterFunctions.ContrastBrightnessFunction")], u12);
var p10 = u12;

// node_modules/@arcgis/core/layers/support/rasterFunctions/mirror.js
function o7(o9, t6, f9, r11, l22) {
  const e9 = Math.floor(r11 / 2);
  for (let c35 = 0; c35 < e9; c35++) for (let r12 = 0; r12 < t6; r12++) o9[c35 * t6 + r12] = o9[(l22 - 1 - c35) * t6 + r12], o9[(f9 - 1 - c35) * t6 + r12] = o9[(f9 - l22 + c35) * t6 + r12];
  const n21 = Math.floor(l22 / 2);
  for (let c35 = 0; c35 < f9; c35++) {
    const f10 = c35 * t6;
    for (let r12 = 0; r12 < n21; r12++) o9[f10 + r12] = o9[f10 + l22 - 1 - r12], o9[f10 + t6 - r12 - 1] = o9[f10 + t6 + r12 - l22];
  }
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/convolutionUtils.js
var l12 = /* @__PURE__ */ new Map();
function o8(e9) {
  const t6 = Math.sqrt(e9.length), n21 = e9.slice(0, t6), l22 = [1];
  for (let o9 = 1; o9 < t6; o9++) {
    let n22 = null;
    for (let l23 = 0; l23 < t6; l23++) {
      const r11 = e9[l23 + o9 * t6], s11 = e9[l23];
      if (null == n22) if (0 === s11) {
        if (r11) return { separable: false, row: null, col: null };
      } else n22 = r11 / s11;
      else if (r11 / s11 !== n22) return { separable: false, row: null, col: null };
    }
    if (null == n22) return { separable: false, row: null, col: null };
    l22.push(n22);
  }
  return { separable: true, row: n21, col: l22 };
}
function r8(e9, t6, n21, l22, o9, r11, s11) {
  const i25 = new Float32Array(t6 * n21), a29 = r11.length, h6 = s11 ? 0 : l22, c35 = s11 ? l22 : 0, p18 = s11 ? 1 : t6;
  for (let u20 = h6; u20 < n21 - h6; u20++) {
    const n22 = u20 * t6;
    for (let s12 = c35; s12 < t6 - c35; s12++) {
      if (o9 && !o9[n22 + s12]) continue;
      let t7 = 0;
      for (let o10 = 0; o10 < a29; o10++) t7 += e9[n22 + s12 + (o10 - l22) * p18] * r11[o10];
      i25[n22 + s12] = t7;
    }
  }
  return i25;
}
function s8(e9, t6, n21, l22, o9, r11, s11) {
  const i25 = new Float32Array(t6 * n21), a29 = Math.floor(l22 / 2), h6 = Math.floor(o9 / 2);
  for (let c35 = a29; c35 < n21 - a29; c35++) {
    const n22 = c35 * t6;
    for (let c36 = h6; c36 < t6 - h6; c36++) {
      if (r11 && !r11[n22 + c36]) continue;
      let p18 = 0;
      for (let r12 = 0; r12 < l22; r12++) for (let l23 = 0; l23 < o9; l23++) p18 += e9[n22 + c36 + (r12 - a29) * t6 + l23 - h6] * s11[r12 * o9 + l23];
      i25[n22 + c36] = p18;
    }
  }
  return i25;
}
function i12(t6, l22, o9 = true) {
  const { pixels: r11, width: i25, height: a29, pixelType: h6, mask: c35 } = t6, p18 = r11.length, u20 = [], { kernel: f9, rows: g4, cols: m19 } = l22;
  for (let e9 = 0; e9 < p18; e9++) {
    const t7 = s8(r11[e9], i25, a29, g4, m19, c35, f9);
    o9 && o7(t7, i25, a29, g4, m19), u20.push(t7);
  }
  return new c2({ width: i25, height: a29, pixelType: h6, pixels: u20, mask: c35 });
}
function a16(t6, l22, o9, s11 = true) {
  const { pixels: i25, width: a29, height: h6, pixelType: c35, mask: p18 } = t6, u20 = i25.length, f9 = [], g4 = l22.length, m19 = o9.length, x6 = Math.floor(g4 / 2), w7 = Math.floor(m19 / 2);
  for (let e9 = 0; e9 < u20; e9++) {
    let t7 = r8(i25[e9], a29, h6, x6, p18, l22, true);
    t7 = r8(t7, a29, h6, w7, p18, o9, false), s11 && o7(t7, a29, h6, g4, m19), f9.push(t7);
  }
  return new c2({ width: a29, height: h6, pixelType: c35, pixels: f9, mask: p18 });
}
function h4(e9, t6) {
  const n21 = o8(t6.kernel), l22 = false !== t6.mirrorEdges, r11 = n21.separable ? a16(e9, n21.row, n21.col, l22) : i12(e9, t6, l22), { outputPixelType: s11 } = t6;
  return s11 && r11.clamp(s11), r11;
}
l12.set(D2.none, [0, 0, 0, 0, 1, 0, 0, 0, 0]), l12.set(D2.lineDetectionHorizontal, [-1, -1, -1, 2, 2, 2, -1, -1, -1]), l12.set(D2.lineDetectionVertical, [-1, 2, -1, -1, 2, -1, -1, 2, -1]), l12.set(D2.lineDetectionLeftDiagonal, [2, -1, -1, -1, 2, -1, -1, -1, 2]), l12.set(D2.lineDetectionRightDiagonal, [-1, -1, 2, -1, 2, -1, 2, -1, -1]), l12.set(D2.gradientNorth, [-1, -2, -1, 0, 0, 0, 1, 2, 1]), l12.set(D2.gradientWest, [-1, 0, 1, -2, 0, 2, -1, 0, 1]), l12.set(D2.gradientEast, [1, 0, -1, 2, 0, -2, 1, 0, -1]), l12.set(D2.gradientSouth, [1, 2, 1, 0, 0, 0, -1, -2, -1]), l12.set(D2.gradientNorthEast, [0, -1, -2, 1, 0, -1, 2, 1, 0]), l12.set(D2.gradientNorthWest, [-2, -1, 0, -1, 0, 1, 0, 1, 2]), l12.set(D2.smoothArithmeticMean, [0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111]), l12.set(D2.smoothing3x3, [0.0625, 0.125, 0.0625, 0.125, 0.25, 0.125, 0.0625, 0.125, 0.0625]), l12.set(D2.smoothing5x5, [1, 1, 1, 1, 1, 1, 4, 4, 4, 1, 1, 4, 12, 4, 1, 1, 4, 4, 4, 1, 1, 1, 1, 1, 1]), l12.set(D2.sharpening3x3, [-1, -1, -1, -1, 9, -1, -1, -1, -1]), l12.set(D2.sharpening5x5, [-1, -3, -4, -3, -1, -3, 0, 6, 0, -3, -4, 6, 21, 6, -4, -3, 0, 6, 0, -3, -1, -3, -4, -3, -1]), l12.set(D2.laplacian3x3, [0, -1, 0, -1, 4, -1, 0, -1, 0]), l12.set(D2.laplacian5x5, [0, 0, -1, 0, 0, 0, -1, -2, -1, 0, -1, -2, 17, -2, -1, 0, -1, -2, -1, 0, 0, 0, -1, 0, 0]), l12.set(D2.sobelHorizontal, [-1, -2, -1, 0, 0, 0, 1, 2, 1]), l12.set(D2.sobelVertical, [-1, 0, 1, -2, 0, 2, -1, 0, 1]), l12.set(D2.sharpen, [0, -0.25, 0, -0.25, 2, -0.25, 0, -0.25, 0]), l12.set(D2.sharpen2, [-0.25, -0.25, -0.25, -0.25, 3, -0.25, -0.25, -0.25, -0.25]), l12.set(D2.pointSpread, [-0.627, 0.352, -0.627, 0.352, 2.923, 0.352, -0.627, 0.352, -0.627]);

// node_modules/@arcgis/core/layers/support/rasterFunctions/ConvolutionFunctionArguments.js
var p11;
var c16 = p11 = class extends p2 {
  constructor() {
    super(...arguments), this.rows = 3, this.cols = 3, this.kernel = [0, 0, 0, 0, 1, 0, 0, 0, 0];
  }
  set convolutionType(o9) {
    this._set("convolutionType", o9);
    const t6 = l12.get(o9);
    if (!t6 || o9 === D2.userDefined || o9 === D2.none) return;
    const r11 = Math.sqrt(t6.length);
    this._set("kernel", t6), this._set("cols", r11), this._set("rows", r11);
  }
  clone() {
    return new p11({ cols: this.cols, rows: this.rows, kernel: [...this.kernel], convolutionType: this.convolutionType, raster: a(this.raster) });
  }
};
__decorate([m({ json: { type: Number, write: true } })], c16.prototype, "rows", void 0), __decorate([m({ json: { type: Number, write: true } })], c16.prototype, "cols", void 0), __decorate([m({ json: { name: "type", type: Number, write: true } })], c16.prototype, "convolutionType", null), __decorate([m({ json: { type: [Number], write: true } })], c16.prototype, "kernel", void 0), c16 = p11 = __decorate([a2("esri.layers.support.rasterFunctions.ConvolutionFunctionArguments")], c16);
var l13 = c16;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ConvolutionFunction.js
var l14 = 25;
var c17 = class extends p3 {
  constructor() {
    super(...arguments), this.functionName = "Convolution", this.rasterArgumentNames = ["raster"];
  }
  get _normalizedKernel() {
    const { kernel: t6, convolutionType: e9 } = this.functionArguments, o9 = t6.reduce((t7, e10) => t7 + e10);
    return -1 === e9 || 0 === o9 || 1 === o9 ? t6 : t6.map((t7) => t7 / o9);
  }
  _bindSourceRasters() {
    const { convolutionType: t6, rows: e9, cols: o9, kernel: s11 } = this.functionArguments;
    if (!Object.values(D2).includes(t6)) return { success: false, supportsGPU: false, error: `convolution-function: the specified kernel type is not supported ${t6}` };
    if (t6 !== D2.none && e9 * o9 !== s11.length) return { success: false, supportsGPU: false, error: "convolution-function: the specified rows and cols do not match the length of the kernel" };
    const n21 = this.sourceRasterInfos[0];
    this.outputPixelType = this._getOutputPixelType(n21.pixelType);
    const i25 = n21.clone();
    i25.pixelType = this.outputPixelType;
    const u20 = [D2.none, D2.sharpen, D2.sharpen2, D2.sharpening3x3, D2.sharpening5x5];
    (-1 === t6 || "u8" !== this.outputPixelType && !u20.includes(t6)) && (i25.statistics = null, i25.histograms = null), i25.colormap = null, i25.attributeTable = null, this.rasterInfo = i25;
    return { success: true, supportsGPU: s11.length <= l14 };
  }
  _processPixels(t6) {
    const e9 = t6.pixelBlocks?.[0];
    if (null == e9 || this.functionArguments.convolutionType === D2.none) return e9;
    const { rows: o9, cols: s11 } = this.functionArguments, { _normalizedKernel: n21 } = this;
    return h4(e9, { kernel: n21, rows: o9, cols: s11, outputPixelType: this.outputPixelType });
  }
  _getWebGLParameters() {
    const t6 = new Float32Array(l14), { rows: e9, cols: o9 } = this.functionArguments, { _normalizedKernel: r11 } = this;
    for (let s11 = 0; s11 < e9; s11++) for (let e10 = 0; e10 < o9; e10++) t6[5 * s11 + e10] = r11[s11 * o9 + e10];
    return { kernelRows: e9, kernelCols: o9, kernel: t6, clampRange: u(this.outputPixelType) };
  }
};
__decorate([m({ json: { write: true, name: "rasterFunction" } })], c17.prototype, "functionName", void 0), __decorate([m({ type: l13, json: { write: true, name: "rasterFunctionArguments" } })], c17.prototype, "functionArguments", void 0), __decorate([m()], c17.prototype, "rasterArgumentNames", void 0), __decorate([m()], c17.prototype, "_normalizedKernel", null), c17 = __decorate([a2("esri.layers.support.rasterFunctions.ConvolutionFunction")], c17);
var p12 = c17;

// node_modules/@arcgis/core/layers/support/rasterFunctions/CurvatureFunctionArguments.js
var c18;
var u13 = new o({ 0: "standard", 1: "planform", 2: "profile" }, { useNumericKeys: true });
var i13 = c18 = class extends p2 {
  constructor() {
    super(...arguments), this.curvatureType = "standard", this.zFactor = 1;
  }
  readCurvatureType(r11, e9) {
    return u13.fromJSON(e9.type ?? e9.curvatureType ?? 0);
  }
  clone() {
    return new c18({ curvatureType: this.curvatureType, zFactor: this.zFactor, raster: this.raster });
  }
};
__decorate([m({ json: { write: { target: "type" } } }), r2(u13)], i13.prototype, "curvatureType", void 0), __decorate([o2("curvatureType", ["type", "curvatureType"])], i13.prototype, "readCurvatureType", null), __decorate([m({ type: Number, json: { write: true } })], i13.prototype, "zFactor", void 0), i13 = c18 = __decorate([a2("esri.layers.support.rasterFunctions.CurvatureFunctionArguments")], i13);
var n11 = i13;

// node_modules/@arcgis/core/layers/support/rasterFunctions/CurvatureFunction.js
var u14 = class extends p3 {
  constructor() {
    super(...arguments), this.functionName = "Curvature", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isGCS = false;
  }
  _bindSourceRasters() {
    this.outputPixelType = this._getOutputPixelType("f32");
    const t6 = this.sourceRasterInfos[0].clone();
    return t6.pixelType = this.outputPixelType, t6.bandCount = 1, this._removeStatsHistColormapVAT(t6), this.rasterInfo = t6, this.isGCS = t6.spatialReference?.isGeographic ?? false, { success: true, supportsGPU: true };
  }
  _processPixels(t6) {
    const r11 = t6.pixelBlocks?.[0];
    if (null == r11) return null;
    const { zFactor: e9, curvatureType: s11 } = this.functionArguments, { extent: o9, primaryPixelSizes: u20 } = t6, c35 = u20?.[0], a29 = c35 ?? (o9 ? { x: o9.width / r11.width, y: o9.height / r11.height } : { x: 1, y: 1 }), p18 = this.isGCS && e9 >= 1 ? e9 * n2 : e9;
    return f4(r11, { zFactor: p18, curvatureType: s11, resolution: a29 });
  }
  _getWebGLParameters() {
    const { zFactor: t6, curvatureType: r11 } = this.functionArguments;
    return { curvatureType: r11, zFactor: this.isGCS && t6 >= 1 ? t6 * n2 : t6 };
  }
};
__decorate([m({ json: { write: true, name: "rasterFunction" } })], u14.prototype, "functionName", void 0), __decorate([m({ type: n11, json: { write: true, name: "rasterFunctionArguments" } })], u14.prototype, "functionArguments", void 0), __decorate([m()], u14.prototype, "rasterArgumentNames", void 0), __decorate([m({ json: { write: true } })], u14.prototype, "isGCS", void 0), u14 = __decorate([a2("esri.layers.support.rasterFunctions.CurvatureFunction")], u14);
var c19 = u14;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ExtractBandFunctionArguments.js
var n12;
var a17 = n12 = class extends p2 {
  constructor() {
    super(...arguments), this.bandIds = [], this.bandNames = [], this.bandWavelengths = [], this.missingBandAction = 0;
  }
  clone() {
    return new n12({ bandIds: this.bandIds?.slice(), bandNames: this.bandNames?.slice(), bandWavelengths: this.bandWavelengths?.slice(), missingBandAction: this.missingBandAction, method: this.method, wavelengthMatchTolerance: this.wavelengthMatchTolerance });
  }
};
__decorate([m({ json: { write: true } })], a17.prototype, "bandIds", void 0), __decorate([m({ json: { write: true } })], a17.prototype, "bandNames", void 0), __decorate([m({ json: { write: true } })], a17.prototype, "bandWavelengths", void 0), __decorate([r2({ 0: "name", 1: "wavelength", 2: "id" })], a17.prototype, "method", void 0), __decorate([m({ json: { write: true } })], a17.prototype, "missingBandAction", void 0), __decorate([m({ json: { write: true } })], a17.prototype, "wavelengthMatchTolerance", void 0), a17 = n12 = __decorate([a2("esri.layers.support.rasterFunctions.ExtractBandFunctionArguments")], a17);
var i14 = a17;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ExtractBandFunction.js
var i15 = class extends p3 {
  constructor() {
    super(...arguments), this.functionName = "ExtractBand", this.functionArguments = null, this.rasterArgumentNames = ["raster"];
  }
  _bindSourceRasters() {
    const { functionArguments: t6, sourceRasterInfos: n21 } = this, e9 = n21[0], { method: s11, bandNames: r11, bandWavelengths: o9, bandIds: i25, missingBandAction: a29 } = t6, d9 = r11?.length && ("name" === s11 || "id" !== s11 && !i25?.length), h6 = o9?.length && ("wavelength" === s11 || "id" !== s11 && !i25?.length), m19 = 1 === a29, g4 = d9 ? l15(e9, r11) : h6 ? c20(e9, o9, this.functionArguments, m19) : u15(e9, i25, m19);
    if (null == g4) {
      return { success: false, supportsGPU: false, error: `extract-band-function: Invalid ${d9 ? "band names" : h6 ? "band wavelengths" : "band ids"} for the imagery data source` };
    }
    this.functionArguments.bandIds = g4, this.functionArguments.method = "id", this.outputPixelType = this._getOutputPixelType("f32");
    const p18 = e9.clone();
    p18.pixelType = this.outputPixelType, p18.bandCount = g4.length;
    const { statistics: f9, histograms: I3 } = p18;
    null != f9 && f9.length && (p18.statistics = g4.map((t7) => f9[t7] || f9[f9.length - 1])), null != I3 && I3.length && (p18.histograms = g4.map((t7) => I3[t7] || I3[I3.length - 1])), p18.multidimensionalInfo && p18.multidimensionalInfo.variables.forEach((t7) => {
      const { statistics: n22, histograms: e10 } = t7;
      null != n22 && n22.length && (t7.statistics = g4.map((t8) => n22[t8] || n22[n22.length - 1])), null != e10 && e10.length && (t7.histograms = g4.map((t8) => e10[t8] || e10[e10.length - 1]));
    });
    let b4 = p18.keyProperties?.BandProperties;
    b4?.length && (b4 = g4.map((t7) => t7 >= b4.length ? b4[b4.length - 1] : b4[t7]), p18.keyProperties = { ...p18.keyProperties, BandProperties: b4 }), this.rasterInfo = p18;
    return { success: true, supportsGPU: p18.bandCount <= 3 };
  }
  _processPixels(t6) {
    const n21 = t6.pixelBlocks?.[0];
    if (null == n21) return null;
    let { bandIds: e9 } = this.functionArguments;
    if (this.rasterInfo.storageInfo.isBsqTile) {
      const { rawInputBandIds: t7 } = this;
      e9 = e9.map((n22) => t7.indexOf(n22));
    } else {
      const t7 = n21.pixels.length;
      e9 = e9.map((n22) => n22 >= t7 ? t7 - 1 : n22);
    }
    return n21.extractBands(e9);
  }
  _getWebGLParameters() {
    let t6;
    if (this.isInputBandIdsSwizzled) t6 = this.swizzledBandSelection.length ? this.swizzledBandSelection : [0, 1, 2];
    else {
      t6 = [...this.functionArguments.bandIds], 0 === t6.length ? t6 = [0, 1, 2] : t6.length < 3 && (t6[1] = t6[1] ?? t6[0], t6[2] = t6[2] ?? t6[1]);
      for (let n21 = 0; n21 < 3; n21++) t6[n21] = Math.min(t6[n21], 2);
    }
    return { bandIndexMat3: c8(t6) };
  }
  _getInputBandIds(t6) {
    const n21 = t6.length;
    return this.functionArguments.bandIds.map((t7) => t7 >= n21 ? n21 - 1 : t7).map((n22) => t6[n22]);
  }
  _swizzleBandIds(t6) {
    const n21 = this.functionArguments.bandIds.map((n22) => t6.indexOf(n22));
    return this.isInputBandIdsSwizzled = true, n21[1] ??= n21[0], n21[2] ??= n21[1], this.swizzledBandSelection = n21, false;
  }
};
__decorate([m({ json: { write: true, name: "rasterFunction" } })], i15.prototype, "functionName", void 0), __decorate([m({ type: i14, json: { write: true, name: "rasterFunctionArguments" } })], i15.prototype, "functionArguments", void 0), __decorate([m()], i15.prototype, "rasterArgumentNames", void 0), i15 = __decorate([a2("esri.layers.support.rasterFunctions.ExtractBandFunction")], i15);
var a18 = i15;
function l15(t6, n21) {
  const e9 = t6.bandInfos.map(({ name: t7 }) => t7.toLowerCase()), s11 = [];
  for (let r11 = 0; r11 < n21.length; r11++) {
    const t7 = n21[r11].toLowerCase();
    let o9 = e9.indexOf(t7);
    if (-1 === o9 && "nearinfrared" === t7 && (o9 = e9.findIndex((t8) => t8.startsWith("nearinfrared_1")), -1 === o9 && (o9 = e9.findIndex((t8) => t8.startsWith("nearinfrared")))), -1 === o9) return null;
    s11.push(o9);
  }
  return s11;
}
function u15(t6, n21, e9) {
  const { bandCount: s11 } = t6;
  return !n21?.length || e9 && n21.some((t7) => t7 < 0 || t7 >= s11) ? null : n21;
}
function c20(t6, n21, { wavelengthMatchTolerance: e9 }, s11) {
  const { bandInfos: r11 } = t6, o9 = [];
  for (let a29 = 0; a29 < r11.length; a29++) {
    const { minWavelength: t7, maxWavelength: n22 } = r11[a29];
    if (!t7 || !n22) return null;
    o9.push({ minWavelength: t7, maxWavelength: n22 });
  }
  const i25 = [];
  for (let a29 = 0; a29 < n21.length; a29++) {
    const t7 = n21[a29];
    let r12 = false, l22 = -1, u20 = Number.MAX_VALUE;
    for (let n22 = 0; n22 < o9.length; n22++) {
      const e10 = o9[n22], s12 = t7 >= e10.minWavelength && t7 <= e10.maxWavelength, i26 = Math.abs(t7 - (e10.minWavelength + e10.maxWavelength) / 2);
      s12 ? i26 < u20 && (r12 = true, l22 = n22, u20 = i26) : !r12 && i26 < u20 && (l22 = n22, u20 = i26);
    }
    if (!r12 && e9 && u20 < e9 && (r12 = true), !r12 && s11) return null;
    i25.push(l22);
  }
  return i25;
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/conversionUtils.js
function i16(i25, s11, a29) {
  const { pixels: l22, width: n21, height: r11, mask: o9, bandMasks: h6 } = i25, p18 = n21 * r11, m19 = h6?.length ? c2.combineBandMasks(h6) : o9, f9 = Math.min(s11.length, l22.length), c35 = a29.startsWith("f"), d9 = !c35 && a29 !== i25.pixelType, [x6, g4] = u(a29), k5 = c2.createEmptyBand(a29, p18);
  for (let t6 = 0; t6 < r11; t6++) {
    let e9 = t6 * n21;
    for (let t7 = 0; t7 < n21; t7++, e9++) if (!m19 || m19[e9]) {
      let t8 = 0;
      for (let i26 = 0; i26 < f9; i26++) t8 += s11[i26] * l22[i26][e9];
      c35 || (t8 = Math.round(t8), d9 && (t8 = t8 > g4 ? g4 : t8 < x6 ? x6 : t8)), k5[e9] = t8;
    }
  }
  const u20 = new c2({ width: n21, height: r11, pixels: [k5], pixelType: a29, mask: m19 });
  return u20.updateStatistics(), u20;
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/GrayscaleFunctionArguments.js
var t5;
var a19 = t5 = class extends p2 {
  clone() {
    return new t5({ conversionParameters: [...this.conversionParameters], raster: this.raster });
  }
};
__decorate([m({ type: [Number], json: { write: true } })], a19.prototype, "conversionParameters", void 0), a19 = t5 = __decorate([a2("esri.layers.support.rasterFunctions.GrayscaleFunctionArguments")], a19);
var c21 = a19;

// node_modules/@arcgis/core/layers/support/rasterFunctions/GrayscaleFunction.js
var i17 = class extends p3 {
  constructor() {
    super(...arguments), this.functionName = "Grayscale", this.functionArguments = null, this.rasterArgumentNames = ["raster"];
  }
  get _normalizedWeights() {
    const { conversionParameters: t6 } = this.functionArguments, e9 = t6.reduce((t7, e10) => t7 + e10);
    return t6.map((t7) => t7 / e9);
  }
  _bindSourceRasters() {
    const { conversionParameters: t6 } = this.functionArguments;
    if (!t6?.length) return { success: false, supportsGPU: false, error: "missing valid conversion parameters." };
    const e9 = this.sourceRasterInfos[0].clone();
    this.outputPixelType = this._getOutputPixelType(e9.pixelType), e9.pixelType = this.outputPixelType;
    const r11 = 3 === t6.length || 3 === e9.bandCount && t6.length > 3;
    return e9.bandCount = 1, this._removeStatsHistColormapVAT(e9), this.rasterInfo = e9, { success: true, supportsGPU: r11 };
  }
  _processPixels(t6) {
    const e9 = t6.pixelBlocks?.[0];
    return null == e9 ? null : i16(e9, this._normalizedWeights, this.outputPixelType);
  }
  _getWebGLParameters() {
    return { weights: this._normalizedWeights };
  }
};
__decorate([m({ json: { write: true, name: "rasterFunction" } })], i17.prototype, "functionName", void 0), __decorate([m({ type: c21, json: { write: true, name: "rasterFunctionArguments" } })], i17.prototype, "functionArguments", void 0), __decorate([m()], i17.prototype, "rasterArgumentNames", void 0), __decorate([m()], i17.prototype, "_normalizedWeights", null), i17 = __decorate([a2("esri.layers.support.rasterFunctions.GrayscaleFunction")], i17);
var u16 = i17;

// node_modules/@arcgis/core/layers/support/rasterFunctions/HillshadeFunctionArguments.js
var p13;
var a20 = new o({ 0: "traditional", 1: "multi-directional" }, { useNumericKeys: true });
var c22 = new o({ 1: "degree", 2: "percent-rise", 3: "scaled" }, { useNumericKeys: true });
var l16 = p13 = class extends p2 {
  constructor() {
    super(...arguments), this.altitude = 45, this.azimuth = 315, this.hillshadeType = "traditional", this.pixelSizePower = 0.664, this.pixelSizeFactor = 0.024, this.slopeType = "degree", this.zFactor = 1, this.removeEdgeEffect = false;
  }
  clone() {
    return new p13({ hillshadeType: this.hillshadeType, altitude: this.altitude, azimuth: this.azimuth, zFactor: this.zFactor, slopeType: this.slopeType, pixelSizeFactor: this.pixelSizeFactor, pixelSizePower: this.pixelSizePower, removeEdgeEffect: this.removeEdgeEffect, raster: this.raster });
  }
};
__decorate([m({ type: Number, json: { write: true } })], l16.prototype, "altitude", void 0), __decorate([m({ type: Number, json: { write: true } })], l16.prototype, "azimuth", void 0), __decorate([m(), r2(a20)], l16.prototype, "hillshadeType", void 0), __decorate([m({ type: Number, json: { write: true, name: "psPower" } })], l16.prototype, "pixelSizePower", void 0), __decorate([m({ type: Number, json: { write: true, name: "psZFactor" } })], l16.prototype, "pixelSizeFactor", void 0), __decorate([m(), r2(c22)], l16.prototype, "slopeType", void 0), __decorate([m({ type: Number, json: { write: true } })], l16.prototype, "zFactor", void 0), __decorate([m({ type: Boolean, json: { write: true } })], l16.prototype, "removeEdgeEffect", void 0), l16 = p13 = __decorate([a2("esri.layers.support.rasterFunctions.HillshadeFunctionArguments")], l16);
var m16 = l16;

// node_modules/@arcgis/core/layers/support/rasterFunctions/HillshadeFunction.js
var c23 = class extends p3 {
  constructor() {
    super(...arguments), this.functionName = "Hillshade", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isGCS = false;
  }
  _bindSourceRasters() {
    const t6 = this.sourceRasterInfos[0];
    if (t6.bandCount > 1) return { success: false, supportsGPU: false, error: "hillshade-function: source data must be single band" };
    this.outputPixelType = this._getOutputPixelType("u8");
    const s11 = t6.clone();
    return this._removeStatsHistColormapVAT(s11), s11.pixelType = this.outputPixelType, s11.bandCount = 1, s11.statistics = [{ min: 0, max: 255, avg: 60, stddev: 10 }], this.rasterInfo = s11, this.isGCS = s11.spatialReference?.isGeographic ?? false, { success: true, supportsGPU: true };
  }
  _processPixels(t6) {
    const s11 = t6.pixelBlocks?.[0];
    if (!s11) return null;
    const { extent: e9, primaryPixelSizes: r11 } = t6, o9 = r11?.[0], i25 = o9 ?? (e9 ? { x: e9.width / s11.width, y: e9.height / s11.height } : { x: 1, y: 1 }), p18 = d(this.functionArguments, i25, this.isGCS), a29 = r5(s11, p18);
    return a29.pixelType = this.outputPixelType, a29;
  }
  _getWebGLParameters() {
    const t6 = d(this.functionArguments, { x: 1, y: 1 }, this.isGCS), s11 = a4(t6), { slopeType: e9, zFactor: o9, pixelSizeFactor: i25, pixelSizePower: u20 } = this.functionArguments, c35 = "scaled" === e9, l22 = r3(this.outputPixelType);
    return { ...s11, zFactor: o9, gcsFactor: this.isGCS ? n2 : 1, pixelSizeFactor: c35 ? i25 : 0, pixelSizePower: c35 ? u20 : 0, isOutputRounded: l22 };
  }
};
__decorate([m({ json: { write: true, name: "rasterFunction" } })], c23.prototype, "functionName", void 0), __decorate([m({ type: m16, json: { write: true, name: "rasterFunctionArguments" } })], c23.prototype, "functionArguments", void 0), __decorate([m()], c23.prototype, "rasterArgumentNames", void 0), __decorate([m({ json: { write: true } })], c23.prototype, "isGCS", void 0), c23 = __decorate([a2("esri.layers.support.rasterFunctions.HillshadeFunction")], c23);
var l17 = c23;

// node_modules/@arcgis/core/layers/support/rasterFunctions/LocalFunctionArguments.js
var i18;
var a21 = i18 = class extends p2 {
  constructor() {
    super(...arguments), this.rasters = [], this.processAsMultiband = true;
  }
  writeRasters(r11, s11) {
    s11.rasters = r11.map((r12) => "number" == typeof r12 || "string" == typeof r12 ? r12 : r12.toJSON());
  }
  clone() {
    return new i18({ operation: this.operation, processAsMultiband: this.processAsMultiband, rasters: a(this.rasters) });
  }
};
__decorate([m({ json: { write: true } })], a21.prototype, "operation", void 0), __decorate([m({ json: { write: true } })], a21.prototype, "rasters", void 0), __decorate([r("rasters")], a21.prototype, "writeRasters", null), __decorate([m({ json: { write: true } })], a21.prototype, "processAsMultiband", void 0), a21 = i18 = __decorate([a2("esri.layers.support.rasterFunctions.LocalFunctionArguments")], a21);
var c24 = a21;

// node_modules/@arcgis/core/layers/support/rasterFunctions/LocalFunction.js
var m17 = class extends p3 {
  constructor() {
    super(...arguments), this.functionName = "Local", this.functionArguments = null, this.rasterArgumentNames = ["rasters"];
  }
  _bindSourceRasters() {
    const { sourceRasterInfos: t6 } = this, s11 = t6[0], { bandCount: e9 } = s11, { processAsMultiband: o9 } = this.functionArguments;
    if (t6.some((t7) => t7.bandCount !== e9)) return { success: false, supportsGPU: false, error: "local-function: input rasters do not have same band count" };
    const { operation: n21, rasters: r11 } = this.functionArguments, i25 = c6[n21];
    if (!(999 === i25 || r11.length === i25 || r11.length <= 1 && 1 === i25)) return { success: false, supportsGPU: false, error: `local-function: the length of functionArguments.rasters does not match operation's requirement: ${i25}` };
    const a29 = s11.clone();
    a29.bandCount = 999 !== i25 || o9 ? e9 : 1, this._removeStatsHistColormapVAT(a29), this._updateStatistics(a29), this._updatePixelType(a29), this.rasterInfo = a29;
    return { success: true, supportsGPU: 1 === a29.bandCount && i25 <= 3 };
  }
  _processPixels(t6) {
    const { pixelBlocks: s11 } = t6;
    return null == s11 || s11.some((t7) => null == t7) ? null : gt(s11, this.functionArguments.operation, { processAsMultiband: this.functionArguments.processAsMultiband, outputPixelType: this.outputPixelType ?? void 0 });
  }
  _getWebGLParameters() {
    const { operation: t6 } = this.functionArguments, s11 = c6[t6], e9 = Object.keys(m7).find((s12) => m7[s12] === t6)?.toLowerCase() ?? "undefined", i25 = this.outputPixelType ?? "f32";
    let [a29, u20] = u(i25);
    const p18 = r3(i25);
    return p18 && (a29 -= 1e-4, u20 += 1e-4), { imageCount: s11, operationName: e9, domainRange: [a29, u20], isOutputRounded: p18 };
  }
  _updateStatistics(t6) {
    const s11 = this.sourceRasterInfos[0], { operation: e9 } = this.functionArguments, o9 = l6(e9)?.domain;
    if (o9) {
      t6.statistics = [];
      for (let s12 = 0; s12 < t6.bandCount; s12++) t6.statistics[s12] = { min: o9[0], max: o9[1], avg: (o9[0] + o9[1]) / 2, stddev: (o9[0] + o9[1]) / 10 };
    } else 45 === e9 && s11.statistics?.length && (t6.statistics = s11.statistics.map((t7) => ({ min: -t7.max, max: -t7.min, avg: null != t7.avg ? -t7.avg : void 0, stddev: null != t7.stddev ? -t7.stddev : void 0 })));
  }
  _updatePixelType(t6) {
    const { statistics: s11, pixelType: e9 } = this.sourceRasterInfos[0], { operation: o9 } = this.functionArguments, { domain: n21, isInteger: a29 } = l6(o9) ?? { domain: null, isInteger: false };
    let u20 = "f32";
    if (n21 && a29) u20 = i(n21[0], n21[1]);
    else if (30 === o9) {
      const t7 = s11?.[0];
      u20 = t7 ? i(t7.min, t7.max) : r3(e9) ? e9 : "s32";
    } else if (45 === o9 && r3(e9)) {
      const t7 = s11?.map(({ max: t8 }) => -t8), o10 = s11?.map(({ min: t8 }) => -t8), n22 = t7?.length ? Math.min(...t7) : null, r11 = o10?.length ? Math.min(...o10) : null;
      u20 = null != n22 && null != r11 ? i(n22, r11) : e9.startsWith("s") ? e9.replace("s", "u") : "u1" === e9 || "u2" === e9 || "u4" === e9 ? "s8" : "u8" === e9 ? "s16" : "s32";
    }
    t6.pixelType = this.outputPixelType = this._getOutputPixelType(u20);
  }
};
__decorate([m({ json: { write: true, name: "rasterFunction" } })], m17.prototype, "functionName", void 0), __decorate([m({ type: c24, json: { write: true, name: "rasterFunctionArguments" } })], m17.prototype, "functionArguments", void 0), __decorate([m()], m17.prototype, "rasterArgumentNames", void 0), m17 = __decorate([a2("esri.layers.support.rasterFunctions.LocalFunction")], m17);
var d8 = m17;

// node_modules/@arcgis/core/layers/support/rasterFunctions/MaskFunctionArguments.js
var n13;
var s9 = n13 = class extends p2 {
  constructor() {
    super(...arguments), this.includedRanges = null, this.noDataValues = null, this.noDataInterpretation = 0;
  }
  get normalizedNoDataValues() {
    const { noDataValues: t6 } = this;
    if (!t6?.length) return null;
    let e9 = false;
    const r11 = t6.map((t7) => {
      if ("number" == typeof t7) return e9 = true, [t7];
      if ("string" == typeof t7) {
        const r12 = t7.trim().split(" ").filter((t8) => "" !== t8.trim()).map((t8) => Number(t8));
        return e9 = e9 || r12.length > 0, 0 === r12.length ? null : r12;
      }
      return null;
    });
    return e9 ? r11 : null;
  }
  clone() {
    return new n13({ includedRanges: this.includedRanges?.slice() ?? [], noDataValues: this.noDataValues?.slice() ?? [], noDataInterpretation: this.noDataInterpretation });
  }
};
__decorate([m({ json: { write: true } })], s9.prototype, "includedRanges", void 0), __decorate([m({ json: { write: true } })], s9.prototype, "noDataValues", void 0), __decorate([m()], s9.prototype, "normalizedNoDataValues", null), __decorate([m({ json: { write: true } })], s9.prototype, "noDataInterpretation", void 0), s9 = n13 = __decorate([a2("esri.layers.support.rasterFunctions.MaskFunctionArguments")], s9);
var a22 = s9;

// node_modules/@arcgis/core/layers/support/rasterFunctions/MaskFunction.js
var l18 = class extends p3 {
  constructor() {
    super(...arguments), this.functionName = "Mask", this.functionArguments = null, this.rasterArgumentNames = ["raster"];
  }
  _bindSourceRasters() {
    const t6 = this.sourceRasterInfos[0].clone(), { pixelType: e9 } = t6;
    this.outputPixelType = this._getOutputPixelType(e9), t6.pixelType = this.outputPixelType, this.rasterInfo = t6;
    const { includedRanges: s11, normalizedNoDataValues: o9 } = this.functionArguments;
    if (!s11?.length && !o9?.length) return { success: false, supportsGPU: false, error: "missing includedRanges or noDataValues argument" };
    let r11 = [];
    for (let i25 = 0; i25 < t6.bandCount; i25++) {
      const t7 = M(e9, s11?.slice(2 * i25, 2 * i25 + 2), o9?.[i25]);
      if (null == t7) {
        r11 = null;
        break;
      }
      r11.push(t7);
    }
    this.lookups = r11;
    const n21 = null != o9 && o9.every((t7) => t7?.length === o9[0]?.length);
    return { success: true, supportsGPU: (!s11 || s11.length <= 2 * l3) && (!o9 || n21 && o9[0].length <= l3) };
  }
  _processPixels(t6) {
    const e9 = t6.pixelBlocks?.[0];
    if (null == e9) return null;
    const { outputPixelType: s11, lookups: o9 } = this, { includedRanges: r11, noDataInterpretation: n21, normalizedNoDataValues: u20 } = this.functionArguments;
    return w(e9, { includedRanges: r11, noDataValues: u20, outputPixelType: s11, matchAll: 1 === n21, lookups: o9 });
  }
  _getWebGLParameters() {
    const { includedRanges: t6, normalizedNoDataValues: s11 } = this.functionArguments, o9 = new Float32Array(l3);
    o9.fill(q), s11?.[0]?.length && o9.set(s11[0]);
    const r11 = new Float32Array(6);
    for (let n21 = 0; n21 < r11.length; n21 += 2) r11[n21] = t6?.[n21] ?? -q, r11[n21 + 1] = t6?.[n21 + 1] ?? q;
    return t6?.length && r11.set(t6), { bandCount: this.sourceRasterInfos[0].bandCount, noDataValues: o9, includedRanges: r11 };
  }
};
__decorate([m({ json: { write: true, name: "rasterFunction" } })], l18.prototype, "functionName", void 0), __decorate([m({ type: a22, json: { write: true, name: "rasterFunctionArguments" } })], l18.prototype, "functionArguments", void 0), __decorate([m()], l18.prototype, "rasterArgumentNames", void 0), __decorate([m({ json: { write: true } })], l18.prototype, "lookups", void 0), l18 = __decorate([a2("esri.layers.support.rasterFunctions.MaskFunction")], l18);
var c25 = l18;

// node_modules/@arcgis/core/layers/support/rasterFunctions/NDVIFunctionArguments.js
var i19;
var e8 = i19 = class extends p2 {
  constructor() {
    super(...arguments), this.visibleBandID = 0, this.infraredBandID = 1, this.scientificOutput = false;
  }
  clone() {
    const { visibleBandID: r11, infraredBandID: t6, scientificOutput: o9 } = this;
    return new i19({ visibleBandID: r11, infraredBandID: t6, scientificOutput: o9 });
  }
};
__decorate([m({ json: { write: true } })], e8.prototype, "visibleBandID", void 0), __decorate([m({ json: { write: true } })], e8.prototype, "infraredBandID", void 0), __decorate([m({ json: { write: true } })], e8.prototype, "scientificOutput", void 0), e8 = i19 = __decorate([a2("esri.layers.support.rasterFunctions.NDVIFunctionArguments")], e8);
var n14 = e8;

// node_modules/@arcgis/core/layers/support/rasterFunctions/NDVIFunction.js
var a23 = class extends p3 {
  constructor() {
    super(...arguments), this.functionName = "NDVI", this.functionArguments = null, this.rasterArgumentNames = ["raster"];
  }
  _bindSourceRasters() {
    const { scientificOutput: t6, visibleBandID: s11, infraredBandID: e9 } = this.functionArguments;
    this.outputPixelType = this._getOutputPixelType(t6 ? "f32" : "u8");
    const n21 = this.sourceRasterInfos[0], r11 = Math.max(s11, e9);
    if (n21.bandCount < 2 || r11 >= n21.bandCount) return { success: false, supportsGPU: false, error: "ndvi-function: source raster has insufficient amount of raster bands" };
    if (s11 < 0 || e9 < 0) return { success: false, supportsGPU: false, error: "ndvi-function: invalid visible or infrared band id" };
    const i25 = n21.clone();
    i25.pixelType = this.outputPixelType, this._removeStatsHistColormapVAT(i25), i25.bandCount = 1, i25.keyProperties = { ...i25.keyProperties, BandProperties: void 0 };
    const [o9, a29, u20, c35] = t6 ? [-1, 1, 0, 0.1] : [0, 200, 100, 10];
    return i25.statistics = [{ min: o9, max: a29, avg: u20, stddev: c35 }], this.rasterInfo = i25, { success: true, supportsGPU: true };
  }
  _processPixels(t6) {
    const s11 = t6.pixelBlocks?.[0];
    if (null == s11) return null;
    let { visibleBandID: e9, infraredBandID: r11, scientificOutput: i25 } = this.functionArguments;
    if (this.rasterInfo.storageInfo.isBsqTile) {
      const { rawInputBandIds: t7 } = this;
      r11 = t7.indexOf(r11), e9 = t7.indexOf(e9);
    }
    return l8(s11, e9, r11, !i25);
  }
  _getWebGLParameters() {
    const { visibleBandID: t6, infraredBandID: s11, scientificOutput: e9 } = this.functionArguments, n21 = this.isInputBandIdsSwizzled ? [0, 1, 2] : [s11, t6, 0];
    return { bandIndexMat3: c8(n21), scaled: !e9 };
  }
  _getInputBandIds(t6) {
    const { visibleBandID: s11, infraredBandID: e9 } = this.functionArguments;
    return [e9, s11, 0].map((s12) => t6[s12]);
  }
  _swizzleBandIds(t6) {
    const { visibleBandID: s11, infraredBandID: e9 } = this.functionArguments, n21 = [s11, e9].map((s12) => t6.indexOf(s12));
    return n21[2] = n21[1], this.isInputBandIdsSwizzled = true, this.swizzledBandSelection = n21, false;
  }
};
__decorate([m({ json: { write: true, name: "rasterFunction" } })], a23.prototype, "functionName", void 0), __decorate([m({ type: n14, json: { write: true, name: "rasterFunctionArguments" } })], a23.prototype, "functionArguments", void 0), __decorate([m()], a23.prototype, "rasterArgumentNames", void 0), a23 = __decorate([a2("esri.layers.support.rasterFunctions.NDVIFunction")], a23);
var u17 = a23;

// node_modules/@arcgis/core/layers/support/rasterFunctions/RemapFunctionArguments.js
var n15;
var r9 = n15 = class extends p2 {
  constructor() {
    super(...arguments), this.inputRanges = null, this.outputValues = null, this.noDataRanges = null, this.allowUnmatched = false, this.isLastInputRangeInclusive = false;
  }
  clone() {
    return new n15({ inputRanges: [...this.inputRanges], outputValues: [...this.outputValues], noDataRanges: [...this.noDataRanges], allowUnmatched: this.allowUnmatched, isLastInputRangeInclusive: this.isLastInputRangeInclusive });
  }
};
__decorate([m({ json: { write: true } })], r9.prototype, "inputRanges", void 0), __decorate([m({ json: { write: true } })], r9.prototype, "outputValues", void 0), __decorate([m({ json: { write: true } })], r9.prototype, "noDataRanges", void 0), __decorate([m({ json: { write: true } })], r9.prototype, "allowUnmatched", void 0), __decorate([m({ json: { write: true } })], r9.prototype, "replacementValue", void 0), __decorate([m({ json: { write: true } })], r9.prototype, "isLastInputRangeInclusive", void 0), r9 = n15 = __decorate([a2("esri.layers.support.rasterFunctions.RemapFunctionArguments")], r9);
var a24 = r9;

// node_modules/@arcgis/core/layers/support/rasterFunctions/RemapFunction.js
var g3 = class extends p3 {
  constructor() {
    super(...arguments), this.functionName = "Remap", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.lookup = null;
  }
  _bindSourceRasters() {
    const t6 = this.sourceRasterInfos[0].clone(), { pixelType: e9 } = t6;
    t6.bandCount = 1;
    const { statistics: s11 } = t6;
    this._removeStatsHistColormapVAT(t6);
    const { allowUnmatched: n21, replacementValue: a29, outputValues: r11, inputRanges: l22, noDataRanges: p18, isLastInputRangeInclusive: m19 } = this.functionArguments, c35 = "unknown" === this.outputPixelType || null == this.outputPixelType;
    if (this.outputPixelType = this._getOutputPixelType(e9), r11?.length) {
      const u20 = s11?.[0];
      if (n21 && null == a29) {
        let e10 = u20?.min ?? r11[0], s12 = u20?.max ?? r11[0];
        e10 = Math.min.apply(null, [...r11, e10]), s12 = Math.max.apply(null, [...r11, s12]), t6.statistics = [{ min: e10, max: s12, avg: u20?.avg ?? 0, stddev: u20?.stddev ?? -1 }];
      } else {
        let e10 = r11[0], s12 = e10;
        for (let t7 = 0; t7 < r11.length; t7++) e10 = e10 > r11[t7] ? r11[t7] : e10, s12 = s12 > r11[t7] ? s12 : r11[t7];
        n21 && null != a29 && (e10 = Math.min(e10, a29), s12 = Math.max(s12, a29)), t6.statistics = [{ min: e10, max: s12, avg: u20?.avg ?? 0, stddev: u20?.stddev ?? -1 }];
      }
      if (c35) {
        const { min: s12, max: u21 } = t6.statistics[0], i25 = ["u8", "s8", "u16", "s16", "u32", "s32", "f32"], l23 = i25.find((t7) => {
          const [e10, n22] = u(t7);
          return s12 >= e10 && u21 <= n22;
        }) ?? "f64";
        r11.some((t7) => Math.floor(t7) !== t7) ? this.outputPixelType = "f64" === l23 ? "f64" : "f32" : this.outputPixelType = n21 && null == a29 && i25.indexOf(e9) > i25.indexOf(l23) ? e9 : l23;
      }
    }
    t6.pixelType = this.outputPixelType, this.rasterInfo = t6, this.lookup = n21 ? null : k({ srcPixelType: e9, inputRanges: l22, outputValues: r11, noDataRanges: p18, allowUnmatched: n21, isLastInputRangeInclusive: m19, outputPixelType: this.outputPixelType });
    return { success: true, supportsGPU: (!r11 || r11.length <= l3) && (!p18 || p18.length <= l3) };
  }
  _processPixels(t6) {
    const e9 = t6.pixelBlocks?.[0];
    if (null == e9) return null;
    const { lookup: s11, outputPixelType: n21 } = this;
    if (s11) {
      const t7 = f3(e9, { lut: [s11.lut], offset: s11.offset, outputPixelType: n21 });
      return null != t7 && s11.mask && (t7.mask = c3(e9.pixels[0], e9.mask, s11.mask, s11.offset, "u8")), t7;
    }
    const { inputRanges: o9, outputValues: a29, noDataRanges: u20, allowUnmatched: i25, isLastInputRangeInclusive: m19, replacementValue: c35 } = this.functionArguments;
    return m4(e9, { inputRanges: o9, outputValues: a29, noDataRanges: u20, outputPixelType: n21, allowUnmatched: i25, isLastInputRangeInclusive: m19, replacementValue: c35 });
  }
  _getWebGLParameters() {
    const { allowUnmatched: t6, noDataRanges: s11, isLastInputRangeInclusive: n21 } = this.functionArguments, a29 = this.functionArguments.inputRanges ?? [], u20 = this.functionArguments.outputValues ?? [], r11 = x(a29, u20, n21), l22 = new Float32Array(2 * l3);
    l22.fill(q), s11?.length && l22.set(s11);
    return { allowUnmatched: t6, rangeMaps: r11, noDataRanges: l22, clampRange: u(this.outputPixelType), replacementValue: this.functionArguments.replacementValue };
  }
};
__decorate([m({ json: { write: true, name: "rasterFunction" } })], g3.prototype, "functionName", void 0), __decorate([m({ type: a24, json: { write: true, name: "rasterFunctionArguments" } })], g3.prototype, "functionArguments", void 0), __decorate([m()], g3.prototype, "rasterArgumentNames", void 0), __decorate([m({ json: { write: true } })], g3.prototype, "lookup", void 0), g3 = __decorate([a2("esri.layers.support.rasterFunctions.RemapFunction")], g3);
var f7 = g3;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ShadedReliefFunctionArguments.js
var a25;
var l19 = a25 = class extends m16 {
  readColorRamp(o9) {
    if ("string" == typeof o9) {
      const r11 = m6.jsonValues.find((r12) => r12.toLowerCase() === o9.toLowerCase());
      return r11 ? d2(m6.fromJSON(r11)) : null;
    }
    return "toJSON" in o9 ? o9.toJSON() : o9;
  }
  clone() {
    return new a25({ hillshadeType: this.hillshadeType, altitude: this.altitude, azimuth: this.azimuth, zFactor: this.zFactor, slopeType: this.slopeType, pixelSizeFactor: this.pixelSizeFactor, pixelSizePower: this.pixelSizePower, removeEdgeEffect: this.removeEdgeEffect, colorRamp: this.colorRamp, colormap: this.colormap, raster: this.raster });
  }
};
__decorate([m({ json: { write: true } })], l19.prototype, "colorRamp", void 0), __decorate([o2("colorRamp")], l19.prototype, "readColorRamp", null), __decorate([m({ type: [[Number]], json: { write: true } })], l19.prototype, "colormap", void 0), l19 = a25 = __decorate([a2("esri.layers.support.rasterFunctions.ShadedReliefFunctionArguments")], l19);
var c26 = l19;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ShadedReliefFunction.js
var h5 = class extends p3 {
  constructor() {
    super(...arguments), this.functionName = "ShadedRelief", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isGCS = false;
  }
  _bindSourceRasters() {
    const e9 = this.sourceRasterInfos[0];
    if (e9.bandCount > 1) return { success: false, supportsGPU: false, error: "shadedrelief-function: source data must be single band" };
    let { colorRamp: t6, colormap: s11 } = this.functionArguments;
    if (!t6 && !s11?.length) return { success: false, supportsGPU: false, error: "shadedrelief-function: a color ramp argument must be specified" };
    this.outputPixelType = this._getOutputPixelType("u8");
    const r11 = e9.clone();
    this._removeStatsHistColormapVAT(r11), r11.pixelType = this.outputPixelType, r11.bandCount = 3, r11.statistics = [{ min: 0, max: 255, avg: 60, stddev: 10 }, { min: 0, max: 255, avg: 60, stddev: 10 }, { min: 0, max: 255, avg: 60, stddev: 10 }], this.rasterInfo = r11, this.isGCS = r11.spatialReference?.isGeographic ?? false, s11?.length || (s11 = B(t6, { interpolateAlpha: true }));
    const { indexedColormap: o9, offset: n21 } = a3({ colormap: s11 });
    if (!o9?.length) return { success: false, supportsGPU: false, error: "shadedrelief-function: a valid colorramp is required" };
    const p18 = D(o9);
    return this.lookup = { indexedColormap: o9, offset: n21, hsvMap: p18 }, { success: true, supportsGPU: a5(o9) };
  }
  _processPixels(e9) {
    const t6 = e9.pixelBlocks?.[0];
    if (!t6 || !this.lookup) return null;
    let s11 = e9.primaryPixelSizes?.[0];
    if (null == s11) {
      const { extent: r12 } = e9;
      s11 = r12 ? { x: r12.width / t6.width, y: r12.height / t6.height } : { x: 1, y: 1 };
    }
    const r11 = d(this.functionArguments, s11, this.isGCS), o9 = r5(t6, r11), i25 = this.sourceRasterInfos[0].statistics?.[0] ?? { min: 0, max: 8e3 };
    return c4(o9, t6, this.lookup.hsvMap, i25), o9.pixelType = this.outputPixelType, o9;
  }
  _getWebGLParameters() {
    const e9 = d(this.functionArguments, { x: 1, y: 1 }, this.isGCS), t6 = a4(e9), { slopeType: s11, zFactor: o9, pixelSizeFactor: i25, pixelSizePower: n21 } = this.functionArguments, a29 = "scaled" === s11, { indexedColormap: u20, offset: m19 } = this.lookup, d9 = this.sourceRasterInfos[0].statistics?.[0], f9 = r3(this.outputPixelType);
    return { ...t6, indexedColormap: u20, offset: m19, zFactor: o9, gcsFactor: this.isGCS ? n2 : 1, pixelSizeFactor: a29 ? i25 : 0, pixelSizePower: a29 ? n21 : 0, minValue: d9?.min ?? 0, maxValue: d9?.max ?? 8e3, isOutputRounded: f9 };
  }
};
__decorate([m({ json: { write: true, name: "rasterFunction" } })], h5.prototype, "functionName", void 0), __decorate([m({ type: c26, json: { write: true, name: "rasterFunctionArguments" } })], h5.prototype, "functionArguments", void 0), __decorate([m()], h5.prototype, "rasterArgumentNames", void 0), __decorate([m({ json: { write: true } })], h5.prototype, "isGCS", void 0), __decorate([m({ json: { write: true } })], h5.prototype, "lookup", void 0), h5 = __decorate([a2("esri.layers.support.rasterFunctions.ShadedReliefFunction")], h5);
var x4 = h5;

// node_modules/@arcgis/core/layers/support/rasterFunctions/SlopeFunctionArguments.js
var i20;
var c27 = new o({ 1: "degree", 2: "percent-rise", 3: "adjusted" }, { useNumericKeys: true });
var a26 = i20 = class extends p2 {
  constructor() {
    super(...arguments), this.slopeType = "degree", this.zFactor = 1, this.pixelSizePower = 0.664, this.pixelSizeFactor = 0.024, this.removeEdgeEffect = false;
  }
  clone() {
    return new i20({ slopeType: this.slopeType, zFactor: this.zFactor, pixelSizePower: this.pixelSizePower, pixelSizeFactor: this.pixelSizeFactor, removeEdgeEffect: this.removeEdgeEffect, raster: this.raster });
  }
};
__decorate([r2(c27)], a26.prototype, "slopeType", void 0), __decorate([m({ type: Number, json: { write: true } })], a26.prototype, "zFactor", void 0), __decorate([m({ type: Number, json: { name: "psPower", write: true } })], a26.prototype, "pixelSizePower", void 0), __decorate([m({ type: Number, json: { name: "psZFactor", write: true } })], a26.prototype, "pixelSizeFactor", void 0), __decorate([m({ type: Boolean, json: { write: true } })], a26.prototype, "removeEdgeEffect", void 0), a26 = i20 = __decorate([a2("esri.layers.support.rasterFunctions.SlopeFunctionArguments")], a26);
var m18 = a26;

// node_modules/@arcgis/core/layers/support/rasterFunctions/SlopeFunction.js
var u18 = class extends p3 {
  constructor() {
    super(...arguments), this.functionName = "Slope", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isGCS = false;
  }
  _bindSourceRasters() {
    this.outputPixelType = this._getOutputPixelType("f32");
    const t6 = this.sourceRasterInfos[0].clone();
    return t6.pixelType = this.outputPixelType, this._removeStatsHistColormapVAT(t6), t6.statistics = "percent-rise" !== this.functionArguments.slopeType ? [{ min: 0, max: 90, avg: 1, stddev: 1 }] : null, t6.bandCount = 1, this.rasterInfo = t6, this.isGCS = t6.spatialReference?.isGeographic ?? false, { success: true, supportsGPU: true };
  }
  _processPixels(t6) {
    const e9 = t6.pixelBlocks?.[0];
    if (null == e9) return null;
    const { zFactor: s11, slopeType: r11, pixelSizePower: o9, pixelSizeFactor: i25 } = this.functionArguments, { isGCS: n21 } = this, { extent: u20, primaryPixelSizes: c35 } = t6, a29 = c35?.[0], l22 = a29 ?? (u20 ? { x: u20.width / e9.width, y: u20.height / e9.height } : { x: 1, y: 1 });
    return h(e9, { zFactor: s11, slopeType: r11, pixelSizePower: o9, pixelSizeFactor: i25, isGCS: n21, resolution: l22 });
  }
  _getWebGLParameters() {
    const { zFactor: t6, slopeType: e9, pixelSizeFactor: s11, pixelSizePower: o9 } = this.functionArguments;
    return { zFactor: this.isGCS && t6 >= 1 ? t6 * n2 : t6, slopeType: e9, pixelSizeFactor: s11 ?? 0, pixelSizePower: o9 ?? 0, isOutputRounded: r3(this.outputPixelType) };
  }
};
__decorate([m({ json: { write: true, name: "rasterFunction" } })], u18.prototype, "functionName", void 0), __decorate([m({ type: m18, json: { write: true, name: "rasterFunctionArguments" } })], u18.prototype, "functionArguments", void 0), __decorate([m()], u18.prototype, "rasterArgumentNames", void 0), __decorate([m({ json: { write: true } })], u18.prototype, "isGCS", void 0), u18 = __decorate([a2("esri.layers.support.rasterFunctions.SlopeFunction")], u18);
var c28 = u18;

// node_modules/@arcgis/core/layers/support/rasterFunctions/focalStatUtils.js
var n16 = new o({ 1: "min", 2: "max", 3: "mean", 4: "stddev", 5: "median", 6: "majority", 7: "minority" }, { useNumericKeys: true });
function s10(t6, e9) {
  const { fillNoDataOnly: o9 } = e9, { band: n21, width: s11, height: r11, mask: i25, outBand: l22 } = t6;
  if (o9 && !i25) return void l22.set(n21);
  const { statisticsType: a29, kernelRows: c35, kernelCols: f9 } = e9, h6 = "stddev" === a29, m19 = s11 * r11, u20 = new Float64Array(m19), d9 = new Float64Array(m19), y3 = new Uint32Array(m19);
  for (let A3 = 0; A3 < r11; A3++) {
    const t7 = A3 * s11;
    let e10 = 0, o10 = 0, r12 = 0;
    for (let s12 = 0; s12 < f9; s12++) i25 && !i25[t7 + s12] || (e10 += n21[t7 + s12], h6 && (o10 += n21[t7 + s12] ** 2), r12++);
    u20[t7] = e10, d9[t7] = o10, y3[t7] = r12;
    for (let l23 = 1; l23 <= s11 - f9; l23++) {
      const s12 = t7 + l23 - 1, a30 = s12 + f9;
      i25 ? (i25[s12] && (r12--, e10 -= n21[s12], h6 && (o10 -= n21[s12] ** 2)), i25[a30] && (r12++, e10 += n21[a30], h6 && (o10 += n21[a30] ** 2))) : (e10 -= n21[s12], e10 += n21[a30], h6 && (o10 -= n21[s12] ** 2, o10 += n21[a30] ** 2)), u20[t7 + l23] = e10, y3[t7 + l23] = r12, h6 && (d9[t7 + l23] = o10);
    }
  }
  const k5 = new Float64Array(m19), w7 = new Float64Array(m19), p18 = new Uint32Array(m19), M4 = c35 * s11;
  for (let A3 = 0; A3 <= s11 - f9; A3++) {
    let t7 = 0, e10 = 0, o10 = 0;
    for (let n22 = 0; n22 < c35; n22++) {
      const r12 = n22 * s11 + A3;
      t7 += u20[r12], o10 += y3[r12], h6 && (e10 += d9[r12]);
    }
    k5[A3] = t7, w7[A3] = e10, p18[A3] = o10;
    for (let n22 = 1; n22 <= r11 - c35; n22++) {
      const r12 = (n22 - 1) * s11 + A3, i26 = r12 + M4;
      t7 -= u20[r12], t7 += u20[i26], o10 -= y3[r12], o10 += y3[i26], h6 && (e10 -= d9[r12], e10 += d9[i26]), k5[n22 * s11 + A3] = t7, w7[n22 * s11 + A3] = e10, p18[n22 * s11 + A3] = o10;
    }
  }
  const g4 = Math.floor(c35 / 2), b4 = Math.floor(f9 / 2);
  for (let A3 = g4; A3 < r11 - g4; A3++) {
    const t7 = A3 * s11;
    for (let e10 = b4; e10 < s11 - b4; e10++) {
      const n22 = (A3 - g4) * s11 + e10 - b4, r12 = p18[n22];
      if (0 === r12 || o9 && (!i25 || i25[t7 + e10])) continue;
      const a30 = k5[n22] / r12, c36 = h6 ? Math.sqrt((w7[n22] - k5[n22] * a30) / r12) : a30;
      l22[t7 + e10] = c36, i25 && (i25[t7 + e10] = 255);
    }
  }
}
function r10(t6, e9) {
  const { fillNoDataOnly: o9 } = e9, { band: n21, width: s11, height: r11, mask: i25, outBand: l22 } = t6;
  if (o9 && !i25) return void l22.set(n21);
  const { kernelRows: a29, kernelCols: c35, statisticsType: f9 } = e9, h6 = Math.floor(a29 / 2), m19 = Math.floor(c35 / 2), u20 = "min" === f9, d9 = l22.slice(), y3 = new Uint32Array(s11 * r11);
  for (let k5 = h6; k5 < r11 - h6; k5++) {
    const t7 = k5 * s11;
    for (let e10 = m19; e10 < s11 - m19; e10++) {
      let o10 = u20 ? Number.MAX_VALUE : -Number.MAX_VALUE, r12 = 0;
      for (let l23 = 0; l23 < a29; l23++) for (let a30 = 0; a30 < c35; a30++) {
        const c36 = t7 + e10 + (l23 - h6) * s11 + a30 - m19;
        i25 && !i25[c36] || (o10 = u20 ? Math.min(o10, n21[c36]) : Math.max(o10, n21[c36]), r12++);
      }
      i25 ? (d9[t7 + e10] = 0 === r12 ? 0 : o10, y3[t7 + e10] = r12) : l22[t7 + e10] = 0 === r12 ? 0 : o10;
    }
  }
  if (i25) for (let k5 = h6; k5 < r11 - h6; k5++) {
    const t7 = k5 * s11;
    for (let e10 = m19; e10 < s11 - m19; e10++) if (y3[t7 + e10]) {
      if (o9 && i25[t7 + e10]) continue;
      l22[t7 + e10] = d9[t7 + e10], i25[t7 + e10] = 255;
    }
  }
}
function i21(t6, e9) {
  const { fillNoDataOnly: o9 } = e9, { band: n21, width: s11, height: r11, mask: i25, outBand: l22 } = t6;
  if (o9 && !i25) return void l22.set(n21);
  const { kernelRows: a29, kernelCols: c35 } = e9, f9 = Math.floor(a29 / 2), h6 = Math.floor(c35 / 2), m19 = l22.slice(), u20 = new Uint32Array(s11 * r11);
  for (let d9 = f9; d9 < r11 - f9; d9++) {
    const t7 = d9 * s11;
    for (let e10 = h6; e10 < s11 - h6; e10++) {
      if (o9 && i25?.[t7 + e10]) continue;
      const r12 = [];
      for (let o10 = 0; o10 < a29; o10++) for (let l23 = 0; l23 < c35; l23++) {
        const a30 = t7 + e10 + (o10 - f9) * s11 + l23 - h6;
        i25 && !i25[a30] || r12.push(n21[a30]);
      }
      r12.length && (r12.sort((t8, e11) => t8 - e11), i25 ? (m19[t7 + e10] = r12[Math.floor((r12.length - 1) / 2)], u20[t7 + e10] = r12.length) : l22[t7 + e10] = r12[Math.floor((r12.length - 1) / 2)]);
    }
  }
  if (i25) for (let d9 = f9; d9 < r11 - f9; d9++) {
    const t7 = d9 * s11;
    for (let e10 = h6; e10 < s11 - h6; e10++) if (u20[t7 + e10]) {
      if (o9 && i25[t7 + e10]) continue;
      l22[t7 + e10] = m19[t7 + e10], i25[t7 + e10] = 255;
    }
  }
}
function l20(t6, e9) {
  const { fillNoDataOnly: o9 } = e9, { band: n21, width: s11, height: r11, mask: i25, outBand: l22 } = t6;
  if (o9 && !i25) return void l22.set(n21);
  const { kernelRows: a29, kernelCols: c35 } = e9, f9 = Math.floor(a29 / 2), h6 = Math.floor(c35 / 2), m19 = "majority" === e9.statisticsType, u20 = a29 * c35, d9 = l22.slice(), y3 = new Uint32Array(s11 * r11);
  for (let k5 = f9; k5 < r11 - f9; k5++) {
    const t7 = k5 * s11;
    for (let e10 = h6; e10 < s11 - h6; e10++) {
      if (o9 && i25?.[t7 + e10]) continue;
      const r12 = /* @__PURE__ */ new Map();
      for (let o10 = 0; o10 < a29; o10++) for (let l23 = 0; l23 < c35; l23++) {
        const a30 = t7 + e10 + (o10 - f9) * s11 + l23 - h6;
        if (i25 && !i25[a30]) continue;
        const c36 = n21[a30];
        r12.set(c36, r12.has(c36) ? r12.get(c36) + 1 : 1);
      }
      if (0 === r12.size) continue;
      let k6 = 0, w7 = 0, p18 = m19 ? 0 : u20 + 1;
      for (const t8 of r12.keys()) w7 = r12.get(t8), m19 === w7 > p18 && (p18 = w7, k6 = t8);
      i25 ? (d9[t7 + e10] = k6, y3[t7 + e10] = r12.size) : l22[t7 + e10] = k6;
    }
  }
  if (i25) for (let k5 = f9; k5 < r11 - f9; k5++) {
    const t7 = k5 * s11;
    for (let e10 = h6; e10 < s11 - h6; e10++) if (y3[t7 + e10]) {
      if (o9 && i25[t7 + e10]) continue;
      l22[t7 + e10] = d9[t7 + e10], i25[t7 + e10] = 255;
    }
  }
}
function a27(t6, n21) {
  const { mask: a29 } = t6, { fillNoDataOnly: c35 } = n21;
  if (c35 && !a29) return t6;
  const { pixels: f9, width: h6, height: m19, bandMasks: u20, pixelType: d9 } = t6, y3 = f9.length, k5 = h6 * m19, w7 = [], { kernelRows: p18, kernelCols: M4, statisticsType: g4, mirrorEdges: b4 } = n21;
  if (c35 && !a29) return t6;
  const A3 = n21.outputPixelType ?? d9, x6 = [];
  for (let N2 = 0; N2 < y3; N2++) {
    const t7 = f9[N2], d10 = c2.createEmptyBand(A3, k5);
    c35 && d10.set(t7);
    const y4 = u20?.[N2] ?? a29, j4 = y4?.slice() ?? null, B6 = { band: t7, width: h6, height: m19, mask: j4, outBand: d10 };
    switch (g4) {
      case "min":
      case "max":
        r10(B6, n21);
        break;
      case "mean":
      case "stddev":
        s10(B6, n21);
        break;
      case "median":
        i21(B6, n21);
        break;
      case "majority":
      case "minority":
        l20(B6, n21);
    }
    b4 && !c35 && o7(d10, h6, m19, p18, M4), w7.push(d10), j4 && x6.push(j4);
  }
  let j3 = x6[0] ?? a29;
  x6.length !== y3 && (x6.length = 0), y3 > 1 && u20?.length && (j3 = c2.combineBandMasks(u20));
  const B5 = new c2({ pixelType: A3, width: h6, height: m19, pixels: w7, bandMasks: u20 && x6.length ? x6 : null, mask: j3 });
  return B5.updateStatistics(), B5;
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/StatisticsFunctionArguments.js
var c29;
var p14 = c29 = class extends p2 {
  constructor() {
    super(...arguments), this.rows = 3, this.cols = 3, this.fillNoDataOnly = false, this.statisticsType = "min";
  }
  clone() {
    return new c29({ rows: this.rows, cols: this.cols, fillNoDataOnly: this.fillNoDataOnly, statisticsType: this.statisticsType, raster: a(this.raster) });
  }
};
__decorate([m({ json: { write: true, read: { source: ["kernelRows", "rows"], reader: (s11, r11) => Number(s11 ?? r11?.kernelRows ?? 3) } } })], p14.prototype, "rows", void 0), __decorate([m({ json: { write: true, read: { source: ["kernelCols", "cols"], reader: (s11, r11) => Number(s11 ?? r11?.kernelCols ?? 3) } } })], p14.prototype, "cols", void 0), __decorate([m({ json: { write: true } })], p14.prototype, "fillNoDataOnly", void 0), __decorate([m({ json: { read: { source: ["statisticsType", "type"], reader: (s11, r11) => n16.fromJSON(r11?.statisticsType ?? r11?.type) ?? "min" }, write: { target: "type" } } }), r2(n16)], p14.prototype, "statisticsType", void 0), p14 = c29 = __decorate([a2("esri.layers.support.rasterFunctions.StatisticsFunctionArguments")], p14);
var l21 = p14;

// node_modules/@arcgis/core/layers/support/rasterFunctions/StatisticsFunction.js
var p15 = class extends p3 {
  constructor() {
    super(...arguments), this.functionName = "Statistics", this.rasterArgumentNames = ["raster"];
  }
  _bindSourceRasters() {
    const { type: t6 } = this.functionArguments.toJSON();
    if (t6 < 1 || t6 > 7) return { success: false, supportsGPU: false, error: `statistics-function: the given statistics type is not supported ${t6}` };
    const s11 = this.sourceRasterInfos[0];
    this.outputPixelType = this._getOutputPixelType(s11.pixelType);
    const e9 = s11.clone();
    e9.pixelType = this.outputPixelType;
    const { statisticsType: o9 } = this.functionArguments;
    "stddev" === o9 && this._removeStatsHistColormapVAT(e9), this.rasterInfo = e9;
    return { success: true, supportsGPU: e9.bandCount <= 3 && t6 < 5 };
  }
  _processPixels(t6) {
    const s11 = t6.pixelBlocks?.[0];
    if (null == s11) return s11;
    const { statisticsType: e9, rows: o9, cols: r11, fillNoDataOnly: n21 } = this.functionArguments;
    return a27(s11, { kernelRows: o9, kernelCols: r11, fillNoDataOnly: n21, outputPixelType: this.outputPixelType, statisticsType: e9, mirrorEdges: true });
  }
  _getWebGLParameters() {
    const { rows: t6, cols: s11, statisticsType: e9, fillNoDataOnly: r11 } = this.functionArguments;
    return { fillNoDataOnly: r11, kernelRows: t6, kernelCols: s11, statisticsType: e9, clampRange: u(this.outputPixelType) };
  }
};
__decorate([m({ json: { write: true, name: "rasterFunction" } })], p15.prototype, "functionName", void 0), __decorate([m({ type: l21, json: { write: true, name: "rasterFunctionArguments" } })], p15.prototype, "functionArguments", void 0), __decorate([m()], p15.prototype, "rasterArgumentNames", void 0), p15 = __decorate([a2("esri.layers.support.rasterFunctions.StatisticsFunction")], p15);
var c30 = p15;

// node_modules/@arcgis/core/layers/support/rasterFunctions/StatisticsHistogramFunctionArguments.js
var c31;
var n17 = c31 = class extends p2 {
  constructor() {
    super(...arguments), this.statistics = null, this.histograms = null;
  }
  readStatistics(t6, s11) {
    if (!t6?.length) return null;
    const r11 = [];
    return t6.forEach((t7) => {
      const s12 = { min: t7.min, max: t7.max, avg: t7.avg ?? t7.mean, stddev: t7.stddev ?? t7.standardDeviation };
      r11.push(s12);
    }), r11;
  }
  writeStatistics(t6, s11, r11) {
    if (!t6?.length) return;
    const o9 = [];
    t6.forEach((t7) => {
      const s12 = { ...t7, mean: t7.avg, standardDeviation: t7.stddev };
      delete s12.avg, delete s12.stddev, o9.push(s12);
    }), s11[r11] = o9;
  }
  clone() {
    return new c31({ statistics: a(this.statistics), histograms: a(this.histograms) });
  }
};
__decorate([m({ json: { write: true } })], n17.prototype, "statistics", void 0), __decorate([o2("statistics")], n17.prototype, "readStatistics", null), __decorate([r("statistics")], n17.prototype, "writeStatistics", null), __decorate([m({ json: { write: true } })], n17.prototype, "histograms", void 0), n17 = c31 = __decorate([a2("esri.layers.support.rasterFunctions.StatisticsHistogramFunctionArguments")], n17);
var p16 = n17;

// node_modules/@arcgis/core/layers/support/rasterFunctions/StatisticsHistogramFunction.js
var i22 = class extends p3 {
  constructor() {
    super(...arguments), this.functionName = "StatisticsHistogram", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isNoopProcess = true;
  }
  _bindSourceRasters() {
    const t6 = this.sourceRasterInfos[0];
    this.outputPixelType = this._getOutputPixelType("u8");
    const s11 = t6.clone(), { statistics: o9, histograms: r11 } = this.functionArguments;
    return r11 && (s11.histograms = r11), o9 && (s11.statistics = o9), this.rasterInfo = s11, { success: true, supportsGPU: true };
  }
  _processPixels(t6) {
    return t6.pixelBlocks?.[0];
  }
};
__decorate([m({ json: { write: true, name: "rasterFunction" } })], i22.prototype, "functionName", void 0), __decorate([m({ type: p16, json: { write: true, name: "rasterFunctionArguments" } })], i22.prototype, "functionArguments", void 0), __decorate([m()], i22.prototype, "rasterArgumentNames", void 0), __decorate([m({ json: { write: true } })], i22.prototype, "indexedColormap", void 0), __decorate([m()], i22.prototype, "isNoopProcess", void 0), i22 = __decorate([a2("esri.layers.support.rasterFunctions.StatisticsHistogramFunction")], i22);
var n18 = i22;

// node_modules/@arcgis/core/layers/support/rasterFunctions/StretchFunctionArguments.js
var n19;
var p17 = new o({ 0: "none", 3: "standard-deviation", 4: "histogram-equalization", 5: "min-max", 6: "percent-clip", 9: "sigmoid" }, { useNumericKeys: true });
var c32 = n19 = class extends p2 {
  constructor() {
    super(...arguments), this.computeGamma = false, this.dynamicRangeAdjustment = false, this.gamma = [], this.histograms = null, this.statistics = null, this.stretchType = "none", this.useGamma = false;
  }
  writeStatistics(t6, e9, o9) {
    t6?.length && (Array.isArray(t6[0]) || (t6 = t6.map((t7) => [t7.min, t7.max, t7.avg, t7.stddev])), e9[o9] = t6);
  }
  clone() {
    return new n19({ stretchType: this.stretchType, outputMin: this.outputMin, outputMax: this.outputMax, useGamma: this.useGamma, computeGamma: this.computeGamma, statistics: a(this.statistics), gamma: a(this.gamma), sigmoidStrengthLevel: this.sigmoidStrengthLevel, numberOfStandardDeviations: this.numberOfStandardDeviations, minPercent: this.minPercent, maxPercent: this.maxPercent, histograms: a(this.histograms), dynamicRangeAdjustment: this.dynamicRangeAdjustment, raster: this.raster });
  }
};
__decorate([m({ type: Boolean, json: { write: true } })], c32.prototype, "computeGamma", void 0), __decorate([m({ type: Boolean, json: { name: "dra", write: true } })], c32.prototype, "dynamicRangeAdjustment", void 0), __decorate([m({ type: [Number], json: { write: true } })], c32.prototype, "gamma", void 0), __decorate([m()], c32.prototype, "histograms", void 0), __decorate([m({ type: Number, json: { write: true } })], c32.prototype, "maxPercent", void 0), __decorate([m({ type: Number, json: { write: true } })], c32.prototype, "minPercent", void 0), __decorate([m({ type: Number, json: { write: true } })], c32.prototype, "numberOfStandardDeviations", void 0), __decorate([m({ type: Number, json: { name: "max", write: true } })], c32.prototype, "outputMax", void 0), __decorate([m({ type: Number, json: { name: "min", write: true } })], c32.prototype, "outputMin", void 0), __decorate([m({ type: Number, json: { write: true } })], c32.prototype, "sigmoidStrengthLevel", void 0), __decorate([m({ json: { type: [[Number]], write: true } })], c32.prototype, "statistics", void 0), __decorate([r("statistics")], c32.prototype, "writeStatistics", null), __decorate([r2(p17)], c32.prototype, "stretchType", void 0), __decorate([m({ type: Boolean, json: { write: true } })], c32.prototype, "useGamma", void 0), c32 = n19 = __decorate([a2("esri.layers.support.rasterFunctions.StretchFunctionArguments")], c32);
var u19 = c32;

// node_modules/@arcgis/core/layers/support/rasterFunctions/StretchFunction.js
var c33 = class extends p3 {
  constructor() {
    super(...arguments), this.functionName = "Stretch", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.lookup = null, this.cutOffs = null;
  }
  _bindSourceRasters() {
    this.lookup = null, this.cutOffs = null;
    const t6 = this.sourceRasterInfos[0], { pixelType: s11 } = t6, { functionArguments: e9 } = this, { dynamicRangeAdjustment: r11, gamma: u20, useGamma: i25 } = e9;
    if (!r11 && ["u8", "u16", "s8", "s16"].includes(s11)) {
      const r12 = b(e9.toJSON(), { rasterInfo: t6 }), a30 = r3(this.outputPixelType) ? "round" : "float";
      this.lookup = l5({ pixelType: s11, ...r12, gamma: i25 ? u20 : null, rounding: a30 }), this.cutOffs = r12;
    } else r11 || (this.cutOffs = b(e9.toJSON(), { rasterInfo: t6 }));
    this.outputPixelType = this._getOutputPixelType(s11);
    const a29 = t6.clone();
    a29.pixelType = this.outputPixelType, this._removeStatsHistColormapVAT(a29), "u8" === this.outputPixelType && (a29.keyProperties.DataType = "processed");
    const { outputMin: m19 = 0, outputMax: c35 = 255 } = this.functionArguments;
    a29.statistics = [];
    for (let o9 = 0; o9 < a29.bandCount; o9++) a29.statistics[o9] = { min: m19, max: c35 };
    this.rasterInfo = a29;
    return { success: true, supportsGPU: !r11 };
  }
  _processPixels(t6) {
    const s11 = t6.pixelBlocks?.[0];
    if (null == s11) return s11;
    const { lookup: e9 } = this;
    if (e9) return f3(s11, { ...e9, outputPixelType: this.rasterInfo.pixelType });
    const { functionArguments: o9 } = this, r11 = this.cutOffs || b(o9.toJSON(), { rasterInfo: this.sourceRasterInfos[0], pixelBlock: s11 }), i25 = o9.useGamma ? o9.gamma : null;
    return z(s11, { ...r11, gamma: i25, outputPixelType: this.outputPixelType });
  }
  _getWebGLParameters() {
    const { outputMin: t6 = 0, outputMax: s11 = 255, gamma: e9, useGamma: r11 } = this.functionArguments, u20 = this.rasterInfo.bandCount >= 2 ? 3 : 1, i25 = r11 && e9?.length ? w3(u20, e9) : [1, 1, 1], { minCutOff: n21, maxCutOff: p18 } = this.cutOffs ?? { minCutOff: [0, 0, 0], maxCutOff: [255, 255, 255] };
    1 === n21.length && (n21[1] = n21[2] = n21[0], p18[1] = p18[2] = p18[0]);
    const a29 = p18.map((e10, o9) => (s11 - t6) / (p18[o9] - n21[o9])), c35 = r3(this.outputPixelType), f9 = r11 && e9 ? [e9[0], e9[1] ?? e9[0], e9[2] ?? e9[0]] : [1, 1, 1], l22 = r11 ? [i25[0], i25[1] ?? i25[0], i25[2] ?? i25[0]] : [1, 1, 1];
    return { bandCount: u20, minOutput: t6, maxOutput: s11, minCutOff: n21, maxCutOff: p18, factor: a29, useGamma: r11, gamma: f9, gammaCorrection: l22, stretchType: this.functionArguments.stretchType, isOutputRounded: c35, type: "stretch" };
  }
};
__decorate([m({ json: { write: true, name: "rasterFunction" } })], c33.prototype, "functionName", void 0), __decorate([m({ type: u19, json: { write: true, name: "rasterFunctionArguments" } })], c33.prototype, "functionArguments", void 0), __decorate([m()], c33.prototype, "rasterArgumentNames", void 0), __decorate([m({ json: { write: true } })], c33.prototype, "lookup", void 0), __decorate([m({ json: { write: true } })], c33.prototype, "cutOffs", void 0), c33 = __decorate([a2("esri.layers.support.rasterFunctions.StretchFunction")], c33);
var f8 = c33;

// node_modules/@arcgis/core/layers/support/rasterFunctions/TableFunctionArguments.js
var c34;
var a28 = c34 = class extends p2 {
  constructor() {
    super(...arguments), this.attributeTableAsRecordSet = null;
  }
  clone() {
    return new c34({ attributeTableAsRecordSet: a(this.attributeTableAsRecordSet) });
  }
};
__decorate([m({ json: { write: true } })], a28.prototype, "attributeTableAsRecordSet", void 0), a28 = c34 = __decorate([a2("esri.layers.support.rasterFunctions.TableFunctionArguments")], a28);
var i23 = a28;

// node_modules/@arcgis/core/layers/support/rasterFunctions/TableFunction.js
var i24 = class extends p3 {
  constructor() {
    super(...arguments), this.functionName = "Table", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isNoopProcess = true;
  }
  _bindSourceRasters() {
    const t6 = this.sourceRasterInfos[0];
    if (t6.bandCount > 1 || t6.pixelType.startsWith("f")) return { success: false, supportsGPU: false, error: "table-function: Source data must be single band and integer pixel type." };
    const { attributeTableAsRecordSet: e9 } = this.functionArguments;
    if (!e9) return { success: false, supportsGPU: false, error: "table-function: Missing attributeTableAsRecordSet argument." };
    this.outputPixelType = this._getOutputPixelType(t6.pixelType);
    const r11 = t6.clone();
    return r11.pixelType = this.outputPixelType, r11.bandCount = 1, "thematic" !== r11.dataType && (r11.keyProperties = r11.keyProperties ? { ...r11.keyProperties, DataType: "thematic" } : { DataType: "thematic" }), this.rasterInfo = r11, { success: true, supportsGPU: true };
  }
  _processPixels(t6) {
    return t6.pixelBlocks?.[0];
  }
};
__decorate([m({ json: { write: true, name: "rasterFunction" } })], i24.prototype, "functionName", void 0), __decorate([m({ type: i23, json: { write: true, name: "rasterFunctionArguments" } })], i24.prototype, "functionArguments", void 0), __decorate([m()], i24.prototype, "rasterArgumentNames", void 0), __decorate([m()], i24.prototype, "isNoopProcess", void 0), i24 = __decorate([a2("esri.layers.support.rasterFunctions.TableFunction")], i24);
var n20 = i24;

// node_modules/@arcgis/core/layers/support/rasterFunctions/rasterFunctionHelper.js
var v3 = /* @__PURE__ */ new Map();
function w6(t6, e9) {
  const { rasterFunctionArguments: r11 } = t6;
  if (!r11) return;
  (r11.rasters || [r11.raster, r11.raster2]).forEach((t7) => {
    t7 && "number" != typeof t7 && ("string" == typeof t7 ? t7.startsWith("http") && (e9.includes(t7) || e9.push(t7)) : "rasterFunctionArguments" in t7 && w6(t7, e9));
  });
}
function T2(t6, n21) {
  n21 = n21 ?? {};
  try {
    if ("function" in (t6 = a(t6)) && "arguments" in t6 && t6.arguments) {
      const r11 = $2(t6, /* @__PURE__ */ new Map(), n21);
      if (L2(r11), !r11.renderingRule) throw new s("raster-function-helper", "Unsupported raster function json.");
      t6 = r11.renderingRule;
    }
    if ("rasterFunction" in t6) {
      const e9 = k4(t6 = B4(t6), n21);
      return e9.isRoot = true, e9;
    }
  } catch {
  }
  throw new s("raster-function-helper", "unsupported raster function json.");
}
function D4(t6, e9) {
  return "rasters" === e9[0] && Array.isArray(t6.rasters) ? t6.rasters : e9.map((e10) => t6[e10]);
}
function V2(t6) {
  return !!(t6 && "object" == typeof t6 && t6.rasterFunction && t6.rasterFunctionArguments);
}
function B4(t6) {
  const { rasterFunction: e9, rasterFunctionArguments: r11 } = t6, n21 = {};
  for (const o9 in r11) {
    let t7 = r11[o9];
    const e10 = o9.toLowerCase();
    if ("rasters" === e10 && Array.isArray(t7)) n21.rasters = t7.map((t8) => V2(t8) ? B4(t8) : t8);
    else switch (V2(t7) && (t7 = B4(t7)), e10) {
      case "dra":
        n21.dra = t7;
        break;
      case "pspower":
        n21.psPower = t7;
        break;
      case "pszfactor":
        n21.psZFactor = t7;
        break;
      case "bandids":
        n21.bandIds = t7;
        break;
      default:
        n21[o9[0].toLowerCase() + o9.slice(1)] = t7;
    }
  }
  return "Local" !== e9 || n21.rasters?.length || (n21.rasters = ["$$"]), { ...t6, rasterFunctionArguments: n21 };
}
function k4(t6, r11) {
  const { rasterFunction: n21, rasterFunctionArguments: o9 } = t6, s11 = t6.outputPixelType?.toLowerCase();
  if (null == n21 || !v3.has(n21)) throw new s("raster-function-helper", `unsupported raster function: ${n21}`);
  const a29 = v3.get(n21), i25 = ("function" == typeof a29.ctor ? a29.ctor : a29.ctor.default).fromJSON({ ...t6, outputPixelType: s11 }), { rasterArgumentNames: c35 } = i25, u20 = [], m19 = D4(o9, c35), l22 = "rasters" === c35[0] || c35.length > 1, p18 = [];
  for (let e9 = 0; e9 < m19.length; e9++) {
    const t7 = m19[e9];
    let n22;
    null == t7 || "string" == typeof t7 && t7.startsWith("$") ? u20.push(r11?.raster) : "string" == typeof t7 ? r11[t7] && u20.push(r11[t7]) : "number" != typeof t7 && "rasterFunction" in t7 && (n22 = k4(t7, r11), l22 || (i25.functionArguments[c35[e9]] = n22), u20.push(n22)), l22 && p18.push(n22 ?? t7);
  }
  if (l22 && ("rasters" === c35[0] ? i25.functionArguments.rasters = p18 : c35.forEach((t7, e9) => {
    i25.functionArguments[t7] = p18[e9];
  })), r11) {
    i25.sourceRasters = u20;
    const t7 = r11.raster?.url;
    t7 && (i25.mainPrimaryRasterId = t7);
  }
  return i25;
}
function x5(t6, e9) {
  if (t6 && e9) for (const r11 in t6) {
    const n21 = t6[r11];
    n21 && "object" == typeof n21 && "type" in n21 && ("RasterFunctionTemplate" === n21.type ? x5(n21.arguments, e9) : "RasterFunctionVariable" === n21.type && null != e9[n21.name] && (n21.value = e9[n21.name]));
  }
}
function E2(t6, r11) {
  if (!t6 || "object" != typeof t6) return t6;
  const { value: n21 } = t6;
  if (!n21 || "object" != typeof n21) return t6.isDataset ? "$$" : n21;
  if (Array.isArray(n21)) return 0 === n21.length ? [] : n21.map((t7) => t7 && "object" == typeof t7 && "RasterFunctionVariable" === t7.type ? E2(t7, r11) : t7);
  if ("value" in n21 && ["number", "string", "boolean"].includes(typeof n21.value)) return n21.value;
  if (t6.isDataset && "Scalar" !== n21.type) return "$$";
  if (!("type" in n21)) return n21;
  let o9 = n21;
  switch (n21.type) {
    case "Scalar":
      o9 = n21.value;
      break;
    case "AlgorithmicColorRamp":
      o9 = M3(n21);
      break;
    case "MultiPartColorRamp":
      o9 = { type: "multipart", colorRamps: n21.ArrayOfColorRamp.map(M3) };
      break;
    case "ArgumentArray":
      if (n21.elements?.length && "RasterStatistics" !== n21.elements[0].type) {
        const t7 = [];
        for (let o10 = 0; o10 < n21.elements.length; o10++) {
          const s11 = n21.elements[o10], { type: a29 } = s11;
          if (a29) if ("RasterFunctionTemplate" === a29) {
            const { renderingRule: e9 } = $2(s11, r11);
            t7.push(e9), null != s11._object_id && r11.set(s11._object_id, e9);
          } else {
            if ("RasterFunctionVariable" !== a29) throw new s("raster-function-helper", "unsupported raster function json.");
            {
              const e9 = E2(s11, r11);
              t7.push(e9), null != s11._object_id && r11.set(s11._object_id, e9);
            }
          }
          else t7.push(s11);
        }
        o9 = t7;
      } else o9 = n21.elements;
  }
  return null != n21._object_id && r11.set(n21._object_id, o9), o9;
}
function M3(e9) {
  const r11 = e9.algorithm ?? "esriHSVAlgorithm";
  let { FromColor: n21, ToColor: o9 } = e9;
  if (!Array.isArray(n21)) {
    const { r: e10, g: r12, b: o10 } = U({ h: n21.Hue, s: n21.Saturation, v: n21.Value });
    n21 = [e10, r12, o10, n21.AlphaValue];
  }
  if (!Array.isArray(o9)) {
    const { r: e10, g: r12, b: n22 } = U({ h: o9.Hue, s: o9.Saturation, v: o9.Value });
    o9 = [e10, r12, n22, o9.AlphaValue];
  }
  return { type: "algorithmic", algorithm: r11, fromColor: n21, toColor: o9 };
}
function $2(t6, e9, r11) {
  r11 && x5(t6, r11);
  const n21 = { renderingRule: {}, templates: e9 };
  return H3(t6, n21), n21;
}
function H3(t6, e9) {
  if (!t6 || !e9.renderingRule) return;
  const { renderingRule: r11, templates: n21 } = e9, { function: o9, arguments: s11, _object_id: a29 } = t6;
  if (!o9 || !s11) return;
  null != a29 && n21.set(a29, r11), r11.rasterFunction = o9.type.replace("Function", ""), r11.outputPixelType = o9.pixelType;
  const i25 = {};
  r11.rasterFunctionArguments = i25;
  for (const c35 in s11) {
    if ("type" === c35 || "object_id" === c35 || "_object_ref_id" === c35) continue;
    const t7 = s11[c35];
    t7 && "object" == typeof t7 && "type" in t7 && ("RasterFunctionTemplate" === t7.type || "RasterFunctionVariable" === t7.type) ? ("RasterFunctionVariable" === t7.type ? i25[c35] = E2(t7, n21) : (r11.rasterFunctionArguments[c35] = {}, H3(t7, { renderingRule: r11.rasterFunctionArguments[c35], templates: n21 })), null != t7._object_id && n21.set(t7._object_id, i25[c35])) : i25[c35] = t7;
  }
  switch (i25.DEM && !i25.Raster && (i25.Raster = i25.DEM, delete i25.DEM), r11.rasterFunction) {
    case "Stretch":
      O2(i25);
      break;
    case "Colormap":
      G2(i25);
      break;
    case "Convolution":
      P2(i25);
      break;
    case "Mask":
      I2(i25);
  }
}
function L2(t6) {
  const { renderingRule: r11, templates: n21 } = t6;
  if ("object" != typeof r11 || !r11?.rasterFunctionArguments || !n21.size) return;
  const { rasterFunctionArguments: o9 } = r11;
  for (const s11 in o9) {
    const t7 = o9[s11], r12 = "_object_ref_id" === s11 ? t7 : t7 && "object" == typeof t7 && "_object_ref_id" in t7 ? t7._object_ref_id : null;
    if (null != r12) {
      if (!n21.has(r12)) throw new s("raster-function-helper", `unsupported raster function json. _object_ref_id: ${r12} does not exist`);
      const t8 = n21.get(r12);
      "_object_ref_id" !== s11 ? o9[s11] = t8 : t8 && "object" == typeof t8 && Object.assign(o9, t8);
      continue;
    }
    t7 && "object" == typeof t7 && (t7.rasterFunctionArguments && L2({ renderingRule: t7, templates: n21 }), Array.isArray(t7) && t7.forEach((o10, s12) => {
      if (o10 && "object" == typeof o10) if (null != o10._object_ref_id) {
        if (!n21.has(o10._object_ref_id)) throw new s("raster-function-helper", `unsupported raster function json. _object_ref_id: ${t7} does not exist`);
        const a29 = n21.get(r12);
        a29 && "object" == typeof a29 ? Object.assign(o10, a29) : t7[s12] = a29;
      } else L2({ renderingRule: o10, templates: n21 });
    }));
  }
}
function O2(t6) {
  t6.Statistics?.length && "object" == typeof t6.Statistics && (t6.Statistics = t6.Statistics.map((t7) => [t7.min, t7.max, t7.mean, t7.standardDeviation])), null != t6.NumberOfStandardDeviation && (t6.NumberOfStandardDeviations = t6.NumberOfStandardDeviation, delete t6.NumberOfStandardDeviation);
}
function G2(t6) {
  "randomcolorramp" === t6.ColorRamp?.type?.toLowerCase() && (delete t6.ColorRamp, t6.ColormapName = "Random"), 0 === t6.ColorSchemeType && delete t6.ColorRamp;
}
function P2(t6) {
  null != t6.ConvolutionType && (t6.Type = t6.ConvolutionType, delete t6.ConvolutionType);
}
function I2(t6) {
  t6.NoDataValues?.length && "string" == typeof t6.NoDataValues[0] && (t6.NoDataValues = t6.NoDataValues.filter((t7) => "" !== t7).map((t7) => Number(t7)));
}
v3.set("Arithmetic", { desc: "Arithmetic Function", ctor: a9, rasterArgumentNames: ["rasters"] }), v3.set("Aspect", { desc: "Aspect Function", ctor: p7, rasterArgumentNames: ["raster"] }), v3.set("BandArithmetic", { desc: "Band Arithmetic Function", ctor: m11, rasterArgumentNames: ["raster"] }), v3.set("Colormap", { desc: "Colormap Function", ctor: u11, rasterArgumentNames: ["raster"] }), v3.set("ColormapToRGB", { desc: "ColormapToRGB Function", ctor: m14, rasterArgumentNames: ["raster"] }), v3.set("CompositeBand", { desc: "CompositeBand Function", ctor: a14, rasterArgumentNames: ["rasters"] }), v3.set("ComputeChange", { desc: "ComputeChange Function", ctor: m15, rasterArgumentNames: ["rasters"] }), v3.set("Convolution", { desc: "Convolution Function", ctor: p12, rasterArgumentNames: ["raster"] }), v3.set("ContrastBrightness", { desc: "Contrast Brightness Function", ctor: p10, rasterArgumentNames: ["raster"] }), v3.set("ExtractBand", { desc: "ExtractBand Function", ctor: a18, rasterArgumentNames: ["raster"] }), v3.set("Curvature", { desc: "Curvature Function", ctor: c19, rasterArgumentNames: ["raster"] }), v3.set("Hillshade", { desc: "Hillshade Function", ctor: l17, rasterArgumentNames: ["raster"] }), v3.set("ShadedRelief", { desc: "ShadedRelief Function", ctor: x4, rasterArgumentNames: ["raster"] }), v3.set("Grayscale", { desc: "Grayscale Function", ctor: u16, rasterArgumentNames: ["raster"] }), v3.set("Clip", { desc: "Clip Function", ctor: u9, rasterArgumentNames: ["raster"] }), v3.set("Local", { desc: "Local Function", ctor: d8, rasterArgumentNames: ["rasters"] }), v3.set("Mask", { desc: "Mask Function", ctor: c25, rasterArgumentNames: ["raster"] }), v3.set("NDVI", { desc: "NDVI Function", ctor: u17, rasterArgumentNames: ["raster"] }), v3.set("Remap", { desc: "Remap Function", ctor: f7, rasterArgumentNames: ["raster"] }), v3.set("Slope", { desc: "Slope Function", ctor: c28, rasterArgumentNames: ["raster"] }), v3.set("Statistics", { desc: "Focal Statistics Function", ctor: c30, rasterArgumentNames: ["raster"] }), v3.set("StatisticsHistogram", { desc: "Statistics Histogram Function", ctor: n18, rasterArgumentNames: ["raster"] }), v3.set("Stretch", { desc: "Stretch Function", ctor: f8, rasterArgumentNames: ["raster"] }), v3.set("Table", { desc: "Attribute Table Function", ctor: n20, rasterArgumentNames: ["raster"] });

export {
  w6 as w,
  T2 as T
};
//# sourceMappingURL=chunk-NEYJ2XGC.js.map
