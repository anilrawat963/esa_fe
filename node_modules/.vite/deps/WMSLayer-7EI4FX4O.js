import {
  a as a4
} from "./chunk-PUPK5C6R.js";
import {
  o as o3
} from "./chunk-LAJ2QATM.js";
import {
  t as t3
} from "./chunk-TG6K2MFM.js";
import {
  i
} from "./chunk-2U5X5TIX.js";
import {
  l as l3
} from "./chunk-JSH3APTG.js";
import "./chunk-WQT2KLDB.js";
import {
  f as f3
} from "./chunk-TCDV4P3G.js";
import {
  b2,
  d,
  y
} from "./chunk-CZOYDK6P.js";
import {
  j
} from "./chunk-6TCXGIIN.js";
import {
  l as l2,
  m as m2
} from "./chunk-NP2TBOXH.js";
import "./chunk-H34D76ZQ.js";
import {
  t
} from "./chunk-OJBEN6CV.js";
import {
  p
} from "./chunk-PEL3D3ZN.js";
import "./chunk-Q5KWD3VQ.js";
import "./chunk-BUQC3CLV.js";
import {
  t as t2
} from "./chunk-W5S3VUFT.js";
import "./chunk-7YH7T6CS.js";
import "./chunk-3T4IXPP4.js";
import "./chunk-XTZAIV4X.js";
import "./chunk-63LDVRFI.js";
import {
  _ as _2
} from "./chunk-C3FRY5U4.js";
import {
  q
} from "./chunk-JNJX34GB.js";
import "./chunk-3STJRSDT.js";
import "./chunk-67Q6KVC6.js";
import "./chunk-23NJHA5Q.js";
import "./chunk-4LA6K4VI.js";
import "./chunk-KEZCWFAR.js";
import "./chunk-JZUJ34RR.js";
import "./chunk-PMGS7UDU.js";
import "./chunk-3GHCGAH2.js";
import "./chunk-HWUOAPTX.js";
import "./chunk-QHCKOBU7.js";
import "./chunk-K2OZ6WVC.js";
import "./chunk-MC6NAKKX.js";
import "./chunk-TF6255HN.js";
import "./chunk-GD4FJL3C.js";
import "./chunk-C5OQVQZF.js";
import "./chunk-F7DKSAOI.js";
import "./chunk-4SOQWNPG.js";
import "./chunk-LTULADK2.js";
import "./chunk-35ST7YRB.js";
import "./chunk-EDA5QFHZ.js";
import {
  l as l4
} from "./chunk-XXBJY7RN.js";
import "./chunk-CNYNCKEV.js";
import "./chunk-XL5QPCXN.js";
import "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-W75DBJD7.js";
import {
  b as b3
} from "./chunk-P6IKJIMO.js";
import "./chunk-MHV23XAQ.js";
import "./chunk-V2X4OKYI.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import "./chunk-MA3QDRC3.js";
import "./chunk-W6J7XCPU.js";
import {
  s as s4
} from "./chunk-ONXWBTTM.js";
import "./chunk-T7F6Q6JJ.js";
import {
  O
} from "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-7P2ANHQ3.js";
import "./chunk-XCKT47LJ.js";
import "./chunk-3FUHCAX3.js";
import "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import {
  z
} from "./chunk-H74Q4SYB.js";
import {
  U,
  a as a3,
  l
} from "./chunk-2OFHDVO5.js";
import "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-5UPBUJPC.js";
import "./chunk-THQO67BJ.js";
import {
  DateTime,
  FixedOffsetZone
} from "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-CCQFL76O.js";
import "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import "./chunk-7H3U4IJR.js";
import "./chunk-SMWUT52Z.js";
import "./chunk-AXZMNHTN.js";
import {
  f as f2
} from "./chunk-5T3MJDSR.js";
import {
  T
} from "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import {
  Bt,
  H2 as H,
  I,
  P,
  _,
  b,
  x as x2
} from "./chunk-V2H77UEV.js";
import {
  s as s3
} from "./chunk-WRA2WBYC.js";
import {
  o as o2
} from "./chunk-XWE6BM2U.js";
import {
  r
} from "./chunk-SOIZOFSB.js";
import {
  c
} from "./chunk-XXLHAM2M.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2,
  w,
  x
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import {
  o
} from "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import {
  f2 as f
} from "./chunk-GNMPGHLQ.js";
import {
  a,
  s,
  s2
} from "./chunk-QY7XKUIV.js";
import {
  N
} from "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/layers/support/WMSSublayer.js
var h;
var c2 = 0;
var m3 = h = class extends s4(m2) {
  constructor(e) {
    super(e), this.description = null, this.dimensions = null, this.fullExtent = null, this.fullExtents = null, this.legendUrl = null, this.legendEnabled = true, this.layer = null, this.maxScale = 0, this.minScale = 0, this.name = null, this.parent = null, this.popupEnabled = false, this.queryable = false, this.sublayers = null, this.spatialReferences = null, this.title = null, this.addHandles([a3(() => this.sublayers, "after-add", ({ item: e2 }) => {
      e2.parent = this, e2.layer = this.layer;
    }, U), a3(() => this.sublayers, "after-remove", ({ item: e2 }) => {
      e2.layer = e2.parent = null;
    }, U), l(() => this.sublayers, (e2, t4) => {
      if (t4) for (const r2 of t4) r2.layer = r2.parent = null;
      if (e2) for (const r2 of e2) r2.parent = this, r2.layer = this.layer;
    }, U), l(() => this.layer, (e2) => {
      if (this.sublayers) for (const t4 of this.sublayers) t4.layer = e2;
    }, U)]);
  }
  get id() {
    const e = this._get("id");
    return e ?? c2++;
  }
  set id(e) {
    this._set("id", e);
  }
  readLegendUrl(e, t4) {
    return t4.legendUrl ?? t4.legendURL ?? null;
  }
  get effectiveScaleRange() {
    const { minScale: e, maxScale: t4 } = this;
    return { minScale: e, maxScale: t4 };
  }
  castSublayers(e) {
    return w(O.ofType(h), e);
  }
  set visible(e) {
    this._setAndNotifyLayer("visible", e);
  }
  clone() {
    const e = new h();
    return this.hasOwnProperty("description") && (e.description = this.description), this.hasOwnProperty("fullExtent") && (e.fullExtent = this.fullExtent.clone()), this.hasOwnProperty("fullExtents") && (e.fullExtents = this.fullExtents?.map((e2) => e2.clone()) ?? null), this.hasOwnProperty("legendUrl") && (e.legendUrl = this.legendUrl), this.hasOwnProperty("legendEnabled") && (e.legendEnabled = this.legendEnabled), this.hasOwnProperty("layer") && (e.layer = this.layer), this.hasOwnProperty("name") && (e.name = this.name), this.hasOwnProperty("parent") && (e.parent = this.parent), this.hasOwnProperty("queryable") && (e.queryable = this.queryable), this.hasOwnProperty("sublayers") && (e.sublayers = this.sublayers?.map((e2) => e2.clone())), this.hasOwnProperty("spatialReferences") && (e.spatialReferences = this.spatialReferences?.map((e2) => e2)), this.hasOwnProperty("visible") && (e.visible = this.visible), this.hasOwnProperty("title") && (e.title = this.title), e;
  }
  _setAndNotifyLayer(e, t4) {
    const r2 = this.layer;
    this._get(e) !== t4 && (this._set(e, t4), r2 && r2.emit("wms-sublayer-update", { propertyName: e, id: this.id }));
  }
};
__decorate([m()], m3.prototype, "description", void 0), __decorate([m({ readOnly: true })], m3.prototype, "dimensions", void 0), __decorate([m({ type: z, json: { name: "extent" } })], m3.prototype, "fullExtent", void 0), __decorate([m()], m3.prototype, "fullExtents", void 0), __decorate([m({ type: Number, json: { write: { enabled: false, overridePolicy: () => ({ ignoreOrigin: true, enabled: true }) } } })], m3.prototype, "id", null), __decorate([m({ type: String, json: { name: "legendUrl", write: { ignoreOrigin: true } } })], m3.prototype, "legendUrl", void 0), __decorate([o2("legendUrl", ["legendUrl", "legendURL"])], m3.prototype, "readLegendUrl", null), __decorate([m({ type: Boolean, json: { name: "showLegend", origins: { "web-map": { read: false, write: false }, "web-scene": { read: false, write: false } } } })], m3.prototype, "legendEnabled", void 0), __decorate([m()], m3.prototype, "layer", void 0), __decorate([m()], m3.prototype, "maxScale", void 0), __decorate([m()], m3.prototype, "minScale", void 0), __decorate([m({ readOnly: true })], m3.prototype, "effectiveScaleRange", null), __decorate([m({ type: String, json: { write: { ignoreOrigin: true } } })], m3.prototype, "name", void 0), __decorate([m()], m3.prototype, "parent", void 0), __decorate([m({ type: Boolean, json: { read: { source: "showPopup" }, write: { ignoreOrigin: true, target: "showPopup" } } })], m3.prototype, "popupEnabled", void 0), __decorate([m({ type: Boolean, json: { write: { ignoreOrigin: true } } })], m3.prototype, "queryable", void 0), __decorate([m()], m3.prototype, "sublayers", void 0), __decorate([s3("sublayers")], m3.prototype, "castSublayers", null), __decorate([m({ type: [Number], json: { read: { source: "spatialReferences" } } })], m3.prototype, "spatialReferences", void 0), __decorate([m({ type: String, json: { write: { ignoreOrigin: true } } })], m3.prototype, "title", void 0), __decorate([m({ type: Boolean, value: true, json: { read: { source: "defaultVisibility" } } })], m3.prototype, "visible", null), m3 = h = __decorate([a2("esri.layers.support.WMSSublayer")], m3);

// node_modules/@arcgis/core/layers/support/wmsUtils.js
var o4 = { 84: 4326, 83: 4269, 27: 4267 };
function a5(n) {
  if (!n) return null;
  const r2 = { idCounter: -1 };
  if ("string" == typeof n) {
    n = new DOMParser().parseFromString(n, "text/xml");
  }
  const i2 = n.documentElement;
  if ("ServiceExceptionReport" === i2.nodeName) {
    const e = Array.prototype.slice.call(i2.childNodes).map((e2) => e2.textContent).join("\r\n");
    throw new s2("wmslayer:wms-capabilities-xml-is-not-valid", "The server returned errors when the WMS capabilities were requested.", e);
  }
  const s5 = d2("Capability", i2), o5 = d2("Service", i2), a6 = s5 && d2("Request", s5);
  if (!s5 || !o5 || !a6) return null;
  const l6 = d2("Layer", s5);
  if (!l6) return null;
  const m5 = "WMS_Capabilities" === i2.nodeName || "WMT_MS_Capabilities" === i2.nodeName ? i2.getAttribute("version") : "1.3.0", f5 = x3("Title", o5, "") || x3("Name", o5, ""), p3 = x3("AccessConstraints", o5, ""), h3 = /^none$/i.test(p3) ? "" : p3, y3 = x3("Abstract", o5, ""), S2 = parseInt(x3("MaxWidth", o5, "5000"), 10), E = parseInt(x3("MaxHeight", o5, "5000"), 10), L2 = g(a6, "GetMap"), C = N2(a6, "GetMap"), M2 = b4(l6, m5, r2);
  if (!M2) return null;
  let T3, R2 = 0;
  const I3 = Array.prototype.slice.call(s5.childNodes), v2 = M2.sublayers ?? [], w3 = (e) => {
    null != e && v2.push(e);
  };
  I3.forEach((e) => {
    "Layer" === e.nodeName && (0 === R2 ? T3 = e : 1 === R2 ? (M2.name && (M2.name = "", w3(b4(T3, m5, r2))), w3(b4(e, m5, r2))) : w3(b4(e, m5, r2)), R2++);
  });
  const U3 = M2.sublayers ?? [], V2 = M2.fullExtents ?? [];
  0 === U3.length && U3.push(M2), M2.extent ??= U3[0].extent;
  const _4 = M2.spatialReferences.length > 0 ? M2.spatialReferences : u(M2), O3 = N2(a6, "GetFeatureInfo"), B2 = O3 ? g(a6, "GetFeatureInfo") : null, k2 = c3(U3), q3 = M2.minScale || 0, X3 = M2.maxScale || 0, D = M2.dimensions ?? [], $ = k2.reduce((e, t4) => e.concat(t4.dimensions ?? []), []), j2 = D.concat($).filter(F);
  let G = null;
  if (j2.length) {
    const t4 = j2.map((e) => {
      const { extent: t5 } = e;
      return A(t5) ? t5.map((e2) => e2.getTime()) : t5?.map((e2) => [e2.min.getTime(), e2.max.getTime()]);
    }).flat(2).filter(N), { start: n2, end: r3 } = t4.reduce((e, t5) => ({ start: Math.min(e.start, t5), end: Math.max(e.end, t5) }), { start: 1 / 0, end: -1 / 0 });
    G = { startTimeField: null, endTimeField: null, trackIdField: void 0, timeExtent: [n2, r3] };
  }
  return { copyright: h3, description: y3, dimensions: D, extent: M2.extent, fullExtents: V2, featureInfoFormats: B2, featureInfoUrl: O3, mapUrl: C, maxWidth: S2, maxHeight: E, maxScale: X3, minScale: q3, layers: k2, spatialReferences: _4, supportedImageFormatTypes: L2, timeInfo: G, title: f5, version: m5 };
}
function l5(e) {
  const t4 = e.filter((e2) => e2.popupEnabled && e2.name && e2.queryable);
  return t4.length ? t4.map(({ name: e2 }) => e2).join() : null;
}
function u(e) {
  if (e.spatialReferences.length > 0) return e.spatialReferences;
  if (e.sublayers) for (const t4 of e.sublayers) {
    const e2 = u(t4);
    if (e2.length > 0) return e2;
  }
  return [];
}
function c3(e) {
  let t4 = [];
  for (const n of e) t4.push(n), n.sublayers?.length && (t4 = t4.concat(c3(n.sublayers)), delete n.sublayers);
  return t4;
}
function m4(e, t4, n) {
  return t4.getAttribute(e) ?? n;
}
function f4(e, t4, n, r2) {
  const i2 = d2(e, n);
  return i2 ? m4(t4, i2, r2) : r2;
}
function d2(e, t4) {
  for (let n = 0; n < t4.childNodes.length; n++) {
    const r2 = t4.childNodes[n];
    if (S(r2) && r2.nodeName === e) return r2;
  }
  return null;
}
function p2(e, t4) {
  if (null == t4) return [];
  const n = [];
  for (let r2 = 0; r2 < t4.childNodes.length; r2++) {
    const i2 = t4.childNodes[r2];
    S(i2) && i2.nodeName === e && n.push(i2);
  }
  return n;
}
function x3(e, t4, n) {
  return d2(e, t4)?.textContent ?? n;
}
function h2(e, t4, n) {
  const r2 = parseFloat(e.getAttribute("minx") ?? "0"), i2 = parseFloat(e.getAttribute("miny") ?? "0"), s5 = parseFloat(e.getAttribute("maxx") ?? "0"), o5 = parseFloat(e.getAttribute("maxy") ?? "0");
  return { xmin: n ? isNaN(i2) ? -Number.MAX_VALUE : i2 : isNaN(r2) ? -Number.MAX_VALUE : r2, ymin: n ? isNaN(r2) ? -Number.MAX_VALUE : r2 : isNaN(i2) ? -Number.MAX_VALUE : i2, xmax: n ? isNaN(o5) ? Number.MAX_VALUE : o5 : isNaN(s5) ? Number.MAX_VALUE : s5, ymax: n ? isNaN(s5) ? Number.MAX_VALUE : s5 : isNaN(o5) ? Number.MAX_VALUE : o5, spatialReference: { wkid: t4 } };
}
function N2(e, t4) {
  const n = d2(t4, e);
  if (n) {
    const e2 = d2("DCPType", n);
    if (e2) {
      const t5 = d2("HTTP", e2);
      if (t5) {
        const e3 = d2("Get", t5);
        if (e3) {
          let t6 = f4("OnlineResource", "xlink:href", e3, null);
          if (t6) {
            const e4 = t6.indexOf("&");
            return -1 !== e4 && e4 === t6.length - 1 && (t6 = t6.slice(0, -1)), M(t6, ["service", "request"]);
          }
        }
      }
    }
  }
  return null;
}
function g(t4, n) {
  const r2 = p2("Operation", t4);
  if (!r2.length) {
    return p2("Format", d2(n, t4)).map(({ textContent: e }) => e).filter(N);
  }
  const i2 = [];
  for (const e of r2) if (e.getAttribute("name") === n) {
    const t5 = p2("Format", e);
    for (const { textContent: e2 } of t5) null != e2 && i2.push(e2);
  }
  return i2;
}
function y2(e, t4, n) {
  const r2 = d2(t4, e);
  if (!r2) return n;
  const { textContent: i2 } = r2;
  if (null == i2 || "" === i2) return n;
  const s5 = Number(i2);
  return isNaN(s5) ? n : s5;
}
function b4(e, t4, n) {
  if (!e) return null;
  const i2 = e.getAttribute("queryable")?.toLowerCase(), s5 = "1" === i2 || "true" === i2, a6 = { id: n.idCounter++, fullExtents: [], parentLayerId: null, queryable: s5, spatialReferences: [], sublayers: null }, l6 = d2("LatLonBoundingBox", e), u2 = d2("EX_GeographicBoundingBox", e), c4 = l6 ? h2(l6, 4326) : u2 ? { xmin: parseFloat(x3("westBoundLongitude", u2, "0")), ymin: parseFloat(x3("southBoundLatitude", u2, "0")), xmax: parseFloat(x3("eastBoundLongitude", u2, "0")), ymax: parseFloat(x3("northBoundLatitude", u2, "0")), spatialReference: { wkid: 4326 } } : { xmin: -180, ymin: -90, xmax: 180, ymax: 90, spatialReference: { wkid: 4326 } };
  a6.minScale = y2(e, "MaxScaleDenominator", 0), a6.maxScale = y2(e, "MinScaleDenominator", 0);
  const f5 = ["1.0.0", "1.1.0", "1.1.1"].includes(t4) ? "SRS" : "CRS";
  return Array.prototype.slice.call(e.childNodes).forEach((e2) => {
    if ("Name" === e2.nodeName) a6.name = e2.textContent || "";
    else if ("Title" === e2.nodeName) a6.title = e2.textContent || "";
    else if ("Abstract" === e2.nodeName) a6.description = e2.textContent || "";
    else if ("BoundingBox" === e2.nodeName) {
      const n2 = e2.getAttribute(f5), i3 = n2?.indexOf(":");
      if (i3 && i3 > -1) {
        let s6 = parseInt(n2.slice(i3 + 1), 10);
        0 === s6 || isNaN(s6) || (s6 = o4[s6] ?? s6);
        const l7 = "1.3.0" === t4 ? h2(e2, s6, o3(s6)) : h2(e2, s6);
        l7 && a6.fullExtents && a6.fullExtents.push(l7);
      }
    } else if (e2.nodeName === f5) {
      (e2.textContent?.split(" ") ?? []).forEach((e3) => {
        let t5 = NaN;
        if (e3.includes(":")) {
          const [n2, r2] = e3.toUpperCase().split(":");
          "CRS" !== n2 && "EPSG" !== n2 || (t5 = parseInt(r2, 10));
        } else t5 = parseInt(e3, 10);
        if (0 !== t5 && !isNaN(t5)) {
          const e4 = o4[t5] ?? t5;
          a6.spatialReferences.includes(e4) || a6.spatialReferences.push(e4);
        }
      });
    } else if ("Style" !== e2.nodeName || a6.legendUrl) {
      if ("Layer" === e2.nodeName) {
        const r2 = b4(e2, t4, n);
        r2 && (r2.parentLayerId = a6.id, a6.sublayers || (a6.sublayers = []), a6.sublayers.push(r2));
      }
    } else {
      const t5 = d2("LegendURL", e2);
      if (t5) {
        const e3 = d2("OnlineResource", t5);
        e3 && (a6.legendUrl = e3.getAttribute("xlink:href"));
      }
    }
  }), a6.extent = c4, a6.dimensions = p2("Dimension", e).filter((e2) => e2.getAttribute("name") && e2.getAttribute("units") && e2.textContent).map((e2) => {
    const t5 = e2.getAttribute("name"), n2 = e2.getAttribute("units"), r2 = e2.textContent, i3 = e2.getAttribute("unitSymbol") ?? void 0, s6 = e2.getAttribute("default") ?? void 0, o5 = "0" !== m4("default", e2, "0"), a7 = "0" !== m4("nearestValue", e2, "0"), l7 = "0" !== m4("current", e2, "0");
    if (F({ name: t5, units: n2 })) {
      return { name: "time", units: "ISO8601", extent: I2(r2), default: I2(s6), multipleValues: o5, nearestValue: a7, current: l7 };
    }
    if (L({ name: t5, units: n2 })) {
      return { name: "elevation", units: n2, extent: T2(r2), unitSymbol: i3, default: T2(s6), multipleValues: o5, nearestValue: a7 };
    }
    return { name: t5, units: n2, extent: R(r2), unitSymbol: i3, default: R(s6), multipleValues: o5, nearestValue: a7 };
  }), a6;
}
function A(e) {
  return Array.isArray(e) && e.length > 0 && e[0] instanceof Date;
}
function S(e) {
  return e.nodeType === Node.ELEMENT_NODE;
}
function L(e) {
  return /^elevation$/i.test(e.name) && /^(epsg|crs):\d+$/i.test(e.units);
}
function F(e) {
  return /^time$/i.test(e.name) && /^iso8601$/i.test(e.units);
}
function M(e, t4) {
  const r2 = [], i2 = I(e);
  for (const n in i2.query) i2.query.hasOwnProperty(n) && (t4.includes(n.toLowerCase()) || r2.push(n + "=" + i2.query[n]));
  return i2.path + (r2.length ? "?" + r2.join("&") : "");
}
function T2(t4) {
  if (!t4) return;
  const n = t4.includes("/"), r2 = t4.split(",");
  return n ? r2.map((e) => {
    const t5 = e.split("/");
    if (t5.length < 2) return null;
    return { min: parseFloat(t5[0]), max: parseFloat(t5[1]), resolution: t5.length >= 3 && "0" !== t5[2] ? parseFloat(t5[2]) : void 0 };
  }).filter(N) : r2.map((e) => parseFloat(e));
}
function R(t4) {
  if (!t4) return;
  const n = t4.includes("/"), r2 = t4.split(",");
  return n ? r2.map((e) => {
    const t5 = e.split("/");
    if (t5.length < 2) return null;
    return { min: t5[0], max: t5[1], resolution: t5.length >= 3 && "0" !== t5[2] ? t5[2] : void 0 };
  }).filter(N) : r2;
}
function I2(t4) {
  if (!t4) return;
  const n = t4.includes("/"), r2 = t4.split(",");
  return n ? r2.map((e) => {
    const t5 = e.split("/");
    if (t5.length < 2) return null;
    return { min: v(t5[0]), max: v(t5[1]), resolution: t5.length >= 3 && "0" !== t5[2] ? w2(t5[2]) : void 0 };
  }).filter(N) : r2.map((e) => v(e));
}
function v(e) {
  return DateTime.fromISO(e, { zone: FixedOffsetZone.utcInstance }).toJSDate();
}
function w2(e) {
  const t4 = /(?:p(\d+y|\d+(?:\.|,)\d+y)?(\d+m|\d+(?:\.|,)\d+m)?(\d+d|\d+(?:\.|,)\d+d)?)?(?:t(\d+h|\d+(?:\.|,)\d+h)?(\d+m|\d+(?:\.|,)\d+m)?(\d+s|\d+(?:\.|,)\d+s)?)?/i, n = e.match(t4);
  if (!n) return null;
  return { years: U2(n[1]), months: U2(n[2]), days: U2(n[3]), hours: U2(n[4]), minutes: U2(n[5]), seconds: U2(n[6]) };
}
function U2(e) {
  if (!e) return 0;
  const t4 = /(?:\d+(?:\.|,)\d+|\d+)/, n = e.match(t4);
  if (!n) return 0;
  const r2 = n[0].replace(",", ".");
  return Number(r2);
}
function V(e) {
  return e.toISOString().replace(/\.[0-9]{3}/, "");
}
var _3 = "0000-01-01T00:00:00Z";
var O2 = "9999-12-31T23:59:59Z";
function B(e) {
  if (!e || e.isAllTime || e.isEmpty) return;
  const { start: t4, end: n } = e;
  if (t4 && n && t4.getTime() === n.getTime()) return `${V(t4)}`;
  return `${t4 ? V(t4) : _3}/${n ? V(n) : O2}`;
}
var k = /* @__PURE__ */ new Set([102100, 3857, 102113, 900913]);
var q2 = /* @__PURE__ */ new Set([3395, 54004]);
function X(e, t4) {
  let n = e.wkid;
  return null == t4 ? n : (null != n && t4.includes(n) || !e.latestWkid || (n = e.latestWkid), null != n && k.has(n) ? t4.find((e2) => k.has(e2)) || t4.find((e2) => q2.has(e2)) || 102100 : n);
}

// node_modules/@arcgis/core/layers/WMSLayer.js
var Q = new o({ bmp: "image/bmp", gif: "image/gif", jpg: "image/jpeg", png: "image/png", svg: "image/svg+xml" }, { ignoreUnknown: false });
function K(e) {
  return "text/html" === e;
}
function X2(e) {
  return "text/plain" === e;
}
var Y = class extends p(l3(f3(t2(b2(j(l2(b3))))))) {
  constructor(...e) {
    super(...e), this.allSublayers = new l4({ getCollections: () => [this.sublayers], getChildrenFunction: (e2) => e2.sublayers }), this.customParameters = null, this.customLayerParameters = null, this.copyright = null, this.description = null, this.dimensions = null, this.fullExtent = null, this.fullExtents = null, this.featureInfoFormats = null, this.featureInfoUrl = null, this.fetchFeatureInfoFunction = null, this.imageFormat = null, this.imageMaxHeight = 2048, this.imageMaxWidth = 2048, this.imageTransparency = true, this.legendEnabled = true, this.mapUrl = null, this.isReference = null, this.operationalLayerType = "WMS", this.spatialReference = null, this.spatialReferences = null, this.sublayers = null, this.type = "wms", this.version = null, this.addHandles([a3(() => this.sublayers, "after-add", ({ item: e2 }) => {
      e2.parent = e2.layer = this;
    }, U), a3(() => this.sublayers, "after-remove", ({ item: e2 }) => {
      e2.layer = e2.parent = null;
    }, U), l(() => this.sublayers, (e2, t4) => {
      if (t4) for (const r2 of t4) r2.layer = r2.parent = null;
      if (e2) for (const r2 of e2) r2.parent = r2.layer = this;
    }, U)]);
  }
  normalizeCtorArgs(e, t4) {
    return "string" == typeof e ? { url: e, ...t4 } : e;
  }
  destroy() {
    this.allSublayers.destroy();
  }
  load(e) {
    const t4 = null != e ? e.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["WMS"] }, e).catch(f).then(() => this._fetchService(t4)).then(() => this._checkLayerValidity())), Promise.resolve(this);
  }
  set timeInfo(e) {
    super.timeInfo = e;
  }
  readFullExtentFromItemOrMap(e, t4) {
    const r2 = t4.extent;
    return r2 ? new z({ xmin: r2[0][0], ymin: r2[0][1], xmax: r2[1][0], ymax: r2[1][1] }) : null;
  }
  writeFullExtent(e, t4) {
    t4.extent = [[e.xmin, e.ymin], [e.xmax, e.ymax]];
  }
  get featureInfoFormat() {
    return null == this.featureInfoFormats ? null : this.featureInfoFormats.find(K) ?? this.featureInfoFormats.find(X2) ?? null;
  }
  set featureInfoFormat(e) {
    null == e ? (this.revert("featureInfoFormat", "service"), this._clearOverride("featureInfoFormat")) : (K(e) || X2(e)) && this._override("featureInfoFormat", e);
  }
  readImageFormat(e, t4) {
    const r2 = t4.supportedImageFormatTypes;
    return r2 && r2.includes("image/png") ? "image/png" : r2 && r2[0];
  }
  readSpatialReferenceFromItemOrDocument(e, t4) {
    return new f2(t4.spatialReferences[0]);
  }
  writeSpatialReferences(e, t4) {
    const r2 = this.spatialReference?.wkid;
    e && r2 ? (t4.spatialReferences = e.filter((e2) => e2 !== r2), t4.spatialReferences.unshift(r2)) : t4.spatialReferences = e;
  }
  readSublayersFromItemOrMap(e, t4, r2) {
    return ee(t4.layers, r2, t4.visibleLayers);
  }
  readSublayers(e, t4, r2) {
    return ee(t4.layers, r2);
  }
  writeSublayers(e, t4, r2, o5) {
    t4.layers = [];
    const s5 = /* @__PURE__ */ new Map(), i2 = e.flatten(({ sublayers: e2 }) => e2 ?? []);
    for (const a6 of i2) if ("number" == typeof a6.parent?.id) {
      const e2 = s5.get(a6.parent.id);
      null != e2 ? e2.push(a6.id) : s5.set(a6.parent.id, [a6.id]);
    }
    for (const a6 of i2) {
      const e2 = { sublayer: a6, ...o5 }, r3 = a6.write({ parentLayerId: "number" == typeof a6.parent?.id ? a6.parent.id : -1 }, e2);
      if (s5.has(a6.id) && (r3.sublayerIds = s5.get(a6.id)), !a6.sublayers && a6.name) {
        const r4 = a6.write({}, e2);
        delete r4.id, t4.layers.push(r4);
      }
    }
    t4.visibleLayers = i2.filter(({ visible: e2, sublayers: t5 }) => e2 && !t5).map(({ name: e2 }) => e2).toArray();
  }
  set url(e) {
    if (!e) return void this._set("url", e);
    const { path: t4, query: r2 } = I(e);
    for (const s5 in r2) /^(request|service)$/i.test(s5) && delete r2[s5];
    const o5 = Bt(t4, r2 ?? {});
    this._set("url", o5);
  }
  createExportImageParameters(e, t4, r2, o5) {
    const s5 = o5?.pixelRatio ?? 1, i2 = i({ extent: e, width: t4 }) * s5, a6 = new a4({ layer: this, scale: i2 }), { xmin: n, ymin: l6, xmax: p3, ymax: m5, spatialReference: u2 } = e, c4 = X(u2, this.spatialReferences), y3 = "1.3.0" === this.version && o3(c4) ? `${l6},${n},${m5},${p3}` : `${n},${l6},${p3},${m5}`, f5 = a6.toJSON(), d3 = "1.3.0" === this.version ? "crs" : "srs";
    return { bbox: y3, [d3]: null == c4 || isNaN(c4) ? void 0 : "EPSG:" + c4, ...f5 };
  }
  async fetchImage(e, t4, r2, o5) {
    const i2 = this.mapUrl, a6 = this.createExportImageParameters(e, t4, r2, o5);
    if (!a6.layers) {
      const e2 = document.createElement("canvas");
      return e2.width = t4, e2.height = r2, e2;
    }
    const n = B(o5?.timeExtent), l6 = { responseType: "image", query: this._mixCustomParameters({ width: t4, height: r2, ...a6, time: n, ...this.refreshParameters }), signal: o5?.signal };
    return H(i2 ?? "", l6).then((e2) => e2.data);
  }
  async fetchImageBitmap(e, t4, r2, o5) {
    const i2 = this.mapUrl ?? "", a6 = this.createExportImageParameters(e, t4, r2, o5);
    if (!a6.layers) {
      const e2 = document.createElement("canvas");
      return e2.width = t4, e2.height = r2, e2;
    }
    const n = B(o5?.timeExtent), l6 = { responseType: "blob", query: this._mixCustomParameters({ width: t4, height: r2, ...a6, time: n, ...this.refreshParameters }), signal: o5?.signal }, { data: p3 } = await H(i2, l6);
    return t3(p3, i2, o5?.signal);
  }
  fetchFeatureInfo(e, t4, r2, o5, s5) {
    const i2 = i({ extent: e, width: t4 }), a6 = new a4({ layer: this, scale: i2 }), n = l5(a6.visibleSublayers);
    if (null == this.featureInfoUrl || null == n) return Promise.resolve([]);
    if (null == this.fetchFeatureInfoFunction && null == this.featureInfoFormat) return Promise.resolve([]);
    const l6 = "1.3.0" === this.version ? { I: o5, J: s5 } : { x: o5, y: s5 }, p3 = { query_layers: n, request: "GetFeatureInfo", info_format: this.featureInfoFormat, feature_count: 25, width: t4, height: r2, ...l6 }, m5 = { ...this.createExportImageParameters(e, t4, r2), ...p3 }, u2 = this._mixCustomParameters(m5);
    return null != this.fetchFeatureInfoFunction ? this.fetchFeatureInfoFunction(u2) : this._defaultFetchFeatureInfoFunction(Bt(this.featureInfoUrl, u2));
  }
  findSublayerById(e) {
    return this.allSublayers.find((t4) => t4.id === e);
  }
  findSublayerByName(e) {
    return this.allSublayers.find((t4) => t4.name === e);
  }
  serviceSupportsSpatialReference(e) {
    return b(this.url) || null != this.spatialReferences && this.spatialReferences.some((t4) => {
      const r2 = 900913 === t4 ? f2.WebMercator : new f2({ wkid: t4 });
      return T(r2, e);
    });
  }
  _defaultFetchFeatureInfoFunction(e) {
    const t4 = document.createElement("iframe");
    t4.src = P(t.sanitizeUrl(_(e))), t4.style.border = "none", t4.style.margin = "0", t4.style.width = "100%", t4.setAttribute("sandbox", "");
    const s5 = new q({ title: this.title, content: t4 }), i2 = new _2({ sourceLayer: this, popupTemplate: s5 });
    return Promise.resolve([i2]);
  }
  async _fetchService(e) {
    if (!this.resourceInfo && this.parsedUrl?.path) {
      const { path: t4, query: r2 } = this.parsedUrl, { data: o5 } = await H(t4, { query: { SERVICE: "WMS", REQUEST: "GetCapabilities", ...r2, ...this.customParameters }, responseType: "xml", signal: e });
      this.resourceInfo = a5(o5);
    }
    if (this.parsedUrl) {
      const e2 = new x2(this.parsedUrl.path), { httpsDomains: r2 } = s.request;
      "https" !== e2.scheme || e2.port && "443" !== e2.port || !e2.host || r2.includes(e2.host) || r2.push(e2.host);
    }
    this.read(this.resourceInfo, { origin: "service" });
  }
  _checkLayerValidity() {
    if (!this.allSublayers.length) throw new s2("wmslayer:empty-layer", "The layer doesn't have any sublayer");
  }
  _mixCustomParameters(e) {
    if (!this.customLayerParameters && !this.customParameters) return e;
    const t4 = { ...this.customParameters, ...this.customLayerParameters };
    for (const r2 in t4) e[r2.toLowerCase()] = t4[r2];
    return e;
  }
};
function Z(e, t4) {
  return e.some((e2) => {
    for (const r2 in e2) if (c(e2, r2, null, t4)) return true;
    return false;
  });
}
function ee(e, t4, r2) {
  e = e ?? [];
  const o5 = /* @__PURE__ */ new Map();
  e.every((e2) => null == e2.id) && (e = a(e)).forEach((e2, t5) => e2.id = t5);
  for (const i2 of e) {
    const e2 = new m3();
    e2.read(i2, t4), r2 && !r2.includes(e2.name) && (e2.visible = false), o5.set(e2.id, e2);
  }
  const s5 = [];
  for (const a6 of e) {
    const e2 = null != a6.id ? o5.get(a6.id) : null;
    if (e2) if (null != a6.parentLayerId && a6.parentLayerId >= 0) {
      const t5 = o5.get(a6.parentLayerId);
      if (!t5) continue;
      t5.sublayers || (t5.sublayers = new O()), t5.sublayers.push(e2);
    } else s5.push(e2);
  }
  return s5;
}
__decorate([m({ readOnly: true })], Y.prototype, "allSublayers", void 0), __decorate([m({ json: { type: Object, write: true } })], Y.prototype, "customParameters", void 0), __decorate([m({ json: { type: Object, write: true } })], Y.prototype, "customLayerParameters", void 0), __decorate([m({ type: String, json: { write: true } })], Y.prototype, "copyright", void 0), __decorate([m()], Y.prototype, "description", void 0), __decorate([m({ readOnly: true })], Y.prototype, "dimensions", void 0), __decorate([m({ json: { type: [[Number]], read: { source: "extent" }, write: { target: "extent" }, origins: { "web-document": { write: { ignoreOrigin: true } }, "portal-item": { write: { ignoreOrigin: true } } } } })], Y.prototype, "fullExtent", void 0), __decorate([o2(["web-document", "portal-item"], "fullExtent", ["extent"])], Y.prototype, "readFullExtentFromItemOrMap", null), __decorate([r(["web-document", "portal-item"], "fullExtent", { extent: { type: [[Number]] } })], Y.prototype, "writeFullExtent", null), __decorate([m({ type: [z] })], Y.prototype, "fullExtents", void 0), __decorate([m({ type: String, json: { write: { ignoreOrigin: true } } })], Y.prototype, "featureInfoFormat", null), __decorate([m({ type: [String], readOnly: true })], Y.prototype, "featureInfoFormats", void 0), __decorate([m({ type: String, json: { write: { ignoreOrigin: true } } })], Y.prototype, "featureInfoUrl", void 0), __decorate([m()], Y.prototype, "fetchFeatureInfoFunction", void 0), __decorate([m({ type: String, json: { origins: { "web-document": { default: "image/png", type: Q.jsonValues, read: { reader: Q.read, source: "format" }, write: { writer: Q.write, target: "format" } } } } })], Y.prototype, "imageFormat", void 0), __decorate([o2("imageFormat", ["supportedImageFormatTypes"])], Y.prototype, "readImageFormat", null), __decorate([m({ type: Number, json: { read: { source: "maxHeight" }, write: { target: "maxHeight" } } })], Y.prototype, "imageMaxHeight", void 0), __decorate([m({ type: Number, json: { read: { source: "maxWidth" }, write: { target: "maxWidth" } } })], Y.prototype, "imageMaxWidth", void 0), __decorate([m()], Y.prototype, "imageTransparency", void 0), __decorate([m(d)], Y.prototype, "legendEnabled", void 0), __decorate([m({ type: ["show", "hide", "hide-children"] })], Y.prototype, "listMode", void 0), __decorate([m({ type: String, json: { write: { ignoreOrigin: true } } })], Y.prototype, "mapUrl", void 0), __decorate([m({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], Y.prototype, "isReference", void 0), __decorate([m({ type: ["WMS"] })], Y.prototype, "operationalLayerType", void 0), __decorate([m()], Y.prototype, "resourceInfo", void 0), __decorate([m({ type: f2, json: { origins: { service: { read: { source: "extent.spatialReference" } } }, write: false } })], Y.prototype, "spatialReference", void 0), __decorate([o2(["web-document", "portal-item"], "spatialReference", ["spatialReferences"])], Y.prototype, "readSpatialReferenceFromItemOrDocument", null), __decorate([m({ type: [x], json: { read: false, origins: { service: { read: true }, "web-document": { read: false, write: { ignoreOrigin: true } }, "portal-item": { read: false, write: { ignoreOrigin: true } } } } })], Y.prototype, "spatialReferences", void 0), __decorate([r(["web-document", "portal-item"], "spatialReferences")], Y.prototype, "writeSpatialReferences", null), __decorate([m({ type: O.ofType(m3), json: { write: { target: "layers", overridePolicy(e, t4, r2) {
  if (Z(this.allSublayers, r2)) return { ignoreOrigin: true };
} } } })], Y.prototype, "sublayers", void 0), __decorate([o2(["web-document", "portal-item"], "sublayers", ["layers", "visibleLayers"])], Y.prototype, "readSublayersFromItemOrMap", null), __decorate([o2("service", "sublayers", ["layers"])], Y.prototype, "readSublayers", null), __decorate([r("sublayers", { layers: { type: [m3] }, visibleLayers: { type: [String] } })], Y.prototype, "writeSublayers", null), __decorate([m({ json: { read: false }, readOnly: true, value: "wms" })], Y.prototype, "type", void 0), __decorate([m(y)], Y.prototype, "url", null), __decorate([m({ type: String, json: { write: { ignoreOrigin: true } } })], Y.prototype, "version", void 0), Y = __decorate([a2("esri.layers.WMSLayer")], Y);
var te = Y;
export {
  te as default
};
//# sourceMappingURL=WMSLayer-7EI4FX4O.js.map
