import {
  o
} from "./chunk-SXZO7ULH.js";
import {
  at
} from "./chunk-JE2NJSBU.js";
import {
  i as i2,
  r
} from "./chunk-SMWUT52Z.js";
import {
  i3 as i
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/symbols/cim/constants.js
var e = 15.5;
var i3 = 4;
var o2 = 64;
var r2 = 1024;
var l = { outlineWidth: 0.75, referenceWidth: 0.75, cap: o.CIMSolidStroke.capstyle, join: o.CIMSolidStroke.joinstyle, miterLimit: o.CIMSolidStroke.miterlimit };

// node_modules/@arcgis/core/core/floatRGBA.js
function o3(o4, n, r4 = 0) {
  const f3 = r(o4, 0, l2);
  for (let t = 0; t < 4; t++) n[r4 + t] = Math.floor(256 * i4(f3 * e2[t]));
}
function r3(t, o4 = 0) {
  let n = 0;
  for (let r4 = 0; r4 < 4; r4++) n += t[o4 + r4] * f[r4];
  return n;
}
var e2 = [1, 256, 65536, 16777216];
var f = [1 / 256, 1 / 65536, 1 / 16777216, 1 / 4294967296];
var l2 = r3(new Uint8ClampedArray([255, 255, 255, 255]));
var a = r3(new Uint8ClampedArray([255, 255, 255, 0]));
function i4(t) {
  return t - Math.floor(t);
}

// node_modules/@arcgis/core/symbols/cim/rasterizingUtils.js
var l3 = () => i.getLogger("esri.symbols.cim.rasterizingUtils");
var c = 32;
var h = (o4) => "vertical" === o4 || "horizontal" === o4 || "cross" === o4 || "esriSFSCross" === o4 || "esriSFSVertical" === o4 || "esriSFSHorizontal" === o4;
function f2(o4, t, r4) {
  const n = t.style, a2 = i2(Math.ceil(r4)), s = h(n) ? 8 * a2 : 16 * a2, i5 = 2 * a2;
  o4.width = s, o4.height = s;
  const l4 = o4.getContext("2d");
  l4.strokeStyle = "#ffffff", l4.lineWidth = a2, l4.beginPath(), "vertical" !== n && "cross" !== n && "esriSFSCross" !== n && "esriSFSVertical" !== n || (l4.moveTo(s / 2, -i5), l4.lineTo(s / 2, s + i5)), "horizontal" !== n && "cross" !== n && "esriSFSCross" !== n && "esriSFSHorizontal" !== n || (l4.moveTo(-i5, s / 2), l4.lineTo(s + i5, s / 2)), "backward-diagonal" !== n && "diagonal-cross" !== n && "esriSFSDiagonalCross" !== n && "esriSFSBackwardDiagonal" !== n || (l4.moveTo(-i5, -i5), l4.lineTo(s + i5, s + i5), l4.moveTo(s - i5, -i5), l4.lineTo(s + i5, i5), l4.moveTo(-i5, s - i5), l4.lineTo(i5, s + i5)), "forward-diagonal" !== n && "diagonal-cross" !== n && "esriSFSForwardDiagonal" !== n && "esriSFSDiagonalCross" !== n || (l4.moveTo(s + i5, -i5), l4.lineTo(-i5, s + i5), l4.moveTo(i5, -i5), l4.lineTo(-i5, i5), l4.moveTo(s + i5, s - i5), l4.lineTo(s - i5, s + i5)), l4.stroke();
  const c2 = l4.getImageData(0, 0, o4.width, o4.height), f3 = new Uint8Array(c2.data);
  let m2;
  for (let e3 = 0; e3 < f3.length; e3 += 4) m2 = f3[e3 + 3] / 255, f3[e3] = f3[e3] * m2, f3[e3 + 1] = f3[e3 + 1] * m2, f3[e3 + 2] = f3[e3 + 2] * m2;
  return [f3, o4.width, o4.height, a2];
}
function m(t) {
  t.length % 2 == 1 && (t = [...t, ...t]);
  const e3 = t.reduce((o4, t2) => o4 + t2, 0), a2 = Math.round(e3 * i3), s = 1, i5 = new Float32Array(a2 * s);
  let l4 = 0, c2 = 0, h2 = 0.5, f3 = true;
  for (const o4 of t) {
    for (l4 = c2, c2 += o4 * i3; h2 <= c2; ) {
      const o5 = h2 - 0.5, t2 = Math.min(Math.abs(h2 - l4), Math.abs(h2 - c2));
      i5[o5] = f3 ? -t2 : t2, h2++;
    }
    f3 = !f3;
  }
  const m2 = i5.length, u2 = new Uint8Array(4 * m2);
  for (let g2 = 0; g2 < m2; ++g2) {
    const t2 = i5[g2] / i3;
    o3(t2 / o2 * 0.5 + 0.5, u2, 4 * g2);
  }
  return [u2, a2, s];
}
function u(t, e3) {
  null == t && (t = []);
  const r4 = "Butt" === e3, n = "Square" === e3, s = !r4 && !n;
  t.length % 2 == 1 && (t = [...t, ...t]);
  const i5 = e, l4 = 2 * i5;
  let c2 = 0;
  for (const o4 of t) c2 += o4;
  const h2 = Math.round(c2 * i5), f3 = new Float32Array(h2 * l4), m2 = 0.5 * i5;
  let u2 = 0, g2 = 0, d2 = 0.5, p2 = true;
  for (const o4 of t) {
    for (u2 = g2, g2 += o4 * i5; d2 <= g2; ) {
      let o5 = 0.5;
      for (; o5 < l4; ) {
        const t2 = (o5 - 0.5) * h2 + d2 - 0.5, e4 = s ? (o5 - i5) * (o5 - i5) : Math.abs(o5 - i5);
        f3[t2] = p2 ? r4 ? Math.max(Math.max(u2 + m2 - d2, e4), Math.max(d2 - g2 + m2, e4)) : e4 : s ? Math.min((d2 - u2) * (d2 - u2) + e4, (d2 - g2) * (d2 - g2) + e4) : n ? Math.min(Math.max(d2 - u2, e4), Math.max(g2 - d2, e4)) : Math.min(Math.max(d2 - u2 + m2, e4), Math.max(g2 + m2 - d2, e4)), o5++;
      }
      d2++;
    }
    p2 = !p2;
  }
  const C2 = f3.length, M2 = new Uint8Array(4 * C2);
  for (let a2 = 0; a2 < C2; ++a2) {
    const t2 = (s ? Math.sqrt(f3[a2]) : f3[a2]) / i5;
    o3(t2, M2, 4 * a2);
  }
  return [M2, h2, l4];
}
function g(o4, t) {
  const { colorRamp: e3, gradientType: r4 } = t, n = "CIMFixedColorRamp" === e3.type, a2 = t.interval || o.CIMGradientFill.interval;
  let i5 = C(e3);
  return n && (i5 = M(i5, a2)), "Discrete" === r4 || n ? w(o4, i5, a2) : x(o4, i5);
}
var d;
function p(o4, t) {
  const { colorRamp: e3, gradientType: r4 } = t, n = C(e3), a2 = "CIMFixedColorRamp" === e3.type;
  if ("Continuous" === r4 && !a2) return y(o4, n);
  const i5 = t.interval ?? o.CIMGradientFill.interval;
  if (a2) {
    return y(o4, M(n, i5));
  }
  const l4 = [];
  d ??= document.createElement("canvas"), S(d, n, i5, 1, 0);
  const c2 = d.getContext("2d").getImageData(0, 0, i5, 1).data;
  for (let s = 0, h2 = 0; s < i5; s++, h2 = 4 * s) {
    const o5 = [c2[h2 + 0], c2[h2 + 1], c2[h2 + 2], c2[h2 + 3]];
    l4.push({ offset: s / i5, color: o5 }), l4.push({ offset: (s + 1) / i5, color: o5 });
  }
  return y(o4, l4);
}
function C(o4) {
  const t = [];
  switch (o4.type) {
    case "CIMPolarContinuousColorRamp":
    case "CIMLinearContinuousColorRamp": {
      "CIMPolarContinuousColorRamp" === o4.type && l3().warnOnce("CIMPolarContinuousColorRamp is currently unsupported. Falling back to CIMLinearContinuousColorRamp.");
      const e3 = o4;
      t.push({ offset: 0, color: [e3.fromColor[0], e3.fromColor[1], e3.fromColor[2], e3.fromColor[3] / 255] }), t.push({ offset: 1, color: [e3.toColor[0], e3.toColor[1], e3.toColor[2], e3.toColor[3] / 255] });
      break;
    }
    case "CIMFixedColorRamp": {
      const e3 = o4, r4 = 1 / (e3.colors.length - 1);
      let n = 0;
      for (const o5 of e3.colors) t.push({ offset: n, color: [o5[0], o5[1], o5[2], o5[3] / 255] }), n += r4;
      break;
    }
    case "CIMMultipartColorRamp": {
      const e3 = o4, r4 = e3.weights.reduce((o5, t2) => o5 + t2, 0);
      let n = 0;
      for (let o5 = 0; o5 < e3.colorRamps.length; o5++) {
        const a2 = e3.colorRamps[o5], s = e3.weights[o5], i5 = C(a2);
        for (const o6 of i5) t.push({ offset: (n + o6.offset * s) / r4, color: o6.color });
        n += s;
      }
      break;
    }
    default:
      l3().error(`Color ramp "${o4.type}" currently unsupported.`);
  }
  return t;
}
function M(o4, t) {
  const e3 = [], r4 = (o4.length - 1) / (t - 1);
  for (let n = 0; n < t; n++) {
    const a2 = o4[Math.round(n * r4)].color;
    e3.push({ offset: n / t, color: a2 }), e3.push({ offset: (n + 1) / t, color: a2 });
  }
  return e3;
}
function x(o4, t) {
  return S(o4, t, c, 1, at), F(o4);
}
function w(o4, t, e3) {
  return S(o4, t, e3, 1, at), F(o4);
}
function y(o4, t, e3 = 0) {
  for (const { offset: r4, color: n } of t) o4.addColorStop(Math.min(Math.max(r4, e3), 1 - e3), `rgba(${n[0]}, ${n[1]}, ${n[2]}, ${n[3]})`);
}
function S(o4, t, e3, r4, n) {
  const a2 = e3 + 2 * n;
  o4.width = a2, o4.height = r4;
  const s = (n + 1) / a2, i5 = o4.getContext("2d", { willReadFrequently: true });
  if (t.length > 0) {
    const o5 = i5.createLinearGradient(0, 0, a2, r4);
    y(o5, t, s), i5.fillStyle = o5;
  } else i5.fillStyle = "rgba(128, 128, 128, 1)";
  i5.fillRect(0, 0, a2, r4);
}
function F(o4) {
  const { width: t, height: e3 } = o4, r4 = o4.getContext("2d").getImageData(0, 0, t, e3), n = new Uint8Array(r4.data);
  for (let a2 = 0; a2 < n.length; a2 += 4) {
    const o5 = n[a2 + 3] / 255;
    n[a2] *= o5, n[a2 + 1] *= o5, n[a2 + 2] *= o5;
  }
  return [n, t, e3];
}
function v(o4) {
  const t = o4[0]?.[0]?.[0] ?? 0, e3 = o4[0]?.[0]?.[1] ?? 0, r4 = { ymin: e3, xmin: t, ymax: e3, xmax: t, width: 0, height: 0 };
  for (let n = 0; n < o4.length; n++) {
    const t2 = o4[n];
    for (let o5 = 0; o5 < t2.length; o5++) {
      const e4 = t2[o5][0], n2 = t2[o5][1];
      e4 < r4.xmin && (r4.xmin = e4), e4 > r4.xmax && (r4.xmax = e4), n2 < r4.ymin && (r4.ymin = n2), n2 > r4.ymax && (r4.ymax = n2);
    }
  }
  return r4.width = Math.abs(r4.xmax - r4.xmin), r4.height = Math.abs(r4.ymax - r4.ymin), r4;
}
function T(o4, t) {
  const e3 = v(o4), r4 = 0 === e3.width ? 1 : e3.width, n = 0 === e3.height ? 1 : e3.height, a2 = [];
  for (let s = 0; s < o4.length; s++) {
    const i5 = o4[s], l4 = [];
    for (let o5 = 0; o5 < i5.length; o5++) {
      let a3 = Math.round(i5[o5][0] - e3.xmin), s2 = Math.round(i5[o5][1] - e3.ymin);
      if (a3 = t.xmin + a3 * t.width / r4, s2 = t.ymin + s2 * t.height / n, isNaN(a3) || isNaN(s2)) throw new Error("Scaled shape has NaN values");
      l4.push([a3, s2]);
    }
    a2.push(l4);
  }
  return a2;
}
function R(o4, t, e3) {
  const r4 = [];
  for (let n = 0; n < o4.length; n++) {
    const a2 = o4[n], s = [];
    for (let o5 = 0; o5 < a2.length; o5++) {
      const r5 = a2[o5][0] + t, n2 = a2[o5][1] + e3;
      if (isNaN(r5) || isNaN(n2)) throw new Error("Scaled shape has NaN values");
      s.push([r5, n2]);
    }
    r4.push(s);
  }
  return r4;
}

export {
  i3 as i,
  o2 as o,
  r2 as r,
  l,
  o3 as o2,
  f2 as f,
  m,
  u,
  g,
  p,
  T,
  R
};
//# sourceMappingURL=chunk-F7RQDGE7.js.map
