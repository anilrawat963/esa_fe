import {
  p as p2
} from "./chunk-43XFWIA5.js";
import "./chunk-EEFFS5EK.js";
import {
  j as j4
} from "./chunk-PGB6KL3Q.js";
import {
  l as l4
} from "./chunk-PG6JVA4Q.js";
import "./chunk-XMUWUWWP.js";
import {
  o as o3
} from "./chunk-SL3GC7WV.js";
import {
  l as l3
} from "./chunk-CJZPTLIZ.js";
import {
  s as s4
} from "./chunk-ZETARPSI.js";
import {
  f as f3
} from "./chunk-TCDV4P3G.js";
import {
  b2 as b,
  y
} from "./chunk-CZOYDK6P.js";
import {
  j as j3
} from "./chunk-6TCXGIIN.js";
import {
  l
} from "./chunk-NP2TBOXH.js";
import "./chunk-SMJWJAIA.js";
import "./chunk-XTEXJOLG.js";
import {
  e as e3
} from "./chunk-HROH5C5D.js";
import "./chunk-H34D76ZQ.js";
import "./chunk-ALR6N4CF.js";
import "./chunk-4X4BOGIG.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import "./chunk-EKZRA6TO.js";
import "./chunk-M5SP6ZBM.js";
import "./chunk-SJ2OBYX2.js";
import {
  t as t2
} from "./chunk-LQPKVYW2.js";
import "./chunk-SHPBZTDJ.js";
import {
  e as e2
} from "./chunk-JUZ3H47H.js";
import "./chunk-JE2NJSBU.js";
import "./chunk-QNVJVDYZ.js";
import {
  l as l2,
  z as z2
} from "./chunk-YP3WVJP3.js";
import "./chunk-M24KZOVI.js";
import {
  p
} from "./chunk-PEL3D3ZN.js";
import "./chunk-Q5KWD3VQ.js";
import "./chunk-BUQC3CLV.js";
import {
  t
} from "./chunk-W5S3VUFT.js";
import "./chunk-7YH7T6CS.js";
import "./chunk-3T4IXPP4.js";
import "./chunk-XTZAIV4X.js";
import "./chunk-63LDVRFI.js";
import "./chunk-MC6NAKKX.js";
import "./chunk-TF6255HN.js";
import "./chunk-C5OQVQZF.js";
import "./chunk-CNYNCKEV.js";
import {
  d as d2
} from "./chunk-XL5QPCXN.js";
import "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-W75DBJD7.js";
import {
  b as b2
} from "./chunk-P6IKJIMO.js";
import "./chunk-MHV23XAQ.js";
import "./chunk-V2X4OKYI.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import "./chunk-W6J7XCPU.js";
import "./chunk-ONXWBTTM.js";
import "./chunk-T7F6Q6JJ.js";
import "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-7P2ANHQ3.js";
import "./chunk-XCKT47LJ.js";
import "./chunk-3FUHCAX3.js";
import "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import {
  z
} from "./chunk-H74Q4SYB.js";
import "./chunk-2OFHDVO5.js";
import "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-5UPBUJPC.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-CCQFL76O.js";
import "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import "./chunk-SMWUT52Z.js";
import {
  _,
  j as j2
} from "./chunk-AXZMNHTN.js";
import {
  f as f2
} from "./chunk-5T3MJDSR.js";
import {
  N,
  h
} from "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import {
  A,
  Bt,
  H2 as H,
  I,
  K,
  Rt,
  V,
  Y,
  ht,
  j,
  jt,
  s as s3,
  x2 as x
} from "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import {
  o as o2
} from "./chunk-XWE6BM2U.js";
import {
  r
} from "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import {
  e
} from "./chunk-4DGC7CBY.js";
import {
  a as a3,
  d,
  f2 as f,
  s as s2,
  u2 as u,
  w
} from "./chunk-GNMPGHLQ.js";
import {
  a,
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  n2 as n,
  o2 as o
} from "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/layers/support/imageUtils.js
var A2 = null;
function o4(o6) {
  if (A2) return A2;
  const l8 = { lossy: "UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", lossless: "UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==", alpha: "UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==", animation: "UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA" };
  return A2 = new Promise((A4) => {
    const n3 = new Image();
    n3.onload = () => {
      n3.onload = n3.onerror = null, A4(n3.width > 0 && n3.height > 0);
    }, n3.onerror = () => {
      n3.onload = n3.onerror = null, A4(false);
    }, n3.src = "data:image/webp;base64," + l8[o6];
  }), A2;
}

// node_modules/@arcgis/core/layers/support/SpriteSource.js
var h2 = 1.15;
var n2 = class {
  constructor(t3, e4) {
    this._spriteSource = t3, this._maxTextureSize = e4, this.devicePixelRatio = 1, this._spriteImageFormat = "png", this._isRetina = false, this._spritesData = {}, this.image = null, this.width = null, this.height = null, this.loadStatus = "not-loaded", "url" === t3.type && t3.spriteFormat && (this._spriteImageFormat = t3.spriteFormat), t3.pixelRatio && (this.devicePixelRatio = t3.pixelRatio), this.baseURL = t3.spriteUrl;
  }
  get spriteNames() {
    const t3 = [];
    for (const e4 in this._spritesData) t3.push(e4);
    return t3.sort(), t3;
  }
  getSpriteInfo(t3) {
    return this._spritesData ? this._spritesData[t3] : null;
  }
  async load(t3) {
    if (this.baseURL) {
      this.loadStatus = "loading";
      try {
        await this._loadSprites(t3), this.loadStatus = "loaded";
      } catch {
        this.loadStatus = "failed";
      }
    } else this.loadStatus = "failed";
  }
  async _loadSprites(t3) {
    this._isRetina = this.devicePixelRatio > h2;
    const { width: s6, height: r3, data: a5, json: o6 } = await this._getSpriteData(this._spriteSource, t3), n3 = Object.keys(o6);
    if (!n3 || 0 === n3.length || !a5) return this._spritesData = this.image = null, void (this.width = this.height = 0);
    this._spritesData = o6, this.width = s6, this.height = r3;
    const d5 = Math.max(this._maxTextureSize, 4096);
    if (s6 > d5 || r3 > d5) {
      const t4 = `Sprite resource for style ${this.baseURL} is bigger than the maximum allowed of ${d5} pixels}`;
      throw i.getLogger("esri.layers.support.SpriteSource").error(t4), new s("SpriteSource", t4);
    }
    let p4;
    for (let e4 = 0; e4 < a5.length; e4 += 4) p4 = a5[e4 + 3] / 255, a5[e4] = a5[e4] * p4, a5[e4 + 1] = a5[e4 + 1] * p4, a5[e4 + 2] = a5[e4 + 2] * p4;
    this.image = a5;
  }
  async _getSpriteData(i2, n3) {
    if ("image" === i2.type) {
      let t3, a5;
      if (this.devicePixelRatio < h2) {
        if (!i2.spriteSource1x) throw new s("SpriteSource", "no image data provided for low resolution sprites!");
        t3 = i2.spriteSource1x.image, a5 = i2.spriteSource1x.json;
      } else {
        if (!i2.spriteSource2x) throw new s("SpriteSource", "no image data provided for high resolution sprites!");
        t3 = i2.spriteSource2x.image, a5 = i2.spriteSource2x.json;
      }
      return "width" in t3 && "height" in t3 && "data" in t3 && (n(t3.data) || o(t3.data)) ? { width: t3.width, height: t3.height, data: new Uint8Array(t3.data), json: a5 } : { ...d3(t3), json: a5 };
    }
    const p4 = I(this.baseURL), l8 = p4.query ? "?" + A(p4.query) : "", g2 = this._isRetina ? "@2x" : "", u2 = `${p4.path}${g2}.${this._spriteImageFormat}${l8}`, c2 = `${p4.path}${g2}.json${l8}`, [m3, S2] = await Promise.all([H(c2, n3), H(u2, { responseType: "image", ...n3 })]);
    return { ...d3(S2.data), json: m3.data };
  }
};
function d3(t3) {
  const e4 = document.createElement("canvas"), i2 = e4.getContext("2d");
  e4.width = t3.width, e4.height = t3.height, i2.drawImage(t3, 0, 0, t3.width, t3.height);
  const s6 = i2.getImageData(0, 0, t3.width, t3.height);
  return { width: t3.width, height: t3.height, data: new Uint8Array(s6.data) };
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TilemapIndex.js
var l5 = class {
  constructor(e4) {
    this.url = e4;
  }
  destroy() {
    this._tileIndexPromise = null;
  }
  async fetchTileIndex() {
    return this._tileIndexPromise || (this._tileIndexPromise = H(this.url).then((e4) => e4.data.index)), this._tileIndexPromise;
  }
  async dataKey(e4, r3) {
    const l8 = await this.fetchTileIndex();
    return s2(r3), this._getIndexedDataKey(l8, e4);
  }
  _getIndexedDataKey(e4, t3) {
    const l8 = [t3];
    if (t3.level < 0 || t3.row < 0 || t3.col < 0 || t3.row >> t3.level > 0 || t3.col >> t3.level > 0) return null;
    let i2 = t3;
    for (; 0 !== i2.level; ) i2 = new e2(i2.level - 1, i2.row >> 1, i2.col >> 1, i2.world), l8.push(i2);
    let o6, s6, n3 = e4, a5 = l8.pop();
    if (1 === n3) return a5;
    for (; l8.length; ) if (o6 = l8.pop(), s6 = (1 & o6.col) + ((1 & o6.row) << 1), n3) {
      if (0 === n3[s6]) {
        a5 = null;
        break;
      }
      if (1 === n3[s6]) {
        a5 = o6;
        break;
      }
      a5 = o6, n3 = n3[s6];
    }
    return a5;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TilemapRequest.js
var l6 = class {
  constructor(e4, t3) {
    this._tilemap = e4, this._tileIndexUrl = t3;
  }
  destroy() {
    this._tilemap = u(this._tilemap), this._tileIndexPromise = null;
  }
  async fetchTileIndex(t3) {
    return this._tileIndexPromise || (this._tileIndexPromise = H(this._tileIndexUrl, { query: { ...t3?.query } }).then((e4) => e4.data.index)), this._tileIndexPromise;
  }
  dataKey(e4, t3) {
    const { level: l8, row: s6, col: o6 } = e4, n3 = new e2(e4);
    return this._tilemap.fetchAvailabilityUpsample(l8, s6, o6, n3, t3).then(() => (n3.world = e4.world, n3)).catch((e5) => {
      if (d(e5)) throw e5;
      return null;
    });
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/style/VectorTilesRequestManager.js
var l7 = class {
  constructor(t3) {
    this._tileUrl = t3, this._promise = null, this._abortController = null, this._abortOptions = [];
  }
  getData(t3) {
    (null == this._promise || a3(this._abortController?.signal)) && (this._promise = this._makeRequest(this._tileUrl));
    const o6 = this._abortOptions;
    return o6.push(t3), w(t3, () => {
      o6.every((t4) => a3(t4)) && this._abortController.abort();
    }), this._promise.then((t4) => a(t4));
  }
  async _makeRequest(r3) {
    this._abortController = new AbortController();
    const { data: o6 } = await H(r3, { responseType: "array-buffer", signal: this._abortController.signal });
    return o6;
  }
};
var a4 = /* @__PURE__ */ new Map();
function c(t3, r3, o6, e4, s6) {
  const l8 = I(t3), a5 = l8.query;
  if (a5) for (const [i2, n3] of Object.entries(a5)) switch (n3) {
    case "{x}":
      a5[i2] = e4.toString();
      break;
    case "{y}":
      a5[i2] = o6.toString();
      break;
    case "{z}":
      a5[i2] = r3.toString();
  }
  const c2 = l8.path;
  return p3(Bt(c2.replaceAll(/\{z\}/gi, r3.toString()).replaceAll(/\{y\}/gi, o6.toString()).replaceAll(/\{x\}/gi, e4.toString()), { ...l8.query }), s6);
}
function p3(t3, r3) {
  return e(a4, t3, () => new l7(t3)).getData(r3).finally(() => a4.delete(t3));
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/style/VectorTileSource.js
var m2 = class {
  constructor(h4, m3, u2) {
    this.tilemap = null, this.tileInfo = null, this.capabilities = null, this.fullExtent = null, this.initialExtent = null, this.name = h4, this.sourceUrl = m3;
    const f4 = I(this.sourceUrl), c2 = a(u2), x3 = c2.tiles;
    if (f4) for (let t3 = 0; t3 < x3.length; t3++) {
      const r3 = I(x3[t3]);
      r3 && (Y(r3.path) || (r3.path = V(f4.path, r3.path)), x3[t3] = Bt(r3.path, { ...f4.query, ...r3.query }));
    }
    this.tileServers = x3;
    const d5 = u2.capabilities && u2.capabilities.split(",").map((t3) => t3.toLowerCase().trim()), y2 = true === u2?.exportTilesAllowed, T2 = true === d5?.includes("tilemap"), I2 = y2 && u2.hasOwnProperty("maxExportTilesCount") ? u2.maxExportTilesCount : 0;
    this.capabilities = { operations: { supportsExportTiles: y2, supportsTileMap: T2 }, exportTiles: y2 ? { maxExportTilesCount: +I2 } : null }, this.tileInfo = z2.fromJSON(c2.tileInfo);
    const g2 = u2.tileMap ? Bt(V(f4.path, u2.tileMap), f4.query ?? {}) : null;
    T2 ? (this.type = "vector-tile", this.tilemap = new l6(new j4({ layer: { parsedUrl: f4, tileInfo: this.tileInfo }, minLOD: c2.minLOD ?? this.tileInfo.lods[0].level, maxLOD: c2.maxLOD ?? this.tileInfo.lods[this.tileInfo.lods.length - 1].level }), g2)) : g2 && (this.tilemap = new l5(g2)), this.fullExtent = z.fromJSON(u2.fullExtent), this.initialExtent = z.fromJSON(u2.initialExtent);
  }
  destroy() {
    this.tilemap?.destroy();
  }
  async getRefKey(t3, e4) {
    return this.tilemap ? this.tilemap.dataKey(t3, e4) : t3;
  }
  requestTile(t3, e4, i2, l8) {
    const s6 = this.tileServers[e4 % this.tileServers.length];
    return c(s6, t3, e4, i2, l8);
  }
  isCompatibleWith(t3) {
    const e4 = this.tileInfo, i2 = t3.tileInfo;
    if (!e4.spatialReference.equals(i2.spatialReference)) return false;
    if (!e4.origin.equals(i2.origin)) return false;
    if (Math.round(e4.dpi) !== Math.round(i2.dpi)) return false;
    const l8 = e4.lods, s6 = i2.lods, r3 = Math.min(l8.length, s6.length);
    for (let o6 = 0; o6 < r3; o6++) {
      const t4 = l8[o6], e5 = s6[o6];
      if (t4.level !== e5.level || Math.round(t4.scale) !== Math.round(e5.scale)) return false;
    }
    return true;
  }
};

// node_modules/@arcgis/core/layers/support/vectorTileLayerLoader.js
async function d4(e4, t3) {
  const o6 = { source: null, sourceBase: null, sourceUrl: null, validatedSource: null, style: null, styleBase: null, styleUrl: null, sourceNameToSource: {}, primarySourceName: "", spriteFormat: "png" }, [l8, r3] = "string" == typeof e4 ? [e4, null] : [null, e4.jsonUrl];
  await S(o6, "esri", e4, r3, t3);
  return { layerDefinition: o6.validatedSource, url: l8, serviceUrl: o6.sourceUrl, style: o6.style, styleUrl: o6.styleUrl, spriteUrl: o6.style && o6.style.sprite && h3(o6.styleBase, o6.style.sprite), spriteFormat: o6.spriteFormat, glyphsUrl: o6.style && o6.style.glyphs && h3(o6.styleBase, o6.style.glyphs), sourceNameToSource: o6.sourceNameToSource, primarySourceName: o6.primarySourceName };
}
function h3(...e4) {
  let t3;
  for (const o6 of e4) if (null != o6) if (ht(o6)) {
    if (t3) {
      const e5 = t3.split("://")[0];
      t3 = e5 + ":" + o6.trim();
    }
  } else t3 = Y(o6) ? o6 : V(t3, o6);
  return t3 ? jt(t3) : void 0;
}
async function S(t3, r3, s6, n3, i2) {
  let u2, c2, a5;
  if (s2(i2), "string" == typeof s6) {
    const t4 = K(s6);
    a5 = await H(t4, { ...i2, responseType: "json", query: { f: "json", ...i2?.query } }), a5.ssl && (u2 && (u2 = u2.replace(/^http:/i, "https:")), c2 && (c2 = c2.replace(/^http:/i, "https:"))), u2 = t4, c2 = t4;
  } else null != s6 && (a5 = { data: s6 }, u2 = s6.jsonUrl || null, c2 = n3);
  const f4 = a5?.data;
  if (g(f4)) return t3.styleUrl = u2 || null, j5(t3, f4, c2, i2);
  if (w2(f4)) return t3.sourceUrl ? U(t3, f4, c2, false, r3, i2) : (t3.sourceUrl = u2 || null, x2(f4) && null == t3.style && (r3 = "tilejson"), U(t3, f4, c2, true, r3, i2));
  throw new Error("You must specify the URL or the JSON for a service or for a style.");
}
function x2(e4) {
  return "object" == typeof e4 && !!e4 && "tilejson" in e4 && null != e4.tilejson;
}
function g(e4) {
  return !!e4 && "sources" in e4 && !!e4.sources;
}
function w2(e4) {
  return !g(e4);
}
async function j5(e4, t3, o6, l8) {
  const n3 = o6 ? Rt(o6) : j();
  e4.styleBase = n3, e4.style = t3, t3["sprite-format"] && "webp" === t3["sprite-format"].toLowerCase() && (e4.spriteFormat = "webp");
  const i2 = [];
  if (t3.sources && t3.sources.esri) {
    const o7 = t3.sources.esri;
    o7.url ? await S(e4, "esri", h3(n3, o7.url), void 0, l8) : i2.push(S(e4, "esri", o7, n3, l8));
  }
  for (const r3 of Object.keys(t3.sources)) "esri" !== r3 && "tilejson" !== r3 && "vector" === t3.sources[r3].type && (t3.sources[r3].url ? i2.push(S(e4, r3, h3(n3, t3.sources[r3].url), void 0, l8)) : t3.sources[r3].tiles && i2.push(S(e4, r3, t3.sources[r3], n3, l8)));
  await Promise.all(i2);
}
async function U(e4, t3, o6, l8, r3, u2) {
  const c2 = o6 ? jt(o6) + "/" : j(), a5 = v(t3, e4), f4 = new m2(r3, Bt(c2, u2?.query ?? {}), a5);
  if (!l8 && e4.primarySourceName in e4.sourceNameToSource) {
    const t4 = e4.sourceNameToSource[e4.primarySourceName];
    if (!t4.isCompatibleWith(f4)) return;
    null != f4.fullExtent && (null != t4.fullExtent ? t4.fullExtent.union(f4.fullExtent) : t4.fullExtent = f4.fullExtent.clone()), t4.tileInfo && f4.tileInfo && t4.tileInfo.lods.length < f4.tileInfo.lods.length && (t4.tileInfo = f4.tileInfo);
  }
  if (l8 && (e4.sourceBase = c2, e4.source = t3, e4.validatedSource = a5, e4.primarySourceName = r3), e4.sourceNameToSource[r3] = f4, !x2(e4) && "defaultStyles" in t3 && !e4.style) {
    if (null == t3.defaultStyles) throw new Error();
    return "string" == typeof t3.defaultStyles ? S(e4, "", h3(c2, t3.defaultStyles, "root.json"), void 0, u2) : S(e4, "", t3.defaultStyles, h3(c2, "root.json"), u2);
  }
  if (x2(t3) && null == e4.style && a5.defaultStyles) return S(e4, "", a5.defaultStyles, h3(c2, "root.json"), u2);
}
function v(e4, o6) {
  const l8 = 512;
  if (N2(e4)) {
    const t3 = e4?.tileInfo;
    return null != t3 && (null == t3.rows && (t3.rows = l8), null == t3.cols && (t3.cols = l8)), e4;
  }
  const r3 = { xmin: -20037507067161843e-9, ymin: -20037507067161843e-9, xmax: 20037507067161843e-9, ymax: 20037507067161843e-9, spatialReference: { wkid: 102100, latestWkid: 3857 } };
  let s6, n3 = null;
  if (x2(e4)) {
    const { bounds: l9, vector_layers: r4 } = e4;
    if (l9) {
      const e5 = j2({ x: l9[0], y: l9[1], spatialReference: a(N) }), o7 = j2({ x: l9[2], y: l9[3], spatialReference: a(N) });
      n3 = { xmin: e5.x, ymin: e5.y, xmax: o7.x, ymax: o7.y, spatialReference: a(h) };
    }
    if (r4 && r4.length > 0) s6 = { version: 8, sprite: "", glyphs: "", sources: { tilejson: { type: "vector", url: e4.tilejson } }, layers: T(r4) };
    else if (null == o6.style) throw new Error("The TileJSON source does not contain any vector_layers. This VectorTileLayer cannot be loaded.");
  }
  null === n3 && (n3 = r3);
  let i2 = 78271.51696400007, u2 = 2958287637957775e-7;
  const c2 = [], a5 = e4.hasOwnProperty("maxzoom") && null != e4.maxzoom ? Math.abs(+e4.maxzoom) : 22, m3 = 0, d5 = 0;
  for (let t3 = 0; t3 <= a5; t3++) c2.push({ level: t3, scale: u2, resolution: i2 }), i2 /= 2, u2 /= 2;
  return { capabilities: "TilesOnly", initialExtent: n3, fullExtent: r3, minScale: m3, maxScale: d5, tiles: e4.tiles, tileInfo: { rows: l8, cols: l8, dpi: 96, format: "pbf", origin: { x: -20037508342787e-6, y: 20037508342787e-6 }, lods: c2, spatialReference: a(h) }, defaultStyles: s6 };
}
function N2(e4) {
  return e4.hasOwnProperty("tileInfo");
}
function T(e4) {
  const t3 = [];
  for (const o6 of e4) o6.geometry_type ? t3.push(b3(o6.geometry_type.toLowerCase(), o6, false)) : (t3.push(b3("polygon", o6, true)), t3.push(b3("line", o6, true)), t3.push(b3("circle", o6, true)));
  return t3;
}
function b3(e4, t3, o6) {
  const { id: l8, minzoom: r3, maxzoom: s6 } = t3, n3 = { type: "polygon" === e4 || "polygons" === e4 ? "fill" : "line" === e4 || "lines" === e4 ? "line" : "circle", id: l8, source: "tilejson", "source-layer": l8, minzoom: r3, maxzoom: s6 };
  switch (e4) {
    case "fill":
      o6 && (n3.id += "_polygon", n3.filter = '(["==", "$type", "Polygon"])'), n3.paint = { "fill-color": "#808080" };
      break;
    case "line":
      o6 && (n3.id += "_line", n3.filter = '(["==", "$type", "LineString"])');
      break;
    case "circle":
      o6 && (n3.id += "_point", n3.filter = '(["==", "$type", "Point"])');
  }
  return n3;
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/tileInfoUtils.js
var s5 = 1e-6;
function r2(l8, e4) {
  if (l8 === e4) return true;
  if (null == l8 && null != e4) return false;
  if (null != l8 && null == e4) return false;
  if (null == l8 || null == e4) return false;
  if (!l8.spatialReference.equals(e4.spatialReference) || l8.dpi !== e4.dpi) return false;
  const n3 = l8.origin, r3 = e4.origin;
  if (Math.abs(n3.x - r3.x) >= s5 || Math.abs(n3.y - r3.y) >= s5) return false;
  let o6, t3;
  l8.lods[0].scale > e4.lods[0].scale ? (o6 = l8, t3 = e4) : (t3 = l8, o6 = e4);
  for (let i2 = o6.lods[0].scale; i2 >= t3.lods[t3.lods.length - 1].scale - s5; i2 /= 2) if (Math.abs(i2 - t3.lods[0].scale) < s5) return true;
  return false;
}
function o5(s6, r3) {
  if (s6 === r3) return s6;
  if (null == s6 && null != r3) return r3;
  if (null != s6 && null == r3) return s6;
  if (null == s6 || null == r3) return null;
  const o6 = s6.size[0], t3 = s6.format, i2 = s6.dpi, u2 = new _({ x: s6.origin.x, y: s6.origin.y }), a5 = s6.spatialReference, f4 = s6.lods[0].scale > r3.lods[0].scale ? s6.lods[0] : r3.lods[0], d5 = s6.lods[s6.lods.length - 1].scale <= r3.lods[r3.lods.length - 1].scale ? s6.lods[s6.lods.length - 1] : r3.lods[r3.lods.length - 1], c2 = f4.scale, p4 = f4.resolution, g2 = d5.scale, h4 = [];
  let m3 = c2, y2 = p4, x3 = 0;
  for (; m3 >= g2; ) h4.push(new l2({ level: x3, resolution: y2, scale: m3 })), x3++, m3 /= 2, y2 /= 2;
  return new z2({ size: [o6, o6], dpi: i2, format: t3 || "pbf", origin: u2, lods: h4, spatialReference: a5 });
}

// node_modules/@arcgis/core/layers/VectorTileLayer.js
var B = class extends p(t(f3(p2(l3(b(j3(s4(o3(l(b2)))))))))) {
  constructor(...e4) {
    super(...e4), this._spriteSourceMap = /* @__PURE__ */ new Map(), this.currentStyleInfo = null, this.isReference = null, this.operationalLayerType = "VectorTileLayer", this.path = null, this.refreshInterval = 0, this.style = null, this.tilemapCache = null, this.type = "vector-tile";
  }
  normalizeCtorArgs(e4, t3) {
    return "string" == typeof e4 ? { url: e4, ...t3 } : e4;
  }
  destroy() {
    if (this.sourceNameToSource) for (const e4 of Object.values(this.sourceNameToSource)) e4?.destroy();
    this.primarySource?.destroy(), this._spriteSourceMap.clear();
  }
  async prefetchResources(e4) {
    await this.loadSpriteSource(globalThis.devicePixelRatio || 1, e4);
  }
  load(e4) {
    const r3 = this.loadFromPortal({ supportedTypes: ["Vector Tile Service"], supportsData: false }, e4).catch(f).then(async () => {
      if (!this.portalItem?.id) return;
      const r4 = `${this.portalItem.itemCdnUrl}/resources/styles/root.json`;
      (await H(r4, { ...e4, query: { f: "json", ...this.customParameters, token: this.apiKey }, authMode: this.portalItem.portal.authMode })).data && this.read({ url: r4 }, e3(this.portalItem, "portal-item"));
    }).catch(f).then(() => this._loadStyle(e4));
    return this.addResolvingPromise(r3), Promise.resolve(this);
  }
  get apiKey() {
    return super.apiKey;
  }
  set apiKey(e4) {
    super.apiKey = e4;
  }
  set portalItem(e4) {
    super.portalItem = e4;
  }
  get attributionDataUrl() {
    const e4 = this.currentStyleInfo, t3 = e4?.serviceUrl && I(e4.serviceUrl);
    if (!t3) return null;
    const r3 = this._getDefaultAttribution(t3.path);
    return r3 ? Bt(r3, { ...this.customParameters, token: this.apiKey }) : null;
  }
  get capabilities() {
    const e4 = this.primarySource;
    return e4 ? e4.capabilities : { operations: { supportsExportTiles: false, supportsTileMap: false }, exportTiles: null };
  }
  get fullExtent() {
    return this.primarySource?.fullExtent || null;
  }
  get initialExtent() {
    return this.primarySource?.initialExtent || null;
  }
  get parsedUrl() {
    return this.serviceUrl ? I(this.serviceUrl) : null;
  }
  get serviceUrl() {
    return this.currentStyleInfo?.serviceUrl || null;
  }
  get spatialReference() {
    return this.tileInfo?.spatialReference ?? null;
  }
  get styleUrl() {
    return this.currentStyleInfo?.styleUrl || null;
  }
  writeStyleUrl(e4, t3) {
    e4 && ht(e4) && (e4 = `https:${e4}`);
    const r3 = s3(e4);
    t3.styleUrl = x(e4, r3);
  }
  get tileInfo() {
    const e4 = [];
    for (const r3 in this.sourceNameToSource) e4.push(this.sourceNameToSource[r3]);
    let t3 = this.primarySource?.tileInfo || new z2();
    if (e4.length > 1) for (let r3 = 0; r3 < e4.length; r3++) r2(t3, e4[r3].tileInfo) && (t3 = o5(t3, e4[r3].tileInfo));
    return t3;
  }
  readTilemapCache(e4, t3) {
    const r3 = t3.capabilities?.includes("Tilemap");
    return r3 ? new j4({ layer: this }) : null;
  }
  set url(e4) {
    if (!e4) return void this._set("url", e4);
    const t3 = I(e4);
    this._set("url", t3.path), t3.query && (this.customParameters = { ...this.customParameters, ...t3.query });
  }
  readVersion(e4, t3) {
    return t3.version ? parseFloat(t3.version) : parseFloat(t3.currentVersion);
  }
  async loadSpriteSource(e4 = 1, t3) {
    if (!this._spriteSourceMap.has(e4)) {
      const r3 = t2().maxTextureSize, i2 = this.currentStyleInfo?.spriteUrl ? Bt(this.currentStyleInfo.spriteUrl, { ...this.customParameters, token: this.apiKey }) : null, o6 = new n2({ type: "url", spriteUrl: i2, pixelRatio: e4, spriteFormat: this.currentStyleInfo?.spriteFormat }, r3);
      await o6.load(t3), this._spriteSourceMap.set(e4, o6);
    }
    return this._spriteSourceMap.get(e4);
  }
  async setSpriteSource(e4, t3) {
    if (!e4) return null;
    const r3 = t2().maxTextureSize, i2 = e4.spriteUrl, o6 = i2 ? Bt(i2, { ...this.customParameters, token: this.apiKey }) : null;
    if (!o6 && "url" === e4.type) return null;
    const s6 = new n2(e4, r3);
    try {
      await s6.load(t3);
      const r4 = e4.pixelRatio || 1;
      return this._spriteSourceMap.clear(), this._spriteSourceMap.set(r4, s6), o6 && this.currentStyleInfo && (this.currentStyleInfo.spriteUrl = o6), this.emit("spriteSource-change", { spriteSource: s6 }), s6;
    } catch (a5) {
      f(a5);
    }
    return null;
  }
  async loadStyle(e4, t3) {
    const i2 = e4 || this.style || this.url;
    return this._loadingTask && "string" == typeof i2 && this.url === i2 || (this._loadingTask?.abort(), this._loadingTask = d2((e5) => (this._spriteSourceMap.clear(), this._getSourceAndStyle(i2, { signal: e5 })), t3)), this._loadingTask.promise;
  }
  getStyleLayerId(e4) {
    return this.styleRepository.getStyleLayerId(e4);
  }
  getStyleLayerIndex(e4) {
    return this.styleRepository.getStyleLayerIndex(e4);
  }
  getPaintProperties(e4) {
    return a(this.styleRepository?.getPaintProperties(e4));
  }
  setPaintProperties(e4, t3) {
    const r3 = this.styleRepository.isPainterDataDriven(e4);
    this.styleRepository.setPaintProperties(e4, t3);
    const i2 = this.styleRepository.isPainterDataDriven(e4);
    this.emit("paint-change", { layer: e4, paint: t3, isDataDriven: r3 || i2 });
  }
  getStyleLayer(e4) {
    return a(this.styleRepository.getStyleLayer(e4));
  }
  setStyleLayer(e4, t3) {
    this.styleRepository.setStyleLayer(e4, t3), this.emit("style-layer-change", { layer: e4, index: t3 });
  }
  deleteStyleLayer(e4) {
    this.styleRepository.deleteStyleLayer(e4), this.emit("delete-style-layer", { layer: e4 });
  }
  getLayoutProperties(e4) {
    return a(this.styleRepository.getLayoutProperties(e4));
  }
  setLayoutProperties(e4, t3) {
    this.styleRepository.setLayoutProperties(e4, t3), this.emit("layout-change", { layer: e4, layout: t3 });
  }
  setStyleLayerVisibility(e4, t3) {
    this.styleRepository.setStyleLayerVisibility(e4, t3), this.emit("style-layer-visibility-change", { layer: e4, visibility: t3 });
  }
  getStyleLayerVisibility(e4) {
    return this.styleRepository.getStyleLayerVisibility(e4);
  }
  write(e4, t3) {
    return t3?.origin && !this.styleUrl ? (t3.messages && t3.messages.push(new s("vectortilelayer:unsupported", `VectorTileLayer (${this.title}, ${this.id}) with style defined by JSON only are not supported`, { layer: this })), null) : super.write(e4, t3);
  }
  getTileUrl(e4, t3, r3) {
    return null;
  }
  async _getSourceAndStyle(e4, t3) {
    if (!e4) throw new Error("invalid style!");
    const r3 = await d4(e4, { ...t3, query: { ...this.customParameters, token: this.apiKey } });
    if ("webp" === r3.spriteFormat) {
      await o4("lossy") || (r3.spriteFormat = "png");
    }
    this._set("currentStyleInfo", { ...r3 }), "string" == typeof e4 ? (this.url = e4, this.style = null) : (this.url = null, this.style = e4), this._set("sourceNameToSource", r3.sourceNameToSource), this._set("primarySource", r3.sourceNameToSource[r3.primarySourceName]), this._set("styleRepository", new l4(r3.style, false)), this.read(r3.layerDefinition, { origin: "service" }), this.emit("load-style");
  }
  _getDefaultAttribution(e4) {
    const t3 = e4.match(/^https?:\/\/(?:basemaps|basemapsbeta|basemapsdev)(?:-api)?\.arcgis\.com(\/[^/]+)?\/arcgis\/rest\/services\/([^/]+(\/[^/]+)*)\/vectortileserver/i), r3 = ["OpenBasemap_v2", "OpenBasemap_GCS_v2", "OpenStreetMap_v2", "OpenStreetMap_Daylight_v2", "OpenStreetMap_Export_v2", "OpenStreetMap_FTS_v2", "OpenStreetMap_GCS_v2", "World_Basemap", "World_Basemap_v2", "World_Basemap_Export_v2", "World_Basemap_GCS_v2", "World_Basemap_WGS84", "World_Contours_v2", "World_Hillshade_v2"];
    if (!t3) return;
    const i2 = t3[2] && t3[2].toLowerCase();
    if (!i2) return;
    const o6 = t3[1] || "";
    for (const s6 of r3) if (s6.toLowerCase().includes(i2)) return K(`//static.arcgis.com/attribution/Vector${o6}/${s6}`);
  }
  async _loadStyle(e4) {
    return this._loadingTask?.promise ?? this.loadStyle(null, e4);
  }
};
__decorate([m({ readOnly: true })], B.prototype, "attributionDataUrl", null), __decorate([m({ type: ["show", "hide"] })], B.prototype, "listMode", void 0), __decorate([m({ json: { read: true, write: true } })], B.prototype, "blendMode", void 0), __decorate([m({ readOnly: true, json: { read: false } })], B.prototype, "capabilities", null), __decorate([m({ readOnly: true })], B.prototype, "currentStyleInfo", void 0), __decorate([m({ json: { read: false }, readOnly: true, type: z })], B.prototype, "fullExtent", null), __decorate([m({ json: { read: false }, readOnly: true, type: z })], B.prototype, "initialExtent", null), __decorate([m({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], B.prototype, "isReference", void 0), __decorate([m({ type: ["VectorTileLayer"] })], B.prototype, "operationalLayerType", void 0), __decorate([m({ readOnly: true })], B.prototype, "parsedUrl", null), __decorate([m({ type: String, json: { origins: { "web-scene": { read: true, write: true } }, read: false } })], B.prototype, "path", void 0), __decorate([m({ type: Number, json: { write: false, origins: { "web-map": { write: false }, "web-scene": { write: false }, "portal-item": { write: false } } } })], B.prototype, "refreshInterval", void 0), __decorate([m()], B.prototype, "style", void 0), __decorate([m({ readOnly: true })], B.prototype, "serviceUrl", null), __decorate([m({ type: f2, readOnly: true })], B.prototype, "spatialReference", null), __decorate([m({ readOnly: true })], B.prototype, "styleRepository", void 0), __decorate([m({ readOnly: true })], B.prototype, "sourceNameToSource", void 0), __decorate([m({ readOnly: true })], B.prototype, "primarySource", void 0), __decorate([m({ type: String, readOnly: true, json: { write: { ignoreOrigin: true }, origins: { "web-document": { write: { ignoreOrigin: true, isRequired: true } } } } })], B.prototype, "styleUrl", null), __decorate([r(["portal-item", "web-document"], "styleUrl")], B.prototype, "writeStyleUrl", null), __decorate([m({ json: { read: false, origins: { service: { read: false } } }, readOnly: true, type: z2 })], B.prototype, "tileInfo", null), __decorate([m()], B.prototype, "tilemapCache", void 0), __decorate([o2("service", "tilemapCache", ["capabilities", "tileInfo"])], B.prototype, "readTilemapCache", null), __decorate([m({ json: { read: false }, readOnly: true, value: "vector-tile" })], B.prototype, "type", void 0), __decorate([m({ json: { origins: { "web-document": { read: { source: "styleUrl" } }, "portal-item": { read: { source: "url" } } }, write: false, read: false } }), m(y)], B.prototype, "url", null), __decorate([m({ readOnly: true })], B.prototype, "version", void 0), __decorate([o2("version", ["version", "currentVersion"])], B.prototype, "readVersion", null), B = __decorate([a2("esri.layers.VectorTileLayer")], B);
var A3 = B;
export {
  A3 as default
};
//# sourceMappingURL=VectorTileLayer-5DMWWFCV.js.map
