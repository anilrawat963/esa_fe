import {
  o as o2
} from "./chunk-3RABUJDL.js";
import {
  A,
  _,
  a
} from "./chunk-U55FA2EK.js";
import {
  D,
  G,
  N,
  O,
  T,
  n,
  o,
  u
} from "./chunk-QNVJVDYZ.js";
import {
  r2 as r
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i
} from "./chunk-QY7XKUIV.js";
import {
  has
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/views/webgl/RenderbufferDescriptor.js
var i2 = class {
  constructor(t, i3 = 0, h2 = i3, r3 = false, s2 = 1) {
    this.internalFormat = t, this.width = i3, this.height = h2, this.multisampled = r3, this.samples = s2;
  }
};
function h(i3) {
  return i3.width <= 0 || i3.height <= 0 || null == i3.internalFormat ? 0 : i3.width * i3.height * _(i3.internalFormat);
}

// node_modules/@arcgis/core/views/webgl/Renderbuffer.js
var r2 = !!has("esri-tests-disable-gpu-memory-measurements");
var s = class {
  constructor(t, r3) {
    this._context = t, this._descriptor = r3, this.type = 2, this._context.instanceCounter.increment(O.Renderbuffer, this);
    const s2 = this._context.gl;
    this.glName = s2.createRenderbuffer(), this._context.bindRenderbuffer(this);
    const { width: i3, height: n2, internalFormat: o3, multisampled: h2 } = r3;
    h2 ? s2.renderbufferStorageMultisample(s2.RENDERBUFFER, this.samples, o3, i3, n2) : s2.renderbufferStorage(s2.RENDERBUFFER, o3, i3, n2), this._context.bindRenderbuffer(null);
  }
  get descriptor() {
    return this._descriptor;
  }
  get samples() {
    const e = this._descriptor.samples, t = this._context.parameters.maxSamples;
    return e ? Math.min(e, t) : t;
  }
  get usedMemory() {
    return r2 ? 0 : h(this._descriptor);
  }
  resize(e, t) {
    const r3 = this._descriptor;
    if (r3.width === e && r3.height === t) return;
    r3.width = e, r3.height = t;
    const s2 = this._context.gl;
    this._context.bindRenderbuffer(this), r3.multisampled ? s2.renderbufferStorageMultisample(s2.RENDERBUFFER, this.samples, r3.internalFormat, r3.width, r3.height) : s2.renderbufferStorage(s2.RENDERBUFFER, r3.internalFormat, r3.width, r3.height), this._context.bindRenderbuffer(null);
  }
  dispose() {
    this._context && (this._context.gl.deleteRenderbuffer(this.glName), this._context.instanceCounter.decrement(O.Renderbuffer, this), this._context = null);
  }
};

// node_modules/@arcgis/core/views/webgl/FramebufferObject.js
var _2 = () => i.getLogger("esri.views.webgl.FramebufferObject");
var _m = class _m {
  constructor(e, t, r3) {
    if (this._context = e, this._glName = null, this._colorAttachments = /* @__PURE__ */ new Map(), this._depthStencilBuffer = null, this._depthStencilTexture = null, this._initialized = false, e.instanceCounter.increment(O.FramebufferObject, this), null != t) {
      const r4 = E(e, t);
      null != r4 && (this._colorAttachments.set(D, r4), p(r4) ? this._validateTextureDescriptor(r4.descriptor) : this._validateRenderbufferDescriptor(r4.descriptor)), this._validateColorAttachmentPoint(D);
    }
    if (null != r3) if (x(r3)) this._depthStencilTexture = p(r3) ? r3 : new A(e, r3), this._validateTextureDescriptor(this._depthStencilTexture.descriptor);
    else {
      const t2 = T2(r3) ? r3 : new s(e, r3);
      this._depthStencilBuffer = t2, this._validateRenderbufferDescriptor(t2.descriptor);
    }
  }
  dispose() {
    const { _colorAttachments: e, _glName: t } = this;
    if (0 === e.size && !this._depthStencilBuffer && !this._depthStencilTexture && !t) return;
    const { _context: r3 } = this, i3 = r3.getBoundFramebufferObject();
    e.forEach((e2, t2) => this.detachColorTexture(t2)?.dispose()), this.detachDepthStencilBuffer()?.dispose(), this.detachDepthStencilTexture()?.dispose(), r3.gl.deleteFramebuffer(t), this._glName = null, r3.bindFramebuffer(i3 === this ? null : i3), r3.instanceCounter.decrement(O.FramebufferObject, this);
  }
  get glName() {
    return this._glName;
  }
  get colorTexture() {
    const e = this._colorAttachments.get(D);
    return p(e) ? e : null;
  }
  get depthStencil() {
    return this._depthStencilTexture || this._depthStencilBuffer;
  }
  get depthStencilTexture() {
    return this._depthStencilTexture;
  }
  get width() {
    const e = this._colorAttachments.get(D) ?? this._depthStencilTexture ?? this._depthStencilBuffer;
    return e?.descriptor?.width ?? 0;
  }
  get height() {
    const e = this._colorAttachments.get(D) ?? this._depthStencilTexture ?? this._depthStencilBuffer;
    return e?.descriptor?.height ?? 0;
  }
  get usedMemory() {
    return [...this._colorAttachments].reduce((e, [t, r3]) => e + r3.usedMemory, this.depthStencil?.usedMemory ?? 0);
  }
  getColorTexture(e) {
    const t = this._colorAttachments.get(e);
    return t && p(t) ? t : null;
  }
  get colorAttachments() {
    return [...this._colorAttachments.keys()];
  }
  attachColorTexture(e, t = D) {
    if (!e) return;
    this._validateColorAttachmentPoint(t);
    const { descriptor: r3 } = e;
    this._validateTextureDescriptor(r3), this.detachColorTexture(t)?.dispose(), this._initialized && (this._context.bindFramebuffer(this), this._framebufferTexture2D(e.glName, t)), this._colorAttachments.set(t, e);
  }
  detachColorTexture(e = D) {
    const t = this._colorAttachments.get(e);
    if (!t) return;
    const r3 = p(t);
    return this._initialized && this._context.temporaryBindFramebufferObject(this, () => {
      if (r3) this._framebufferTexture2D(null, e);
      else {
        const t2 = this._context.gl;
        t2.framebufferRenderbuffer(t2.FRAMEBUFFER, e, t2.RENDERBUFFER, null);
      }
    }), this._colorAttachments.delete(e), r3 ? t : void 0;
  }
  setColorTextureTarget(e, t = D, r3 = 0) {
    const i3 = this._colorAttachments.get(t);
    i3 && (35866 === e ? this._framebufferTextureLayer(i3.glName, t, 36160, 0, r3) : this._framebufferTexture2D(i3.glName, t, e, 36160, 0));
  }
  attachDepthStencil(e) {
    if (e) switch (e.type) {
      case 1:
        return this._attachDepthStencilTexture(e);
      case 2:
        return this._attachDepthStencilBuffer(e);
    }
  }
  _attachDepthStencilTexture(e) {
    if (null == e) return;
    const { descriptor: t } = e, { pixelFormat: r3, dataType: i3 } = t;
    34041 === r3 || 6402 === r3 ? 34041 !== r3 || i3 === N.UNSIGNED_INT_24_8 ? 6402 !== r3 || i3 === N.UNSIGNED_INT || i3 === N.UNSIGNED_SHORT ? (this._validateTextureDescriptor(t), this._disposeDepthStencilAttachments(), this._initialized && (this._context.bindFramebuffer(this), this._framebufferTexture2D(e.glName, A2(r3))), this._depthStencilTexture?.dispose(), this._depthStencilTexture = e) : console.error("Depth texture must have data type of UNSIGNED_INT or UNSIGNED_SHORT!") : console.error("Depth/Stencil texture must have data type of UNSIGNED_INT_24_8!") : console.error("Depth/Stencil texture must have a pixel type of DEPTH_STENCIL!");
  }
  detachDepthStencilTexture() {
    const e = this._depthStencilTexture;
    return e && this._initialized && this._context.temporaryBindFramebufferObject(this, () => {
      this._framebufferTexture2D(null, A2(e.descriptor.pixelFormat));
    }), this._depthStencilTexture = null, e;
  }
  _attachDepthStencilBuffer(e) {
    if (null == e) return;
    const t = e.descriptor;
    if (this._validateRenderbufferDescriptor(t), this._disposeDepthStencilAttachments(), this._initialized) {
      this._context.bindFramebuffer(this);
      const { gl: r3 } = this._context, i3 = this._getGLAttachmentPoint(t);
      r3.framebufferRenderbuffer(36160, i3, r3.RENDERBUFFER, e.glName);
    }
    this._depthStencilBuffer = e;
  }
  detachDepthStencilBuffer() {
    const e = this._depthStencilBuffer;
    if (e && this._initialized) {
      const { _context: t } = this, r3 = t.getBoundFramebufferObject();
      t.bindFramebuffer(this);
      const { gl: i3 } = t, s2 = this._getGLAttachmentPoint(e.descriptor);
      i3.framebufferRenderbuffer(36160, s2, i3.RENDERBUFFER, null), t.bindFramebuffer(r3);
    }
    return this._depthStencilBuffer = null, e;
  }
  invalidateAttachments(e) {
    const { _context: t } = this;
    t.temporaryBindFramebufferObject(this, () => t.gl.invalidateFramebuffer(36160, e), true);
  }
  copyToTexture(e, t, r3, i3, s2, n2, h2) {
    (e < 0 || t < 0 || s2 < 0 || n2 < 0) && console.error("Offsets cannot be negative!"), (r3 <= 0 || i3 <= 0) && console.error("Copy width and height must be greater than zero!");
    const o3 = h2.descriptor;
    3553 !== h2.descriptor.target && console.error("Texture target must be TEXTURE_2D!"), (null == o3?.width || null == o3?.height || e + r3 > this.width || t + i3 > this.height || s2 + r3 > o3.width || n2 + i3 > o3.height) && console.error("Bad dimensions, the current input values will attempt to read or copy out of bounds!");
    const c = this._context, a2 = c.bindTexture(h2, A.TEXTURE_UNIT_FOR_UPDATES);
    c.setActiveTexture(A.TEXTURE_UNIT_FOR_UPDATES), c.bindFramebuffer(this), c.gl.copyTexSubImage2D(3553, 0, s2, n2, e, t, r3, i3), c.bindTexture(a2, A.TEXTURE_UNIT_FOR_UPDATES);
  }
  readPixels(e, t, r3, i3, s2, n2, h2) {
    (r3 <= 0 || i3 <= 0) && console.error("Copy width and height must be greater than zero!"), h2 || console.error("Target memory is not initialized!"), this._context.bindFramebuffer(this), this._context.gl.readPixels(e, t, r3, i3, s2, n2, h2);
  }
  async readPixelsAsync(e, t, i3, s2, n2, h2, o3) {
    const { gl: c } = this._context, a2 = o2.createPixelPack(this._context, 35041, o3.byteLength);
    this._context.bindBuffer(a2);
    const u2 = this._context.getBoundFramebufferObject();
    this._context.bindFramebuffer(this), c.readPixels(e, t, i3, s2, n2, h2, 0), this._context.unbindBuffer(35051), this._context.bindFramebuffer(u2), await a2.getSubDataAsync(o3), a2.dispose();
  }
  resize(e, t) {
    if (this.width === e && this.height === t) return;
    const r3 = { width: e, height: t };
    if (F(r3, this._context.parameters.maxTextureSize), this._colorAttachments.forEach((e2) => e2.resize(r3.width, r3.height)), this._depthStencilTexture?.resize(r3.width, r3.height), this._initialized && (F(r3, this._context.parameters.maxRenderbufferSize), this._depthStencilBuffer?.resize(r3.width, r3.height), a())) {
      const { gl: e2 } = this._context;
      e2.checkFramebufferStatus(36160) !== e2.FRAMEBUFFER_COMPLETE && console.error("Framebuffer is incomplete!");
    }
  }
  initializeAndBind(e = 36160) {
    const { gl: t } = this._context;
    if (this._initialized) return void t.bindFramebuffer(e, this.glName);
    this._glName && t.deleteFramebuffer(this._glName);
    const r3 = t.createFramebuffer();
    if (t.bindFramebuffer(e, r3), this._colorAttachments.forEach((t2, r4) => {
      if (p(t2)) {
        const i3 = D2(t2);
        35866 === i3 ? this._framebufferTextureLayer(t2.glName, r4, e, 0, 0) : this._framebufferTexture2D(t2.glName, r4, i3, e);
      } else if (T2(t2)) {
        const i3 = this._context.gl;
        i3.framebufferRenderbuffer(e, r4, i3.RENDERBUFFER, t2.glName);
      }
    }), this._depthStencilBuffer) {
      const r4 = this._getGLAttachmentPoint(this._depthStencilBuffer.descriptor);
      t.framebufferRenderbuffer(e, r4, t.RENDERBUFFER, this._depthStencilBuffer.glName);
    } else if (this._depthStencilTexture) {
      const t2 = A2(this._depthStencilTexture.descriptor.pixelFormat);
      this._framebufferTexture2D(this._depthStencilTexture.glName, t2, D2(this._depthStencilTexture), e);
    }
    if (a()) {
      t.checkFramebufferStatus(e) !== t.FRAMEBUFFER_COMPLETE && console.error("Framebuffer is incomplete!");
    }
    this._glName = r3, this._initialized = true;
  }
  _framebufferTexture2D(e, t = D, r3 = 3553, i3 = 36160, s2 = 0) {
    this._context.gl.framebufferTexture2D(i3, t, r3, e, s2);
  }
  _framebufferTextureLayer(e, t = D, r3 = 36160, i3 = 0, s2 = 0) {
    this._context.gl.framebufferTextureLayer(r3, t, e, i3, s2);
  }
  _disposeDepthStencilAttachments() {
    const e = this._context.gl;
    if (this._depthStencilBuffer) {
      if (this._initialized) {
        this._context.bindFramebuffer(this);
        const t = this._getGLAttachmentPoint(this._depthStencilBuffer.descriptor);
        e.framebufferRenderbuffer(36160, t, e.RENDERBUFFER, null);
      }
      this._depthStencilBuffer = r(this._depthStencilBuffer);
    }
    this._depthStencilTexture && (this._initialized && (this._context.bindFramebuffer(this), this._framebufferTexture2D(null, A2(this._depthStencilTexture.descriptor.pixelFormat))), this._depthStencilTexture = r(this._depthStencilTexture));
  }
  _validateTextureDescriptor(e) {
    3553 !== e.target && 34067 !== e.target && 35866 !== e.target && console.error("Texture type must be TEXTURE_2D, TEXTURE_2D_ARRAY or TEXTURE_CUBE_MAP!"), F(e, this._context.parameters.maxTextureSize), this._validateBufferDimensions(e);
  }
  _validateRenderbufferDescriptor(e) {
    F(e, this._context.parameters.maxRenderbufferSize), this._validateBufferDimensions(e);
  }
  _validateBufferDimensions(e) {
    e.width <= 0 && (e.width = this.width), e.height <= 0 && (e.height = this.height), this.width > 0 && this.height > 0 && (this.width === e.width && this.height === e.height || console.error("Attachment size must match framebuffer size!"));
  }
  _getGLAttachmentPoint(e) {
    switch (e.internalFormat) {
      case T.DEPTH_COMPONENT16:
      case T.DEPTH_COMPONENT24:
      case T.DEPTH_COMPONENT32F:
        return o;
      case G.DEPTH24_STENCIL8:
      case G.DEPTH32F_STENCIL8:
        return n;
      case 36168:
        return u;
      default:
        return D;
    }
  }
  _validateColorAttachmentPoint(t) {
    if (-1 === _m._MAX_COLOR_ATTACHMENTS) {
      const { gl: e } = this._context;
      _m._MAX_COLOR_ATTACHMENTS = e.getParameter(e.MAX_COLOR_ATTACHMENTS);
    }
    const r3 = t - D;
    r3 + 1 > _m._MAX_COLOR_ATTACHMENTS && i.getLogger("esri.views.webgl.FrameBufferObject").error("esri.FrameBufferObject", `illegal attachment point for color attachment: ${r3 + 1}. Implementation supports up to ${_m._MAX_COLOR_ATTACHMENTS} color attachments`);
  }
};
_m._MAX_COLOR_ATTACHMENTS = -1;
var m = _m;
function p(e) {
  return 1 === S(e);
}
function T2(e) {
  return 2 === S(e);
}
function x(e) {
  return p(e) || b(e);
}
function b(e) {
  return 0 === S(e);
}
function g(e) {
  return 3 === S(e) || null != e && "samples" in e;
}
function S(e) {
  return null != e && "type" in e ? e.type : null;
}
function E(e, t) {
  return p(t) || T2(t) ? t : b(t) ? new A(e, t) : g(t) ? new s(e, t) : null;
}
function F(e, t) {
  const r3 = Math.max(e.width, e.height);
  if (r3 > t) {
    _2().warnOnce(`Resizing FBO attachment size ${e.width}x${e.height} to device limit ${t}`);
    const i3 = t / r3;
    return e.width = Math.round(e.width * i3), e.height = Math.round(e.height * i3), false;
  }
  return true;
}
function D2(e) {
  return 34067 === e.descriptor.target ? 34069 : 35866 === e.descriptor.target ? 35866 : 3553;
}
function A2(e) {
  return 6402 === e ? o : n;
}

export {
  i2 as i,
  s,
  m
};
//# sourceMappingURL=chunk-NNZE65VM.js.map
