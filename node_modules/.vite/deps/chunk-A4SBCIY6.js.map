{
  "version": 3,
  "sources": ["../../@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/FoamRendering.glsl.js", "../../@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/WaterDistortion.glsl.js", "../../@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ScreenSpaceReflections.glsl.js", "../../@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/LookupCloudsFromTextureArray.glsl.js", "../../@arcgis/core/views/3d/webgl-engine/core/shaderModules/Texture2DArrayBindUniform.js", "../../@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/CloudsParallaxShading.glsl.js", "../../@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/Water.glsl.js", "../../@arcgis/core/chunks/WaterSurface.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.34/esri/copyright.txt for details.\n*/\nimport{glsl as o}from\"../../shaderModules/glsl.js\";function t(t){t.code.add(o`float normals2FoamIntensity(vec3 n, float waveStrength){\nfloat normalizationFactor =  max(0.015, waveStrength);\nreturn max((n.x + n.y)*0.3303545/normalizationFactor + 0.3303545, 0.0);\n}`)}function n(t){t.code.add(o`vec3 foamIntensity2FoamColor(float foamIntensityExternal, float foamPixelIntensity, vec3 skyZenitColor, float dayMod){\nreturn foamIntensityExternal * (0.075 * skyZenitColor * pow(foamPixelIntensity, 4.) +  50.* pow(foamPixelIntensity, 23.0)) * dayMod;\n}`)}export{n as FoamColor,t as FoamIntensity};\n", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.34/esri/copyright.txt for details.\n*/\nimport{set as e}from\"../../../../../../core/libs/gl-matrix-2/math/vec2.js\";import{create as t}from\"../../../../../../core/libs/gl-matrix-2/factories/vec2f64.js\";import{s as r}from\"../../../../../../chunks/vec42.js\";import{create as a}from\"../../../../../../core/libs/gl-matrix-2/factories/vec4f64.js\";import{FoamIntensity as o}from\"./FoamRendering.glsl.js\";import{ReadShadowMapPassParameters as m}from\"./ReadShadowMap.glsl.js\";import{Float2PassUniform as s}from\"../../shaderModules/Float2PassUniform.js\";import{Float4PassUniform as v}from\"../../shaderModules/Float4PassUniform.js\";import{glsl as l}from\"../../shaderModules/glsl.js\";import{Texture2DPassUniform as i}from\"../../shaderModules/Texture2DPassUniform.js\";function u(t){t.fragment.uniforms.add(new i(\"texWaveNormal\",e=>e.waveNormal),new i(\"texWavePerturbation\",e=>e.wavePerturbation),new v(\"waveParams\",e=>r(c,e.waveStrength,e.waveTextureRepeat,e.flowStrength,e.flowOffset)),new s(\"waveDirection\",t=>e(n,t.waveDirection[0]*t.waveVelocity,t.waveDirection[1]*t.waveVelocity))),t.fragment.include(o),t.fragment.code.add(l`const vec2  FLOW_JUMP = vec2(6.0/25.0, 5.0/24.0);\nvec2 textureDenormalized2D(sampler2D _tex, vec2 _uv) {\nreturn 2.0 * texture(_tex, _uv).rg - 1.0;\n}\nfloat sampleNoiseTexture(vec2 _uv) {\nreturn texture(texWavePerturbation, _uv).b;\n}\nvec3 textureDenormalized3D(sampler2D _tex, vec2 _uv) {\nreturn 2.0 * texture(_tex, _uv).rgb - 1.0;\n}\nfloat computeProgress(vec2 uv, float time) {\nreturn fract(time);\n}\nfloat computeWeight(vec2 uv, float time) {\nfloat progress = computeProgress(uv, time);\nreturn 1.0 - abs(1.0 - 2.0 * progress);\n}\nvec3 computeUVPerturbedWeigth(sampler2D texFlow, vec2 uv, float time, float phaseOffset) {\nfloat flowStrength = waveParams[2];\nfloat flowOffset = waveParams[3];\nvec2 flowVector = textureDenormalized2D(texFlow, uv) * flowStrength;\nfloat progress = computeProgress(uv, time + phaseOffset);\nfloat weight = computeWeight(uv, time + phaseOffset);\nvec2 result = uv;\nresult -= flowVector * (progress + flowOffset);\nresult += phaseOffset;\nresult += (time - progress) * FLOW_JUMP;\nreturn vec3(result, weight);\n}\nconst float TIME_NOISE_TEXTURE_REPEAT = 0.3737;\nconst float TIME_NOISE_STRENGTH = 7.77;\nvec3 getWaveLayer(sampler2D _texNormal, sampler2D _dudv, vec2 _uv, vec2 _waveDir, float time) {\nfloat waveStrength = waveParams[0];\nvec2 waveMovement = time * -_waveDir;\nfloat timeNoise = sampleNoiseTexture(_uv * TIME_NOISE_TEXTURE_REPEAT) * TIME_NOISE_STRENGTH;\nvec3 uv_A = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, time + timeNoise, 0.0);\nvec3 uv_B = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, time + timeNoise, 0.5);\nvec3 normal_A = textureDenormalized3D(_texNormal, uv_A.xy) * uv_A.z;\nvec3 normal_B = textureDenormalized3D(_texNormal, uv_B.xy) * uv_B.z;\nvec3 mixNormal = normalize(normal_A + normal_B);\nmixNormal.xy *= waveStrength;\nmixNormal.z = sqrt(1.0 - dot(mixNormal.xy, mixNormal.xy));\nreturn mixNormal;\n}\nvec4 getSurfaceNormalAndFoam(vec2 _uv, float _time) {\nfloat waveTextureRepeat = waveParams[1];\nvec3 normal = getWaveLayer(texWaveNormal, texWavePerturbation, _uv * waveTextureRepeat, waveDirection, _time);\nfloat foam  = normals2FoamIntensity(normal, waveParams[0]);\nreturn vec4(normal, foam);\n}`)}class f extends m{}const c=a(),n=t();export{u as WaterDistortion,f as WaterDistortionPassParameters};\n", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.34/esri/copyright.txt for details.\n*/\nimport{ReadDepth as e}from\"../output/ReadDepth.glsl.js\";import{Float2BindUniform as t}from\"../../shaderModules/Float2BindUniform.js\";import{FloatBindUniform as o}from\"../../shaderModules/FloatBindUniform.js\";import{glsl as r}from\"../../shaderModules/glsl.js\";import{Matrix4BindUniform as i}from\"../../shaderModules/Matrix4BindUniform.js\";import{Texture2DBindUniform as a}from\"../../shaderModules/Texture2DBindUniform.js\";function d(d,n){if(!n.screenSpaceReflections)return;const c=d.fragment;c.include(e),c.uniforms.add(new t(\"nearFar\",e=>e.camera.nearFar),new a(\"depthMap\",e=>e.depth?.attachment),new i(\"proj\",e=>e.camera.projectionMatrix),new o(\"invResolutionHeight\",e=>1/e.camera.height),new i(\"reprojectionMatrix\",e=>e.ssr.reprojectionMatrix)).code.add(r`\n  vec2 reprojectionCoordinate(vec3 projectionCoordinate)\n  {\n    vec4 zw = proj * vec4(0.0, 0.0, -projectionCoordinate.z, 1.0);\n    vec4 reprojectedCoord = reprojectionMatrix * vec4(zw.w * (projectionCoordinate.xy * 2.0 - 1.0), zw.z, zw.w);\n    reprojectedCoord.xy /= reprojectedCoord.w;\n    return reprojectedCoord.xy * 0.5 + 0.5;\n  }\n\n  const int maxSteps = ${n.highStepCount?\"150\":\"75\"};\n\n  vec4 applyProjectionMat(mat4 projectionMat, vec3 x)\n  {\n    vec4 projectedCoord =  projectionMat * vec4(x, 1.0);\n    projectedCoord.xy /= projectedCoord.w;\n    projectedCoord.xy = projectedCoord.xy*0.5 + 0.5;\n    return projectedCoord;\n  }\n\n  vec3 screenSpaceIntersection(vec3 dir, vec3 startPosition, vec3 viewDir, vec3 normal)\n  {\n    vec3 viewPos = startPosition;\n    vec3 viewPosEnd = startPosition;\n\n    // Project the start position to the screen\n    vec4 projectedCoordStart = applyProjectionMat(proj, viewPos);\n    vec3  Q0 = viewPos / projectedCoordStart.w; // homogeneous camera space\n    float k0 = 1.0/ projectedCoordStart.w;\n\n    // advance the position in the direction of the reflection\n    viewPos += dir;\n\n    vec4 projectedCoordVanishingPoint = applyProjectionMat(proj, dir);\n\n    // Project the advanced position to the screen\n    vec4 projectedCoordEnd = applyProjectionMat(proj, viewPos);\n    vec3  Q1 = viewPos / projectedCoordEnd.w; // homogeneous camera space\n    float k1 = 1.0/ projectedCoordEnd.w;\n\n    // calculate the reflection direction in the screen space\n    vec2 projectedCoordDir = (projectedCoordEnd.xy - projectedCoordStart.xy);\n    vec2 projectedCoordDistVanishingPoint = (projectedCoordVanishingPoint.xy - projectedCoordStart.xy);\n\n    float yMod = min(abs(projectedCoordDistVanishingPoint.y), 1.0);\n\n    float projectedCoordDirLength = length(projectedCoordDir);\n    float maxSt = float(maxSteps);\n\n    // normalize the projection direction depending on maximum steps\n    // this determines how blocky the reflection looks\n    vec2 dP = yMod * (projectedCoordDir)/(maxSt * projectedCoordDirLength);\n\n    // Normalize the homogeneous camera space coordinates\n    vec3  dQ = yMod * (Q1 - Q0)/(maxSt * projectedCoordDirLength);\n    float dk = yMod * (k1 - k0)/(maxSt * projectedCoordDirLength);\n\n    // initialize the variables for ray marching\n    vec2 P = projectedCoordStart.xy;\n    vec3 Q = Q0;\n    float k = k0;\n    float rayStartZ = -startPosition.z; // estimated ray start depth value\n    float rayEndZ = -startPosition.z;   // estimated ray end depth value\n    float prevEstimateZ = -startPosition.z;\n    float rayDiffZ = 0.0;\n    float dDepth;\n    float depth;\n    float rayDiffZOld = 0.0;\n\n    // early outs\n    if (dot(normal, dir) < 0.0 || dot(-viewDir, normal) < 0.0)\n      return vec3(P, 0.0);\n    float dDepthBefore = 0.0;\n\n    for(int i = 0; i < maxSteps-1; i++)\n    {\n      depth = -linearDepthFromTexture(depthMap, P); // get linear depth from the depth buffer\n\n      // estimate depth of the marching ray\n      rayStartZ = prevEstimateZ;\n      dDepth = -rayStartZ - depth;\n      rayEndZ = (dQ.z * 0.5 + Q.z)/ ((dk * 0.5 + k));\n      rayDiffZ = rayEndZ- rayStartZ;\n      prevEstimateZ = rayEndZ;\n\n      if(-rayEndZ > nearFar[1] || -rayEndZ < nearFar[0] || P.y < 0.0  || P.y > 1.0 )\n      {\n        return vec3(P, 0.);\n      }\n\n      // If we detect a hit - return the intersection point, two conditions:\n      //  - dDepth > 0.0 - sampled point depth is in front of estimated depth\n      //  - if difference between dDepth and rayDiffZOld is not too large\n      //  - if difference between dDepth and 0.025/abs(k) is not too large\n      //  - if the sampled depth is not behind far plane or in front of near plane\n\n      if((dDepth) < 0.025/abs(k) + abs(rayDiffZ) && dDepth > 0.0 && depth > nearFar[0] && depth < nearFar[1] && abs(P.y - projectedCoordStart.y) > invResolutionHeight)\n      {\n        float weight = dDepth / (dDepth - dDepthBefore);\n        vec2 Pf = mix(P - dP, P, 1.0 - weight);\n        if (abs(Pf.y - projectedCoordStart.y) > invResolutionHeight) {\n          return vec3(Pf, depth);\n        }\n        else {\n          return vec3(P, depth);\n        }\n      }\n\n      // continue with ray marching\n      P = clamp(P + dP, vec2(0.0), vec2(0.999));\n      Q.z += dQ.z;\n      k += dk;\n      rayDiffZOld = rayDiffZ;\n      dDepthBefore = dDepth;\n    }\n    return vec3(P, 0.0);\n  }\n  `)}export{d as ScreenSpaceReflections};\n", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.34/esri/copyright.txt for details.\n*/\nimport{FloatBindUniform as r}from\"../../shaderModules/FloatBindUniform.js\";import{glsl as a}from\"../../shaderModules/glsl.js\";function e(e){e.fragment.uniforms.add(new r(\"cloudAbsorption\",r=>r.clouds.absorption),new r(\"cloudCoverage\",r=>r.clouds.coverage)).code.add(a`vec4 lookupCloudsFromTextureArray(sampler2DArray cubeMap, vec3 rayDir) {\nint faceIndex;\nvec2 uv;\nif(rayDir.z <= 0.0) {\nfloat hazeFactor = smoothstep(-0.01, mix(0.0, 0.075, cloudCoverage), abs(dot(rayDir, vec3(0, 0, 1))));\nfloat shading = clamp(1.0 - cloudAbsorption, 0.6, 1.0) * (1.0 - hazeFactor);\nfloat totalTransmittance = hazeFactor;\nreturn vec4(shading, totalTransmittance, shading, totalTransmittance);\n}\nif (abs(rayDir.x) >= abs(rayDir.y) && abs(rayDir.x) >= abs(rayDir.z)) {\nif(rayDir.x > 0.0) {\nfaceIndex = 0;\nuv = rayDir.yz / rayDir.x;\nuv = vec2(-uv.x, uv.y);\n} else {\nfaceIndex = 1;\nuv = rayDir.yz / rayDir.x;\nuv = vec2(-uv.x, -uv.y);\n}\n} else if (abs(rayDir.y) >= abs(rayDir.x) && abs(rayDir.y) >= abs(rayDir.z)) {\nif(rayDir.y > 0.0) {\nfaceIndex = 2;\nuv = rayDir.xz / rayDir.y;\n} else {\nfaceIndex = 3;\nuv = rayDir.xz / rayDir.y;\nuv = vec2(uv.x, -uv.y);\n}\n} else {\nif(rayDir.y < 0.0) {\nfaceIndex = 4;\nuv = rayDir.xy / rayDir.z;\nuv = vec2(uv.x, -uv.y);\n} else {\nfaceIndex = 5;\nuv = rayDir.xy / rayDir.z;\nuv = vec2(uv.x, -uv.y);\n}\n}\nuv = 0.5 * (uv + 1.0);\nif(faceIndex != 5) {\nuv.y = uv.y - 0.5;\n}\nuv.y = uv.y * 2.0;\nvec4 s = texture(cubeMap, vec3(uv, float(faceIndex)));\nreturn s;\n}`)}export{e as LookupCloudsFromTextureArray};\n", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.34/esri/copyright.txt for details.\n*/\nimport{Uniform as r}from\"../../../../webgl/Uniform.js\";class e extends r{constructor(r,e){super(r,\"sampler2DArray\",0,(s,o)=>s.bindTexture(r,e(o)))}}export{e as Texture2DArrayBindUniform};\n", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.34/esri/copyright.txt for details.\n*/\nimport{fromValues as o}from\"../../../../../../core/libs/gl-matrix-2/factories/vec3f64.js\";import{earth as t}from\"../../../../../../geometry/support/Ellipsoid.js\";import{cloudsHeight as e}from\"../../../../environment/weather.js\";import{addMainLightDirection as a,addMainLightIntensity as r}from\"../shading/MainLighting.glsl.js\";import{LookupCloudsFromTextureArray as i}from\"./LookupCloudsFromTextureArray.glsl.js\";import{BooleanBindUniform as c}from\"../../shaderModules/BooleanBindUniform.js\";import{Float3BindUniform as d}from\"../../shaderModules/Float3BindUniform.js\";import{FloatBindUniform as n}from\"../../shaderModules/FloatBindUniform.js\";import{glsl as l}from\"../../shaderModules/glsl.js\";import{Matrix4BindUniform as s}from\"../../shaderModules/Matrix4BindUniform.js\";import{Texture2DArrayBindUniform as u}from\"../../shaderModules/Texture2DArrayBindUniform.js\";function m(t){const e=t.fragment;e.constants.add(\"radiusCloudsSquared\",\"float\",h).code.add(l`vec3 intersectWithCloudLayer(vec3 dir, vec3 cameraPosition, vec3 spherePos) {\nfloat B = 2.0 * dot(cameraPosition, dir);\nfloat C = dot(cameraPosition, cameraPosition) - radiusCloudsSquared;\nfloat det = B * B - 4.0 * C;\nfloat pointIntDist = max(0.0, 0.5 *(-B + sqrt(det)));\nreturn (cameraPosition + dir * pointIntDist) - spherePos;\n}`),e.uniforms.add(new n(\"radiusCurvatureCorrection\",({clouds:o})=>o.parallax.radiusCurvatureCorrection)).code.add(l`vec3 correctForPlanetCurvature(vec3 dir) {\ndir.z = dir.z * (1.0 - radiusCurvatureCorrection) + radiusCurvatureCorrection;\nreturn dir;\n}`),e.code.add(l`vec3 rotateDirectionToAnchorPoint(mat4 rotMat, vec3 inVec) {\nreturn (rotMat * vec4(inVec, 0.0)).xyz;\n}`),a(e),r(e);const m=o(.28,.175,.035);e.constants.add(\"RIM_COLOR\",\"vec3\",m);const C=.3,v=140,f=.2,p=10,g=.3;e.code.add(l`\n    vec3 calculateCloudColor(vec3 cameraPosition, vec3 worldSpaceRay, vec4 clouds) {\n      float upDotLight = dot(cameraPosition, mainLightDirection);\n      float dirDotLight = max(dot(worldSpaceRay, mainLightDirection), 0.0);\n      float sunsetTransition = clamp(pow(max(upDotLight, 0.0), ${l.float(C)}), 0.0, 1.0);\n\n      // Base color of the clouds that depends on lighting of the sun and sky\n      vec3 ambientLight = calculateAmbientIrradiance(cameraPosition,  0.0);\n      vec3 combinedLight = clamp((mainLightIntensity + ambientLight )/PI, vec3(0.0), vec3(1.0));\n      vec3 baseCloudColor = pow(combinedLight * pow(clouds.xyz, vec3(GAMMA)), vec3(INV_GAMMA));\n\n      // Rim light around the edge of the clouds simulating scattering of the direct lun light\n      float scatteringMod = max(clouds.a < 0.5 ? clouds.a / 0.5 : - clouds.a / 0.5 + 2.0, 0.0);\n      float rimLightIntensity = 0.5 + 0.5 * pow(max(upDotLight, 0.0), 0.35);\n      vec3 directSunScattering = RIM_COLOR * rimLightIntensity * (pow(dirDotLight, ${l.float(v)})) * scatteringMod;\n\n      // Brighten the clouds around the sun at the sunsets\n      float additionalLight = ${l.float(f)} * pow(dirDotLight, ${l.float(p)}) * (1. - pow(sunsetTransition, ${l.float(g)})) ;\n\n      return vec3(baseCloudColor * (1.0 + additionalLight) + directSunScattering);\n    }\n  `),t.include(i),e.uniforms.add(new c(\"readChannelsRG\",o=>0===o.clouds.readChannels),new u(\"cubeMap\",o=>o.clouds.data?.cubeMap?.colorTexture)).code.add(l`vec4 sampleCloud(vec3 rayDir, bool readOtherChannel) {\nvec4 s = lookupCloudsFromTextureArray(cubeMap, rayDir);\nbool readRG = readChannelsRG ^^ readOtherChannel;\ns = readRG ? vec4(vec3(s.r), s.g) : vec4(vec3(s.b), s.a);\nreturn length(s) == 0.0 ? vec4(s.rgb, 1.0) : s;\n}`),e.uniforms.add(new d(\"anchorPoint\",o=>o.clouds.parallax.anchorPoint),new d(\"anchorPointNew\",o=>o.clouds.parallaxNew.anchorPoint),new s(\"rotationClouds\",o=>o.clouds.parallax.transform),new s(\"rotationCloudsNew\",o=>o.clouds.parallaxNew.transform),new n(\"cloudsOpacity\",o=>o.clouds.opacity),new n(\"fadeFactor\",o=>o.clouds.fadeFactor),new c(\"crossFade\",o=>3===o.clouds.fadeState)).code.add(l`vec4 renderClouds(vec3 worldRay, vec3 cameraPosition) {\nvec3 intersectionPoint = intersectWithCloudLayer(worldRay, cameraPosition, anchorPoint);\nvec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationClouds, normalize(intersectionPoint));\nvec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);\nvec4 cloudData = sampleCloud(worldRayRotatedCorrected, crossFade);\nvec3 cameraPositionN = normalize(cameraPosition);\nvec4 cloudColor = vec4(calculateCloudColor(cameraPositionN, worldRay, cloudData), cloudData.a);\nif(crossFade) {\nintersectionPoint = intersectWithCloudLayer(worldRay, cameraPosition, anchorPointNew);\nworldRayRotated = rotateDirectionToAnchorPoint(rotationCloudsNew, normalize(intersectionPoint));\nworldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);\ncloudData = sampleCloud(worldRayRotatedCorrected, false);\nvec4 cloudColorNew = vec4(calculateCloudColor(cameraPositionN, worldRay, cloudData), cloudData.a);\ncloudColor = mix(cloudColor, cloudColorNew, fadeFactor);\n}\nfloat totalTransmittance = length(cloudColor.rgb) == 0.0 ?\n1.0 :\nclamp(cloudColor.a * cloudsOpacity + (1.0 - cloudsOpacity), 0.0 , 1.0);\nreturn vec4(cloudColor.rgb, totalTransmittance);\n}`)}const h=(t.radius+e)**2;export{m as CloudsParallaxShading};\n", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.34/esri/copyright.txt for details.\n*/\nimport{FoamColor as e}from\"./FoamRendering.glsl.js\";import{Gamma as o}from\"./Gamma.glsl.js\";import{PhysicallyBasedRenderingWater as t}from\"./PhysicallyBasedRendering.glsl.js\";import{distanceFadeStart as r,distanceFadeEnd as i}from\"./ScreenSpaceConstants.js\";import{ScreenSpaceReflections as n}from\"./ScreenSpaceReflections.glsl.js\";import{CloudsParallaxShading as a}from\"../util/CloudsParallaxShading.glsl.js\";import{FloatBindUniform as l}from\"../../shaderModules/FloatBindUniform.js\";import{glsl as d}from\"../../shaderModules/glsl.js\";import{Matrix4BindUniform as c}from\"../../shaderModules/Matrix4BindUniform.js\";import{Texture2DBindUniform as s}from\"../../shaderModules/Texture2DBindUniform.js\";import{ToneMapping as f}from\"../../../shaders/ToneMapping.glsl.js\";function m(m,v){const u=m.fragment;u.include(t,v),u.include(o),u.include(e),v.cloudReflections&&m.include(a),m.include(n,v),u.include(f,v),u.constants.add(\"fresnelSky\",\"vec3\",[.02,1,15]),u.constants.add(\"fresnelMaterial\",\"vec2\",[.02,.1]),u.constants.add(\"roughness\",\"float\",.015),u.constants.add(\"foamIntensityExternal\",\"float\",1.7),u.constants.add(\"ssrIntensity\",\"float\",.65),u.constants.add(\"ssrHeightFadeStart\",\"float\",r),u.constants.add(\"ssrHeightFadeEnd\",\"float\",i),u.constants.add(\"waterDiffusion\",\"float\",.92),u.constants.add(\"waterSeaColorMod\",\"float\",.8),u.constants.add(\"correctionViewingPowerFactor\",\"float\",.4),u.constants.add(\"skyZenitColor\",\"vec3\",[.52,.68,.9]),u.constants.add(\"skyColor\",\"vec3\",[.67,.79,.9]),u.constants.add(\"cloudFresnelModifier\",\"vec2\",[1.2,.01]),u.code.add(d`PBRShadingWater shadingInfo;\nvec3 getSkyGradientColor(in float cosTheta, in vec3 horizon, in vec3 zenit) {\nfloat exponent = pow((1.0 - cosTheta), fresnelSky[2]);\nreturn mix(zenit, horizon, exponent);\n}`),u.uniforms.add(new l(\"lightingSpecularStrength\",e=>e.lighting.mainLight.specularStrength),new l(\"lightingEnvironmentStrength\",e=>e.lighting.mainLight.environmentStrength)),u.code.add(d`vec3 getSeaColor(in vec3 n, in vec3 v, in vec3 l, vec3 color, in vec3 lightIntensity, in vec3 localUp, in float shadow, float foamIntensity, vec3 viewPosition, vec3 position) {\nfloat reflectionHit = 0.0;\nfloat reflectionHitDiffused = 0.0;\nvec3 seaWaterColor = linearizeGamma(color);\nvec3 h = normalize(l + v);\nshadingInfo.NdotV = clamp(dot(n, v), 0.001, 1.0);\nshadingInfo.VdotN = clamp(dot(v, n), 0.001, 1.0);\nshadingInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);\nshadingInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);\nshadingInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);\nfloat upDotV = max(dot(localUp,v), 0.0);\nvec3 skyHorizon = linearizeGamma(skyColor);\nvec3 skyZenit = linearizeGamma(skyZenitColor);\nvec3 skyColor = getSkyGradientColor(upDotV, skyHorizon, skyZenit );\nfloat upDotL = max(dot(localUp,l),0.0);\nfloat daytimeMod = 0.1 + upDotL * 0.9;\nskyColor *= daytimeMod;\nfloat shadowModifier = clamp(shadow, 0.8, 1.0);\nvec3 fresnelModifier = fresnelReflection(shadingInfo.VdotN, vec3(fresnelSky[0]), fresnelSky[1]);\nvec3 reflSky = lightingEnvironmentStrength * fresnelModifier * skyColor * shadowModifier;\nvec3 reflSea = seaWaterColor * mix(skyColor, upDotL * lightIntensity * LIGHT_NORMALIZATION, 2.0 / 3.0) * shadowModifier;\nvec3 specular = vec3(0.0);\nif(upDotV > 0.0 && upDotL > 0.0) {\nvec3 specularSun = brdfSpecularWater(shadingInfo, roughness, vec3(fresnelMaterial[0]), fresnelMaterial[1]);\nvec3 incidentLight = lightIntensity * LIGHT_NORMALIZATION * shadow;\nfloat NdotL = clamp(dot(n, l), 0.0, 1.0);\nspecular = lightingSpecularStrength * NdotL * incidentLight * specularSun;\n}\nvec3 foam = vec3(0.0);\nif(upDotV > 0.0) {\nfoam = foamIntensity2FoamColor(foamIntensityExternal, foamIntensity, skyZenitColor, daytimeMod);\n}\nfloat correctionViewingFactor = pow(max(dot(v, localUp), 0.0), correctionViewingPowerFactor);\nvec3 normalCorrectedClouds = mix(localUp, n, correctionViewingFactor);\nvec3 reflectedWorld = normalize(reflect(-v, normalCorrectedClouds));`),v.cloudReflections&&u.uniforms.add(new l(\"cloudsOpacity\",e=>e.clouds.opacity)).code.add(d`vec4 cloudsColor = renderClouds(reflectedWorld, position);\ncloudsColor.a = 1.0 - cloudsColor.a;\ncloudsColor = pow(cloudsColor, vec4(GAMMA));\ncloudsColor *= clamp(fresnelModifier.y * cloudFresnelModifier[0] - cloudFresnelModifier[1], 0.0, 1.0) * cloudsOpacity;`),v.screenSpaceReflections?u.uniforms.add(new c(\"view\",e=>e.camera.viewMatrix),new s(\"lastFrameColorTexture\",e=>e.ssr.lastFrameColor?.getTexture()),new l(\"fadeFactorSSR\",e=>e.ssr.fadeFactor)).code.add(d`vec3 viewDir = normalize(viewPosition);\nvec4 viewNormalVectorCoordinate = view * vec4(n, 0.0);\nvec3 viewNormal = normalize(viewNormalVectorCoordinate.xyz);\nvec4 viewUp = view * vec4(localUp, 0.0);\nvec3 viewNormalCorrectedSSR = mix(viewUp.xyz, viewNormal, correctionViewingFactor);\nvec3 reflected = normalize(reflect(viewDir, viewNormalCorrectedSSR));\nvec3 hitCoordinate = screenSpaceIntersection(reflected, viewPosition, viewDir, viewUp.xyz);\nvec3 reflectedColor = vec3(0.0);\nif (hitCoordinate.z > 0.0)\n{\nvec2 reprojectedCoordinate = reprojectionCoordinate(hitCoordinate);\nvec2 dCoords = smoothstep(0.3, 0.6, abs(vec2(0.5, 0.5) - hitCoordinate.xy));\nfloat heightMod = smoothstep(ssrHeightFadeEnd, ssrHeightFadeStart, -viewPosition.z);\nreflectionHit = clamp(1.0 - (1.3 * dCoords.y), 0.0, 1.0) * heightMod * fadeFactorSSR;\nreflectionHitDiffused = waterDiffusion * reflectionHit;\nreflectedColor = linearizeGamma(texture(lastFrameColorTexture, reprojectedCoordinate).xyz) *\nreflectionHitDiffused * fresnelModifier.y * ssrIntensity;\n}\nfloat seaColorMod =  mix(waterSeaColorMod, waterSeaColorMod * 0.5, reflectionHitDiffused);\nvec3 waterRenderedColor = tonemapACES((1.0 - reflectionHitDiffused) * reflSky + reflectedColor +\nreflSea * seaColorMod + specular + foam);`):u.code.add(d`vec3 waterRenderedColor = tonemapACES(reflSky + reflSea * waterSeaColorMod + specular + foam);`),v.cloudReflections?v.screenSpaceReflections?u.code.add(d`return waterRenderedColor * (1.0 - (1.0 - reflectionHit) * cloudsColor.a) + (1.0 - reflectionHit) * cloudsColor.xyz;\n}`):u.code.add(d`return waterRenderedColor * (1.0 - cloudsColor.a) + cloudsColor.xyz;\n}`):u.code.add(d`return waterRenderedColor;\n}`)}export{m as Water};\n", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.34/esri/copyright.txt for details.\n*/\nimport{isColorOrColorEmission as e}from\"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js\";import{SliceDraw as r}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{Transform as i}from\"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js\";import{ObjectAndLayerIdColor as o}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/ObjectAndLayerIdColor.glsl.js\";import{OutputHighlight as a}from\"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js\";import{EvaluateAmbientLighting as t}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientLighting.glsl.js\";import{addMainLightDirection as n,addMainLightIntensity as s}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js\";import{NormalUtils as l}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/NormalUtils.glsl.js\";import{ReadShadowMapDraw as d}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js\";import{terrainDepthTest as g}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/TerrainDepthTest.glsl.js\";import{Water as m}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/Water.glsl.js\";import{WaterDistortion as c}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/WaterDistortion.glsl.js\";import{ColorConversion as v}from\"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js\";import{addProjViewLocalOrigin as p,addCameraPosition as w}from\"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";import{Float4PassUniform as u}from\"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";import{FloatPassUniform as f}from\"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";import{glsl as h}from\"../views/3d/webgl-engine/core/shaderModules/glsl.js\";import{outputColorHighlightOID as b}from\"../views/3d/webgl-engine/shaders/OutputColorHighlightOID.glsl.js\";import{ShaderBuilder as y}from\"../views/webgl/ShaderBuilder.js\";import{alphaCutoff as j}from\"../webscene/support/AlphaCutoff.js\";function L(L){const C=new y,{vertex:P,fragment:x,varyings:S}=C,{output:O,draped:D,receiveShadows:M}=L;p(P,L),C.include(i),C.attributes.add(\"position\",\"vec3\"),C.attributes.add(\"uv0\",\"vec2\");const _=new u(\"waterColor\",e=>e.color);if(S.add(\"vpos\",\"vec3\",{invariant:!0}),P.uniforms.add(_),e(O)){if(D)return P.main.add(h`\n      if (waterColor.a < ${h.float(j)}) {\n        // Discard this vertex\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }\n\n      vpos = position;\n      gl_Position = transformPosition(proj, view, vpos);`),x.uniforms.add(_),x.main.add(h`fragColor = waterColor;`),C;C.include(l,L),S.add(\"vuv\",\"vec2\"),S.add(\"vnormal\",\"vec3\"),S.add(\"vtbnMatrix\",\"mat3\"),P.main.add(h`\n      if (waterColor.a < ${h.float(j)}) {\n        // Discard this vertex\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }\n\n      vuv = uv0;\n      vpos = position;\n\n      vnormal = getLocalUp(vpos, localOrigin);\n      vtbnMatrix = getTBNMatrix(vnormal);\n      forwardViewPosDepth((view * vec4(vpos, 1.0)).xyz);\n\n      gl_Position = transformPosition(proj, view, vpos);\n      forwardLinearDepthToReadShadowMap();`)}switch(C.include(d,L),C.include(g,L),O){case 0:case 1:C.include(t,{pbrMode:0,lightingSphericalHarmonicsOrder:2}),C.include(c),C.include(m,L),x.include(r,L),C.include(b,L),x.include(v),w(x,L),n(x),s(x),x.uniforms.add(_,new f(\"timeElapsed\",({timeElapsed:e})=>e),P.uniforms.get(\"view\"),P.uniforms.get(\"localOrigin\")).main.add(h`\n        discardBySlice(vpos);\n        discardByTerrainDepth();\n        vec3 localUp = vnormal;\n        // the created normal is in tangent space\n        vec4 tangentNormalFoam = getSurfaceNormalAndFoam(vuv, timeElapsed);\n\n        // we rotate the normal according to the tangent-bitangent-normal-Matrix\n        vec3 n = normalize(vtbnMatrix * tangentNormalFoam.xyz);\n        vec3 v = -normalize(vpos - cameraPosition);\n        float shadow = ${M?h`1.0 - readShadowMap(vpos, linearDepth)`:\"1.0\"};\n        vec4 vPosView = view * vec4(vpos, 1.0);\n        vec4 final = vec4(getSeaColor(n, v, mainLightDirection, waterColor.rgb, mainLightIntensity, localUp, shadow, tangentNormalFoam.w, vPosView.xyz, vpos + localOrigin), waterColor.w);\n\n        fragColor = delinearizeGamma(final);\n        outputColorHighlightOID(fragColor, vpos, final.rgb);`);break;case 3:C.include(l,L),C.include(c,L),x.include(r,L),S.add(\"vuv\",\"vec2\"),P.main.add(h`\n        if (waterColor.a < ${h.float(j)}) {\n          // Discard this vertex\n          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n          return;\n        }\n\n        vuv = uv0;\n        vpos = position;\n\n        gl_Position = transformPosition(proj, view, vpos);`),x.uniforms.add(new f(\"timeElapsed\",({timeElapsed:e})=>e)).main.add(h`discardBySlice(vpos);\nvec4 tangentNormalFoam = getSurfaceNormalAndFoam(vuv, timeElapsed);\ntangentNormalFoam.xyz = normalize(tangentNormalFoam.xyz);\nfragColor = vec4((tangentNormalFoam.xyz + vec3(1.0)) * 0.5, tangentNormalFoam.w);`);break;case 9:C.include(a,L),P.main.add(h`\n        if (waterColor.a < ${h.float(j)}) {\n          // Discard this vertex\n          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n          return;\n        }\n\n        vpos = position;\n        gl_Position = transformPosition(proj, view, vpos);`),x.include(r,L),x.main.add(h`discardBySlice(vpos);\ncalculateOcclusionAndOutputHighlight();`);break;case 10:C.include(o,L),P.main.add(h`\n        if (waterColor.a < ${h.float(j)}) {\n          // Discard this vertex\n          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n          return;\n        }\n\n        vpos = position;\n        gl_Position = transformPosition(proj, view, vpos);\n        forwardObjectAndLayerIdColor();`),x.include(r,L),x.main.add(h`discardBySlice(vpos);\noutputObjectAndLayerIdColor();`)}return C}const C=Object.freeze(Object.defineProperty({__proto__:null,build:L},Symbol.toStringTag,{value:\"Module\"}));export{C as W,L as b};\n"],
  "mappings": "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",
  "names": ["t", "n", "t", "e", "n", "n", "d", "n", "c", "e", "t", "r", "e", "r", "t", "e", "r", "s", "o", "m", "t", "e", "r", "o", "a", "C", "f", "p", "i", "m", "u", "a", "e", "n", "d", "o", "t", "r", "L", "C", "s", "o", "e", "t", "r", "f", "i", "m", "n", "a", "d"]
}
