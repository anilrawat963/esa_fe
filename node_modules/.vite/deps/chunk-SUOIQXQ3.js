import {
  i as i3
} from "./chunk-QCJFPBRP.js";
import {
  a as a2
} from "./chunk-GD72EK2J.js";
import {
  J as J2
} from "./chunk-VNSHGTPN.js";
import {
  i as i2
} from "./chunk-WHHIH5YU.js";
import {
  p
} from "./chunk-VYMBX5H5.js";
import {
  c
} from "./chunk-3T4IXPP4.js";
import {
  J,
  W
} from "./chunk-2LC2762W.js";
import {
  n
} from "./chunk-75XOUSSS.js";
import {
  f2,
  u4 as u2,
  w
} from "./chunk-PZ5RULLK.js";
import {
  B
} from "./chunk-LTPHDYPK.js";
import {
  e,
  n as n2
} from "./chunk-3OVERDFX.js";
import {
  b as b2
} from "./chunk-AZXJIEZ6.js";
import {
  U,
  l
} from "./chunk-2OFHDVO5.js";
import {
  i
} from "./chunk-TFJXG32O.js";
import {
  f,
  g,
  u
} from "./chunk-CSMCPN64.js";
import {
  b,
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";

// node_modules/@arcgis/core/views/interactive/support/utils.js
function s(s2) {
  let t = 0, a3 = 0, e2 = 0;
  return s2 ? ("cim" === s2.type && s2.data.symbol && "symbolLayers" in s2.data.symbol && s2.data.symbol.symbolLayers && s2.data.symbol.symbolLayers.map((o) => {
    "CIMVectorMarker" === o.type && o.anchorPoint && (Math.abs(o.anchorPoint.x) > t && (t = o.anchorPoint.x), Math.abs(o.anchorPoint.y) > a3 && (a3 = o.anchorPoint.y), null != o.size && o.size > e2 && (e2 = o.size));
  }), t = u(t), a3 = u(a3), e2 = u(e2), { offsetX: t, offsetY: a3, size: e2 }) : { offsetX: t, offsetY: a3, size: e2 };
}

// node_modules/@arcgis/core/views/interactive/GraphicManipulator.js
var S = class extends b {
  set graphic(t) {
    this._circleCollisionCache = null, this._originalSymbol = t.symbol, this._set("graphic", t), this.attachSymbolChanged();
  }
  get elevationInfo() {
    const { layer: t } = this.graphic, e2 = t && "elevationInfo" in t ? t.elevationInfo : null, o = a2(this.graphic), i4 = e2 ? e2.offset : 0;
    return new c({ mode: o, offset: i4 });
  }
  set focusedSymbol(t) {
    t !== this._get("focusedSymbol") && (this._set("focusedSymbol", t), this._updateGraphicSymbol(), this._circleCollisionCache = null);
  }
  grabbableForEvent() {
    return true;
  }
  set grabbing(t) {
    t !== this._get("grabbing") && (this._set("grabbing", t), this._updateGraphicSymbol());
  }
  set hovering(t) {
    t !== this._get("hovering") && (this._set("hovering", t), this._updateGraphicSymbol());
  }
  set selected(t) {
    t !== this._get("selected") && (this._set("selected", t), this._updateGraphicSymbol(), this.events.emit("select-changed", { action: t ? "select" : "deselect" }));
  }
  get _focused() {
    return this._get("hovering") || this._get("grabbing");
  }
  constructor(t) {
    super(t), this.layer = null, this.interactive = true, this.selectable = false, this.grabbable = true, this.dragging = false, this.cursor = null, this.consumesClicks = true, this.events = new i(), this._circleCollisionCache = null, this._graphicSymbolChangedHandle = null, this._originalSymbol = null;
  }
  destroy() {
    this.detachSymbolChanged(), this._resetGraphicSymbol(), this._set("view", null);
  }
  intersectionDistance(t) {
    const e2 = this.graphic;
    if (false === e2.visible) return null;
    const o = e2.geometry;
    if (null == o) return null;
    const i4 = this._get("focusedSymbol"), s2 = null != i4 ? i4 : e2.symbol;
    return "2d" === this.view.type ? this._intersectDistance2D(this.view, t, o, s2) : this._intersectDistance3D(this.view, t, e2);
  }
  attach() {
    this.attachSymbolChanged(), null != this.layer && this.layer.add(this.graphic);
  }
  detach() {
    this.detachSymbolChanged(), this._resetGraphicSymbol(), null != this.layer && this.layer.remove(this.graphic);
  }
  attachSymbolChanged() {
    this.detachSymbolChanged(), this._graphicSymbolChangedHandle = l(() => this.graphic?.symbol, (t) => {
      null != t && t !== this.focusedSymbol && t !== this._originalSymbol && (this._originalSymbol = t, this._focused && null != this.focusedSymbol && (this.graphic.symbol = this.focusedSymbol));
    }, U);
  }
  detachSymbolChanged() {
    null != this._graphicSymbolChangedHandle && (this._graphicSymbolChangedHandle.remove(), this._graphicSymbolChangedHandle = null);
  }
  onElevationChange() {
  }
  onViewChange() {
  }
  _updateGraphicSymbol() {
    this.graphic.symbol = this._focused && null != this.focusedSymbol ? this.focusedSymbol : this._originalSymbol;
  }
  _resetGraphicSymbol() {
    this.graphic.symbol = this._originalSymbol;
  }
  _intersectDistance2D(t, e2, o, i4) {
    if (null == (i4 = i4 || J2(o))) return null;
    const s2 = 1;
    let n3 = this._circleCollisionCache;
    if ("point" === o.type && "cim" === i4.type && "CIMPointSymbol" === i4.data.symbol?.type && i4.data.symbol.symbolLayers) {
      const { offsetX: l2, offsetY: n4, size: a3 } = s(i4), c3 = g(e2, j), p2 = a3 / 2, m3 = t.toScreen(o), u3 = m3.x + l2, y = m3.y + n4;
      return b2(c3, [u3, y]) < p2 * p2 ? s2 : null;
    }
    if ("point" !== o.type || "simple-marker" !== i4.type) return i3(e2, o, t) ? s2 : null;
    if (null == n3 || !n3.originalPoint.equals(o)) {
      const e3 = o, s3 = t.spatialReference;
      if (J(e3.spatialReference, s3)) {
        const t2 = W(e3, s3);
        n3 = { originalPoint: e3.clone(), mapPoint: t2, radiusPx: u(i4.size) }, this._circleCollisionCache = n3;
      }
    }
    if (null != n3) {
      const o2 = g(e2, j), a3 = t.toScreen?.(n3.mapPoint);
      if (!a3) return null;
      const c3 = n3.radiusPx, p2 = a3.x + u(i4.xoffset), m3 = a3.y - u(i4.yoffset);
      return b2(o2, [p2, m3]) < c3 * c3 ? s2 : null;
    }
    return null;
  }
  _intersectDistance3D(t, e2, o) {
    const i4 = t.toMap(e2, { include: [o] });
    return i4 && i2(i4, C, t.renderSpatialReference) ? p(C, t.state.camera.eye) : null;
  }
};
__decorate([m({ constructOnly: true, nonNullable: true })], S.prototype, "graphic", null), __decorate([m()], S.prototype, "elevationInfo", null), __decorate([m({ constructOnly: true, nonNullable: true })], S.prototype, "view", void 0), __decorate([m({ value: null })], S.prototype, "focusedSymbol", null), __decorate([m({ constructOnly: true })], S.prototype, "layer", void 0), __decorate([m()], S.prototype, "interactive", void 0), __decorate([m()], S.prototype, "selectable", void 0), __decorate([m()], S.prototype, "grabbable", void 0), __decorate([m({ value: false })], S.prototype, "grabbing", null), __decorate([m()], S.prototype, "dragging", void 0), __decorate([m()], S.prototype, "hovering", null), __decorate([m({ value: false })], S.prototype, "selected", null), __decorate([m()], S.prototype, "cursor", void 0), S = __decorate([a("esri.views.interactive.GraphicManipulator")], S);
var C = n();
var j = f();

// node_modules/@arcgis/core/views/interactive/editGeometry/operations/curveOperationUtils.js
function m2(r, t, o, m3, p2, u3, l2, a3) {
  const f3 = t ?? o.leftVertex.pos, n3 = u2(r) ? f2(f3, r) : r, [g2, j2, v, x, y, h, U2] = n3.a, b3 = y ?? 0, A = h ?? Math.hypot(g2[0] - j2[0], g2[1] - j2[1]), M = U2 ?? 1, V = c2(m3[0], m3[1], p2[0], p2[1], u3[0], u3[1], l2, a3);
  return w(f3, { a: [g2, j2, v, x, b3, A, M] }, V);
}
function c2(e2, s2, i4, m3, c3, p2, u3, l2) {
  const a3 = n2(1, 0, 0, 0, 1, 0, -e2, -s2, 1), f3 = u3 - 1, n3 = n2(i4 * i4 * f3 + 1, m3 * i4 * f3, 0, i4 * m3 * f3, m3 * m3 * f3 + 1, 0, 0, 0, 1), g2 = l2 - 1, j2 = n2(c3 * c3 * g2 + 1, p2 * c3 * g2, 0, c3 * p2 * g2, p2 * p2 * g2 + 1, 0, 0, 0, 1), v = n2(1, 0, 0, 0, 1, 0, e2, s2, 1), x = e();
  return B(x, n3, a3), B(x, j2, x), B(x, v, x), x;
}

export {
  m2 as m,
  c2 as c,
  s,
  S
};
//# sourceMappingURL=chunk-SUOIQXQ3.js.map
