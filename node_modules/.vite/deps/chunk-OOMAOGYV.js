import {
  W,
  c as c2,
  f3 as f2,
  g,
  o as o3,
  p,
  r as r3,
  x
} from "./chunk-Q4G6BRR7.js";
import {
  e as e3,
  s as s3
} from "./chunk-D6KKUGCT.js";
import {
  l
} from "./chunk-LBWWJ76V.js";
import {
  A,
  G as G2,
  w
} from "./chunk-KDOWKZ3H.js";
import {
  P
} from "./chunk-3RNQTFH6.js";
import {
  ot,
  t as t2
} from "./chunk-F43BIMML.js";
import {
  t
} from "./chunk-ALKEERWI.js";
import {
  I
} from "./chunk-U6CJFTOF.js";
import {
  D
} from "./chunk-OEBAFVQK.js";
import {
  i as i2
} from "./chunk-WHHIH5YU.js";
import {
  f
} from "./chunk-MEDXVTKR.js";
import {
  a as a3,
  r as r2,
  s,
  u as u2
} from "./chunk-ZVTEFYZX.js";
import {
  a as a2,
  m as m2
} from "./chunk-LPUPM55U.js";
import {
  E,
  o as o2,
  s as s2,
  u as u3
} from "./chunk-VYMBX5H5.js";
import {
  d3
} from "./chunk-23NJHA5Q.js";
import {
  C,
  G,
  V,
  Z,
  b,
  d as d2,
  q,
  u
} from "./chunk-HWUOAPTX.js";
import {
  e as e2
} from "./chunk-K2OZ6WVC.js";
import {
  o
} from "./chunk-DTZUXJMD.js";
import {
  n as n3
} from "./chunk-XLOINTMG.js";
import {
  _,
  n as n2,
  r
} from "./chunk-75XOUSSS.js";
import {
  a,
  c,
  m
} from "./chunk-OPJX4KXH.js";
import {
  u as u4
} from "./chunk-CCQFL76O.js";
import {
  d,
  e2 as e
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i
} from "./chunk-QY7XKUIV.js";
import {
  has,
  n
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/renderers/support/RenderingInfo.js
var l2 = class {
  constructor(l4, t7) {
    this.renderer = l4, this.symbol = t7, this.color = null, this.size = null, this.opacity = null, this.outlineSize = null, this.heading = null, this.tilt = null, this.roll = null;
  }
};

// node_modules/@arcgis/core/renderers/support/renderingInfoUtils.js
function i3(e6, t7) {
  if (null != e6.symbol) return e6.symbol;
  const o5 = t7?.renderer;
  return null != o5 && "dot-density" !== o5.type ? o5.getSymbol(e6, t7) : null;
}
function r4(e6, r8) {
  const l4 = i3(e6, r8);
  if (null == l4) return null;
  const n5 = r8?.renderer, a6 = new l2(n5, l4);
  if (null == n5 || !("visualVariables" in n5) || !n5.visualVariables) return a6;
  const s6 = D(n5, e6, r8) ?? [], u8 = ["proportional", "proportional", "proportional"];
  for (const { variable: t7, value: o5 } of s6) if (null != o5 || "size" === t7.type && t7.useSymbolValue) switch (t7.type) {
    case "color":
      a6.color = o5?.toRgba();
      break;
    case "size":
      if ("outline" === t7.target) a6.outlineSize = o5;
      else {
        const e7 = t7.axis, i4 = t7.useSymbolValue ? "symbol-value" : o5 ?? "proportional";
        switch (e7) {
          case "width":
            u8[0] = i4;
            break;
          case "depth":
            u8[1] = i4;
            break;
          case "height":
            u8[2] = i4;
            break;
          case "width-and-depth":
            u8[0] = u8[1] = i4;
            break;
          default:
            u8[0] = u8[1] = u8[2] = i4;
        }
      }
      break;
    case "opacity":
      a6.opacity = o5;
      break;
    case "rotation":
      switch (t7.axis) {
        case "tilt":
          a6.tilt = o5;
          break;
        case "roll":
          a6.roll = o5;
          break;
        default:
          a6.heading = o5;
      }
  }
  return "proportional" === u8[0] && "proportional" === u8[1] && "proportional" === u8[2] || (a6.size = u8), a6;
}
async function l3(e6, t7) {
  return null != e6.symbol ? e6.symbol : t7?.renderer?.getSymbolAsync(e6, t7) ?? null;
}
async function n4(i4, r8) {
  const n5 = await l3(i4, r8);
  if (!n5) return null;
  const a6 = r8?.renderer, s6 = new l2(a6, n5);
  if (!a6 || !("visualVariables" in a6) || !a6.visualVariables) return s6;
  const u8 = D(a6, i4, r8) ?? [], p6 = ["proportional", "proportional", "proportional"];
  for (const { variable: t7, value: o5 } of u8) if ("color" === t7.type) s6.color = u4.toUnitRGBA(o5);
  else if ("size" === t7.type) if ("outline" === t7.target) s6.outlineSize = o5;
  else {
    const e6 = t7.axis, i5 = t7.useSymbolValue ? "symbol-value" : o5;
    "width" === e6 ? p6[0] = i5 : "depth" === e6 ? p6[1] = i5 : "height" === e6 ? p6[2] = i5 : p6[0] = p6[1] = "width-and-depth" === e6 ? i5 : p6[2] = i5;
  }
  else "opacity" === t7.type ? s6.opacity = o5 : "rotation" === t7.type && "tilt" === t7.axis ? s6.tilt = o5 : "rotation" === t7.type && "roll" === t7.axis ? s6.roll = o5 : "rotation" === t7.type && (s6.heading = o5);
  return (isFinite(p6[0]) || isFinite(p6[1]) || isFinite(p6[2])) && (s6.size = p6), s6;
}
function a4(e6, t7 = 0) {
  const o5 = e6[t7];
  return "number" == typeof o5 && isFinite(o5) ? o5 : null;
}
function s4(e6) {
  for (let t7 = 0; t7 < 3; t7++) {
    const o5 = e6[t7];
    if ("number" == typeof o5) return isFinite(o5) ? o5 : 0;
  }
  return 0;
}

// node_modules/@arcgis/core/views/3d/layers/graphics/constants.js
var r5 = 1.2;
var t3 = a3;

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DPathSymbolLayerConstants.js
var o4 = 3;
var t4 = 3;
var c3 = 10;

// node_modules/@arcgis/core/views/3d/layers/graphics/SymbolComplexity.js
var e4 = class {
  constructor(e6) {
    this.estimated = false, this.verticesPerFeature = e6.verticesPerFeature ?? 0, this.verticesPerCoordinate = e6.verticesPerCoordinate ?? 0, this.drawCallsPerFeature = e6.drawCallsPerFeature ?? 0, this.memory = e6.memory ?? new a5();
  }
};
var t5 = class extends e4 {
  constructor(e6) {
    super(e6), this.estimated = true;
  }
};
var s5 = class extends e4 {
  constructor(e6, t7) {
    super(t7), this.numComplexities = e6;
  }
};
var r6 = class extends t5 {
  constructor(e6, t7) {
    super(t7), this.numComplexities = e6;
  }
};
var a5 = class {
  constructor() {
    this.bytesPerFeature = 0, this.bytesPerFeatureLabel = 0, this.resourceBytes = 0, this.draped = { bytesPerFeature: 0, bytesPerFeatureLabel: 0 };
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/defaultSymbolComplexity.js
var P2 = new t5({});
function m3(e6) {
  if ("web-style" === e6.type) return P2;
  return F(e6.symbolLayers.toArray().map((r8) => L(e6, r8)));
}
function F(e6) {
  let r8 = 0, t7 = 0, a6 = 0, s6 = false, u8 = 0;
  const o5 = new a5();
  for (const b4 of e6) null != b4 && (r8 += b4.verticesPerFeature, t7 += b4.verticesPerCoordinate, a6 += b4.drawCallsPerFeature, o5.bytesPerFeature += b4.memory.bytesPerFeature, o5.bytesPerFeatureLabel += b4.memory.bytesPerFeatureLabel, o5.resourceBytes += b4.memory.resourceBytes, o5.draped.bytesPerFeature += b4.memory.bytesPerFeature, o5.draped.bytesPerFeatureLabel += b4.memory.bytesPerFeatureLabel, s6 = s6 || b4.estimated, ++u8);
  return s6 ? new r6(u8, { verticesPerFeature: r8, verticesPerCoordinate: t7, drawCallsPerFeature: a6, memory: o5 }) : new s5(u8, { verticesPerFeature: r8, verticesPerCoordinate: t7, drawCallsPerFeature: a6, memory: o5 });
}
function d4(e6) {
  const r8 = F(e6);
  return r8.numComplexities > 0 && (r8.verticesPerFeature /= r8.numComplexities, r8.verticesPerCoordinate /= r8.numComplexities, r8.drawCallsPerFeature /= r8.numComplexities, r8.memory.bytesPerFeature /= r8.numComplexities, r8.memory.bytesPerFeatureLabel /= r8.numComplexities, r8.memory.resourceBytes /= r8.numComplexities, r8.memory.draped.bytesPerFeature /= r8.numComplexities, r8.memory.draped.bytesPerFeatureLabel /= r8.numComplexities), r8;
}
var p2 = {};
function L(u8, b4) {
  const y2 = C2(u8, b4), i4 = s3(b4) ? 2 : 0;
  switch (b4.type) {
    case "extrude":
      return new e4({ verticesPerFeature: -12, verticesPerCoordinate: 12, drawCallsPerFeature: i4, memory: y2 });
    case "fill":
      if ("mesh-3d" === u8.type) return new e4({ drawCallsPerFeature: i4, memory: y2 });
      if (null != b4.outline && b4.outline.size > 0) return new e4({ verticesPerFeature: -12, verticesPerCoordinate: 9, memory: y2 });
    case "water":
      return new e4({ verticesPerFeature: -6, verticesPerCoordinate: 3, memory: y2 });
    case "line":
      return new e4({ verticesPerFeature: -6, verticesPerCoordinate: 6, memory: y2 });
    case "object":
      return b4.resource?.href ? new t5({ verticesPerFeature: 100, memory: y2 }) : { ...f3(b4.resource?.primitive ?? d3), memory: y2 };
    case "path": {
      let r8 = 0, u9 = 0;
      switch (b4.profile) {
        case "circle":
          r8 = c3;
          break;
        case "quad":
          r8 = 4;
          break;
        default:
          return void n(b4.profile);
      }
      switch (b4.join) {
        case "round":
          u9 = o4;
          break;
        case "miter":
        case "bevel":
          u9 = 1;
          break;
        default:
          return;
      }
      const o5 = 2 * r8, i5 = r8 * u9 * 2, n5 = i5 + o5;
      let l4 = -2 * i5 - o5;
      switch (b4.cap) {
        case "none":
          break;
        case "butt":
        case "square":
          l4 += 2 * (r8 - 1);
          break;
        case "round":
          l4 += 2 * (r8 * (t4 - 1) * 2 + r8);
          break;
        default:
          return;
      }
      return new e4({ verticesPerFeature: l4, verticesPerCoordinate: n5, memory: y2 });
    }
    case "text": {
      const e6 = "label-3d" === u8.type ? 0 : 2;
      return new e4({ verticesPerFeature: 6, memory: y2, drawCallsPerFeature: e6 });
    }
    case "icon":
      return new e4({ verticesPerFeature: 6, memory: y2 });
    default:
      return;
  }
}
function C2(r8, t7) {
  const a6 = "point-3d" === r8.type;
  switch (t7.type) {
    case "extrude":
      return t7.edges && t7.edges.size > 0 ? E2.EXTRUDE_EDGES : E2.EXTRUDE;
    case "fill":
      return null != t7.outline && t7.outline.size > 0 ? E2.FILL_OUTLINE : E2.FILL;
    case "water":
      return E2.FILL;
    case "line":
      return "round" === t7.join ? E2.LINE_ROUND : E2.LINE_MITER;
    case "path":
      switch (t7.join) {
        case "round":
          switch (t7.profile) {
            case "circle":
              return E2.PATH_ROUND_CIRCLE;
            case "quad":
              return E2.PATH_ROUND_QUAD;
            default:
              return void n(t7.profile);
          }
        case "miter":
        case "bevel":
          switch (t7.profile) {
            case "circle":
              return E2.PATH_MITER_CIRCLE;
            case "quad":
              return E2.PATH_MITER_QUAD;
            default:
              return void n(t7.profile);
          }
        default:
          return;
      }
    case "object":
      return a6 ? E2.OBJECT_POINT : E2.OBJECT_POLYGON;
    case "icon":
    case "text":
      return a6 ? E2.ICON_POINT : E2.ICON_POLYGON;
    default:
      return;
  }
}
function f3(e6) {
  const r8 = p2[e6];
  if (r8) return r8;
  const t7 = w2(l(e6, new P({}, { spherical: true })).levels);
  return p2[e6] = new e4({ verticesPerFeature: t7 }), p2[e6];
}
function w2(e6) {
  return e6.reduce((e7, r8, t7) => e7 + r8.numVertices * (1 / 10 ** t7), 0) / e6.reduce((e7, r8, t7) => e7 + 1 / 10 ** t7, 0);
}
var E2 = { ICON_POINT: { bytesPerFeature: 2658, bytesPerFeatureLabel: 3484, resourceBytes: 0, draped: { bytesPerFeature: 1845, bytesPerFeatureLabel: 3498 } }, ICON_POLYGON: { bytesPerFeature: 3086, bytesPerFeatureLabel: 2996, resourceBytes: 0, draped: { bytesPerFeature: 2694, bytesPerFeatureLabel: 3014 } }, OBJECT_POINT: { bytesPerFeature: 497, bytesPerFeatureLabel: 2933, resourceBytes: 0, draped: { bytesPerFeature: 497, bytesPerFeatureLabel: 2933 } }, OBJECT_POLYGON: { bytesPerFeature: 867, bytesPerFeatureLabel: 2491, resourceBytes: 0, draped: { bytesPerFeature: 867, bytesPerFeatureLabel: 2491 } }, LINE_MITER: { bytesPerFeature: 2337, bytesPerFeatureLabel: 2658, resourceBytes: 0, draped: { bytesPerFeature: 1864, bytesPerFeatureLabel: 2656 } }, LINE_ROUND: { bytesPerFeature: 2341, bytesPerFeatureLabel: 2672, resourceBytes: 0, draped: { bytesPerFeature: 1873, bytesPerFeatureLabel: 2643 } }, PATH_MITER_CIRCLE: { bytesPerFeature: 22374, bytesPerFeatureLabel: 2558, resourceBytes: 0, draped: { bytesPerFeature: 22374, bytesPerFeatureLabel: 2558 } }, PATH_ROUND_CIRCLE: { bytesPerFeature: 24004, bytesPerFeatureLabel: 2598, resourceBytes: 0, draped: { bytesPerFeature: 24004, bytesPerFeatureLabel: 2598 } }, PATH_MITER_QUAD: { bytesPerFeature: 24040, bytesPerFeatureLabel: 2940, resourceBytes: 0, draped: { bytesPerFeature: 24040, bytesPerFeatureLabel: 2940 } }, PATH_ROUND_QUAD: { bytesPerFeature: 23088, bytesPerFeatureLabel: 2886, resourceBytes: 0, draped: { bytesPerFeature: 23088, bytesPerFeatureLabel: 2886 } }, FILL: { bytesPerFeature: 3059, bytesPerFeatureLabel: 2838, resourceBytes: 0, draped: { bytesPerFeature: 2352, bytesPerFeatureLabel: 2808 } }, FILL_OUTLINE: { bytesPerFeature: 3093, bytesPerFeatureLabel: 2632, resourceBytes: 0, draped: { bytesPerFeature: 2480, bytesPerFeatureLabel: 2601 } }, EXTRUDE: { bytesPerFeature: 5075, bytesPerFeatureLabel: 2559, resourceBytes: 0, draped: { bytesPerFeature: 5075, bytesPerFeatureLabel: 2559 } }, EXTRUDE_EDGES: { bytesPerFeature: 2843, bytesPerFeatureLabel: 2139, resourceBytes: 0, draped: { bytesPerFeature: 2843, bytesPerFeatureLabel: 2139 } } };
if (has("esri-tests-disable-symbol-memory-estimators")) for (const _3 in E2) {
  const e6 = E2[_3];
  e6.bytesPerFeature = 0, e6.bytesPerFeatureLabel = 0, e6.draped.bytesPerFeature = 0, e6.draped.bytesPerFeatureLabel = 0;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/GeometryWithMapPositions.js
function e5(o5) {
  return null != o5.mapPositions;
}

// node_modules/@arcgis/core/views/3d/layers/graphics/ElevationAligners.js
function f4(t7, e6, o5, n5, r8) {
  const a6 = t7.stageObject, s6 = a6.geometries;
  let i4 = 0;
  for (const l4 of s6) {
    if (!e5(l4)) continue;
    const { update: t8, averageGeometrySampledElevation: s7 } = M(l4, e6, o5, n5, r8);
    i4 += s7, t8 && a6.geometryVertexAttributeUpdated(l4, "position");
  }
  return i4 / s6.length;
}
function u5(e6, n5, a6, s6, m8, c4) {
  const f6 = e6.stageObject, u8 = n5.centerInElevationSR;
  let g5 = 0;
  if (s6(u8, E3), f6.usesVerticalDistanceToGround) p(f6, E3.verticalDistanceToGround), g5 = E3.sampledElevation;
  else {
    "absolute-height" !== n5.mode && (g5 = E3.sampledElevation);
  }
  const d7 = n3(p3, c4 ?? f6.transformation), I3 = o2(v, d7[12], d7[13], d7[14]);
  t2.TESTS_DISABLE_OPTIMIZATIONS ? (T[0] = u8[0], T[1] = u8[1], T[2] = E3.z, f(a6, T, d7, m8.spatialReference) && (c4 ? n3(c4, d7) : f6.transformation = d7)) : m8.setAltitudeOfTransformation(E3.z, d7);
  const S2 = b2 / m8.unitInMeters;
  return (Math.abs(d7[12] - I3[0]) >= S2 || Math.abs(d7[13] - I3[1]) >= S2 || Math.abs(d7[14] - I3[2]) >= S2) && (c4 ? n3(c4, d7) : f6.transformation = d7), g5;
}
var p3 = e2();
function g2(t7, e6, n5, a6, s6) {
  const i4 = t7.graphics3DSymbolLayer.lodRenderer;
  if (null == i4) return 0;
  const m8 = e6.centerInElevationSR;
  a6(m8, E3);
  const c4 = "absolute-height" !== e6.mode ? E3.sampledElevation : 0, f6 = i4.instanceData, u8 = t7.instanceIndex, p6 = h;
  f6.getGlobalTransform(u8, p6);
  const g5 = o2(v, p6[12], p6[13], p6[14]);
  t2.TESTS_DISABLE_OPTIMIZATIONS ? (T[0] = m8[0], T[1] = m8[1], T[2] = E3.z, f(n5, T, p6, s6.spatialReference) && f6.setGlobalTransform(u8, p6)) : s6.setAltitudeOfTransformation(E3.z, p6);
  const d7 = b2 / s6.unitInMeters;
  return (t2.TESTS_DISABLE_OPTIMIZATIONS || Math.abs(p6[12] - g5[0]) >= d7 || Math.abs(p6[13] - g5[1]) >= d7 || Math.abs(p6[14] - g5[2]) >= d7) && f6.setGlobalTransform(u8, p6), c4;
}
function d5(t7, e6, o5, n5, r8) {
  const a6 = t7.stageObject, s6 = a6.geometries;
  if (0 === s6.length) return 0;
  let i4 = 0, l4 = null, m8 = 0, f6 = false;
  for (const u8 of s6) {
    if (!e5(u8)) continue;
    const t8 = u8.attributes.get("position");
    if (t8 !== l4) {
      const { update: a7, averageGeometrySampledElevation: s7 } = M(u8, e6, o5, n5, r8);
      m8 = s7, l4 = t8, f6 = a7;
    }
    f6 && a6.geometryVertexAttributeUpdated(u8, "position"), i4 += m8;
  }
  return i4 / s6.length;
}
var b2 = 0.01;
var T = n2();
var I2 = n2();
var S = n2();
var h = e2();
var v = n2();
var E3 = new x();
function M(t7, e6, o5, n5, r8) {
  let s6 = false;
  const i4 = t7.transformation, c4 = e6.requiresSampledElevationInfo;
  I2[0] = i4[12], I2[1] = i4[13], I2[2] = i4[14], t7.invalidateBoundingInfo();
  const f6 = t7.getMutableAttribute("position"), u8 = f6.data, p6 = f6.size, g5 = u8.length / p6, d7 = new r3(t7.mapPositions, o5);
  let h2 = 0, v3 = 0;
  for (let m8 = 0; m8 < g5; m8++) {
    if (S[0] = u8[h2], S[1] = u8[h2 + 1], S[2] = u8[h2 + 2], n5(d7, E3), c4 && (v3 += E3.sampledElevation), t2.TESTS_DISABLE_OPTIMIZATIONS) u8[h2] = d7.array[d7.offset], u8[h2 + 1] = d7.array[d7.offset + 1], u8[h2 + 2] = E3.z, o(u8, o5, h2, u8, r8.spatialReference, h2, 1), u8[h2] -= I2[0], u8[h2 + 1] -= I2[1], u8[h2 + 2] -= I2[2], s6 = true;
    else {
      T[0] = u8[h2] + I2[0], T[1] = u8[h2 + 1] + I2[1], T[2] = u8[h2 + 2] + I2[2], r8.setAltitude(T, E3.z), u8[h2] = T[0] - I2[0], u8[h2 + 1] = T[1] - I2[1], u8[h2 + 2] = T[2] - I2[2];
      const t8 = b2 / r8.unitInMeters;
      (Math.abs(S[0] - u8[h2]) >= t8 || Math.abs(S[1] - u8[h2 + 1]) >= t8 || Math.abs(S[2] - u8[h2 + 2]) >= t8) && (s6 = true);
    }
    h2 += p6, d7.offset += 3;
  }
  return v3 /= g5, { update: s6, averageGeometrySampledElevation: v3 };
}

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DObject3DGraphicLayer.js
var u6 = class {
  constructor(e6, t7, i4) {
    this.baseMaterial = e6, this.edgeMaterial = t7, this.hasSlicePlane = i4;
  }
};
var O = class {
  get isElevationSource() {
    return !!this.stageObject.lastValidElevationBB;
  }
  constructor(e6, t7, i4, s6, a6, n5 = null) {
    this.graphics3DSymbolLayer = e6, this.stageObject = t7, this._sharedResource = i4, this.elevationAligner = s6, this.elevationContext = a6, this._edgeState = n5, this.type = "object3d", this._stageLayer = null, this._visible = false, this._addedToStage = false, this.alignedSampledElevation = 0, this.needsElevationUpdates = false, this.useObjectOriginAsAttachmentOrigin = false;
  }
  initialize(e6) {
    this._stageLayer = e6;
  }
  destroy() {
    if (!this._stageLayer) return;
    const e6 = this._stageLayer.stage;
    this._addedToStage && (this._stageLayer.remove(this.stageObject), this._addedToStage = false), e6.renderer.edgeView?.removeObject(this.stageObject), this.stageObject.dispose(), this._sharedResource?.release(), this._visible = false, this._stageLayer = null;
  }
  get usedMemory() {
    return this.graphics3DSymbolLayer.usedMemory;
  }
  layerOpacityChanged(e6, t7) {
    const { stageObject: i4, _edgeState: s6, _stageLayer: a6 } = this;
    if (null == s6) return;
    const n5 = j(s6.baseMaterial);
    s6.edgeMaterial.objectTransparency !== n5 && (s6.edgeMaterial.objectTransparency = n5, this.resetEdgeObject(t7)), a6.stage.renderer.withEdgeView((t8) => t8.updateAllComponentOpacities(i4, [e6]));
  }
  updateHighlights(e6) {
  }
  slicePlaneEnabledChanged(e6, t7) {
    const { stageObject: i4, _edgeState: s6, _stageLayer: a6 } = this;
    null != s6 && a6.stage.renderer.withEdgeView((a7) => {
      a7.updateAllComponentMaterials(i4, s6.edgeMaterial, e6, !t7), s6.hasSlicePlane = e6;
    });
  }
  setVisibility(e6) {
    const { _edgeState: t7, stageObject: i4, _stageLayer: s6 } = this;
    null != s6 && this.visible !== e6 && (this._visible = e6, i4.visible = e6, e6 && !this._addedToStage && (s6.add(i4), this._addedToStage = true), null != t7 && s6.stage.renderer.withEdgeView((s7) => {
      s7.hasObject(i4) ? s7.updateObjectVisibility(i4, e6) : e6 && this._addOrUpdateEdgeObject(t7, s7, false);
    }));
  }
  get visible() {
    return this._visible;
  }
  alignWithElevation(e6, t7, i4) {
    if (null == this.elevationAligner) return;
    const s6 = (i5, s7) => c2(i5, e6, this.elevationContext, t7, s7);
    this.alignedSampledElevation = this.elevationAligner(this, this.elevationContext, e6.spatialReference, s6, t7), this.resetEdgeObject(i4);
  }
  alignWithAbsoluteElevation(e6, t7, i4) {
    const s6 = (t8, i5) => {
      i5.sampledElevation = e6, i5.verticalDistanceToGround = 0, i5.z = e6;
    };
    this.alignedSampledElevation = this.elevationAligner(this, this.elevationContext, this.graphics3DSymbolLayer.view.spatialReference, s6, t7), this.resetEdgeObject(i4);
  }
  getCenterObjectSpace(t7 = n2()) {
    return s2(t7, I(this.stageObject.boundingVolumeObjectSpace.bounds));
  }
  getBoundingBoxObjectSpace(e6 = u()) {
    const t7 = this.stageObject.boundingVolumeObjectSpace;
    return Z(e6, t7.min), d2(e6, t7.max), e6;
  }
  computeAttachmentOrigin(e6) {
    const s6 = this.stageObject.effectiveTransformation;
    if (this.useObjectOriginAsAttachmentOrigin) e6.render.origin[0] += s6[12], e6.render.origin[1] += s6[13], e6.render.origin[2] += s6[14], e6.render.num++;
    else for (const a6 of this.stageObject.geometries) a6.computeAttachmentOrigin(v2) && (E(v2, v2, s6), u3(e6.render.origin, e6.render.origin, v2), e6.render.num++);
  }
  async getProjectedBoundingBox(e6, i4, s6, a6, n5) {
    const r8 = this.getBoundingBoxObjectSpace(n5), h2 = y, d7 = C(r8) ? 1 : h2.length;
    for (let o5 = 0; o5 < d7; o5++) {
      const e7 = h2[o5];
      p4[0] = r8[e7[0]], p4[1] = r8[e7[1]], p4[2] = r8[e7[2]], E(p4, p4, this.stageObject.transformation), m5[3 * o5] = p4[0], m5[3 * o5 + 1] = p4[1], m5[3 * o5 + 2] = p4[2];
    }
    if (!e6(m5, 0, d7)) return null;
    q(r8);
    let u8 = null;
    this.calculateRelativeScreenBounds && (u8 = this.calculateRelativeScreenBounds());
    for (let t7 = 0; t7 < 3 * d7; t7 += 3) {
      for (let e7 = 0; e7 < 3; e7++) r8[e7] = Math.min(r8[e7], m5[t7 + e7]), r8[e7 + 3] = Math.max(r8[e7 + 3], m5[t7 + e7]);
      u8 && s6.push({ location: m5.slice(t7, t7 + 3), screenSpaceBoundingRect: u8 });
    }
    if (i4?.service && "absolute-height" !== this.elevationContext.mode) {
      b(r8, v2);
      const e7 = "relative-to-scene" === this.elevationContext.mode ? "scene" : "ground";
      let t7 = 0;
      if (i4.useViewElevation) t7 = i4.service.getElevation(v2[0], v2[1], e7) ?? 0;
      else try {
        const s7 = G2(r8, i4.service.spatialReference, i4);
        t7 = await i4.service.queryElevation(v2[0], v2[1], a6, s7, e7) ?? 0;
      } catch (O3) {
      }
      G(r8, 0, 0, -this.alignedSampledElevation + t7);
    }
    return r8;
  }
  addObjectState(e6) {
    0 === e6.stateType && e6.addObject(this.stageObject, this.stageObject.highlight(e6.highlightName)), 1 === e6.stateType && e6.addObject(this.stageObject, this.stageObject.maskOccludee());
  }
  removeObjectState(e6) {
    e6.removeByObject(this.stageObject);
  }
  resetEdgeObject(e6) {
    const { _edgeState: t7, stageObject: i4, _stageLayer: s6, _visible: a6 } = this;
    null != t7 && s6.stage.renderer.withEdgeView((s7) => {
      a6 ? this._addOrUpdateEdgeObject(t7, s7, e6) : s7.removeObject(i4);
    });
  }
  _addOrUpdateEdgeObject(e6, t7, i4) {
    const s6 = j(e6.baseMaterial);
    e6.edgeMaterial.objectTransparency = s6, t7.addOrUpdateObject3D(this.stageObject, e6.edgeMaterial, e6.hasSlicePlane, !i4).then(() => this._stageLayer?.sync());
  }
};
function j(e6) {
  return e6.transparent ? 0 : 1;
}
var m5 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
var p4 = n2();
var v2 = n2();
var y = [[0, 1, 2], [3, 1, 2], [0, 4, 2], [3, 4, 2], [0, 1, 5], [3, 1, 5], [0, 4, 5], [3, 4, 5]];

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DObjectMetadata.js
var t6 = class {
  constructor(t7, e6 = null) {
    this.labelText = e6, this.elevationOffset = t7 ?? 0;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Loadable.js
var r7 = class {
  constructor(t7) {
    this.schedule = t7, this._abortController = null, this._loadStatus = 0, this._loadError = null, this._loader = null, this.logger = null;
  }
  destroy() {
    this.abortLoad();
  }
  get loadStatus() {
    return this._loadStatus;
  }
  load(t7, r8) {
    return 1 === this._loadStatus ? (t7 && t7(), this._loader ?? Promise.resolve()) : 2 === this._loadStatus ? (r8 && r8(this._loadError), this._loader ?? Promise.resolve()) : (null == this._loader && (this._abortController = new AbortController(), this._loader = this.doLoad(this._abortController.signal).then(() => {
      this._abortController = null, this._loadStatus = 1;
    }, (t8) => {
      throw this._loadError = t8, this._abortController = null, this._loadStatus = 2, !d(t8) && this.logger && t8.message && this.logger.warn(t8.message), t8;
    })), this._loader.then(t7, r8).catch(() => {
    }), this._loader);
  }
  abortLoad() {
    null != this._abortController ? this._abortController = e(this._abortController) : 0 === this._loadStatus && (this._loadStatus = 2), this._loader = null;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/Graphics3DSymbolLayer.js
var g3 = () => i.getLogger("esri.views.3d.layers.graphics.Graphics3DSymbolLayer");
var m6 = class extends r7 {
  constructor(e6, t7, r8, i4, o5 = true) {
    super(r8.schedule), this.symbol = e6, this.symbolLayer = t7, this._context = r8, this._drivenOpacityFallbackAlwaysOpaque = o5, this.ignoreDrivers = false, this._drivenProperties = { color: false, opacity: false, opacityAlwaysOpaque: true, size: false, rotation: false }, this._materials = [], this.logger = g3(), this._elevationOptions = { supportsOffsetAdjustment: false, supportsOnTheGround: true }, this.skipHighSymbolLodsChanged = true, this._renderPriority = i4.renderPriority, this._renderPriorityStep = i4.renderPriorityStep, this._elevationContext = new o3(), this.updateComplexity(), this.ignoreDrivers = i4.ignoreDrivers, this.ignoreDrivers || (this._drivenProperties = _2(this._context.renderer, o5)), this._updateElevationContext();
  }
  destroy() {
    this.complexity = null, this._materials.length = 0, super.destroy();
  }
  get view() {
    return this._context.stage.view;
  }
  getCachedSize() {
    return null;
  }
  get extentPadding() {
    return 0;
  }
  get materials() {
    return this._materials;
  }
  get estimatedMemory() {
    const { complexity: e6 } = this;
    if (null == e6) return 0;
    return (this.draped ? e6.memory.draped : e6.memory).bytesPerFeature;
  }
  get usedMemory() {
    return this.estimatedMemory;
  }
  _drivenPropertiesChanged(e6) {
    if (this.ignoreDrivers) return false;
    const t7 = this._drivenProperties, r8 = _2(e6, this._drivenOpacityFallbackAlwaysOpaque);
    return r8.color !== t7.color || r8.opacity !== t7.opacity || r8.opacityAlwaysOpaque !== t7.opacityAlwaysOpaque || r8.size !== t7.size || r8.rotation !== t7.rotation;
  }
  get needsDrivenTransparentPass() {
    return this._hasDrivenColorOrOpacity && !this._drivenProperties.opacityAlwaysOpaque;
  }
  get _hasDrivenColorOrOpacity() {
    return this._drivenProperties.color || this._drivenProperties.opacity;
  }
  _logGeometryCreationWarnings(e6, t7, r8, i4) {
    const o5 = e6.projectionSuccess, s6 = "polygons" in e6 ? e6.polygons : null, n5 = `${i4} geometry failed to be created`;
    o5 ? !this._logGeometryValidationWarnings(t7, r8, i4) && s6 && 0 === s6.length && "rings" === r8 && t7.length > 0 && t7[0].length > 2 && g3().warnOncePerTick(`${n5} (filled rings should use clockwise winding - try reversing the order of vertices)`) : g3().warnOncePerTick(`${n5} (failed to project geometry to view spatial reference)`);
  }
  get needsUpdateFocus() {
    return false;
  }
  _logGeometryValidationWarnings(e6, t7, r8) {
    const i4 = `${r8} geometry failed to be created`;
    return !e6.length || 1 === e6.length && !e6[0].length ? (g3().warnOncePerTick(`${i4} (no ${t7} were defined)`), true) : (!Array.isArray(e6) || !Array.isArray(e6[0])) && (g3().warnOncePerTick(`${i4} (${t7} should be defined as a 2D array)`), true);
  }
  _validateGeometry(e6, t7 = null, r8 = null) {
    if (null != t7 && !t7.includes(e6.type)) return this.logger.warn("unsupported geometry type for " + r8 + ` symbol: ${e6.type}`), false;
    switch (e6.type) {
      case "point": {
        const t8 = e6;
        if (!isFinite(t8.x) || !isFinite(t8.y)) return g3().warn("point coordinate is not a valid number, graphic skipped"), false;
        break;
      }
      case "polygon":
        m(e6);
    }
    return true;
  }
  _defaultElevationInfoNoZ() {
    return x2;
  }
  _defaultElevationInfoZ() {
    return C3;
  }
  _updateElevationContext() {
    null != this._elevationInfoOverride ? (this._elevationContext.setFromElevationInfo(this._elevationInfoOverride), this._elevationContext.setFeatureExpressionInfoContext(null)) : this._context.layer.elevationInfo ? (this._elevationContext.setFromElevationInfo(this._context.layer.elevationInfo), this._elevationContext.setFeatureExpressionInfoContext(this._context.featureExpressionInfoContext)) : this._elevationContext.reset();
  }
  getDefaultElevationInfo(e6) {
    return e6.hasZ ? this._defaultElevationInfoZ() : this._defaultElevationInfoNoZ();
  }
  getGeometryElevationMode(e6, t7 = this.getDefaultElevationInfo(e6)) {
    return this._elevationContext.mode || t7.mode;
  }
  setElevationInfoOverride(e6) {
    this._elevationInfoOverride = e6, this._updateElevationContext();
  }
  createElevationContextForGraphic(e6) {
    const t7 = new o3();
    return this.updateElevationContextForGraphic(t7, e6), t7;
  }
  updateElevationContextForGraphic(e6, t7) {
    const r8 = t7.geometry, i4 = this.getDefaultElevationInfo(r8);
    e6.unit = null != this._elevationContext.unit ? this._elevationContext.unit : i4.unit, e6.mode = this.getGeometryElevationMode(r8, i4), e6.offsetMeters = this._elevationContext.meterUnitOffset ?? i4.offset ?? 0;
    const o5 = !this._elevationOptions.supportsOnTheGround && "on-the-ground" === e6.mode;
    o5 && (e6.mode = "relative-to-ground", e6.offsetMeters = 0);
    const s6 = o5 ? f2 : this._elevationContext.featureExpressionInfoContext;
    s6 ? e6.updateFeatureExpressionInfoContextForGraphic(s6, t7, this._context.layer) : e6.setFeatureExpressionInfoContext(null);
  }
  prepareSymbolLayerPatch(e6) {
  }
  onRemoveGraphic(e6) {
  }
  _getLayerOpacity() {
    if (this._context.graphicsCoreOwner && "fullOpacity" in this._context.graphicsCoreOwner) return this._context.graphicsCoreOwner.fullOpacity ?? 0;
    const e6 = this._context.layer.opacity;
    return e6 ?? 1;
  }
  _getCombinedOpacity(e6, t7 = b3) {
    const r8 = this.draped ? 1 : this._getLayerOpacity();
    return this._drivenProperties.color ? r8 : e6 ? r8 * (this._drivenProperties.opacity ? 1 : e6.a) : t7.hasIntrinsicColor ? r8 : 0;
  }
  _getCombinedOpacityAndColor(t7, i4 = b3) {
    const o5 = this._getCombinedOpacity(t7, i4);
    if (this._drivenProperties.color) return A(null, o5);
    const s6 = null != t7 ? u4.toUnitRGB(t7) : _;
    return A(s6, o5);
  }
  _getDrivenUInt8Color({ color: t7, opacity: r8 }, i4, o5) {
    const { color: s6, opacity: l4 } = this._drivenProperties, p6 = u4.toUnitRGBA(i4) ?? (o5 ? s : a3), c4 = s6 ? t7 ?? p6 : null, d7 = t7 || i4 || o5, h2 = s6 ? null : p6[3];
    return A(c4, l4 && d7 ? r8 ?? h2 : null, 255);
  }
  _getDrivenUInt8ColorWithNaNSupport({ color: t7, opacity: r8 }, n5, a6) {
    const p6 = n5 ? u2(u4.toUnitRGBA(n5)) : r2(NaN, NaN, NaN, a6 ? NaN : 0);
    return this._drivenProperties.color && null != t7 && a2(p6, t7), this._drivenProperties.opacity && null != r8 && (p6[3] = r8), m2(p6, p6, 255), e3(p6, p6);
  }
  isFastUpdatesEnabled() {
    return null != this._fastUpdates;
  }
  updateComplexity() {
    this.complexity = this.computeComplexity();
  }
  computeComplexity() {
    return L(this.symbol, this.symbolLayer);
  }
  globalPropertyChanged(e6, t7, r8) {
    switch (e6) {
      case "opacity":
        return this.layerOpacityChanged(t7, r8), true;
      case "screenSizePerspectiveEnabled":
        return this.layerScreenSizePerspectiveChanged(t7, r8), true;
      case "elevationInfo": {
        const e7 = this._elevationContext.mode;
        this._updateElevationContext();
        return 2 !== this.layerElevationInfoChanged(t7, r8, e7);
      }
      case "slicePlaneEnabled":
        return this.slicePlaneEnabledChanged(t7, r8);
      case "physicalBasedRenderingEnabled":
        return this.physicalBasedRenderingChanged();
      case "pixelRatio":
        return this.pixelRatioChanged;
      case "skipHighSymbolLods":
        return this.skipHighSymbolLodsChanged;
      default:
        return false;
    }
  }
  get pixelRatioChanged() {
    return true;
  }
  updateGraphics3DGraphicElevationInfo(e6, t7, r8) {
    let i4 = 1;
    return e6?.forEach((e7) => {
      const o5 = t7(e7);
      if (null != o5) {
        const t8 = e7.graphic;
        this.updateElevationContextForGraphic(o5.elevationContext, t8), o5.needsElevationUpdates = r8(o5.elevationContext.mode);
      } else i4 = 2;
    }), i4;
  }
  applyRendererDiff(e6, t7) {
    return 0;
  }
  getFastUpdateAttrValues(e6) {
    if (!this._fastUpdates) return null;
    const t7 = this._fastUpdates.visualVariables, r8 = t7.size ? ot(t7.size.field, e6) : 0, i4 = t7.color ? ot(t7.color.field, e6) : 0, o5 = t7.opacity ? ot(t7.opacity.field, e6) : 0;
    return r2(r8, i4, o5, 0);
  }
  get draped() {
    return this._draped;
  }
  ensureDrapedStatus(e6) {
    return null == this._draped ? (this._draped = e6, true) : (e6 !== this.draped && g3().warnOnce("A symbol can only produce either draped or non-draped visualizations. Use two separate symbol instances for draped and non-draped graphics if necessary."), false);
  }
  test() {
    const e6 = () => ({ size: this._fastUpdates?.visualVariables.size?.field ?? null, color: this._fastUpdates?.visualVariables.color?.field ?? null, opacity: this._fastUpdates?.visualVariables.opacity?.field ?? null, rotation: this._fastUpdates?.visualVariables.rotation?.field ?? null });
    return { drivenProperties: this._drivenProperties, getVisVarFields: e6 };
  }
};
function _2(e6, t7) {
  const r8 = { color: false, opacity: false, opacityAlwaysOpaque: t7, size: false, rotation: false };
  return e6 && "visualVariables" in e6 && e6.visualVariables && e6.visualVariables.forEach((e7) => {
    switch (e7.type) {
      case "color":
        if (r8.color = true, e7.stops) for (let t8 = 0; t8 < e7.stops.length; t8++) {
          const i4 = e7.stops[t8].color;
          i4 && i4.a < 1 && (r8.opacityAlwaysOpaque = false);
        }
        break;
      case "opacity":
        r8.opacity = true, r8.opacityAlwaysOpaque = false;
        break;
      case "size":
        r8.size = true;
        break;
      case "rotation":
        r8.rotation = true;
    }
  }), r8;
}
var x2 = { mode: "on-the-ground", offset: 0, unit: "meters" };
var C3 = { mode: "absolute-height", offset: 0, unit: "meters" };
var b3 = { hasIntrinsicColor: false };
var O2 = r2(NaN, NaN, NaN, NaN);

// node_modules/@arcgis/core/views/3d/layers/graphics/pointUtils.js
function p5(e6, r8, t7, o5, n5) {
  if (m7(e6, r8)) return null;
  t7.localOrigin = g4(e6, r8);
  const i4 = new W({ geometries: [t7], castShadow: false, layerViewUid: e6.layerViewUid, graphicUid: n5, usesVerticalDistanceToGround: true });
  return { object: i4, sampledElevation: g(i4, r8, e6.elevationProvider, e6.renderCoordsHelper, o5) };
}
function u7(e6, r8, t7, o5) {
  if (m7(r8, t7)) return null;
  return g(e6, t7, r8.elevationProvider, r8.renderCoordsHelper, o5);
}
function m7(e6, r8) {
  const n5 = e6.clippingExtent;
  return !!n5 && (i2(r8, j2, e6.elevationProvider.spatialReference), !V(n5, j2));
}
function f5(e6, o5, n5) {
  const i4 = e6.elevationContext, s6 = n5.spatialReference;
  i2(o5, j2, s6), i4.centerInElevationSR = r(j2[0], j2[1], o5.hasZ ? j2[2] : 0);
}
function d6(e6) {
  switch (e6.type) {
    case "point":
      return e6;
    case "polygon":
    case "extent":
      return w(e6);
    case "polyline": {
      const r8 = e6.paths[0];
      if (!r8 || 0 === r8.length) return null;
      const t7 = a(r8, c(r8) / 2);
      return t(t7[0], t7[1], t7[2], e6.spatialReference);
    }
    case "mesh":
      return e6.extent.center;
  }
  return null;
}
function g4(e6, r8) {
  return i2(r8, j2, e6.renderCoordsHelper.spatialReference), e6.localOriginFactory.getOrigin(j2);
}
var j2 = n2();

export {
  l2 as l,
  r4 as r,
  n4 as n,
  a4 as a,
  s4 as s,
  r5 as r2,
  t3 as t,
  o4 as o,
  t4 as t2,
  c3 as c,
  e4 as e,
  P2 as P,
  m3 as m,
  F,
  d4 as d,
  C2 as C,
  w2 as w,
  e5 as e2,
  f4 as f,
  u5 as u,
  g2 as g,
  d5 as d2,
  u6 as u2,
  O,
  t6 as t3,
  r7 as r3,
  m6 as m2,
  O2,
  p5 as p,
  u7 as u3,
  f5 as f2,
  d6 as d3,
  g4 as g2
};
//# sourceMappingURL=chunk-OOMAOGYV.js.map
