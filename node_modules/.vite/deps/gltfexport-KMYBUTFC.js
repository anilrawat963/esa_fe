import {
  u
} from "./chunk-7EFQIJSP.js";
import "./chunk-YJPRACXY.js";
import {
  t as t3
} from "./chunk-KBVQCWWY.js";
import {
  N,
  T
} from "./chunk-GVMCGYZ6.js";
import {
  e as e2,
  r,
  t as t2
} from "./chunk-JHV6OBEB.js";
import {
  q
} from "./chunk-274P3DJ3.js";
import "./chunk-2WMZLC2C.js";
import "./chunk-HHDWMGJ3.js";
import "./chunk-WHHIH5YU.js";
import "./chunk-MEDXVTKR.js";
import "./chunk-5LMH6D7V.js";
import "./chunk-BZLHV37L.js";
import "./chunk-V6V3WWJF.js";
import "./chunk-NDFIZYZY.js";
import "./chunk-TLTSPUO7.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import "./chunk-WCWUUHUV.js";
import {
  R
} from "./chunk-QNVJVDYZ.js";
import "./chunk-WDTGOP77.js";
import {
  A,
  H,
  _ as _2,
  c,
  o
} from "./chunk-VYMBX5H5.js";
import "./chunk-K2OZ6WVC.js";
import "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-XLOINTMG.js";
import "./chunk-T7F6Q6JJ.js";
import {
  _,
  a,
  n,
  t
} from "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-3FUHCAX3.js";
import "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import "./chunk-CCQFL76O.js";
import {
  p
} from "./chunk-GY6YF4EN.js";
import "./chunk-7H3U4IJR.js";
import {
  s as s3
} from "./chunk-SMWUT52Z.js";
import "./chunk-AXZMNHTN.js";
import "./chunk-5T3MJDSR.js";
import "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import {
  ot,
  tt
} from "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import "./chunk-5EI5H4QX.js";
import "./chunk-ZIE53VIV.js";
import "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import {
  e
} from "./chunk-4DGC7CBY.js";
import {
  s as s2
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  L
} from "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/asset.js
var s4 = class {
  constructor() {
    this.copyright = "", this.defaultScene = 0, this.generator = "", this._scenes = [];
  }
  addScene(e5) {
    if (this._scenes.includes(e5)) throw new Error("Scene already added");
    this._scenes.push(e5);
  }
  removeScene(s6) {
    L(this._scenes, s6);
  }
  forEachScene(e5) {
    this._scenes.forEach(e5);
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/glb.js
var _t = class _t {
  constructor(e5, h) {
    if (!e5) throw new Error("GLB requires a JSON gltf chunk");
    this._length = _t.HEADER_SIZE, this._length += _t.CHUNK_HEADER_SIZE;
    const s6 = i2(e5);
    if (this._length += n2(s6.byteLength, 4), h && (this._length += _t.CHUNK_HEADER_SIZE, this._length += h.byteLength, h.byteLength % 4)) throw new Error("Expected BIN chunk length to be divisible by 4 at this point");
    this.buffer = new ArrayBuffer(this._length), this._outView = new DataView(this.buffer), this._writeHeader();
    const r3 = this._writeChunk(s6, 12, 1313821514, 32);
    h && this._writeChunk(h, r3, 5130562);
  }
  _writeHeader() {
    this._outView.setUint32(0, _t.MAGIC, true), this._outView.setUint32(4, _t.VERSION, true), this._outView.setUint32(8, this._length, true);
  }
  _writeChunk(t6, i6, h, s6 = 0) {
    const r3 = n2(t6.byteLength, 4);
    for (this._outView.setUint32(i6, r3, true), this._outView.setUint32(i6 += 4, h, true), e3(this._outView.buffer, t6, i6 += 4, 0, t6.byteLength), i6 += t6.byteLength; i6 % 4; ) s6 && this._outView.setUint8(i6, s6), i6++;
    return i6;
  }
};
_t.HEADER_SIZE = 12;
_t.CHUNK_HEADER_SIZE = 8;
_t.MAGIC = 1179937895;
_t.VERSION = 2;
var t4 = _t;
function e3(t6, e5, i6, n3, h) {
  new Uint8Array(t6, i6, h).set(new Uint8Array(e5, n3, h), 0);
}
function i2(t6) {
  return new TextEncoder().encode(t6).buffer;
}
function n2(t6, e5) {
  return e5 * Math.ceil(t6 / e5);
}

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/bufferview.js
var t5 = class {
  constructor(e5, t6, s6, i6, r3) {
    this._buffer = e5, this._componentType = s6, this._dataType = i6, this._data = [], this._isFinalized = false, this._accessorIndex = -1, this._accessorAttribute = null, this._accessorMin = null, this._accessorMax = null, t6.bufferViews || (t6.bufferViews = []), this.index = t6.bufferViews.length, this._bufferView = { buffer: e5.index, byteLength: -1, target: r3 };
    const n3 = this._getElementSize();
    n3 >= 4 && 34963 !== r3 && (this._bufferView.byteStride = n3), t6.bufferViews.push(this._bufferView), this._numComponentsForDataType = this._calculateNumComponentsForDataType();
  }
  push(e5) {
    const t6 = this._data.length;
    if (this._data.push(e5), this._accessorIndex >= 0) {
      const s6 = t6 % this._numComponentsForDataType, i6 = this._accessorMin[s6];
      this._accessorMin[s6] = "number" != typeof i6 ? e5 : Math.min(i6, e5);
      const r3 = this._accessorMax[s6];
      this._accessorMax[s6] = "number" != typeof r3 ? e5 : Math.max(r3, e5);
    }
  }
  get dataSize() {
    return this._data.length * this._sizeComponentType();
  }
  get byteSize() {
    function e5(e6, t6) {
      return t6 * Math.ceil(e6 / t6);
    }
    return e5(this.dataSize, 4);
  }
  getByteOffset() {
    if (!this._isFinalized) throw new Error("Cannot get BufferView offset until it is finalized");
    return this._buffer.getByteOffset(this);
  }
  get byteOffset() {
    if (!this._isFinalized) throw new Error("Cannot get BufferView offset until it is finalized");
    return this._buffer.getByteOffset(this);
  }
  _createTypedArray(t6, s6) {
    switch (this._componentType) {
      case R.BYTE:
        return new Int8Array(t6, s6);
      case R.FLOAT:
        return new Float32Array(t6, s6);
      case R.SHORT:
        return new Int16Array(t6, s6);
      case R.UNSIGNED_BYTE:
        return new Uint8Array(t6, s6);
      case R.UNSIGNED_INT:
        return new Uint32Array(t6, s6);
      case R.UNSIGNED_SHORT:
        return new Uint16Array(t6, s6);
    }
  }
  writeOutToBuffer(e5, t6) {
    this._createTypedArray(e5, t6).set(this._data);
  }
  writeAsync(e5) {
    if (this._asyncWritePromise) throw new Error("Can't write multiple bufferView values asynchronously");
    return this._asyncWritePromise = e5.then((e6) => {
      const t6 = new Uint8Array(e6);
      for (let s6 = 0; s6 < t6.length; ++s6) this._data.push(t6[s6]);
      delete this._asyncWritePromise;
    }), this._asyncWritePromise;
  }
  startAccessor(e5) {
    if (this._accessorIndex >= 0) throw new Error("Accessor was started without ending the previous one");
    this._accessorIndex = this._data.length, this._accessorAttribute = e5;
    const t6 = this._numComponentsForDataType;
    this._accessorMin = new Array(t6), this._accessorMax = new Array(t6);
  }
  endAccessor() {
    if (this._accessorIndex < 0) throw new Error("An accessor was not started, but was attempted to be ended");
    const t6 = this._getElementSize(), s6 = this._numComponentsForDataType, i6 = (this._data.length - this._accessorIndex) / s6;
    if (i6 % 1) throw new Error("An accessor was ended with missing component values");
    for (let e5 = 0; e5 < this._accessorMin.length; ++e5) "number" != typeof this._accessorMin[e5] && (this._accessorMin[e5] = 0), "number" != typeof this._accessorMax[e5] && (this._accessorMax[e5] = 0);
    const r3 = { byteOffset: t6 * (this._accessorIndex / s6), componentType: this._componentType, count: i6, type: this._dataType, min: this._accessorMin, max: this._accessorMax, name: this._accessorAttribute };
    switch (this._accessorAttribute) {
      case "TEXCOORD_0":
      case "TEXCOORD_1":
      case "COLOR_0":
      case "WEIGHTS_0":
        switch (this._componentType) {
          case R.UNSIGNED_BYTE:
          case R.UNSIGNED_SHORT:
            r3.normalized = true;
        }
    }
    return this._accessorIndex = -1, this._accessorAttribute = null, this._accessorMin = null, this._accessorMax = null, r3;
  }
  get finalized() {
    return this._finalizedPromise ? this._finalizedPromise : this._isFinalized ? this._finalizedPromise = Promise.resolve() : this._finalizedPromise = new Promise((e5) => this._finalizedPromiseResolve = e5);
  }
  async finalize() {
    const e5 = this._bufferView, t6 = this._buffer.getViewFinalizePromises(this);
    this._asyncWritePromise && t6.push(this._asyncWritePromise), await Promise.allSettled(t6), this._isFinalized = true, e5.byteOffset = this.getByteOffset(), e5.byteLength = this.dataSize, this._finalizedPromiseResolve && this._finalizedPromiseResolve();
  }
  _getElementSize() {
    return this._sizeComponentType() * this._numComponentsForDataType;
  }
  _sizeComponentType() {
    switch (this._componentType) {
      case R.BYTE:
      case R.UNSIGNED_BYTE:
        return 1;
      case R.SHORT:
      case R.UNSIGNED_SHORT:
        return 2;
      case R.UNSIGNED_INT:
      case R.FLOAT:
        return 4;
    }
  }
  _calculateNumComponentsForDataType() {
    switch (this._dataType) {
      case "SCALAR":
        return 1;
      case "VEC2":
        return 2;
      case "VEC3":
        return 3;
      case "VEC4":
      case "MAT2":
        return 4;
      case "MAT3":
        return 9;
      case "MAT4":
        return 16;
    }
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/buffer.js
var i3 = class {
  constructor(e5) {
    this._gltf = e5, this._bufferViews = [], this._isFinalized = false, e5.buffers || (e5.buffers = []), this.index = e5.buffers.length;
    const i6 = { byteLength: -1 };
    e5.buffers.push(i6), this._buffer = i6;
  }
  addBufferView(i6, t6, r3) {
    if (this._finalizePromise) throw new Error("Cannot add buffer view after fiinalizing buffer");
    const f3 = new t5(this, this._gltf, i6, t6, r3);
    return this._bufferViews.push(f3), f3;
  }
  getByteOffset(e5) {
    let i6 = 0;
    for (const t6 of this._bufferViews) {
      if (t6 === e5) return i6;
      i6 += t6.byteSize;
    }
    throw new Error("Given bufferView was not present in this buffer");
  }
  getViewFinalizePromises(e5) {
    const i6 = [];
    for (const t6 of this._bufferViews) {
      if (e5 && t6 === e5) return i6;
      i6.push(t6.finalized);
    }
    return i6;
  }
  getArrayBuffer() {
    if (!this._isFinalized) throw new Error("Cannot get ArrayBuffer from Buffer before it is finalized");
    const e5 = this._getTotalSize(), i6 = new ArrayBuffer(e5);
    let t6 = 0;
    for (const r3 of this._bufferViews) r3.writeOutToBuffer(i6, t6), t6 += r3.byteSize;
    return i6;
  }
  finalize() {
    if (this._finalizePromise) throw new Error(`Buffer ${this.index} was already finalized`);
    return this._finalizePromise = Promise.allSettled(this.getViewFinalizePromises()).then(() => {
      this._isFinalized = true;
      const e5 = this.getArrayBuffer();
      this._buffer.byteLength = e5.byteLength, this._buffer.uri = e5;
    }), this._gltf.extras.promises.push(this._finalizePromise), this._finalizePromise;
  }
  _getTotalSize() {
    let e5 = 0;
    for (const i6 of this._bufferViews) e5 += i6.byteSize;
    return e5;
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/geometry.js
function r2(o3, n3) {
  if (o3.components) for (const t6 of o3.components) t6.faces && "smooth" === t6.shading && c2(t6.faces, n3);
}
function c2(e5, r3) {
  null == r3.normal && (r3.normal = new Float32Array(r3.position.length));
  const { position: c5, normal: m3 } = r3, p2 = e5.length / 3;
  for (let s6 = 0; s6 < p2; ++s6) {
    const r4 = 3 * e5[3 * s6], l3 = 3 * e5[3 * s6 + 1], p3 = 3 * e5[3 * s6 + 2], h = o(a2, c5[r4], c5[r4 + 1], c5[r4 + 2]), g = o(i4, c5[l3], c5[l3 + 1], c5[l3 + 2]), u3 = o(f, c5[p3], c5[p3 + 1], c5[p3 + 2]), j = c(g, g, h), v = c(u3, u3, h), x = _2(j, j, v);
    m3[r4] += x[0], m3[r4 + 1] += x[1], m3[r4 + 2] += x[2], m3[l3] += x[0], m3[l3 + 1] += x[1], m3[l3 + 2] += x[2], m3[p3] += x[0], m3[p3 + 1] += x[1], m3[p3 + 2] += x[2];
  }
  for (let n3 = 0; n3 < m3.length; n3 += 3) o(l, m3[n3], m3[n3 + 1], m3[n3 + 2]), A(l, l), m3[n3] = l[0], m3[n3 + 1] = l[1], m3[n3 + 2] = l[2];
}
var a2 = n();
var i4 = n();
var f = n();
var l = n();

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/imageutils.js
function a3(e5) {
  const t6 = m(e5);
  return null != t6 ? t6.toDataURL() : "";
}
async function i5(n3, r3) {
  const a4 = m(n3);
  if (null == a4) throw new s("imageToArrayBuffer", "Unsupported image type");
  const i6 = o2(n3), s6 = await new Promise((e5) => a4.toBlob(e5, i6));
  if (s2(r3), !s6) throw new s("imageToArrayBuffer", "Failed to encode image");
  const c5 = await s6.arrayBuffer();
  return s2(r3), { data: c5, type: i6 };
}
function o2(e5) {
  if (!(e5 instanceof HTMLImageElement)) return "image/png";
  const t6 = e5.src;
  if (tt(t6)) {
    const e6 = ot(t6);
    return "image/jpeg" === e6?.mediaType ? e6.mediaType : "image/png";
  }
  return /\.png$/i.test(t6) ? "image/png" : /\.(jpg|jpeg)$/i.test(t6) ? "image/jpeg" : "image/png";
}
function m(e5) {
  if (e5 instanceof HTMLCanvasElement) return e5;
  if (e5 instanceof HTMLVideoElement) return null;
  const t6 = document.createElement("canvas");
  t6.width = e5.width, t6.height = e5.height;
  const n3 = t6.getContext("2d");
  return e5 instanceof HTMLImageElement ? n3.drawImage(e5, 0, 0, e5.width, e5.height) : e5 instanceof ImageData && n3.putImageData(e5, 0, 0), t6;
}
function s5(e5) {
  const t6 = [], n3 = new Uint8Array(e5);
  for (let r3 = 0; r3 < n3.length; r3++) t6.push(String.fromCharCode(n3[r3]));
  return "data:application/octet-stream;base64," + btoa(t6.join(""));
}
function c3(e5) {
  if (e5.byteLength < 8) return false;
  const t6 = new Uint8Array(e5);
  return 137 === t6[0] && 80 === t6[1] && 78 === t6[2] && 71 === t6[3] && 13 === t6[4] && 10 === t6[5] && 26 === t6[6] && 10 === t6[7];
}

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/gltf.js
var b = () => i.getLogger("esri.geometry.support.meshUtils.exporters.gltf.gltf");
var _3 = class {
  constructor(e5, t6) {
    this.options = t6, this._materialMap = new Array(), this._imageMap = /* @__PURE__ */ new Map(), this._textureMap = /* @__PURE__ */ new Map(), this.gltf = { asset: { version: "2.0", copyright: e5.copyright, generator: e5.generator }, extras: { output: t6.output, binChunkBuffer: null, promises: [] } }, this._addScenes(e5);
  }
  _addScenes(e5) {
    this.gltf.scene = e5.defaultScene;
    const t6 = this.gltf.extras, s6 = 2 === t6.output.buffer || 2 === t6.output.image;
    s6 && (t6.binChunkBuffer = new i3(this.gltf)), e5.forEachScene((e6) => {
      this._addScene(e6);
    }), s6 && t6.binChunkBuffer.finalize();
  }
  _addScene(e5) {
    this.gltf.scenes || (this.gltf.scenes = []);
    const t6 = {};
    e5.name && (t6.name = e5.name), e5.forEachNode((e6) => {
      t6.nodes || (t6.nodes = []), t6.nodes.push(...this._addNodes(e6));
    }), this.gltf.scenes.push(t6);
  }
  _addNodes(e5) {
    this.gltf.nodes || (this.gltf.nodes = []);
    const t6 = {};
    e5.name && (t6.name = e5.name);
    const s6 = e5.translation;
    H(s6, a) || (t6.translation = t(s6));
    const r3 = e5.rotation;
    N(r3, r) || (t6.rotation = t2(r3));
    const h = e5.scale;
    H(h, _) || (t6.scale = t(h));
    const f3 = this.gltf.nodes.length;
    if (this.gltf.nodes.push(t6), e5.mesh && e5.mesh.vertexAttributes.position) {
      const s7 = this._createMeshes(e5.mesh), r4 = [f3];
      if (1 === s7.length) this._addMesh(t6, s7[0]);
      else for (const e6 of s7) {
        const t7 = {};
        this._addMesh(t7, e6), r4.push(this.gltf.nodes.length), this.gltf.nodes.push(t7);
      }
      return r4;
    }
    return e5.forEachNode((e6) => {
      t6.children || (t6.children = []), t6.children.push(...this._addNodes(e6));
    }), [f3];
  }
  _addMesh(e5, t6) {
    this.gltf.meshes ??= [];
    const s6 = this.gltf.meshes.length;
    this.gltf.meshes.push(t6), e5.mesh = s6;
  }
  _createMeshes(e5) {
    const t6 = this.gltf.extras, s6 = 2 === t6.output.buffer;
    let r3;
    r3 = s6 ? t6.binChunkBuffer : new i3(this.gltf);
    const i6 = this.options.origin, o3 = e5.vertexSpace.clone();
    o3.origin = [i6.x, i6.y, i6.z ?? 0];
    const a4 = q({ vertexAttributes: e5.vertexAttributes, vertexSpace: e5.vertexSpace, transform: this.options?.ignoreLocalTransform ? null : e5.transform, spatialReference: e5.spatialReference }, o3, { targetUnit: this.options.unitConversionDisabled ? void 0 : "meters" });
    if (!a4) return [];
    r2(e5, a4), M(a4);
    const { position: n3, normal: l3, tangent: c5 } = a4, { uv: u3, color: h } = e5.vertexAttributes, d2 = r3.addBufferView(R.FLOAT, "VEC3", 34962);
    let g, x, b2, _4;
    l3 && (g = r3.addBufferView(R.FLOAT, "VEC3", 34962)), u3 && (x = r3.addBufferView(R.FLOAT, "VEC2", 34962)), c5 && (b2 = r3.addBufferView(R.FLOAT, "VEC4", 34962)), h && (_4 = r3.addBufferView(R.FLOAT, "VEC4", 34962)), d2.startAccessor("POSITION"), g && g.startAccessor("NORMAL"), x && x.startAccessor("TEXCOORD_0"), b2 && b2.startAccessor("TANGENT"), _4 && _4.startAccessor("COLOR_0");
    const A3 = a4.position.length / 3;
    for (let f3 = 0; f3 < A3; ++f3) d2.push(n3[3 * f3]), d2.push(n3[3 * f3 + 1]), d2.push(n3[3 * f3 + 2]), g && null != l3 && (g.push(l3[3 * f3]), g.push(l3[3 * f3 + 1]), g.push(l3[3 * f3 + 2])), x && null != u3 && (x.push(u3[2 * f3]), x.push(u3[2 * f3 + 1])), b2 && null != c5 && (b2.push(c5[4 * f3]), b2.push(c5[4 * f3 + 1]), b2.push(c5[4 * f3 + 2]), b2.push(c5[4 * f3 + 3])), _4 && null != h && (_4.push(w(h[4 * f3] / 255)), _4.push(w(h[4 * f3 + 1] / 255)), _4.push(w(h[4 * f3 + 2] / 255)), _4.push(h[4 * f3 + 3] / 255));
    const O = d2.endAccessor(), v = this._addAccessor(d2.index, O);
    let R2, N2, C, S, I;
    if (g) {
      const e6 = g.endAccessor();
      R2 = this._addAccessor(g.index, e6);
    }
    if (x) {
      const e6 = x.endAccessor();
      N2 = this._addAccessor(x.index, e6);
    }
    if (b2) {
      const e6 = b2.endAccessor();
      C = this._addAccessor(b2.index, e6);
    }
    if (_4) {
      const e6 = _4.endAccessor();
      S = this._addAccessor(_4.index, e6);
    }
    const y = [];
    return e5.components && e5.components.length > 0 && e5.components[0].faces ? (I = r3.addBufferView(R.UNSIGNED_INT, "SCALAR", 34963), this._addMeshVertexIndexed(I, e5.components, y, v, R2, N2, C, S)) : this._addMeshVertexNonIndexed(e5.components, y, v, R2, N2, C, S), d2.finalize(), g?.finalize(), x?.finalize(), b2?.finalize(), I?.finalize(), _4?.finalize(), s6 || r3.finalize(), y;
  }
  _addMaterial(e5) {
    if (null == e5) return;
    const t6 = this._materialMap.indexOf(e5);
    if (-1 !== t6) return t6;
    this.gltf.materials || (this.gltf.materials = []);
    const s6 = {};
    switch (e5.alphaMode) {
      case "mask":
        s6.alphaMode = "MASK";
        break;
      case "auto":
      case "blend":
        s6.alphaMode = "BLEND";
    }
    s6.alphaCutoff = e5.alphaCutoff, e5.doubleSided && (s6.doubleSided = e5.doubleSided), s6.pbrMetallicRoughness = {};
    const r3 = (e6) => {
      const t7 = e6.toRgba();
      return t7[0] = w(t7[0] / 255), t7[1] = w(t7[1] / 255), t7[2] = w(t7[2] / 255), t7;
    };
    if (null != e5.color && (s6.pbrMetallicRoughness.baseColorFactor = r3(e5.color)), null != e5.colorTexture && (s6.pbrMetallicRoughness.baseColorTexture = this._createTextureInfo(e5.colorTexture, e5.colorTextureTransform)), null != e5.normalTexture && (s6.normalTexture = this._createTextureInfo(e5.normalTexture, e5.normalTextureTransform)), e5 instanceof u) {
      if (null != e5.emissiveTexture && (s6.emissiveTexture = this._createTextureInfo(e5.emissiveTexture, e5.emissiveTextureTransform)), null != e5.emissiveColor) {
        const t7 = r3(e5.emissiveColor);
        s6.emissiveFactor = [t7[0], t7[1], t7[2]];
      }
      null != e5.occlusionTexture && (s6.occlusionTexture = this._createTextureInfo(e5.occlusionTexture, e5.occlusionTextureTransform)), null != e5.metallicRoughnessTexture && (s6.pbrMetallicRoughness.metallicRoughnessTexture = this._createTextureInfo(e5.metallicRoughnessTexture, e5.metallicRoughnessTextureTransform)), s6.pbrMetallicRoughness.metallicFactor = e5.metallic, s6.pbrMetallicRoughness.roughnessFactor = e5.roughness;
    } else s6.pbrMetallicRoughness.metallicFactor = 1, s6.pbrMetallicRoughness.roughnessFactor = 1, b().warnOnce("Meshes exported to GLTF without MeshMaterialMetallicRoughness material will appear different when imported back.");
    const i6 = this.gltf.materials.length;
    return this.gltf.materials.push(s6), this._materialMap.push(e5), i6;
  }
  _createTextureInfo(e5, t6) {
    const s6 = { index: this._addTexture(e5) };
    return t6 ? (s6.extensions || (s6.extensions = {}), s6.extensions.KHR_texture_transform = { scale: t6.scale, offset: t6.offset, rotation: s3(t6.rotation) }, s6) : s6;
  }
  _addTexture(e5) {
    const t6 = this.gltf.textures ?? [];
    return this.gltf.textures = t6, e(this._textureMap, e5, () => {
      const s6 = { sampler: this._addSampler(e5), source: this._addImage(e5) }, r3 = t6.length;
      return t6.push(s6), r3;
    });
  }
  _addImage(e5) {
    const t6 = this._imageMap.get(e5);
    if (null != t6) return t6;
    this.gltf.images || (this.gltf.images = []);
    const s6 = {};
    if (e5.url) s6.uri = e5.url;
    else {
      const t7 = e5.data;
      s6.extras = t7;
      for (let e6 = 0; e6 < this.gltf.images.length; ++e6) if (t7 === this.gltf.images[e6].extras) return e6;
      const r4 = this.gltf.extras;
      switch (r4.output.image) {
        case 2: {
          const e6 = r4.binChunkBuffer.addBufferView(R.UNSIGNED_BYTE, "SCALAR");
          if (t3(t7)) null != t7.data && e6.writeOutToBuffer(t7.data.buffer, 0);
          else {
            const i6 = i5(t7, this.options.signal).then(({ data: e7, type: t8 }) => (s6.mimeType = t8, e7));
            r4.promises.push(e6.writeAsync(i6).then(() => e6.finalize()));
          }
          s6.bufferView = e6.index;
          break;
        }
        case 1:
          if (t3(t7)) {
            b().warnOnce("Image export for basis compressed textures not available.");
            break;
          }
          s6.uri = a3(t7);
          break;
        default:
          if (t3(t7)) {
            b().warnOnce("Image export for basis compressed textures not available.");
            break;
          }
          r4.promises.push(i5(t7, this.options.signal).then(({ data: e6, type: t8 }) => {
            s6.uri = e6, s6.mimeType = t8;
          }));
      }
    }
    const r3 = this.gltf.images.length;
    return this.gltf.images.push(s6), this._imageMap.set(e5, r3), r3;
  }
  _addSampler(e5) {
    this.gltf.samplers || (this.gltf.samplers = []);
    let t6 = 10497, s6 = 10497;
    if ("string" == typeof e5.wrap) switch (e5.wrap) {
      case "clamp":
        t6 = 33071, s6 = 33071;
        break;
      case "mirror":
        t6 = 33648, s6 = 33648;
    }
    else {
      switch (e5.wrap.vertical) {
        case "clamp":
          s6 = 33071;
          break;
        case "mirror":
          s6 = 33648;
      }
      switch (e5.wrap.horizontal) {
        case "clamp":
          t6 = 33071;
          break;
        case "mirror":
          t6 = 33648;
      }
    }
    const r3 = { wrapS: t6, wrapT: s6 };
    for (let o3 = 0; o3 < this.gltf.samplers.length; ++o3) if (JSON.stringify(r3) === JSON.stringify(this.gltf.samplers[o3])) return o3;
    const i6 = this.gltf.samplers.length;
    return this.gltf.samplers.push(r3), i6;
  }
  _addAccessor(e5, t6) {
    this.gltf.accessors || (this.gltf.accessors = []);
    const s6 = { bufferView: e5, byteOffset: t6.byteOffset, componentType: t6.componentType, count: t6.count, type: t6.type, min: t6.min, max: t6.max, name: t6.name };
    t6.normalized && (s6.normalized = true);
    const r3 = this.gltf.accessors.length;
    return this.gltf.accessors.push(s6), r3;
  }
  _addMeshVertexIndexed(e5, t6, s6, r3, i6, o3, a4, n3) {
    const l3 = /* @__PURE__ */ new Map();
    for (const c5 of t6) {
      if (e5.startAccessor("INDICES"), c5.faces) for (let s7 = 0; s7 < c5.faces.length; ++s7) e5.push(c5.faces[s7]);
      const t7 = e5.endAccessor(), u3 = { attributes: { POSITION: r3 }, indices: this._addAccessor(e5.index, t7), material: this._addMaterial(c5.material) };
      i6 && "flat" !== c5.shading && (u3.attributes.NORMAL = i6), o3 && (u3.attributes.TEXCOORD_0 = o3), a4 && "flat" !== c5.shading && (u3.attributes.TANGENT = a4), n3 && (u3.attributes.COLOR_0 = n3);
      const h = l3.get(c5.name);
      if (h) h.primitives.push(u3);
      else {
        const e6 = { name: c5.name, primitives: [u3] };
        l3.set(c5.name, e6), s6.push(e6);
      }
    }
  }
  _addMeshVertexNonIndexed(e5, t6, s6, r3, i6, o3, a4) {
    const n3 = { primitives: [] };
    t6.push(n3);
    const l3 = { attributes: { POSITION: s6 } };
    r3 && (l3.attributes.NORMAL = r3), i6 && (l3.attributes.TEXCOORD_0 = i6), o3 && (l3.attributes.TANGENT = o3), a4 && (l3.attributes.COLOR_0 = a4), e5 && (l3.material = this._addMaterial(e5[0].material)), n3.primitives.push(l3);
  }
};
function M({ position: e5, normal: t6, tangent: s6 }) {
  A2(e5, 3), A2(t6, 3), A2(s6, 4);
}
function A2(e5, t6) {
  if (null != e5) for (let s6 = 1, r3 = 2; s6 < e5.length; s6 += t6, r3 += t6) {
    const t7 = e5[s6], i6 = e5[r3];
    e5[s6] = i6, e5[r3] = -t7;
  }
}
function w(t6) {
  return t6 ** p;
}

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/node.js
var e4 = class {
  constructor(t6) {
    this.mesh = t6, this.name = "", this.translation = n(), this.rotation = e2(), this.scale = t(_), this._nodes = [];
  }
  addNode(t6) {
    if (this._nodes.includes(t6)) throw new Error("Node already added");
    this._nodes.push(t6);
  }
  forEachNode(t6) {
    this._nodes.forEach(t6);
  }
  set rotationAngles(s6) {
    T(this.rotation, s6[0], s6[1], s6[2]);
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/scene.js
var d = class {
  constructor() {
    this.name = "", this._nodes = [];
  }
  addNode(d2) {
    if (this._nodes.includes(d2)) throw new Error("Node already added");
    this._nodes.push(d2);
  }
  forEachNode(d2) {
    this._nodes.forEach(d2);
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/gltfexport.js
var f2 = "model.gltf";
var u2 = "model.glb";
async function c4(e5, s6) {
  const a4 = new _3(e5, s6).gltf, c5 = a4.extras.promises;
  let m3 = 1, l3 = 1, p2 = null;
  await Promise.allSettled(c5), s2(s6.signal);
  const g = s6.jsonSpacing ?? 4, d2 = /* @__PURE__ */ new Map(), w2 = JSON.stringify(a4, (t6, e6) => {
    if ("extras" !== t6) {
      if (e6 instanceof ArrayBuffer) {
        if (c3(e6)) switch (s6.output?.image) {
          case 1:
          case 2:
            break;
          default: {
            const t7 = `img${l3}.png`;
            return l3++, d2.set(t7, e6), t7;
          }
        }
        switch (s6.output?.buffer) {
          case 1:
            return s5(e6);
          case 2:
            if (p2) throw new Error("Already encountered an ArrayBuffer, there should only be one in the GLB format.");
            return void (p2 = e6);
          default: {
            const t7 = `data${m3}.bin`;
            return m3++, d2.set(t7, e6), t7;
          }
        }
      }
      return e6;
    }
  }, g);
  return 2 === s6.output?.buffer || 2 === s6.output?.image ? d2.set(u2, new t4(w2, p2).buffer) : d2.set(f2, w2), d2;
}
async function m2(t6, e5) {
  const r3 = (await c4(t6, { output: { buffer: 2, image: 2 }, jsonSpacing: 0, ...e5 })).get(u2);
  if (!(r3 && r3 instanceof ArrayBuffer)) throw new Error("failed to export to glb");
  return r3;
}
async function l2(t6, r3) {
  const o3 = new s4(), n3 = new d();
  return o3.addScene(n3), n3.addNode(new e4(t6)), await m2(o3, { origin: t6.origin, ...r3 });
}
export {
  c4 as exportGLTF,
  u2 as modelNameGlb,
  f2 as modelNameGltf,
  l2 as toBinaryGLTF
};
//# sourceMappingURL=gltfexport-KMYBUTFC.js.map
