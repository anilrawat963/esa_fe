import {
  y
} from "./chunk-QNW4D2V2.js";
import {
  b
} from "./chunk-647DAMHU.js";
import {
  f as f2
} from "./chunk-GD4FJL3C.js";
import {
  o
} from "./chunk-W6HOAVT4.js";
import {
  l
} from "./chunk-TFJXG32O.js";
import {
  f
} from "./chunk-5T3MJDSR.js";
import {
  Bt,
  H2 as H
} from "./chunk-V2H77UEV.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  $,
  T
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/layers/support/StreamConnection.js
var i2 = class extends l {
  destroy() {
    this.emit("destroy");
  }
  get connectionError() {
    return this.errorString ? new s("stream-connection", this.errorString) : null;
  }
  onFeature(r2) {
    this.emit("data-received", r2);
  }
  onMessage(r2) {
    this.emit("message-received", r2);
  }
};
__decorate([m({ readOnly: true })], i2.prototype, "connectionError", null), i2 = __decorate([a("esri.layers.support.StreamConnection")], i2);

// node_modules/@arcgis/core/layers/graphics/sources/connections/WebSocketConnection.js
var h = class extends i2 {
  constructor(e) {
    super({}), this._outstandingMessages = [], this.errorString = null;
    const { geometryType: t, spatialReference: o3, sourceSpatialReference: s2 } = e;
    this._config = e, this._featureZScaler = o(t, s2, o3), this._open();
  }
  normalizeCtorArgs() {
    return {};
  }
  async _open() {
    await this._tryCreateWebSocket(), this.destroyed || await this._handshake();
  }
  destroy() {
    super.destroy(), null != this._websocket && (this._websocket.onopen = null, this._websocket.onclose = null, this._websocket.onerror = null, this._websocket.onmessage = null, this._websocket.close()), this._websocket = null;
  }
  get connectionStatus() {
    if (null == this._websocket) return "disconnected";
    switch (this._websocket.readyState) {
      case 0:
      case 1:
        return "connected";
      case 2:
      case 3:
        return "disconnected";
    }
  }
  sendMessageToSocket(e) {
    null != this._websocket ? this._websocket.send(JSON.stringify(e)) : this._outstandingMessages.push(e);
  }
  sendMessageToClient(e) {
    this._onMessage(e);
  }
  updateCustomParameters(e) {
    this._config.customParameters = e, null != this._websocket && this._websocket.close();
  }
  async _tryCreateWebSocket(e = this._config.source.path, r2 = 1e3, i3 = 0) {
    try {
      if (this.destroyed) return;
      const t = Bt(e, this._config.customParameters ?? {});
      this._websocket = await this._createWebSocket(t), this.notifyChange("connectionStatus");
    } catch (c) {
      const n = r2 / 1e3;
      return this._config.maxReconnectionAttempts && i3 >= this._config.maxReconnectionAttempts ? (i.getLogger(this).error(new s("websocket-connection", "Exceeded maxReconnectionAttempts attempts. No further attempts will be made")), void this.destroy()) : (i.getLogger(this).error(new s("websocket-connection", `Failed to connect. Attempting to reconnect in ${n}s`, c)), await T(r2), this._tryCreateWebSocket(e, Math.min(1.5 * r2, 1e3 * this._config.maxReconnectionInterval), i3 + 1));
    }
  }
  _setWebSocketJSONParseHandler(e) {
    e.onmessage = (e2) => {
      try {
        const t = JSON.parse(e2.data);
        this._onMessage(t);
      } catch (s2) {
        return void i.getLogger(this).error(new s("websocket-connection", "Failed to parse message, invalid JSON", { error: s2 }));
      }
    };
  }
  _createWebSocket(e) {
    return new Promise((t, o3) => {
      const s2 = new WebSocket(e);
      s2.onopen = () => {
        if (s2.onopen = null, this.destroyed) return s2.onclose = null, void s2.close();
        s2.onclose = (e2) => this._onClose(e2), s2.onerror = (e2) => this._onError(e2), this._setWebSocketJSONParseHandler(s2), t(s2);
      }, s2.onclose = (e2) => {
        s2.onopen = s2.onclose = null, o3(e2);
      };
    });
  }
  async _handshake(e = 1e4) {
    const s2 = this._websocket;
    if (null == s2) return;
    const n = $(), i3 = s2.onmessage, { filter: c, outFields: a3, spatialReference: l2 } = this._config;
    return n.timeout(e), s2.onmessage = (e2) => {
      let r2 = null;
      try {
        r2 = JSON.parse(e2.data);
      } catch (h3) {
      }
      r2 && "object" == typeof r2 || (i.getLogger(this).error(new s("websocket-connection", "Protocol violation. Handshake failed - malformed message", e2.data)), n.reject(), this.destroy()), r2.spatialReference?.wkid !== l2?.wkid && (i.getLogger(this).error(new s("websocket-connection", `Protocol violation. Handshake failed - expected wkid of ${l2.wkid}`, e2.data)), n.reject(), this.destroy()), "json" !== r2.format && (i.getLogger(this).error(new s("websocket-connection", "Protocol violation. Handshake failed - format is not set", e2.data)), n.reject(), this.destroy()), c && r2.filter !== c && i.getLogger(this).error(new s("websocket-connection", "Tried to set filter, but server doesn't support it")), a3 && r2.outFields !== a3 && i.getLogger(this).error(new s("websocket-connection", "Tried to set outFields, but server doesn't support it")), s2.onmessage = i3;
      for (const t of this._outstandingMessages) s2.send(JSON.stringify(t));
      this._outstandingMessages = [], n.resolve();
    }, s2.send(JSON.stringify({ filter: c, outFields: a3, format: "json", spatialReference: { wkid: l2.wkid } })), n.promise;
  }
  _onMessage(e) {
    if (this.onMessage(e), "type" in e) switch (e.type) {
      case "features":
      case "featureResult":
        for (const t of e.features) null != this._featureZScaler && this._featureZScaler(t.geometry), this.onFeature(t);
    }
  }
  _onError(e) {
    const t = "Encountered an error over WebSocket connection";
    this._set("errorString", t), i.getLogger(this).error("websocket-connection", t);
  }
  _onClose(e) {
    this._websocket = null, this.notifyChange("connectionStatus"), 1e3 !== e.code && i.getLogger(this).error("websocket-connection", `WebSocket closed unexpectedly with error code ${e.code}`), this.destroyed || this._open();
  }
};
__decorate([m()], h.prototype, "connectionStatus", null), __decorate([m()], h.prototype, "errorString", void 0), h = __decorate([a("esri.layers.graphics.sources.connections.WebSocketConnection")], h);

// node_modules/@arcgis/core/layers/graphics/sources/connections/GeoEventConnection.js
var h2 = 1e4;
var d = { maxQueryDepth: 5, maxRecordCountFactor: 3 };
var g = class extends h {
  constructor(e) {
    super({ ...d, ...e }), this._buddyServicesQuery = null, this._relatedFeatures = null;
  }
  async _open() {
    const e = await this._fetchServiceDefinition(this._config.source);
    e.timeInfo.trackIdField || i.getLogger(this).warn("GeoEvent service was configured without a TrackIdField. This may result in certain functionality being disabled. The purgeOptions.maxObservations property will have no effect.");
    const t = this._fetchWebSocketUrl(e.streamUrls, this._config.spatialReference);
    this._buddyServicesQuery || (this._buddyServicesQuery = this._queryBuddyServices()), await this._buddyServicesQuery, await this._tryCreateWebSocket(t);
    const { filter: r2, outFields: o3 } = this._config;
    this.destroyed || this._setFilter(r2, o3);
  }
  _onMessage(e) {
    if ("attributes" in e) {
      let o3;
      try {
        o3 = this._enrich(e), null != this._featureZScaler && this._featureZScaler(o3.geometry);
      } catch (t) {
        return void i.getLogger(this).error(new s("geoevent-connection", "Failed to parse message", t));
      }
      this.onFeature(o3);
    } else this.onMessage(e);
  }
  async _fetchServiceDefinition(e) {
    const r2 = { f: "json", ...this._config.customParameters }, i3 = H(e.path, { query: r2, responseType: "json" }), o3 = (await i3).data;
    return this._serviceDefinition = o3, o3;
  }
  _fetchWebSocketUrl(e, t) {
    const r2 = e[0], { urls: i3, token: o3 } = r2, n = this._inferWebSocketBaseUrl(i3);
    return Bt(`${n}/subscribe`, { outSR: "" + t.wkid, token: o3 });
  }
  _inferWebSocketBaseUrl(e) {
    if (1 === e.length) return e[0];
    for (const t of e) if (t.includes("wss")) return t;
    return i.getLogger(this).error(new s("geoevent-connection", "Unable to infer WebSocket url", e)), null;
  }
  async _setFilter(e, t) {
    const s2 = this._websocket;
    if (null == s2 || null == e && null == t) return;
    const n = JSON.stringify({ filter: this._serializeFilter(e, t) });
    let a3 = false;
    const c = $(), u = () => {
      a3 || (this.destroyed || this._websocket !== s2 || i.getLogger(this).error(new s("geoevent-connection", "Server timed out when setting filter")), c.reject());
    }, l2 = (e2) => {
      const t2 = JSON.parse(e2.data);
      t2.filter && (t2.error && (i.getLogger(this).error(new s("geoevent-connection", "Failed to set service filter", t2.error)), this._set("errorString", `Could not set service filter - ${t2.error}`), c.reject(t2.error)), this._setWebSocketJSONParseHandler(s2), a3 = true, c.resolve());
    };
    return s2.onmessage = l2, s2.send(n), setTimeout(u, h2), c.promise;
  }
  _serializeFilter(e, t) {
    const o3 = {};
    if (null == e && null == t) return o3;
    if (e?.geometry) try {
      const t2 = f2(e.geometry);
      if ("extent" !== t2.type) throw new s("geoevent-connection", `Expected extent but found type ${t2.type}`);
      o3.geometry = JSON.stringify(t2.shiftCentralMeridian());
    } catch (s2) {
      i.getLogger(this).error(new s("geoevent-connection", "Encountered an error when setting connection geometryDefinition", s2));
    }
    return e?.where && "1 = 1" !== e.where && "1=1" !== e.where && (o3.where = e.where), null != t && (o3.outFields = t.join(",")), o3;
  }
  _enrich(e) {
    if (!this._relatedFeatures) return e;
    const t = this._serviceDefinition.relatedFeatures.joinField, o3 = e.attributes[t], s2 = this._relatedFeatures.get(o3);
    if (!s2) return i.getLogger(this).warn("geoevent-connection", "Feature join failed. Is the join field configured correctly?", e), e;
    const { attributes: n, geometry: a3 } = s2;
    for (const r2 in n) e.attributes[r2] = n[r2];
    return a3 && (e.geometry = a3), e.geometry || e.centroid || i.getLogger(this).error(new s("geoevent-connection", "Found malformed feature - no geometry found", e)), e;
  }
  async _queryBuddyServices() {
    try {
      const { relatedFeatures: e, keepLatestArchive: t } = this._serviceDefinition, r2 = this._queryRelatedFeatures(e), i3 = this._queryArchive(t);
      await r2;
      const o3 = await i3;
      if (!o3) return;
      for (const s2 of o3.features) this.onFeature(this._enrich(s2));
    } catch (e) {
      i.getLogger(this).error(new s("geoevent-connection", "Encountered an error when querying buddy services", { error: e }));
    }
  }
  async _queryRelatedFeatures(e) {
    if (!e) return;
    const t = await this._queryBuddy(e.featuresUrl);
    this._addRelatedFeatures(t);
  }
  async _queryArchive(e) {
    if (e) return this._queryBuddy(e.featuresUrl);
  }
  async _queryBuddy(e) {
    const t = new (await import("./FeatureLayer-67ZFNT6Z.js")).default({ url: e }), { capabilities: r2 } = await t.load(), i3 = r2.query.supportsMaxRecordCountFactor, o3 = r2.query.supportsPagination, s2 = r2.query.supportsCentroid, n = this._config.maxRecordCountFactor, c = t.capabilities.query.maxRecordCount, u = i3 ? c * n : c, h3 = new b();
    if (h3.outFields = this._config.outFields ?? ["*"], h3.where = this._config.filter?.where ?? "1=1", h3.returnGeometry = true, h3.returnExceededLimitFeatures = true, h3.outSpatialReference = f.fromJSON(this._config.spatialReference), s2 && (h3.returnCentroid = true), i3 && (h3.maxRecordCountFactor = n), o3) return h3.num = u, t.destroy(), this._queryPages(e, h3);
    const d2 = await y(e, h3, this._config.sourceSpatialReference);
    return t.destroy(), d2.data;
  }
  async _queryPages(e, t, r2 = [], i3 = 0) {
    t.start = null != t.num ? i3 * t.num : null;
    const { data: o3 } = await y(e, t, this._config.sourceSpatialReference);
    return o3.exceededTransferLimit && i3 < (this._config.maxQueryDepth ?? 0) ? (o3.features.forEach((e2) => r2.push(e2)), this._queryPages(e, t, r2, i3 + 1)) : (r2.forEach((e2) => o3.features.push(e2)), o3);
  }
  _addRelatedFeatures(e) {
    const t = /* @__PURE__ */ new Map(), r2 = e.features, i3 = this._serviceDefinition.relatedFeatures.joinField;
    for (const o3 of r2) {
      const e2 = o3.attributes[i3];
      t.set(e2, o3);
    }
    this._relatedFeatures = t;
  }
};
g = __decorate([a("esri.layers.graphics.sources.connections.GeoEventConnection")], g);

// node_modules/@arcgis/core/layers/support/ClientSideConnection.js
var a2 = class extends i2 {
  constructor(e) {
    super({}), this.connectionStatus = "connected", this.errorString = null;
    const { geometryType: r2, spatialReference: t, sourceSpatialReference: s2 } = e;
    this._featureZScaler = o(r2, s2, t);
  }
  normalizeCtorArgs() {
    return {};
  }
  updateCustomParameters(e) {
  }
  sendMessageToSocket(e) {
  }
  sendMessageToClient(e) {
    if ("type" in e) switch (e.type) {
      case "features":
      case "featureResult":
        for (const r2 of e.features) null != this._featureZScaler && this._featureZScaler(r2.geometry), this.onFeature(r2);
    }
    this.onMessage(e);
  }
};
__decorate([m()], a2.prototype, "connectionStatus", void 0), __decorate([m()], a2.prototype, "errorString", void 0), a2 = __decorate([a("esri.layers.support.ClientSideConnection")], a2);

// node_modules/@arcgis/core/layers/graphics/sources/connections/createConnection.js
function o2(e, t) {
  if (null == e && null == t) return null;
  const n = {};
  return null != t && (n.geometry = t), null != e && (n.where = e), n;
}
function r(r2, i3, s2, c, l2, u, a3, m2, p) {
  const f3 = { source: r2, sourceSpatialReference: i3, spatialReference: s2, geometryType: c, filter: o2(l2, u), maxReconnectionAttempts: a3, maxReconnectionInterval: m2, customParameters: p };
  if (!r2) return new a2(f3);
  return r2.path.startsWith("wss://") || r2.path.startsWith("ws://") ? new h(f3) : new g(f3);
}

export {
  r
};
//# sourceMappingURL=chunk-CSVD3MCH.js.map
