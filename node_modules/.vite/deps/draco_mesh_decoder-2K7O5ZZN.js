import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/chunks/draco_mesh_decoder.js
var r;
var e = (r = "undefined" != typeof document ? document.currentScript?.src : void 0, function(e2 = {}) {
  var t, n, a, o = e2, i = new Promise((r2, e3) => {
    t = r2, n = e3;
  }), u = Object.assign({}, o), s = "";
  function l(r2) {
    return o.locateFile ? o.locateFile(r2, s) : s + r2;
  }
  "undefined" != typeof document && document.currentScript && (s = document.currentScript.src), r && (s = r), s = s.startsWith("blob:") ? "" : s.substr(0, s.replace(/[?#].*/, "").lastIndexOf("/") + 1), a = async (r2) => {
    var e3 = await fetch(r2, { credentials: "same-origin" });
    if (e3.ok) return e3.arrayBuffer();
    throw new Error(e3.status + " : " + e3.url);
  }, o.print || console.log.bind(console);
  var c = o.printErr || console.error.bind(console);
  Object.assign(o, u), u = null, o.arguments && o.arguments, o.thisProgram && o.thisProgram;
  var f, d, h, p, v, g, m, y, b, $ = o.wasmBinary, w = false;
  function A() {
    var r2 = f.buffer;
    o.HEAP8 = d = new Int8Array(r2), o.HEAP16 = p = new Int16Array(r2), o.HEAPU8 = h = new Uint8Array(r2), o.HEAPU16 = v = new Uint16Array(r2), o.HEAP32 = g = new Int32Array(r2), o.HEAPU32 = m = new Uint32Array(r2), o.HEAPF32 = y = new Float32Array(r2), o.HEAPF64 = b = new Float64Array(r2);
  }
  var T = [], C = [], P = [];
  function W() {
    if (o.preRun) for ("function" == typeof o.preRun && (o.preRun = [o.preRun]); o.preRun.length; ) F(o.preRun.shift());
    L(T);
  }
  function E() {
    L(C);
  }
  function _() {
    if (o.postRun) for ("function" == typeof o.postRun && (o.postRun = [o.postRun]); o.postRun.length; ) R(o.postRun.shift());
    L(P);
  }
  function F(r2) {
    T.unshift(r2);
  }
  function k(r2) {
    C.unshift(r2);
  }
  function R(r2) {
    P.unshift(r2);
  }
  var S = 0, x = null;
  function j(r2) {
    S++, o.monitorRunDependencies?.(S);
  }
  function V(r2) {
    if (S--, o.monitorRunDependencies?.(S), 0 == S && x) {
      var e3 = x;
      x = null, e3();
    }
  }
  function I(r2) {
    o.onAbort?.(r2), c(r2 = "Aborted(" + r2 + ")"), w = true, r2 += ". Build with -sASSERTIONS for more info.";
    var e3 = new WebAssembly.RuntimeError(r2);
    throw n(e3), e3;
  }
  var H, U = "data:application/octet-stream;base64,", O = (r2) => r2.startsWith(U);
  function D() {
    var r2 = "draco_mesh_decoder.wasm";
    return O(r2) ? r2 : l(r2);
  }
  function B(r2) {
    if (r2 == H && $) return new Uint8Array($);
    throw "both async and sync fetching of the wasm failed";
  }
  async function M(r2) {
    if (!$) try {
      var e3 = await a(r2);
      return new Uint8Array(e3);
    } catch {
    }
    return B(r2);
  }
  async function N(r2, e3) {
    try {
      var t2 = await M(r2);
      return await WebAssembly.instantiate(t2, e3);
    } catch (n2) {
      c(`failed to asynchronously prepare wasm: ${n2}`), I(n2);
    }
  }
  async function z(r2, e3, t2) {
    if (!r2 && "function" == typeof WebAssembly.instantiateStreaming && !O(e3) && "function" == typeof fetch) try {
      var n2 = fetch(e3, { credentials: "same-origin" });
      return await WebAssembly.instantiateStreaming(n2, t2);
    } catch (a2) {
      c(`wasm streaming compile failed: ${a2}`), c("falling back to ArrayBuffer instantiation");
    }
    return N(e3, t2);
  }
  function q() {
    return { a: Oe };
  }
  async function G() {
    function r2(r3, e4) {
      return Ue = r3.exports, f = Ue.C, A(), kr = Ue.F, k(Ue.D), V(), Ue;
    }
    function e3(e4) {
      r2(e4.instance);
    }
    j();
    var t2 = q();
    if (o.instantiateWasm) try {
      return o.instantiateWasm(t2, r2);
    } catch (i2) {
      c(`Module.instantiateWasm callback failed with error: ${i2}`), n(i2);
    }
    H ??= D();
    try {
      var a2 = await z($, H, t2);
      return e3(a2), a2;
    } catch (i2) {
      return void n(i2);
    }
  }
  var L = (r2) => {
    for (; r2.length > 0; ) r2.shift()(o);
  };
  o.noExitRuntime;
  class J {
    constructor(r2) {
      this.excPtr = r2, this.ptr = r2 - 24;
    }
    set_type(r2) {
      m[this.ptr + 4 >> 2] = r2;
    }
    get_type() {
      return m[this.ptr + 4 >> 2];
    }
    set_destructor(r2) {
      m[this.ptr + 8 >> 2] = r2;
    }
    get_destructor() {
      return m[this.ptr + 8 >> 2];
    }
    set_caught(r2) {
      r2 = r2 ? 1 : 0, d[this.ptr + 12] = r2;
    }
    get_caught() {
      return 0 != d[this.ptr + 12];
    }
    set_rethrown(r2) {
      r2 = r2 ? 1 : 0, d[this.ptr + 13] = r2;
    }
    get_rethrown() {
      return 0 != d[this.ptr + 13];
    }
    init(r2, e3) {
      this.set_adjusted_ptr(0), this.set_type(r2), this.set_destructor(e3);
    }
    set_adjusted_ptr(r2) {
      m[this.ptr + 16 >> 2] = r2;
    }
    get_adjusted_ptr() {
      return m[this.ptr + 16 >> 2];
    }
  }
  var K = (r2, e3, t2) => {
    throw new J(r2).init(e3, t2), r2;
  }, Q = () => I(""), X = {}, Y = (r2) => {
    for (; r2.length; ) {
      var e3 = r2.pop();
      r2.pop()(e3);
    }
  };
  function Z(r2) {
    return this.fromWireType(m[r2 >> 2]);
  }
  var rr, er, tr, nr = {}, ar = {}, or = {}, ir = (r2) => {
    throw new rr(r2);
  }, ur = (r2, e3, t2) => {
    function n2(e4) {
      var n3 = t2(e4);
      n3.length !== r2.length && ir("Mismatched type converter count");
      for (var a3 = 0; a3 < r2.length; ++a3) pr(r2[a3], n3[a3]);
    }
    r2.forEach((r3) => or[r3] = e3);
    var a2 = new Array(e3.length), o2 = [], i2 = 0;
    e3.forEach((r3, e4) => {
      ar.hasOwnProperty(r3) ? a2[e4] = ar[r3] : (o2.push(r3), nr.hasOwnProperty(r3) || (nr[r3] = []), nr[r3].push(() => {
        a2[e4] = ar[r3], ++i2 === o2.length && n2(a2);
      }));
    }), 0 === o2.length && n2(a2);
  }, sr = (r2) => {
    var e3 = X[r2];
    delete X[r2];
    var t2 = e3.rawConstructor, n2 = e3.rawDestructor, a2 = e3.fields, o2 = a2.map((r3) => r3.getterReturnType).concat(a2.map((r3) => r3.setterArgumentType));
    ur([r2], o2, (r3) => {
      var o3 = {};
      return a2.forEach((e4, t3) => {
        var n3 = e4.fieldName, i2 = r3[t3], u2 = e4.getter, s2 = e4.getterContext, l2 = r3[t3 + a2.length], c2 = e4.setter, f2 = e4.setterContext;
        o3[n3] = { read: (r4) => i2.fromWireType(u2(s2, r4)), write: (r4, e5) => {
          var t4 = [];
          c2(f2, r4, l2.toWireType(t4, e5)), Y(t4);
        } };
      }), [{ name: e3.name, fromWireType: (r4) => {
        var e4 = {};
        for (var t3 in o3) e4[t3] = o3[t3].read(r4);
        return n2(r4), e4;
      }, toWireType: (r4, e4) => {
        for (var a3 in o3) if (!(a3 in e4)) throw new TypeError(`Missing field: "${a3}"`);
        var i2 = t2();
        for (a3 in o3) o3[a3].write(i2, e4[a3]);
        return null !== r4 && r4.push(n2, i2), i2;
      }, argPackAdvance: vr, readValueFromPointer: Z, destructorFunction: n2 }];
    });
  }, lr = (r2, e3, t2, n2, a2) => {
  }, cr = () => {
    for (var r2 = new Array(256), e3 = 0; e3 < 256; ++e3) r2[e3] = String.fromCharCode(e3);
    er = r2;
  }, fr = (r2) => {
    for (var e3 = "", t2 = r2; h[t2]; ) e3 += er[h[t2++]];
    return e3;
  }, dr = (r2) => {
    throw new tr(r2);
  };
  function hr(r2, e3, t2 = {}) {
    var n2 = e3.name;
    if (r2 || dr(`type "${n2}" must have a positive integer typeid pointer`), ar.hasOwnProperty(r2)) {
      if (t2.ignoreDuplicateRegistrations) return;
      dr(`Cannot register type '${n2}' twice`);
    }
    if (ar[r2] = e3, delete or[r2], nr.hasOwnProperty(r2)) {
      var a2 = nr[r2];
      delete nr[r2], a2.forEach((r3) => r3());
    }
  }
  function pr(r2, e3, t2 = {}) {
    return hr(r2, e3, t2);
  }
  var vr = 8, gr = (r2, e3, t2, n2) => {
    pr(r2, { name: e3 = fr(e3), fromWireType: function(r3) {
      return !!r3;
    }, toWireType: function(r3, e4) {
      return e4 ? t2 : n2;
    }, argPackAdvance: vr, readValueFromPointer: function(r3) {
      return this.fromWireType(h[r3]);
    }, destructorFunction: null });
  }, mr = [], yr = [], br = (r2) => {
    r2 > 9 && 0 === --yr[r2 + 1] && (yr[r2] = void 0, mr.push(r2));
  }, $r = () => yr.length / 2 - 5 - mr.length, wr = () => {
    yr.push(0, 1, void 0, 1, null, 1, true, 1, false, 1), o.count_emval_handles = $r;
  }, Ar = { toValue: (r2) => (r2 || dr("Cannot use deleted val. handle = " + r2), yr[r2]), toHandle: (r2) => {
    switch (r2) {
      case void 0:
        return 2;
      case null:
        return 4;
      case true:
        return 6;
      case false:
        return 8;
      default: {
        const e3 = mr.pop() || yr.length;
        return yr[e3] = r2, yr[e3 + 1] = 1, e3;
      }
    }
  } }, Tr = { name: "emscripten::val", fromWireType: (r2) => {
    var e3 = Ar.toValue(r2);
    return br(r2), e3;
  }, toWireType: (r2, e3) => Ar.toHandle(e3), argPackAdvance: vr, readValueFromPointer: Z, destructorFunction: null }, Cr = (r2) => pr(r2, Tr), Pr = (r2, e3) => {
    switch (e3) {
      case 4:
        return function(r3) {
          return this.fromWireType(y[r3 >> 2]);
        };
      case 8:
        return function(r3) {
          return this.fromWireType(b[r3 >> 3]);
        };
      default:
        throw new TypeError(`invalid float width (${e3}): ${r2}`);
    }
  }, Wr = (r2, e3, t2) => {
    pr(r2, { name: e3 = fr(e3), fromWireType: (r3) => r3, toWireType: (r3, e4) => e4, argPackAdvance: vr, readValueFromPointer: Pr(e3, t2), destructorFunction: null });
  }, Er = (r2, e3) => Object.defineProperty(e3, "name", { value: r2 });
  function _r(r2) {
    for (var e3 = 1; e3 < r2.length; ++e3) if (null !== r2[e3] && void 0 === r2[e3].destructorFunction) return true;
    return false;
  }
  function Fr(r2, e3, t2, n2, a2, o2) {
    var i2 = e3.length;
    i2 < 2 && dr("argTypes array size mismatch! Must at least get return value and 'this' types!"), e3[1];
    var u2 = _r(e3), s2 = "void" !== e3[0].name, l2 = i2 - 2, c2 = new Array(l2), f2 = [], d2 = [];
    return Er(r2, function(...r3) {
      var t3;
      d2.length = 0, f2.length = 1, f2[0] = a2;
      for (var o3 = 0; o3 < l2; ++o3) c2[o3] = e3[o3 + 2].toWireType(d2, r3[o3]), f2.push(c2[o3]);
      function i3(r4) {
        if (u2) Y(d2);
        else for (var n3 = 2; n3 < e3.length; n3++) {
          var a3 = 1 === n3 ? t3 : c2[n3 - 2];
          null !== e3[n3].destructorFunction && e3[n3].destructorFunction(a3);
        }
        if (s2) return e3[0].fromWireType(r4);
      }
      return i3(n2(...f2));
    });
  }
  var kr, Rr, Sr = (r2, e3, t2) => {
    if (void 0 === r2[e3].overloadTable) {
      var n2 = r2[e3];
      r2[e3] = function(...n3) {
        return r2[e3].overloadTable.hasOwnProperty(n3.length) || dr(`Function '${t2}' called with an invalid number of arguments (${n3.length}) - expects one of (${r2[e3].overloadTable})!`), r2[e3].overloadTable[n3.length].apply(this, n3);
      }, r2[e3].overloadTable = [], r2[e3].overloadTable[n2.argCount] = n2;
    }
  }, xr = (r2, e3, t2) => {
    o.hasOwnProperty(r2) ? ((void 0 === t2 || void 0 !== o[r2].overloadTable && void 0 !== o[r2].overloadTable[t2]) && dr(`Cannot register public name '${r2}' twice`), Sr(o, r2, r2), o[r2].overloadTable.hasOwnProperty(t2) && dr(`Cannot register multiple overloads of a function with the same number of arguments (${t2})!`), o[r2].overloadTable[t2] = e3) : (o[r2] = e3, o[r2].argCount = t2);
  }, jr = (r2, e3) => {
    for (var t2 = [], n2 = 0; n2 < r2; n2++) t2.push(m[e3 + 4 * n2 >> 2]);
    return t2;
  }, Vr = (r2, e3, t2) => {
    o.hasOwnProperty(r2) || ir("Replacing nonexistent public symbol"), void 0 !== o[r2].overloadTable && void 0 !== t2 ? o[r2].overloadTable[t2] = e3 : (o[r2] = e3, o[r2].argCount = t2);
  }, Ir = (r2, e3, t2) => (r2 = r2.replace(/p/g, "i"), (0, o["dynCall_" + r2])(e3, ...t2)), Hr = [], Ur = (r2) => {
    var e3 = Hr[r2];
    return e3 || (r2 >= Hr.length && (Hr.length = r2 + 1), Hr[r2] = e3 = kr.get(r2)), e3;
  }, Or = (r2, e3, t2 = []) => r2.includes("j") ? Ir(r2, e3, t2) : Ur(e3)(...t2), Dr = (r2, e3) => (...t2) => Or(r2, e3, t2), Br = (r2, e3) => {
    function t2() {
      return r2.includes("j") ? Dr(r2, e3) : Ur(e3);
    }
    r2 = fr(r2);
    var n2 = t2();
    return "function" != typeof n2 && dr(`unknown function pointer with signature ${r2}: ${e3}`), n2;
  }, Mr = (r2, e3) => {
    var t2 = Er(e3, function(r3) {
      this.name = e3, this.message = r3;
      var t3 = new Error(r3).stack;
      void 0 !== t3 && (this.stack = this.toString() + "\n" + t3.replace(/^Error(:[^\n]*)?\n/, ""));
    });
    return t2.prototype = Object.create(r2.prototype), t2.prototype.constructor = t2, t2.prototype.toString = function() {
      return void 0 === this.message ? this.name : `${this.name}: ${this.message}`;
    }, t2;
  }, Nr = (r2) => {
    var e3 = Be(r2), t2 = fr(e3);
    return Ne(e3), t2;
  }, zr = (r2, e3) => {
    var t2 = [], n2 = {};
    function a2(r3) {
      n2[r3] || ar[r3] || (or[r3] ? or[r3].forEach(a2) : (t2.push(r3), n2[r3] = true));
    }
    throw e3.forEach(a2), new Rr(`${r2}: ` + t2.map(Nr).join([", "]));
  }, qr = (r2) => {
    const e3 = (r2 = r2.trim()).indexOf("(");
    return -1 !== e3 ? r2.substr(0, e3) : r2;
  }, Gr = (r2, e3, t2, n2, a2, o2, i2, u2) => {
    var s2 = jr(e3, t2);
    r2 = fr(r2), r2 = qr(r2), a2 = Br(n2, a2), xr(r2, function() {
      zr(`Cannot call ${r2} due to unbound types`, s2);
    }, e3 - 1), ur([], s2, (t3) => {
      var n3 = [t3[0], null].concat(t3.slice(1));
      return Vr(r2, Fr(r2, n3, null, a2, o2), e3 - 1), [];
    });
  }, Lr = (r2, e3, t2) => {
    switch (e3) {
      case 1:
        return t2 ? (r3) => d[r3] : (r3) => h[r3];
      case 2:
        return t2 ? (r3) => p[r3 >> 1] : (r3) => v[r3 >> 1];
      case 4:
        return t2 ? (r3) => g[r3 >> 2] : (r3) => m[r3 >> 2];
      default:
        throw new TypeError(`invalid integer width (${e3}): ${r2}`);
    }
  }, Jr = (r2, e3, t2, n2, a2) => {
    e3 = fr(e3);
    var o2 = (r3) => r3;
    if (0 === n2) {
      var i2 = 32 - 8 * t2;
      o2 = (r3) => r3 << i2 >>> i2;
    }
    var u2 = e3.includes("unsigned"), s2 = (r3, e4) => {
    };
    pr(r2, { name: e3, fromWireType: o2, toWireType: u2 ? function(r3, e4) {
      return s2(e4, this.name), e4 >>> 0;
    } : function(r3, e4) {
      return s2(e4, this.name), e4;
    }, argPackAdvance: vr, readValueFromPointer: Lr(e3, t2, 0 !== n2), destructorFunction: null });
  }, Kr = (r2, e3, t2) => {
    var n2 = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][e3];
    function a2(r3) {
      var e4 = m[r3 >> 2], t3 = m[r3 + 4 >> 2];
      return new n2(d.buffer, t3, e4);
    }
    pr(r2, { name: t2 = fr(t2), fromWireType: a2, argPackAdvance: vr, readValueFromPointer: a2 }, { ignoreDuplicateRegistrations: true });
  }, Qr = (r2, e3, t2, n2) => {
    if (!(n2 > 0)) return 0;
    for (var a2 = t2, o2 = t2 + n2 - 1, i2 = 0; i2 < r2.length; ++i2) {
      var u2 = r2.charCodeAt(i2);
      if (u2 >= 55296 && u2 <= 57343 && (u2 = 65536 + ((1023 & u2) << 10) | 1023 & r2.charCodeAt(++i2)), u2 <= 127) {
        if (t2 >= o2) break;
        e3[t2++] = u2;
      } else if (u2 <= 2047) {
        if (t2 + 1 >= o2) break;
        e3[t2++] = 192 | u2 >> 6, e3[t2++] = 128 | 63 & u2;
      } else if (u2 <= 65535) {
        if (t2 + 2 >= o2) break;
        e3[t2++] = 224 | u2 >> 12, e3[t2++] = 128 | u2 >> 6 & 63, e3[t2++] = 128 | 63 & u2;
      } else {
        if (t2 + 3 >= o2) break;
        e3[t2++] = 240 | u2 >> 18, e3[t2++] = 128 | u2 >> 12 & 63, e3[t2++] = 128 | u2 >> 6 & 63, e3[t2++] = 128 | 63 & u2;
      }
    }
    return e3[t2] = 0, t2 - a2;
  }, Xr = (r2, e3, t2) => Qr(r2, h, e3, t2), Yr = (r2) => {
    for (var e3 = 0, t2 = 0; t2 < r2.length; ++t2) {
      var n2 = r2.charCodeAt(t2);
      n2 <= 127 ? e3++ : n2 <= 2047 ? e3 += 2 : n2 >= 55296 && n2 <= 57343 ? (e3 += 4, ++t2) : e3 += 3;
    }
    return e3;
  }, Zr = "undefined" != typeof TextDecoder ? new TextDecoder() : void 0, re = (r2, e3 = 0, t2 = NaN) => {
    for (var n2 = e3 + t2, a2 = e3; r2[a2] && !(a2 >= n2); ) ++a2;
    if (a2 - e3 > 16 && r2.buffer && Zr) return Zr.decode(r2.subarray(e3, a2));
    for (var o2 = ""; e3 < a2; ) {
      var i2 = r2[e3++];
      if (128 & i2) {
        var u2 = 63 & r2[e3++];
        if (192 != (224 & i2)) {
          var s2 = 63 & r2[e3++];
          if ((i2 = 224 == (240 & i2) ? (15 & i2) << 12 | u2 << 6 | s2 : (7 & i2) << 18 | u2 << 12 | s2 << 6 | 63 & r2[e3++]) < 65536) o2 += String.fromCharCode(i2);
          else {
            var l2 = i2 - 65536;
            o2 += String.fromCharCode(55296 | l2 >> 10, 56320 | 1023 & l2);
          }
        } else o2 += String.fromCharCode((31 & i2) << 6 | u2);
      } else o2 += String.fromCharCode(i2);
    }
    return o2;
  }, ee = (r2, e3) => r2 ? re(h, r2, e3) : "", te = (r2, e3) => {
    pr(r2, { name: e3 = fr(e3), fromWireType(r3) {
      for (var e4, t2 = m[r3 >> 2], n2 = r3 + 4, a2 = n2, o2 = 0; o2 <= t2; ++o2) {
        var i2 = n2 + o2;
        if (o2 == t2 || 0 == h[i2]) {
          var u2 = ee(a2, i2 - a2);
          void 0 === e4 ? e4 = u2 : (e4 += String.fromCharCode(0), e4 += u2), a2 = i2 + 1;
        }
      }
      return Ne(r3), e4;
    }, toWireType(r3, e4) {
      var t2;
      e4 instanceof ArrayBuffer && (e4 = new Uint8Array(e4));
      var n2 = "string" == typeof e4;
      n2 || e4 instanceof Uint8Array || e4 instanceof Uint8ClampedArray || e4 instanceof Int8Array || dr("Cannot pass non-string to std::string"), t2 = n2 ? Yr(e4) : e4.length;
      var a2 = Me(4 + t2 + 1), o2 = a2 + 4;
      if (m[a2 >> 2] = t2, n2) Xr(e4, o2, t2 + 1);
      else if (n2) for (var i2 = 0; i2 < t2; ++i2) {
        var u2 = e4.charCodeAt(i2);
        u2 > 255 && (Ne(o2), dr("String has UTF-16 code units that do not fit in 8 bits")), h[o2 + i2] = u2;
      }
      else for (i2 = 0; i2 < t2; ++i2) h[o2 + i2] = e4[i2];
      return null !== r3 && r3.push(Ne, a2), a2;
    }, argPackAdvance: vr, readValueFromPointer: Z, destructorFunction(r3) {
      Ne(r3);
    } });
  }, ne = "undefined" != typeof TextDecoder ? new TextDecoder("utf-16le") : void 0, ae = (r2, e3) => {
    for (var t2 = r2, n2 = t2 >> 1, a2 = n2 + e3 / 2; !(n2 >= a2) && v[n2]; ) ++n2;
    if ((t2 = n2 << 1) - r2 > 32 && ne) return ne.decode(h.subarray(r2, t2));
    for (var o2 = "", i2 = 0; !(i2 >= e3 / 2); ++i2) {
      var u2 = p[r2 + 2 * i2 >> 1];
      if (0 == u2) break;
      o2 += String.fromCharCode(u2);
    }
    return o2;
  }, oe = (r2, e3, t2) => {
    if (t2 ??= 2147483647, t2 < 2) return 0;
    for (var n2 = e3, a2 = (t2 -= 2) < 2 * r2.length ? t2 / 2 : r2.length, o2 = 0; o2 < a2; ++o2) {
      var i2 = r2.charCodeAt(o2);
      p[e3 >> 1] = i2, e3 += 2;
    }
    return p[e3 >> 1] = 0, e3 - n2;
  }, ie = (r2) => 2 * r2.length, ue = (r2, e3) => {
    for (var t2 = 0, n2 = ""; !(t2 >= e3 / 4); ) {
      var a2 = g[r2 + 4 * t2 >> 2];
      if (0 == a2) break;
      if (++t2, a2 >= 65536) {
        var o2 = a2 - 65536;
        n2 += String.fromCharCode(55296 | o2 >> 10, 56320 | 1023 & o2);
      } else n2 += String.fromCharCode(a2);
    }
    return n2;
  }, se = (r2, e3, t2) => {
    if (t2 ??= 2147483647, t2 < 4) return 0;
    for (var n2 = e3, a2 = n2 + t2 - 4, o2 = 0; o2 < r2.length; ++o2) {
      var i2 = r2.charCodeAt(o2);
      if (i2 >= 55296 && i2 <= 57343 && (i2 = 65536 + ((1023 & i2) << 10) | 1023 & r2.charCodeAt(++o2)), g[e3 >> 2] = i2, (e3 += 4) + 4 > a2) break;
    }
    return g[e3 >> 2] = 0, e3 - n2;
  }, le = (r2) => {
    for (var e3 = 0, t2 = 0; t2 < r2.length; ++t2) {
      var n2 = r2.charCodeAt(t2);
      n2 >= 55296 && n2 <= 57343 && ++t2, e3 += 4;
    }
    return e3;
  }, ce = (r2, e3, t2) => {
    var n2, a2, o2, i2;
    t2 = fr(t2), 2 === e3 ? (n2 = ae, a2 = oe, i2 = ie, o2 = (r3) => v[r3 >> 1]) : 4 === e3 && (n2 = ue, a2 = se, i2 = le, o2 = (r3) => m[r3 >> 2]), pr(r2, { name: t2, fromWireType: (r3) => {
      for (var t3, a3 = m[r3 >> 2], i3 = r3 + 4, u2 = 0; u2 <= a3; ++u2) {
        var s2 = r3 + 4 + u2 * e3;
        if (u2 == a3 || 0 == o2(s2)) {
          var l2 = n2(i3, s2 - i3);
          void 0 === t3 ? t3 = l2 : (t3 += String.fromCharCode(0), t3 += l2), i3 = s2 + e3;
        }
      }
      return Ne(r3), t3;
    }, toWireType: (r3, n3) => {
      "string" != typeof n3 && dr(`Cannot pass non-string to C++ string type ${t2}`);
      var o3 = i2(n3), u2 = Me(4 + o3 + e3);
      return m[u2 >> 2] = o3 / e3, a2(n3, u2 + 4, o3 + e3), null !== r3 && r3.push(Ne, u2), u2;
    }, argPackAdvance: vr, readValueFromPointer: Z, destructorFunction(r3) {
      Ne(r3);
    } });
  }, fe = (r2, e3, t2, n2, a2, o2) => {
    X[r2] = { name: fr(e3), rawConstructor: Br(t2, n2), rawDestructor: Br(a2, o2), fields: [] };
  }, de = (r2, e3, t2, n2, a2, o2, i2, u2, s2, l2) => {
    X[r2].fields.push({ fieldName: fr(e3), getterReturnType: t2, getter: Br(n2, a2), getterContext: o2, setterArgumentType: i2, setter: Br(u2, s2), setterContext: l2 });
  }, he = (r2, e3) => {
    pr(r2, { isVoid: true, name: e3 = fr(e3), argPackAdvance: 0, fromWireType: () => {
    }, toWireType: (r3, e4) => {
    } });
  }, pe = (r2, e3, t2) => h.copyWithin(r2, e3, e3 + t2), ve = (r2, e3) => {
    var t2 = ar[r2];
    return void 0 === t2 && dr(`${e3} has unknown type ${Nr(r2)}`), t2;
  }, ge = (r2, e3, t2) => {
    var n2 = [], a2 = r2.toWireType(n2, t2);
    return n2.length && (m[e3 >> 2] = Ar.toHandle(n2)), a2;
  }, me = (r2, e3, t2) => (r2 = Ar.toValue(r2), e3 = ve(e3, "emval::as"), ge(e3, t2, r2)), ye = [], be = (r2, e3, t2, n2) => (r2 = ye[r2])(null, e3 = Ar.toValue(e3), t2, n2), $e = {}, we = (r2) => {
    var e3 = $e[r2];
    return void 0 === e3 ? fr(r2) : e3;
  }, Ae = (r2, e3, t2, n2, a2) => (r2 = ye[r2])(e3 = Ar.toValue(e3), e3[t2 = we(t2)], n2, a2), Te = () => {
    if ("object" == typeof globalThis) return globalThis;
    function r2(r3) {
      r3.$$$embind_global$$$ = r3;
      var e3 = "object" == typeof $$$embind_global$$$ && r3.$$$embind_global$$$ == r3;
      return e3 || delete r3.$$$embind_global$$$, e3;
    }
    if ("object" == typeof $$$embind_global$$$) return $$$embind_global$$$;
    if ("object" == typeof global && r2(global) ? $$$embind_global$$$ = global : "object" == typeof self && r2(self) && ($$$embind_global$$$ = self), "object" == typeof $$$embind_global$$$) return $$$embind_global$$$;
    throw Error("unable to get global object.");
  }, Ce = (r2) => 0 === r2 ? Ar.toHandle(Te()) : (r2 = we(r2), Ar.toHandle(Te()[r2])), Pe = (r2) => {
    var e3 = ye.length;
    return ye.push(r2), e3;
  }, We = (r2, e3) => {
    for (var t2 = new Array(r2), n2 = 0; n2 < r2; ++n2) t2[n2] = ve(m[e3 + 4 * n2 >> 2], "parameter " + n2);
    return t2;
  }, Ee = Reflect.construct, _e = (r2, e3, t2) => {
    var n2 = We(r2, e3), a2 = n2.shift();
    r2--;
    var o2 = new Array(r2), i2 = (e4, i3, u3, s2) => {
      for (var l2 = 0, c2 = 0; c2 < r2; ++c2) o2[c2] = n2[c2].readValueFromPointer(s2 + l2), l2 += n2[c2].argPackAdvance;
      var f2 = 1 === t2 ? Ee(i3, o2) : i3.apply(e4, o2);
      return ge(a2, u3, f2);
    }, u2 = `methodCaller<(${n2.map((r3) => r3.name).join(", ")}) => ${a2.name}>`;
    return Pe(Er(u2, i2));
  }, Fe = (r2, e3) => (r2 = Ar.toValue(r2), e3 = Ar.toValue(e3), Ar.toHandle(r2[e3])), ke = (r2) => {
    r2 > 9 && (yr[r2 + 1] += 1);
  }, Re = (r2) => Ar.toHandle(we(r2)), Se = (r2) => {
    var e3 = Ar.toValue(r2);
    Y(e3), br(r2);
  }, xe = (r2, e3) => {
    var t2 = (r2 = ve(r2, "_emval_take_value")).readValueFromPointer(e3);
    return Ar.toHandle(t2);
  }, je = () => 2147483648, Ve = (r2, e3) => Math.ceil(r2 / e3) * e3, Ie = (r2) => {
    var e3 = (r2 - f.buffer.byteLength + 65535) / 65536 | 0;
    try {
      return f.grow(e3), A(), 1;
    } catch (t2) {
    }
  }, He = (r2) => {
    var e3 = h.length;
    r2 >>>= 0;
    var t2 = je();
    if (r2 > t2) return false;
    for (var n2 = 1; n2 <= 4; n2 *= 2) {
      var a2 = e3 * (1 + 0.2 / n2);
      a2 = Math.min(a2, r2 + 100663296);
      var o2 = Math.min(t2, Ve(Math.max(r2, a2), 65536));
      if (Ie(o2)) return true;
    }
    return false;
  };
  rr = o.InternalError = class extends Error {
    constructor(r2) {
      super(r2), this.name = "InternalError";
    }
  }, cr(), tr = o.BindingError = class extends Error {
    constructor(r2) {
      super(r2), this.name = "BindingError";
    }
  }, wr(), Rr = o.UnboundTypeError = Mr(Error, "UnboundTypeError");
  var Ue, Oe = { g: K, r: Q, m: sr, q: lr, w: gr, u: Cr, l: Wr, y: Gr, d: Jr, a: Kr, v: te, i: ce, n: fe, c: de, x: he, t: pe, p: me, z: be, j: Ae, b: br, o: Ce, h: _e, A: Fe, e: ke, B: Re, f: Se, k: xe, s: He };
  G();
  var De, Be = (r2) => (Be = Ue.E)(r2), Me = (r2) => (Me = Ue.G)(r2), Ne = (r2) => (Ne = Ue.H)(r2);
  function ze() {
    function r2() {
      De || (De = true, o.calledRun = true, w || (E(), t(o), o.onRuntimeInitialized?.(), _()));
    }
    S > 0 || (W(), S > 0 || (o.setStatus ? (o.setStatus("Running..."), setTimeout(() => {
      setTimeout(() => o.setStatus(""), 1), r2();
    }, 1)) : r2()));
  }
  if (x = function r2() {
    De || ze(), De || (x = r2);
  }, o.preInit) for ("function" == typeof o.preInit && (o.preInit = [o.preInit]); o.preInit.length > 0; ) o.preInit.pop()();
  return ze(), i;
});
export {
  e as default
};
//# sourceMappingURL=draco_mesh_decoder-2K7O5ZZN.js.map
