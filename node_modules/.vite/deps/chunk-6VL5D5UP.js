import {
  i as i2,
  o,
  r,
  s as s3
} from "./chunk-6QHY54HZ.js";
import {
  o as o2,
  r as r2
} from "./chunk-GXJJY3ND.js";
import {
  n
} from "./chunk-5ONGWFJ3.js";
import {
  f as f3
} from "./chunk-PLNHHGHL.js";
import {
  f as f2,
  v
} from "./chunk-GD4FJL3C.js";
import {
  P,
  y3 as y
} from "./chunk-PZ5RULLK.js";
import {
  S,
  j
} from "./chunk-AXZMNHTN.js";
import {
  f
} from "./chunk-5T3MJDSR.js";
import {
  A,
  G
} from "./chunk-NMQNUPE4.js";
import {
  H2 as H,
  I
} from "./chunk-V2H77UEV.js";
import {
  i3 as i,
  s,
  s2
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/rest/geometryService/cut.js
async function i3(i4, n2, p, m2) {
  const a = f3(i4), u = n2[0].spatialReference, c = { ...m2, responseType: "json", query: { ...a.query, f: "json", sr: A(u), target: JSON.stringify({ geometryType: v(n2[0]), geometries: n2 }), cutter: JSON.stringify(p) } }, f4 = await H(a.path + "/cut", c), { cutIndexes: y3, geometries: g = [] } = f4.data;
  return { cutIndexes: y3, geometries: g.map((e) => {
    const t = f2(e);
    return t.spatialReference = u, t;
  }) };
}

// node_modules/@arcgis/core/rest/geometryService/simplify.js
async function m(m2, p, f4) {
  const n2 = "string" == typeof m2 ? I(m2) : m2, a = p[0].spatialReference, u = v(p[0]), l = { ...f4, query: { ...n2.query, f: "json", sr: A(a), geometries: JSON.stringify(r2(p)) } }, { data: y3 } = await H(n2.path + "/simplify", l);
  return o2(y3.geometries, u, a);
}

// node_modules/@arcgis/core/geometry/support/normalizeUtils.js
var y2 = () => i.getLogger("esri.geometry.support.normalizeUtils");
function x(t) {
  return "polygon" === t.type;
}
function d(t) {
  return "polygon" === t[0].type;
}
function M(t) {
  return "polyline" === t[0].type;
}
function w(t) {
  const e = [];
  let n2 = 0, o3 = 0;
  for (let s4 = 0; s4 < t.length; s4++) {
    const r3 = t[s4];
    let i4 = null;
    for (let t2 = 0; t2 < r3.length; t2++) i4 = r3[t2], e.push(i4), 0 === t2 ? (n2 = i4[0], o3 = n2) : (n2 = Math.min(n2, i4[0]), o3 = Math.max(o3, i4[0]));
    i4 && e.push([(n2 + o3) / 2, 0]);
  }
  return e;
}
function b(t, e) {
  if (!(t instanceof y || t instanceof P)) {
    const t2 = "straightLineDensify: the input geometry is neither polyline nor polygon";
    throw y2().error(t2), new s2("internal:geometry", t2);
  }
  const o3 = o(t), i4 = [];
  for (const n2 of o3) {
    const t2 = [];
    i4.push(t2), t2.push([n2[0][0], n2[0][1]]);
    for (let o4 = 0; o4 < n2.length - 1; o4++) {
      const s4 = n2[o4][0], r3 = n2[o4][1], i5 = n2[o4 + 1][0], l = n2[o4 + 1][1], c = Math.sqrt((i5 - s4) * (i5 - s4) + (l - r3) * (l - r3)), f4 = (l - r3) / c, u = (i5 - s4) / c, a = c / e;
      if (a > 1) {
        for (let l2 = 1; l2 <= a - 1; l2++) {
          const n4 = l2 * e, o6 = u * n4 + s4, i7 = f4 * n4 + r3;
          t2.push([o6, i7]);
        }
        const n3 = (c + Math.floor(a - 1) * e) / 2, o5 = u * n3 + s4, i6 = f4 * n3 + r3;
        t2.push([o5, i6]);
      }
      t2.push([i5, l]);
    }
  }
  return x(t) ? new P({ rings: i4, spatialReference: t.spatialReference }) : new y({ paths: i4, spatialReference: t.spatialReference });
}
function j2(t, e, n2) {
  if (e) {
    const e2 = b(t, 1e6);
    t = S(e2, true);
  }
  return n2 && (t = s3(t, n2)), t;
}
function R(t, e, n2) {
  if (Array.isArray(t)) {
    const o3 = t[0];
    if (o3 > e) {
      const n3 = i2(o3, e);
      t[0] = o3 + n3 * (-2 * e);
    } else if (o3 < n2) {
      const e2 = i2(o3, n2);
      t[0] = o3 + e2 * (-2 * n2);
    }
  } else {
    const o3 = t.x;
    if (o3 > e) {
      const n3 = i2(o3, e);
      t = t.clone().offset(n3 * (-2 * e), 0);
    } else if (o3 < n2) {
      const e2 = i2(o3, n2);
      t = t.clone().offset(e2 * (-2 * n2), 0);
    }
  }
  return t;
}
function v2(t, e) {
  let n2 = -1;
  for (let o3 = 0; o3 < e.cutIndexes.length; o3++) {
    const s4 = e.cutIndexes[o3], r3 = e.geometries[o3], i4 = o(r3);
    for (let t2 = 0; t2 < i4.length; t2++) {
      const e2 = i4[t2];
      e2.some((n3) => {
        if (n3[0] < 180) return true;
        {
          let n4 = 0;
          for (let t3 = 0; t3 < e2.length; t3++) {
            const o5 = e2[t3][0];
            n4 = o5 > n4 ? o5 : n4;
          }
          n4 = Number(n4.toFixed(9));
          const o4 = -360 * i2(n4, 180);
          for (let s5 = 0; s5 < e2.length; s5++) {
            const e3 = r3.getPoint(t2, s5);
            r3.setPoint(t2, s5, e3.clone().offset(o4, 0));
          }
          return true;
        }
      });
    }
    if (s4 === n2) {
      if (d(t)) for (const e2 of o(r3)) t[s4] = t[s4].addRing(e2);
      else if (M(t)) for (const e2 of o(r3)) t[s4] = t[s4].addPath(e2);
    } else n2 = s4, t[s4] = r3;
  }
  return t;
}
async function P2(e, n2, o3) {
  if (!Array.isArray(e)) return P2([e], n2);
  n2 && "string" != typeof n2 && y2().warn("normalizeCentralMeridian()", "The url object is deprecated, use the url string instead");
  const i4 = "string" == typeof n2 ? n2 : n2?.url ?? s.geometryServiceUrl;
  let u, h, x2, d2, M2, w2, b2, z2, L2 = 0;
  const S3 = [], U2 = [];
  for (const t of e) if (null != t) if (u || (u = t.spatialReference, h = G(u), x2 = u.isWebMercator, w2 = x2 ? 102100 : 4326, d2 = r[w2].maxX, M2 = r[w2].minX, b2 = r[w2].plus180Line, z2 = r[w2].minus180Line), h) if ("mesh" === t.type) U2.push(t);
  else if ("point" === t.type) U2.push(R(t.clone(), d2, M2));
  else if ("multipoint" === t.type) {
    const e2 = t.clone();
    e2.points = e2.points.map((t2) => R(t2, d2, M2)), U2.push(e2);
  } else if ("extent" === t.type) {
    const e2 = t.clone()._normalize(false, false, h);
    U2.push(e2.rings ? new P(e2) : e2);
  } else if (t.extent) {
    const e2 = t.extent, n3 = i2(e2.xmin, M2) * (2 * d2);
    let o4 = 0 === n3 ? t.clone() : s3(t.clone(), n3);
    e2.offset(n3, 0);
    let { xmin: s4, xmax: r3 } = e2;
    s4 = Number(s4.toFixed(9)), r3 = Number(r3.toFixed(9)), e2.intersects(b2) && r3 !== d2 ? (L2 = r3 > L2 ? r3 : L2, o4 = j2(o4, x2), S3.push(o4), U2.push("cut")) : e2.intersects(z2) && s4 !== M2 ? (L2 = r3 * (2 * d2) > L2 ? r3 * (2 * d2) : L2, o4 = j2(o4, x2, 360), S3.push(o4), U2.push("cut")) : U2.push(o4);
  } else U2.push(t.clone());
  else U2.push(t);
  else U2.push(t);
  let A3 = i2(L2, d2), C2 = -90;
  const F = A3, N = new y();
  for (; A3 > 0; ) {
    const t = 360 * A3 - 180;
    N.addPath([[t, C2], [t, -1 * C2]]), C2 *= -1, A3--;
  }
  if (S3.length > 0 && F > 0) {
    const t = v2(S3, await i3(i4, S3, N, o3)), n3 = [], s4 = [];
    for (let o4 = 0; o4 < U2.length; o4++) {
      const r4 = U2[o4];
      if ("cut" !== r4) s4.push(r4);
      else {
        const r5 = t.shift(), i5 = e[o4];
        null != i5 && "polygon" === i5.type && i5.rings && i5.rings.length > 1 && r5.rings.length >= i5.rings.length ? (n3.push(r5), s4.push("simplify")) : s4.push(x2 ? j(r5) : r5);
      }
    }
    if (!n3.length) return s4;
    const r3 = await m(i4, n3, o3), l = [];
    for (let e2 = 0; e2 < s4.length; e2++) {
      const t2 = s4[e2];
      "simplify" !== t2 ? l.push(t2) : l.push(x2 ? j(r3.shift()) : r3.shift());
    }
    return l;
  }
  const W = [];
  for (let t = 0; t < U2.length; t++) {
    const e2 = U2[t];
    if ("cut" !== e2) W.push(e2);
    else {
      const t2 = S3.shift();
      W.push(true === x2 ? j(t2) : t2);
    }
  }
  return W;
}
function z(t) {
  if (!t) return null;
  const e = t.extent;
  if (!e) return null;
  const n2 = t.spatialReference && G(t.spatialReference);
  if (!n2) return e;
  const [o3, s4] = n2.valid, r3 = 2 * s4, { width: i4 } = e;
  let l, { xmin: c, xmax: f4 } = e;
  if ([c, f4] = [f4, c], "extent" === t.type || 0 === i4 || i4 <= s4 || i4 > r3 || c < o3 || f4 > s4) return e;
  switch (t.type) {
    case "polygon":
      if (!(t.rings.length > 1)) return e;
      l = w(t.rings);
      break;
    case "polyline":
      if (!(t.paths.length > 1)) return e;
      l = w(t.paths);
      break;
    case "multipoint":
      l = t.points;
  }
  const u = e.clone();
  for (let a = 0; a < l.length; a++) {
    let t2 = l[a][0];
    t2 < 0 ? (t2 += s4, f4 = Math.max(t2, f4)) : (t2 -= s4, c = Math.min(t2, c));
  }
  return u.xmin = c, u.xmax = f4, u.width < i4 ? (u.xmin -= s4, u.xmax -= s4, u) : e;
}
function L(t, e, n2) {
  const o3 = G(n2);
  if (null == o3) return t;
  const [s4, r3] = o3.valid, i4 = 2 * r3;
  let l = 0, c = 0;
  e > r3 ? l = Math.ceil(Math.abs(e - r3) / i4) : e < s4 && (l = -Math.ceil(Math.abs(e - s4) / i4)), t > r3 ? c = Math.ceil(Math.abs(t - r3) / i4) : t < s4 && (c = -Math.ceil(Math.abs(t - s4) / i4));
  let f4 = t + (l - c) * i4;
  const u = f4 - e;
  return u > r3 ? f4 -= i4 : u < s4 && (f4 += i4), f4;
}
function S2(t, e) {
  const n2 = U(e);
  return n2?.normalize(t) ?? t;
}
function U(t) {
  const n2 = G(t);
  if (null == n2) return null;
  const [o3, s4] = n2.valid;
  return new n(o3, s4);
}
var A2 = U(f.WGS84);
var C = U(f.WebMercator);

export {
  b,
  P2 as P,
  z,
  L,
  S2 as S,
  A2 as A
};
//# sourceMappingURL=chunk-6VL5D5UP.js.map
