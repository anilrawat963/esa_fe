import {
  d as d3,
  l,
  n as n3
} from "./chunk-P355ISZZ.js";
import {
  d
} from "./chunk-NDWECAKM.js";
import {
  u
} from "./chunk-KTMKDXZP.js";
import {
  i as i3
} from "./chunk-CT7HOWYG.js";
import {
  i as i2,
  s,
  t as t3
} from "./chunk-CW4AXF3Q.js";
import {
  d as d2,
  e as e6,
  o2
} from "./chunk-BZBDEPRV.js";
import {
  m
} from "./chunk-MXP2VO3L.js";
import {
  w
} from "./chunk-OWSUTT7E.js";
import {
  e
} from "./chunk-COMSADUT.js";
import {
  e as e2
} from "./chunk-U5J3MCMX.js";
import {
  e as e4
} from "./chunk-SZ5DGQ75.js";
import {
  e as e5
} from "./chunk-3PAAA3FK.js";
import {
  r as r3
} from "./chunk-EGPAQBOO.js";
import {
  s as s2
} from "./chunk-WJ3E33GQ.js";
import {
  r as r4
} from "./chunk-YOYO2XMY.js";
import {
  e as e3
} from "./chunk-SZTZNZQW.js";
import {
  i
} from "./chunk-AJG2ZYEA.js";
import {
  n as n2,
  t as t2
} from "./chunk-CFXCM2NO.js";
import {
  a,
  r as r2
} from "./chunk-ZVTEFYZX.js";
import {
  n
} from "./chunk-WDTGOP77.js";
import {
  o,
  r
} from "./chunk-AZXJIEZ6.js";
import {
  t
} from "./chunk-6KIXN4DJ.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/hud/HUDOcclusionPass.glsl.js
function i4(i5, t4) {
  const { vertex: s3, fragment: p } = i5;
  i5.include(i3, t4), s3.include(l), s3.main.add(t2`vec4 posProjCenter;
if (dot(position, position) > 0.0) {
ProjectHUDAux projectAux;
vec4 posProj = projectPositionHUD(projectAux);
posProjCenter = alignToPixelCenter(posProj, viewport.zw);
forwardViewPosDepth(projectAux.posView);
vec3 vpos = projectAux.posModel;
if (rejectBySlice(vpos)) {
posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
}
} else {
posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
}
gl_Position = posProjCenter;
gl_PointSize = 1.0;`), p.main.add(t2`fragColor = vec4(1);
if(discardByTerrainDepth()) {
fragColor.g = 0.5;
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Float4DrawUniform.js
var e7 = class extends i {
  constructor(r5, e8, o3) {
    super(r5, "vec4", 2, (s3, t4, c) => s3.setUniform4fv(r5, e8(t4, c), o3));
  }
};

// node_modules/@arcgis/core/chunks/HUDMaterial.glsl.js
function F(e8) {
  const i5 = new s2(), { signedDistanceFieldEnabled: F2, occlusionTestEnabled: M2, horizonCullingEnabled: U2, pixelSnappingEnabled: H2, hasScreenSizePerspective: E, debugDrawLabelBorder: _, hasVVSize: q, hasVVColor: R, hasRotation: k, occludedFragmentFade: I, sampleSignedDistanceFieldTexelCenter: G } = e8;
  i5.include(d3, e8), i5.vertex.include(m, e8);
  const { occlusionPass: J, output: K, oitPass: N } = e8;
  if (J) return i5.include(i4, e8), i5;
  const { vertex: Q, fragment: W } = i5;
  i5.include(s), i5.include(u, e8), i5.include(d, e8), M2 && i5.include(n3), W.include(e6), i5.varyings.add("vcolor", "vec4"), i5.varyings.add("vtc", "vec2"), i5.varyings.add("vsize", "vec2");
  const X = 9 === K, Y = X && M2;
  Y && i5.varyings.add("voccluded", "float"), Q.uniforms.add(new e5("viewport", (e9) => e9.camera.fullViewport), new e4("screenOffset", (e9, i6) => o(L, 2 * e9.screenOffset[0] * i6.camera.pixelRatio, 2 * e9.screenOffset[1] * i6.camera.pixelRatio)), new e4("anchorPosition", (e9) => B(e9)), new e("materialColor", (e9) => e9.color), new r4("materialRotation", (e9) => e9.rotation), new e3("tex", (e9) => e9.texture)), w(Q), F2 && (Q.uniforms.add(new e("outlineColor", (e9) => e9.outlineColor)), W.uniforms.add(new e("outlineColor", (e9) => T(e9) ? e9.outlineColor : a), new r4("outlineSize", (e9) => T(e9) ? e9.outlineSize : 0))), U2 && Q.uniforms.add(new e7("pointDistanceSphere", (e9, o3) => {
    const i6 = o3.camera.eye, r5 = e9.origin;
    return r2(r5[0] - i6[0], r5[1] - i6[1], r5[2] - i6[2], t.radius);
  })), H2 && Q.include(l), E && (t3(Q), i2(Q)), _ && i5.varyings.add("debugBorderCoords", "vec4"), i5.attributes.add("uv0", "vec2"), i5.attributes.add("uvi", "vec4"), i5.attributes.add("color", "vec4"), i5.attributes.add("size", "vec2"), i5.attributes.add("rotation", "float"), (q || R) && i5.attributes.add("featureAttribute", "vec4"), Q.code.add(U2 ? t2`bool behindHorizon(vec3 posModel) {
vec3 camToEarthCenter = pointDistanceSphere.xyz - localOrigin;
vec3 camToPos = pointDistanceSphere.xyz + posModel;
float earthRadius = pointDistanceSphere.w;
float a = dot(camToPos, camToPos);
float b = dot(camToPos, camToEarthCenter);
float c = dot(camToEarthCenter, camToEarthCenter) - earthRadius * earthRadius;
return b > 0.0 && b < a && b * b  > a * c;
}` : t2`bool behindHorizon(vec3 posModel) { return false; }`), Q.main.add(t2`
    ProjectHUDAux projectAux;
    vec4 posProj = projectPositionHUD(projectAux);
    forwardObjectAndLayerIdColor();

    if (rejectBySlice(projectAux.posModel)) {
      // Project outside of clip plane
      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
      return;
    }

    if (behindHorizon(projectAux.posModel)) {
      // Project outside of clip plane
      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
      return;
    }

    vec2 inputSize;
    ${n2(E, t2`
        inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);
        vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);`, t2`
        inputSize = size;
        vec2 screenOffsetScaled = screenOffset;`)}
    ${n2(q, t2`inputSize *= vvScale(featureAttribute).xx;`)}

    vec2 combinedSize = inputSize * pixelRatio;
    vec4 quadOffset = vec4(0.0);

    ${n2(M2, t2`
    bool visible = testHUDVisibility(posProj);
    if (!visible) {
      vtc = vec2(0.0);
      ${n2(_, "debugBorderCoords = vec4(0.5, 0.5, 1.5 / combinedSize);")}
      return;
    }`)}
    ${n2(Y, t2`voccluded = visible ? 0.0 : 1.0;`)}
  `);
  const Z = t2`
      vec2 uv = mix(uvi.xy, uvi.zw, bvec2(uv0));
      vec2 texSize = vec2(textureSize(tex, 0));
      uv = mix(vec2(1.0), uv / texSize, lessThan(uv, vec2(${V})));
      quadOffset.xy = (uv0 - anchorPosition) * 2.0 * combinedSize;

      ${n2(k, t2`
          float angle = radians(materialRotation + rotation);
          float cosAngle = cos(angle);
          float sinAngle = sin(angle);
          mat2 rotate = mat2(cosAngle, -sinAngle, sinAngle,  cosAngle);

          quadOffset.xy = rotate * quadOffset.xy;
        `)}

      quadOffset.xy = (quadOffset.xy + screenOffsetScaled) / viewport.zw * posProj.w;
  `, ee = H2 ? F2 ? t2`posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;` : t2`posProj += quadOffset;
if (inputSize.x == size.x) {
posProj = alignToPixelOrigin(posProj, viewport.zw);
}` : t2`posProj += quadOffset;`;
  Q.main.add(t2`
    ${Z}
    ${R ? "vcolor = interpolateVVColor(featureAttribute.y) * materialColor;" : "vcolor = color / 255.0 * materialColor;"}

    ${n2(10 === K, t2`vcolor.a = 1.0;`)}

    bool alphaDiscard = vcolor.a < ${t2.float(o2)};
    ${n2(F2, `alphaDiscard = alphaDiscard && outlineColor.a < ${t2.float(o2)};`)}
    if (alphaDiscard) {
      // "early discard" if both symbol color (= fill) and outline color (if applicable) are transparent
      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
      return;
    } else {
      ${ee}
      gl_Position = posProj;
    }

    vtc = uv;

    ${n2(_, t2`debugBorderCoords = vec4(uv01, 1.5 / combinedSize);`)}
    vsize = inputSize;
  `), W.uniforms.add(new e3("tex", (e9) => e9.texture)), I && !X && W.uniforms.add(new e2("depthMap", (e9) => e9.mainDepth), new r3("occludedOpacity", (e9) => e9.hudOccludedFragmentOpacity));
  const oe = _ ? t2`(isBorder > 0.0 ? 0.0 : ${t2.float(o2)})` : t2.float(o2), ie = t2`
    ${n2(_, t2`float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));`)}

    vec2 samplePos = vtc;

    ${n2(G, t2`
      float txSize = float(textureSize(tex, 0).x);
      float texelSize = 1.0 / txSize;

      // Calculate how much we have to add/subtract to/from each texel to reach the size of an onscreen pixel
      vec2 scaleFactor = (vsize - txSize) * texelSize;
      samplePos += (vec2(1.0, -1.0) * texelSize) * scaleFactor;`)}

    ${F2 ? t2`
      vec4 fillPixelColor = vcolor;

      // Get distance in output units (i.e. pixels)

      float sdf = texture(tex, samplePos).r;
      float pixelDistance = sdf * vsize.x;

      // Create smooth transition from the icon into its outline
      float fillAlphaFactor = clamp(0.5 - pixelDistance, 0.0, 1.0);
      fillPixelColor.a *= fillAlphaFactor;

      if (outlineSize > 0.25) {
        vec4 outlinePixelColor = outlineColor;
        float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);

        // Create smooth transition around outline
        float outlineAlphaFactor = clamp(0.5 - (abs(pixelDistance) - 0.5*clampedOutlineSize), 0.0, 1.0);
        outlinePixelColor.a *= outlineAlphaFactor;

        if (
          outlineAlphaFactor + fillAlphaFactor < ${oe} ||
          fillPixelColor.a + outlinePixelColor.a < ${t2.float(o2)}
        ) {
          discard;
        }

        // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)
        float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);
        vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +
          vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);

        ${n2(!X, t2`fragColor = vec4(compositeColor, compositeAlpha);`)}
      } else {
        if (fillAlphaFactor < ${oe}) {
          discard;
        }

        ${n2(!X, t2`fragColor = premultiplyAlpha(fillPixelColor);`)}
      }

      // visualize SDF:
      // fragColor = vec4(clamp(-pixelDistance/vsize.x*2.0, 0.0, 1.0), clamp(pixelDistance/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);
      ` : t2`
          vec4 texColor = texture(tex, samplePos, -0.5);
          if (texColor.a < ${oe}) {
            discard;
          }
          ${n2(!X, t2`fragColor = texColor * premultiplyAlpha(vcolor);`)}
          `}

    ${n2(I && !X, t2`
        float zSample = texelFetch(depthMap, ivec2(gl_FragCoord.xy), 0).x;
        if (zSample < gl_FragCoord.z) {
          fragColor *= occludedOpacity;
        }
        `)}

    ${n2(!X && _, t2`fragColor = mix(fragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder * 0.5);`)}
  `;
  switch (K) {
    case 0:
    case 1:
      i5.outputs.add("fragColor", "vec4", 0), 1 === K && i5.outputs.add("fragEmission", "vec4", 1), 1 === N && i5.outputs.add("fragAlpha", "float", 1 === K ? 2 : 1), W.main.add(t2`
        ${ie}
        ${n2(2 === N, t2`fragColor.rgb /= fragColor.a;`)}
        ${n2(1 === K, t2`fragEmission = vec4(0.0);`)}
        ${n2(1 === N, t2`fragAlpha = fragColor.a;`)}`);
      break;
    case 10:
      W.main.add(t2`
        ${ie}
        outputObjectAndLayerIdColor();`);
      break;
    case 9:
      i5.include(d2, e8), W.main.add(t2`
        ${ie}
        outputHighlight(${n2(Y, t2`voccluded == 1.0`, t2`false`)});`);
  }
  return i5;
}
function T(e8) {
  return e8.outlineColor[3] > 0 && e8.outlineSize > 0;
}
function B(o3) {
  return o3.textureIsSignedDistanceField ? M(o3.anchorPosition, o3.distanceFieldBoundingBox, L) : r(L, o3.anchorPosition), L;
}
function M(e8, i5, r5) {
  o(r5, e8[0] * (i5[2] - i5[0]) + i5[0], e8[1] * (i5[3] - i5[1]) + i5[1]);
}
var L = n();
var U = 32e3;
var V = t2.float(U);
var H = Object.freeze(Object.defineProperty({ __proto__: null, build: F, calculateAnchorPosition: B, fullUV: U }, Symbol.toStringTag, { value: "Module" }));

export {
  F,
  B,
  U,
  H
};
//# sourceMappingURL=chunk-JNASI2YX.js.map
