import {
  a
} from "./chunk-QVM6IWUX.js";
import {
  s as s2
} from "./chunk-63RKYW5K.js";
import {
  l,
  n,
  t
} from "./chunk-65WW7L4T.js";
import {
  K,
  w
} from "./chunk-CNYNCKEV.js";
import "./chunk-W75DBJD7.js";
import "./chunk-P6IKJIMO.js";
import "./chunk-MHV23XAQ.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-ONXWBTTM.js";
import "./chunk-YDTPM7OQ.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-7P2ANHQ3.js";
import "./chunk-XCKT47LJ.js";
import "./chunk-H74Q4SYB.js";
import "./chunk-2OFHDVO5.js";
import "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-5UPBUJPC.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-AXZMNHTN.js";
import "./chunk-5T3MJDSR.js";
import "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import {
  I,
  h2 as h,
  p2 as p,
  qt
} from "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import "./chunk-5EI5H4QX.js";
import "./chunk-ZIE53VIV.js";
import "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import "./chunk-GNMPGHLQ.js";
import {
  s2 as s
} from "./chunk-QY7XKUIV.js";
import "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/layers/support/arcgisLayers.js
var f = { FeatureLayer: true, SceneLayer: true, VideoLayer: true };
async function p2(e) {
  const { properties: r, url: a2 } = e, t2 = { ...r, url: a2 }, s3 = await v(a2, r?.customParameters), { Constructor: l2, layerId: o, sourceJSON: n2, parsedUrl: c, layers: i, tables: u } = s3;
  if (i.length + u.length === 0) return null != o && (t2.layerId = o), null != n2 && (t2.sourceJSON = n2), new l2(t2);
  const y = new (0, (await import("./GroupLayer-QYIX6L7Y.js")).default)({ title: c.title });
  return await w2(y, s3, t2), y;
}
function m(e, r) {
  return e ? e.find(({ id: e2 }) => e2 === r) : null;
}
function d(e, r, a2, t2, s3) {
  const l2 = { ...s3, layerId: r };
  return null != e && (l2.url = e), null != a2 && (l2.sourceJSON = a2), "sublayerTitleMode" in t2.prototype && (l2.sublayerTitleMode = "service-name"), new t2(l2);
}
async function w2(e, r, a2) {
  const t2 = r.sublayerConstructorProvider;
  for (const { id: s3, serverUrl: l2 } of r.layers) {
    const o = m(r.sublayerInfos, s3), n2 = d(l2, s3, o, (o && t2?.(o)) ?? r.Constructor, a2);
    e.add(n2);
  }
  if (r.tables.length) {
    const t3 = await L("FeatureLayer");
    r.tables.forEach(({ id: s3, serverUrl: l2 }) => {
      const o = d(l2, s3, m(r.tableInfos, s3), t3, a2);
      e.tables.add(o);
    });
  }
}
async function v(r, a2) {
  let s3 = p(r);
  if (null == s3 && (s3 = await S(r, a2)), null == s3) throw new s("arcgis-layers:url-mismatch", "The url '${url}' is not a valid arcgis resource", { url: r });
  const { serverType: l2, sublayer: n2 } = s3;
  let u;
  const p3 = { FeatureServer: "FeatureLayer", KnowledgeGraphServer: "KnowledgeGraphLayer", StreamServer: "StreamLayer", VectorTileServer: "VectorTileLayer", VideoServer: "VideoLayer" }, m2 = "FeatureServer" === l2, d2 = "SceneServer" === l2, w3 = { parsedUrl: s3, Constructor: null, layerId: m2 || d2 ? n2 ?? void 0 : void 0, layers: [], tables: [] };
  switch (l2) {
    case "MapServer":
      if (null != n2) {
        const { type: t2 } = await t(r, { customParameters: a2 });
        switch (u = "FeatureLayer", t2) {
          case "Catalog Layer":
            u = "CatalogLayer";
            break;
          case "Catalog Dynamic Group Layer":
            throw new s("arcgis-layers:unsupported", `fromUrl() not supported for "${t2}" layers`);
        }
      } else {
        u = await g(r, a2) ? "TileLayer" : "MapImageLayer";
      }
      break;
    case "ImageServer": {
      const e = await t(r, { customParameters: a2 }), { tileInfo: t2, cacheType: s4 } = e;
      u = t2 ? "LERC" !== t2?.format?.toUpperCase() || s4 && "elevation" !== s4.toLowerCase() ? "ImageryTileLayer" : "ElevationLayer" : "ImageryLayer";
      break;
    }
    case "SceneServer": {
      const e = await t(s3.url.path, { customParameters: a2 });
      if (u = "SceneLayer", e) {
        const r2 = e?.layers;
        if ("Voxel" === e?.layerType) u = "VoxelLayer";
        else if (r2?.length) {
          const e2 = r2[0]?.layerType;
          null != e2 && null != w[e2] && (u = w[e2]);
        }
      }
      break;
    }
    case "3DTilesServer":
      throw new s("arcgis-layers:unsupported", "fromUrl() not supported for 3DTiles layers");
    case "FeatureServer":
      if (u = "FeatureLayer", null != n2) {
        const e = await t(r, { customParameters: a2 });
        w3.sourceJSON = e, w3.preferredUrl = K(), u = l(e.type);
      }
      break;
    default:
      u = p3[l2];
  }
  if (f[u] && null == n2) {
    const e = await h2(r, l2, a2);
    m2 && (w3.preferredUrl = e.preferredUrl, w3.sublayerInfos = e.layerInfos, w3.tableInfos = e.tableInfos);
    if (1 !== e.layers.length + e.tables.length) w3.layers = e.layers, w3.tables = e.tables, m2 && e.layerInfos?.length && (w3.sublayerConstructorProvider = await P(e.layerInfos));
    else if (m2 || d2) {
      const r2 = e.layerInfos?.[0] ?? e.tableInfos?.[0];
      if (w3.layerId = e.layers[0]?.id ?? e.tables[0]?.id, w3.sourceJSON = r2, m2) {
        const e2 = r2?.type;
        u = l(e2);
      }
    }
  }
  return w3.Constructor = await L(u), w3;
}
async function S(e, t2) {
  const l2 = await t(e, { customParameters: t2 });
  let o = null, n2 = null;
  const c = l2.type;
  if ("Feature Layer" === c || "Table" === c ? (o = "FeatureServer", n2 = l2.id ?? null) : "indexedVector" === c ? o = "VectorTileServer" : l2.hasOwnProperty("mapName") ? o = "MapServer" : l2.hasOwnProperty("bandCount") && l2.hasOwnProperty("pixelSizeX") ? o = "ImageServer" : l2.hasOwnProperty("maxRecordCount") && l2.hasOwnProperty("allowGeometryUpdates") ? o = "FeatureServer" : l2.hasOwnProperty("streamUrls") ? o = "StreamServer" : b(l2) ? (o = "SceneServer", n2 = l2.id) : l2.hasOwnProperty("layers") && b(l2.layers?.[0]) && (o = "SceneServer"), !o) return null;
  const i = null != n2 ? h(e) : null;
  return { title: null != i && l2.name || qt(e), serverType: o, sublayer: n2, url: { path: null != i ? i.serviceUrl : I(e).path } };
}
function b(e) {
  return null != e && e.hasOwnProperty("store") && e.hasOwnProperty("id") && "number" == typeof e.id;
}
async function h2(e, r, a2) {
  let t2, s3, l2, o = false;
  switch (r) {
    case "FeatureServer": {
      const r2 = await n(e, { customParameters: a2 });
      l2 = K(e, { preferredHost: r2.preferredHost }), o = !!r2.layersJSON, t2 = r2.layersJSON || r2.serviceJSON;
      break;
    }
    case "SceneServer": {
      const r2 = await I2(e, a2);
      t2 = r2.serviceInfo, s3 = r2.tableServerUrl;
      break;
    }
    default:
      t2 = await t(e, { customParameters: a2 });
  }
  const i = t2?.layers, u = t2?.tables;
  return { preferredUrl: l2, layers: i?.map((e2) => ({ id: e2.id })).reverse() || [], tables: u?.map((e2) => ({ serverUrl: s3, id: e2.id })).reverse() || [], layerInfos: o ? i : [], tableInfos: o ? u : [] };
}
async function I2(e, r) {
  const a2 = await t(e, { customParameters: r }), t2 = a2.layers?.[0];
  if (!t2) return { serviceInfo: a2 };
  try {
    const { serverUrl: t3 } = await s2(e), s3 = await t(t3, { customParameters: r }).catch(() => null);
    return s3 && (a2.tables = s3.tables), { serviceInfo: a2, tableServerUrl: t3 };
  } catch {
    return { serviceInfo: a2 };
  }
}
async function L(e) {
  return (0, a[e])();
}
async function g(e, r) {
  return (await t(e, { customParameters: r })).tileInfo;
}
async function P(e) {
  if (!e.length) return;
  const r = /* @__PURE__ */ new Set(), a2 = [];
  for (const { type: l2 } of e) r.has(l2) || (r.add(l2), a2.push(L(l(l2))));
  const t2 = await Promise.all(a2), s3 = /* @__PURE__ */ new Map();
  return Array.from(r).forEach((e2, r2) => {
    s3.set(e2, t2[r2]);
  }), (e2) => s3.get(e2.type);
}
export {
  p2 as fromUrl
};
//# sourceMappingURL=arcgisLayers-FRKHQ74Y.js.map
