import {
  S
} from "./chunk-4NBKAJGB.js";
import {
  a
} from "./chunk-QVM6IWUX.js";
import {
  e
} from "./chunk-ZMVRYYR6.js";
import {
  t
} from "./chunk-5BAQPFKY.js";
import {
  k
} from "./chunk-W75DBJD7.js";
import {
  O
} from "./chunk-YDTPM7OQ.js";
import {
  has
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/portal/support/featureCollectionUtils.js
function e2(e3) {
  return t2(e3, "notes");
}
function r(e3) {
  return t2(e3, "markup");
}
function n(e3) {
  return t2(e3, "route");
}
function t2(e3, r2) {
  return !(!e3.layerType || "ArcGISFeatureLayer" !== e3.layerType) && e3.featureCollectionType === r2;
}

// node_modules/@arcgis/core/layers/support/layersCreator.js
async function l(e3, r2, a2) {
  if (!r2) return;
  const y = r2.map((e4) => f(e4, a2)), t3 = await Promise.allSettled(y);
  for (const i of t3) "rejected" === i.status || i.value && e3.add(i.value);
}
var s = { ArcGISDimensionLayer: "DimensionLayer", ArcGISFeatureLayer: "FeatureLayer", ArcGISImageServiceLayer: "ImageryLayer", ArcGISMapServiceLayer: "MapImageLayer", ArcGISSceneServiceLayer: "SceneLayer", ArcGISTiledElevationServiceLayer: "ElevationLayer", ArcGISTiledImageServiceLayer: "ImageryTileLayer", ArcGISTiledMapServiceLayer: "TileLayer", BuildingSceneLayer: "BuildingSceneLayer", CatalogLayer: "CatalogLayer", CSV: "CSVLayer", DefaultTileLayer: "TileLayer", GaussianSplatLayer: "GaussianSplatLayer", GeoJSON: "GeoJSONLayer", GroupLayer: "GroupLayer", IntegratedMesh3DTilesLayer: "IntegratedMesh3DTilesLayer", Object3DTilesLayer: "UnsupportedLayer", IntegratedMeshLayer: "IntegratedMeshLayer", KML: "KMLLayer", LineOfSightLayer: "LineOfSightLayer", MediaLayer: "MediaLayer", OGCFeatureLayer: "OGCFeatureLayer", OrientedImageryLayer: "OrientedImageryLayer", PointCloudLayer: "PointCloudLayer", RasterDataLayer: "UnsupportedLayer", VectorTileLayer: "VectorTileLayer", ViewshedLayer: "ViewshedLayer", Voxel: "VoxelLayer", WCS: "WCSLayer", WFS: "WFSLayer", WMS: "WMSLayer", WebTiledLayer: "WebTileLayer" };
var c = { ArcGISTiledElevationServiceLayer: "ElevationLayer", DefaultTileLayer: "ElevationLayer", RasterDataElevationLayer: "UnsupportedLayer" };
var p = { ArcGISFeatureLayer: "FeatureLayer" };
var S2 = { ArcGISImageServiceLayer: "UnsupportedLayer", ArcGISMapServiceLayer: "UnsupportedLayer", ArcGISSceneServiceLayer: "SceneLayer", ArcGISTiledImageServiceLayer: "ImageryTileLayer", ArcGISTiledMapServiceLayer: "TileLayer", DefaultTileLayer: "TileLayer", OpenStreetMap: "OpenStreetMapLayer", VectorTileLayer: "VectorTileLayer", WCS: "UnsupportedLayer", WMS: "UnsupportedLayer", WebTiledLayer: "WebTileLayer" };
var u = { IntegratedMesh3DTilesLayer: "IntegratedMesh3DTilesLayer" };
var d = { ArcGISAnnotationLayer: "UnsupportedLayer", ArcGISDimensionLayer: "UnsupportedLayer", ArcGISFeatureLayer: "FeatureLayer", ArcGISImageServiceLayer: "ImageryLayer", ArcGISImageServiceVectorLayer: "ImageryLayer", ArcGISMapServiceLayer: "MapImageLayer", ArcGISStreamLayer: "StreamLayer", ArcGISTiledImageServiceLayer: "ImageryTileLayer", ArcGISTiledMapServiceLayer: "TileLayer", ArcGISVideoLayer: "VideoLayer", BingMapsAerial: "BingMapsLayer", BingMapsHybrid: "BingMapsLayer", BingMapsRoad: "BingMapsLayer", CatalogLayer: "CatalogLayer", CSV: "CSVLayer", DefaultTileLayer: "TileLayer", GeoJSON: "GeoJSONLayer", GeoRSS: "GeoRSSLayer", GroupLayer: "GroupLayer", KML: "KMLLayer", KnowledgeGraphLayer: "KnowledgeGraphLayer", MediaLayer: "MediaLayer", OGCFeatureLayer: "OGCFeatureLayer", OrientedImageryLayer: "OrientedImageryLayer", get ParquetLayer() {
  return has("parquetlayer-persistence-enabled") ? "ParquetLayer" : "UnsupportedLayer";
}, SubtypeGroupLayer: "SubtypeGroupLayer", VectorTileLayer: "VectorTileLayer", WCS: "WCSLayer", WFS: "WFSLayer", WMS: "WMSLayer", WebTiledLayer: "WebTileLayer" };
var I = { ArcGISFeatureLayer: "FeatureLayer", SubtypeGroupTable: "SubtypeGroupLayer" };
var g = { ArcGISImageServiceLayer: "ImageryLayer", ArcGISImageServiceVectorLayer: "ImageryLayer", ArcGISMapServiceLayer: "MapImageLayer", ArcGISTiledImageServiceLayer: "ImageryTileLayer", ArcGISTiledMapServiceLayer: "TileLayer", BingMapsAerial: "BingMapsLayer", BingMapsHybrid: "BingMapsLayer", BingMapsRoad: "BingMapsLayer", DefaultTileLayer: "TileLayer", OpenStreetMap: "OpenStreetMapLayer", VectorTileLayer: "VectorTileLayer", WCS: "WCSLayer", WMS: "WMSLayer", WebTiledLayer: "WebTileLayer" };
var m = { ...d, LinkChartLayer: "LinkChartLayer" };
var T = { ...I };
var G = { ...g };
async function f(e3, r2) {
  return M(await b(e3, r2), e3, r2);
}
async function M(e3, r2, a2) {
  const y = new e3();
  return y.read(r2, a2.context), "group" === y.type && ("GroupLayer" === r2.layerType ? await C(y, r2, a2) : w(r2) ? h(y, r2, a2.context) : A(r2) && await W(y, r2, a2.context)), await t(y, a2.context), y;
}
async function b(e3, o) {
  const l2 = o.context, s2 = v(l2);
  let c2 = e3.layerType || e3.type;
  !c2 && o?.defaultLayerType && (c2 = o.defaultLayerType);
  const p2 = s2[c2];
  let S3 = p2 ? a[p2] : a.UnknownLayer;
  if (w(e3)) {
    const t3 = l2?.portal;
    if (e3.itemId) {
      const i = new k({ id: e3.itemId, portal: t3 });
      await i.load();
      const L = (await S(i, new e())).className || "UnknownLayer";
      S3 = a[L];
    }
  } else "ArcGISFeatureLayer" === c2 ? e2(e3) || r(e3) ? S3 = a.MapNotesLayer : n(e3) ? S3 = a.RouteLayer : A(e3) && (S3 = a.GroupLayer) : e3.wmtsInfo?.url && e3.wmtsInfo.layerIdentifier ? S3 = a.WMTSLayer : "WFS" === c2 && "2.0.0" !== e3.wfsInfo?.version && (S3 = a.UnsupportedLayer);
  return S3();
}
function A(e3) {
  if ("ArcGISFeatureLayer" !== e3.layerType || w(e3)) return false;
  return (e3.featureCollection?.layers?.length ?? 0) > 1;
}
function w(e3) {
  return "Feature Collection" === e3.type;
}
function v(e3) {
  let r2;
  switch (e3.origin) {
    case "web-scene":
      switch (e3.layerContainerType) {
        case "basemap-base-layers":
          r2 = S2;
          break;
        case "basemap-ground-layers":
          r2 = u;
          break;
        case "ground":
          r2 = c;
          break;
        case "tables":
          r2 = p;
          break;
        default:
          r2 = s;
      }
      break;
    case "link-chart":
      switch (e3.layerContainerType) {
        case "basemap-base-layers":
          r2 = G;
          break;
        case "tables":
          r2 = T;
          break;
        default:
          r2 = m;
      }
      break;
    default:
      switch (e3.layerContainerType) {
        case "basemap-base-layers":
          r2 = g;
          break;
        case "tables":
          r2 = I;
          break;
        default:
          r2 = d;
      }
  }
  return r2;
}
async function C(r2, a2, y) {
  const t3 = new O(), i = l(t3, Array.isArray(a2.layers) ? a2.layers : [], y);
  try {
    try {
      if (await i, "group" === r2.type) return r2.layers.addMany(t3), r2;
    } catch (L) {
      r2.destroy();
      for (const e3 of t3) e3.destroy();
      throw L;
    }
  } catch (L) {
    throw L;
  }
}
function h(e3, r2, a2) {
  r2.itemId && (e3.portalItem = new k({ id: r2.itemId, portal: a2?.portal }), e3.when(() => {
    const y = (y2) => {
      const t3 = y2.layerId;
      F(y2, e3, r2, t3, a2);
      const i = r2.featureCollection?.layers?.[t3];
      i && y2.read(i, a2);
    };
    e3.layers?.forEach(y), e3.tables?.forEach(y);
  }));
}
async function W(e3, r2, y) {
  const t3 = a.FeatureLayer, i = await t3(), L = r2.featureCollection, n2 = L?.showLegend, o = L?.layers?.map((a2, t4) => {
    const L2 = new i();
    L2.read(a2, y);
    const o2 = { ...y, ignoreDefaults: true };
    return F(L2, e3, r2, t4, o2), null != n2 && L2.read({ showLegend: n2 }, o2), L2;
  });
  e3.layers.addMany(o ?? []);
}
function F(e3, r2, a2, y, t3) {
  e3.read({ id: `${r2.id}-sublayer-${y}`, visibility: a2.visibleLayers?.includes(y) ?? true }, t3);
}

export {
  l,
  C
};
//# sourceMappingURL=chunk-LWUV664B.js.map
