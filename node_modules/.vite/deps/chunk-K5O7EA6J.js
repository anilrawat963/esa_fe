import {
  n,
  p as p2
} from "./chunk-NFPLS75J.js";
import {
  i as i3
} from "./chunk-WVAXXVEK.js";
import {
  s as s3
} from "./chunk-NJSGYS3K.js";
import {
  i as i2,
  s as s2
} from "./chunk-A7O5R67Z.js";
import {
  u
} from "./chunk-CZOYDK6P.js";
import {
  o as o2
} from "./chunk-HROH5C5D.js";
import {
  m as m3
} from "./chunk-ET5EDAFM.js";
import {
  k
} from "./chunk-W75DBJD7.js";
import {
  M
} from "./chunk-7P2ANHQ3.js";
import {
  z
} from "./chunk-H74Q4SYB.js";
import {
  f
} from "./chunk-5T3MJDSR.js";
import {
  H2 as H,
  m2,
  p2 as p,
  w
} from "./chunk-V2H77UEV.js";
import {
  o
} from "./chunk-XWE6BM2U.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  L
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/layers/support/I3SIndexInfo.js
async function r(r2, n3, t, s4, a2, i4, l) {
  let d = null;
  if (null != t) {
    const o3 = `${r2}/nodepages/`, n4 = o3 + Math.floor(t.rootIndex / t.nodesPerPage);
    try {
      return { type: "page", rootPage: (await H(n4, { query: { f: "json", ...s4, token: a2 }, responseType: "json", signal: l })).data, rootIndex: t.rootIndex, pageSize: t.nodesPerPage, lodMetric: t.lodSelectionMetricType, urlPrefix: o3 };
    } catch (g) {
      null != i4 && i4.warn("#fetchIndexInfo()", "Failed to load root node page. Falling back to node documents.", n4, g), d = g;
    }
  }
  if (!n3) return null;
  const p3 = n3?.split("/").pop(), c = `${r2}/nodes/`, u3 = c + p3;
  try {
    return { type: "node", rootNode: (await H(u3, { query: { f: "json", ...s4, token: a2 }, responseType: "json", signal: l })).data, urlPrefix: c };
  } catch (g) {
    throw new s("sceneservice:root-node-missing", "Root node missing.", { pageError: d, nodeError: g, url: u3 });
  }
}

// node_modules/@arcgis/core/layers/support/schemaValidatorLoader.js
var n2 = null;
function u2() {
  return n2;
}

// node_modules/@arcgis/core/layers/mixins/SceneService.js
var _ = (_2) => {
  const A = _2;
  let E = class extends A {
    constructor() {
      super(...arguments), this.spatialReference = null, this.fullExtent = null, this.heightModelInfo = null, this.minScale = 0, this.maxScale = 0, this.version = { major: Number.NaN, minor: Number.NaN, versionString: "" }, this.copyright = null, this.sublayerTitleMode = "item-title", this.title = null, this.layerId = null, this.url = null, this.indexInfo = null, this._debouncedSaveOperations = L(async (e, t, r2) => {
        switch (e) {
          case 0:
            return this._save(t);
          case 1:
            return this._saveAs(r2, t);
        }
      });
    }
    readSpatialReference(e, t) {
      return L2(t);
    }
    readFullExtent(e, t, r2) {
      if (null != e && "object" == typeof e) {
        const o4 = null == e.spatialReference ? { ...e, spatialReference: L2(t) } : e;
        return z.fromJSON(o4, r2);
      }
      const o3 = t.store, i4 = L2(t);
      return null == i4 || null == o3?.extent || !Array.isArray(o3.extent) || o3.extent.some((e2) => e2 < R) ? null : new z({ xmin: o3.extent[0], ymin: o3.extent[1], xmax: o3.extent[2], ymax: o3.extent[3], spatialReference: i4 });
    }
    parseVersionString(e) {
      const t = { major: Number.NaN, minor: Number.NaN, versionString: e }, r2 = e.split(".");
      return r2.length >= 2 && (t.major = parseInt(r2[0], 10), t.minor = parseInt(r2[1], 10)), t;
    }
    readVersion(e, t) {
      const r2 = t.store, o3 = null != r2.version ? r2.version.toString() : "";
      return this.parseVersionString(o3);
    }
    readTitlePortalItem(e) {
      return "item-title" !== this.sublayerTitleMode ? void 0 : e;
    }
    readTitleService(e, t) {
      const r2 = this.portalItem?.title;
      if ("item-title" === this.sublayerTitleMode) return this.url ? w(this.url, t.name) : t.name;
      let o3 = t.name;
      if (!o3 && this.url) {
        const e2 = p(this.url);
        null != e2 && (o3 = e2.title);
      }
      return "item-title-and-service-name" === this.sublayerTitleMode && r2 && (o3 = r2 + " - " + o3), m2(o3);
    }
    get parsedUrl() {
      return s2(this, { separator: "layers" });
    }
    async _fetchIndexAndUpdateExtent(e, t) {
      this.indexInfo = r(this.parsedUrl?.path ?? "", this.rootNode, e, this.customParameters, this.apiKey, i.getLogger(this), t);
      const { fullExtent: r2 } = this;
      null == r2 || r2.hasZ || this._updateExtent(r2, await this.indexInfo);
    }
    _updateExtent(e, t) {
      if ("page" === t?.type) {
        const r2 = t.rootIndex % t.pageSize, o3 = t.rootPage?.nodes?.[r2];
        O(e, o3?.obb);
      } else if ("node" === t?.type) {
        const r2 = t.rootNode?.mbs;
        if (!Array.isArray(r2) || 4 !== r2.length || r2[0] < R) return;
        const o3 = r2[2], i4 = r2[3];
        e.zmin = o3 - i4, e.zmax = o3 + i4;
      }
    }
    async _fetchService(e) {
      if (null == this.url) throw new s("sceneservice:url-not-set", "Scene service can not be loaded without valid portal item or url");
      if (null == this.layerId && /SceneServer\/*$/i.test(this.url)) {
        const t = await this._fetchFirstLayerId(e);
        null != t && (this.layerId = t);
      }
      return this._fetchServiceLayer(e);
    }
    async _fetchFirstLayerId(e) {
      const r2 = await H(this.url ?? "", { query: { f: "json", ...this.customParameters, token: this.apiKey }, responseType: "json", signal: e });
      if (r2.data && Array.isArray(r2.data.layers) && r2.data.layers.length > 0) return r2.data.layers[0].id;
    }
    async _fetchServiceLayer(e) {
      const r2 = await H(this.parsedUrl?.path ?? "", { query: { f: "json", ...this.customParameters, token: this.apiKey }, responseType: "json", signal: e });
      r2.ssl && this.url && (this.url = this.url.replace(/^http:/i, "https:"));
      let o3 = false;
      if (r2.data.layerType && "Voxel" === r2.data.layerType && (o3 = true), o3) return this._fetchVoxelServiceLayer();
      const i4 = r2.data;
      this.read(i4, this._getServiceContext()), this.validateLayer(i4);
    }
    async _fetchVoxelServiceLayer(e) {
      const r2 = (await H(this.parsedUrl?.path + "/layer", { query: { f: "json", ...this.customParameters, token: this.apiKey }, responseType: "json", signal: e })).data;
      this.read(r2, this._getServiceContext()), this.validateLayer(r2);
    }
    _getServiceContext() {
      return { origin: "service", portalItem: this.portalItem, portal: this.portalItem?.portal, url: this.parsedUrl };
    }
    async _ensureLoadBeforeSave() {
      await this.load(), "beforeSave" in this && "function" == typeof this.beforeSave && await this.beforeSave();
    }
    validateLayer(e) {
    }
    async _saveAs(e, t) {
      const o3 = { ...P, ...t };
      let i4 = k.from(e);
      if (!i4) throw new s("sceneservice:portal-item-required", "_saveAs() requires a portal item to save to");
      i4.id && (i4 = i4.clone(), i4.id = null);
      const s4 = i4.portal || M.getDefault();
      await this._ensureLoadBeforeSave(), i4.type = U, i4.portal = s4;
      const a2 = o2(i4, "portal-item", true), n3 = { layers: [this.write({}, a2)] };
      return await Promise.all(a2.resources.pendingOperations ?? []), await this._validateAgainstJSONSchema(n3, a2, o3), this.url && (i4.url = this.url), i4.title || (i4.title = this.title), T(i4, o3, 1), await s4.signIn(), await s4.user.addItem({ item: i4, folder: o3?.folder, data: n3 }), await p2(this.resourceReferences, a2), this.portalItem = i4, i3(a2), a2.portalItem = i4, i4;
    }
    async _save(e) {
      const t = { ...P, ...e };
      if (!this.portalItem) throw new s("sceneservice:portal-item-not-set", "Portal item to save to has not been set on this SceneService");
      if (this.portalItem.type !== U) throw new s("sceneservice:portal-item-wrong-type", `Portal item needs to have type "${U}"`);
      await this._ensureLoadBeforeSave();
      const o3 = o2(this.portalItem, "portal-item", true), i4 = { layers: [this.write({}, o3)] };
      return await Promise.all(o3.resources.pendingOperations ?? []), await this._validateAgainstJSONSchema(i4, o3, t), this.url && (this.portalItem.url = this.url), this.portalItem.title || (this.portalItem.title = this.title), T(this.portalItem, t, 0), await n(this.portalItem, i4, this.resourceReferences, o3), i3(o3), this.portalItem;
    }
    async _validateAgainstJSONSchema(e, t, i4) {
      const s4 = i4?.validationOptions;
      s3(t, { errorName: "sceneservice:save" }, { ignoreUnsupported: s4?.ignoreUnsupported, supplementalUnsupportedErrors: ["scenemodification:unsupported"] });
      const a2 = s4?.enabled, n3 = u2();
      if (a2 && n3) {
        const t2 = (await n3()).validate(e, i4.portalItemLayerType);
        if (!t2.length) return;
        const a3 = `Layer item did not validate:
${t2.join("\n")}`;
        if (i.getLogger(this).error(`_validateAgainstJSONSchema(): ${a3}`), "throw" === s4.failPolicy) {
          const e2 = t2.map((e3) => new s("sceneservice:schema-validation", e3));
          throw new s("sceneservice-validate:error", "Failed to save layer item due to schema validation, see `details.errors`.", { validationErrors: e2 });
        }
      }
    }
  };
  return __decorate([m(u)], E.prototype, "id", void 0), __decorate([m({ type: f })], E.prototype, "spatialReference", void 0), __decorate([o("spatialReference", ["spatialReference", "store.indexCRS", "store.geographicCRS"])], E.prototype, "readSpatialReference", null), __decorate([m({ type: z })], E.prototype, "fullExtent", void 0), __decorate([o("fullExtent", ["fullExtent", "store.extent", "spatialReference", "store.indexCRS", "store.geographicCRS"])], E.prototype, "readFullExtent", null), __decorate([m({ readOnly: true, type: m3 })], E.prototype, "heightModelInfo", void 0), __decorate([m({ type: Number, json: { name: "layerDefinition.minScale", write: true, origins: { service: { read: { source: "minScale" }, write: false } } } })], E.prototype, "minScale", void 0), __decorate([m({ type: Number, json: { name: "layerDefinition.maxScale", write: true, origins: { service: { read: { source: "maxScale" }, write: false } } } })], E.prototype, "maxScale", void 0), __decorate([m({ readOnly: true })], E.prototype, "version", void 0), __decorate([o("version", ["store.version"])], E.prototype, "readVersion", null), __decorate([m({ type: String, json: { read: { source: "copyrightText" } } })], E.prototype, "copyright", void 0), __decorate([m({ type: String, json: { read: false } })], E.prototype, "sublayerTitleMode", void 0), __decorate([m({ type: String })], E.prototype, "title", void 0), __decorate([o("portal-item", "title")], E.prototype, "readTitlePortalItem", null), __decorate([o("service", "title", ["name"])], E.prototype, "readTitleService", null), __decorate([m({ type: Number, json: { origins: { service: { read: { source: "id" } }, "portal-item": { write: { target: "id", isRequired: true, ignoreOrigin: true }, read: false } } } })], E.prototype, "layerId", void 0), __decorate([m(i2({ separator: "layers" }))], E.prototype, "url", void 0), __decorate([m({ readOnly: true })], E.prototype, "parsedUrl", null), __decorate([m({ readOnly: true })], E.prototype, "store", void 0), __decorate([m({ type: String, readOnly: true, json: { read: { source: "store.rootNode" } } })], E.prototype, "rootNode", void 0), E = __decorate([a("esri.layers.mixins.SceneService")], E), E;
};
var R = -1e38;
function L2(e) {
  if (null != e.spatialReference) return f.fromJSON(e.spatialReference);
  const t = e.store, r2 = t.indexCRS || t.geographicCRS, o3 = r2 && parseInt(r2.slice(r2.lastIndexOf("/") + 1), 10);
  return null != o3 ? new f(o3) : null;
}
function O(e, t) {
  if (null == t?.center || null == t.halfSize) throw new s("sceneservice:invalid-node-page", "Invalid node page.");
  if (t.center[0] < R) return;
  const o3 = t.halfSize, i4 = t.center[2], s4 = Math.sqrt(o3[0] * o3[0] + o3[1] * o3[1] + o3[2] * o3[2]);
  e.zmin = i4 - s4, e.zmax = i4 + s4;
}
function T(e, t, r2) {
  e.typeKeywords || (e.typeKeywords = []);
  const o3 = t.getTypeKeywords();
  for (const i4 of o3) e.typeKeywords.push(i4);
  e.typeKeywords && (e.typeKeywords = e.typeKeywords.filter((e2, t2, r3) => r3.indexOf(e2) === t2), 1 === r2 && (e.typeKeywords = e.typeKeywords.filter((e2) => "Hosted Service" !== e2)));
}
var U = "Scene Service";
var P = { getTypeKeywords: () => [], portalItemLayerType: "unknown", validationOptions: { enabled: true, ignoreUnsupported: false, failPolicy: "throw" } };

export {
  r,
  _,
  O
};
//# sourceMappingURL=chunk-K5O7EA6J.js.map
