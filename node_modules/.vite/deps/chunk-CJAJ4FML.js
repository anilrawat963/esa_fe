import {
  s as s2
} from "./chunk-WRA2WBYC.js";
import {
  n
} from "./chunk-XXLHAM2M.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  a,
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/layers/support/SimpleBandStatistics.js
var l = class {
  constructor(l3 = null, a4 = null, t2 = null) {
    this.minValue = l3, this.maxValue = a4, this.noDataValue = t2;
  }
};

// node_modules/@arcgis/core/layers/support/rasterFormats/pixelRangeUtils.js
var t = 9999999e31;
var n2 = 2e-7;
var e = { u1: [0, 1], u2: [0, 3], u4: [0, 15], u8: [0, 255], s8: [-128, 127], u16: [0, 65535], s16: [-32768, 32767], u32: [0, 4294967295], s32: [-2147483648, 2147483647], f32: [-34028234663852886e22, 34028234663852886e22], f64: [-Number.MAX_VALUE, Number.MAX_VALUE], unknown: void 0, c64: void 0, c128: void 0 };
function u(t2) {
  return e[t2] ?? [-34028234663852886e22, 34028234663852886e22];
}
var s3 = { u1: 1, u2: 1, u4: 1, u8: 1, s8: 1, u16: 2, s16: 2, u32: 4, s32: 4, f32: 4, f64: 8, unknown: 4, c64: 16, c128: 32 };
function o(t2) {
  return s3[t2];
}
function l2(t2) {
  return o(t2.pixelType) * t2.bandCount;
}
function i2(t2, n3) {
  return null == t2 || null == n3 ? "s32" : t2 < 0 ? t2 >= -128 && n3 < 128 ? "s8" : t2 >= -32768 && n3 < 32768 ? "s16" : "s32" : n3 < 256 ? "u8" : n3 < 65536 ? "u16" : "u32";
}
function r(t2) {
  return (t2?.startsWith("s") || t2?.startsWith("u")) ?? false;
}
function c(t2, n3, e2, s4) {
  let [o2, l3] = u(e2);
  const i3 = r(e2);
  return i3 && (o2 -= 1e-5, l3 += 1e-5), i3 ? e2.startsWith("u") ? a3(t2, n3, s4, [o2, l3]) : h(t2, n3, s4, [o2, l3]) : b(t2, n3, s4, [o2, l3]);
}
function f(t2, n3) {
  for (let e2 = 0; e2 < n3.length; e2++) n3[e2] && isNaN(t2[e2]) && (n3[e2] = 0, t2[e2] = 0);
}
function a3(t2, n3, e2, u3) {
  const [s4, o2] = u3;
  for (let l3 = 0; l3 < n3.length; l3++) if (n3[l3]) {
    const u4 = t2[l3];
    u4 < s4 || u4 > o2 ? n3[l3] = 0 : e2[l3] = u4 + 0.5 | 0;
  }
}
function h(t2, n3, e2, u3) {
  const [s4, o2] = u3;
  for (let l3 = 0; l3 < n3.length; l3++) if (n3[l3]) {
    const u4 = t2[l3];
    u4 < s4 || u4 > o2 ? n3[l3] = 0 : e2[l3] = u4 + (u4 > 0 ? 0.5 : -0.5) | 0;
  }
}
function b(t2, n3, e2, u3) {
  const [s4, o2] = u3;
  for (let l3 = 0; l3 < n3.length; l3++) if (n3[l3]) {
    const u4 = t2[l3];
    u4 < s4 || u4 > o2 ? n3[l3] = 0 : e2[l3] = u4;
  }
}
function g(e2, s4, o2) {
  if (e2.depthCount && e2.depthCount > 1) return;
  const { pixels: l3, statistics: i3, pixelType: r2 } = e2, c3 = l3[0].length, f2 = e2.bandMasks ?? [], a4 = e2.mask ?? new Uint8Array(c3).fill(255), h2 = "f32" === r2 || "f64" === r2, b2 = u(r2);
  let g2 = false;
  for (let u3 = 0; u3 < l3.length; u3++) {
    const e3 = "number" == typeof s4 ? s4 : s4[u3];
    if (null == e3) continue;
    const c4 = i3?.[u3]?.minValue ?? b2[0], m3 = i3?.[u3]?.maxValue ?? b2[1];
    if (c4 > e3 + Number.EPSILON || m3 < e3 - Number.EPSILON) continue;
    const p2 = f2[u3] || a4.slice(), d = l3[u3], N = o2?.customFloatTolerance;
    if (h2 && 0 !== N) {
      let u4 = N;
      u4 || (u4 = Math.abs(e3) >= t ? n2 * Math.abs(e3) : "f32" === r2 ? 2 ** -23 : Number.EPSILON);
      for (let t2 = 0; t2 < d.length; t2++) p2[t2] && Math.abs(d[t2] - e3) < u4 && (d[t2] = 0, p2[t2] = 0, a4[t2] = 0, g2 = true);
    } else for (let t2 = 0; t2 < d.length; t2++) p2[t2] && d[t2] === e3 && (d[t2] = 0, p2[t2] = 0, a4[t2] = 0, g2 = true);
    f2[u3] = p2;
  }
  if (g2) {
    const t2 = e2.bandMasks || e2.pixels.length > 1 ? f2 : null;
    o2?.matchAllNoData ? e2.mask = t2 && t2.length > 1 ? m2(t2) : a4 : (e2.bandMasks = t2, e2.mask = a4);
  }
  function m2(t2) {
    if (t2.length < 2) return t2[0];
    const n3 = t2[0].length, e3 = new Uint8Array(n3).fill(0);
    for (let u3 = 0; u3 < t2.length; u3++) {
      const s5 = t2[u3];
      for (let t3 = 0; t3 < n3; t3++) s5[t3] && (e3[t3] = 255);
    }
    return e3;
  }
  g2 && "updateStatistics" in e2 && e2.updateStatistics();
}

// node_modules/@arcgis/core/layers/support/PixelBlock.js
var p;
var c2 = p = class extends n {
  static createEmptyBand(t2, s4) {
    return new (p.getPixelArrayConstructor(t2))(s4);
  }
  static combineBandMasks(t2) {
    if (t2.length < 2) return t2[0];
    const s4 = t2[0].length, e2 = new Uint8Array(s4).fill(255);
    for (let i3 = 0; i3 < t2.length; i3++) {
      const l3 = t2[i3];
      for (let t3 = 0; t3 < s4; t3++) l3[t3] || (e2[t3] = 0);
    }
    return e2;
  }
  static getPixelArrayConstructor(t2) {
    let s4;
    switch (t2) {
      case "u1":
      case "u2":
      case "u4":
      case "u8":
        s4 = Uint8Array;
        break;
      case "u16":
        s4 = Uint16Array;
        break;
      case "u32":
        s4 = Uint32Array;
        break;
      case "s8":
        s4 = Int8Array;
        break;
      case "s16":
        s4 = Int16Array;
        break;
      case "s32":
        s4 = Int32Array;
        break;
      case "f32":
      case "c64":
      case "c128":
      case "unknown":
        s4 = Float32Array;
        break;
      case "f64":
        s4 = Float64Array;
    }
    return s4;
  }
  constructor(t2) {
    super(t2), this.width = null, this.height = null, this.pixelType = "f32", this.validPixelCount = null, this.mask = null, this.maskIsAlpha = false, this.premultiplyAlpha = false, this.statistics = null, this.depthCount = 1;
  }
  castPixelType(t2) {
    if (!t2) return "f32";
    let s4 = t2.toLowerCase();
    return ["u1", "u2", "u4"].includes(s4) ? s4 = "u8" : ["unknown", "u8", "s8", "u16", "s16", "u32", "s32", "f32", "f64"].includes(s4) || (s4 = "f32"), s4;
  }
  getPlaneCount() {
    return this.pixels?.length;
  }
  addData(t2) {
    if (!t2.pixels || t2.pixels.length !== this.width * this.height) throw new s("pixelblock:invalid-or-missing-pixels", "add data requires valid pixels array that has same length defined by pixel block width * height");
    this.pixels || (this.pixels = []), this.statistics || (this.statistics = []), this.pixels.push(t2.pixels), this.statistics.push(t2.statistics ?? new l());
  }
  getAsRGBA() {
    const t2 = new ArrayBuffer(this.width * this.height * 4);
    switch (this.pixelType) {
      case "s8":
      case "s16":
      case "u16":
      case "s32":
      case "u32":
      case "f32":
      case "f64":
        this._fillFromNon8Bit(t2);
        break;
      default:
        this._fillFrom8Bit(t2);
    }
    return new Uint8ClampedArray(t2);
  }
  getAsRGBAFloat() {
    const t2 = new Float32Array(this.width * this.height * 4);
    return this._fillFrom32Bit(t2), t2;
  }
  updateStatistics() {
    if (!this.pixels) return;
    this.statistics = this.pixels.map((t3) => u2(t3, this.mask));
    const t2 = this.mask;
    let s4 = 0;
    if (null != t2) for (let e2 = 0; e2 < t2.length; e2++) t2[e2] && s4++;
    else s4 = this.width * this.height;
    this.validPixelCount = s4;
  }
  clamp(t2) {
    if (!t2 || "f64" === t2 || "f32" === t2 || !this.pixels) return;
    const [s4, e2] = u(t2), i3 = this.pixels, l3 = this.width * this.height, r2 = i3.length;
    let o2, a4, n3;
    const c3 = [];
    for (let h2 = 0; h2 < r2; h2++) {
      n3 = p.createEmptyBand(t2, l3), o2 = i3[h2];
      for (let t3 = 0; t3 < l3; t3++) a4 = o2[t3], n3[t3] = a4 > e2 ? e2 : a4 < s4 ? s4 : a4;
      c3.push(n3);
    }
    this.pixels = c3, this.pixelType = t2;
  }
  extractBands(t2) {
    const { pixels: s4, statistics: e2 } = this;
    if (null == t2 || 0 === t2.length || !s4 || 0 === s4.length) return this;
    const i3 = s4.length, l3 = t2.some((t3) => t3 >= s4.length), r2 = i3 === t2.length && !t2.some((t3, s5) => t3 !== s5);
    if (l3 || r2) return this;
    const o2 = this.bandMasks?.length === i3 ? t2.map((t3) => this.bandMasks[t3]) : void 0;
    let { mask: a4, validPixelCount: n3 } = this;
    const { width: h2, height: c3 } = this;
    return o2?.length && (a4 = p.combineBandMasks(o2), n3 = a4.filter((t3) => !!t3).length), new p({ pixelType: this.pixelType, width: h2, height: c3, mask: a4, bandMasks: o2, validPixelCount: n3, maskIsAlpha: this.maskIsAlpha, pixels: t2.map((t3) => s4[t3]), statistics: e2 && t2.map((t3) => e2[t3]) });
  }
  clone() {
    const t2 = new p({ width: this.width, height: this.height, pixelType: this.pixelType, maskIsAlpha: this.maskIsAlpha, validPixelCount: this.validPixelCount, premultiplyAlpha: this.premultiplyAlpha, depthCount: this.depthCount });
    let s4;
    null != this.mask && (t2.mask = new Uint8Array(this.mask)), this.noDataValues && (t2.noDataValues = [...this.noDataValues]), this.bandMasks && (t2.bandMasks = this.bandMasks.map((t3) => new Uint8Array(t3)));
    const e2 = p.getPixelArrayConstructor(this.pixelType);
    if (this.pixels && this.pixels.length > 0) {
      t2.pixels = [];
      const i3 = !!this.pixels[0].slice;
      for (s4 = 0; s4 < this.pixels.length; s4++) t2.pixels[s4] = i3 ? this.pixels[s4].slice() : new e2(this.pixels[s4]);
    }
    if (this.statistics) for (t2.statistics = [], s4 = 0; s4 < this.statistics.length; s4++) t2.statistics[s4] = a(this.statistics[s4]);
    return t2;
  }
  getTransferableObject() {
    const { pixels: t2, bandMasks: s4, mask: e2 } = this;
    this.pixels = [], this.bandMasks = void 0, this.mask = void 0;
    const i3 = this.toJSON();
    this.pixels = t2, this.bandMasks = s4, this.mask = e2, i3.pixels = t2 ? [...t2] : t2, i3.bandMasks = s4 ? [...s4] : s4, i3.mask = e2;
    const l3 = [];
    return [...t2 ?? [], e2, ...s4 ?? []].filter((t3) => null != t3 && ArrayBuffer.isView(t3)).forEach((t3) => {
      t3 && !l3.includes(t3.buffer) && l3.push(t3.buffer);
    }), { pixelBlock: i3, transferList: l3 };
  }
  _fillFrom8Bit(t2) {
    const { mask: s4, maskIsAlpha: e2, premultiplyAlpha: i3, pixels: r2 } = this;
    if (!t2 || !r2?.length) return void i.getLogger(this).error("getAsRGBA()", "Unable to convert to RGBA. The input pixel block is empty.");
    let o2, a4, n3, h2;
    o2 = a4 = n3 = r2[0], r2.length >= 3 ? (a4 = r2[1], n3 = r2[2]) : 2 === r2.length && (a4 = r2[1]);
    const p2 = new Uint32Array(t2), c3 = this.width * this.height;
    if (o2.length === c3) if (null != s4 && s4.length === c3) if (e2) for (h2 = 0; h2 < c3; h2++) {
      const t3 = s4[h2];
      if (t3) {
        const s5 = t3 / 255;
        p2[h2] = i3 ? t3 << 24 | n3[h2] * s5 << 16 | a4[h2] * s5 << 8 | o2[h2] * s5 : t3 << 24 | n3[h2] << 16 | a4[h2] << 8 | o2[h2];
      }
    }
    else for (h2 = 0; h2 < c3; h2++) s4[h2] && (p2[h2] = 255 << 24 | n3[h2] << 16 | a4[h2] << 8 | o2[h2]);
    else for (h2 = 0; h2 < c3; h2++) p2[h2] = 255 << 24 | n3[h2] << 16 | a4[h2] << 8 | o2[h2];
    else i.getLogger(this).error("getAsRGBA()", "Unable to convert to RGBA. The pixelblock is invalid.");
  }
  _fillFromNon8Bit(t2) {
    const { pixels: s4, mask: e2, statistics: i3 } = this;
    if (!t2 || !s4?.length) return void i.getLogger(this).error("getAsRGBA()", "Unable to convert to RGBA. The input pixel block is empty.");
    const r2 = this.pixelType;
    let o2 = 1, a4 = 0, n3 = 1;
    if (i3 && i3.length > 0) {
      for (const t3 of i3) if (null != t3.minValue && (a4 = Math.min(a4, t3.minValue)), null != t3.maxValue && null != t3.minValue) {
        const s5 = t3.maxValue - t3.minValue;
        n3 = Math.max(n3, s5);
      }
      o2 = 255 / n3;
    } else {
      let t3 = 255;
      "s8" === r2 ? (a4 = -128, t3 = 127) : "u16" === r2 ? t3 = 65535 : "s16" === r2 ? (a4 = -32768, t3 = 32767) : "u32" === r2 ? t3 = 4294967295 : "s32" === r2 ? (a4 = -2147483648, t3 = 2147483647) : "f32" === r2 ? (a4 = -34e38, t3 = 34e38) : "f64" === r2 && (a4 = -Number.MAX_VALUE, t3 = Number.MAX_VALUE), o2 = 255 / (t3 - a4);
    }
    const h2 = new Uint32Array(t2), p2 = this.width * this.height;
    let c3, u3, f2, g2, m2;
    if (c3 = u3 = f2 = s4[0], c3.length !== p2) return i.getLogger(this).error("getAsRGBA()", "Unable to convert to RGBA. The pixelblock is invalid.");
    if (s4.length >= 2) if (u3 = s4[1], s4.length >= 3 && (f2 = s4[2]), null != e2 && e2.length === p2) for (g2 = 0; g2 < p2; g2++) e2[g2] && (h2[g2] = 255 << 24 | (f2[g2] - a4) * o2 << 16 | (u3[g2] - a4) * o2 << 8 | (c3[g2] - a4) * o2);
    else for (g2 = 0; g2 < p2; g2++) h2[g2] = 255 << 24 | (f2[g2] - a4) * o2 << 16 | (u3[g2] - a4) * o2 << 8 | (c3[g2] - a4) * o2;
    else if (null != e2 && e2.length === p2) for (g2 = 0; g2 < p2; g2++) m2 = (c3[g2] - a4) * o2, e2[g2] && (h2[g2] = 255 << 24 | m2 << 16 | m2 << 8 | m2);
    else for (g2 = 0; g2 < p2; g2++) m2 = (c3[g2] - a4) * o2, h2[g2] = 255 << 24 | m2 << 16 | m2 << 8 | m2;
  }
  _fillFrom32Bit(t2) {
    const { pixels: s4, mask: e2 } = this;
    if (!t2 || !s4?.length) return i.getLogger(this).error("getAsRGBAFloat()", "Unable to convert to RGBA. The input pixel block is empty.");
    let i3, r2, o2, a4;
    i3 = r2 = o2 = s4[0], s4.length >= 3 ? (r2 = s4[1], o2 = s4[2]) : 2 === s4.length && (r2 = s4[1]);
    const n3 = this.width * this.height;
    if (i3.length !== n3) return i.getLogger(this).error("getAsRGBAFloat()", "Unable to convert to RGBA. The pixelblock is invalid.");
    let h2 = 0;
    if (null != e2 && e2.length === n3) for (a4 = 0; a4 < n3; a4++) t2[h2++] = i3[a4], t2[h2++] = r2[a4], t2[h2++] = o2[a4], t2[h2++] = 1 & e2[a4];
    else for (a4 = 0; a4 < n3; a4++) t2[h2++] = i3[a4], t2[h2++] = r2[a4], t2[h2++] = o2[a4], t2[h2++] = 1;
  }
};
function u2(t2, s4) {
  let e2 = 1 / 0, i3 = -1 / 0;
  const l3 = t2.length;
  let r2, o2 = 0;
  if (null != s4) for (r2 = 0; r2 < l3; r2++) s4[r2] && (o2 = t2[r2], e2 = o2 < e2 ? o2 : e2, i3 = o2 > i3 ? o2 : i3);
  else for (r2 = 0; r2 < l3; r2++) o2 = t2[r2], e2 = o2 < e2 ? o2 : e2, i3 = o2 > i3 ? o2 : i3;
  return new l(e2, i3);
}
__decorate([m({ json: { write: true } })], c2.prototype, "width", void 0), __decorate([m({ json: { write: true } })], c2.prototype, "height", void 0), __decorate([m({ json: { write: true } })], c2.prototype, "pixelType", void 0), __decorate([s2("pixelType")], c2.prototype, "castPixelType", null), __decorate([m({ json: { write: true } })], c2.prototype, "validPixelCount", void 0), __decorate([m({ json: { write: true } })], c2.prototype, "mask", void 0), __decorate([m({ json: { write: true } })], c2.prototype, "maskIsAlpha", void 0), __decorate([m({ json: { write: true } })], c2.prototype, "pixels", void 0), __decorate([m()], c2.prototype, "premultiplyAlpha", void 0), __decorate([m({ json: { write: true } })], c2.prototype, "statistics", void 0), __decorate([m({ json: { write: true } })], c2.prototype, "depthCount", void 0), __decorate([m({ json: { write: true } })], c2.prototype, "noDataValues", void 0), __decorate([m({ json: { write: true } })], c2.prototype, "bandMasks", void 0), c2 = p = __decorate([a2("esri.layers.support.PixelBlock")], c2);

export {
  l,
  u,
  l2,
  i2 as i,
  r,
  c,
  f,
  g,
  c2
};
//# sourceMappingURL=chunk-CJAJ4FML.js.map
