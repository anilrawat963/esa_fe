import {
  O,
  r,
  r2,
  u as u4
} from "./chunk-TWE24CRT.js";
import {
  re
} from "./chunk-JCMADXBT.js";
import {
  g
} from "./chunk-BA6HYZ35.js";
import {
  a,
  i as i2,
  u as u3
} from "./chunk-VGXUPJSS.js";
import {
  R,
  T,
  X,
  b,
  gt,
  lt
} from "./chunk-XX3OKYJS.js";
import {
  e
} from "./chunk-GCI4MA3M.js";
import {
  n,
  s
} from "./chunk-SJ2OBYX2.js";
import {
  e as e2
} from "./chunk-E2RVV63B.js";
import {
  i as i3
} from "./chunk-AJGINJLG.js";
import {
  o as o2
} from "./chunk-JE2NJSBU.js";
import {
  n as n2
} from "./chunk-WDTGOP77.js";
import {
  u as u2
} from "./chunk-HWUOAPTX.js";
import {
  u
} from "./chunk-TF6255HN.js";
import {
  P
} from "./chunk-PZ5RULLK.js";
import {
  c
} from "./chunk-FPMLKIDB.js";
import {
  i
} from "./chunk-TFJXG32O.js";
import {
  M
} from "./chunk-SMWUT52Z.js";
import {
  f
} from "./chunk-5T3MJDSR.js";
import {
  ae,
  o2 as o
} from "./chunk-NMQNUPE4.js";
import {
  t
} from "./chunk-6KIXN4DJ.js";
import {
  has
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/views/2d/layers/features/FeatureSpatialIndex.js
var n3 = class _n {
  static fromReader(s4) {
    const o7 = [], r8 = s4.copy(), i8 = u2();
    for (; r8.next(); ) {
      r8.getBounds(i8) && o7.push(r8.getIndex());
    }
    const m = i3(9, (s5) => (r8.setIndex(s5), { minX: r8.getBoundsXMin(), minY: r8.getBoundsYMin(), maxX: r8.getBoundsXMax(), maxY: r8.getBoundsYMax() }));
    return m.load(o7), new _n(m, o7.length);
  }
  constructor(s4, t4) {
    this._index = s4, this._size = t4;
  }
  get usedMemory() {
    return this._size * n;
  }
  search(s4) {
    const t4 = { minX: s4[0], minY: s4[1], maxX: s4[2], maxY: s4[3] };
    return this._index.search(t4);
  }
};

// node_modules/@arcgis/core/geohash/geohashUtils.js
var g2 = n2();
var d = n2();
var b2 = 64;
function v(t4, o7, r8, i8) {
  const l3 = [t4.xmin, t4.ymin, t4.xmax, t4.ymax], u6 = P.fromExtent(c(l3, i8)), m = g(u6, i8, f.WGS84, { extendedParams: { densificationStep: o7 * b2 } });
  if (!m) return null;
  const h3 = X(new e(), m, false, false), p = h3.coords.filter((t5, o8) => !(o8 % 2)), g3 = h3.coords.filter((t5, o8) => o8 % 2), d4 = Math.min(...p), x = Math.min(...g3), y = Math.max(...p), j = Math.max(...g3), M2 = G(d4, x, r8, f.WGS84), S = G(y, j, r8, f.WGS84);
  return M2 && S ? { bounds: l3, geohashBounds: { xLL: M2[0], yLL: M2[1], xTR: S[0], yTR: S[1] }, level: r8 } : null;
}
function G(o7, r8, n8, s4) {
  if (s4.isWebMercator) {
    const e4 = M(o7 / t.radius), s5 = e4 - 360 * Math.floor((e4 + 180) / 360), c5 = [0, 0];
    return z(c5, 0, M(Math.PI / 2 - 2 * Math.atan(Math.exp(-r8 / t.radius))), s5, n8), c5;
  }
  const c4 = g({ x: o7, y: r8 }, s4, f.WGS84);
  if (!c4) return null;
  const f2 = [0, 0];
  return z(f2, 0, c4.y, c4.x, n8), f2;
}
function Y(t4, o7) {
  let r8 = -90, n8 = 90, e4 = -180, s4 = 180;
  for (let i8 = 0; i8 < o7; i8++) {
    const o8 = Math.ceil((i8 + 1) / 2), c4 = Math.floor((i8 + 1) / 2), f2 = 1 - i8 % 2, a4 = 30 - (3 * o8 + 2 * c4), l3 = 30 - (2 * o8 + 3 * c4), u6 = 3 * f2 + 2 * (1 - f2), m = 2 * f2 + 3 * (1 - f2), h3 = 3 * f2 + 7 * (1 - f2) << l3, p = (7 * f2 + 3 * (1 - f2) << a4 & t4.geohashX) >> a4, g3 = (h3 & t4.geohashY) >> l3;
    for (let t5 = u6 - 1; t5 >= 0; t5--) {
      const o9 = (e4 + s4) / 2, r9 = p & 1 << t5 ? 1 : 0;
      e4 = (1 - r9) * e4 + r9 * o9, s4 = (1 - r9) * o9 + r9 * s4;
    }
    for (let t5 = m - 1; t5 >= 0; t5--) {
      const o9 = (r8 + n8) / 2, e5 = g3 & 1 << t5 ? 1 : 0;
      r8 = (1 - e5) * r8 + e5 * o9, n8 = (1 - e5) * o9 + e5 * n8;
    }
  }
  return [e4, r8, s4, n8];
}
function z(t4, o7, r8, n8, e4) {
  e4 % 2 && (e4 += 1);
  let s4 = 0, i8 = 0, c4 = -90, f2 = 90, a4 = -180, l3 = 180;
  for (let u6 = 0; u6 < e4 / 2; u6++) {
    for (let t5 = 0; t5 < 5; t5++) {
      const o8 = (a4 + l3) / 2, r9 = n8 > o8 ? 1 : 0;
      s4 |= r9 << 29 - (t5 + 5 * u6), a4 = (1 - r9) * a4 + r9 * o8, l3 = (1 - r9) * o8 + r9 * l3;
    }
    for (let t5 = 0; t5 < 5; t5++) {
      const o8 = (c4 + f2) / 2, n9 = r8 > o8 ? 1 : 0;
      i8 |= n9 << 29 - (t5 + 5 * u6), c4 = (1 - n9) * c4 + n9 * o8, f2 = (1 - n9) * o8 + n9 * f2;
    }
  }
  t4[2 * o7] = s4, t4[2 * o7 + 1] = i8;
}

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/AAggregateCell.js
var t2 = class {
  constructor(t4) {
    this._statistics = t4;
  }
  get statistics() {
    return this._statistics;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/AccumulatedStatistics.js
var s2 = Math.PI / 180;
var i4 = class _i {
  static create(t4) {
    return new _i(t4.map((t5) => n4(t5)));
  }
  constructor(t4) {
    this._statistics = t4;
  }
  static get estimatedMemory() {
    return s + 4 * s;
  }
  values() {
    return this._statistics.values();
  }
  insert(t4, e4) {
    for (const s4 of this._statistics) s4.insert(t4, e4);
  }
  merge(t4) {
    for (let e4 = 0; e4 < this._statistics.length; e4++) {
      const s4 = this._statistics[e4], i8 = t4._statistics[e4];
      if (s4.field.name !== i8.field.name) throw new Error("InternalError: Tried to merge incompatible statistics");
      s4.merge(i8);
    }
  }
  clone() {
    return new _i(this._statistics.map((t4) => t4.clone()));
  }
};
function n4(t4) {
  switch (t4.statisticType) {
    case "min":
      return new u5(t4);
    case "max":
      return new a2(t4);
    case "avg":
      return new o4(t4);
    case "avg_angle":
      return new h(t4);
    case "sum":
    case "count":
      return new c2(t4);
    case "mode":
      return new l(t4);
  }
}
var r3 = class {
  constructor(t4) {
    this.field = t4;
  }
  insert(t4, s4) {
    if (!this.field.computed) return;
    const i8 = this.field.computed.read(t4, s4);
    r(i8) || this._insertValue(i8);
  }
};
var u5 = class _u extends r3 {
  constructor() {
    super(...arguments), this.type = "min", this.value = Number.MAX_VALUE;
  }
  _insertValue(t4) {
    this.value = Math.min(this.value, t4);
  }
  merge(t4) {
    this.value = Math.min(this.value, t4.value);
  }
  clone() {
    const t4 = new _u(this.field);
    return t4.value = this.value, t4;
  }
};
var a2 = class _a extends r3 {
  constructor() {
    super(...arguments), this.type = "max", this.value = Number.MIN_VALUE;
  }
  _insertValue(t4) {
    this.value = Math.max(this.value, t4);
  }
  merge(t4) {
    this.value = Math.max(this.value, t4.value);
  }
  clone() {
    const t4 = new _a(this.field);
    return t4.value = this.value, t4;
  }
};
var c2 = class _c extends r3 {
  constructor() {
    super(...arguments), this.type = "sum", this.value = 0;
  }
  _insertValue(t4) {
    this.value += t4;
  }
  merge(t4) {
    this.value += t4.value;
  }
  clone() {
    const t4 = new _c(this.field);
    return t4.value = this.value, t4;
  }
};
var o4 = class _o extends r3 {
  constructor() {
    super(...arguments), this.type = "avg", this._total = 0, this._count = 0;
  }
  get value() {
    return this._total / this._count;
  }
  _insertValue(t4) {
    this._total += t4, this._count += 1;
  }
  merge(t4) {
    this._total += t4._total, this._count += t4._count;
  }
  clone() {
    const t4 = new _o(this.field);
    return t4._total = this._total, t4._count = this._count, t4;
  }
};
var h = class _h extends r3 {
  constructor() {
    super(...arguments), this.type = "avg_angle", this._x = 0, this._y = 0, this._count = 0;
  }
  get value() {
    const t4 = this._x / this._count, e4 = this._y / this._count, s4 = 180 / Math.PI;
    return Math.atan2(e4, t4) * s4;
  }
  _insertValue(t4) {
    this._x = this._x + Math.cos(t4 * s2), this._y = this._y + Math.sin(t4 * s2), this._count += 1;
  }
  merge(t4) {
    this._x += t4._x, this._y += t4._y, this._count += t4._count;
  }
  clone() {
    const t4 = new _h(this.field);
    return t4._x = this._x, t4._y = this._y, t4._count = this._count, t4;
  }
};
var l = class _l extends r3 {
  constructor() {
    super(...arguments), this._frequencies = /* @__PURE__ */ new Map();
  }
  get value() {
    let t4, e4 = 0;
    for (const [s4, i8] of this._frequencies.entries()) i8 > e4 && (e4 = i8, t4 = s4);
    return t4;
  }
  _insertValue(t4) {
    const e4 = this._frequencies.get(t4);
    null != e4 ? this._frequencies.set(t4, e4 + 1) : this._frequencies.set(t4, 1);
  }
  merge(t4) {
    for (const [e4, s4] of t4._frequencies.entries()) {
      const t5 = this._frequencies.get(e4);
      null != t5 ? this._frequencies.set(e4, t5 + s4) : this._frequencies.set(e4, s4);
    }
  }
  clone() {
    const t4 = new _l(this.field);
    return t4._frequencies = new Map(this._frequencies), t4;
  }
};

// node_modules/@arcgis/core/geohash/GeohashCell.js
var c3 = 32;
var _ = class __ extends t2 {
  static create(t4, e4, o7, s4) {
    const r8 = i4.create(t4), i8 = new Array(c3);
    for (let h3 = 0; h3 < i8.length; h3++) i8[h3] = null;
    return new __(r8, e4, o7, s4, i8);
  }
  constructor(t4, e4, o7, s4, r8) {
    super(t4), this.xNode = e4, this.yNode = o7, this.depth = s4, this.children = r8, this._objectIds = /* @__PURE__ */ new Set(), this._count = 0, this._xWorldTotal = 0, this._yWorldTotal = 0, this._xGeohashTotal = 0, this._yGeohashTotal = 0, this.next = null;
  }
  static get estimatedMemory() {
    let o7 = 0;
    return o7 += 2 * s, o7 += n * c3, o7 += i4.estimatedMemory, o7;
  }
  get id() {
    return `${this.xNode}.${this.yNode}`;
  }
  get containedObjectIds() {
    return this._objectIds;
  }
  get count() {
    return this._count;
  }
  clone() {
    const t4 = new __(this._statistics.clone(), this.xNode, this.yNode, this.depth, this.children);
    return t4._count = this._count, t4._xWorldTotal = this._xWorldTotal, t4._yWorldTotal = this._yWorldTotal, t4._xGeohashTotal = this._xGeohashTotal, t4._yGeohashTotal = this._yGeohashTotal, t4.next = this.next, t4._objectIds = new Set(this._objectIds), t4;
  }
  insert(t4, e4, o7, s4, r8, i8) {
    this._count += 1, this._xWorldTotal += e4, this._yWorldTotal += o7, this._xGeohashTotal += s4, this._yGeohashTotal += r8, this._statistics.insert(t4, i8), this._objectIds.add(t4.getObjectId());
  }
  merge(t4) {
    if (0 !== t4._count) {
      this._count += t4._count, this._xWorldTotal += t4._xWorldTotal, this._yWorldTotal += t4._yWorldTotal, this._xGeohashTotal += t4._xWorldTotal, this._yGeohashTotal += t4._yWorldTotal, this._statistics.merge(t4._statistics);
      for (const e4 of t4._objectIds.values()) this._objectIds.add(e4);
    }
  }
  getCentroid(t4) {
    throw new Error("getCentroid not supported for GeohashNode");
  }
  getGeometry(t4, e4) {
    const o7 = this._getLngLatBounds(), [h3, l3, d4, c4] = o7, _2 = g({ rings: [[[h3, l3], [h3, c4], [d4, c4], [d4, l3], [h3, l3]]] }, f.WGS84, t4), u6 = X(new e(), _2, false, false);
    if (null != e4) {
      return gt(new e(), u6, false, false, "esriGeometryPolygon", e4, false, false);
    }
    return u6;
  }
  getGeometricCentroid(t4, e4) {
    const o7 = this._getLngLatBounds(), [r8, l3, d4, c4] = o7, _2 = g({ x: (r8 + d4) / 2, y: (l3 + c4) / 2 }, f.WGS84, t4), u6 = R(new e(), _2);
    if (null != e4) {
      return gt(new e(), u6, false, false, "esriGeometryPoint", e4, false, false);
    }
    return u6;
  }
  getAttributes() {
    const t4 = { aggregateId: this.id };
    for (const e4 of this._statistics.values()) t4[e4.field.name] = e4.value;
    return t4.aggregateCount = this._count, t4;
  }
  find(t4, e4, o7, s4, r8, i8) {
    if (s4 >= o7) return this;
    const h3 = 1 - s4 % 2, a4 = 3 * h3 + 2 * (1 - h3), n8 = 2 * h3 + 3 * (1 - h3), l3 = 30 - r8 - a4, d4 = 30 - i8 - n8, c4 = ((t4 & 7 * h3 + 3 * (1 - h3) << l3) >> l3) + ((e4 & 3 * h3 + 7 * (1 - h3) << d4) >> d4) * (8 * h3 + 4 * (1 - h3)), _2 = this.children[c4];
    return null == _2 ? null : _2.find(t4, e4, o7, s4 + 1, r8 + a4, i8 + n8);
  }
  _getLngLatBounds() {
    const t4 = this.depth, e4 = Math.ceil(t4 / 2), s4 = Math.floor(t4 / 2), r8 = 30 - (3 * e4 + 2 * s4), i8 = 30 - (2 * e4 + 3 * s4), h3 = this.xNode << r8, a4 = this.yNode << i8;
    return Y({ geohashX: h3, geohashY: a4 }, this.depth);
  }
};

// node_modules/@arcgis/core/geohash/GeohashTree.js
var e3 = class {
  constructor(e4) {
    this._fields = e4, this._size = 0, this._depth = 0, this._root = _.create(this._fields, 0, 0, 0);
  }
  destroy() {
  }
  get size() {
    return this._size;
  }
  get depth() {
    return this._depth;
  }
  get usedMemory() {
    return this._size * _.estimatedMemory;
  }
  find(t4, e4, s4) {
    return this._root.find(t4, e4, s4, 0, 0, 0);
  }
  insert(e4, s4, i8, o7, n8, h3, r8) {
    let l3 = this._root, d4 = 0, c4 = 0, a4 = 0;
    for (; null !== l3; ) {
      if (l3.insert(e4, s4, i8, o7, n8, r8), d4 >= h3) return;
      const u6 = Math.ceil((d4 + 1) / 2), f2 = Math.floor((d4 + 1) / 2), _2 = 1 - d4 % 2, x = 30 - (3 * u6 + 2 * f2), m = 30 - (2 * u6 + 3 * f2), M2 = (o7 & 7 * _2 + 3 * (1 - _2) << x) >> x, p = (n8 & 3 * _2 + 7 * (1 - _2) << m) >> m, g3 = M2 + p * (8 * _2 + 4 * (1 - _2));
      c4 = c4 << 3 * _2 + 2 * (1 - _2) | M2, a4 = a4 << 2 * _2 + 3 * (1 - _2) | p, null == l3.children[g3] && (l3.children[g3] = _.create(this._fields, c4, a4, d4 + 1), this._depth = Math.max(this._depth, d4 + 1), this._size += 1), d4 += 1, l3 = l3.children[g3];
    }
  }
  putBins(t4, e4) {
    for (const s4 of this.getNodes(e4)) {
      const e5 = t4.get(s4.id);
      e5 ? e5.merge(s4) : t4.set(s4.id, s4.clone());
    }
  }
  getNodes(t4) {
    const e4 = [], { geohashBounds: s4, level: i8 } = t4;
    let o7 = this._root;
    for (; null !== o7; ) {
      const t5 = o7.depth, n8 = o7.xNode, h3 = o7.yNode;
      if (t5 >= i8) {
        e4.push(o7), o7 = o7.next;
        continue;
      }
      const r8 = Math.ceil((t5 + 1) / 2), l3 = Math.floor((t5 + 1) / 2), d4 = 1 - t5 % 2, c4 = 30 - (3 * r8 + 2 * l3), a4 = 30 - (2 * r8 + 3 * l3), u6 = ~((1 << c4) - 1), f2 = ~((1 << a4) - 1), _2 = (s4.xLL & u6) >> c4, x = (s4.yLL & f2) >> a4, m = (s4.xTR & u6) >> c4, M2 = (s4.yTR & f2) >> a4, p = n8 << 3 * d4 + 2 * (1 - d4), g3 = h3 << 2 * d4 + 3 * (1 - d4), y = p + 8 * d4 + 4 * (1 - d4), z2 = g3 + 4 * d4 + 8 * (1 - d4), L = Math.max(p, _2), N = Math.max(g3, x), B = Math.min(y, m), R2 = Math.min(z2, M2);
      let T2 = null, j = null;
      for (let e5 = N; e5 <= R2; e5++) for (let t6 = L; t6 <= B; t6++) {
        const s5 = t6 - p + (e5 - g3) * (8 * d4 + 4 * (1 - d4)), i9 = o7.children[s5];
        i9 && (T2 || (T2 = i9, T2.next = o7.next), j && (j.next = i9), j = i9, i9.next = o7.next);
      }
      o7 = T2 || o7.next;
    }
    return e4;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/AAggregateSpatialIndex.js
var r4 = class {
  constructor(t4) {
    this._options = t4;
  }
  insert(t4, r8) {
    const o7 = t4.getCursor(), { arcadeContextInfo: s4, scale: i8 } = this._options, n8 = e2(i8, s4);
    for (; o7.next(); ) this._insertFeature(o7, n8, this._options.sqlOptions, r8);
  }
  _insertFeature(e4, r8, o7, s4) {
    const { featureFilter: i8 } = this._options;
    if (null !== i8 && !i8.check(e4, o7)) return;
    let n8 = 0, c4 = 0;
    if ("esriGeometryPoint" === e4.geometryType) n8 = e4.readXWorldSpace(), c4 = e4.readYWorldSpace();
    else {
      if (s4) {
        const r10 = e4.readCentroidForDisplay();
        if (null == r10) return;
        const [o8, s5] = r10.coords;
        if (o8 < 0 || o8 > o2 || s5 < 0 || s5 > o2) return;
      }
      const r9 = e4.readCentroidWorldSpace();
      if (null == r9) return;
      n8 = r9.coords[0], c4 = r9.coords[1];
    }
    this._insert(e4, n8, c4, r8);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/GeohashSpatialIndex.js
var r5 = class extends r4 {
  constructor(t4) {
    super(t4), this._tree = new e3(this._options.fields);
  }
  get usedMemory() {
    return this._tree.usedMemory;
  }
  put(e4) {
    throw new Error("Geohash tree does not support put");
  }
  putBounded(e4, s4, o7) {
    const { geohashLevel: r8, spatialReference: h3 } = this._options, i8 = v(s4, o7, r8, h3);
    null != i8 && this._tree.putBins(e4, i8);
  }
  _insert(e4, t4, o7, r8) {
    const { geohashLevel: h3, spatialReference: i8 } = this._options, n8 = G(t4, o7, h3, i8);
    n8 && this._tree.insert(e4, t4, o7, n8[0], n8[1], h3, r8);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/GridCell.js
var l2 = class _l extends t2 {
  static createId(t4, e4) {
    return `${t4}.${e4}`;
  }
  static create(t4, e4, r8, i8) {
    return new _l(t4, e4, i4.create(r8), i8);
  }
  constructor(t4, e4, r8, i8) {
    super(r8), this.gridX = t4, this.gridY = e4, this._worldUnitsPerCell = i8, this._count = 0, this._xWorldTotal = 0, this._yWorldTotal = 0, this._objectIds = /* @__PURE__ */ new Set();
  }
  get id() {
    return _l.createId(this.gridX, this.gridY);
  }
  get containedObjectIds() {
    return this._objectIds;
  }
  get count() {
    return this._count;
  }
  get firstObjectId() {
    return this._objectIds.values().next().value;
  }
  get centroidXWorld() {
    return this._xWorldTotal / this._count;
  }
  get centroidYWorld() {
    return this._yWorldTotal / this._count;
  }
  get usedMemory() {
    return 48;
  }
  clone() {
    const t4 = new _l(this.gridX, this.gridY, this._statistics.clone(), this._worldUnitsPerCell);
    return t4._count = this._count, t4._xWorldTotal = this._xWorldTotal, t4._yWorldTotal = this._yWorldTotal, t4._firstFeatureAttributes = this._firstFeatureAttributes, t4._objectIds = new Set(this._objectIds), t4;
  }
  insert(t4, e4, r8, i8) {
    0 === this._count ? this._firstFeatureAttributes = t4.readAttributes() : this._firstFeatureAttributes = null, this._count += 1, this._xWorldTotal += r8, this._yWorldTotal += i8, this._statistics.insert(t4, e4), this._objectIds.add(t4.getObjectId());
  }
  merge(t4) {
    if (0 !== t4._count) {
      this._count += t4._count, this._firstFeatureAttributes = t4._firstFeatureAttributes, this._xWorldTotal += t4._xWorldTotal, this._yWorldTotal += t4._yWorldTotal, this._statistics.merge(t4._statistics);
      for (const e4 of t4._objectIds.values()) this._objectIds.add(e4);
    }
  }
  getCentroidX(e4) {
    return null == e4 ? this.centroidXWorld : b(e4, this.centroidXWorld);
  }
  getCentroidY(t4) {
    return null == t4 ? this.centroidYWorld : T(t4, this.centroidYWorld);
  }
  getGeometry(t4, e4) {
    const s4 = this.gridX * this._worldUnitsPerCell, o7 = this.gridY * this._worldUnitsPerCell, l3 = new e([4], [s4, o7, s4 + this._worldUnitsPerCell, o7, s4 + this._worldUnitsPerCell, o7 + this._worldUnitsPerCell, s4, o7 + this._worldUnitsPerCell]);
    if (null != e4) {
      const t5 = new e();
      return gt(t5, l3, false, false, "esriGeometryPolygon", e4);
    }
    return l3;
  }
  getCentroid(t4) {
    const e4 = new e([], [this.centroidXWorld, this.centroidYWorld]);
    if (null != t4) {
      const s4 = new e();
      return gt(s4, e4, false, false, "esriGeometryPoint", t4);
    }
    return e4;
  }
  getGeometricCentroid(t4, e4) {
    const s4 = this.gridX * this._worldUnitsPerCell + 0.5 * this._worldUnitsPerCell, o7 = this.gridY * this._worldUnitsPerCell + 0.5 * this._worldUnitsPerCell, l3 = new e([], [s4, o7]);
    if (null != e4) {
      const t5 = new e();
      return gt(t5, l3, false, false, "esriGeometryPoint", e4);
    }
    return l3;
  }
  getAttributes() {
    const t4 = { aggregateId: this.id };
    for (const e4 of this._statistics.values()) t4[e4.field.name] = e4.value;
    return null != this._firstFeatureAttributes ? { ...t4, ...this._firstFeatureAttributes } : t4;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/GridSpatialIndex.js
var o5 = 96;
function r6(e4, s4) {
  return ae(e4) * o * o5 / s4;
}
var n5 = class extends r4 {
  constructor(e4) {
    super(e4), this._cells = /* @__PURE__ */ new Map(), this._pixelsPerMapUnit = r6(e4.spatialReference, e4.scale);
  }
  get usedMemory() {
    const t4 = this._cells.values().next().value;
    return t4 ? (n + t4.usedMemory) * this._cells.size : 0;
  }
  put(e4) {
    for (const t4 of this._cells.values()) {
      const i8 = e4.get(t4.id);
      i8 ? i8.merge(t4) : e4.set(t4.id, t4.clone());
    }
  }
  putBounded(e4, t4, i8) {
    const s4 = [t4.xmin, t4.ymin, t4.xmax, t4.ymax], [l3, o7, r8, n8] = s4, c4 = Math.floor(l3 * this._pixelsPerMapUnit / this._options.cellSize), p = Math.floor(o7 * this._pixelsPerMapUnit / this._options.cellSize), a4 = Math.ceil(r8 * this._pixelsPerMapUnit / this._options.cellSize), h3 = Math.ceil(n8 * this._pixelsPerMapUnit / this._options.cellSize);
    for (let _2 = p; _2 <= h3; _2++) for (let t5 = c4; t5 <= a4; t5++) {
      const i9 = `${t5}.${_2}`, s5 = this._cells.get(i9);
      if (!s5) continue;
      const l4 = e4.get(s5.id);
      l4 ? s5 && !e4.has(s5.id) && l4.merge(s5) : e4.set(s5.id, s5.clone());
    }
  }
  _insert(e4, t4, i8, s4) {
    const l3 = t4 * this._pixelsPerMapUnit, o7 = i8 * this._pixelsPerMapUnit, r8 = Math.floor(l3 / this._options.cellSize), n8 = Math.floor(o7 / this._options.cellSize);
    this._getCellOrCreate(r8, n8).insert(e4, s4, t4, i8);
  }
  _getCellOrCreate(e4, t4) {
    const i8 = l2.createId(e4, t4);
    let s4 = this._cells.get(i8);
    if (!s4) {
      const o7 = 1 * this._options.cellSize / this._pixelsPerMapUnit;
      s4 = l2.create(e4, t4, this._options.fields, o7), this._cells.set(i8, s4);
    }
    return s4;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderIndirect.js
var d2 = class _d extends O {
  static from(r8, e4) {
    if (r8 instanceof this) {
      const t4 = new Set(e4), s4 = r8._indices.filter((r9) => t4.has(r9));
      return new _d(r8._reader, s4);
    }
    return new _d(r8.copy(), e4);
  }
  constructor(r8, e4) {
    super(r8.metadata), this._currentIndex = -1, this._displayTransform = null, this._reader = r8, this._indices = e4;
  }
  setTransformForDisplay(r8) {
    const t4 = this._reader.getInTransform();
    if (null == t4) return void (this._displayTransform = u3(r8));
    const s4 = u3(t4), a4 = u3(r8), [i8, d4] = s4.scale, [n8, o7] = s4.translate, [h3, u6] = a4.scale, [_2, l3] = a4.translate, c4 = i8 / h3, y = d4 / u6, p = (n8 - _2) / h3, m = (o7 - l3) / u6;
    this._displayTransform = { originPosition: "lowerLeft", scale: [1 / c4, 1 / y, 1, 1], translate: [-p / c4, -m / y, 0, 0] };
  }
  getInTransform() {
    return this._reader.getInTransform();
  }
  get fields() {
    return this._reader.fields;
  }
  get hasNext() {
    return this._currentIndex + 1 < this._indices.length;
  }
  getSize() {
    return this._indices.length;
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    const r8 = new _d(this._reader.copy(), this._indices);
    return r8._currentIndex = this._currentIndex, r8._displayTransform = this._displayTransform, r8._processorAttributes = this._processorAttributes, r8;
  }
  get contextTimeZone() {
    return this._reader.contextTimeZone;
  }
  set contextTimeZone(r8) {
    this._reader.contextTimeZone = r8;
  }
  get usedMemory() {
    return s + this._reader.usedMemory;
  }
  setProcessorAttributes(r8) {
    this._processorAttributes = Object.assign(this._processorAttributes ?? {}, r8);
  }
  _nextIndex() {
    return ++this._currentIndex < this._indices.length && (this._reader.setIndex(this._indices[this._currentIndex]), true);
  }
  next() {
    for (; this._nextIndex() && !this._reader._getExists(); ) ;
    return this._currentIndex < this._indices.length;
  }
  readXForDisplay() {
    return this._displayTransform ? i2(this._displayTransform, this._reader.readXForDisplay()) : this._reader.readXForDisplay();
  }
  readYForDisplay() {
    return this._displayTransform ? a(this._displayTransform, this._reader.readYForDisplay()) : this._reader.readYForDisplay();
  }
  readGeometryForDisplay() {
    return this._displayTransform ? this._reader.readGeometryForDisplayTransformed(this._displayTransform) : this._reader.readGeometryForDisplay();
  }
  readCentroidForDisplay() {
    const r8 = this._reader.readCentroidForDisplay()?.clone();
    if (r8) {
      const [e4, a4] = r8.coords;
      this._displayTransform ? (r8.coords[0] = i2(this._displayTransform, e4), r8.coords[1] = a(this._displayTransform, a4)) : (r8.coords[0] = e4, r8.coords[1] = a4);
    }
    return r8;
  }
  get geometryType() {
    return this._reader.geometryType;
  }
  get hasFeatures() {
    return this._reader.hasFeatures;
  }
  get exceededTransferLimit() {
    return this._reader.exceededTransferLimit;
  }
  get hasZ() {
    return this._reader.hasZ;
  }
  get hasM() {
    return this._reader.hasM;
  }
  readAttribute(r8, e4 = false) {
    const t4 = this._reader.readAttribute(r8, e4);
    return null == t4 && this._processorAttributes ? this._processorAttributes[r8] : t4;
  }
  readAttributes() {
    return { ...this._processorAttributes, ...this._reader.readAttributes() };
  }
  joinAttributes(r8) {
    return this._reader.joinAttributes(r8);
  }
  getBounds(r8) {
    return this._reader.getBounds(r8);
  }
  getAttributeHash() {
    return this._reader.getAttributeHash();
  }
  getObjectId() {
    return this._reader.getObjectId();
  }
  getDisplayId() {
    return this._reader.getDisplayId();
  }
  setDisplayId(r8) {
    return this._reader.setDisplayId(r8);
  }
  setIndex(r8) {
    return this._reader.setIndex(r8);
  }
  getIndex() {
    return this._reader.getIndex();
  }
  readXWorldSpace() {
    return this._reader.readXWorldSpace();
  }
  readYWorldSpace() {
    return this._reader.readYWorldSpace();
  }
  _readX() {
    return this._reader.readXForDisplay();
  }
  _readY() {
    return this._reader.readYForDisplay();
  }
  _readServerCentroid() {
    return this._reader._readServerCentroid();
  }
  readLegacyFeatureForDisplay() {
    const r8 = this.readCentroidForDisplay();
    return { attributes: this.readAttributes(), geometry: this.readLegacyGeometryForDisplay(), centroid: (r8 && { x: r8.coords[0], y: r8.coords[1] }) ?? null };
  }
  readLegacyGeometryForDisplay() {
    const r8 = this.readGeometryForDisplay();
    return lt(r8, this.geometryType, false, false);
  }
  readGeometryArea() {
    return this._displayTransform ? this._reader.readGeometryForDisplayTransformed(this._displayTransform)?.area() ?? 0 : this._reader.readGeometryArea();
  }
  readGeometryWorldSpace() {
    return this._reader.readGeometryWorldSpace();
  }
  _readGeometry() {
    return this._reader._readGeometry();
  }
  _readAttribute(r8, e4) {
    throw new Error("Error: Should not be called. Underlying _reader should be used instead");
  }
  _readAttributes() {
    throw new Error("Error: Should not be called. Underlying _reader should be used instead");
  }
  readArcadeFeature() {
    return this._reader.readArcadeFeature();
  }
  geometry() {
    return this._reader.geometry();
  }
  field(r8) {
    return this._reader.field(r8);
  }
  hasField(r8) {
    return this._reader.hasField(r8);
  }
  setField(r8, e4) {
    return this._reader.setField(r8, e4);
  }
  keys() {
    return this._reader.keys();
  }
  castToText(r8 = false) {
    return this._reader.castToText(r8);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/ASourceChunk.js
var i5 = class {
  size() {
    return this.reader.getSize();
  }
  get fields() {
    return this.reader.fields;
  }
  invalidate() {
    this._aggregateIndex = null, this._aggregateIndexHash = null, this._spatialIndex = null;
  }
  get usedMemory() {
    let e4 = 0;
    return e4 += this.reader.underlyingMemory, this._aggregateIndex && (e4 += this._aggregateIndex.usedMemory), this._spatialIndex && (e4 += this._spatialIndex.usedMemory), e4;
  }
  registerOverrides(e4) {
    this.reader.registerOverrides(e4), this.invalidate();
  }
  queryFeaturesInBounds(e4) {
    const t4 = this._getSpatialIndex().search(e4);
    return d2.from(this.reader, t4);
  }
  getAggregateIndex(e4) {
    const a4 = JSON.stringify(e4);
    if (a4 !== this._aggregateIndexHash) {
      switch (this._aggregateIndexHash = a4, e4.type) {
        case "grid":
          this._aggregateIndex = new n5(e4);
          break;
        case "geohash":
          this._aggregateIndex = new r5(e4);
      }
      this._aggregateIndex.insert(this.reader, this.isTiled);
    }
    return this._aggregateIndex;
  }
  _getSpatialIndex() {
    return this._spatialIndex || (this._spatialIndex = n3.fromReader(this.reader)), this._spatialIndex;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/FeatureSnapshotSourceChunk.js
var t3 = class extends i5 {
  constructor(e4, t4, s4, r8, i8 = 0) {
    super(), this._reader = e4, this._queryJSON = t4, this._page = s4, this._end = r8, this._fileIndex = i8, this.chunkId = `${this._fileIndex}.${this._page}${this.end ? "e" : ""}`, this.normalizedChunkId = this.chunkId;
  }
  get reader() {
    return this._reader;
  }
  get first() {
    return 0 === this._page;
  }
  get end() {
    return this._end;
  }
  get queryInfo() {
    return { type: "snapshot", chunkId: this.chunkId, queryJSON: this._queryJSON, page: this._page, size: this.size(), end: this.end };
  }
  get isTiled() {
    return false;
  }
  getTileReader(e4) {
    const t4 = this.queryFeaturesInBounds(e4.bounds);
    return t4.setTransformForDisplay(e4.transform), t4;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderParquet.js
var s3;
var i6 = class _i extends O {
  constructor(t4, r8, n8, s4, i8, d4 = new Uint32Array(n8.size())) {
    super(t4), this._fields = r8, this._inner = n8, this._chunkId = s4, this._fileIndex = i8, this._displayIds = d4, this._index = -1, this.usedMemory = s, this._size = this._inner.size();
    t4.featureIdInfo.type, this._chunkId > 65535 && console.error("Exceeded max allowed parquet reader size");
  }
  destroy() {
    super.destroy(), this._inner.free();
  }
  get fields() {
    return this._fields;
  }
  get geometryType() {
    return this.metadata.geometryType;
  }
  get hasFeatures() {
    return true;
  }
  get hasNext() {
    throw new Error("Method not implemented.");
  }
  get exceededTransferLimit() {
    return false;
  }
  get hasZ() {
    return false;
  }
  get hasM() {
    return false;
  }
  getInTransform() {
    return null;
  }
  getSize() {
    return this._size;
  }
  getCursor() {
    return this.copy();
  }
  getAttributeHash() {
    let e4 = "";
    for (const t4 of this.fields.fields) e4 += this._readAttribute(t4.name, false) + ".";
    return e4;
  }
  getObjectId() {
    return this._fileIndex << 24 | this._inner.rowId(this._index);
  }
  getDisplayId() {
    return this._displayIds[this._index];
  }
  setDisplayId(e4) {
    this._displayIds[this._index] = e4;
  }
  setIndex(e4) {
    this._index = e4;
  }
  getBoundsXMin() {
    return this._inner.boundsXMin(this._index);
  }
  getBoundsYMin() {
    return this._inner.boundsYMin(this._index);
  }
  getBoundsXMax() {
    return this._inner.boundsXMax(this._index);
  }
  getBoundsYMax() {
    return this._inner.boundsYMax(this._index);
  }
  setBoundsXMin(e4) {
    throw new Error("InternalError: Setting bounds is unsupported");
  }
  setBoundsYMin(e4) {
    throw new Error("InternalError: Setting bounds is unsupported");
  }
  setBoundsXMax(e4) {
    throw new Error("InternalError: Setting bounds is unsupported");
  }
  setBoundsYMax(e4) {
    throw new Error("InternalError: Setting bounds is unsupported");
  }
  getIndex() {
    return this._index;
  }
  next() {
    for (; ++this._index < this._size && !this._getExists(); ) ;
    return this._index < this._size;
  }
  readGeometryArea() {
    return this.readGeometryForDisplay()?.area() ?? 0;
  }
  copy() {
    const e4 = new _i(this.metadata, this._fields, this._inner, this._chunkId, this._fileIndex, this._displayIds);
    return this.copyInto(e4), e4;
  }
  copyInto(e4) {
    super.copyInto(e4), e4._index = this._index;
  }
  readGeometryForDisplayTransformed(e4) {
    const [n8, i8] = e4.translate, [d4, o7] = e4.scale;
    s3 || (s3 = re.new());
    return this._inner.transformGeometry(s3, n8, i8, d4, o7, this._index) ? new e(s3.readLengthsUnsafe(), s3.readCoordsUnsafe()) : null;
  }
  _readGeometry(e4) {
    const r8 = this._inner.readCoords(this._index), n8 = this._inner.readLengths(this._index);
    return r8 && n8 ? new e(n8, r8) : null;
  }
  _readX() {
    return this._inner.readX(this._index);
  }
  _readY() {
    return this._inner.readY(this._index);
  }
  _readServerCentroid() {
    return null;
  }
  _readAttribute(e4, t4) {
    const r8 = this.fields.get(e4);
    if (!r8) return;
    if (null == r8.column) return this.getObjectId();
    const n8 = this._inner.readAttribute(this._index, r8.column);
    if (null == n8) return n8;
    const s4 = this.fields.isDateField(r8.name);
    return t4 ? null == n8 ? n8 : s4 ? new Date(n8) : n8 : n8;
  }
  _readAttributes() {
    const e4 = {};
    for (const t4 of this._fields.fields) null != t4.column && (this._inner.isEmpty(t4.column) || (e4[t4.name] = this._readAttribute(t4.name, false)));
    return e4.__OBJECTID = this.getObjectId(), e4;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/Overrides.js
var r7 = 1e4;
var i7 = 1e3;
var a3 = class _a {
  static async create(t4) {
    const { metadata: s4, definitionExpression: r8 } = t4, i8 = r8 ? await u(r8, s4.fieldsIndex) : null;
    return new _a(s4, i8, r8);
  }
  constructor(e4, t4, s4) {
    this.metadata = e4, this._clause = t4, this._definitionExpression = s4;
  }
  get hash() {
    return this._definitionExpression;
  }
  testFeature(e4) {
    return null == this._clause || this._clause.testFeature(e4);
  }
};
var o6 = class _o {
  constructor() {
    this.modified = /* @__PURE__ */ new Map(), this.removed = /* @__PURE__ */ new Set();
  }
  modify(e4) {
    this.modified.set(e4.objectId, e4), this.removed.has(e4.objectId) && this.removed.delete(e4.objectId);
  }
  remove(e4) {
    this.modified.delete(e4), this.removed.add(e4);
  }
  get isEmpty() {
    return 0 === this.modified.size && 0 === this.removed.size;
  }
  applyWhereClause(e4) {
    const t4 = new _o();
    for (const [s4, r8] of this.modified) e4.testFeature(r8) ? t4.modified.set(s4, r8) : t4.removed.add(r8.objectId);
    for (const s4 of this.removed) t4.removed.add(s4);
    return t4;
  }
};
var n6 = class _n extends i5 {
  constructor(e4) {
    super(), this._reader = e4, this.chunkId = "override", this.normalizedChunkId = "override";
  }
  static fromFeatures(e4, t4) {
    const r8 = u4.fromOptimizedFeatures(e4, t4);
    return new _n(r8);
  }
  get reader() {
    return this._reader;
  }
  get queryInfo() {
    return {};
  }
  get first() {
    return false;
  }
  get end() {
    return false;
  }
  get isTiled() {
    return false;
  }
  getTileReader(e4) {
    if (!this._reader.getSize()) return null;
    const t4 = this.queryFeaturesInBounds(e4.bounds);
    return t4.setTransformForDisplay(e4.transform), t4;
  }
};
var d3 = class {
  constructor(e4, t4) {
    this.inner = e4, this.isWeak = t4, this.lastWeak = null;
  }
  get isStrong() {
    return !this.isWeak;
  }
};
var h2 = class {
  constructor(e4) {
    this._parameters = e4, this._overrides = /* @__PURE__ */ new Map(), this._update = new o6(), this._lastCleanup = 0;
  }
  update(e4) {
    this._parameters = e4;
  }
  hasOverride(e4) {
    return this._overrides.has(e4);
  }
  onChunkInsert(e4) {
    if (this._overrides.size) {
      const t4 = e4.reader.getCursor();
      for (; t4.next(); ) {
        const e5 = t4.getObjectId(), s4 = this._overrides.get(e5);
        if (s4?.lastWeak && (s4.lastWeak = null), s4?.isWeak) {
          const e6 = t4.readOptimizedFeatureWorldSpace(), r8 = s4.inner?.attributes ?? {};
          e6.attributes = { ...r8, ...e6.attributes }, s4.inner = e6, this._update.modify(e6), this.invalidate();
        }
      }
    }
    e4.registerOverrides(this);
  }
  apply(e4, t4) {
    const { updateWeak: s4, removeWeak: r8, update: i8, remove: a4, release: o7 } = e4.commands;
    this.invalidate();
    for (const n8 of s4) {
      const e5 = new d3(n8, true), t5 = this._overrides.get(n8.objectId);
      t5?.isStrong ? t5.lastWeak = e5 : (this._overrides.set(n8.objectId, e5), this._update.modify(n8));
    }
    for (const n8 of i8) {
      const e5 = new d3(n8, false), t5 = this._overrides.get(n8.objectId);
      e5.lastWeak = t5?.isWeak ? t5 : t5?.lastWeak ?? null, this._overrides.set(n8.objectId, e5), this._update.modify(n8);
    }
    for (const n8 of r8) {
      const e5 = new d3(null, true), t5 = this._overrides.get(n8);
      t5?.isStrong ? t5.lastWeak = e5 : (this._overrides.set(n8, e5), this._update.remove(n8));
    }
    for (const n8 of a4) {
      const e5 = new d3(null, false), t5 = this._overrides.get(n8);
      e5.lastWeak = t5?.isWeak ? t5 : t5?.lastWeak ?? null, this._overrides.set(n8, e5), this._update.remove(n8);
    }
    if (o7.length) {
      const e5 = /* @__PURE__ */ new Set();
      for (const t5 of o7) {
        const s5 = this._overrides.get(t5);
        s5?.lastWeak ? (this._overrides.set(t5, s5.lastWeak), null == s5.lastWeak.inner ? this._update.remove(t5) : this._update.modify(s5.lastWeak.inner)) : s5 && !s5.isWeak && (this._overrides.delete(t5), e5.add(t5));
      }
      t4.forEachUnsafe((t5) => {
        const s5 = t5.getObjectId();
        e5.has(s5) && (this._update.modify(t5.readOptimizedFeatureWorldSpace()), e5.delete(s5));
      });
      for (const t5 of e5.values()) this._update.remove(t5);
    }
  }
  clearWeakOverrides() {
    for (const [e4, t4] of this._overrides.entries()) t4.isWeak && this._overrides.delete(e4);
    this.invalidate();
  }
  cleanup(e4) {
    if (this._overrides.size < r7) return;
    const t4 = performance.now();
    if (t4 - this._lastCleanup < i7) return;
    this._lastCleanup = t4;
    const s4 = this._getWeakDeletions();
    if (!(s4.size < r7)) {
      for (const t5 of e4) {
        const e5 = t5.reader.withoutOverrides().getCursor();
        for (; e5.next(); ) {
          const t6 = e5.getObjectId();
          s4.delete(t6);
        }
      }
      for (const e5 of s4) this._overrides.delete(e5);
      s4.size && this.invalidate();
    }
  }
  takeOverrideUpdate() {
    const e4 = this._update;
    return e4.isEmpty ? null : (this._update = new o6(), e4.applyWhereClause(this._parameters));
  }
  asChunk() {
    const e4 = this._parameters;
    if (this._lastOverrideParametersHash !== e4.hash && (this._lastOverrideParametersHash = e4.hash, this._chunk = null), !this._chunk) {
      const t4 = [];
      for (const s4 of this._overrides.values()) null != s4.inner && e4.testFeature(s4.inner) && t4.push(s4.inner);
      this._chunk = n6.fromFeatures(t4, e4.metadata);
    }
    return this._chunk;
  }
  invalidate() {
    this._chunk = null;
  }
  putWeakObjectIdsFromGlobalIds(e4, t4, s4) {
    for (const [r8, i8] of this._overrides.entries()) {
      if (i8.isWeak && null != i8.inner) {
        const a4 = i8.inner.attributes[s4];
        a4 && t4.has(a4) && !e4.has(a4) && e4.set(a4, r8);
        continue;
      }
      if (null != i8.lastWeak && null != i8.lastWeak.inner) {
        const a4 = i8.lastWeak.inner.attributes[s4];
        a4 && t4.has(a4) && !e4.has(a4) && e4.set(a4, r8);
      }
    }
  }
  _getWeakDeletions() {
    const e4 = /* @__PURE__ */ new Set();
    for (const [t4, s4] of this._overrides.entries()) s4.isWeak && null == s4.inner && e4.add(t4);
    return e4;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/SourceChunkStore.js
var n7 = class {
  constructor() {
    this._chunks = /* @__PURE__ */ new Map(), this._chunksToRemove = [], this.events = new i(), this.featureAdapter = new r2();
  }
  destroy() {
    this.clear();
  }
  clear() {
    for (const e4 of this._chunks.values()) this._chunksToRemove.push(e4);
    this._chunks.clear(), this._overrides?.clearWeakOverrides();
  }
  get usedMemory() {
    let e4 = 0;
    for (const s4 of this._chunks.values()) e4 += s4.usedMemory;
    return e4;
  }
  async update(e4) {
    if (this._overrides) {
      const s4 = await a3.create(e4);
      this._overrides.update(s4);
    }
    this._schema = e4;
  }
  *chunks() {
    this._overrides && (yield this._overrides.asChunk()), yield* this._chunks.values();
  }
  insert(e4) {
    has("esri-2d-update-debug") && console.debug(`Chunk[${e4.chunkId}] SourceChunkStore.insert`), this._overrides?.onChunkInsert(e4), this._chunks.set(e4.chunkId, e4), this.events.emit("changed");
  }
  remove(e4) {
    has("esri-2d-update-debug") && console.debug(`Chunk[${e4.chunkId}] SourceChunkStore.remove`), this._chunks.delete(e4.chunkId), this._chunksToRemove.push(e4);
  }
  removeById(e4) {
    has("esri-2d-update-debug") && console.debug(`Chunk[${e4}] SourceChunkStore.remove`);
    const s4 = this._chunks.get(e4);
    this._chunks.delete(e4), s4 && this._chunksToRemove.push(s4);
  }
  cleanup() {
    const e4 = this._chunksToRemove;
    return this._chunksToRemove = [], this._overrides?.cleanup(this._chunks.values()), e4;
  }
  async applyOverride(e4) {
    if (null == this._overrides) {
      const e5 = await a3.create(this._schema);
      this._overrides = new h2(e5);
      for (const s4 of this._chunks.values()) this._overrides.onChunkInsert(s4);
    }
    this._overrides.apply(e4, this), this.events.emit("changed");
    for (const s4 of this._chunks.values()) s4.invalidate();
  }
  takeOverrideUpdate() {
    return this._overrides?.takeOverrideUpdate();
  }
  refresh() {
    this.events.emit("refresh");
  }
  forEach(e4) {
    const s4 = /* @__PURE__ */ new Set();
    for (const t4 of this.chunks()) {
      const r8 = t4.reader.getCursor();
      for (; r8.next(); ) {
        const t5 = r8.getObjectId();
        s4.has(t5) || (e4(r8.copy()), s4.add(t5));
      }
    }
  }
  forEachUnsafe(e4) {
    const s4 = /* @__PURE__ */ new Set();
    for (const t4 of this.chunks()) {
      const r8 = t4.reader.getCursor();
      for (; r8.next(); ) {
        const t5 = r8.getObjectId();
        s4.has(t5) || (e4(r8), s4.add(t5));
      }
    }
  }
  mapObjectIdsFromGlobalIds(e4, s4) {
    const t4 = /* @__PURE__ */ new Map(), r8 = new Set(e4);
    return this._overrides?.putWeakObjectIdsFromGlobalIds(t4, r8, s4), this._forEachUnsafeIgnoreOverrides((e5) => {
      const o7 = e5.readAttribute(s4);
      if (o7 && r8.has(o7) && !t4.has(o7)) {
        const s5 = e5.getObjectId();
        t4.set(o7, s5);
      }
    }), t4;
  }
  forEachInBounds(e4, s4) {
    const t4 = /* @__PURE__ */ new Set();
    for (const r8 of this.chunks()) {
      const o7 = r8.queryFeaturesInBounds(e4);
      for (; o7.next(); ) {
        const e5 = o7.getObjectId();
        t4.has(e5) || (s4(o7.copy()), t4.add(e5));
      }
    }
  }
  forEachBounds(e4, t4) {
    const r8 = u2();
    for (const s4 of e4) {
      s4.getBounds(r8) && t4(r8);
    }
  }
  _forEachUnsafeIgnoreOverrides(e4) {
    const s4 = /* @__PURE__ */ new Set();
    for (const t4 of this._chunks.values()) {
      const r8 = t4.reader.withoutOverrides().getCursor();
      for (; r8.next(); ) {
        const t5 = r8.getObjectId();
        s4.has(t5) || (e4(r8), s4.add(t5));
      }
    }
  }
};

export {
  i4 as i,
  l2 as l,
  r6 as r,
  d2 as d,
  i5 as i2,
  n6 as n,
  t3 as t,
  i6 as i3,
  n7 as n2
};
//# sourceMappingURL=chunk-IOYCE6EG.js.map
