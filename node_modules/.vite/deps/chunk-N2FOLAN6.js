import {
  i as i9
} from "./chunk-VEW6BMSK.js";
import {
  a as a5
} from "./chunk-TYWPNUCZ.js";
import {
  r as r5
} from "./chunk-ZS4Q4DJE.js";
import {
  i as i7,
  r as r3,
  s as s6
} from "./chunk-6SXRWZMX.js";
import {
  A,
  F,
  b as b5,
  c as c2,
  e as e4,
  m as m7,
  o2 as o4,
  p2 as p7,
  s2 as s5,
  t2 as t5,
  t3 as t6,
  x2,
  z as z2
} from "./chunk-N3OIGAM3.js";
import {
  i as i8
} from "./chunk-UXLDVCDU.js";
import {
  b as b4
} from "./chunk-43423NKQ.js";
import {
  b as b6
} from "./chunk-T5PAMHK6.js";
import {
  d as d3
} from "./chunk-PZZ55S55.js";
import {
  a as a6
} from "./chunk-ALLCMCHO.js";
import {
  y as y3
} from "./chunk-MJIAJDWR.js";
import {
  E
} from "./chunk-BYU7VMB6.js";
import {
  n as n4,
  s as s4
} from "./chunk-GUZURMV5.js";
import {
  n as n5,
  p as p6
} from "./chunk-RRK2YVM5.js";
import {
  o as o3
} from "./chunk-INJCHY4H.js";
import {
  p2 as p4
} from "./chunk-ZOIMNPWT.js";
import {
  p as p3
} from "./chunk-MA6OR5A6.js";
import {
  d as d2
} from "./chunk-RCHRSC54.js";
import {
  n as n3
} from "./chunk-ABHLEPDK.js";
import {
  c
} from "./chunk-EVZ7KLPS.js";
import {
  J,
  W
} from "./chunk-KY5OS6CK.js";
import {
  e as e3,
  u as u7
} from "./chunk-X5BCRMNY.js";
import {
  t as t2
} from "./chunk-YYGF76T3.js";
import {
  K,
  Y,
  a as a4
} from "./chunk-DRHU543D.js";
import {
  i as i5
} from "./chunk-Y3GEZC7J.js";
import {
  u as u6
} from "./chunk-WBYRWTBX.js";
import {
  i as i6
} from "./chunk-A4YBHV2M.js";
import {
  g as g2
} from "./chunk-HCTBVF3W.js";
import {
  T
} from "./chunk-BICOKFED.js";
import {
  p as p2,
  y as y2
} from "./chunk-QNW4D2V2.js";
import {
  f as f2
} from "./chunk-TTLSEJNG.js";
import {
  ot
} from "./chunk-XX3OKYJS.js";
import {
  h2 as h3,
  r2 as r4
} from "./chunk-WKTI47FV.js";
import {
  t as t4
} from "./chunk-LQPKVYW2.js";
import {
  p as p5
} from "./chunk-ZCI5A4FF.js";
import {
  e as e2
} from "./chunk-JUZ3H47H.js";
import {
  f as f3
} from "./chunk-JE2NJSBU.js";
import {
  h
} from "./chunk-BPTFV5VM.js";
import {
  b as b2
} from "./chunk-647DAMHU.js";
import {
  p
} from "./chunk-ZKNZTIAS.js";
import {
  s as s3
} from "./chunk-4WTOIJXV.js";
import {
  m as m4
} from "./chunk-63LDVRFI.js";
import {
  _
} from "./chunk-C3FRY5U4.js";
import {
  t as t3
} from "./chunk-JNJX34GB.js";
import {
  m as m6
} from "./chunk-JZUJ34RR.js";
import {
  D,
  L,
  R,
  T as T2,
  V,
  X,
  Y as Y2,
  b as b3,
  h as h2,
  j,
  ke,
  w as w2,
  x
} from "./chunk-MC6NAKKX.js";
import {
  l as l3,
  o as o2,
  r as r2,
  u as u4
} from "./chunk-TF6255HN.js";
import {
  u as u5
} from "./chunk-F7DKSAOI.js";
import {
  m as m5
} from "./chunk-4SOQWNPG.js";
import {
  G
} from "./chunk-CNYNCKEV.js";
import {
  O
} from "./chunk-YDTPM7OQ.js";
import {
  n as n2
} from "./chunk-PZ5RULLK.js";
import {
  i as i4
} from "./chunk-FPMLKIDB.js";
import {
  z
} from "./chunk-H74Q4SYB.js";
import {
  a as a3,
  l as l2,
  w
} from "./chunk-2OFHDVO5.js";
import {
  i as i3
} from "./chunk-TFJXG32O.js";
import {
  u as u3
} from "./chunk-CSMCPN64.js";
import {
  m as m3,
  r
} from "./chunk-SMWUT52Z.js";
import {
  f
} from "./chunk-5T3MJDSR.js";
import {
  ae
} from "./chunk-NMQNUPE4.js";
import {
  g2 as g
} from "./chunk-V2H77UEV.js";
import {
  o
} from "./chunk-XWE6BM2U.js";
import {
  b,
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  $,
  d,
  e,
  m2,
  s as s2,
  t,
  u2 as u,
  u3 as u2,
  y
} from "./chunk-GNMPGHLQ.js";
import {
  a,
  i,
  i3 as i2,
  l3 as l,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  N,
  has,
  n
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/AggregateGraphic.js
var s7 = class extends _ {
  constructor() {
    super(...arguments), this.isAggregate = true, this.origin = null;
  }
  getObjectId() {
    return this.attributes.aggregateId;
  }
};
__decorate([m({ type: Boolean })], s7.prototype, "isAggregate", void 0), __decorate([m({ clonable: "reference" })], s7.prototype, "origin", void 0), s7 = __decorate([a2("esri.AggregateGraphic")], s7);
var i10 = s7;

// node_modules/@arcgis/core/TrackGraphic.js
var s8 = class extends _ {
  constructor() {
    super(...arguments), this.isAggregate = true, this.origin = null;
  }
  getObjectId() {
    return this.attributes.aggregateId;
  }
};
__decorate([m({ type: Boolean })], s8.prototype, "isAggregate", void 0), __decorate([m({ clonable: "reference" })], s8.prototype, "origin", void 0), s8 = __decorate([a2("esri.TrackGraphic")], s8);
var i11 = s8;

// node_modules/@arcgis/core/layers/effects/FeatureEffectView.js
var c3 = class extends b {
  constructor(e13) {
    super(e13), this._filter = null, this.duration = has("mapview-transitions-duration"), this._excludedEffectView = new a6(e13), this._includedEffectView = new a6(e13);
  }
  get excludedEffects() {
    return this._excludedEffectView.effects;
  }
  set featureEffect(e13) {
    this._get("featureEffect") !== e13 && this._transitionTo(e13);
  }
  get filter() {
    return this._filter || this.featureEffect?.filter || null;
  }
  get hasEffects() {
    return this._excludedEffectView.hasEffects || this._includedEffectView.hasEffects;
  }
  get includedEffects() {
    return this._includedEffectView.effects;
  }
  set scale(e13) {
    this._set("scale", e13), this._excludedEffectView.scale = e13, this._includedEffectView.scale = e13;
  }
  get transitioning() {
    return this._excludedEffectView.transitioning || this._includedEffectView.transitioning;
  }
  get transitioningToEmpty() {
    return !this._excludedEffectView.final && !this._includedEffectView.final;
  }
  transitionStep(e13, t11) {
    this._set("scale", t11), this.transitioning ? (this._includedEffectView.transitionStep(e13, t11), this._excludedEffectView.transitionStep(e13, t11), this.transitioning || (this._filter = null)) : (this._excludedEffectView.scale = t11, this._includedEffectView.scale = t11);
  }
  endTransition() {
    this._includedEffectView.endTransition(), this._excludedEffectView.endTransition(), this._filter = null;
  }
  _transitionTo(e13) {
    const t11 = this._get("featureEffect"), i16 = e13, f8 = i16?.includedEffect, s14 = i16?.excludedEffect, c9 = this._includedEffectView.canTransitionTo(f8) && this._excludedEffectView.canTransitionTo(s14);
    this._includedEffectView.effect = f8, this._excludedEffectView.effect = s14, this._set("featureEffect", i16), this._filter = i16?.filter || t11?.filter || null, c9 || this.endTransition();
  }
};
__decorate([m()], c3.prototype, "_filter", void 0), __decorate([m()], c3.prototype, "_excludedEffectView", void 0), __decorate([m()], c3.prototype, "_includedEffectView", void 0), __decorate([m()], c3.prototype, "duration", void 0), __decorate([m()], c3.prototype, "excludedEffects", null), __decorate([m()], c3.prototype, "featureEffect", null), __decorate([m()], c3.prototype, "filter", null), __decorate([m()], c3.prototype, "hasEffects", null), __decorate([m()], c3.prototype, "includedEffects", null), __decorate([m({ value: 0 })], c3.prototype, "scale", null), __decorate([m()], c3.prototype, "transitioning", null), __decorate([m()], c3.prototype, "transitioningToEmpty", null), c3 = __decorate([a2("esri.layers.effects.FeatureEffectView")], c3);

// node_modules/@arcgis/core/rest/support/AggregateFeatureSet.js
var c4 = class extends g2 {
  constructor() {
    super(...arguments), this.features = [];
  }
  readFeatures(e13, t11) {
    const o14 = f.fromJSON(t11.spatialReference), s14 = [];
    for (let a10 = 0; a10 < e13.length; a10++) {
      const t12 = e13[a10], p12 = i10.fromJSON(t12), c9 = t12.geometry?.spatialReference;
      null == p12.geometry || c9 || (p12.geometry.spatialReference = o14);
      const i16 = t12.aggregateGeometries, m13 = p12.aggregateGeometries;
      if (i16 && null != m13) for (const e14 in m13) {
        const r12 = m13[e14], t13 = i16[e14], s15 = t13?.spatialReference;
        null == r12 || s15 || (r12.spatialReference = o14);
      }
      s14.push(p12);
    }
    return s14;
  }
};
__decorate([m({ type: [i10], json: { write: true } })], c4.prototype, "features", void 0), __decorate([o("features")], c4.prototype, "readFeatures", null), c4 = __decorate([a2("esri.rest.support.AggregateFeatureSet")], c4);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/FeatureInstanceStore.js
var n6 = class {
  constructor() {
    this._instanceById = /* @__PURE__ */ new Map();
  }
  destroy() {
    this._instanceById.clear();
  }
  get size() {
    return this._instanceById.size;
  }
  entries() {
    return this._instanceById.entries();
  }
  find(t11) {
    for (const e13 of this.values()) if (e13.techniqueRef.type === t11) return e13;
    return null;
  }
  updateStart(t11) {
    t11 && (this._instanceByIdNext = /* @__PURE__ */ new Map(), this._shaderCountByMesh = /* @__PURE__ */ new Map(), this._shaderIndices = /* @__PURE__ */ new Map());
  }
  updateEnd(t11) {
    if (t11) {
      if (!this._instanceByIdNext) throw new Error("InternalError: Found updateEnd call without corresponding updateStart");
      for (const t12 of this._instanceById.keys()) this._instanceByIdNext.has(t12) || this._instanceById.delete(t12);
      for (const [t12, e13] of this._instanceByIdNext.entries()) {
        const s14 = this._instanceById.get(t12);
        s14 ? s14.setInput(e13.getInput()) : this._instanceById.set(t12, e13);
      }
      this._instanceByIdNext = null, this._shaderCountByMesh = null, this._shaderIndices = null;
    }
  }
  values() {
    return this._instanceById.values();
  }
  ensureInstance(n14, i16) {
    let r12;
    if ("object" == typeof i16 && "optionalAttributes" in i16 && "uniforms" in i16) {
      const t11 = `${n14.type}.${JSON.stringify(i16.optionalAttributes)}`, e13 = t11 + `.${JSON.stringify(i16.uniforms)}`;
      let s14 = 0;
      null != this._instanceByIdNext && (this._shaderIndices.has(e13) ? s14 = this._shaderIndices.get(e13) : (s14 = this._shaderCountByMesh.get(t11) ?? 0, this._shaderCountByMesh.set(t11, s14 + 1), this._shaderIndices.set(e13, s14))), r12 = t11 + `.${s14}`;
    } else r12 = `${n14.type}.${JSON.stringify(i16)}`;
    const a10 = l(r12);
    if (this._instanceByIdNext) {
      const t11 = new i7(r3(a10), n14, i16);
      return this._instanceByIdNext.set(a10, t11), t11;
    }
    if (!this._instanceById.has(a10)) {
      const t11 = new i7(r3(a10), n14, i16);
      this._instanceById.set(a10, t11);
    }
    return this._instanceById.get(a10);
  }
  getInstance(t11) {
    const e13 = this._instanceById.get(t11);
    if (null == e13) throw new Error(`InternalError: Unable to get instance for ${t11}`);
    return e13;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/RenderState.js
var o5 = 1e3;
var d4 = class {
  constructor(t11, i16, s14, n14, r12, d10) {
    this.getStage = t11, this.getSubscriptionVersion = i16, this.version = s14, this._fader = n14, this._container = r12, this._tileInfoView = d10, this._pendingUpdates = new t2(o5), this._locked = false, this._tiles = /* @__PURE__ */ new Map();
  }
  destroy() {
    for (const e13 of this.tiles()) this._fader.unregisterFeatureTile(e13), e13.destroy();
    this._pendingUpdates.clear(), this._tiles.clear(), this._container = null, this._fader = null;
  }
  tiles() {
    return this._tiles.values();
  }
  size() {
    return this._tiles.size;
  }
  get usedMemory() {
    let e13 = 0;
    for (const t11 of this._tiles.values()) e13 += t11.usedMemory;
    for (const t11 of this._pendingUpdates.entries) t11 && (e13 += l4(t11.inner));
    return e13;
  }
  getTile(e13) {
    return this._tiles.get(e13);
  }
  setTiles(e13) {
    this._tiles.clear();
    for (const t11 of e13) this._tiles.set(t11.key.id, t11);
  }
  lockUploads() {
    this._locked = true;
  }
  unlockUploads() {
    this._locked = false, this.flush();
  }
  enqueueUpdate(e13) {
    this._pendingUpdates.enqueue(e13);
  }
  update(e13) {
    if (!this._locked) for (; this._pendingUpdates.size; ) {
      const t11 = this._pendingUpdates.peek();
      if (null == t11 || t11.inner.attributeEpoch > e13) break;
      this._updateTile(t11), this._pendingUpdates.dequeue();
    }
  }
  removeTile(e13) {
    const t11 = this._tiles.get(e13);
    has("esri-2d-update-debug") && console.debug(`Tile[${e13}] RenderState.removeTile`), t11 && (this._fader.unregisterFeatureTile(t11), t11.destroy()), this._tiles.delete(e13);
  }
  isTileDone(e13) {
    const t11 = this._tiles.get(e13.id);
    return !!t11 && (t11.isReady && t11.decluttered);
  }
  flush() {
    for (; this._pendingUpdates.size; ) {
      const e13 = this._pendingUpdates.dequeue();
      null != e13 && this._updateTile(e13);
    }
    for (const e13 of this._tiles.values()) e13.upload();
  }
  _updateTile(e13) {
    const { inner: t11, objectIdMap: i16 } = e13, s14 = this.getSubscriptionVersion(t11.id);
    if (s14 !== t11.subscriptionVesrion) {
      if (has("esri-2d-update-debug")) {
        const e14 = `${t11.subscriptionVesrion} != ${s14}`;
        console.debug(`Version[${e14}] Tile[${t11.id}] FeatureContainer - Dropping message, outdated version]`, t11);
      }
      return;
    }
    if (has("esri-2d-update-debug")) {
      const e14 = t11.debugInfo?.chunkId ?? "<EnsureEnd>";
      console.debug(`Version[${t11.version}] Tile[${t11.id}] Chunk[${e14}] RenderState.updateTile [${t11.type}]`, t11);
    }
    const n14 = this._ensureTile(t11.id);
    if ("update" === t11.type) {
      const [e14, ...s15] = t11.modify;
      n14.onMessage({ type: "update", modify: e14, remove: t11.remove, end: t11.end, attributeEpoch: t11.attributeEpoch, objectIdMap: i16 });
      for (const n15 of s15) {
        const e15 = this._tiles.get(n15.tileId);
        e15 && e15.onMessage({ type: "update", modify: n15, remove: t11.remove, end: false, isPixelBuffer: true, attributeEpoch: null, objectIdMap: i16 });
      }
      return;
    }
    if (null == t11.append) return void n14.onMessage({ type: "append", clear: t11.clear, debugInfo: t11.debugInfo, end: t11.end, attributeEpoch: t11.attributeEpoch, objectIdMap: i16 });
    const [r12, ...o14] = t11.append;
    n14.onMessage({ type: "append", clear: t11.clear, append: r12, debugInfo: t11.debugInfo, end: t11.end, attributeEpoch: t11.attributeEpoch, objectIdMap: i16 });
    for (const d10 of o14) {
      const e14 = this._tiles.get(d10.tileId);
      e14 && e14.onMessage({ type: "update", modify: d10, remove: [], sort: false, end: false, isPixelBuffer: true, attributeEpoch: null, objectIdMap: i16 });
    }
  }
  _ensureTile(e13) {
    if (!this._tiles.has(e13)) {
      const t11 = this._createTile(e13);
      this._copyPixelBufferedEntitiesInto(t11), this._tiles.set(e13, t11);
    }
    return this._tiles.get(e13);
  }
  _createTile(e13) {
    has("esri-2d-update-debug") && console.debug(`Version[${this.version}] Tile[${e13}] RenderState.createTile`);
    const o14 = new e2(e13), d10 = this._tileInfoView.getTileBounds(i4(), o14), l11 = d10[0], a10 = d10[3], u17 = this._tileInfoView.getTileResolution(o14.level), p12 = this._container.instanceStore.find(18)?.instanceId, c9 = new b4(o14, u17, l11, a10, this._fader, p12, true);
    if (this._fader.registerFeatureTile(c9), c9.stage = this.getStage(), !c9.stage) {
      const e14 = new s("featurelayerview:webgl", "Cannot create tile with empty stage");
      i2.getLogger("esri.views.2d.layers.features.RenderState").error(e14);
    }
    return c9;
  }
  _copyPixelBufferedEntitiesInto(e13) {
    let t11 = 7;
    const i16 = this._tileInfoView.getLODInfoAt(e13.key);
    for (let s14 = -1; s14 <= 1; s14++) for (let n14 = -1; n14 <= 1; n14++) {
      if (0 === s14 && 0 === n14) continue;
      const r12 = e13.key.getNormalizedNeighbor(n14, s14, i16).id, o14 = this._tiles.get(r12);
      if (null != o14) {
        const i17 = 1 << t11;
        e13.copyPixelBufferedEntitesFrom(o14, i17, n14, s14);
      }
      t11--;
    }
  }
};
function l4(e13) {
  switch (e13.type) {
    case "update":
      return e13.modify.reduce((e14, t11) => e14 + a7(t11), 0);
    case "append":
      return e13.append ? e13.append.reduce((e14, t11) => e14 + a7(t11), 0) : 0;
  }
}
function a7(e13) {
  return e13.entities.byteLength + e13.data.reduce((e14, t11) => e14 + u8(t11), 0);
}
function u8(e13) {
  return e13.indices.byteLength + e13.vertices.byteLength + (e13.metrics?.byteLength ?? 0);
}

// node_modules/@arcgis/core/views/2d/layers/features/FeatureContainer.js
var d5 = class {
  constructor(e13, t11) {
    this.id = e13, this.version = t11, this._resolver = $(), this._done = false;
  }
  get done() {
    return this._done;
  }
  get promise() {
    return this._resolver.promise;
  }
  end() {
    this._resolver.resolve(), this._done = true;
  }
  destroy() {
    this._resolver.reject();
  }
};
var l5 = class extends s6 {
  constructor(e13) {
    super(e13.view.featuresTilingScheme), this.updatingHandles = new h(), this._hitTestsRequests = [], this._store = new n6(), this._visibleTiles = /* @__PURE__ */ new Set(), this._subscriptions = /* @__PURE__ */ new Map(), this._updateStatisticsRequests = [], this._lockStatisticUpdates = false, this._shouldUnlockAttributeView = false, this._layerView = e13, this.addTransitionable(this._layerView.featureEffectView);
  }
  destroy() {
    this.updatingHandles.destroy(), super.destroy(), this._renderState = u(this._renderState), this._renderStateNext = u(this._renderStateNext);
  }
  renderChildren(e13) {
    if (this._updateAttributeView(), this._renderState?.update(this.attributeView.currentEpoch), this._layerView.requestUpdate(), this._renderState) {
      const e14 = Array.from(this._renderState.tiles()).filter((e15) => e15.needsUpload);
      if (e14.length) {
        e14[Math.floor(Math.random() * e14.length)].upload(), e14.length >= 2 && this.requestRender();
      }
      for (const t12 of this._renderState.tiles()) t12.tryReady(this.attributeView.currentEpoch) && (this._subscriptions.get(t12.key.id)?.end(), this._layerView.requestUpdate(), this.hasLabels && this._layerView.view.labelManager.requestUpdate(), this._layerView.view.labelManager.symbolFader.restartDeclutter(), this.requestRender());
    }
    const t11 = this._layerView.subscriptionManager.updateVisibility();
    this.setVisibleTiles(t11);
    for (const s14 of this.children) s14.setTransform(e13.state);
    switch (super.renderChildren(e13), e13.drawPhase) {
      case 1:
        return this._renderMapPhase(e13);
      case 16:
        return this._renderHighlightPhase(e13);
      case 2:
        return this._renderLabelPhase(e13);
    }
  }
  subscriptions() {
    return this._subscriptions.values();
  }
  get hasLabels() {
    return this._layerView.labelingCollisionInfos.length > 0;
  }
  get hasHighlight() {
    return this._layerView.hasHighlight;
  }
  get children() {
    return this._renderState ? Array.from(this._renderState.tiles()).filter((e13) => this._visibleTiles.has(e13.key.id)) : [];
  }
  get usedMemory() {
    let e13 = 0;
    return this._renderState && (e13 += this._renderState.usedMemory), this._renderStateNext && (e13 += this._renderStateNext.usedMemory), e13 += this.attributeView.usedMemory, e13;
  }
  get instanceStore() {
    return this._store;
  }
  get layerView() {
    return this._layerView;
  }
  get tiles() {
    return this._renderState?.tiles();
  }
  get _instanceStore() {
    return this._store;
  }
  get _layer() {
    return this._layerView.layer;
  }
  _getHeatmapInstance(e13) {
    if (null == this._instanceStore || !(e13.drawPhase & F.heatmap.drawPhase)) return null;
    for (const t11 of this._instanceStore.values()) if (u9(t11)) return t11;
    return null;
  }
  updateAttributeView(e13) {
    this.requestRender(), this.attributeView.requestUpdate(e13), this.hasLabels && (this._layerView.view.labelManager.requestUpdate(), this._layerView.view.labelManager.symbolFader.restartDeclutter());
  }
  updateSubscriptions(e13) {
    for (const { tileId: t11, version: s14 } of e13.subscribe) {
      if (!this._subscriptions.has(t11)) {
        const e14 = new d5(t11, s14);
        this._subscriptions.set(t11, e14), this.updatingHandles.addPromise(e14.promise);
        continue;
      }
      this._subscriptions.get(t11).version = s14;
    }
    for (const t11 of e13.unsubscribe) {
      const e14 = this._subscriptions.get(t11);
      e14?.destroy(), this._subscriptions.delete(t11), this.removeTile(t11);
    }
  }
  isDone(e13) {
    return !!this._renderState && this._renderState.isTileDone(e13);
  }
  async updateRenderState(e13) {
    has("esri-2d-update-debug") && console.debug(`Version[${e13}] FeatureContainer.updateRenderState`), this._renderStateNext = new d4(() => this._stage, (e14) => this._subscriptions.get(e14)?.version, e13, this.layerView.view.labelManager.symbolFader, this, this.tileInfoView);
  }
  getDisplayStatistics(e13, t11) {
    const s14 = this._statisticsByLevel.get(e13);
    return s14 ? s14.get(t11) : null;
  }
  updateStatistics(e13, t11) {
    if (this._lockStatisticUpdates) return void this._updateStatisticsRequests.push({ level: e13, statistics: t11 });
    let s14 = this._statisticsByLevel.get(e13);
    s14 || (s14 = /* @__PURE__ */ new Map(), this._statisticsByLevel.set(e13, s14));
    for (const r12 of t11) s14.set(r12.fieldName, { minValue: r12.minValue, maxValue: r12.maxValue });
  }
  lockForOverrides() {
    this._renderState?.lockUploads(), this._lockStatisticUpdates = true, this.attributeView.locked || (this.attributeView.lockTextureUploads(), this._shouldUnlockAttributeView = true);
  }
  unlockForOverrides() {
    this._renderState?.unlockUploads(), this._shouldUnlockAttributeView && (this.attributeView.unlockTextureUploads(), this._shouldUnlockAttributeView = false), this._lockStatisticUpdates = false;
    for (const e13 of this._updateStatisticsRequests) this.updateStatistics(e13.level, e13.statistics);
    this._updateStatisticsRequests = [], this._renderState?.flush(), this.requestRender();
  }
  trySwapRenderState() {
    if (this._renderStateNext) {
      has("esri-2d-update-debug") && console.debug(`Version[${this._renderStateNext.version}] FeatureContainer.update.swapRenderState`);
      const e13 = /* @__PURE__ */ new Map();
      for (const t11 of this._renderState?.tiles() || []) e13.set(t11.id, t11.metricsVisibility);
      this._renderState?.destroy(), this._renderState = this._renderStateNext, this._renderState.flush();
      for (const t11 of this._renderState.tiles()) t11.copyMetricsVisibility(e13.get(t11.id) || /* @__PURE__ */ new Set());
      this._renderStateNext = null;
    }
    this.requestRender();
  }
  setVisibleTiles(e13) {
    this._visibleTiles = e13;
    for (const t11 of this.tiles ?? []) t11.rendering = e13.has(t11.key.id);
  }
  async onMessage(e13, s14) {
    s2(s14);
    const r12 = e13.inner;
    if (!this._subscriptions.has(r12.id)) return;
    const i16 = this._subscriptions.get(r12.id);
    if (i16.version !== r12.subscriptionVesrion) {
      if (has("esri-2d-update-debug")) {
        const e14 = `${r12.subscriptionVesrion} != ${i16.version}`;
        console.debug(`Version[${e14}] Tile[${r12.id}] FeatureContainer - Dropping message, outdated version]`, r12);
      }
      return;
    }
    const n14 = this._renderStateNext ?? this._renderState;
    if (!n14) throw new Error("InternalError: No renderState defined");
    n14.version !== r12.version && console.error(`InternalError: Version mismatch. [renderState: ${n14.version}, message: ${r12.version}]`), n14.enqueueUpdate(e13), this.requestRender(), this._layerView.view.labelManager.requestUpdate(), this._layerView.requestUpdate();
  }
  removeTile(e13) {
    (this._renderState || this._renderStateNext) && (this._renderState && this._renderState.removeTile(e13), this._renderStateNext && this._renderStateNext.removeTile(e13));
  }
  hitTest(e13) {
    let t11 = this._hitTestsRequests.find(({ x: t12, y: s14 }) => t12 === e13.x && s14 === e13.y);
    const r12 = $();
    return t11 ? t11.resolvers.push(r12) : (t11 = { x: e13.x, y: e13.y, resolvers: [r12] }, this._hitTestsRequests.push(t11)), this.requestRender(), r12.promise;
  }
  getSortKeys(e13) {
    const t11 = new Set(e13), s14 = /* @__PURE__ */ new Map();
    for (const r12 of this.children) if (r12.getSortKeys(t11).forEach((e14, t12) => s14.set(t12, e14)), s14.size === t11.size) break;
    return s14;
  }
  get hasAnimation() {
    return this.hasLabels;
  }
  doRender(e13) {
    const { minScale: t11, maxScale: s14 } = this._layer.effectiveScaleRange, r12 = e13.state.scale;
    r12 <= (t11 || 1 / 0) && r12 >= s14 && super.doRender(e13);
  }
  afterRender(e13) {
    super.afterRender(e13), this._hitTestsRequests.length && this.requestRender();
  }
  setStencilReference(e13) {
    if (null == this._getHeatmapInstance(e13)) super.setStencilReference(e13);
    else for (const t11 of this.children) t11.stencilRef = F.heatmap.getStencilReference(t11);
  }
  _renderMapPhase(e13) {
    this._layerView.featureEffectView.hasEffects ? (this._renderOutsideEffect(e13), this._renderInsideEffect(e13)) : this._renderFeatures(e13, 0), this._hitTestsRequests.length > 0 && this._renderHittest(e13);
  }
  _renderHighlightPhase(e13) {
    this.hasHighlight && h3(e13, false, (e14) => {
      this._renderFeatures(e14, 1);
    });
  }
  _renderLabelPhase(e13) {
    this._renderFeatures(e13, 0);
  }
  _renderInsideEffect(e13) {
    const t11 = e13.painter.effects.insideEffect;
    t11.bind(e13), this._renderFeatures(e13, 2), t11.draw(e13, this._layerView.featureEffectView.includedEffects), t11.unbind();
  }
  _renderOutsideEffect(e13) {
    const t11 = e13.painter.effects.outsideEffect;
    t11.bind(e13), this._renderFeatures(e13, 3), t11.draw(e13, this._layerView.featureEffectView.excludedEffects), t11.unbind();
  }
  _renderHittest(e13) {
    const { context: t11 } = e13, s14 = e13.painter.effects.hittest, r12 = t11.getBoundFramebufferObject(), i16 = t11.getViewport(), n14 = e13.passOptions, a10 = e13.drawPhase;
    s14.bind(e13), e13.passOptions = s14.createOptions(e13, this._hitTestsRequests), e13.drawPhase = 8;
    const { distance: o14, smallSymbolDistance: h4 } = e13.passOptions, d10 = Math.max(o14, h4);
    for (const l11 of this.children) l11.visible && l11.containsScreenPoint(e13.state, e13.passOptions.position, 2 * d10) && this._renderTile(l11, e13, 0);
    s14.draw(e13), s14.unbind(), t11.bindFramebuffer(r12), t11.restoreViewport(i16), e13.passOptions = n14, e13.drawPhase = a10;
  }
  _renderFeatures(e13, t11) {
    const s14 = this._getHeatmapInstance(e13);
    null != s14 ? this._renderHeatmapFeatures(e13, t11, s14) : this._renderGeometryFeatures(e13, t11);
  }
  _renderGeometryFeatures(e13, t11) {
    for (const s14 of this.children) s14.visible && this._renderTile(s14, e13, t11);
  }
  _renderHeatmapFeatures(e13, t11, s14) {
    for (const r12 of this.children) r12.visible && this._renderTile(r12, e13, t11, 17);
    s14.techniqueRef.renderResolvePass(e13, s14);
  }
  _renderTile(e13, t11, s14, r12) {
    const i16 = has("featurelayer-strict-draw-order") ? 1 : has("featurelayer-force-marker-text-draw-order") ? 2 : 0, n14 = e13.getDisplayList(this._instanceStore, i16);
    t11.selection = s14, n14?.render(t11, r12);
  }
};
function u9(e13) {
  return 17 === e13.techniqueRef.type;
}

// node_modules/@arcgis/core/views/2d/layers/features/FeaturePipelineWorkerProxy.js
async function t7(t11) {
  const o14 = await p5("FeaturePipelineWorker", { client: t11, strategy: "dedicated" });
  return new n7(o14);
}
var n7 = class {
  constructor(e13) {
    this._connection = e13, this.pipeline = this._connection.createInvokeProxy(), this.features = this._connection.createInvokeProxy("features"), this.aggregates = this._connection.createInvokeProxy("aggregates"), this.streamMessenger = this._connection.createInvokeProxy("streamMessenger");
  }
  destroy() {
    this._connection.destroy();
  }
  get closed() {
    return this._connection.closed;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/FeatureSourceEventLog.js
var l6 = 10;
var u10 = class extends b {
  constructor() {
    super(...arguments), this.events = new i3(), this._updatingStrategy = true, this._tileToEvent = new s3(), this._fetchStatus = { outstanding: 0, done: 0 }, this._pipelineStatistics = { type: "performance", usedMemory: 0 };
  }
  get hasAllData() {
    return !this._updatingStrategy && this._hasAllTileData();
  }
  get pipelineStatistics() {
    return this._pipelineStatistics;
  }
  get willQueryAllFeatures() {
    return this._strategyInfo?.willQueryAllFeatures ?? false;
  }
  get willQueryFullResolutionGeometry() {
    return this._strategyInfo?.willQueryAllFeatures ?? false;
  }
  onEvent(t11) {
    switch (t11.type) {
      case "subscribe":
      case "unsubscribe":
      case "loaded":
      case "error":
        this._handleTileEvent(t11);
        break;
      case "updateStrategyStart":
        this._updatingStrategy = true, this._fetchStatus = { done: 0, outstanding: 0 }, this._strategyInfo = t11.about;
        break;
      case "updateStrategyEnd":
        this._updatingStrategy = false;
        break;
      case "updateFieldsStart":
        this._fetchStatus = { done: 0, outstanding: 0 };
        break;
      case "updateFieldsEnd":
        break;
      case "updateFieldsError":
        this.events.emit("error", t11);
        break;
      case "fetchStart":
        this._fetchStatus.outstanding += 1, this.events.emit("status", this._fetchStatus);
        break;
      case "fetchEnd":
        this._fetchStatus.done += 1, this.events.emit("status", this._fetchStatus), t11.done && (this._fetchStatus = { done: 0, outstanding: 0 });
        break;
      case "performance":
        this._pipelineStatistics = t11;
    }
  }
  _hasAllTileData() {
    for (const t11 of this._tileToEvent.values()) {
      const e13 = t11.peekLast();
      if ("loaded" !== e13?.type) return false;
    }
    return true;
  }
  _handleTileEvent(t11) {
    switch (t11.type) {
      case "subscribe": {
        const e13 = new t2(l6);
        e13.enqueue(t11), this._tileToEvent.set(t11.tile, e13);
        break;
      }
      case "unsubscribe":
        this._tileToEvent.delete(t11.tile);
        break;
      case "loaded": {
        const e13 = this._tileToEvent.get(t11.tile);
        if (!e13) return;
        e13.enqueue(t11), this._tileToEvent.set(t11.tile, e13);
        break;
      }
      case "error": {
        const e13 = this._tileToEvent.get(t11.tile);
        if (!e13) return;
        e13.enqueue(t11), this._tileToEvent.set(t11.tile, e13), this.events.emit("error", t11), i2.getLogger(this).error(`Failed to load tile ${t11.tile}.`, { error: t11.error });
        break;
      }
    }
  }
};
__decorate([m({ readOnly: true })], u10.prototype, "hasAllData", null), __decorate([m()], u10.prototype, "pipelineStatistics", null), __decorate([m()], u10.prototype, "willQueryAllFeatures", null), __decorate([m()], u10.prototype, "willQueryFullResolutionGeometry", null), __decorate([m()], u10.prototype, "_updatingStrategy", void 0), __decorate([m()], u10.prototype, "_strategyInfo", void 0), __decorate([m()], u10.prototype, "_tileToEvent", void 0), __decorate([m()], u10.prototype, "_pipelineStatistics", void 0), u10 = __decorate([a2("esri.views.2d.layers.features.FeatureSourceEventLog")], u10);

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/geometryUtils.js
function e5(e13) {
  switch (e13.geometryType) {
    case "point":
      return "esriGeometryPoint";
    case "polyline":
      return "esriGeometryPolyline";
    case "mesh":
    case "polygon":
      return "esriGeometryPolygon";
    case "multipatch":
      return "esriGeometryMultiPatch";
    case "multipoint":
      return "esriGeometryMultipoint";
    default:
      return null;
  }
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/featureReductionUtils.js
function e6(e13, a10) {
  const c9 = e13.featureReduction;
  return c9 && "selection" !== c9.type && (!("maxScale" in c9) || !c9.maxScale || c9.maxScale < a10.scale) ? c9 : null;
}

// node_modules/@arcgis/core/views/2d/layers/support/visualVariableSimpleUtils.js
var e7 = Math.PI;
function r6(t11, n14) {
  switch (n14.transformationType) {
    case "additive":
      return a8(t11, n14);
    case "constant":
      return s9(n14, t11);
    case "clamped-linear":
      return u11(t11, n14);
    case "proportional":
      return o6(t11, n14);
    case "stops":
      return c5(t11, n14);
    case "real-world-size":
      return l7(t11, n14);
    case "identity":
      return t11;
    case "unknown":
      return null;
  }
}
function i12(t11, n14) {
  return "number" == typeof t11 ? t11 : r6(n14, t11);
}
function a8(t11, n14) {
  return t11 + (i12(n14.minSize, t11) || n14.minDataValue);
}
function s9(t11, n14) {
  const e13 = t11.stops;
  let r12 = e13?.length && e13[0].size;
  return null == r12 && (r12 = t11.minSize), i12(r12, n14);
}
function u11(t11, n14) {
  const e13 = n14.minDataValue, r12 = n14.maxDataValue, a10 = (t11 - e13) / (r12 - e13), s14 = i12(n14.minSize, t11), u17 = i12(n14.maxSize, t11);
  return t11 <= e13 ? s14 : t11 >= r12 ? u17 : s14 + a10 * (u17 - s14);
}
function o6(n14, e13) {
  const r12 = n14 / e13.minDataValue, a10 = i12(e13.minSize, n14), s14 = i12(e13.maxSize, n14);
  let u17 = null;
  return u17 = r12 * a10, r(u17, a10, s14);
}
function c5(t11, n14) {
  const [e13, r12, a10] = m8(t11, n14.cache.ipData);
  if (e13 === r12) return i12(n14.stops[e13].size, t11);
  {
    const s14 = i12(n14.stops[e13].size, t11);
    return s14 + (i12(n14.stops[r12].size, t11) - s14) * a10;
  }
}
function l7(t11, r12) {
  const i16 = m4[r12.valueUnit], { valueRepresentation: a10 } = r12;
  let s14 = null;
  return s14 = "area" === a10 ? 2 * Math.sqrt(t11 / e7) / i16 : "radius" === a10 || "distance" === a10 ? 2 * t11 / i16 : t11 / i16, s14;
}
function m8(t11, n14) {
  if (!n14) return;
  let e13 = 0, r12 = n14.length - 1;
  return n14.some((n15, i16) => t11 < n15 ? (r12 = i16, true) : (e13 = i16, false)), [e13, r12, (t11 - n14[e13]) / (n14[r12] - n14[e13])];
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/labelingUtils.js
function l8(n14) {
  return (n14.labelsVisible && n14.labelingInfo?.every((n15) => "none" !== n15.deconflictionStrategy)) ?? false;
}
function r7(n14, i16) {
  const l11 = e6(n14, i16);
  if (l11?.labelsVisible && l11.labelingInfo?.length) return l11.labelingInfo.every((n15) => "none" !== n15.deconflictionStrategy);
}
function t8(e13) {
  return (l11) => u3(r6(l11, e13));
}
function o7(n14) {
  const e13 = null != n14 && "visualVariables" in n14 && n14.visualVariables;
  if (!e13) return null;
  for (const i16 of e13) if ("size" === i16.type) return t8(i16);
  return null;
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/ExceedsLimitCache.js
var s10 = class {
  constructor() {
    this._cache = /* @__PURE__ */ new Map();
  }
  async executeExceedsLimitQuery(t11, e13, r12) {
    const s14 = i5.createFeature(t11.metadata), i16 = u7.create(t11, e13, s14).createQuery();
    i16.inner.orderByFields = [], i16.inner.returnGeometry = false, i16.inner.cacheHint = true;
    const c9 = "esriGeometryPoint" !== t11.metadata.geometryType, u17 = JSON.stringify({ source: t11.source, query: i16.inner.toJSON(), customParameters: i16.customParameters, snapshotInfo: r12, isPoints: c9 });
    let m13 = this._cache.get(u17);
    return null == m13 && (m13 = await n8(t11.source, c9, i16, r12), this._cache.set(u17, m13)), m13;
  }
};
async function n8(e13, a10, o14, s14) {
  if (!s14.supportsExceedsLimit) return i13(e13, a10, o14, s14);
  try {
    const a11 = o14.inner.clone(), n14 = new p();
    n14.statisticType = "exceedslimit", n14.maxPointCount = s14.maxFeatureCount, n14.maxRecordCount = s14.maxFeatureCount, n14.outStatisticFieldName = "exceedslimit", s14.maxVertexCount && (n14.maxVertexCount = s14.maxVertexCount), a11.outStatistics = [n14];
    const i16 = await y2(e13, a11, void 0, { query: o14.customParameters }), c9 = i16.data.features[0]?.attributes.exceedslimit;
    return !(0 === c9);
  } catch (n14) {
    return i13(e13, a10, o14, s14);
  }
}
async function i13(t11, r12, a10, o14) {
  if (r12) return true;
  const s14 = a10.inner.clone();
  try {
    return (await p2(t11, s14, { query: a10.customParameters })).data.count > o14.maxFeatureCount;
  } catch (n14) {
    return true;
  }
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/SourceSchema.js
async function e8(e13, r12, i16) {
  return { type: "feature", service: e13, strategy: await t9(e13, i16, r12, i16.cache) };
}
async function t9(e13, t11, r12, i16) {
  const s14 = t11.customParameters ?? {};
  t11.apiKey && (s14.apiKey = t11.apiKey);
  const n14 = t11.displayFilterEnabled ? t11.displayFilterInfo?.toJSON() : null, o14 = t11.historicMoment?.getTime(), a10 = t11.timeExtent?.toJSON(), l11 = { ...t11, displayFilterInfo: n14, customParameters: s14, historicMoment: o14, timeExtent: a10 };
  if ("feature-service" === e13.type && null != r12 && !await i16.executeExceedsLimitQuery(e13, l11, r12)) return { type: "snapshot", snapshotInfo: r12, partial: { availableFields: t11.availableFields }, full: { displayFilterInfo: null, queryScaleRanges: null, sourceRefreshVersion: t11.sourceRefreshVersion, definitionExpression: t11.definitionExpression, customParameters: t11.customParameters, gdbVersion: t11.gdbVersion, historicMoment: o14, timeExtent: a10 } };
  return "feature-service" === e13.type && e13.isSourceHosted || "memory" === e13.type || "ogc" === e13.type ? { type: "paged-tile", partial: { availableFields: t11.availableFields }, full: { sourceRefreshVersion: t11.sourceRefreshVersion, definitionExpression: t11.definitionExpression, customParameters: t11.customParameters, gdbVersion: t11.gdbVersion, historicMoment: o14, queryScaleRanges: t11.queryScaleRanges, timeExtent: a10, displayFilterInfo: n14 } } : { type: "drill-down", partial: { availableFields: t11.availableFields }, full: { sourceRefreshVersion: t11.sourceRefreshVersion, definitionExpression: t11.definitionExpression, customParameters: t11.customParameters, gdbVersion: t11.gdbVersion, historicMoment: o14, queryScaleRanges: t11.queryScaleRanges, timeExtent: a10, displayFilterInfo: n14 } };
}
function r8(e13, t11, r12, a10, l11, u17) {
  const c9 = o8(a10);
  if (!(!!has("featurelayer-snapshot-enabled") && r12?.query.supportsPagination && !r12?.operations.supportsEditing && !t11)) return null;
  const m13 = n9(l11, u17), { min: p12, max: y7 } = c9, h4 = m13 ? y7 : p12, d10 = s11(a10);
  let f8 = has("featurelayer-snapshot-initial-tolerance");
  return "esriGeometryPoint" !== a10 && "esriGeometryMultipoint" !== a10 || (f8 = null), { supportsExceedsLimit: i14(e13, r12), initialTolerance: f8, maxFeatureCount: h4, maxVertexCount: d10 };
}
function i14(e13, t11) {
  return !(!e13 && !has("featurelayer-snapshot-non-hosted-exceedslimit-enabled")) && t11?.operations.supportsExceedsLimitStatistics;
}
function s11(e13) {
  switch (e13) {
    case "esriGeometryPoint":
    case "esriGeometryPolyline":
    case "esriGeometryPolygon":
    case "esriGeometryMultiPatch":
    case "esriGeometryMultipoint":
      return has("featurelayer-snapshot-max-vertex-count");
  }
}
function n9(e13, t11) {
  const r12 = t11?.clone().intersection(e13), i16 = null != r12 ? r12.width * r12.height : 0, s14 = t11 ? t11.width * t11.height : 0, n14 = 0 === s14 ? 0 : i16 / s14, o14 = has("featurelayer-snapshot-coverage");
  return !isNaN(n14) && n14 >= o14;
}
function o8(e13) {
  switch (e13) {
    case "esriGeometryMultipoint":
      return { min: has("featurelayer-snapshot-multipoint-min-threshold"), max: has("featurelayer-snapshot-multipoint-max-threshold") };
    case "esriGeometryPoint":
      return { min: has("featurelayer-snapshot-point-min-threshold"), max: has("featurelayer-snapshot-point-max-threshold") };
    case "esriGeometryMultiPatch":
    case "esriGeometryPolygon":
      return { min: has("featurelayer-snapshot-polygon-min-threshold"), max: has("featurelayer-snapshot-polygon-max-threshold") };
    case "esriGeometryPolyline":
      return { min: has("featurelayer-snapshot-polyline-min-threshold"), max: has("featurelayer-snapshot-polyline-max-threshold") };
  }
}

// node_modules/@arcgis/core/views/2d/engine/webgl/color.js
function u12(n14, r12, t11 = 0) {
  if (null == r12) return n14[t11] = 0, n14[t11 + 1] = 0, n14[t11 + 2] = 0, void (n14[t11 + 3] = 0);
  const { r: o14, g: u17, b: i16, a: c9 } = r12;
  n14[t11] = o14 * c9 / 255, n14[t11 + 1] = u17 * c9 / 255, n14[t11 + 2] = i16 * c9 / 255, n14[t11 + 3] = c9;
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/symbols/SymbolSchema.js
async function z3(i16, a10) {
  if (!i16) return [];
  switch (i16.type) {
    case "simple-fill":
      return U(i16, a10);
    case "picture-fill":
      return j2(i16, a10);
    case "simple-marker":
      return C(i16, a10);
    case "picture-marker":
      return I(i16, a10);
    case "simple-line":
      return F2(i16, a10, false);
    case "text":
      return O2(i16, a10);
    case "label":
      return A2(i16, a10);
    case "cim":
      return c2(i16.data, a10);
    case "web-style":
      return z3(await i16.fetchSymbol({ acceptedFormats: ["cim", "web"] }), a10);
    case "line-3d":
      return i2.getLogger("esri.views.layers.FeatureLayerView").warn("unsupported-symbol", `Symbol of type "${i16.type}" unsupported in MapView. Defaulting to simple-line`), F2(new m5(), a10, false);
    case "point-3d":
      return i2.getLogger("esri.views.layers.FeatureLayerView").warn("unsupported-symbol", `Symbol of type "${i16.type}" unsupported in MapView. Defaulting to simple-marker`), C(new u5(), a10);
    case "polygon-3d":
      return i2.getLogger("esri.views.layers.FeatureLayerView").warn("unsupported-symbol", `Symbol of type "${i16.type}" unsupported in MapView. Defaulting to simple-fill`), U(new m6(), a10);
    case "mesh-3d":
    case "label-3d":
      return i2.getLogger("esri.views.layers.FeatureLayerView").warn("unsupported-symbol", `Symbol of type "${i16.type}" unsupported in MapView. Ignoring`), [];
    case "CIMSymbolReference":
      throw new Error("InternalError: CIMSymbolReference should already be resolved");
  }
}
async function d6(e13, i16) {
  const { schemaOptions: a10 } = i16, { store: r12 } = a10, t11 = new Array(f3), o14 = new Array(f3 / 4);
  for (let l11 = 0; l11 < f3; l11++) {
    const i17 = l11 < e13.attributes.length ? e13.attributes[l11].color : null;
    t11[l11] = [0, 0, 0, 0], u12(t11[l11], i17);
  }
  for (let l11 = 0; l11 < f3 / 4; l11++) o14[l11] = [0, 0, 0, 0], o14[l11][0] = 4 * l11 < e13.attributes.length ? 1 : 0, o14[l11][1] = 4 * l11 + 1 < e13.attributes.length ? 1 : 0, o14[l11][2] = 4 * l11 + 2 < e13.attributes.length ? 1 : 0, o14[l11][3] = 4 * l11 + 3 < e13.attributes.length ? 1 : 0;
  const s14 = { uniforms: { isActive: o14, colors: t11, dotValue: e13.dotValue, dotScale: e13.referenceScale, blending: e13.dotBlendingEnabled, dotSize: e13.dotSize, seed: e13.seed }, optionalAttributes: {} }, n14 = r12.ensureInstance(F.dotDensity, s14).createMeshInfo({ effects: null }), u17 = [], b8 = new m6({ color: e13.backgroundColor ?? [0, 0, 0, 0], outline: null }), m13 = await z3(b8, i16);
  if (u17.push(...m13), u17.push(n14), e13.outline) {
    const a11 = F2(e13.outline, i16, true);
    u17.push(...a11);
  }
  return u17;
}
async function g3(e13, l11) {
  const { store: r12 } = l11, { radius: t11, minDensity: o14, maxDensity: s14, referenceScale: n14, field: u17, valueExpression: c9, colorStops: p12 } = e13, b8 = f2(p12);
  return [r12.ensureInstance(F.heatmap, { uniforms: { radius: u3(t11), minDensity: o14, maxDensity: s14, referenceScale: n14, isFieldActive: !(!u17 && !c9), gradient: b8, gradientHash: b8.join(",") }, optionalAttributes: {} }).createMeshInfo({ effects: null })];
}
async function M(e13, a10) {
  const { store: l11 } = a10, r12 = e13.outline?.width || 0, t11 = x2(e13), o14 = l11.ensureInstance(F.pieChart, { uniforms: { shader: { outlineWidth: Math.round(u3(r12)), defaultColor: t5(e13.defaultColor), outlineColor: t5(e13.outline?.color), othersColor: t5(e13.othersCategory?.color), donutRatio: e13.holePercentage, sectorThreshold: e13.othersCategory?.threshold || 0, colors: e13.attributes.map((e14) => t5(e14.color)), visualVariableOpacity: t11.visualVariableOpacity, visualVariableSizeMinMaxValue: t11.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: t11.visualVariableSizeScaleStops, visualVariableSizeStops: t11.visualVariableSizeStops, visualVariableSizeUnitValue: t11.visualVariableSizeUnitValue, hittestUniforms: null, highlightUniforms: null }, numberOfFields: e13.attributes.length }, optionalAttributes: {} }).createMeshInfo({ size: e13.size, outlineWidth: r12, effects: null, scaleInfo: null, minPixelBuffer: z2(t11) });
  return [...e13.backgroundFillSymbol ? await U(e13.backgroundFillSymbol, { schemaOptions: a10, uniforms: b5 }) : [], o14];
}
function x3(e13) {
  if ("path" === e13.style) {
    if (null == e13.path) throw new Error("Symbol with a style of type path must define a path");
    return { type: "sprite-rasterization-param", overrides: [], resource: { type: "path", path: e13.path, asFill: true } };
  }
  const i16 = Y.fromSimpleMarker(e13);
  if ("outline" in e13 && e13.outline && "none" !== e13.outline.style) {
    if ("solid" !== e13.outline.style) {
      if (!i16 || !i16.symbolLayers) throw new Error("Error handling marker! ");
      return { type: "sprite-rasterization-param", resource: i16.symbolLayers[0], overrides: [] };
    }
  }
  return { type: "sprite-rasterization-param", resource: a5(i16), overrides: [] };
}
async function C(e13, i16) {
  const { uniforms: a10, schemaOptions: l11 } = i16, { store: r12 } = l11;
  if ("path" === e13.style || e13.outline && "solid" !== e13.outline.style && "none" !== e13.outline.style) {
    const l12 = Y.fromSimpleMarker(e13);
    if (!l12 || !l12.symbolLayers) throw new Error("Error handling marker! ");
    if (a10.visualVariableRotation && (l12.angleAlignment = "Map"), "path" !== e13.style) {
      const e14 = l12.symbolLayers[0];
      if (A(i16.uniforms)) {
        const a11 = z2(i16.uniforms, 0, 1);
        if (a11 > e14.size) {
          const i17 = a11 / e14.size;
          e14.size = a11;
          const l13 = e14.markerGraphics?.[0].symbol;
          (l13.symbolLayers && l13.symbolLayers[0]).width *= i17;
        }
      }
    }
    return c2({ type: "CIMSymbolReference", symbol: l12 }, i16);
  }
  const t11 = r12.ensureInstance(F.marker, { uniforms: { visualVariableColor: a10.visualVariableColor, visualVariableOpacity: a10.visualVariableOpacity, visualVariableSizeMinMaxValue: a10.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: a10.visualVariableSizeScaleStops, visualVariableSizeStops: a10.visualVariableSizeStops, visualVariableSizeUnitValue: a10.visualVariableSizeUnitValue, visualVariableRotation: a10.visualVariableRotation }, optionalAttributes: { zoomRange: false } }), s14 = x3(e13);
  let n14 = e13.color?.toArray() ?? [0, 0, 0, 0];
  "CIMVectorMarker" === s14.resource.type && (n14 = [255, 255, 255, 255]);
  const u17 = "triangle" === e13.style ? 124 / 116 : 1, c9 = e13.size, p12 = c9 * u17, b8 = null != a10.visualVariableColor && ("cross" === e13.style || "x" === e13.style);
  return [t11.createMeshInfo({ type: "simple", color: n14, height: c9, width: p12, offsetX: e13.xoffset, offsetY: e13.yoffset, angle: e13.angle, alignment: e4(a10) ? 1 : 0, outlineColor: e13.outline?.color?.toArray() ?? [0, 0, 0, 0], outlineSize: e13.outline?.width ?? 1, referenceSize: c9, sprite: s14, overrideOutlineColor: b8, hasSizeVV: A(a10), placement: null, effects: null, transforms: null, scaleInfo: null, minPixelBuffer: z2(a10) })];
}
function I(e13, i16) {
  const { uniforms: a10, schemaOptions: l11 } = i16, { store: r12 } = l11, t11 = r12.ensureInstance(F.marker, { uniforms: { visualVariableColor: a10.visualVariableColor, visualVariableOpacity: a10.visualVariableOpacity, visualVariableSizeMinMaxValue: a10.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: a10.visualVariableSizeScaleStops, visualVariableSizeStops: a10.visualVariableSizeStops, visualVariableSizeUnitValue: a10.visualVariableSizeUnitValue, visualVariableRotation: a10.visualVariableRotation }, optionalAttributes: { zoomRange: false } }), s14 = Y.createPictureMarkerRasterizationParam(e13);
  if (!s14) return [];
  return [t11.createMeshInfo({ type: "picture", color: [255, 255, 255, 255], height: e13.height, width: e13.width, offsetX: e13.xoffset, offsetY: e13.yoffset, angle: e13.angle, alignment: e4(a10) ? 1 : 0, outlineColor: null, outlineSize: 0, referenceSize: e13.height, sprite: s14, overrideOutlineColor: false, hasSizeVV: A(a10), placement: null, effects: null, transforms: null, scaleInfo: null, minPixelBuffer: z2(a10) })];
}
function w3(e13, i16, a10) {
  const { uniforms: l11, schemaOptions: r12 } = a10, { store: t11 } = r12, o14 = t11.ensureInstance(F.marker, { uniforms: { visualVariableColor: l11.visualVariableColor, visualVariableOpacity: l11.visualVariableOpacity, visualVariableSizeMinMaxValue: l11.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: l11.visualVariableSizeScaleStops, visualVariableSizeStops: l11.visualVariableSizeStops, visualVariableSizeUnitValue: l11.visualVariableSizeUnitValue, visualVariableRotation: l11.visualVariableRotation }, optionalAttributes: { zoomRange: false } }), s14 = x3(e13), n14 = 6, u17 = n14 * i16.width, c9 = u17, p12 = e13.color?.toArray() ?? i16.color?.toArray() ?? [0, 0, 0, 0], b8 = "cross" === e13.style || "x" === e13.style;
  let m13;
  switch (e13.placement) {
    case "begin-end":
      m13 = "Both";
      break;
    case "begin":
      m13 = "JustBegin";
      break;
    case "end":
      m13 = "JustEnd";
      break;
    default:
      m13 = "None";
  }
  const V2 = { type: "cim-marker-placement-param", placement: { type: "CIMMarkerPlacementAtExtremities", angleToLine: true, offset: 0, extremityPlacement: m13, offsetAlongLine: 0 }, overrides: [] };
  return [o14.createMeshInfo({ type: "simple", color: p12, height: c9, width: u17, offsetX: 0, offsetY: 0, angle: 0, alignment: e4(l11) ? 1 : 0, outlineColor: p12, outlineSize: b8 ? i16.width : 0, referenceSize: c9 / n14, sprite: s14, overrideOutlineColor: b8 && null != l11.visualVariableColor, hasSizeVV: A(l11), placement: V2, transforms: null, effects: null, scaleInfo: null, minPixelBuffer: z2(l11) })];
}
function O2(e13, i16) {
  const { uniforms: a10, schemaOptions: l11 } = i16, { store: r12 } = l11;
  return [r12.ensureInstance(F.text, { uniforms: { visualVariableColor: a10.visualVariableColor, visualVariableOpacity: a10.visualVariableOpacity, visualVariableRotation: a10.visualVariableRotation, visualVariableSizeMinMaxValue: a10.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: a10.visualVariableSizeScaleStops, visualVariableSizeStops: a10.visualVariableSizeStops, visualVariableSizeUnitValue: a10.visualVariableSizeUnitValue }, optionalAttributes: { zoomRange: false, clipAngle: false, referenceSymbol: false, visibility: false } }).createMeshInfo({ boxBackgroundColor: e13.backgroundColor?.toArray(), boxBorderLineColor: e13.borderLineColor?.toArray(), boxBorderLineSize: e13.borderLineSize ?? 0, color: e13.color?.toArray() ?? [0, 0, 0, 0], offsetX: e13.xoffset, offsetY: e13.yoffset, postAngle: e13.angle, fontSize: e13.font.size, decoration: e13.font.decoration, haloColor: e13.haloColor?.toArray() ?? [0, 0, 0, 0], haloSize: e13.haloSize ?? 0, outlineColor: [0, 0, 0, 0], outlineSize: 0, lineWidth: e13.lineWidth, lineHeightRatio: e13.lineHeight, horizontalAlignment: e13.horizontalAlignment, verticalAlignment: e13.verticalAlignment, useCIMAngleBehavior: false, glyphs: { type: "text-rasterization-param", resource: { type: "text", font: e13.font.toJSON(), textString: e13.text, symbol: Y.createCIMTextSymbolfromTextSymbol(e13) }, overrides: [] }, referenceSize: null, effects: null, placement: null, scaleInfo: null, transforms: null, scaleFactor: 1, minPixelBuffer: z2(a10), repeatLabel: null, repeatLabelDistance: null, allowOverrun: null, labelPosition: null, layerId: null, labelClassId: null })];
}
function A2(e13, a10) {
  const { schemaOptions: l11, uniforms: r12 } = a10, { store: t11 } = l11, s14 = e13.symbol, { allowOverrun: n14, repeatLabel: c9, repeatLabelDistance: p12 } = e13, b8 = { maxScale: e13.maxScale ?? 0, minScale: e13.minScale ?? 0 }, m13 = t11.ensureInstance(F.label, { uniforms: { visualVariableColor: null, visualVariableOpacity: null, visualVariableRotation: r12.visualVariableRotation, visualVariableSizeMinMaxValue: r12.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: r12.visualVariableSizeScaleStops, visualVariableSizeStops: r12.visualVariableSizeStops, visualVariableSizeUnitValue: r12.visualVariableSizeUnitValue }, optionalAttributes: { zoomRange: true, clipAngle: true, referenceSymbol: true, visibility: true } }), V2 = e13.labelPlacement, [y7, v] = a4(V2);
  return [m13.createMeshInfo({ boxBackgroundColor: s14.backgroundColor?.toArray(), boxBorderLineColor: s14.borderLineColor?.toArray(), boxBorderLineSize: s14.borderLineSize ?? 0, color: s14.color?.toArray() ?? [0, 0, 0, 0], offsetX: s14.xoffset, offsetY: s14.yoffset, postAngle: s14.angle, fontSize: s14.font.size, decoration: s14.font.decoration, outlineColor: [0, 0, 0, 0], outlineSize: 0, haloColor: s14.haloColor?.toArray() ?? [0, 0, 0, 0], haloSize: s14.haloSize ?? 0, lineWidth: s14.lineWidth, lineHeightRatio: s14.lineHeight, horizontalAlignment: y7, verticalAlignment: v, repeatLabel: c9, repeatLabelDistance: u3(p12), allowOverrun: n14, labelPosition: e13.labelPosition, scaleInfo: b8, minPixelBuffer: z2(r12), useCIMAngleBehavior: false, glyphs: { type: "text-rasterization-param", resource: { type: "text", font: s14.font.toJSON(), textString: s14.text, symbol: Y.createCIMTextSymbolfromTextSymbol(s14), primitiveName: "label-override" }, useLegacyLabelEvaluationRules: null == e13.labelExpressionInfo?.expression, overrides: [{ valueExpressionInfo: { type: "CIMExpressionInfo", expression: e13.labelExpressionInfo?.expression ?? e13.labelExpression, returnType: "String" }, primitiveName: "label-override", propertyName: "textString", defaultValue: "" }] }, referenceSize: null, effects: null, placement: null, transforms: null, scaleFactor: 1, layerId: a10.layerId, labelClassId: a10.labelClassId })];
}
function L2(e13, i16) {
  const a10 = e13.width;
  return { outlineColor: e13.color?.toArray() || [0, 0, 0, 1], width: a10, referenceWidth: a10, capType: e13.cap ?? "round", joinType: e13.join ?? "round", miterLimit: e13.miterLimit, hasSizeVV: i16, outlineUsesColorVV: false };
}
function R2(e13, i16) {
  const { uniforms: a10, schemaOptions: l11 } = i16, { store: r12 } = l11, t11 = e13.color?.toArray() ?? [0, 0, 0, 0], o14 = { type: "sprite-rasterization-param", resource: { type: "fill-style", style: e13.style }, overrides: [] };
  if ("solid" === e13.outline?.style) {
    return [r12.ensureInstance(F.patternOutlineFill, { uniforms: { visualVariableColor: a10.visualVariableColor, visualVariableOpacity: a10.visualVariableOpacity, visualVariableSizeScaleStops: a10.visualVariableSizeOutlineScaleStops, visualVariableSizeMinMaxValue: null, visualVariableSizeStops: null, visualVariableSizeUnitValue: null }, optionalAttributes: { zoomRange: false } }).createMeshInfo({ color: t11, ...L2(e13.outline, !!a10.visualVariableSizeOutlineScaleStops), sprite: o14, scaleInfo: null, effects: null })];
  }
  const s14 = [], n14 = r12.ensureInstance(F.patternFill, { uniforms: { visualVariableColor: a10.visualVariableColor, visualVariableOpacity: a10.visualVariableOpacity }, optionalAttributes: { zoomRange: false } }).createMeshInfo({ color: e13.color?.toArray() ?? [0, 0, 0, 0], sprite: o14, scaleInfo: null, effects: null });
  return s14.push(n14), e13.outline && s14.push(...F2(e13.outline, i16, true)), s14;
}
function k(e13, i16) {
  const { uniforms: a10, schemaOptions: l11 } = i16, { store: r12 } = l11, t11 = e13.color?.toArray() ?? [0, 0, 0, 0];
  if ("none" !== e13.style && "solid" === e13.outline?.style) {
    return [r12.ensureInstance(F.outlineFill, { uniforms: { visualVariableColor: a10.visualVariableColor, visualVariableOpacity: a10.visualVariableOpacity, visualVariableSizeScaleStops: a10.visualVariableSizeOutlineScaleStops, visualVariableSizeMinMaxValue: null, visualVariableSizeStops: null, visualVariableSizeUnitValue: null }, optionalAttributes: { zoomRange: false } }).createMeshInfo({ color: t11, ...L2(e13.outline, !!a10.visualVariableSizeOutlineScaleStops), scaleInfo: null, effects: null })];
  }
  const o14 = [];
  if ("none" !== e13.style) {
    const e14 = r12.ensureInstance(F.fill, { uniforms: { visualVariableColor: a10.visualVariableColor, visualVariableOpacity: a10.visualVariableOpacity }, optionalAttributes: { zoomRange: false } }).createMeshInfo({ color: t11, scaleInfo: null, effects: null });
    o14.push(e14);
  }
  return e13.outline && o14.push(...F2(e13.outline, i16, true)), o14;
}
async function U(e13, i16) {
  if ("cim" === e13.type) return c2(e13.data, i16);
  const { style: a10 } = e13;
  return a10 && "none" !== a10 && "solid" !== a10 ? R2(e13, i16) : k(e13, i16);
}
function j2(e13, i16) {
  const { outline: a10 } = e13, { uniforms: l11, schemaOptions: r12 } = i16, { store: t11 } = r12, s14 = [], n14 = Y.createPictureFillRasterizationParam(e13);
  if (!n14) return [];
  const { width: u17, height: c9, xoffset: p12, yoffset: b8, xscale: m13, yscale: S } = e13, V2 = { color: [255, 255, 255, 255], sprite: n14, height: c9, aspectRatio: u17 / c9, offsetX: p12, offsetY: b8, scaleX: m13, scaleY: S, angle: 0, applyRandomOffset: false, sampleAlphaOnly: false, scaleProportionally: false, effects: null, scaleInfo: null };
  if ("solid" === a10?.style) {
    return [t11.ensureInstance(F.complexOutlineFill, { uniforms: { visualVariableColor: l11.visualVariableColor, visualVariableOpacity: l11.visualVariableOpacity, visualVariableSizeScaleStops: l11.visualVariableSizeOutlineScaleStops, visualVariableSizeMinMaxValue: null, visualVariableSizeStops: null, visualVariableSizeUnitValue: null }, optionalAttributes: { zoomRange: false } }).createMeshInfo({ ...V2, ...L2(a10, !!l11.visualVariableSizeOutlineScaleStops) })];
  }
  const y7 = t11.ensureInstance(F.complexFill, { uniforms: { visualVariableColor: l11.visualVariableColor, visualVariableOpacity: l11.visualVariableOpacity }, optionalAttributes: { zoomRange: false } });
  return s14.push(y7.createMeshInfo(V2)), a10 && s14.push(...F2(a10, i16, true)), s14;
}
function F2(e13, i16, a10) {
  const { color: l11, style: r12, width: t11, cap: o14, join: n14 } = e13, { schemaOptions: u17 } = i16, { store: c9 } = u17, p12 = [], b8 = a10 ? { ...b5, visualVariableSizeScaleStops: i16.uniforms.visualVariableSizeOutlineScaleStops } : i16.uniforms, m13 = { uniforms: { visualVariableColor: b8.visualVariableColor, visualVariableOpacity: b8.visualVariableOpacity, visualVariableSizeMinMaxValue: b8.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: b8.visualVariableSizeScaleStops, visualVariableSizeStops: b8.visualVariableSizeStops, visualVariableSizeUnitValue: b8.visualVariableSizeUnitValue }, optionalAttributes: { zoomRange: false } }, S = { color: l11?.toArray() ?? [0, 0, 0, 0], width: t11, referenceWidth: t11, capType: o14, joinType: n14, miterLimit: e13.miterLimit, hasSizeVV: A(b8), effects: null, scaleInfo: null };
  if (null == r12 || "solid" === r12) {
    const e14 = c9.ensureInstance(F.line, m13).createMeshInfo(S);
    p12.push(e14);
  } else if ("none" !== r12) {
    const e14 = c9.ensureInstance(F.texturedLine, m13).createMeshInfo({ ...S, offsetAlongLine: 0, shouldScaleDash: true, shouldSampleAlphaOnly: false, isSDF: true, sprite: { type: "sprite-rasterization-param", resource: { type: "dash", dashTemplate: K(r12, o14) }, overrides: [] } });
    p12.push(e14);
  }
  return null != e13.marker && p12.push(...w3(e13.marker, e13, i16)), p12;
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/LabelMatcherSchema.js
async function o9(e13, a10, o14) {
  const r12 = a10.labelsVisible && a10.labelingInfo || [], i16 = e5(a10), t11 = c(r12, i16);
  return { type: "label", classes: await Promise.all(t11.map((l11, s14) => n10(e13, l11, a10.labelsVisible, a10.labelingInfoSource, s14, i16, o14))) };
}
async function n10(l11, s14, o14, n14, r12, i16, t11) {
  const m13 = l(`${n14} ${r12}`), c9 = n14, p12 = await z3(s14, { schemaOptions: l11, uniforms: t11, layerId: c9, labelClassId: m13 });
  return { maxScale: s14.maxScale, minScale: s14.minScale, deconflictionEnabled: "none" !== s14.deconflictionStrategy && o14, expression: s14.labelExpressionInfo?.expression ?? s14.labelExpression, where: s14.where, meshes: p12, layerId: c9, labelClassId: m13, geometryType: i16 };
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/MatcherSchema.js
async function l9(e13, i16) {
  if (!i16) return { type: "simple", meshes: [] };
  switch (i16.type) {
    case "simple":
      return o10(e13, i16);
    case "dot-density":
      return r9(e13, i16);
    case "class-breaks":
      return u13(e13, i16);
    case "unique-value":
      return m10(e13, i16);
    case "dictionary":
      return c6(i16);
    case "heatmap":
      return p8(e13, i16);
    case "pie-chart":
      return f4(e13, i16);
  }
}
async function o10(i16, a10) {
  const n14 = a10.symbols, t11 = n14.length ? n14[0] : null, l11 = x2(a10);
  return { type: "simple", meshes: await z3(t11, { schemaOptions: i16, uniforms: l11 }) };
}
async function r9(i16, a10) {
  const n14 = x2(a10);
  return { type: "dot-density", meshes: await d6(a10, { schemaOptions: i16, uniforms: n14 }) };
}
async function u13(a10, n14) {
  const t11 = x2(n14), l11 = n14.backgroundFillSymbol, o14 = n14.normalizationType, r12 = "log" === o14 ? "esriNormalizeByLog" : "percent-of-total" === o14 ? "esriNormalizeByPercentOfTotal" : "field" === o14 ? "esriNormalizeByField" : null, u17 = n14.classBreakInfos.map(async (e13) => ({ meshes: await z3(e13.symbol, { path: `renderer-stop-${e13.minValue}-${e13.maxValue}`, schemaOptions: a10, uniforms: t11 }), min: e13.minValue, max: e13.maxValue })), m13 = (await Promise.all(u17)).sort((e13, i16) => e13.min - i16.min), c9 = await z3(l11, { schemaOptions: a10, uniforms: { ...b5, visualVariableSizeOutlineScaleStops: t11.visualVariableSizeOutlineScaleStops } }), p12 = await z3(n14.defaultSymbol, { schemaOptions: a10, uniforms: t11 });
  return { type: "interval", field: n14.field, expression: n14.valueExpression, backgroundFill: c9, defaultSymbol: p12, intervals: m13, normalizationField: n14.normalizationField, normalizationTotal: n14.normalizationTotal, normalizationType: r12, isMaxInclusive: n14.isMaxInclusive };
}
async function m10(a10, n14) {
  const t11 = [], l11 = x2(n14), o14 = await z3(n14.backgroundFillSymbol, { schemaOptions: a10, uniforms: { ...b5, visualVariableSizeOutlineScaleStops: l11.visualVariableSizeOutlineScaleStops } }), r12 = await z3(n14.defaultSymbol, { schemaOptions: a10, uniforms: l11 });
  for (const e13 of n14.uniqueValueInfos ?? []) {
    const i16 = await z3(e13.symbol, { path: `renderer-unique-value-${e13.value}`, schemaOptions: a10, uniforms: l11 });
    t11.push({ value: "" + e13.value, symbol: i16 });
  }
  return { type: "map", field: n14.field, expression: n14.valueExpression, field2: n14.field2, field3: n14.field3, fieldDelimiter: n14.fieldDelimiter, backgroundFill: o14, defaultSymbol: r12, map: t11 };
}
async function c6(i16) {
  const a10 = x2(i16), n14 = await i16.getDictionaryInfo(), s14 = i16.scaleExpression, t11 = null != s14 && "1" !== s14 ? { valueExpressionInfo: { type: "CIMExpressionInfo", expression: i16.scaleExpression, returnType: "Numeric" }, defaultValue: 1 } : void 0;
  return { type: "dictionary", dictionaryInfo: n14, userConfig: i16.config ?? {}, fieldMap: i16.fieldMap ?? {}, scaleExpression: t11, visualVariableUniforms: a10 };
}
async function p8(e13, i16) {
  return { type: "heatmap", meshes: await g3(i16, e13) };
}
async function f4(e13, i16) {
  return { type: "pie-chart", meshes: await M(i16, e13) };
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/SimpleProcessorSchema.js
async function l10(e13, r12) {
  const s14 = r12.renderer, n14 = x2(s14);
  return { symbology: await l9(e13, s14), labels: await o9(e13, r12, n14) };
}
async function o11(e13, r12, t11, i16) {
  const n14 = t11.featureReduction;
  if (n14) switch (n14.type) {
    case "binning":
      return f5(n14, e13, r12, t11, i16);
    case "cluster":
      return b7(n14, e13, r12, t11, i16);
  }
  if (t11.trackInfo?.enabled) return p9(t11.trackInfo, e13, r12, t11, i16);
  const a10 = y4(t11.orderBy, t11.renderer, t11.objectIdField), o14 = t6(t11.renderer, r12.filters), c9 = await l10(e13, t11), u17 = m11(c9.symbology);
  return { storage: o14, mesh: { properties: { sortKey: a10, timeZone: r12.timeZone, returnMeshObjectId: u17, displayRefreshVersion: i16, currentUser: r12.currentUser }, strategy: { type: "feature" }, factory: c9 }, expressionProperties: { timeExtent: r12.timeExtent?.toJSON() } };
}
function c7(e13, r12) {
  return e13.fields.map((e14) => ({ ...e14.toJSON(), type: u14(e14, r12) }));
}
function u14(e13, r12) {
  const { onStatisticExpression: t11, onStatisticField: i16, statisticType: s14 } = e13;
  switch (s14) {
    case "min":
    case "max":
    case "avg":
    case "avg_angle":
    case "sum":
    case "count":
      return "esriFieldTypeDouble";
    case "mode": {
      if (t11) {
        const { returnType: e15 } = t11;
        return e15 ? "string" === e15 ? "esriFieldTypeString" : "esriFieldTypeDouble" : "esriFieldTypeString";
      }
      const e14 = r12.find((e15) => e15.name === i16);
      return e14 ? e14.type : "esriFieldTypeString";
    }
  }
}
async function f5(r12, n14, l11, o14, u17) {
  const f8 = c7(r12, o14.fields), b8 = r12.renderer, p12 = await l9(n14, b8), y7 = t6(b8, [null, null]), d10 = x2(b8), g4 = await o9(n14, { geometryType: "polygon", labelingInfoSource: o14.labelingInfoSource + "-binning", labelingInfo: r12.labelingInfo, labelsVisible: r12.labelsVisible }, d10), v = m11(p12), h4 = "geohash" === r12.binType ? { type: "geohash", fixBinLevel: r12.fixedBinLevel ?? 3 } : { type: "grid", size: u3(r12.size), fixedBinLevel: r12.fixedBinLevel };
  return { storage: y7, mesh: { properties: { sortKey: null, timeZone: l11.timeZone, returnMeshObjectId: v, displayRefreshVersion: u17, currentUser: l11.currentUser }, strategy: { type: "binning", fields: f8, index: h4, featureFilter: l11.filters[0] }, factory: { labels: g4, symbology: p12 } }, expressionProperties: { timeExtent: l11.timeExtent?.toJSON() } };
}
async function b7(r12, n14, l11, o14, u17) {
  const f8 = c7(r12, o14.fields), b8 = { type: "cluster", feature: await l9(n14, r12.effectiveFeatureRenderer), cluster: await l9(n14, r12.effectiveClusterRenderer) }, p12 = x2(r12.effectiveFeatureRenderer), y7 = { type: "cluster", feature: await o9(n14, o14, p12), cluster: await o9(n14, { geometryType: "point", labelingInfoSource: o14.labelingInfoSource + "-clusters", labelingInfo: r12.labelingInfo, labelsVisible: r12.labelsVisible }, p12) }, d10 = t6(r12.effectiveFeatureRenderer, [null, null]), g4 = m11(b8);
  return { storage: d10, mesh: { properties: { sortKey: null, timeZone: l11.timeZone, displayRefreshVersion: u17, returnMeshObjectId: g4, currentUser: l11.currentUser }, strategy: { type: "cluster", fields: f8, featureFilter: l11.filters[0], clusterRadius: u3(r12.clusterRadius / 2) }, factory: { labels: y7, symbology: b8 } }, expressionProperties: { timeExtent: l11.timeExtent?.toJSON() } };
}
async function p9(e13, r12, s14, l11, o14) {
  const u17 = c7(e13, l11.fields), f8 = { type: "track", previousObservation: await l9(r12, e13.previousObservations.renderer), latestObservation: await l9(r12, e13.latestObservations.renderer), trackLine: await l9(r12, e13.trackLines.renderer) }, b8 = { type: "track", previousObservation: await o9(r12, { geometryType: l11.geometryType, labelingInfoSource: l11.labelingInfoSource + "-track-prev", labelingInfo: e13.previousObservations.labelingInfo, labelsVisible: e13.previousObservations.labelsVisible }, x2(e13.previousObservations.renderer)), latestObservation: await o9(r12, { geometryType: l11.geometryType, labelingInfoSource: l11.labelingInfoSource + "-track-latest", labelingInfo: e13.latestObservations.labelingInfo, labelsVisible: e13.latestObservations.labelsVisible }, x2(e13.latestObservations.renderer)), trackLine: await o9(r12, { geometryType: "polyline", labelingInfoSource: l11.labelingInfoSource + "-track-line", labelingInfo: e13.trackLines.labelingInfo, labelsVisible: e13.trackLines.labelsVisible }, x2(e13.trackLines.renderer)) }, p12 = s5(e13, [null, null]), y7 = m11(f8);
  return { storage: p12, mesh: { properties: { sortKey: null, timeZone: s14.timeZone, returnMeshObjectId: y7, displayRefreshVersion: o14, currentUser: s14.currentUser }, strategy: { type: "track", featureFilter: s14.filters[0], fields: u17, maxDisplayDuration: e13.maxDisplayDuration?.toMilliseconds() ?? 0, maxDisplayObservationsPerTrack: e13.maxDisplayObservationsPerTrack, showLatestObservation: e13.latestObservations.visible, showPreviousObservations: e13.previousObservations.visible, showTrackLine: e13.trackLines.visible, timeField: e13.timeField }, factory: { labels: b8, symbology: f8 } }, expressionProperties: { timeExtent: s14.timeExtent?.toJSON() } };
}
function y4(e13, t11, i16) {
  const s14 = null != t11 && "unique-value" === t11.type && t11.orderByClassesEnabled;
  if ("default" !== e13 || s14 || (e13 = [new n3({ field: i16, order: "descending" })]), "default" !== e13 && e13?.length) {
    e13.length;
    const r12 = e13[0], t12 = "ascending" === r12.order ? "asc" : "desc";
    return r12.field ? { field: r12.field, order: t12 } : r12.valueExpression ? { expression: r12.valueExpression, order: t12 } : null;
  }
  if (s14) {
    return { byRenderer: true, order: "asc" };
  }
  return null;
}
function d7(e13) {
  return 2 === e13.techniqueType;
}
function m11(e13) {
  if ("simple" === e13.type && e13.meshes.some(d7)) return true;
  if ("interval" === e13.type) {
    if (e13.intervals.some((e14) => e14.meshes.some(d7))) return true;
    if (e13.backgroundFill.some(d7)) return true;
  }
  if ("map" === e13.type) {
    if (e13.map.some((e14) => e14.symbol.some(d7))) return true;
    if (e13.backgroundFill.some(d7)) return true;
  }
  return false;
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/CatalogFootprintLayerAdapter.js
var p10 = class {
  constructor(e13) {
    this.layer = e13, this._cache = new s10();
  }
  getLabelingDeconflictionInfo(e13) {
    const r12 = this.layer, t11 = l8(r12);
    return [{ vvEvaluators: { 0: o7(r12.renderer) }, deconflictionEnabled: t11 }];
  }
  async createSourceSchema(e13, r12) {
    const t11 = this._createServiceInfo(e13);
    return e8(t11, null, { definitionExpression: this.layer.definitionExpression, queryScaleRanges: [], displayFilterEnabled: e13.displayFilterEnabled, displayFilterInfo: this.layer.displayFilterInfo, customParameters: this.layer.customParameters, gdbVersion: null, historicMoment: null, timeExtent: this.layer.timeExtent, apiKey: this.layer.apiKey, sourceRefreshVersion: r12, availableFields: e13.availableFields, cache: this._cache });
  }
  createProcessorSchema(e13, r12, t11) {
    const { fields: i16, geometryType: s14, orderBy: a10, objectIdField: o14, renderer: n14, labelingInfo: p12, labelsVisible: d10 } = this.layer, u17 = { featureReduction: null, labelingInfoSource: this.layer.id, fields: i16.map((e14) => e14.toJSON()), geometryType: s14, labelingInfo: p12, labelsVisible: d10, objectIdField: o14, orderBy: a10 ?? "default", renderer: n14?.clone() };
    return o11(e13, r12, u17, t11);
  }
  get hasRequiredSupport() {
    return m7(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  getUpdateHashProperties(e13) {
    return [() => this.layer.apiKey, () => this.layer.customParameters, () => this.layer.definitionExpression, () => this.layer.outFields, () => this.layer.renderer, () => this.layer.labelsVisible ? this.layer.labelingInfo : null, () => this.layer.orderBy];
  }
  setGraphicOrigin(e13) {
    e13.origin = this.layer.graphicOrigin;
  }
  _createServiceInfo(i16) {
    const s14 = this.layer, { capabilities: a10, editingInfo: o14, objectIdField: l11, globalIdField: n14, datesInUnknownTimezone: p12, dateFieldsTimeZone: d10, orderBy: u17, parsedUrl: c9 } = s14, y7 = s14.fieldsIndex.toJSON(), m13 = e5(s14), f8 = s14.timeInfo?.toJSON(), h4 = s14.spatialReference.toJSON(), g4 = a(c9);
    let b8 = l11;
    if (u17?.length) {
      const e13 = !u17[0].valueExpression && u17[0].field;
      e13 && (b8 = e13);
    }
    const F3 = g(g4.path), I2 = i16.spatialReference.toJSON();
    return { type: "feature-service", source: g4, isSourceHosted: F3, orderByFields: b8, outSpatialReference: I2, metadata: { timeReferenceUnknownClient: p12, dateFieldsTimeZone: d10, globalIdField: n14, fieldsIndex: y7, geometryType: m13, featureIdInfo: { type: "object-id", fieldName: l11 }, timeInfo: f8, spatialReference: h4, outSpatialReference: I2, subtypeField: null, subtypes: null, typeIdField: null, types: null }, queryMetadata: { maxRecordCount: a10.query.maxRecordCount, supportsCompactGeometry: a10.query.supportsCompactGeometry, supportsDefaultSpatialReference: a10.query.supportsDefaultSpatialReference, supportsFormatPBF: a10.query.supportsFormatPBF, supportsMaxRecordCountFactor: a10.query.supportsMaxRecordCountFactor, supportsQuantization: a10.query.supportsQuantization, supportsCentroidOnDegeneratedQuantizedGeometry: a10.query.supportsCentroidOnDegeneratedQuantizedGeometry, supportsDegeneratedQuantizedGeometry: a10.query.supportsDegeneratedQuantizedGeometry, lastEditDate: o14?.lastEditDate?.getTime() } };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/featureServiceUtils.js
function e9(e13) {
  const { objectIdField: i16, uniqueIdFields: t11 } = e13;
  return t11?.length ? t11.length >= 2 ? { type: "unique-id-composite", fieldNames: t11 } : { type: "unique-id-simple", fieldName: t11[0] } : { type: "object-id", fieldName: i16 };
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/floorFilterUtils.js
function o12(e13, l11) {
  return null != e13.floorInfo && (e13.floorInfo.viewAllLevelIds.length > 0 || l11.floors.length > 0);
}
function r10(e13, o14, r12) {
  const t11 = n11(e13, o14?.where, r12);
  return t11 ? (o14 ??= new d2(), o14.where = t11, o14) : o14;
}
function n11(l11, o14, r12) {
  if (null == l11.floorInfo || !r12.floors?.length) return o14;
  let n14 = r12.floors;
  const { floorField: t11, viewAllLevelIds: f8 } = l11.floorInfo;
  f8.length && (n14 = f8);
  const s14 = n14.filter((e13) => "" !== e13).map((e13) => "'" + e13 + "'");
  if (s14.push("''"), o14?.includes(t11)) {
    let e13 = new RegExp("AND \\(" + t11 + ".*NULL\\)", "g");
    o14 = o14.replace(e13, ""), e13 = new RegExp("\\(" + t11 + ".*NULL\\)", "g"), o14 = (o14 = o14.replace(e13, "")).replaceAll(/\s+/g, " ").trim();
  }
  let i16 = "(" + t11 + " IN ({ids}) OR " + t11 + " IS NULL)";
  return i16 = i16.replace("{ids}", s14.join(", ")), l3(o14, i16);
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/FeatureLayerAdapter.js
var f6 = class {
  constructor(e13) {
    this.layer = e13, this._cache = new s10();
  }
  getLabelingDeconflictionInfo(e13) {
    const r12 = this.layer, t11 = r7(r12, e13) ?? l8(r12), s14 = e6(r12, e13), a10 = [...r12.labelingInfo || [], ...s14?.labelingInfo || []];
    return [{ vvEvaluators: { 0: o7(r12.renderer) }, deconflictionEnabled: t11, labelingInfo: a10 }];
  }
  async createSourceSchema(e13, t11) {
    const i16 = this._createServiceInfo(e13), s14 = null != this.layer.editingInfo?.lastEditDate, a10 = this.layer.refreshInterval > 0, o14 = !s14 && a10, l11 = r8(i16.isSourceHosted, o14, this.layer.capabilities, i16.metadata.geometryType, e13.extent, this.layer.fullExtent), n14 = null != this.layer.subtypeCode ? `${this.layer.subtypeField} = ${this.layer.subtypeCode}` : null, y7 = l3(this.layer.definitionExpression, n14);
    return e8(i16, l11, { definitionExpression: y7, queryScaleRanges: [], displayFilterEnabled: e13.displayFilterEnabled, displayFilterInfo: this.layer.displayFilterInfo, customParameters: this.layer.customParameters, gdbVersion: this.layer.gdbVersion, historicMoment: this.layer.historicMoment, timeExtent: this.layer.timeExtent, apiKey: this.layer.apiKey, sourceRefreshVersion: t11, availableFields: e13.availableFields, cache: this._cache });
  }
  createProcessorSchema(e13, r12, t11) {
    const { fields: s14, renderer: a10, geometryType: o14, labelingInfo: l11, labelsVisible: n14, orderBy: y7, objectIdField: p12, trackInfo: d10 } = this.layer, c9 = { fields: s14.map((e14) => e14.toJSON()), renderer: a10?.clone(), labelingInfoSource: this.layer.id, featureReduction: e6(this.layer, r12), geometryType: o14, labelingInfo: l11, labelsVisible: n14, objectIdField: p12, orderBy: y7 ?? "default", trackInfo: d10 };
    return o11(e13, r12, c9, t11);
  }
  get hasRequiredSupport() {
    return m7(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  addFilters(e13, r12) {
    return r10(this.layer, e13, r12);
  }
  getUpdateHashProperties(e13) {
    return this.layer.destroyed ? [] : [() => this.layer.apiKey, () => this.layer.customParameters, () => this.layer.definitionExpression, () => e6(this.layer, e13), () => o12(this.layer, e13) ? e13.floors : null, () => this.layer.gdbVersion, () => this.layer.historicMoment, () => this.layer.labelsVisible ? this.layer.labelingInfo : null, () => this.layer.orderBy, () => this.layer.outFields, () => this.layer.renderer, () => this.layer.subtypeCode, () => this.layer.trackInfo];
  }
  setGraphicOrigin(e13) {
    e13.origin = this.layer.graphicOrigin;
  }
  setAggregateGraphicOrigin(e13) {
    e13.origin = this.layer.aggregateGraphicOrigin;
  }
  setTrackGraphicOrigin(e13) {
    e13.origin = this.layer.trackGraphicOrigin;
  }
  _createServiceInfo(r12) {
    const i16 = this.layer, { capabilities: a10, editingInfo: o14, typeIdField: n14, globalIdField: y7, datesInUnknownTimezone: p12, dateFieldsTimeZone: d10, orderBy: c9, subtypeField: u17 } = i16, m13 = i16.fieldsIndex.toJSON(), h4 = e5(i16), f8 = i16.timeInfo?.toJSON(), g4 = i16.spatialReference.toJSON(), b8 = i16.types?.map((e13) => e13.toJSON()), I2 = a(this.layer.parsedUrl);
    this.layer.dynamicDataSource && (I2.query = { layer: JSON.stringify({ source: this.layer.dynamicDataSource }) });
    let S = this.layer.objectIdField;
    if (c9?.length) {
      const e13 = !c9[0].valueExpression && c9[0].field;
      e13 && (S = e13);
    }
    const F3 = g(I2.path), O3 = r12.spatialReference.toJSON();
    return { type: "feature-service", source: I2, isSourceHosted: F3, orderByFields: S, outSpatialReference: O3, metadata: { typeIdField: n14 ?? void 0, types: b8, timeReferenceUnknownClient: p12, dateFieldsTimeZone: d10, subtypeField: u17, globalIdField: y7, fieldsIndex: m13, geometryType: h4, featureIdInfo: e9(i16), timeInfo: f8, spatialReference: g4, outSpatialReference: O3, subtypes: this.layer.subtypes?.map((e13) => e13.toJSON()) }, queryMetadata: { maxRecordCount: a10.query.maxRecordCount, supportsCompactGeometry: a10.query.supportsCompactGeometry, supportsDefaultSpatialReference: a10.query.supportsDefaultSpatialReference, supportsFormatPBF: a10.query.supportsFormatPBF, supportsMaxRecordCountFactor: a10.query.supportsMaxRecordCountFactor, supportsQuantization: a10.query.supportsQuantization, supportsCentroidOnDegeneratedQuantizedGeometry: a10.query.supportsCentroidOnDegeneratedQuantizedGeometry, supportsDegeneratedQuantizedGeometry: a10.query.supportsDegeneratedQuantizedGeometry, lastEditDate: o14?.lastEditDate?.getTime() } };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/InMemoryLayerAdapter.js
function c8(r12) {
  if (!("openPorts" in r12)) throw new s("featurelayer:source-not-supported", "source is not supported");
}
var p11 = class {
  constructor(e13) {
    this.layer = e13, this._cache = new s10();
  }
  openMessagePorts() {
    return c8(this.layer.source), this.layer.source.openPorts();
  }
  getLabelingDeconflictionInfo(e13) {
    const t11 = this.layer, n14 = r7(t11, e13) ?? l8(t11), s14 = e6(t11, e13), l11 = [...t11.labelingInfo || [], ...s14?.labelingInfo || []];
    return [{ vvEvaluators: { 0: o7(t11.renderer) }, deconflictionEnabled: n14, labelingInfo: l11 }];
  }
  async createSourceSchema(e13, r12) {
    const t11 = this._createServiceInfo(e13);
    return e8(t11, null, { definitionExpression: this.layer.definitionExpression, queryScaleRanges: [], displayFilterEnabled: e13.displayFilterEnabled, displayFilterInfo: this.layer.displayFilterInfo, customParameters: this.layer.customParameters, gdbVersion: null, historicMoment: null, timeExtent: this.layer.timeExtent, apiKey: null, sourceRefreshVersion: r12, availableFields: e13.availableFields, cache: this._cache });
  }
  createProcessorSchema(e13, t11, i16) {
    const { fields: o14, renderer: a10, geometryType: n14, labelingInfo: s14, labelsVisible: u17, orderBy: c9, objectIdField: p12 } = this.layer, d10 = "trackInfo" in this.layer ? this.layer.trackInfo : null, y7 = { fields: o14.map((e14) => e14.toJSON()), renderer: a10?.clone(), labelingInfoSource: this.layer.id, featureReduction: e6(this.layer, t11), geometryType: n14, labelingInfo: s14, labelsVisible: u17, objectIdField: p12, orderBy: c9 ?? "default", trackInfo: d10 };
    return o11(e13, t11, y7, i16);
  }
  get hasRequiredSupport() {
    return m7(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  getUpdateHashProperties(e13) {
    return [() => this.layer.definitionExpression, () => this.layer.displayFilterInfo, () => this.layer.orderBy, () => "outFields" in this.layer ? this.layer.outFields : null, () => this.layer.renderer, () => this.layer.labelsVisible ? this.layer.labelingInfo : null, () => e6(this.layer, e13), () => "trackInfo" in this.layer ? this.layer.trackInfo : null];
  }
  setGraphicOrigin(e13) {
    e13.origin = this.layer.graphicOrigin;
  }
  setAggregateGraphicOrigin(e13) {
    e13.origin = this.layer.aggregateGraphicOrigin;
  }
  setTrackGraphicOrigin(e13) {
    e13.origin = this.layer.trackGraphicOrigin;
  }
  _createServiceInfo(e13) {
    const r12 = this.layer, { capabilities: i16, objectIdField: o14 } = r12, a10 = r12.fieldsIndex.toJSON(), n14 = e5(r12), s14 = r12.timeInfo?.toJSON(), l11 = r12.spatialReference.toJSON();
    c8(r12.source);
    const u17 = o14, p12 = e13.spatialReference.toJSON();
    return { type: "memory", orderByFields: u17, outSpatialReference: p12, metadata: { fieldsIndex: a10, geometryType: n14, featureIdInfo: { type: "object-id", fieldName: r12.objectIdField }, timeInfo: s14, spatialReference: l11, outSpatialReference: p12, subtypes: null, subtypeField: null, globalIdField: null, typeIdField: null, types: null, timeReferenceUnknownClient: "datesInUnknownTimezone" in r12 ? r12.datesInUnknownTimezone : null, dateFieldsTimeZone: "dateFieldsTimeZone" in r12 ? r12.dateFieldsTimeZone : null }, queryMetadata: { maxRecordCount: i16.query.maxRecordCount, supportsCompactGeometry: i16.query.supportsCompactGeometry, supportsDefaultSpatialReference: i16.query.supportsDefaultSpatialReference, supportsFormatPBF: i16.query.supportsFormatPBF, supportsMaxRecordCountFactor: i16.query.supportsMaxRecordCountFactor, supportsQuantization: i16.query.supportsQuantization, supportsCentroidOnDegeneratedQuantizedGeometry: i16.query.supportsCentroidOnDegeneratedQuantizedGeometry, supportsDegeneratedQuantizedGeometry: i16.query.supportsDegeneratedQuantizedGeometry, lastEditDate: null } };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/KnowledgeGraphSublayerAdapter.js
var d8 = class {
  constructor(e13) {
    this.layer = e13, this._cache = new s10();
  }
  getLabelingDeconflictionInfo(e13) {
    const r12 = this.layer, t11 = r7(r12, e13) ?? l8(r12);
    return [{ vvEvaluators: { 0: o7(r12.renderer) }, deconflictionEnabled: t11 }];
  }
  async createSourceSchema(e13, r12) {
    const t11 = this._createServiceInfo(e13);
    return e8(t11, null, { definitionExpression: this.layer.definitionExpression, queryScaleRanges: [], displayFilterEnabled: e13.displayFilterEnabled, displayFilterInfo: this.layer.displayFilterInfo, customParameters: null, gdbVersion: null, historicMoment: null, timeExtent: this.layer.timeExtent, apiKey: null, sourceRefreshVersion: r12, availableFields: e13.availableFields, cache: this._cache });
  }
  createProcessorSchema(e13, r12, t11) {
    const { fields: a10, renderer: s14, geometryType: o14, labelingInfo: n14, labelsVisible: l11, objectIdField: p12 } = this.layer, c9 = { fields: a10.map((e14) => e14.toJSON()), renderer: s14?.clone(), labelingInfoSource: this.layer.id, featureReduction: e6(this.layer, r12), geometryType: o14, labelingInfo: n14, labelsVisible: l11, objectIdField: p12, orderBy: "default" };
    return o11(e13, r12, c9, t11);
  }
  get hasRequiredSupport() {
    return m7(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  getUpdateHashProperties(e13) {
    return [() => this.layer.definitionExpression, () => this.layer.renderer, () => this.layer.labelsVisible ? this.layer.labelingInfo : null, () => e6(this.layer, e13), () => y5(this.layer)];
  }
  hasFilters(e13) {
    return y5(this.layer);
  }
  addFilters(i16, a10) {
    if (y5(this.layer)) {
      const a11 = l3(i16?.where, `${E}=1`);
      if (!a11) return i16;
      i16 ??= new d2(), i16.where = a11;
    }
    return i16;
  }
  setGraphicOrigin(e13) {
    e13.origin = this.layer.graphicOrigin;
  }
  setAggregateGraphicOrigin(e13) {
    e13.origin = this.layer.aggregateGraphicOrigin;
  }
  openMessagePorts() {
    return this.layer.source.openPorts();
  }
  _createServiceInfo(e13) {
    const r12 = this.layer, { capabilities: t11, objectIdField: i16 } = r12, s14 = r12.fieldsIndex.toJSON(), o14 = e5(r12), n14 = r12.spatialReference.toJSON(), l11 = i16, p12 = e13.spatialReference.toJSON();
    return { type: "memory", orderByFields: l11, outSpatialReference: p12, metadata: { fieldsIndex: s14, geometryType: o14, featureIdInfo: { type: "object-id", fieldName: r12.objectIdField }, spatialReference: n14, outSpatialReference: p12, globalIdField: null, subtypeField: null, subtypes: null, timeInfo: r12.timeInfo?.toJSON(), timeReferenceUnknownClient: null, dateFieldsTimeZone: null, typeIdField: null, types: null }, queryMetadata: { maxRecordCount: t11.query.maxRecordCount, supportsCompactGeometry: t11.query.supportsCompactGeometry, supportsDefaultSpatialReference: t11.query.supportsDefaultSpatialReference, supportsFormatPBF: t11.query.supportsFormatPBF, supportsMaxRecordCountFactor: t11.query.supportsMaxRecordCountFactor, supportsQuantization: t11.query.supportsQuantization, supportsCentroidOnDegeneratedQuantizedGeometry: t11.query.supportsCentroidOnDegeneratedQuantizedGeometry, supportsDegeneratedQuantizedGeometry: t11.query.supportsDegeneratedQuantizedGeometry, lastEditDate: null } };
  }
};
function y5(e13) {
  return "link-chart" === e13.parentCompositeLayer.type && "hidden" === e13.parentCompositeLayer.linkChart?.linkChartProperties.nonspatialDataDisplay?.mode;
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/OGCFeatureLayerAdapter.js
var u15 = class {
  constructor(e13) {
    this.layer = e13, this._cache = new s10();
  }
  getLabelingDeconflictionInfo(e13) {
    const r12 = this.layer, t11 = r7(r12, e13) ?? l8(r12);
    return [{ vvEvaluators: { 0: o7(r12.renderer) }, deconflictionEnabled: t11, labelingInfo: r12.labelingInfo }];
  }
  async createSourceSchema(e13, r12) {
    const t11 = this._createServiceInfo(e13);
    return e8(t11, null, { definitionExpression: null, queryScaleRanges: [], displayFilterEnabled: e13.displayFilterEnabled, displayFilterInfo: null, customParameters: this.layer.customParameters, gdbVersion: null, historicMoment: null, timeExtent: this.layer.timeExtent, apiKey: this.layer.apiKey, sourceRefreshVersion: r12, availableFields: e13.availableFields, cache: this._cache });
  }
  createProcessorSchema(e13, t11, i16) {
    const { fields: a10, renderer: o14, geometryType: s14, labelingInfo: l11, labelsVisible: c9, orderBy: u17, objectIdField: p12 } = this.layer, d10 = { fields: a10.map((e14) => e14.toJSON()), renderer: o14?.clone(), labelingInfoSource: this.layer.id, featureReduction: e6(this.layer, t11), geometryType: s14, labelingInfo: l11, labelsVisible: c9, objectIdField: p12, orderBy: u17 ?? "default" };
    return o11(e13, t11, d10, i16);
  }
  get hasRequiredSupport() {
    return m7(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  getUpdateHashProperties(e13) {
    return [() => this.layer.apiKey, () => this.layer.customParameters, () => e6(this.layer, e13), () => this.layer.labelsVisible ? this.layer.labelingInfo : null, () => this.layer.orderBy, () => this.layer.renderer];
  }
  setGraphicOrigin(e13) {
    e13.origin = this.layer.graphicOrigin;
  }
  setAggregateGraphicOrigin(e13) {
    e13.origin = this.layer.aggregateGraphicOrigin;
  }
  setTrackGraphicOrigin(e13) {
    e13.origin = this.layer.trackGraphicOrigin;
  }
  _createServiceInfo(r12) {
    const i16 = this.layer, { capabilities: a10 } = i16, o14 = i16.fieldsIndex.toJSON(), s14 = e5(i16), l11 = i16.timeInfo?.toJSON(), n14 = i16.spatialReference.toJSON(), c9 = i16.source.getSource(), u17 = this.layer.objectIdField, p12 = a(a10);
    p12.query.maxRecordCount = c9.maxRecordCount;
    const d10 = r12.spatialReference.toJSON();
    return { type: "ogc", source: c9, orderByFields: u17, outSpatialReference: d10, metadata: { fieldsIndex: o14, geometryType: s14, featureIdInfo: { type: "object-id", fieldName: i16.objectIdField }, timeInfo: l11, spatialReference: n14, outSpatialReference: d10, globalIdField: null, subtypeField: null, subtypes: null, timeReferenceUnknownClient: null, dateFieldsTimeZone: null, typeIdField: null, types: null }, queryMetadata: { maxRecordCount: p12.query.maxRecordCount, supportsCompactGeometry: p12.query.supportsCompactGeometry, supportsDefaultSpatialReference: p12.query.supportsDefaultSpatialReference, supportsFormatPBF: p12.query.supportsFormatPBF, supportsMaxRecordCountFactor: p12.query.supportsMaxRecordCountFactor, supportsQuantization: p12.query.supportsQuantization, supportsCentroidOnDegeneratedQuantizedGeometry: p12.query.supportsCentroidOnDegeneratedQuantizedGeometry, supportsDegeneratedQuantizedGeometry: p12.query.supportsDegeneratedQuantizedGeometry, lastEditDate: null } };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/OrientedImageryLayerAdapter.js
var m12 = class {
  constructor(e13) {
    this.layer = e13, this._cache = new s10();
  }
  getLabelingDeconflictionInfo(e13) {
    const r12 = this.layer, t11 = r7(r12, e13) ?? l8(r12);
    return [{ vvEvaluators: { 0: o7(r12.renderer) }, deconflictionEnabled: t11 }];
  }
  async createSourceSchema(e13, r12) {
    const t11 = this._createServiceInfo(e13), i16 = null != this.layer.editingInfo?.lastEditDate, s14 = this.layer.refreshInterval > 0, a10 = !i16 && s14, o14 = r8(t11.isSourceHosted, a10, this.layer.capabilities, t11.metadata.geometryType, e13.extent, this.layer.fullExtent);
    return e8(t11, o14, { definitionExpression: this.layer.definitionExpression, queryScaleRanges: [], displayFilterEnabled: e13.displayFilterEnabled, displayFilterInfo: this.layer.displayFilterInfo, customParameters: this.layer.customParameters, gdbVersion: this.layer.gdbVersion, historicMoment: this.layer.historicMoment, timeExtent: this.layer.timeExtent, apiKey: this.layer.apiKey, sourceRefreshVersion: r12, availableFields: e13.availableFields, cache: this._cache });
  }
  createProcessorSchema(e13, r12, i16) {
    const { fields: s14, renderer: a10, geometryType: o14, labelingInfo: l11, labelsVisible: n14, orderBy: d10, objectIdField: p12 } = this.layer, c9 = { fields: s14.map((e14) => e14.toJSON()), renderer: a10?.clone(), labelingInfoSource: this.layer.id, featureReduction: e6(this.layer, r12), geometryType: o14, labelingInfo: l11, labelsVisible: n14, objectIdField: p12, orderBy: d10 ?? "default" };
    return o11(e13, r12, c9, i16);
  }
  get hasRequiredSupport() {
    return m7(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  addFilters(e13, r12) {
    return r10(this.layer, e13, r12);
  }
  getUpdateHashProperties(e13) {
    return [() => this.layer.outFields, () => this.layer.orderBy, () => this.layer.definitionExpression, () => this.layer.renderer, () => this.layer.labelsVisible ? this.layer.labelingInfo : null, () => e6(this.layer, e13), () => this.layer.customParameters, () => o12(this.layer, e13) ? e13.floors : null];
  }
  setGraphicOrigin(e13) {
    e13.origin = this.layer.graphicOrigin;
  }
  setAggregateGraphicOrigin(e13) {
    e13.origin = this.layer.aggregateGraphicOrigin;
  }
  setTrackGraphicOrigin(e13) {
    e13.origin = this.layer.trackGraphicOrigin;
  }
  _createServiceInfo(t11) {
    const i16 = this.layer, { capabilities: s14, globalIdField: o14, orderBy: l11 } = i16, n14 = i16.fieldsIndex.toJSON(), d10 = e5(i16), p12 = i16.timeInfo?.toJSON(), c9 = i16.spatialReference.toJSON(), u17 = a(this.layer.parsedUrl);
    let y7 = this.layer.objectIdField;
    if (l11?.length) {
      const e13 = !l11[0].valueExpression && l11[0].field;
      e13 && (y7 = e13);
    }
    const m13 = g(u17.path), h4 = t11.spatialReference.toJSON();
    return { type: "feature-service", source: u17, isSourceHosted: m13, orderByFields: y7, outSpatialReference: h4, metadata: { globalIdField: o14, fieldsIndex: n14, geometryType: d10, featureIdInfo: { type: "object-id", fieldName: i16.objectIdField }, timeInfo: p12, spatialReference: c9, outSpatialReference: h4, timeReferenceUnknownClient: i16.datesInUnknownTimezone, dateFieldsTimeZone: i16.dateFieldsTimeZone, subtypeField: null, subtypes: null, typeIdField: null, types: null }, queryMetadata: { maxRecordCount: s14.query.maxRecordCount, supportsCompactGeometry: s14.query.supportsCompactGeometry, supportsDefaultSpatialReference: s14.query.supportsDefaultSpatialReference, supportsFormatPBF: s14.query.supportsFormatPBF, supportsMaxRecordCountFactor: s14.query.supportsMaxRecordCountFactor, supportsQuantization: s14.query.supportsQuantization, supportsCentroidOnDegeneratedQuantizedGeometry: s14.query.supportsCentroidOnDegeneratedQuantizedGeometry, supportsDegeneratedQuantizedGeometry: s14.query.supportsDegeneratedQuantizedGeometry, lastEditDate: null } };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/ParquetLayerAdapter.js
var y6 = class {
  constructor(e13) {
    this.layer = e13;
  }
  get hasRequiredSupport() {
    return m7(this.layer.renderer);
  }
  get timeOptions() {
    return null;
  }
  getLabelingDeconflictionInfo(e13) {
    const r12 = this.layer, i16 = r7(r12, e13) ?? l8(r12), n14 = e6(r12, e13), o14 = [...r12.labelingInfo || [], ...n14?.labelingInfo || []];
    return [{ vvEvaluators: { 0: o7(r12.renderer) }, deconflictionEnabled: i16, labelingInfo: o14 }];
  }
  getUpdateHashProperties(e13) {
    return [() => this.layer.urls.join(","), () => this.layer.outFields, () => this.layer.labelsVisible ? this.layer.labelingInfo : null, () => e6(this.layer, e13), () => this.layer.customParameters, () => this.layer.orderBy, () => this.layer.renderer, () => this.layer.popupTemplate];
  }
  async createSourceSchema(e13, r12) {
    const t11 = this._createServiceInfo(e13), i16 = e13.availableFields.includes("*") ? this.layer.fields.map((e14) => e14.name) : e13.availableFields, l11 = { partial: { urls: [...this.layer.urls.items], availableFields: i16 }, full: { definitionExpression: null, sourceRefreshVersion: r12, customParameters: this.layer.customParameters ?? null } };
    return { type: "parquet", service: t11, strategy: this._createStrategy(t11, l11) };
  }
  _createStrategy(e13, r12) {
    return e13.geometryInfo.displayOptimization ? { type: "xz", ...r12 } : { type: "snapshot", ...r12 };
  }
  createProcessorSchema(e13, r12, i16) {
    const l11 = { fields: this.layer.fields.map((e14) => e14.toJSON()), renderer: this.layer.renderer?.clone(), labelingInfoSource: this.layer.id, featureReduction: e6(this.layer, r12), geometryType: this.layer.geometryType, labelingInfo: this.layer.labelingInfo, labelsVisible: this.layer.labelsVisible, objectIdField: this.layer.objectIdField, orderBy: this.layer.orderBy };
    return o11(e13, r12, l11, i16);
  }
  setGraphicOrigin(e13) {
    e13.origin = this.layer.graphicOrigin;
  }
  setAggregateGraphicOrigin(e13) {
    e13.origin = this.layer.aggregateGraphicOrigin;
  }
  _createServiceInfo(t11) {
    const l11 = e5(this.layer), a10 = t11.spatialReference.toJSON(), s14 = this.layer.encoding;
    if (null == s14) throw new s("parquet-layer:unsupported", "creating a parquet layer view requires an encoding", { layer: this.layer });
    return { type: "parquet", outSpatialReference: a10, geometryInfo: { geometryType: p4(this.layer.geometryType), spatialReference: this.layer.spatialReference.toJSON(), encoding: s14.toJSON(), displayOptimization: this.layer.displayOptimization }, metadata: { spatialReference: this.layer.spatialReference.toJSON(), outSpatialReference: a10, fieldsIndex: this.layer.fieldsIndex.toJSON(), featureIdInfo: { type: "object-id", fieldName: this.layer.objectIdField }, geometryType: l11, types: null, subtypes: null, timeInfo: null, typeIdField: null, subtypeField: null, globalIdField: null, timeReferenceUnknownClient: null, dateFieldsTimeZone: null } };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/StreamLayerAdapter.js
var s12 = class {
  constructor(e13) {
    this.layer = e13;
  }
  getLabelingDeconflictionInfo(r12) {
    const a10 = this.layer, n14 = r7(a10, r12) ?? l8(a10), s14 = e6(a10, r12), o14 = [...a10.labelingInfo || [], ...s14?.labelingInfo || []];
    return [{ vvEvaluators: { 0: o7(a10.renderer) }, deconflictionEnabled: n14, labelingInfo: o14 }];
  }
  async createSourceSchema(e13, r12) {
    return { type: "stream", service: this._createServiceInfo(e13), strategy: { type: "stream", partial: { sourceRefreshVersion: r12 }, full: { availableFields: e13.availableFields, geometryDefinition: this.layer.geometryDefinition?.toJSON(), definitionExpression: this.layer.definitionExpression, customParameters: this.layer.customParameters, maxReconnectionAttempts: this.layer.maxReconnectionAttempts, maxReconnectionInterval: this.layer.maxReconnectionInterval, purgeOptions: this.layer.purgeOptions.toJSON() } } };
  }
  createProcessorSchema(r12, t11, i16) {
    const { fields: l11, renderer: n14, geometryType: s14, labelingInfo: o14, labelsVisible: c9, objectIdField: y7, trackInfo: p12 } = this.layer, f8 = { fields: l11.map((e13) => e13.toJSON()), renderer: n14?.clone(), labelingInfoSource: this.layer.id, featureReduction: e6(this.layer, t11), geometryType: s14, labelingInfo: o14, labelsVisible: c9, objectIdField: y7, orderBy: "default", trackInfo: p12 };
    return o11(r12, t11, f8, i16);
  }
  get hasRequiredSupport() {
    return m7(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  getUpdateHashProperties(r12) {
    return [() => this.layer.definitionExpression, () => this.layer.renderer, () => this.layer.labelsVisible ? this.layer.labelingInfo : null, () => e6(this.layer, r12), () => this.layer.customParameters, () => this.layer.geometryDefinition, () => this.layer.definitionExpression, () => this.layer.trackInfo];
  }
  setGraphicOrigin(e13) {
    e13.origin = this.layer.graphicOrigin;
  }
  setAggregateGraphicOrigin(e13) {
    e13.origin = this.layer.aggregateGraphicOrigin;
  }
  setTrackGraphicOrigin(e13) {
    e13.origin = this.layer.trackGraphicOrigin;
  }
  _createServiceInfo(e13) {
    const t11 = e5(this.layer), i16 = this.layer.timeInfo?.toJSON() || null, l11 = this.layer.spatialReference ? this.layer.spatialReference.toJSON() : null, a10 = e13.spatialReference.toJSON();
    return { type: "stream", source: this.layer.parsedUrl, outSpatialReference: a10, metadata: { fieldsIndex: this.layer.fieldsIndex.toJSON(), geometryType: t11, featureIdInfo: { type: "object-id", fieldName: this.layer.objectIdField }, timeInfo: i16, timeReferenceUnknownClient: null, dateFieldsTimeZone: null, spatialReference: l11, outSpatialReference: a10, subtypeField: null, subtypes: null, globalIdField: null, typeIdField: null, types: null } };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/SubtypeProcessorSchema.js
async function a9(e13, { subtypeField: t11, sublayers: s14 }) {
  const i16 = await Promise.all(s14.map(({ renderer: t12 }) => l9(e13, t12)));
  return { type: "subtype", subtypeField: t11, renderers: s14.reduce((e14, { subtypeCode: r12 }, t12) => ({ ...e14, [r12]: i16[t12] }), {}) };
}
function n12(e13, r12) {
  const s14 = t4();
  return { type: "multi", filters: e13.filters, capabilities: { maxTextureSize: s14.maxTextureSize }, keyField: r12.subtypeField, target: "feature", bindings: r12.sublayers.reduce((e14, { renderer: r13, subtypeCode: s15 }) => {
    const i16 = p7(r13);
    return { ...e14, [s15]: i16 };
  }, {}) };
}
async function o13(r12, { subtypeField: t11, sublayers: i16, labelingInfoSource: a10 }) {
  const n14 = await Promise.all(i16.map((t12) => {
    const i17 = x2(t12.renderer), n15 = { ...t12, geometryType: t12.geometryType ?? null, labelingInfoSource: a10 };
    return o9(r12, n15, i17);
  }));
  return { type: "subtype", subtypeField: t11, renderers: i16.reduce((e13, { subtypeCode: r13 }, t12) => ({ ...e13, [r13]: n14[t12] }), {}) };
}
async function u16(e13, r12, t11, s14) {
  return { storage: n12(r12, t11), mesh: { properties: { timeZone: r12.timeZone, displayRefreshVersion: s14, returnMeshObjectId: false, sortKey: null, currentUser: r12.currentUser }, strategy: { type: "feature" }, factory: { symbology: await a9(e13, t11), labels: await o13(e13, t11) } }, expressionProperties: { timeExtent: r12.timeExtent?.toJSON() } };
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/SubtypeGroupLayerAdapter.js
var d9 = class {
  constructor(e13) {
    this.layer = e13, this._cache = new s10();
  }
  getLabelingDeconflictionInfo(e13) {
    const t11 = this.layer;
    return [{ vvEvaluators: {}, deconflictionEnabled: t11.sublayers.some((e14) => l8(e14)), labelingInfo: t11.sublayers.toArray().filter((e14) => !!e14.labelingInfo).flatMap((e14) => e14.labelingInfo) }];
  }
  async createSourceSchema(e13, t11) {
    const { definitionExpression: r12, customParameters: a10, gdbVersion: i16, historicMoment: s14, timeExtent: l11, apiKey: o14, displayFilterInfo: n14 } = this.layer, u17 = this._createServiceInfo(e13), c9 = null != this.layer.editingInfo?.lastEditDate, m13 = this.layer.refreshInterval > 0, d10 = !c9 && m13, f8 = r8(u17.isSourceHosted, d10, this.layer.capabilities, u17.metadata.geometryType, e13.extent, this.layer.fullExtent);
    return e8(u17, f8, { definitionExpression: r12, queryScaleRanges: this.layer.sublayers.items.map((e14) => ({ subtypeCode: e14.subtypeCode, minScale: e14.minScale, maxScale: e14.maxScale })), displayFilterEnabled: e13.displayFilterEnabled, displayFilterInfo: n14, customParameters: a10, gdbVersion: i16, historicMoment: s14, timeExtent: l11, apiKey: o14, sourceRefreshVersion: t11, availableFields: e13.availableFields, cache: this._cache });
  }
  createProcessorSchema(e13, t11, r12) {
    const a10 = { labelingInfoSource: this.layer.id, subtypeField: this.layer.subtypeField, sublayers: Array.from(this.layer.sublayers, (e14, t12) => ({ featureReduction: null, geometryType: this.layer.geometryType, labelingInfoSource: this.layer.id + `-${t12}`, labelingInfo: e14.labelingInfo, labelsVisible: e14.labelsVisible, renderer: e14.renderer, subtypeCode: e14.subtypeCode, orderBy: null })) };
    return u16(e13, t11, a10, r12);
  }
  addFilters(e13, t11) {
    e13 = r10(this.layer, e13, t11);
    const a10 = this.layer.sublayers.filter((e14) => !f7(e14, t11)).map((e14) => e14.subtypeCode);
    if (!a10.length) return e13;
    e13 ??= new d2();
    const s14 = `NOT ${this.layer.subtypeField} IN (${a10.join(",")})`;
    return e13.where = l3(e13.where, s14), e13;
  }
  get hasRequiredSupport() {
    return true;
  }
  get timeOptions() {
    return this.layer;
  }
  getUpdateHashProperties(e13) {
    return [() => this.layer.apiKey, () => this.layer.customParameters, () => this.layer.definitionExpression, () => o12(this.layer, e13) ? e13.floors : null, () => this.layer.outFields, () => this.layer.gdbVersion, () => this.layer.historicMoment, () => this.layer.sublayers.map(({ renderer: e14, labelsVisible: t11, labelingInfo: r12, visible: a10, minScale: i16, maxScale: s14 }) => ({ renderer: e14, labelsVisible: t11, labelingInfo: r12, visible: a10, minScale: i16, maxScale: s14 }))];
  }
  setGraphicOrigin(e13) {
    const t11 = this.layer.findSublayerForFeature(e13);
    e13.layer = e13.sourceLayer = t11, e13.origin = t11?.graphicOrigin;
  }
  _createServiceInfo(t11) {
    const { capabilities: r12, datesInUnknownTimezone: i16, dateFieldsTimeZone: l11, editingInfo: o14, globalIdField: u17, objectIdField: c9, subtypeField: p12 } = this.layer, y7 = this.layer.fieldsIndex.toJSON(), m13 = e5(this.layer), d10 = this.layer.timeInfo?.toJSON(), f8 = this.layer.spatialReference.toJSON(), h4 = a(this.layer.parsedUrl), b8 = c9, g4 = g(h4.path), S = t11.spatialReference.toJSON();
    return { type: "feature-service", source: h4, isSourceHosted: g4, orderByFields: b8, outSpatialReference: S, metadata: { timeReferenceUnknownClient: i16, dateFieldsTimeZone: l11, subtypeField: p12, globalIdField: u17, fieldsIndex: y7, geometryType: m13, featureIdInfo: e9(this.layer), timeInfo: d10, spatialReference: f8, outSpatialReference: S, subtypes: this.layer.subtypes?.map((e13) => e13.toJSON()), typeIdField: null, types: null }, queryMetadata: { maxRecordCount: r12.query.maxRecordCount, supportsCompactGeometry: r12.query.supportsCompactGeometry, supportsDefaultSpatialReference: r12.query.supportsDefaultSpatialReference, supportsFormatPBF: r12.query.supportsFormatPBF, supportsMaxRecordCountFactor: r12.query.supportsMaxRecordCountFactor, supportsQuantization: r12.query.supportsQuantization, supportsCentroidOnDegeneratedQuantizedGeometry: r12.query.supportsCentroidOnDegeneratedQuantizedGeometry, supportsDegeneratedQuantizedGeometry: r12.query.supportsDegeneratedQuantizedGeometry, lastEditDate: o14?.lastEditDate?.getTime() } };
  }
};
function f7(e13, r12) {
  return e13.visible && (0 === e13.minScale || m3(r12.scale, e13.minScale) || r12.scale < e13.minScale) && (0 === e13.maxScale || m3(r12.scale, e13.maxScale) || r12.scale > e13.maxScale);
}

// node_modules/@arcgis/core/views/2d/layers/support/DebouncedFeatureOverride.js
var e10 = class {
  constructor() {
    this._commands = /* @__PURE__ */ new Map(), this._historicMoment = null;
  }
  add(e13) {
    switch (e13.type) {
      case "override":
        return this._addOverride(e13);
      case "override-by-id":
        return this._addOverrideById(e13);
    }
  }
  toMessage() {
    const e13 = { historicMoment: this._historicMoment, commands: { updateByIdWeak: [], updateWeak: [], removeWeak: [], update: [], remove: [], release: [] } };
    for (const [s14, r12] of this._commands.entries()) switch (r12.type) {
      case "override-update-by-id":
        e13.commands.updateByIdWeak.push(s14);
        break;
      case "override-update":
        r12.isWeak ? e13.commands.updateWeak.push(r12.feature) : e13.commands.update.push(r12.feature);
        break;
      case "override-remove":
        r12.isWeak ? e13.commands.removeWeak.push(s14) : e13.commands.remove.push(s14);
        break;
      case "override-release":
        e13.commands.release.push(s14);
    }
    return e13;
  }
  _addOverrideById(e13) {
    this._historicMoment = e13.historicMoment;
    for (const s14 of e13.updates) this._commands.set(s14, { type: "override-update-by-id", isWeak: e13.isWeak });
    for (const s14 of e13.removed) this._commands.set(s14, { type: "override-remove", isWeak: e13.isWeak });
  }
  _addOverride(e13) {
    this._historicMoment = e13.historicMoment;
    for (const s14 of e13.updates) this._commands.set(s14.objectId, { type: "override-update", feature: s14, isWeak: e13.isWeak });
    for (const s14 of e13.removed) this._commands.set(s14, { type: "override-remove", isWeak: e13.isWeak });
    for (const s14 of e13.release) this._commands.set(s14, { type: "override-release" });
  }
};

// node_modules/@arcgis/core/views/2d/layers/support/handleNoEngineError.js
async function n13(n14, r12) {
  try {
    return await n14;
  } catch (t11) {
    if ("no-queryEngine" !== t11.name) throw t11;
    return r12;
  }
}

// node_modules/@arcgis/core/views/2d/tiling/FeatureTileSubscriptionManager.js
function e11(s14, e13) {
  const i16 = /* @__PURE__ */ new Set();
  for (const t11 of s14 instanceof Set ? s14.values() : s14.keys()) e13.has(t11) || i16.add(t11);
  return i16;
}
var i15 = class {
  constructor(s14, e13, i16) {
    this.target = /* @__PURE__ */ new Map(), this.previous = /* @__PURE__ */ new Map();
    const t11 = i16 ? s14.getTileCoverage(i16, 0, true, "closest") : null, r12 = s14.getTileCoverage(e13, 0, true, "closest");
    if (this.target.clear(), this.previous.clear(), t11) for (const o14 of t11.keys()) this.previous.set(o14.id, o14);
    if (r12) for (const o14 of r12.keys()) this.target.set(o14.id, o14);
  }
  *values() {
    yield* this.target.values(), yield* this.previous.values();
  }
  *keys() {
    yield* this.target.keys(), yield* this.previous.keys();
  }
};
var t10 = class {
  constructor(s14) {
    this.version = s14;
  }
};
var r11 = class {
  constructor(s14) {
    this._subscriptions = /* @__PURE__ */ new Map(), this._visible = /* @__PURE__ */ new Set(), this._version = 0, this._strategy = "eager", this._config = s14;
  }
  destroy() {
  }
  get coverage() {
    return this._coverage;
  }
  get subscriptions() {
    return new Set(this._subscriptions.keys());
  }
  setVisibilityStrategy(s14) {
    this._strategy = s14;
  }
  suspend() {
    this._suspendedCoverage = this._coverage, this._coverage = null, this._updateSubscriptions();
  }
  resume() {
    null == this._coverage && (this._coverage = this._suspendedCoverage, this._suspendedCoverage = null, this._updateSubscriptions());
  }
  update(s14, e13) {
    return this._version = (this._version + 1) % Number.MAX_SAFE_INTEGER, this._coverage = new i15(this._config.tileInfoView, s14, e13), this._updateSubscriptions(), new Set(this._visible);
  }
  updateVisibility() {
    const s14 = this._updateVisibility();
    return this._visible = s14, this._visible;
  }
  _updateSubscriptions() {
    if (!this._coverage) return;
    const s14 = this._updateVisibility(), i16 = new Set(this._coverage.keys()), r12 = e11(this._subscriptions, s14), o14 = e11(i16, this._subscriptions), n14 = e11(r12, i16);
    this._visible = s14;
    for (const e13 of o14.values()) this._subscriptions.set(e13, new t10(this._version));
    for (const e13 of n14.values()) this._subscriptions.delete(e13);
    (o14.size || n14.size) && this._sendUpdateSubscriptions(o14, n14);
  }
  _sendUpdateSubscriptions(s14, e13) {
    const i16 = Array.from(s14.values()).map((s15) => ({ tileId: s15, version: this._subscriptions.get(s15).version }));
    this._config.updateSubscriptions({ subscribe: i16, unsubscribe: Array.from(e13.values()) });
  }
  _updateVisibility() {
    if (!this._coverage) return /* @__PURE__ */ new Set();
    switch (this._strategy) {
      case "eager":
        return this._updateVisibilityEager(this._coverage);
      case "target-defer":
        return this._updateVisibilityTargetDefer(this._coverage);
    }
  }
  _updateVisibilityEager(s14) {
    const e13 = /* @__PURE__ */ new Set();
    for (const i16 of s14.values()) {
      if (this._config.isDone(i16)) {
        e13.add(i16.id);
        continue;
      }
      if (this._addVisibleParent(e13, i16)) continue;
      this._addVisibleChildren(e13, i16) || e13.add(i16.id);
    }
    return e13;
  }
  _updateVisibilityTargetDefer(s14) {
    const e13 = /* @__PURE__ */ new Set(), i16 = Array.from(s14.target.values());
    if (!i16.some((s15) => !this._config.isDone(s15))) {
      for (const s15 of i16) e13.add(s15.id);
      return e13;
    }
    for (const t11 of s14.values()) {
      if (this._addVisibleParent(e13, t11)) continue;
      this._addVisibleChildren(e13, t11) || e13.add(t11.id);
    }
    return e13;
  }
  _addVisibleParent(e13, i16) {
    let t11 = false;
    for (const r12 of this._visible.values()) {
      new e2(r12).containsChild(i16) && (e13.add(r12), t11 = true);
    }
    return t11;
  }
  _addVisibleChildren(e13, i16) {
    let t11 = false;
    for (const r12 of this._visible.values()) {
      const o14 = new e2(r12);
      i16.containsChild(o14) && (e13.add(r12), t11 = true);
    }
    return t11;
  }
};

// node_modules/@arcgis/core/networks/support/networkFieldUtils.js
function e12(t11, e13) {
  if ("feature" !== e13.type && "subtype-group" !== e13.type) return [];
  if (!e13.url) return [];
  const n14 = "utilityNetworks" in t11.map ? t11.map.utilityNetworks ?? [] : [];
  for (const o14 of n14) if (o14.isUtilityLayer(e13)) {
    const t12 = e13.fieldsIndex.get("assetgroup"), n15 = e13.fieldsIndex.get("assettype");
    return [t12?.name, n15?.name].filter((t13) => null != t13);
  }
  return [];
}

// node_modules/@arcgis/core/views/layers/support/WhereClauseVisitor.js
var s13 = class {
  constructor(i16) {
    this._fieldsIndex = i16, this._clauses = [];
  }
  async finish() {
    return { requiresCurrentUser: (await Promise.all(this._clauses)).some((i16) => i16.currentUserRequired) };
  }
  visitClientWhereClause(s14) {
    s14 && this._clauses.push(u4(s14, this._fieldsIndex));
  }
  visitFeatureReduction(i16) {
    if (i16) switch (i16.type) {
      case "binning":
      case "cluster":
        this.visitLabelingInfo(i16.labelsVisible, i16.labelingInfo);
    }
  }
  visitLabelingInfo(i16, s14) {
    if (i16 && null != s14) for (const e13 of s14) this.visitClientWhereClause(e13.where);
  }
  visitDisplayFilter(i16, s14) {
    if (i16) for (const e13 of s14?.filters ?? []) this.visitClientWhereClause(e13.where);
  }
  visitFilter(i16) {
    this.visitClientWhereClause(i16?.where);
  }
  visitTrackInfo(i16) {
    null != i16 && (this.visitLabelingInfo(i16?.latestObservations.labelsVisible, i16?.latestObservations.labelingInfo), this.visitLabelingInfo(i16?.previousObservations.labelsVisible, i16?.previousObservations.labelingInfo), this.visitLabelingInfo(i16?.trackLines.labelsVisible, i16?.trackLines.labelingInfo));
  }
};

// node_modules/@arcgis/core/views/layers/FeatureLayerView.js
var Q = (Q2) => {
  const G2 = Q2;
  let A3 = class extends G2 {
    constructor(...e13) {
      super(...e13), this._updatingRequiredPromise = null, this.filter = null, this.layer = null, this.requiresCurrentUser = false, this.requiredFields = [], this.view = null;
    }
    initialize() {
      this.addHandles([l2(() => {
        const e13 = this.layer, t11 = this.view;
        return [e13 && "elevationInfo" in e13 ? e13.elevationInfo?.featureExpressionInfo : null, e13 && "displayField" in e13 ? e13.displayField : null, e13 && "timeInfo" in e13 && e13.timeInfo, e13 && "renderer" in e13 && e13.renderer, e13 && "labelingInfo" in e13 && e13.labelingInfo, e13 && "floorInfo" in e13 && e13.floorInfo, t11?.requiredFieldsOptions?.featureTitleFields && e13 && "featureTitleFields" in e13 && e13.featureTitleFields, t11?.requiredFieldsOptions?.utilityNetworkFields && e12(t11, e13), e13.displayFilterInfo, this.displayFilterEnabled, this.filter, this.featureEffect, this.timeExtent, "knowledge-graph-sublayer" === e13?.type && "link-chart" === e13.parentCompositeLayer.type && e13.parentCompositeLayer.linkChart?.linkChartProperties.nonspatialDataDisplay?.mode];
      }, () => this._handleChange(), w), a3(() => this.view?.floors, "change", () => this._handleChange()), a3(() => this.layer.displayFilterInfo?.filters, "change", () => this._handleChange()), a3(() => this.layer && "sublayers" in this.layer ? this.layer.sublayers : null, "change", () => this._handleChange())]);
    }
    get availableFields() {
      if (!this.layer) return [];
      const { layer: e13, layer: { fieldsIndex: t11 }, requiredFields: i16 } = this;
      return "outFields" in e13 && e13.outFields ? b3(t11, [...T2(t11, e13.outFields), ...i16]) : b3(t11, i16);
    }
    get displayFilterEnabled() {
      return (this.view?.displayFilterEnabled ?? true) && (!("displayFilterEnabled" in this.layer) || (this.layer?.displayFilterEnabled ?? true));
    }
    get effectiveDisplayFilter() {
      const e13 = this.layer;
      return this.displayFilterEnabled && e13.displayFilterInfo ? u6(e13.displayFilterInfo, this.view) : null;
    }
    get effectiveDisplayFilterClause() {
      const e13 = this.effectiveDisplayFilter?.where ?? null;
      return e13 && this.hasHighlight ? r2(e13, o2(this.layer.objectIdField, this.highlightIds)) : e13;
    }
    get featureEffect() {
      return this.layer && "featureEffect" in this.layer ? this.layer.featureEffect : null;
    }
    set featureEffect(e13) {
      this._override("featureEffect", e13);
    }
    get maximumNumberOfFeatures() {
      return 0;
    }
    set maximumNumberOfFeatures(e13) {
      i2.getLogger(this).error("#maximumNumberOfFeatures=", "Setting maximum number of features is not supported");
    }
    get maximumNumberOfFeaturesExceeded() {
      return false;
    }
    get signedInUser() {
      return this.layer?.url ? J(this.layer.url) : Promise.resolve(null);
    }
    highlight(e13, t11) {
      throw new Error("missing implementation");
    }
    createQuery() {
      const e13 = { outFields: ["*"], returnGeometry: true, outSpatialReference: this.view.spatialReference }, t11 = null != this.filter ? this.filter.createQuery(e13) : new b2(e13);
      return "floorInfo" in this.layer && this.layer.floorInfo && (t11.where = l3(t11.where, o3(this))), this.displayFilterEnabled && (t11.where = l3(t11.where, this.effectiveDisplayFilter?.where)), null != this.timeExtent && (t11.timeExtent = null != t11.timeExtent ? t11.timeExtent.intersection(this.timeExtent) : this.timeExtent.clone()), t11;
    }
    createAggregateQuery() {
      const e13 = { outFields: ["*"], returnGeometry: true, outSpatialReference: this.view.spatialReference };
      return new b2(e13);
    }
    queryFeatures(e13, t11) {
      throw new Error("missing implementation");
    }
    queryObjectIds(e13, t11) {
      throw new Error("missing implementation");
    }
    queryFeatureCount(e13, t11) {
      throw new Error("missing implementation");
    }
    queryExtent(e13, t11) {
      throw new Error("missing implementation");
    }
    async fetchPopupFeaturesFromGraphics(e13, t11) {
      const i16 = [], r12 = /* @__PURE__ */ new Set();
      for (const l11 of e13) {
        const e14 = t3(l11.origin), s15 = n5(e14, { ...t11, checkPopupEnabled: true });
        s15 && (i16.push(l11), r12.add(s15));
      }
      if (0 === i16.length || 0 === r12.size) return [];
      const s14 = await this._createPopupQuery(r12, t11);
      return await n4(this.layer, i16, s14, { hasRequiredFields: (e14, t12) => this._popupFeatureHasRequiredFields(e14, t12), ...t11 });
    }
    _handleChange() {
      const e13 = Promise.all([this._updateRequiredFields(), this._updateClientWhereClauseRequirements()]).then(() => {
      });
      return this._set("_updatingRequiredPromise", e13), e13.then(() => {
        this._updatingRequiredPromise === e13 && this._set("_updatingRequiredPromise", null);
      }), e13;
    }
    async _updateClientWhereClauseRequirements() {
      if (!this.layer || !this.view) return;
      const { layer: e13 } = this, i16 = new s13(e13.fieldsIndex);
      if (i16.visitFilter(this.filter), "featureReduction" in e13 && i16.visitFeatureReduction(e13.featureReduction), "labelingInfo" in e13 && i16.visitLabelingInfo(e13.labelsVisible, e13.labelingInfo), "trackInfo" in e13 && i16.visitTrackInfo(e13.trackInfo), "2d" === this.view.type && (i16.visitFilter(this.featureEffect?.filter), i16.visitDisplayFilter(this.displayFilterEnabled, e13.displayFilterInfo), "featureReduction" in e13 && i16.visitFeatureReduction(e13.featureReduction)), "subtype-group" === e13.type) for (const t11 of e13.sublayers) i16.visitLabelingInfo(t11.labelsVisible, t11.labelingInfo);
      try {
        const e14 = await i16.finish();
        this._set("requiresCurrentUser", e14.requiresCurrentUser);
      } catch (r12) {
        i2.getLogger(this).error(r12);
      }
    }
    async _updateRequiredFields() {
      if (!this.layer || !this.view) return;
      const e13 = "3d" === this.view.type, { layer: i16, layer: { fieldsIndex: r12 } } = this, s14 = "renderer" in i16 && i16.renderer, l11 = "orderBy" in i16 && i16.orderBy, o14 = "featureReduction" in i16 ? i16.featureReduction : null, n14 = /* @__PURE__ */ new Set(), a10 = [s14 ? s14.collectRequiredFields(n14, r12) : null, Y2(n14, i16), e13 && "elevationInfo" in i16 ? L(n14, i16) : null, null != this.filter ? R(n14, i16, this.filter) : null, e13 || null == this.featureEffect ? null : R(n14, i16, this.featureEffect.filter), !e13 && o14 ? j(n14, i16, o14) : null, !e13 && l11 ? V(n14, i16, l11) : null];
      if ("timeInfo" in i16 && i16.timeInfo && this.timeExtent && w2(n14, i16.fieldsIndex, [i16.timeInfo.startField, i16.timeInfo.endField]), "timeInfo" in i16 && i16.timeInfo && "trackInfo" in i16 && i16.trackInfo) {
        const { trackInfo: e14 } = i16;
        w2(n14, i16.fieldsIndex, [i16.timeInfo.trackIdField]), "feature" !== i16.type && "startTimeField" !== e14.timeField || w2(n14, i16.fieldsIndex, [i16.timeInfo.startField]), "endTimeField" === e14.timeField && w2(n14, i16.fieldsIndex, [i16.timeInfo.endField]), await D(n14, i16);
      }
      if ("floorInfo" in i16 && i16.floorInfo && w2(n14, i16.fieldsIndex, [i16.floorInfo.floorField]), "featureTitleFields" in i16 && this.view?.requiredFieldsOptions?.featureTitleFields && i16.featureTitleFields && w2(n14, i16.fieldsIndex, i16.featureTitleFields), "feature" === i16.type && i16.globalIdField && this.view?.requiredFieldsOptions?.globalIdField && w2(n14, i16.fieldsIndex, [i16.globalIdField]), this.displayFilterEnabled && a10.push(X(n14, i16, i16.displayFilterInfo)), "feature" === i16.type && e13 && null != i16.infoFor3D && (null == i16.globalIdField && i2.getLogger(this).error("globalIdField missing on 3DObjectFeatureLayer"), w2(n14, i16.fieldsIndex, [i16.globalIdField])), "subtype-group" === i16.type) {
        x(n14, r12, i16.subtypeField);
        const e14 = i16.sublayers.map((e15) => Promise.all([e15.renderer?.collectRequiredFields(n14, r12), Y2(n14, e15)]));
        a10.push(Promise.all(e14));
      }
      if ("catalog-footprint" === i16.type && i16.parent) {
        const e14 = i16.parent;
        w2(n14, r12, [e14.itemNameField, e14.itemSourceField, e14.itemTypeField, e14.maxScaleField, e14.minScaleField]);
      }
      "knowledge-graph-sublayer" === i16.type && "link-chart" === i16.parentCompositeLayer.type && x(n14, r12, E);
      const u17 = await Promise.allSettled(a10);
      if (e13) x(n14, r12, i16.objectIdField);
      else for (const t11 of e3(e9(i16))) x(n14, r12, t11);
      e13 && "displayField" in i16 && i16.displayField && x(n14, r12, i16.displayField);
      for (const p12 of u17) "rejected" === p12.status && i2.getLogger(this).error(p12.reason);
      const d10 = Array.from(n14).sort();
      this._set("requiredFields", d10);
    }
    _popupFeatureHasRequiredFields(e13, t11) {
      return ke(e13, t11);
    }
    async _createPopupQuery(e13, t11) {
      const r12 = this.layer.createQuery(), s14 = /* @__PURE__ */ new Set();
      let l11 = "point" === this.layer.geometryType;
      for (const o14 of e13) {
        if (!l11) {
          const e15 = await s4(o14);
          s2(t11), l11 = (e15 && e15.arcadeUtils.hasGeometryOperations(o14)) ?? false;
        }
        const e14 = await p6(this.layer, o14);
        s2(t11);
        for (const t12 of e14) s14.add(t12);
      }
      return r12.returnGeometry = l11, r12.returnZ = l11, r12.returnM = l11, r12.outFields = Array.from(s14), r12.outSpatialReference = this.view.spatialReference, "floorInfo" in this.layer && this.layer.floorInfo && (r12.where = l3(r12.where, o3(this))), r12;
    }
    canResume() {
      return !!super.canResume() && (null == this.timeExtent || !this.timeExtent.isEmpty);
    }
    getTest() {
    }
    get test() {
    }
  };
  return __decorate([m()], A3.prototype, "_updatingRequiredPromise", void 0), __decorate([m({ readOnly: true })], A3.prototype, "availableFields", null), __decorate([m({ readOnly: true })], A3.prototype, "displayFilterEnabled", null), __decorate([m({ readOnly: true })], A3.prototype, "effectiveDisplayFilter", null), __decorate([m({ readOnly: true })], A3.prototype, "effectiveDisplayFilterClause", null), __decorate([m({ type: p3 })], A3.prototype, "featureEffect", null), __decorate([m({ type: d2 })], A3.prototype, "filter", void 0), __decorate([m()], A3.prototype, "layer", void 0), __decorate([m({ type: Number })], A3.prototype, "maximumNumberOfFeatures", null), __decorate([m({ readOnly: true, type: Boolean })], A3.prototype, "maximumNumberOfFeaturesExceeded", null), __decorate([m()], A3.prototype, "requiresCurrentUser", void 0), __decorate([m({ readOnly: true })], A3.prototype, "requiredFields", void 0), __decorate([m({ readOnly: true })], A3.prototype, "signedInUser", null), __decorate([m()], A3.prototype, "suspended", void 0), __decorate([m()], A3.prototype, "view", void 0), A3 = __decorate([a2("esri.views.layers.FeatureLayerView")], A3), A3;
};

// node_modules/@arcgis/core/views/2d/layers/FeatureLayerView2D.js
function le(e13, t11) {
  const r12 = /* @__PURE__ */ new Set();
  return e13 && e13.forEach((e14) => r12.add(e14)), t11 && t11.forEach((e14) => r12.add(e14)), r12.has("*") ? ["*"] : Array.from(r12);
}
var he = 4294967294;
function ce(e13, t11) {
  return t(e13.map((e14) => l2(() => {
    const t12 = e14();
    return t12 && "object" == typeof t12 ? "getTime" in t12 && "function" == typeof t12.getTime ? t12.getTime() : JSON.stringify(t12) : t12;
  }, t11)));
}
function pe(e13) {
  if (!e13.geometry) return e13;
  if (!n2(e13.geometry)) return e13;
  const t11 = 1e-3 / ae(e13.geometry.spatialReference), r12 = 100;
  return { geometry: y3(e13.geometry, { maxSegmentsPerCurve: 12e3, maxSegmentLength: r12 * t11, maxDeviation: 0 }), attributes: e13.attributes };
}
var de = class extends Q(i8(b6(d3))) {
  constructor() {
    super(...arguments), this._commandsQueue = new o4({ process: (e13) => {
      switch (e13.type) {
        case "override-batch":
          return this._doOverride(e13);
        case "update":
          return this._doUpdate();
        case "highlight":
          return this._updateHighlights();
      }
    } }), this._visibilityOverrides = /* @__PURE__ */ new Set(), this._lastAvailableFields = [], this._lastTargetState = null, this.eventLog = new u10(), this._sourceRefreshVersion = 1, this._displayRefreshVersion = 1, this._pipelineUpdating = false, this._editUpdatingHandles = new h(), this._fields = null, this._sourceUpdating = false, this.featureEffectView = new c3(), this._lastUpdate = 0;
  }
  destroy() {
    this._editUpdatingHandles.destroy(), this._workerProxy?.destroy(), this._workerAttached.reject(u2()), this._commandsQueue.destroy();
  }
  initialize() {
    this._workerAttached = $(), y(this._workerAttached.promise), this.addResolvingPromise(this._initProxy()), this.featureEffectView.featureEffect = this.featureEffect, this.featureEffectView.endTransition();
  }
  async _initProxy() {
    const e13 = this.layer;
    if ("isTable" in e13 && e13.isTable) throw new s("featurelayerview:table-not-supported", "table feature layer can't be displayed", { layer: e13 });
    if (("feature" === e13.type || "subtype-group" === e13.type) && false === G(e13)?.operations.supportsQuery) throw new s("featurelayerview:query-not-supported", "layer view requires a layer with query capability", { layer: e13 });
    this._workerProxy && this._workerProxy.destroy();
    const t11 = this._createClientOptions();
    this._workerProxy = await t7(t11);
  }
  async _attachProxy() {
    const e13 = { tileInfoJSON: this.view?.featuresTilingScheme?.tileInfo?.toJSON() };
    try {
      await this._workerProxy.pipeline.onAttach(e13), this._workerAttached.resolve();
    } catch (t11) {
      this._workerAttached.reject(u2()), m2(t11);
    }
  }
  async _detachProxy() {
    return this._workerProxy.pipeline.onDetach();
  }
  async getWorker() {
    return await this._workerAttached.promise, this._workerProxy;
  }
  get dataUpdating() {
    return this._sourceUpdating || this._editUpdatingHandles.updating;
  }
  get hasAllFeatures() {
    return this.layer.visible && !this.suspended && this.eventLog.hasAllData && this.eventLog.willQueryAllFeatures;
  }
  get hasAllFeaturesInView() {
    const e13 = this.effectiveDisplayFilter?.where || null, t11 = !this.eventLog.willQueryAllFeatures && null != e13 && "1=1" !== e13;
    return this.layer.visible && !this.suspended && this.eventLog.hasAllData && !t11;
  }
  get hasFullGeometries() {
    return this.layer.visible && !this.suspended && this.eventLog.hasAllData && this.eventLog.willQueryFullResolutionGeometry;
  }
  get labelingCollisionInfos() {
    const e13 = this.layerAdapter.getLabelingDeconflictionInfo(this.view), t11 = this.layer.geometryType, r12 = !this.suspended;
    return e13.map(({ vvEvaluators: e14, deconflictionEnabled: i16, labelingInfo: s14 }) => ({ labelingInfo: s14, container: this.featureContainer, vvEvaluators: e14, deconflictionEnabled: i16, geometryType: t11, visible: r12 }));
  }
  get layerAdapter() {
    switch (this.layer.type) {
      case "feature":
        return "memory" === this.layer.source.type ? new p11(this.layer) : new f6(this.layer);
      case "geojson":
      case "csv":
      case "wfs":
        return new p11(this.layer);
      case "parquet":
        return new y6(this.layer);
      case "subtype-group":
        return new d9(this.layer);
      case "ogc-feature":
        return new u15(this.layer);
      case "stream":
        return new s12(this.layer);
      case "oriented-imagery":
        return new m12(this.layer);
      case "knowledge-graph-sublayer":
        return new d8(this.layer);
      case "catalog-footprint":
        return new p10(this.layer);
      default:
        n(this.layer);
    }
    return null;
  }
  get timeExtent() {
    return i9(this.layerAdapter.timeOptions, this.view?.timeExtent, this._get("timeExtent"));
  }
  get usedMemory() {
    return this.container.usedMemory + this.eventLog.pipelineStatistics.usedMemory;
  }
  getDisplayStatistics(e13, t11) {
    return this.featureContainer?.getDisplayStatistics(e13, t11);
  }
  async queryHeatmapStatistics(e13) {
    return (await this.getWorker()).pipeline.queryHeatmapStatistics(e13);
  }
  highlight(e13, t11) {
    let i16;
    e13 instanceof _ ? i16 = [e13.getObjectId()] : "number" == typeof e13 || "string" == typeof e13 ? i16 = [e13] : O.isCollection(e13) && e13.length > 0 ? i16 = e13.map((e14) => e14?.getObjectId()).toArray() : Array.isArray(e13) && e13.length > 0 && (i16 = "number" == typeof e13[0] || "string" == typeof e13[0] ? e13 : e13.map((e14) => e14?.getObjectId()));
    const o14 = i16?.filter(N);
    if (!o14?.length) return e();
    const n14 = r5(t11);
    return this._addHighlights(o14, n14), e(() => !this.destroyed && this._removeHighlights(o14, n14));
  }
  async hitTest(e13, s14) {
    const a10 = await this.featureContainer.hitTest(s14);
    if (0 === a10.length) return null;
    const o14 = await this.getWorker(), { features: n14, aggregates: u17, tracks: l11 } = await o14.pipeline.getDisplayFeatures(a10), h4 = this.featureContainer.getSortKeys(a10), c9 = ({ displayId: e14 }, { displayId: t11 }) => h4.has(e14) && h4.has(t11) ? h4.get(e14) - h4.get(t11) : e14 - t11;
    n14.sort(c9).reverse(), u17.sort(c9).reverse();
    const p12 = has("parquetlayer-hittest-max-feature-count") ?? 1;
    return "parquet" === this.layer.type && n14.length > p12 && (n14.length = p12), [...u17.map((r12) => this._createAggregateGraphicHit(e13, i10.fromJSON(r12))), ...l11.map((t11) => this._createTrackGraphicHit(e13, i11.fromJSON(t11))), ...n14.map((t11) => this._createFeatureGraphicHit(e13, _.fromJSON(t11)))];
  }
  async queryStatistics() {
    const e13 = await this.getWorker();
    return n13(e13.pipeline.queryStatistics(), { featureCount: 0, ringCount: 0, vertexCount: 0 });
  }
  async querySummaryStatistics(e13, t11, r12) {
    const i16 = await this.getWorker(), s14 = { ...t11, scale: this.view.scale }, a10 = i16.features.executeQueryForSummaryStatistics(this._cleanUpQuery(e13), s14, r12);
    return n13(a10, {});
  }
  async queryAggregateSummaryStatistics(e13, t11, r12) {
    const i16 = { ...t11, scale: this.view.scale }, s14 = (await this.getWorker()).aggregates.executeQueryForSummaryStatistics(this._cleanUpAggregateQuery(e13), i16, r12);
    return n13(s14, {});
  }
  async queryUniqueValues(e13, t11, r12) {
    const i16 = await this.getWorker(), s14 = { ...t11, scale: this.view.scale }, a10 = i16.features.executeQueryForUniqueValues(this._cleanUpQuery(e13), s14, r12);
    return n13(a10, { uniqueValueInfos: [] });
  }
  async queryAggregateUniqueValues(e13, t11, r12) {
    const i16 = await this.getWorker(), s14 = { ...t11, scale: this.view.scale }, a10 = i16.aggregates.executeQueryForUniqueValues(this._cleanUpAggregateQuery(e13), s14, r12);
    return n13(a10, { uniqueValueInfos: [] });
  }
  async queryClassBreaks(e13, t11, r12) {
    const i16 = await this.getWorker(), s14 = { ...t11, scale: this.view.scale }, a10 = i16.features.executeQueryForClassBreaks(this._cleanUpQuery(e13), s14, r12);
    return n13(a10, { classBreakInfos: [] });
  }
  async queryAggregateClassBreaks(e13, t11, r12) {
    const i16 = await this.getWorker(), s14 = { ...t11, scale: this.view.scale }, a10 = i16.aggregates.executeQueryForClassBreaks(this._cleanUpAggregateQuery(e13), s14, r12);
    return n13(a10, { classBreakInfos: [] });
  }
  async queryHistogram(e13, t11, r12) {
    const i16 = await this.getWorker(), s14 = { ...t11, scale: this.view.scale }, a10 = i16.features.executeQueryForHistogram(this._cleanUpQuery(e13), s14, r12);
    return n13(a10, { bins: [], maxValue: null, minValue: null, normalizationTotal: null });
  }
  async queryAggregateHistogram(e13, t11, r12) {
    const i16 = await this.getWorker(), s14 = { ...t11, scale: this.view.scale }, a10 = i16.aggregates.executeQueryForHistogram(this._cleanUpAggregateQuery(e13), s14, r12);
    return n13(a10, { bins: [], maxValue: null, minValue: null, normalizationTotal: null });
  }
  queryFeatures(e13, t11) {
    return this.queryFeaturesJSON(e13, t11).then((e14) => {
      const t12 = g2.fromJSON(e14);
      return t12.features.forEach((e15) => this._setOriginForFeature(e15)), t12;
    });
  }
  async queryVisibleFeatures(e13, t11) {
    const r12 = (await this.getWorker()).pipeline.queryVisibleFeatures(this._cleanUpQuery(e13), t11), i16 = await n13(r12, { features: [] }), s14 = g2.fromJSON(i16);
    return s14.features.forEach((e14) => this._setOriginForFeature(e14)), s14;
  }
  async queryAggregates(e13, t11) {
    const r12 = (await this.getWorker()).aggregates.executeQuery(this._cleanUpAggregateQuery(e13), t11), i16 = await n13(r12, { features: [] }), s14 = c4.fromJSON(i16);
    return s14.features.forEach((e14) => this.layerAdapter.setAggregateGraphicOrigin?.(e14)), s14;
  }
  async queryAggregateIds(e13, t11) {
    const r12 = (await this.getWorker()).aggregates.executeQueryForIds(this._cleanUpAggregateQuery(e13), t11);
    return n13(r12, []);
  }
  async queryAggregateCount(e13, t11) {
    const r12 = (await this.getWorker()).aggregates.executeQueryForCount(this._cleanUpAggregateQuery(e13), t11);
    return n13(r12, 0);
  }
  async queryAggregateJSON(e13, t11) {
    const r12 = (await this.getWorker()).aggregates.executeQuery(this._cleanUpAggregateQuery(e13), t11);
    return n13(r12, { features: [] });
  }
  async queryFeaturesJSON(e13, t11) {
    const r12 = (await this.getWorker()).features.executeQuery(this._cleanUpQuery(e13), t11);
    return n13(r12, { features: [] });
  }
  async queryObjectIds(e13, t11) {
    const r12 = (await this.getWorker()).features.executeQueryForIds(this._cleanUpQuery(e13), t11);
    return n13(r12, []);
  }
  async queryFeatureCount(e13, t11) {
    const r12 = (await this.getWorker()).features.executeQueryForCount(this._cleanUpQuery(e13), t11);
    return n13(r12, 0);
  }
  async queryExtent(e13, t11) {
    const r12 = (await this.getWorker()).features.executeQueryForExtent(this._cleanUpQuery(e13), t11), i16 = await n13(r12, { count: 0, extent: null });
    return { count: i16.count, extent: z.fromJSON(i16.extent) };
  }
  async queryAttributeBins(e13, t11) {
    const r12 = (await this.getWorker()).features.executeAttributeBinsQuery(this._cleanUpAttributeBinsQuery(e13), t11), i16 = await n13(r12, { features: [] });
    return i6.fromJSON(i16);
  }
  async getSampleFeatures(e13) {
    return (await this.getWorker()).pipeline.getSampleFeatures(e13);
  }
  setVisibility(e13, t11) {
    t11 ? this._visibilityOverrides.delete(e13) : this._visibilityOverrides.add(e13), this._update();
  }
  update(e13) {
    const t11 = performance.now();
    if (t11 - this._lastUpdate < 200) return;
    if (this._lastUpdate = t11, !this.subscriptionManager) return;
    this.view.animation && !this._lastTargetState && (this._lastTargetState = e13.state.clone()), !this.view.animation && this._lastTargetState && (this._lastTargetState = null);
    const r12 = this.subscriptionManager.update(e13.targetState, this._lastTargetState), i16 = new Set(this.subscriptionManager.coverage?.target.keys());
    for (const s14 of this.featureContainer.tiles || []) s14.isCoverage = i16.has(s14.id);
    this.featureContainer.setVisibleTiles(r12);
  }
  attach() {
    has("esri-2d-update-debug") && console.debug("FeatureLayerView2D.attach"), y(this._updatingHandles.addPromise(this._workerAttached.promise)), y(this._attachProxy()), this.featureContainer = new l5(this), this.container.addChild(this.featureContainer), this.view.timeline.record(`${this.layer.title} (FeatureLayer) Attach`), this.subscriptionManager = new r11({ tileInfoView: this.view.featuresTilingScheme, updateSubscriptions: (e13) => {
      this.featureContainer.updateSubscriptions(e13), y(this._updatingHandles.addPromise(this.getWorker().then((t11) => t11.pipeline.updateSubscriptions(e13))));
    }, isDone: (e13) => this.featureContainer.isDone(e13) }), this.requestUpdate(), this.addAttachHandles([ce([() => this._displayRefreshVersion, () => this.layer.displayFilterInfo, () => this.timeExtent, () => this.clips, () => this.filter, () => this.effectiveDisplayFilterClause, () => this.featureEffect, () => this._sourceRefreshVersion, () => this.view.timeZone, () => this.view.timeExtent, ...this.layerAdapter.getUpdateHashProperties(this.view)], () => this._update()), l2(() => this.updateSuspended, (e13) => {
      e13 || (this.subscriptionManager.resume(), this.view.labelManager.requestUpdate());
    }), l2(() => this.visible, (e13) => {
      this.view.labelManager.symbolFader.restartDeclutter(), this.view.labelManager.requestUpdate();
    })]), this._update(), "stream" !== this.layer.type && "parquet" !== this.layer.type && "catalog-footprint" !== this.layer.type && this.addAttachHandles(this.layer.on("edits", (e13) => this._editUpdatingHandles.addPromise(this._edit(e13))));
  }
  detach() {
    has("esri-2d-update-debug") && console.debug("FeatureLayerView2D.detach"), this._detachProxy(), this._fields = null, this.view.labelManager.removeContainer(this.featureContainer), this.featureContainer.destroy(), this.featureContainer = null, this._commandsQueue.clear(), this.container.removeAllChildren(), this.subscriptionManager = u(this.subscriptionManager), this._workerProxy.pipeline.onDetach(), this._workerAttached = $(), y(this._workerAttached.promise), this._lastAvailableFields = [], this._lastSchema = null;
  }
  viewChange() {
    this.requestUpdate();
  }
  moveEnd() {
    this.requestUpdate();
  }
  addOverrides(e13) {
    return this._commandsQueue.push({ type: "override", options: { ...e13, release: [] } });
  }
  removeOverrides(e13) {
    for (const r12 of e13) if (null == r12) throw new s("featurelayerview:bad-override", "Tried to remove an override for an invalid objectId", { objectId: r12 });
    const t11 = { added: [], updated: [], removed: [], release: e13, isWeak: false, historicMoment: null };
    return this._commandsQueue.push({ type: "override", options: t11 });
  }
  isUpdating() {
    const e13 = "renderer" in this.layer && null != this.layer.renderer, t11 = this._commandsQueue.updateTracking.updating, r12 = null != this._updatingRequiredPromise, i16 = this.featureContainer.updatingHandles.updating, s14 = this.updateRequested || e13 && (t11 || r12) || i16 || this._pipelineUpdating || this.dataUpdating;
    if (has("esri-2d-log-updating")) {
      console.log(`Updating FLV2D (${this.layer.id}): ${s14}
  -> updateRequested ${this.updateRequested}
  -> hasRenderer ${e13}
  -> updatingRequiredFields ${r12}
  -> hasPendingCommand ${t11}
  -> dataUpdating ${this.dataUpdating}
  -> processing ${this._pipelineUpdating}
  -> updatingContainer ${i16}
`);
      for (const e14 of this.featureContainer.subscriptions()) console.log(`    -> Tile[${e14.id}] Done: ${e14.done}`);
    }
    return s14;
  }
  _createClientOptions() {
    const e13 = this;
    return { openMemoryPorts: async () => {
      if (this.layerAdapter?.openMessagePorts) {
        const e14 = await this.layerAdapter.openMessagePorts();
        return { result: e14, transferList: e14 };
      }
      throw new Error("InternalError: Layer adapter does not support opening message ports");
    }, get container() {
      return e13.featureContainer;
    }, setUpdating: (e14) => {
      this._set("_pipelineUpdating", e14.pipeline), this._set("_sourceUpdating", e14.source);
    }, emitEvent: (e14) => {
      this.emit(e14.name, e14.event);
    }, get eventLog() {
      return e13.eventLog;
    }, fetch: async (t11) => {
      if (has("esri-2d-stabilize-glyphs")) {
        const r12 = [];
        for (const i16 of t11) r12.push(await e13.view.stage.painter.textureManager.rasterizeItem(i16));
        return r12;
      }
      return Promise.all(t11.map((t12) => e13.view.stage.painter.textureManager.rasterizeItem(t12)));
    }, fetchDictionary: (e14) => Promise.all(e14.map((e15) => this._fetchDictionaryRequest(e15))) };
  }
  async _fetchDictionaryRequest(e13) {
    try {
      if ("subtype-group" === this.layer.type) throw new Error("InternalError: SubtypeGroupLayer does not support dictionary renderer");
      const t11 = this.layer.renderer;
      if (!t11 || "dictionary" !== t11.type) throw new Error("InternalError: Expected layer to have a DictionaryRenderer");
      const r12 = this._lastSchema.processor.mesh.factory.symbology;
      if ("dictionary" !== r12.type) throw new Error("InternalError: Expected schema to be of type 'dictionary'");
      const i16 = { cimAnalyzer: this.view.stage.cimAnalyzer, cimResourceManager: this.view.stage.painter.textureManager.resourceManager, store: this.featureContainer.instanceStore, scaleExpression: r12.scaleExpression };
      this._fields || (this._fields = this.layer.fields.map((e14) => e14.toJSON()));
      const s14 = r12.visualVariableUniforms, a10 = r4(this.layer.geometryType), o14 = await t11.getSymbolForControlString(e13.controlString, a10, false);
      if (!o14 || !o14.data) return { type: "dictionary-response", meshes: [] };
      return { type: "dictionary-response", meshes: await c2({ ...o14.data, hasTextStringTemplates: true }, { uniforms: s14, path: "renderer", schemaOptions: i16 }) };
    } catch (t11) {
      return { type: "dictionary-response", meshes: [] };
    }
  }
  _cleanUpQuery(e13) {
    const t11 = b2.from(e13) || this.createQuery();
    return t11.outSpatialReference || (t11.outSpatialReference = this.view.spatialReference), t11.toJSON();
  }
  _cleanUpAttributeBinsQuery(e13) {
    const t11 = T.from(e13);
    return t11.outSpatialReference || (t11.outSpatialReference = this.view.spatialReference), t11.toJSON();
  }
  _cleanUpAggregateQuery(e13) {
    const t11 = b2.from(e13) || this.createAggregateQuery();
    t11.outSpatialReference || (t11.outSpatialReference = this.view.spatialReference);
    const r12 = t11.objectIds ?? [];
    for (const i16 of t11.aggregateIds ?? []) r12.push(i16);
    return t11.objectIds = r12, t11.aggregateIds = [], t11.toJSON();
  }
  async _update() {
    return this._commandsQueue.push({ type: "update" });
  }
  _edit(e13) {
    return this._commandsQueue.push({ type: "edit", event: e13 });
  }
  async doRefresh(e13) {
    this.attached && (this.updateSuspended && e13 || (e13 ? this.incrementSourceRefreshVersion() : this.incrementDisplayRefreshVersion()));
  }
  incrementSourceRefreshVersion() {
    this._sourceRefreshVersion = (this._sourceRefreshVersion + 1) % he + 1;
  }
  incrementDisplayRefreshVersion() {
    this._displayRefreshVersion = (this._displayRefreshVersion + 1) % he + 1;
  }
  async _resolveIdenifiers(e13) {
    const t11 = [], r12 = [];
    for (const a10 of e13) null == a10.objectId || -1 === a10.objectId ? null == a10.globalId ? i2.getLogger(this).warn("mapview-apply-edits", "A feature identifier must contain either a GlobalId or ObjectId. Ignoring", { identifier: a10 }) : r12.push(a10.globalId) : t11.push(a10.objectId);
    const i16 = "globalIdField" in this.layer && this.layer.globalIdField, s14 = i16 && this.availableFields.includes(i16);
    if (r12.length && !s14) return i2.getLogger(this).error(new s("mapview-apply-edits", `Editing the specified service requires the layer's globalIdField, ${i16} to be included the layer's outFields for updates to be reflected on the map`)), t11;
    if (r12.length) {
      const e14 = await this._workerProxy.pipeline.getObjectIdsFromGlobalIds(r12);
      for (const r13 of e14) t11.push(r13);
    }
    return t11;
  }
  _resolveOverrides(e13) {
    const t11 = false, r12 = false, i16 = r4(this.layer.geometryType), s14 = e9(this.layer), a10 = [];
    for (const o14 of e13.added) {
      const e14 = ot(pe(o14), i16, t11, r12, s14);
      if (null == e14.objectId) throw new s("featurelayerview:bad-override", "Feature does not have an objectId", { feature: o14 });
      a10.push(e14);
    }
    for (const o14 of e13.updated) {
      const e14 = ot(pe(o14), i16, t11, r12, s14);
      if (null == e14.objectId) throw new s("featurelayerview:bad-override", "Feature does not have an objectId", { feature: o14 });
      a10.push(e14);
    }
    for (const o14 of e13.removed) if (null == o14) throw new s("featurelayerview:bad-override", "Tried to remove an invalid objectId", { objectId: o14 });
    return { type: "override", updates: a10, removed: e13.removed, release: e13.release, isWeak: e13.isWeak ?? false, historicMoment: e13.historicMoment ?? null };
  }
  async _resolveEdit(e13) {
    const t11 = this.layer, r12 = e13.historicMoment?.getTime() ?? null, i16 = "layerId" in t11 && e13.editedFeatures?.find((e14) => e14.layerId === t11.layerId);
    if (i16 && this._canEditByFeature(i16)) {
      const { adds: e14, deletes: t12, updates: s15 } = i16.editedFeatures, a11 = this.layer.objectIdField, o15 = s15.map((e15) => e15.current), n14 = t12.map((e15) => "attributes" in e15 ? { objectId: a11 ? e15.attributes[a11] : null } : e15), u17 = await this._resolveIdenifiers(n14);
      return this._resolveOverrides({ added: e14, updated: o15, removed: u17, historicMoment: r12, isWeak: true, release: [] });
    }
    const [s14, a10, o14] = await Promise.all([this._resolveIdenifiers(e13.addedFeatures), this._resolveIdenifiers(e13.updatedFeatures), this._resolveIdenifiers(e13.deletedFeatures)]);
    return { type: "override-by-id", updates: [...s14, ...a10], removed: o14, historicMoment: r12, isWeak: true };
  }
  _canEditByFeature(e13) {
    const { adds: t11, updates: r12 } = e13.editedFeatures;
    return t11.every((e14) => this.view.spatialReference.equals(e14.geometry?.spatialReference)) && r12.every((e14) => this.view.spatialReference.equals(e14.current.geometry?.spatialReference));
  }
  async _doUpdate() {
    "featureReduction" in this.layer && this.layer.featureReduction && this.layer.featureReduction !== this._lastFeatureReduction && (this.layer.featureReduction = this.layer.featureReduction?.clone(), this._lastFeatureReduction = this.layer.featureReduction);
    try {
      if (await Promise.allSettled([this._handleChange(), W(this.layer)]), this.destroyed || !this.layerAdapter?.hasRequiredSupport || !this.subscriptionManager) return;
      const e13 = this.featureContainer.instanceStore;
      this.featureContainer.attributeView.lockTextureUploads();
      const t11 = this._lastSchema?.processor.mesh.factory.symbology?.type;
      let r12 = true;
      "subtype-group" !== this.layer.type && "dictionary" === this.layer.renderer?.type && "dictionary" === t11 && (r12 = false), e13.updateStart(r12);
      const i16 = this.featureEffect, s14 = { store: e13, cimAnalyzer: this.view.stage.cimAnalyzer, cimResourceManager: this.view.stage.painter.textureManager.resourceManager, scaleExpression: void 0 }, a10 = await this._createViewSchemaConfig(), o14 = { source: await this.layerAdapter.createSourceSchema(a10, this._sourceRefreshVersion), processor: await this.layerAdapter.createProcessorSchema(s14, a10, this._displayRefreshVersion) }, n14 = o14.processor.mesh.factory.labels;
      n14 && this.view.labelManager.setLabelSchemaStyles(n14, this.featureContainer);
      const u17 = i(this._lastSchema?.source.strategy, o14.source.strategy) || i(this._lastSchema?.processor, o14.processor);
      if (!u17) return this.featureContainer.requestRender(), this.featureContainer.attributeView.unlockTextureUploads(), e13.updateEnd(r12), void (this.featureEffectView.featureEffect = i16);
      this._lastSchema = o14, this._fields = null;
      const l11 = Math.round(performance.now());
      has("esri-2d-update-debug") && console.debug(`Id[${this.layer.uid}] Version[${l11}] FeatureLayerView2D._doUpdate`, { changes: u17 });
      const h4 = await this.getWorker();
      await h4.pipeline.updateSchema(o14, l11), e13.updateEnd(r12), this.featureEffectView.featureEffect = i16, this.featureEffectView.endTransition(), this.featureContainer.restartAllAnimations(), this.featureContainer.attributeView.unlockTextureUploads(), this.featureContainer.trySwapRenderState(), this.featureContainer.requestRender();
      const c9 = o14.processor.mesh.strategy, d10 = "cluster" === c9.type || "binning" === c9.type, y7 = "heatmap" === o14.processor.mesh.factory.symbology.type, g4 = d10 || y7 ? "target-defer" : "eager";
      this.subscriptionManager.setVisibilityStrategy(g4), has("esri-2d-update-debug") && console.debug(`Version[${l11}] FeatureLayerView2D.updateEnd`), this.requestUpdate();
    } catch (e13) {
      has("esri-2d-update-debug") && console.error("Encountered an error during update", e13);
    }
  }
  async _doOverride(e13) {
    const t11 = await this.getWorker();
    try {
      for (const r12 of e13.messages) switch (r12.type) {
        case "edit": {
          const e14 = new e10();
          e14.add(await this._resolveEdit(r12.event)), await t11.pipeline.onOverride(e14.toMessage());
          break;
        }
        case "override": {
          const e14 = new e10();
          e14.add(this._resolveOverrides(r12.options)), await t11.pipeline.onOverride(e14.toMessage());
          break;
        }
      }
    } catch (r12) {
      d(r12), 0;
    }
  }
  _getEffectiveAvailableFields(e13) {
    const t11 = le(this._lastAvailableFields, e13);
    return this._lastAvailableFields = t11, h2(this.layer.fieldsIndex, t11);
  }
  async _createViewSchemaConfig() {
    const e13 = this.requiresCurrentUser ? await this.signedInUser : null, t11 = [ye(this.view, this.layerAdapter, this.timeExtent, this._visibilityOverrides, this.filter, this.effectiveDisplayFilterClause), this.featureEffect?.filter?.toJSON() ?? null];
    return { availableFields: this._getEffectiveAvailableFields(this.availableFields), displayFilterEnabled: this.displayFilterEnabled, filters: t11, scale: this.view.scale, timeZone: this.view.timeZone, timeExtent: this.view.timeExtent, currentUser: e13, spatialReference: this.view.spatialReference, extent: this.view.extent };
  }
  _processHighlight() {
    this._commandsQueue.push({ type: "highlight" });
  }
  async _updateHighlights() {
    const e13 = this._getHighlights(), t11 = await this.getWorker();
    if (this.destroyed) return;
    const r12 = t11.pipeline.updateHighlight({ highlights: e13 }).catch((e14) => {
      d(e14) || i2.getLogger(this).error(e14);
    });
    this._updatingHandles.addPromise(r12);
  }
  _setOriginForFeature(e13) {
    e13.layer = e13.sourceLayer = this.layer, this.layerAdapter.setGraphicOrigin(e13);
  }
  _createFeatureGraphicHit(e13, t11) {
    return this._setOriginForFeature(t11), this._createGraphicHit(e13, t11);
  }
  _createTrackGraphicHit(e13, t11) {
    return t11.layer = t11.sourceLayer = this.layer, this.layerAdapter.setTrackGraphicOrigin?.(t11), this._createGraphicHit(e13, t11);
  }
  _createAggregateGraphicHit(e13, t11) {
    return t11.layer = t11.sourceLayer = this.layer, this.layerAdapter.setAggregateGraphicOrigin?.(t11), this._createGraphicHit(e13, t11);
  }
  _createGraphicHit(e13, t11) {
    return null != t11.geometry && (t11.geometry.spatialReference = this.view.spatialReference), { type: "graphic", graphic: t11, layer: this.layer, mapPoint: e13 };
  }
};
function ye(e13, t11, r12, i16, s14, a10) {
  s14 && (s14 = s14.clone());
  const o14 = null != s14 ? s14.timeExtent : null, n14 = null != r12 && null != o14 ? r12.intersection(o14) : r12 || o14;
  n14 && (s14 ??= new d2(), s14.timeExtent = n14), s14 = t11.addFilters?.(s14, e13) ?? s14, a10 && (s14 ??= new d2(), s14.where = l3(s14.where, a10));
  let u17 = s14?.toJSON() ?? null;
  return i16.size && (u17 ??= new d2().toJSON(), u17.hiddenIds = Array.from(i16)), u17;
}
__decorate([m()], de.prototype, "_commandsQueue", void 0), __decorate([m()], de.prototype, "_sourceRefreshVersion", void 0), __decorate([m()], de.prototype, "_displayRefreshVersion", void 0), __decorate([m({ readOnly: true })], de.prototype, "_pipelineUpdating", void 0), __decorate([m()], de.prototype, "_sourceUpdating", void 0), __decorate([m({ readOnly: true })], de.prototype, "dataUpdating", null), __decorate([m({ readOnly: true })], de.prototype, "hasAllFeatures", null), __decorate([m({ readOnly: true })], de.prototype, "hasAllFeaturesInView", null), __decorate([m({ readOnly: true })], de.prototype, "hasFullGeometries", null), __decorate([m()], de.prototype, "featureEffectView", void 0), __decorate([m()], de.prototype, "labelingCollisionInfos", null), __decorate([m()], de.prototype, "layerAdapter", null), __decorate([m({ readOnly: true })], de.prototype, "timeExtent", null), de = __decorate([a2("esri.views.2d.layers.FeatureLayerView2D")], de);

export {
  n13 as n,
  de
};
//# sourceMappingURL=chunk-N2FOLAN6.js.map
