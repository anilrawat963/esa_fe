import {
  r2 as r4
} from "./chunk-43423NKQ.js";
import {
  h as h2
} from "./chunk-7LPDSYJP.js";
import {
  r as r3
} from "./chunk-QTS3W27E.js";
import {
  o as o2
} from "./chunk-3RABUJDL.js";
import {
  c,
  e as e2,
  t as t2
} from "./chunk-U3B7YMY7.js";
import {
  t
} from "./chunk-XMUWUWWP.js";
import {
  w
} from "./chunk-SMJWJAIA.js";
import {
  i
} from "./chunk-SJ2OBYX2.js";
import {
  e as e3,
  t as t3
} from "./chunk-WKTI47FV.js";
import {
  e
} from "./chunk-JUZ3H47H.js";
import {
  Q,
  R
} from "./chunk-JE2NJSBU.js";
import {
  r as r2
} from "./chunk-EM7Y2JZC.js";
import {
  M,
  f,
  h,
  o
} from "./chunk-LTPHDYPK.js";
import {
  r2 as r
} from "./chunk-GNMPGHLQ.js";

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/core.js
var t4 = class {
  constructor(t5, s5) {
    this.sourceTile = s5, this.xTile = 0, this.yTile = 0, this.hash = 0, this.priority = 1, this.featureIndex = 0, this.uniqueSymbol = null, this._colliders = [], this.textVertexRanges = [], this.iconVertexRanges = [], this.tile = t5;
  }
  colliders() {
    return this._colliders;
  }
};
var s = class {
  constructor(t5) {
    this.parts = [{ startTime: 0, startOpacity: 0, targetOpacity: 0, show: false }, { startTime: 0, startOpacity: 0, targetOpacity: 0, show: false }], this.show = false, this.lastShow = false, this.tileSymbols = [t5], this.id = t5.id;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/util.js
function o3(t5, e4, o6, l5) {
  return s2(t5, e4, o6.level, o6.col, l5.key.level, l5.key.col);
}
function l(t5, e4, o6, l5) {
  return s2(t5, e4, o6.level, o6.row, l5.level, l5.row);
}
function s2(t5, e4, o6, l5, s5, r8) {
  const i3 = o6 - s5;
  if (i3 >= 0) return (e4 >> i3) + (l5 - (r8 << i3)) * (t5 >> i3);
  const n5 = -i3;
  return e4 - (r8 - (l5 << n5)) * (t5 >> n5) << n5;
}
var r5 = class {
  constructor(t5, e4, o6) {
    this._rows = Math.ceil(e4 / o6), this._columns = Math.ceil(t5 / o6), this._cellSize = o6, this.cells = new Array(this._rows);
    for (let l5 = 0; l5 < this._rows; l5++) {
      this.cells[l5] = new Array(this._columns);
      for (let t6 = 0; t6 < this._columns; t6++) this.cells[l5][t6] = [];
    }
  }
  getCell(t5, e4) {
    const o6 = Math.min(Math.max(Math.floor(e4 / this._cellSize), 0), this._rows - 1), l5 = Math.min(Math.max(Math.floor(t5 / this._cellSize), 0), this._columns - 1);
    return this.cells[o6] && this.cells[o6][l5] || null;
  }
  getCellSpan(t5, e4, o6, l5) {
    return [Math.min(Math.max(Math.floor(t5 / this._cellSize), 0), this.columns - 1), Math.min(Math.max(Math.floor(e4 / this._cellSize), 0), this.rows - 1), Math.min(Math.max(Math.floor(o6 / this._cellSize), 0), this.columns - 1), Math.min(Math.max(Math.floor(l5 / this._cellSize), 0), this.rows - 1)];
  }
  get cellSize() {
    return this._cellSize;
  }
  get columns() {
    return this._columns;
  }
  get rows() {
    return this._rows;
  }
};
function i2(t5, o6, l5, s5, r8, i3, n5) {
  const c4 = o6[s5++];
  for (let a5 = 0; a5 < c4; a5++) {
    const c5 = new t4(i3, n5);
    c5.xTile = o6[s5++], c5.yTile = o6[s5++], c5.hash = o6[s5++], c5.priority = o6[s5++], c5.featureIndex = o6[s5++];
    const a6 = o6[s5++], h5 = c5.colliders();
    for (let t6 = 0; t6 < a6; t6++) {
      const t7 = o6[s5++], e4 = o6[s5++], r9 = o6[s5++], i4 = o6[s5++], n6 = !!o6[s5++], c6 = o6[s5++], a7 = l5[s5++], u4 = l5[s5++], f4 = o6[s5++], m = o6[s5++];
      h5.push({ xTile: t7, yTile: e4, dxPixels: r9, dyPixels: i4, hard: n6, partIndex: c6, width: f4, height: m, minLod: a7, maxLod: u4 });
    }
    const u3 = t5[s5++];
    for (let e4 = 0; e4 < u3; e4++) c5.textVertexRanges.push([t5[s5++], t5[s5++]]);
    const f3 = t5[s5++];
    for (let e4 = 0; e4 < f3; e4++) c5.iconVertexRanges.push([t5[s5++], t5[s5++]]);
    r8.push(c5);
  }
  return s5;
}
function n(t5, e4, o6) {
  for (const [l5, s5] of t5.symbols) c2(t5, e4, o6, s5, l5);
}
function c2(t5, e4, o6, l5, s5) {
  const r8 = t5.layerData.get(s5);
  if (3 === r8.type) {
    for (const e5 of l5) {
      const l6 = e5.uniqueSymbol;
      let s6;
      if (e5.selectedForRendering) {
        const e6 = l6.parts[0], r9 = e6.startOpacity, i3 = e6.targetOpacity;
        t5.allSymbolsFadingOut = t5.allSymbolsFadingOut && 0 === i3;
        const n5 = o6 ? Math.floor(127 * r9) | i3 << 7 : i3 ? 255 : 0;
        s6 = n5 << 24 | n5 << 16 | n5 << 8 | n5;
      } else s6 = 0;
      for (const [t6, o7] of e5.iconVertexRanges) for (let e6 = t6; e6 < t6 + o7; e6 += 4) r8.iconOpacity[e6 / 4] = s6;
      if (e5.selectedForRendering) {
        const e6 = l6.parts[1], r9 = e6.startOpacity, i3 = e6.targetOpacity;
        t5.allSymbolsFadingOut = t5.allSymbolsFadingOut && 0 === i3;
        const n5 = o6 ? Math.floor(127 * r9) | i3 << 7 : i3 ? 255 : 0;
        s6 = n5 << 24 | n5 << 16 | n5 << 8 | n5;
      } else s6 = 0;
      for (const [t6, o7] of e5.textVertexRanges) for (let e6 = t6; e6 < t6 + o7; e6 += 4) r8.textOpacity[e6 / 4] = s6;
    }
    r8.lastOpacityUpdate = e4, r8.opacityChanged = true;
  }
}
function a(e4, o6, l5, s5) {
  const r8 = e4.colliders();
  let i3, n5, c4, a5;
  for (const h5 of r8) {
    if (e4.uniqueSymbol?.show && e4.uniqueSymbol.parts[h5.partIndex].show && (i3 = h5.xScreen - s5[0] + h5.dxScreen, n5 = h5.yScreen - s5[1] + h5.dyScreen, c4 = i3 + h5.width, a5 = n5 + h5.height, w(l5, o6.x, o6.y, i3, n5, c4, a5))) return true;
  }
  return false;
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/RenderBucket.js
var o4 = class {
  constructor(t5, e4) {
    this.layerUIDs = [], this.isDestroyed = false, this._data = t5;
    let r8 = 1;
    const n5 = new Uint32Array(t5);
    this.layerUIDs = [];
    const s5 = n5[r8++];
    for (let i3 = 0; i3 < s5; i3++) this.layerUIDs[i3] = n5[r8++];
    this.bufferDataOffset = r8, e4 && (this.layer = e4.getStyleLayerByUID(this.layerUIDs[0]));
  }
  get isPreparedForRendering() {
    return null == this._data;
  }
  get offset() {
    return this.bufferDataOffset;
  }
  get data() {
    return this._data;
  }
  destroy() {
    this.isDestroyed || (this.doDestroy(), this._data = null, this.isDestroyed = true);
  }
  prepareForRendering(t5) {
    null != this._data && (this.doPrepareForRendering(t5, this._data, this.bufferDataOffset), this._data = null);
  }
};
var h3 = class extends o4 {
  constructor(t5, e4) {
    super(t5, e4), this.type = 2, this.lineIndexStart = 0, this.lineIndexCount = 0;
    const r8 = new Uint32Array(t5);
    let n5 = this.bufferDataOffset;
    this.lineIndexStart = r8[n5++], this.lineIndexCount = r8[n5++];
    const s5 = r8[n5++];
    if (s5 > 0) {
      this.patternMap = /* @__PURE__ */ new Map();
      for (let t6 = 0; t6 < s5; t6++) {
        const t7 = r8[n5++], e5 = r8[n5++], s6 = r8[n5++];
        this.patternMap.set(t7, [e5, s6]);
      }
    }
    this.bufferDataOffset = n5;
  }
  get usedMemory() {
    return (this.data?.byteLength ?? 0) + (this.vao?.usedMemory ?? 0);
  }
  hasData() {
    return this.lineIndexCount > 0;
  }
  triangleCount() {
    return this.lineIndexCount / 3;
  }
  doDestroy() {
    this.vao = r(this.vao);
  }
  doPrepareForRendering(t5, e4, r8) {
    const n5 = new Uint32Array(e4), o6 = new Int32Array(n5.buffer), h5 = n5[r8++], l5 = this.layer.lineMaterial, f3 = new r3(t5, l5.geometryLayout, new Int32Array(o6.buffer, 4 * r8, h5));
    r8 += h5;
    const u3 = n5[r8++], y3 = o2.createIndex(t5, 35044, new Uint32Array(n5.buffer, 4 * r8, u3));
    r8 += u3, this.vao = new h2(t5, f3, y3);
  }
};
var l2 = class extends o4 {
  constructor(t5, e4) {
    super(t5, e4), this.type = 1, this.fillIndexStart = 0, this.fillIndexCount = 0, this.outlineIndexStart = 0, this.outlineIndexCount = 0;
    const r8 = new Uint32Array(t5);
    let n5 = this.bufferDataOffset;
    this.fillIndexStart = r8[n5++], this.fillIndexCount = r8[n5++], this.outlineIndexStart = r8[n5++], this.outlineIndexCount = r8[n5++];
    const s5 = r8[n5++];
    if (s5 > 0) {
      this.patternMap = /* @__PURE__ */ new Map();
      for (let t6 = 0; t6 < s5; t6++) {
        const t7 = r8[n5++], e5 = r8[n5++], s6 = r8[n5++];
        this.patternMap.set(t7, [e5, s6]);
      }
    }
    this.bufferDataOffset = n5;
  }
  get usedMemory() {
    return (this.data?.byteLength ?? 0) + (this.fillVAO?.usedMemory ?? 0) + (this.outlineVAO?.usedMemory ?? 0);
  }
  hasData() {
    return this.fillIndexCount > 0 || this.outlineIndexCount > 0;
  }
  triangleCount() {
    return (this.fillIndexCount + this.outlineIndexCount) / 3;
  }
  doDestroy() {
    this.fillVAO = r(this.fillVAO), this.outlineVAO = r(this.outlineVAO);
  }
  doPrepareForRendering(t5, e4, r8) {
    const n5 = new Uint32Array(e4), o6 = new Int32Array(n5.buffer), h5 = n5[r8++], l5 = this.layer, f3 = l5.fillMaterial, u3 = new r3(t5, f3.geometryLayout, new Int32Array(o6.buffer, 4 * r8, h5));
    r8 += h5;
    const y3 = n5[r8++], c4 = o2.createIndex(t5, 35044, new Uint32Array(n5.buffer, 4 * r8, y3));
    r8 += y3;
    const d = n5[r8++], p = l5.outlineMaterial, g = new r3(t5, p.geometryLayout, new Int32Array(o6.buffer, 4 * r8, d));
    r8 += d;
    const w2 = n5[r8++], I = o2.createIndex(t5, 35044, new Uint32Array(n5.buffer, 4 * r8, w2));
    r8 += w2, this.fillVAO = new h2(t5, u3, c4), this.outlineVAO = new h2(t5, g, I);
  }
};
var f2 = class extends o4 {
  constructor(t5, e4, s5) {
    super(t5, e4), this.type = 3, this.iconPerPageElementsMap = /* @__PURE__ */ new Map(), this.glyphPerPageElementsMap = /* @__PURE__ */ new Map(), this.symbolInstances = [], this.isIconSDF = false, this.opacityChanged = false, this.lastOpacityUpdate = 0, this.symbols = [];
    const i3 = new Uint32Array(t5), a5 = new Int32Array(t5), o6 = new Float32Array(t5);
    let h5 = this.bufferDataOffset;
    this.isIconSDF = !!i3[h5++];
    const l5 = i3[h5++], f3 = i3[h5++], u3 = i3[h5++], y3 = new e(l5, f3, u3, 0), c4 = i3[h5++];
    for (let r8 = 0; r8 < c4; r8++) {
      const t6 = i3[h5++], e5 = i3[h5++], r9 = i3[h5++];
      this.iconPerPageElementsMap.set(t6, [e5, r9]);
    }
    const d = i3[h5++];
    for (let r8 = 0; r8 < d; r8++) {
      const t6 = i3[h5++], e5 = i3[h5++], r9 = i3[h5++];
      this.glyphPerPageElementsMap.set(t6, [e5, r9]);
    }
    const p = i3[h5++], g = i3[h5++];
    this.iconOpacity = new Int32Array(p), this.textOpacity = new Int32Array(g), h5 = i2(i3, a5, o6, h5, this.symbols, s5, y3), this.bufferDataOffset = h5;
  }
  get usedMemory() {
    return (this.data?.byteLength ?? 0) + (this.iconVAO?.usedMemory ?? 0) + (this.textVAO?.usedMemory ?? 0) + i(this.iconOpacity) + i(this.textOpacity);
  }
  hasData() {
    return this.iconPerPageElementsMap.size > 0 || this.glyphPerPageElementsMap.size > 0;
  }
  triangleCount() {
    let t5 = 0;
    for (const e4 of this.iconPerPageElementsMap.values()) t5 += e4[1];
    for (const e4 of this.glyphPerPageElementsMap.values()) t5 += e4[1];
    return t5 / 3;
  }
  doDestroy() {
    this.iconVAO = r(this.iconVAO), this.textVAO = r(this.textVAO);
  }
  updateOpacityInfo() {
    if (!this.opacityChanged) return;
    this.opacityChanged = false;
    const t5 = this.iconOpacity, e4 = this.iconVAO.buffer("opacity");
    t5.length > 0 && t5.byteLength === e4.usedMemory && e4.setSubData(t5, 0, 0, t5.length);
    const r8 = this.textOpacity, n5 = this.textVAO.buffer("opacity");
    r8.length > 0 && r8.byteLength === n5.usedMemory && n5.setSubData(r8, 0, 0, r8.length);
  }
  doPrepareForRendering(t5, e4, r8) {
    const n5 = new Uint32Array(e4), o6 = new Int32Array(n5.buffer), h5 = n5[r8++], l5 = this.layer, f3 = l5.iconMaterial, u3 = new r3(t5, f3.geometryLayout, new Int32Array(o6.buffer, 4 * r8, h5));
    r8 += h5;
    const y3 = n5[r8++], c4 = o2.createIndex(t5, 35044, new Uint32Array(n5.buffer, 4 * r8, y3));
    r8 += y3;
    const d = n5[r8++], p = l5.textMaterial, g = new r3(t5, p.geometryLayout, new Int32Array(o6.buffer, 4 * r8, d));
    r8 += d;
    const w2 = n5[r8++], I = o2.createIndex(t5, 35044, new Uint32Array(n5.buffer, 4 * r8, w2));
    r8 += w2;
    const m = new r3(t5, f3.opacityLayout, this.iconOpacity.buffer), b = new r3(t5, p.opacityLayout, this.textOpacity.buffer);
    this.iconVAO = new h2(t5, /* @__PURE__ */ new Map([["geometry", u3], ["opacity", m]]), c4), this.textVAO = new h2(t5, /* @__PURE__ */ new Map([["geometry", g], ["opacity", b]]), I);
  }
};
var u = class extends o4 {
  constructor(t5, e4) {
    super(t5, e4), this.type = 4, this.circleIndexStart = 0, this.circleIndexCount = 0;
    const r8 = new Uint32Array(t5);
    let n5 = this.bufferDataOffset;
    this.circleIndexStart = r8[n5++], this.circleIndexCount = r8[n5++], this.bufferDataOffset = n5;
  }
  get usedMemory() {
    return (this.data?.byteLength ?? 0) + (this.vao?.usedMemory ?? 0);
  }
  hasData() {
    return this.circleIndexCount > 0;
  }
  triangleCount() {
    return this.circleIndexCount / 3;
  }
  doDestroy() {
    this.vao = r(this.vao);
  }
  doPrepareForRendering(t5, e4, r8) {
    const n5 = new Uint32Array(e4), o6 = new Int32Array(n5.buffer), h5 = n5[r8++], l5 = this.layer.circleMaterial, f3 = new r3(t5, l5.geometryLayout, new Int32Array(o6.buffer, 4 * r8, h5));
    r8 += h5;
    const u3 = n5[r8++], y3 = o2.createIndex(t5, 35044, new Uint32Array(n5.buffer, 4 * r8, u3));
    r8 += u3, this.vao = new h2(t5, f3, y3);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VectorTile.js
var y = class _y extends r4 {
  constructor(e4, t5, s5, r8, a5, o6, h5, n5 = null) {
    super(e4, t5, s5, r8, a5, o6, t, t), this.styleRepository = h5, this._owner = n5, this.type = "vector-tile", this._referenced = 1, this._hasSymbolBuckets = false, this._usedMemory = 256, this.layerData = /* @__PURE__ */ new Map(), this.status = "loading", this.allSymbolsFadingOut = false, this.lastOpacityUpdate = 0, this.symbols = /* @__PURE__ */ new Map(), this.isCoverage = false, this.neededForCoverage = false, this.decluttered = false, this.parentTile = null, this.childrenTiles = /* @__PURE__ */ new Set(), this.featureIndex = null, this.triangleCount = 0, this._processed = false, this.id = e4.id;
  }
  get styleLayerUIDs() {
    return Array.from(this.layerData.keys());
  }
  get hasSymbolBuckets() {
    return this._hasSymbolBuckets;
  }
  get isFading() {
    return this._hasSymbolBuckets && performance.now() - this.lastOpacityUpdate < e2;
  }
  get isHoldingForFade() {
    return this._hasSymbolBuckets && (!this.allSymbolsFadingOut || performance.now() - this.lastOpacityUpdate < e2);
  }
  get wasRequested() {
    return "errored" === this.status || "loaded" === this.status || "reloading" === this.status;
  }
  setData(e4) {
    this.changeDataImpl(e4), this.requestRender(), this.ready(), this._processed = true;
  }
  deleteLayerData(e4) {
    let t5 = false;
    for (const s5 of e4) {
      const e5 = this.layerData.get(s5);
      e5 && (this._usedMemory -= e5.usedMemory, 3 === e5.type && this.symbols.delete(s5) && (t5 = true), e5.destroy(), this.layerData.delete(s5));
    }
    this._owner?.updateTileSize(this), t5 && (this.featureIndex?.clear(), this.emit("symbols-changed")), this.requestRender();
  }
  processed() {
    return this._processed;
  }
  hasData() {
    return this.layerData.size > 0;
  }
  hasFeatures() {
    const e4 = this.layerData.values();
    for (const t5 of e4) if (t5.hasData()) return true;
    return false;
  }
  dispose() {
    "unloaded" !== this.status && (_y._destroyRenderBuckets(this.layerData), this.layerData.clear(), this.featureIndex = null, this._usedMemory = 0, this.destroy(), this.status = "unloaded");
  }
  release() {
    0 === --this._referenced && (this._owner?.onDisposeTile(this), this.dispose(), this.stage = null);
  }
  retain() {
    ++this._referenced;
  }
  get usedMemory() {
    return this._usedMemory;
  }
  get usedMemoryPerReference() {
    return this._usedMemory / (this._referenced || 1);
  }
  changeDataImpl(e4) {
    this.featureIndex?.clear();
    let t5 = false;
    if (e4) {
      const { bucketsWithData: s5, emptyBuckets: r8 } = e4, a5 = this._createRenderBuckets(s5);
      if (r8 && r8.byteLength > 0) {
        const e5 = new Uint32Array(r8);
        for (const t6 of e5) this._deleteLayerData(t6);
      }
      for (const [e5, i3] of a5) this._deleteLayerData(e5), 3 === i3.type && (this.symbols.set(e5, i3.symbols), t5 = true), this._usedMemory += i3.usedMemory, this.layerData.set(e5, i3);
      this._owner?.updateTileSize(this);
    }
    this._hasSymbolBuckets = false;
    for (const s5 of this.layerData.values()) 3 === s5.type && (this._hasSymbolBuckets = true);
    t5 && this.emit("symbols-changed");
  }
  attachWithContext(e4) {
    this.stage = { context: e4, trashDisplayObject(e5) {
      e5.processDetach();
    }, untrashDisplayObject: () => false };
  }
  setTransform(a5) {
    super.setTransform(a5);
    const i3 = this.resolution / (a5.resolution * a5.pixelRatio), o6 = this.width / this.rangeX * i3, h5 = this.height / this.rangeY * i3, n5 = [0, 0];
    a5.toScreen(n5, [this.x, this.y]);
    const l5 = this.transforms.tileUnitsToPixels;
    o(l5), M(l5, l5, n5), h(l5, l5, Math.PI * a5.rotation / 180), f(l5, l5, [o6, h5, 1]);
  }
  _createTransforms() {
    return { displayViewScreenMat3: e3(), tileMat3: e3(), tileUnitsToPixels: e3() };
  }
  static _destroyRenderBuckets(e4) {
    if (!e4) return;
    const t5 = /* @__PURE__ */ new Set();
    for (const s5 of e4.values()) t5.has(s5) || (s5.destroy(), t5.add(s5));
    e4.clear();
  }
  _createRenderBuckets(e4) {
    const t5 = /* @__PURE__ */ new Map(), s5 = /* @__PURE__ */ new Map();
    for (const r8 of e4) {
      const e5 = this._deserializeBucket(r8, s5);
      for (const s6 of e5.layerUIDs) t5.set(s6, e5);
    }
    return t5;
  }
  _deserializeBucket(e4, t5) {
    let s5 = t5.get(e4);
    if (s5) return s5;
    switch (new Uint32Array(e4)[0]) {
      case 1:
        s5 = new l2(e4, this.styleRepository);
        break;
      case 2:
        s5 = new h3(e4, this.styleRepository);
        break;
      case 3:
        s5 = new f2(e4, this.styleRepository, this);
        break;
      case 4:
        s5 = new u(e4, this.styleRepository);
    }
    return t5.set(e4, s5), s5;
  }
  _deleteLayerData(e4) {
    if (!this.layerData.has(e4)) return;
    const t5 = this.layerData.get(e4);
    this._usedMemory -= t5.usedMemory, t5.destroy(), this.layerData.delete(e4);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/CollisionJob.js
var s3 = class {
  constructor(s5, o6, n5, i3, l5, c4) {
    this._symbols = s5, this._styleRepository = i3, this._zoom = l5, this._currentLayerCursor = 0, this._currentSymbolCursor = 0, this._styleProps = /* @__PURE__ */ new Map(), this._allNeededMatrices = /* @__PURE__ */ new Map(), this._gridIndex = new r5(o6, n5, t2), this._si = Math.sin(Math.PI * c4 / 180), this._co = Math.cos(Math.PI * c4 / 180), i3.cachedStyles && (this._styleProps = i3.cachedStyles);
    for (const t5 of s5) for (const r8 of t5.symbols) this._allNeededMatrices.has(r8.tile) || this._allNeededMatrices.set(r8.tile, t3(r8.tile.transforms.tileUnitsToPixels));
  }
  work(e4) {
    const t5 = performance.now();
    for (; this._currentLayerCursor < this._symbols.length; this._currentLayerCursor++, this._currentSymbolCursor = 0) {
      const r8 = this._symbols[this._currentLayerCursor], s5 = this._getProperties(r8.styleLayerUID), o6 = this._styleRepository.layerContexts?.get(r8.styleLayerUID);
      for (; this._currentSymbolCursor < r8.symbols.length; this._currentSymbolCursor++) {
        if (this._currentSymbolCursor % 100 == 99 && performance.now() - t5 > e4) return false;
        const n5 = r8.symbols[this._currentSymbolCursor];
        if (!n5.uniqueSymbol?.show) continue;
        const i3 = this._computeCoordinates(n5, s5, o6), l5 = n5.uniqueSymbol;
        if (!l5.show) continue;
        const { iconAllowOverlap: c4, textAllowOverlap: h5 } = s5;
        for (const e5 of i3) {
          if (!e5.enabled) continue;
          const t6 = l5.parts[e5.partIndex];
          if (!t6.show) continue;
          !(e5.partIndex ? h5 : c4) && this._doesCollide(e5) && (e5.hard ? l5.show = false : t6.show = false);
        }
        l5.show && this._insertColliders(l5.parts, i3, s5);
      }
    }
    return true;
  }
  _insertColliders(e4, t5, r8) {
    const { iconIgnorePlacement: s5, textIgnorePlacement: o6 } = r8;
    for (const n5 of t5) {
      if (!n5.enabled) continue;
      if (n5.partIndex ? o6 : s5) continue;
      if (!e4[n5.partIndex].show) continue;
      const t6 = n5.xScreen + n5.dxScreen, r9 = n5.yScreen + n5.dyScreen, i3 = t6 + n5.width, l5 = r9 + n5.height, [c4, h5, a5, d] = this._gridIndex.getCellSpan(t6, r9, i3, l5);
      for (let e5 = h5; e5 <= d; e5++) for (let t7 = c4; t7 <= a5; t7++) {
        this._gridIndex.cells[e5][t7].push(n5);
      }
    }
  }
  _computeCoordinates(e4, t5, r8) {
    const { iconRotationAlignment: s5, textRotationAlignment: o6, iconTranslate: n5, iconTranslateAnchor: i3, textTranslate: l5, textTranslateAnchor: c4 } = t5, h5 = this._si, a5 = this._co, d = this._zoom, y3 = this._allNeededMatrices.get(e4.tile), u3 = e4.uniqueSymbol, x = e4.colliders(r8);
    let _ = 0;
    for (const f3 of x) {
      const [e5, t6] = 0 === f3.partIndex ? n5 : l5, r9 = 0 === f3.partIndex ? i3 : c4, u4 = f3.minLod <= d && d <= f3.maxLod;
      _ += u4 ? 0 : 1, f3.enabled = u4, f3.xScreen = f3.xTile * y3[0] + f3.yTile * y3[3] + y3[6], f3.yScreen = f3.xTile * y3[1] + f3.yTile * y3[4] + y3[7], 0 === r9 ? (f3.xScreen += a5 * e5 - h5 * t6, f3.yScreen += h5 * e5 + a5 * t6) : (f3.xScreen += e5, f3.yScreen += t6), 1 === (0 === f3.partIndex ? s5 : o6) ? (f3.dxScreen = f3.dxPixels, f3.dyScreen = f3.dyPixels) : (f3.dxScreen = a5 * (f3.dxPixels + f3.width / 2) - h5 * (f3.dyPixels + f3.height / 2) - f3.width / 2, f3.dyScreen = h5 * (f3.dxPixels + f3.width / 2) + a5 * (f3.dyPixels + f3.height / 2) - f3.height / 2);
    }
    return x.length > 0 && _ === x.length && u3 && (u3.show = false), x;
  }
  _getProperties(e4) {
    const t5 = this._styleProps.get(e4);
    if (t5) return t5;
    const r8 = this._styleRepository.getLayerStyleProperties?.(e4, this._zoom);
    return this._styleProps.set(e4, r8), r8;
  }
  _doesCollide(e4) {
    const t5 = e4.xScreen + e4.dxScreen, r8 = e4.yScreen + e4.dyScreen, s5 = t5 + e4.width, o6 = r8 + e4.height, [n5, i3, l5, c4] = this._gridIndex.getCellSpan(t5, r8, s5, o6);
    for (let h5 = i3; h5 <= c4; h5++) for (let i4 = n5; i4 <= l5; i4++) {
      const n6 = this._gridIndex.cells[h5][i4];
      for (const i5 of n6) {
        if (null != i5.labelId && null != e4.labelId && i5.labelId === e4.labelId) continue;
        const n7 = i5.xScreen + i5.dxScreen, l6 = i5.yScreen + i5.dyScreen, c5 = n7 + i5.width, h6 = l6 + i5.height;
        if (!(s5 < n7 || t5 > c5 || o6 < l6 || r8 > h6)) return true;
      }
    }
    return false;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolDeclutterer.js
function s4(e4) {
  return (e4.uniqueSymbol?.show && e4.uniqueSymbol?.lastShow) ?? false;
}
function r6(e4, t5) {
  if (e4.priority - t5.priority) return e4.priority - t5.priority;
  if (s4(e4) && !s4(t5)) return -1;
  if (s4(t5) && !s4(e4)) return 1;
  const o6 = e4.tile.key, i3 = t5.tile.key;
  return o6.world - i3.world ? o6.world - i3.world : o6.level - i3.level ? o6.level - i3.level : o6.row - i3.row ? o6.row - i3.row : o6.col - i3.col ? o6.col - i3.col : e4.xTile - t5.xTile ? e4.xTile - t5.xTile : e4.yTile - t5.yTile;
}
var n2 = class {
  get running() {
    return this._running;
  }
  constructor(e4, t5, o6, i3, s5, r8, n5, l5) {
    this.selectionMode = e4, this._visibleTiles = t5, this._symbolRepository = o6, this._styleRepository = i3, this._createCollisionJob = s5, this._assignTileSymbolsOpacity = r8, this._symbolLayerSorter = n5, this._isLayerVisible = l5, this._selectionJob = null, this._selectionJobCompleted = false, this._collisionJob = null, this._collisionJobCompleted = false, this._opacityJob = null, this._opacityJobCompleted = false, this._running = true;
  }
  setScreenSize(e4, t5) {
    this._screenWidth === e4 && this._screenHeight === t5 || this.restart(), this._screenWidth = e4, this._screenHeight = t5;
  }
  restart() {
    this._selectionJob = null, this._selectionJobCompleted = false, this._collisionJob = null, this._collisionJobCompleted = false, this._opacityJob = null, this._opacityJobCompleted = false, this._running = true;
  }
  continue(e4) {
    if (this._selectionJob || (this._selectionJob = this._createSelectionJob()), !this._selectionJobCompleted) {
      const t5 = performance.now();
      if (!this._selectionJob.work(e4)) return false;
      if (this._selectionJobCompleted = true, 0 === (e4 = Math.max(0, e4 - (performance.now() - t5)))) return false;
    }
    if (this._collisionJob || (this._collisionJob = this._createCollisionJob(this._selectionJob.sortedSymbols, this._screenWidth, this._screenHeight)), !this._collisionJobCompleted) {
      const t5 = performance.now();
      if (!this._collisionJob.work(e4)) return false;
      if (this._collisionJobCompleted = true, 0 === (e4 = Math.max(0, e4 - (performance.now() - t5)))) return false;
    }
    if (this._opacityJob || (this._opacityJob = this._createOpacityJob()), !this._opacityJobCompleted) {
      const t5 = performance.now();
      if (!this._opacityJob.work(e4)) return false;
      if (this._opacityJobCompleted = true, 0 === (e4 = Math.max(0, e4 - (performance.now() - t5)))) return false;
    }
    return this._running = false, true;
  }
  _isFeatureFiltered(e4, t5, s5) {
    const r8 = t5.getFilterFlags(e4), n5 = r8 & Q, l5 = null == s5.featureEffect || s5.featureEffect.excludedLabelsVisible || r8 & R;
    return !(n5 && l5);
  }
  _getFilteredByLayer() {
    let e4;
    if (this._styleRepository?.layerContexts) for (const t5 of this._symbolRepository.uniqueSymbols) {
      const o6 = this._styleRepository.layerContexts?.get(t5.styleLayerUID);
      if (o6?.attributeView) for (const i3 of t5.uniqueSymbols) {
        e4 ??= /* @__PURE__ */ new Map(), e4.get(t5.styleLayerUID) || e4.set(t5.styleLayerUID, /* @__PURE__ */ new Set());
        const s5 = e4.get(t5.styleLayerUID), r8 = o6.attributeView, n5 = o6.layerView;
        this._isFeatureFiltered(i3.id, r8, n5) && s5.add(i3.id);
      }
    }
    return e4;
  }
  _resetSelection() {
    for (let e4 = 0; e4 < this._symbolRepository.uniqueSymbols.length; e4++) {
      const t5 = this._symbolRepository.uniqueSymbols[e4];
      for (let e5 = 0; e5 < t5.uniqueSymbols.length; e5++) {
        const o6 = t5.uniqueSymbols[e5];
        for (const e6 of o6.tileSymbols) e6.selectedForRendering = false;
      }
    }
  }
  _createSelectionJob() {
    const e4 = "feature-tile" === this.selectionMode ? c3 : a2, t5 = this._symbolRepository.uniqueSymbols;
    this._resetSelection();
    const o6 = [];
    let i3 = 0, s5 = 0;
    const n5 = this._isLayerVisible, l5 = this._getFilteredByLayer(), y3 = this._styleRepository?.layerContexts;
    function h5(c4) {
      let a5;
      const h6 = performance.now();
      for (; s5 < t5.length; s5++, i3 = 0) {
        const r8 = t5[s5], u4 = r8.styleLayerUID, f3 = l5?.get(u4);
        let b = 0;
        if (y3) {
          const e5 = y3.get(u4).layerView;
          b = e5.view.allLayerViews.items.indexOf(e5);
        }
        if (!n5(u4)) {
          o6[s5] || (o6[s5] = { styleLayerUID: u4, layerOrder: b, symbols: [] });
          continue;
        }
        o6[s5] ||= { styleLayerUID: u4, symbols: [], layerOrder: b };
        const m = o6[s5];
        for (; i3 < r8.uniqueSymbols.length; i3++) {
          if (a5 = r8.uniqueSymbols[i3], i3 % 100 == 99 && performance.now() - h6 > c4) return false;
          if (a5.lastShow = a5.show, a5.id && f3?.has(a5.id)) {
            a5.show = false, a5.parts[0].show = false, a5.parts[1].show = false;
            continue;
          }
          const t6 = e4(a5);
          if (t6) {
            t6.selectedForRendering = true, m.symbols.push(t6), a5.show = true;
            for (const e5 of a5.parts) e5.show = true;
          } else a5.show = false;
        }
      }
      for (const e5 of o6) e5.symbols.sort(r6);
      return o6.sort((e5, t6) => t6.layerOrder - e5.layerOrder), true;
    }
    const u3 = this._symbolLayerSorter;
    return { work: h5, get sortedSymbols() {
      return o6.sort(u3);
    } };
  }
  _createOpacityJob() {
    const t5 = this._assignTileSymbolsOpacity, o6 = this._visibleTiles;
    let i3 = 0;
    function s5(e4, o7) {
      for (const t6 of e4.symbols.values()) l3(t6, o7);
      t5(e4, o7);
      for (const t6 of e4.childrenTiles) s5(t6, o7);
    }
    return { work(r8) {
      const n5 = performance.now();
      for (; i3 < o6.length; i3++) {
        if (performance.now() - n5 > r8) return false;
        const l5 = o6[i3];
        if (null != l5.parentTile) continue;
        const c4 = performance.now();
        l5 instanceof y ? s5(l5, c4) : t5(l5, c4);
      }
      return true;
    } };
  }
};
function l3(e4, o6) {
  for (const i3 of e4) {
    const e5 = i3.uniqueSymbol;
    for (const i4 of e5.parts) {
      const s5 = i4.targetOpacity > 0.5 ? 1 : -1;
      i4.startOpacity += s5 * ((o6 - i4.startTime) / e2), i4.startOpacity = Math.min(Math.max(i4.startOpacity, 0), 1), i4.startTime = o6, i4.targetOpacity = e5.show && i4.show ? 1 : 0;
    }
  }
}
function c3(e4) {
  let t5 = null, o6 = null, i3 = null;
  for (const s5 of e4.tileSymbols) {
    const e5 = s5.tile;
    e5.isReady && e5.isCoverage ? t5 = s5 : e5.isReady ? o6 = s5 : e5.rendering && (i3 = s5);
  }
  return t5 ?? o6 ?? i3;
}
function a2(e4) {
  let t5 = null, o6 = false, i3 = false;
  for (const s5 of e4.tileSymbols) if (!i3 || !o6) {
    const e5 = s5.tile;
    (!t5 || e5.isCoverage || e5.neededForCoverage && !o6) && (t5 = s5, (e5.neededForCoverage || e5.isCoverage) && (i3 = true), e5.isCoverage && (o6 = true));
  }
  return i3 ? t5 : null;
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolRepository.js
var o5 = class _o {
  static fromSymbols(e4, t5) {
    let s5 = e4.length;
    if (s5 >= n3) {
      let i3 = t5;
      do {
        i3 /= 2, s5 /= 4;
      } while (s5 > r7 && i3 > y2);
      const n5 = new r5(t5, t5, i3);
      for (const t6 of e4) n5.getCell(t6.xTile, t6.yTile).push(t6);
      return new _o(t5, e4, n5);
    }
    return new _o(t5, e4, null);
  }
  constructor(e4, t5, s5) {
    this.tileCoordRange = e4, this._symbols = t5, this._index = s5;
  }
  addSymbols(e4) {
    for (const t5 of e4) this._symbols.push(t5);
    if (this._index) for (const t5 of e4) this._index.getCell(t5.xTile, t5.yTile).push(t5);
  }
  removeSymbols(e4) {
    const t5 = new Set(e4);
    if (this._symbols = this._symbols.filter((e5) => !t5.has(e5)), this._index) for (const s5 of this._index.cells) for (let e5 = 0; e5 < s5.length; e5++) s5[e5] = s5[e5].filter((e6) => !t5.has(e6));
  }
  getSymbols() {
    return this._symbols;
  }
  getCandidate(e4, t5, s5, i3) {
    if (!this._index) {
      for (const l6 of this._symbols) if (s5 === l6.hash && Math.abs(e4 - l6.xTile) <= i3 && Math.abs(t5 - l6.yTile) <= i3) return l6;
      return null;
    }
    const l5 = this._index.getCellSpan(e4 - i3, t5 - i3, e4 + i3, t5 + i3), [o6, n5, r8, y3] = l5;
    for (let a5 = n5; a5 <= y3; a5++) for (let l6 = o6; l6 <= r8; l6++) {
      const o7 = this._index.cells[a5][l6];
      for (const l7 of o7) if (s5 === l7.hash && Math.abs(e4 - l7.xTile) <= i3 && Math.abs(t5 - l7.yTile) <= i3) return l7;
    }
    return null;
  }
};
var n3 = 32;
var r7 = 8;
var y2 = 64;
var a3 = 20;
var u2 = class {
  constructor(e4, t5) {
    this.tileCoordRange = e4, this._visibleTiles = t5, this._indexMapByTile = /* @__PURE__ */ new Map(), this._uniqueSymbolsByStyleLayerId = /* @__PURE__ */ new Map();
  }
  get uniqueSymbols() {
    return null == this._uniqueSymbolLayerArray && (this._uniqueSymbolLayerArray = this._createUniqueSymbolLayerArray()), this._uniqueSymbolLayerArray;
  }
  registerVectorTile(e4, t5) {
    const s5 = this._ensureIndexMap(e4), i3 = t5?.values() ?? s5.keys();
    for (const l5 of i3) {
      const e5 = s5.get(l5);
      e5 && (this._removeSymbols(l5, e5.getSymbols()), s5.delete(l5));
    }
    this._addSymbols(e4.key, s5, e4.symbols), this._invalidate();
  }
  unregisterVectorTile(e4) {
    this._removeTile(e4), this._invalidate();
  }
  registerFeatureTile(e4) {
    this._ensureIndexMap(e4), this._invalidate();
  }
  unregisterFeatureTile(e4) {
    this._removeTile(e4), this._invalidate();
  }
  insertFeatureTileMetrics(e4, t5) {
    const s5 = this._indexMapByTile.get(e4);
    if (!s5) throw new Error(`tile ${e4.id} not registered!`);
    this._addSymbols(e4.key, s5, h4(t5)), this._invalidate();
  }
  removeFeatureTileMetrics(e4, t5) {
    const s5 = this._indexMapByTile.get(e4);
    if (!s5) return;
    const i3 = h4(t5);
    for (const [l5, o6] of s5.entries()) {
      const e5 = i3.get(l5);
      e5 && (o6.removeSymbols(e5), this._removeSymbols(l5, e5));
    }
    this._invalidate();
  }
  deleteStyleLayers(e4) {
    for (const t5 of this._indexMapByTile.values()) for (const s5 of e4) {
      const e5 = t5.get(s5);
      e5 && (this._removeSymbols(s5, e5.getSymbols()), t5.delete(s5));
    }
    this._invalidate();
  }
  querySymbols(e4, s5, i3, l5) {
    const o6 = [];
    for (const [n5, r8] of this._uniqueSymbolsByStyleLayerId.entries()) for (const l6 of r8) {
      const r9 = l6.tileSymbols.find((e5) => e5.selectedForRendering);
      r9 && a(r9, e4, s5 * (window.devicePixelRatio || 1), i3) && o6.push({ vtlSymbol: r9, styleLayerUID: n5, tileKey: r9.tile.key });
    }
    return o6;
  }
  _ensureIndexMap(e4) {
    let t5 = this._indexMapByTile.get(e4);
    return t5 || (t5 = /* @__PURE__ */ new Map(), this._indexMapByTile.set(e4, t5)), t5;
  }
  _invalidate() {
    this._uniqueSymbolLayerArray = null;
  }
  _addSymbols(e4, t5, s5) {
    for (const [i3, l5] of s5) {
      let e5 = t5.get(i3);
      e5 ? e5.addSymbols(l5) : (e5 = o5.fromSymbols(l5, this.tileCoordRange), t5.set(i3, e5));
    }
    this._updateUniqueSymbols(e4, s5);
  }
  _removeTile(e4) {
    const t5 = this._indexMapByTile.get(e4);
    if (t5) {
      for (const [e5, s5] of t5.entries()) this._removeSymbols(e5, s5.getSymbols());
      this._indexMapByTile.delete(e4), this._invalidate();
    }
  }
  _removeSymbols(e4, t5) {
    for (const s5 of t5) {
      const t6 = s5.uniqueSymbol;
      if (t6) {
        if (t6.tileSymbols = t6.tileSymbols.filter((e5) => e5 !== s5), 0 === t6.tileSymbols.length) {
          const s6 = this._uniqueSymbolsByStyleLayerId.get(e4);
          s6.delete(t6), 0 === s6.size && this._uniqueSymbolsByStyleLayerId.delete(e4);
        }
        s5.uniqueSymbol = null;
      }
    }
  }
  _updateUniqueSymbols(t5, s5) {
    if (0 !== s5.size) {
      for (const e4 of this._visibleTiles) e4.parentTile || e4.key.world !== t5.world || e4.key.level === t5.level && !e4.key.equals(t5) || this._matchSymbols(e4, t5, s5);
      for (const [t6, i3] of s5) for (const s6 of i3) if (!s6.uniqueSymbol) {
        s6.uniqueSymbol = new s(s6);
        let i4 = this._uniqueSymbolsByStyleLayerId.get(t6);
        i4 || (i4 = /* @__PURE__ */ new Set(), this._uniqueSymbolsByStyleLayerId.set(t6, i4)), i4.add(s6.uniqueSymbol);
      }
    }
  }
  _matchSymbols(e4, t5, l5) {
    if (e4.key.level > t5.level) {
      const s5 = e4.key.level - t5.level;
      if (e4.key.row >> s5 !== t5.row || e4.key.col >> s5 !== t5.col) return;
    }
    if (t5.level > e4.key.level) {
      const s5 = t5.level - e4.key.level;
      if (t5.row >> s5 !== e4.key.row || t5.col >> s5 !== e4.key.col) return;
    }
    const o6 = /* @__PURE__ */ new Map();
    for (const [n5, r8] of l5) {
      const l6 = [], y3 = e4.key.level < t5.level ? 1 : 1 << Math.abs(e4.key.level - t5.level), u3 = this._indexMapByTile.get(e4), h5 = u3?.get(n5);
      if (h5) for (const o7 of r8) {
        if (o7.uniqueSymbol) continue;
        const n6 = o3(this.tileCoordRange, o7.xTile, t5, e4.key), r9 = l(this.tileCoordRange, o7.yTile, t5, e4.key), u4 = -a3, c4 = this.tileCoordRange + a3;
        if (!(n6 >= u4 && n6 < c4 && r9 >= u4 && r9 < c4)) {
          l6.push(o7);
          continue;
        }
        const f3 = h5.getCandidate(n6, r9, o7.hash, y3), m = f3?.uniqueSymbol;
        m ? (o7.uniqueSymbol = m, m.tileSymbols.push(o7)) : l6.push(o7);
      }
      l6.length > 0 && o6.set(n5, l6);
    }
    for (const s5 of e4.childrenTiles || []) this._matchSymbols(s5, t5, o6);
  }
  _createUniqueSymbolLayerArray() {
    const e4 = this._uniqueSymbolsByStyleLayerId, t5 = new Array(e4.size);
    let s5, i3 = 0;
    for (const [l5, o6] of e4) {
      const e5 = new Array(o6.size);
      s5 = 0;
      for (const t6 of o6) e5[s5++] = t6;
      t5[i3] = { styleLayerUID: l5, uniqueSymbols: e5 }, i3++;
    }
    return t5;
  }
};
function h4(e4) {
  const t5 = /* @__PURE__ */ new Map();
  for (const s5 of e4) {
    const e5 = s5.labelClassId;
    let i3 = t5.get(e5);
    i3 || (i3 = [], t5.set(e5, i3)), i3.push(s5);
  }
  return t5;
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolFader.js
var l4 = 0.5;
var a4 = 1e-6;
var n4 = class {
  constructor(e4, s5, l5, n5, c4, h5 = c) {
    this.styleRepository = s5, this._declutterBudget = h5, this._tileToHandle = /* @__PURE__ */ new Map(), this._viewState = { scale: 0, rotation: 0, center: [0, 0], size: [0, 0] }, this._declutterViewState = { scale: 0, rotation: 0, center: [0, 0], size: [0, 0] }, this._offsetFromScreenCenter = [0, 0], this._completed = false, this._fading = r2(false);
    const y3 = (t5, e5, i3) => this._createCollisionJob(t5, e5, i3), _ = (t5) => {
      const e5 = this.styleRepository.getStyleLayerByUID?.(t5);
      if (e5) {
        if (this._zoom + a4 < e5.minzoom || this._zoom - a4 >= e5.maxzoom) return false;
        const t6 = e5.getLayoutProperty?.("visibility");
        if (t6 && 1 === t6.getValue()) return false;
      }
      const i3 = this.styleRepository.layerContexts?.get(t5);
      return !(i3 && !i3.layerView.layer.visible);
    }, u3 = (t5, e5) => (this.styleRepository.getStyleLayerByUID?.(t5.styleLayerUID)?.z ?? 0) - (this.styleRepository.getStyleLayerByUID?.(e5.styleLayerUID)?.z ?? 0);
    this._symbolRepository = new u2(c4, n5), this._symbolDeclutterer = new n2(e4, n5, this._symbolRepository, this.styleRepository, y3, l5, u3, _);
  }
  get symbolRepository() {
    return this._symbolRepository;
  }
  _createCollisionJob(t5, i3, s5) {
    return this.updateDecluttererViewState(), new s3(t5, i3, s5, this.styleRepository, this._zoom, this._viewState.rotation);
  }
  get fading() {
    return this._fading.value;
  }
  get decluttererOffset() {
    return this._offsetFromScreenCenter;
  }
  registerFeatureTile(t5) {
    this.symbolRepository ? (this.symbolRepository.registerFeatureTile(t5), this.restartDeclutter()) : console.error("InternalError: Symbol repository not yet initialized");
  }
  unregisterFeatureTile(t5) {
    this.symbolRepository ? (this._symbolRepository.unregisterFeatureTile(t5), this.restartDeclutter()) : console.error("InternalError: Symbol repository not yet initialized");
  }
  insertFeatureTileMetrics(t5, e4) {
    this.symbolRepository ? (this.symbolRepository.insertFeatureTileMetrics(t5, e4), this.restartDeclutter()) : console.error("InternalError: Symbol repository not yet initialized");
  }
  removeFeatureTileMetrics(t5, e4) {
    this.symbolRepository ? (this.symbolRepository.removeFeatureTileMetrics(t5, e4), this.restartDeclutter()) : console.error("InternalError: Symbol repository not yet initialized");
  }
  addTile(t5) {
    t5.decluttered = false, this._tileToHandle.set(t5, t5.on("symbols-changed", () => {
      this._symbolRepository.registerVectorTile(t5), this.restartDeclutter();
    })), this._symbolRepository.registerVectorTile(t5), this.restartDeclutter();
  }
  removeTile(t5) {
    const e4 = this._tileToHandle.get(t5);
    e4 && (this._symbolRepository.unregisterVectorTile(t5), this.restartDeclutter(), e4.remove(), this._tileToHandle.delete(t5));
  }
  update(t5, e4) {
    this._zoom = t5, this._viewState = { scale: e4.scale, rotation: e4.rotation, center: [e4.center[0], e4.center[1]], size: [e4.size[0], e4.size[1]] };
    const i3 = [0, 0];
    e4.toScreen(i3, e4.center);
    const s5 = [0, 0];
    return e4.toScreen(s5, this._declutterViewState.center), this._offsetFromScreenCenter[0] = i3[0] - s5[0], this._offsetFromScreenCenter[1] = i3[1] - s5[1], this._continueDeclutter(), this._completed;
  }
  restartDeclutter() {
    this._completed = false, this._symbolDeclutterer.restart(), this._notifyUnstable();
  }
  clear() {
    this._completed = false, this._symbolRepository = null, this._symbolDeclutterer.restart(), this._tileToHandle.forEach((t5) => t5.remove()), this._tileToHandle.clear();
  }
  get stale() {
    return this._zoom !== this._declutterZoom || this._viewState.size[0] !== this._declutterViewState.size[0] || this._viewState.size[1] !== this._declutterViewState.size[1] || this._viewState.scale !== this._declutterViewState.scale || this._viewState.rotation !== this._declutterViewState.rotation;
  }
  deleteStyleLayers(t5) {
    this._symbolRepository.deleteStyleLayers(t5);
  }
  _continueDeclutter() {
    this._completed && !this.stale || (this._symbolDeclutterer.running || (this.updateDecluttererViewState(), this._symbolDeclutterer.restart()), this._symbolDeclutterer.setScreenSize(this._viewState.size[0], this._viewState.size[1]), this._completed = this._symbolDeclutterer.continue(this._declutterBudget), this._completed && this._scheduleNotifyStable());
  }
  _scheduleNotifyStable() {
    null != this._stableNotificationHandle && clearTimeout(this._stableNotificationHandle), this._stableNotificationHandle = setTimeout(() => {
      this._stableNotificationHandle = null, this._fading.value = false;
    }, (1 + l4) * e2);
  }
  _notifyUnstable() {
    null != this._stableNotificationHandle && (clearTimeout(this._stableNotificationHandle), this._stableNotificationHandle = null), this._fading.value = true;
  }
  updateDecluttererViewState() {
    this._declutterZoom = this._zoom, this._declutterViewState.center[0] = this._viewState.center[0], this._declutterViewState.center[1] = this._viewState.center[1], this._declutterViewState.rotation = this._viewState.rotation, this._declutterViewState.scale = this._viewState.scale, this._declutterViewState.size[0] = this._viewState.size[0], this._declutterViewState.size[1] = this._viewState.size[1], this._offsetFromScreenCenter[0] = 0, this._offsetFromScreenCenter[1] = 0;
  }
};

export {
  n,
  y,
  n4 as n2
};
//# sourceMappingURL=chunk-P77QHDEC.js.map
