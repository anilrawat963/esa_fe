import {
  n
} from "./chunk-ALR6N4CF.js";
import {
  t
} from "./chunk-4X4BOGIG.js";
import {
  e
} from "./chunk-7QPS6ATI.js";
import {
  A,
  B,
  C,
  D,
  E,
  F,
  G,
  H,
  I,
  J,
  K,
  L,
  M,
  N,
  O,
  P,
  Q,
  R,
  S,
  T,
  U,
  V,
  W,
  a,
  b,
  d,
  f,
  g,
  h,
  j,
  k,
  m,
  o,
  p,
  q,
  r,
  v,
  w,
  x,
  y as y2,
  z
} from "./chunk-NDFIZYZY.js";
import {
  s
} from "./chunk-TLTSPUO7.js";
import {
  R as R2
} from "./chunk-QNVJVDYZ.js";
import {
  y
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/geometry/support/FloatArray.js
function n2(n4, t3 = false) {
  return n4 <= y ? t3 ? new Array(n4).fill(0) : new Array(n4) : new Float32Array(n4);
}
function a2(n4) {
  return (Array.isArray(n4) ? n4.length : n4.byteLength / 8) <= y ? Array.from(n4) : new Float32Array(n4);
}
function e2(r2, n4, t3) {
  return Array.isArray(r2) ? r2.slice(n4, n4 + t3) : r2.subarray(n4, n4 + t3);
}

// node_modules/@arcgis/core/views/3d/support/buffer/glUtil.js
function t2(e3, t3 = 0) {
  const o2 = e3.stride;
  return Array.from(e3.fields.keys()).map((s2) => {
    const u = e3.fields.get(s2), c = u.constructor.ElementCount, i = n3(u.constructor.ElementType), a3 = u.offset, f2 = u.optional?.glNormalized ?? false;
    return new t(s2, c, i, a3, o2, f2, t3);
  });
}
function n3(r2) {
  switch (r2) {
    case "u8":
      return R2.UNSIGNED_BYTE;
    case "u16":
      return R2.UNSIGNED_SHORT;
    case "u32":
      return R2.UNSIGNED_INT;
    case "i8":
      return R2.BYTE;
    case "i16":
      return R2.SHORT;
    case "i32":
      return R2.INT;
    case "f16":
      return R2.HALF_FLOAT;
    case "f32":
      return R2.FLOAT;
    default:
      throw new Error("BufferType not supported in WebGL");
  }
}

// node_modules/@arcgis/core/views/3d/support/buffer/InterleavedLayout.js
var O2 = class _O {
  constructor(e3, t3) {
    this.layout = e3, this.buffer = "number" == typeof t3 ? new ArrayBuffer(t3 * e3.stride) : t3;
    for (const i of e3.fields.keys()) {
      const t4 = e3.fields.get(i);
      this[i] = new t4.constructor(this.buffer, t4.offset, this.stride);
    }
  }
  get stride() {
    return this.layout.stride;
  }
  get count() {
    return this.buffer.byteLength / this.stride;
  }
  get byteLength() {
    return this.buffer.byteLength;
  }
  getField(e3, t3) {
    const i = this[e3];
    return i && i.elementCount === t3.ElementCount && i.elementType === t3.ElementType ? i : null;
  }
  slice(e3, t3) {
    return new _O(this.layout, this.buffer.slice(e3 * this.stride, t3 * this.stride));
  }
  copyFrom(e3, t3 = 0, i = 0, r2 = e3.count) {
    const s2 = this.stride;
    if (s2 % 4 == 0) {
      const n4 = new Uint32Array(e3.buffer, t3 * s2, r2 * s2 / 4);
      new Uint32Array(this.buffer, i * s2, r2 * s2 / 4).set(n4);
    } else {
      const n4 = new Uint8Array(e3.buffer, t3 * s2, r2 * s2);
      new Uint8Array(this.buffer, i * s2, r2 * s2).set(n4);
    }
    return this;
  }
  get usedMemory() {
    return this.byteLength;
  }
  dispose() {
  }
};
var P2 = class _P {
  constructor(e3) {
    this._stride = 0, this._fields = /* @__PURE__ */ new Map(), e3 && (this._stride = e3.stride, e3.fields.forEach((e4) => this._fields.set(e4[0], { ...e4[1], constructor: X(e4[1].constructor) })));
  }
  freeze() {
    return this;
  }
  get locations() {
    return n(t2(this));
  }
  vec2f16(r2, s2) {
    return this._appendField(r2, r ? p : y2, s2), this;
  }
  vec2f(e3, t3) {
    return this._appendField(e3, y2, t3), this;
  }
  vec2f64(e3, t3) {
    return this._appendField(e3, b, t3), this;
  }
  vec3f16(t3, i) {
    return this._appendField(t3, r ? h : o, i), this;
  }
  vec3f(e3, t3) {
    return this._appendField(e3, o, t3), this;
  }
  vec3f64(e3, t3) {
    return this._appendField(e3, U, t3), this;
  }
  vec4f16(t3, i) {
    return this._appendField(t3, r ? m : T, i), this;
  }
  vec4f(e3, t3) {
    return this._appendField(e3, T, t3), this;
  }
  vec4f64(e3, t3) {
    return this._appendField(e3, F, t3), this;
  }
  mat3f(e3, t3) {
    return this._appendField(e3, d, t3), this;
  }
  mat3f64(e3, t3) {
    return this._appendField(e3, x, t3), this;
  }
  mat4f(e3, t3) {
    return this._appendField(e3, E, t3), this;
  }
  mat4f64(e3, t3) {
    return this._appendField(e3, A, t3), this;
  }
  vec4u8(e3, t3) {
    return this._appendField(e3, g, t3), this;
  }
  f16(t3, i) {
    return this._appendField(t3, r ? a : f, i), this;
  }
  f32(e3, t3) {
    return this._appendField(e3, f, t3), this;
  }
  f64(e3, t3) {
    return this._appendField(e3, B, t3), this;
  }
  u8(e3, t3) {
    return this._appendField(e3, I, t3), this;
  }
  u16(e3, t3) {
    return this._appendField(e3, w, t3), this;
  }
  i8(e3, t3) {
    return this._appendField(e3, z, t3), this;
  }
  vec2i8(e3, t3) {
    return this._appendField(e3, C, t3), this;
  }
  vec2i16(e3, t3) {
    return this._appendField(e3, J, t3), this;
  }
  vec2u8(e3, t3) {
    return this._appendField(e3, j, t3), this;
  }
  vec2u16(e3, t3) {
    return this._appendField(e3, L, t3), this;
  }
  vec4u16(e3, t3) {
    return this._appendField(e3, M, t3), this;
  }
  vec4i16(e3, t3) {
    return this._appendField(e3, N, t3), this;
  }
  u32(e3, t3) {
    return this._appendField(e3, v, t3), this;
  }
  _appendField(e3, t3, i) {
    this._fields.has(e3) && s(false, `${e3} already added to vertex buffer layout`);
    const r2 = t3.ElementCount * e(t3.ElementType), s2 = this._stride;
    this._fields.set(e3, { constructor: t3, size: r2, offset: s2, optional: i }), this._alignFields();
  }
  _alignFields() {
    let e3 = 0, t3 = 1;
    this._fields.forEach((i) => {
      const r2 = e(i.constructor.ElementType);
      e3 = Math.floor((e3 + r2 - 1) / r2) * r2, i.offset = e3, e3 += i.size, t3 = Math.max(t3, r2);
    }), e3 = Math.floor((e3 + t3 - 1) / t3) * t3, this._stride = e3;
  }
  createBuffer(e3) {
    return new O2(this, e3);
  }
  createView(e3) {
    return new O2(this, e3);
  }
  clone() {
    const e3 = new _P();
    return e3._stride = this._stride, e3._fields = /* @__PURE__ */ new Map(), this._fields.forEach((t3, i) => e3._fields.set(i, t3)), e3.BufferType = this.BufferType, e3;
  }
  get stride() {
    return this._stride;
  }
  get fields() {
    return this._fields;
  }
};
function Q2() {
  return new P2();
}
var R3 = class {
  constructor(e3) {
    this.fields = new Array(), e3.fields.forEach((e4, t3) => {
      const i = { ...e4, constructor: W2(e4.constructor) };
      this.fields.push([t3, i]);
    }), this.stride = e3.stride;
  }
};
var S2 = [f, y2, o, T, d, E, B, b, U, F, x, A, I, j, O, g, w, L, V, M, v, S, k, q, z, C, D, G, H, J, K, N, P, Q, R, W];
function W2(e3) {
  return `${e3.ElementType}_${e3.ElementCount}`;
}
function X(e3) {
  return Y.get(e3);
}
var Y = /* @__PURE__ */ new Map();
S2.forEach((e3) => Y.set(W2(e3), e3));

export {
  t2 as t,
  P2 as P,
  Q2 as Q,
  R3 as R,
  n2 as n,
  a2 as a,
  e2 as e
};
//# sourceMappingURL=chunk-2AOVWXAQ.js.map
