import {
  c as c8
} from "./chunk-C7T2CCN3.js";
import {
  f as f5,
  m as m5,
  o as o3
} from "./chunk-DGQSLK46.js";
import {
  d as d2
} from "./chunk-EOQ2S5UA.js";
import {
  U,
  d,
  j,
  w as w2,
  z as z3
} from "./chunk-WBXDB33U.js";
import {
  h
} from "./chunk-QL52LNOM.js";
import {
  c as c7
} from "./chunk-V6DIT5FJ.js";
import {
  a as a7,
  c as c6,
  n as n4
} from "./chunk-YJPRACXY.js";
import {
  b as b2
} from "./chunk-GVMCGYZ6.js";
import {
  e as e4,
  r as r3
} from "./chunk-JHV6OBEB.js";
import {
  F,
  M,
  P as P2,
  P2 as P3,
  V,
  b,
  k,
  nt,
  q,
  w,
  x
} from "./chunk-274P3DJ3.js";
import {
  a as a6,
  r as r2
} from "./chunk-HHDWMGJ3.js";
import {
  i as i3
} from "./chunk-WHHIH5YU.js";
import {
  f as f4
} from "./chunk-MEDXVTKR.js";
import {
  a as a5
} from "./chunk-5LMH6D7V.js";
import {
  c as c5,
  l as l3,
  t,
  u as u4
} from "./chunk-BZLHV37L.js";
import {
  i as i2,
  i2 as i4
} from "./chunk-V6V3WWJF.js";
import {
  A as A2,
  E,
  N,
  c as c4,
  g,
  o as o2,
  u as u3,
  z as z2
} from "./chunk-VYMBX5H5.js";
import {
  Q,
  c as c3,
  f as f3,
  m as m4,
  u as u2
} from "./chunk-HWUOAPTX.js";
import {
  e as e3
} from "./chunk-QHCKOBU7.js";
import {
  e as e2
} from "./chunk-K2OZ6WVC.js";
import {
  J
} from "./chunk-2LC2762W.js";
import {
  o
} from "./chunk-DTZUXJMD.js";
import {
  D,
  I,
  O as O2,
  c as c2,
  f,
  p as p3
} from "./chunk-XLOINTMG.js";
import {
  f as f2,
  l as l2
} from "./chunk-T7F6Q6JJ.js";
import {
  O
} from "./chunk-YDTPM7OQ.js";
import {
  _ as _2,
  a as a4,
  n as n2,
  r
} from "./chunk-75XOUSSS.js";
import {
  p as p2
} from "./chunk-XCKT47LJ.js";
import {
  P
} from "./chunk-PZ5RULLK.js";
import {
  n as n3
} from "./chunk-LTPHDYPK.js";
import {
  e
} from "./chunk-3OVERDFX.js";
import {
  z
} from "./chunk-H74Q4SYB.js";
import {
  a as a3,
  l
} from "./chunk-2OFHDVO5.js";
import {
  m as m3
} from "./chunk-5UPBUJPC.js";
import {
  _,
  c
} from "./chunk-AXZMNHTN.js";
import {
  G,
  Rt
} from "./chunk-V2H77UEV.js";
import {
  m,
  m2
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  A,
  a as a2,
  p,
  s as s2,
  u3 as u
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  n
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/geometry/support/meshErrors.js
var t2 = "Mesh must be loaded before applying operations";
var e5 = "Provided component is not part of the list of components";
var n5 = "Expected polygon to be a Polygon instance";
var s3 = "Expected location to be a Point instance";
var i5 = class extends s {
  constructor() {
    super("invalid-input:location", s3);
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/geographicUtils.js
function t3(o4, t4, i6, a9) {
  if (void 0 !== a9) {
    m2(o4(), "option: geographic", { replacement: "Use mesh `vertexSpace` and spatial reference to control how operations are performed instead.", version: "4.30", warnOnce: true });
    const c10 = "local" === t4.type;
    if (!t(t4) || a9 === c10) return i6.isGeographic || i6.isWebMercator && a9;
    o4().warnOnce(`Specifying the 'geographic' parameter (${a9}) for a Mesh vertex space of type "${t4.type}" is not supported. This parameter will be ignored.`);
  }
  switch (t4.type) {
    case "georeferenced":
      return i6.isGeographic;
    case "local":
      return i6.isGeographic || i6.isWebMercator;
  }
}

// node_modules/@arcgis/core/geometry/support/meshUtils/centerAt.js
var g2 = () => i.getLogger("esri.geometry.support.meshUtils.centerAt");
function u5(e6, t4, r4) {
  if (!e6.vertexAttributes?.position) return;
  const { vertexSpace: i6 } = e6, o4 = r4?.origin ?? e6.origin, n6 = t3(g2, i6, o4.spatialReference, r4?.geographic);
  t(i6) ? x2(e6, t4, o4) : n6 ? v(e6, t4, o4) : R(e6, t4, o4);
}
function x2(e6, o4, s4) {
  const { vertexSpace: c10 } = e6;
  if (!t(c10)) return;
  const f8 = h2, m8 = b3;
  if (!i3(o4, m8, e6.spatialReference)) return void k(g2(), o4.spatialReference, e6.spatialReference, b);
  if (!i3(s4, f8, e6.spatialReference)) {
    const t4 = e6.origin;
    return f8[0] = t4.x, f8[1] = t4.y, f8[2] = t4.z, void k(g2(), s4.spatialReference, e6.spatialReference, b);
  }
  const u9 = c4(A3, m8, f8);
  c10.origin = u3(n2(), c10.origin, u9);
}
function v(e6, t4, r4) {
  const i6 = r(r4.x, r4.y, r4.z ?? 0), n6 = q(e6, new i4({ origin: i6 }));
  if (!n6) return;
  const a9 = r(t4.x, t4.y, t4.z ?? 0), f8 = q({ vertexAttributes: n6, spatialReference: e6.spatialReference, vertexSpace: new i4({ origin: a9 }) }, i2.absolute);
  if (!f8) return;
  const { position: p6, normal: l5, tangent: g5 } = f8;
  e6.vertexAttributes.position = p6, e6.vertexAttributes.normal = l5, e6.vertexAttributes.tangent = g5, e6.vertexAttributesChanged();
}
function R(e6, t4, r4) {
  const i6 = h2, o4 = b3;
  if (i3(t4, o4, e6.spatialReference)) {
    if (!i3(r4, i6, e6.spatialReference)) {
      const t5 = e6.origin;
      return i6[0] = t5.x, i6[1] = t5.y, i6[2] = t5.z, void k(g2(), r4.spatialReference, e6.spatialReference, b);
    }
    j2(e6.vertexAttributes.position, o4, i6), e6.vertexAttributesChanged();
  } else k(g2(), t4.spatialReference, e6.spatialReference, b);
}
function j2(e6, t4, r4) {
  if (e6) for (let i6 = 0; i6 < e6.length; i6 += 3) for (let o4 = 0; o4 < 3; o4++) e6[i6 + o4] += t4[o4] - r4[o4];
}
var b3 = n2();
var h2 = n2();
var A3 = n2();

// node_modules/@arcgis/core/geometry/support/meshUtils/extent.js
function l4(r4) {
  const { spatialReference: f8, vertexSpace: l5, untransformedBounds: d5 } = r4, g5 = f3(d5, u6);
  if (t(l5) && r4.transform && r2(g5, g5, r4.transform.localMatrix), "georeferenced" === l5.type) {
    const r5 = l5.origin;
    return r5 && a6(g5, g5, r5), c3(m4(g5), f8);
  }
  const y3 = a5(f8), B2 = l5.origin;
  if (!J(y3, f8)) {
    const [r5, t4, e6] = B2;
    return new z({ xmin: r5, ymin: t4, zmin: e6, xmax: r5, ymax: t4, zmax: e6, spatialReference: f8 });
  }
  return f4(f8, B2, x3, y3), r2(g5, g5, x3), o(g5, y3, 0, g5, f8, 0), c3(m4(g5), f8);
}
var x3 = e2();
var u6 = e3(24);

// node_modules/@arcgis/core/geometry/support/meshUtils/loadExternal.js
async function u7(t4, s4, r4) {
  switch (s4.source.type) {
    case "client":
    case "service":
      return m6(t4, s4, r4);
    case "loadable":
      return s4.source.load(t4, r4);
    default:
      n(s4.source);
  }
}
async function m6(e6, o4, n6) {
  const { source: i6 } = o4, { loadGLTFMesh: a9 } = await p(import("./loadGLTFMesh-AJKH3W6I.js"), n6), l5 = await p4(i6, n6);
  s2(n6);
  const u9 = a9(new _({ x: 0, y: 0, z: 0, spatialReference: e6.spatialReference }), l5.url, { resolveFile: f6(l5), signal: n6?.signal, expectedType: l5.type, unitConversionDisabled: o4.unitConversionDisabled });
  u9.then(() => l5.dispose(), () => l5.dispose());
  const { mesh: { vertexAttributes: m8, components: d5 }, meta: { isDracoDecompressed: h5 } } = await u9;
  if (h5) throw new s("mesh-load-external:draco-not-supported", "The provided mesh uses Draco compression which is not supported.");
  e6.vertexAttributes = m8, e6.components = d5;
}
function f6(e6) {
  const t4 = Rt(e6.url);
  return (s4) => {
    const r4 = G(s4, t4, t4), o4 = r4 ? r4.replace(/^ *\.\//, "") : null;
    return (o4 ? e6.files.get(o4) : null) ?? s4;
  };
}
async function p4(e6, s4) {
  switch (e6.type) {
    case "client":
      return Array.isArray(e6.files) ? w3(e6.files) : h3(e6.files);
    case "service":
      return y(e6.assets, s4);
    default:
      throw new s("mesh-load-external:invalid-source", "Invalid source type");
  }
}
async function d3(e6, t4) {
  const { parts: s4, assetMimeType: o4, assetName: n6 } = e6;
  if (1 === s4.length) return new M2(s4[0].partUrl);
  const i6 = await e6.toBlob(t4);
  return s2(t4), M2.fromBlob(i6, R2(n6, o4));
}
function h3(e6) {
  return M2.fromBlob(e6, R2(e6.name, e6.type));
}
function w3(e6) {
  if (!e6.length) throw new s("mesh-load-external:missing-assets", "There must be at least one file to load");
  return j3(e6.map((e7) => ({ name: e7.name, mimeType: e7.type, source: h3(e7) })));
}
async function y(e6, s4) {
  if (!e6.length) throw new s("mesh-load-external:missing-assets", "There must be at least one file to load");
  const a9 = await A(e6.map(async (e7) => {
    const t4 = await d3(e7);
    return s2(s4), { name: e7.assetName, mimeType: e7.assetMimeType, source: t4 };
  }));
  if (a2(s4)) throw a9.forEach((e7) => e7.source.dispose()), u();
  return j3(a9);
}
var g3 = /^model\/gltf\+json$/;
var b4 = /^model\/gltf-binary$/;
var v2 = /\.gltf$/i;
var x4 = /\.glb$/i;
function T({ mimeType: e6, source: t4, name: s4 }) {
  return g3.test(e6) || v2.test(s4) ? { url: t4.url, type: "gltf" } : b4.test(e6) || x4.test(s4) ? { url: t4.url, type: "glb" } : null;
}
function j3(e6) {
  const s4 = /* @__PURE__ */ new Map();
  let r4 = null, o4 = null;
  for (const t4 of e6) {
    const { source: e7, name: n7 } = t4;
    r4 ??= T(t4), "ESRI3DO_NORM.glb" === n7 && (o4 = T(t4)), s4.set(n7, e7.url), e7.files.forEach((e8, t5) => s4.set(t5, e8));
  }
  const n6 = o4 ?? r4;
  if (null == n6) throw new s("mesh-load-external:missing-files", "Missing files to load external mesh source");
  return new M2(n6.url, () => e6.forEach(({ source: e7 }) => e7.dispose()), s4, n6.type);
}
var M2 = class _M {
  constructor(e6, t4 = () => {
  }, s4 = /* @__PURE__ */ new Map(), r4) {
    this.url = e6, this.dispose = t4, this.files = s4, this.type = r4;
  }
  static fromBlob(e6, t4) {
    const s4 = URL.createObjectURL(e6);
    return new _M(s4, () => URL.revokeObjectURL(s4), void 0, t4);
  }
};
function R2(e6, t4) {
  return g3.test(t4) || v2.test(e6) ? "gltf" : b4.test(t4) || v2.test(e6) ? "glb" : void 0;
}

// node_modules/@arcgis/core/geometry/support/meshUtils/Metadata.js
var a8 = class extends f2 {
  constructor(e6) {
    super(e6), this.externalSources = new O(), this._explicitDisplaySource = null, this.georeferenced = false, this.addHandles(a3(() => this.externalSources, "after-remove", ({ item: e7 }) => {
      e7 === this._explicitDisplaySource && (this._explicitDisplaySource = null);
    }, { sync: true, onListenerRemove: () => this._explicitDisplaySource = null }));
  }
  get displaySource() {
    return this._explicitDisplaySource ?? this._implicitDisplaySource;
  }
  set displaySource(e6) {
    if (null != e6 && !o3(e6)) throw new Error("Cannot use this source for display: it is not in a supported format.");
    this._explicitDisplaySource = e6, e6 && this.externalSources.every((r4) => !m5(r4, e6)) && this.externalSources.add(e6);
  }
  clearSources() {
    this.externalSources.removeAll();
  }
  getExternalSourcesOnService(e6) {
    return this.externalSources.items.filter((r4) => f5(r4, e6));
  }
  get _implicitDisplaySource() {
    return this.externalSources.find(o3);
  }
};
__decorate([m()], a8.prototype, "externalSources", void 0), __decorate([m()], a8.prototype, "displaySource", null), __decorate([m()], a8.prototype, "_implicitDisplaySource", null), __decorate([m()], a8.prototype, "_explicitDisplaySource", void 0), __decorate([m()], a8.prototype, "georeferenced", void 0), a8 = __decorate([a("esri.geometry.support.meshUtils.Metadata")], a8);

// node_modules/@arcgis/core/geometry/support/meshUtils/primitives.js
function c9() {
  const { faceDescriptions: t4, faceVertexOffsets: e6, uvScales: r4 } = F2, n6 = 4 * t4.length, o4 = new Float64Array(3 * n6), s4 = new Float32Array(3 * n6), a9 = new Float32Array(2 * n6), i6 = new Uint32Array(2 * t4.length * 3);
  let l5 = 0, c10 = 0, f8 = 0, u9 = 0;
  for (let h5 = 0; h5 < t4.length; h5++) {
    const n7 = t4[h5], p6 = l5 / 3;
    for (const t5 of e6) i6[u9++] = p6 + t5;
    const m8 = n7.corners;
    for (let t5 = 0; t5 < 4; t5++) {
      const e7 = m8[t5];
      let i7 = 0;
      a9[f8++] = 0.25 * r4[t5][0] + n7.uvOrigin[0], a9[f8++] = n7.uvOrigin[1] - 0.25 * r4[t5][1];
      for (let t6 = 0; t6 < 3; t6++) 0 !== n7.axis[t6] ? (o4[l5++] = 0.5 * n7.axis[t6], s4[c10++] = n7.axis[t6]) : (o4[l5++] = 0.5 * e7[i7++], s4[c10++] = 0);
    }
  }
  return { position: o4, normal: s4, uv: a9, faces: i6 };
}
function f7(t4, e6) {
  const r4 = t4.components[0], n6 = r4.faces, s4 = b5[e6], a9 = 6 * s4, i6 = new Array(6), l5 = new Array(n6.length - 6);
  let c10 = 0, f8 = 0;
  for (let o4 = 0; o4 < n6.length; o4++) o4 >= a9 && o4 < a9 + 6 ? i6[c10++] = n6[o4] : l5[f8++] = n6[o4];
  if (null != t4.vertexAttributes.uv) {
    const e7 = new Float32Array(t4.vertexAttributes.uv), r5 = 4 * s4 * 2, n7 = [0, 1, 1, 1, 1, 0, 0, 0];
    for (let t5 = 0; t5 < n7.length; t5++) e7[r5 + t5] = n7[t5];
    t4.vertexAttributes.uv = e7;
  }
  return t4.components = [new h({ faces: i6, material: r4.material }), new h({ faces: l5 })], t4;
}
function u8(t4 = 0) {
  const e6 = Math.round(8 * 2 ** t4), r4 = 2 * e6, n6 = (e6 - 1) * (r4 + 1) + 2 * r4, o4 = new Float64Array(3 * n6), s4 = new Float32Array(3 * n6), a9 = new Float32Array(2 * n6), i6 = new Uint32Array(3 * ((e6 - 1) * r4 * 2));
  let l5 = 0, c10 = 0, f8 = 0, u9 = 0;
  for (let h5 = 0; h5 <= e6; h5++) {
    const t5 = h5 / e6 * Math.PI + 0.5 * Math.PI, n7 = Math.cos(t5), p6 = Math.sin(t5);
    O3[2] = p6;
    const m8 = 0 === h5 || h5 === e6, w5 = m8 ? r4 - 1 : r4;
    for (let v4 = 0; v4 <= w5; v4++) {
      const t6 = v4 / w5 * 2 * Math.PI;
      O3[0] = -Math.sin(t6) * n7, O3[1] = Math.cos(t6) * n7;
      for (let e7 = 0; e7 < 3; e7++) o4[l5] = 0.5 * O3[e7], s4[l5] = O3[e7], ++l5;
      a9[c10++] = (v4 + (m8 ? 0.5 : 0)) / r4, a9[c10++] = h5 / e6, 0 !== h5 && v4 !== r4 && (h5 !== e6 && (i6[f8++] = u9, i6[f8++] = u9 + 1, i6[f8++] = u9 - r4), 1 !== h5 && (i6[f8++] = u9, i6[f8++] = u9 - r4, i6[f8++] = u9 - r4 - 1)), u9++;
    }
  }
  return { position: o4, normal: s4, uv: a9, faces: i6 };
}
function h4(t4 = 0) {
  const e6 = 5, r4 = Math.round(16 * 2 ** t4), n6 = (e6 - 1) * (r4 + 1) + 2 * r4, o4 = new Float64Array(3 * n6), s4 = new Float32Array(3 * n6), a9 = new Float32Array(2 * n6), i6 = new Uint32Array(3 * (4 * r4));
  let l5 = 0, c10 = 0, f8 = 0, u9 = 0, h5 = 0;
  for (let p6 = 0; p6 <= e6; p6++) {
    const t5 = 0 === p6 || p6 === e6, n7 = p6 <= 1 || p6 >= e6 - 1, m8 = 2 === p6 || 4 === p6, w5 = t5 ? r4 - 1 : r4;
    for (let v4 = 0; v4 <= w5; v4++) {
      const g5 = v4 / w5 * 2 * Math.PI, A5 = t5 ? 0 : 0.5;
      O3[0] = A5 * Math.sin(g5), O3[1] = A5 * -Math.cos(g5), O3[2] = p6 <= 2 ? 0.5 : -0.5;
      for (let t6 = 0; t6 < 3; t6++) o4[l5++] = O3[t6], s4[c10++] = n7 ? 2 === t6 ? p6 <= 1 ? 1 : -1 : 0 : 2 === t6 ? 0 : O3[t6] / A5;
      a9[f8++] = (v4 + (t5 ? 0.5 : 0)) / r4, a9[f8++] = p6 <= 1 ? 1 * p6 / 3 : p6 <= 3 ? 1 * (p6 - 2) / 3 + 1 / 3 : 1 * (p6 - 4) / 3 + 2 / 3, m8 || 0 === p6 || v4 === r4 || (p6 !== e6 && (i6[u9++] = h5, i6[u9++] = h5 + 1, i6[u9++] = h5 - r4), 1 !== p6 && (i6[u9++] = h5, i6[u9++] = h5 - r4, i6[u9++] = h5 - r4 - 1)), h5++;
    }
  }
  return { position: o4, normal: s4, uv: a9, faces: i6 };
}
function p5(t4, e6) {
  const r4 = "number" == typeof e6 ? e6 : null != e6 ? e6.width : 1, n6 = "number" == typeof e6 ? e6 : null != e6 ? e6.height : 1;
  switch (t4) {
    case "up":
    case "down":
      return { width: r4, depth: n6 };
    case "north":
    case "south":
      return { width: r4, height: n6 };
    case "east":
    case "west":
      return { depth: r4, height: n6 };
  }
}
function m7(t4) {
  const e6 = A4.facingAxisOrderSwap[t4], r4 = A4.position, n6 = A4.normal, o4 = new Float64Array(r4.length), s4 = new Float32Array(n6.length);
  let a9 = 0;
  for (let i6 = 0; i6 < 4; i6++) {
    const t5 = a9;
    for (let i7 = 0; i7 < 3; i7++) {
      const l5 = e6[i7], c10 = Math.abs(l5) - 1, f8 = l5 >= 0 ? 1 : -1;
      o4[a9] = r4[t5 + c10] * f8, s4[a9] = n6[t5 + c10] * f8, a9++;
    }
  }
  return { position: o4, normal: s4, uv: new Float32Array(A4.uv), faces: new Uint32Array(A4.faces), isPlane: true };
}
var w4 = 1;
var v3 = 2;
var g4 = 3;
var A4 = { position: [-0.5, -0.5, 0, 0.5, -0.5, 0, 0.5, 0.5, 0, -0.5, 0.5, 0], normal: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], uv: [0, 1, 1, 1, 1, 0, 0, 0], faces: [0, 1, 2, 0, 2, 3], facingAxisOrderSwap: { east: [g4, w4, v3], west: [-g4, -w4, v3], north: [-w4, g4, v3], south: [w4, -g4, v3], up: [w4, v3, g4], down: [w4, -v3, -g4] } };
function x5(t4, e6, r4) {
  t4.isPlane || y2(t4), M3(t4, d4(r4?.size, r4?.unit, e6.spatialReference));
  const n6 = l3(e6, r4), l5 = e6.spatialReference.isGeographic ? l3(e6) : n6, c10 = q({ vertexAttributes: t4, vertexSpace: l5, spatialReference: e6.spatialReference }, n6, { allowBufferReuse: true });
  return { vertexAttributes: new c7({ ...c10, uv: t4.uv }), vertexSpace: n6, components: [new h({ faces: t4.faces, material: r4?.material || null })], spatialReference: e6.spatialReference };
}
function y2(t4) {
  for (let e6 = 0; e6 < t4.position.length; e6 += 3) t4.position[e6 + 2] += 0.5;
}
function d4(t4, e6, r4) {
  const n6 = nt(e6, r4);
  if (null == t4 && 1 === n6) return null;
  if (null == t4) return [n6, n6, n6];
  if ("number" == typeof t4) {
    const e7 = t4 * n6;
    return [e7, e7, e7];
  }
  return [null != t4.width ? t4.width * n6 : n6, null != t4.depth ? t4.depth * n6 : n6, null != t4.height ? t4.height * n6 : n6];
}
function M3(t4, n6) {
  if (null != n6) {
    S[0] = n6[0], S[4] = n6[1], S[8] = n6[2];
    for (let r4 = 0; r4 < t4.position.length; r4 += 3) {
      for (let e6 = 0; e6 < 3; e6++) O3[e6] = t4.position[r4 + e6];
      N(O3, O3, S);
      for (let e6 = 0; e6 < 3; e6++) t4.position[r4 + e6] = O3[e6];
    }
    if (n6[0] !== n6[1] || n6[1] !== n6[2]) {
      S[0] = 1 / n6[0], S[4] = 1 / n6[1], S[8] = 1 / n6[2];
      for (let n7 = 0; n7 < t4.normal.length; n7 += 3) {
        for (let e6 = 0; e6 < 3; e6++) O3[e6] = t4.normal[n7 + e6];
        N(O3, O3, S), A2(O3, O3);
        for (let e6 = 0; e6 < 3; e6++) t4.normal[n7 + e6] = O3[e6];
      }
    }
  }
}
var F2 = { faceDescriptions: [{ axis: [0, -1, 0], uvOrigin: [0, 0.625], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [1, 0, 0], uvOrigin: [0.25, 0.625], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [0, 1, 0], uvOrigin: [0.5, 0.625], corners: [[1, -1], [-1, -1], [-1, 1], [1, 1]] }, { axis: [-1, 0, 0], uvOrigin: [0.75, 0.625], corners: [[1, -1], [-1, -1], [-1, 1], [1, 1]] }, { axis: [0, 0, 1], uvOrigin: [0, 0.375], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [0, 0, -1], uvOrigin: [0, 0.875], corners: [[-1, 1], [1, 1], [1, -1], [-1, -1]] }], uvScales: [[0, 0], [1, 0], [1, 1], [0, 1]], faceVertexOffsets: [0, 1, 2, 0, 2, 3] };
var b5 = { south: 0, east: 1, north: 2, west: 3, up: 4, down: 5 };
var O3 = n2();
var S = e();

// node_modules/@arcgis/core/geometry/support/meshUtils/rotate.js
var O4 = () => i.getLogger("esri.geometry.support.meshUtils.rotate");
function B(t4, e6, r4) {
  if (!t4.vertexAttributes?.position || 0 === e6[3]) return;
  const { spatialReference: o4, vertexSpace: i6 } = t4, n6 = r4?.origin ?? t4.origin, s4 = r4?.geographic, a9 = t3(O4, i6, o4, s4);
  c5(t4) ? G2(t4, e6, n6) : a9 ? H(t4, e6, n6) : I2(t4, e6, n6);
}
function G2(t4, e6, r4) {
  t4.transform ??= new d2();
  const { vertexSpace: l5, transform: c10, spatialReference: f8 } = t4, [u9, x6, h5] = l5.origin, R3 = new _({ x: u9, y: x6, z: h5, spatialReference: f8 }), d5 = K;
  if (R3.equals(r4)) o2(d5, 0, 0, 0);
  else if (!P3(d5, r4, t4)) return void k(O4(), r4.spatialReference, f8, b);
  b2(Z, w2(e6), z3(e6));
  const S2 = D(N2, Z, a4, _2, d5), { localMatrix: U2 } = c10, q3 = c2(N2, S2, U2);
  c10.scale = O2(n2(), q3), f(q3, q3, z2(K, c10.scale));
  const z5 = c10.rotationAxis;
  c10.rotation = d(q3), 0 === c10.rotationAngle && (c10.rotationAxis = z5), c10.translation = I(n2(), q3);
}
function H(t4, r4, o4) {
  const i6 = t4.spatialReference, n6 = a5(i6), s4 = Y;
  if (!i3(o4, s4, n6) && (k(O4(), o4.spatialReference, n6, "Falling back to mesh origin"), !i3(t4.origin, s4, n6))) return void k(O4(), t4.origin.spatialReference, n6);
  const a9 = t4.vertexAttributes.position, l5 = t4.vertexAttributes.normal, c10 = t4.vertexAttributes.tangent, m8 = new Float64Array(a9.length), f8 = null != l5 ? new Float32Array(l5.length) : null, p6 = null != c10 ? new Float32Array(c10.length) : null;
  f4(n6, s4, W, n6), n3(X, W);
  const g5 = Q2;
  N(w2(Q2), w2(r4), X), g5[3] = r4[3], V(a9, i6, m8, n6) && (null == l5 || null == f8 || w(l5, a9, i6, m8, n6, f8)) && (null == c10 || null == p6 || F(c10, a9, i6, m8, n6, p6)) ? (J2(m8, g5, 3, s4), x(m8, n6, a9, i6) && (null == l5 || null == f8 || (J2(f8, g5, 3), M(f8, a9, i6, m8, n6, l5))) && (null == c10 || null == p6 || (J2(p6, g5, 4), P2(p6, a9, i6, m8, n6, c10))) ? t4.vertexAttributesChanged() : k(O4(), n6, i6)) : k(O4(), i6, n6);
}
function I2(t4, e6, r4) {
  const o4 = Y;
  if (!i3(r4, o4, t4.spatialReference)) {
    const e7 = t4.origin;
    return o4[0] = e7.x, o4[1] = e7.y, o4[2] = e7.z, void k(O4(), r4.spatialReference, t4.spatialReference, b);
  }
  J2(t4.vertexAttributes.position, e6, 3, o4), J2(t4.vertexAttributes.normal, e6, 3), J2(t4.vertexAttributes.tangent, e6, 4), t4.vertexAttributesChanged();
}
function J2(t4, e6, r4, o4 = a4) {
  if (null != t4) {
    p3(W, z3(e6), w2(e6));
    for (let e7 = 0; e7 < t4.length; e7 += r4) {
      for (let r5 = 0; r5 < 3; r5++) K[r5] = t4[e7 + r5] - o4[r5];
      E(K, K, W);
      for (let r5 = 0; r5 < 3; r5++) t4[e7 + r5] = K[r5] + o4[r5];
    }
  }
}
var K = n2();
var N2 = e2();
var Q2 = j();
var W = e2();
var X = e();
var Y = n2();
var Z = e4();

// node_modules/@arcgis/core/geometry/support/meshUtils/scale.js
var k2 = () => i.getLogger("esri.geometry.support.meshUtils.scale");
function q2(e6, t4, r4) {
  if (!e6.vertexAttributes?.position) return;
  const { vertexSpace: o4, spatialReference: i6 } = e6, n6 = r4?.origin ?? e6.origin, s4 = r4?.geographic, a9 = t3(k2, o4, i6, s4);
  c5(e6) ? z4(e6, t4, n6) : a9 ? L(e6, t4, n6) : M4(e6, t4, n6);
}
function z4(e6, s4, f8) {
  e6.transform ??= new d2();
  const { vertexSpace: u9, transform: x6, spatialReference: h5 } = e6, [A5, d5, y3] = u9.origin, w5 = new _({ x: A5, y: d5, z: y3, spatialReference: h5 }), F3 = T2;
  if (w5.equals(f8)) o2(F3, 0, 0, 0);
  else if (!P3(F3, f8, e6)) return void k(k2(), f8.spatialReference, h5, b);
  const S2 = o2(V2, s4, s4, s4), U2 = D(D2, r3, a4, S2, F3), { localMatrix: q3 } = x6, z5 = c2(D2, U2, q3);
  x6.scale = O2(n2(), z5), f(z5, z5, z2(T2, x6.scale));
  const L2 = x6.rotationAxis;
  x6.rotation = d(z5), 0 === x6.rotationAngle && (x6.rotationAxis = L2), x6.translation = I(n2(), z5);
}
function L(e6, t4, r4) {
  const o4 = e6.spatialReference, i6 = a5(o4), n6 = E2;
  if (!i3(r4, n6, i6) && (k(k2(), r4.spatialReference, i6, "Falling back to mesh origin"), !i3(e6.origin, n6, i6))) return void k(k2(), e6.origin.spatialReference, i6);
  const s4 = e6.vertexAttributes.position, a9 = e6.vertexAttributes.normal, l5 = e6.vertexAttributes.tangent, c10 = new Float64Array(s4.length), f8 = null != a9 ? new Float32Array(a9.length) : null, m8 = null != l5 ? new Float32Array(l5.length) : null;
  V(s4, o4, c10, i6) && (null == a9 || null == f8 || w(a9, s4, o4, c10, i6, f8)) && (null == l5 || null == m8 || F(l5, s4, o4, c10, i6, m8)) ? (P4(c10, t4, n6), x(c10, i6, s4, o4) && (null == a9 || null == f8 || M(f8, s4, o4, c10, i6, a9)) && (null == l5 || null == m8 || P2(m8, s4, o4, c10, i6, l5)) ? e6.vertexAttributesChanged() : k(k2(), i6, o4)) : k(k2(), o4, i6);
}
function M4(e6, t4, r4) {
  const o4 = E2;
  if (!i3(r4, o4, e6.spatialReference)) {
    const t5 = e6.origin;
    return o4[0] = t5.x, o4[1] = t5.y, o4[2] = t5.z, void k(k2(), r4.spatialReference, e6.spatialReference, b);
  }
  P4(e6.vertexAttributes.position, t4, o4), e6.vertexAttributesChanged();
}
function P4(e6, t4, r4 = a4) {
  if (e6) for (let o4 = 0; o4 < e6.length; o4 += 3) {
    for (let t5 = 0; t5 < 3; t5++) T2[t5] = e6[o4 + t5] - r4[t5];
    g(T2, T2, t4);
    for (let t5 = 0; t5 < 3; t5++) e6[o4 + t5] = T2[t5] + r4[t5];
  }
}
var T2 = n2();
var V2 = n2();
var D2 = e2();
var E2 = n2();

// node_modules/@arcgis/core/geometry/Mesh.js
var Q3;
var X2 = { base: null, key: "type", defaultKeyValue: "georeferenced", typeMap: { georeferenced: i2, local: i4 } };
var Y2 = Q3 = class extends l2(p2(m3(c))) {
  constructor(e6) {
    super(e6), this.components = null, this.vertexSpace = new i2(), this.transform = null, this.metadata = new a8(), this.hasZ = true, this.hasM = false, this.vertexAttributes = new c7(), this.type = "mesh";
  }
  initialize() {
    (0 === this.metadata.externalSources.length || this.vertexAttributes.position.length) && (this.loadStatus = "loaded"), this.when(() => {
      this.addHandles(l(() => ({ vertexAttributes: this.vertexAttributes, components: this.components?.map((e6) => e6.clone()) }), () => this._clearSources(), { once: true, sync: true }));
    });
  }
  get hasExtent() {
    return this.loaded ? this.vertexAttributes.position.length > 0 && (!this.components || this.components.length > 0) : null != this.metadata.displaySource?.extent;
  }
  get _transformedExtent() {
    const { spatialReference: e6, vertexSpace: t4 } = this, r4 = this;
    return l4({ get transform() {
      return r4.transform;
    }, vertexSpace: t4, spatialReference: e6, untransformedBounds: this._untransformedBounds });
  }
  get _untransformedBounds() {
    const { vertexAttributes: { position: e6 }, components: t4 } = this;
    return 0 === e6.length || 0 === t4?.length ? u2(Q) : m4(e6);
  }
  get origin() {
    const e6 = u4(this.vertexSpace, this.spatialReference);
    if (null != e6) return e6;
    const { center: t4, zmin: r4 } = this._transformedExtent;
    return new _({ x: t4.x, y: t4.y, z: r4, spatialReference: this.spatialReference });
  }
  get extent() {
    return this.loaded || null == this.metadata?.displaySource?.extent ? this._transformedExtent : this.metadata.displaySource.extent.clone();
  }
  addComponent(e6) {
    this._checkIfLoaded("addComponent()") && (this.components || (this.components = []), this.components.push(h.from(e6)), this.notifyChange("components"));
  }
  removeComponent(e6) {
    if (this._checkIfLoaded("removeComponent()")) {
      if (this.components) {
        const t4 = this.components.indexOf(e6);
        if (-1 !== t4) return this.components.splice(t4, 1), void this.notifyChange("components");
      }
      i.getLogger(this).error("removeComponent()", e5);
    }
  }
  rotate(e6, t4, r4, o4) {
    return U(e6, t4, r4, $), B(this, $, o4), this;
  }
  offset(e6, t4, r4) {
    if (!this._checkIfLoaded("offset()")) return this;
    const { vertexSpace: o4, vertexAttributes: s4 } = this, n6 = s4?.position;
    if (!n6) return this;
    if (t(o4)) {
      const [s5, n7, i6] = o4.origin;
      o4.origin = r(s5 + e6, n7 + t4, i6 + r4);
    } else {
      for (let o5 = 0; o5 < n6.length; o5 += 3) n6[o5] += e6, n6[o5 + 1] += t4, n6[o5 + 2] += r4;
      this.vertexAttributesChanged();
    }
    return this;
  }
  scale(e6, t4) {
    return this._checkIfLoaded("scale()") ? (q2(this, e6, t4), this) : this;
  }
  centerAt(e6, t4) {
    return this._checkIfLoaded("centerAt()") ? (u5(this, e6, t4), this) : this;
  }
  load(e6) {
    const { metadata: { displaySource: t4 } } = this;
    return t4 && this.addResolvingPromise(u7(this, t4, e6)), Promise.resolve(this);
  }
  addExternalSources(e6) {
    this.metadata.externalSources.addMany(e6);
  }
  updateDisplaySource(e6) {
    this.metadata.displaySource = e6;
  }
  clone(e6) {
    return super.clone(c6(a7(e6)));
  }
  cloneShallow() {
    return new Q3({ components: this.components, spatialReference: this.spatialReference, vertexAttributes: this.vertexAttributes, vertexSpace: this.vertexSpace.clone(), transform: this.transform, metadata: this.metadata });
  }
  vertexAttributesChanged() {
    this.notifyChange("vertexAttributes");
  }
  async toBinaryGLTF(e6) {
    const [{ toBinaryGLTF: t4 }] = await Promise.all([import("./gltfexport-KMYBUTFC.js"), this.load(e6)]);
    return s2(e6), await t4(this, e6);
  }
  get usedMemory() {
    return this.components ? this.components.reduce((e6, t4) => e6 + t4.memoryUsage, this.vertexAttributes.usedMemory) : this.vertexAttributes.usedMemory;
  }
  _clearSources() {
    this.metadata.clearSources();
  }
  _checkIfLoaded(e6) {
    return !!this.loaded || (i.getLogger(this).error(e6, t2), false);
  }
  static createBox(e6, t4) {
    if (!(e6 instanceof _)) return i.getLogger(this.prototype).error(".createBox()", s3), null;
    const r4 = new Q3(x5(c9(), e6, t4));
    return t4?.imageFace && "all" !== t4.imageFace ? f7(r4, t4.imageFace) : r4;
  }
  static createSphere(e6, t4) {
    return e6 instanceof _ ? new Q3(x5(u8(t4?.densificationFactor || 0), e6, t4)) : (i.getLogger(this.prototype).error(".createSphere()", s3), null);
  }
  static createCylinder(e6, t4) {
    return e6 instanceof _ ? new Q3(x5(h4(t4?.densificationFactor || 0), e6, t4)) : (i.getLogger(this.prototype).error(".createCylinder()", s3), null);
  }
  static createPlane(e6, t4) {
    if (!(e6 instanceof _)) return i.getLogger(this.prototype).error(".createPlane()", s3), null;
    const r4 = t4?.facing ?? "up", o4 = p5(r4, t4?.size);
    return new Q3(x5(m7(r4), e6, { ...t4, size: o4 }));
  }
  static createFromPolygon(e6, t4) {
    if (!(e6 instanceof P)) return i.getLogger(this.prototype).error(".createFromPolygon()", n5), null;
    const r4 = c8(e6);
    return new Q3({ vertexAttributes: new c7({ position: r4.position }), components: [new h({ faces: r4.faces, shading: "flat", material: t4?.material ?? null })], spatialReference: e6.spatialReference, vertexSpace: new i2() });
  }
  static async createFromGLTF(e6, t4, r4) {
    if (!(e6 instanceof _)) {
      const e7 = new i5();
      throw i.getLogger(this.prototype).error(".createfromGLTF()", e7.message), e7;
    }
    const { loadGLTFMesh: o4 } = await p(import("./loadGLTFMesh-AJKH3W6I.js"), r4);
    return new Q3((await o4(e6, t4, r4)).mesh);
  }
  static createWithExternalSource(e6, t4, r4) {
    const o4 = r4?.extent ?? null, { spatialReference: s4 } = e6, n6 = r4?.transform?.clone() ?? new d2(), i6 = l3(e6, r4), a9 = r4?.unitConversionDisabled, p6 = { source: t4, extent: o4, unitConversionDisabled: a9 }, c10 = new a8();
    return c10.externalSources.push(p6), new Q3({ metadata: c10, transform: n6, vertexSpace: i6, spatialReference: s4 });
  }
  static createIncomplete(e6, t4) {
    const { spatialReference: o4 } = e6, s4 = t4?.transform?.clone() ?? new d2(), n6 = l3(e6, t4), i6 = new Q3({ transform: s4, vertexSpace: n6, spatialReference: o4 });
    return i6.addResolvingPromise(Promise.reject(new s("mesh-incomplete", "Mesh resources are not complete"))), i6;
  }
};
__decorate([m({ type: [h], json: { write: true } })], Y2.prototype, "components", void 0), __decorate([m({ nonNullable: true, types: X2, constructOnly: true, json: { write: true }, clonable: (e6, t4) => n4(t4)?.vertexSpace ?? e6.clone(t4) })], Y2.prototype, "vertexSpace", void 0), __decorate([m({ type: d2, clonable: (e6, t4) => {
  const r4 = n4(t4);
  return r4 && "transform" in r4 ? r4.transform : e6?.clone() ?? e6;
}, json: { write: true } })], Y2.prototype, "transform", void 0), __decorate([m({ constructOnly: true, type: a8, clonable: (e6, t4) => n4(t4)?.metadata ?? e6.clone() })], Y2.prototype, "metadata", void 0), __decorate([m()], Y2.prototype, "hasExtent", null), __decorate([m()], Y2.prototype, "_transformedExtent", null), __decorate([m()], Y2.prototype, "_untransformedBounds", null), __decorate([m()], Y2.prototype, "origin", null), __decorate([m({ readOnly: true, json: { read: false } })], Y2.prototype, "extent", null), __decorate([m({ readOnly: true, json: { read: false, write: true, default: true } })], Y2.prototype, "hasZ", void 0), __decorate([m({ readOnly: true, json: { read: false, write: true, default: false } })], Y2.prototype, "hasM", void 0), __decorate([m({ type: c7, nonNullable: true, json: { write: true }, clonable: (e6, t4) => n4(t4)?.vertexAttributes ?? e6.clone(t4) })], Y2.prototype, "vertexAttributes", void 0), Y2 = Q3 = __decorate([a("esri.geometry.Mesh")], Y2);
var $ = j();

export {
  Y2 as Y
};
//# sourceMappingURL=chunk-FQUT4EXK.js.map
