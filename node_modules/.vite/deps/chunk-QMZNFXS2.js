import {
  j as j2
} from "./chunk-NTNXXNRP.js";
import {
  L,
  R
} from "./chunk-GVMCGYZ6.js";
import {
  e
} from "./chunk-JHV6OBEB.js";
import {
  c as c2,
  u
} from "./chunk-RORL5XZJ.js";
import {
  c
} from "./chunk-FXT57D73.js";
import {
  e as e2,
  t
} from "./chunk-QSGJ3ECU.js";
import {
  u as u2
} from "./chunk-52SEOH5H.js";
import {
  A,
  I,
  P as P2,
  Q,
  _ as _2,
  c as c3,
  g
} from "./chunk-VYMBX5H5.js";
import {
  n
} from "./chunk-75XOUSSS.js";
import {
  m as m2
} from "./chunk-3FUHCAX3.js";
import {
  P,
  y3 as y
} from "./chunk-PZ5RULLK.js";
import {
  M,
  h as h2,
  x
} from "./chunk-OPJX4KXH.js";
import {
  S,
  _,
  j
} from "./chunk-AXZMNHTN.js";
import {
  f
} from "./chunk-5T3MJDSR.js";
import {
  E,
  N2,
  ae,
  be,
  p,
  r,
  re,
  se
} from "./chunk-NMQNUPE4.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  a
} from "./chunk-QY7XKUIV.js";
import {
  N,
  h
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/views/draw/support/surfaceCoordinateSystems.js
function u3(t2, r2, e3 = null) {
  return null != e3 ? [t2, r2, e3] : [t2, r2];
}
function w(t2, r2, e3 = null) {
  return null != e3 ? { x: t2, y: r2, z: e3 } : { x: t2, y: r2 };
}
var g2 = class {
  constructor(t2) {
    this.spatialReference = t2;
  }
  mapToLocalMultiple(r2) {
    return r2.map((t2) => this.mapToLocal(t2)).filter(N);
  }
  get doUnnormalization() {
    return false;
  }
};
var R2 = class extends g2 {
  constructor(t2, a3, o = null) {
    super(a3), this._defaultZ = o, this.transform = e2(), this.transformInv = e2(), this.transform = t(t2), u2(this.transformInv, this.transform);
  }
  makeMapPoint(t2, r2) {
    return u3(t2, r2, this._defaultZ);
  }
  mapToLocal(t2) {
    return w(this.transform[0] * t2[0] + this.transform[2] * t2[1] + this.transform[4], this.transform[1] * t2[0] + this.transform[3] * t2[1] + this.transform[5]);
  }
  localToMap(t2) {
    return u3(this.transformInv[0] * t2.x + this.transformInv[2] * t2.y + this.transformInv[4], this.transformInv[1] * t2.x + this.transformInv[3] * t2.y + this.transformInv[5], this._defaultZ);
  }
};
var v = class extends g2 {
  constructor(t2, r2) {
    super(t2.spatialReference), this.view = t2, this.defaultZ = null, this.pWS = n(), this.tangentFrameUpWS = n(), this.tangentFrameRightWS = n(), this.tangentFrameForwardWS = n(), this.localFrameRightWS = n(), this.localFrameUpWS = n(), this.worldToLocalTransform = e(), this.localToWorldTransform = e(), this.scale = 1, this.scale = t2.resolution, this.referenceMapPoint = r2, this.defaultZ = r2.hasZ ? r2.z : null;
    const e3 = t2.state.camera.viewRight;
    this.view.renderCoordsHelper.toRenderCoords(this.referenceMapPoint, this.pWS), this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS, 0, this.tangentFrameRightWS), this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS, 1, this.tangentFrameUpWS), this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS, 2, this.tangentFrameForwardWS);
    const s = n();
    g(s, this.tangentFrameForwardWS, P2(e3, this.tangentFrameForwardWS)), c3(this.localFrameRightWS, e3, s), A(this.localFrameRightWS, this.localFrameRightWS), _2(this.localFrameUpWS, this.tangentFrameForwardWS, this.localFrameRightWS), R(this.worldToLocalTransform, this.localFrameRightWS, this.tangentFrameRightWS), L(this.localToWorldTransform, this.worldToLocalTransform);
  }
  get doUnnormalization() {
    return "global" === this.view.viewingMode;
  }
  makeMapPoint(t2, r2) {
    return u3(t2, r2, this.defaultZ);
  }
  mapToLocal(t2) {
    const r2 = n();
    this.view.renderCoordsHelper.toRenderCoords(new _({ x: t2[0], y: t2[1], spatialReference: this.spatialReference }), r2), Q(r2, r2, this.worldToLocalTransform);
    const e3 = this.view.renderCoordsHelper.fromRenderCoords(r2, new _({ spatialReference: this.view.spatialReference }));
    return null != e3 ? w(e3.x / this.scale, e3.y / this.scale) : null;
  }
  localToMap(t2) {
    const r2 = n();
    this.view.renderCoordsHelper.toRenderCoords(new _({ x: t2.x * this.scale, y: t2.y * this.scale, spatialReference: this.spatialReference }), r2), Q(r2, r2, this.localToWorldTransform);
    const e3 = this.view.renderCoordsHelper.fromRenderCoords(r2, new _({ spatialReference: this.view.spatialReference }));
    return null != e3 ? u3(e3.x, e3.y, this.defaultZ) : null;
  }
};
function W(t2, r2) {
  if ("2d" === t2.type) return new R2(t2.state.transform, t2.spatialReference, r2.length > 2 ? r2[2] : null);
  if ("3d" === t2.type) {
    const e3 = r2.length > 2 ? new _({ x: r2[0], y: r2[1], z: r2[2], spatialReference: t2.spatialReference }) : new _({ x: r2[0], y: r2[1], spatialReference: t2.spatialReference });
    return new v(t2, e3);
  }
  return null;
}

// node_modules/@arcgis/core/geometry/Circle.js
var f2;
var g3 = f2 = class extends P {
  constructor(e3) {
    super(e3), this.center = null, this.geodesic = false, this.numberOfPoints = 60, this.radius = 1e3, this.radiusUnit = "meters";
  }
  initialize() {
    const e3 = this.center, o = this.numberOfPoints;
    if (this.hasZ = e3?.hasZ ?? false, 0 !== this.rings.length || !e3) return;
    const c4 = N2(this.radius, this.radiusUnit, "meters"), n2 = e3.spatialReference;
    let p2, l = "geographic";
    if (n2.isWebMercator ? l = "webMercator" : (null != (n2.wkid && r[n2.wkid]) || (n2.wkt2 || n2.wkt) && be(n2.wkt2 || n2.wkt)) && (l = "projected"), this.geodesic) {
      let r2;
      switch (l) {
        case "webMercator":
          r2 = S(e3);
          break;
        case "projected":
          console.error("Creating a geodesic circle requires the center to be specified in web mercator or geographic coordinate system");
          break;
        case "geographic":
          r2 = e3;
      }
      p2 = this._createGeodesicCircle(r2, c4, o), "webMercator" === l && (p2 = j(p2));
    } else {
      let r2;
      "webMercator" === l || "projected" === l ? r2 = c4 / re(e3.spatialReference) : "geographic" === l && (r2 = se(c4, "meters", E(e3.spatialReference).radius)), p2 = this._createPlanarCircle(e3, r2, o);
    }
    this.spatialReference = p2.spatialReference, this.addRing(p2.rings[0]);
  }
  clone() {
    const { center: e3, numberOfPoints: r2, radius: t2, radiusUnit: s, geodesic: i } = this;
    return new f2({ center: e3?.clone(), numberOfPoints: r2, radius: t2, radiusUnit: s, geodesic: i });
  }
  _createGeodesicCircle(e3, r2, t2) {
    const s = [], i = [e3.x, e3.y];
    for (let o = 0; o < 360; o += 360 / t2) {
      const t3 = this.hasZ ? [0, 0, e3.z ?? 0] : [0, 0];
      j2(t3, i, o, r2, f.WGS84), s.push(t3);
    }
    return s.push(s[0]), new P({ rings: [s] });
  }
  _createPlanarCircle(e3, r2, t2) {
    const s = [], i = 2 * Math.PI / t2;
    for (let o = 0; o < t2; ++o) {
      const t3 = i * o, c4 = [e3.x + Math.cos(-t3) * r2, e3.y + Math.sin(-t3) * r2];
      this.hasZ && c4.push(e3.z ?? 0), s.push(c4);
    }
    return s.push(s[0]), new P({ spatialReference: e3.spatialReference, rings: [s] });
  }
};
__decorate([m({ type: _ })], g3.prototype, "center", void 0), __decorate([m()], g3.prototype, "geodesic", void 0), __decorate([m()], g3.prototype, "numberOfPoints", void 0), __decorate([m()], g3.prototype, "radius", void 0), __decorate([m()], g3.prototype, "radiusUnit", void 0), g3 = f2 = __decorate([a2("esri.geometry.Circle")], g3);
var b = g3;

// node_modules/@arcgis/core/views/draw/support/createUtils.js
function d(t2, e3) {
  const o = new _({ x: t2[0], y: t2[1], spatialReference: e3 });
  return t2.length > 2 && (o.z = t2[2]), o;
}
function R3(t2, e3) {
  return new m2({ points: t2, spatialReference: e3 });
}
function j3(t2, e3, o) {
  const n2 = new y({ paths: t2, spatialReference: e3 });
  return o && x(n2), n2;
}
function T(t2, n2, r2, a3 = true) {
  const l = a(t2);
  l.forEach((t3) => {
    const o = t3[0], n3 = t3[t3.length - 1];
    h(o, n3) && 1 !== t3.length || t3.push(t3[0]);
  });
  let s = new P({ rings: l, spatialReference: n2 });
  return s.rings.forEach((t3) => {
    h2(t3) || t3.reverse();
  }), r2 && x(s), a3 && !c2(s) && p(n2) && (s = u(s) || s), s;
}
function b2(e3, o, n2) {
  const r2 = o.mapToLocalMultiple(e3), a3 = [], l = { x: r2[0].x, y: r2[0].y }, s = { x: r2[1].x, y: r2[1].y }, i = Math.round(s.x - l.x), c4 = Math.round(s.y - l.y), p2 = Math.max(Math.abs(i), Math.abs(c4));
  if (n2) {
    const t2 = { x: l.x + p2, y: l.y + p2 }, e4 = { x: l.x - p2, y: l.y - p2 };
    a3.push(w(t2.x, e4.y), w(e4.x, e4.y), w(e4.x, t2.y), w(t2.x, t2.y));
  } else {
    const t2 = { x: i > 0 ? l.x + p2 : l.x - p2, y: c4 > 0 ? l.y + p2 : l.y - p2 };
    a3.push(w(l.x, l.y), w(t2.x, l.y), w(t2.x, t2.y), w(l.x, t2.y));
  }
  return P3(T([a3.map((t2) => o.localToMap(t2)).filter(N)], o.spatialReference, o.doUnnormalization, true), a3, o);
}
function U(e3, o, n2) {
  let r2 = o.mapToLocalMultiple(e3);
  if (1 === r2.length) {
    const t2 = 48, e4 = r2[0];
    r2 = [w(e4.x - t2, e4.y + t2), w(e4.x + t2, e4.y - t2), w(e4.x + t2, e4.y - t2), w(e4.x - t2, e4.y + t2)];
  }
  const a3 = [], l = { x: r2[0].x, y: r2[0].y }, s = { x: r2[1].x, y: r2[1].y };
  if (n2) {
    const t2 = Math.round(s.x - l.x), e4 = Math.round(s.y - l.y);
    a3.push(w(l.x - t2, l.y - e4), w(s.x, l.y - e4), w(s.x, s.y), w(l.x - t2, s.y));
  } else a3.push(w(l.x, l.y), w(s.x, l.y), w(s.x, s.y), w(l.x, s.y));
  return P3(T([a3.map((t2) => o.localToMap(t2)).filter(N)], o.spatialReference, o.doUnnormalization, true), a3, o);
}
function P3(t2, e3, o) {
  const n2 = z(e3[3], e3[2], o), r2 = z(e3[1], e3[2], o), a3 = z(e3[0], e3[1], o), l = z(e3[0], e3[3], o);
  return { geometry: t2, midpoints: null != n2 && null != r2 && null != a3 && null != l ? { top: n2, right: r2, bottom: a3, left: l } : null };
}
function z(t2, e3, o) {
  I2[0] = t2.x, I2[1] = t2.y, I2[2] = 0, L2[0] = e3.x, L2[1] = e3.y, L2[2] = 0, I(I2, I2, L2, 0.5), w2.x = I2[0], w2.y = L2[1], w2.z = L2[2];
  const n2 = o.localToMap(w2);
  return null != n2 ? d(n2, o.spatialReference) : null;
}
var w2 = w(0, 0, 0);
var I2 = n();
var L2 = n();
function k(t2, e3, o, r2) {
  const a3 = e3.mapToLocalMultiple(t2);
  let s = null, i = null;
  if (o) s = a3[0], i = a3[1];
  else {
    const t3 = a3[0], e4 = a3[1], o2 = Math.round(e4.x - t3.x), n2 = Math.round(e4.y - t3.y), r3 = Math.max(Math.abs(o2), Math.abs(n2));
    s = w(o2 > 0 ? t3.x + r3 / 2 : t3.x - r3 / 2, n2 > 0 ? t3.y + r3 / 2 : t3.y - r3 / 2), i = w(Math.abs(o2) > Math.abs(n2) ? s.x - r3 / 2 : s.x, Math.abs(o2) > Math.abs(n2) ? s.y : s.y - r3 / 2);
  }
  const c4 = e3.localToMap(s), p2 = e3.localToMap(i);
  if (null == c4 || null == p2) return null;
  e3.doUnnormalization && M([[c4, p2]], e3.spatialReference);
  const u4 = d(c4, e3.spatialReference), f3 = d(p2, e3.spatialReference), m3 = ae(e3.spatialReference);
  let h3 = 0;
  if (p(e3.spatialReference)) h3 = m3 * c(u4, f3);
  else {
    const t3 = s.x - i.x, e4 = s.y - i.y;
    h3 = m3 * Math.sqrt(t3 * t3 + e4 * e4) * (r2 || 1);
  }
  const R4 = new b({ center: u4, radius: h3, radiusUnit: "meters", spatialReference: e3.spatialReference });
  return { geometry: T(R4.rings, R4.spatialReference, false), center: u4, edge: f3 };
}
function v2(e3, o, n2) {
  const r2 = o.mapToLocalMultiple(e3), a3 = r2[0], l = r2[1], s = Math.round(l.x - a3.x), i = Math.round(l.y - a3.y), c4 = w(n2 ? a3.x : a3.x + s / 2, n2 ? a3.y : a3.y + i / 2), p2 = n2 ? s : s / 2, y2 = n2 ? i : i / 2, u4 = 60, f3 = [], m3 = 2 * Math.PI / u4;
  function x2(t2) {
    const e4 = Math.cos(t2), o2 = Math.sin(t2);
    return w(p2 * e4 + c4.x, y2 * o2 + c4.y);
  }
  for (let t2 = 0; t2 < u4; t2++) f3.push(x2(t2 * m3));
  f3.push(f3[0]);
  const { spatialReference: h3, doUnnormalization: M2 } = o, R4 = T([f3.map((t2) => o.localToMap(t2)).filter(N)], h3, M2, false), j4 = o.localToMap(x2(Math.PI / 2)), b3 = o.localToMap(x2(0)), U2 = o.localToMap(x2(-Math.PI / 2)), P4 = o.localToMap(x2(Math.PI));
  return { geometry: R4, midpoints: null != j4 && null != b3 && null != U2 && null != P4 ? { top: d(j4, h3), right: d(b3, h3), bottom: d(U2, h3), left: d(P4, h3) } : null };
}

export {
  W,
  R3 as R,
  j3 as j,
  T,
  b2 as b,
  U,
  k,
  v2 as v
};
//# sourceMappingURL=chunk-QMZNFXS2.js.map
