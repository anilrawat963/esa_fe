import {
  E,
  a as a2,
  c as c2,
  e,
  e2,
  f,
  o,
  s as s4
} from "./chunk-2D47RURG.js";
import {
  l as l2
} from "./chunk-YY5PITIH.js";
import {
  n
} from "./chunk-234CIOHE.js";
import {
  H2 as H,
  N,
  _,
  a2 as a,
  c,
  r2 as r
} from "./chunk-V2H77UEV.js";
import {
  t
} from "./chunk-LZ2XTYP2.js";
import {
  C,
  d,
  h,
  l2 as l,
  s as s3
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i,
  s,
  s2
} from "./chunk-QY7XKUIV.js";
import {
  has
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/core/workers/staticWorkerMessages.js
var a3 = { async request(a7, s6) {
  const r3 = a7.options, n3 = r3.responseType;
  r3.signal = s6?.signal, r3.responseType = "native" === n3 || "native-request-init" === n3 ? "native-request-init" : n3 && ["blob", "json", "text"].includes(n3) && N(a7.url)?.after ? n3 : "array-buffer";
  const i2 = await H(a7.url, r3), o2 = { data: i2.data, httpStatus: i2.httpStatus, ssl: i2.ssl };
  switch (i2.requestOptions?.responseType) {
    case "native-request-init":
      return delete o2.data.signal, o2;
    case "blob":
      o2.data = await o2.data.arrayBuffer();
      break;
    case "json":
      o2.data = new TextEncoder().encode(JSON.stringify(o2.data)).buffer;
      break;
    case "text":
      o2.data = new TextEncoder().encode(o2.data).buffer;
  }
  return { result: o2, transferList: [o2.data] };
} };

// node_modules/@arcgis/core/core/workers/loaderConfig.js
var a4 = {};
function r2(s6) {
  const r3 = { async: s6.async, isDebug: s6.isDebug, locale: s6.locale, baseUrl: s6.baseUrl, has: { ...s6.has }, map: { ...s6.map }, packages: s6.packages?.slice() || [], paths: { ...a4.paths, ...s6.paths } };
  return s6.hasOwnProperty("async") || (r3.async = true), s6.hasOwnProperty("isDebug") || (r3.isDebug = false), s6.baseUrl || (r3.baseUrl = a4.baseUrl), r3;
}

// node_modules/@arcgis/core/core/workers/WorkerFallback.js
var n2 = class {
  constructor() {
    const e3 = document.createDocumentFragment();
    ["addEventListener", "dispatchEvent", "removeEventListener"].forEach((s6) => {
      this[s6] = (...r3) => e3[s6](...r3);
    });
  }
};
var a5 = class {
  constructor() {
    this._dispatcher = new n2(), this._workerPostMessage({ type: e2.HANDSHAKE });
  }
  terminate() {
  }
  get onmessage() {
    return this._onmessageHandler;
  }
  set onmessage(e3) {
    this._onmessageHandler && this.removeEventListener("message", this._onmessageHandler), this._onmessageHandler = e3, e3 && this.addEventListener("message", e3);
  }
  get onmessageerror() {
    return this._onmessageerrorHandler;
  }
  set onmessageerror(e3) {
    this._onmessageerrorHandler && this.removeEventListener("messageerror", this._onmessageerrorHandler), this._onmessageerrorHandler = e3, e3 && this.addEventListener("messageerror", e3);
  }
  get onerror() {
    return this._onerrorHandler;
  }
  set onerror(e3) {
    this._onerrorHandler && this.removeEventListener("error", this._onerrorHandler), this._onerrorHandler = e3, e3 && this.addEventListener("error", e3);
  }
  postMessage(s6) {
    t(() => {
      this._workerMessageHandler(new MessageEvent("message", { data: s6 }));
    });
  }
  dispatchEvent(e3) {
    return this._dispatcher.dispatchEvent(e3);
  }
  addEventListener(e3, s6, r3) {
    this._dispatcher.addEventListener(e3, s6, r3);
  }
  removeEventListener(e3, s6, r3) {
    this._dispatcher.removeEventListener(e3, s6, r3);
  }
  _workerPostMessage(s6) {
    t(() => {
      this.dispatchEvent(new MessageEvent("message", { data: s6 }));
    });
  }
  async _workerMessageHandler(e3) {
    const n3 = f(e3);
    if (n3 && n3.type === e2.OPEN) {
      const { modulePath: e4, jobId: t2 } = n3;
      let a7 = await E.loadWorker(e4);
      a7 || (a7 = await import(
        /* @vite-ignore */
        /* webpackIgnore: true */
        e4
      ));
      const o2 = E.connect(a7);
      this._workerPostMessage({ type: e2.OPENED, jobId: t2, data: o2 });
    }
  }
};

// node_modules/@arcgis/core/core/workers/workerFactory.js
var d2 = () => i.getLogger("esri.core.workers.workerFactory");
var { HANDSHAKE: m } = e2;
var p = 'let globalId=0;const outgoing=new Map,configuration={CONFIGURATION};self.esriConfig=configuration.esriConfig;const workerPath=self.esriConfig.workers.workerPath,HANDSHAKE=0,OPEN=1,OPENED=2,RESPONSE=3,INVOKE=4,ABORT=5;function createAbortError(){const e=new Error("Aborted");return e.name="AbortError",e}function receiveMessage(e){return e&&e.data?"string"==typeof e.data?JSON.parse(e.data):e.data:null}function invokeStaticMessage(e,o,r){const t=r&&r.signal,n=globalId++;let s=null;return new Promise((r,i)=>{if(t){if(t.aborted)return i(createAbortError());s=()=>{outgoing.get(n)&&(outgoing.delete(n),self.postMessage({type:5,jobId:n}),i(createAbortError()))},t.addEventListener("abort",s)}outgoing.set(n,{resolve:r,reject:i}),self.postMessage({type:4,jobId:n,methodName:e,abortable:null!=t,data:o})}).finally(()=>{t&&t.removeEventListener("abort",s)})}let workerRevisionChecked=!1;function checkWorkerRevision(e){if(!workerRevisionChecked&&e.kernelInfo){workerRevisionChecked=!0;const{revision:o,fullVersion:r}=configuration.kernelInfo,{revision:t,fullVersion:n,version:s}=e.kernelInfo;esriConfig.assetsPath!==esriConfig.defaultAssetsPath&&o!==t&&console.warn(`Version mismatch detected between ArcGIS Maps SDK for JavaScript modules and assets. For more information visit https://esriurl.com/using-local-assets.\nModules version: ${r}\nAssets version: ${n??s}\nAssets path: ${esriConfig.assetsPath}`)}}function messageHandler(e){const o=receiveMessage(e);if(!o)return;const r=o.jobId;switch(o.type){case 1:let n;function t(e){const o=n.connect(e);self.postMessage({type:2,jobId:r,data:o},[o])}"function"==typeof define&&define.amd?require([workerPath],e=>{n=e.default||e,checkWorkerRevision(n),n.loadWorker(o.modulePath).then(e=>e||new Promise(e=>{require([o.modulePath],e)})).then(t)}):"System"in self&&"function"==typeof System.import?System.import(workerPath).then(e=>(n=e.default,checkWorkerRevision(n),n.loadWorker(o.modulePath))).then(e=>e||System.import(o.modulePath)).then(t):esriConfig.workers.useDynamicImport?import(workerPath).then(e=>{n=e.default||e,checkWorkerRevision(n),n.loadWorker(o.modulePath).then(e=>e||import(o.modulePath)).then(t)}):(self.RemoteClient||importScripts(workerPath),n=self.RemoteClient.default||self.RemoteClient,checkWorkerRevision(n),n.loadWorker(o.modulePath).then(t));break;case 3:if(outgoing.has(r)){const s=outgoing.get(r);outgoing.delete(r),o.error?s.reject(JSON.parse(o.error)):s.resolve(o.data)}}}self.dojoConfig=configuration.loaderConfig,esriConfig.workers.loaderUrl&&(self.importScripts(esriConfig.workers.loaderUrl),"function"==typeof require&&"function"==typeof require.config&&require.config(configuration.loaderConfig)),self.addEventListener("message",messageHandler),self.postMessage({type:0});';
var g;
var y;
var h2 = "Failed to create Worker. Fallback to execute module in main thread";
async function k() {
  if (!has("esri-workers")) return w(new a5());
  if (!g && !y) try {
    const e4 = p.split("{CONFIGURATION}").join(b());
    g = URL.createObjectURL(new Blob([e4], { type: "text/javascript" }));
  } catch (r3) {
    y = r3 || {};
  }
  let e3;
  if (g) try {
    e3 = new Worker(g, { name: "esri-worker-" + v++ });
  } catch (r3) {
    d2().warn(h2, y), e3 = new a5();
  }
  else d2().warn(h2, y), e3 = new a5();
  return w(e3);
}
async function w(e3) {
  return new Promise((r3) => {
    function t2(s6) {
      const a7 = f(s6);
      a7 && a7.type === m && (e3.removeEventListener("message", t2), e3.removeEventListener("error", o2), r3(e3));
    }
    function o2(r4) {
      r4.preventDefault(), e3.removeEventListener("message", t2), e3.removeEventListener("error", o2), d2().warn("Failed to create Worker. Fallback to execute module in main thread", r4), (e3 = new a5()).addEventListener("message", t2), e3.addEventListener("error", o2);
    }
    e3.addEventListener("message", t2), e3.addEventListener("error", o2);
  });
}
function b() {
  let o2;
  if (null != s.default) {
    const e3 = { ...s };
    delete e3.default, o2 = JSON.parse(JSON.stringify(e3));
  } else o2 = JSON.parse(JSON.stringify(s));
  o2.assetsPath = _(o2.assetsPath), o2.defaultAssetsPath = o2.defaultAssetsPath ? _(o2.defaultAssetsPath) : void 0, o2.request.interceptors = [], o2.log.interceptors = [], o2.locale = l2(), o2.has = { "esri-csp-restrictions": has("esri-csp-restrictions"), "esri-2d-debug": false, "esri-2d-update-debug": has("esri-2d-update-debug"), "esri-2d-log-updating": has("esri-2d-log-updating"), "featurelayer-pbf": has("featurelayer-pbf"), "featurelayer-fast-triangulation-enabled": has("featurelayer-fast-triangulation-enabled"), "featurelayer-simplify-thresholds": has("featurelayer-simplify-thresholds"), "featurelayer-simplify-payload-size-factors": has("featurelayer-simplify-payload-size-factors"), "featurelayer-simplify-mobile-factor": has("featurelayer-simplify-mobile-factor"), "featurelayer-query-max-depth": has("featurelayer-query-max-depth"), "featurelayer-query-tile-max-features": has("featurelayer-query-tile-max-features"), "featurelayer-query-tile-concurrency": has("featurelayer-query-tile-concurrency"), "featurelayer-query-pausing-enabled": has("featurelayer-query-pausing-enabled"), "featurelayer-snapshot-concurrency": has("featurelayer-snapshot-concurrency"), "featurelayer-snapshot-enabled": has("featurelayer-snapshot-enabled"), "parquetlayer-full-query-feature-count": has("parquetlayer-full-query-feature-count"), "esri-atomics": has("esri-atomics"), "esri-shared-array-buffer": has("esri-shared-array-buffer"), "esri-tiles-debug": has("esri-tiles-debug"), "esri-workers-arraybuffer-transfer": has("esri-workers-arraybuffer-transfer"), "feature-polyline-generalization-factor": has("feature-polyline-generalization-factor"), "host-webworker": 1 }, o2.workers.loaderUrl && (o2.workers.loaderUrl = _(o2.workers.loaderUrl)), o2.workers.workerPath ? o2.workers.workerPath = _(o2.workers.workerPath) : o2.workers.workerPath = _(n("esri/core/workers/RemoteClient.js")), o2.workers.useDynamicImport = false;
  const n3 = s.workers.loaderConfig, i2 = r2({ baseUrl: n3?.baseUrl, locale: l2(), has: { "csp-restrictions": 1, "dojo-test-sniff": 0, "host-webworker": 1, ...n3?.has }, map: { ...n3?.map }, paths: { ...n3?.paths }, packages: n3?.packages || [] }), l4 = { buildDate: a, fullVersion: r, revision: c };
  return JSON.stringify({ esriConfig: o2, loaderConfig: i2, kernelInfo: l4 });
}
var v = 0;

// node_modules/@arcgis/core/core/workers/WorkerOwner.js
var { ABORT: b2, INVOKE: m2, OPEN: _2, OPENED: g2, RESPONSE: u } = e2;
var j = class _j {
  static async create(e3) {
    const t2 = await k();
    return new _j(t2, e3);
  }
  constructor(e3, o2) {
    this._outJobs = /* @__PURE__ */ new Map(), this._inJobs = /* @__PURE__ */ new Map(), this.worker = e3, this.id = o2, e3.addEventListener("message", this._onMessage.bind(this)), e3.addEventListener("error", (e4) => {
      e4.preventDefault(), i.getLogger("esri.core.workers.WorkerOwner").error(e4);
    });
  }
  terminate() {
    this.worker.terminate();
  }
  async open(e3, t2 = {}) {
    const { signal: o2 } = t2, r3 = s4();
    return new Promise((t3, n3) => {
      const a7 = { resolve: t3, reject: n3, abortHandle: h(o2, () => {
        this._outJobs.delete(r3), this._post({ type: b2, jobId: r3 });
      }) };
      this._outJobs.set(r3, a7), this._post({ type: _2, jobId: r3, modulePath: e3 });
    });
  }
  _onMessage(e3) {
    const t2 = f(e3);
    if (t2) switch (t2.type) {
      case g2:
        this._onOpenedMessage(t2);
        break;
      case u:
        this._onResponseMessage(t2);
        break;
      case b2:
        this._onAbortMessage(t2);
        break;
      case m2:
        this._onInvokeMessage(t2);
    }
  }
  _onAbortMessage(e3) {
    const t2 = this._inJobs, o2 = e3.jobId, s6 = t2.get(o2);
    s6 && (s6.controller && s6.controller.abort(), t2.delete(o2));
  }
  _onInvokeMessage(e3) {
    const { methodName: t2, jobId: o2, data: s6, abortable: i2 } = e3, l4 = i2 ? new AbortController() : null, d4 = this._inJobs, h4 = a3[t2];
    let p3;
    try {
      if ("function" != typeof h4) throw new TypeError(`${t2} is not a function`);
      p3 = h4.call(null, s6, { signal: l4 ? l4.signal : null });
    } catch (b3) {
      return void this._post({ type: u, jobId: o2, error: o(b3) });
    }
    C(p3) ? (d4.set(o2, { controller: l4, promise: p3 }), p3.then((e4) => {
      d4.has(o2) && (d4.delete(o2), this._post({ type: u, jobId: o2 }, e4));
    }, (e4) => {
      d4.has(o2) && (d4.delete(o2), e4 || (e4 = { message: "Error encountered at method" + t2 }), d(e4) || this._post({ type: u, jobId: o2, error: o(e4 || { message: `Error encountered at method ${t2}` }) }));
    })) : this._post({ type: u, jobId: o2 }, p3);
  }
  _onOpenedMessage(e3) {
    const { jobId: t2, data: s6 } = e3, r3 = this._outJobs.get(t2);
    r3 && (this._outJobs.delete(t2), l(r3.abortHandle), r3.resolve(s6));
  }
  _onResponseMessage(t2) {
    const { jobId: s6, error: r3, data: n3 } = t2, a7 = this._outJobs.get(s6);
    a7 && (this._outJobs.delete(s6), l(a7.abortHandle), r3 ? a7.reject(s2.fromJSON(JSON.parse(r3))) : a7.resolve(n3));
  }
  _post(e3, t2, o2) {
    return a2(this.worker, e3, t2, o2);
  }
};

// node_modules/@arcgis/core/core/workers/workers.js
var s5 = has("host-browser") ? Math.min(navigator.hardwareConcurrency - 1, has("workers-pool-size") ?? 8) : 0;
var a6 = has("esri-mobile") ? Math.min(s5, 3) : s5;
a6 || (a6 = has("safari") && has("mac") ? 7 : 2);
var c3 = 0;
var l3 = [];
function m3() {
  g3();
}
async function f2(r3, t2) {
  const n3 = new c2(), { registryTarget: i2, ...s6 } = t2;
  return await n3.open(r3, s6), i2 && e(i2, n3), n3;
}
async function p2(e3, o2 = {}) {
  if ("string" != typeof e3) throw new s2("workers:undefined-module", "modulePath is missing");
  let i2 = o2.strategy || "distributed";
  if (has("host-webworker") && !has("esri-workers") && (i2 = "local"), "local" === i2) {
    let r3 = await E.loadWorker(e3);
    r3 || (r3 = await import(
      /* @vite-ignore */
      /* webpackIgnore: true */
      e3
    )), s3(o2.signal);
    const i3 = o2.client || r3;
    return f2([E.connect(r3, o2.schedule)], { ...o2, client: i3 });
  }
  if (await g3(), s3(o2.signal), "dedicated" === i2) {
    const r3 = c3++ % a6;
    return f2([await l3[r3].open(e3, o2)], o2);
  }
  if (o2.maxNumWorkers && o2.maxNumWorkers > 0) {
    const r3 = Math.min(o2.maxNumWorkers, a6);
    if (r3 < a6) {
      const t2 = new Array(r3);
      for (let n3 = 0; n3 < r3; ++n3) {
        const r4 = c3++ % a6;
        t2[n3] = l3[r4].open(e3, o2);
      }
      return f2(t2, o2);
    }
  }
  return f2(l3.map((r3) => r3.open(e3, o2)), o2);
}
var h3;
var d3 = null;
async function g3() {
  if (d3) return d3;
  h3 = new AbortController();
  const r3 = [];
  for (let t2 = 0; t2 < a6; t2++) {
    const e3 = j.create(t2).then((r4) => (l3[t2] = r4, r4));
    r3.push(e3);
  }
  return d3 = Promise.all(r3), d3;
}

export {
  m3 as m,
  p2 as p
};
//# sourceMappingURL=chunk-ZCI5A4FF.js.map
