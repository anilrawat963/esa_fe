import {
  n
} from "./chunk-GIKMBX7P.js";
import {
  i,
  s as s2
} from "./chunk-TF4EQP5K.js";
import {
  a as a2
} from "./chunk-ZUQ2O3KU.js";
import {
  g
} from "./chunk-HCTBVF3W.js";
import {
  d as d2
} from "./chunk-S5K4XWUR.js";
import {
  d
} from "./chunk-QNW4D2V2.js";
import {
  b as b2
} from "./chunk-647DAMHU.js";
import {
  R
} from "./chunk-EFV6H5NA.js";
import {
  f
} from "./chunk-PLNHHGHL.js";
import {
  z
} from "./chunk-H74Q4SYB.js";
import {
  T
} from "./chunk-NMQNUPE4.js";
import {
  I
} from "./chunk-V2H77UEV.js";
import {
  b,
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  p
} from "./chunk-GNMPGHLQ.js";
import {
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  has
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/rest/query/executeForExtent.js
async function a3(a4, m2, e) {
  const i2 = f(a4), s3 = await d(i2, b2.from(m2), { ...e }), u = s3.data.extent;
  return !u || isNaN(u.xmin) || isNaN(u.ymin) || isNaN(u.xmax) || isNaN(u.ymax) ? { count: s3.data.count, extent: null } : { count: s3.data.count, extent: z.fromJSON(u) };
}

// node_modules/@arcgis/core/layers/graphics/sources/support/QueryTask.js
var S = class extends b {
  constructor(e) {
    super(e), this.dynamicDataSource = null, this.fieldsIndex = null, this.gdbVersion = null, this.infoFor3D = null, this.pbfSupported = false, this.queryAttachmentsSupported = false, this.sourceSpatialReference = null, this.uniqueIdFields = null, this.url = null;
  }
  get parsedUrl() {
    return I(this.url);
  }
  async execute(e, t) {
    const r = await this.executeJSON(e, t);
    return this.featureSetFromJSON(e, r, t);
  }
  async executeJSON(e, t) {
    const r = this._normalizeQuery(e), o = null != e.outStatistics?.[0], s3 = has("featurelayer-pbf-statistics"), i2 = (!o || s3) && true !== e.returnTrueCurves;
    let u;
    if (this.pbfSupported && i2) try {
      u = await n(this.url, r, t, { uniqueIdFields: this.uniqueIdFields });
    } catch (n2) {
      if ("query:parsing-pbf" !== n2.name) throw n2;
      this.pbfSupported = false;
    }
    return this.pbfSupported && i2 || (u = await a2(this.url, r, t, { uniqueIdFields: this.uniqueIdFields })), this._normalizeFields(u.fields), u;
  }
  async featureSetFromJSON(e, t, r) {
    if (!this._queryIs3DObjectFormat(e) || null == this.infoFor3D || !t.features) return g.fromJSON(t);
    const { meshFeatureSetFromJSON: s3 } = await p(import("./meshFeatureSet-AS7I4OCS.js"), r);
    return s3(e, this.infoFor3D, t);
  }
  executeForCount(e, t) {
    return s2(this.url, this._normalizeQuery(e), t, { uniqueIdFields: this.uniqueIdFields });
  }
  executeForExtent(e, t) {
    return a3(this.url, this._normalizeQuery(e), t);
  }
  executeForIds(e, t) {
    return i(this.url, this._normalizeQuery(e), t, { uniqueIdFields: this.uniqueIdFields });
  }
  async executeRelationshipQuery(e, t) {
    const [{ default: r }, { executeRelationshipQuery: s3 }] = await p(Promise.all([import("./RelationshipQuery-U5RG7SZF.js"), import("./executeRelationshipQuery-2CACTZMD.js")]), t);
    return e = r.from(e), (this.gdbVersion || this.dynamicDataSource) && ((e = e.clone()).gdbVersion = e.gdbVersion || this.gdbVersion, e.dynamicDataSource = e.dynamicDataSource || this.dynamicDataSource), s3(this.url, e, t);
  }
  async executeRelationshipQueryForCount(e, t) {
    const [{ default: r }, { executeRelationshipQueryForCount: s3 }] = await p(Promise.all([import("./RelationshipQuery-U5RG7SZF.js"), import("./executeRelationshipQuery-2CACTZMD.js")]), t);
    return e = r.from(e), (this.gdbVersion || this.dynamicDataSource) && ((e = e.clone()).gdbVersion = e.gdbVersion || this.gdbVersion, e.dynamicDataSource = e.dynamicDataSource || this.dynamicDataSource), s3(this.url, e, t);
  }
  async executeAttachmentQuery(e, t) {
    const { executeAttachmentQuery: r, fetchAttachments: s3, processAttachmentQueryResult: i2 } = await p(import("./queryAttachments-BIKQJ3VO.js"), t), u = f(this.url);
    return i2(u, await (this.queryAttachmentsSupported ? r(u, e, t) : s3(u, e, t)));
  }
  async executeAttributeBinsQuery(e, t) {
    const { executeAttributeBinsQuery: r } = await p(import("./executeAttributeBinsQuery-M3UWA4QY.js"), t);
    return r(this.parsedUrl, e, t);
  }
  async executePivotQuery(e, t) {
    const { executePivotQuery: r } = await p(import("./executePivotQuery-WNXYWFOI.js"), t);
    return r(this.parsedUrl, e, t);
  }
  async executeTopFeaturesQuery(e, t) {
    const { executeTopFeaturesQuery: r } = await p(import("./executeTopFeaturesQuery-RXJTMMGO.js"), t);
    return r(this.parsedUrl, e, this.sourceSpatialReference, t);
  }
  async executeForTopIds(e, t) {
    const { executeForTopIds: r } = await p(import("./executeForTopIds-VHPOQPHT.js"), t);
    return r(this.parsedUrl, e, t);
  }
  async executeForTopExtents(e, t) {
    const { executeForTopExtents: r } = await p(import("./executeForTopExtents-DBBKCKZN.js"), t);
    return r(this.parsedUrl, e, t);
  }
  async executeForTopCount(e, t) {
    const { executeForTopCount: r } = await p(import("./executeForTopCount-DXEZLVSM.js"), t);
    return r(this.parsedUrl, e, t);
  }
  _normalizeQuery(e) {
    let t = b2.from(e);
    t.sourceSpatialReference = t.sourceSpatialReference || this.sourceSpatialReference, (this.gdbVersion || this.dynamicDataSource) && (t = t === e ? t.clone() : t, t.gdbVersion = e.gdbVersion || this.gdbVersion, t.dynamicDataSource = e.dynamicDataSource ? R.from(e.dynamicDataSource) : this.dynamicDataSource);
    const { infoFor3D: o } = this;
    if (null != o && this._queryIs3DObjectFormat(e)) {
      if (t = t === e ? t.clone() : t, t.formatOf3DObjects = d2(o), !t.formatOf3DObjects) throw new s("query:unsupported-3d-query-formats", "Could not find any supported 3D object query format. Only supported formats are 3D_glb and 3D_gltf");
      if (t.outSpatialReference && !T(t.outSpatialReference, this.sourceSpatialReference)) throw new s("query:unsupported-out-spatial-reference", "3D object feature services do not support projection of geometries");
      if (null == t.outFields || !t.outFields.includes("*")) {
        t = t === e ? t.clone() : t, null == t.outFields && (t.outFields = []);
        const { originX: r, originY: s3, originZ: i2, translationX: u, translationY: n2, translationZ: a4, scaleX: c, scaleY: p2, scaleZ: l, rotationX: d3, rotationY: m2, rotationZ: y, rotationDeg: h } = o.transformFieldRoles;
        t.outFields.push(r, s3, i2, u, n2, a4, c, p2, l, d3, m2, y, h);
      }
    }
    return t;
  }
  _normalizeFields(e) {
    if (null != this.fieldsIndex && null != e) for (const t of e) {
      const e2 = this.fieldsIndex.get(t.name);
      e2 && Object.assign(t, e2.toJSON());
    }
  }
  _queryIs3DObjectFormat(e) {
    return null != this.infoFor3D && true === e.returnGeometry && "xyFootprint" !== e.multipatchOption && !e.outStatistics;
  }
};
__decorate([m({ type: R })], S.prototype, "dynamicDataSource", void 0), __decorate([m()], S.prototype, "fieldsIndex", void 0), __decorate([m()], S.prototype, "gdbVersion", void 0), __decorate([m()], S.prototype, "infoFor3D", void 0), __decorate([m({ readOnly: true })], S.prototype, "parsedUrl", null), __decorate([m()], S.prototype, "pbfSupported", void 0), __decorate([m()], S.prototype, "queryAttachmentsSupported", void 0), __decorate([m()], S.prototype, "sourceSpatialReference", void 0), __decorate([m()], S.prototype, "uniqueIdFields", void 0), __decorate([m({ type: String })], S.prototype, "url", void 0), S = __decorate([a("esri.layers.graphics.sources.support.QueryTask")], S);

export {
  S
};
//# sourceMappingURL=chunk-2QMXQ3D5.js.map
