import {
  u as u3
} from "./chunk-TF6255HN.js";
import {
  e as e2,
  u as u2
} from "./chunk-C5OQVQZF.js";
import {
  DateTime
} from "./chunk-4YDOPHTZ.js";
import {
  u3 as u
} from "./chunk-5EI5H4QX.js";
import {
  f
} from "./chunk-GNMPGHLQ.js";
import {
  e,
  s2 as s,
  t
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/support/loadArcade.js
var a;
function e3() {
  return a || (a = (async () => {
    const [a3, e6, r2] = await Promise.all([import("./arcadeUtils-INHVJQGO.js"), import("./batchExec-6WD2F5IB.js"), import("./aiServices-3B7OKS4O.js")]);
    return { arcade: a3.arcade, arcadeUtils: a3, batchExec: e6, aiServices: r2, Dictionary: a3.Dictionary, Feature: a3.arcadeFeature, Voxel: a3.Voxel, Pixel: a3.Pixel };
  })()), a;
}

// node_modules/@arcgis/core/support/dateUtils.js
var t2 = "HH:mm";
var l = "HH:mm:ss";
var m = "HH:mm:ss.SSS";
var i = [m, l, t2, "TT"];
var s2 = "yyyy-MM-dd";
function e4(r2) {
  if (!r2 || !e2(r2)) return null;
  const t4 = DateTime.fromFormat(r2, s2);
  return t4.isValid ? t4 : null;
}
function H(t4) {
  return t4 && e2(t4) ? f(i, (r2) => {
    const n = DateTime.fromFormat(t4, r2);
    return n.isValid ? n : null;
  }) ?? null : null;
}
function c(r2) {
  if (!r2 || !e2(r2)) return null;
  const t4 = DateTime.fromISO(r2);
  return t4.isValid ? t4 : null;
}

// node_modules/@arcgis/core/layers/support/domainUtils.js
var r = /* @__PURE__ */ new Set(["integer", "small-integer", "long", "big-integer", "esriFieldTypeInteger", "esriFieldTypeSmallInteger", "esriFieldTypeLong", "esriFieldTypeBigInteger"]);
function l2(e6) {
  return null != e6 && r.has(e6.type);
}
function u4(e6) {
  return null != e6 && ("date-only" === e6.type || "esriFieldTypeDateOnly" === e6.type);
}
function a2(e6) {
  return null != e6 && ("timestamp-offset" === e6.type || "esriFieldTypeTimestampOffset" === e6.type);
}
function o(e6) {
  return null != e6 && ("time-only" === e6.type || "esriFieldTypeTimeOnly" === e6.type);
}
var s3 = /* @__PURE__ */ new Set([...["single", "double"], ...["esriFieldTypeSingle", "esriFieldTypeDouble"]]);
var m2 = u(r, s3);
function y(e6, n) {
  const i2 = n ?? e6?.domain;
  if (!i2 || "range" !== i2.type) return;
  const t4 = "range" in i2 ? i2.range[0] : i2.minValue, r2 = "range" in i2 ? i2.range[1] : i2.maxValue, s4 = l2(e6);
  return u4(e6) || o(e6) || a2(e6) ? { ...g(e6, r2, t4), isInteger: s4 } : { min: null != t4 && "number" == typeof t4 ? t4 : null, max: null != r2 && "number" == typeof r2 ? r2 : null, rawMin: t4, rawMax: r2, isInteger: s4 };
}
function g(e6, r2, l3) {
  return u4(e6) ? { min: e4(l3)?.toMillis(), max: e4(r2)?.toMillis(), rawMin: l3, rawMax: r2 } : o(e6) ? { min: H(l3)?.toMillis(), max: H(r2)?.toMillis(), rawMin: l3, rawMax: r2 } : a2(e6) ? { min: c(l3)?.toMillis(), max: c(r2)?.toMillis(), rawMin: l3, rawMax: r2 } : { max: null, min: null };
}

// node_modules/@arcgis/core/support/arcadeExpressionUtils.js
function t3(t4) {
  if (!t4) return;
  const e6 = t4.match(o2);
  return e6?.groups ? e6.groups.doubleQuoted ?? e6.groups.singleQuoted ?? e6.groups.dotNotation : void 0;
}
var o2 = /^(\$feature\[(?:"(?<doubleQuoted>[^"]+)"|'(?<singleQuoted>[^']+)')\]|\$feature\.(?<dotNotation>[a-z_][a-z0-9_]*))$/i;
function e5(t4) {
  return t4.match(u5)?.[1]?.replaceAll("\\'", "'") ?? null;
}
var u5 = /^hash\(\$feature\['((\\'|[^'])+)'\]\) \* 8\.381e-8$/;

// node_modules/@arcgis/core/layers/support/fieldUtils.js
var f2 = /^([0-9_])/;
var d = /[^a-z0-9_\u0080-\uffff]+/gi;
function c2(e6) {
  if (null == e6) return null;
  return e6.trim().replaceAll(d, "_").replace(f2, "F$1") || null;
}
var p = ["field", "field2", "field3", "normalizationField", "rotationInfo.field", "proportionalSymbolInfo.field", "proportionalSymbolInfo.normalizationField", "colorInfo.field", "colorInfo.normalizationField"];
var m3 = ["field", "normalizationField"];
function y2(e6, n) {
  if (null != e6 && null != n) {
    for (const i2 of Array.isArray(e6) ? e6 : [e6]) if (g2(p, i2, n), "visualVariables" in i2 && i2.visualVariables) for (const e7 of i2.visualVariables) g2(m3, e7, n);
  }
}
function g2(e6, t4, r2) {
  if (e6) for (const l3 of e6) {
    const e7 = t(l3, t4), o3 = e7 && "function" != typeof e7 && r2.get(e7);
    o3 && e(l3, o3.name, t4);
  }
}
function F(e6, n) {
  if (null != e6 && n?.fields?.length) if ("startField" in e6) {
    const i2 = n.get(e6.startField), t4 = n.get(e6.endField);
    e6.startField = i2?.name ?? null, e6.endField = t4?.name ?? null;
  } else {
    const i2 = n.get(e6.startTimeField), t4 = n.get(e6.endTimeField);
    e6.startTimeField = i2?.name ?? null, e6.endTimeField = t4?.name ?? null;
  }
}
var I = /* @__PURE__ */ new Set();
function b(e6, n) {
  return e6 && n ? (I.clear(), w(I, e6, n), Array.from(I).sort()) : [];
}
function w(e6, n, i2) {
  if (i2) if (n?.fields?.length) if (i2.includes("*")) for (const { name: t4 } of n.fields) e6.add(t4);
  else for (const t4 of i2) x(e6, n, t4);
  else {
    if (i2.includes("*")) return e6.clear(), void e6.add("*");
    for (const n2 of i2) null != n2 && e6.add(n2);
  }
}
function x(e6, n, i2) {
  if ("string" == typeof i2) if (n) {
    const t4 = n.get(i2);
    t4 && e6.add(t4.name);
  } else e6.add(i2);
}
function T(e6, n) {
  return null == n || null == e6 ? [] : n.includes("*") ? (e6.fields ?? []).map((e7) => e7.name) : n;
}
function h(e6, n, i2 = 1) {
  if (!n || !e6) return [];
  if (n.includes("*")) return ["*"];
  const t4 = b(e6, n);
  return t4.length / e6.fields.length >= i2 ? ["*"] : t4;
}
async function v(e6, n, i2, t4) {
  if (!t4) return;
  const r2 = t3(t4);
  if (r2) x(e6, n, r2);
  else {
    const { arcadeUtils: r3 } = await e3(), l3 = r3.extractFieldNames(t4, i2?.partitions ?? n?.fields?.map((e7) => e7.name));
    for (const t5 of l3) x(e6, i2?.index ?? n, t5);
  }
}
async function S(n, i2, t4) {
  if (t4 && "1=1" !== t4) {
    const l3 = await u3(t4, i2);
    if (!l3.isStandardized) throw new s("fieldUtils:collectFilterFields", "Where clause is not standardized", { where: t4 });
    w(n, i2, l3.fieldNames);
  }
}
function E({ displayField: e6, fields: n }) {
  return e6 || (n?.length ? A(n) : null);
}
function A(e6) {
  return _(e6, "name-or-title") || _(e6, "unique-identifier") || _(e6, "type-or-category") || $(e6);
}
function $(e6) {
  for (const n of e6) {
    if (!n?.name) continue;
    const e7 = n.name.toLowerCase();
    if (e7.includes("name") || e7.includes("title")) return n.name;
  }
  return null;
}
function _(e6, n) {
  for (const i2 of e6) if (i2?.valueType && i2.valueType === n) return i2.name;
  return null;
}
async function L(e6, n) {
  if (!n) return;
  const i2 = n.elevationInfo?.featureExpressionInfo;
  return i2 ? i2.collectRequiredFields(e6, n.fieldsIndex) : void 0;
}
function M(e6, n, i2) {
  i2.onStatisticExpression ? v(e6, n, null, i2.onStatisticExpression.expression) : e6.add(i2.onStatisticField);
}
async function j(e6, n, i2) {
  if (!n || !i2 || !("fields" in i2)) return;
  const t4 = [], r2 = i2.popupTemplate;
  t4.push(O(e6, n, r2)), i2.fields && t4.push(...i2.fields.map(async (i3) => M(e6, n.fieldsIndex, i3))), await Promise.all(t4);
}
async function D(e6, n) {
  const { fieldsIndex: i2, trackInfo: t4 } = n;
  if (!n || !t4 || !i2) return;
  const r2 = [t4.latestObservations.renderer?.collectRequiredFields(e6, i2), t4.previousObservations.renderer?.collectRequiredFields(e6, i2), t4.trackLines.renderer?.collectRequiredFields(e6, i2)];
  t4.popupTemplate && r2.push(O(e6, n, t4.popupTemplate));
  for (const l3 of [t4.latestObservations.labelingInfo, t4.previousObservations.labelingInfo, t4.trackLines.labelingInfo]) if (l3) for (const n2 of l3) r2.push(Z(e6, i2, n2));
  await Promise.all(r2);
}
async function O(e6, n, i2) {
  const t4 = [];
  i2?.expressionInfos && t4.push(...i2.expressionInfos.map((i3) => v(e6, n.fieldsIndex, null, i3.expression)));
  const r2 = i2?.content;
  if (Array.isArray(r2)) for (const l3 of r2) "expression" === l3.type && l3.expressionInfo && t4.push(v(e6, n.fieldsIndex, null, l3.expressionInfo.expression));
  await Promise.all(t4);
}
async function R(e6, n, i2) {
  n && (n.timeInfo && i2?.timeExtent && w(e6, n.fieldsIndex, [n.timeInfo.startField, n.timeInfo.endField]), n.floorInfo && w(e6, n.fieldsIndex, [n.floorInfo.floorField]), null != i2?.where && await S(e6, n.fieldsIndex, i2.where));
}
async function V(e6, n, i2) {
  n && i2 && await Promise.all(i2.map((i3) => k(e6, n, i3)));
}
async function k(e6, n, i2) {
  n && i2 && (i2.valueExpression ? await v(e6, n.fieldsIndex, null, i2.valueExpression) : i2.field && x(e6, n.fieldsIndex, i2.field));
}
function U(e6) {
  return e6 ? b(e6.fieldsIndex, J(e6)) : [];
}
function q(e6) {
  if (!e6) return [];
  const n = e6.geometryFieldsInfo;
  return n ? b(e6.fieldsIndex, [n.shapeAreaField, n.shapeLengthField]) : [];
}
async function X(e6, n, i2) {
  if (!n || !i2) return;
  const t4 = n.fieldsIndex;
  await Promise.all(i2.filters.map((n2) => S(e6, t4, n2.where)));
}
var z = /* @__PURE__ */ new Set(["oid", "global-id", "guid"]);
var P = /* @__PURE__ */ new Set(["oid", "global-id"]);
var B = [/^fnode_$/i, /^tnode_$/i, /^lpoly_$/i, /^rpoly_$/i, /^poly_$/i, /^shape$/i, /^shape_$/i, /^subclass$/i, /^subclass_$/i, /^rings_ok$/i, /^rings_nok$/i, /objectid/i, /^perimeter_/i, /_perimeter$/i, /_i$/i];
function G(e6) {
  const n = /* @__PURE__ */ new Set();
  W(e6).forEach((e7) => n.add(e7)), q(e6).forEach((e7) => n.add(e7.toLowerCase()));
  const i2 = e6 && "infoFor3D" in e6 ? e6.infoFor3D : void 0;
  return i2 && (Object.values(i2.assetMapFieldRoles).forEach((e7) => n.add(e7.toLowerCase())), Object.values(i2.transformFieldRoles).forEach((e7) => n.add(e7.toLowerCase()))), Array.from(n);
}
function J(e6) {
  if (!e6) return [];
  const n = "editFieldsInfo" in e6 && e6.editFieldsInfo;
  if (!n) return [];
  const { creationDateField: i2, creatorField: t4, editDateField: r2, editorField: l3 } = n;
  return [i2, t4, r2, l3].filter(Boolean);
}
function W(e6) {
  return J(e6).map((e7) => e7.toLowerCase());
}
function H2(e6, n) {
  return e6.editable && !z.has(e6.type) && !W(n).includes(e6.name?.toLowerCase() ?? "");
}
function K(e6, n) {
  const i2 = e6.name?.toLowerCase() ?? "";
  return !(null != n?.objectIdField && i2 === n.objectIdField.toLowerCase() || null != n?.globalIdField && i2 === n.globalIdField.toLowerCase() || G(n).includes(i2) || P.has(e6.type) || B.some((e7) => e7.test(i2)));
}
async function Y(e6, n) {
  const { labelingInfo: i2, fieldsIndex: t4 } = n;
  i2?.length && await Promise.all(i2.map((n2) => Z(e6, t4, n2)));
}
async function Z(e6, n, i2) {
  if (!i2) return;
  const t4 = i2.getLabelExpression(), r2 = i2.where;
  if ("arcade" === t4.type) await v(e6, n, null, t4.expression);
  else {
    const i3 = t4.expression.match(/{[^}]*}/g);
    i3 && i3.forEach((i4) => {
      x(e6, n, i4.slice(1, -1));
    });
  }
  await S(e6, n, r2);
}
function ee(e6) {
  const n = e6.defaultValue;
  return void 0 !== n && oe(e6, n) ? n : e6.nullable ? null : void 0;
}
function ne(e6) {
  const n = "string" == typeof e6 ? { type: e6 } : e6;
  return Fe(n) ? 255 : "esriFieldTypeDate" === n.type || "date" === n.type ? 8 : void 0;
}
function ie(e6) {
  return "number" == typeof e6 && !isNaN(e6) && isFinite(e6);
}
function te(e6) {
  return null === e6 || ie(e6);
}
function re(e6) {
  return null === e6 || Number.isInteger(e6);
}
function le() {
  return true;
}
function oe(e6, n) {
  let i2;
  switch (e6.type) {
    case "date":
    case "integer":
    case "long":
    case "small-integer":
    case "big-integer":
    case "esriFieldTypeDate":
    case "esriFieldTypeInteger":
    case "esriFieldTypeLong":
    case "esriFieldTypeSmallInteger":
    case "esriFieldTypeBigInteger":
      i2 = e6.nullable ? re : Number.isInteger;
      break;
    case "double":
    case "single":
    case "esriFieldTypeSingle":
    case "esriFieldTypeDouble":
      i2 = e6.nullable ? te : ie;
      break;
    case "string":
    case "esriFieldTypeString":
      i2 = e6.nullable ? u2 : e2;
      break;
    default:
      i2 = le;
  }
  return 1 === arguments.length ? i2 : i2(n);
}
var se = ["integer", "small-integer", "big-integer", "long"];
var ae = ["single", "double"];
var ue = [...se, ...ae];
var fe = ["esriFieldTypeInteger", "esriFieldTypeSmallInteger", "esriFieldTypeLong", "esriFieldTypeBigInteger"];
var de = ["esriFieldTypeSingle", "esriFieldTypeDouble"];
var ce = /* @__PURE__ */ new Set([...se, ...fe]);
var pe = /* @__PURE__ */ new Set([...ae, ...de]);
var me = u(ce, pe);
function ye(e6) {
  return null != e6 && ce.has(e6.type);
}
function ge(e6) {
  return null != e6 && me.has(e6.type);
}
function Fe(e6) {
  return null != e6 && ("string" === e6.type || "esriFieldTypeString" === e6.type);
}
function Ie(e6) {
  return null != e6 && ("date" === e6.type || "esriFieldTypeDate" === e6.type);
}
function be(e6) {
  return null != e6 && ("date-only" === e6.type || "esriFieldTypeDateOnly" === e6.type);
}
function we(e6) {
  return null != e6 && ("timestamp-offset" === e6.type || "esriFieldTypeTimestampOffset" === e6.type);
}
function xe(e6) {
  return null != e6 && ("time-only" === e6.type || "esriFieldTypeTimeOnly" === e6.type);
}
function Te(e6) {
  return null != e6 && ("oid" === e6.type || "esriFieldTypeOID" === e6.type);
}
function he(e6) {
  return null != e6 && ("global-id" === e6.type || "esriFieldTypeGlobalID" === e6.type);
}
function ve(e6, n) {
  return null === Ee(e6, n);
}
function Se(e6) {
  return null == e6 || "number" == typeof e6 && isNaN(e6) ? null : e6;
}
function Ee(e6, n) {
  return null == e6 || e6.nullable && null === n ? null : oe(e6, n) ? ge(e6) && !Ae(e6.type, Number(n)) ? "numeric-range-validation-error::out-of-range" : null : "type-validation-error::invalid-type";
}
function Ae(e6, n) {
  const i2 = "string" == typeof e6 ? _e(e6) : e6;
  if (!i2) return false;
  const t4 = i2.min, r2 = i2.max;
  return i2.isInteger ? Number.isInteger(n) && n >= t4 && n <= r2 : n >= t4 && n <= r2;
}
function _e(e6) {
  switch (e6) {
    case "esriFieldTypeSmallInteger":
    case "small-integer":
      return Le;
    case "esriFieldTypeInteger":
    case "esriFieldTypeLong":
    case "integer":
    case "long":
      return Me;
    case "esriFieldTypeBigInteger":
    case "big-integer":
      return je;
    case "esriFieldTypeSingle":
    case "single":
      return Oe;
    case "esriFieldTypeDouble":
    case "double":
      return Re;
  }
}
var Le = { min: -32768, max: 32767, isInteger: true, rawMin: -32768, rawMax: 32767 };
var Me = { min: -2147483648, max: 2147483647, isInteger: true, rawMin: -2147483648, rawMax: 2147483647 };
var je = { min: -Number.MAX_SAFE_INTEGER, max: Number.MAX_SAFE_INTEGER, isInteger: true, rawMin: -Number.MAX_SAFE_INTEGER, rawMax: Number.MAX_SAFE_INTEGER };
var De = (2 - 2 ** -23) * 2 ** 127;
var Oe = { min: -De, max: De, isInteger: false, rawMin: -De, rawMax: De };
var Re = { min: -Number.MAX_VALUE, max: Number.MAX_VALUE, isInteger: false, rawMin: -Number.MAX_VALUE, rawMax: Number.MAX_VALUE };
function Ve(e6, n, i2) {
  switch (e6) {
    case "domain-validation-error::invalid-coded-value":
      return `Value ${i2} is not in the coded domain - field: ${n.name}, domain: ${JSON.stringify(n.domain)}`;
    case "domain-validation-error::value-out-of-range":
      return `Value ${i2} is out of the range of valid values - field: ${n.name}, domain: ${JSON.stringify(n.domain)}`;
    case "type-validation-error::invalid-type":
      return `Value ${i2} is not a valid value for the field type - field: ${n.name}, type: ${n.type}, nullable: ${n.nullable}`;
    case "numeric-range-validation-error::out-of-range": {
      const { min: e7, max: t4 } = _e(n.type);
      return `Value ${i2} is out of range for the number type - field: ${n.name}, type: ${n.type}, value range is ${e7} to ${t4}`;
    }
  }
}
function ke(e6, n) {
  return !Ce(e6, n, null);
}
function Ce(e6, n, i2) {
  if (!e6?.attributes || !n) {
    if (null != i2) for (const e7 of n ?? []) i2.add(e7);
    return true;
  }
  const t4 = new Set(Object.keys(e6.attributes));
  let r2 = false;
  for (const l3 of n) if (!t4.has(l3)) {
    if (r2 = true, null == i2) break;
    i2.add(l3);
  }
  return r2;
}
function qe(e6) {
  return !!e6 && ["raster.itempixelvalue", "raster.servicepixelvalue"].some((n) => e6.toLowerCase().startsWith(n));
}
function ze(e6) {
  const n = e6?.match(/{[^}]+}/g);
  return n ? n.map((e7) => e7.slice(1, -1).split(":")[0].trim()) : [];
}

export {
  y,
  e5 as e,
  e3 as e2,
  c2 as c,
  y2,
  F,
  b,
  w,
  x,
  T,
  h,
  v,
  S,
  E,
  L,
  j,
  D,
  R,
  V,
  U,
  X,
  H2 as H,
  K,
  Y,
  ee,
  ne,
  ye,
  ge,
  Fe,
  Ie,
  be,
  we,
  xe,
  Te,
  he,
  ve,
  Se,
  Ee,
  Ve,
  ke,
  qe,
  ze
};
//# sourceMappingURL=chunk-MC6NAKKX.js.map
