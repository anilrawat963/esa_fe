import {
  j
} from "./chunk-U3X2LY5C.js";
import {
  J,
  on
} from "./chunk-2LC2762W.js";
import {
  O
} from "./chunk-YDTPM7OQ.js";
import {
  P
} from "./chunk-PZ5RULLK.js";
import {
  H2 as H,
  I
} from "./chunk-V2H77UEV.js";
import {
  r
} from "./chunk-SOIZOFSB.js";
import {
  a as a3,
  n
} from "./chunk-XXLHAM2M.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2,
  s2 as s
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  a
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/layers/support/SceneModification.js
var n2;
var y = n2 = class extends n {
  constructor(e) {
    super(e), this.geometry = null, this.type = "clip";
  }
  writeGeometry(e, r2, o, s2) {
    if (s2.layer?.spatialReference && !s2.layer.spatialReference.equals(this.geometry.spatialReference)) {
      if (!J(e.spatialReference, s2.layer.spatialReference)) return void (s2?.messages && s2.messages.push(new s("scenemodification:unsupported", "Scene modifications with incompatible spatial references are not supported", { modification: this, spatialReference: s2.layer.spatialReference, context: s2 })));
      const p = new P();
      on(e, p, s2.layer.spatialReference), r2[o] = p.toJSON(s2);
    } else r2[o] = e.toJSON(s2);
  }
  clone() {
    return new n2({ geometry: a(this.geometry), type: this.type });
  }
};
__decorate([m({ type: P }), j()], y.prototype, "geometry", void 0), __decorate([r(["web-scene", "portal-item"], "geometry")], y.prototype, "writeGeometry", null), __decorate([m({ type: ["clip", "mask", "replace"], nonNullable: true }), j()], y.prototype, "type", void 0), y = n2 = __decorate([a2("esri.layers.support.SceneModification")], y);

// node_modules/@arcgis/core/layers/support/SceneModifications.js
var m2;
var n3 = m2 = class extends a3(O.ofType(y)) {
  constructor(r2) {
    super(r2), this.url = null;
  }
  clone() {
    return new m2({ url: this.url, items: this.items.map((r2) => r2.clone()) });
  }
  toJSON(r2) {
    return this.toArray().map((o) => o.toJSON(r2)).filter((r3) => !!r3.geometry);
  }
  static fromJSON(r2, o) {
    const t = new m2();
    for (const e of r2) t.add(y.fromJSON(e, o));
    return t;
  }
  static async fromUrl(r2, t, e) {
    const i = { url: I(r2), origin: "service" }, c = await H(r2, { responseType: "json", signal: e?.signal }), n4 = t.toJSON(), a4 = [];
    for (const o of c.data) a4.push(y.fromJSON({ ...o, geometry: { spatialReference: n4, ...o.geometry } }, i));
    return new m2({ url: r2, items: a4 });
  }
};
__decorate([m({ type: String })], n3.prototype, "url", void 0), n3 = m2 = __decorate([a2("esri.layers.support.SceneModifications")], n3);

export {
  n3 as n
};
//# sourceMappingURL=chunk-D2MXQDQ2.js.map
