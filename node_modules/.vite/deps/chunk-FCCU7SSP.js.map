{
  "version": 3,
  "sources": ["../../@arcgis/core/views/3d/webgl-engine/core/shaderModules/Texture2DUintPassUniform.js", "../../@arcgis/core/chunks/HighlightDownsample.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.34/esri/copyright.txt for details.\n*/\nimport{Uniform as r}from\"../../../../webgl/Uniform.js\";class e extends r{constructor(r,e){super(r,\"usampler2D\",1,(s,o,t)=>s.bindTexture(r,e(o,t)))}}export{e as Texture2DUintPassUniform};\n", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.34/esri/copyright.txt for details.\n*/\nimport{ScreenSpacePass as e}from\"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.glsl.js\";import{glsl as t}from\"../views/3d/webgl-engine/core/shaderModules/glsl.js\";import{Texture2DUintPassUniform as i}from\"../views/3d/webgl-engine/core/shaderModules/Texture2DUintPassUniform.js\";import{NoParameters as l}from\"../views/webgl/NoParameters.js\";import{ShaderBuilder as r}from\"../views/webgl/ShaderBuilder.js\";class o extends l{}function c(){const l=new r,{outputs:o,fragment:c}=l;return l.include(e),c.uniforms.add(new i(\"highlightTexture\",e=>e.highlightTexture)),c.constants.add(\"outlineWidth\",\"int\",Math.ceil(n)),c.constants.add(\"cellSize\",\"int\",u),o.add(\"fragGrid\",\"uvec2\"),c.main.add(t`ivec2 inputTextureSize = textureSize(highlightTexture, 0);\nivec2 cellBottomLeftCornerInput = ivec2(ivec2(floor(gl_FragCoord.xy) * vec2(cellSize)));\nivec2 coordMid =  cellBottomLeftCornerInput + ivec2(cellSize >> 1);\nuvec2 centreTexel = texelFetch(highlightTexture, coordMid, 0).rg & uvec2(0x55u);\nfloat marginSquare = float(outlineWidth*outlineWidth);\nuvec2 outputValue = centreTexel & uvec2(0x55u);\nfor(int y = -outlineWidth; y <= cellSize + outlineWidth; y+=2) {\nint dy = y < 0 ? -y : y > cellSize ? y-cellSize : 0;\nint xMargin = dy > 0 ? int(ceil(sqrt(marginSquare - float(dy*dy)))) : outlineWidth;\nfor(int x = -xMargin; x <= cellSize + xMargin; x+=2) {\nivec2 coord = cellBottomLeftCornerInput + ivec2(x, y);\nuvec2[4] texels = uvec2[4] (\ntexelFetch(highlightTexture,coord+ivec2(0,0),0).rg & uvec2(0x55u),\ntexelFetch(highlightTexture,coord+ivec2(1,0),0).rg & uvec2(0x55u),\ntexelFetch(highlightTexture,coord+ivec2(0,1),0).rg & uvec2(0x55u),\ntexelFetch(highlightTexture,coord+ivec2(1,1),0).rg & uvec2(0x55u)\n);\nif (texels[0] == texels[1] && texels[1] == texels[2] && texels[2] == texels[3] && texels[3] ==  centreTexel) {\ncontinue;\n}\nfor (int i=0; i<4; ++i){\noutputValue |= ((texels[i] ^ centreTexel) << 1);\noutputValue |= texels[i];\n}\n}\n}\nfragGrid = outputValue;`),l}const u=32,n=9,s=.4,a=Object.freeze(Object.defineProperty({__proto__:null,HighlightDownsampleDrawParameters:o,blurSize:s,build:c,gridCellPixelSize:u,outlineSize:n},Symbol.toStringTag,{value:\"Module\"}));export{o as H,a,s as b,c,u as g,n as o};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAIuD,IAAM,IAAN,cAAgB,EAAC;AAAA,EAAC,YAAY,GAAEA,IAAE;AAAC,UAAM,GAAE,cAAa,GAAE,CAACC,IAAEC,IAAEC,OAAIF,GAAE,YAAY,GAAED,GAAEE,IAAEC,EAAC,CAAC,CAAC;AAAA,EAAC;AAAC;;;ACA+Q,IAAMC,KAAN,cAAgB,EAAC;AAAC;AAAC,SAASC,KAAG;AAAC,QAAM,IAAE,IAAI,KAAE,EAAC,SAAQD,IAAE,UAASC,GAAC,IAAE;AAAE,SAAO,EAAE,QAAQ,CAAC,GAAEA,GAAE,SAAS,IAAI,IAAI,EAAE,oBAAmB,CAAAC,OAAGA,GAAE,gBAAgB,CAAC,GAAED,GAAE,UAAU,IAAI,gBAAe,OAAM,KAAK,KAAK,CAAC,CAAC,GAAEA,GAAE,UAAU,IAAI,YAAW,OAAM,CAAC,GAAED,GAAE,IAAI,YAAW,OAAO,GAAEC,GAAE,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBA0BjqB,GAAE;AAAC;AAAC,IAAM,IAAE;AAAR,IAAW,IAAE;AAAb,IAAeE,KAAE;AAAjB,IAAoB,IAAE,OAAO,OAAO,OAAO,eAAe,EAAC,WAAU,MAAK,mCAAkCH,IAAE,UAASG,IAAE,OAAMF,IAAE,mBAAkB,GAAE,aAAY,EAAC,GAAE,OAAO,aAAY,EAAC,OAAM,SAAQ,CAAC,CAAC;",
  "names": ["e", "s", "o", "t", "o", "c", "e", "s"]
}
