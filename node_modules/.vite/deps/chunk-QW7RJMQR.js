import {
  z
} from "./chunk-H74Q4SYB.js";
import {
  _,
  s as s2
} from "./chunk-SMWUT52Z.js";
import {
  G
} from "./chunk-NMQNUPE4.js";
import {
  s
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i
} from "./chunk-QY7XKUIV.js";
import {
  has,
  t
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/views/2d/engine/flow/dataUtils.js
var s3 = () => i.getLogger("esri.views.2d.engine.flow.dataUtils");
var a = 10;
async function c(t2, e, n, o) {
  const i2 = performance.now(), l = f(e, n), c2 = performance.now(), h2 = d(e, l, n.width, n.height), u2 = performance.now(), m2 = w(h2, true), y2 = performance.now(), x2 = "Streamlines" === t2 ? p(m2, a) : g(m2), M2 = performance.now();
  return has("esri-2d-profiler") && (s3().info("I.1", "_createFlowFieldFromData (ms)", Math.round(c2 - i2)), s3().info("I.2", "_getStreamlines (ms)", Math.round(u2 - c2)), s3().info("I.3", "createAnimatedLinesData (ms)", Math.round(y2 - u2)), s3().info("I.4", "create{Streamlines|Particles}Mesh (ms)", Math.round(M2 - y2)), s3().info("I.5", "createFlowMesh (ms)", Math.round(M2 - i2)), s3().info("I.6", "Mesh size (bytes)", x2.vertexData.buffer.byteLength + x2.indexData.buffer.byteLength)), await Promise.resolve(), s(o), x2;
}
function f(t2, e) {
  const n = m(e.data, e.width, e.height, t2.smoothing);
  if (t2.interpolate) {
    return (t3, r) => {
      const o = Math.floor(t3), i2 = Math.floor(r);
      if (o < 0 || o >= e.width) return [0, 0];
      if (i2 < 0 || i2 >= e.height) return [0, 0];
      const l = t3 - o, s4 = r - i2, a2 = o, c2 = i2, f2 = o < e.width - 1 ? o + 1 : o, h2 = i2 < e.height - 1 ? i2 + 1 : i2, u2 = n[2 * (c2 * e.width + a2)], d2 = n[2 * (c2 * e.width + f2)], m2 = n[2 * (h2 * e.width + a2)], w2 = n[2 * (h2 * e.width + f2)], p2 = n[2 * (c2 * e.width + a2) + 1], g2 = n[2 * (c2 * e.width + f2) + 1];
      return [(u2 * (1 - s4) + m2 * s4) * (1 - l) + (d2 * (1 - s4) + w2 * s4) * l, (p2 * (1 - s4) + n[2 * (h2 * e.width + a2) + 1] * s4) * (1 - l) + (g2 * (1 - s4) + n[2 * (h2 * e.width + f2) + 1] * s4) * l];
    };
  }
  return (t3, r) => {
    const o = Math.round(t3), i2 = Math.round(r);
    return o < 0 || o >= e.width || i2 < 0 || i2 >= e.height ? [0, 0] : [n[2 * (i2 * e.width + o)], n[2 * (i2 * e.width + o) + 1]];
  };
}
function h(t2, n, r, o, i2, l, s4, a2) {
  const c2 = [], { raster: f2, width: h2, height: u2, resolutionFactor: d2 } = a2;
  let m2 = o, w2 = i2, p2 = 0, [g2, y2] = r(m2, w2);
  g2 *= n.velocityScale, y2 *= n.velocityScale;
  const x2 = Math.sqrt(g2 * g2 + y2 * y2);
  let M2, A;
  c2.push({ x: m2, y: w2, t: p2, speed: x2 });
  for (let v = 0; v < n.verticesPerLine; v++) {
    let [o2, i3] = r(m2, w2);
    o2 *= n.velocityScale, i3 *= n.velocityScale;
    const a3 = Math.sqrt(o2 * o2 + i3 * i3);
    if (a3 < n.minSpeedThreshold) return c2;
    const g3 = t2 * o2 / a3, y3 = t2 * i3 / a3;
    m2 += g3 * n.segmentLength, w2 += y3 * n.segmentLength, n.wrapAround && (m2 = _(m2, l[0]));
    if (p2 += t2 * n.segmentLength / a3, Math.acos(g3 * M2 + y3 * A) > n.maxTurnAngle) return c2;
    if (n.collisions) {
      let t3 = Math.round(m2 * d2);
      const r2 = Math.round(w2 * d2);
      if (n.wrapAround && (t3 = _(t3, h2)), t3 < 0 || t3 > h2 - 1 || r2 < 0 || r2 > u2 - 1) return c2;
      const o3 = f2[r2 * h2 + t3];
      if (-1 !== o3 && o3 !== s4) return c2;
      f2[r2 * h2 + t3] = s4;
    }
    c2.push({ x: m2, y: w2, t: p2, speed: a3 }), M2 = g3, A = y3;
  }
  return c2;
}
function u(t2, e, n, r, o, i2, l, s4) {
  const a2 = Math.round((0.2 + 0.6 * l.getFloat()) * t2.verticesPerLine), c2 = t2.verticesPerLine - a2, f2 = h(-1, { ...t2, verticesPerLine: c2 }, e, n, r, o, i2, s4), u2 = h(1, { ...t2, verticesPerLine: a2 }, e, n, r, o, i2, s4), d2 = f2.reverse();
  d2.splice(-1, 1);
  return d2.concat(u2);
}
function d(t2, e, n, r, i2 = { positions: [] }) {
  if (t2.density <= 0) return [];
  const { positions: l } = i2, s4 = [], a2 = new t(), c2 = 1 / Math.max(t2.lineCollisionWidth, 1), f2 = Math.round(n * c2), d2 = Math.round(r * c2), m2 = new Int32Array(f2 * d2);
  for (let o = 0; o < m2.length; o++) m2[o] = -1;
  const w2 = { raster: m2, width: f2, height: d2, resolutionFactor: c2 }, p2 = {}, g2 = t2.lineSpacing / Math.sqrt(t2.density), y2 = Math.floor(r / g2), x2 = Math.floor(n / g2);
  for (let o = 0; o < y2; o++) {
    const t3 = o * g2;
    for (let e2 = 0; e2 < x2; e2++) {
      const n2 = e2 * g2;
      p2[`${e2}-${o}`] = { x: n2, y: t3, positions: [] };
    }
  }
  for (const { x: o, y: h2 } of l) {
    const t3 = p2[`${Math.floor(o / g2)}-${Math.floor(h2 / g2)}`];
    t3 && t3.positions.push([o, h2]);
  }
  const M2 = [];
  for (const o in p2) {
    const t3 = p2[o];
    if (0 === t3.positions.length) M2.push({ x: t3.x + g2 / 2, y: t3.y + g2 / 2, sort: 0.66 + 0.33 * a2.getFloat(), stage: 0 });
    else {
      const [e2] = t3.positions.splice(0, 1);
      M2.push({ x: e2[0], y: e2[1], sort: 0.33 * a2.getFloat(), stage: 1 });
      for (const [n2, r2] of t3.positions) M2.push({ x: n2, y: r2, sort: 0.33 + 0.33 * a2.getFloat(), stage: 2 });
    }
  }
  M2.sort((t3, e2) => t3.sort - e2.sort);
  for (const { x: o, y: A, stage: v } of M2) {
    const i3 = t2.onlyForwardTracing ? h(1, t2, e, o, A, [n, r], s4.length, w2) : u(t2, e, o, A, [n, r], s4.length, a2, w2);
    i3.length < 2 || s4.push({ stage: v, vertices: i3 });
  }
  return s4;
}
function m(t2, e, n, r) {
  if (0 === r) return t2;
  const o = Math.round(3 * r), i2 = new Array(2 * o + 1);
  let l = 0;
  for (let c2 = -o; c2 <= o; c2++) {
    const t3 = Math.exp(-c2 * c2 / (r * r));
    i2[c2 + o] = t3, l += t3;
  }
  for (let c2 = -o; c2 <= o; c2++) i2[c2 + o] /= l;
  const s4 = new Float32Array(t2.length);
  for (let c2 = 0; c2 < n; c2++) for (let n2 = 0; n2 < e; n2++) {
    let r2 = 0, l2 = 0;
    for (let s5 = -o; s5 <= o; s5++) {
      if (n2 + s5 < 0 || n2 + s5 >= e) continue;
      const a3 = i2[s5 + o];
      r2 += a3 * t2[2 * (c2 * e + (n2 + s5))], l2 += a3 * t2[2 * (c2 * e + (n2 + s5)) + 1];
    }
    s4[2 * (c2 * e + n2)] = r2, s4[2 * (c2 * e + n2) + 1] = l2;
  }
  const a2 = new Float32Array(t2.length);
  for (let c2 = 0; c2 < e; c2++) for (let t3 = 0; t3 < n; t3++) {
    let r2 = 0, l2 = 0;
    for (let a3 = -o; a3 <= o; a3++) {
      if (t3 + a3 < 0 || t3 + a3 >= n) continue;
      const f2 = i2[a3 + o];
      r2 += f2 * s4[2 * ((t3 + a3) * e + c2)], l2 += f2 * s4[2 * ((t3 + a3) * e + c2) + 1];
    }
    a2[2 * (t3 * e + c2)] = r2, a2[2 * (t3 * e + c2) + 1] = l2;
  }
  return a2;
}
function w(t2, e) {
  const n = new t(), r = t2.reduce((t3, e2) => t3 + e2.vertices.length, 0), i2 = new Float32Array(4 * r), l = new Array(t2.length);
  let s4 = 0, a2 = 0;
  for (const { vertices: o } of t2) {
    const t3 = s4;
    for (const e2 of o) i2[4 * s4] = e2.x, i2[4 * s4 + 1] = e2.y, i2[4 * s4 + 2] = e2.t, i2[4 * s4 + 3] = e2.speed, s4++;
    l[a2++] = { startVertex: t3, numberOfVertices: o.length, totalTime: o[o.length - 1].t, timeSeed: e ? n.getFloat() : 0 };
  }
  return { lineVertices: i2, lineDescriptors: l };
}
function p(t2, e) {
  const n = 9, { lineVertices: r, lineDescriptors: o } = t2;
  let i2 = 0, l = 0;
  for (const d2 of o) {
    i2 += 2 * d2.numberOfVertices;
    l += 6 * (d2.numberOfVertices - 1);
  }
  const s4 = new Float32Array(i2 * n), a2 = new Uint32Array(l);
  let c2 = 0, f2 = 0;
  function h2() {
    a2[f2++] = c2 - 2, a2[f2++] = c2, a2[f2++] = c2 - 1, a2[f2++] = c2, a2[f2++] = c2 + 1, a2[f2++] = c2 - 1;
  }
  function u2(t3, e2, r2, o2, i3, l2, a3, f3) {
    const h3 = c2 * n;
    let u3 = 0;
    s4[h3 + u3++] = t3, s4[h3 + u3++] = e2, s4[h3 + u3++] = 1, s4[h3 + u3++] = r2, s4[h3 + u3++] = l2, s4[h3 + u3++] = a3, s4[h3 + u3++] = o2 / 2, s4[h3 + u3++] = i3 / 2, s4[h3 + u3++] = f3, c2++, s4[h3 + u3++] = t3, s4[h3 + u3++] = e2, s4[h3 + u3++] = -1, s4[h3 + u3++] = r2, s4[h3 + u3++] = l2, s4[h3 + u3++] = a3, s4[h3 + u3++] = -o2 / 2, s4[h3 + u3++] = -i3 / 2, s4[h3 + u3++] = f3, c2++;
  }
  for (const d2 of o) {
    const { totalTime: t3, timeSeed: n2 } = d2;
    let o2 = null, i3 = null, l2 = null, s5 = null, a3 = null, c3 = null;
    for (let f3 = 0; f3 < d2.numberOfVertices; f3++) {
      const m2 = r[4 * (d2.startVertex + f3)], w2 = r[4 * (d2.startVertex + f3) + 1], p2 = r[4 * (d2.startVertex + f3) + 2], g2 = r[4 * (d2.startVertex + f3) + 3];
      let y2 = null, x2 = null, M2 = null, A = null;
      if (f3 > 0) {
        y2 = m2 - o2, x2 = w2 - i3;
        const r2 = Math.sqrt(y2 * y2 + x2 * x2);
        if (y2 /= r2, x2 /= r2, f3 > 1) {
          let t4 = y2 + a3, n3 = x2 + c3;
          const r3 = Math.sqrt(t4 * t4 + n3 * n3);
          t4 /= r3, n3 /= r3;
          const o3 = Math.min(1 / (t4 * y2 + n3 * x2), e);
          t4 *= o3, n3 *= o3, M2 = -n3, A = t4;
        } else M2 = -x2, A = y2;
        null !== M2 && null !== A && (u2(o2, i3, l2, M2, A, t3, n2, g2), h2());
      }
      o2 = m2, i3 = w2, l2 = p2, a3 = y2, c3 = x2, s5 = g2;
    }
    u2(o2, i3, l2, -c3, a3, t3, n2, s5);
  }
  return { vertexData: s4, indexData: a2 };
}
function g(t2) {
  const e = 16, n = 1, r = 2, { lineVertices: o, lineDescriptors: i2 } = t2;
  let l = 0, s4 = 0;
  for (const S of i2) {
    const t3 = S.numberOfVertices - 1;
    l += 4 * t3 * 2, s4 += 6 * t3 * 2;
  }
  const a2 = new Float32Array(l * e), c2 = new Uint32Array(s4);
  let f2, h2, u2, d2, m2, w2, p2, g2, y2, x2, M2, A, v, F, I = 0, V = 0;
  function L() {
    c2[V++] = I - 8, c2[V++] = I - 7, c2[V++] = I - 6, c2[V++] = I - 7, c2[V++] = I - 5, c2[V++] = I - 6, c2[V++] = I - 4, c2[V++] = I - 3, c2[V++] = I - 2, c2[V++] = I - 3, c2[V++] = I - 1, c2[V++] = I - 2;
  }
  function b(t3, o2, i3, l2, s5, c3, f3, h3, u3, d3, m3, w3, p3, g3) {
    const y3 = I * e;
    let x3 = 0;
    for (const e2 of [n, r]) for (const n2 of [1, 2, 3, 4]) a2[y3 + x3++] = t3, a2[y3 + x3++] = o2, a2[y3 + x3++] = i3, a2[y3 + x3++] = l2, a2[y3 + x3++] = f3, a2[y3 + x3++] = h3, a2[y3 + x3++] = u3, a2[y3 + x3++] = d3, a2[y3 + x3++] = e2, a2[y3 + x3++] = n2, a2[y3 + x3++] = p3, a2[y3 + x3++] = g3, a2[y3 + x3++] = s5 / 2, a2[y3 + x3++] = c3 / 2, a2[y3 + x3++] = m3 / 2, a2[y3 + x3++] = w3 / 2, I++;
  }
  function k(t3, e2) {
    let n2 = y2 + M2, r2 = x2 + A;
    const o2 = Math.sqrt(n2 * n2 + r2 * r2);
    n2 /= o2, r2 /= o2;
    const i3 = y2 * n2 + x2 * r2;
    n2 /= i3, r2 /= i3;
    let l2 = M2 + v, s5 = A + F;
    const a3 = Math.sqrt(l2 * l2 + s5 * s5);
    l2 /= a3, s5 /= a3;
    const c3 = M2 * l2 + A * s5;
    l2 /= c3, s5 /= c3, b(f2, h2, u2, d2, -r2, n2, m2, w2, p2, g2, -s5, l2, t3, e2), L();
  }
  function D(t3, e2, n2, r2, o2, i3) {
    if (y2 = M2, x2 = A, M2 = v, A = F, null == y2 && null == x2 && (y2 = M2, x2 = A), null != m2 && null != w2) {
      v = t3 - m2, F = e2 - w2;
      const n3 = Math.sqrt(v * v + F * F);
      v /= n3, F /= n3;
    }
    null != y2 && null != x2 && k(o2, i3), f2 = m2, h2 = w2, u2 = p2, d2 = g2, m2 = t3, w2 = e2, p2 = n2, g2 = r2;
  }
  function P(t3, e2) {
    y2 = M2, x2 = A, M2 = v, A = F, null == y2 && null == x2 && (y2 = M2, x2 = A), null != y2 && null != x2 && k(t3, e2);
  }
  for (const S of i2) {
    f2 = null, h2 = null, u2 = null, d2 = null, m2 = null, w2 = null, p2 = null, g2 = null, y2 = null, x2 = null, M2 = null, A = null, v = null, F = null;
    const { totalTime: t3, timeSeed: e2 } = S;
    for (let n2 = 0; n2 < S.numberOfVertices; n2++) {
      D(o[4 * (S.startVertex + n2)], o[4 * (S.startVertex + n2) + 1], o[4 * (S.startVertex + n2) + 2], o[4 * (S.startVertex + n2) + 3], t3, e2);
    }
    P(t3, e2);
  }
  return { vertexData: a2, indexData: c2 };
}
function y(t2, e, r = e.width, o = e.height, i2 = 0, l = 0) {
  const s4 = e.pixels, a2 = r * o, c2 = 2, f2 = new Float32Array(a2 * c2), h2 = e.width, u2 = (t3, e2) => t3 + i2 + (e2 + l) * h2, d2 = (t3, e2) => t3 + e2 * r;
  let m2;
  if (null != e.mask) if (r !== e.width || o !== e.height || 0 !== i2 || 0 !== l) {
    m2 = new Uint8Array(a2 * c2);
    const t3 = e.mask;
    for (let e2 = 0; e2 < o; ++e2) for (let n = 0; n < r; ++n) {
      const r2 = u2(n, e2), o2 = d2(n, e2);
      m2[c2 * o2] = t3[c2 * r2], m2[c2 * o2 + 1] = t3[c2 * r2 + 1];
    }
  } else m2 = e.mask;
  else m2 = new Uint8Array(a2 * c2), m2.fill(255);
  if ("vector-uv" === t2) for (let n = 0; n < o; ++n) for (let t3 = 0; t3 < r; ++t3) {
    const e2 = u2(t3, n), r2 = d2(t3, n);
    f2[c2 * r2] = s4[0][e2], f2[c2 * r2 + 1] = -s4[1][e2];
  }
  else if ("vector-magdir" === t2) {
    const { cos: t3, sin: e2 } = Math;
    for (let i3 = 0; i3 < o; ++i3) for (let o2 = 0; o2 < r; ++o2) {
      const r2 = u2(o2, i3), l2 = d2(o2, i3), a3 = s4[0][r2], h3 = s2(s4[1][r2]), m3 = t3(h3 - Math.PI / 2), w2 = e2(h3 - Math.PI / 2);
      f2[c2 * l2] = m3 * a3, f2[c2 * l2 + 1] = w2 * a3;
    }
  }
  return { data: f2, mask: m2, width: r, height: o };
}
async function x(t2, e, n, r, o, a2) {
  const c2 = performance.now(), f2 = G(e.spatialReference);
  if (!f2) {
    const i2 = await M(t2, e, n, r, o, a2);
    return has("esri-2d-profiler") && s3().info("I.7", "loadImagery, early exit (ms)", Math.round(performance.now() - c2)), has("esri-2d-profiler") && s3().info("I.9", "Number of parts", 1), i2;
  }
  const [h2, u2] = f2.valid, d2 = u2 - h2, m2 = Math.ceil(e.width / d2), w2 = e.width / m2, p2 = Math.round(n / m2);
  let g2 = e.xmin;
  const y2 = [], x2 = performance.now();
  for (let l = 0; l < m2; l++) {
    const n2 = new z({ xmin: g2, xmax: g2 + w2, ymin: e.ymin, ymax: e.ymax, spatialReference: e.spatialReference });
    y2.push(M(t2, n2, p2, r, o, a2)), g2 += w2;
  }
  const A = await Promise.all(y2);
  if (has("esri-2d-profiler") && s3().info("I.8", "All calls to _fetchPart (ms)", Math.round(performance.now() - x2)), has("esri-2d-profiler") && s3().info("I.9", "Number of parts", A.length), 1 === A.length) return has("esri-2d-profiler") && s3().info("I.10", "loadImagery, general exit without stitching back (ms)", Math.round(performance.now() - c2)), A[0];
  const v = { data: new Float32Array(n * r * 2), mask: new Uint8Array(n * r), width: n, height: r };
  let F = 0;
  for (const i2 of A) {
    for (let t3 = 0; t3 < i2.height; t3++) for (let e2 = 0; e2 < i2.width; e2++) F + e2 >= n || (v.data[2 * (t3 * n + F + e2)] = i2.data[2 * (t3 * i2.width + e2)], v.data[2 * (t3 * n + F + e2) + 1] = i2.data[2 * (t3 * i2.width + e2) + 1], v.mask[t3 * n + F + e2] = i2.mask[t3 * i2.width + e2]);
    F += i2.width;
  }
  return has("esri-2d-profiler") && s3().info("I.10", "loadImagery, general exit (ms)", Math.round(performance.now() - c2)), v;
}
async function M(t2, e, n, r, o, i2) {
  const l = { requestProjectedLocalDirections: true, signal: i2 };
  if (null != o && (l.timeExtent = o), "imagery" === t2.type) {
    await t2.load({ signal: i2 });
    const o2 = await t2.internalFetchImage(e, n, r, l);
    if (null == o2?.pixelData?.pixelBlock) return { data: new Float32Array(n * r * 2), mask: new Uint8Array(n * r), width: n, height: r };
    return y(t2.rasterInfo.dataType, o2.pixelData.pixelBlock);
  }
  await t2.load({ signal: i2 });
  const s4 = await t2.fetchPixels(e, n, r, l);
  if (null == s4?.pixelBlock) return { data: new Float32Array(n * r * 2), mask: new Uint8Array(n * r), width: n, height: r };
  return y(t2.serviceRasterInfo.dataType, s4.pixelBlock);
}

export {
  c,
  f,
  d,
  x
};
//# sourceMappingURL=chunk-QW7RJMQR.js.map
