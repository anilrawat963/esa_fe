import {
  w
} from "./chunk-S4VHS6P4.js";
import {
  Al,
  Cc,
  Dc,
  Hu,
  Js,
  Os,
  Tl,
  Zl,
  m,
  qh
} from "./chunk-RKVVFTIZ.js";
import "./chunk-WJ5RYEGC.js";
import "./chunk-7TAAMEZT.js";
import "./chunk-4POFO7MP.js";
import "./chunk-257FD5T2.js";
import {
  P,
  a,
  f,
  j,
  x2 as x
} from "./chunk-ZNI54T6D.js";
import {
  __addDisposableResource,
  __disposeResources
} from "./chunk-SS5CLIUY.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/chunks/OperatorGeodeticLength.js
var S = class {
  getOperatorType() {
    return 10311;
  }
  supportsCurves() {
    return true;
  }
  accelerateGeometry(e, t, r) {
    return false;
  }
  canAccelerateGeometry(e) {
    return false;
  }
  execute(e, t, f2, x2) {
    if (4 === f2) return new w().execute(e, t, x2);
    if (0 === t.getCoordinateSystemType() && P(""), j(e), e.isEmpty() || e.getDimension() < 1) return 0;
    const S2 = t.getGCS(), P2 = Hu();
    S2.querySpheroidData(P2);
    const d = P2.majorSemiAxis, E = P2.e2, G = S2.getUnit().getUnitToBaseFactor();
    let j2;
    const v = e.getGeometryType();
    if (v === a.enumPolygon ? j2 = e.getBoundary() : v === a.enumEnvelope ? j2 = Js(e) : f(v) ? (j2 = new Os({ vd: e.getDescription() }), j2.addSegment(e, true)) : j2 = e, j2.hasNonLinearSegments()) {
      j2 = new m().execute(j2, 0, t.getTolerance(0), 0, x2);
    }
    if (S2 !== t) {
      const r = t.getSRToGCSTransform();
      if (t.isPannable()) {
        j2 = Al(j2, t), v === a.enumPolyline && j2 === e && (j2 = e.clone());
        const r2 = new x();
        t.getPannableExtent().queryIntervalX(r2);
        for (let e2 = 0, t2 = j2.getPointCount(); e2 < t2; e2++) {
          const t3 = j2.getXY(e2);
          t3.x = Tl(t3.x, r2), j2.setXY(e2, t3);
        }
      }
      const n = j2.createInstance();
      j2 = Zl(r, j2, n, x2) ? n : new qh().execute(j2, r, x2);
    }
    return this._ExecuteMultiPathGeodeticLength(j2, f2, d, E, G);
  }
  _ExecuteMultiPathGeodeticLength(r, n, o, a2, s) {
    const i = { stack: [], error: void 0, hasError: false };
    try {
      const t = __addDisposableResource(i, new Cc(), false);
      let c = 0;
      const m2 = r.querySegmentIterator();
      for (; m2.nextPath(); ) for (; m2.hasNextSegment(); ) {
        const e = m2.nextSegment(), r2 = e.getStartXY(), i2 = e.getEndXY();
        r2.scale(s), i2.scale(s), Dc.geodeticDistance(o, a2, r2.x, r2.y, i2.x, i2.y, t, null, null, n), c += t.val;
      }
      return c;
    } catch (c) {
      i.error = c, i.hasError = true;
    } finally {
      __disposeResources(i);
    }
  }
};
export {
  S as OperatorGeodeticLength
};
//# sourceMappingURL=OperatorGeodeticLength-X3NFKYG3.js.map
