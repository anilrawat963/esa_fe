import {
  t as t3
} from "./chunk-F5JN6VXH.js";
import {
  e as e3
} from "./chunk-4YQFF2F7.js";
import {
  e as e4
} from "./chunk-Y2DYCFJT.js";
import {
  i as i2
} from "./chunk-HUA6ZZZG.js";
import {
  r as r4
} from "./chunk-UP6PVI7I.js";
import {
  Z,
  a as a6,
  l as l5,
  m as m5,
  t as t2
} from "./chunk-6AWERJZ7.js";
import {
  c as c3,
  l as l6,
  n as n5,
  r as r3
} from "./chunk-Y2GQGUGW.js";
import {
  h as h3,
  h2 as h4
} from "./chunk-GGINWBRK.js";
import {
  r as r5,
  s as s3
} from "./chunk-IJG47UFZ.js";
import {
  p as p3
} from "./chunk-Z3EPMK46.js";
import {
  n as n6
} from "./chunk-BCL23HLU.js";
import {
  i as i3
} from "./chunk-ZG2JXORT.js";
import {
  g as g3,
  v as v3,
  y as y3
} from "./chunk-36YQJD5W.js";
import {
  g as g2,
  h as h2,
  p as p2
} from "./chunk-3SCRAN3E.js";
import {
  R,
  b as b2,
  q as q2,
  v as v2
} from "./chunk-NTNXXNRP.js";
import {
  a as a5,
  l as l4
} from "./chunk-IGRCAVBL.js";
import {
  U as U2
} from "./chunk-GD72EK2J.js";
import {
  v
} from "./chunk-BRGWF4BT.js";
import {
  n as n2
} from "./chunk-B3BLJNSM.js";
import {
  e as e2
} from "./chunk-M5JMVUW2.js";
import {
  T as T2,
  d as d4,
  k,
  w as w2
} from "./chunk-2JMKFI2D.js";
import {
  l as l3,
  m as m2
} from "./chunk-VATXM3AM.js";
import {
  n as n4
} from "./chunk-E7PJOFGP.js";
import {
  c
} from "./chunk-4VQDBNTM.js";
import {
  f as f2
} from "./chunk-3BNOOWTA.js";
import {
  c as c2
} from "./chunk-T3SYSTKO.js";
import {
  j as j2,
  o,
  q
} from "./chunk-VYMBX5H5.js";
import {
  h
} from "./chunk-BPTFV5VM.js";
import {
  n as n3
} from "./chunk-36OXW4YN.js";
import {
  a as a4,
  d as d3,
  x
} from "./chunk-23NJHA5Q.js";
import {
  m as m4
} from "./chunk-JZUJ34RR.js";
import {
  u as u3
} from "./chunk-F7DKSAOI.js";
import {
  m as m3
} from "./chunk-4SOQWNPG.js";
import {
  g
} from "./chunk-LTULADK2.js";
import {
  S
} from "./chunk-CNYNCKEV.js";
import {
  d as d2
} from "./chunk-XL5QPCXN.js";
import {
  G,
  J,
  L,
  N as N2,
  W
} from "./chunk-2LC2762W.js";
import {
  O
} from "./chunk-YDTPM7OQ.js";
import {
  n
} from "./chunk-75XOUSSS.js";
import {
  y3 as y2
} from "./chunk-PZ5RULLK.js";
import {
  r as r2
} from "./chunk-OPJX4KXH.js";
import {
  U,
  a as a3,
  f,
  j,
  l as l2,
  w
} from "./chunk-2OFHDVO5.js";
import {
  l
} from "./chunk-TFJXG32O.js";
import {
  E,
  T,
  de
} from "./chunk-NMQNUPE4.js";
import {
  b,
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  a as a2,
  e2 as e,
  p,
  r,
  s as s2,
  t,
  u2 as u,
  u3 as u2,
  y
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  N,
  d
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/views/3d/interactive/editingTools/isSupportedObjectUtils.js
function e5(e8) {
  switch (e8) {
    case 0:
      break;
    case 1:
      return "not owned by a graphics layer";
    case 2:
      return "no geometry";
    case 3:
      return "the geometry type is not supported";
    case 4:
      return "the symbol type is not supported";
  }
  return "";
}

// node_modules/@arcgis/core/views/3d/interactive/editingTools/reshape/isSupportedObject.js
function r6(r9) {
  return t4(r9).result;
}
function t4(r9) {
  if (r9.graphic && "graphics" !== r9.graphic.layer?.type) return { result: 1 };
  if (!r9.operations) return { result: 2 };
  const t6 = r9.operations.data.type, e8 = r9.operations.data.geometry;
  return "point" === t6 || "mesh" === t6 || "polyline" === t6 || "polygon" === t6 ? { result: 0, geometry: e8 } : { result: 3 };
}

// node_modules/@arcgis/core/views/3d/interactive/editingTools/transform/isSupportedGraphic.js
function e6(e8) {
  if ("graphics" !== e8.layer?.type) return 1;
  if (null == e8.geometry) return 2;
  switch (e8.geometry.type) {
    case "point":
      break;
    case "polygon":
    case "polyline":
    case "multipoint":
    case "extent":
    case "mesh":
      return 0;
    default:
      return 3;
  }
  const t6 = null != e8.symbol && "point-3d" === e8.symbol.type && e8.symbol.symbolLayers;
  return t6 && t6.some((e9) => "object" === e9.type) ? 0 : 4;
}

// node_modules/@arcgis/core/views/interactive/snapping/FeatureSnappingLayerSource.js
var i4 = class extends b {
  constructor(o3) {
    super(o3), this.layer = null, this.enabled = true, this.updating = false, this.availability = 1, this.sublayerSources = new O();
  }
};
__decorate([m({ constructOnly: true })], i4.prototype, "layer", void 0), __decorate([m()], i4.prototype, "enabled", void 0), __decorate([m()], i4.prototype, "updating", void 0), __decorate([m()], i4.prototype, "availability", void 0), __decorate([m()], i4.prototype, "sublayerSources", void 0), i4 = __decorate([a("esri.views.interactive.snapping.FeatureSnappingLayerSource")], i4);

// node_modules/@arcgis/core/views/interactive/snapping/SnappingOptions.js
var u4 = class extends b {
  constructor(e8) {
    super(e8), this.enabled = false, this.enabledToggled = false, this.forceDisabled = false, this.selfEnabled = true, this.featureEnabled = true, this.gridEnabled = false, this.attributeRulesEnabled = false, this.featureSources = new O(), this.distance = p3.distance, this.touchSensitivityMultiplier = p3.touchSensitivityMultiplier;
  }
  get effectiveEnabled() {
    return !this.forceDisabled && (this.enabledToggled ? !this.enabled : this.enabled);
  }
  get effectiveGridEnabled() {
    return this.effectiveEnabled && this.gridEnabled;
  }
  get effectiveSelfEnabled() {
    return this.effectiveEnabled && this.selfEnabled;
  }
  get effectiveFeatureEnabled() {
    return this.effectiveEnabled && this.featureEnabled;
  }
  get _effectiveFeatureSources() {
    const e8 = this.featureSources;
    e8.some(c4) && i.getLogger(this).warnOnce("Do not configure SubtypeGroupLayer sources in SnappingOptions.featureSources directly. Create a FeatureSnappingLayerSource for each SubtypeSublayer.");
    const t6 = e8.filter(d5), s7 = this._get("_effectiveFeatureSources")?.filter(c4) ?? new O();
    for (const r9 of t6) {
      const e9 = s7.find((e10) => e10.layer === r9.layer.parent);
      if (e9) e9.sublayerSources.includes(r9) || e9.sublayerSources.add(r9);
      else if (r9.layer.parent) {
        const e10 = new i4({ layer: r9.layer.parent });
        e10.sublayerSources.add(r9), s7.add(e10);
      }
    }
    for (const r9 of s7) {
      const e9 = r9.sublayerSources.filter((e10) => !t6.includes(e10));
      r9.sublayerSources.removeMany(e9);
    }
    s7.removeMany(s7.filter((e9) => 0 === e9.sublayerSources.length));
    const a11 = e8.filter(p4), l8 = this._get("_effectiveFeatureSources") ?? new O(), { added: u6, removed: f4 } = d(l8.toArray(), [...a11, ...s7]);
    return l8.removeMany(f4), l8.addMany(u6), l8;
  }
};
function c4(e8) {
  return "subtype-group" === e8.layer.type;
}
function p4(e8) {
  return "subtype-group" !== e8.layer.type;
}
function d5(e8) {
  return "subtype-sublayer" === e8.layer.type;
}
__decorate([m()], u4.prototype, "enabled", void 0), __decorate([m()], u4.prototype, "enabledToggled", void 0), __decorate([m()], u4.prototype, "forceDisabled", void 0), __decorate([m()], u4.prototype, "selfEnabled", void 0), __decorate([m()], u4.prototype, "featureEnabled", void 0), __decorate([m()], u4.prototype, "gridEnabled", void 0), __decorate([m()], u4.prototype, "attributeRulesEnabled", void 0), __decorate([m({ type: O.ofType(i4) })], u4.prototype, "featureSources", void 0), __decorate([m()], u4.prototype, "distance", void 0), __decorate([m()], u4.prototype, "touchSensitivityMultiplier", void 0), __decorate([m({ readOnly: true })], u4.prototype, "effectiveEnabled", null), __decorate([m({ readOnly: true })], u4.prototype, "effectiveGridEnabled", null), __decorate([m({ readOnly: true })], u4.prototype, "effectiveSelfEnabled", null), __decorate([m({ readOnly: true })], u4.prototype, "effectiveFeatureEnabled", null), __decorate([m({ readOnly: true })], u4.prototype, "_effectiveFeatureSources", null), u4 = __decorate([a("esri.views.interactive.snapping.SnappingOptions")], u4);

// node_modules/@arcgis/core/views/support/geodesicLengthMeasurementUtils.js
function m6(e8) {
  const { spatialReference: t6 } = e8;
  return t2(t6, j3, h5, e8);
}
function f3(e8, t6) {
  if (!T(e8.spatialReference, t6.spatialReference)) return null;
  const { spatialReference: r9 } = e8;
  return x2[0] = e8.x, x2[1] = e8.y, x2[2] = e8.hasZ ? e8.z : 0, U3[0] = t6.x, U3[1] = t6.y, U3[2] = t6.hasZ ? t6.z : 0, p5(x2, U3, r9);
}
function p5(e8, t6, r9) {
  return t2(r9, y4, d6, e8, t6, r9);
}
var l7 = { geodesicLength: m6, geodesicDistanceBetweenPoints: f3, geodesicDistance: p5 };
async function g4() {
  return await m2(), l7;
}
function y4(t6, r9, n11) {
  return a5(q2(w3, t6, r9, n11).distance, "meters");
}
function d6(t6, r9, n11) {
  return a5(l3(R2(t6, r9, n11), { unit: "meters" }), "meters");
}
function j3(t6) {
  return a5(R([t6], "meters")[0], "meters");
}
function h5(t6) {
  return a5(l3(t6, { unit: "meters" }), "meters");
}
function R2(e8, t6, n11) {
  return new y2({ spatialReference: n11, paths: [[[...e8], [...t6]]] });
}
var w3 = new b2();
var x2 = n();
var U3 = n();

// node_modules/@arcgis/core/views/interactive/snapping/SnappingManager.js
var q3 = class extends l {
  constructor(e8) {
    super(e8), this.options = new u4(), this._engineCache = /* @__PURE__ */ new Map(), this._loadTask = null, this._engines = [], this._currentMainCandidate = null, this._currentOtherActiveCandidates = [], this._currentSnappedType = 0;
  }
  initialize() {
    this.addHandles([l2(() => {
      const { distance: e8, touchSensitivityMultiplier: t6, effectiveSelfEnabled: n11, effectiveFeatureEnabled: i5, effectiveGridEnabled: s7 } = this.options;
      return { selfEnabled: n11, featureEnabled: i5, gridEnabled: "2d" === this.view.type && s7, viewReady: this.view.ready, viewSpatialReference: this.view.spatialReference, distance: e8, touchSensitivityMultiplier: t6 };
    }, (e8, n11) => {
      n11 && (this.doneSnapping(), this.emit("changed")), this._loadTask?.abort(), this._loadTask = d2((t6) => this._updateEngines(e8, n11, t6));
    }, w), l2(() => this.options, (e8) => {
      for (const t6 of this._engines) t6.options = e8;
    }, U)]);
  }
  destroy() {
    this._loadTask?.abort(), this._destroyEngines();
  }
  get updating() {
    return this._engines.some((e8) => e8.updating) || !this._loadTask?.finished;
  }
  _destroyEngines() {
    this._engineCache.forEach((e8) => e8.destroy()), this._engineCache.clear(), this._engines = [];
  }
  async _updateEngines(e8, t6, n11) {
    if (!e8.viewReady) return void this._destroyEngines();
    t6?.viewSpatialReference !== e8.viewSpatialReference && this._destroyEngines();
    const i5 = this._engineCache, s7 = await Promise.allSettled([e8.featureEnabled && !i5.has("feature") ? this._createFeatureSnappingEngine(n11) : void 0, e8.selfEnabled && !i5.has("self") ? this._createSelfSnappingEngine(n11) : void 0, e8.gridEnabled && !i5.has("grid") ? this._createGridSnappingEngine(n11) : void 0]);
    if (n11.aborted) for (const a11 of s7) "fulfilled" === a11.status && a11.value?.engine.destroy();
    else {
      for (const e9 of s7) "fulfilled" === e9.status && e9.value && i5.set(e9.value.type, e9.value.engine);
      this._engines = Array.from(i5.values());
    }
  }
  async _createSelfSnappingEngine(e8) {
    const [{ SelfSnappingEngine: t6 }, n11] = await Promise.all([import("./SelfSnappingEngine-F2YJNA7I.js"), g4()]);
    return s2(e8), { type: "self", engine: new t6({ view: this.view, options: this.options, geodesicLengthMeasurementUtils: n11 }) };
  }
  async _createGridSnappingEngine(e8) {
    const { view: t6 } = this;
    if ("2d" !== t6.type) return;
    const { GridSnappingEngine: n11 } = await import("./GridSnappingEngine-QLMSZ377.js");
    return s2(e8), { type: "grid", engine: new n11({ view: t6, options: this.options }) };
  }
  async _createFeatureSnappingEngine(e8) {
    const { FeatureSnappingEngine: t6 } = await import("./FeatureSnappingEngine-SWXZJT3B.js");
    s2(e8);
    const { view: n11, options: s7 } = this, { spatialReference: a11 } = n11;
    return { type: "feature", engine: new t6({ view: n11, options: s7, spatialReference: a11 }) };
  }
  get _squaredMouseProximityThreshold() {
    return this.options.distance * this.options.distance;
  }
  get _squaredTouchProximityThreshold() {
    const { distance: e8, touchSensitivityMultiplier: t6 } = this.options, n11 = e8 * t6;
    return n11 * n11;
  }
  snap(e8) {
    return O2(e8) ? this._snapMultiPoint(e8) : this._snapSinglePoint(e8);
  }
  update(e8) {
    const { point: t6, context: n11 } = e8;
    this._removeVisualization();
    const i5 = this._currentMainCandidate;
    if (null == i5) return t6;
    const s7 = this._selectUpdateInput(e8);
    if (null == s7) return t6;
    const { spatialReference: a11 } = n11, r9 = W(s7, a11);
    if (null == r9) return t6;
    const { view: o3 } = this, { elevationInfo: p7, visualizer: d8 } = n11, l8 = [], h7 = h2(r9, o3, p7), _ = i5.constraint.closestTo(h7);
    if (!this._arePointsWithinScreenThreshold(h7, _, n11) || !z(i5, n11.drawConstraints)) return this._resetSnappingState(), t6;
    i5.targetPoint = p2(_), l8.push(...i5.hints);
    for (const c6 of this._currentOtherActiveCandidates) z(c6, n11.drawConstraints) && (c6.targetPoint = p2(_), l8.push(...c6.hints));
    return null != d8 && this.addHandles(d8.draw(l8, { spatialReference: a11, elevationInfo: H(n11), view: o3, selfSnappingZ: n11.selfSnappingZ }), b3), g2(_, o3, t6, n11);
  }
  doneSnapping() {
    this._removeVisualization(), this._resetSnappingState();
  }
  _selectUpdateInput({ point: e8, scenePoint: t6 }) {
    switch (this._currentSnappedType) {
      case 0:
        return e8;
      case 1:
        return t6;
    }
  }
  _resetSnappingState() {
    this._currentMainCandidate = null, this._currentOtherActiveCandidates = [], this._currentSnappedType = 0;
  }
  _removeVisualization() {
    this.removeHandles(b3);
  }
  async _snapSinglePoint({ point: e8, context: t6, signal: n11 }) {
    const { view: i5 } = this, { elevationInfo: s7 } = t6, a11 = h2(e8, i5, s7), r9 = await this._fetchCandidates(a11, 3, t6, n11);
    return this._createSnapResult(a11, 0, r9, i5, e8, t6, n11);
  }
  async _snapMultiPoint({ point: e8, scenePoint: t6, context: n11, signal: i5 }) {
    const { view: s7 } = this, { coordinateHelper: a11, elevationInfo: r9, spatialReference: o3 } = n11;
    await N2(t6.spatialReference, o3);
    const p7 = W(t6, o3), d8 = h2(p7, s7, r9), h7 = await this._fetchCandidates(d8, 1, n11, i5);
    if (h7.length > 0) {
      const e9 = await this._fetchCandidates(d8, 2, n11, i5);
      return this._createSnapResult(d8, 1, [...h7, ...e9], s7, p7, n11, i5);
    }
    const f4 = h2(e8, s7, r9), g6 = await this._fetchCandidates(f4, 2, n11, i5);
    return this._createSnapResult(f4, 0, g6, s7, { z: a11.hasZ() && e8.hasZ ? e8.z ?? 0 : void 0, m: a11.hasM() && e8.hasM ? e8.m ?? 0 : void 0 }, n11, i5);
  }
  async _fetchCandidates(e8, t6, n11, i5) {
    return (await Promise.all(this._engines.map((s7) => s7.fetchCandidates(e8, t6, n11, i5)))).flat();
  }
  _createSnapResult(e8, t6, n11, i5, a11, r9, o3) {
    return { get valid() {
      return !a2(o3);
    }, apply: () => {
      const { spatialReference: s7 } = r9, { snappedPoint: o4, hints: p7 } = this._processCandidates(e8, t6, n11, r9);
      return this._removeVisualization(), null != r9.visualizer && this.addHandles(r9.visualizer.draw(p7, { spatialReference: s7, elevationInfo: U2, view: i5, selfSnappingZ: r9.selfSnappingZ }), b3), g2(o4, i5, a11, r9);
    } };
  }
  _processCandidates(e8, t6, n11, i5) {
    if (n11.length < 1) return this.doneSnapping(), { snappedPoint: e8, hints: [] };
    this._currentSnappedType !== t6 && this._resetSnappingState(), y3(e8, n11);
    const s7 = this._currentMainCandidate;
    if (null != s7) {
      const a11 = U4(s7, n11);
      if (a11 >= 0) {
        if (!(n11[a11] instanceof n6)) return this._intersectWithOtherCandidates(a11, n11, e8, t6, i5);
        if (this._arePointsWithinScreenThreshold(e8, s7.targetPoint, i5)) return this._updateSnappingCandidate(s7, t6, n11, i5);
      }
    }
    return this._intersectWithOtherCandidates(0, n11, e8, t6, i5);
  }
  _intersectWithOtherCandidates(e8, t6, n11, i5, s7) {
    const { coordinateHelper: a11 } = s7, r9 = t6[e8], o3 = [];
    for (let p7 = 0; p7 < t6.length; ++p7) {
      if (p7 === e8) continue;
      const i6 = t6[p7], s8 = r9.constraint.intersect(i6.constraint);
      if (s8) for (const e9 of s8.closestPoints(r9.targetPoint)) o3.push([new n6(p2(e9), r9, i6, i6.isDraped), this._squaredScreenDistance(n11, e9, a11)]);
    }
    return o3.length > 0 && (o3.sort((e9, t7) => e9[1] - t7[1]), o3[0][1] < this._squaredPointProximityThreshold(s7.pointer)) ? this._updateSnappingCandidate(o3[0][0], i5, t6, s7) : z(r9, s7.drawConstraints) ? this._updateSnappingCandidate(r9, i5, t6, s7) : { snappedPoint: n11, hints: [] };
  }
  _updateSnappingCandidate(e8, t6, n11, i5) {
    this.doneSnapping(), this._currentMainCandidate = e8, this._currentSnappedType = t6;
    const s7 = this._currentMainCandidate.targetPoint, a11 = [];
    a11.push(...e8.hints);
    for (const r9 of n11) {
      if (e8 instanceof n6) {
        if (r9.constraint.equals(e8.first.constraint) || r9.constraint.equals(e8.second.constraint)) continue;
      } else if (r9.constraint.equals(e8.constraint)) continue;
      const t7 = r9.constraint.closestTo(s7);
      this._squaredScreenDistance(t7, s7, i5.coordinateHelper) < x3() && (r9.targetPoint = s7, this._currentOtherActiveCandidates.push(r9), a11.push(...r9.hints));
    }
    return { snappedPoint: s7, hints: a11 };
  }
  _squaredPointProximityThreshold(e8) {
    return "touch" === e8 ? this._squaredTouchProximityThreshold : this._squaredMouseProximityThreshold;
  }
  _arePointsWithinScreenThreshold(e8, t6, n11) {
    return this._squaredScreenDistance(e8, t6, n11.coordinateHelper) < this._squaredPointProximityThreshold(n11.pointer);
  }
  _squaredScreenDistance(e8, t6, n11) {
    return g3(this._toScreen(e8, n11), this._toScreen(t6, n11));
  }
  _toScreen(e8, t6) {
    return s3(e8, t6.spatialReference, U2, this.view);
  }
  get test() {
  }
};
__decorate([m({ constructOnly: true })], q3.prototype, "view", void 0), __decorate([m()], q3.prototype, "options", void 0), __decorate([m({ readOnly: true })], q3.prototype, "updating", null), __decorate([m()], q3.prototype, "_loadTask", void 0), __decorate([m()], q3.prototype, "_engines", void 0), __decorate([m()], q3.prototype, "_squaredMouseProximityThreshold", null), __decorate([m()], q3.prototype, "_squaredTouchProximityThreshold", null), q3 = __decorate([a("esri.views.interactive.snapping.SnappingManager")], q3);
var b3 = "visualization-handle";
function x3() {
  return p3.satisfiesConstraintScreenThreshold * p3.satisfiesConstraintScreenThreshold;
}
function z(e8, t6) {
  return !t6 || null == t6.direction && null == t6.distance || !(e8 instanceof e4 || e8 instanceof i2 || e8 instanceof i3 || e8 instanceof h3 || e8 instanceof h4) && (!(e8 instanceof r5) || null == t6.direction && 1 === e8.selfSnappingType);
}
function U4(e8, t6) {
  return e8 instanceof n6 ? I(t6, e8.first) >= 0 && I(t6, e8.second) >= 0 ? 0 : -1 : I(t6, e8);
}
function I(e8, t6) {
  let n11 = -1;
  for (let i5 = 0; i5 < e8.length; ++i5) if (t6.constraint.equals(e8[i5].constraint)) {
    n11 = i5;
    break;
  }
  return n11;
}
function O2(e8) {
  return null != e8.scenePoint;
}
function H({ coordinateHelper: e8, elevationInfo: t6 }) {
  return e8.hasZ() ? U2 : t6;
}

// node_modules/@arcgis/core/views/support/euclideanAreaMeasurementUtils.js
function g5(t6, o3 = U5()) {
  return h6(t6, o3);
}
function j4(t6, o3 = U5()) {
  return h6(t6, o3, false);
}
function h6(r9, g6, j5 = r9.hasZ) {
  const h7 = l5(r9.spatialReference), U6 = de(h7);
  if (null == U6) return null;
  const v5 = (t6, o3) => !(o3.length < 2) && (o(t6, o3[0], o3[1], j5 && o3[2] || 0), true);
  let x4 = 0;
  for (const t6 of r9.rings) {
    const o3 = t6.length;
    if (o3 < 3) continue;
    const { positionsWorldCoords: a11 } = g6;
    for (; a11.length < o3; ) a11.push(n());
    const j6 = y5, U7 = o(d7, 0, 0, 0), C = 1 / o3;
    for (let n11 = 0; n11 < o3; n11++) {
      if (!v5(j6, t6[n11])) return null;
      if (!n2(j6, r9.spatialReference, a11[n11], h7)) return null;
      q(U7, U7, a11[n11], C);
    }
    const R3 = w2(a11[0], a11[1], U7, d4());
    if (0 === j2(k(R3))) continue;
    for (let t7 = 0; t7 < o3; t7++) T2(R3, U7, a11[t7], a11[t7]);
    const V = k2(a11);
    for (let t7 = 0; t7 < V.length; t7 += 3) x4 += v(a11[V[t7]], a11[V[t7 + 1]], a11[V[t7 + 2]]);
  }
  return l4(x4, U6);
}
var y5 = n();
var d7 = n();
function U5() {
  return { positionsWorldCoords: [] };
}
function k2(t6) {
  return e2(v4(t6), [], 2);
}
function v4(t6) {
  const o3 = new Float64Array(2 * t6.length);
  for (let r9 = 0; r9 < t6.length; ++r9) {
    const n11 = t6[r9], e8 = 2 * r9;
    o3[e8] = n11[0], o3[e8 + 1] = n11[1];
  }
  return o3;
}

// node_modules/@arcgis/core/views/support/geodesicAreaMeasurementUtils.js
var s4 = (e8) => ({ geodesicArea(r9) {
  const { spatialReference: s7 } = r9;
  return t2(s7, n7, (r10) => a7(e8, r10), r9);
} });
async function o2() {
  const e8 = await import("./geometryEngine-2B2KU6X2.js");
  return s4(e8);
}
function n7(t6) {
  return l4(Math.abs(v2([t6], "square-meters")[0]), "square-meters");
}
function a7(r9, t6) {
  try {
    return l4(Math.abs(r9.geodesicArea(t6, "square-meters")), "square-meters");
  } catch (s7) {
    return null;
  }
}

// node_modules/@arcgis/core/views/support/automaticAreaMeasurementUtils.js
var n8 = (o3) => ({ autoAreaByElevationMode(n11, a11, u6 = U5()) {
  if ("on-the-ground" === a11) {
    const e8 = o3.geodesicArea(n11);
    return null != e8 ? e8 : j4(n11, u6);
  }
  return g5(n11, u6);
}, autoArea2D(t6, r9 = U5()) {
  return this.autoAreaByElevationMode(t6, "on-the-ground", r9);
} });
var a8 = null;
async function u5() {
  return a8 || (a8 = n8(await o2())), a8;
}

// node_modules/@arcgis/core/views/support/automaticLengthMeasurementUtils.js
function s5(e8) {
  return { autoLength2D: (t6) => e8.geodesicLength(t6) ?? a6(t6), autoDistanceBetweenPoints2D: (t6, i5) => e8.geodesicDistanceBetweenPoints(t6, i5) ?? m5(t6, i5), autoDistance2D: (n11, i5, o3) => (r7[0] = n11[0], r7[1] = n11[1], r7[2] = 3 === n11.length ? n11[2] : 0, a9[0] = i5[0], a9[1] = i5[1], a9[2] = 3 === i5.length ? i5[2] : 0, e8.geodesicDistance(r7, a9, o3) ?? Z(r7, a9, o3)) };
}
async function c5() {
  return s5(await g4());
}
var r7 = n();
var a9 = n();

// node_modules/@arcgis/core/widgets/Sketch/adapters/layer/GraphicsLayerAdapter.js
var t5 = class {
  constructor(r9) {
    this.layer = r9;
  }
  get elevationInfo() {
    return this.layer.elevationInfo;
  }
  add(r9) {
    this.layer.add(r9);
  }
  addMany(r9) {
    this.layer.addMany(r9);
  }
  onGraphicsChange(r9) {
    const { layer: o3 } = this;
    return a3(() => o3.graphics, "change", (e8) => r9(e8));
  }
  has(r9) {
    return r9.layer === this.layer;
  }
  remove(r9) {
    this.layer.remove(r9);
  }
  removeMany(r9) {
    this.layer.removeMany(r9);
  }
  removeAll() {
    this.layer.removeAll();
  }
};
__decorate([m()], t5.prototype, "elevationInfo", null);

// node_modules/@arcgis/core/widgets/Sketch/adapters/layer/MapNotesLayerAdapter.js
var a10 = class {
  constructor(r9) {
    this.layer = r9;
  }
  get elevationInfo() {
  }
  add(r9, e8) {
    const o3 = this._getSublayerForCreateTool(e8) ?? this._getSublayerForGraphic(r9);
    o3?.add(r9);
  }
  addMany(r9, e8) {
    if (e8) {
      const o3 = this._getSublayerForCreateTool(e8);
      if (o3) return void o3.addMany(r9);
    }
    r9.forEach((r10) => this._getSublayerForGraphic(r10)?.add(r10));
  }
  onGraphicsChange(r9) {
    const { layer: t6 } = this;
    if (t6.sublayers?.length) return t(t6.sublayers?.toArray().map((e8) => a3(() => e8.graphics, "change", (e9) => r9(e9))));
  }
  has(r9) {
    const { layer: e8 } = this;
    return r9.layer === e8 || r9.sourceLayer === e8 || !!e8.sublayers?.some((e9) => r9.layer === e9 || r9.sourceLayer === e9);
  }
  remove(r9) {
    this._getSublayerForGraphic(r9)?.remove(r9);
  }
  removeMany(r9) {
    r9.forEach((r10) => this._getSublayerForGraphic(r10)?.remove(r10));
  }
  removeAll() {
    this.layer.sublayers?.forEach((r9) => r9.removeAll());
  }
  _getSublayerForCreateTool(r9) {
    const { layer: e8 } = this;
    switch (r9) {
      case "point":
        return e8.pointLayer;
      case "polyline":
        return e8.polylineLayer;
      case "polygon":
        return e8.polygonLayer;
      case "multipoint":
        return e8.multipointLayer;
      case "text":
        return e8.textLayer;
    }
  }
  _getSublayerForGraphic(r9) {
    const { layer: e8 } = this;
    if (r9?.geometry) switch (r9.geometry.type) {
      case "point":
        return "text" === r9.symbol?.type ? e8.textLayer : e8.pointLayer;
      case "polyline":
        return e8.polylineLayer;
      case "polygon":
        return e8.polygonLayer;
      case "multipoint":
        return e8.multipointLayer;
    }
  }
};
__decorate([m()], a10.prototype, "elevationInfo", null);

// node_modules/@arcgis/core/widgets/Sketch/support/OperationHandle.js
var s6 = class extends l {
  constructor(e8) {
    super(e8), this.cancelled = false, this.history = { undo: [], redo: [] }, this.type = null;
  }
  get tool() {
    const { activeComponent: e8 } = this;
    if (!e8) return null;
    switch (e8.type) {
      case "graphic-mover":
      case "move-3d":
        return "move";
      case "box":
      case "transform-3d":
        return "transform";
      case "reshape":
      case "reshape-3d":
        return "reshape";
      case "draw-2d":
        return "text" === e8.graphicSymbol?.type ? "text" : e8.geometryType;
      case "draw-3d":
        return e8.geometryType;
    }
    return null;
  }
  addToHistory(e8) {
    this.history.redo = [], this.history.undo.push(e8);
  }
  resetHistory() {
    this.history.redo = [], this.history.undo = [];
  }
  canUndo() {
    return this.history.undo.length > 0;
  }
  canRedo() {
    return this.history.redo.length > 0;
  }
  complete() {
    this._reset(), this.onEnd(), this.emit("complete");
  }
  cancel() {
    this.cancelled = true, this.complete();
  }
  _reset() {
    this.activeComponent?.reset();
  }
  refreshComponent() {
    const e8 = this.activeComponent;
    e8 && ("box" !== e8.type && "reshape" !== e8.type && "graphic-mover" !== e8.type || e8.refresh());
  }
  set undo(e8) {
    this._set("undo", () => {
      this.canUndo() && e8();
    });
  }
  set redo(e8) {
    this._set("redo", () => {
      this.canRedo() && e8();
    });
  }
};
__decorate([m()], s6.prototype, "activeComponent", void 0), __decorate([m()], s6.prototype, "cancelled", void 0), __decorate([m()], s6.prototype, "history", void 0), __decorate([m()], s6.prototype, "tool", null), __decorate([m()], s6.prototype, "type", void 0), __decorate([m()], s6.prototype, "canUndo", null), __decorate([m()], s6.prototype, "canRedo", null), __decorate([m()], s6.prototype, "onEnd", void 0), __decorate([m()], s6.prototype, "undo", null), __decorate([m()], s6.prototype, "redo", null), __decorate([m()], s6.prototype, "toggleTool", void 0), __decorate([m()], s6.prototype, "addToSelection", void 0), __decorate([m()], s6.prototype, "removeFromSelection", void 0), s6 = __decorate([a("esri.widgets.Sketch.support.OperationHandle")], s6);
var p6 = class extends s6 {
};
__decorate([m()], p6.prototype, "activeComponent", void 0), p6 = __decorate([a("esri.widgets.Sketch.support.OperationHandle.CreateOperationHandle")], p6);
var n9 = class extends s6 {
};
__decorate([m()], n9.prototype, "activeComponent", void 0), n9 = __decorate([a("esri.widgets.Sketch.support.OperationHandle.UpdateOperationHandle")], n9);

// node_modules/@arcgis/core/widgets/Sketch/support/sketchUtils.js
function e7(e8, n11) {
  if ("freehandPolygon" === n11 || "freehandPolyline" === n11) return "freehand";
  return e8 ?? ("rectangle" === n11 || "circle" === n11 ? "hybrid" : "click");
}
function n10(e8) {
  switch (e8) {
    case "freehandPolygon":
      return "polygon";
    case "freehandPolyline":
      return "polyline";
    case "text":
      return "point";
    default:
      return e8;
  }
}
function r8(e8) {
  if (e8.length > 1) return false;
  const n11 = e8.at(0)?.geometry;
  return "point" === n11?.type || "multipoint" === n11?.type && n11.points.length < 2;
}

// node_modules/@arcgis/core/widgets/Sketch/SketchViewModel.js
var pe = { defaultZ: 0 };
var le = { reshapeOptions: { edgeOperation: "split", shapeOperation: "move", vertexOperation: "move" }, enableMoveAllGraphics: true, enableRotation: true, enableScaling: true, multipleSelectionEnabled: true, preserveAspectRatio: false, toggleToolOnClick: true, enableZ: true, highlightOptions: { enabled: true, name: c2 }, tool: "transform" };
var he = Symbol();
var ce = Symbol();
var de2 = class extends l {
  constructor(e8) {
    super(e8), this._defaultSnappingManager = null, this._internalGraphicsLayer = new n3({ listMode: "hide", internal: true, title: "SVM Internal" }), this._operationHandle = null, this._updatingHandles = new h(), this._viewHandlesKey = "viewHandles", this.activeFillSymbol = null, this.activeLineSymbol = null, this.activeVertexSymbol = null, this.allowDeleteKey = true, this.layer = null, this.pointSymbol = new u3({ style: "circle", size: 6, color: [255, 255, 255], outline: { color: [50, 50, 50], width: 1 } }), this.polygonSymbol = new m4({ color: [150, 150, 150, 0.2], outline: { color: [50, 50, 50], width: 2 } }), this.polylineSymbol = new m3({ color: [130, 130, 130, 1], width: 2 }), this.meshSymbol = new a4({ symbolLayers: new O([new d3()]) }), this.textSymbol = new g({ text: "text" }), this.updateGraphics = new O(), this.updateOnGraphicClick = true, this.creationMode = "single", this.vertexSymbol = new u3({ style: "circle", size: 6, color: [255, 255, 255], outline: { color: [50, 50, 50], width: 1 } }), this.sketchOptions = new l6(), this._moduleLoaderAbortController = null, this._viewReadyAbortController = null, this._sketchContinuationFlag = false, this._onLayerAdapterChange = async () => {
      const { _layerAdapter: e9 } = this;
      if (this.removeHandles(ce), !e9) return;
      const o3 = [e9.onGraphicsChange((e10) => this._onLayerGraphicsChangeCallback(e10)), l2(() => e9.elevationInfo, (e10) => {
        e10 !== this._internalGraphicsLayer.elevationInfo && (this.cancel(), this._internalGraphicsLayer.elevationInfo = e10);
      }, w)].filter(N);
      this.addHandles(o3, ce);
    }, this._originalPopupEnabled = null, this.defaultCreateOptions = pe, this.defaultUpdateOptions = le, this.snappingOptions = e8?.snappingManager?.options ?? e8?.snappingOptions ?? new u4();
  }
  initialize() {
    this.addHandles([a3(() => this.view?.map?.layers, "change", (e8) => {
      this.layer && e8.removed.includes(this.layer) && this.cancel();
    }), l2(() => this._layerAdapter, () => this._onLayerAdapterChange(), w), l2(() => this.view, (e8) => {
      this._defaultSnappingManager = u(this._defaultSnappingManager), e8 && (this.snappingManager || (this._defaultSnappingManager = new q3({ view: e8, options: this.snappingOptions })), "2d" === e8.type ? import("./editingTools-7G272MXS.js") : "3d" === e8.type && (import("./editingTools-WAH3GP4C.js"), import("./GraphicsLayerView3D-HZH7HNVH.js")));
    }, w), l2(() => this.view?.spatialReference, (e8, t6) => {
      e8 && t6 && !e8.equals(t6) && this.cancel();
    })]), v3(this);
  }
  destroy() {
    this.cancel(), this._removeDefaultLayer(), this._defaultSnappingManager = u(this._defaultSnappingManager), this._set("snappingManager", null), this._set("view", null), this._updatingHandles.destroy(), this.emit("destroy");
  }
  get _layerAdapter() {
    const { layer: e8 } = this;
    switch (e8?.type) {
      case "graphics":
        return new t5(e8);
      case "map-notes":
        return new a10(e8);
      default:
        return null;
    }
  }
  get activeTool() {
    return this._operationHandle?.tool ?? null;
  }
  get activeCreateToolDrawMode() {
    return "create" === this._operationHandle?.type && this._operationHandle.activeComponent && "mode" in this._operationHandle.activeComponent ? this._operationHandle.activeComponent.mode : null;
  }
  get activeTooltip() {
    const { activeComponent: e8, destroyed: t6 } = this, o3 = !t6 && e8 && "tooltip" in e8 ? e8.tooltip : null;
    return o3?.visible ? o3 : null;
  }
  get activeComponent() {
    return this._operationHandle?.activeComponent ?? null;
  }
  get createGraphic() {
    return null == this.activeComponent || "draw-3d" !== this.activeComponent.type && "draw-2d" !== this.activeComponent.type ? this._get("createGraphic") : this.activeComponent.graphic;
  }
  get defaultCreateOptions() {
    return this._get("defaultCreateOptions");
  }
  set defaultCreateOptions(e8) {
    this._set("defaultCreateOptions", { ...pe, ...e8 });
  }
  get defaultUpdateOptions() {
    return this._get("defaultUpdateOptions");
  }
  set defaultUpdateOptions(e8) {
    this._set("defaultUpdateOptions", { ...le, ...e8, reshapeOptions: { ...le.reshapeOptions, ...e8?.reshapeOptions }, highlightOptions: { ...le.highlightOptions, ...e8?.highlightOptions } });
  }
  get labelOptions() {
    return this.sketchOptions.labels;
  }
  set labelOptions(e8) {
    this.sketchOptions.labels = e8;
  }
  get snappingOptions() {
    return this.snappingManager?.options ?? this._get("snappingOptions");
  }
  set snappingOptions(e8) {
    null != this._defaultSnappingManager && (this._defaultSnappingManager.options = e8), this._set("snappingOptions", e8);
  }
  get snappingManager() {
    return this._isOverridden("snappingManager") && this._get("snappingManager"), this._defaultSnappingManager;
  }
  set snappingManager(e8) {
    if (e8) this._isOverridden("snappingManager") || (this._defaultSnappingManager = u(this._defaultSnappingManager)), this._override("snappingManager", e8);
    else {
      const { view: e9 } = this;
      !this._defaultSnappingManager && e9 && (this._defaultSnappingManager = new q3({ options: this.snappingOptions, view: e9 })), this._clearOverride("snappingManager");
    }
  }
  get state() {
    const e8 = !(!this.view?.ready || !this.layer), t6 = this._operationHandle;
    return e8 && t6 ? "active" : e8 ? "ready" : "disabled";
  }
  get tooltipOptions() {
    return this.sketchOptions.tooltips;
  }
  set tooltipOptions(e8) {
    this.sketchOptions.tooltips = e8;
  }
  get updating() {
    return !(!this._updatingHandles.updating && !this.snappingManager?.updating);
  }
  get valueOptions() {
    return this.sketchOptions.values;
  }
  set valueOptions(e8) {
    this.sketchOptions.values = e8;
  }
  get view() {
    return this._get("view");
  }
  set view(e8) {
    const t6 = this._get("view");
    if (t6) {
      const { container: e9, map: o4 } = t6;
      e9 && this._clearCursor(), o4?.remove(this._internalGraphicsLayer), this.removeHandles(this._viewHandlesKey), this.cancel();
    }
    const o3 = "view-ready";
    this.removeHandles(o3), e8 && this.addHandles(f(() => e8.ready, (t7) => {
      this.removeHandles(this._viewHandlesKey), t7 && this.addHandles(this._generateViewHandles(e8), this._viewHandlesKey);
    }, w), o3), this._set("view", e8);
  }
  addGraphic(e8) {
    this._layerAdapter?.add(e8);
  }
  addGraphics(e8) {
    this._layerAdapter?.addMany(e8);
  }
  hasGraphic(e8) {
    return !!this._layerAdapter?.has(e8);
  }
  removeGraphic(e8) {
    this._layerAdapter?.remove(e8);
  }
  removeGraphics(e8) {
    this._layerAdapter?.removeMany(e8);
  }
  removeAllGraphics() {
    this._layerAdapter?.removeAll();
  }
  cancel() {
    this._moduleLoaderAbortController = e(this._moduleLoaderAbortController), this._viewReadyAbortController = e(this._viewReadyAbortController), this._sketchContinuationFlag = true, this._operationHandle && this._operationHandle.cancel();
  }
  complete() {
    this._operationHandle?.complete();
  }
  delete() {
    const { state: e8, updateGraphics: t6 } = this;
    if ("active" === e8 && t6.length) {
      const { activeTool: e9 } = this, o3 = t6.toArray();
      this.removeGraphics(o3), this.cancel(), this._emitDeleteEvent({ graphics: o3, tool: e9 });
    }
  }
  duplicate() {
    if ("active" === this.state && this.updateGraphics.length) {
      const e8 = this.updateGraphics.map((e9) => e9.clone()).toArray();
      return this.addGraphics(e8), this.emit("duplicate", { graphics: e8, type: "duplicate" }), e8;
    }
    return [];
  }
  async create(e8, t6) {
    this.cancel(), await this._waitViewReady();
    const { view: o3, layer: a11 } = this;
    if (!o3 || "disabled" === this.state) throw a11 || this._logMissingLayer(), u2();
    if (null != o3.activeTool && (o3.activeTool = null), !e8) return void this._logError("sketch:missing-parameter", "Missing parameter 'tool'.");
    t3(o3, this._internalGraphicsLayer);
    const i5 = await this._updatingHandles.addPromise(this._setupCreateOperation(e8, t6));
    if (null == i5 || this.destroyed) return void o3.map?.remove(this._internalGraphicsLayer);
    const r9 = () => {
      if (i5 === this._operationHandle) {
        const o4 = this.createGraphic, a12 = this._operationHandle.cancelled;
        if (this._operationHandle.destroy(), this._operationHandle = null, this._set("createGraphic", null), this.view?.map?.remove(this._internalGraphicsLayer), i5.cancelled || null == o4 || this.addGraphic(o4), this._sketchContinuationFlag = false, this.emit("create", { graphic: o4, state: a12 ? "cancel" : "complete", tool: e8, toolEventInfo: null, type: "create" }), a12 || this._sketchContinuationFlag) return;
        const { creationMode: r10 } = this;
        if ("continuous" === r10) {
          if (t6?.geometryToPlace) return;
          this._updatingHandles.addPromise(y(this.create(e8, t6)));
        } else "update" === r10 && o4 && this._updatingHandles.addPromise(y(this.update([o4])));
      }
    };
    i5.on("complete", r9), this._operationHandle = i5, o3.ready && o3.focus();
  }
  async place(e8, t6) {
    return await e8.load(), this.create("mesh", { mode: "click", hasZ: e8.hasZ, geometryToPlace: e8, ...t6 });
  }
  async update(e8, t6) {
    this.cancel(), await this._waitViewReady();
    const { layer: o3, view: a11, state: i5 } = this;
    if (!a11 || "disabled" === i5) throw o3 || this._logMissingLayer(), u2();
    null != a11.activeTool && (a11.activeTool = null);
    const r9 = Array.isArray(e8) ? e8 : [e8];
    if (null == e8 || !r9?.length) return void this._logError("sketch:missing-parameter", "Missing parameter 'graphics'.");
    if (r9.some((e9) => this.hasGraphic(e9) ? null == e9.geometry && (this._logError("sketch:invalid-parameter", "Parameter 'graphics' contains one or more graphics with an unsupported geometry."), true) : (this._logError("sketch:invalid-parameter", "Parameter 'graphics' contains one or more graphics missing from the supplied GraphicsLayer."), true))) return;
    const s7 = await this._updatingHandles.addPromise(this._setupUpdateOperation(r9, t6));
    this.destroyed || null == s7 || Ge(s7) || (t3(a11, this._internalGraphicsLayer), this._setUpdateOperationHandle(s7, t6), this.emit("update", { graphics: r9, state: "start", aborted: false, tool: s7.tool, toolEventInfo: null, type: "update" }));
  }
  async _updateSpatialReference(e8) {
    const t6 = this.view;
    if (t6) {
      e8 = Array.isArray(e8) ? e8 : [e8];
      for (const o3 of e8) null == o3.geometry || "mesh" === o3.geometry.type || T(o3.geometry.spatialReference, t6.spatialReference) || (J(o3.geometry.spatialReference, t6.spatialReference) || G() || await L(), o3.geometry = W(o3.geometry, t6.spatialReference));
    } else this._logMissingView();
  }
  undo() {
    this.canUndo() && this._operationHandle?.undo();
  }
  redo() {
    this.canRedo() && this._operationHandle?.redo();
  }
  canUndo() {
    return !!this._operationHandle?.canUndo();
  }
  canRedo() {
    return !!this._operationHandle?.canRedo();
  }
  toggleUpdateTool() {
    this._operationHandle?.toggleTool();
  }
  async _getFirstHit(e8) {
    const t6 = this.view;
    if (!t6) return this._logMissingView(), null;
    if ("2d" === t6.type) {
      const o4 = [];
      t6.map.allLayers.forEach((e9) => {
        "vector-tile" !== e9.type && "imagery" !== e9.type || o4.push(e9);
      });
      const a12 = await t6.hitTest(e8, { exclude: o4 });
      return r4(a12.results);
    }
    const o3 = [t6.map.ground];
    t6.map.allLayers.forEach((e9) => {
      S(e9) && o3.push(e9);
    });
    const a11 = await t6.hitTest(e8, { exclude: o3 });
    if (a11.results.length > 0) {
      const e9 = a11.results[0];
      if (null != e9 && "graphic" === e9.type && e9.graphic && (!a11.ground.mapPoint || t6.map.ground.opacity < 1 || a11.ground.distance - (e9.distance ?? 0) > -Math.min(3 * a11.ground.distance, "global" === t6.viewingMode ? E(t6.renderCoordsHelper.spatialReference).radius / t6.renderCoordsHelper.unitInMeters : Number.POSITIVE_INFINITY))) return e9;
    }
    return null;
  }
  _generateViewHandles(e8) {
    return [e8.on("immediate-click", async (e9) => {
      const t6 = "active" === this.state && "create" === this._operationHandle?.type;
      "disabled" !== this.state && !t6 && this.updateOnGraphicClick && await this._updatingHandles.addPromise(this._handleImmediateClick(e9));
    }, f2.WIDGET)];
  }
  async _handleImmediateClick(e8) {
    const t6 = await e8.defer(() => this._getFirstHit(n4(e8)));
    let o3 = null;
    if (null != t6) {
      const a11 = t6.graphic;
      this.updateGraphics.includes(a11) || this.hasGraphic(a11) ? (e8.stopPropagation(), o3 = a11) : "2d" !== this.view?.type || this._isComponentGraphic(a11) || "active" !== this.state || this.cancel();
    } else "active" === this.state && this.cancel();
    null == o3 || this.updateGraphics.includes(o3) || await this.update([o3], { ...this.defaultUpdateOptions, reshapeOptions: { ...this.defaultUpdateOptions.reshapeOptions } });
  }
  async _setupCreateOperation(e8, t6) {
    const o3 = this.view;
    if (!o3) return this._logMissingView(), null;
    const a11 = { hasZ: "3d" === o3.type, ...this.defaultCreateOptions, ...t6 }, i5 = await this._setupDrawGraphicTool(e8, o3, a11);
    return null == i5 ? null : (o3.tools.add(i5), o3.activeTool = i5, this._setupCreateOperationHandle(i5, e8));
  }
  async _setupDrawGraphicTool(e8, t6, o3) {
    if ("multipoint" === e8 && "3d" === t6.type) return this._logError("sketch:create", "Multipoint geometries are not supported in SceneView."), null;
    if (!t6) return this._logMissingView(), null;
    const { cursor: a11, defaultZ: i5, hasZ: r9, geometryToPlace: s7, graphicProperties: n11, mode: p7, preserveAspectRatio: l8 } = o3, h7 = e7(p7, e8), c6 = n10(e8), d8 = o3?.optionsPerTool?.has(e8) ? o3.optionsPerTool.get(e8) : {}, u6 = d8?.preserveAspectRatio ?? l8 ?? "rectangle" !== e8, m7 = { centered: "rectangle" !== e8 && !("circle" === e8 && !u6), cursor: a11, defaultZ: i5, forceUniformSize: u6, graphicProperties: { ...n11, attributes: { ...n11?.attributes } }, geometryToPlace: s7, geometryType: c6, mode: h7, graphicSymbol: this._getGraphicSymbolFromTool(e8), hasZ: r9, snappingManager: this.snappingManager, snapToScene: false, view: t6, ...d8 };
    return "2d" === t6.type ? this._makeDrawGraphicTool2D(m7) : this._makeDrawGraphicTool3D(m7);
  }
  async _makeDrawGraphicTool2D(e8) {
    const [t6, o3, a11] = await Promise.all([this._requireModule(import("./editingTools-7G272MXS.js")), u5(), c5()]);
    return Ge(t6) || this.destroyed ? null : new t6.module.DrawGraphicTool2D({ ...e8, activeVertexSymbol: this.activeVertexSymbol, regularVerticesSymbol: this.vertexSymbol, activeLineSymbol: this.activeLineSymbol, activeFillSymbol: ye(e8.geometryType) ? this.activeFillSymbol : null, sketchOptions: this.sketchOptions, automaticAreaMeasurementUtils: o3, automaticLengthMeasurementUtils: a11 });
  }
  async _makeDrawGraphicTool3D(e8) {
    const [t6, o3, a11] = await Promise.all([this._requireModule(import("./editingTools-WAH3GP4C.js")), u5(), c5()]);
    return Ge(t6) || this.destroyed ? null : new t6.module.DrawGraphicTool3D({ ...e8, elevationInfo: this._layerAdapter?.elevationInfo, snapToScene: true, sketchOptions: this.sketchOptions, automaticAreaMeasurementUtils: o3, automaticLengthMeasurementUtils: a11 });
  }
  _setupCreateOperationHandle(e8, t6) {
    const o3 = this.view;
    if (!o3) return this._logMissingView(), null;
    let a11 = null;
    const i5 = e8.forceUniformSize, s7 = e8.centered, n11 = [o3.on("key-down", (t7) => {
      if (t7.key === c.pan) t7.stopPropagation(), t7.repeat || (e8.enabled = false);
      else if (t7.key === c.complete) t7.stopPropagation(), e8.completeCreateOperation();
      else if (t7.key !== c.vertexAdd || t7.repeat) t7.key === c.undo ? (t7.stopPropagation(), p7.undo()) : t7.key === c.redo ? (t7.stopPropagation(), p7.redo()) : t7.key !== c.constraint || "rectangle" !== e8.geometryType && "circle" !== e8.geometryType || t7.repeat ? t7.key === c.center && (t7.repeat || (e8.centered = !s7, t7.stopPropagation())) : (e8.forceUniformSize = !i5, t7.stopPropagation());
      else {
        const o4 = e8.drawOperation.geometryType;
        "polyline" !== o4 && "polygon" !== o4 && "multipoint" !== o4 || (t7.stopPropagation(), e8.drawOperation.commitStagedVertex());
      }
    }, f2.WIDGET), o3.on("key-up", (t7) => {
      t7.key === c.pan ? e8.enabled = true : t7.key !== c.constraint || "rectangle" !== e8.geometryType && "circle" !== e8.geometryType ? t7.key === c.center && (e8.centered = s7, t7.stopPropagation()) : (e8.forceUniformSize = i5, t7.stopPropagation());
    }, f2.WIDGET), e8.on("vertex-add", (t7) => {
      switch (a11 = null == a11 ? "start" : "active", t7.operation) {
        case "apply":
          this.emit("create", { graphic: e8.graphic, state: a11, tool: this.activeTool, toolEventInfo: t7, type: "create" });
          break;
        case "undo":
          this._emitUndoEvent({ graphics: [e8.graphic], tool: e8.geometryType });
          break;
        case "redo":
          this._emitRedoEvent({ graphics: [e8.graphic], tool: e8.geometryType });
      }
    }), e8.on("cursor-update", (t7) => {
      e8.drawOperation.numCommittedVertices > 0 && this.emit("create", { graphic: e8.graphic, state: "active", tool: this.activeTool, toolEventInfo: { coordinates: t7.vertices[0].coordinates, type: "cursor-update" }, type: "create" });
    }), e8.on("vertex-remove", (t7) => {
      switch (t7.operation) {
        case "apply":
          this.emit("create", { graphic: e8.graphic, state: "active", tool: this.activeTool, toolEventInfo: t7, type: "create" });
          break;
        case "undo":
          this._emitUndoEvent({ graphics: [e8.graphic], tool: e8.geometryType });
          break;
        case "redo":
          this._emitRedoEvent({ graphics: [e8.graphic], tool: e8.geometryType });
      }
    }), e8.on("complete", (e9) => {
      this._set("createGraphic", e9.graphic), a11 = "complete", e9.aborted ? p7 && p7.cancel() : p7 && p7.complete();
    }), l2(() => this._getGraphicSymbolFromTool(t6), (t7) => {
      e8.graphicSymbol = t7;
    })], p7 = new p6({ activeComponent: e8, type: "create", onEnd: () => {
      r(n11), o3.tools?.remove(e8);
    }, undo: () => {
      e8.canUndo && e8.undo();
    }, redo: () => {
      e8.canRedo && e8.redo();
    }, canUndo: () => e8.canUndo, canRedo: () => e8.canRedo });
    return p7;
  }
  _getGraphicSymbolFromTool(e8) {
    switch (e8) {
      case "point":
      case "multipoint":
        return this.pointSymbol;
      case "polyline":
      case "freehandPolyline":
        return this.polylineSymbol;
      case "circle":
      case "rectangle":
      case "polygon":
      case "freehandPolygon":
        return this.polygonSymbol;
      case "mesh":
        return this.meshSymbol;
      case "text":
        return this.textSymbol;
    }
  }
  async _setupUpdateOperation(e8, t6) {
    const { view: o3 } = this;
    if (!o3) return this._logMissingView(), null;
    const a11 = { ...this.defaultUpdateOptions, ...t6, reshapeOptions: { ...this.defaultUpdateOptions.reshapeOptions, ...t6?.reshapeOptions }, highlightOptions: { ...this.defaultUpdateOptions.highlightOptions, ...t6?.highlightOptions } };
    let i5 = a11.tool ?? le.tool;
    if (this.removeGraphics(e8), this.addGraphics(e8), "3d" === o3.type) {
      if (0 === e8.length) return null;
      switch (i5) {
        case "move":
          return this._setupMove3DOperation(e8, a11, o3, i5);
        case "reshape":
          return e8.length > 1 ? (this._logError("sketch:reshape-multiple", "Reshape operation does not support multiple graphics."), null) : this._setupReshape3DOperation(e8[0], a11, o3);
        case "transform":
          return this._setupGraphicTransform3DOperation(e8, a11, o3);
      }
    }
    switch (i5) {
      case "move":
        return this._setupMove2DOperation(e8, a11, o3);
      case "reshape":
        return e8.length > 1 ? (this._logError("sketch:reshape-multiple", "Reshape operation does not support multiple graphics."), null) : this._setupTransformOrReshape2DOperation(e8, i5, a11, o3);
      case "transform":
        return r8(e8) && (i5 = "reshape"), this._setupTransformOrReshape2DOperation(e8, i5, a11, o3);
    }
  }
  async _setupMove3DOperation(e8, t6, o3, a11, i5 = false) {
    const [s7, n11] = await Promise.all([this._requireModule(import("./editingTools-WAH3GP4C.js")), c5()]);
    if (Ge(s7)) return s7;
    const { ManipulatedObject3DGraphic: p7, MoveTool3D: l8 } = s7.module, h7 = /* @__PURE__ */ new Map(), c6 = () => {
      h7.forEach((e9) => e9.destroy()), h7.clear();
    };
    for (const r9 of e8) {
      const e9 = new p7({ view: o3, graphic: r9 }), t7 = e3(e9);
      if (0 !== t7) return c6(), this._logError("sketch:move", `Move operation not supported for provided graphic(s) (${e5(t7)}).`), null;
      h7.set(r9, e9);
    }
    const d8 = new l8({ view: o3, enableZ: t6.enableZ, snappingManager: this.snappingManager, sketchOptions: this.sketchOptions, autoLengthMeasurementUtils: n11 });
    o3.tools.add(d8), d8.objects.addMany(Array.from(h7.values())), i5 || this.updateGraphics.addMany(e8);
    const u6 = [], m7 = new n9({ activeComponent: d8, tool: a11, type: "update", onEnd: () => {
      r(u6), we(o3, d8), c6();
    }, undo: () => {
      _e(this.view, d8), ge(m7, this.updateGraphics.toArray()), this._emitUndoEvent({ graphics: this.updateGraphics.toArray(), tool: a11 });
    }, redo: () => {
      ve(m7, this.updateGraphics.toArray()), this._emitRedoEvent({ graphics: this.updateGraphics.toArray(), tool: a11 });
    }, addToSelection: (e9) => {
      this.updateGraphics.push(e9);
      const t7 = new p7({ view: o3, graphic: e9 });
      h7.set(e9, t7), d8.objects.push(t7), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e9], removed: [], type: "selection-change" }, type: "update" });
    }, removeFromSelection: (e9) => {
      const t7 = this.updateGraphics.indexOf(e9);
      if (m7.history.undo.forEach((e10) => e10.updates.splice(t7, 1)), m7.history.redo.forEach((e10) => e10.updates.splice(t7, 1)), this.updateGraphics.remove(e9), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e9], type: "selection-change" }, type: "update" }), 0 === this.updateGraphics.length) return void m7.complete();
      const o4 = h7.get(e9);
      o4 && (d8.objects.remove(o4), o4.destroy(), h7.delete(e9));
    }, toggleTool: async () => {
      if (1 !== this.updateGraphics.length || false === t6.toggleToolOnClick) return;
      if ("transform" !== a11) return;
      const e9 = this.updateGraphics.at(0), i6 = await this._setupReshape3DOperation(e9, t6, o3, true);
      i6 && !Ge(i6) && (m7.onEnd(), m7.destroy(), this._setUpdateOperationHandle(i6, t6));
    } });
    return u6.push(...this._getHandlesForComponent(m7, t6), o3.on("immediate-click", (e9) => this._getCommonUpdateOperationClickHandlers(m7, e9, t6), f2.WIDGET), o3.on("key-down", (e9) => {
      this._getCommonUpdateOperationKeyDownHandlers(m7, e9);
    }, f2.WIDGET)), m7;
  }
  _setupGraphicTransform3DOperation(e8, t6, o3, a11 = false) {
    if (1 === e8.length && 0 === e6(e8[0])) {
      const i5 = e8[0], r9 = i5.geometry;
      if (null != r9 && ("point" === r9.type || "mesh" === r9.type)) return this._setupPointTransform3DOperation(i5, t6, o3);
      if (null != r9 && ("polygon" === r9.type || "polyline" === r9.type)) return this._setupPolyTransform3DOperation(i5, t6, o3, a11);
    }
    return this._setupMove3DOperation(e8, t6, o3, "transform", a11);
  }
  async _setupPointTransform3DOperation(e8, t6, o3) {
    const a11 = "transform", { enableRotation: i5, enableScaling: s7, enableZ: n11 } = t6, p7 = await this._requireModule(import("./editingTools-WAH3GP4C.js"));
    if (Ge(p7)) return p7;
    const { TransformTool3D: l8, ManipulatedObject3DGraphic: h7 } = p7.module, c6 = new h7({ graphic: e8, view: o3 }), d8 = new l8({ object: c6, view: o3, enableRotation: i5, enableScaling: s7, enableZ: n11, snappingManager: this.snappingManager, sketchOptions: this.sketchOptions });
    o3.tools.add(d8), this.updateGraphics.add(e8);
    const u6 = [], m7 = new n9({ activeComponent: d8, tool: a11, type: "update", onEnd: () => {
      r(u6), we(o3, d8), c6.destroy();
    }, undo: () => {
      _e(this.view, d8), ge(m7, this.updateGraphics.toArray()), this._emitUndoEvent({ graphics: this.updateGraphics.toArray(), tool: a11 });
    }, redo: () => {
      ve(m7, this.updateGraphics.toArray()), this._emitRedoEvent({ graphics: this.updateGraphics.toArray(), tool: a11 });
    }, addToSelection: async (e9) => {
      this.updateGraphics.add(e9), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e9], removed: [], type: "selection-change" }, type: "update" }), m7.onEnd(), m7.destroy();
      const a12 = await this._setupMove3DOperation(this.updateGraphics.toArray(), t6, o3, "transform", true);
      Ge(a12) || this._setUpdateOperationHandle(a12, t6);
    }, removeFromSelection: (e9) => {
      this.updateGraphics.remove(e9), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e9], type: "selection-change" }, type: "update" }), m7.complete();
    }, toggleTool: () => {
    } });
    return u6.push(...this._getHandlesForComponent(m7, t6), o3.on("immediate-click", (e9) => this._getCommonUpdateOperationClickHandlers(m7, e9, t6), f2.WIDGET), o3.on("key-down", (e9) => {
      this._getCommonUpdateOperationKeyDownHandlers(m7, e9);
    }, f2.WIDGET)), m7;
  }
  async _setupPolyTransform3DOperation(e8, t6, o3, a11 = false) {
    const i5 = "transform", { enableRotation: s7, enableScaling: n11, enableZ: p7, preserveAspectRatio: l8 } = t6, [h7, c6] = await Promise.all([this._requireModule(import("./editingTools-WAH3GP4C.js")), c5()]);
    if (Ge(h7)) return h7;
    const { ManipulatedObject3DGraphic: d8, ExtentTransformTool: u6 } = h7.module, m7 = this.view?.inputManager?.isModifierKeyDown(c.constraint), y6 = new d8({ view: o3, graphic: e8 }), g6 = new u6({ object: y6, view: o3, enableRotation: s7, enableScaling: n11, enableZ: p7, preserveAspectRatio: !!l8 != !!m7, sketchOptions: this.sketchOptions, automaticLengthMeasurementUtils: c6 });
    o3.tools.add(g6), a11 || this.updateGraphics.add(e8);
    const v5 = [], f4 = new n9({ activeComponent: g6, tool: i5, type: "update", onEnd: () => {
      r(v5), we(o3, g6), y6.destroy();
    }, canUndo: () => !g6.destroyed && g6.canUndo, undo: () => {
      g6.destroyed || (g6.undo(), this._emitUndoEvent({ graphics: this.updateGraphics.toArray(), tool: i5 }));
    }, canRedo: () => !g6.destroyed && g6.canRedo, redo: () => {
      g6.destroyed || (g6.redo(), this._emitRedoEvent({ graphics: this.updateGraphics.toArray(), tool: i5 }));
    }, addToSelection: async (e9) => {
      this.updateGraphics.add(e9), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e9], removed: [], type: "selection-change" }, type: "update" }), f4.onEnd(), f4.destroy();
      const a12 = await this._setupMove3DOperation(this.updateGraphics.toArray(), t6, o3, "transform", true);
      Ge(a12) || this._setUpdateOperationHandle(a12, t6);
    }, removeFromSelection: (e9) => {
      this.updateGraphics.remove(e9), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e9], type: "selection-change" }, type: "update" }), f4.complete();
    }, toggleTool: async () => {
      if (1 !== this.updateGraphics.length || false === t6.toggleToolOnClick) return;
      const a12 = await this._setupReshape3DOperation(e8, t6, o3, true);
      a12 && !Ge(a12) && (f4.onEnd(), f4.destroy(), this._setUpdateOperationHandle(a12, t6));
    } });
    return v5.push(...this._getHandlesForComponent(f4, t6), o3.on("immediate-click", (e9) => this._getCommonUpdateOperationClickHandlers(f4, e9, t6), f2.WIDGET), o3.on("key-down", (e9) => this._getCommonUpdateOperationKeyDownHandlers(f4, e9), f2.WIDGET), o3.on("key-down", (e9) => {
      e9.key !== c.constraint || e9.repeat || (g6.preserveAspectRatio = !g6.preserveAspectRatio, e9.stopPropagation());
    }, f2.WIDGET), o3.on("key-up", (e9) => {
      e9.key === c.constraint && (g6.preserveAspectRatio = !g6.preserveAspectRatio, e9.stopPropagation());
    }, f2.WIDGET)), f4;
  }
  async _setupMove2DOperation(e8, t6, o3) {
    const a11 = "move";
    this.updateGraphics.addMany(e8), await this._updatingHandles.addPromise(this._updateSpatialReference(e8));
    const i5 = await this._getGraphicMover(e8, t6, o3);
    if (Ge(i5)) return i5;
    const s7 = new n9({ activeComponent: i5, tool: a11, type: "update", onEnd: () => {
      this._clearCursor(), r(l8), r(p7), i5.destroy(), this._internalGraphicsLayer?.removeMany([...this.updateGraphics.toArray()]);
    }, undo: () => {
      const e9 = this.updateGraphics.toArray();
      ge(s7, e9), s7.refreshComponent(), this._emitUndoEvent({ graphics: e9, tool: a11 });
    }, redo: () => {
      const e9 = this.updateGraphics.toArray();
      ve(s7, e9), s7.refreshComponent(), this._emitRedoEvent({ graphics: e9, tool: a11 });
    }, addToSelection: async (e9) => {
      await this._updatingHandles.addPromise(this._updateSpatialReference(e9)), this.updateGraphics.push(e9), i5.graphics = this.updateGraphics.toArray(), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e9], removed: [], type: "selection-change" }, type: "update" });
    }, removeFromSelection: (e9) => {
      const t7 = this.updateGraphics.indexOf(e9);
      s7.history.undo.forEach((e10) => e10.updates.splice(t7, 1)), s7.history.redo.forEach((e10) => e10.updates.splice(t7, 1)), this.updateGraphics.remove(e9);
      const o4 = this.updateGraphics.toArray();
      this.emit("update", { graphics: o4, state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e9], type: "selection-change" }, type: "update" }), 0 !== this.updateGraphics.length ? i5.graphics = o4 : s7.complete();
    } });
    let n11 = false;
    const p7 = [o3.on("immediate-click", (e9) => this._getCommonUpdateOperationClickHandlers(s7, e9, t6), f2.WIDGET), o3.on("key-down", (e9) => {
      this._getCommonUpdateOperationKeyDownHandlers(s7, e9), e9.key !== c.constraint || e9.repeat || (n11 = true, i5.enableMoveAllGraphics = !i5.enableMoveAllGraphics);
    }, f2.WIDGET), o3.on("key-up", (e9) => {
      e9.key === c.constraint && n11 && (n11 = false, i5.enableMoveAllGraphics = !i5.enableMoveAllGraphics);
    }, f2.WIDGET)], l8 = this._getHandlesForComponent(s7, t6);
    return s7;
  }
  async _setupReshape3DOperation(e8, t6, o3, a11 = false) {
    const i5 = "reshape", [s7, n11, p7] = await Promise.all([this._requireModule(import("./editingTools-WAH3GP4C.js")), u5(), c5()]);
    if (Ge(s7)) return s7;
    const { ManipulatedObject3DGraphic: l8, ReshapeTool3D: h7 } = s7.module, c6 = new l8({ view: o3, graphic: e8 }), d8 = r6(c6);
    if (0 !== d8) return c6.destroy(), this._logError("sketch:reshape", `Reshape operation not supported for provided graphic(s) (${e5(d8)}).`), null;
    const u6 = t6.reshapeOptions, m7 = new h7({ view: o3, object: c6, enableZVertex: t6.enableZ && "move" === u6?.vertexOperation, enableZShape: t6.enableZ && "move" === u6?.shapeOperation, enableMoveObject: "move" === u6?.shapeOperation || "move-xy" === u6?.shapeOperation, enableMidpoints: "split" === u6?.edgeOperation, enableEdgeOffset: "offset" === u6?.edgeOperation, snappingManager: this.snappingManager, sketchOptions: this.sketchOptions, automaticAreaMeasurementUtils: n11, automaticLengthMeasurementUtils: p7 });
    o3.tools.add(m7), a11 || this.updateGraphics.add(c6.graphic);
    const y6 = [], g6 = new n9({ activeComponent: m7, tool: i5, type: "update", onEnd: () => {
      r(y6), we(o3, m7), c6.destroy();
    }, canUndo: () => !m7.destroyed && m7.canUndo, undo: () => {
      m7.destroyed || (m7.undo(), this._emitUndoEvent({ graphics: this.updateGraphics.toArray(), tool: i5 }));
    }, canRedo: () => !m7.destroyed && m7.canRedo, redo: () => {
      m7.destroyed || (m7.redo(), this._emitRedoEvent({ graphics: this.updateGraphics.toArray(), tool: i5 }));
    }, addToSelection: async (e9) => {
      this.updateGraphics.add(e9), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e9], removed: [], type: "selection-change" }, type: "update" }), g6.onEnd(), g6.destroy();
      const a12 = await this._setupMove3DOperation(this.updateGraphics.toArray(), t6, o3, "transform", true);
      Ge(a12) || this._setUpdateOperationHandle(a12, t6);
    }, removeFromSelection: (e9) => {
      this.updateGraphics.remove(e9), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e9], type: "selection-change" }, type: "update" }), g6.complete();
    }, toggleTool: async () => {
      if (false === t6.toggleToolOnClick) return;
      g6.onEnd(), g6.destroy();
      const e9 = await this._setupGraphicTransform3DOperation(this.updateGraphics.toArray(), t6, o3, true);
      Ge(e9) || this._setUpdateOperationHandle(e9, t6);
    } });
    return y6.push(...this._getHandlesForComponent(g6, t6), o3.on("immediate-click", (e9) => this._getCommonUpdateOperationClickHandlers(g6, e9, t6), f2.WIDGET), o3.on("key-down", (e9) => {
      this._getCommonUpdateOperationKeyDownHandlers(g6, e9);
    }, f2.WIDGET)), g6;
  }
  async _setupTransformOrReshape2DOperation(e8, t6, o3, a11) {
    this.updateGraphics.addMany(e8), await this._updatingHandles.addPromise(this._updateSpatialReference(e8));
    const i5 = "transform" === t6 ? await this._getBox(e8, o3, a11) : await this._getReshape(e8, o3, a11);
    if (Ge(i5)) return i5;
    const s7 = new n9({ activeComponent: i5, type: "update", onEnd: () => {
      r(p7), r(n11), s7.activeComponent && !s7.activeComponent.destroyed && s7.activeComponent.destroy(), this._internalGraphicsLayer.removeMany(this.updateGraphics.toArray());
    }, undo: () => {
      ge(s7, this.updateGraphics.toArray()), s7.refreshComponent(), this._emitUndoEvent({ graphics: this.updateGraphics.toArray(), tool: s7.tool });
    }, redo: () => {
      ve(s7, this.updateGraphics.toArray()), s7.refreshComponent(), this._emitRedoEvent({ graphics: this.updateGraphics.toArray(), tool: s7.tool });
    }, addToSelection: async (e9) => {
      let t7 = s7.activeComponent;
      if ("reshape" === t7?.type) {
        const t8 = [...this.updateGraphics, e9];
        this.updateGraphics.removeAll(), s7.onEnd(), s7.destroy();
        const i6 = await this._setupTransformOrReshape2DOperation(t8, "transform", o3, a11);
        if (Ge(i6)) return;
        this._setUpdateOperationHandle(i6, o3);
      } else this.updateGraphics.add(e9), t7.graphics = this.updateGraphics.toArray(), t7.refresh(), s7.resetHistory();
      this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [e9], removed: [], type: "selection-change" }, type: "update" });
    }, removeFromSelection: (e9) => {
      const t7 = this.updateGraphics.indexOf(e9);
      s7.history.undo.forEach((e10) => e10.updates.splice(t7, 1)), s7.history.redo.forEach((e10) => e10.updates.splice(t7, 1)), this.updateGraphics.remove(e9);
      const o4 = this.updateGraphics.toArray();
      0 === o4.length ? s7.complete() : r8(o4) ? s7.toggleTool() : s7.activeComponent.graphics = o4, this.emit("update", { graphics: o4, state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: [], removed: [e9], type: "selection-change" }, type: "update" });
    }, toggleTool: async () => {
      if (this.updateGraphics.length > 1) return;
      const e9 = this.updateGraphics.at(0), t7 = e9.geometry;
      if (null != t7 && ("reshape" === s7.tool && "point" === t7.type || "transform" === s7.tool && "extent" === t7.type)) return;
      let i6 = null;
      "transform" === s7.tool ? i6 = await this._getReshape([e9], o3, a11) : "reshape" === s7.tool && (i6 = await this._getBox([e9], o3, a11)), Ge(i6) || (s7.activeComponent?.destroy(), s7.activeComponent = i6, s7.activeComponent && (r(p7), p7 = this._getHandlesForComponent(s7, o3)));
    } }), n11 = [a11.on("immediate-click", (e9) => this._getCommonUpdateOperationClickHandlers(s7, e9, o3), f2.WIDGET), a11.on("key-down", (e9) => {
      if (this._getCommonUpdateOperationKeyDownHandlers(s7, e9), e9.key === c.constraint && !e9.repeat && s7) {
        const e10 = s7.activeComponent;
        e10 && "box" === e10.type && (e10.preserveAspectRatio = !e10.preserveAspectRatio);
      }
    }, f2.WIDGET), a11.on("key-up", (e9) => {
      if (e9.key === c.constraint && s7) {
        const e10 = s7.activeComponent;
        e10 && "box" === e10.type && (e10.preserveAspectRatio = !e10.preserveAspectRatio);
      }
    }, f2.WIDGET)];
    let p7 = this._getHandlesForComponent(s7, o3);
    return s7;
  }
  async _getGraphicMover(e8, t6, o3) {
    const { enableMoveAllGraphics: a11, highlightOptions: i5 } = t6, r9 = await this._requireModule(import("./GraphicMover-ITGLBDUL.js"));
    return Ge(r9) ? r9 : new r9.module.default({ enableMoveAllGraphics: a11, highlightName: i5?.name, highlightsEnabled: !!i5?.enabled, indicatorsEnabled: false, graphics: e8, view: o3, callbacks: { onGraphicMoveStart: ({ dx: e9, dy: t7, graphic: o4 }) => {
      this._displayCursor("grabbing"), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e9, dy: t7, mover: o4, type: "move-start" }, type: "update" });
    }, onGraphicMove: ({ dx: e9, dy: t7, graphic: o4 }) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e9, dy: t7, mover: o4, type: "move" }, type: "update" }), onGraphicMoveStop: ({ dx: e9, dy: t7, graphic: o4 }) => {
      this._displayCursor("pointer"), this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e9, dy: t7, mover: o4, type: "move-stop" }, type: "update" });
    }, onGraphicPointerOver: () => this._displayCursor("move"), onGraphicPointerOut: () => this._clearCursor() } });
  }
  async _getBox(e8, t6, o3) {
    const { enableRotation: a11, enableScaling: i5, highlightOptions: r9, preserveAspectRatio: s7 } = t6, [n11, p7] = await Promise.all([this._requireModule(import("./Box-FA4AFAUU.js")), c5()]);
    if (Ge(n11)) return n11;
    const l8 = this.view?.inputManager?.isModifierKeyDown(c.constraint);
    return new n11.module.default({ graphics: e8, enableRotation: a11, enableScaling: i5, highlightName: r9?.name, highlightsEnabled: !!r9?.enabled, preserveAspectRatio: !!s7 != !!l8, layer: this._internalGraphicsLayer, view: o3, sketchOptions: this.sketchOptions, automaticLengthMeasurementUtils: p7, callbacks: { onMoveStart: (e9) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e9 }, type: "update" }), onMove: (e9) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e9 }, type: "update" }), onMoveStop: (e9) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e9 }, type: "update" }), onScaleStart: (e9) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e9 }, type: "update" }), onScale: (e9) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e9 }, type: "update" }), onScaleStop: (e9) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e9 }, type: "update" }), onRotateStart: (e9) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e9 }, type: "update" }), onRotate: (e9) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e9 }, type: "update" }), onRotateStop: (e9) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e9 }, type: "update" }) } });
  }
  async _getReshape(e8, t6, o3) {
    const { highlightOptions: a11, reshapeOptions: i5 } = t6, r9 = "split" === i5?.edgeOperation, s7 = "move" === i5?.shapeOperation, n11 = !!i5?.enableCreateCurveFromStraightEdge, [p7, l8, h7] = await Promise.all([this._requireModule(import("./Reshape-VWS3KVJE.js")), u5(), c5()]);
    return Ge(p7) ? p7 : new p7.module.default({ enableMidpoints: r9, enableMovement: s7, enableCurveOnMidpoint: n11, graphic: e8[0], highlightName: a11?.name, highlightsEnabled: !!a11?.enabled, layer: this._internalGraphicsLayer, snappingManager: this.snappingManager, sketchOptions: this.sketchOptions, automaticAreaMeasurementUtils: l8, automaticLengthMeasurementUtils: h7, view: o3, callbacks: { onReshapeStart: (e9) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e9 }, type: "update" }), onReshape: (e9) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e9 }, type: "update" }), onReshapeStop: ({ mover: e9, type: t7 }) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e9, type: t7 }, type: "update" }), onMoveStart: ({ dx: e9, dy: t7, mover: o4, type: a12 }) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e9, dy: t7, mover: o4, type: a12 }, type: "update" }), onMove: ({ dx: e9, dy: t7, mover: o4, type: a12 }) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e9, dy: t7, mover: o4, type: a12 }, type: "update" }), onMoveStop: ({ dx: e9, dy: t7, mover: o4, type: a12 }) => this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e9, dy: t7, mover: o4, type: a12 }, type: "update" }), onVertexAdd: ({ added: e9, type: t7, vertices: o4 }) => {
      const a12 = e9.map((e10) => r2(e10.geometry));
      this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { added: a12, vertices: o4, type: t7 }, type: "update" });
    }, onVertexRemove: ({ removed: e9, type: t7, vertices: o4 }) => {
      const a12 = e9.map((e10) => r2(e10.geometry));
      this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { removed: a12, vertices: o4, type: t7 }, type: "update" });
    } } });
  }
  _getHandlesForComponent(e8, t6) {
    const o3 = e8.activeComponent;
    if (!o3) return [];
    switch (o3.type) {
      case "graphic-mover":
        return [o3.on("graphic-click", ({ graphic: o4, viewEvent: a11 }) => {
          a11.native?.shiftKey && t6.multipleSelectionEnabled && (a11.stopPropagation(), e8.removeFromSelection(o4));
        }), o3.on("graphic-move-start", (t7) => e8.addToHistory(be(t7.allGraphics)))];
      case "box":
        return [o3.on("graphic-click", (o4) => this._onTransformOrReshape2DGraphicClick(e8, t6, o4)), o3.on("move-start", (t7) => e8.addToHistory(be(t7.graphics))), o3.on("rotate-start", (t7) => e8.addToHistory(be(t7.graphics))), o3.on("scale-start", (t7) => e8.addToHistory(be(t7.graphics)))];
      case "reshape":
        return [o3.on("graphic-click", (o4) => this._onTransformOrReshape2DGraphicClick(e8, t6, o4)), o3.on("move-start", (t7) => e8.addToHistory(be([t7.mover]))), o3.on("reshape-start", (t7) => e8.addToHistory(be([t7.graphic]))), o3.on("vertex-add", (t7) => e8.addToHistory(be([t7.oldGraphic]))), o3.on("vertex-remove", (t7) => e8.addToHistory(be([t7.oldGraphic])))];
      case "move-3d":
        return [o3.events.on("record-undo", ({ updates: t7 }) => {
          e8.addToHistory({ updates: t7 });
        }), o3.events.on("move-start", (e9) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: 0, dy: 0, mover: e9.objects.length > 0 ? e9.objects[0].graphic : null, type: "move-start" }, type: "update" });
        }), o3.events.on("move", (e9) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: e9.dx, dy: e9.dy, mover: e9.objects.length > 0 ? e9.objects[0].graphic : null, type: "move" }, type: "update" });
        }), o3.events.on("move-stop", (e9) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { dx: 0, dy: 0, mover: e9.objects.length > 0 ? e9.objects[0].graphic : null, type: "move-stop" }, type: "update" });
        }), o3.events.on("immediate-click", (o4) => {
          o4.shiftKey ? this._toggleSelection([o4.object.graphic], e8, t6) : e8.toggleTool();
        })];
      case "transform-3d":
        return [o3.events.on("record-undo", ({ updates: t7 }) => {
          e8.addToHistory({ updates: t7 });
        }), o3.events.on("translate-start", (e9) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e9.object.graphic, dx: e9.dxScreen, dy: e9.dyScreen, type: "move-start" }, type: "update" });
        }), o3.events.on("translate-stop", (e9) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e9.object.graphic, dx: e9.dxScreen, dy: e9.dyScreen, type: "move-stop" }, type: "update" });
        }), o3.events.on("rotate-start", (e9) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e9.object.graphic, angle: e9.angle, type: "rotate-start" }, type: "update" });
        }), o3.events.on("rotate-stop", (e9) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e9.object.graphic, angle: e9.angle, type: "rotate-stop" }, type: "update" });
        }), o3.events.on("scale-start", (e9) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e9.object.graphic, xScale: e9.xScale, yScale: e9.yScale, type: "scale-start" }, type: "update" });
        }), o3.events.on("scale-stop", (e9) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e9.object.graphic, xScale: e9.xScale, yScale: e9.yScale, type: "scale-stop" }, type: "update" });
        }), o3.events.on("translate", (e9) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e9.object.graphic, dx: e9.dxScreen, dy: e9.dyScreen, type: "move" }, type: "update" });
        }), o3.events.on("rotate", (e9) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e9.object.graphic, angle: e9.angle, type: "rotate" }, type: "update" });
        }), o3.events.on("scale", (e9) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { mover: e9.object.graphic, xScale: e9.xScale, yScale: e9.yScale, type: "scale" }, type: "update" });
        }), o3.events.on("immediate-click", (o4) => {
          o4.shiftKey ? this._toggleSelection([o4.object.graphic], e8, t6) : e8.toggleTool();
        })];
      case "reshape-3d":
        return [o3.events.on("reshape", (e9) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e9, mover: e9.object.graphic }, type: "update" });
        }), o3.events.on("move", (e9) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: { ...e9, mover: e9.object.graphic }, type: "update" });
        }), o3.events.on("vertex-add", (e9) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: e9, type: "update" });
        }), o3.events.on("vertex-remove", (e9) => {
          this.emit("update", { graphics: this.updateGraphics.toArray(), state: "active", aborted: false, tool: this.activeTool, toolEventInfo: e9, type: "update" });
        }), o3.events.on("immediate-click", (o4) => {
          o4.shiftKey ? this._toggleSelection([o4.object.graphic], e8, t6) : e8.toggleTool();
        })];
    }
  }
  _onTransformOrReshape2DGraphicClick(e8, t6, o3) {
    const { graphic: a11, viewEvent: i5 } = o3;
    return i5.native?.shiftKey && this.hasGraphic(a11) ? (i5.stopPropagation(), e8.removeFromSelection(a11)) : t6.toggleToolOnClick ? (i5.stopPropagation(), e8.toggleTool()) : void 0;
  }
  _setUpdateOperationHandle(e8, t6) {
    this._operationHandle = e8;
    const o3 = this.view?.map;
    this._disablePopup(t6);
    const a11 = () => {
      if (e8 === this._operationHandle) {
        const a12 = this.updateGraphics.toArray(), i5 = this._operationHandle.tool;
        this._operationHandle.destroy(), this._operationHandle = null, this._internalGraphicsLayer.removeMany(this.updateGraphics.toArray()), this.updateGraphics.removeAll(), o3 && o3.remove(this._internalGraphicsLayer), this._restorePopup(t6), this.emit("update", { graphics: a12, state: "complete", aborted: e8.cancelled, tool: i5, toolEventInfo: null, type: "update" });
      }
    };
    e8.on("complete", a11);
  }
  async _getCommonUpdateOperationClickHandlers(e8, t6, o3) {
    const a11 = n4(t6), i5 = await t6.defer(() => this._getFirstHit(a11));
    if (null == i5) return void e8.complete();
    if (t6.native.shiftKey && this._toggleSelection([i5.graphic], e8, o3)) return void t6.stopPropagation();
    this.updateGraphics.includes(i5.graphic) ? t6.stopPropagation() : e8.complete();
  }
  _toggleSelection(e8, t6, o3) {
    const a11 = !!o3.multipleSelectionEnabled;
    return e8.some((e9) => null != e9 && (!(!a11 || !this.hasGraphic(e9)) && (this.updateGraphics.includes(e9) ? t6.removeFromSelection(e9) : t6.addToSelection(e9), true)));
  }
  _getCommonUpdateOperationKeyDownHandlers(e8, t6) {
    if (!e8) return;
    const o3 = t6.key;
    o3 === c.undo && e8.canUndo() ? (t6.stopPropagation(), e8.undo()) : o3 === c.redo && e8.canRedo() ? (t6.stopPropagation(), e8.redo()) : o3 === c.cancel ? (t6.stopPropagation(), e8.cancel()) : this.allowDeleteKey && c.delete.includes(o3) && this._onDeleteKey(t6);
  }
  _onDeleteKey(e8) {
    if (!this._operationHandle || "update" !== this._operationHandle.type) return;
    const t6 = this.activeComponent, o3 = this.updateGraphics.toArray();
    null != t6 && ("reshape" !== t6.type || 1 === o3.length && "point" === o3[0].geometry?.type) && (e8.stopPropagation(), this.delete());
  }
  _removeDefaultLayer() {
    this._internalGraphicsLayer && (this.view?.map?.remove(this._internalGraphicsLayer), this._internalGraphicsLayer = u(this._internalGraphicsLayer));
  }
  _isComponentGraphic(e8) {
    const { activeComponent: t6 } = this;
    return !(!e8 || null == t6) && (e8.attributes?.esriSketchTool || "draw-2d" === t6.type && t6.graphic === e8 || ("box" === t6.type || "reshape" === t6.type) && t6.isUIGraphic(e8));
  }
  _clearCursor() {
    this.removeHandles(he);
  }
  _displayCursor(e8) {
    this.removeHandles(he), this.view?.container && null != e8 && this.addHandles(this.view.acquireCursor(e8, "high"), he);
  }
  _logError(e8, t6, o3) {
    i.getLogger(this).error(new s(e8, t6, o3));
  }
  async _requireModule(e8) {
    const t6 = new AbortController();
    this._moduleLoaderAbortController = t6;
    const o3 = await e8;
    return this._moduleLoaderAbortController !== t6 || t6.signal.aborted ? { requireError: "aborted" } : { module: o3 };
  }
  _emitUndoEvent(e8) {
    this.emit("undo", { ...e8, type: "undo" });
  }
  _emitRedoEvent(e8) {
    this.emit("redo", { ...e8, type: "redo" });
  }
  _emitDeleteEvent(e8) {
    this.emit("delete", { ...e8, type: "delete" });
  }
  _onLayerGraphicsChangeCallback(e8) {
    if (null != this._operationHandle) {
      const { updateGraphics: t6 } = this;
      for (const o3 of e8.removed) if (t6.includes(o3)) {
        if (!(t6.length > 1)) {
          this._operationHandle.cancel();
          break;
        }
        this._operationHandle.removeFromSelection(o3);
      }
    }
  }
  get test() {
  }
  wait() {
    return j(() => !this.updating);
  }
  _disablePopupEnabled(e8) {
    return "3d" !== this.view?.type || this.updateOnGraphicClick || (e8?.toggleToolOnClick ?? false);
  }
  _disablePopup(e8) {
    this._disablePopupEnabled(e8) && this.view && null == this._originalPopupEnabled && (this._originalPopupEnabled = this.view.popupEnabled, this.view.popupEnabled = false);
  }
  _restorePopup(e8) {
    this._disablePopupEnabled(e8) && this.view && null != this._originalPopupEnabled && (this.view.popupEnabled = this._originalPopupEnabled, this._originalPopupEnabled = null);
  }
  async _waitViewReady() {
    const e8 = this.view;
    e8 ? (e(this._viewReadyAbortController), this._viewReadyAbortController = new AbortController(), await p(j(() => e8?.ready), this._viewReadyAbortController.signal)) : this._logMissingView();
  }
  _logMissingView() {
    this._logError("sketch:missing-property", me("view"));
  }
  _logMissingLayer() {
    this._logError(ue, me("layer"));
  }
};
__decorate([m()], de2.prototype, "_defaultSnappingManager", void 0), __decorate([m()], de2.prototype, "_layerAdapter", null), __decorate([m()], de2.prototype, "_operationHandle", void 0), __decorate([m({ readOnly: true })], de2.prototype, "_updatingHandles", void 0), __decorate([m({ readOnly: true })], de2.prototype, "activeTool", null), __decorate([m({ readOnly: true })], de2.prototype, "activeCreateToolDrawMode", null), __decorate([m()], de2.prototype, "activeTooltip", null), __decorate([m({ types: x })], de2.prototype, "activeFillSymbol", void 0), __decorate([m()], de2.prototype, "activeLineSymbol", void 0), __decorate([m()], de2.prototype, "activeVertexSymbol", void 0), __decorate([m()], de2.prototype, "allowDeleteKey", void 0), __decorate([m({ readOnly: true })], de2.prototype, "createGraphic", null), __decorate([m()], de2.prototype, "defaultCreateOptions", null), __decorate([m()], de2.prototype, "defaultUpdateOptions", null), __decorate([m({ type: c3, nonNullable: true })], de2.prototype, "labelOptions", null), __decorate([m()], de2.prototype, "layer", void 0), __decorate([m({ types: x })], de2.prototype, "pointSymbol", void 0), __decorate([m({ types: x })], de2.prototype, "polygonSymbol", void 0), __decorate([m({ types: x })], de2.prototype, "polylineSymbol", void 0), __decorate([m()], de2.prototype, "meshSymbol", void 0), __decorate([m()], de2.prototype, "textSymbol", void 0), __decorate([m({ type: u4, nonNullable: true })], de2.prototype, "snappingOptions", null), __decorate([m()], de2.prototype, "snappingManager", null), __decorate([m({ readOnly: true })], de2.prototype, "state", null), __decorate([m({ type: r3, nonNullable: true })], de2.prototype, "tooltipOptions", null), __decorate([m({ readOnly: true })], de2.prototype, "updateGraphics", void 0), __decorate([m()], de2.prototype, "updateOnGraphicClick", void 0), __decorate([m()], de2.prototype, "updating", null), __decorate([m()], de2.prototype, "creationMode", void 0), __decorate([m({ type: n5, nonNullable: true })], de2.prototype, "valueOptions", null), __decorate([m({ types: x })], de2.prototype, "vertexSymbol", void 0), __decorate([m({ value: null })], de2.prototype, "view", null), __decorate([m({ constructOnly: true, type: l6 })], de2.prototype, "sketchOptions", void 0), de2 = __decorate([a("esri.widgets.Sketch.SketchViewModel")], de2);
var ue = "sketch:missing-property";
var me = (e8) => `Property '${e8}' is missing on SketchViewModel.`;
function ye(e8) {
  return "polygon" === e8 || "rectangle" === e8 || "circle" === e8;
}
function ge(e8, t6) {
  fe("undo", e8.history.undo, e8.history.redo, t6);
}
function ve(e8, t6) {
  fe("redo", e8.history.redo, e8.history.undo, t6);
}
function fe(e8, t6, o3, a11) {
  const i5 = t6.pop();
  if (!i5) return;
  const r9 = i5.updates, s7 = [];
  a11.forEach((t7, o4) => {
    const a12 = r9[o4];
    null != a12 && ("geometry" in a12 && null != a12.geometry && (s7.push({ geometry: t7.geometry }), t7.geometry = a12.geometry), "symbol" in a12 && null != a12.symbol && (s7.push({ symbol: t7.symbol }), t7.symbol = a12.symbol), "undo" in a12 && (s7.push(a12), a12[e8](t7)));
  }), o3.push({ updates: s7 });
}
function _e(e8, t6) {
  null != e8 && t6.hasGrabbedManipulators && (e8.activeTool = null);
}
function be(e8) {
  return { updates: e8.map(({ geometry: e9 }) => "mesh" === e9?.type ? { geometry: e9.cloneShallow() } : { geometry: e9 }) };
}
function we(e8, t6) {
  e8.tools?.remove(t6), t6.destroyed || t6.destroy();
}
function Ge(e8) {
  return "requireError" in e8 && "aborted" === e8.requireError;
}

export {
  de2 as de
};
//# sourceMappingURL=chunk-UTFQHSO2.js.map
