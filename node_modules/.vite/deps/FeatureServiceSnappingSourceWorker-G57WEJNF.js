import {
  i as i4,
  n,
  r
} from "./chunk-RNW3VGJP.js";
import {
  d as d3,
  f as f7,
  p as p2,
  y
} from "./chunk-QNW4D2V2.js";
import "./chunk-XAI6T5FU.js";
import "./chunk-QNDHLVDC.js";
import "./chunk-ZT4KW2M5.js";
import {
  a as a2
} from "./chunk-FHQNDU7E.js";
import "./chunk-IOJ4QFRL.js";
import {
  f as f6
} from "./chunk-5DFXT3PU.js";
import {
  o as o3
} from "./chunk-CKE7BUXC.js";
import "./chunk-B5SL7XHP.js";
import {
  W
} from "./chunk-3VXANCFN.js";
import "./chunk-MBQEPUQX.js";
import "./chunk-ODQ5APZK.js";
import "./chunk-G5IXTUNN.js";
import "./chunk-ZNQKJRCD.js";
import "./chunk-BA6HYZ35.js";
import "./chunk-GCTH5LET.js";
import "./chunk-Q7VRQYAO.js";
import "./chunk-SJB744AD.js";
import "./chunk-WM2VG5F2.js";
import "./chunk-IXFJYDA2.js";
import "./chunk-TTLSEJNG.js";
import "./chunk-U73R3I4U.js";
import "./chunk-VGXUPJSS.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import "./chunk-DLM5SBNY.js";
import "./chunk-EKZRA6TO.js";
import "./chunk-M5SP6ZBM.js";
import "./chunk-FAA2FDN5.js";
import "./chunk-2HGIYEIL.js";
import {
  Mt,
  at,
  ht
} from "./chunk-XX3OKYJS.js";
import {
  e as e4
} from "./chunk-OTCNIJ2H.js";
import "./chunk-JGA5YJWL.js";
import "./chunk-GCI4MA3M.js";
import "./chunk-SJ2OBYX2.js";
import "./chunk-MDJNYPVI.js";
import "./chunk-Z6VKIQV2.js";
import "./chunk-4PXNA4MD.js";
import {
  h as h2
} from "./chunk-BPTFV5VM.js";
import {
  z as z2
} from "./chunk-YP3WVJP3.js";
import {
  e as e3
} from "./chunk-M24KZOVI.js";
import {
  b as b3
} from "./chunk-647DAMHU.js";
import "./chunk-O6G3PPOK.js";
import "./chunk-ZKNZTIAS.js";
import "./chunk-OJMISN3F.js";
import "./chunk-EFV6H5NA.js";
import "./chunk-XDLV73DB.js";
import "./chunk-ARTU4L55.js";
import "./chunk-6VL5D5UP.js";
import "./chunk-6QHY54HZ.js";
import "./chunk-GXJJY3ND.js";
import "./chunk-5ONGWFJ3.js";
import "./chunk-PLNHHGHL.js";
import "./chunk-DFK6QMLO.js";
import "./chunk-EM7Y2JZC.js";
import "./chunk-QZQPB5XR.js";
import "./chunk-AQFRVV3U.js";
import {
  c as c2
} from "./chunk-3T4IXPP4.js";
import "./chunk-XTZAIV4X.js";
import "./chunk-63LDVRFI.js";
import "./chunk-PMGS7UDU.js";
import "./chunk-3GHCGAH2.js";
import "./chunk-HWUOAPTX.js";
import "./chunk-QHCKOBU7.js";
import "./chunk-K2OZ6WVC.js";
import "./chunk-MC6NAKKX.js";
import "./chunk-TF6255HN.js";
import {
  f as f5
} from "./chunk-GD4FJL3C.js";
import "./chunk-C5OQVQZF.js";
import {
  b as b2,
  d
} from "./chunk-XL5QPCXN.js";
import "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-C5M24ACM.js";
import "./chunk-L4A2QJG4.js";
import {
  e as e2
} from "./chunk-QF7FRVN6.js";
import "./chunk-ENINOZUZ.js";
import "./chunk-MHV23XAQ.js";
import "./chunk-V2X4OKYI.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import "./chunk-T7F6Q6JJ.js";
import "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-3FUHCAX3.js";
import "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import {
  c,
  d as d2,
  i as i3,
  o as o2,
  p
} from "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import {
  z
} from "./chunk-H74Q4SYB.js";
import {
  U,
  f as f3,
  j,
  l as l2
} from "./chunk-2OFHDVO5.js";
import {
  l
} from "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import "./chunk-7H3U4IJR.js";
import "./chunk-SMWUT52Z.js";
import "./chunk-AXZMNHTN.js";
import {
  f as f4
} from "./chunk-5T3MJDSR.js";
import "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import {
  g2 as g
} from "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import {
  b,
  e3 as e,
  f as f2,
  i2,
  m,
  o3 as o,
  u3 as u
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import {
  $,
  f2 as f,
  s
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i
} from "./chunk-QY7XKUIV.js";
import {
  h
} from "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/PendingFeatureTile.js
var s2 = class {
  constructor(t2, e5) {
    this.key = t2, this.resolution = e5, this.state = { type: 0 }, this.alive = true;
  }
  process(t2) {
    switch (this.state.type) {
      case 0:
        return this.state = this._gotoFetchCount(this.state, t2), this.state.task.promise.then(t2.resume, t2.resume);
      case 1:
      case 3:
        break;
      case 2:
        return this.state = this._gotoFetchFeatures(this.state, t2), this.state.task.promise.then(t2.resume, t2.resume);
      case 4:
        this.state = this._goToDone(this.state, t2);
    }
    return null;
  }
  get debugInfo() {
    return { key: this.key, featureCount: this._featureCount, state: this._stateToString };
  }
  get _featureCount() {
    switch (this.state.type) {
      case 0:
      case 1:
        return 0;
      case 2:
        return this.state.featureCount;
      case 3:
        return this.state.previous.featureCount;
      case 4:
        return this.state.features.length;
      case 5:
        return this.state.previous.features.length;
    }
  }
  get _stateToString() {
    switch (this.state.type) {
      case 0:
        return "created";
      case 1:
        return "fetch-count";
      case 2:
        return "fetched-count";
      case 3:
        return "fetch-features";
      case 4:
        return "fetched-features";
      case 5:
        return "done";
    }
  }
  _gotoFetchCount(s3, r3) {
    return { type: 1, previous: s3, task: d(async (t2) => {
      const s4 = await b2(r3.fetchCount(this, t2));
      1 === this.state.type && (this.state = a3(this.state, s4.ok ? s4.value : 1 / 0));
    }) };
  }
  _gotoFetchFeatures(s3, a4) {
    return { type: 3, previous: s3, task: d(async (t2) => {
      const u2 = await b2(a4.fetchFeatures(this, s3.featureCount, t2));
      3 === this.state.type && (this.state = r2(this.state, u2.ok ? u2.value : []));
    }) };
  }
  _goToDone(t2, e5) {
    return e5.finish(this, t2.features), { type: 5, previous: t2 };
  }
  reset() {
    const t2 = this.state;
    switch (this.state = { type: 0 }, t2.type) {
      case 0:
      case 2:
      case 4:
      case 5:
        break;
      case 1:
      case 3:
        t2.task.abort();
    }
  }
};
function a3(t2, e5) {
  return { type: 2, featureCount: e5, previous: t2 };
}
function r2(t2, e5) {
  return { type: 4, previous: t2, features: e5 };
}

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTiledFetcher.js
var j2 = class extends b {
  get _minimumVerticesPerFeature() {
    switch (this.store?.featureStore.geometryType) {
      case "esriGeometryPoint":
      case "esriGeometryMultipoint":
        return 1;
      case "esriGeometryPolygon":
        return 4;
      case "esriGeometryPolyline":
        return 2;
    }
  }
  get _mandatoryOutFields() {
    const e5 = /* @__PURE__ */ new Set();
    return this.objectIdField && e5.add(this.objectIdField), this.globalIdField && e5.add(this.globalIdField), e5;
  }
  set outFields(e5) {
    const t2 = this._get("outFields"), i5 = u(e5, this._mandatoryOutFields);
    f2(i5, t2) || (this._set("outFields", i5), o(i5, t2) || this.refresh());
  }
  get outFields() {
    return this._get("outFields") ?? this._mandatoryOutFields;
  }
  set filter(e5) {
    const t2 = this._get("filter"), i5 = this._filterProperties(e5);
    JSON.stringify(t2) !== JSON.stringify(i5) && this._set("filter", i5);
  }
  set customParameters(e5) {
    const t2 = this._get("customParameters");
    JSON.stringify(t2) !== JSON.stringify(e5) && this._set("customParameters", e5);
  }
  get _configuration() {
    return { filter: this.filter, customParameters: this.customParameters, tileInfo: this.tileInfo, tileSize: this.tileSize };
  }
  set tileInfo(e5) {
    const t2 = this._get("tileInfo");
    t2 !== e5 && (null != e5 && null != t2 && JSON.stringify(e5) === JSON.stringify(t2) || (this._set("tileInfo", e5), this.store.tileInfo = e5));
  }
  set tileSize(e5) {
    this._get("tileSize") !== e5 && this._set("tileSize", e5);
  }
  get updating() {
    return this._updatingHandles.updating;
  }
  get hasZ() {
    return this.store.featureStore.hasZ;
  }
  constructor(e5) {
    super(e5), this.suspended = true, this._historicMoment = null, this.tilesOfInterest = new Array(), this.availability = 0, this._pendingTiles = /* @__PURE__ */ new Map(), this._updatingHandles = new h2();
  }
  initialize() {
    this._initializeFetchExtent(), this._updatingHandles.add(() => this._configuration, () => this.refresh()), this._updatingHandles.add(() => this.tilesOfInterest, () => {
      this._updatePriorities(), this._process();
    }, { sync: true, initial: true, equals: (e5, t2) => h(e5, t2, ({ id: e6 }, { id: t3 }) => e6 === t3) }), this.addHandles(f3(() => !this.suspended, () => this._process()));
  }
  _updatePriorities() {
    this.store.setPriorityOrderByKey(this.tilesOfInterest.map(({ id: e5 }) => e5) ?? []);
  }
  destroy() {
    this._pendingTiles.forEach((e5) => this._deletePendingTile(e5)), this._pendingTiles.clear(), this.store.destroy(), this.tilesOfInterest.length = 0, this._updatingHandles.destroy();
  }
  refresh() {
    this.store.refresh(), this._pendingTiles.forEach((e5) => this._deletePendingTile(e5)), this._process();
  }
  async handleEdits(e5) {
    if (e5.historicMoment && (this._historicMoment = e5.historicMoment), !e5.addedFeatures.length && !e5.updatedFeatures.length && !e5.deletedFeatures.length) return;
    for (const s3 of this._pendingTiles.values()) s3.reset();
    const t2 = { ...e5, deletedFeatures: e5.deletedFeatures.map(({ objectId: e6, globalId: t3 }) => e6 && -1 !== e6 ? e6 : this._lookupObjectIdByGlobalId(t3)) }, i5 = d(async (e6) => {
      try {
        await this.store.processEdits(t2, (e7, t3) => this._queryFeaturesById(e7, t3), e6), this._processPendingTiles();
      } catch (i6) {
        f(i6), i.getLogger(this).warn("Failed to apply edits", i6);
      }
    });
    this.addHandles(i5), await this._updatingHandles.addPromise(i5.promise);
  }
  setHistoricMoment(e5) {
    e5?.getTime() !== this._historicMoment?.getTime() && (this._historicMoment = e5, this.refresh());
  }
  _initializeFetchExtent() {
    if (!this.capabilities.query.supportsExtent || !g(this.url)) return;
    const e5 = d(async (e6) => {
      try {
        const t2 = await d3(this.url, new b3({ where: "1=1", outSpatialReference: this.spatialReference, cacheHint: this.capabilities.query.supportsCacheHint ?? void 0 }), { query: this._configuration.customParameters, signal: e6 });
        this.store.extent = z.fromJSON(t2.data?.extent);
      } catch (t2) {
        f(t2), i.getLogger(this).warn("Failed to fetch data extent", t2);
      }
    });
    this._updatingHandles.addPromise(e5.promise.then(() => this._process())), this.addHandles(e5);
  }
  get debugInfo() {
    return { numberOfFeatures: this.store.featureStore.numFeatures, tilesOfInterest: this.tilesOfInterest, pendingTiles: Array.from(this._pendingTiles.values()).map((e5) => e5.debugInfo), storedTiles: this.store.debugInfo };
  }
  _process() {
    this._markTilesNotAlive(), this._createPendingTiles(), this._deletePendingTiles(), this._processPendingTiles();
  }
  _markTilesNotAlive() {
    for (const e5 of this._pendingTiles.values()) e5.alive = false;
  }
  _createPendingTiles() {
    if (this.suspended) return;
    const e5 = this._collectMissingTilesInfo();
    if (this._setAvailability(null == e5 ? 1 : e5.coveredArea / e5.fullArea), null != e5) for (const { data: t2, resolution: i5 } of e5.missingTiles) {
      const e6 = this._pendingTiles.get(t2.id);
      e6 ? (e6.resolution = i5, e6.alive = true) : this._createPendingTile(t2, i5);
    }
  }
  _collectMissingTilesInfo() {
    let e5 = null;
    for (const t2 of this.tilesOfInterest) {
      const i5 = this.store.process(t2, (e6, t3) => this._verifyTileComplexity(e6, t3), this.outFields);
      null == e5 ? e5 = i5 : e5.prepend(i5);
    }
    return e5;
  }
  _deletePendingTiles() {
    for (const e5 of this._pendingTiles.values()) e5.alive || this._deletePendingTile(e5);
  }
  _processPendingTiles() {
    const e5 = { fetchCount: (e6, t2) => this._fetchCount(e6, t2), fetchFeatures: (e6, t2, i5) => this._fetchFeatures(e6, t2, i5), finish: (e6, t2) => this._finishPendingTile(e6, t2), resume: () => this._processPendingTiles() };
    if (this._ensureFetchAllCounts(e5)) for (const t2 of this._pendingTiles.values()) this._verifyTileComplexity(this.store.getFeatureCount(t2.key), t2.resolution) && this._updatingHandles.addPromise(t2.process(e5));
  }
  _verifyTileComplexity(e5, t2) {
    return this._verifyVertexComplexity(e5) && this._verifyFeatureDensity(e5, t2);
  }
  _verifyVertexComplexity(e5) {
    return e5 * this._minimumVerticesPerFeature < C;
  }
  _verifyFeatureDensity(e5, t2) {
    if (null == this.tileInfo) return false;
    const i5 = this.tileSize * t2;
    return e5 * (q / (i5 * i5)) < M;
  }
  _ensureFetchAllCounts(e5) {
    let t2 = true;
    for (const i5 of this._pendingTiles.values()) i5.state.type < 2 && this._updatingHandles.addPromise(i5.process(e5)), i5.state.type <= 1 && (t2 = false);
    return t2;
  }
  _finishPendingTile(e5, t2) {
    this.store.add(e5.key, t2), this._deletePendingTile(e5), this._updateAvailability();
  }
  _updateAvailability() {
    const e5 = this._collectMissingTilesInfo();
    this._setAvailability(null == e5 ? 1 : e5.coveredArea / e5.fullArea);
  }
  _setAvailability(e5) {
    this._set("availability", e5);
  }
  _createPendingTile(e5, t2) {
    const i5 = new s2(e5, t2);
    return this._pendingTiles.set(e5.id, i5), i5;
  }
  _deletePendingTile(e5) {
    e5.reset(), this._pendingTiles.delete(e5.key.id);
  }
  async _fetchCount(e5, t2) {
    return this.store.fetchCount(e5.key, this.url, this._createCountQuery(e5), { query: this.customParameters, timeout: x, signal: t2 });
  }
  async _fetchFeatures(e5, t2, i5) {
    let s3 = 0;
    const r3 = [];
    let o4 = 0, n2 = t2;
    for (; ; ) {
      const a4 = this._createFeaturesQuery(e5), l3 = this._setPagingParameters(a4, s3, n2), { features: u2, exceededTransferLimit: c3 } = await this._queryFeatures(a4, i5);
      l3 && (s3 += a4.num), o4 += u2.length;
      for (const e6 of u2) r3.push(e6);
      if (n2 = t2 - o4, !l3 || !c3 || n2 <= 0) return r3;
    }
  }
  _filterProperties(e5) {
    return null == e5 ? { where: "1=1", gdbVersion: void 0, timeExtent: void 0 } : { where: e5.where || "1=1", timeExtent: e5.timeExtent, gdbVersion: e5.gdbVersion };
  }
  _lookupObjectIdByGlobalId(e5) {
    const t2 = this.globalIdField, i5 = this.objectIdField;
    if (null == t2) throw new Error("Expected globalIdField to be defined");
    let s3 = null;
    const r3 = e5 ? e2(e5) : e5;
    if (this.store.featureStore.forEach((e6) => {
      r3 === e2(e6.attributes[t2]) && (s3 = e6.objectId ?? e6.attributes[i5]);
    }), null == s3) throw new Error(`Expected to find a feature with globalId ${e5}`);
    return s3;
  }
  _queryFeaturesById(e5, t2) {
    const i5 = this._createFeaturesQuery();
    return i5.objectIds = e5, this._queryFeatures(i5, t2);
  }
  async _queryFeatures(e5, t2) {
    return 0 === e5.num ? new e4() : this.capabilities.query.supportsFormatPBF ? this._queryFeaturesPBF(e5, t2) : this._queryFeaturesJSON(e5, t2);
  }
  async _queryFeaturesPBF(e5, t2) {
    const { sourceSpatialReference: i5 } = this, { data: s3 } = await f7(this.url, e5, new a2({ sourceSpatialReference: i5 }), { query: this._configuration.customParameters, timeout: x, signal: t2 });
    return ht(s3);
  }
  async _queryFeaturesJSON(e5, t2) {
    const { sourceSpatialReference: i5 } = this, { data: s3 } = await y(this.url, e5, i5, { query: this._configuration.customParameters, timeout: x, signal: t2 });
    return at(s3, { type: "object-id", fieldName: this.objectIdField });
  }
  _createCountQuery(e5) {
    const t2 = this._createBaseQuery(e5);
    return this.capabilities.query.supportsCacheHint && (t2.cacheHint = true), t2;
  }
  _createFeaturesQuery(e5 = null) {
    const t2 = this._createBaseQuery(e5), i5 = null != e5?.key ? this.store.getAttributesForTile(e5?.key?.id) : null, s3 = u(i2(this.outFields, i5 ?? /* @__PURE__ */ new Set()), this._mandatoryOutFields);
    return t2.outFields = Array.from(s3), t2.returnGeometry = true, null != e5 && (this.capabilities.query.supportsResultType ? t2.resultType = "tile" : this.capabilities.query.supportsCacheHint && (t2.cacheHint = true)), t2;
  }
  _createBaseQuery(e5) {
    const t2 = new b3({ returnZ: this.hasZ, returnM: false, historicMoment: this._historicMoment, geometry: null != this.tileInfo && null != e5 ? c(e5.key.extent, this.tileInfo.spatialReference) : void 0 }), i5 = this._configuration.filter;
    return null != i5 && (t2.where = i5.where, t2.gdbVersion = i5.gdbVersion, t2.timeExtent = i5.timeExtent), t2.outSpatialReference = this.spatialReference, t2;
  }
  _setPagingParameters(e5, t2, i5) {
    if (!this.capabilities.query.supportsPagination) return false;
    const { supportsMaxRecordCountFactor: s3, supportsCacheHint: r3, tileMaxRecordCount: o4, maxRecordCount: n2, supportsResultType: a4 } = this.capabilities.query, l3 = s3 ? b3.MAX_MAX_RECORD_COUNT_FACTOR : 1, u2 = l3 * ((a4 || r3) && o4 ? o4 : n2 || w);
    return e5.start = t2, s3 ? (e5.maxRecordCountFactor = Math.min(l3, Math.ceil(i5 / u2)), e5.num = Math.min(i5, e5.maxRecordCountFactor * u2)) : e5.num = Math.min(i5, u2), true;
  }
};
__decorate([m({ constructOnly: true })], j2.prototype, "url", void 0), __decorate([m({ constructOnly: true })], j2.prototype, "objectIdField", void 0), __decorate([m({ constructOnly: true })], j2.prototype, "globalIdField", void 0), __decorate([m({ constructOnly: true })], j2.prototype, "capabilities", void 0), __decorate([m({ constructOnly: true })], j2.prototype, "sourceSpatialReference", void 0), __decorate([m({ constructOnly: true })], j2.prototype, "spatialReference", void 0), __decorate([m({ constructOnly: true })], j2.prototype, "store", void 0), __decorate([m({ readOnly: true })], j2.prototype, "_minimumVerticesPerFeature", null), __decorate([m()], j2.prototype, "_mandatoryOutFields", null), __decorate([m()], j2.prototype, "outFields", null), __decorate([m()], j2.prototype, "suspended", void 0), __decorate([m()], j2.prototype, "_historicMoment", void 0), __decorate([m()], j2.prototype, "filter", null), __decorate([m()], j2.prototype, "customParameters", null), __decorate([m({ readOnly: true })], j2.prototype, "_configuration", null), __decorate([m()], j2.prototype, "tileInfo", null), __decorate([m()], j2.prototype, "tileSize", null), __decorate([m()], j2.prototype, "tilesOfInterest", void 0), __decorate([m({ readOnly: true })], j2.prototype, "updating", null), __decorate([m({ readOnly: true })], j2.prototype, "availability", void 0), __decorate([m()], j2.prototype, "hasZ", null), j2 = __decorate([a("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiledFetcher")], j2);
var w = 2e3;
var x = 6e5;
var C = 1e6;
var q = 25;
var M = 1;

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTileCache.js
var t = class {
  constructor() {
    this._store = /* @__PURE__ */ new Map(), this._priorities = /* @__PURE__ */ new Map();
  }
  get size() {
    return this._store.size;
  }
  setPriorityOrderByKey(t2) {
    this._priorities.clear();
    for (let r3 = t2.length - 1; r3 >= 0; r3--) this._priorities.set(t2[r3], t2.length - r3);
  }
  hasLowerPriority(t2) {
    const r3 = this._priorities.get(t2);
    if (null == r3) return true;
    for (const [e5] of this._store) {
      const t3 = this._priorities.get(e5);
      if (null == t3 || t3 < r3) return true;
    }
    return false;
  }
  someFromLowestToHighestPriority(t2) {
    const { _priorities: r3 } = this;
    for (const [e5, s3] of this._store) if (!r3.has(e5) && t2(s3, e5)) return true;
    for (const [e5] of r3) {
      const r4 = this._store.get(e5);
      if (r4 && t2(r4, e5)) return true;
    }
    return false;
  }
  set(t2, r3) {
    this._store.set(t2, r3);
  }
  delete(t2) {
    return this._store.delete(t2);
  }
  get(t2) {
    return this._store.get(t2);
  }
  has(t2) {
    return this._store.has(t2);
  }
  clear() {
    this._store.clear();
  }
  values() {
    return this._store.values();
  }
  [Symbol.iterator]() {
    return this._store[Symbol.iterator]();
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTileStore.js
var m2 = class extends b {
  setPriorityOrderByKey(e5) {
    this._tiles.setPriorityOrderByKey(e5);
  }
  get _memoryLimitExceeded() {
    return this.featureStore.usedMemory >= this.maximumByteSize;
  }
  constructor(e5) {
    super(e5), this.tileInfo = null, this.extent = null, this.maximumByteSize = 10485760, this._tileBounds = new o3(), this._tiles = new t(), this._refCounts = /* @__PURE__ */ new Map(), this._tileFeatureCounts = /* @__PURE__ */ new Map(), this._tmpBoundingRect = i3();
  }
  add(e5, t2) {
    for (const s3 of t2) this._referenceFeature(s3.objectId);
    const i5 = this.featureStore.upsertMany(t2), r3 = i5.map((e6) => new Set(Object.keys(e6.attributes))).reduce((e6, t3) => e(e6, t3), new Set(Object.keys(i5[0]?.attributes ?? []))), o4 = this._memoryLimitExceeded;
    this._addTileStorage(e5, new Set(i5.map((e6) => e6.objectId)), r3), o4 && this._applyCacheMemoryLimits();
  }
  _applyCacheMemoryLimits() {
    if (!this._memoryLimitExceeded) return;
    const { _tiles: e5, featureStore: t2, maximumByteSize: s3 } = this;
    e5.someFromLowestToHighestPriority((e6) => !this._memoryLimitExceeded || t2.usedMemory - this._estimateRemoveTileMemoryReduction(e6) < s3 || (this._removeTileStorage(e6), false));
  }
  _estimateRemoveTileMemoryReduction(e5) {
    let t2 = 0;
    for (const s3 of e5.objectIds) {
      if (1 === this._refCounts.get(s3)) {
        const e6 = this.featureStore.getFeature(s3);
        e6 && (t2 += this.featureStore.estimateFeatureUsedMemory?.(e6) ?? 0);
      }
    }
    return t2;
  }
  _hasAttributesForTile(e5, t2) {
    if (e5) {
      const s3 = this._tiles.get(e5);
      if (s3) return !s3.objectIds.size || o(t2, s3.attributeKeys);
    }
    return false;
  }
  getAttributesForTile(e5) {
    return e5 ? this._tiles.get(e5)?.attributeKeys : null;
  }
  destroy() {
    this.clear(), this._tileFeatureCounts.clear();
  }
  clear() {
    this.featureStore.clear(), this._tileBounds.clear(), this._tiles.clear(), this._refCounts.clear();
  }
  refresh() {
    this.clear(), this._tileFeatureCounts.clear();
  }
  processEdits(e5, t2, s3) {
    return this._processEditsDelete(e5.deletedFeatures.concat(e5.updatedFeatures)), this._processEditsRefetch(e5.addedFeatures.concat(e5.updatedFeatures), t2, s3);
  }
  _addTileStorage(e5, t2, s3) {
    const i5 = e5.id;
    this._tiles.set(i5, new y2(e5, t2, s3)), this._tileBounds.set(i5, e5.extent), this._tileFeatureCounts.set(i5, t2.size);
  }
  _remove({ id: e5 }) {
    const t2 = this._tiles.get(e5);
    t2 && this._removeTileStorage(t2);
  }
  _removeTileStorage(e5) {
    const t2 = [];
    for (const i5 of e5.objectIds) 1 === this._unreferenceFeature(i5) && t2.push(i5);
    this.featureStore.removeManyById(t2);
    const s3 = e5.key.id;
    this._tiles.delete(s3), this._tileBounds.delete(s3);
  }
  _processEditsDelete(e5) {
    this.featureStore.removeManyById(e5);
    for (const t2 of this._tiles.values()) {
      for (const s3 of e5) t2.objectIds.delete(s3);
      this._tileFeatureCounts.set(t2.key.id, t2.objectIds.size);
    }
    for (const t2 of e5) this._refCounts.delete(t2);
  }
  async _processEditsRefetch(e5, t2, s3) {
    if (!e5.length) return;
    const i5 = (await t2(e5, s3)).features, { hasZ: r3, hasM: o4 } = this.featureStore;
    for (const n2 of i5) {
      const e6 = Mt(this._tmpBoundingRect, n2.geometry, r3, o4);
      null != e6 && this._tileBounds.forEachInBounds(e6, (e7) => {
        const t3 = this._tiles.get(e7);
        this.featureStore.add(n2);
        const s4 = n2.objectId;
        t3.objectIds.has(s4) || (t3.objectIds.add(s4), this._referenceFeature(s4), this._tileFeatureCounts.set(t3.key.id, t3.objectIds.size));
      });
    }
  }
  process(e5, t2 = () => true, s3) {
    if (null == this.tileInfo || !e5.extent || null != this.extent && !d2(o2(this.extent, this._tmpBoundingRect), e5.extent)) return new v(e5);
    if (this._memoryLimitExceeded && !this._tiles.hasLowerPriority(e5.id ?? "")) return new v(e5);
    if (this._hasAttributesForTile(e5.id, s3)) return new v(e5);
    const i5 = this._createTileTree(e5, this.tileInfo);
    return this._simplify(i5, t2, null, 0, 1), this._collectMissingTiles(e5, i5, this.tileInfo, s3);
  }
  get debugInfo() {
    return Array.from(this._tiles.values()).map(({ key: e5 }) => ({ key: e5.toJSON(), featureCount: this._tileFeatureCounts.get(e5.id) || 0 }));
  }
  getFeatureCount(e5) {
    return this._tileFeatureCounts.get(e5.id) ?? 0;
  }
  async fetchCount(e5, t2, s3, i5) {
    const r3 = this._tileFeatureCounts.get(e5.id);
    if (null != r3) return r3;
    const o4 = await p2(t2, s3, i5);
    return this._tileFeatureCounts.set(e5.id, o4.data.count), o4.data.count;
  }
  _createTileTree(e5, t2) {
    const s3 = new g2(e5.level, e5.row, e5.col);
    return t2.updateTileInfo(s3, 1), this._tileBounds.forEachInBounds(e5.extent, (i5) => {
      const r3 = this._tiles.get(i5)?.key;
      r3 && p3(e5, r3) && this._populateChildren(s3, r3, t2, this._tileFeatureCounts.get(r3.id) || 0);
    }), s3;
  }
  _populateChildren(e5, t2, s3, i5) {
    const r3 = t2.level - e5.level - 1;
    if (r3 < 0) return void (e5.isLeaf = true);
    const o4 = t2.row >> r3, n2 = t2.col >> r3, l3 = e5.row << 1, u2 = n2 - (e5.col << 1) + (o4 - l3 << 1), c3 = e5.children[u2];
    if (null != c3) this._populateChildren(c3, t2, s3, i5);
    else {
      const r4 = new g2(e5.level + 1, o4, n2);
      s3.updateTileInfo(r4, 1), e5.children[u2] = r4, this._populateChildren(r4, t2, s3, i5);
    }
  }
  _simplify(e5, t2, s3, i5, r3) {
    const o4 = r3 * r3;
    if (e5.isLeaf) return t2(this.getFeatureCount(e5), r3) ? 0 : (this._remove(e5), null != s3 && (s3.children[i5] = null), o4);
    const n2 = r3 / 2, l3 = n2 * n2;
    let u2 = 0;
    for (let c3 = 0; c3 < e5.children.length; c3++) {
      const s4 = e5.children[c3];
      u2 += null != s4 ? this._simplify(s4, t2, e5, c3, n2) : l3;
    }
    return 0 === u2 ? this._mergeChildren(e5) : 1 - u2 / o4 < S && (this._purge(e5), null != s3 && (s3.children[i5] = null), u2 = o4), u2;
  }
  _mergeChildren(e5) {
    const t2 = /* @__PURE__ */ new Set();
    let i5;
    this._forEachLeaf(e5, (e6) => {
      const r3 = this._tiles.get(e6.id);
      if (r3) {
        i5 = i5 ? e(i5, r3.attributeKeys) : new Set(r3.attributeKeys);
        for (const e7 of r3.objectIds) t2.has(e7) || (t2.add(e7), this._referenceFeature(e7));
        this._remove(e6);
      }
    }), this._addTileStorage(e5, t2, i5 ?? /* @__PURE__ */ new Set()), e5.isLeaf = true, e5.children[0] = e5.children[1] = e5.children[2] = e5.children[3] = null, this._tileFeatureCounts.set(e5.id, t2.size);
  }
  _forEachLeaf(e5, t2) {
    for (const s3 of e5.children) null != s3 && (s3.isLeaf ? t2(s3) : this._forEachLeaf(s3, t2));
  }
  _purge(e5) {
    if (null != e5) if (e5.isLeaf) this._remove(e5);
    else for (let t2 = 0; t2 < e5.children.length; t2++) {
      const s3 = e5.children[t2];
      this._purge(s3), e5.children[t2] = null;
    }
  }
  _collectMissingTiles(e5, t2, s3, i5) {
    const r3 = new C2(s3, e5, this.extent);
    return this._collectMissingTilesRecurse(t2, r3, 1, i5), r3.info;
  }
  _collectMissingTilesRecurse(e5, t2, s3, i5) {
    const r3 = this._tiles.has(e5.id) && !this._hasAttributesForTile(e5.id, i5);
    if (r3 && t2.addMissing(e5.level, e5.row, e5.col, s3), e5.isLeaf) return;
    if (!e5.hasChildren) return void (r3 || t2.addMissing(e5.level, e5.row, e5.col, s3));
    const o4 = s3 / 2;
    for (let n2 = 0; n2 < e5.children.length; n2++) {
      const s4 = e5.children[n2];
      null == s4 ? t2.addMissing(e5.level + 1, (e5.row << 1) + ((2 & n2) >> 1), (e5.col << 1) + (1 & n2), o4) : this._collectMissingTilesRecurse(s4, t2, o4, i5);
    }
  }
  _referenceFeature(e5) {
    const t2 = (this._refCounts.get(e5) || 0) + 1;
    return this._refCounts.set(e5, t2), 1 === t2 ? 0 : 2;
  }
  _unreferenceFeature(e5) {
    const t2 = (this._refCounts.get(e5) || 0) - 1;
    return 0 === t2 ? (this._refCounts.delete(e5), 1) : (t2 > 0 && this._refCounts.set(e5, t2), 2);
  }
  get test() {
  }
};
function p3(e5, t2) {
  if (!e5 || !t2) return false;
  if (e5.level === t2.level) return e5.row === t2.row && e5.col === t2.col;
  const s3 = e5.level < t2.level, i5 = s3 ? e5 : t2, r3 = s3 ? t2 : e5, o4 = 1 << r3.level - i5.level;
  return Math.floor(r3.row / o4) === i5.row && Math.floor(r3.col / o4) === i5.col;
}
__decorate([m({ constructOnly: true })], m2.prototype, "featureStore", void 0), __decorate([m()], m2.prototype, "tileInfo", void 0), __decorate([m()], m2.prototype, "extent", void 0), __decorate([m()], m2.prototype, "maximumByteSize", void 0), m2 = __decorate([a("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTileStore")], m2);
var y2 = class {
  constructor(e5, t2, s3) {
    this.key = e5, this.objectIds = t2, this.attributeKeys = s3;
  }
};
var g2 = class extends e3 {
  constructor() {
    super(...arguments), this.isLeaf = false, this.children = [null, null, null, null];
  }
  get hasChildren() {
    return !this.isLeaf && (null != this.children[0] || null != this.children[1] || null != this.children[2] || null != this.children[3]);
  }
};
var v = class {
  constructor(e5, t2 = []) {
    this.missingTiles = t2, this.fullArea = 0, this.coveredArea = 0, this.fullArea = p(e5.extent), this.coveredArea = this.fullArea;
  }
  prepend(e5) {
    this.missingTiles = e5.missingTiles.concat(this.missingTiles), this.coveredArea += e5.coveredArea, this.fullArea += e5.fullArea;
  }
};
var C2 = class {
  constructor(e5, t2, s3) {
    this._tileInfo = e5, this._extent = null, this.info = new v(t2), null != s3 && (this._extent = o2(s3));
  }
  addMissing(e5, t2, s3, i5) {
    const r3 = new e3(e5, t2, s3);
    this._tileInfo.updateTileInfo(r3, 1) && (null == this._extent || d2(this._extent, r3.extent)) && (this.info.missingTiles.push({ data: r3, resolution: i5 }), this.info.coveredArea -= p(r3.extent));
  }
};
var S = 0.18751;

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceSnappingSourceWorker.js
var w2 = class extends l {
  constructor() {
    super(...arguments), this._isInitializing = true, this.remoteClient = null, this._whenSetup = $(), this._elevationAligner = i4(), this._elevationFilter = r(), this._symbologyCandidatesFetcher = n(), this._updatingHandles = new h2(), this._alignPointsInFeatures = async (e5, t2) => {
      const i5 = { query: e5 }, s3 = await this.remoteClient.invoke("alignElevation", i5, { signal: t2 });
      return s(t2), s3;
    }, this._getSymbologyCandidates = async (e5, t2) => {
      const i5 = { candidates: e5, spatialReference: this._spatialReference.toJSON() }, s3 = await this.remoteClient.invoke("getSymbologyCandidates", i5, { signal: t2 });
      return s(t2), s3;
    };
  }
  get updating() {
    return this._isInitializing || this._updatingHandles.updating || this._featureFetcher.updating;
  }
  destroy() {
    this._featureFetcher?.destroy(), this._queryEngine?.destroy(), this._featureStore?.clear();
  }
  async setup(e5) {
    if (this.destroyed) return { result: {} };
    const { geometryType: t2, objectIdField: i5, timeInfo: r3, fieldsIndex: n2 } = e5.serviceInfo, { hasZ: o4 } = e5, l3 = f4.fromJSON(e5.spatialReference);
    this._spatialReference = l3, this._featureStore = new f6({ ...e5.serviceInfo, hasZ: o4, hasM: false }), this._featureStore.estimateFeatureUsedMemory = (e6) => e6.usedMemory, this._queryEngine = new W({ spatialReference: e5.spatialReference, featureStore: this._featureStore, geometryType: t2, fieldsIndex: n2, hasZ: o4, hasM: false, featureIdInfo: { type: "object-id", fieldName: i5 }, timeInfo: r3 }), this._featureFetcher = new j2({ store: new m2({ featureStore: this._featureStore }), url: e5.serviceInfo.url, objectIdField: e5.serviceInfo.objectIdField, globalIdField: e5.serviceInfo.globalIdField, capabilities: e5.serviceInfo.capabilities, spatialReference: l3, sourceSpatialReference: f4.fromJSON(e5.serviceInfo.spatialReference), customParameters: e5.configuration.customParameters });
    const u2 = "3d" === e5.configuration.viewType;
    return this._elevationAligner = i4(u2, { elevationInfo: null != e5.elevationInfo ? c2.fromJSON(e5.elevationInfo) : null, alignPointsInFeatures: this._alignPointsInFeatures }), this._elevationFilter = r(u2), this.addHandles([l2(() => this._featureFetcher.availability, (e6) => this.emit("notify-availability", { availability: e6 }), U), l2(() => this.updating, () => this._notifyUpdating())]), this._whenSetup.resolve(), this._isInitializing = false, this.configure(e5.configuration);
  }
  async configure(e5) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), this._updateFeatureFetcherConfiguration(e5), C3;
  }
  async setSuspended(e5, t2) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s(t2), this._featureFetcher.suspended = e5, C3;
  }
  async updateOutFields(e5, t2) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s(t2), this._featureFetcher.outFields = new Set(e5 ?? []), C3;
  }
  async fetchCandidates(e5, t2) {
    await this._whenSetup.promise, s(t2);
    const i5 = j3(e5, this._featureStore.hasZ), s3 = t2?.signal, a4 = await this._queryEngine.executeQueryForSnapping(i5, s3);
    s(s3);
    const n2 = await this._elevationAligner.alignCandidates(a4.candidates, f4.fromJSON(e5.point.spatialReference) ?? f4.WGS84, s3);
    s(s3);
    const o4 = await this._symbologyCandidatesFetcher.fetch(n2, s3);
    s(s3);
    const l3 = 0 === o4.length ? n2 : n2.concat(o4);
    return { result: { candidates: this._elevationFilter.filter(i5, l3) } };
  }
  async updateTiles(e5, t2) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s(t2), this._featureFetcher.tileSize = e5.tileSize, this._featureFetcher.tilesOfInterest = e5.tiles.map((e6) => e3.fromJSON(e6)), this._featureFetcher.tileInfo = null != e5.tileInfo ? z2.fromJSON(e5.tileInfo) : null, C3;
  }
  async refresh(e5, t2) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s(t2), this._featureFetcher.refresh(), C3;
  }
  async whenNotUpdating(e5, t2) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s(t2), await j(() => !this.updating, t2), s(t2), C3;
  }
  async getDebugInfo(e5, t2) {
    return s(t2), { result: this._featureFetcher.debugInfo };
  }
  async handleEdits(e5, t2) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s(t2), await this._updatingHandles.addPromise(this._featureFetcher.handleEdits(e5)), s(t2), C3;
  }
  async setHistoricMoment(e5, t2) {
    return this._featureFetcher.setHistoricMoment(e5.moment), C3;
  }
  async notifyElevationSourceChange(e5, t2) {
    return this._elevationAligner.notifyElevationSourceChange(), C3;
  }
  async notifySymbologyChange(e5, t2) {
    return this._symbologyCandidatesFetcher.notifySymbologyChange(), C3;
  }
  async setSymbologySnappingSupported(e5) {
    return this._symbologyCandidatesFetcher = n(e5, this._getSymbologyCandidates), C3;
  }
  _updateFeatureFetcherConfiguration(e5) {
    this._featureFetcher.filter = null != e5.filter ? b3.fromJSON(e5.filter) : null, this._featureFetcher.customParameters = e5.customParameters;
  }
  _notifyUpdating() {
    this.emit("notify-updating", { updating: this.updating });
  }
};
__decorate([m({ readOnly: true })], w2.prototype, "updating", null), __decorate([m()], w2.prototype, "_isInitializing", void 0), w2 = __decorate([a("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceSnappingSourceWorker")], w2);
var b4 = w2;
function j3(e5, t2) {
  const i5 = !!t2 || void 0;
  if (!e5.filter) return { ...e5, query: { where: "1=1", returnZ: i5 } };
  const { distance: r3, units: s3, spatialRel: a4, where: n2, timeExtent: o4, objectIds: l3 } = e5.filter, u2 = { geometry: e5.filter.geometry ? f5(e5.filter.geometry) : void 0, distance: r3, units: s3, spatialRel: a4, timeExtent: o4, objectIds: l3, returnZ: i5, where: n2 ?? "1=1" };
  return { ...e5, query: u2 };
}
var C3 = { result: {} };
export {
  b4 as default
};
//# sourceMappingURL=FeatureServiceSnappingSourceWorker-G57WEJNF.js.map
