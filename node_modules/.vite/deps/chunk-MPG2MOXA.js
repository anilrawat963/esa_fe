import {
  p as p2
} from "./chunk-PBFXKJNR.js";
import {
  o as o2
} from "./chunk-A3JORY5L.js";
import {
  e as e3
} from "./chunk-COMSADUT.js";
import {
  e as e2
} from "./chunk-66Y6I5GR.js";
import {
  e
} from "./chunk-IT62DCG6.js";
import {
  e as e4
} from "./chunk-SZ5DGQ75.js";
import {
  r as r2
} from "./chunk-EGPAQBOO.js";
import {
  s as s3
} from "./chunk-WJ3E33GQ.js";
import {
  r as r3
} from "./chunk-YOYO2XMY.js";
import {
  t
} from "./chunk-CFXCM2NO.js";
import {
  l
} from "./chunk-JBTWCDRR.js";
import {
  H,
  P,
  V
} from "./chunk-U6CJFTOF.js";
import {
  U,
  j2 as j
} from "./chunk-2JMKFI2D.js";
import {
  n as n2
} from "./chunk-ZVTEFYZX.js";
import {
  z
} from "./chunk-LPUPM55U.js";
import {
  n as n3
} from "./chunk-WDTGOP77.js";
import {
  A,
  E,
  _,
  c,
  p,
  r,
  s as s2,
  u
} from "./chunk-VYMBX5H5.js";
import {
  n
} from "./chunk-75XOUSSS.js";
import {
  o
} from "./chunk-AZXJIEZ6.js";
import {
  s
} from "./chunk-SMWUT52Z.js";

// node_modules/@arcgis/core/chunks/Laserlines.glsl.js
var y = s(6);
function O(e5) {
  const i = new s3();
  i.include(o2), i.include(p2, e5);
  const t2 = i.fragment;
  if (e5.lineVerticalPlaneEnabled || e5.heightManifoldEnabled) if (t2.uniforms.add(new r3("maxPixelDistance", (i2, t3) => e5.heightManifoldEnabled ? 2 * t3.camera.computeScreenPixelSizeAt(i2.heightManifoldTarget) : 2 * t3.camera.computeScreenPixelSizeAt(i2.lineVerticalPlaneSegment.origin))), t2.code.add(t`float planeDistancePixels(vec4 plane, vec3 pos) {
float dist = dot(plane.xyz, pos) + plane.w;
float width = fwidth(dist);
dist /= min(width, maxPixelDistance);
return abs(dist);
}`), e5.spherical) {
    const e6 = (e7, i3, t3) => E(e7, i3.heightManifoldTarget, t3.camera.viewMatrix), i2 = (e7, i3) => E(e7, [0, 0, 0], i3.camera.viewMatrix);
    t2.uniforms.add(new e3("heightManifoldOrigin", (t3, n4) => (e6(G, t3, n4), i2(_2, n4), c(_2, _2, G), A(W, _2), W[3] = r(_2), W)), new e2("globalOrigin", (e7) => i2(G, e7)), new r3("cosSphericalAngleThreshold", (e7, i3) => 1 - Math.max(2, p(i3.camera.eye, e7.heightManifoldTarget) * i3.camera.perRenderPixelRatio) / r(e7.heightManifoldTarget))), t2.code.add(t`float globeDistancePixels(float posInGlobalOriginLength) {
float dist = abs(posInGlobalOriginLength - heightManifoldOrigin.w);
float width = fwidth(dist);
dist /= min(width, maxPixelDistance);
return abs(dist);
}
float heightManifoldDistancePixels(vec4 heightPlane, vec3 pos) {
vec3 posInGlobalOriginNorm = normalize(globalOrigin - pos);
float cosAngle = dot(posInGlobalOriginNorm, heightManifoldOrigin.xyz);
vec3 posInGlobalOrigin = globalOrigin - pos;
float posInGlobalOriginLength = length(posInGlobalOrigin);
float sphericalDistance = globeDistancePixels(posInGlobalOriginLength);
float planarDistance = planeDistancePixels(heightPlane, pos);
return cosAngle < cosSphericalAngleThreshold ? sphericalDistance : planarDistance;
}`);
  } else t2.code.add(t`float heightManifoldDistancePixels(vec4 heightPlane, vec3 pos) {
return planeDistancePixels(heightPlane, pos);
}`);
  if (e5.pointDistanceEnabled && (t2.uniforms.add(new r3("maxPixelDistance", (e6, i2) => 2 * i2.camera.computeScreenPixelSizeAt(e6.pointDistanceTarget))), t2.code.add(t`float sphereDistancePixels(vec4 sphere, vec3 pos) {
float dist = distance(sphere.xyz, pos) - sphere.w;
float width = fwidth(dist);
dist /= min(width, maxPixelDistance);
return abs(dist);
}`)), e5.intersectsLineEnabled && t2.uniforms.add(new r2("perScreenPixelRatio", (e6) => e6.camera.perScreenPixelRatio)).code.add(t`float lineDistancePixels(vec3 start, vec3 dir, float radius, vec3 pos) {
float dist = length(cross(dir, pos - start)) / (length(pos) * perScreenPixelRatio);
return abs(dist) - radius;
}`), (e5.lineVerticalPlaneEnabled || e5.intersectsLineEnabled) && t2.code.add(t`bool pointIsWithinLine(vec3 pos, vec3 start, vec3 end) {
vec3 dir = end - start;
float t2 = dot(dir, pos - start);
float l2 = dot(dir, dir);
return t2 >= 0.0 && t2 <= l2;
}`), t2.main.add(t`vec3 pos;
vec3 normal;
float angleCutoffAdjust;
float depthDiscontinuityAlpha;
if (!laserlineReconstructFromDepth(pos, normal, angleCutoffAdjust, depthDiscontinuityAlpha)) {
fragColor = vec4(0.0);
return;
}
vec4 color = vec4(0.0);`), e5.heightManifoldEnabled) {
    t2.uniforms.add(new e4("angleCutoff", (e6) => E2(e6)), new e3("heightPlane", (e6, i3) => U2(e6.heightManifoldTarget, e6.renderCoordsHelper.worldUpAtPosition(e6.heightManifoldTarget, G), i3.camera.viewMatrix)));
    const i2 = e5.spherical ? t`normalize(globalOrigin - pos)` : t`heightPlane.xyz`;
    t2.main.add(t`
      vec2 angleCutoffAdjusted = angleCutoff - angleCutoffAdjust;
      // Fade out laserlines on flat surfaces
      float heightManifoldAlpha = 1.0 - smoothstep(angleCutoffAdjusted.x, angleCutoffAdjusted.y, abs(dot(normal, ${i2})));
      vec4 heightManifoldColor = laserlineProfile(heightManifoldDistancePixels(heightPlane, pos));
      color = max(color, heightManifoldColor * heightManifoldAlpha);`);
  }
  return e5.pointDistanceEnabled && (t2.uniforms.add(new e4("angleCutoff", (e6) => E2(e6)), new e3("pointDistanceSphere", (e6, i2) => H(z2(e6, i2)))), t2.main.add(t`float pointDistanceSphereDistance = sphereDistancePixels(pointDistanceSphere, pos);
vec4 pointDistanceSphereColor = laserlineProfile(pointDistanceSphereDistance);
float pointDistanceSphereAlpha = 1.0 - smoothstep(angleCutoff.x, angleCutoff.y, abs(dot(normal, normalize(pos - pointDistanceSphere.xyz))));
color = max(color, pointDistanceSphereColor * pointDistanceSphereAlpha);`)), e5.lineVerticalPlaneEnabled && (t2.uniforms.add(new e4("angleCutoff", (e6) => E2(e6)), new e3("lineVerticalPlane", (e6, i2) => I(e6, i2)), new e("lineVerticalStart", (e6, i2) => T(e6, i2)), new e("lineVerticalEnd", (e6, i2) => R(e6, i2))), t2.main.add(t`if (pointIsWithinLine(pos, lineVerticalStart, lineVerticalEnd)) {
float lineVerticalDistance = planeDistancePixels(lineVerticalPlane, pos);
vec4 lineVerticalColor = laserlineProfile(lineVerticalDistance);
float lineVerticalAlpha = 1.0 - smoothstep(angleCutoff.x, angleCutoff.y, abs(dot(normal, lineVerticalPlane.xyz)));
color = max(color, lineVerticalColor * lineVerticalAlpha);
}`)), e5.intersectsLineEnabled && (t2.uniforms.add(new e4("angleCutoff", (e6) => E2(e6)), new e("intersectsLineStart", (e6, i2) => E(G, e6.lineStartWorld, i2.camera.viewMatrix)), new e("intersectsLineEnd", (e6, i2) => E(G, e6.lineEndWorld, i2.camera.viewMatrix)), new e("intersectsLineDirection", (e6, i2) => (s2(W, e6.intersectsLineSegment.vector), W[3] = 0, A(G, z(W, W, i2.camera.viewMatrix)))), new r3("intersectsLineRadius", (e6) => e6.intersectsLineRadius)), t2.main.add(t`if (pointIsWithinLine(pos, intersectsLineStart, intersectsLineEnd)) {
float intersectsLineDistance = lineDistancePixels(intersectsLineStart, intersectsLineDirection, intersectsLineRadius, pos);
vec4 intersectsLineColor = laserlineProfile(intersectsLineDistance);
float intersectsLineAlpha = 1.0 - smoothstep(angleCutoff.x, angleCutoff.y, 1.0 - abs(dot(normal, intersectsLineDirection)));
color = max(color, intersectsLineColor * intersectsLineAlpha);
}`)), t2.main.add(t`fragColor = laserlineOutput(color * depthDiscontinuityAlpha);`), i;
}
function E2(t2) {
  return o(F, Math.cos(t2.angleCutoff), Math.cos(Math.max(0, t2.angleCutoff - s(2))));
}
function z2(e5, i) {
  const t2 = E(k, e5.pointDistanceOrigin, i.camera.viewMatrix), a = p(e5.pointDistanceOrigin, e5.pointDistanceTarget);
  return V($, t2, a);
}
function I(e5, i) {
  const t2 = l(e5.lineVerticalPlaneSegment, 0.5, G), n4 = e5.renderCoordsHelper.worldUpAtPosition(t2, H2), a = A(_2, e5.lineVerticalPlaneSegment.vector), r4 = _(G, n4, a);
  return A(r4, r4), U2(e5.lineVerticalPlaneSegment.origin, r4, i.camera.viewMatrix);
}
function T(e5, i) {
  const t2 = s2(G, e5.lineVerticalPlaneSegment.origin);
  return e5.renderCoordsHelper.setAltitude(t2, 0), E(t2, t2, i.camera.viewMatrix);
}
function R(e5, i) {
  const t2 = u(G, e5.lineVerticalPlaneSegment.origin, e5.lineVerticalPlaneSegment.vector);
  return e5.renderCoordsHelper.setAltitude(t2, 0), E(t2, t2, i.camera.viewMatrix);
}
function U2(e5, i, t2) {
  return E(B, e5, t2), s2(W, i), W[3] = 0, z(W, W, t2), U(B, W, N);
}
var F = n3();
var G = n();
var W = n2();
var H2 = n();
var _2 = n();
var B = n();
var N = j();
var k = n();
var $ = P();
var q = Object.freeze(Object.defineProperty({ __proto__: null, build: O, defaultAngleCutoff: y }, Symbol.toStringTag, { value: "Module" }));

export {
  y,
  O,
  q
};
//# sourceMappingURL=chunk-MPG2MOXA.js.map
