import {
  L,
  M,
  P,
  V as V3,
  b as b4,
  d as d2,
  f as f3,
  k2 as k,
  m2 as m4,
  o2,
  p,
  r,
  t3 as t2,
  y as y7,
  z2 as z
} from "./chunk-N3OIGAM3.js";
import {
  b as b3
} from "./chunk-43423NKQ.js";
import {
  y as y6
} from "./chunk-MJIAJDWR.js";
import {
  b as b2,
  l as l4,
  n as n4,
  s as s4
} from "./chunk-2GRS3IMC.js";
import {
  n2 as n6
} from "./chunk-GVFNGMIY.js";
import {
  A,
  V as V2,
  Y,
  ct,
  i2 as i3,
  m as m3
} from "./chunk-DRHU543D.js";
import {
  a as a3
} from "./chunk-4V63WUXV.js";
import {
  O as O2
} from "./chunk-TWE24CRT.js";
import {
  n as n5
} from "./chunk-Y3GEZC7J.js";
import {
  v as v2
} from "./chunk-SIUG2XLL.js";
import {
  N as N2,
  O,
  y as y5
} from "./chunk-VNSHGTPN.js";
import {
  F,
  e as e3,
  i as i2,
  n as n3,
  t
} from "./chunk-XHNYLMJC.js";
import {
  f as f2,
  g
} from "./chunk-BA6HYZ35.js";
import {
  Z
} from "./chunk-2HGIYEIL.js";
import {
  dt,
  gt,
  ut
} from "./chunk-XX3OKYJS.js";
import {
  e as e2
} from "./chunk-GCI4MA3M.js";
import {
  e
} from "./chunk-SJ2OBYX2.js";
import {
  i as i4
} from "./chunk-AJGINJLG.js";
import {
  Q,
  U,
  V,
  W,
  o
} from "./chunk-JE2NJSBU.js";
import {
  S
} from "./chunk-6VL5D5UP.js";
import {
  m as m2,
  s as s3,
  v,
  y as y4
} from "./chunk-GD4FJL3C.js";
import {
  s as s2
} from "./chunk-ONXWBTTM.js";
import {
  f4 as f,
  l3,
  n as n2,
  u5 as u2
} from "./chunk-PZ5RULLK.js";
import {
  y as y3
} from "./chunk-OPJX4KXH.js";
import {
  K,
  a as a2,
  d,
  i,
  l as l2,
  y as y2
} from "./chunk-FPMLKIDB.js";
import {
  l
} from "./chunk-2OFHDVO5.js";
import {
  u
} from "./chunk-CSMCPN64.js";
import {
  G
} from "./chunk-NMQNUPE4.js";
import {
  b,
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  n,
  s,
  y
} from "./chunk-GNMPGHLQ.js";
import {
  N,
  has
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/createGraphicSymbolMeshSchemas.js
async function u3(u4, f4, k2) {
  const b6 = [], d3 = { scaleInfo: r(u4), scaleExpression: null };
  for (const s5 of f4) switch (s5.type) {
    case "marker":
      if (s5.animationParams) {
        if (s5.animationParams.params.hasShiftAnimation) {
          b6.push(...f3(k2.instances.animatedMarkerShift, s5, b4, d3));
          break;
        }
        b6.push(...f3(k2.instances.animatedMarker, s5, b4, d3));
        break;
      }
      b6.push(...p(k2.instances.marker, s5, b4, d3));
      break;
    case "fill":
      if (s5.animationParams) {
        b6.push(...m4(k2.instances.animatedPolygon, s5, b4, d3));
        break;
      }
      null == s5.spriteRasterizationParam ? b6.push(...z(k2.instances.fill, s5, d3)) : b6.push(...d2(k2.instances.complexFill, s5, false, d3));
      break;
    case "line":
      if (s5.animationParams) {
        if (s5.animationParams.params.hasShiftAnimation) {
          b6.push(...m4(k2.instances.animatedPolylineShift, s5, b4, d3));
          break;
        }
        b6.push(...m4(k2.instances.animatedPolyline, s5, b4, d3));
        break;
      }
      s5.spriteRasterizationParam ? b6.push(...P(k2.instances.texturedLine, s5, false, d3)) : b6.push(...M(k2.instances.line, s5, false, d3));
      break;
    case "text":
      b6.push(...L(k2.instances.text, s5, b4, d3));
      break;
    case "gradientFill":
      b6.push(...y7(k2.instances.gradientFill, s5, d3));
      break;
    case "gradientStroke":
      b6.push(...k(k2.instances.gradientStroke, s5, d3));
      break;
    case "outlineFill":
      b6.push(...V3(k2.instances.outlineFill, s5, d3));
  }
  return b6;
}

// node_modules/@arcgis/core/views/2d/layers/features/support/GraphicsReader.js
var a4 = class _a extends O2 {
  static from(t4, e4, r2) {
    return new _a(t4, e4, r2);
  }
  constructor(t4, e4, r2) {
    super(r2), this._items = t4, this._tile = e4, this._index = -1, this._cachedGeometry = null;
    const s5 = e4.lod;
    s5.wrap && (this._wrappingInfo = { worldSizeX: s5.worldSize[0] });
  }
  get _current() {
    return this._items[this._index];
  }
  getItem() {
    return this._current;
  }
  getZOrder() {
    return this._current.zOrder;
  }
  getMeshWriters() {
    return this._current.symbolResource?.symbolInfo.meshWriters ?? [];
  }
  hasField(t4) {
    return null != this._current.attributes[t4];
  }
  field(t4) {
    return this.readAttribute(t4);
  }
  get geometryType() {
    const t4 = v(this._current.geometry);
    return "esriGeometryPoint" === t4 ? "esriGeometryMultipoint" : t4;
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    const t4 = new _a(this._items, this._tile, this.metadata);
    return this.copyInto(t4), t4;
  }
  copyInto(t4) {
    super.copyInto(t4), t4._cachedGeometry = this._cachedGeometry, t4._index = this._index;
  }
  get fields() {
    throw new Error("Fields reading not supported to graphics.");
  }
  get hasFeatures() {
    return !!this._items.length;
  }
  get hasNext() {
    return this._index + 1 < this._items.length;
  }
  get exceededTransferLimit() {
    throw new Error("InternalError: exceededTransferLimit not implemented for graphics.");
  }
  get hasZ() {
    return false;
  }
  get hasM() {
    return false;
  }
  get usedMemory() {
    return this._current.usedMemory;
  }
  getInTransform() {
    return this._tile.transform;
  }
  getSize() {
    return this._items.length;
  }
  getAttributeHash() {
    let t4 = "";
    for (const e4 in this._current.attributes) t4 += this._current.attributes[e4];
    return t4;
  }
  getObjectId() {
    return this._items[this._index].objectId;
  }
  getDisplayId() {
    return this._current.displayId;
  }
  setDisplayId(t4) {
    throw new Error("InternalError: Setting displayId not supported for graphics.");
  }
  setIndex(t4) {
    this._index = t4;
  }
  getIndex() {
    return this._index;
  }
  next() {
    for (this._cachedGeometry = null; ++this._index < this._items.length && !this._getExists(); ) ;
    return this._index < this._items.length;
  }
  readGeometryArea() {
    throw new Error("InternalError: readGeometryArea not supported for graphics.");
  }
  _readGeometry() {
    if (!this._cachedGeometry) {
      let t4 = ut(this._current.projectedGeometry, this.hasZ, this.hasM);
      if ("esriGeometryPolyline" === this.geometryType && (t4 = dt(new e2(), t4, this.hasZ, this.hasM, this.geometryType, this._tile.transform.scale[0])), this._cachedGeometry = gt(new e2(), t4, this.hasZ, this.hasM, this.geometryType, this._tile.transform), !this._cachedGeometry) return null;
      this._wrapGeometry(this._cachedGeometry);
    }
    return this._cachedGeometry;
  }
  _wrapGeometry(t4) {
    if (!this._wrappingInfo) return;
    const { worldSizeX: e4 } = this._wrappingInfo;
    if (t4.isPoint) return 1 === e4 ? (t4.coords.push(o, 0), t4.coords.push(2 * -o, 0), void t4.lengths.push(3)) : 2 === e4 ? (t4.coords.push(2 * o, 0), t4.coords.push(4 * -o, 0), void t4.lengths.push(3)) : void this._wrapVertex(t4.coords, 0, 2, e4);
    if ("esriGeometryMultipoint" !== this.geometryType) ;
    else {
      if (1 === e4) {
        const e5 = t4.coords.slice();
        e5[0] -= 512;
        const r2 = t4.coords.slice();
        r2[0] += 512, t4.coords.push(...e5, ...r2);
        const s5 = t4.lengths[0];
        return void t4.lengths.push(s5, s5);
      }
      this._wrapVertex(t4.coords, 0, 2, e4);
    }
  }
  _wrapVertex(t4, e4, r2, s5) {
    const i5 = e4 * r2, o3 = t4[i5];
    o3 < -o * (s5 - 2) ? t4[i5] = o3 + o * s5 : o3 > o * (s5 - 1) && (t4[i5] = o3 - o * s5);
  }
  _readX() {
    const t4 = this._readGeometry();
    return null != t4 ? t4.coords[0] : 0;
  }
  _readY() {
    const t4 = this._readGeometry();
    return null != t4 ? t4.coords[1] : 0;
  }
  _readServerCentroid() {
    switch (this.geometryType) {
      case "esriGeometryPolygon": {
        const t4 = l3(this._current.projectedGeometry), r2 = new e2([], t4);
        return gt(new e2(), r2, this.hasZ, this.hasM, this.geometryType, this._tile.transform);
      }
      case "esriGeometryPolyline": {
        const e4 = this._current.projectedGeometry, r2 = u2(e4.paths, this.hasZ), s5 = new e2([], r2);
        return gt(new e2(), s5, this.hasZ, this.hasM, this.geometryType, this._tile.transform);
      }
    }
    return null;
  }
  _readAttribute(t4, e4) {
    const r2 = this._current.attributes[t4];
    if (void 0 !== r2) return r2;
    const s5 = t4.toLowerCase();
    for (const i5 in this._current.attributes) if (i5.toLowerCase() === s5) return this._current.attributes[i5];
  }
  _readAttributes() {
    return this._current.attributes;
  }
};

// node_modules/@arcgis/core/views/2d/layers/graphics/GraphicStoreItem.js
var v3 = class _v {
  static fromGraphic(t4, e4, i5, s5) {
    return new _v(t4.geometry, e4, t4.attributes, t4.visible, t4.uid, t4.version, i5, s5);
  }
  constructor(t4, i5, s5, r2, o3, n7, m5, a5) {
    this.geometry = t4, this.symbol = i5, this.attributes = s5, this.visible = r2, this.objectId = o3, this._version = n7, this.zOrder = m5, this.displayId = a5, this.symbolBounds = K(), this.prevSymbolBounds = K(), this.size = [0, 0, 0, 0], this.geometryBounds = K(), this._isDensificationDirty = false, this._densificationDeviation = 1 / 0;
  }
  get projectedGeometry() {
    return this._projectedGeometry;
  }
  get linearCIM() {
    return this.symbolResource?.symbolInfo.linearCIM;
  }
  get usedMemory() {
    return 128 + e(this.attributes) + F(this.geometry);
  }
  get hasAnimations() {
    const { linearCIM: t4 } = this;
    return !!t4 && t4.some((t5) => "animationParams" in t5 && !!t5.animationParams);
  }
  get hasCurvedGeoemtry() {
    return null != this.geometry && "mesh" !== this.geometry.type && n2(this.geometry);
  }
  update(t4, i5, s5) {
    return (this._version !== t4.version || this.zOrder !== s5 || this.symbol !== i5) && (this.prevSymbolBounds = this.symbolBounds, this.symbolBounds = K(), this.zOrder = s5, this.geometry = t4.geometry, this.attributes = t4.attributes, this.symbol = i5, this.visible = t4.visible, this._version = t4.version, this.symbolResource = null, this._projectedGeometry = null, K(this.geometryBounds), this._minDensificationDeviation = null, this._isDensificationDirty = true, true);
  }
  updateDensificationResolution(t4) {
    if (!this.hasCurvedGeoemtry) return false;
    const e4 = Math.max(D(t4), this._minDensificationDeviation ?? 0);
    return e4 !== this._densificationDeviation && (this._densificationDeviation = e4, this._isDensificationDirty = true, true);
  }
  async projectAndNormalize(t4) {
    let e4, o3 = this.geometry;
    if (o3 && o3.spatialReference && "mesh" !== o3.type && ("extent" === o3.type && (o3 = m3(o3)), e4 = n2(o3) ? y6(o3, { maxSegmentLength: 1 / 0, minSegmentsPerCurve: n3() }) : o3.toJSON(), this._projectedGeometry = await j(e4, o3.spatialReference, t4), f(this.geometryBounds, this._projectedGeometry), this.hasCurvedGeoemtry && null != this._projectedGeometry)) {
      const t5 = l2(this.geometryBounds), e5 = y2(this.geometryBounds);
      this._minDensificationDeviation = b5(t5, e5);
    }
  }
  async densifyCurvedGeometryForDisplay(t4) {
    if (!this.hasCurvedGeoemtry || !this._isDensificationDirty) return;
    this._isDensificationDirty = false;
    const e4 = this.geometry;
    if (!e4 || !e4.spatialReference || "mesh" === e4.type) return;
    const i5 = t4.metersPerUnit / e4.spatialReference.metersPerUnit, s5 = this._densificationDeviation * i5, r2 = y6(e4, { maxDeviation: s5, minSegmentsPerCurve: i2() });
    this._projectedGeometry = await j(r2, e4.spatialReference, t4);
  }
};
async function j(t4, e4, i5) {
  await f2(t4.spatialReference, i5);
  const s5 = a3(t4);
  if (!s5) return;
  const r2 = g(s5, e4, i5);
  return r2 && y3(r2), m2(r2) ? m3(r2) : r2;
}
function D(t4) {
  return 2 ** Math.round(Math.log2(t4)) * t();
}
function b5(t4, e4) {
  if (t4 > 0 && e4 > 0) {
    const i5 = Math.min(t4, e4) / 2, s5 = 2 * Math.PI / e3();
    return i5 * (1 - Math.cos(s5 / 2));
  }
  return null;
}

// node_modules/@arcgis/core/views/2d/layers/graphics/GraphicUpdateMessage.js
var t3 = class {
  constructor(t4, e4, d3) {
    this.added = t4, this.updated = e4, this.removed = d3;
  }
  hasAnyUpdate() {
    return !!(this.added.length || this.updated.length || this.removed.length);
  }
};

// node_modules/@arcgis/core/views/2d/layers/graphics/GraphicStore.js
var p2 = 1e-5;
function _(e4, t4) {
  return t4.zOrder - e4.zOrder;
}
var y8 = class {
  constructor(e4, t4, s5, o3, i5) {
    this._items = /* @__PURE__ */ new Map(), this._boundsDirty = false, this._outSpatialReference = e4, this._cimResourceManager = t4, this._hittestDrawHelper = new ct(t4), this._tileInfoView = s5, this._store = i5;
    const r2 = s5.getClosestInfoForScale(o3);
    this._resolution = this._tileInfoView.getTileResolution(r2.level);
  }
  destroy() {
    this._hittestDrawHelper.destroy();
  }
  items() {
    return this._items.values();
  }
  getItem(e4) {
    return this._items.get(e4);
  }
  async update(e4, t4, s5) {
    const o3 = [], i5 = [], r2 = [], n7 = /* @__PURE__ */ new Set(), m5 = [];
    let l5 = 0;
    const a5 = /* @__PURE__ */ new Set();
    for (const c of e4.items) {
      const e5 = c.uid;
      if (a5.has(e5)) continue;
      a5.add(e5), l5++;
      const r3 = this._items.get(e5), u4 = t4(c);
      if (n7.add(e5), r3) {
        const e6 = r3.update(c, u4, l5), t5 = r3.updateDensificationResolution(this._resolution);
        e6 && m5.push(this._updateItem(r3, s5)), (e6 || t5) && i5.push(r3);
        continue;
      }
      const d3 = this._store.createDisplayIdForObjectId(e5), f4 = v3.fromGraphic(c, u4, l5, d3);
      f4.updateDensificationResolution(this._resolution), m5.push(this._updateItem(f4, s5)), this._items.set(f4.objectId, f4), o3.push(f4);
    }
    for (const [c, u4] of this._items.entries()) n7.has(c) || (this._store.releaseDisplayIdForObjectId(c), this._items.delete(c), r2.push(u4));
    return await Promise.all(m5), this._index = null, new t3(o3, i5, r2);
  }
  updateLevel(e4) {
    if (this._resolution === e4) return false;
    this._index = null, this._boundsDirty = true, this._resolution = e4;
    for (const t4 of this.items()) if (t4.hasCurvedGeoemtry) return true;
    return false;
  }
  hitTest(e4, t4, i5, n7, m5) {
    const l5 = has("esri-mobile"), h = l5 ? U : V, f4 = h + (l5 ? 0 : W);
    e4 = S(e4, this._tileInfoView.spatialReference);
    const p3 = n7 * window.devicePixelRatio * f4, y9 = i();
    y9[0] = e4 - p3, y9[1] = t4 - p3, y9[2] = e4 + p3, y9[3] = t4 + p3;
    const b6 = n7 * window.devicePixelRatio * h, I = i();
    I[0] = e4 - b6, I[1] = t4 - b6, I[2] = e4 + b6, I[3] = t4 + b6;
    const g2 = 0.5 * n7 * (f4 + i3), w = this._searchIndex(e4 - g2, t4 - g2, e4 + g2, t4 + g2);
    if (!w || 0 === w.length) return [];
    const x = [], j2 = i(), S2 = i();
    for (const s5 of w) {
      if (!s5.visible) continue;
      const { geometryBounds: e5, symbolResource: t5 } = s5;
      this._getSymbolBounds(j2, t5, e5, S2, m5), S2[3] = S2[2] = S2[1] = S2[0] = 0, d(j2, y9) && x.push(s5);
    }
    if (0 === x.length) return [];
    const R = this._hittestDrawHelper, B = [];
    for (const s5 of x) {
      const { projectedGeometry: e5, symbolResource: t5 } = s5;
      if (!t5) continue;
      const { textInfo: o3, symbolInfo: i6 } = t5, r2 = i6.cimSymbol;
      R.hitTest(I, r2.symbol, e5, o3, m5, n7) && B.push(s5);
    }
    return B.sort(_), B.map((e5) => e5.objectId);
  }
  queryItems(e4) {
    return 0 === this._items.size ? [] : this._searchForItems(e4);
  }
  clear() {
    this._items.clear(), this._index = null;
  }
  async _updateItem(e4, t4) {
    await e4.projectAndNormalize(this._outSpatialReference), await t4(e4);
    const { size: s5 } = e4;
    s5[0] = s5[1] = s5[2] = s5[3] = 0, this._getSymbolBounds(e4.symbolBounds, e4.symbolResource, e4.geometryBounds, e4.size, 0);
  }
  _searchIndex(e4, s5, o3, i5) {
    return this._boundsDirty && (this._items.forEach((e5) => this._getSymbolBounds(e5.symbolBounds, e5.symbolResource, e5.geometryBounds, e5.size, 0)), this._boundsDirty = false), this._index || (this._index = i4(9, (e5) => ({ minX: e5.symbolBounds[0], minY: e5.symbolBounds[1], maxX: e5.symbolBounds[2], maxY: e5.symbolBounds[3] })), this._index.load(Array.from(this._items.values()))), this._index.search({ minX: e4, minY: s5, maxX: o3, maxY: i5 });
  }
  _searchForItems(e4) {
    const t4 = this._tileInfoView.spatialReference, o3 = e4.bounds, i5 = G(t4);
    if (i5 && t4.isWrappable) {
      const [t5, r2] = i5.valid, n7 = Math.abs(o3[2] - r2) < p2, m5 = Math.abs(o3[0] - t5) < p2;
      if ((!n7 || !m5) && (n7 || m5)) {
        const i6 = e4.resolution;
        let m6;
        m6 = i(n7 ? [t5, o3[1], t5 + i6 * i3, o3[3]] : [r2 - i6 * i3, o3[1], r2, o3[3]]);
        const l5 = this._searchIndex(o3[0], o3[1], o3[2], o3[3]), a5 = this._searchIndex(m6[0], m6[1], m6[2], m6[3]);
        return [.../* @__PURE__ */ new Set([...l5, ...a5])];
      }
    }
    return this._searchIndex(o3[0], o3[1], o3[2], o3[3]);
  }
  _getSymbolBounds(t4, o3, r2, n7, m5) {
    if (!o3 || !o3.symbolInfo.linearCIM) return null;
    if (t4 || (t4 = i()), a2(t4, r2), !n7 || 0 === n7[0] && 0 === n7[1] && 0 === n7[2] && 0 === n7[3]) {
      const { textInfo: t5, symbolInfo: s5 } = o3, i5 = s5.cimSymbol;
      n7 || (n7 = [0, 0, 0, 0]);
      const r3 = V2.getSymbolInflateSize(n7, i5.symbol, this._cimResourceManager, m5, t5);
      n7[0] = u(r3[0]), n7[1] = u(r3[1]), n7[2] = u(r3[2]), n7[3] = u(r3[3]);
    }
    const a5 = this._resolution, c = V2.safeSize(n7);
    return t4[0] -= c * a5, t4[1] -= c * a5, t4[2] += c * a5, t4[3] += c * a5, t4;
  }
};

// node_modules/@arcgis/core/views/2d/layers/graphics/GraphicsView2D.js
var F2 = class _F {
  static getOrCreate(e4, t4, s5) {
    let r2 = t4.get(e4.id);
    return r2 || (r2 = new _F(e4, s5), t4.set(e4.id, r2)), r2;
  }
  static fromItems(e4, t4, s5) {
    const r2 = new _F(e4, s5);
    for (const i5 of t4) r2.append(i5);
    return r2;
  }
  constructor(e4, t4) {
    this.tile = e4, this.metadata = t4, this.addedOrModified = [], this.removed = [], this.objectIdMap = null;
  }
  get reader() {
    return this._reader || (this._reader = a4.from(this.addedOrModified, this.tile, this.metadata)), this._reader;
  }
  append(e4) {
    this.addedOrModified.push(e4), e4.hasAnimations && (this.objectIdMap = this.objectIdMap || {}, this.objectIdMap[e4.displayId] = e4.objectId);
  }
};
var O3 = class extends s2(b) {
  constructor(e4) {
    super(e4), this._attached = false, this._tiles = /* @__PURE__ */ new Map(), this._controller = new AbortController(), this._hashToSymbolInfo = /* @__PURE__ */ new Map(), this._lastCleanup = performance.now(), this._cleanupRequired = true, this.lastUpdateId = -1, this.renderer = null, this._updateTracking = new n6({ debugName: "GraphicsView2D" }), this.updateRequested = false, this.defaultPointSymbolEnabled = true, this._commandQueue = new o2({ process: (e5) => {
      if ("update" === e5.type) return this._update();
      throw new Error("InternalError: Unsupported command");
    } }), this.graphicUpdateHandler = this.graphicUpdateHandler.bind(this);
  }
  destroy() {
    this.container.destroy(), this.view = null, this.renderer = null, this._set("graphics", null), this._controller.abort(), this._graphicStore.clear(), this._graphicStore.destroy(), this._attributeStore = null, this._hashToSymbolInfo.clear(), this._updateTracking.destroy(), this._commandQueue.destroy();
  }
  _initAttributeStore() {
    this._storage = new l4({ spatialReference: this.view.spatialReference, fields: new Z() }), this._attributeStore = new b2({ isLocal: true, update: (e5) => {
      has("esri-2d-update-debug") && console.debug(`[Id: ${this.layerId}] GraphicsView2D.AttributeStoreView.updateStart`, { message: e5 }), this.container.attributeView.requestUpdate(e5), this.container.requestRender(), has("esri-2d-update-debug") && console.debug(`[Id: ${this.layerId}] GraphicsView2D.AttributeStoreView.updateEnd`, { message: e5 });
    } });
    const e4 = t2(null, []);
    this._attributeStore.update(e4, this._storage, null), this.container.checkHighlight = () => this._attributeStore.hasHighlight;
  }
  initialize() {
    this._initAttributeStore(), this._metadata = n5.createGraphics(this.view.spatialReference), this._resourceProxy = new s4({ fetch: (e5) => Promise.all(e5.map((e6) => this.view.stage.textureManager.rasterizeItem(e6))), fetchDictionary: (e5) => {
      throw new Error("InternalError: Graphics do not support Dictionary requests");
    } }), this.addHandles([l(() => this._effectiveRenderer, () => this._pushUpdate()), this.view.graphicsTileStore.on("update", this._onTileUpdate.bind(this)), this.container.on("attach", () => {
      this.addHandles([this.graphics.on("change", () => this._pushUpdate())]), this._graphicStore?.destroy(), this._graphicStore = new y8(this.view.spatialReference, this._cimResourceManager, this.view.featuresTilingScheme, this.view.state.scale, this._attributeStore), this._attached = true, this.requestUpdate(), this._pushUpdate();
    })]), this._updateTracking.addUpdateTracking("CommandQueue", this._commandQueue.updateTracking);
    const e4 = this.view.graphicsTileStore.tiles;
    this._onTileUpdate({ added: e4, removed: [] });
  }
  get _effectiveRenderer() {
    return "function" == typeof this.renderer ? this.renderer() : this.renderer;
  }
  get _cimResourceManager() {
    return this.view.stage.textureManager.resourceManager;
  }
  get updating() {
    const e4 = !this._attached || this._updateTracking.updating;
    return has("esri-2d-log-updating") && console.log(`Updating GraphicsView2D: ${e4}
  -> attaching ${!this._attached}
  -> updateTracking ${this._updateTracking.updating}`), e4;
  }
  hitTest(e4) {
    if (!this.view || this.view.suspended) return [];
    const { resolution: t4, rotation: r2 } = this.view.state, i5 = this._graphicStore.hitTest(e4.x, e4.y, 2, t4, r2), o3 = new Set(i5), a5 = this.graphics.items.reduce((e5, t5) => (o3.has(t5.uid) && e5.set(t5.uid, t5), e5), /* @__PURE__ */ new Map());
    return i5.map((e5) => a5.get(e5)).filter(N);
  }
  requestUpdate() {
    this.updateRequested || (this.updateRequested = true, this.requestUpdateCallback()), this.notifyChange("updating");
  }
  processUpdate(e4) {
    this.updateRequested && (this.updateRequested = false, this.update(e4));
  }
  viewChange() {
    this.requestUpdate();
  }
  setHighlight(e4) {
    const t4 = [];
    for (const { objectId: s5, highlightFlags: r2 } of e4) {
      const e5 = this._graphicStore.getItem(s5)?.displayId;
      t4.push({ objectId: s5, highlightFlags: r2, displayId: e5 });
    }
    this._attributeStore.setHighlight(t4, e4), this._pushUpdate();
  }
  graphicUpdateHandler(e4) {
    this._pushUpdate();
  }
  update(e4) {
    this.updateRequested = false, this._attached && this._graphicStore.updateLevel(e4.state.resolution) && this.pushUpdate();
  }
  pushUpdate() {
    this._pushUpdate();
  }
  _pushUpdate() {
    y(this._commandQueue.push({ type: "update" }));
  }
  async _update() {
    try {
      if (has("esri-2d-update-debug") && console.debug(`[Id: ${this.layerId}] GraphicsView._update start`), this.graphics.destroyed) return;
      const e4 = await this._graphicStore.update(this.graphics, (e5) => this._getSymbolForGraphic(e5), (e5) => this._ensureSymbolResource(e5));
      for (const s5 of e4.updated) this.container.restartAnimation(s5.objectId);
      if (!e4.hasAnyUpdate()) return void this._attributeStore.sendUpdates();
      e4.removed.length && (this._cleanupRequired = true), has("esri-2d-update-debug") && console.debug(`[Id: ${this.layerId}] GraphicsView updateMessage`, e4);
      const t4 = this._createTileMessages(e4);
      await this._densifyItemsForDisplay(t4), await this._fetchResources(t4), this._write(t4);
      for (const s5 of e4.added) this._setFilterState(s5);
      for (const s5 of e4.updated) this._setFilterState(s5);
      has("esri-2d-update-debug") && console.debug(`[Id: ${this.layerId}] GraphicsView sendUpdate`, e4), this._attributeStore.sendUpdates(), has("esri-2d-update-debug") && console.debug(`[Id: ${this.layerId}] GraphicsView sendUpdate.await`, e4);
    } catch (e4) {
    }
    this._cleanupSharedResources();
  }
  _createTileMessages(e4) {
    const t4 = /* @__PURE__ */ new Map();
    for (const s5 of e4.added) {
      const e5 = this.view.graphicsTileStore.getIntersectingTiles(s5.symbolBounds);
      for (const r2 of e5) {
        F2.getOrCreate(r2, t4, this._metadata).append(s5);
      }
    }
    for (const s5 of e4.updated) {
      const e5 = this.view.graphicsTileStore.getIntersectingTiles(s5.prevSymbolBounds), r2 = this.view.graphicsTileStore.getIntersectingTiles(s5.symbolBounds);
      for (const i5 of e5) {
        F2.getOrCreate(i5, t4, this._metadata).removed.push(s5.displayId);
      }
      for (const i5 of r2) {
        F2.getOrCreate(i5, t4, this._metadata).append(s5);
      }
    }
    for (const s5 of e4.removed) {
      const e5 = this.view.graphicsTileStore.getIntersectingTiles(s5.symbolBounds);
      for (const r2 of e5) {
        F2.getOrCreate(r2, t4, this._metadata).removed.push(s5.displayId);
      }
    }
    return Array.from(t4.values());
  }
  async _densifyItemsForDisplay(e4) {
    const t4 = /* @__PURE__ */ new Map();
    for (const s5 of e4) for (const e5 of s5.addedOrModified) t4.has(e5) || t4.set(e5, e5.densifyCurvedGeometryForDisplay(this.view.spatialReference));
    await Promise.all(t4.values());
  }
  async _fetchResources(e4) {
    const t4 = { timeZone: null, timeExtent: null };
    for (const { tile: s5, reader: r2 } of e4) {
      has("esri-2d-update-debug") && console.debug(`Id[${this.layerId}] Tile[${s5.id}] GraphicsView fetchResources`, e4);
      const i5 = r2.getCursor();
      for (; i5.next(); ) for (const e5 of i5.getMeshWriters()) e5.enqueueRequest(this._resourceProxy, i5, s5.createArcadeEvaluationOptions(t4));
    }
    await this._resourceProxy.fetchEnqueuedResources();
  }
  _write(e4) {
    for (const t4 of e4) {
      has("esri-2d-update-debug") && console.debug(`Id[${this.layerId}] Tile[${t4.tile.id}] GraphicsView write`, t4);
      const e5 = this._writeMeshes(t4);
      let s5 = this._tiles.get(t4.tile.key);
      s5 || (s5 = this._createFeatureTile(t4.tile.key)), has("esri-2d-update-debug") && console.debug(`Id[${this.layerId}] Tile[${t4.tile.id}] GraphicsView onTileData`, t4), this.container.onTileData(s5, { type: "update", modify: e5, remove: t4.removed, end: false, attributeEpoch: this._attributeStore.epoch, objectIdMap: t4.objectIdMap }), this.container.requestRender();
    }
  }
  _writeMeshes(e4) {
    const t4 = { timeZone: null, timeExtent: null }, s5 = new n4(e4.tile.id), r2 = e4.reader.getCursor();
    for (; r2.next(); ) {
      s5.entityStart(r2.getDisplayId(), r2.getZOrder());
      for (const i5 of r2.getMeshWriters()) i5.write(s5, this._resourceProxy, r2, e4.tile.createArcadeEvaluationOptions(t4), e4.tile.level);
      s5.entityEnd();
    }
    return { ...s5.serialize().message, tileId: e4.tile.id };
  }
  _setFilterState(e4) {
    const t4 = e4.displayId, s5 = this._attributeStore.getHighlightFlags(e4.objectId);
    this._attributeStore.setData(t4, 0, 0, s5 | (e4.visible ? Q : 0));
  }
  _getSymbolForGraphic(e4) {
    return null != e4.symbol ? e4.symbol : null != this._effectiveRenderer ? this._effectiveRenderer.getSymbol(e4) : this._getNullSymbol(e4);
  }
  async _ensureSymbolResource(e4) {
    if (!e4.symbol) return;
    const t4 = await this._getSymbolInfo(e4.symbol);
    if (!t4) return;
    const s5 = t4.linearCIM.filter((e5) => "text" === e5.type);
    if (s5.length > 0) {
      const r2 = await this._getTextResources(e4, s5);
      return void (e4.symbolResource = { symbolInfo: t4, textInfo: r2 });
    }
    e4.symbolResource = { symbolInfo: t4 };
  }
  _getSymbolInfo(e4) {
    const t4 = e4.hash();
    return this._hashToSymbolInfo.has(t4) || this._hashToSymbolInfo.set(t4, this._createSymbolInfo(t4, e4).catch((e5) => null)), this._hashToSymbolInfo.get(t4);
  }
  async _createSymbolInfo(e4, t4) {
    const s5 = await this._convertToCIMSymbol(t4), r2 = await this._createLinearCIM(s5);
    return { hash: e4, cimSymbol: s5, linearCIM: r2, meshWriters: await this._createMeshWriters(s5, r2) };
  }
  async _convertToCIMSymbol(e4) {
    const t4 = A(e4);
    return "web-style" === t4.type ? this._convertToCIMSymbol(await t4.fetchSymbol({ acceptedFormats: ["cim", "web"] })) : t4;
  }
  async _createLinearCIM(e4) {
    return await Promise.all(Y.fetchResources(e4.symbol, this._cimResourceManager, [])), this.view.stage.cimAnalyzer.analyzeSymbolReference(e4, false);
  }
  async _createMeshWriters(e4, t4) {
    s(this._controller.signal);
    const s5 = this.container.instanceStore, r2 = this.view.stage.meshWriterRegistry, i5 = await u3(e4, t4, s5);
    return Promise.all(i5.map((e5) => r2.createMeshWriter(this._storage, this._resourceProxy, { tileInfo: this.view.featuresTilingScheme.tileInfo }, e5, null)));
  }
  _onTileUpdate(e4) {
    if (e4.added && e4.added.length > 0) for (const t4 of e4.added) this._updateTracking.addPromise(this._addTile(t4));
    if (e4.removed && e4.removed.length > 0) for (const t4 of e4.removed) this._removeTile(t4.key);
  }
  _createFeatureTile(e4) {
    const t4 = this.view.featuresTilingScheme.getTileBounds(i(), e4), s5 = this.view.featuresTilingScheme.getTileResolution(e4.level), r2 = new b3(e4, s5, t4[0], t4[3]);
    return this._tiles.set(e4, r2), this.container.addChild(r2), r2;
  }
  async _addTile(e4) {
    if (!this._attached) return;
    const t4 = this._graphicStore.queryItems(e4);
    if (!t4.length) return;
    const s5 = this._createFeatureTile(e4.key), r2 = F2.fromItems(e4, t4, this._metadata);
    await this._densifyItemsForDisplay([r2]), await this._fetchResources([r2]);
    const i5 = this._writeMeshes(r2);
    s5.onMessage({ type: "append", append: i5, clear: false, end: true, attributeEpoch: this._attributeStore.epoch, objectIdMap: r2.objectIdMap });
  }
  _removeTile(e4) {
    if (!this._tiles.has(e4)) return;
    const t4 = this._tiles.get(e4);
    this.container.removeChild(t4), t4.destroy(), this._tiles.delete(e4);
  }
  _getNullSymbol(e4) {
    const t4 = e4.geometry;
    return t4 ? s3(t4) ? O : y4(t4) || m2(t4) ? y5 : this.defaultPointSymbolEnabled ? N2 : null : this.defaultPointSymbolEnabled ? N2 : null;
  }
  async _getTextResources(e4, t4) {
    const s5 = new Array(), r2 = new Array();
    for (let i5 = 0; i5 < t4.length; i5++) {
      const o4 = t4[i5], { resource: a6, overrides: n8 } = o4.textRasterizationParam;
      if (n8?.length > 0) {
        const t5 = v2.resolveSymbolOverrides({ type: "CIMSymbolReference", primitiveOverrides: n8, symbol: { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMVectorMarker", enable: true, size: a6.symbol.height, anchorPointUnits: "Relative", frame: { xmin: -5, ymin: -5, xmax: 5, ymax: 5 }, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: { x: 0, y: 0 }, symbol: a6.symbol, textString: a6.textString }], scaleSymbolsProportionally: true, respectFrame: true }] } }, e4, this.view.spatialReference, null, v(e4.projectedGeometry), null, null);
        t5.then((e5) => {
          const t6 = e5.symbolLayers[0], { textString: s6 } = t6.markerGraphics[0];
          r2.push({ type: "cim-rasterization-info", resource: { type: "text", textString: s6 || "", font: a6.font } }), o4.text = a6.textString = s6 || "";
        }), s5.push(t5);
      } else r2.push({ type: "cim-rasterization-info", resource: a6 });
    }
    s5.length > 0 && await Promise.all(s5);
    const o3 = r2.map((e5) => this.view.stage.textureManager.rasterizeItem(e5)), a5 = await Promise.all(o3);
    n(a5);
    const n7 = /* @__PURE__ */ new Map();
    for (let i5 = 0; i5 < t4.length; i5++) {
      const e5 = t4[i5];
      n7.set(e5.textRasterizationParam.resource.symbol, { text: e5.text, glyphMosaicItems: a5[i5] });
    }
    return n7;
  }
  _cleanupSharedResources() {
    if (!this._cleanupRequired) return;
    const e4 = performance.now();
    if (e4 - this._lastCleanup < 5e3) return;
    this._cleanupRequired = false, this._lastCleanup = e4;
    const t4 = /* @__PURE__ */ new Set();
    for (const r2 of this._graphicStore.items()) {
      const e5 = r2.symbolResource?.symbolInfo.hash;
      t4.add(e5);
    }
    const s5 = new Set(this._hashToSymbolInfo.keys());
    for (const r2 of s5.values()) t4.has(r2) || this._hashToSymbolInfo.delete(r2);
  }
};
__decorate([m()], O3.prototype, "_effectiveRenderer", null), __decorate([m({ constructOnly: true })], O3.prototype, "layerId", void 0), __decorate([m({ constructOnly: true })], O3.prototype, "requestUpdateCallback", void 0), __decorate([m()], O3.prototype, "container", void 0), __decorate([m({ constructOnly: true })], O3.prototype, "graphics", void 0), __decorate([m()], O3.prototype, "renderer", void 0), __decorate([m()], O3.prototype, "_updateTracking", void 0), __decorate([m()], O3.prototype, "updating", null), __decorate([m()], O3.prototype, "view", void 0), __decorate([m()], O3.prototype, "updateRequested", void 0), __decorate([m()], O3.prototype, "defaultPointSymbolEnabled", void 0), O3 = __decorate([a("esri.views.2d.layers.graphics.GraphicsView2D")], O3);

export {
  O3 as O
};
//# sourceMappingURL=chunk-UQ4NKDVH.js.map
