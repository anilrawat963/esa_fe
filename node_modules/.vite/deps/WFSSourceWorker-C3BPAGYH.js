import {
  K,
  ee,
  oe
} from "./chunk-6CCH2DQQ.js";
import "./chunk-Y2QJFDQ5.js";
import {
  E,
  N
} from "./chunk-2W3LGFFY.js";
import {
  d as d3
} from "./chunk-5BM4D5UD.js";
import "./chunk-W2EKXSEY.js";
import {
  f
} from "./chunk-5DFXT3PU.js";
import "./chunk-CKE7BUXC.js";
import "./chunk-B5SL7XHP.js";
import {
  W
} from "./chunk-3VXANCFN.js";
import "./chunk-MBQEPUQX.js";
import "./chunk-ODQ5APZK.js";
import "./chunk-G5IXTUNN.js";
import "./chunk-ZNQKJRCD.js";
import {
  f as f2,
  g
} from "./chunk-BA6HYZ35.js";
import "./chunk-GCTH5LET.js";
import "./chunk-Q7VRQYAO.js";
import "./chunk-SJB744AD.js";
import "./chunk-WM2VG5F2.js";
import "./chunk-IXFJYDA2.js";
import "./chunk-TTLSEJNG.js";
import "./chunk-U73R3I4U.js";
import "./chunk-VGXUPJSS.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import "./chunk-DLM5SBNY.js";
import "./chunk-EKZRA6TO.js";
import "./chunk-M5SP6ZBM.js";
import "./chunk-FAA2FDN5.js";
import {
  Z
} from "./chunk-2HGIYEIL.js";
import {
  lt,
  ut
} from "./chunk-XX3OKYJS.js";
import "./chunk-OTCNIJ2H.js";
import "./chunk-JGA5YJWL.js";
import "./chunk-GCI4MA3M.js";
import "./chunk-SJ2OBYX2.js";
import "./chunk-MDJNYPVI.js";
import "./chunk-Z6VKIQV2.js";
import "./chunk-4PXNA4MD.js";
import "./chunk-XDLV73DB.js";
import "./chunk-ARTU4L55.js";
import "./chunk-6VL5D5UP.js";
import "./chunk-6QHY54HZ.js";
import "./chunk-GXJJY3ND.js";
import "./chunk-5ONGWFJ3.js";
import "./chunk-PLNHHGHL.js";
import "./chunk-DFK6QMLO.js";
import "./chunk-EM7Y2JZC.js";
import "./chunk-QZQPB5XR.js";
import "./chunk-AQFRVV3U.js";
import "./chunk-PMGS7UDU.js";
import "./chunk-3GHCGAH2.js";
import "./chunk-HWUOAPTX.js";
import "./chunk-QHCKOBU7.js";
import "./chunk-K2OZ6WVC.js";
import "./chunk-MC6NAKKX.js";
import "./chunk-TF6255HN.js";
import "./chunk-GD4FJL3C.js";
import {
  n as n2
} from "./chunk-C5OQVQZF.js";
import {
  d as d2
} from "./chunk-XL5QPCXN.js";
import "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-C5M24ACM.js";
import "./chunk-L4A2QJG4.js";
import "./chunk-ENINOZUZ.js";
import "./chunk-V2X4OKYI.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import "./chunk-T7F6Q6JJ.js";
import "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-3FUHCAX3.js";
import "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import "./chunk-2OFHDVO5.js";
import "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import {
  n
} from "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import "./chunk-7H3U4IJR.js";
import {
  r
} from "./chunk-SMWUT52Z.js";
import "./chunk-AXZMNHTN.js";
import "./chunk-5T3MJDSR.js";
import {
  T
} from "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import "./chunk-5EI5H4QX.js";
import {
  s2
} from "./chunk-ZIE53VIV.js";
import "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import {
  d,
  s as s3
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/layers/graphics/sources/WFSSourceWorker.js
var F = "esri.layers.WFSLayer";
var S = class {
  constructor() {
    this._customParameters = null, this._queryEngine = null, this._supportsPagination = true;
  }
  destroy() {
    this._queryEngine?.destroy(), this._queryEngine = null;
  }
  async load(e, r2 = {}) {
    const { getFeatureUrl: a, getFeatureOutputFormat: o, fields: n3, geometryType: i2, featureType: u, maxRecordCount: l, maxTotalRecordCount: m, maxPageCount: d4, objectIdField: g2, customParameters: f3 } = e, { spatialReference: _, getFeatureSpatialReference: x } = oe(a, u, e.spatialReference);
    try {
      await f2(x, _);
    } catch {
      throw new s("unsupported-projection", "Projection not supported", { inSpatialReference: x, outSpatialReference: _ });
    }
    s3(r2), this._customParameters = f3, this._featureType = u, this._fieldsIndex = Z.fromLayerJSON({ fields: n3, dateFieldsTimeReference: n3.some((e2) => "esriFieldTypeDate" === e2.type) ? { timeZoneIANA: n } : null }), this._geometryType = i2, this._getFeatureUrl = a, this._getFeatureOutputFormat = o, this._getFeatureSpatialReference = x, this._maxRecordCount = l, this._maxTotalRecordCount = m, this._maxPageCount = d4, this._objectIdField = g2, this._spatialReference = _;
    let w = await this._snapshotFeatures(r2);
    if (w.errors.length > 0 && (this._supportsPagination = false, w = await this._snapshotFeatures(r2), w.errors.length > 0)) throw w.errors[0];
    const F2 = { type: "object-id", fieldName: g2 };
    return this._queryEngine = new W({ fieldsIndex: this._fieldsIndex, geometryType: i2, hasM: false, hasZ: false, featureIdInfo: F2, spatialReference: _, timeInfo: null, featureStore: new f({ geometryType: i2, hasM: false, hasZ: false }) }), this._queryEngine.featureStore.addMany(w.features), { warnings: E2(w), extent: (await this._queryEngine.fetchRecomputedExtents()).fullExtent };
  }
  async applyEdits() {
    throw new s("wfs-source:editing-not-supported", "applyEdits() is not supported on WFSLayer");
  }
  async queryFeatures(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQuery(e, t.signal);
  }
  async queryFeatureCount(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForCount(e, t.signal);
  }
  async queryObjectIds(e = {}, t = {}) {
    await this._waitSnapshotComplete();
    return (await this._queryEngine.executeQueryForIds(e, t.signal)).filter(n2);
  }
  async queryExtent(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForExtent(e, t.signal);
  }
  async querySnapping(e, t = {}) {
    return await this._waitSnapshotComplete(), await this._queryEngine.executeQueryForSnapping(e, t.signal);
  }
  async queryAttributeBins(e, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeAttributeBinsQuery(e, t.signal);
  }
  async refresh(t) {
    return this._customParameters = t.customParameters, this._maxRecordCount = t.maxRecordCount, this._maxTotalRecordCount = t.maxTotalRecordCount, this._maxPageCount = t.maxPageCount, this._snapshotTask?.abort(), this._snapshotTask = d2((e) => this._snapshotFeatures({ signal: e })), this._snapshotTask.promise.then((e) => {
      this._queryEngine.featureStore.clear(), this._queryEngine.featureStore.addMany(e.features);
      for (const t2 of E2(e)) i.getLogger(F).warn(new s2("wfs-layer:refresh-warning", t2.message, t2.details));
      e.errors?.length && i.getLogger(F).warn(new s2("wfs-layer:refresh-error", "Refresh completed with errors", { errors: e.errors }));
    }, () => {
      this._queryEngine.featureStore.clear();
    }), await this._waitSnapshotComplete(), { extent: (await this._queryEngine.fetchRecomputedExtents()).fullExtent };
  }
  async _waitSnapshotComplete() {
    if (this._snapshotTask && !this._snapshotTask.finished) {
      try {
        await this._snapshotTask.promise;
      } catch {
      }
      return this._waitSnapshotComplete();
    }
  }
  async _snapshotFeatures(e) {
    const t = e?.signal, r2 = this._maxTotalRecordCount, n3 = this._maxPageCount, i2 = this._supportsPagination && n3 > 1 ? await ee(this._getFeatureUrl, this._featureType.typeName, { customParameters: this._customParameters, signal: t }) : void 0;
    let u = [];
    const l = [];
    if (null == i2) try {
      u = await this._singleQuery(t);
    } catch (c) {
      d(c) || l.push(c);
    }
    else {
      const e2 = Math.min(i2, r2), s4 = T2(this, r(Math.ceil(e2 / this._maxRecordCount), 1, n3), t);
      await Promise.allSettled(Array.from({ length: 10 }).map(() => j(s4, u, l)));
    }
    return s3(t), { features: u, totalRecordCount: i2, maxTotalRecordCount: r2, maxPageCount: n3, errors: l };
  }
  async _singleQuery(e) {
    const t = Number.isFinite(this._maxRecordCount) && this._maxRecordCount > 0 ? this._maxRecordCount : void 0, r2 = await K(this._getFeatureUrl, this._featureType.typeName, this._getFeatureSpatialReference, this._getFeatureOutputFormat, { customParameters: this._customParameters, count: t, signal: e });
    return this._processGeoJSON(r2, { signal: e });
  }
  async _pageQuery(e, t) {
    const r2 = e * this._maxRecordCount, a = await K(this._getFeatureUrl, this._featureType.typeName, this._getFeatureSpatialReference, this._getFeatureOutputFormat, { customParameters: this._customParameters, startIndex: r2, count: this._maxRecordCount, signal: t });
    return this._processGeoJSON(a, { startIndex: r2, signal: t });
  }
  _processGeoJSON(e, t) {
    E(e, this._getFeatureSpatialReference.wkid);
    const { startIndex: r2, signal: a } = t;
    s3(a);
    const o = N(e, { geometryType: this._geometryType, hasZ: false, objectIdField: this._objectIdField });
    if (!T(this._spatialReference, this._getFeatureSpatialReference)) for (const s4 of o) null != s4.geometry && (s4.geometry = ut(g(lt(s4.geometry, this._geometryType, false, false), this._getFeatureSpatialReference, this._spatialReference)));
    let n3 = r2 ?? 1;
    for (const s4 of o) {
      const e2 = {};
      d3(this._fieldsIndex, e2, s4.attributes, true), s4.attributes = e2, null == e2[this._objectIdField] && (s4.objectId = e2[this._objectIdField] = n3++);
    }
    return o;
  }
};
function* T2(e, t, r2) {
  for (let a = 0; a < t; a++) yield e._pageQuery(a, r2);
}
async function j(e, t, r2) {
  let a = e.next();
  for (; !a.done; ) {
    try {
      const e2 = await a.value;
      t.push(...e2);
    } catch (s4) {
      d(s4) || r2.push(s4);
    }
    a = e.next();
  }
}
function E2(e) {
  const t = [];
  return null != e.totalRecordCount && (e.features.length < e.totalRecordCount && t.push({ name: "wfs-layer:maxRecordCount-too-low", message: `Could only fetch ${e.features.length} of ${e.totalRecordCount} in ${e.maxPageCount} queries. Try increasing the value of WFSLayer.maxRecordCount.`, details: { recordCount: e.features.length, totalRecordCount: e.totalRecordCount } }), e.totalRecordCount > e.maxTotalRecordCount && t.push({ name: "wfs-layer:large-dataset", message: `The number of ${e.totalRecordCount} features exceeds the maximum allowed of ${e.maxTotalRecordCount}.`, details: { recordCount: e.features.length, totalRecordCount: e.totalRecordCount, maxTotalRecordCount: e.maxTotalRecordCount } })), t;
}
export {
  S as default
};
//# sourceMappingURL=WFSSourceWorker-C3BPAGYH.js.map
