import {
  e as e10,
  n as n9
} from "./chunk-ALLCMCHO.js";
import {
  e as e8,
  e2 as e9
} from "./chunk-RZOWZMPW.js";
import {
  h as h5
} from "./chunk-7LPDSYJP.js";
import {
  r as r5
} from "./chunk-QTS3W27E.js";
import {
  o as o5
} from "./chunk-3RABUJDL.js";
import {
  e as e6
} from "./chunk-U3B7YMY7.js";
import {
  n as n8
} from "./chunk-F75XORHS.js";
import {
  $ as $2,
  a,
  e as e3,
  h as h2,
  h2 as h3,
  n as n5,
  s as s3,
  s2 as s4,
  t2
} from "./chunk-JPZOLUPV.js";
import {
  e as e5
} from "./chunk-M5JMVUW2.js";
import {
  n as n4
} from "./chunk-ALR6N4CF.js";
import {
  t
} from "./chunk-4X4BOGIG.js";
import {
  X,
  tt
} from "./chunk-XX3OKYJS.js";
import {
  e
} from "./chunk-GCI4MA3M.js";
import {
  n as n2
} from "./chunk-SJ2OBYX2.js";
import {
  n as n10
} from "./chunk-IXRRTVLJ.js";
import {
  a as a2,
  e as e7
} from "./chunk-WKTI47FV.js";
import {
  A,
  h as h4
} from "./chunk-U55FA2EK.js";
import {
  n as n6
} from "./chunk-B5A4L35M.js";
import {
  e as e4,
  r as r3
} from "./chunk-52SEOH5H.js";
import {
  e as e2
} from "./chunk-JUZ3H47H.js";
import {
  n as n7,
  r as r4
} from "./chunk-UYMV6HXW.js";
import {
  $,
  Ct,
  Dt,
  Et,
  Ft,
  Y,
  Z,
  o as o4
} from "./chunk-JE2NJSBU.js";
import {
  R,
  _
} from "./chunk-QNVJVDYZ.js";
import {
  n as n3
} from "./chunk-WDTGOP77.js";
import {
  N,
  o as o3
} from "./chunk-VYMBX5H5.js";
import {
  M,
  f,
  h,
  i as i3,
  o as o2,
  r as r2,
  s as s2
} from "./chunk-LTPHDYPK.js";
import {
  o
} from "./chunk-AZXJIEZ6.js";
import {
  l
} from "./chunk-2OFHDVO5.js";
import {
  i as i2
} from "./chunk-SMWUT52Z.js";
import {
  n,
  r2 as r,
  u2 as u
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  c,
  d2 as d,
  has
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/core/libs/gl-matrix-2/factories/vec4f32.js
function n11() {
  return new Float32Array(4);
}
function t3(n17) {
  const t10 = new Float32Array(4);
  return t10[0] = n17[0], t10[1] = n17[1], t10[2] = n17[2], t10[3] = n17[3], t10;
}
function r6(n17, t10, r14, e16) {
  const o9 = new Float32Array(4);
  return o9[0] = n17, o9[1] = t10, o9[2] = r14, o9[3] = e16, o9;
}
function e11() {
  return n11();
}
function o6() {
  return r6(1, 1, 1, 1);
}
function u2() {
  return r6(1, 0, 0, 0);
}
function c2() {
  return r6(0, 1, 0, 0);
}
function i4() {
  return r6(0, 0, 1, 0);
}
function f2() {
  return r6(0, 0, 0, 1);
}
var a3 = e11();
var l2 = o6();
var _2 = u2();
var s5 = c2();
var y = i4();
var N2 = f2();
var T = Object.freeze(Object.defineProperty({ __proto__: null, ONES: l2, UNIT_W: N2, UNIT_X: _2, UNIT_Y: s5, UNIT_Z: y, ZEROS: a3, clone: t3, create: n11, fromValues: r6, ones: o6, unitW: f2, unitX: u2, unitY: c2, unitZ: i4, zeros: e11 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/sources/shaderRepository.js
var e12 = { background: { "background.frag": "uniform lowp vec4 u_color;\nvoid main() {\ngl_FragColor = u_color;\n}", "background.vert": "attribute vec2 a_pos;\nuniform highp mat3 u_dvsMat3;\nuniform mediump vec2 u_coord_range;\nuniform mediump float u_depth;\nvoid main() {\nvec3 v_pos = u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0);\ngl_Position = vec4(v_pos.xy, 0.0, 1.0);\n}" }, bitBlit: { "bitBlit.frag": "uniform lowp sampler2D u_tex;\nuniform lowp float u_opacity;\nvarying mediump vec2 v_uv;\nvoid main() {\nlowp vec4 color = texture2D(u_tex, v_uv);\ngl_FragColor = color * u_opacity;\n}", "bitBlit.vert": "attribute vec2 a_pos;\nattribute vec2 a_tex;\nvarying mediump vec2 v_uv;\nvoid main(void) {\ngl_Position = vec4(a_pos , 0.0, 1.0);\nv_uv = a_tex;\n}" }, debug: { overlay: { "overlay.frag": "precision mediump float;\nvarying vec4 v_color;\nvoid main(void) {\ngl_FragColor = v_color;\n}", "overlay.vert": "attribute vec3 a_PositionAndFlags;\nuniform mat3 u_dvsMat3;\nuniform vec4 u_colors[4];\nuniform float u_opacities[4];\nvarying vec4 v_color;\nvoid main(void) {\nvec2 position = a_PositionAndFlags.xy;\nfloat flags = a_PositionAndFlags.z;\nint colorIndex = int(mod(flags, 4.0));\nvec4 color;\nfor (int i = 0; i < 4; i++) {\ncolor = u_colors[i];\nif (i == colorIndex) {\nbreak;\n}\n}\nint opacityIndex = int(mod(floor(flags / 4.0), 4.0));\nfloat opacity;\nfor (int i = 0; i < 4; i++) {\nopacity = u_opacities[i];\nif (i == opacityIndex) {\nbreak;\n}\n}\nv_color = color * opacity;\ngl_Position = vec4((u_dvsMat3 * vec3(position, 1.0)).xy, 0.0, 1.0);\n}" } }, dot: { dot: { "dot.frag": "precision mediump float;\nvarying vec4 v_color;\nvarying float v_dotRatio;\nvarying float v_invEdgeRatio;\nuniform highp float u_tileZoomFactor;\nvoid main()\n{\nfloat dist = length(gl_PointCoord - vec2(.5, .5)) * 2.;\nfloat alpha = smoothstep(0., 1., v_invEdgeRatio * (dist - v_dotRatio) + 1.);\ngl_FragColor = v_color * alpha;\n}", "dot.vert": "precision highp float;\nattribute vec2 a_pos;\nuniform sampler2D u_texture;\nuniform highp mat3 u_dvsMat3;\nuniform highp float u_tileZoomFactor;\nuniform highp float u_dotSize;\nuniform highp float u_pixelRatio;\nvarying vec2 v_pos;\nvarying vec4 v_color;\nvarying float v_dotRatio;\nvarying float v_invEdgeRatio;\nconst float EPSILON = 0.000001;\nvoid main()\n{\nmat3 tileToTileTexture = mat3(  1., 0., 0.,\n0., -1., 0.,\n0., 1., 1.  );\nvec3 texCoords = tileToTileTexture * vec3(a_pos.xy / 512., 1.);\nv_color = texture2D(u_texture, texCoords.xy);\nfloat smoothEdgeWidth = max(u_dotSize / 2., 1.) ;\nfloat z = 0.;\nz += 2.0 * step(v_color.a, EPSILON);\ngl_PointSize = (smoothEdgeWidth + u_dotSize);\ngl_Position = vec4((u_dvsMat3 * vec3(a_pos + .5, 1.)).xy, z, 1.);\nv_dotRatio = u_dotSize / gl_PointSize;\nv_invEdgeRatio = -1. / ( smoothEdgeWidth / gl_PointSize );\ngl_PointSize  *= (u_pixelRatio * u_tileZoomFactor);\n}" } }, filtering: { "bicubic.glsl": "vec4 computeWeights(float v) {\nfloat b = 1.0 / 6.0;\nfloat v2 = v * v;\nfloat v3 = v2 * v;\nfloat w0 = b * (-v3 + 3.0 * v2 - 3.0 * v + 1.0);\nfloat w1 = b * (3.0 * v3  - 6.0 * v2 + 4.0);\nfloat w2 = b * (-3.0 * v3 + 3.0 * v2 + 3.0 * v + 1.0);\nfloat w3 = b * v3;\nreturn vec4(w0, w1, w2, w3);\n}\nvec4 bicubicOffsetsAndWeights(float v) {\nvec4 w = computeWeights(v);\nfloat g0 = w.x + w.y;\nfloat g1 = w.z + w.w;\nfloat h0 = 1.0 - (w.y / g0) + v;\nfloat h1 = 1.0 + (w.w / g1) - v;\nreturn vec4(h0, h1, g0, g1);\n}\nvec4 sampleBicubicBSpline(sampler2D sampler, vec2 coords, vec2 texSize) {\nvec2 eX = vec2(1.0 / texSize.x, 0.0);\nvec2 eY = vec2(0.0, 1.0 / texSize.y);\nvec2 texel = coords * texSize - 0.5;\nvec3 hgX = bicubicOffsetsAndWeights(fract(texel).x).xyz;\nvec3 hgY = bicubicOffsetsAndWeights(fract(texel).y).xyz;\nvec2 coords10 = coords + hgX.x * eX;\nvec2 coords00 = coords - hgX.y * eX;\nvec2 coords11 = coords10 + hgY.x * eY;\nvec2 coords01 = coords00 + hgY.x * eY;\ncoords10 = coords10 - hgY.y * eY;\ncoords00 = coords00 - hgY.y * eY;\nvec4 color00 = texture2D(sampler, coords00);\nvec4 color10 = texture2D(sampler, coords10);\nvec4 color01 = texture2D(sampler, coords01);\nvec4 color11 = texture2D(sampler, coords11);\ncolor00 = mix(color00, color01, hgY.z);\ncolor10 = mix(color10, color11, hgY.z);\ncolor00 = mix(color00, color10, hgX.z);\nreturn color00;\n}", "bilinear.glsl": "vec4 sampleBilinear(sampler2D sampler, vec2 coords, vec2 texSize) {\nvec2 texelStart = floor(coords * texSize);\nvec2 coord0 = texelStart / texSize;\nvec2 coord1 = (texelStart +  vec2(1.0, 0.0)) / texSize;\nvec2 coord2 = (texelStart +  vec2(0.0, 1.0)) / texSize;\nvec2 coord3 = (texelStart +  vec2(1.0, 1.0)) / texSize;\nvec4 color0 = texture2D(sampler, coord0);\nvec4 color1 = texture2D(sampler, coord1);\nvec4 color2 = texture2D(sampler, coord2);\nvec4 color3 = texture2D(sampler, coord3);\nvec2 blend = fract(coords * texSize);\nvec4 color01 = mix(color0, color1, blend.x);\nvec4 color23 = mix(color2, color3, blend.x);\nvec4 color = mix(color01, color23, blend.y);\n#ifdef NNEDGE\nfloat alpha = floor(color0.a * color1.a * color2.a * color3.a + 0.5);\ncolor = color * alpha + (1.0 - alpha) * texture2D(sampler, coords);\n#endif\nreturn color;\n}", "epx.glsl": "vec4 sampleEPX(sampler2D sampler, float size, vec2 coords, vec2 texSize) {\nvec2 invSize = 1.0 / texSize;\nvec2 texel = coords * texSize;\nvec2 texel_i = floor(texel);\nvec2 texel_frac = fract(texel);\nvec4 colorP = texture2D(sampler, texel_i * invSize);\nvec4 colorP1 = vec4(colorP);\nvec4 colorP2 = vec4(colorP);\nvec4 colorP3 = vec4(colorP);\nvec4 colorP4 = vec4(colorP);\nvec4 colorA = texture2D(sampler, (texel_i - vec2(0.0, 1.0)) * invSize);\nvec4 colorB = texture2D(sampler, (texel_i + vec2(1.0, 0.0)) * invSize);\nvec4 colorC = texture2D(sampler, (texel_i - vec2(1.0, 0.0)) * invSize);\nvec4 colorD = texture2D(sampler, (texel_i + vec2(0.0, 1.0)) * invSize);\nif (colorC == colorA && colorC != colorD && colorA != colorB) {\ncolorP1 = colorA;\n}\nif (colorA == colorB && colorA != colorC && colorB != colorD) {\ncolorP2 = colorB;\n}\nif (colorD == colorC && colorD != colorB && colorC != colorA) {\ncolorP3 = colorC;\n}\nif (colorB == colorD && colorB != colorA && colorD != colorC) {\ncolorP4 = colorD;\n}\nvec4 colorP12 = mix(colorP1, colorP2, texel_frac.x);\nvec4 colorP34 = mix(colorP1, colorP2, texel_frac.x);\nreturn mix(colorP12, colorP34, texel_frac.y);\n}" }, heatmap: { heatmapResolve: { "heatmapResolve.frag": "precision highp float;\n#ifdef HEATMAP_PRECISION_HALF_FLOAT\n#define COMPRESSION_FACTOR 4.0\n#else\n#define COMPRESSION_FACTOR 1.0\n#endif\nuniform sampler2D u_texture;\nuniform sampler2D u_gradient;\nuniform vec2 u_densityMinAndInvRange;\nuniform float u_densityNormalization;\nvarying vec2 v_uv;\nvoid main() {\nvec4 data = texture2D(u_texture, v_uv);\nfloat density = data.r * COMPRESSION_FACTOR;\ndensity *= u_densityNormalization;\ndensity = (density - u_densityMinAndInvRange.x) * u_densityMinAndInvRange.y;\nvec4 color = texture2D(u_gradient, vec2(density, 0.5));\ngl_FragColor = vec4(color.rgb * color.a, color.a);\n}", "heatmapResolve.vert": "precision highp float;\nattribute vec2 a_pos;\nvarying vec2 v_uv;\nvoid main() {\nv_uv = a_pos;\ngl_Position = vec4(a_pos * 2.0 - 1.0, 1., 1.);\n}" } }, highlight: { "blur.frag": "varying mediump vec2 v_texcoord;\nuniform mediump vec4 u_direction;\nuniform mediump mat4 u_channelSelector;\nuniform mediump float u_sigma;\nuniform sampler2D u_texture;\nmediump float gauss1(mediump vec2 dir) {\nreturn exp(-dot(dir, dir) / (2.0 * u_sigma * u_sigma));\n}\nmediump vec4 selectChannel(mediump vec4 sample) {\nreturn u_channelSelector * sample;\n}\nvoid accumGauss1(mediump float i, inout mediump float tot, inout mediump float weight) {\nmediump float w = gauss1(i * u_direction.xy);\ntot += selectChannel(texture2D(u_texture, v_texcoord + i * u_direction.zw))[3] * w;\nweight += w;\n}\nvoid main(void) {\nmediump float tot = 0.0;\nmediump float weight = 0.0;\naccumGauss1(-5.0, tot, weight);\naccumGauss1(-4.0, tot, weight);\naccumGauss1(-3.0, tot, weight);\naccumGauss1(-2.0, tot, weight);\naccumGauss1(-1.0, tot, weight);\naccumGauss1(0.0, tot, weight);\naccumGauss1(1.0, tot, weight);\naccumGauss1(2.0, tot, weight);\naccumGauss1(3.0, tot, weight);\naccumGauss1(4.0, tot, weight);\naccumGauss1(5.0, tot, weight);\ngl_FragColor = vec4(0.0, 0.0, 0.0, tot / weight);\n}", "highlight.frag": "varying mediump vec2 v_texcoord;\nuniform sampler2D u_texture;\nuniform mediump float u_sigma;\nuniform sampler2D u_shade;\nuniform mediump vec2 u_minMaxDistance;\nmediump float estimateDistance() {\nmediump float y = texture2D(u_texture, v_texcoord)[3];\nconst mediump float y0 = 0.5;\nmediump float m0 = 1.0 / (sqrt(2.0 * 3.1415) * u_sigma);\nmediump float d = (y - y0) / m0;\nreturn d;\n}\nmediump vec4 shade(mediump float d) {\nmediump float mappedDistance = (d - u_minMaxDistance.x) / (u_minMaxDistance.y - u_minMaxDistance.x);\nmappedDistance = clamp(mappedDistance, 0.0, 1.0);\nreturn texture2D(u_shade, vec2(mappedDistance, 0.5));\n}\nvoid main(void) {\nmediump float d = estimateDistance();\ngl_FragColor = shade(d);\n}", "textured.vert": "attribute mediump vec2 a_position;\nattribute mediump vec2 a_texcoord;\nvarying mediump vec2 v_texcoord;\nvoid main(void) {\ngl_Position = vec4(a_position, 0.0, 1.0);\nv_texcoord = a_texcoord;\n}" }, materials: { "attributeData.glsl": "uniform highp sampler2D filterFlags;\nuniform highp sampler2D animation;\nuniform highp sampler2D gpgpu;\nuniform highp sampler2D visualVariableData;\nuniform highp sampler2D dataDriven0;\nuniform highp sampler2D dataDriven1;\nuniform highp sampler2D dataDriven2;\nuniform float size;\nhighp vec2 getAttributeDataCoords(in highp vec3 id) {\nhighp vec3  texel = unpackDisplayIdTexel(id);\nhighp float u32 = float(int(texel.r) + int(texel.g) * 256 + int(texel.b) * 256 * 256);\nhighp float col = mod(u32, size);\nhighp float row = (u32 - col) / size;\nhighp float u = col / size;\nhighp float v = row / size;\nreturn vec2(u, v);\n}\nhighp vec2 getAttributeDataTextureCoords(in highp vec3 id) {\nreturn (getAttributeDataCoords(id) * 2.0) - 1.0 + (.5 / vec2(size));\n}\nhighp vec4 getFilterData(in highp vec3 id) {\nvec2 coords = getAttributeDataCoords(id);\nreturn texture2D(filterFlags, coords);\n}\nhighp vec4 getAnimation(in highp vec3 id) {\nhighp vec2 coords = getAttributeDataCoords(id);\nreturn texture2D(animation, coords);\n}\nhighp vec4 getVisualVariableData(in highp vec3 id) {\nhighp vec2 coords = getAttributeDataCoords(id);\nreturn texture2D(visualVariableData, coords);\n}\nhighp vec4 getDataDriven0(in highp vec3 id) {\nhighp vec2 coords = getAttributeDataCoords(id);\nreturn texture2D(dataDriven0, coords);\n}\nhighp vec4 getDataDriven1(in highp vec3 id) {\nhighp vec2 coords = getAttributeDataCoords(id);\nreturn texture2D(dataDriven1, coords);\n}\nhighp vec4 getGPGPU(in highp vec3 id) {\nhighp vec2 coords = getAttributeDataCoords(id);\nreturn texture2D(gpgpu, coords);\n}\nhighp vec4 getDataDriven2(in highp vec3 id) {\nhighp vec2 coords = getAttributeDataCoords(id);\nreturn texture2D(dataDriven2, coords);\n}\nfloat u88VVToFloat(in vec2 v) {\nbool isMagic = v.x == 255.0 && v.y == 255.0;\nif (isMagic) {\nreturn NAN_MAGIC_NUMBER;\n}\nreturn (v.x + v.y * float(0x100)) - 32768.0;\n}", "barycentric.glsl": "float inTriangle(vec3 bary) {\nvec3 absBary = abs(bary);\nreturn step((absBary.x + absBary.y + absBary.z), 1.05);\n}\nvec3 xyToBarycentric(in vec2 pos, in vec2 v0,  in vec2 v1, in vec2 v2) {\nmat3 xyToBarycentricMat3 = mat3(\nv1.x * v2.y - v2.x * v1.y, v2.x * v0.y - v0.x * v2.y, v0.x * v1.y - v1.x * v0.y,\nv1.y - v2.y, v2.y - v0.y, v0.y - v1.y,\nv2.x - v1.x, v0.x - v2.x, v1.x - v0.x\n);\nfloat A2 = v0.x * (v1.y - v2.y) + v1.x * (v2.y - v0.y) + v2.x * (v0.y - v1.y);\nreturn (1. / A2) * xyToBarycentricMat3 * vec3(1., pos);\n}", "constants.glsl": "const float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_RAD_TO_DEG = 180.0 / 3.141592654;\nconst float POSITION_PRECISION = 1.0 / 8.0;\nconst float FILL_POSITION_PRECISION = 1.0 / 1.0;\nconst float SOFT_EDGE_RATIO = 1.0;\nconst float THIN_LINE_WIDTH_FACTOR = 1.1;\nconst float THIN_LINE_HALF_WIDTH = 1.0;\nconst float EXTRUDE_SCALE_PLACEMENT_PADDING = 1.0 / 4.0;\nconst float OFFSET_PRECISION = 1.0 / 8.0;\nconst float OUTLINE_SCALE = 1.0 / 5.0;\nconst float SDF_FONT_SIZE = 24.0;\nconst float MAX_SDF_DISTANCE = 8.0;\nconst float PLACEMENT_PADDING = 8.0;\nconst float EPSILON = 0.00001;\nconst float EPSILON_HITTEST = 0.05;\nconst int MAX_FILTER_COUNT = 2;\nconst int ATTR_VV_SIZE = 0;\nconst int ATTR_VV_COLOR = 1;\nconst int ATTR_VV_OPACITY = 2;\nconst int ATTR_VV_ROTATION = 3;\nconst highp float NAN_MAGIC_NUMBER = 1e-30;\nconst int BITSET_GENERIC_LOCK_COLOR = 1;\nconst int BITSET_GENERIC_CONSIDER_ALPHA_ONLY = 4;\nconst int BITSET_MARKER_ALIGNMENT_MAP = 0;\nconst int BITSET_MARKER_OUTLINE_ALLOW_COLOR_OVERRIDE = 2;\nconst int BITSET_MARKER_SCALE_SYMBOLS_PROPORTIONALLY = 3;\nconst int BITSET_TYPE_FILL_OUTLINE = 0;\nconst int BITSET_FILL_RANDOM_PATTERN_OFFSET = 2;\nconst int BITSET_FILL_HAS_UNRESOLVED_REPLACEMENT_COLOR = 3;\nconst int BITSET_FILL_HAS_PATTERN_HEIGHT_PRECISION_FACTOR = 5;\nconst int BITSET_FILL_HAS_PATTERN_WIDTH_PRECISION_FACTOR = 6;\nconst int BITSET_LINE_SCALE_DASH = 2;", fill: { "common.glsl": "#include <materials/symbologyTypeUtils.glsl>\n#ifdef PATTERN\nuniform mediump vec2 u_mosaicSize;\nvarying mediump float v_sampleAlphaOnly;\n#endif\n#if SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_DOT_DENSITY\nuniform lowp vec4 u_isActive[ 2 ];\nuniform highp float u_dotValue;\nuniform highp float u_tileDotsOverArea;\nuniform highp float u_dotTextureDotCount;\nuniform mediump float u_tileZoomFactor;\n#endif\nvarying highp vec3 v_id;\nvarying lowp vec4 v_color;\nvarying lowp float v_opacity;\nvarying mediump vec4 v_aux1;\n#ifdef PATTERN\nvarying mediump vec2 v_tileTextureCoord;\n#endif\n#ifdef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\nvarying lowp float v_isOutline;\n#endif\n#if SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_DOT_DENSITY\nvarying highp vec2 v_dotTextureCoords;\nvarying highp vec4 v_dotThresholds[ 2 ];\n#endif", "fill.frag": "precision highp float;\n#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <materials/fill/common.glsl>\n#ifdef PATTERN\nuniform lowp sampler2D u_texture;\n#endif\n#if SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_DOT_DENSITY\nuniform mediump mat4 u_dotColors[ 2 ];\nuniform sampler2D u_dotTextures[ 2 ];\nuniform vec4 u_dotBackgroundColor;\n#endif\n#ifdef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\n#include <materials/shared/line/common.glsl>\n#include <materials/shared/line/line.frag>\nlowp vec4 drawLine() {\nfloat v_lineWidth = v_aux1.x;\nvec2  v_normal    = v_aux1.yz;\nLineData inputs = LineData(\nv_color,\nv_normal,\nv_lineWidth,\nv_opacity,\nv_id\n);\nreturn shadeLine(inputs);\n}\n#endif\nlowp vec4 drawFill() {\nlowp vec4 out_color = vec4(0.);\n#ifdef HITTEST\nout_color = v_color;\n#elif defined(PATTERN)\nmediump vec4 v_tlbr = v_aux1;\nmediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\nif (v_sampleAlphaOnly > 0.5) {\ncolor.rgb = vec3(color.a);\n}\nout_color = v_opacity * v_color * color;\n#elif SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_DOT_DENSITY && !defined(HIGHLIGHT)\nvec4 textureThresholds0 = texture2D(u_dotTextures[0], v_dotTextureCoords);\nvec4 textureThresholds1 = texture2D(u_dotTextures[1], v_dotTextureCoords);\nvec4 difference0 = v_dotThresholds[0] - textureThresholds0;\nvec4 difference1 = v_dotThresholds[1] - textureThresholds1;\n#ifdef DD_DOT_BLENDING\nvec4 isPositive0 = step(0.0, difference0);\nvec4 isPositive1 = step(0.0, difference1);\nfloat weightSum = dot(isPositive0, difference0) + dot(isPositive1, difference1);\nfloat lessThanEqZero = step(weightSum, 0.0);\nfloat greaterThanZero = 1.0 - lessThanEqZero ;\nfloat divisor = (weightSum + lessThanEqZero);\nvec4 weights0 = difference0 * isPositive0 / divisor;\nvec4 weights1 = difference1 * isPositive1 / divisor;\nvec4 dotColor = u_dotColors[0] * weights0 + u_dotColors[1] * weights1;\nvec4 preEffectColor = greaterThanZero * dotColor + lessThanEqZero * u_dotBackgroundColor;\n#else\nfloat diffMax = max(max4(difference0), max4(difference1));\nfloat lessThanZero = step(diffMax, 0.0);\nfloat greaterOrEqZero = 1.0 - lessThanZero;\nvec4 isMax0 = step(diffMax, difference0);\nvec4 isMax1 = step(diffMax, difference1);\nvec4 dotColor = u_dotColors[0] * isMax0 + u_dotColors[1] * isMax1;\nvec4 preEffectColor = greaterOrEqZero * dotColor + lessThanZero * u_dotBackgroundColor;\n#endif\nout_color = preEffectColor;\n#else\nout_color = v_opacity * v_color;\n#endif\n#ifdef HIGHLIGHT\nout_color.a = 1.0;\n#endif\nreturn out_color;\n}\nvoid main() {\n#ifdef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\nif (v_isOutline > 0.5) {\ngl_FragColor = drawLine();\n} else {\ngl_FragColor = drawFill();\n}\n#else\ngl_FragColor = drawFill();\n#endif\n}", "fill.vert": "#include <materials/symbologyTypeUtils.glsl>\n#define PACKED_LINE\nprecision highp float;\nattribute float a_bitset;\n#if SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_DOT_DENSITY\nattribute float a_inverseArea;\nvec4 a_color = vec4(0.0, 0.0, 0.0, 1.0);\nvec2 a_zoomRange = vec2(0.0, 10000.0);\n#else\nattribute vec4 a_color;\nattribute vec4 a_aux2;\nattribute vec4 a_aux3;\n#ifndef SYMBOLOGY_TYPE_IS_SIMPLE_LIKE\nattribute vec4 a_aux1;\nattribute vec2 a_zoomRange;\n#else\nvec2 a_zoomRange = vec2(0.0, 10000.0);\n#endif\n#endif\nuniform vec2 u_tileOffset;\nuniform vec2 u_maxIntNumOfCrossing;\n#include <util/encoding.glsl>\n#include <materials/vcommon.glsl>\n#include <materials/fill/common.glsl>\n#include <materials/fill/hittest.glsl>\nconst float INV_SCALE_COMPRESSION_FACTOR = 1.0 / 128.0;\nconst float MAX_REPRESENTABLE_INT = 16777216.0;\n#if SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_DOT_DENSITY\nvec4 dotThreshold(vec4 featureAttrOverFeatureArea, float dotValue, float tileDotsOverArea) {\nreturn featureAttrOverFeatureArea * (1.0 / dotValue)  * (1.0 / tileDotsOverArea);\n}\n#endif\n#ifdef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\n#include <materials/shared/line/common.glsl>\n#include <materials/shared/line/line.vert>\nvoid drawLine(out lowp vec4 out_color, out highp vec3 out_pos) {\nLineData outputs = buildLine(\nout_pos,\na_id,\na_pos,\na_color,\n(a_aux3.xy - 128.) / 16.,\n(a_aux3.zw - 128.) / 16.,\n0.,\na_aux2.z / 16.,\na_bitset,\nvec4(0.),\nvec2(0.),\na_aux2.w / 16.\n);\nv_id      = outputs.id;\nv_opacity = outputs.opacity;\nv_aux1    = vec4(outputs.lineHalfWidth, outputs.normal, 0.);\nout_color = outputs.color;\n}\n#endif\nvoid drawFill(out lowp vec4 out_color, out highp vec3 out_pos) {\nfloat a_bitSet = a_bitset;\nout_color = getColor(a_color, a_bitSet, BITSET_GENERIC_LOCK_COLOR);\nv_opacity = getOpacity();\nv_id      = norm(a_id);\n#if SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_DOT_DENSITY\nmat3 tileToTileNormalized = mat3(  2. / 512.,  0.,  0.,\n0., -2. / 512.,  0.,\n-1.,  1.,  1.  );\nout_pos   = tileToTileNormalized * vec3((a_pos * FILL_POSITION_PRECISION), 1.);\n#else\nout_pos   = u_dvsMat3 * vec3(a_pos * FILL_POSITION_PRECISION, 1.);\n#endif\n#ifdef PATTERN\nvec4  a_tlbr   = a_aux1;\nfloat a_width  = a_aux2.x;\nfloat a_height = a_aux2.y;\nvec2  a_offset = a_aux2.zw;\nvec2  a_scale  = a_aux3.xy;\nfloat a_angle  = a_aux3.z;\nif (getBit(a_bitset, BITSET_FILL_HAS_PATTERN_WIDTH_PRECISION_FACTOR) > 0.5) {\na_width *= INV_SCALE_COMPRESSION_FACTOR;\n}\nif (getBit(a_bitset, BITSET_FILL_HAS_PATTERN_HEIGHT_PRECISION_FACTOR) > 0.5) {\na_height *= INV_SCALE_COMPRESSION_FACTOR;\n}\nvec2 scale = INV_SCALE_COMPRESSION_FACTOR * a_scale;\nfloat width = u_zoomFactor * a_width * scale.x;\nfloat height = u_zoomFactor * a_height * scale.y;\nfloat angle = C_256_TO_RAD * a_angle;\nfloat sinA = sin(angle);\nfloat cosA = cos(angle);\nfloat dx = 0.0;\nfloat dy = 0.0;\nif (getBit(a_bitset, BITSET_FILL_RANDOM_PATTERN_OFFSET) > 0.5) {\nfloat id = rgba2float(vec4(a_id, 0.0));\ndx = rand(vec2(id, 0.0));\ndy = rand(vec2(0.0, id));\n}\nmat3 patternMatrix = mat3(cosA / width, sinA / height, 0,\n-sinA / width, cosA / height, 0,\ndx,            dy,           1);\nvec2 patternSize = vec2(a_width, a_height);\nvec2 numPatternsPerMaxInt = vec2(MAX_REPRESENTABLE_INT) / patternSize;\nvec2 maxIntCrossingOffsetCorrection = patternSize * fract(u_maxIntNumOfCrossing * numPatternsPerMaxInt);\nvec2 tileOffset = u_tileOffset + maxIntCrossingOffsetCorrection - 0.5 * patternSize;\ntileOffset = vec2(tileOffset.x * cosA - tileOffset.y * sinA, tileOffset.x * sinA + tileOffset.y * cosA);\ntileOffset = mod(tileOffset, patternSize);\nvec2 symbolOffset = u_zoomFactor * scale * vec2(a_offset - tileOffset) / vec2(width, height);\nv_tileTextureCoord = (patternMatrix * vec3(a_pos * FILL_POSITION_PRECISION, 1.0)).xy - symbolOffset;\nv_aux1 = a_tlbr / u_mosaicSize.xyxy;\nv_sampleAlphaOnly = getBit(a_bitset, BITSET_GENERIC_CONSIDER_ALPHA_ONLY);\nif (getBit(a_bitSet, BITSET_FILL_HAS_UNRESOLVED_REPLACEMENT_COLOR) > 0.5) {\n#ifdef VV_COLOR\nv_sampleAlphaOnly *= (1.0 - float(isNan(VV_ADATA[ATTR_VV_COLOR]))) * (1.0 - getBit(a_bitSet, BITSET_GENERIC_LOCK_COLOR));\n#else\nv_sampleAlphaOnly = 0.0;\n#endif\n}\n#elif SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_DOT_DENSITY\nvec4 ddAttributeData0 = getAttributeData2(a_id) * u_isActive[0] * a_inverseArea;\nvec4 ddAttributeData1 = getAttributeData3(a_id) * u_isActive[1] * a_inverseArea;\nfloat size = u_tileZoomFactor * 512.0 * 1.0 / u_pixelRatio;\nv_dotThresholds[0] = dotThreshold(ddAttributeData0, u_dotValue, u_tileDotsOverArea);\nv_dotThresholds[1] = dotThreshold(ddAttributeData1, u_dotValue, u_tileDotsOverArea);\nv_dotTextureCoords = (a_pos * FILL_POSITION_PRECISION + 0.5) / size;\n#endif\n}\n#ifdef HITTEST\nvoid draw(out lowp vec4 out_color, out highp vec3 out_pos) {\n#ifdef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\nif (getBit(a_bitset, BITSET_TYPE_FILL_OUTLINE) > 0.5) {\nout_pos = vec3(0., 0., 2.);\nreturn;\n}\n#endif\nhittestFill(out_color, out_pos);\ngl_PointSize = 1.0;\n}\n#elif defined(SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE)\nvoid draw(out lowp vec4 out_color, out highp vec3 out_pos) {\nv_isOutline = getBit(a_bitset, BITSET_TYPE_FILL_OUTLINE);\nif (v_isOutline > 0.5) {\ndrawLine(out_color, out_pos);\n} else {\ndrawFill(out_color, out_pos);\n}\n}\n#else\n#define draw drawFill\n#endif\nvoid main()\n{\nINIT;\nhighp vec3 pos  = vec3(0.);\nhighp vec4 color  = vec4(0.);\ndraw(color, pos);\nv_color = color;\ngl_Position = vec4(clip(v_color, pos, getFilterFlags(), a_zoomRange), 1.0);\n}", "hittest.glsl": "#ifdef HITTEST\n#include <materials/hittest/common.glsl>\nattribute vec2 a_pos1;\nattribute vec2 a_pos2;\nvoid hittestFill(\nout lowp vec4 out_color,\nout highp vec3 out_pos\n) {\nvec3 pos        = u_viewMat3 * u_tileMat3 * vec3(a_pos  * FILL_POSITION_PRECISION, 1.);\nvec3 pos1       = u_viewMat3 * u_tileMat3 * vec3(a_pos1 * FILL_POSITION_PRECISION, 1.);\nvec3 pos2       = u_viewMat3 * u_tileMat3 * vec3(a_pos2 * FILL_POSITION_PRECISION, 1.);\nfloat hittestDist = u_hittestDist;\nfloat dist = distPointTriangle(u_hittestPos, pos.xy, pos1.xy, pos2.xy);\nout_pos = vec3(getAttributeDataTextureCoords(a_id), 0.0);\nif (dist < 0. || dist >= hittestDist) {\nout_pos.z += 2.0;\n}\nout_color = vec4(1. / 255., 0, 0, dist == 0. ? (1. / 255.) : 0.);\n}\n#endif" }, hittest: { "common.glsl": "#ifdef HITTEST\nuniform float hittestDist;\nuniform highp vec2 hittestPos;\nfloat projectScalar(vec2 a, vec2 b) {\nreturn dot(a, normalize(b));\n}\nfloat distPointSegment(vec2 p0, vec2 p1, vec2 p2) {\nvec2 L = p2 - p1;\nvec2 A = p0 - p1;\nfloat projAL = projectScalar(A, L);\nfloat t = clamp(projAL / length(L), 0., 1.);\nreturn distance(p0, p1 + t * (p2 - p1));\n}\nvoid hittestMarker(out lowp vec4 out_color, out highp vec3 out_pos, in highp vec3 pos, float size) {\nfloat dist = distance(pos, vec3(hittestPos, 1.));\nout_pos = vec3(getAttributeDataTextureCoords(a_id), 0.0);\nif ((dist - size) > hittestDist) {\nout_pos.z += 2.0;\n}\nout_color = vec4(1. / 255., 0, 0, (dist - size) < 0. ? (1. / 255.) : 0.);\n}\nfloat intersectPointTriangleBary(vec2 p, vec2 a, vec2 b, vec2 c) {\nreturn inTriangle(xyToBarycentric(p, a, b, c));\n}\nfloat distPointTriangle(vec2 p, vec2 a, vec2 b, vec2 c) {\nvec2 ba = b - a;\nvec2 ca = c - a;\nfloat crossProduct = ba.x * ca.y - ca.x * ba.y;\nbool isParallel = crossProduct < EPSILON_HITTEST && crossProduct > -EPSILON_HITTEST;\nif (isParallel) {\nreturn -1.;\n}\nif (intersectPointTriangleBary(p.xy, a, b, c) == 1.) {\nreturn 0.;\n}\nfloat distAB = distPointSegment(p, a, b);\nfloat distBC = distPointSegment(p, b, c);\nfloat distCA = distPointSegment(p, c, a);\nreturn min(min(distAB, distBC), distCA);\n}\n#endif" }, icon: { "common.glsl": "#include <util/encoding.glsl>\nuniform lowp vec2 u_mosaicSize;\nvarying lowp vec4 v_color;\nvarying highp vec3 v_id;\nvarying highp vec4 v_sizeTex;\nvarying mediump vec3 v_pos;\nvarying lowp float v_opacity;\nuniform lowp sampler2D u_texture;\n#ifdef SDF\nvarying lowp vec4 v_outlineColor;\nvarying mediump float v_outlineWidth;\nvarying mediump float v_distRatio;\nvarying mediump float v_overridingOutlineColor;\nvarying mediump float v_isThin;\n#endif\n#ifdef SDF\nvec4 getColor(vec2 v_size, vec2 v_tex) {\n#ifdef HITTEST\nlowp vec4 fillPixelColor = vec4(1.0);\n#else\nlowp vec4 fillPixelColor = v_color;\n#endif\nfloat d = 0.5 - rgba2float(texture2D(u_texture, v_tex));\nfloat size = max(v_size.x, v_size.y);\nfloat dist = d * size * SOFT_EDGE_RATIO * v_distRatio;\nfillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\nfloat outlineWidth = v_outlineWidth;\n#ifdef HIGHLIGHT\noutlineWidth = max(outlineWidth, 4.0 * v_isThin);\n#endif\nif (outlineWidth > 0.25) {\nlowp vec4 outlinePixelColor = v_overridingOutlineColor * v_color + (1.0 - v_overridingOutlineColor) * v_outlineColor;\nfloat clampedOutlineSize = min(outlineWidth, size);\noutlinePixelColor *= clamp(0.5 - abs(dist) + clampedOutlineSize * 0.5, 0.0, 1.0);\nreturn v_opacity * ((1.0 - outlinePixelColor.a) * fillPixelColor + outlinePixelColor);\n}\nreturn v_opacity * fillPixelColor;\n}\n#else\nvec4 getColor(vec2 _v_size, vec2 v_tex) {\nlowp vec4 texColor = texture2D(u_texture, v_tex);\nreturn v_opacity * texColor * v_color;\n}\n#endif", heatmapAccumulate: { "common.glsl": "varying lowp vec4 v_hittestResult;\nvarying mediump vec2 v_offsetFromCenter;\nvarying highp float v_fieldValue;", "heatmapAccumulate.frag": "precision mediump float;\n#include <materials/icon/heatmapAccumulate/common.glsl>\n#ifdef HEATMAP_PRECISION_HALF_FLOAT\n#define COMPRESSION_FACTOR 0.25\n#else\n#define COMPRESSION_FACTOR 1.0\n#endif\nuniform lowp sampler2D u_texture;\nvoid main() {\n#ifdef HITTEST\ngl_FragColor = v_hittestResult;\n#else\nfloat radius = length(v_offsetFromCenter);\nfloat shapeWeight = step(radius, 1.0);\nfloat oneMinusRadiusSquared = 1.0 - radius * radius;\nfloat kernelWeight = oneMinusRadiusSquared * oneMinusRadiusSquared;\ngl_FragColor = vec4(shapeWeight * kernelWeight * v_fieldValue * COMPRESSION_FACTOR);\n#endif\n}", "heatmapAccumulate.vert": "precision highp float;\nattribute vec2 a_vertexOffset;\nvec4 a_color = vec4(0.0);\nvec2 a_zoomRange = vec2(0.0, 10000.0);\nuniform float u_radius;\nuniform float u_isFieldActive;\n#include <materials/vcommon.glsl>\n#include <materials/hittest/common.glsl>\n#include <materials/icon/heatmapAccumulate/common.glsl>\nvoid main() {\nfloat filterFlags = getFilterFlags();\n#ifdef HITTEST\nhighp vec4 out_hittestResult = vec4(0.);\nhighp vec3 out_pos = vec3(0.);\nvec3 pos = u_viewMat3 * u_tileMat3 * vec3(a_pos * POSITION_PRECISION, 1.0);\nhittestMarker(out_hittestResult, out_pos, pos, u_radius);\nv_hittestResult = out_hittestResult;\ngl_PointSize = 1.;\ngl_Position = vec4(clip(a_color, out_pos, filterFlags, a_zoomRange), 1.0);\n#else\nv_offsetFromCenter = sign(a_vertexOffset);\nv_fieldValue = getAttributeData2(a_id).x * u_isFieldActive + 1.0 - u_isFieldActive;\nvec3 centerPos = u_dvsMat3 * vec3(a_pos * POSITION_PRECISION, 1.0);\nvec3 vertexPos = centerPos + u_displayViewMat3 * vec3(v_offsetFromCenter, 0.0) * u_radius;\ngl_Position = vec4(clip(a_color, vertexPos, filterFlags, a_zoomRange), 1.0);\n#endif\n}" }, "hittest.glsl": "#ifdef HITTEST\n#include <materials/hittest/common.glsl>\nattribute vec2 a_vertexOffset1;\nattribute vec2 a_vertexOffset2;\nattribute vec2 a_texCoords1;\nattribute vec2 a_texCoords2;\nvec2 getTextureCoords(in vec3 bary, in vec2 texCoords0, in vec2 texCoords1, in vec2 texCoords2) {\nreturn texCoords0 * bary.x + texCoords1 * bary.y + texCoords2 * bary.z;\n}\nvoid hittestIcon(\ninout lowp vec4 out_color,\nout highp vec3 out_pos,\nin vec3 pos,\nin vec3 offset,\nin vec2 size,\nin float scaleFactor,\nin float isMapAligned\n) {\nout_pos = vec3(getAttributeDataTextureCoords(a_id), 0.0);\nvec3 posBase = u_viewMat3 * u_tileMat3  * pos;\nvec3 offset1 = scaleFactor * vec3(a_vertexOffset1 / 16.0, 0.);\nvec3 offset2 = scaleFactor * vec3(a_vertexOffset2 / 16.0, 0.);\nvec2 pos0    = (posBase + getMatrixNoDisplay(isMapAligned) * offset).xy;\nvec2 pos1    = (posBase + getMatrixNoDisplay(isMapAligned) * offset1).xy;\nvec2 pos2    = (posBase + getMatrixNoDisplay(isMapAligned) * offset2).xy;\nvec3 bary0 = xyToBarycentric(u_hittestPos + vec2(-u_hittestDist, -u_hittestDist), pos0, pos1, pos2);\nvec3 bary1 = xyToBarycentric(u_hittestPos + vec2(0., -u_hittestDist), pos0, pos1, pos2);\nvec3 bary2 = xyToBarycentric(u_hittestPos + vec2(u_hittestDist, -u_hittestDist), pos0, pos1, pos2);\nvec3 bary3 = xyToBarycentric(u_hittestPos + vec2(-u_hittestDist, 0.), pos0, pos1, pos2);\nvec3 bary4 = xyToBarycentric(u_hittestPos, pos0, pos1, pos2);\nvec3 bary5 = xyToBarycentric(u_hittestPos + vec2(u_hittestDist, 0.), pos0, pos1, pos2);\nvec3 bary6 = xyToBarycentric(u_hittestPos + vec2(-u_hittestDist, u_hittestDist), pos0, pos1, pos2);\nvec3 bary7 = xyToBarycentric(u_hittestPos + vec2(0., u_hittestDist), pos0, pos1, pos2);\nvec3 bary8 = xyToBarycentric(u_hittestPos + vec2(u_hittestDist, u_hittestDist), pos0, pos1, pos2);\nvec2 tex0 = a_texCoords  / u_mosaicSize;\nvec2 tex1 = a_texCoords1 / u_mosaicSize;\nvec2 tex2 = a_texCoords2 / u_mosaicSize;\nfloat alphaSum = 0.;\nalphaSum += inTriangle(bary0) * getColor(size, getTextureCoords(bary0, tex0, tex1, tex2)).a;\nalphaSum += inTriangle(bary1) * getColor(size, getTextureCoords(bary1, tex0, tex1, tex2)).a;\nalphaSum += inTriangle(bary2) * getColor(size, getTextureCoords(bary2, tex0, tex1, tex2)).a;\nalphaSum += inTriangle(bary3) * getColor(size, getTextureCoords(bary3, tex0, tex1, tex2)).a;\nalphaSum += inTriangle(bary4) * getColor(size, getTextureCoords(bary4, tex0, tex1, tex2)).a;\nalphaSum += inTriangle(bary5) * getColor(size, getTextureCoords(bary5, tex0, tex1, tex2)).a;\nalphaSum += inTriangle(bary6) * getColor(size, getTextureCoords(bary6, tex0, tex1, tex2)).a;\nalphaSum += inTriangle(bary7) * getColor(size, getTextureCoords(bary7, tex0, tex1, tex2)).a;\nout_pos.z += step(alphaSum, .05) * 2.0;\nout_color = vec4(1. / 255., 0., 0., alphaSum / 255.);\n}\n#endif", "icon.frag": "precision mediump float;\n#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <materials/icon/common.glsl>\nvoid main()\n{\n#ifdef HITTEST\nvec4 color = v_color;\n#else\nvec4 color = getColor(v_sizeTex.xy, v_sizeTex.zw);\n#endif\n#ifdef HIGHLIGHT\ncolor.a = step(1.0 / 255.0, color.a);\n#endif\ngl_FragColor = color;\n}", "icon.vert": "precision highp float;\nattribute vec4 a_color;\nattribute vec4 a_outlineColor;\nattribute vec4 a_sizeAndOutlineWidth;\nattribute vec2 a_vertexOffset;\nattribute vec2 a_texCoords;\nattribute vec2 a_bitSetAndDistRatio;\nattribute vec2 a_zoomRange;\n#include <materials/vcommon.glsl>\n#include <materials/icon/common.glsl>\n#include <materials/icon/hittest.glsl>\nfloat getMarkerScaleFactor(inout vec2 size, in float referenceSize) {\n#ifdef VV_SIZE\nfloat f = getSize(size.y) / size.y;\nfloat sizeFactor = size.y / referenceSize;\nreturn getSize(referenceSize) / referenceSize;\n#else\nreturn 1.;\n#endif\n}\nvoid main()\n{\nINIT;\nfloat a_bitSet = a_bitSetAndDistRatio.x;\nvec3  pos           = vec3(a_pos * POSITION_PRECISION, 1.0);\nvec2  size          = a_sizeAndOutlineWidth.xy * a_sizeAndOutlineWidth.xy / 128.0;\nvec3  offset        = vec3(a_vertexOffset / 16.0, 0.);\nfloat outlineSize   = a_sizeAndOutlineWidth.z * a_sizeAndOutlineWidth.z / 128.0;\nfloat isMapAligned  = getBit(a_bitSet, BITSET_MARKER_ALIGNMENT_MAP);\nfloat referenceSize = a_sizeAndOutlineWidth.w * a_sizeAndOutlineWidth.w / 128.0;\nfloat scaleSymbolProportionally = getBit(a_bitSet, BITSET_MARKER_SCALE_SYMBOLS_PROPORTIONALLY);\nfloat scaleFactor               = getMarkerScaleFactor(size, referenceSize);\nsize.xy     *= scaleFactor;\noffset.xy   *= scaleFactor;\noutlineSize *= scaleSymbolProportionally * (scaleFactor - 1.0) + 1.0;\nvec2 v_tex   = a_texCoords / u_mosaicSize;\nfloat filterFlags = getFilterFlags();\nv_color    = getColor(a_color, a_bitSet, BITSET_GENERIC_LOCK_COLOR);\nv_opacity  = getOpacity();\nv_id       = norm(a_id);\nv_pos      = u_dvsMat3 * pos + getMatrix(isMapAligned) * getRotation()  * offset;\nv_sizeTex  = vec4(size.xy, v_tex.xy);\n#ifdef SDF\nv_isThin   = getBit(a_bitSet, BITSET_MARKER_OUTLINE_ALLOW_COLOR_OVERRIDE);\n#ifdef VV_COLOR\nv_overridingOutlineColor = v_isThin;\n#else\nv_overridingOutlineColor = 0.0;\n#endif\nv_outlineWidth = min(outlineSize, max(max(size.x, size.y) - 0.99, 0.0));\nv_outlineColor = a_outlineColor;\nv_distRatio = a_bitSetAndDistRatio.y / 128.0;\n#endif\n#ifdef HITTEST\nhighp vec4 out_color = vec4(0.);\nhighp vec3 out_pos   = vec3(0.);\nhittestIcon(out_color, out_pos, pos, offset, size, scaleFactor, isMapAligned);\nv_color = out_color;\ngl_PointSize = 1.;\ngl_Position = vec4(clip(v_color, out_pos, filterFlags, a_zoomRange), 1.0);\n#else\ngl_Position = vec4(clip(v_color, v_pos, filterFlags, a_zoomRange), 1.0);\n#endif\n}" }, label: { "common.glsl": "uniform mediump float u_zoomLevel;\nuniform mediump float u_mapRotation;\nuniform mediump float u_mapAligned;\nuniform mediump vec2 u_mosaicSize;\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\nvarying mediump vec2 v_tex;\nvarying mediump vec4 v_color;\nvarying lowp vec4 v_animation;", "label.frag": "#include <materials/text/text.frag>", "label.vert": "precision highp float;\n#include <materials/vcommon.glsl>\n#include <materials/text/common.glsl>\nattribute vec4 a_color;\nattribute vec4 a_haloColor;\nattribute vec4 a_texAndSize;\nattribute vec4 a_refSymbolAndPlacementOffset;\nattribute vec4 a_glyphData;\nattribute vec2 a_vertexOffset;\nattribute vec2 a_texCoords;\nuniform float u_isHaloPass;\nuniform float u_isBackgroundPass;\nuniform float u_mapRotation;\nuniform float u_mapAligned;\nfloat getZ(in float minZoom, in float maxZoom, in float angle) {\nfloat glyphAngle = angle * 360.0 / 254.0;\nfloat mapAngle = u_mapRotation * 360.0 / 254.0;\nfloat diffAngle = min(360.0 - abs(mapAngle - glyphAngle), abs(mapAngle - glyphAngle));\nfloat z = 0.0;\nz += u_mapAligned * (2.0 * (1.0 - step(minZoom, u_currentZoom)));\nz += u_mapAligned * 2.0 * step(90.0, diffAngle);\nz += 2.0 * (1.0 - step(u_currentZoom, maxZoom));\nreturn z;\n}\nvoid main()\n{\nINIT;\nfloat groupMinZoom    = getMinZoom();\nfloat glyphMinZoom    = a_glyphData.x;\nfloat glyphMaxZoom    = a_glyphData.y;\nfloat glyphAngle      = a_glyphData.z;\nfloat a_isBackground  = a_glyphData.w;\nfloat a_minZoom          = max(groupMinZoom, glyphMinZoom);\nfloat a_placementPadding = a_refSymbolAndPlacementOffset.x * EXTRUDE_SCALE_PLACEMENT_PADDING;\nvec2  a_placementDir     = unpack_u8_nf32(a_refSymbolAndPlacementOffset.zw);\nfloat a_refSymbolSize    = a_refSymbolAndPlacementOffset.y;\nfloat fontSize           = a_texAndSize.z;\nfloat haloSize           = a_texAndSize.w * OUTLINE_SCALE;\nvec2  vertexOffset = a_vertexOffset * OFFSET_PRECISION;\nvec3  pos          = vec3(a_pos * POSITION_PRECISION, 1.0);\nfloat z            = getZ(a_minZoom, glyphMaxZoom, glyphAngle);\nfloat fontScale    = fontSize / SDF_FONT_SIZE;\nfloat halfSize     = getSize(a_refSymbolSize) / 2.0;\nfloat animation    = pow(getAnimationState(), vec4(2.0)).r;\nfloat isText = 1.0 - a_isBackground;\nfloat isBackground = u_isBackgroundPass * a_isBackground;\nvec4  nonHaloColor = (isBackground + isText) * a_color;\nv_color     = animation * ((1.0 - u_isHaloPass) * nonHaloColor + (u_isHaloPass * a_haloColor));\nv_opacity   = 1.0;\nv_tex       = a_texCoords / u_mosaicSize;\nv_edgeDistanceOffset = u_isHaloPass * haloSize / fontScale / MAX_SDF_DISTANCE;\nv_antialiasingWidth  = 0.105 * SDF_FONT_SIZE / fontSize / u_pixelRatio;\nvec2 placementOffset = a_placementDir * (halfSize + a_placementPadding);\nvec3 glyphOffset     = u_displayMat3 * vec3(vertexOffset + placementOffset, 0.0);\nvec3 v_pos           = vec3((u_dvsMat3 * pos + glyphOffset).xy, z);\nfloat isHidden = u_isBackgroundPass * isText + (1.0 - u_isBackgroundPass) * a_isBackground;\nv_pos.z += 2.0 * isHidden;\ngl_Position = vec4(v_pos, 1.0);\n#ifdef DEBUG\nv_color = vec4(a_color.rgb, z == 0.0 ? 1.0 : 0.645);\n#endif\n}" }, line: { "common.glsl": "varying lowp vec4 v_color;\nvarying highp vec3 v_id;\nvarying mediump vec2 v_normal;\nvarying mediump float v_lineHalfWidth;\nvarying lowp float v_opacity;\n#ifdef PATTERN\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\n#endif\n#if defined(PATTERN) || defined(SDF)\nvarying highp float v_accumulatedDistance;\n#endif\n#ifdef SDF\nvarying mediump float v_lineWidthRatio;\n#endif", "hittest.glsl": "#include <materials/hittest/common.glsl>\n#ifdef HITTEST\nattribute vec2 a_pos1;\nattribute vec2 a_pos2;\nvoid hittestLine(out lowp vec4 out_color, out highp vec3 out_pos, float halfWidth) {\nvec3 pos        = u_viewMat3 * u_tileMat3 * vec3(a_pos  * POSITION_PRECISION, 1.);\nvec3 pos1       = u_viewMat3 * u_tileMat3 * vec3(a_pos1 * POSITION_PRECISION, 1.);\nvec3 pos2       = u_viewMat3 * u_tileMat3 * vec3(a_pos2 * POSITION_PRECISION, 1.);\nvec3 outTextureCoords = vec3(getAttributeDataTextureCoords(a_id), 0.0);\nfloat dist = min(distPointSegment(u_hittestPos, pos.xy, pos1.xy),\ndistPointSegment(u_hittestPos, pos.xy, pos2.xy)) - halfWidth;\nout_pos = vec3(getAttributeDataTextureCoords(a_id), 0.0);\nif (dist >= u_hittestDist) {\nout_pos.z += 2.0;\n}\nout_color = vec4(1. / 255., 0, 0, dist <= 0. ? (1. / 255.) : 0.);\n}\n#endif", "line.frag": "precision lowp float;\n#include <util/encoding.glsl>\n#include <materials/constants.glsl>\n#include <materials/symbologyTypeUtils.glsl>\n#include <materials/line/common.glsl>\n#include <materials/shared/line/common.glsl>\n#include <materials/shared/line/line.frag>\n#ifdef HITTEST\nvoid main() {\ngl_FragColor = v_color;\n}\n#else\nvoid main() {\nLineData inputs = LineData(\nv_color,\nv_normal,\nv_lineHalfWidth,\nv_opacity,\n#ifndef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\n#ifdef PATTERN\nv_tlbr,\nv_patternSize,\n#endif\n#ifdef SDF\nv_lineWidthRatio,\n#endif\n#if defined(PATTERN) || defined(SDF)\nv_accumulatedDistance,\n#endif\n#endif\nv_id\n);\ngl_FragColor = shadeLine(inputs);\n}\n#endif", "line.vert": "precision highp float;\nattribute vec4 a_color;\nattribute vec4 a_offsetAndNormal;\nattribute vec2 a_accumulatedDistanceAndHalfWidth;\nattribute vec4 a_tlbr;\nattribute vec4 a_segmentDirection;\nattribute vec2 a_aux;\nattribute vec2 a_zoomRange;\n#include <materials/vcommon.glsl>\n#include <materials/symbologyTypeUtils.glsl>\n#include <materials/line/common.glsl>\n#include <materials/line/hittest.glsl>\n#include <materials/shared/line/common.glsl>\n#include <materials/shared/line/line.vert>\n#ifdef HITTEST\nvoid draw() {\nfloat aa        = 0.5 * u_antialiasing;\nfloat a_halfWidth = a_accumulatedDistanceAndHalfWidth.y / 16.;\nfloat a_cimHalfWidth = a_aux.x / 16. ;\nvec2  a_offset = a_offsetAndNormal.xy / 16.;\nfloat baseWidth = getBaseLineHalfWidth(a_halfWidth, a_cimHalfWidth);\nfloat halfWidth = getLineHalfWidth(baseWidth, aa);\nhighp vec3 pos  = vec3(0.);\nv_color = vec4(0.);\nhittestLine(v_color, pos, halfWidth);\ngl_PointSize = 1.;\ngl_Position = vec4(clip(v_color, pos, getFilterFlags(), a_zoomRange), 1.0);\n}\n#else\nvoid draw()\n{\nhighp vec3 pos = vec3(0.);\nLineData outputs = buildLine(\npos,\na_id,\na_pos,\na_color,\na_offsetAndNormal.xy / 16.,\na_offsetAndNormal.zw / 16.,\na_accumulatedDistanceAndHalfWidth.x,\na_accumulatedDistanceAndHalfWidth.y / 16.,\na_segmentDirection.w,\na_tlbr,\na_segmentDirection.xy / 16.,\na_aux.x / 16.\n);\nv_id              = outputs.id;\nv_color           = outputs.color;\nv_normal          = outputs.normal;\nv_lineHalfWidth   = outputs.lineHalfWidth;\nv_opacity         = outputs.opacity;\n#ifndef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\n#ifdef PATTERN\nv_tlbr          = outputs.tlbr;\nv_patternSize   = outputs.patternSize;\n#endif\n#ifdef SDF\nv_lineWidthRatio = outputs.lineWidthRatio;\n#endif\n#if defined(PATTERN) || defined(SDF)\nv_accumulatedDistance = outputs.accumulatedDistance;\n#endif\n#endif\ngl_Position = vec4(clip(outputs.color, pos, getFilterFlags(), a_zoomRange), 1.0);\n}\n#endif\nvoid main() {\nINIT;\ndraw();\n}" }, pie: { "pie.common.glsl": "uniform float outlineWidth;\nuniform mediump float sectorThreshold;\nvarying vec3  v_id;\nvarying vec3  v_pos;\nvarying vec2  v_offset;\nvarying vec4  v_color;\nvarying float v_size;\nvarying float v_numOfEntries;\nvarying float v_maxSectorAngle;\nvarying vec2  v_filteredSectorToColorId[numberOfFields];\nvarying vec2  v_texCoords;\nvarying float v_outlineWidth;\nvarying float v_opacity;\nstruct FilteredChartInfo {\nfloat endSectorAngle;\nint colorId;\n};", "pie.frag": "precision highp float;\n#include <util/atan2.glsl>\n#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <materials/pie/pie.common.glsl>\nuniform lowp vec4 colors[numberOfFields];\nuniform lowp vec4 defaultColor;\nuniform lowp vec4 othersColor;\nuniform lowp vec4 outlineColor;\nuniform float donutRatio;\nlowp vec4 getSectorColor(in int index, in vec2 filteredSectorToColorId[numberOfFields]) {\nmediump int colorIndex = int(filteredSectorToColorId[index].y);\nreturn colors[colorIndex];\n}\nconst int OTHER_SECTOR_ID = 255;\n#ifdef HITTEST\nvec4 getColor() {\nfloat distanceSize = length(v_offset) * v_size;\nfloat donutSize = donutRatio * v_size;\nfloat alpha = step(donutSize, distanceSize) * (1.0 - step(v_size, distanceSize));\nreturn v_color;\n}\n#else\nvec4 getColor() {\nfloat angle = 90.0 - C_RAD_TO_DEG * atan2(v_offset.y, v_offset.x);\nif (angle < 0.0) {\nangle += 360.0;\n} else if (angle > 360.0) {\nangle = mod(angle, 360.0);\n}\nint numOfEntries = int(v_numOfEntries);\nfloat maxSectorAngle = v_maxSectorAngle;\nlowp vec4 fillColor = (maxSectorAngle > 0.0 || sectorThreshold > 0.0) ? othersColor : defaultColor;\nlowp vec4 prevColor = vec4(0.0);\nlowp vec4 nextColor = vec4(0.0);\nfloat startSectorAngle = 0.0;\nfloat endSectorAngle = 0.0;\nif (angle < maxSectorAngle) {\nfor (int index = 0; index < numberOfFields; ++index) {\nstartSectorAngle = endSectorAngle;\nendSectorAngle = v_filteredSectorToColorId[index].x;\nif (endSectorAngle > angle) {\nfillColor = getSectorColor(index, v_filteredSectorToColorId);\nprevColor = sectorThreshold != 0.0 && index == 0 && abs(360.0 - maxSectorAngle) < EPSILON ? othersColor :\ngetSectorColor(index > 0 ? index - 1 : numOfEntries - 1, v_filteredSectorToColorId);\nnextColor = sectorThreshold != 0.0 && abs(endSectorAngle - maxSectorAngle) < EPSILON ? othersColor :\ngetSectorColor(index < numOfEntries - 1 ? index + 1 : 0, v_filteredSectorToColorId);\nbreak;\n}\nif (index == numOfEntries - 1) {\nbreak;\n}\n}\n} else {\nprevColor = getSectorColor(numOfEntries - 1, v_filteredSectorToColorId);\nnextColor = getSectorColor(0, v_filteredSectorToColorId);\nstartSectorAngle = maxSectorAngle;\nendSectorAngle = 360.0;\n}\nlowp vec4 outlineColor = outlineColor;\nfloat offset = length(v_offset);\nfloat distanceSize = offset * v_size;\nif (startSectorAngle != 0.0 || endSectorAngle != 360.0) {\nfloat distanceToStartSector = (angle - startSectorAngle);\nfloat distanceToEndSector = (endSectorAngle - angle);\nfloat sectorThreshold = 0.6;\nfloat beginSectorAlpha = smoothstep(0.0, sectorThreshold, distanceToStartSector * offset);\nfloat endSectorAlpha = smoothstep(0.0, sectorThreshold, distanceToEndSector * offset);\nif (endSectorAlpha > 0.0) {\nfillColor = mix(nextColor, fillColor, endSectorAlpha);\n} else if (beginSectorAlpha > 0.0) {\nfillColor = mix(prevColor, fillColor, beginSectorAlpha);\n}\n}\nfloat donutSize = donutRatio * (v_size - v_outlineWidth);\nfloat endOfDonut = donutSize - v_outlineWidth;\nfloat aaThreshold = 0.75;\nfloat innerCircleAlpha = endOfDonut - aaThreshold > 0.0 ? smoothstep(endOfDonut - aaThreshold, endOfDonut + aaThreshold, distanceSize) : 1.0;\nfloat outerCircleAlpha = 1.0 - smoothstep(v_size - aaThreshold, v_size + aaThreshold , distanceSize);\nfloat circleAlpha = innerCircleAlpha * outerCircleAlpha;\nfloat startOfOutline = v_size - v_outlineWidth;\nif (startOfOutline > 0.0 && v_outlineWidth > 0.25) {\nfloat outlineFactor = smoothstep(startOfOutline - aaThreshold, startOfOutline + aaThreshold, distanceSize);\nfloat innerLineFactor = donutSize - aaThreshold > 0.0 ? 1.0 - smoothstep(donutSize - aaThreshold, donutSize + aaThreshold , distanceSize) : 0.0;\nfillColor = mix(fillColor, outlineColor, innerLineFactor + outlineFactor);\n}\nreturn v_opacity * circleAlpha * fillColor;\n}\n#endif\nvoid main()\n{\nvec4 color = getColor();\n#ifdef highlight\ncolor.a = step(1.0 / 255.0, color.a);\n#endif\ngl_FragColor = color;\n}", "pie.vert": "#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <materials/barycentric.glsl>\n#include <materials/vcommon.glsl>\n#include <materials/vv.glsl>\n#include <materials/attributeData.glsl>\n#include <materials/pie/pie.common.glsl>\n#include <materials/hittest/common.glsl>\nattribute float a_bitSet;\nattribute vec2  a_offset;\nattribute vec2  a_texCoords;\nattribute vec2  a_size;\nattribute float a_referenceSize;\nattribute vec2  a_zoomRange;\nint filterValue(in float sectorAngle,\nin int currentIndex,\ninout FilteredChartInfo filteredInfo,\ninout vec2 filteredSectorToColorId[numberOfFields]) {\nif (sectorAngle > sectorThreshold * 360.0) {\nfilteredInfo.endSectorAngle += sectorAngle;\nfilteredSectorToColorId[filteredInfo.colorId] = vec2(filteredInfo.endSectorAngle, currentIndex);\n++filteredInfo.colorId;\n}\nreturn 0;\n}\nint filterValues(inout vec2 filteredSectorToColorId[numberOfFields],\ninout FilteredChartInfo filteredInfo,\nin float sectorAngles[numberOfFields]) {\nfor (int index = 0; index < numberOfFields; ++index) {\nfloat sectorValue = sectorAngles[index];\nfilterValue(sectorValue, index, filteredInfo, filteredSectorToColorId);\n}\nreturn filteredInfo.colorId;\n}\nvec2 getMarkerSize(inout vec2 offset, inout vec2 baseSize, inout float outlineSize, in float a_referenceSize, in float bitSet) {\nvec2 outSize = baseSize;\n#ifdef VV_SIZE\nfloat r = getSize(a_referenceSize, currentScale) / a_referenceSize;\noutSize.xy *= r;\noffset.xy *= r;\nfloat scaleSymbolProportionally = getBit(bitSet, BITSET_MARKER_SCALE_SYMBOLS_PROPORTIONALLY);\noutlineSize *= scaleSymbolProportionally * (r - 1.0) + 1.0;\n#endif\nreturn outSize;\n}\nvec3 getOffset(in vec2 in_offset, float a_bitSet) {\nfloat isMapAligned = getBit(a_bitSet, BITSET_MARKER_ALIGNMENT_MAP);\nvec3  offset       = vec3(in_offset, 0.0);\nreturn getMatrix(isMapAligned) * offset;\n}\nfloat filterNaNValues(in float value) {\nreturn value != NAN_MAGIC_NUMBER && value > 0.0 ? value : 0.0;\n}\nvoid main()\n{\nINIT;\nvec2  a_size   = a_size;\nvec2  a_offset = a_offset / 16.0;\nfloat outlineSize = outlineWidth;\nfloat a_bitSet = a_bitSet;\nfloat a_referenceSize = a_referenceSize;\nvec2 a_texCoords = a_texCoords / 4.0;\nvec2 markerSize = getMarkerSize(a_offset, a_size, outlineSize, a_referenceSize, a_bitSet);\nfloat filterFlags = getFilterFlags();\nvec3  pos         = vec3(a_pos / 10.0, 1.0);\nv_opacity      = getOpacity();\nv_id           = norm(a_id);\nv_pos          = displayViewScreenMat3 * pos + getOffset(a_offset, a_bitSet);\nv_offset       = sign(a_texCoords - 0.5);\nv_size         = max(markerSize.x, markerSize.y);\nv_outlineWidth = outlineSize;\nfloat attributeData[10];\nvec4 attributeData3 = getDataDriven0(a_id);\nattributeData[0] = filterNaNValues(attributeData3.x);\nattributeData[1] = filterNaNValues(attributeData3.y);\nattributeData[2] = filterNaNValues(attributeData3.z);\nattributeData[3] = filterNaNValues(attributeData3.w);\n#if (numberOfFields > 4)\nvec4 attributeData4 = getDataDriven1(a_id);\nattributeData[4] = filterNaNValues(attributeData4.x);\nattributeData[5] = filterNaNValues(attributeData4.y);\nattributeData[6] = filterNaNValues(attributeData4.z);\nattributeData[7] = filterNaNValues(attributeData4.w);\n#endif\n#if (numberOfFields > 8)\nvec4 attributeData5 = getDataDriven2(a_id);\nattributeData[8] = filterNaNValues(attributeData5.x);\nattributeData[9] = filterNaNValues(attributeData5.y);\n#endif\nfloat sum = 0.0;\nfor (int i = 0; i < numberOfFields; ++i) {\nsum += attributeData[i];\n}\nfloat sectorAngles[numberOfFields];\nfor (int i = 0; i < numberOfFields; ++i) {\nsectorAngles[i] = 360.0 * attributeData[i] / sum;\n}\nvec2 filteredSectorToColorId[numberOfFields];\nFilteredChartInfo filteredInfo = FilteredChartInfo(0.0, 0);\nint numOfEntries = filterValues(filteredSectorToColorId, filteredInfo, sectorAngles);\nv_numOfEntries = float(numOfEntries);\nv_maxSectorAngle = filteredInfo.endSectorAngle;\nv_filteredSectorToColorId = filteredSectorToColorId;\n#ifdef HITTEST\nhighp vec3 out_pos = vec3(0.0);\nv_color            = vec4(0.0);\nhittestMarker(v_color, out_pos, viewMat3 * tileMat3 *  pos, v_size);\ngl_PointSize = 1.0;\ngl_Position = vec4(clip(v_color, out_pos, filterFlags, a_zoomRange), 1.0);\n#else\ngl_Position = vec4(clip(v_color, v_pos, filterFlags, a_zoomRange), 1.0);\n#endif\n}" }, shared: { line: { "common.glsl": "#if !defined(SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE) && defined(PATTERN)\nuniform mediump vec2 u_mosaicSize;\nvarying mediump float v_sampleAlphaOnly;\n#endif\nstruct LineData {\nlowp vec4 color;\nmediump vec2 normal;\nmediump float lineHalfWidth;\nlowp float opacity;\n#ifndef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\n#ifdef PATTERN\nmediump vec4 tlbr;\nmediump vec2 patternSize;\n#endif\n#ifdef SDF\nmediump float lineWidthRatio;\n#endif\n#if defined(PATTERN) || defined(SDF)\nhighp float accumulatedDistance;\n#endif\n#endif\nhighp vec3 id;\n};", "line.frag": "uniform lowp float u_blur;\n#if !defined(SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE) && !defined(HIGHLIGHT)\n#if defined(PATTERN) || defined(SDF)\nuniform sampler2D u_texture;\nuniform highp float u_pixelRatio;\n#endif\n#endif\n#if defined(SDF) && !defined(HIGHLIGHT) && !defined(SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE)\nlowp vec4 getLineColor(LineData line) {\nmediump float adjustedPatternWidth = line.patternSize.x * 2.0 * line.lineWidthRatio;\nmediump float relativeTexX = fract(line.accumulatedDistance / adjustedPatternWidth);\nmediump float relativeTexY = 0.5 + 0.25 * line.normal.y;\nmediump vec2 texCoord = mix(line.tlbr.xy, line.tlbr.zw, vec2(relativeTexX, relativeTexY));\nmediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\nfloat dist = d * line.lineHalfWidth;\nreturn line.opacity * clamp(0.5 - dist, 0.0, 1.0) * line.color;\n}\n#elif defined(PATTERN) && !defined(HIGHLIGHT) && !defined(SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE)\nlowp vec4 getLineColor(LineData line) {\nmediump float lineHalfWidth = line.lineHalfWidth;\nmediump float adjustedPatternHeight = line.patternSize.y * 2.0 * lineHalfWidth / line.patternSize.x;\nmediump float relativeTexY = fract(line.accumulatedDistance / adjustedPatternHeight);\nmediump float relativeTexX = 0.5 + 0.5 * line.normal.y;\nmediump vec2 texCoord = mix(line.tlbr.xy, line.tlbr.zw, vec2(relativeTexX, relativeTexY));\nlowp vec4 color = texture2D(u_texture, texCoord);\n#ifdef VV_COLOR\nif (v_sampleAlphaOnly > 0.5) {\ncolor.rgb = vec3(color.a);\n}\n#endif\nreturn line.opacity * line.color * color;\n}\n#else\nlowp vec4 getLineColor(LineData line) {\nreturn line.opacity * line.color;\n}\n#endif\nvec4 shadeLine(LineData line)\n{\nmediump float thinLineFactor = max(THIN_LINE_WIDTH_FACTOR * step(line.lineHalfWidth, THIN_LINE_HALF_WIDTH), 1.0);\nmediump float fragDist = length(line.normal) * line.lineHalfWidth;\nlowp float alpha = clamp(thinLineFactor * (line.lineHalfWidth - fragDist) / (u_blur + thinLineFactor - 1.0), 0.0, 1.0);\nlowp vec4 out_color = getLineColor(line) * alpha;\n#ifdef HIGHLIGHT\nout_color.a = step(1.0 / 255.0, out_color.a);\n#endif\n#ifdef ID\nif (out_color.a < 1.0 / 255.0) {\ndiscard;\n}\nout_color = vec4(line.id, 0.0);\n#endif\nreturn out_color;\n}", "line.vert": "float getBaseLineHalfWidth(in float lineHalfWidth, in float referenceHalfWidth) {\n#ifdef VV_SIZE\nfloat refLineWidth = 2.0 * referenceHalfWidth;\nreturn 0.5 * (lineHalfWidth / max(referenceHalfWidth, EPSILON)) * getSize(refLineWidth);\n#else\nreturn lineHalfWidth;\n#endif\n}\nfloat getLineHalfWidth(in float baseWidth, in float aa) {\nfloat halfWidth = max(baseWidth + aa, 0.45) + 0.1 * aa;\n#ifdef HIGHLIGHT\nhalfWidth = max(halfWidth, 2.0);\n#endif\nreturn halfWidth;\n}\nvec2 getDist(in vec2 offset, in float halfWidth) {\nfloat thinLineFactor = max(THIN_LINE_WIDTH_FACTOR * step(halfWidth, THIN_LINE_HALF_WIDTH), 1.0);\nreturn thinLineFactor * halfWidth * offset;\n}\nLineData buildLine(\nout vec3 out_pos,\nin vec3 in_id,\nin vec2 in_pos,\nin vec4 in_color,\nin vec2 in_offset,\nin vec2 in_normal,\nin float in_accumulatedDist,\nin float in_lineHalfWidth,\nin float in_bitSet,\nin vec4 in_tlbr,\nin vec2 in_segmentDirection,\nin float in_referenceHalfWidth\n)\n{\nfloat aa        = 0.5 * u_antialiasing;\nfloat baseWidth = getBaseLineHalfWidth(in_lineHalfWidth, in_referenceHalfWidth);\nfloat halfWidth = getLineHalfWidth(baseWidth, aa);\nfloat z         = 2.0 * step(baseWidth, 0.0);\nvec2  dist      = getDist(in_offset, halfWidth);\nvec3  offset    = u_displayViewMat3 * vec3(dist, 0.0);\nvec3  pos       = u_dvsMat3 * vec3(in_pos * POSITION_PRECISION, 1.0) + offset;\n#ifdef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\nvec4  color     = in_color;\nfloat opacity   = 1.0;\n#else\nvec4  color     = getColor(in_color, in_bitSet, BITSET_GENERIC_LOCK_COLOR);\nfloat opacity   = getOpacity();\n#ifdef SDF\nconst float SDF_PATTERN_HALF_WIDTH = 15.5;\nfloat scaleDash = getBit(in_bitSet, BITSET_LINE_SCALE_DASH);\nfloat lineWidthRatio = (scaleDash * max(halfWidth - 0.55 * u_antialiasing, 0.25) + (1.0 - scaleDash)) / SDF_PATTERN_HALF_WIDTH;\n#endif\n#endif\n#if !defined(SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE) && defined(PATTERN)\nv_sampleAlphaOnly = getBit(in_bitSet, BITSET_GENERIC_CONSIDER_ALPHA_ONLY);\n#endif\nout_pos = vec3(pos.xy, z);\nreturn LineData(\ncolor,\nin_normal,\nhalfWidth,\nopacity,\n#ifndef SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\n#ifdef PATTERN\nin_tlbr / u_mosaicSize.xyxy,\nvec2(in_tlbr.z - in_tlbr.x, in_tlbr.w - in_tlbr.y),\n#endif\n#ifdef SDF\nlineWidthRatio,\n#endif\n#if defined(PATTERN) || defined(SDF)\nin_accumulatedDist * u_zoomFactor + dot(in_segmentDirection, dist),\n#endif\n#endif\nnorm(in_id)\n);\n}" } }, "symbologyTypeUtils.glsl": "#if SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_OUTLINE_FILL || SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_OUTLINE_FILL_SIMPLE\n#define SYMBOLOGY_TYPE_IS_OUTLINE_FILL_LIKE\n#endif\n#if SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_SIMPLE || SYMBOLOGY_TYPE == SYMBOLOGY_TYPE_OUTLINE_FILL_SIMPLE\n#define SYMBOLOGY_TYPE_IS_SIMPLE_LIKE\n#endif", text: { "common.glsl": "uniform highp vec2 u_mosaicSize;\nvarying highp vec3 v_id;\nvarying mediump vec3 v_pos;\nvarying lowp float v_opacity;\nvarying lowp vec4 v_color;\nvarying highp vec2 v_tex;\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\nvarying lowp float v_transparency;", "hittest.glsl": "#include <materials/hittest/common.glsl>", "text.frag": "precision mediump float;\n#include <materials/text/common.glsl>\nuniform lowp sampler2D u_texture;\n#ifdef HITTEST\nvec4 getColor() {\nreturn v_color;\n}\n#else\nvec4 getColor()\n{\nfloat SDF_CUTOFF = (2.0 / 8.0);\nfloat SDF_BASE_EDGE_DIST = 1.0 - SDF_CUTOFF;\nlowp float dist = texture2D(u_texture, v_tex).a;\nmediump float edge = SDF_BASE_EDGE_DIST - v_edgeDistanceOffset;\n#ifdef HIGHLIGHT\nedge /= 2.0;\n#endif\nlowp float aa = v_antialiasingWidth;\nlowp float alpha = smoothstep(edge - aa, edge + aa, dist);\nreturn alpha * v_color * v_opacity;\n}\n#endif\nvoid main()\n{\ngl_FragColor = getColor();\n}", "text.vert": "precision highp float;\n#include <materials/utils.glsl>\n#include <materials/vcommon.glsl>\n#include <materials/text/common.glsl>\n#include <materials/text/hittest.glsl>\nattribute vec4 a_color;\nattribute vec4 a_haloColor;\nattribute vec4 a_texFontSize;\nattribute vec4 a_aux;\nattribute vec2 a_zoomRange;\nattribute vec2 a_vertexOffset;\nattribute vec2 a_texCoords;\nuniform float u_isHaloPass;\nuniform float u_isBackgroundPass;\nfloat getTextSize(inout vec2 offset, inout float baseSize, in float referenceSize) {\n#ifdef VV_SIZE\nfloat r = getSize(referenceSize) / referenceSize;\nbaseSize *= r;\noffset.xy *= r;\nreturn baseSize;\n#endif\nreturn baseSize;\n}\nvoid main()\n{\nINIT;\nfloat a_isBackground  = a_aux.y;\nfloat a_referenceSize = a_aux.z * a_aux.z / 256.0;\nfloat a_bitSet        = a_aux.w;\nfloat a_fontSize      = a_texFontSize.z;\nvec2  a_offset        = a_vertexOffset * OFFSET_PRECISION;\nvec3  in_pos        = vec3(a_pos * POSITION_PRECISION, 1.0);\nfloat fontSize      = getTextSize(a_offset, a_fontSize, a_referenceSize);\nfloat fontScale     = fontSize / SDF_FONT_SIZE;\nvec3  offset        = getRotation() * vec3(a_offset, 0.0);\nmat3  extrudeMatrix = getBit(a_bitSet, 0) == 1.0 ? u_displayViewMat3 : u_displayMat3;\nfloat isText = 1.0 - a_isBackground;\nfloat isBackground = u_isBackgroundPass * a_isBackground;\nvec4  nonHaloColor  = (isBackground * a_color) + (isText * getColor(a_color, a_bitSet, 1));\nv_color   = u_isHaloPass * a_haloColor + (1.0 - u_isHaloPass) * nonHaloColor;\nv_opacity = getOpacity();\nv_id      = norm(a_id);\nv_tex     = a_texCoords / u_mosaicSize;\nv_pos     = u_dvsMat3 * in_pos + extrudeMatrix * offset;\nfloat isHidden = u_isBackgroundPass * isText + (1.0 - u_isBackgroundPass) * a_isBackground;\nv_pos.z += 2.0 * isHidden;\nv_edgeDistanceOffset = u_isHaloPass * OUTLINE_SCALE * a_texFontSize.w / fontScale / MAX_SDF_DISTANCE;\nv_antialiasingWidth  = 0.105 * SDF_FONT_SIZE / fontSize / u_pixelRatio;\n#ifdef HITTEST\nhighp vec3 out_pos  = vec3(0.);\nv_color = vec4(0.);\nhittestMarker(v_color, out_pos, u_viewMat3 * u_tileMat3 *  vec3(a_pos * POSITION_PRECISION, 1.0)\n+ u_tileMat3 * offset, fontSize / 2.);\ngl_PointSize = 1.;\ngl_Position = vec4(clip(v_color, out_pos, getFilterFlags(), a_zoomRange), 1.0);\n#else\ngl_Position =  vec4(clip(v_color, v_pos, getFilterFlags(), a_zoomRange), 1.0);\n#endif\n}" }, "utils.glsl": "float rshift(in float u32, in int amount) {\nreturn floor(u32 / pow(2.0, float(amount)));\n}\nfloat getBit(in float bitset, in int bitIndex) {\nfloat offset = pow(2.0, float(bitIndex));\nreturn mod(floor(bitset / offset), 2.0);\n}\nconst int maxHighlightReasons = 6;\nfloat getFilterBit(in float bitset, in int bitIndex) {\nreturn getBit(bitset, bitIndex + maxHighlightReasons);\n}\nfloat getHighlightBit(in float bitset, in int bitIndex) {\nreturn getBit(bitset, bitIndex);\n}\nhighp vec3 unpackDisplayIdTexel(in highp vec3 bitset) {\nfloat isAggregate = getBit(bitset.b, 7);\nreturn (1.0 - isAggregate) * bitset + isAggregate * (vec3(bitset.rgb) - vec3(0.0, 0.0, float(0x80)));\n}\nvec4 unpack(in float u32) {\nfloat r = mod(rshift(u32, 0), 255.0);\nfloat g = mod(rshift(u32, 8), 255.0);\nfloat b = mod(rshift(u32, 16), 255.0);\nfloat a = mod(rshift(u32, 24), 255.0);\nreturn vec4(r, g, b, a);\n}\nvec3 norm(in vec3 v) {\nreturn v /= 255.0;\n}\nvec4 norm(in vec4 v) {\nreturn v /= 255.0;\n}\nfloat max4(vec4 target) {\nreturn max(max(max(target.x, target.y), target.z), target.w);\n}\nvec2 unpack_u8_nf32(vec2 bytes) {\nreturn (bytes - 127.0) / 127.0;\n}\nhighp float rand(in vec2 co) {\nhighp float a = 12.9898;\nhighp float b = 78.233;\nhighp float c = 43758.5453;\nhighp float dt = dot(co, vec2(a,b));\nhighp float sn = mod(dt, 3.14);\nreturn fract(sin(sn) * c);\n}", "vcommon.glsl": "#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <materials/attributeData.glsl>\n#include <materials/vv.glsl>\n#include <materials/barycentric.glsl>\nattribute vec2 a_pos;\nattribute highp vec3 a_id;\nuniform highp mat3 displayViewScreenMat3;\nuniform highp mat3 displayViewMat3;\nuniform highp mat3 displayMat3;\nuniform highp mat3 tileMat3;\nuniform highp mat3 viewMat3;\nuniform highp float pixelRatio;\nuniform mediump float zoomFactor;\nuniform mediump float antialiasing;\nuniform mediump float currentScale;\nuniform mediump float currentZoom;\nuniform mediump float metersPerSRUnit;\nuniform mediump float activeReasons;\nuniform mediump float highlightAll;\nvec4 VV_ADATA = vec4(0.0);\nvoid loadVisualVariableData(inout vec4 target) {\ntarget.rgba = getVisualVariableData(a_id);\n}\n#ifdef VV\n#define INIT loadVisualVariableData(VV_ADATA)\n#else\n#define INIT\n#endif\nvec4 getColor(in vec4 a_color, in float a_bitSet, int index) {\n#ifdef VV_COLOR\nfloat isColorLocked   = getBit(a_bitSet, index);\nreturn getVVColor(VV_ADATA[ATTR_VV_COLOR], a_color, isColorLocked);\n#else\nreturn a_color;\n#endif\n}\nfloat getOpacity() {\n#ifdef VV_OPACITY\nreturn getVVOpacity(VV_ADATA[ATTR_VV_OPACITY]);\n#else\nreturn 1.0;\n#endif\n}\nfloat getSize(in float in_size, in float currentScale) {\n#ifdef VV_SIZE\nreturn getVVSize(in_size, VV_ADATA[ATTR_VV_SIZE], currentScale);\n#else\nreturn in_size;\n#endif\n}\nmat3 getRotation() {\n#ifdef VV_ROTATION\nreturn getVVRotationMat3(mod(VV_ADATA[ATTR_VV_ROTATION], 360.0));\n#else\nreturn mat3(1.0);\n#endif\n}\nfloat getFilterFlags() {\n#ifdef IGNORES_SAMPLER_PRECISION\nreturn ceil(getFilterData(a_id).x * 255.0);\n#else\nreturn getFilterData(a_id).x * 255.0;\n#endif\n}\nvec4 getAnimationState() {\nreturn getAnimation(a_id);\n}\nfloat getMinZoom() {\nvec4 data0 = getFilterData(a_id) * 255.0;\nreturn data0.g;\n}\nmat3 getMatrixNoDisplay(float isMapAligned) {\nreturn isMapAligned * viewMat3 * tileMat3 + (1.0 - isMapAligned) * tileMat3;\n}\nmat3 getMatrix(float isMapAligned) {\nreturn isMapAligned * displayViewMat3 + (1.0 - isMapAligned) * displayMat3;\n}\nfloat checkHighlightBit(float filterFlags, int index) {\nreturn getHighlightBit(filterFlags, index) * getBit(activeReasons, index);\n}\nfloat checkHighlight(float filterFlags) {\nfloat result = checkHighlightBit(filterFlags, 0);\nfor (int i = 1; i < maxHighlightReasons; i++) {\nresult = result + checkHighlightBit(filterFlags, i);\n}\nreturn step(0.1, result + highlightAll);\n}\nvec3 clip(inout vec4 color, inout vec3 pos, in float filterFlags, in vec2 minMaxZoom) {\npos.z += 2.0 * (1.0 - getFilterBit(filterFlags, 0));\n#ifdef inside\npos.z += 2.0 * (1.0 - getFilterBit(filterFlags, 1));\n#elif defined(outside)\npos.z += 2.0 * getFilterBit(filterFlags, 1);\n#elif defined(highlight)\npos.z += 2.0 * (1.0 - checkHighlight(filterFlags));\n#endif\npos.z += 2.0 * (step(minMaxZoom.y, currentZoom) + (1.0 - step(minMaxZoom.x, currentZoom)));\nreturn pos;\n}", "vv.glsl": "#if defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n#define VV_SIZE\n#endif\n#if defined(VV_COLOR) || defined(VV_SIZE) || defined(VV_OPACITY) || defined(VV_ROTATION)\n#define VV\n#endif\n#ifdef VV_COLOR\nuniform highp float colorValues[8];\nuniform vec4 colors[8];\n#endif\n#ifdef VV_SIZE_MIN_MAX_VALUE\nuniform highp vec4 minMaxValueAndSize;\n#endif\n#ifdef VV_SIZE_SCALE_STOPS\nuniform highp float values[8];\nuniform float sizes[8];\n#endif\n#ifdef VV_SIZE_FIELD_STOPS\nuniform highp float values[8];\nuniform float sizes[8];\n#endif\n#ifdef VV_SIZE_UNIT_VALUE\nuniform highp float unitMeterRatio;\n#endif\n#ifdef VV_OPACITY\nuniform highp float opacityValues[8];\nuniform float opacities[8];\n#endif\n#ifdef VV_ROTATION\nuniform lowp float rotationType;\n#endif\nbool isNan(float val) {\nreturn (val == NAN_MAGIC_NUMBER);\n}\n#ifdef VV_SIZE_MIN_MAX_VALUE\nfloat getVVMinMaxSize(float sizeValue, float fallback) {\nif (isNan(sizeValue)) {\nreturn fallback;\n}\nfloat interpolationRatio = (sizeValue  - minMaxValueAndSize.x) / (minMaxValueAndSize.y - minMaxValueAndSize.x);\ninterpolationRatio = clamp(interpolationRatio, 0.0, 1.0);\nreturn minMaxValueAndSize.z + interpolationRatio * (minMaxValueAndSize.w - minMaxValueAndSize.z);\n}\n#endif\n#ifdef VV_SIZE_SCALE_STOPS\nfloat getVVScaleStopsSize(float currentScale) {\nfloat outSize;\nif (currentScale <= values[0]) {\noutSize = sizes[0];\n} else {\nif (currentScale >= values[7]) {\noutSize = sizes[7];\n} else {\nint index;\nindex = -1;\nfor (int i = 0; i < 8; i++) {\nif (values[i] > currentScale) {\nindex = i;\nbreak;\n}\n}\nint prevIndex = index - 1;\nfloat a = currentScale - values[prevIndex];\nfloat b = values[index] - values[prevIndex];\noutSize = mix(sizes[prevIndex], sizes[index], a / b);\n}\n}\nreturn outSize;\n}\n#endif\n#ifdef VV_SIZE_FIELD_STOPS\nconst int VV_SIZE_N = 8;\nfloat getVVStopsSize(float sizeValue, float fallback) {\nif (isNan(sizeValue)) {\nreturn fallback;\n}\nif (sizeValue <= values[0]) {\nreturn sizes[0];\n}\nif (sizeValue >= values[VV_SIZE_N - 1]) {\nreturn sizes[VV_SIZE_N - 1];\n}\nfor (int i = 1; i < VV_SIZE_N; ++i) {\nif (values[i] >= sizeValue) {\nfloat f = (sizeValue - values[i-1]) / (values[i] - values[i-1]);\nreturn mix(sizes[i-1], sizes[i], f);\n}\n}\nreturn sizes[VV_SIZE_N - 1];\n}\n#endif\n#ifdef VV_SIZE_UNIT_VALUE\nfloat getVVUnitValue(float sizeValue, float fallback) {\nif (isNan(sizeValue)) {\nreturn fallback;\n}\nreturn sizeValue * (metersPerSRUnit / unitMeterRatio);\n}\n#endif\n#ifdef VV_OPACITY\nconst int VV_OPACITY_N = 8;\nfloat getVVOpacity(float opacityValue) {\nif (isNan(opacityValue)) {\nreturn 1.0;\n}\nif (opacityValue <= opacityValues[0]) {\nreturn opacities[0];\n}\nfor (int i = 1; i < VV_OPACITY_N; ++i) {\nif (opacityValues[i] >= opacityValue) {\nfloat f = (opacityValue - opacityValues[i-1]) / (opacityValues[i] - opacityValues[i-1]);\nreturn mix(opacities[i-1], opacities[i], f);\n}\n}\nreturn opacities[VV_OPACITY_N - 1];\n}\n#endif\n#ifdef VV_ROTATION\nmat4 getVVRotation(float rotationValue) {\nif (isNan(rotationValue)) {\nreturn mat4(1, 0, 0, 0,\n0, 1, 0, 0,\n0, 0, 1, 0,\n0, 0, 0, 1);\n}\nfloat rotation = rotationValue;\nif (rotationType == 1.0) {\nrotation = 90.0 - rotation;\n}\nfloat angle = C_DEG_TO_RAD * rotation;\nfloat sinA = sin(angle);\nfloat cosA = cos(angle);\nreturn mat4(cosA, sinA, 0, 0,\n-sinA,  cosA, 0, 0,\n0,     0, 1, 0,\n0,     0, 0, 1);\n}\nmat3 getVVRotationMat3(float rotationValue) {\nif (isNan(rotationValue)) {\nreturn mat3(1, 0, 0,\n0, 1, 0,\n0, 0, 1);\n}\nfloat rotation = rotationValue;\nif (rotationType == 1.0) {\nrotation = 90.0 - rotation;\n}\nfloat angle = C_DEG_TO_RAD * -rotation;\nfloat sinA = sin(angle);\nfloat cosA = cos(angle);\nreturn mat3(cosA, -sinA, 0,\nsinA, cosA, 0,\n0,    0,    1);\n}\n#endif\n#ifdef VV_COLOR\nconst int VV_COLOR_N = 8;\nvec4 getVVColor(float colorValue, vec4 fallback, float isColorLocked) {\nif (isNan(colorValue) || isColorLocked == 1.0) {\nreturn fallback;\n}\nif (colorValue <= colorValues[0]) {\nreturn colors[0];\n}\nfor (int i = 1; i < VV_COLOR_N; ++i) {\nif (colorValues[i] >= colorValue) {\nfloat f = (colorValue - colorValues[i-1]) / (colorValues[i] - colorValues[i-1]);\nreturn mix(colors[i-1], colors[i], f);\n}\n}\nreturn colors[VV_COLOR_N - 1];\n}\n#endif\nfloat getVVSize(in float size, in float vvSize, in float currentScale)  {\n#ifdef VV_SIZE_MIN_MAX_VALUE\nreturn getVVMinMaxSize(vvSize, size);\n#elif defined(VV_SIZE_SCALE_STOPS)\nfloat outSize = getVVScaleStopsSize(currentScale);\nreturn isNan(outSize) ? size : outSize;\n#elif defined(VV_SIZE_FIELD_STOPS)\nfloat outSize = getVVStopsSize(vvSize, size);\nreturn isNan(outSize) ? size : outSize;\n#elif defined(VV_SIZE_UNIT_VALUE)\nreturn getVVUnitValue(vvSize, size);\n#else\nreturn size;\n#endif\n}" }, "post-processing": { dra: { "dra.frag": "precision mediump float;\nuniform sampler2D u_minColor;\nuniform sampler2D u_maxColor;\nuniform sampler2D u_texture;\nvarying vec2 v_uv;\nvoid main() {\nvec4 minColor = texture2D(u_minColor, vec2(0.5));\nvec4 maxColor = texture2D(u_maxColor, vec2(0.5));\nvec4 color = texture2D(u_texture, v_uv);\nvec3 minColorUnpremultiply = minColor.rgb / minColor.a;\nvec3 maxColorUnpremultiply = maxColor.rgb / maxColor.a;\nvec3 colorUnpremultiply = color.rgb / color.a;\nvec3 range = maxColorUnpremultiply - minColorUnpremultiply;\ngl_FragColor = vec4(color.a * (colorUnpremultiply - minColorUnpremultiply) / range, color.a);\n}", "min-max": { "min-max.frag": "#extension GL_EXT_draw_buffers : require\nprecision mediump float;\n#define CELL_SIZE 2\nuniform sampler2D u_minTexture;\nuniform sampler2D u_maxTexture;\nuniform vec2 u_srcResolution;\nuniform vec2 u_dstResolution;\nvarying vec2 v_uv;\nvoid main() {\nvec2 srcPixel = floor(gl_FragCoord.xy) * float(CELL_SIZE);\nvec2 onePixel = vec2(1.0) / u_srcResolution;\nvec2 uv = (srcPixel + 0.5) / u_srcResolution;\nvec4 minColor = vec4(1.0);\nvec4 maxColor = vec4(0.0);\nfor (int y = 0; y < CELL_SIZE; ++y) {\nfor (int x = 0; x < CELL_SIZE; ++x) {\nvec2 offset = uv + vec2(x, y) * onePixel;\nminColor = min(minColor, texture2D(u_minTexture, offset));\nmaxColor = max(maxColor, texture2D(u_maxTexture, offset));\n}\n}\ngl_FragData[0] = minColor;\ngl_FragData[1] = maxColor;\n}" } }, "edge-detect": { "frei-chen": { "frei-chen.frag": "precision mediump float;\nuniform sampler2D u_colorTexture;\nuniform vec2 u_texSize;\nvarying vec2 v_uv;\nvec2 texel = vec2(1.0 / u_texSize.x, 1.0 / u_texSize.y);\nmat3 G[9];\nconst mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );\nconst mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );\nconst mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );\nconst mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );\nconst mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );\nconst mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );\nconst mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );\nconst mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );\nconst mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );\nvoid main() {\nG[0] = g0,\nG[1] = g1,\nG[2] = g2,\nG[3] = g3,\nG[4] = g4,\nG[5] = g5,\nG[6] = g6,\nG[7] = g7,\nG[8] = g8;\nmat3 I;\nfloat cnv[9];\nvec3 sample;\nfor (float i = 0.0; i < 3.0; i++) {\nfor (float j = 0.0; j < 3.0; j++) {\nsample = texture2D(u_colorTexture, v_uv + texel * vec2(i - 1.0,j - 1.0)).rgb;\nI[int(i)][int(j)] = length(sample);\n}\n}\nfor (int i = 0; i < 9; i++) {\nfloat dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\ncnv[i] = dp3 * dp3;\n}\nfloat M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);\nfloat S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);\ngl_FragColor = vec4(vec3(sqrt(M / S)), texture2D(u_colorTexture, v_uv).a);\n}" }, sobel: { "sobel.frag": "precision mediump float;\nuniform sampler2D u_colorTexture;\nvarying vec2 v_uv;\nuniform vec2 u_texSize;\nvec2 texel = vec2(1.0 / u_texSize.x, 1.0 / u_texSize.y);\nmat3 G[2];\nconst mat3 g0 = mat3( 1.0, 2.0, 1.0, 0.0, 0.0, 0.0, -1.0, -2.0, -1.0 );\nconst mat3 g1 = mat3( 1.0, 0.0, -1.0, 2.0, 0.0, -2.0, 1.0, 0.0, -1.0 );\nvoid main() {\nmat3 I;\nfloat cnv[2];\nvec3 sample;\nG[0] = g0;\nG[1] = g1;\nfor (float i = 0.0; i < 3.0; i++) {\nfor (float j = 0.0; j < 3.0; j++) {\nsample = texture2D( u_colorTexture, v_uv + texel * vec2(i-1.0,j-1.0) ).rgb;\nI[int(i)][int(j)] = length(sample);\n}\n}\nfor (int i = 0; i < 2; i++) {\nfloat dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\ncnv[i] = dp3 * dp3;\n}\ngl_FragColor = vec4(vec3(0.5 * sqrt(cnv[0] * cnv[0] + cnv[1] * cnv[1])), texture2D(u_colorTexture, v_uv).a);\n}" } }, "edge-enhance": { "edge-enhance.frag": "precision mediump float;\nuniform sampler2D u_colorTexture;\nvarying vec2 v_uv;\nuniform vec2 u_texSize;\nvec2 texel = vec2(1.0 / u_texSize.x, 1.0 / u_texSize.y);\nmat3 G[2];\nconst mat3 g0 = mat3( 1.0, 0.0, -1.0, 1.0, 0.0, -1.0, 1.0, 0.0, -1.0 );\nconst mat3 g1 = mat3( 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, -1.0, -1.0, -1.0 );\nvoid main() {\nmat3 I;\nfloat cnv[2];\nvec3 sample;\nG[0] = g0;\nG[1] = g1;\nfor (float i = 0.0; i < 3.0; i++) {\nfor (float j = 0.0; j < 3.0; j++) {\nsample = texture2D( u_colorTexture, v_uv + texel * vec2(i-1.0,j-1.0) ).rgb;\nI[int(i)][int(j)] = length(sample);\n}\n}\nfor (int i = 0; i < 2; i++) {\nfloat dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\ncnv[i] = dp3 * dp3;\n}\nvec4 color = texture2D(u_colorTexture, v_uv);\ngl_FragColor = vec4(0.5 * sqrt(cnv[0] * cnv[0] + cnv[1] * cnv[1]) * color);\n}" }, filterEffect: { "filterEffect.frag": "precision mediump float;\nuniform sampler2D u_colorTexture;\nuniform mat4 u_coefficients;\nvarying vec2 v_uv;\nvoid main() {\nvec4 color = texture2D(u_colorTexture, v_uv);\nvec4 rgbw = u_coefficients * vec4(color.a > 0.0 ? color.rgb / color.a : vec3(0.0), 1.0);\nfloat a = color.a;\ngl_FragColor = vec4(a * rgbw.rgb, a);\n}" }, pp: { "pp.vert": "precision mediump float;\nattribute vec2 a_position;\nvarying vec2 v_uv;\nvoid main() {\ngl_Position = vec4(a_position, 0.0, 1.0);\nv_uv = (a_position + 1.0) / 2.0;\n}" } }, raster: { common: { "common.glsl": "uniform sampler2D u_image;\nuniform int u_bandCount;\nuniform bool u_flipY;\nuniform float u_opacity;\nuniform int u_resampling;\nuniform vec2 u_srcImageSize;\n#ifdef APPLY_PROJECTION\n#include <raster/common/projection.glsl>\n#endif\n#ifdef BICUBIC\n#include <filtering/bicubic.glsl>\n#endif\n#ifdef BILINEAR\n#include <filtering/bilinear.glsl>\n#endif\nvec2 getPixelLocation(vec2 coords) {\nvec2 targetLocation = u_flipY ? vec2(coords.s, 1.0 - coords.t) : coords;\n#ifdef APPLY_PROJECTION\ntargetLocation = projectPixelLocation(targetLocation);\n#endif\nreturn targetLocation;\n}\nbool isOutside(vec2 coords){\nif (coords.t>1.00001 ||coords.t<-0.00001 || coords.s>1.00001 ||coords.s<-0.00001) {\nreturn true;\n} else {\nreturn false;\n}\n}\nvec4 getPixel(vec2 pixelLocation) {\n#ifdef BICUBIC\nvec4 color = sampleBicubicBSpline(u_image, pixelLocation, u_srcImageSize);\n#elif defined(BILINEAR)\nvec4 color = sampleBilinear(u_image, pixelLocation, u_srcImageSize);\n#else\nvec4 color = texture2D(u_image, pixelLocation);\n#endif\nreturn color;\n}", "projection.glsl": "uniform sampler2D u_transformGrid;\nuniform vec2 u_transformSpacing;\nuniform vec2 u_transformGridSize;\nuniform vec2 u_targetImageSize;\nvec2 projectPixelLocation(vec2 coords) {\n#ifdef LOOKUP_PROJECTION\nvec4 pv = texture2D(u_transformGrid, coords);\nreturn vec2(pv.r, pv.g);\n#endif\nvec2 index_image = floor(coords * u_targetImageSize);\nvec2 oneTransformPixel = vec2(0.25 / u_transformGridSize.s, 1.0 / u_transformGridSize.t);\nvec2 index_transform = floor(index_image / u_transformSpacing) / u_transformGridSize;\nvec2 pos = fract((index_image + vec2(0.5, 0.5)) / u_transformSpacing);\nvec2 srcLocation;\nvec2 transform_location = index_transform + oneTransformPixel * 0.5;\nif (pos.s <= pos.t) {\nvec4 ll_abc = texture2D(u_transformGrid, vec2(transform_location.s, transform_location.t));\nvec4 ll_def = texture2D(u_transformGrid, vec2(transform_location.s + oneTransformPixel.s, transform_location.t));\nsrcLocation.s = dot(ll_abc.rgb, vec3(pos, 1.0));\nsrcLocation.t = dot(ll_def.rgb, vec3(pos, 1.0));\n} else {\nvec4 ur_abc = texture2D(u_transformGrid, vec2(transform_location.s + 2.0 * oneTransformPixel.s, transform_location.t));\nvec4 ur_def = texture2D(u_transformGrid, vec2(transform_location.s + 3.0 * oneTransformPixel.s, transform_location.t));\nsrcLocation.s = dot(ur_abc.rgb, vec3(pos, 1.0));\nsrcLocation.t = dot(ur_def.rgb, vec3(pos, 1.0));\n}\nreturn srcLocation;\n}" }, flow: { "getFadeOpacity.glsl": "uniform float u_decayRate;\nuniform float u_fadeToZero;\nfloat getFadeOpacity(float x) {\nfloat cutOff = mix(0.0, exp(-u_decayRate), u_fadeToZero);\nreturn (exp(-u_decayRate * x) - cutOff) / (1.0 - cutOff);\n}", "getFragmentColor.glsl": "vec4 getFragmentColor(vec4 color, float dist, float size, float featheringSize) {\nfloat featheringStart = clamp(0.5 - featheringSize / size, 0.0, 0.5);\nif (dist > featheringStart) {\ncolor *= 1.0 - (dist - featheringStart) / (0.5 - featheringStart);\n}\nreturn color;\n}", imagery: { "imagery.frag": "precision highp float;\nvarying vec2 v_texcoord;\nuniform sampler2D u_texture;\nuniform float u_Min;\nuniform float u_Max;\nuniform float u_featheringSize;\n#include <raster/flow/vv.glsl>\nfloat getIntensity(float v) {\nreturn u_Min + v * (u_Max - u_Min);\n}\nvoid main(void) {\nvec4 sampled = texture2D(u_texture, v_texcoord);\nfloat intensity = getIntensity(sampled.r);\ngl_FragColor = getColor(intensity);\ngl_FragColor.a *= getOpacity(sampled.r);\ngl_FragColor.a *= sampled.a;\ngl_FragColor.rgb *= gl_FragColor.a;\n}", "imagery.vert": "attribute vec2 a_position;\nattribute vec2 a_texcoord;\nuniform mat3 u_dvsMat3;\nvarying vec2 v_texcoord;\nvoid main(void) {\nvec2 xy = (u_dvsMat3 * vec3(a_position, 1.0)).xy;\ngl_Position = vec4(xy, 0.0, 1.0);\nv_texcoord = a_texcoord;\n}" }, particles: { "particles.frag": "precision highp float;\nvarying vec4 v_color;\nvarying vec2 v_texcoord;\nvarying float v_size;\nuniform float u_featheringSize;\n#include <raster/flow/getFragmentColor.glsl>\nvoid main(void) {\ngl_FragColor = getFragmentColor(v_color, length(v_texcoord - 0.5), v_size, u_featheringSize);\n}", "particles.vert": "attribute vec4 a_xyts0;\nattribute vec4 a_xyts1;\nattribute vec4 a_typeIdDurationSeed;\nattribute vec4 a_extrudeInfo;\nuniform mat3 u_dvsMat3;\nuniform mat3 u_displayViewMat3;\nuniform float u_time;\nuniform float u_trailLength;\nuniform float u_flowSpeed;\nvarying vec4 v_color;\nvarying vec2 v_texcoord;\nvarying float v_size;\nuniform float u_featheringSize;\nuniform float u_introFade;\n#include <raster/flow/vv.glsl>\n#include <raster/flow/getFadeOpacity.glsl>\nvoid main(void) {\nvec2 position0 = a_xyts0.xy;\nfloat t0 = a_xyts0.z;\nfloat speed0 = a_xyts0.w;\nvec2 position1 = a_xyts1.xy;\nfloat t1 = a_xyts1.z;\nfloat speed1 = a_xyts1.w;\nfloat type = a_typeIdDurationSeed.x;\nfloat id = a_typeIdDurationSeed.y;\nfloat duration = a_typeIdDurationSeed.z;\nfloat seed = a_typeIdDurationSeed.w;\nvec2 e0 = a_extrudeInfo.xy;\nvec2 e1 = a_extrudeInfo.zw;\nfloat animationPeriod = duration + u_trailLength;\nfloat scaledTime = u_time * u_flowSpeed;\nfloat randomizedTime = scaledTime + seed * animationPeriod;\nfloat t = mod(randomizedTime, animationPeriod);\nfloat fUnclamped = (t - t0) / (t1 - t0);\nfloat f = clamp(fUnclamped, 0.0, 1.0);\nfloat clampedTime = mix(t0, t1, f);\nfloat speed = mix(speed0, speed1, f);\nvec2 extrude;\nvec2 position;\nfloat fadeOpacity;\nfloat introOpacity;\nif (type == 2.0) {\nif (fUnclamped < 0.0 || (fUnclamped > 1.0 && t1 != duration)) {\ngl_Position = vec4(0.0, 0.0, -2.0, 1.0);\nreturn;\n}\nvec2 ortho = mix(e0, e1, f);\nvec2 parallel;\nparallel = normalize(position1 - position0) * 0.5;\nif (id == 1.0) {\nextrude = ortho;\nv_texcoord = vec2(0.5, 0.0);\n} else if (id == 2.0) {\nextrude = -ortho;\nv_texcoord = vec2(0.5, 1.0);\n} else if (id == 3.0) {\nextrude = ortho + parallel;\nv_texcoord = vec2(1.0, 0.0);\n} else if (id == 4.0) {\nextrude = -ortho + parallel;\nv_texcoord = vec2(1.0, 1.0);\n}\nfadeOpacity = getFadeOpacity((t - clampedTime) / u_trailLength);\nintroOpacity = 1.0 - exp(-clampedTime);\nv_size = getSize(speed);\nv_color = getColor(speed);\nv_color.a *= getOpacity(speed);\nposition = mix(position0, position1, f);\n} else {\nif (fUnclamped < 0.0) {\ngl_Position = vec4(0.0, 0.0, -2.0, 1.0);\nreturn;\n}\nif (id == 1.0) {\nextrude = e0;\nv_texcoord = vec2(0.5, 0.0);\nfadeOpacity = getFadeOpacity((t - t0) / u_trailLength);\nintroOpacity = 1.0 - exp(-t0);\nv_size = getSize(speed0);\nv_color = getColor(speed0);\nv_color.a *= getOpacity(speed0);\nposition = position0;\n} else if (id == 2.0) {\nextrude = -e0;\nv_texcoord = vec2(0.5, 1.0);\nfadeOpacity = getFadeOpacity((t - t0) / u_trailLength);\nintroOpacity = 1.0 - exp(-t0);\nv_size = getSize(speed0);\nv_color = getColor(speed0);\nv_color.a *= getOpacity(speed0);\nposition = position0;\n} else if (id == 3.0) {\nextrude = mix(e0, e1, f);\nv_texcoord = vec2(0.5, 0.0);\nfadeOpacity = getFadeOpacity((t - clampedTime) / u_trailLength);\nintroOpacity = 1.0 - exp(-clampedTime);\nv_size = getSize(speed);\nv_color = getColor(speed);\nv_color.a *= getOpacity(speed);\nposition = mix(position0, position1, f);\n} else if (id == 4.0) {\nextrude = -mix(e0, e1, f);\nv_texcoord = vec2(0.5, 1.0);\nfadeOpacity = getFadeOpacity((t - clampedTime) / u_trailLength);\nintroOpacity = 1.0 - exp(-clampedTime);\nv_size = getSize(speed);\nv_color = getColor(speed);\nv_color.a *= getOpacity(speed);\nposition = mix(position0, position1, f);\n}\n}\nvec2 xy = (u_dvsMat3 * vec3(position, 1.0) + u_displayViewMat3 * vec3(extrude * v_size, 0.0)).xy;\ngl_Position = vec4(xy, 0.0, 1.0);\nv_color.a *= fadeOpacity;\nv_color.a *= mix(1.0, introOpacity, u_introFade);\nv_color.rgb *= v_color.a;\n}" }, streamlines: { "streamlines.frag": "precision highp float;\nvarying float v_side;\nvarying float v_time;\nvarying float v_totalTime;\nvarying float v_timeSeed;\nvarying vec4 v_color;\nvarying float v_size;\nuniform float u_time;\nuniform float u_trailLength;\nuniform float u_flowSpeed;\nuniform float u_featheringSize;\nuniform float u_introFade;\n#include <raster/flow/getFragmentColor.glsl>\n#include <raster/flow/getFadeOpacity.glsl>\nvoid main(void) {\nfloat t = mod(v_timeSeed * (v_totalTime + u_trailLength) + u_time * u_flowSpeed, v_totalTime + u_trailLength) - v_time;\nvec4 color = v_color * step(0.0, t) * getFadeOpacity(t / u_trailLength);\ncolor *= mix(1.0, 1.0 - exp(-v_time), u_introFade);\ngl_FragColor = getFragmentColor(color, length((v_side + 1.0) / 2.0 - 0.5), v_size, u_featheringSize);\n}", "streamlines.vert": "attribute vec3 a_positionAndSide;\nattribute vec3 a_timeInfo;\nattribute vec2 a_extrude;\nattribute float a_speed;\nuniform mat3 u_dvsMat3;\nuniform mat3 u_displayViewMat3;\nvarying float v_time;\nvarying float v_totalTime;\nvarying float v_timeSeed;\nvarying vec4 v_color;\nvarying float v_side;\nvarying float v_size;\nuniform float u_featheringSize;\n#include <raster/flow/vv.glsl>\nvoid main(void) {\nvec4 lineColor = getColor(a_speed);\nfloat lineOpacity = getOpacity(a_speed);\nfloat lineSize = getSize(a_speed);\nvec2 position = a_positionAndSide.xy;\nv_side = a_positionAndSide.z;\nvec2 xy = (u_dvsMat3 * vec3(position, 1.0) + u_displayViewMat3 * vec3(a_extrude * lineSize, 0.0)).xy;\ngl_Position = vec4(xy, 0.0, 1.0);\nv_time = a_timeInfo.x;\nv_totalTime = a_timeInfo.y;\nv_timeSeed = a_timeInfo.z;\nv_color = lineColor;\nv_color.a *= lineOpacity;\nv_color.rgb *= v_color.a;\nv_size = lineSize;\n}" }, "vv.glsl": "#define MAX_STOPS 8\n#ifdef VV_COLOR\nuniform float u_color_stops[MAX_STOPS];\nuniform vec4 u_color_values[MAX_STOPS];\nuniform int u_color_count;\n#else\nuniform vec4 u_color;\n#endif\n#ifdef VV_OPACITY\nuniform float u_opacity_stops[MAX_STOPS];\nuniform float u_opacity_values[MAX_STOPS];\nuniform int u_opacity_count;\n#else\nuniform float u_opacity;\n#endif\n#ifdef VV_SIZE\nuniform float u_size_stops[MAX_STOPS];\nuniform float u_size_values[MAX_STOPS];\nuniform int u_size_count;\n#else\nuniform float u_size;\n#endif\nuniform float u_featheringOffset;\nvec4 getColor(float x) {\n#ifdef VV_COLOR\nvec4 color = u_color_values[0];\n{\nfor (int i = 1; i < MAX_STOPS; i++) {\nif (i >= u_color_count) {\nbreak;\n}\nfloat x1 = u_color_stops[i - 1];\nif (x < x1) {\nbreak;\n}\nfloat x2 = u_color_stops[i];\nvec4 y2 = u_color_values[i];\nif (x < x2) {\nvec4 y1 = u_color_values[i - 1];\ncolor = y1 + (y2 - y1) * (x - x1) / (x2 - x1);\n} else {\ncolor = y2;\n}\n}\n}\n#else\nvec4 color = u_color;\n#endif\nreturn color;\n}\nfloat getOpacity(float x) {\n#ifdef VV_OPACITY\nfloat opacity = u_opacity_values[0];\n{\nfor (int i = 1; i < MAX_STOPS; i++) {\nif (i >= u_opacity_count) {\nbreak;\n}\nfloat x1 = u_opacity_stops[i - 1];\nif (x < x1) {\nbreak;\n}\nfloat x2 = u_opacity_stops[i];\nfloat y2 = u_opacity_values[i];\nif (x < x2) {\nfloat y1 = u_opacity_values[i - 1];\nopacity = y1 + (y2 - y1) * (x - x1) / (x2 - x1);\n} else {\nopacity = y2;\n}\n}\n}\n#else\nfloat opacity = u_opacity;\n#endif\nreturn opacity;\n}\nfloat getSize(float x) {\n#ifdef VV_SIZE\nfloat size = u_size_values[0];\n{\nfor (int i = 1; i < MAX_STOPS; i++) {\nif (i >= u_size_count) {\nbreak;\n}\nfloat x1 = u_size_stops[i - 1];\nif (x < x1) {\nbreak;\n}\nfloat x2 = u_size_stops[i];\nfloat y2 = u_size_values[i];\nif (x < x2) {\nfloat y1 = u_size_values[i - 1];\nsize = y1 + (y2 - y1) * (x - x1) / (x2 - x1);\n} else {\nsize = y2;\n}\n}\n}\n#else\nfloat size = u_size;\n#endif\nreturn size + 2.0 * u_featheringSize * u_featheringOffset;\n}" }, magdir: { "magdir.frag": "precision mediump float;\nvarying vec4 v_color;\nuniform lowp float u_opacity;\nvoid main() {\ngl_FragColor = v_color * u_opacity;\n}", "magdir.vert": "precision mediump float;\nattribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_vv;\nuniform highp mat3 u_dvsMat3;\nuniform highp vec2 u_coordScale;\nuniform vec2 u_symbolSize;\nuniform vec2 u_symbolPercentRange;\nuniform vec2 u_dataRange;\nuniform float u_rotation;\nuniform vec4 u_colors[12];\nvarying vec4 v_color;\nvoid main()\n{\nfloat angle = a_offset.y + u_rotation;\n#ifndef ROTATION_GEOGRAPHIC\nangle = 3.14159265359 * 2.0 - angle - 3.14159265359 / 2.0;\n#endif\nvec2 offset = vec2(cos(angle), sin(angle)) * a_offset.x;\n#ifdef DATA_RANGE\nfloat valuePercentage = clamp((a_vv.y - u_dataRange.x) / (u_dataRange.y - u_dataRange.x), 0.0, 1.0);\nfloat sizeRatio = u_symbolPercentRange.x + valuePercentage * (u_symbolPercentRange.y - u_symbolPercentRange.x);\nfloat sizePercentage = clamp(sizeRatio, u_symbolPercentRange.x, u_symbolPercentRange.y);\n#else\nfloat sizePercentage = (u_symbolPercentRange.x + u_symbolPercentRange.y) / 2.0;\n#endif\nvec2 pos = a_pos + offset * sizePercentage * u_symbolSize;\nv_color = u_colors[int(a_vv.x)];\ngl_Position = vec4(u_dvsMat3 * vec3(pos * u_coordScale, 1.0), 1.0);\n}" }, reproject: { "reproject.frag": "precision mediump float;\nvarying vec2 v_texcoord;\n#include <raster/common/common.glsl>\nvoid main() {\nvec2 pixelLocation = getPixelLocation(v_texcoord);\nif (isOutside(pixelLocation)) {\ngl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\nreturn;\n}\nvec4 currentPixel = getPixel(pixelLocation);\ngl_FragColor = vec4(currentPixel.rgb, 1.0) * currentPixel.a * u_opacity;\n}", "reproject.vert": "precision mediump float;\nattribute vec2 a_position;\nvarying highp vec2 v_texcoord;\nvoid main()\n{\nv_texcoord = a_position;\ngl_Position = vec4(2.0 * (a_position - 0.5), 0.0, 1.0);\n}" }, scalar: { "scalar.frag": "precision mediump float;\nuniform lowp float u_opacity;\nvarying vec2 v_pos;\nconst vec4 outlineColor = vec4(0.2, 0.2, 0.2, 1.0);\nconst float outlineSize = 0.02;\nconst float innerRadius = 0.25;\nconst float outerRadius = 0.42;\nconst float innerSquareLength = 0.15;\nvoid main() {\nmediump float dist = length(v_pos);\nmediump float fillalpha1 = smoothstep(outerRadius, outerRadius + outlineSize, dist);\nfillalpha1 *= (1.0-smoothstep(outerRadius + outlineSize, outerRadius + 0.1 + outlineSize, dist));\n#ifdef INNER_CIRCLE\nmediump float fillalpha2 = smoothstep(innerRadius, innerRadius + outlineSize, dist);\nfillalpha2 *= (1.0-smoothstep(innerRadius + outlineSize, innerRadius + 0.1 + outlineSize, dist));\n#else\nmediump float fillalpha2 = (abs(v_pos.x) < innerSquareLength ? 1.0 : 0.0) * (abs(v_pos.y) < innerSquareLength ? 1.0 : 0.0);\n#endif\ngl_FragColor = (fillalpha2 + fillalpha1) * outlineColor * u_opacity;\n}", "scalar.vert": "precision mediump float;\nattribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_vv;\nuniform highp mat3 u_dvsMat3;\nuniform highp vec2 u_coordScale;\nuniform vec2 u_symbolSize;\nuniform vec2 u_symbolPercentRange;\nuniform vec2 u_dataRange;\nvarying vec2 v_pos;\nvoid main()\n{\n#ifdef DATA_RANGE\nfloat valuePercentage = clamp((a_vv.y - u_dataRange.x) / (u_dataRange.y - u_dataRange.x), 0.0, 1.0);\nfloat sizeRatio = u_symbolPercentRange.x + valuePercentage * (u_symbolPercentRange.y - u_symbolPercentRange.x);\nfloat sizePercentage = clamp(sizeRatio, u_symbolPercentRange.x, u_symbolPercentRange.y);\n#else\nfloat sizePercentage = (u_symbolPercentRange.x + u_symbolPercentRange.y) / 2.0;\n#endif\nvec2 size = u_symbolSize * sizePercentage;\nvec2 pos = a_pos + a_offset * size;\nv_pos = a_offset;\ngl_Position = vec4(u_dvsMat3 * vec3(pos * u_coordScale, 1.0), 1.0);\n}" } }, stencil: { "stencil.frag": "void main() {\ngl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n}", "stencil.vert": "attribute vec2 a_pos;\nuniform mat3 u_worldExtent;\nvoid main() {\ngl_Position = vec4(u_worldExtent * vec3(a_pos, 1.0), 1.0);\n}" }, test: { "TestShader.common.glsl": "#ifndef RETURN_RED\nvarying    vec4      v_color;\n#endif\nvarying    vec2      v_offset;", "TestShader.frag": "precision highp float;\n#include <test/TestShader.common.glsl>\nvoid main() {\nif (v_offset.x > -.5 && v_offset.y > -.5 && v_offset.x < .5 && v_offset.y < .5) {\ndiscard;\n}\n#ifdef RETURN_RED\ngl_FragColor = vec4(1., 0., 0., 1.);\n#else\ngl_FragColor = v_color;\n#endif\n}", "TestShader.vert": "const float POS_PRECISION_FACTOR = 10.;\nconst float OFFSET_PRECISION_FACTOR = 10.;\nconst float SIZE_PRECISION_FACTOR = 10.;\nattribute  vec2      a_pos_packed;\nattribute  vec2      a_offset_packed;\nattribute  float     a_size_packed;\n#ifdef DATA_DRIVEN_COLOR\nconst float u_dataDrivenColor_validValues[4] = float[4](0., 0., 1., 0.);\nuniform    vec4      u_dataDrivenColor_colorFallback;\nuniform    vec4      u_dataDrivenColor_color;\n#endif\nuniform    float     u_view_zoomLevel;\n#include <test/TestShader.common.glsl>\n#ifdef DATA_DRIVEN_COLOR\nvec4 getColor(float value) {\nint index = -1;\nfor (int i = 0; i < 4; i++) {\nif (u_dataDrivenColor_validValues[i] == value) {\nindex = i;\nbreak;\n}\n}\nif (index == -1) {\nreturn u_dataDrivenColor_colorFallback;\n}\nreturn u_dataDrivenColor_color;\n}\n#endif\nvoid main() {\nvec2  a_pos = a_pos_packed / POS_PRECISION_FACTOR;\nvec2  a_offset = a_offset_packed / OFFSET_PRECISION_FACTOR;\nfloat a_size = a_size_packed / SIZE_PRECISION_FACTOR;\nvec4 color = vec4(1., 0., 0., 1.);\n#ifdef DATA_DRIVEN_COLOR\ncolor = getColor(1.);\n#endif\nvec2 offsetScaled = a_offset * a_size;\nvec4 pos = vec4(a_pos.xy + offsetScaled, 0., 1.);\ngl_Position = pos;\n#ifndef RETURN_RED\nv_color = color;\n#endif\nv_offset = a_offset;\n}" }, tileInfo: { "tileInfo.frag": "uniform mediump sampler2D u_texture;\nvarying mediump vec2 v_tex;\nvoid main(void) {\nlowp vec4 color = texture2D(u_texture, v_tex);\ncolor.rgb *= color.a;\ngl_FragColor = color;\n}", "tileInfo.vert": "attribute vec2 a_pos;\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_depth;\nuniform mediump vec2 u_coord_ratio;\nuniform mediump vec2 u_delta;\nuniform mediump vec2 u_dimensions;\nvarying mediump vec2 v_tex;\nvoid main() {\nmediump vec2 offset = u_coord_ratio * vec2(u_delta + a_pos * u_dimensions);\nvec3 v_pos = u_dvsMat3 * vec3(offset, 1.0);\ngl_Position = vec4(v_pos.xy, 0.0, 1.0);\nv_tex = a_pos;\n}" }, util: { "atan2.glsl": "float atan2(in float y, in float x) {\nfloat t0, t1, t2, t3, t4;\nt3 = abs(x);\nt1 = abs(y);\nt0 = max(t3, t1);\nt1 = min(t3, t1);\nt3 = 1.0 / t0;\nt3 = t1 * t3;\nt4 = t3 * t3;\nt0 =         - 0.013480470;\nt0 = t0 * t4 + 0.057477314;\nt0 = t0 * t4 - 0.121239071;\nt0 = t0 * t4 + 0.195635925;\nt0 = t0 * t4 - 0.332994597;\nt0 = t0 * t4 + 0.999995630;\nt3 = t0 * t3;\nt3 = (abs(y) > abs(x)) ? 1.570796327 - t3 : t3;\nt3 = x < 0.0 ?  3.141592654 - t3 : t3;\nt3 = y < 0.0 ? -t3 : t3;\nreturn t3;\n}", "encoding.glsl": "const vec4 rgba2float_factors = vec4(\n255.0 / (256.0),\n255.0 / (256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\nreturn dot(rgba, rgba2float_factors);\n}" } };

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/sources/resolver.js
function o7(r14) {
  return function(e16) {
    let o9 = r14;
    return e16.split("/").forEach((r15) => {
      o9 && (o9 = o9[r15]);
    }), o9;
  };
}
var t4 = new e8(o7(e12));
function n12(r14) {
  return t4.resolveIncludes(r14);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/BackgroundPrograms.js
var e13 = { vertexShader: n12("background/background.vert"), fragmentShader: n12("background/background.frag") };

// node_modules/@arcgis/core/views/webgl/VertexAttributeLayouts.js
var r7 = [new t("position", 2, R.UNSIGNED_SHORT, 0, 4)];
var s6 = [new t("a_pos", 2, R.BYTE, 0, 2)];
var n13 = [new t("a_pos", 2, R.BYTE, 0, 4), new t("a_tex", 2, R.BYTE, 2, 4)];
var i5 = n4(r7);

// node_modules/@arcgis/core/views/2d/engine/webgl/TiledDisplayObject.js
var r8 = class extends e10 {
  constructor(t10, e16, s9, r14, o9, n17, h9 = o9, d6 = n17) {
    super(), this.tileDebugInfoTexture = null, this.debugInfo = { display: { length: 0, minOrderedLength: 0, minUnorderedLength: 0, triangleCount: 0 }, memory: { bytesUsed: 0, bytesReserved: 0 } }, this._destroyed = false, this.key = new e2(t10), this.resolution = e16, this.x = s9, this.y = r14, this.width = o9, this.height = n17, this.rangeX = h9, this.rangeY = d6;
  }
  destroy() {
    super.destroy(), this.tileDebugInfoTexture && (this.tileDebugInfoTexture.dispose(), this.tileDebugInfoTexture = null), this._destroyed = true;
  }
  get debugSlot() {
    let t10 = this;
    for (; t10.parent !== this._stage; ) {
      if (!t10.parent) return 0;
      t10 = t10.parent;
    }
    return this._stage.children.indexOf(t10);
  }
  setTransform(s9) {
    const i7 = this.resolution / (s9.resolution * s9.pixelRatio), r14 = this.transforms.tileMat3, [o9, n17] = s9.toScreenNoRotation([0, 0], [this.x, this.y]), h9 = this.width / this.rangeX * i7, d6 = this.height / this.rangeY * i7;
    r2(r14, h9, 0, 0, 0, d6, 0, o9, n17, 1), i3(this.transforms.displayViewScreenMat3, s9.displayViewMat3, r14);
  }
  get destroyed() {
    return this._destroyed;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/AFeatureTile.js
var x = e7();
var M2 = n8();
var j = class extends r8 {
  constructor(t10, s9, i7, r14) {
    super(t10, s9, i7, r14, o4, o4);
  }
  destroy() {
    super.destroy();
  }
  setTransform(m4) {
    const c6 = this.resolution / m4.resolution, h9 = this.transforms.tileMat3, [f5, p2] = m4.toScreenNoRotation([0, 0], [this.x, this.y]), d6 = this.width / this.rangeX * c6, u7 = this.height / this.rangeY * c6;
    r2(h9, d6, 0, 0, 0, u7, 0, f5, p2, 1), i3(this.transforms.displayViewScreenMat3, m4.displayViewMat3, h9);
    const x4 = r3(n6(), d6, 0, 0, u7, f5, p2);
    e4(this.transforms.labelMat2d, m4.viewMat2d, x4);
    const M3 = [0, 0];
    m4.toScreen(M3, [this.x, this.y]);
    const j2 = this.transforms.tileUnitsToPixels;
    o2(j2), M(j2, j2, M3), h(j2, j2, Math.PI * m4.rotation / 180), f(j2, j2, [d6, u7, 1]);
  }
  _createTransforms() {
    return { labelMat2d: n6(), tileMat3: e7(), displayViewScreenMat3: e7(), tileUnitsToPixels: e7() };
  }
  containsScreenPoint(t10, s9, i7) {
    const r14 = i3(x, t10.viewMat3, this.transforms.tileMat3), e16 = s2(x, r14);
    if (null == e16) return true;
    o3(M2, ...s9, 1);
    const a11 = N(M2, M2, e16), n17 = i7 * (this.resolution / t10.resolution);
    return a11[0] >= -n17 && a11[0] < this.width + n17 && a11[1] >= -n17 && a11[1] < this.height + n17;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/FreeList.js
var t5 = class _t {
  constructor(a11) {
    if (this.next = null, !Array.isArray(a11)) return void (this.data = a11);
    this.data = a11[0];
    let e16 = this;
    for (let n17 = 1; n17 < a11.length; n17++) e16.next = new _t([a11[n17]]), e16 = e16.next;
  }
  *values() {
    let t10 = this;
    for (; t10; ) yield t10.data, t10 = t10.next;
  }
  forEach(t10) {
    let a11 = this;
    for (; a11; ) t10(a11.data), a11 = a11.next;
  }
  get last() {
    return this.next ? this.next.last : this;
  }
};
var a4 = class {
  constructor(a11) {
    this._head = null, null != a11 && (this._head = new t5(a11));
  }
  get head() {
    return this._head;
  }
  maxAvailableSpace() {
    if (null == this._head) return 0;
    let t10 = 0;
    return this._head.forEach((a11) => {
      const e16 = a11.end - a11.start;
      t10 = Math.max(t10, e16);
    }), t10;
  }
  firstFit(t10) {
    if (null == this._head) return null;
    let a11 = null, e16 = this._head;
    for (; e16; ) {
      const n17 = e16.data.end - e16.data.start;
      if (n17 === t10) return a11 ? a11.next = e16.next : this._head = e16.next, e16.data.start;
      if (n17 > t10) {
        const a12 = e16.data.start;
        return e16.data.start += t10, a12;
      }
      a11 = e16, e16 = e16.next;
    }
    return null;
  }
  free(a11, e16) {
    const n17 = a11 + e16;
    if (null == this._head) {
      const e17 = new t5({ start: a11, end: n17 });
      return void (this._head = e17);
    }
    if (n17 <= this._head.data.start) {
      if (n17 === this._head.data.start) return void (this._head.data.start -= e16);
      const r15 = new t5({ start: a11, end: n17 });
      return r15.next = this._head, void (this._head = r15);
    }
    let r14 = this._head, d6 = r14.next;
    for (; d6; ) {
      if (d6.data.start >= n17) {
        if (r14.data.end === a11) {
          if (r14.data.end += e16, r14.data.end === d6.data.start) {
            const t10 = d6.data.end - d6.data.start;
            return r14.data.end += t10, void (r14.next = d6.next);
          }
          return;
        }
        if (d6.data.start === n17) return void (d6.data.start -= e16);
        const s10 = new t5({ start: a11, end: n17 });
        return s10.next = r14.next, void (r14.next = s10);
      }
      r14 = d6, d6 = d6.next;
    }
    if (a11 === r14.data.end) return void (r14.data.end += e16);
    const s9 = new t5({ start: a11, end: n17 });
    r14.next = s9;
  }
  clear() {
    this._head = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/PooledUint32Array.js
var e14 = has("esri-2d-log-allocations");
var r9 = class _r {
  static create(t10, e16) {
    const s9 = e16.acquireUint32Array(t10);
    return new _r(s9, e16);
  }
  constructor(t10, e16) {
    this._array = t10, this._pool = e16;
  }
  get array() {
    return this._array;
  }
  get length() {
    return this._array.length;
  }
  getUint32View(t10, e16) {
    return new Uint32Array(this._array.buffer, t10 + this._array.byteOffset, e16);
  }
  expand(t10) {
    if (t10 <= this._array.byteLength) return;
    const e16 = this._pool.acquireUint32Array(t10);
    e16.set(this._array), this._pool.releaseUint32Array(this._array), this._array = e16;
  }
  destroy() {
    this._pool.releaseUint32Array(this._array);
  }
};
var s7 = class _s {
  constructor() {
    this._data = new ArrayBuffer(_s.BYTE_LENGTH), this._freeList = new a4({ start: 0, end: this._data.byteLength });
  }
  static get BYTE_LENGTH() {
    return 16e6;
  }
  get buffer() {
    return this._data;
  }
  acquireUint32Array(t10) {
    const e16 = this._freeList.firstFit(t10);
    return null == e16 ? null : new Uint32Array(this._data, e16, t10 / Uint32Array.BYTES_PER_ELEMENT);
  }
  releaseUint32Array(t10) {
    this._freeList.free(t10.byteOffset, t10.byteLength);
  }
};
var a5 = class {
  constructor() {
    this._pages = [], this._pagesByBuffer = /* @__PURE__ */ new Map(), this._bytesAllocated = 0;
  }
  destroy() {
    this._pages = [], this._pagesByBuffer = null;
  }
  get _bytesTotal() {
    return this._pages.length * s7.BYTE_LENGTH;
  }
  acquireUint32Array(t10) {
    return this._bytesAllocated += t10, e14 && console.log(`Allocating ${t10}, (${this._bytesAllocated} / ${this._bytesTotal})`), new Uint32Array(t10 / Uint32Array.BYTES_PER_ELEMENT);
  }
  releaseUint32Array(t10) {
    this._bytesAllocated -= t10.byteLength, e14 && console.log(`Freeing ${t10.byteLength}, (${this._bytesAllocated} / ${this._bytesTotal})`);
  }
  _addPage() {
    const t10 = new s7();
    return this._pages.push(t10), this._pagesByBuffer.set(t10.buffer, t10), t10;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/Buffer.js
var d2 = 1.25;
var u3 = 32767;
var f3 = u3 << 16 | u3;
var o8 = class {
  constructor(t10, i7, r14, e16) {
    this.bufferType = t10, this.size = i7, this.strideInt = r14, this._pool = e16, this._cpu = r9.create(i7 * r14 * Uint32Array.BYTES_PER_ELEMENT, this._pool), this.dirty = { start: 1 / 0, end: 0 }, this.memoryStats = { bytesUsed: 0, bytesReserved: i7 * r14 * Uint32Array.BYTES_PER_ELEMENT }, this.clear();
  }
  get elementSize() {
    return this._cpu.length / this.strideInt;
  }
  get intSize() {
    return this.fillPointer * this.strideInt;
  }
  get byteSize() {
    return this.intSize * Uint32Array.BYTES_PER_ELEMENT;
  }
  get invalidated() {
    return this.bufferSize > 0 && !this._gpu;
  }
  get invalidatedComputeBuffer() {
    return this.bufferSize > 0 && !this._gpuComputeTriangles;
  }
  get usedMemory() {
    return this._cpu.array.byteLength;
  }
  invalidate() {
    this._invalidateTriangleBuffer(), this._gpu?.dispose(), this._gpu = null;
  }
  _invalidateTriangleBuffer() {
    this._gpuComputeTriangles?.dispose(), this._gpuComputeTriangles = null;
  }
  destroy() {
    this._gpu?.dispose(), this._gpuComputeTriangles?.dispose(), this._cpu?.destroy();
  }
  clear() {
    this.dirty.start = 1 / 0, this.dirty.end = 0, this.freeList = new a4({ start: 0, end: this._cpu.length / this.strideInt }), this.fillPointer = 0;
  }
  ensure(t10) {
    if (this.maxAvailableSpace() >= t10) return;
    if (t10 * this.strideInt > this._cpu.length - this.fillPointer) {
      this.invalidate();
      const i7 = this._cpu.length / this.strideInt, r14 = Math.round((i7 + t10) * d2), e16 = r14 * this.strideInt;
      this._cpu.expand(e16 * Uint32Array.BYTES_PER_ELEMENT), this.freeList.free(i7, r14 - i7), this.memoryStats.bytesReserved += (r14 - i7) * this.strideInt * Uint32Array.BYTES_PER_ELEMENT;
    }
  }
  setU32(t10, i7) {
    this._cpu.array[t10] !== i7 && (this._cpu.array[t10] = i7, this.dirty.start = Math.min(t10, this.dirty.start), this.dirty.end = Math.max(t10 + 1, this.dirty.end));
  }
  setF32(t10, i7) {
    this.setU32(t10, a(i7));
  }
  setF32Range(t10, i7, e16) {
    const s9 = a(e16);
    this._cpu.array.fill(s9, t10, i7), this.dirty.start = Math.min(t10, this.dirty.start), this.dirty.end = Math.max(i7, this.dirty.end);
  }
  getF32(t10) {
    return h2(this._cpu.array[t10]);
  }
  getVertexBuffer(t10, i7) {
    return "vertex" === this.bufferType ? this._getGPUBuffer(t10, i7) : null;
  }
  getIndexBuffer(t10, i7) {
    return "index" === this.bufferType ? this._getGPUBuffer(t10, null, i7) : null;
  }
  _getGPUBuffer(t10, i7, r14 = false) {
    if (this.bufferSize) {
      if (r14) {
        if ("index" !== this.bufferType) throw new Error("Tried to get triangle buffer, but target is not an index buffer");
        return null == this._gpuComputeTriangles && (this._gpuComputeTriangles = this._createComputeBuffer(t10)), this._gpuComputeTriangles;
      }
      return this._gpu ??= "index" === this.bufferType ? o5.createIndex(t10, 35048, this._cpu.array) : i7 && new r5(t10, i7, this._cpu.array, 35048), this._gpu;
    }
  }
  getView(t10, i7) {
    return this._cpu.getUint32View(t10, i7 / Uint32Array.BYTES_PER_ELEMENT);
  }
  get bufferSize() {
    return this._cpu.length / this.strideInt;
  }
  maxAvailableSpace() {
    return this.freeList.maxAvailableSpace();
  }
  insert(r14, e16, s9, n17) {
    const h9 = s9 * this.strideInt;
    if (!h9) return 0;
    const a11 = e16 * this.strideInt * Uint32Array.BYTES_PER_ELEMENT, d6 = new Uint32Array(d(r14), a11, h9), u7 = this.freeList.firstFit(s9);
    n(u7, "First fit region must be defined");
    const f5 = u7 * this.strideInt, o9 = h9;
    if (this._cpu.array.set(d6, f5), 0 !== n17) for (let t10 = 0; t10 < d6.length; t10++) this._cpu.array[t10 + f5] += n17;
    return this.dirty.start = Math.min(this.dirty.start, f5), this.dirty.end = Math.max(this.dirty.end, f5 + o9), this.fillPointer = Math.max(this.fillPointer, f5 + o9), this.memoryStats.bytesUsed += s9 * this.strideInt * Uint32Array.BYTES_PER_ELEMENT, u7;
  }
  copyFrom(i7, r14, e16, s9, n17) {
    const h9 = e16 * this.strideInt;
    if (!h9) return 0;
    const a11 = r14 * this.strideInt * Uint32Array.BYTES_PER_ELEMENT, d6 = i7._cpu.getUint32View(a11, h9), u7 = this.freeList.firstFit(e16);
    n(u7, "First fit region must be defined");
    const f5 = u7 * this.strideInt, o9 = h9;
    if (this._cpu.array.set(d6, f5), 0 !== s9) for (let t10 = 0; t10 < h9; t10++) this._cpu.array[f5 + t10 * this.strideInt + n17] += s9;
    return this.dirty.start = Math.min(this.dirty.start, f5), this.dirty.end = Math.max(this.dirty.end, f5 + o9), this.fillPointer = Math.max(this.fillPointer, f5 + o9), this.memoryStats.bytesUsed += e16 * this.strideInt * Uint32Array.BYTES_PER_ELEMENT, u7;
  }
  free(t10, i7, r14) {
    const e16 = t10 * this.strideInt, s9 = (t10 + i7) * this.strideInt;
    if (true === r14) for (let n17 = t10; n17 !== t10 + i7; n17++) this._cpu.array[n17 * this.strideInt] = f3;
    this.dirty.start = Math.min(this.dirty.start, e16), this.dirty.end = Math.max(this.dirty.end, s9), this.freeList.free(t10, i7), this.memoryStats.bytesUsed -= i7 * this.strideInt * Uint32Array.BYTES_PER_ELEMENT;
  }
  upload() {
    if (this.dirty.end) {
      if (this._invalidateTriangleBuffer(), null == this._gpu) return this.dirty.start = 1 / 0, void (this.dirty.end = 0);
      this._gpu.setSubData(this._cpu.array, this.dirty.start, this.dirty.start, this.dirty.end), this.dirty.start = 1 / 0, this.dirty.end = 0;
    }
  }
  reshuffle(t10, i7) {
    if (0 === i7.length) return;
    const r14 = this.byteSize, e16 = t10 * this.strideInt * Uint32Array.BYTES_PER_ELEMENT, n17 = r14 > e16, h9 = this._cpu, a11 = r9.create(e16, this._pool);
    n17 || a11.array.set(this._cpu.getUint32View(0, this.intSize));
    for (const s9 of i7) if (n17 || s9.srcFrom !== s9.dstFrom || 0 !== s9.mutate) {
      this.dirty.start = Math.min(this.dirty.start, s9.dstFrom * this.strideInt), this.dirty.end = Math.max(this.dirty.end, (s9.dstFrom + s9.count) * this.strideInt);
      for (let t11 = 0; t11 < s9.count; t11++) {
        const i8 = (s9.dstFrom + t11) * this.strideInt, r15 = (s9.srcFrom + t11) * this.strideInt;
        for (let t12 = 0; t12 < this.strideInt; t12++) a11.array[i8 + t12] = h9.array[r15 + t12] + s9.mutate;
      }
    }
    this._cpu.destroy(), this._cpu = a11, n17 && this.invalidate(), this.freeList.clear(), this.memoryStats.bytesUsed = this.memoryStats.bytesReserved = e16;
  }
  _createComputeBuffer(t10) {
    const i7 = 35048, r14 = new Uint32Array(this.fillPointer / 3);
    for (let e16 = 0; e16 < this.fillPointer; e16 += 3) r14[e16 / 3] = this._cpu.array[e16];
    return o5.createIndex(t10, i7, r14);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/MappedMesh.js
var a6 = 1e3;
var h6 = 4;
var l3 = [{ name: "visibility", offset: 0, type: R.FLOAT, count: 1 }];
var d3 = { hash: t2(l3), attributes: l3, stride: h6 };
function _3(t10, i7) {
  return c(t10.attributes, (e16, t11) => e16.name === t11.name).filter((e16) => i7.locations.has(e16.name)).map((e16) => ({ name: e16.name, type: e16.type, count: e16.count, divisor: 0, normalized: e16.normalized ?? false, offset: e16.offset, stride: t10.stride })).sort((e16, t11) => i7.locations.get(e16.name) - i7.locations.get(t11.name));
}
function m(t10, i7) {
  const r14 = [], s9 = c(t10.attributes, (e16, t11) => e16.name === t11.name).filter((e16) => i7.locations.has(e16.name));
  for (const e16 of s9) {
    r14.push({ name: e16.name, type: e16.type, count: e16.count, divisor: 0, normalized: e16.normalized ?? false, offset: e16.offset, stride: t10.stride });
    const s10 = i7.computeAttributeMap[e16.name];
    null != s10 && 2 === s10.length && (r14.push({ name: s10[0], count: e16.count, divisor: 0, type: e16.type, normalized: e16.normalized ?? false, offset: e16.offset + t10.stride, stride: t10.stride }), r14.push({ name: s10[1], count: e16.count, divisor: 0, type: e16.type, normalized: e16.normalized ?? false, offset: e16.offset + 2 * t10.stride, stride: t10.stride }));
  }
  return r14.sort((e16, t11) => i7.locations.get(e16.name) - i7.locations.get(t11.name));
}
var y2 = class {
  constructor(e16, t10, i7) {
    if (this._bufferPool = e16, this._layout = t10, this.useVisibility = i7, this._invalidatedGeometry = false, this._invalidatedCompute = false, this._position = this._layout.attributes.find((e17) => "pos" === e17.name || "position" === e17.name), !this._position) throw new Error("InternalError: Unable to find position attribute");
  }
  destroy() {
    this._indexBuffer = u(this._indexBuffer), this._vertexBuffer = u(this._vertexBuffer), this._visibilityBuffer = u(this._visibilityBuffer), this._computeVAO?.disposeVAOOnly(), this._geometryVAO?.disposeVAOOnly();
  }
  get layout() {
    return this._layout;
  }
  get usedMemory() {
    let e16 = 0;
    return e16 += this._indexBuffer.usedMemory, e16 += this._vertexBuffer.usedMemory, null != this._visibilityBuffer && (e16 += this._visibilityBuffer.usedMemory), e16;
  }
  getDrawArgs(e16, t10, i7, r14) {
    return r14 ? { primitive: _.POINTS, count: t10 / 3, offset: i7 / 3 } : { primitive: e16, count: t10, offset: i7 };
  }
  getAttributePrecisionPackFactors() {
    const e16 = {};
    for (const t10 of this.layout.attributes) t10.packPrecisionFactor && (e16[t10.name] = t10.packPrecisionFactor);
    return e16;
  }
  getDebugVertexInfo(e16 = false, t10) {
    if (!this._vertexBuffer) return null;
    const i7 = this._layout, r14 = i7.stride, f5 = this._vertexBuffer.getView(0, this._vertexBuffer.byteSize), o9 = [];
    if (e16) if (null == t10) console.log("must provide location info to see compute attributes");
    else for (const s9 of i7.attributes) {
      const e17 = t10.computeAttributeMap[s9.name];
      null != e17 && 2 === e17.length && (o9.push({ ...s9, name: e17[0], offset: s9.offset + r14 }), o9.push({ ...s9, name: e17[1], offset: s9.offset + 2 * r14 }));
    }
    const n17 = new DataView(f5.slice().buffer);
    let u7 = f5.byteLength / r14;
    e16 && (u7 = this._indexBuffer.fillPointer / 3);
    const a11 = this._indexBuffer.getView(0, this._indexBuffer.byteSize);
    let h9 = 0;
    const l7 = [];
    for (let d6 = 0; d6 < u7; d6++) {
      if (e16) {
        h9 = a11[3 * d6] * r14;
      }
      const t11 = {};
      for (const e17 of [...i7.attributes, ...o9]) {
        let i8 = `${e17.offset} ${e17.name}`, r15 = s4(n17, e17, h9);
        if (e17.packPrecisionFactor) if (i8 += ` (precision: ${e17.packPrecisionFactor})`, "number" == typeof r15) r15 /= e17.packPrecisionFactor;
        else for (let t12 = 0; t12 < r15.length; t12++) r15[t12] /= e17.packPrecisionFactor;
        t11[i8] = r15;
      }
      h9 += r14, l7.push(t11);
    }
    return { vertices: l7, layout: i7 };
  }
  _ensure(e16, t10) {
    if (this._vertexBuffer && this._indexBuffer) this._indexBuffer.ensure(Math.max(e16, a6)), this._vertexBuffer.ensure(Math.max(t10, a6)), this._visibilityBuffer && this._visibilityBuffer.ensure(Math.max(t10, a6));
    else {
      const i7 = this._layout.stride / Uint32Array.BYTES_PER_ELEMENT;
      this._indexBuffer = new o8("index", Math.max(e16, a6), 1, this._bufferPool), this._vertexBuffer = new o8("vertex", Math.max(t10, a6), i7, this._bufferPool), this.useVisibility && (this._visibilityBuffer = new o8("vertex", Math.max(t10, a6), h6 / Uint32Array.BYTES_PER_ELEMENT, this._bufferPool));
    }
  }
  append(e16) {
    const t10 = e16.layout.stride, i7 = e16.indices.byteLength / Uint32Array.BYTES_PER_ELEMENT, r14 = e16.vertices.byteLength / t10;
    this._ensure(i7, r14);
    const { vertices: s9, indices: f5 } = e16, o9 = this._vertexBuffer.insert(s9, 0, s9.byteLength / t10, 0), n17 = new Uint32Array(r14);
    new Float32Array(n17.buffer).fill(255), this._visibilityBuffer && this._visibilityBuffer.insert(n17, 0, n17.byteLength / h6, 0);
    return { vertexFrom: o9, indexFrom: this._indexBuffer.insert(f5, 0, f5.byteLength / 4, o9) };
  }
  setEntityRecordRangeVisibility(e16, t10, i7, r14) {
    if (null != this._visibilityBuffer && !(t10 + i7 > e16.length)) for (let s9 = t10; s9 < t10 + i7; s9++) {
      const { vertexStart: t11, vertexCount: i8 } = e16[s9];
      this._visibilityBuffer.setF32Range(t11, t11 + i8, r14);
    }
  }
  getEntityRecordVisibility(e16, t10) {
    if (null == this._visibilityBuffer) return 0;
    const i7 = e16.records[t10];
    return this._visibilityBuffer.getF32(i7.vertexStart);
  }
  copyRecordFrom(e16, t10, r14, s9) {
    const { indexStart: f5, indexCount: o9, vertexStart: n17, vertexCount: u7 } = t10;
    this._ensure(o9, u7);
    const a11 = e16._position, h9 = r14 * (a11.packPrecisionFactor ?? 1), l7 = s9 * (a11.packPrecisionFactor ?? 1), d6 = a11.offset, _5 = s3(h9, l7), m4 = this._vertexBuffer.copyFrom(e16._vertexBuffer, n17, u7, _5, d6);
    this._visibilityBuffer && e16._visibilityBuffer && this._visibilityBuffer.copyFrom(e16._visibilityBuffer, n17, u7, 0, 0);
    const y3 = this._indexBuffer.copyFrom(e16._indexBuffer, f5, o9, m4 - n17, 0), v = t10.clone();
    return v.vertexStart = m4, v.indexStart = y3, v.overlaps = 0, v;
  }
  remove(e16, t10, i7, r14) {
    this._indexBuffer.free(e16, t10), this._vertexBuffer.free(i7, r14), this._visibilityBuffer && this._visibilityBuffer.free(i7, r14);
  }
  upload() {
    this._invalidatedGeometry = true, this._invalidatedCompute = true;
  }
  getGeometryVAO(e16, t10) {
    if (!this._vertexBuffer || !this._indexBuffer || !this._vertexBuffer.bufferSize) return null;
    if (this._invalidatedGeometry) {
      if ((this._vertexBuffer.invalidated || this._indexBuffer.invalidated || this._visibilityBuffer?.invalidated) && (this._vertexBuffer.invalidate(), this._indexBuffer.invalidate(), this._visibilityBuffer && this._visibilityBuffer.invalidate(), this._geometryVAO?.disposeVAOOnly(), this._geometryVAO = null), this._vertexBuffer.upload(), this._indexBuffer.upload(), this._visibilityBuffer && this._visibilityBuffer.upload(), !this._geometryVAO) {
        const i7 = this._indexBuffer.getIndexBuffer(e16, false), r14 = /* @__PURE__ */ new Map([["geometry", this._vertexBuffer.getVertexBuffer(e16, _3(this.layout, t10))]]);
        this._visibilityBuffer && r14.set("visibility", this._visibilityBuffer.getVertexBuffer(e16, _3(d3, t10))), this._geometryVAO = new h5(e16, r14, i7);
      }
      this._invalidatedGeometry = false;
    }
    return this._geometryVAO;
  }
  getComputeVAO(e16, t10) {
    if (!this._vertexBuffer || !this._indexBuffer || !this._vertexBuffer.bufferSize) return null;
    if (this._invalidatedCompute && ((this._vertexBuffer.invalidated || this._indexBuffer.invalidatedComputeBuffer) && (this._vertexBuffer.invalidate(), this._indexBuffer.invalidate(), this._visibilityBuffer?.invalidate(), this._computeVAO?.disposeVAOOnly(), this._computeVAO = null), this._vertexBuffer.upload(), this._indexBuffer.upload(), this._visibilityBuffer?.upload(), !this._computeVAO)) {
      const i7 = this._indexBuffer.getIndexBuffer(e16, true), r14 = /* @__PURE__ */ new Map([["geometry", this._vertexBuffer.getVertexBuffer(e16, m(this.layout, t10))]]);
      this._visibilityBuffer && r14.set("visibility", this._visibilityBuffer.getVertexBuffer(e16, _3(d3, t10))), this._computeVAO = new h5(e16, r14, i7), this._invalidatedCompute = false;
    }
    return this._computeVAO;
  }
  get memoryStats() {
    return { bytesUsed: this._vertexBuffer.memoryStats.bytesUsed + this._indexBuffer.memoryStats.bytesUsed, bytesReserved: this._vertexBuffer.memoryStats.bytesReserved + this._indexBuffer.memoryStats.bytesReserved, vertex: this._vertexBuffer.memoryStats, index: this._indexBuffer.memoryStats };
  }
  reshuffle(e16) {
    this._vertexBuffer && this._vertexBuffer.reshuffle(e16.vertex.count, e16.vertex.operations), this._indexBuffer && this._indexBuffer.reshuffle(e16.index.count, e16.index.operations), this._visibilityBuffer && this._visibilityBuffer.reshuffle(e16.vertex.count, e16.vertex.operations);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/TileInfoPrograms.js
var r10 = { vertexShader: n12("tileInfo/tileInfo.vert"), fragmentShader: n12("tileInfo/tileInfo.frag") };

// node_modules/@arcgis/core/views/2d/engine/webgl/FeatureDisplayList.js
function a7(t10, e16) {
  return t10 << 16 | 255 & e16;
}
function r11(t10) {
  return 255 & t10;
}
var d4 = class {
  constructor(t10, e16, n17, i7, s9) {
    this.instance = t10, this.materialKey = e16, this.target = n17, this.start = i7, this.count = s9;
  }
  get textureKey() {
    return r11(this.materialKey);
  }
  get indexEnd() {
    return this.start + this.count;
  }
  extend(t10) {
    this.count += t10;
  }
  render(t10) {
    this.instance.techniqueRef.render(t10, this);
  }
  getStencilReference() {
    return this.target.stencilRef;
  }
  getAttributePrecisionPackFactors() {
    const t10 = this.instance.instanceId;
    return this.target.getMesh(t10).getAttributePrecisionPackFactors();
  }
  draw(t10, e16) {
    a2(t10) ? this.drawCompute(t10.context, e16) : this.drawGeometry(t10.context, e16);
  }
  drawCompute(t10, e16) {
    const n17 = this.instance.instanceId, a11 = this.target.getMesh(n17).getComputeVAO(t10, e16), r14 = this.start * Uint32Array.BYTES_PER_ELEMENT / 3;
    t10.bindVAO(a11, e16.locations), t10.drawElements(_.POINTS, this.count / 3, R.UNSIGNED_INT, r14), t10.bindVAO(null);
  }
  drawGeometry(t10, e16) {
    const n17 = this.instance.instanceId, a11 = this.target.getMesh(n17).getGeometryVAO(t10, e16), r14 = this.start * Uint32Array.BYTES_PER_ELEMENT;
    t10.bindVAO(a11, e16.locations), t10.drawElements(_.TRIANGLES, this.count, R.UNSIGNED_INT, r14), t10.bindVAO(null);
  }
};
var h7 = class _h {
  constructor() {
    this._length = 0, this._minOrderedLength = 0, this._materialKeys = /* @__PURE__ */ new Set();
  }
  static fromDisplayEntities(t10, e16, n17, i7) {
    const s9 = new _h();
    for (const r14 of t10.values()) for (const t11 of r14.records) {
      const r15 = n17.getInstance(t11.instanceId), d6 = a7(r15.instanceId, t11.textureKey);
      s9.addRecord(r15, d6, t11.indexStart, t11.indexCount, t11.vertexStart, t11.vertexCount, e16, i7);
    }
    return s9;
  }
  get length() {
    return this._length;
  }
  get minOrderedLength() {
    return this._minOrderedLength;
  }
  get minUnorderedLength() {
    return this._materialKeys.size;
  }
  get usedMemory() {
    return this._length ? 5 * this._length * n2 : 0;
  }
  render(t10, e16) {
    const { drawPhase: n17 } = t10;
    for (const i7 of this.infos()) {
      const s9 = i7.instance.techniqueRef;
      s9.drawPhase & n17 && (null == e16 || s9.type === e16) && i7.render(t10);
    }
  }
  addRecord(t10, n17, i7, s9, a11, r14, h9, o9) {
    let l7 = i7, c6 = s9;
    if (c6 || (l7 = a11, c6 = r14), !c6) return;
    if (null == this._head) {
      const i8 = new d4(t10, n17, h9, l7, c6);
      return this._head = new t5(i8), this._tail = this._head, this._length++, void this._minOrderedLength++;
    }
    if (1 === o9) return this._insert(t10, n17, h9, l7, c6, this._tail, null);
    let u7 = null, _5 = this._head;
    const g3 = t10.instanceId, m4 = t10.techniqueRef.symbologyPlane;
    if (2 === o9 && (2 === m4 || 3 === m4)) return this._insert(t10, n17, h9, l7, c6, this._tail, null);
    for (; _5; ) {
      const e16 = _5.data.instance, i8 = e16.instanceId, s10 = e16.techniqueRef.symbologyPlane, a12 = u7?.data.instance.instanceId;
      if (m4 < s10 || g3 === a12 && g3 !== i8) return this._insert(t10, n17, h9, l7, c6, u7, _5);
      u7 = _5, _5 = _5.next;
    }
    this._insert(t10, n17, h9, l7, c6, u7, null);
  }
  *infos() {
    if (null != this._head) for (const t10 of this._head.values()) yield t10;
  }
  _insert(t10, n17, i7, s9, a11, r14, h9) {
    if (null == r14 && null == h9) {
      const r15 = new d4(t10, n17, i7, s9, a11);
      return this._head = new t5(r15), this._tail = this._head, this._length++, void this._minOrderedLength++;
    }
    return n17 !== this._tail.data.materialKey && this._minOrderedLength++, this._materialKeys.add(n17), null == r14 && null != h9 ? this._insertAtHead(t10, n17, i7, s9, a11, h9) : null != r14 && null == h9 ? this._insertAtEnd(t10, n17, i7, s9, a11, r14) : null != r14 && null != h9 ? this._insertAtMiddle(t10, n17, i7, s9, a11, r14, h9) : void 0;
  }
  _insertAtHead(t10, n17, i7, s9, a11, r14) {
    const h9 = s9 + a11;
    if (n17 === r14.data.materialKey && i7 === r14.data.target && h9 === r14.data.start) r14.data.start = s9, r14.data.count += a11;
    else {
      const h10 = new d4(t10, n17, i7, s9, a11);
      this._head = new t5(h10), this._head.next = r14, this._length++;
    }
  }
  _insertAtEnd(t10, n17, i7, s9, a11, r14) {
    if (r14.data.materialKey === n17 && r14.data.indexEnd === s9) r14.data.count += a11;
    else {
      const h9 = new d4(t10, n17, i7, s9, a11);
      this._tail = new t5(h9), r14.next = this._tail, this._length++;
    }
  }
  _insertAtMiddle(t10, n17, i7, s9, a11, r14, h9) {
    const o9 = s9 + a11;
    if (r14.data.materialKey === n17 && r14.data.target === i7 && r14.data.indexEnd === s9) r14.data.count += a11, r14.data.materialKey === h9.data.materialKey && r14.data.target === h9.data.target && r14.data.indexEnd === h9.data.start && (r14.data.count += h9.data.count, r14.next = h9.next, this._length--);
    else if (n17 === h9.data.materialKey && i7 === h9.data.target && o9 === h9.data.start) h9.data.start = s9, h9.data.count += a11;
    else {
      const o10 = new d4(t10, n17, i7, s9, a11), l7 = new t5(o10);
      r14.next = l7, l7.next = h9, this._length++;
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/ReshufflePlan.js
var t6 = class {
  constructor(t10) {
    this._indexOnly = t10, this.vertex = { count: 0, operations: [] }, this.index = { count: 0, operations: [] };
  }
  copyRecord(t10) {
    let e16 = 0;
    this._indexOnly || (e16 = this.vertex.count - t10.vertexStart, this.vertex.operations.push({ srcFrom: t10.vertexStart, dstFrom: this.vertex.count, count: t10.vertexCount, mutate: 0 }), t10.vertexStart = this.vertex.count, this.vertex.count += t10.vertexCount);
    let n17 = false;
    if (this._indexOnly && this.index.operations.length >= 1) {
      const e17 = this.index.operations[this.index.operations.length - 1];
      e17.srcFrom + e17.count === t10.indexStart && (e17.count += t10.indexCount, n17 = true);
    }
    n17 || this.index.operations.push({ srcFrom: t10.indexStart, dstFrom: this.index.count, count: t10.indexCount, mutate: e16 }), t10.indexStart = this.index.count, this.index.count += t10.indexCount;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Reader.js
var t7 = class {
  constructor(t10) {
    this._pos = 0, this._buffer = t10, this._i32View = new Int32Array(this._buffer), this._f32View = new Float32Array(this._buffer);
  }
  readInt32() {
    return this._i32View[this._pos++];
  }
  readF32() {
    return this._f32View[this._pos++];
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/meshDebugUtils.js
function s8(e16) {
  if (!e16) return null;
  return { entities: n5(new t7(e16.entities), e3), vertexData: e16.data.map(a8) };
}
function a8(t10) {
  const s9 = t10.layout.stride, a11 = new DataView(t10.vertices), n17 = [], c6 = t10.vertices.byteLength / s9;
  let l7 = 0;
  for (let e16 = 0; e16 < c6; e16++) {
    const e17 = {};
    for (const r14 of t10.layout.attributes) {
      let t11 = `${r14.offset} ${r14.name}`, o9 = s4(a11, r14, l7);
      if (r14.packPrecisionFactor) if (t11 += ` (precision: ${r14.packPrecisionFactor})`, "number" == typeof o9) o9 /= r14.packPrecisionFactor;
      else for (let e18 = 0; e18 < o9.length; e18++) o9[e18] /= r14.packPrecisionFactor;
      e17[t11] = o9;
    }
    l7 += s9, n17.push(e17);
  }
  const f5 = t10.metrics ? n5(new t7(t10.metrics), h3) ?? [] : [];
  return { vertices: n17, layout: t10.layout, metrics: f5 };
}

// node_modules/@arcgis/core/views/2d/engine/webgl/FeatureTile.js
var p = () => i.getLogger("esri.views.2d.engine.webgl.FeatureTile");
var g = 0;
var b = class extends j {
  constructor(e16, i7, r14, o9, n17, d6, h9 = false) {
    super(e16, i7, r14, o9), this._fader = n17, this._labelInstanceId = d6, this._meshes = /* @__PURE__ */ new Map(), this._entities = [], this._entityIndex = /* @__PURE__ */ new Map(), this._invalidated = false, this._nextUploadAllowed = false, this.tileAge = g++, this._metrics = [], this._metricsVisibility = /* @__PURE__ */ new Set(), this._entityIds = /* @__PURE__ */ new Set(), this._entityIdsFromBuffer = /* @__PURE__ */ new Set(), this._attributeEpoch = 0, this._encounteredEnd = false, this._decluttered = false, this._objectIdMap = null, this.isCoverage = false, this.rendering = false, this.visible = true, this.transforms.labelMat2d = n6(), this.transforms.tileUnitsToPixels = e7(), this.enableDeferredUploads = h9;
  }
  destroy() {
    super.destroy(), this.clear();
  }
  clear() {
    for (const e16 of this._meshes.values()) e16.destroy();
    this._meshes.clear(), this._entities = [], this._fader?.removeFeatureTileMetrics(this, this._metrics), this._metrics = [], this._displayList = null, this._invalidated = true, this._entityIds.clear(), this._nextUploadAllowed = true;
  }
  beforeRender(e16) {
    super.beforeRender(e16), this._needsReshuffle && e16.reshuffleManager.schedule(this);
  }
  tryReady(e16) {
    const t10 = this._invalidated && !this._uploadAllowed;
    return !(this.isReady || t10 || !this._encounteredEnd || !(e16 >= this._attributeEpoch)) && (has("esri-2d-update-debug") && console.debug(`Tile[${this.key.id}] FeatureTile.ready [epoch=${e16}]`), this.ready(), this.requestRender(), this.decluttered = false, true);
  }
  get symbols() {
    const e16 = /* @__PURE__ */ new Map();
    for (const t10 of this._metrics) e16.get(t10.labelClassId) || e16.set(t10.labelClassId, []), e16.get(t10.labelClassId).push(t10);
    return e16;
  }
  get decluttered() {
    return this._decluttered;
  }
  set decluttered(e16) {
    this._decluttered = e16, this.requestRender();
  }
  get id() {
    return this.key.id;
  }
  get hasData() {
    return !!this._meshes.size;
  }
  get hasAnimations() {
    return !!this._objectIdMap;
  }
  get needsUpload() {
    return this._invalidated;
  }
  get usedMemory() {
    let e16 = 0;
    for (const t10 of this._meshes.values()) e16 += t10.usedMemory;
    if (this._entities.length) {
      let t10 = 0;
      const s9 = Math.min(this._entities.length, 10);
      for (let e17 = 0; e17 < s9; e17++) t10 += this._entities[0].records.length;
      const i7 = t10 / s9;
      e16 += e3.estimateMemory(i7) * this._entities.length, e16 += 4 * this._entities.length;
    }
    return e16 += 25 * this._entityIndex.size, e16 += 18 * this._entityIds.size, e16 += 25 * this._entityIdsFromBuffer.size, this._displayList && (e16 += this._displayList.usedMemory), this._objectIdMap && (e16 += 25 * this._entities.length), e16;
  }
  get _uploadAllowed() {
    return !this.enableDeferredUploads || this._nextUploadAllowed;
  }
  get _hasMetrics() {
    return this._metrics.length > 0;
  }
  upload() {
    this._nextUploadAllowed = true;
  }
  getDisplayList(e16, t10) {
    if (this._uploadAllowed && this._invalidated) {
      this._entities.sort((e17, t11) => {
        const s9 = t11.sortKey, i7 = e17.sortKey;
        return i7 === s9 ? e17.id - t11.id : i7 - s9;
      }), 0 === t10 && this.reshuffle(true), this._displayList = h7.fromDisplayEntities(this._entities, this, e16, t10);
      for (const e17 of this._meshes.values()) e17.upload();
      this.debugInfo.display.length = this._displayList.length, this.debugInfo.display.minOrderedLength = this._displayList.minOrderedLength, this.debugInfo.display.minUnorderedLength = this._displayList.minUnorderedLength, this.requestRender(), this._invalidated = false, this._nextUploadAllowed = false;
    }
    return this._displayList;
  }
  getMesh(e16) {
    if (!this._meshes.has(e16)) throw new Error(`InternalError: Unable to find VAO for instance: ${e16}`);
    return this._meshes.get(e16);
  }
  getSortKeys(e16) {
    const t10 = /* @__PURE__ */ new Map();
    for (const { id: s9, sortKey: i7 } of this._entities) if (e16.has(s9) && t10.set(s9, i7), t10.size === e16.size) break;
    return t10;
  }
  onMessage(e16) {
    if (e16.objectIdMap) for (const t10 in e16.objectIdMap) this._objectIdMap || (this._objectIdMap = {}), this._objectIdMap[t10] = e16.objectIdMap[t10];
    switch (e16.type) {
      case "append":
        this._onAppendMessage(e16);
        break;
      case "update":
        this._onUpdateMessage(e16);
    }
    if (this._aggregateMemoryStats(), this.requestRender(), e16.end) {
      if (has("esri-2d-update-debug") && console.debug(`Tile[${this.key.id}] FeatureTile.end [epoch=${e16.attributeEpoch}]`), !e16.attributeEpoch) throw new Error("InternalError: Attribute epoch not defined.");
      this._attributeEpoch = e16.attributeEpoch, this._encounteredEnd = true;
    }
    this._writeLabelVisibilityToMesh();
  }
  _onAppendMessage(e16) {
    if (has("esri-2d-update-debug") && console.debug(`Tile[${this.key.id}] FeatureTile.append`, { append: s8(e16?.append) }), e16.clear && this.clear(), !e16.append) return;
    const t10 = n5(new t7(e16.append.entities), e3);
    this._insert(t10, e16.append.data, false);
  }
  _onUpdateMessage(e16) {
    has("esri-2d-update-debug") && console.debug(`Tile[${this.key.id}] FeatureTile.update`, { isPixelBuffer: e16.isPixelBuffer, modify: s8(e16.modify), remove: e16.remove });
    const t10 = n5(new t7(e16.modify.entities), e3), s9 = t10.map((e17) => e17.id), i7 = e16.isPixelBuffer ?? false, r14 = [...e16.remove, ...s9];
    i7 ? this._removeByIdsFromBuffer(r14) : this._removeByIds(r14), this._insert(t10, e16.modify.data, i7);
  }
  reshuffle(e16 = false) {
    if (this.destroyed) return;
    const t10 = /* @__PURE__ */ new Map();
    for (const s9 of this._entities) for (const i7 of s9.records) {
      const s10 = this._meshes.get(i7.instanceId);
      let r14 = t10.get(s10);
      r14 || (r14 = new t6(e16), t10.set(s10, r14)), r14.copyRecord(i7);
    }
    for (const [s9, i7] of t10) s9.reshuffle(i7);
    this._invalidated = true, this._aggregateMemoryStats(), has("esri-2d-update-debug") && p().info(`Tile ${this.key.id} was reshuffled.`);
  }
  copyPixelBufferedEntitesFrom(e16, t10, s9, i7) {
    const r14 = s9 * o4, o9 = i7 * o4;
    for (const n17 of e16._entities) {
      let s10 = null;
      for (const i8 of n17.records) if (i8.overlaps & t10) {
        const t11 = e16.getMesh(i8.instanceId), d6 = this._ensureMesh(i8.instanceId, t11.layout, t11.useVisibility).copyRecordFrom(t11, i8, r14, o9);
        s10 || (s10 = new e3(n17.id, n17.sortKey), this._entityIdsFromBuffer.add(n17.id), this._entityIndex.set(s10.id, s10), this._entities.push(s10)), s10.records.push(d6);
      }
    }
    this._invalidated = true;
  }
  get metricsVisibility() {
    return this._metricsVisibility;
  }
  copyMetricsVisibility(e16) {
    for (const t10 of e16) this._metricsVisibility.add(t10);
    this._writeLabelVisibilityToMesh();
  }
  updateLabelVisibility() {
    this._metricsVisibility.clear();
    for (const e16 of this._metrics) {
      e16.uniqueSymbol.show && e16.selectedForRendering && this._metricsVisibility.add(e16.hash);
    }
    this._writeLabelVisibilityToMesh();
  }
  _writeLabelVisibilityToMesh() {
    const e16 = this._meshes.get(this._labelInstanceId);
    if (e16 && this._hasMetrics) {
      for (const t10 of this._metrics) {
        const s9 = this._entityIndex.get(t10.id);
        if (!s9) continue;
        const i7 = this._metricsVisibility.has(t10.hash);
        e16.setEntityRecordRangeVisibility(s9.records, t10.recordStart, t10.recordCount, i7 ? 0 : 255);
      }
      this._invalidated = true;
    }
  }
  _ensureMesh(e16, t10, s9) {
    return this._meshes.has(e16) || this._meshes.set(e16, new y2(this._stage.bufferPool, t10, s9)), this._meshes.get(e16);
  }
  _insert(e16, t10, s9) {
    if (!e16.length) return;
    this._removeDuplicatedBufferedEntites(e16);
    const i7 = this._insertVertexData(t10);
    for (const r14 of e16) {
      for (const e17 of r14.records) e17.updateBaseOffsets(i7.get(e17.instanceId));
      s9 ? this._tryInsertBufferedEntity(r14) : this._insertEntity(r14);
    }
    this._invalidated = true;
  }
  _insertMetrics(e16) {
    for (const t10 of e16) t10.tile = this;
    this._metrics.push(...e16), this._fader?.insertFeatureTileMetrics(this, e16);
  }
  _insertVertexData(e16) {
    const t10 = /* @__PURE__ */ new Map();
    for (const s9 of e16) {
      const { instanceId: e17, layout: i7 } = s9, r14 = i7.attributes.some((e18) => "visibility" === e18.name), o9 = this._ensureMesh(e17, i7, r14).append(s9);
      if (s9.metrics) {
        const e18 = n5(new t7(s9.metrics), h3) ?? [];
        this._insertMetrics(e18);
      }
      t10.set(e17, o9);
    }
    return t10;
  }
  _insertEntity(e16) {
    has("esri-2d-update-debug") && this._entityIds.has(e16.id) && console.error(`Tile ${this.key.id} insertEntity: Already have entityId ${e16.id}`), this._entityIds.add(e16.id), this._entityIndex.set(e16.id, e16), this._entities.push(e16);
  }
  _tryInsertBufferedEntity(e16) {
    this._entityIds.has(e16.id) ? this._removeRecordsFromMesh(e16.records) : (this._entityIdsFromBuffer.add(e16.id), this._entityIndex.set(e16.id, e16), this._entities.push(e16));
  }
  _removeDuplicatedBufferedEntites(e16) {
    if (!this._entityIdsFromBuffer.size) return;
    const t10 = [];
    for (const s9 of e16) this._entityIdsFromBuffer.has(s9.id) && t10.push(s9.id);
    this._removeByIds(t10);
  }
  _removeByIdsFromBuffer(e16) {
    this._removeByIds(e16.filter((e17) => this._entityIdsFromBuffer.has(e17)));
  }
  _removeByIds(e16) {
    if (0 === e16.length) return;
    const t10 = new Set(e16), s9 = [];
    for (const r14 of this._entities) t10.has(r14.id) ? (this._remove(r14), this._entityIndex.delete(r14.id)) : s9.push(r14);
    this._entities = s9;
    const i7 = this._metrics.filter((e17) => t10.has(e17.displayId));
    this._metrics = this._metrics.filter((e17) => !t10.has(e17.displayId)), this._fader?.removeFeatureTileMetrics(this, i7), this._invalidated = true;
  }
  _remove(e16) {
    this._removeRecordsFromMesh(e16.records), this._entityIds.delete(e16.id), this._entityIdsFromBuffer.delete(e16.id);
  }
  _removeRecordsFromMesh(e16) {
    for (const t10 of e16) {
      const { instanceId: e17, indexStart: s9, indexCount: i7, vertexStart: r14, vertexCount: o9 } = t10;
      this._meshes.get(e17)?.remove(s9, i7, r14, o9);
    }
  }
  _aggregateMemoryStats() {
    this.debugInfo.memory.bytesUsed = 0, this.debugInfo.memory.bytesReserved = 0;
    for (const e16 of this._meshes.values()) this.debugInfo.memory.bytesUsed += e16.memoryStats.bytesUsed, this.debugInfo.memory.bytesReserved += e16.memoryStats.bytesReserved;
  }
  get _needsReshuffle() {
    if (this.destroyed) return false;
    const { bytesUsed: e16, bytesReserved: t10 } = this.debugInfo.memory, s9 = e16 / t10, { minOrderedLength: i7, length: h9 } = this.debugInfo.display;
    return t10 > Ct && s9 < Dt || h9 > Et && i7 / h9 < Ft;
  }
  get entityIds() {
    return this._objectIdMap ? this._entities.map(({ id: e16 }) => ({ objectId: this._objectIdMap[e16], displayId: e16 })) : [];
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrush.js
var t8 = class {
  constructor() {
    this.name = this.constructor.name || "UnnamedBrush", this.brushEffect = null;
  }
  prepareState(t10, r14) {
  }
  draw(t10, r14, s9) {
  }
  drawMany(t10, r14, s9) {
    for (const a11 of r14) a11.visible && this.draw(t10, a11, s9);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/brushes/BrushClip.js
var n14 = () => $2("clip", [{ location: 0, name: "a_pos", count: 2, type: R.SHORT }]);
var l4 = class extends t8 {
  constructor() {
    super(...arguments), this._color = r6(0, 1, 0, 1);
  }
  dispose() {
    this._program && this._program.dispose();
  }
  prepareState({ context: e16 }) {
    e16.setStencilTestEnabled(true), e16.setBlendingEnabled(false), e16.setFaceCullingEnabled(false), e16.setColorMask(false, false, false, false), e16.setStencilOp(7680, 7680, 7681), e16.setStencilWriteMask(255), e16.setStencilFunction(519, 0, 255);
  }
  draw(e16, r14) {
    const { context: t10, state: l7, requestRender: m4, allowDelayedRender: p2 } = e16, c6 = n14(), d6 = r14.getVAO(t10, l7, c6.bufferLayout);
    null != d6.indexBuffer && (this._program ??= e9(t10, e13, d6.locations), !p2 || null == m4 || this._program.compiled ? (t10.useProgram(this._program), this._program.setUniform2fv("u_coord_range", [1, 1]), this._program.setUniform4fv("u_color", this._color), this._program.setUniformMatrix3fv("u_dvsMat3", l7.displayMat3), t10.bindVAO(d6), t10.drawElements(_.TRIANGLES, d6.indexBuffer.size, R.UNSIGNED_INT, 0), t10.bindVAO(null)) : m4());
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushStencil.js
var n15 = class extends t8 {
  constructor() {
    super(...arguments), this._color = r6(1, 0, 0, 1), this._initialized = false;
  }
  dispose() {
    this._solidProgram && (this._solidProgram.dispose(), this._solidProgram = null), this._solidVertexArrayObject && (this._solidVertexArrayObject.dispose(), this._solidVertexArrayObject = null);
  }
  prepareState({ context: e16 }) {
    e16.setDepthWriteEnabled(false), e16.setDepthTestEnabled(false), e16.setStencilTestEnabled(true), e16.setBlendingEnabled(false), e16.setColorMask(false, false, false, false), e16.setStencilOp(7680, 7680, 7681), e16.setStencilWriteMask(255);
  }
  draw(e16, r14) {
    const { context: t10, requestRender: s9, allowDelayedRender: o9 } = e16;
    this._initialized || this._initialize(t10), !o9 || null == s9 || this._solidProgram.compiled ? (t10.setStencilFunctionSeparate(1032, 516, r14.stencilRef, 255), t10.bindVAO(this._solidVertexArrayObject), t10.useProgram(this._solidProgram), this._solidProgram.setUniformMatrix3fv("u_dvsMat3", r14.transforms.displayViewScreenMat3), this._solidProgram.setUniform2fv("u_coord_range", [r14.rangeX, r14.rangeY]), this._solidProgram.setUniform1f("u_depth", 0), this._solidProgram.setUniform4fv("u_color", this._color), t10.drawArrays(_.TRIANGLE_STRIP, 0, 4), t10.bindVAO(null)) : s9();
  }
  _initialize(e16) {
    if (this._initialized) return true;
    const r14 = new Int8Array([0, 0, 1, 0, 0, 1, 1, 1]), i7 = new r5(e16, s6, r14), n17 = new h5(e16, i7);
    return this._solidProgram = e9(e16, e13, n17.locations), this._solidVertexArrayObject = n17, this._initialized = true, true;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushTileDebugInfo.js
var u4 = 512;
var d5 = 512;
var h8 = 16;
var g2 = 8;
var _4 = (d5 - 2 * g2) / 5;
var x2 = class extends t8 {
  constructor() {
    super(...arguments), this._color = r6(1, 0, 0, 1);
  }
  dispose() {
    this._outlineProgram?.dispose(), this._outlineProgram = null, this._tileInfoProgram?.dispose(), this._tileInfoProgram = null, this._outlineVertexArrayObject?.dispose(), this._outlineVertexArrayObject = null, this._tileInfoVertexArrayObject?.dispose(), this._tileInfoVertexArrayObject = null, this._ctx = null;
  }
  prepareState({ context: e16 }) {
    e16.setBlendingEnabled(true), e16.setBlendFunctionSeparate(1, 771, 1, 771), e16.setColorMask(true, true, true, true), e16.setStencilWriteMask(0), e16.setStencilTestEnabled(false);
  }
  draw(e16, r14) {
    const { context: o9, requestRender: i7, allowDelayedRender: n17 } = e16;
    if (!r14.isReady && r14 instanceof b && r14.hasData) return;
    if (this._loadWGLResources(o9), n17 && null != i7 && (!this._outlineProgram.compiled || !this._tileInfoProgram.compiled)) return void i7();
    o9.bindVAO(this._outlineVertexArrayObject), o9.useProgram(this._outlineProgram), this._outlineProgram.setUniformMatrix3fv("u_dvsMat3", r14.transforms.displayViewScreenMat3), this._outlineProgram.setUniform2f("u_coord_range", r14.rangeX, r14.rangeY), this._outlineProgram.setUniform1f("u_depth", 0), this._outlineProgram.setUniform4fv("u_color", this._color), o9.drawArrays(_.LINE_STRIP, 0, 4);
    const l7 = this._getTexture(o9, r14);
    l7 ? (o9.bindVAO(this._tileInfoVertexArrayObject), o9.useProgram(this._tileInfoProgram), o9.bindTexture(l7, 0), this._tileInfoProgram.setUniformMatrix3fv("u_dvsMat3", r14.transforms.displayViewScreenMat3), this._tileInfoProgram.setUniform1f("u_depth", 0), this._tileInfoProgram.setUniform2f("u_coord_ratio", r14.rangeX / r14.width, r14.rangeY / r14.height), this._tileInfoProgram.setUniform2f("u_delta", 0, 0), this._tileInfoProgram.setUniform2f("u_dimensions", l7.descriptor.width, l7.descriptor.height), o9.drawArrays(_.TRIANGLE_STRIP, 0, 4), o9.bindVAO(null)) : o9.bindVAO(null);
  }
  _loadWGLResources(e16) {
    if (this._outlineProgram && this._tileInfoProgram) return;
    const t10 = new Int8Array([0, 0, 1, 0, 1, 1, 0, 1]), r14 = new r5(e16, s6, t10);
    this._outlineVertexArrayObject = new h5(e16, r14), this._outlineProgram = e9(e16, e13, this._outlineVertexArrayObject.locations);
    const s9 = new Int8Array([0, 0, 1, 0, 0, 1, 1, 1]), l7 = new r5(e16, s6, s9);
    this._tileInfoVertexArrayObject = new h5(e16, l7), this._tileInfoProgram = e9(e16, r10, this._tileInfoVertexArrayObject.locations);
  }
  _getTexture(e16, t10) {
    if (!this._ctx) {
      const e17 = document.createElement("canvas");
      e17.width = u4, e17.height = d5, this._ctx = e17.getContext("2d");
    }
    if (!t10.tileDebugInfoTexture) {
      const r15 = new h4(u4, d5);
      r15.wrapMode = 33071, r15.samplingMode = 9729, r15.isImmutable = true, t10.tileDebugInfoTexture = new A(e16, r15);
    }
    const r14 = this._ctx;
    r14.clearRect(0, 0, r14.canvas.width, r14.canvas.height), r14.textAlign = "left", r14.textBaseline = "top", r14.font = h8 - 2 + "px sans-serif", r14.lineWidth = 2, r14.fillStyle = "white", r14.strokeStyle = "black";
    const { debugSlot: o9 } = t10;
    let i7 = g2 + _4 * o9;
    const s9 = `${o9}) ${t10.key.id} (${t10.constructor.name})`;
    r14.strokeText(s9, g2, i7), r14.fillText(s9, g2, i7), i7 += h8;
    const { debugInfo: n17 } = t10;
    if (n17) {
      const { length: e17, minOrderedLength: t11, minUnorderedLength: o10, triangleCount: s10 } = n17.display;
      if (e17 > 0) {
        const t12 = `Length: ${e17}`;
        r14.strokeText(t12, g2, i7), r14.fillText(t12, g2, i7), i7 += h8;
      }
      if (t11) {
        const e18 = `Min ordered length: ${t11}`;
        r14.strokeText(e18, g2, i7), r14.fillText(e18, g2, i7), i7 += h8;
      }
      if (o10) {
        const e18 = `Min unordered length: ${o10}`;
        r14.strokeText(e18, g2, i7), r14.fillText(e18, g2, i7), i7 += h8;
      }
      if (s10 > 0) {
        s10 > 1e5 && (r14.fillStyle = "red", r14.strokeStyle = "white");
        const e18 = `Triangle count: ${s10}`;
        r14.strokeText(e18, g2, i7), r14.fillText(e18, g2, i7), i7 += h8;
      }
      const { bytesUsed: l7, bytesReserved: a11 } = n17.memory;
      if (r14.fillStyle = "white", r14.strokeStyle = "black", l7 > 0 || a11 > 0) {
        const e18 = `Memory usage: ${l7} of ${a11} bytes`;
        r14.strokeText(e18, g2, i7), r14.fillText(e18, g2, i7), i7 += h8;
      }
    }
    return t10.tileDebugInfoTexture.setData(r14.canvas), t10.tileDebugInfoTexture;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushVTLBackground.js
var m2 = class extends t8 {
  constructor() {
    super(...arguments), this._color = r6(1, 0, 0, 1), this._patternMatrix = e7(), this._programOptions = { id: false, pattern: false };
  }
  dispose() {
    this._vao = r(this._vao);
  }
  drawMany(r14, e16) {
    const { context: o9, painter: a11, requestRender: c6, allowDelayedRender: l7 } = r14;
    this._loadWGLResources(r14);
    const m4 = r14.displayLevel, f5 = r14.styleLayer, u7 = f5.backgroundMaterial, p2 = a11.vectorTilesMaterialManager, _5 = f5.getPaintValue("background-color", m4), d6 = f5.getPaintValue("background-opacity", m4), g3 = f5.getPaintValue("background-pattern", m4), h9 = void 0 !== g3, x4 = 1 | window.devicePixelRatio, y3 = r14.spriteMosaic;
    let M3, b2;
    const v = x4 > $ ? 2 : 1, w = this._programOptions;
    w.pattern = h9;
    const j2 = p2.getMaterialProgram(o9, u7, w);
    if (!l7 || null == c6 || j2.compiled) {
      if (o9.bindVAO(this._vao), o9.useProgram(j2), h9) {
        const t10 = y3.getMosaicItemPosition(g3, true);
        if (null != t10) {
          const { tl: r15, br: e17, page: s9 } = t10;
          M3 = e17[0] - r15[0], b2 = e17[1] - r15[1];
          const a12 = y3.getPageSize(s9);
          null != a12 && (y3.bind(o9, 9729, s9, Y), j2.setUniform4f("u_tlbr", r15[0], r15[1], e17[0], e17[1]), j2.setUniform2fv("u_mosaicSize", a12), j2.setUniform1i("u_texture", Y));
        }
        j2.setUniform1f("u_opacity", d6);
      } else {
        const t10 = _5[3] * d6;
        this._color[0] = t10 * _5[0], this._color[1] = t10 * _5[1], this._color[2] = t10 * _5[2], this._color[3] = t10, j2.setUniform4fv("u_color", this._color);
      }
      j2.setUniform1f("u_depth", f5.z || 0);
      for (const r15 of e16) {
        if (j2.setUniform1f("u_coord_range", r15.rangeX), j2.setUniformMatrix3fv("u_dvsMat3", r15.transforms.displayViewScreenMat3), h9) {
          const e17 = Math.max(2 ** (Math.round(m4) - r15.key.level), 1), o10 = v * r15.width * e17, i7 = o10 / i2(M3), s9 = o10 / i2(b2);
          this._patternMatrix[0] = i7, this._patternMatrix[4] = s9, j2.setUniformMatrix3fv("u_pattern_matrix", this._patternMatrix);
        }
        o9.setStencilFunction(514, 0, 255), o9.drawArrays(_.TRIANGLE_STRIP, 0, 4);
      }
    } else c6();
  }
  _loadWGLResources(t10) {
    if (this._vao) return;
    const { context: r14, styleLayer: e16 } = t10, o9 = e16.backgroundMaterial, i7 = new Int8Array([0, 0, 1, 0, 0, 1, 1, 1]), s9 = new r5(r14, o9.geometryLayout, i7);
    this._vao = new h5(r14, s9);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushVTLCircle.js
var a9 = class extends t8 {
  constructor() {
    super(...arguments), this._programOptions = { id: false };
  }
  dispose() {
  }
  drawMany(e16, a11) {
    const { context: i7, displayLevel: n17, requiredLevel: l7, state: s9, painter: o9, spriteMosaic: c6, styleLayerUID: u7, requestRender: d6, allowDelayedRender: f5 } = e16;
    if (!a11.some((e17) => e17.layerData.get(u7)?.circleIndexCount ?? false)) return;
    const p2 = e16.styleLayer, m4 = p2.circleMaterial, y3 = o9.vectorTilesMaterialManager, g3 = 1.2, M3 = p2.getPaintValue("circle-translate", n17), v = p2.getPaintValue("circle-translate-anchor", n17), x4 = this._programOptions, _5 = y3.getMaterialProgram(i7, m4, x4);
    if (f5 && null != d6 && !_5.compiled) return void d6();
    i7.useProgram(_5), _5.setUniformMatrix3fv("u_displayMat3", 1 === v ? s9.displayMat3 : s9.displayViewMat3), _5.setUniform2fv("u_circleTranslation", M3), _5.setUniform1f("u_depth", p2.z), _5.setUniform1f("u_antialiasingWidth", g3);
    let I = -1;
    for (const U of a11) {
      if (!U.layerData.has(u7)) continue;
      U.key.level !== I && (I = U.key.level, m4.setDataUniforms(_5, n17, p2, I, c6));
      const e17 = U.layerData.get(u7);
      if (!e17.circleIndexCount) continue;
      e17.prepareForRendering(i7);
      const a12 = e17.vao;
      null != a12 && (i7.bindVAO(a12), _5.setUniformMatrix3fv("u_dvsMat3", U.transforms.displayViewScreenMat3), l7 !== U.key.level ? i7.setStencilFunction(514, U.stencilRef, 255) : i7.setStencilFunction(516, 255, 255), i7.drawElements(_.TRIANGLES, e17.circleIndexCount, R.UNSIGNED_INT, Uint32Array.BYTES_PER_ELEMENT * e17.circleIndexStart), U.triangleCount += e17.circleIndexCount / 3);
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushVTLFill.js
var l5 = 1 / 65536;
var r12 = class extends t8 {
  constructor() {
    super(...arguments), this._fillProgramOptions = { id: false, pattern: false }, this._outlineProgramOptions = { id: false };
  }
  dispose() {
  }
  drawMany(t10, e16) {
    const { displayLevel: i7, renderPass: n17, spriteMosaic: a11, styleLayerUID: l7 } = t10;
    let r14 = false;
    for (const _5 of e16) if (_5.layerData.has(l7)) {
      const t11 = _5.layerData.get(l7);
      if (t11.fillIndexCount > 0 || t11.outlineIndexCount > 0) {
        r14 = true;
        break;
      }
    }
    if (!r14) return;
    const o9 = t10.styleLayer, s9 = o9.getPaintProperty("fill-pattern"), f5 = void 0 !== s9, u7 = f5 && s9.isDataDriven;
    let c6;
    if (f5 && !u7) {
      const t11 = s9.getValue(i7);
      c6 = a11.getMosaicItemPosition(t11, true);
    }
    const d6 = !f5 && o9.getPaintValue("fill-antialias", i7);
    let p2 = true, m4 = 1;
    if (!f5) {
      const t11 = o9.getPaintProperty("fill-color"), e17 = o9.getPaintProperty("fill-opacity");
      if (!t11?.isDataDriven && !e17?.isDataDriven) {
        const t12 = o9.getPaintValue("fill-color", i7);
        m4 = o9.getPaintValue("fill-opacity", i7) * t12[3], m4 >= 1 && (p2 = false);
      }
    }
    if (p2 && "opaque" === n17) return;
    const y3 = o9.getPaintValue("fill-translate", i7), g3 = o9.getPaintValue("fill-translate-anchor", i7);
    (p2 || "translucent" !== n17) && this._drawFill(t10, l7, o9, e16, y3, g3, f5, c6, u7);
    const M3 = !o9.hasDataDrivenOutlineColor && o9.outlineUsesFillColor && m4 < 1;
    d6 && "opaque" !== n17 && !M3 && this._drawOutline(t10, l7, o9, e16, y3, g3);
  }
  _drawFill(i7, r14, o9, s9, f5, u7, c6, d6, p2) {
    if (c6 && !p2 && null == d6) return;
    const { context: m4, displayLevel: y3, state: g3, painter: M3, pixelRatio: _5, spriteMosaic: v, requestRender: P, allowDelayedRender: E } = i7, U = o9.fillMaterial, x4 = M3.vectorTilesMaterialManager, D = _5 > $ ? 2 : 1, I = this._fillProgramOptions;
    I.pattern = c6;
    const S = x4.getMaterialProgram(m4, U, I);
    if (E && null != P && !S.compiled) return void P();
    if (m4.useProgram(S), null != d6) {
      const { page: e16 } = d6, i8 = v.getPageSize(e16);
      null != i8 && (v.bind(m4, 9729, e16, Y), S.setUniform2fv("u_mosaicSize", i8), S.setUniform1i("u_texture", Y));
    }
    S.setUniformMatrix3fv("u_displayMat3", 1 === u7 ? g3.displayMat3 : g3.displayViewMat3), S.setUniform2fv("u_fillTranslation", f5), S.setUniform1f("u_depth", o9.z + l5);
    let h9 = -1;
    for (const e16 of s9) {
      if (!e16.layerData.has(r14)) continue;
      e16.key.level !== h9 && (h9 = e16.key.level, U.setDataUniforms(S, y3, o9, h9, v));
      const i8 = e16.layerData.get(r14);
      if (!i8.fillIndexCount) continue;
      i8.prepareForRendering(m4);
      const l7 = i8.fillVAO;
      if (null != l7) {
        if (m4.bindVAO(l7), S.setUniformMatrix3fv("u_dvsMat3", e16.transforms.displayViewScreenMat3), m4.setStencilFunction(514, e16.stencilRef, 255), c6) {
          const t10 = Math.max(2 ** (Math.round(y3) - e16.key.level), 1), i9 = e16.rangeX / (D * e16.width * t10);
          S.setUniform1f("u_patternFactor", i9);
        }
        if (p2) {
          const e17 = i8.patternMap;
          if (!e17) continue;
          for (const [i9, l8] of e17) {
            const e18 = v.getPageSize(i9);
            null != e18 && (v.bind(m4, 9729, i9, Y), S.setUniform2fv("u_mosaicSize", e18), S.setUniform1i("u_texture", Y), m4.drawElements(_.TRIANGLES, l8[1], R.UNSIGNED_INT, Uint32Array.BYTES_PER_ELEMENT * l8[0]));
          }
        } else m4.drawElements(_.TRIANGLES, i8.fillIndexCount, R.UNSIGNED_INT, Uint32Array.BYTES_PER_ELEMENT * i8.fillIndexStart);
        e16.triangleCount += i8.fillIndexCount / 3;
      }
    }
  }
  _drawOutline(t10, e16, i7, r14, o9, s9) {
    const { context: f5, displayLevel: u7, state: c6, painter: d6, pixelRatio: p2, spriteMosaic: m4, requestRender: y3, allowDelayedRender: g3 } = t10, M3 = i7.outlineMaterial, _5 = d6.vectorTilesMaterialManager, v = 0.75 / p2, P = this._outlineProgramOptions, E = _5.getMaterialProgram(f5, M3, P);
    if (g3 && null != y3 && !E.compiled) return void y3();
    f5.useProgram(E), E.setUniformMatrix3fv("u_displayMat3", 1 === s9 ? c6.displayMat3 : c6.displayViewMat3), E.setUniform2fv("u_fillTranslation", o9), E.setUniform1f("u_depth", i7.z + l5), E.setUniform1f("u_outline_width", v);
    let U = -1;
    for (const l7 of r14) {
      if (!l7.layerData.has(e16)) continue;
      l7.key.level !== U && (U = l7.key.level, M3.setDataUniforms(E, u7, i7, U, m4));
      const t11 = l7.layerData.get(e16);
      if (t11.prepareForRendering(f5), !t11.outlineIndexCount) continue;
      const r15 = t11.outlineVAO;
      null != r15 && (f5.bindVAO(r15), E.setUniformMatrix3fv("u_dvsMat3", l7.transforms.displayViewScreenMat3), f5.setStencilFunction(514, l7.stencilRef, 255), f5.drawElements(_.TRIANGLES, t11.outlineIndexCount, R.UNSIGNED_INT, Uint32Array.BYTES_PER_ELEMENT * t11.outlineIndexStart), l7.triangleCount += t11.outlineIndexCount / 3);
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushVTLLine.js
var a10 = class extends t8 {
  constructor() {
    super(...arguments), this._programOptions = { id: false, pattern: false, sdf: false };
  }
  dispose() {
  }
  drawMany(t10, a11) {
    const { context: r14, displayLevel: o9, state: s9, painter: l7, pixelRatio: f5, spriteMosaic: u7, styleLayerUID: c6, requestRender: d6, allowDelayedRender: m4 } = t10;
    if (!a11.some((e16) => e16.layerData.get(c6)?.lineIndexCount ?? false)) return;
    const p2 = t10.styleLayer, g3 = p2.lineMaterial, y3 = l7.vectorTilesMaterialManager, M3 = p2.getPaintValue("line-translate", o9), _5 = p2.getPaintValue("line-translate-anchor", o9), v = p2.getPaintProperty("line-pattern"), U = void 0 !== v, E = U && v.isDataDriven;
    let x4, I;
    if (U && !E) {
      const e16 = v.getValue(o9);
      x4 = u7.getMosaicItemPosition(e16);
    }
    let P = false;
    if (!U) {
      const e16 = p2.getPaintProperty("line-dasharray");
      if (I = void 0 !== e16, P = I && e16.isDataDriven, I && !P) {
        const t11 = e16.getValue(o9), i7 = p2.getDashKey(t11, p2.getLayoutValue("line-cap", o9));
        x4 = u7.getMosaicItemPosition(i7);
      }
    }
    const D = 1 / f5, S = this._programOptions;
    S.pattern = U, S.sdf = I;
    const N3 = y3.getMaterialProgram(r14, g3, S);
    if (m4 && null != d6 && !N3.compiled) return void d6();
    if (r14.useProgram(N3), N3.setUniformMatrix3fv("u_displayViewMat3", s9.displayViewMat3), N3.setUniformMatrix3fv("u_displayMat3", 1 === _5 ? s9.displayMat3 : s9.displayViewMat3), N3.setUniform2fv("u_lineTranslation", M3), N3.setUniform1f("u_depth", p2.z), N3.setUniform1f("u_antialiasing", D), x4 && null != x4) {
      const { page: t11 } = x4, i7 = u7.getPageSize(t11);
      null != i7 && (u7.bind(r14, 9729, t11, Y), N3.setUniform2fv("u_mosaicSize", i7), N3.setUniform1i("u_texture", Y));
    }
    let T2 = -1;
    for (const V of a11) {
      if (!V.layerData.has(c6)) continue;
      V.key.level !== T2 && (T2 = V.key.level, g3.setDataUniforms(N3, o9, p2, T2, u7));
      const t11 = 2 ** (o9 - T2) / f5;
      N3.setUniform1f("u_zoomFactor", t11);
      const a12 = V.layerData.get(c6);
      if (!a12.lineIndexCount) continue;
      a12.prepareForRendering(r14);
      const s10 = a12.vao;
      if (null != s10) {
        if (r14.bindVAO(s10), N3.setUniformMatrix3fv("u_dvsMat3", V.transforms.displayViewScreenMat3), r14.setStencilFunction(514, V.stencilRef, 255), E || P) {
          const t12 = a12.patternMap;
          if (!t12) continue;
          for (const [a13, o10] of t12) {
            const t13 = u7.getPageSize(a13);
            null != t13 && (u7.bind(r14, 9729, a13, Y), N3.setUniform2fv("u_mosaicSize", t13), N3.setUniform1i("u_texture", Y), r14.drawElements(_.TRIANGLES, o10[1], R.UNSIGNED_INT, Uint32Array.BYTES_PER_ELEMENT * o10[0]));
          }
        } else r14.drawElements(_.TRIANGLES, a12.lineIndexCount, R.UNSIGNED_INT, Uint32Array.BYTES_PER_ELEMENT * a12.lineIndexStart);
        V.triangleCount += a12.lineIndexCount / 3;
      }
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/GeometryUtils.js
var n16 = 128 / Math.PI;
var t9 = 256 / 360;
var r13 = 1 / Math.LN2;
function u5(n17, t10) {
  return (n17 %= t10) >= 0 ? n17 : n17 + t10;
}
function c3(n17) {
  return u5(n17 * t9, 256);
}
function e15(n17) {
  return Math.log(n17) * r13;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/brushes/WGLBrushVTLSymbol.js
var f4 = 1 / 65536;
var c4 = class extends t8 {
  constructor() {
    super(...arguments), this._iconProgramOptions = { id: false, sdf: false }, this._sdfProgramOptions = { id: false }, this._spritesTextureSize = n7();
  }
  dispose() {
  }
  drawMany(e16, t10) {
    const i7 = e16.styleLayer;
    this._drawIcons(e16, i7, t10), this._drawText(e16, i7, t10);
  }
  _drawIcons(e16, t10, r14) {
    const { context: s9, displayLevel: o9, painter: l7, spriteMosaic: f5, state: c6, styleLayerUID: u7, requestRender: p2, allowDelayedRender: m4 } = e16, g3 = t10.iconMaterial, d6 = l7.vectorTilesMaterialManager;
    let y3, _5 = false;
    for (const i7 of r14) if (i7.layerData.has(u7) && (y3 = i7.layerData.get(u7), y3.iconPerPageElementsMap.size > 0)) {
      _5 = true;
      break;
    }
    if (!_5) return;
    const h9 = t10.getPaintValue("icon-translate", o9), M3 = t10.getPaintValue("icon-translate-anchor", o9);
    let U = t10.getLayoutValue("icon-rotation-alignment", o9);
    2 === U && (U = 0 === t10.getLayoutValue("symbol-placement", o9) ? 1 : 0);
    const x4 = 0 === U, P = t10.getLayoutValue("icon-keep-upright", o9) && x4, S = y3.isIconSDF, E = this._iconProgramOptions;
    E.sdf = S;
    const v = d6.getMaterialProgram(s9, g3, E);
    if (m4 && null != p2 && !v.compiled) return void p2();
    s9.useProgram(v), v.setUniformMatrix3fv("u_displayViewMat3", 0 === U ? c6.displayViewMat3 : c6.displayMat3), v.setUniformMatrix3fv("u_displayMat3", 1 === M3 ? c6.displayMat3 : c6.displayViewMat3), v.setUniform2fv("u_iconTranslation", h9), v.setUniform1f("u_depth", t10.z), v.setUniform1f("u_mapRotation", c3(c6.rotation)), v.setUniform1f("u_keepUpright", P ? 1 : 0), v.setUniform1f("u_level", 10 * o9), v.setUniform1i("u_texture", Y), v.setUniform1f("u_fadeDuration", e6 / 1e3), v.setUniform1i("u_isStencilPass", e16.stencilSymbols ? 1 : 0);
    let D = -1;
    for (const i7 of r14) {
      if (!i7.layerData.has(u7)) continue;
      if (i7.key.level !== D && (D = i7.key.level, g3.setDataUniforms(v, o9, t10, D, f5)), y3 = i7.layerData.get(u7), 0 === y3.iconPerPageElementsMap.size) continue;
      y3.prepareForRendering(s9), y3.updateOpacityInfo();
      const a11 = y3.iconVAO;
      if (null != a11) {
        s9.bindVAO(a11), v.setUniformMatrix3fv("u_dvsMat3", i7.transforms.displayViewScreenMat3), v.setUniform1f("u_time", (performance.now() - y3.lastOpacityUpdate) / 1e3);
        for (const [t11, a12] of y3.iconPerPageElementsMap) this._renderIconRange(e16, v, a12, t11, i7);
      }
    }
  }
  _renderIconRange(e16, t10, i7, r14, n17) {
    const { context: s9, spriteMosaic: f5 } = e16;
    this._spritesTextureSize[0] = f5.getWidth(r14) / 4, this._spritesTextureSize[1] = f5.getHeight(r14) / 4, t10.setUniform2fv("u_mosaicSize", this._spritesTextureSize), f5.bind(s9, 9729, r14, Y), this._setStencilState(e16, n17), s9.drawElements(_.TRIANGLES, i7[1], R.UNSIGNED_INT, Uint32Array.BYTES_PER_ELEMENT * i7[0]), n17.triangleCount += i7[1] / 3;
  }
  _drawText(e16, a11, s9) {
    const { context: o9, displayLevel: l7, glyphMosaic: c6, painter: u7, pixelRatio: p2, spriteMosaic: m4, state: g3, styleLayerUID: d6, requestRender: y3, allowDelayedRender: _5 } = e16, h9 = a11.textMaterial, M3 = u7.vectorTilesMaterialManager;
    let U, x4 = false;
    for (const t10 of s9) if (t10.layerData.has(d6) && (U = t10.layerData.get(d6), U.glyphPerPageElementsMap.size > 0)) {
      x4 = true;
      break;
    }
    if (!x4) return;
    const P = a11.getPaintProperty("text-opacity");
    if (P && !P.isDataDriven && 0 === P.getValue(l7)) return;
    const S = a11.getPaintProperty("text-color"), E = !S || S.isDataDriven || S.getValue(l7)[3] > 0, v = a11.getPaintProperty("text-halo-width"), D = a11.getPaintProperty("text-halo-color"), T2 = (!v || v.isDataDriven || v.getValue(l7) > 0) && (!D || D.isDataDriven || D.getValue(l7)[3] > 0);
    if (!E && !T2) return;
    const V = 24 / 8;
    let w = a11.getLayoutValue("text-rotation-alignment", l7);
    2 === w && (w = 0 === a11.getLayoutValue("symbol-placement", l7) ? 1 : 0);
    const R2 = 0 === w, I = a11.getLayoutValue("text-keep-upright", l7) && R2, L = 0.8 * V / p2;
    this._glyphTextureSize || (this._glyphTextureSize = r4(c6.width / 4, c6.height / 4));
    const z = a11.getPaintValue("text-translate", l7), N3 = a11.getPaintValue("text-translate-anchor", l7), b2 = this._sdfProgramOptions, k = M3.getMaterialProgram(o9, h9, b2);
    if (_5 && null != y3 && !k.compiled) return void y3();
    o9.useProgram(k), k.setUniformMatrix3fv("u_displayViewMat3", 0 === w ? g3.displayViewMat3 : g3.displayMat3), k.setUniformMatrix3fv("u_displayMat3", 1 === N3 ? g3.displayMat3 : g3.displayViewMat3), k.setUniform2fv("u_textTranslation", z), k.setUniform1f("u_depth", a11.z + f4), k.setUniform2fv("u_mosaicSize", this._glyphTextureSize), k.setUniform1f("u_mapRotation", c3(g3.rotation)), k.setUniform1f("u_keepUpright", I ? 1 : 0), k.setUniform1f("u_level", 10 * l7), k.setUniform1i("u_texture", Z), k.setUniform1f("u_antialiasingWidth", L), k.setUniform1f("u_fadeDuration", e6 / 1e3);
    let O = -1;
    for (const t10 of s9) {
      if (!t10.layerData.has(d6)) continue;
      if (t10.key.level !== O && (O = t10.key.level, h9.setDataUniforms(k, l7, a11, O, m4)), U = t10.layerData.get(d6), 0 === U.glyphPerPageElementsMap.size) continue;
      U.prepareForRendering(o9), U.updateOpacityInfo();
      const i7 = U.textVAO;
      if (null == i7) continue;
      o9.bindVAO(i7), k.setUniformMatrix3fv("u_dvsMat3", t10.transforms.displayViewScreenMat3), this._setStencilState(e16, t10);
      const r14 = (performance.now() - U.lastOpacityUpdate) / 1e3;
      k.setUniform1f("u_time", r14), U.glyphPerPageElementsMap.forEach((e17, i8) => {
        this._renderGlyphRange(o9, e17, i8, c6, k, T2, E, t10);
      });
    }
  }
  _renderGlyphRange(e16, t10, i7, a11, n17, s9, f5, c6) {
    a11.bind(e16, 9729, i7, Z), s9 && (n17.setUniform1f("u_halo", 1), e16.drawElements(_.TRIANGLES, t10[1], R.UNSIGNED_INT, Uint32Array.BYTES_PER_ELEMENT * t10[0]), c6.triangleCount += t10[1] / 3), f5 && (n17.setUniform1f("u_halo", 0), e16.drawElements(_.TRIANGLES, t10[1], R.UNSIGNED_INT, Uint32Array.BYTES_PER_ELEMENT * t10[0]), c6.triangleCount += t10[1] / 3);
  }
  _setStencilState(e16, t10) {
    const { context: i7, is3D: a11, stencilSymbols: r14 } = e16;
    if (i7.setStencilTestEnabled(true), r14) return i7.setStencilWriteMask(255), void i7.setStencilFunction(519, t10.stencilRef, 255);
    i7.setStencilWriteMask(0), a11 ? i7.setStencilFunction(514, t10.stencilRef, 255) : i7.setStencilFunction(516, 255, 255);
  }
};

// node_modules/@arcgis/core/views/2d/engine/brushes.js
var m3 = { clip: l4, stencil: n15, tileDebugInfo: x2, vtlBackground: m2, vtlFill: r12, vtlLine: a10, vtlCircle: a9, vtlSymbol: c4 };

// node_modules/@arcgis/core/views/2d/engine/webgl/Mesh2D.js
var l6 = (e16, r14, t10, o9) => {
  let n17 = 0;
  for (let s9 = 1; s9 < t10; s9++) {
    const t11 = e16[2 * (r14 + s9 - 1)], o10 = e16[2 * (r14 + s9 - 1) + 1];
    n17 += (e16[2 * (r14 + s9)] - t11) * (e16[2 * (r14 + s9) + 1] + o10);
  }
  return o9 ? n17 > 0 : n17 < 0;
};
var u6 = ({ coords: e16, lengths: r14 }, o9) => {
  const n17 = [];
  for (let s9 = 0, i7 = 0; s9 < r14.length; i7 += r14[s9], s9 += 1) {
    const c6 = i7, a11 = [];
    for (; s9 < r14.length - 1 && l6(e16, i7 + r14[s9], r14[s9 + 1], o9); s9 += 1, i7 += r14[s9]) a11.push(i7 + r14[s9] - c6);
    const f5 = e16.slice(2 * c6, 2 * (i7 + r14[s9])), m4 = e5(f5, a11, 2);
    for (const e17 of m4) n17.push(e17 + c6);
  }
  return n17;
};
var x3 = class _x {
  constructor(e16, r14, t10, o9 = false) {
    this.vertices = e16, this.indices = r14, this.primitiveType = t10, this.isMapSpace = o9, this._cache = {};
  }
  static fromPath(e16) {
    const r14 = tt(new e(), e16.path, false, false), t10 = r14.coords, o9 = new Uint32Array(u6(r14, true)), n17 = new Uint32Array(t10.length / 2);
    for (let s9 = 0; s9 < n17.length; s9++) n17[s9] = s3(Math.floor(t10[2 * s9]), Math.floor(t10[2 * s9 + 1]));
    return new _x(n17, o9, _.TRIANGLES);
  }
  static fromGeometry(t10, o9) {
    const n17 = o9.geometry?.type;
    switch (n17) {
      case "polygon":
        return _x.fromPolygon(t10, o9.geometry);
      case "extent":
        return _x.fromMapExtent(t10, o9.geometry);
      default:
        return i.getLogger("esri.views.2d.engine.webgl.Mesh2D").error(new s("mapview-bad-type", `Unable to create a mesh from type ${n17}`, o9)), _x.fromScreenExtent({ xmin: 0, ymin: 0, xmax: 1, ymax: 1 });
    }
  }
  static fromPolygon(e16, r14) {
    const t10 = X(new e(), r14, false, false), s9 = t10.coords, f5 = new Uint32Array(u6(t10, false)), h9 = new Uint32Array(s9.length / 2), l7 = n3(), p2 = n3();
    for (let n17 = 0; n17 < h9.length; n17++) o(l7, s9[2 * n17], s9[2 * n17 + 1]), e16.toScreen(p2, l7), h9[n17] = s3(Math.floor(p2[0]), Math.floor(p2[1]));
    return new _x(h9, f5, _.TRIANGLES, true);
  }
  static fromScreenExtent({ xmin: e16, xmax: r14, ymin: t10, ymax: o9 }) {
    const n17 = new Uint32Array([s3(e16, t10), s3(r14, t10), s3(e16, o9), s3(e16, o9), s3(r14, t10), s3(r14, o9)]), s9 = new Uint32Array([0, 1, 2, 3, 4, 5]);
    return new _x(n17, s9, _.TRIANGLES);
  }
  static fromMapExtent(e16, r14) {
    const [t10, o9] = e16.toScreen([0, 0], [r14.xmin, r14.ymin]), [n17, s9] = e16.toScreen([0, 0], [r14.xmax, r14.ymax]), i7 = new Uint32Array([s3(t10, o9), s3(n17, o9), s3(t10, s9), s3(t10, s9), s3(n17, o9), s3(n17, s9)]), c6 = new Uint32Array([0, 1, 2, 3, 4, 5]);
    return new _x(i7, c6, _.TRIANGLES);
  }
  destroy() {
    null != this._cache.indexBuffer && this._cache.indexBuffer.dispose(), this._cache.vertexBuffer?.dispose(), this._cache.indexBuffer = this._cache.vertexBuffer = null;
  }
  getIndexBuffer(e16, r14 = 35044) {
    return this._cache.indexBuffer ??= o5.createIndex(e16, r14, this.indices), this._cache.indexBuffer;
  }
  getVertexBuffers(e16, r14) {
    return this._cache.vertexBuffer ??= new r5(e16, r14, this.vertices), this._cache.vertexBuffer;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/ClippingInfo.js
var c5 = class _c extends e10 {
  constructor(e16, t10) {
    super(), this._clip = t10, this._cache = {}, this.stage = e16, this._handle = l(() => t10.version, () => this._invalidate()), this.ready();
  }
  static fromClipArea(e16, t10) {
    return new _c(e16, t10);
  }
  _destroyGL() {
    null != this._cache.mesh && (this._cache.mesh.destroy(), this._cache.mesh = null), null != this._cache.vao && (this._cache.vao.dispose(), this._cache.vao = null);
  }
  destroy() {
    super.destroy(), this._destroyGL(), this._handle.remove();
  }
  getVAO(e16, t10, r14) {
    const [s9, i7] = t10.size;
    if ("geometry" !== this._clip.type && this._lastWidth === s9 && this._lastHeight === i7 || (this._lastWidth = s9, this._lastHeight = i7, this._destroyGL()), null == this._cache.vao) {
      const s10 = this._createMesh(t10, this._clip), i8 = s10.getIndexBuffer(e16), o9 = s10.getVertexBuffers(e16, r14);
      this._cache.mesh = s10, this._cache.vao = new h5(e16, o9, i8);
    }
    return this._cache.vao;
  }
  _createTransforms() {
    return { displayViewScreenMat3: e7() };
  }
  _invalidate() {
    this._destroyGL(), this.requestRender();
  }
  _createMesh(r14, s9) {
    switch (s9.type) {
      case "rect":
        return x3.fromScreenExtent(n10(s9, r14.size[0], r14.size[1]));
      case "path":
        return x3.fromPath(s9);
      case "geometry":
        return x3.fromGeometry(r14, s9);
      default:
        return i.getLogger("esri.views.2d.engine.webgl.ClippingInfo").error(new s("mapview-bad-type", "Unable to create ClippingInfo mesh from clip of type: ${clip.type}")), x3.fromScreenExtent({ xmin: 0, ymin: 0, xmax: 1, ymax: 1 });
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/WGLContainer.js
var i6 = class extends n9 {
  set clips(e16) {
    super.clips = e16, this._updateClippingInfo(e16);
  }
  renderChildren(e16) {
    e16.painter.setPipelineState(null), null == this._renderPasses && (this._renderPasses = this.prepareRenderPasses(e16.painter));
    for (const r14 of this._renderPasses) try {
      r14.render(e16);
    } catch (s9) {
    }
  }
  prepareRenderPasses(s9) {
    return [s9.registerRenderPass({ name: "clip", brushes: [m3.clip], target: () => this._clippingInfos, drawPhase: 87 })];
  }
  _updateClippingInfo(e16) {
    null != this._clippingInfos && (this._clippingInfos.forEach((e17) => e17.destroy()), this._clippingInfos = null), null != e16 && e16.length && (this._clippingInfos = e16.items.map((e17) => c5.fromClipArea(this.stage, e17))), this.requestRender();
  }
};

export {
  n11 as n,
  t8 as t,
  n12 as n2,
  r7 as r,
  n13 as n3,
  i5 as i,
  n15 as n4,
  r8 as r2,
  a5 as a,
  b,
  x2 as x,
  e15 as e,
  m3 as m,
  i6 as i2
};
//# sourceMappingURL=chunk-43423NKQ.js.map
