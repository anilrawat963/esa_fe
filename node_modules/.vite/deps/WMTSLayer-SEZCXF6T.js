import {
  o as o4
} from "./chunk-LAJ2QATM.js";
import {
  U as U2,
  p as p2
} from "./chunk-WL35VWQQ.js";
import {
  e
} from "./chunk-EEFFS5EK.js";
import {
  o as o2
} from "./chunk-TG6K2MFM.js";
import {
  o as o3
} from "./chunk-Y2QJFDQ5.js";
import {
  f as f2
} from "./chunk-TCDV4P3G.js";
import {
  b2 as b
} from "./chunk-CZOYDK6P.js";
import {
  j
} from "./chunk-6TCXGIIN.js";
import {
  l as l2
} from "./chunk-NP2TBOXH.js";
import "./chunk-H34D76ZQ.js";
import {
  l as l3,
  z as z2
} from "./chunk-YP3WVJP3.js";
import "./chunk-M24KZOVI.js";
import {
  p
} from "./chunk-PEL3D3ZN.js";
import "./chunk-Q5KWD3VQ.js";
import "./chunk-BUQC3CLV.js";
import {
  t as t2
} from "./chunk-W5S3VUFT.js";
import "./chunk-7YH7T6CS.js";
import "./chunk-3T4IXPP4.js";
import "./chunk-XTZAIV4X.js";
import "./chunk-63LDVRFI.js";
import "./chunk-MC6NAKKX.js";
import "./chunk-TF6255HN.js";
import "./chunk-C5OQVQZF.js";
import "./chunk-CNYNCKEV.js";
import "./chunk-XL5QPCXN.js";
import "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-W75DBJD7.js";
import {
  b as b2
} from "./chunk-P6IKJIMO.js";
import "./chunk-MHV23XAQ.js";
import "./chunk-V2X4OKYI.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import "./chunk-W6J7XCPU.js";
import "./chunk-ONXWBTTM.js";
import "./chunk-T7F6Q6JJ.js";
import {
  O
} from "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-7P2ANHQ3.js";
import "./chunk-XCKT47LJ.js";
import "./chunk-3FUHCAX3.js";
import "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import {
  z
} from "./chunk-H74Q4SYB.js";
import {
  U,
  a as a3,
  l
} from "./chunk-2OFHDVO5.js";
import "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-5UPBUJPC.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import "./chunk-SMWUT52Z.js";
import {
  _
} from "./chunk-AXZMNHTN.js";
import "./chunk-5T3MJDSR.js";
import {
  A2,
  r
} from "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import {
  A,
  H2 as H,
  I
} from "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import {
  o
} from "./chunk-XWE6BM2U.js";
import {
  r as r2
} from "./chunk-SOIZOFSB.js";
import {
  n
} from "./chunk-XXLHAM2M.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import {
  f2 as f
} from "./chunk-GNMPGHLQ.js";
import {
  a,
  s2 as s,
  t
} from "./chunk-QY7XKUIV.js";
import {
  N
} from "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/layers/support/TileMatrixSet.js
var l4;
var n2 = l4 = class extends n {
  constructor(t3) {
    super(t3), this.fullExtent = null, this.id = null, this.tileInfo = null;
  }
  clone() {
    const t3 = new l4();
    return this.hasOwnProperty("fullExtent") && (t3.fullExtent = this.fullExtent?.clone() ?? null), this.hasOwnProperty("id") && (t3.id = this.id), this.hasOwnProperty("tileInfo") && (t3.tileInfo = this.tileInfo?.clone() ?? null), t3;
  }
};
__decorate([m({ type: z, json: { read: { source: "fullExtent" } } })], n2.prototype, "fullExtent", void 0), __decorate([m({ type: String, json: { read: { source: "id" } } })], n2.prototype, "id", void 0), __decorate([m({ type: z2, json: { read: { source: "tileInfo" } } })], n2.prototype, "tileInfo", void 0), n2 = l4 = __decorate([a2("esri.layers.support.TileMatrixSet")], n2);
var p3 = n2;

// node_modules/@arcgis/core/layers/support/WMTSStyle.js
var s2;
var i = s2 = class extends n {
  constructor(r3) {
    super(r3), this.id = null, this.title = null, this.description = null, this.legendUrl = null;
  }
  clone() {
    const r3 = new s2();
    return this.hasOwnProperty("description") && (r3.description = this.description), this.hasOwnProperty("id") && (r3.id = this.id), this.hasOwnProperty("isDefault") && (r3.isDefault = this.isDefault), this.hasOwnProperty("keywords") && (r3.keywords = this.keywords && this.keywords.slice()), this.hasOwnProperty("legendUrl") && (r3.legendUrl = this.legendUrl), this.hasOwnProperty("title") && (r3.title = this.title), r3;
  }
};
__decorate([m({ json: { read: { source: "id" } } })], i.prototype, "id", void 0), __decorate([m({ json: { read: { source: "title" } } })], i.prototype, "title", void 0), __decorate([m({ json: { read: { source: "abstract" } } })], i.prototype, "description", void 0), __decorate([m({ json: { read: { source: "legendUrl" } } })], i.prototype, "legendUrl", void 0), __decorate([m({ json: { read: { source: "isDefault" } } })], i.prototype, "isDefault", void 0), __decorate([m({ json: { read: { source: "keywords" } } })], i.prototype, "keywords", void 0), i = s2 = __decorate([a2("esri.layers.support.WMTSStyle")], i);
var p4 = i;

// node_modules/@arcgis/core/layers/support/WMTSSublayer.js
var p5;
var m2 = p5 = class extends n {
  constructor(t3) {
    super(t3), this.description = null, this.fullExtent = null, this.fullExtents = null, this.id = null, this.imageFormats = null, this.layer = null, this.parent = null, this.styles = null, this.title = null, this.tileMatrixSetId = null, this.tileMatrixSets = null;
  }
  readFullExtent(t3, e2) {
    return (t3 = e2.fullExtent) ? z.fromJSON(t3) : null;
  }
  readFullExtents(t3, e2) {
    return e2.fullExtents?.length ? e2.fullExtents.map((t4) => z.fromJSON(t4)) : e2.tileMatrixSets?.map((t4) => z.fromJSON(t4.fullExtent)).filter((t4) => t4) ?? [];
  }
  get imageFormat() {
    let t3 = this._get("imageFormat");
    return t3 || (t3 = this.imageFormats?.length ? this.imageFormats[0] : ""), t3;
  }
  set imageFormat(t3) {
    const e2 = this.imageFormats;
    t3 && (t3.includes("image/") || e2 && !e2.includes(t3)) && (t3.includes("image/") || (t3 = "image/" + t3), e2 && !e2.includes(t3)) ? console.error("The layer doesn't support the format of " + t3) : this._set("imageFormat", t3);
  }
  get styleId() {
    let t3 = this._get("styleId");
    return t3 || (t3 = this.styles?.at(0)?.id ?? ""), t3;
  }
  set styleId(t3) {
    this._set("styleId", t3);
  }
  get tileMatrixSet() {
    return this.tileMatrixSets?.find(({ id: t3 }) => t3 === this.tileMatrixSetId) ?? null;
  }
  clone() {
    const t3 = new p5();
    return this.hasOwnProperty("description") && (t3.description = this.description), this.hasOwnProperty("imageFormats") && (t3.imageFormats = this.imageFormats?.slice() ?? null), this.hasOwnProperty("imageFormat") && (t3.imageFormat = this.imageFormat), this.hasOwnProperty("fullExtent") && (t3.fullExtent = this.fullExtent?.clone()), this.hasOwnProperty("id") && (t3.id = this.id), this.hasOwnProperty("layer") && (t3.layer = this.layer), this.hasOwnProperty("styleId") && (t3.styleId = this.styleId), this.hasOwnProperty("styles") && (t3.styles = this.styles?.clone()), this.hasOwnProperty("tileMatrixSetId") && (t3.tileMatrixSetId = this.tileMatrixSetId), this.hasOwnProperty("tileMatrixSets") && (t3.tileMatrixSets = this.tileMatrixSets?.clone()), this.hasOwnProperty("title") && (t3.title = this.title), t3;
  }
};
__decorate([m()], m2.prototype, "description", void 0), __decorate([m({ type: z })], m2.prototype, "fullExtent", void 0), __decorate([o("fullExtent", ["fullExtent"])], m2.prototype, "readFullExtent", null), __decorate([m({ readOnly: true })], m2.prototype, "fullExtents", void 0), __decorate([o("fullExtents", ["fullExtents", "tileMatrixSets"])], m2.prototype, "readFullExtents", null), __decorate([m()], m2.prototype, "id", void 0), __decorate([m()], m2.prototype, "imageFormat", null), __decorate([m({ json: { read: { source: "formats" } } })], m2.prototype, "imageFormats", void 0), __decorate([m()], m2.prototype, "layer", void 0), __decorate([m()], m2.prototype, "parent", void 0), __decorate([m()], m2.prototype, "styleId", null), __decorate([m({ type: O.ofType(p4), json: { read: { source: "styles" } } })], m2.prototype, "styles", void 0), __decorate([m({ json: { write: { ignoreOrigin: true } } })], m2.prototype, "title", void 0), __decorate([m()], m2.prototype, "tileMatrixSetId", void 0), __decorate([m({ readOnly: true })], m2.prototype, "tileMatrixSet", null), __decorate([m({ type: O.ofType(p3), json: { read: { source: "tileMatrixSets" } } })], m2.prototype, "tileMatrixSets", void 0), m2 = p5 = __decorate([a2("esri.layers.support.WMTSSublayer")], m2);

// node_modules/@arcgis/core/layers/support/wmtsUtils.js
var u = 90.71428571428571;
function p6(e2) {
  const t3 = e2.replaceAll(/ows:/gi, "");
  return new DOMParser().parseFromString(t3, "text/xml");
}
function f3(e2) {
  if (!g("Contents", e2.documentElement)) throw new s("wmtslayer:wmts-capabilities-xml-is-not-valid", "the wmts get capabilities response is not compliant");
}
function d(e2, i2) {
  const n3 = e2.documentElement, l5 = /* @__PURE__ */ new Map(), r3 = /* @__PURE__ */ new Map(), o5 = g("Contents", n3);
  if (!o5) throw new s("wmtslayer:wmts-capabilities-xml-is-not-valid", "Can't retrieve xml capabilities element");
  const s3 = g("OperationsMetadata", n3), a4 = s3?.querySelector("[name='GetTile']"), c = a4?.getElementsByTagName("Get"), u2 = c && Array.prototype.slice.call(c), p7 = i2.url?.indexOf("https"), f4 = void 0 !== p7 && p7 > -1;
  let d2, m4, x2 = i2.serviceMode, w2 = i2?.url;
  if (u2?.length && u2.some((e3) => {
    const t3 = g("Constraint", e3);
    return !t3 || C("AllowedValues", "Value", x2, t3) ? (w2 = e3.attributes[0].nodeValue, true) : (!t3 || C("AllowedValues", "Value", "RESTful", t3) || C("AllowedValues", "Value", "REST", t3) ? m4 = e3.attributes[0].nodeValue : t3 && !C("AllowedValues", "Value", "KVP", t3) || (d2 = e3.attributes[0].nodeValue), false);
  }), !w2) if (m4) w2 = m4, x2 = "RESTful";
  else if (d2) w2 = d2, x2 = "KVP";
  else {
    const e3 = g("ServiceMetadataURL", n3);
    w2 = e3?.getAttribute("xlink:href");
  }
  const y2 = w2.indexOf("1.0.0/");
  -1 === y2 && "RESTful" === x2 ? w2 += "/" : y2 > -1 && (w2 = w2.slice(0, y2)), "KVP" === x2 && (w2 += y2 > -1 ? "" : "?"), f4 && (w2 = w2.replace(/^http:/i, "https:"));
  const A4 = M("ServiceIdentification>ServiceTypeVersion", n3), R2 = M("ServiceIdentification>AccessConstraints", n3), S2 = R2 && /^none$/i.test(R2) ? null : R2, V3 = h("Layer", o5), L2 = h("TileMatrixSet", o5), b4 = V3.map((e3) => {
    const t3 = M("Identifier", e3);
    return l5.set(t3, e3), T(t3, e3, L2, f4, A4);
  });
  return { copyright: S2, dimensionMap: r3, layerMap: l5, layers: b4, serviceMode: x2, tileUrl: w2 };
}
function m3(e2) {
  for (const t3 of e2.layers) for (const e3 of t3.tileMatrixSets ?? []) {
    const { tileInfo: t4 } = e3;
    if (t4 && 96 !== t4.dpi) {
      for (const i2 of t4.lods ?? []) i2.scale = 96 * i2.scale / t4.dpi, i2.resolution = j2(t4.spatialReference?.wkid, i2.scale * u / 96, e3.id);
      t4.dpi = 96;
    }
  }
}
function x(e2) {
  return e2.nodeType === Node.ELEMENT_NODE;
}
function g(e2, t3) {
  for (let i2 = 0; i2 < t3.childNodes.length; i2++) {
    const n3 = t3.childNodes[i2];
    if (x(n3) && n3.nodeName === e2) return n3;
  }
  return null;
}
function h(e2, t3) {
  const i2 = [];
  for (let n3 = 0; n3 < t3.childNodes.length; n3++) {
    const l5 = t3.childNodes[n3];
    x(l5) && l5.nodeName === e2 && i2.push(l5);
  }
  return i2;
}
function w(t3, i2) {
  const n3 = [];
  for (let e2 = 0; e2 < i2.childNodes.length; e2++) {
    const l5 = i2.childNodes[e2];
    x(l5) && l5.nodeName === t3 && n3.push(l5);
  }
  return n3.map((e2) => e2.textContent).filter(N);
}
function M(e2, t3) {
  return e2.split(">").forEach((e3) => {
    t3 && (t3 = g(e3, t3));
  }), t3 && t3.textContent;
}
function C(e2, t3, i2, n3) {
  let l5;
  return Array.prototype.slice.call(n3.childNodes).some((n4) => {
    if (n4.nodeName.includes(e2)) {
      const e3 = g(t3, n4), r3 = e3?.textContent;
      if (r3 === i2 || i2.split(":") && i2.split(":")[1] === r3) return l5 = n4, true;
    }
    return false;
  }), l5;
}
function T(e2, t3, i2, n3, l5) {
  const r3 = M("Abstract", t3), o5 = w("Format", t3);
  return { id: e2, fullExtent: V(t3), fullExtents: L(t3), description: r3, formats: o5, styles: b3(t3, n3), title: M("Title", t3), tileMatrixSets: E(l5, t3, i2) };
}
function y(e2, t3) {
  const i2 = [], n3 = e2.layerMap?.get(t3);
  if (!n3) return null;
  const l5 = h("ResourceURL", n3), r3 = h("Dimension", n3);
  let o5, s3, a4, c;
  return r3.length && (o5 = M("Identifier", r3[0]), s3 = w("Default", r3[0]) || w("Value", r3[0])), r3.length > 1 && (a4 = M("Identifier", r3[1]), c = w("Default", r3[1]) || w("Value", r3[1])), e2.dimensionMap.set(t3, { dimensions: s3, dimensions2: c }), l5.forEach((e3) => {
    let t4 = e3.getAttribute("template");
    if ("tile" === e3.getAttribute("resourceType")) {
      if (o5 && s3.length) if (t4.includes("{" + o5 + "}")) t4 = t4.replace("{" + o5 + "}", "{dimensionValue}");
      else {
        const e4 = t4.toLowerCase().indexOf("{" + o5.toLowerCase() + "}");
        e4 > -1 && (t4 = t4.slice(0, e4) + "{dimensionValue}" + t4.slice(e4 + o5.length + 2));
      }
      if (a4 && c.length) if (t4.includes("{" + a4 + "}")) t4 = t4.replace("{" + a4 + "}", "{dimensionValue2}");
      else {
        const e4 = t4.toLowerCase().indexOf("{" + a4.toLowerCase() + "}");
        e4 > -1 && (t4 = t4.slice(0, e4) + "{dimensionValue2}" + t4.slice(e4 + a4.length + 2));
      }
      i2.push({ template: t4, format: e3.getAttribute("format"), resourceType: "tile" });
    }
  }), i2;
}
function A3(e2, t3, i2, n3, l5, r3, o5, s3) {
  const a4 = R(e2, t3, n3);
  if (!(a4?.length > 0)) return "";
  const { dimensionMap: c } = e2, u2 = c.get(t3).dimensions?.[0], p7 = c.get(t3).dimensions2?.[0];
  return a4[o5 % a4.length].template.replaceAll(/\{Style\}/gi, l5 ?? "").replaceAll(/\{TileMatrixSet\}/gi, i2 ?? "").replaceAll(/\{TileMatrix\}/gi, r3).replaceAll(/\{TileRow\}/gi, "" + o5).replaceAll(/\{TileCol\}/gi, "" + s3).replaceAll(/\{dimensionValue\}/gi, u2).replaceAll(/\{dimensionValue2\}/gi, p7);
}
function R(e2, t3, i2) {
  const n3 = y(e2, t3), l5 = n3?.filter((e3) => e3.format === i2);
  return (l5?.length ? l5 : n3) ?? [];
}
function S(e2, t3, i2, n3) {
  const { dimensionMap: l5 } = e2, r3 = y(e2, t3);
  let o5 = "";
  if (r3 && r3.length > 0) {
    const e3 = l5.get(t3).dimensions?.[0], s3 = l5.get(t3).dimensions2?.[0];
    o5 = r3[0].template, o5.endsWith(".xxx") && (o5 = o5.slice(0, -4)), o5 = o5.replaceAll(/\{Style\}/gi, n3), o5 = o5.replaceAll(/\{TileMatrixSet\}/gi, i2), o5 = o5.replaceAll(/\{TileMatrix\}/gi, "{level}"), o5 = o5.replaceAll(/\{TileRow\}/gi, "{row}"), o5 = o5.replaceAll(/\{TileCol\}/gi, "{col}"), o5 = o5.replaceAll(/\{dimensionValue\}/gi, e3), o5 = o5.replaceAll(/\{dimensionValue2\}/gi, s3);
  }
  return o5;
}
function V(e2) {
  const t3 = g("WGS84BoundingBox", e2), i2 = t3 ? M("LowerCorner", t3).split(" ") : ["-180", "-90"], n3 = t3 ? M("UpperCorner", t3).split(" ") : ["180", "90"];
  return { xmin: parseFloat(i2[0]), ymin: parseFloat(i2[1]), xmax: parseFloat(n3[0]), ymax: parseFloat(n3[1]), spatialReference: { wkid: 4326 } };
}
function L(e2) {
  const t3 = [];
  return o3(e2, { BoundingBox: (e3) => {
    if (!e3.getAttribute("crs")) return;
    const i2 = e3.getAttribute("crs").toLowerCase(), n3 = N2(i2), l5 = i2.includes("epsg") && o4(n3.wkid);
    let r3, a4, c, u2;
    o3(e3, { LowerCorner: (e4) => {
      [r3, a4] = e4.textContent.split(" ").map((e5) => Number.parseFloat(e5)), l5 && ([r3, a4] = [a4, r3]);
    }, UpperCorner: (e4) => {
      [c, u2] = e4.textContent.split(" ").map((e5) => Number.parseFloat(e5)), l5 && ([c, u2] = [u2, c]);
    } }), t3.push({ xmin: r3, ymin: a4, xmax: c, ymax: u2, spatialReference: n3 });
  } }), t3;
}
function b3(e2, t3) {
  return h("Style", e2).map((e3) => {
    const i2 = g("LegendURL", e3), n3 = g("Keywords", e3), l5 = n3 ? w("Keyword", n3) : [];
    let r3 = i2?.getAttribute("xlink:href");
    t3 && (r3 = r3?.replace(/^http:/i, "https:"));
    return { abstract: M("Abstract", e3), id: M("Identifier", e3), isDefault: "true" === e3.getAttribute("isDefault"), keywords: l5, legendUrl: r3, title: M("Title", e3) };
  });
}
function E(e2, t3, i2) {
  return h("TileMatrixSetLink", t3).map((t4) => I2(e2, t4, i2));
}
function I2(e2, t3, i2) {
  const n3 = g("TileMatrixSet", t3).textContent, l5 = w("TileMatrix", t3), r3 = i2.find((e3) => {
    const t4 = g("Identifier", e3), i3 = t4?.textContent;
    return !!(i3 === n3 || n3.split(":") && n3.split(":")[1] === i3);
  }), o5 = g("TileMatrixSetLimits", t3), s3 = o5 && h("TileMatrixLimits", o5), a4 = /* @__PURE__ */ new Map();
  if (s3?.length) for (const c of s3) {
    const e3 = g("TileMatrix", c).textContent, t4 = +g("MinTileRow", c).textContent, i3 = +g("MaxTileRow", c).textContent, n4 = +g("MinTileCol", c).textContent, l6 = +g("MaxTileCol", c).textContent;
    a4.set(e3, { minCol: n4, maxCol: l6, minRow: t4, maxRow: i3 });
  }
  const u2 = M("SupportedCRS", r3).toLowerCase(), p7 = v(r3, u2), f4 = p7.spatialReference, d2 = g("TileMatrix", r3), m4 = [parseInt(M("TileWidth", d2), 10), parseInt(M("TileHeight", d2), 10)], x2 = [];
  if (l5.length) l5.forEach((e3, t4) => {
    const i3 = C("TileMatrix", "Identifier", e3, r3);
    x2.push(O2(i3, u2, t4, n3, a4));
  });
  else {
    h("TileMatrix", r3).forEach((e3, t4) => {
      x2.push(O2(e3, u2, t4, n3, a4));
    });
  }
  const T2 = U3(e2, r3, p7, m4, x2[0]).toJSON(), y2 = new z2({ dpi: 96, spatialReference: f4, size: m4, origin: p7, lods: x2 }).toJSON();
  return { id: n3, fullExtent: T2, tileInfo: y2 };
}
function N2(e2) {
  e2 = e2.toLowerCase();
  let t3 = parseInt(e2.split(":").pop(), 10);
  900913 !== t3 && 3857 !== t3 || (t3 = 102100);
  const i2 = D(e2);
  return null != i2 && (t3 = i2), { wkid: t3 };
}
function v(e2, t3) {
  return F(g("TileMatrix", e2), t3);
}
function F(e2, t3) {
  const i2 = N2(t3), [n3, r3] = M("TopLeftCorner", e2).split(" ").map((e3) => parseFloat(e3)), s3 = t3.includes("epsg") && o4(i2.wkid);
  return new _(s3 ? { x: r3, y: n3, spatialReference: i2 } : { x: n3, y: r3, spatialReference: i2 });
}
function U3(e2, t3, i2, l5, r3) {
  const o5 = g("BoundingBox", t3);
  let s3, a4, c, u2, p7, f4;
  if (o5 && (s3 = M("LowerCorner", o5).split(" "), a4 = M("UpperCorner", o5).split(" ")), s3 && s3.length > 1 && a4 && a4.length > 1) c = parseFloat(s3[0]), p7 = parseFloat(s3[1]), u2 = parseFloat(a4[0]), f4 = parseFloat(a4[1]);
  else {
    const e3 = g("TileMatrix", t3), n3 = parseInt(M("MatrixWidth", e3), 10), o6 = parseInt(M("MatrixHeight", e3), 10);
    c = i2.x, f4 = i2.y, u2 = c + n3 * l5[0] * r3.resolution, p7 = f4 - o6 * l5[1] * r3.resolution;
  }
  return k(e2, i2.spatialReference, i2) ? new z(p7, c, f4, u2, i2.spatialReference) : new z(c, p7, u2, f4, i2.spatialReference);
}
function k(e2, t3, i2) {
  return "1.0.0" === e2 && o4(t3.wkid) && !(i2.spatialReference.isGeographic && i2.x < -90 && i2.y >= -90);
}
function D(e2) {
  return e2.includes("crs84") || e2.includes("crs:84") ? 4326 : e2.includes("crs83") || e2.includes("crs:83") ? 4269 : e2.includes("crs27") || e2.includes("crs:27") ? 4267 : null;
}
function O2(e2, t3, i2, n3, l5) {
  const r3 = N2(t3), o5 = M("Identifier", e2);
  let s3 = parseFloat(M("ScaleDenominator", e2));
  const c = j2(r3.wkid, s3, n3);
  s3 *= 96 / u;
  const p7 = +M("MatrixWidth", e2), f4 = +M("MatrixHeight", e2), { maxCol: d2 = p7 - 1, maxRow: m4 = f4 - 1, minCol: x2 = 0, minRow: g2 = 0 } = l5.get(o5) ?? {}, { x: h2, y: w2 } = F(e2, t3);
  return new l3({ cols: [x2, d2], level: i2, levelValue: o5, origin: [h2, w2], scale: s3, resolution: c, rows: [g2, m4] });
}
function j2(e2, t3, n3) {
  let l5;
  return l5 = r.hasOwnProperty("" + e2) ? r.values[r[e2]] : "default028mm" === n3 ? 6370997 * Math.PI / 180 : A2(e2).metersPerDegree, 7 * t3 / 25e3 / l5;
}

// node_modules/@arcgis/core/layers/WMTSLayer.js
var F2;
var V2 = { "image/png": ".png", "image/png8": ".png", "image/png24": ".png", "image/png32": ".png", "image/jpg": ".jpg", "image/jpeg": ".jpeg", "image/gif": ".gif", "image/bmp": ".bmp", "image/tiff": ".tif", "image/jpgpng": "", "image/jpegpng": "", "image/unknown": "" };
var B = /* @__PURE__ */ new Set(["version", "service", "request", "layer", "style", "format", "tilematrixset", "tilematrix", "tilerow", "tilecol"]);
var $ = F2 = class extends p(f2(t2(b(j(l2(b2)))))) {
  constructor(...e2) {
    super(...e2), this.activeLayer = null, this.copyright = "", this.customParameters = null, this.customLayerParameters = null, this.fullExtent = null, this.operationalLayerType = "WebTiledLayer", this.resourceInfo = null, this.serviceMode = "RESTful", this.sublayers = null, this.type = "wmts", this.version = "1.0.0", this.addHandles([l(() => this.activeLayer, (e3, t3) => {
      t3 && !this.sublayers?.includes(t3) && (t3.layer = null, t3.parent = null), e3 && (e3.layer = this, e3.parent = this);
    }, U), a3(() => this.sublayers, "after-add", ({ item: e3 }) => {
      e3.layer = this, e3.parent = this;
    }, U), a3(() => this.sublayers, "after-remove", ({ item: e3 }) => {
      e3.layer = null, e3.parent = null;
    }, U), l(() => this.sublayers, (e3, t3) => {
      if (t3) for (const r3 of t3) r3.layer = null, r3.parent = null;
      if (e3) for (const r3 of e3) r3.layer = this, r3.parent = this;
    }, U)]);
  }
  normalizeCtorArgs(e2, t3) {
    return "string" == typeof e2 ? { url: e2, ...t3 } : e2;
  }
  load(e2) {
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["WMTS"] }, e2).catch(f).then(() => this._fetchService(e2)).catch((e3) => {
      throw f(e3), new s("wmtslayer:unsupported-service-data", "Invalid response from the WMTS service.", { error: e3 });
    })), Promise.resolve(this);
  }
  readActiveLayerFromService(e2, t3, r3) {
    this.activeLayer || (this.activeLayer = new m2());
    let i2 = t3.layers.find((e3) => e3.id === this.activeLayer.id);
    return i2 || (i2 = t3.layers[0]), this.activeLayer.read(i2, r3), this.activeLayer;
  }
  readActiveLayerFromItemOrWebDoc(e2, t3) {
    const { templateUrl: r3, wmtsInfo: i2 } = t3, s3 = r3 ? this._getLowerCasedUrlParams(r3) : null, a4 = i2?.layerIdentifier;
    let o5 = null;
    const l5 = i2?.tileMatrixSet;
    l5 && (Array.isArray(l5) ? l5.length && (o5 = l5[0]) : o5 = l5);
    const n3 = s3?.format, m4 = s3?.style;
    return new m2({ id: a4, imageFormat: n3, styleId: m4, tileMatrixSetId: o5 });
  }
  writeActiveLayer(e2, t3, r3, i2) {
    const s3 = this.activeLayer;
    t3.templateUrl = this.getUrlTemplate(s3.id, s3.tileMatrixSetId, s3.imageFormat, s3.styleId);
    const a4 = t("tileMatrixSet.tileInfo", s3);
    t3.tileInfo = a4 ? a4.toJSON(i2) : null, t3.wmtsInfo = { ...t3.wmtsInfo, layerIdentifier: s3.id, tileMatrixSet: s3.tileMatrixSetId };
  }
  readCustomParameters(e2, t3) {
    const r3 = t3.wmtsInfo;
    return r3 ? this._mergeParams(r3.customParameters, r3.url) : null;
  }
  get fullExtents() {
    return this.activeLayer.fullExtents;
  }
  readServiceMode(e2, t3) {
    return t3.templateUrl.includes("?") ? "KVP" : "RESTful";
  }
  readSublayersFromService(e2, t3, r3) {
    return K(t3.layers, r3);
  }
  get supportedSpatialReferences() {
    return this.activeLayer.tileMatrixSets?.map((e2) => e2.tileInfo?.spatialReference).toArray().filter(N) ?? [];
  }
  get tilemapCache() {
    const e2 = this.activeLayer?.tileMatrixSet?.tileInfo;
    return e2 ? new e(e2) : void 0;
  }
  get title() {
    return this.activeLayer?.title ?? "Layer";
  }
  set title(e2) {
    this._overrideIfSome("title", e2);
  }
  get url() {
    return this._get("url");
  }
  set url(e2) {
    e2 && e2.endsWith("/") ? this._set("url", e2.slice(0, -1)) : this._set("url", e2);
  }
  createWebTileLayer(e2) {
    const t3 = this.getUrlTemplate(this.activeLayer.id, this.activeLayer.tileMatrixSetId, this.activeLayer.imageFormat, this.activeLayer.styleId), r3 = this._getTileMatrixSetById(e2.tileMatrixSetId), i2 = r3?.tileInfo, s3 = e2.fullExtent, a4 = new p2({ layerIdentifier: e2.id, tileMatrixSet: e2.tileMatrixSetId, url: this.url });
    return this.customLayerParameters && (a4.customLayerParameters = this.customLayerParameters), this.customParameters && (a4.customParameters = this.customParameters), new U2({ fullExtent: s3, urlTemplate: t3, tileInfo: i2, wmtsInfo: a4 });
  }
  async fetchTile(e2, r3, i2, s3 = {}) {
    const { signal: a4 } = s3, o5 = this.getTileUrl(e2, r3, i2), { data: l5 } = await H(o5, { responseType: "image", signal: a4 });
    return l5;
  }
  async fetchImageBitmapTile(e2, r3, i2, s3 = {}) {
    const { signal: a4 } = s3;
    if (this.fetchTile !== F2.prototype.fetchTile) {
      const t3 = await this.fetchTile(e2, r3, i2, s3);
      return o2(t3, e2, r3, i2, a4);
    }
    const o5 = this.getTileUrl(e2, r3, i2), { data: l5 } = await H(o5, { responseType: "blob", signal: a4 });
    return o2(l5, e2, r3, i2, a4);
  }
  findSublayerById(e2) {
    return this.sublayers?.find((t3) => t3.id === e2);
  }
  getTileUrl(e2, t3, r3) {
    const i2 = this._getTileMatrixSetById(this.activeLayer.tileMatrixSetId), s3 = i2?.tileInfo?.lods[e2], a4 = s3 ? s3.levelValue || `${s3.level}` : `${e2}`;
    let o5 = this.resourceInfo ? "" : A3({ dimensionMap: this.dimensionMap, layerMap: this.layerMap }, this.activeLayer.id, this.activeLayer.tileMatrixSetId, this.activeLayer.imageFormat, this.activeLayer.styleId, a4, t3, r3);
    if (!o5) {
      o5 = this.getUrlTemplate(this.activeLayer.id, this.activeLayer.tileMatrixSetId, this.activeLayer.imageFormat, this.activeLayer.styleId).replaceAll(/\{level\}/gi, a4).replaceAll(/\{row\}/gi, `${t3}`).replaceAll(/\{col\}/gi, `${r3}`);
    }
    return o5 = this._appendCustomLayerParameters(o5), o5;
  }
  getUrlTemplate(e2, t3, r3, i2) {
    if (!this.resourceInfo) {
      const r4 = S({ dimensionMap: this.dimensionMap, layerMap: this.layerMap }, e2, t3, i2);
      if (r4) return r4;
    }
    if ("KVP" === this.serviceMode) return this.url + "?SERVICE=WMTS&VERSION=" + this.version + "&REQUEST=GetTile&LAYER=" + e2 + "&STYLE=" + i2 + "&FORMAT=" + r3 + "&TILEMATRIXSET=" + t3 + "&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}";
    if ("RESTful" === this.serviceMode) {
      let s3 = "";
      return V2[r3.toLowerCase()] && (s3 = V2[r3.toLowerCase()]), this.url + e2 + "/" + i2 + "/" + t3 + "/{level}/{row}/{col}" + s3;
    }
    return "";
  }
  async _fetchService(e2) {
    if (this.resourceInfo) return "KVP" !== this.resourceInfo.serviceMode || this.url.includes("?") || (this.url += "?"), m3(this.resourceInfo), void this.read(this.resourceInfo, { origin: "service" });
    let t3 = null;
    try {
      const { data: r4 } = await this._getCapabilities(this.serviceMode, e2);
      t3 = p6(r4), f3(t3);
    } catch {
      const r4 = "KVP" === this.serviceMode ? "RESTful" : "KVP";
      try {
        const { data: i3 } = await this._getCapabilities(r4, e2);
        t3 = p6(i3), f3(t3), this.serviceMode = r4;
      } catch (o5) {
        throw new s("wmtslayer:unsupported-service-data", "Services does not support RESTful or KVP service modes.", { error: o5 });
      }
    }
    const { serviceMode: r3, url: i2 } = this, a4 = d(t3, { serviceMode: r3, url: i2 });
    this.read(a4, { origin: "service" });
  }
  async _getCapabilities(e2, r3) {
    const i2 = this._getCapabilitiesUrl(e2);
    return await H(i2, { ...r3, responseType: "text" });
  }
  _getTileMatrixSetById(e2) {
    const t3 = this.findSublayerById(this.activeLayer.id);
    return t3?.tileMatrixSets?.find(({ id: t4 }) => t4 === e2);
  }
  _appendCustomParameters(e2) {
    return this._appendParameters(e2, this.customParameters);
  }
  _appendCustomLayerParameters(e2) {
    return this._appendParameters(e2, { ...a(this.customParameters), ...this.customLayerParameters });
  }
  _appendParameters(e2, t3) {
    const r3 = I(e2), i2 = { ...r3.query, ...t3 }, s3 = A(i2);
    return "" === s3 ? r3.path : `${r3.path}?${s3}`;
  }
  _getCapabilitiesUrl(e2) {
    this.url = I(this.url).path;
    let t3 = this.url;
    switch (e2) {
      case "KVP":
        t3 += `?request=GetCapabilities&service=WMTS&version=${this.version}`;
        break;
      case "RESTful": {
        const e3 = `/${this.version}/WMTSCapabilities.xml`, r3 = new RegExp(e3, "i");
        t3 = t3.replace(r3, ""), t3 += e3;
        break;
      }
    }
    return this._appendCustomParameters(t3);
  }
  _getLowerCasedUrlParams(e2) {
    if (!e2) return null;
    const t3 = I(e2).query;
    if (!t3) return null;
    const r3 = {};
    return Object.keys(t3).forEach((e3) => {
      r3[e3.toLowerCase()] = t3[e3];
    }), r3;
  }
  _mergeParams(e2, t3) {
    const r3 = this._getLowerCasedUrlParams(t3);
    if (r3) {
      const t4 = Object.keys(r3);
      t4.length && (e2 = e2 ? a(e2) : {}, t4.forEach((t5) => {
        e2.hasOwnProperty(t5) || B.has(t5) || (e2[t5] = r3[t5]);
      }));
    }
    return e2;
  }
};
function K(e2, t3) {
  return e2.map((e3) => {
    const r3 = new m2();
    return r3.read(e3, t3), r3;
  });
}
__decorate([m()], $.prototype, "dimensionMap", void 0), __decorate([m()], $.prototype, "layerMap", void 0), __decorate([m({ type: m2, json: { origins: { "web-document": { write: { ignoreOrigin: true } } } } })], $.prototype, "activeLayer", void 0), __decorate([o("service", "activeLayer", ["layers"])], $.prototype, "readActiveLayerFromService", null), __decorate([o(["web-document", "portal-item"], "activeLayer", ["wmtsInfo"])], $.prototype, "readActiveLayerFromItemOrWebDoc", null), __decorate([r2(["web-document", "portal-item"], "activeLayer", { templateUrl: { type: String }, tileInfo: { type: z2 }, "wmtsInfo.layerIdentifier": { type: String }, "wmtsInfo.tileMatrixSet": { type: String } })], $.prototype, "writeActiveLayer", null), __decorate([m({ type: String, value: "", json: { write: true } })], $.prototype, "copyright", void 0), __decorate([m({ type: ["show", "hide"] })], $.prototype, "listMode", void 0), __decorate([m({ json: { read: true, write: true } })], $.prototype, "blendMode", void 0), __decorate([m({ json: { origins: { "web-document": { read: { source: ["wmtsInfo.customParameters", "wmtsInfo.url"] }, write: { target: "wmtsInfo.customParameters" } }, "portal-item": { read: { source: ["wmtsInfo.customParameters", "wmtsInfo.url"] }, write: { target: "wmtsInfo.customParameters" } } } } })], $.prototype, "customParameters", void 0), __decorate([o(["portal-item", "web-document"], "customParameters")], $.prototype, "readCustomParameters", null), __decorate([m({ json: { origins: { "web-document": { read: { source: "wmtsInfo.customLayerParameters" }, write: { target: "wmtsInfo.customLayerParameters" } }, "portal-item": { read: { source: "wmtsInfo.customLayerParameters" }, write: { target: "wmtsInfo.customLayerParameters" } } } } })], $.prototype, "customLayerParameters", void 0), __decorate([m({ type: z, json: { write: { ignoreOrigin: true }, origins: { "web-document": { read: { source: "fullExtent" } }, "portal-item": { read: { source: "fullExtent" } } } } })], $.prototype, "fullExtent", void 0), __decorate([m({ readOnly: true })], $.prototype, "fullExtents", null), __decorate([m({ type: ["WebTiledLayer"] })], $.prototype, "operationalLayerType", void 0), __decorate([m()], $.prototype, "resourceInfo", void 0), __decorate([m()], $.prototype, "serviceMode", void 0), __decorate([o(["portal-item", "web-document"], "serviceMode", ["templateUrl"])], $.prototype, "readServiceMode", null), __decorate([m({ type: O.ofType(m2) })], $.prototype, "sublayers", void 0), __decorate([o("service", "sublayers", ["layers"])], $.prototype, "readSublayersFromService", null), __decorate([m({ readOnly: true })], $.prototype, "supportedSpatialReferences", null), __decorate([m({ readOnly: true })], $.prototype, "tilemapCache", null), __decorate([m({ json: { read: { source: "title" } } })], $.prototype, "title", null), __decorate([m({ json: { read: false }, readOnly: true, value: "wmts" })], $.prototype, "type", void 0), __decorate([m({ json: { origins: { service: { read: { source: "tileUrl" } }, "web-document": { read: { source: "wmtsInfo.url" }, write: { target: "wmtsInfo.url" } }, "portal-item": { read: { source: "wmtsInfo.url" }, write: { target: "wmtsInfo.url" } } } } })], $.prototype, "url", null), __decorate([m()], $.prototype, "version", void 0), $ = F2 = __decorate([a2("esri.layers.WMTSLayer")], $);
var k2 = $;
export {
  k2 as default
};
//# sourceMappingURL=WMTSLayer-SEZCXF6T.js.map
