import {
  T,
  e2 as e,
  ke
} from "./chunk-MC6NAKKX.js";
import {
  l
} from "./chunk-TF6255HN.js";

// node_modules/@arcgis/core/layers/support/featurePopupQueryUtils.js
async function n(i, n2, s2, r) {
  const u = new Array(n2.length), l2 = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Map(), a = T(i.fieldsIndex, s2.outFields), d = true === i.capabilities?.operations?.supportsQuery && null != i.queryFeatures, f = r?.hasRequiredFields ?? ke;
  for (let e2 = 0; e2 < n2.length; e2++) {
    const t = n2[e2];
    if (d && !t.isAggregate) {
      if (s2.returnGeometry || !f(t, a)) {
        const o = t.getObjectId();
        if (null != o) {
          l2.set(o, { graphic: t, index: e2 });
          continue;
        }
        const i2 = t.getGlobalId();
        if (null != i2) {
          c.set(i2, { graphic: t, index: e2 });
          continue;
        }
      }
      u[e2] = t;
    } else u[e2] = t;
  }
  if (!d || !i.queryFeatures || 0 === l2.size && 0 === c.size) return u.filter(Boolean);
  const p = [], y = (e2, t) => {
    t && (e2.outFields ??= [], e2.outFields.includes(t) || e2.outFields.push(t));
  };
  if (l2.size > 0) {
    const e2 = s2.clone();
    y(e2, i.objectIdField), "uniqueIdFields" in i && i.uniqueIdFields?.length && (e2.outFields ??= [], e2.outFields.push(...i.uniqueIdFields)), e2.objectIds = Array.from(l2.keys()), p.push({ type: "object-id", query: e2, map: l2 });
  }
  const g = "globalIdField" in i ? i.globalIdField : null;
  if (null != g && c.size > 0) {
    const t = s2.clone();
    y(t, g);
    const o = Array.from(c.keys());
    t.where = l(s2.where, `${g} IN (${o.map((e2) => `'${e2}'`).join(",")})`), p.push({ type: "global-id", query: t, map: c });
  }
  const b = r?.updateSourceAttributes ?? false;
  for (const { type: e2, query: t, map: o } of p) try {
    const n3 = await i.queryFeatures(t, r);
    for (const t2 of n3.features) {
      const i2 = "object-id" === e2 ? t2.getObjectId() : t2.getGlobalId();
      if (null == i2) continue;
      const n4 = o.get(i2);
      if (!n4) continue;
      const { graphic: s3, index: r2 } = n4;
      if (b && t2.attributes) {
        s3.attributes ??= {};
        for (const e3 of a) e3 in t2.attributes && (s3.attributes[e3] = t2.attributes[e3]);
      }
      const { geometry: l3, origin: c2 } = s3;
      t2.geometry ||= l3, t2.origin = c2, u[r2] = t2;
    }
  } catch {
  }
  return u.filter(Boolean);
}
async function s(e2) {
  if (e2.expressionInfos?.length || Array.isArray(e2.content) && e2.content.some((e3) => "expression" === e3.type)) return e();
}

export {
  n,
  s
};
//# sourceMappingURL=chunk-GUZURMV5.js.map
