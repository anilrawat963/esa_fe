import {
  A,
  C,
  F,
  I,
  L,
  L2,
  N,
  Ne,
  P,
  b as b2,
  d as d2,
  f2 as f,
  g,
  o as o3,
  p as p2,
  r
} from "./chunk-6KSX5BD3.js";
import {
  I as I2,
  S,
  _ as _2,
  o as o2,
  t as t3
} from "./chunk-BYU7VMB6.js";
import "./chunk-BTFBYI67.js";
import "./chunk-D3G5WIRR.js";
import "./chunk-Q3JOE7TC.js";
import "./chunk-URFJA5XM.js";
import {
  ue
} from "./chunk-LH5BO2EF.js";
import "./chunk-XPO6OCCI.js";
import "./chunk-43UUQEW5.js";
import "./chunk-UOYGNM27.js";
import "./chunk-QPBITBUR.js";
import "./chunk-PJJUVY7C.js";
import "./chunk-7VJQTJLO.js";
import "./chunk-VVMIB6RA.js";
import "./chunk-SQ4OSZIG.js";
import "./chunk-MA6OR5A6.js";
import "./chunk-RCHRSC54.js";
import "./chunk-ZEI5DZXH.js";
import "./chunk-RGWH5UES.js";
import "./chunk-2U5X5TIX.js";
import "./chunk-5D65KWSM.js";
import "./chunk-ABHLEPDK.js";
import "./chunk-4FQUAV7M.js";
import "./chunk-EVZ7KLPS.js";
import "./chunk-JSH3APTG.js";
import "./chunk-WQT2KLDB.js";
import "./chunk-UVDECGZC.js";
import "./chunk-VKFTCFFM.js";
import "./chunk-TCDV4P3G.js";
import {
  b2 as b,
  y as y2
} from "./chunk-CZOYDK6P.js";
import "./chunk-RS755KXS.js";
import "./chunk-TMUM75KQ.js";
import "./chunk-KY5OS6CK.js";
import "./chunk-3U5UUY3S.js";
import "./chunk-UOYGMZIS.js";
import "./chunk-RXH2WNPA.js";
import "./chunk-TWU3GKHX.js";
import "./chunk-BGIBV6LL.js";
import "./chunk-UQXJMFRI.js";
import "./chunk-DY7N5RAZ.js";
import {
  l as l2
} from "./chunk-NP2TBOXH.js";
import "./chunk-WBYRWTBX.js";
import "./chunk-WFCLXKCE.js";
import "./chunk-WX3525ER.js";
import "./chunk-FHCV4NTV.js";
import "./chunk-HCTBVF3W.js";
import "./chunk-NH6FXYCM.js";
import "./chunk-YE4E5JCT.js";
import "./chunk-SXZO7ULH.js";
import "./chunk-QTRET3PG.js";
import "./chunk-FMOL5XMB.js";
import "./chunk-VNSHGTPN.js";
import "./chunk-OEBAFVQK.js";
import "./chunk-76V6RN4F.js";
import "./chunk-DUZAVZR4.js";
import "./chunk-EK7HOTRR.js";
import "./chunk-5DFXT3PU.js";
import "./chunk-CKE7BUXC.js";
import "./chunk-B5SL7XHP.js";
import "./chunk-3VXANCFN.js";
import "./chunk-MBQEPUQX.js";
import "./chunk-ODQ5APZK.js";
import "./chunk-G5IXTUNN.js";
import "./chunk-ZNQKJRCD.js";
import "./chunk-BA6HYZ35.js";
import "./chunk-GCTH5LET.js";
import "./chunk-Q7VRQYAO.js";
import "./chunk-SJB744AD.js";
import "./chunk-WM2VG5F2.js";
import "./chunk-IXFJYDA2.js";
import "./chunk-TTLSEJNG.js";
import "./chunk-U73R3I4U.js";
import "./chunk-VGXUPJSS.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import "./chunk-DLM5SBNY.js";
import "./chunk-EKZRA6TO.js";
import "./chunk-M5SP6ZBM.js";
import "./chunk-FAA2FDN5.js";
import "./chunk-2HGIYEIL.js";
import {
  ut
} from "./chunk-XX3OKYJS.js";
import "./chunk-OTCNIJ2H.js";
import "./chunk-JGA5YJWL.js";
import "./chunk-GCI4MA3M.js";
import "./chunk-SJ2OBYX2.js";
import "./chunk-MDJNYPVI.js";
import "./chunk-Z6VKIQV2.js";
import "./chunk-4PXNA4MD.js";
import "./chunk-ZCI5A4FF.js";
import "./chunk-2D47RURG.js";
import "./chunk-7HTU7ZUX.js";
import "./chunk-647DAMHU.js";
import "./chunk-O6G3PPOK.js";
import "./chunk-ZKNZTIAS.js";
import "./chunk-OJMISN3F.js";
import "./chunk-EFV6H5NA.js";
import "./chunk-XDLV73DB.js";
import "./chunk-ARTU4L55.js";
import "./chunk-6VL5D5UP.js";
import "./chunk-6QHY54HZ.js";
import "./chunk-GXJJY3ND.js";
import "./chunk-5ONGWFJ3.js";
import "./chunk-PLNHHGHL.js";
import "./chunk-DFK6QMLO.js";
import "./chunk-BBYMM7CM.js";
import "./chunk-EM7Y2JZC.js";
import "./chunk-QZQPB5XR.js";
import "./chunk-AQFRVV3U.js";
import "./chunk-36OXW4YN.js";
import {
  p
} from "./chunk-PEL3D3ZN.js";
import "./chunk-Q5KWD3VQ.js";
import "./chunk-BUQC3CLV.js";
import {
  t as t2
} from "./chunk-W5S3VUFT.js";
import "./chunk-7YH7T6CS.js";
import "./chunk-3T4IXPP4.js";
import "./chunk-XTZAIV4X.js";
import "./chunk-63LDVRFI.js";
import "./chunk-TJTOV6JD.js";
import "./chunk-C3FRY5U4.js";
import "./chunk-JNJX34GB.js";
import "./chunk-3STJRSDT.js";
import "./chunk-67Q6KVC6.js";
import "./chunk-23NJHA5Q.js";
import "./chunk-4LA6K4VI.js";
import "./chunk-KEZCWFAR.js";
import "./chunk-JZUJ34RR.js";
import "./chunk-PMGS7UDU.js";
import "./chunk-3GHCGAH2.js";
import "./chunk-HWUOAPTX.js";
import "./chunk-QHCKOBU7.js";
import "./chunk-K2OZ6WVC.js";
import "./chunk-MC6NAKKX.js";
import "./chunk-TF6255HN.js";
import "./chunk-GD4FJL3C.js";
import "./chunk-C5OQVQZF.js";
import "./chunk-F7DKSAOI.js";
import "./chunk-4SOQWNPG.js";
import "./chunk-LTULADK2.js";
import "./chunk-35ST7YRB.js";
import "./chunk-EDA5QFHZ.js";
import "./chunk-JW6DU3OK.js";
import "./chunk-CNYNCKEV.js";
import "./chunk-XL5QPCXN.js";
import "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-C5M24ACM.js";
import "./chunk-L4A2QJG4.js";
import "./chunk-6KDQMJAI.js";
import "./chunk-UDHS2MGH.js";
import "./chunk-QF7FRVN6.js";
import "./chunk-ENINOZUZ.js";
import {
  b as b3
} from "./chunk-P6IKJIMO.js";
import "./chunk-MHV23XAQ.js";
import "./chunk-V2X4OKYI.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import "./chunk-MA3QDRC3.js";
import "./chunk-W6J7XCPU.js";
import "./chunk-ONXWBTTM.js";
import "./chunk-T7F6Q6JJ.js";
import {
  O
} from "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-7P2ANHQ3.js";
import "./chunk-XCKT47LJ.js";
import "./chunk-3FUHCAX3.js";
import {
  o3 as o,
  y3 as y
} from "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import {
  z
} from "./chunk-H74Q4SYB.js";
import {
  U,
  l
} from "./chunk-2OFHDVO5.js";
import "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-5UPBUJPC.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-CCQFL76O.js";
import "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import "./chunk-7H3U4IJR.js";
import "./chunk-SMWUT52Z.js";
import {
  _
} from "./chunk-AXZMNHTN.js";
import "./chunk-5T3MJDSR.js";
import "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import {
  m,
  t3 as t
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import {
  e
} from "./chunk-4DGC7CBY.js";
import {
  d,
  s as s2,
  u3 as u
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/layers/knowledgeGraph/IdealEdgeLengthTypeOptions.js
var e2 = { MULTIPLIER: "multiplier", ABSOLUTE: "absolute-value" };

// node_modules/@arcgis/core/layers/LinkChartLayer.js
var K = class extends b(p(t2(l2(b3)))) {
  constructor(e3) {
    if (super(e3), this.url = null, this.dataPreloadedInLocalCache = false, this.initializationLinkChartConfig = null, this.membershipModified = true, this._currentLinkChartConfig = { layoutMode: "organic-standard" }, this._graphTypeLookup = /* @__PURE__ */ new Map(), this.dataManager = null, this.knowledgeGraph = null, this.layers = new (O.ofType(Ne))(), this.entityLinkChartDiagramLookup = /* @__PURE__ */ new Map(), this.relationshipLinkChartDiagramLookup = /* @__PURE__ */ new Map(), this.linkChartExtent = new z({ xmin: -1e-7, ymin: -1e-7, xmax: 1e-7, ymax: 1e-7 }), this.memberEntityTypes = null, this.memberRelationshipTypes = null, this.operationalLayerType = "LinkChartLayer", this.sublayerIdsCache = /* @__PURE__ */ new Map(), this.tables = new (O.ofType(Ne))(), this.type = "link-chart", this.chronologicalAuxiliaryGraphics = null, this._originalInclusionList = e3?.initializationInclusionModeDefinition, e3?.dataPreloadedInLocalCache && !e3?.initializationInclusionModeDefinition) throw new s("knowledge-graph:linkchart-layer-constructor", "If creating a link chart composite layer and configured that data is already loaded in the cache, you must specify an inclusion list so the Composite Layer knows what records belong to it");
    this.addHandles(l(() => this.layers.concat(this.tables), (e4, t4) => this._handleSublayersChange(e4, t4), U));
  }
  normalizeCtorArgs(e3) {
    if (!e3) return {};
    const { url: t4, title: a2, dataPreloadedInLocalCache: i2, initializationLinkChartConfig: n } = e3;
    return { url: t4, title: a2, dataPreloadedInLocalCache: i2, initializationLinkChartConfig: n };
  }
  _initializeLayerProperties(e3) {
    if (!this.title && this.url) {
      const e4 = this.url.split("/");
      this.title = e4[e4.length - 2];
    }
    const t4 = /* @__PURE__ */ new Set();
    let a2 = [], o4 = [];
    if (e3.inclusionModeDefinition && (!e3.inclusionModeDefinition.namedTypeDefinitions || e3.inclusionModeDefinition.namedTypeDefinitions.size < 1)) throw new s("knowledge-graph:composite-layer-constructor", "If an explicit inclusion definition is defined, at least one namedTypeDefinition must also be defined");
    e3.inclusionModeDefinition?.generateAllSublayers ? (a2 = e3.knowledgeGraph.dataModel.entityTypes ?? [], o4 = e3.knowledgeGraph.dataModel.relationshipTypes ?? []) : e3.inclusionModeDefinition?.namedTypeDefinitions && e3.inclusionModeDefinition?.namedTypeDefinitions.size > 0 ? e3.inclusionModeDefinition?.namedTypeDefinitions.forEach((i2, s4) => {
      const r2 = this._graphTypeLookup.get(s4);
      if (!r2) return i.getLogger(this).warn(`A named type, ${s4}, was in the inclusion list that wasn't in the data model and will be removed`), void e3.inclusionModeDefinition?.namedTypeDefinitions.delete(s4);
      "relationship" === r2.type ? t4.has(s4) || (t4.add(s4), o4.push(r2)) : "entity" === r2.type ? t4.has(s4) || (t4.add(s4), a2.push(r2)) : (i.getLogger(this).warn(`A named type, ${s4}, was in the inclusion list that wasn't properly modeled and will be removed`), e3.inclusionModeDefinition?.namedTypeDefinitions.delete(s4));
    }) : (a2 = e3.knowledgeGraph.dataModel.entityTypes ?? [], o4 = e3.knowledgeGraph.dataModel.relationshipTypes ?? []);
    const s3 = new N({ knowledgeGraph: e3.knowledgeGraph, inclusionModeDefinition: e3.inclusionModeDefinition });
    this.knowledgeGraph = e3.knowledgeGraph, this.memberEntityTypes = a2, this.memberRelationshipTypes = o4, this.dataManager = s3;
  }
  load(e3) {
    const a2 = async () => {
      const e4 = [], t4 = [];
      this.loadLayerAssumingLocalCache(), this._layersLoadedFromAuthoritativeItem() || await L2(this), this.dataManager.inclusionModeDefinition && (this.dataManager.inclusionModeDefinition.generateAllSublayers = false), this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.forEach((e5) => {
        e5.useAllData = false;
      }), await this._initializeDiagram(), this.layers.forEach((a3) => {
        t4.push(a3.refreshCachedQueryEngine()), e4.push(new Promise((e5) => {
          a3.on("layerview-create", () => {
            e5(null);
          });
        }));
      }), this.tables.forEach((e5) => {
        t4.push(e5.refreshCachedQueryEngine());
      }), await Promise.all(t4);
    };
    return this.addResolvingPromise(new Promise((i2) => {
      ue(this.url).then(async (n) => {
        n.dataModel.entityTypes?.forEach((e4) => {
          e4.name && this._graphTypeLookup.set(e4.name, e4);
        }), n.dataModel.relationshipTypes?.forEach((e4) => {
          e4.name && this._graphTypeLookup.set(e4.name, e4);
        });
        const s3 = this.linkChart?.linkChartProperties;
        if (6 === s3?.originIdOf("entitiesUrl") && (this.membershipModified = false, this._originalInclusionList = await I.fetchAndConvertSerializedLinkChart({ entitiesUrl: s3?.entitiesUrl, relationshipsUrl: s3?.relationshipsUrl }), this._alignLayersDataModelAndInclusionDefinition(n.dataModel), this.initializationLinkChartConfig = { layoutSettings: s3?.layoutSettings ?? void 0, layoutMode: C(s3.layoutType) }), this._initializeLayerProperties({ knowledgeGraph: n, inclusionModeDefinition: this._originalInclusionList }), this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.size || (this.dataManager.inclusionModeDefinition = { generateAllSublayers: false, namedTypeDefinitions: /* @__PURE__ */ new Map() }, this.dataManager.knowledgeGraph.dataModel.entityTypes?.forEach((e4) => {
          e4.name && this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.set(e4.name, { useAllData: true });
        }), this.dataManager.knowledgeGraph.dataModel.relationshipTypes?.forEach((e4) => {
          e4.name && this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.set(e4.name, { useAllData: true });
        })), this.dataPreloadedInLocalCache) {
          const e4 = o3.getInstance();
          for (const [t4, a3] of this.dataManager.inclusionModeDefinition?.namedTypeDefinitions ?? []) for (const i3 of a3.members?.values() ?? []) {
            const a4 = e4.readFromStoreById(`${t4}__${i3.id}`);
            if (a4) {
              e(this.dataManager.sublayerCaches, t4, () => /* @__PURE__ */ new Map()).set(i3.id, a4);
            }
          }
          await a2();
        } else {
          const t4 = "geographic-organic-standard" === this.initializationLinkChartConfig?.layoutMode;
          this.addResolvingPromise(this.dataManager.refreshCacheContent(void 0, false, t4, true).then(async () => {
            s2(e3), await a2();
          }));
        }
        i2(null);
      });
    })), Promise.resolve(this);
  }
  set initializationInclusionModeDefinition(e3) {
    "loaded" !== this.loadStatus && "failed" !== this.loadStatus ? this._set("initializationInclusionModeDefinition", e3) : i.getLogger(this).error("#initializationInclusionModeDefinition", "initializationInclusionModeDefinition cannot be changed after the layer is loaded.");
  }
  get linkChart() {
    return this.parent;
  }
  get sublayerCapabilities() {
    return F(this.knowledgeGraph);
  }
  async addRecords(e3, t4) {
    let a2 = [];
    t4?.cascadeAddRelationshipEndNodes && this.dataManager.knowledgeGraph.dataModel && (a2 = await g(e3, this.dataManager.knowledgeGraph));
    const i2 = e3.concat(a2).filter((e4) => !this.sublayerIdsCache.get(e4.typeName)?.has(e4.id));
    i2.length > 0 && (this.membershipModified = true), await this._handleNewRecords(i2, t4);
  }
  async createSublayerForNamedType(e3) {
    await this.load();
    const t4 = this._graphTypeLookup.get(e3);
    if (!t4) throw new s("knowledge-graph:missing-type", "The specified type does not exist in the knowledge graph.");
    if (this.dataManager.sublayerCaches.has(e3)) throw new s("knowledge-graph:duplicate-type", "The specified type already exists as a sublayer.");
    this.dataManager.sublayerCaches.set(e3, /* @__PURE__ */ new Map()), e(this.sublayerIdsCache, e3, () => /* @__PURE__ */ new Set());
    const a2 = this._createSublayer(t4);
    return "entity" === t4.type ? this.dataManager.entityTypeNames.add(e3) : this.dataManager.relationshipTypeNames.add(e3), this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.set(e3, { useAllData: false, members: /* @__PURE__ */ new Map() }), a2.geometryType ? this.layers.push(a2) : this.tables.push(a2), await L2(this, [e3]), this._refreshNamedTypes(), a2;
  }
  async removeRecords(e3, { cascadeRemoveRelationships: t4 = true, recalculateLayout: a2 = false, overrideMembershipCheck: i2 = false } = { cascadeRemoveRelationships: true, recalculateLayout: false, overrideMembershipCheck: false }) {
    let n = [];
    for (const r2 of e3) (i2 || false === this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.get(r2.typeName)?.useAllData && this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.get(r2.typeName)?.members?.has(r2.id)) && n.push(r2);
    if (t4) {
      const e4 = /* @__PURE__ */ new Set(), t5 = [];
      for (const a3 of n) if (this.dataManager.nodeConnectionsLookup.has(a3.id)) for (const t6 of this.dataManager.nodeConnectionsLookup.get(a3.id)) e4.add(t6);
      for (const a3 of e4) if (this.dataManager.memberIdTypeLookup.has(a3)) for (const e5 of this.dataManager.memberIdTypeLookup.get(a3)) this.dataManager.relationshipTypeNames.has(e5) && t5.push({ id: a3, typeName: e5 });
      n = n.concat(t5);
    }
    this.dataManager.removeFromLayer(n);
    for (const r2 of n) this.sublayerIdsCache.get(r2.typeName)?.delete(r2.id), this.dataManager.relationshipTypeNames.has(r2.typeName) ? this.relationshipLinkChartDiagramLookup.delete(r2.id) : this.entityLinkChartDiagramLookup.delete(r2.id);
    const o4 = a2 ? void 0 : this.getCurrentNodeLocations();
    await this._calculateLayoutWithSublayerTimeInfo(this._currentLinkChartConfig.layoutMode, { layoutSettings: this._currentLinkChartConfig.layoutSettings, lockedNodeLocations: o4 }), n.length > 0 && (this.membershipModified = true);
    const s3 = [];
    return this.layers.forEach((e4) => {
      s3.push(e4.refreshCachedQueryEngine());
    }), await Promise.all(s3), this._refreshNamedTypes(), n;
  }
  async expand(e3, t4) {
    let a2 = [];
    try {
      const i2 = await this.dataManager.getConnectedRecordIds(e3, t4?.relationshipTypeNames, t4);
      a2 = i2.filter((e4) => !this.sublayerIdsCache.get(e4.typeName)?.has(e4.id)), await this._handleNewRecords(a2, t4), i2.length > 0 && (this.membershipModified = true), s2(t4?.signal);
    } catch (i2) {
      throw d(i2) && a2.length > 0 && await this.removeRecords(a2, { overrideMembershipCheck: true }), i2;
    }
    return { records: a2 };
  }
  loadLayerAssumingLocalCache() {
    const e3 = [...this.memberRelationshipTypes, ...this.memberEntityTypes];
    this.layers.length || 0 === this.originIdOf("tables") ? 0 === this.originIdOf("layers") ? this._createSublayers(e3, this.layers, (e4) => !!e4.geometryType) : this._updateSublayers(e3, this.layers) : this.layers = new O(), this.tables.length || 0 === this.originIdOf("layers") ? 0 === this.originIdOf("tables") ? this._createSublayers(e3, this.tables, (e4) => !e4.geometryType) : this._updateSublayers(e3, this.tables) : this.tables = new O(), this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.forEach((e4, t4) => {
      const a2 = e(this.sublayerIdsCache, t4, () => /* @__PURE__ */ new Set());
      e4.members?.forEach(({ id: e5, linkChartLocation: i2 }) => {
        if (a2.add(e5), i2) {
          const a3 = "coords" in i2 && "lengths" in i2 ? i2 : ut(i2);
          this.dataManager.relationshipTypeNames.has(t4) ? this.relationshipLinkChartDiagramLookup.set(e5, a3) : this.entityLinkChartDiagramLookup.set(e5, a3);
        }
      });
    });
  }
  async calculateLinkChartLayout(e3 = "organic-standard", t4) {
    const a2 = [], s3 = [], l3 = [];
    this.dataManager.sublayerCaches.forEach((e4, t5) => {
      this.dataManager.entityTypeNames.has(t5) ? e4.forEach((e5) => {
        a2.push({ typeName: t5, feature: e5 });
      }) : this.dataManager.relationshipTypeNames.has(t5) && e4.forEach((e5) => {
        s3.push({ typeName: t5, feature: e5 });
      });
    }), this.entityLinkChartDiagramLookup = /* @__PURE__ */ new Map(), this.relationshipLinkChartDiagramLookup = /* @__PURE__ */ new Map();
    const d3 = /* @__PURE__ */ new Map(), p3 = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Map(), u2 = /* @__PURE__ */ new Map(), y3 = new Uint8Array(a2.length), L3 = new Float64Array(a2.length), D = new Float64Array(a2.length), x = new Float64Array(a2.length), v = new Float64Array(a2.length), I3 = new Uint32Array(s3.length), E = new Uint32Array(s3.length), S2 = new Float64Array(s3.length), _3 = new Float64Array(s3.length), A2 = [], R = "organic-standard";
    let j = false;
    const G = new z({ xmin: -1e-7, ymin: -1e-7, xmax: 1e-7, ymax: 1e-7 });
    let z2, H = "organic-standard", K2 = 0, J2 = 0;
    const V = b2.apply;
    switch (H = "geographic-organic-standard" === e3 ? R : e3, H) {
      case "organic-standard":
        z2 = p2.apply;
        break;
      case "organic-community":
        z2 = f.apply;
        break;
      case "hierarchical-bottom-to-top":
        z2 = P.apply;
        break;
      case "radial-root-centric":
        z2 = L.apply;
        break;
      case "tree-left-to-right":
        z2 = d2.apply;
        break;
      default:
        z2 = A.apply;
    }
    let q = false;
    a2.forEach(({ typeName: a3, feature: i2 }) => {
      if ("chronological-mono-timeline" !== e3 && "chronological-multi-timeline" !== e3 && t4?.lockedNodeLocations?.has(i2.attributes[_2])) {
        "geographic-organic-standard" === e3 && this.dataManager.geographicLookup.has(a3) ? y3[K2] = 2 : y3[K2] = 0;
        const n = t4.lockedNodeLocations.get(i2.attributes[_2]);
        L3[K2] = n.x, D[K2] = n.y;
      } else if ("geographic-organic-standard" === e3 && this.dataManager.geographicLookup.has(a3)) {
        y3[K2] = 2;
        let e4 = null;
        const t5 = i2.attributes[this.dataManager.geographicLookup.get(a3).name], n = this.dataManager.geographicLookup.get(a3)?.geometryType;
        switch (n) {
          case "esriGeometryPoint":
            L3[K2] = t5?.x, D[K2] = t5?.y;
            break;
          case "esriGeometryPolygon": {
            const a4 = o(t5);
            e4 = a4 ? _.fromJSON(a4) : null, null != e4?.x && null != e4?.y ? (L3[K2] = e4.x, D[K2] = e4.y) : y3[K2] = 1;
            break;
          }
          case "esriGeometryPolyline":
          case "esriGeometryMultipoint":
            e4 = t5?.extent?.center, null != e4?.x && null != e4?.y ? (L3[K2] = e4.x, D[K2] = e4.y) : y3[K2] = 1;
            break;
          default:
            y3[K2] = 1;
        }
        (null == L3[K2] || null == D[K2] || Number.isNaN(L3[K2]) || Number.isNaN(D[K2])) && (y3[K2] = 1, L3[K2] = 0, D[K2] = 0);
      } else if ("chronological-mono-timeline" === e3 || "chronological-multi-timeline" === e3) {
        !q && t4?.lockedNodeLocations?.has(i2.attributes[_2]) && (q = true);
        const e4 = t4?.timeInfoByTypeName?.get(a3), n = e4?.startField, o4 = n && e4?.startField ? i2.attributes[n] : null;
        x[K2] = o4 ? new Date(o4).getTime() : NaN;
        const s4 = e4?.endField, r2 = s4 && e4?.endField ? i2.attributes[s4] : null;
        v[K2] = r2 ? new Date(r2).getTime() : NaN, L3[K2] = 0, D[K2] = 0, y3[K2] = 1;
      } else y3[K2] = 1, L3[K2] = 0, D[K2] = 0;
      u2.set(i2.attributes[_2], K2), A2[K2] = { feature: i2, typeName: a3 }, K2++;
    }), q && i.getLogger(this).warn("Locked node locations are not supported for chronological layout at this time.  Requested node locations were ignored");
    let X = false;
    const Y = /* @__PURE__ */ new Map();
    s3.forEach((a3) => {
      const i2 = a3.feature.attributes[I2], n = a3.feature.attributes[t3], o4 = u2.get(i2), s4 = u2.get(n), r2 = t4?.timeInfoByTypeName?.get(a3.typeName), h = t4?.timeInfoByTypeName ? r2?.startField : null, d4 = h ? a3.feature.attributes[h] : null, p4 = r2?.endField, c2 = p4 ? a3.feature.attributes[p4] : null;
      if (void 0 !== o4 && void 0 !== s4) {
        let t5 = i2 + "-" + n;
        "chronological-mono-timeline" !== e3 && "chronological-multi-timeline" !== e3 || (t5 = t5 + "-" + d4 + "-" + c2);
        const r3 = Y.get(t5), h2 = r3?.has(a3.typeName);
        h2 || (I3[J2] = o4, E[J2] = s4, "chronological-mono-timeline" !== e3 && "chronological-multi-timeline" !== e3 || (S2[J2] = d4 ? new Date(d4).getTime() : NaN, _3[J2] = c2 ? new Date(c2).getTime() : NaN), void 0 === r3 ? Y.set(t5, /* @__PURE__ */ new Map([[a3.typeName, J2]])) : r3.set(a3.typeName, J2), J2++), l3.push(a3);
      } else X = true, this.relationshipLinkChartDiagramLookup.set(i2, null);
    }), X && i.getLogger(this).warn("A relationship is a member of this layer that has either origin or destination entity nodes that are not members. The diagram geometry will be set to null");
    const Z = this._validateOrganicLayoutSettings(e3, t4?.layoutSettings?.organicLayoutSettings), ee = this._convertValidatedOrganicSettingsToCalculationSettings(Z);
    await r();
    let te = 1, ae = null;
    if ("chronological-mono-timeline" === e3 || "chronological-multi-timeline" === e3) {
      let a3;
      ({ status: te, links: ae, graphics: a3 } = V(() => t4?.signal?.aborted ?? false, y3, L3, D, x, v, I3.subarray(0, J2), E.subarray(0, J2), S2.subarray(0, J2), _3.subarray(0, J2), "chronological-multi-timeline" === e3, t4?.layoutSettings?.chronologicalLayoutSettings)), 0 === te && (this.chronologicalAuxiliaryGraphics = a3);
    } else ({ status: te, links: ae } = z2(() => t4?.signal?.aborted ?? false, y3, L3, D, I3.subarray(0, J2), E.subarray(0, J2), ee.computationBudgetTime, ee.idealEdgeLengthMultiplier, ee.repulsionRadiusMultiplier));
    if (s2(t4?.signal), 1 === te) throw new s("knowledge-graph:layout-failed", "Attempting to arrange the records in the specified layout failed");
    if (2 === te) throw u();
    for (let i2 = 0; i2 < A2.length; i2++) {
      if (D[i2] > 84.9999 ? D[i2] = 84.9999 : D[i2] < -84.9999 && (D[i2] = -84.9999), L3[i2] > 179.9999 ? L3[i2] = 179.9999 : L3[i2] < -179.9999 && (L3[i2] = -179.9999), A2[i2].feature.attributes[S] = new _(L3[i2], D[i2]), d3.has(A2[i2].typeName)) {
        const e5 = d3.get(A2[i2].typeName);
        e5?.set(A2[i2].feature.attributes[_2], A2[i2].feature);
      } else {
        const e5 = /* @__PURE__ */ new Map();
        e5.set(A2[i2].feature.attributes[_2], A2[i2].feature), d3.set(A2[i2].typeName, e5);
      }
      c.set(A2[i2].feature.attributes[_2], A2[i2].feature);
      const e4 = ut(A2[i2].feature.attributes[S]);
      this.entityLinkChartDiagramLookup.set(A2[i2].feature.attributes[_2], A2[i2].feature.attributes[S] ? e4 : null);
      const t5 = e(this.dataManager.inclusionModeDefinition.namedTypeDefinitions, A2[i2].typeName, () => ({ useAllData: false, members: /* @__PURE__ */ new Map() }));
      e(t5.members, A2[i2].feature.attributes[_2], () => ({ id: A2[i2].feature.attributes[_2], linkChartLocation: void 0 })).linkChartLocation = A2[i2].feature.attributes[S];
      const { x: a3, y: n } = A2[i2].feature.attributes[S];
      if (j) G.xmin = Math.min(G.xmin, a3), G.xmax = Math.max(G.xmax, a3), G.ymin = Math.min(G.ymin, n), G.ymax = Math.max(G.ymax, n);
      else {
        const e5 = 1e-7;
        G.xmin = a3 - e5, G.xmax = a3 + e5, G.ymin = n - e5, G.ymax = n + e5, j = true;
      }
    }
    if (this.linkChartExtent.xmin = G.xmin, this.linkChartExtent.xmax = G.xmax, this.linkChartExtent.ymin = G.ymin, this.linkChartExtent.ymax = G.ymax, !ae) throw new s("knowledge-graph:layout-failed", "Attempting to retrieve link geometry from diagram engine failed");
    const ie = /* @__PURE__ */ new Map(), ne = /* @__PURE__ */ new Map(), oe = /* @__PURE__ */ new Map(), se = /* @__PURE__ */ new Set();
    for (let i2 = 0; i2 < l3.length; i2++) {
      const a3 = [], s4 = l3[i2], r2 = s4.feature.attributes[I2], h = s4.feature.attributes[t3];
      let d4 = r2 + "-" + h;
      if ("chronological-mono-timeline" === e3 || "chronological-multi-timeline" === e3) {
        const e4 = t4?.timeInfoByTypeName?.get(s4.typeName), a4 = t4?.timeInfoByTypeName ? e4?.startField : null, i3 = a4 ? s4.feature.attributes[a4] : null, n = e4?.endField;
        d4 += "-" + i3 + "-" + (n ? s4.feature.attributes[n] : null);
      }
      const y4 = Y.get(d4).get(s4.typeName), g2 = 0 === y4 ? 0 : ae?.vertexEndIndex[y4 - 1];
      if (!se.has(y4)) {
        if (se.add(y4), 2 === ae.types[y4]) {
          const e4 = [ae.vertices[2 * g2], ae.vertices[2 * g2 + 1]], t5 = [ae.vertices[2 * (g2 + 1)], ae.vertices[2 * (g2 + 1) + 1]], i3 = [0.5 * (e4[0] + t5[0]), 0.5 * (e4[1] + t5[1])], n = [i3[0] - e4[0], i3[1] - e4[1]], o4 = [i3[0] + n[1], i3[1] - n[0]], s5 = [i3[0] - n[1], i3[1] + n[0]];
          a3.push(e4), a3.push(o4), a3.push(t5), a3.push(s5), a3.push(e4);
        } else {
          if (0 !== ae.types[y4]) {
            i.getLogger(this).warn("A relationship generated an unsupported link geometry type.  It will not be rendered");
            continue;
          }
          for (let e4 = g2; e4 < ae.vertexEndIndex[y4]; e4++) a3.push([ae.vertices[2 * e4], ae.vertices[2 * e4 + 1]]);
        }
        if ("chronological-mono-timeline" !== e3 && "chronological-multi-timeline" !== e3) {
          const e4 = A2[u2.get(r2)]?.feature.attributes[S], t5 = A2[u2.get(h)]?.feature.attributes[S];
          a3[0][0] === e4.x && a3[0][1] === e4.y || (a3[0] = [e4.x, e4.y]), a3[a3.length - 1][0] === t5.x && a3[a3.length - 1][1] === t5.y || (a3[a3.length - 1] = [t5.x, t5.y]);
        }
        for (let e4 = 1; e4 < a3.length - 1; e4++) a3[e4][1] > 85.5 ? a3[e4][1] = 85.5 : a3[e4][1] < -85.5 && (a3[e4][1] = -85.5), a3[e4][0] > 179.9999 ? a3[e4][0] = 179.9999 : a3[e4][0] < -179.9999 && (a3[e4][0] = -179.9999);
        ie.has(d4) ? ie.get(d4).push(a3) : ie.set(d4, [a3]);
      }
      const m2 = ie.get(d4);
      ne.has(d4) || (ne.set(d4, /* @__PURE__ */ new Map()), oe.set(d4, /* @__PURE__ */ new Map()));
      const w = ne.get(d4), L4 = oe.get(d4);
      w.has(s4.typeName) || (w.set(s4.typeName, m2.shift()), L4.set(s4.typeName, 0));
      const N2 = w.get(s4.typeName);
      L4.set(s4.typeName, L4.get(s4.typeName) + 1);
      const D2 = new y({ paths: [N2] });
      if (s4.feature.attributes[S] = D2, p3.has(s4.typeName)) {
        const e4 = p3.get(s4.typeName);
        e4?.set(s4.feature.attributes[_2], s4.feature);
      } else {
        const e4 = /* @__PURE__ */ new Map();
        e4.set(s4.feature.attributes[_2], s4.feature), p3.set(s4.typeName, e4);
      }
      c.set(s4.feature.attributes[_2], s4.feature);
      const x2 = ut(s4.feature.attributes[S]);
      this.relationshipLinkChartDiagramLookup.set(s4.feature.attributes[_2], s4.feature.attributes[S] ? x2 : null);
      const v2 = e(this.dataManager.inclusionModeDefinition.namedTypeDefinitions, s4.typeName, () => ({ useAllData: false, members: /* @__PURE__ */ new Map() }));
      e(v2.members, s4.feature.attributes[_2], () => ({ id: s4.feature.attributes[_2], linkChartLocation: void 0 })).linkChartLocation = x2;
    }
    for (const i2 of l3) i2.feature.attributes[o2] = oe.get(i2.feature.attributes[I2] + "-" + i2.feature.attributes[t3])?.get(i2.typeName) ?? null;
    return this._currentLinkChartConfig = { layoutMode: e3, layoutSettings: t4?.layoutSettings?.clone() }, { nodes: d3, links: p3, idMap: c };
  }
  async applyNewLinkChartLayout(e3 = "organic-standard", t4) {
    const a2 = [];
    await this._calculateLayoutWithSublayerTimeInfo(e3, t4), this.layers.forEach((e4) => {
      a2.push(e4.refreshCachedQueryEngine());
    }), this.membershipModified = true, await Promise.all(a2), this._refreshNamedTypes();
  }
  getCurrentNodeLocations() {
    const e3 = /* @__PURE__ */ new Map();
    for (const [t4, a2] of this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.entries() ?? []) this.dataManager.relationshipTypeNames.has(t4) || a2?.members?.forEach((t5) => {
      const a3 = t5.linkChartLocation;
      let i2;
      const n = t5.id;
      a3 && (i2 = "x" in a3 ? { x: a3.x, y: a3.y } : { x: a3.coords[0], y: a3.coords[1] }, e3.set(n, new _({ x: i2.x, y: i2.y })));
    });
    return e3;
  }
  async refreshLinkChartCache(e3) {
    await this.dataManager.refreshCacheContent(e3);
    const t4 = [];
    this.layers.forEach((e4) => {
      t4.push(e4.refreshCachedQueryEngine());
    }), await Promise.all(t4), this._refreshNamedTypes();
  }
  async connectBetweenEntities(e3, t4) {
    if (!e3.length) return { records: [] };
    let a2 = [];
    try {
      let i2 = [];
      for (const e4 of this.dataManager.relationshipTypeNames) {
        const t5 = this.sublayerIdsCache.get(e4);
        t5 && (i2 = i2.concat(Array.from(t5.keys())));
      }
      a2 = await this.dataManager.getRelationshipsBetweenNodes(e3, i2, t4), await this._handleNewRecords(a2, t4), s2(t4);
    } catch (i2) {
      throw d(i2) && this.removeRecords(a2), i2;
    }
    return { records: a2 };
  }
  async connectFromEntities(e3, t4) {
    if (!e3.length) return { records: [] };
    let a2 = [];
    try {
      let i2 = [];
      for (const e4 of this.dataManager.relationshipTypeNames) {
        const t5 = this.sublayerIdsCache.get(e4);
        t5 && (i2 = i2.concat(Array.from(t5.keys())));
      }
      let n = [];
      for (const e4 of this.dataManager.entityTypeNames) {
        const t5 = this.sublayerIdsCache.get(e4);
        t5 && (n = n.concat(Array.from(t5)));
      }
      a2 = await this.dataManager.getRelationshipsFromNodes(e3, n, i2, t4), await this._handleNewRecords(a2, t4), a2.length > 0 && (this.membershipModified = true), s2(t4);
    } catch (i2) {
      throw d(i2) && this.removeRecords(a2), i2;
    }
    return { records: a2 };
  }
  getCurrentLayout() {
    return this._currentLinkChartConfig.layoutMode;
  }
  async _calculateLayoutWithSublayerTimeInfo(e3 = "organic-standard", t4) {
    const a2 = /* @__PURE__ */ new Map();
    this.layers.forEach((e4) => {
      a2.set(e4.objectType.name, e4.timeInfo);
    }), await this.calculateLinkChartLayout(e3, { timeInfoByTypeName: a2, ...t4 }), this.linkChart?.handleChronologicalOverlay();
  }
  async _handleNewRecords(e3, t4) {
    const a2 = /* @__PURE__ */ new Set(), i2 = [], n = this.layers.concat(this.tables);
    for (const r2 of e3) {
      if (!this._graphTypeLookup.has(r2.typeName)) continue;
      false === n.some((e4) => e4.objectType.name === r2.typeName) && (this.dataManager.sublayerCaches.set(r2.typeName, /* @__PURE__ */ new Map()), a2.add(r2.typeName));
      e(this.sublayerIdsCache, r2.typeName, () => /* @__PURE__ */ new Set()).add(r2.id), i2.push(r2);
    }
    this.dataManager.addToLayer(i2);
    for (const o4 of a2) {
      const e4 = this._graphTypeLookup.get(o4);
      if (e4) {
        const t5 = this._createSublayer(e4);
        "entity" === e4.type ? this.dataManager.entityTypeNames.add(o4) : this.dataManager.relationshipTypeNames.add(o4), t5.geometryType ? this.layers.push(t5) : this.tables.push(t5);
      }
    }
    await L2(this, Array.from(a2), t4), await this.dataManager.refreshCacheContent(e3.map((e4) => e4.id), void 0, void 0, void 0, t4);
    const s3 = { layoutSettings: this._currentLinkChartConfig.layoutSettings, lockedNodeLocations: /* @__PURE__ */ new Map() };
    for (const [o4, r2] of this.entityLinkChartDiagramLookup.entries()) r2 && s3.lockedNodeLocations.set(o4, new _(r2.coords[0], r2.coords[1]));
    await this.applyNewLinkChartLayout(this._currentLinkChartConfig.layoutMode, s3);
  }
  _createSublayers(e3, t4, a2) {
    e3.forEach((e4) => {
      const i2 = this._createSublayer(e4);
      a2(i2) && t4.push(i2), this._updateSublayerCaches(e4);
    });
  }
  _updateSublayers(e3, t4) {
    t4.forEach((t5) => {
      t5.parentCompositeLayer = this;
      const a2 = e3.find((e4) => e4.type === t5.graphType && e4.name === t5.graphTypeName);
      a2 && (t5.objectType = a2, t5.read({ title: a2.name }, { origin: "service" }), this._updateSublayerCaches(a2));
    });
  }
  _updateSublayerCaches({ name: e3 }) {
    if (!e3) return;
    const t4 = this.dataManager.sublayerCaches;
    t4.has(e3) || t4.set(e3, /* @__PURE__ */ new Map());
  }
  _layersLoadedFromAuthoritativeItem() {
    const e3 = this.originIdOf("layers");
    return e3 >= 3 && e3 < 7;
  }
  async _initializeDiagram() {
    this.initializationLinkChartConfig ? this.initializationLinkChartConfig.doNotRecalculateLayout ? (this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.forEach((e3, t4) => {
      e3?.members?.forEach((e4) => {
        const a2 = e4.linkChartLocation;
        let i2;
        const n = e4.id;
        if (!a2) return;
        i2 = "x" in a2 ? { x: a2.x, y: a2.y } : { x: a2.coords[0], y: a2.coords[1] };
        const o4 = ut(i2);
        this.dataManager.relationshipTypeNames.has(t4) ? this.relationshipLinkChartDiagramLookup.set(n, o4) : this.entityLinkChartDiagramLookup.set(n, o4), this.linkChartExtent.xmin > i2.x && (this.linkChartExtent.xmin = i2.x), this.linkChartExtent.xmax < i2.x && (this.linkChartExtent.xmax = i2.x), this.linkChartExtent.ymin > i2.y && (this.linkChartExtent.ymin = i2.y), this.linkChartExtent.ymax < i2.y && (this.linkChartExtent.ymax = i2.y);
      });
    }), this.memberRelationshipTypes.forEach((e3) => {
      e3.name && this.dataManager.sublayerCaches.get(e3.name)?.forEach((e4) => {
        const t4 = this.relationshipLinkChartDiagramLookup.get(e4.attributes[I2]), a2 = this.relationshipLinkChartDiagramLookup.get(e4.attributes[t3]);
        if (t4 && a2) {
          const i2 = ut(new y({ paths: [[[t4.coords[0], t4.coords[1]], [a2.coords[0], a2.coords[1]]]] }));
          this.relationshipLinkChartDiagramLookup.set(e4.attributes[_2], i2);
        } else this.relationshipLinkChartDiagramLookup.set(e4.attributes[_2], null);
      });
    })) : await this._calculateLayoutWithSublayerTimeInfo(this.initializationLinkChartConfig.layoutMode, { lockedNodeLocations: this.getCurrentNodeLocations(), ...this.initializationLinkChartConfig }) : await this._calculateLayoutWithSublayerTimeInfo("organic-standard", { lockedNodeLocations: this.getCurrentNodeLocations() });
  }
  _refreshNamedTypes() {
    for (const e3 of this.layers) e3.emit("refresh", { dataChanged: true });
    for (const e3 of this.tables) e3.emit("refresh", { dataChanged: true });
  }
  _validateOrganicLayoutSettings(e3, t4) {
    const a2 = (e4) => "number" == typeof e4 && !isNaN(e4), i2 = (e4) => a2(e4) && e4 >= 1, o4 = (e4) => a2(e4) && e4 >= 1, s3 = (e4) => Object.values(e2).includes(e4), r2 = (e4) => a2(e4) && e4 >= 0, l3 = {};
    if (!(/* @__PURE__ */ new Set(["organic-standard", "organic-community", "geographic-organic-standard", "chronological-multi-timeline", "chronological-mono-timeline"])).has(e3) || !t4) return l3;
    const { computationBudgetTime: h, autoRepulsionRadius: d3, repulsionRadiusMultiplier: p3, absoluteIdealEdgeLength: c, multiplicativeIdealEdgeLength: u2, idealEdgeLengthType: y3 } = t4;
    return o4(h) ? l3.computationBudgetTime = h : h && i.getLogger(this).warn("Invalid layout computationBudgetTime setting, will revert to default setting"), l3.autoRepulsionRadius = d3, !d3 && i2(p3) ? l3.repulsionRadiusMultiplier = p3 : d3 || (l3.autoRepulsionRadius = true, i.getLogger(this).warn("Invalid layout repulsionRadiusMultiplier setting, will revert to default setting")), "geographic-organic-standard" === e3 && (s3(y3) ? l3.idealEdgeLengthType = y3 : void 0 !== y3 && i.getLogger(this).warn('Invalid layout idealEdgeLengthType setting, will revert to "multiplier" setting'), "absolute-value" === y3 && r2(c) ? l3.absoluteIdealEdgeLength = c : "absolute-value" === y3 && void 0 !== c ? i.getLogger(this).warn("Invalid layout idealEdgeLength setting, will revert to default setting") : "multiplier" === y3 && r2(u2) ? l3.multiplicativeIdealEdgeLength = u2 : "multiplier" === y3 && void 0 !== u2 && i.getLogger(this).warn("Invalid layout idealEdgeLength setting, will revert to default setting")), l3;
  }
  _convertValidatedOrganicSettingsToCalculationSettings(e3) {
    let t4 = e3.idealEdgeLengthType === e2.ABSOLUTE ? e3.absoluteIdealEdgeLength : e3.multiplicativeIdealEdgeLength;
    return e3.idealEdgeLengthType === e2.ABSOLUTE && (void 0 === t4 ? t4 = -1 : t4 *= -1), { computationBudgetTime: e3.computationBudgetTime ?? void 0, repulsionRadiusMultiplier: e3.repulsionRadiusMultiplier && !e3.autoRepulsionRadius ? e3.repulsionRadiusMultiplier : void 0, idealEdgeLengthMultiplier: t4 };
  }
  _createSublayer(e3) {
    return new Ne({ objectType: e3, parentCompositeLayer: this, graphType: e3.type });
  }
  _handleSublayersChange(e3, t4) {
    t4 && (t4.forEach((e4) => {
      e4.parent = null;
    }), this.removeHandles("sublayers-owner")), e3 && (e3.forEach((e4) => {
      e4.parent = this;
    }), this.addHandles([e3.on("after-add", ({ item: e4 }) => {
      e4.parent = this;
    }), e3.on("after-remove", ({ item: e4 }) => {
      e4.parent = null;
    })], "sublayers-owner"));
  }
  _alignLayersDataModelAndInclusionDefinition(e3) {
    const t4 = new Set((e3.entityTypes ?? []).map((e4) => e4.name).concat((e3.relationshipTypes ?? []).map((e4) => e4.name))), i2 = new Set((e3.entityTypes ?? []).map((e4) => e4.name)), o4 = new Set((e3.relationshipTypes ?? []).map((e4) => e4.name));
    if (this.layers) {
      for (const a2 of this.layers) !a2.graphType && t4.has(a2.graphTypeName) && (a2.graphType = i2.has(a2.graphTypeName) ? "entity" : "relationship");
      const e4 = this.layers.filter((e5) => t4.has(e5.graphTypeName) && ("entity" === e5.graphType ? i2.has(e5.graphTypeName) : o4.has(e5.graphTypeName)));
      this.setAtOrigin("layers", e4, t(this.originIdOf("layers")));
    } else this.layers = new O();
    if (this.layers && this._originalInclusionList) {
      const e4 = new Set(this._originalInclusionList.namedTypeDefinitions.keys()), t5 = this.tables?.map((e5) => e5.graphTypeName) ?? [], a2 = this.layers.map((e5) => e5.graphTypeName).concat(t5);
      for (const n of a2) e4.has(n) || this._originalInclusionList.namedTypeDefinitions.set(n, { useAllData: false, members: /* @__PURE__ */ new Map() });
      const i3 = [];
      for (const o5 of this._originalInclusionList.namedTypeDefinitions.keys()) a2.includes(o5) || (i.getLogger(this).warn(`A named type, ${o5}, was in the serialized feature collection but did not have a sublayer config in the item, so will be removed`), i3.push(o5));
      for (const n of i3) this._originalInclusionList.namedTypeDefinitions.delete(n);
    }
  }
};
__decorate([m(y2)], K.prototype, "url", void 0), __decorate([m()], K.prototype, "dataPreloadedInLocalCache", void 0), __decorate([m()], K.prototype, "initializationLinkChartConfig", void 0), __decorate([m()], K.prototype, "membershipModified", void 0), __decorate([m()], K.prototype, "dataManager", void 0), __decorate([m()], K.prototype, "initializationInclusionModeDefinition", null), __decorate([m()], K.prototype, "knowledgeGraph", void 0), __decorate([m({ type: O.ofType(Ne), json: { write: { ignoreOrigin: true } } })], K.prototype, "layers", void 0), __decorate([m({ readOnly: true })], K.prototype, "linkChart", null), __decorate([m()], K.prototype, "entityLinkChartDiagramLookup", void 0), __decorate([m()], K.prototype, "relationshipLinkChartDiagramLookup", void 0), __decorate([m()], K.prototype, "linkChartExtent", void 0), __decorate([m()], K.prototype, "memberEntityTypes", void 0), __decorate([m()], K.prototype, "memberRelationshipTypes", void 0), __decorate([m({ type: ["LinkChartLayer"] })], K.prototype, "operationalLayerType", void 0), __decorate([m()], K.prototype, "sublayerCapabilities", null), __decorate([m()], K.prototype, "sublayerIdsCache", void 0), __decorate([m({ type: O.ofType(Ne), json: { write: { ignoreOrigin: true } } })], K.prototype, "tables", void 0), __decorate([m({ json: { read: false } })], K.prototype, "type", void 0), __decorate([m({ json: { read: false } })], K.prototype, "chronologicalAuxiliaryGraphics", void 0), K = __decorate([a("esri.layers.LinkChartLayer")], K);
var J = K;
export {
  J as default
};
//# sourceMappingURL=LinkChartLayer-W63VFIXT.js.map
