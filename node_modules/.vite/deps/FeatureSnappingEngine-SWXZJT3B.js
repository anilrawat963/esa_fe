import {
  u
} from "./chunk-B5JDN6EY.js";
import {
  e as e3
} from "./chunk-Y2DYCFJT.js";
import {
  e as e2,
  i as i2
} from "./chunk-HUA6ZZZG.js";
import {
  r as r2,
  s as s4
} from "./chunk-IJG47UFZ.js";
import "./chunk-M6NE6PU7.js";
import "./chunk-2XEDAAX5.js";
import "./chunk-OL6EYE44.js";
import {
  f,
  x,
  y
} from "./chunk-36YQJD5W.js";
import {
  Dt
} from "./chunk-BQ6DEXWK.js";
import {
  m as m2,
  p,
  s as s3
} from "./chunk-3SCRAN3E.js";
import "./chunk-NTNXXNRP.js";
import {
  r
} from "./chunk-VIDAPS4J.js";
import {
  U as U2
} from "./chunk-GD72EK2J.js";
import {
  o as o2
} from "./chunk-INJCHY4H.js";
import "./chunk-ALKEERWI.js";
import "./chunk-U6CJFTOF.js";
import {
  d as d2
} from "./chunk-RCHRSC54.js";
import "./chunk-2JMKFI2D.js";
import "./chunk-QYAMBIRP.js";
import "./chunk-JHV6OBEB.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import "./chunk-4VQDBNTM.js";
import "./chunk-3BNOOWTA.js";
import "./chunk-AIJLLSRB.js";
import "./chunk-VX2NEBRT.js";
import "./chunk-7HTU7ZUX.js";
import "./chunk-WDTGOP77.js";
import {
  s as s2,
  v
} from "./chunk-VYMBX5H5.js";
import {
  h
} from "./chunk-BPTFV5VM.js";
import "./chunk-647DAMHU.js";
import "./chunk-O6G3PPOK.js";
import "./chunk-ZKNZTIAS.js";
import "./chunk-OJMISN3F.js";
import "./chunk-EFV6H5NA.js";
import "./chunk-BBYMM7CM.js";
import "./chunk-EM7Y2JZC.js";
import "./chunk-QZQPB5XR.js";
import "./chunk-AQFRVV3U.js";
import "./chunk-XTZAIV4X.js";
import "./chunk-63LDVRFI.js";
import "./chunk-PMGS7UDU.js";
import "./chunk-K2OZ6WVC.js";
import {
  l as l2
} from "./chunk-TF6255HN.js";
import "./chunk-GD4FJL3C.js";
import {
  d,
  o2 as o
} from "./chunk-CNYNCKEV.js";
import "./chunk-XL5QPCXN.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-P6IKJIMO.js";
import "./chunk-MHV23XAQ.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import "./chunk-ONXWBTTM.js";
import "./chunk-T7F6Q6JJ.js";
import "./chunk-YDTPM7OQ.js";
import {
  n
} from "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-XCKT47LJ.js";
import "./chunk-3FUHCAX3.js";
import "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import {
  b as b2
} from "./chunk-AZXJIEZ6.js";
import {
  e
} from "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import {
  U,
  l,
  w
} from "./chunk-2OFHDVO5.js";
import "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-5UPBUJPC.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-CSMCPN64.js";
import "./chunk-7H3U4IJR.js";
import "./chunk-SMWUT52Z.js";
import "./chunk-AXZMNHTN.js";
import "./chunk-5T3MJDSR.js";
import {
  ae,
  ne
} from "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import {
  b,
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import {
  A,
  c,
  s
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i
} from "./chunk-QY7XKUIV.js";
import {
  N,
  has
} from "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/views/interactive/snapping/FeatureSnappingSourceInfo.js
var f2 = class extends b {
  set attributeRulesEnabled(e4) {
    this._set("attributeRulesEnabled", e4), e4 && this.loadRules();
  }
  get layerView() {
    return this.view?.allLayerViews?.find((e4) => e4.layer === this.layer);
  }
  get valid() {
    const { _valid: e4, snappingSource: t, layer: r3 } = this;
    return !(!t || !r3) && e4;
  }
  get subtypeFilter() {
    const { layer: e4, snappingSource: t } = this;
    if (!d(e4) || !e4.subtypes?.length || !t) return { mode: "not-in-use", filter: null };
    const r3 = t.layerSource.sublayerSources.filter((e5) => e5.enabled && e5.layer.visible && r(this.view?.scale, e5.layer.effectiveScaleRange.minScale, e5.layer.effectiveScaleRange.maxScale)).map((e5) => e5.layer.subtypeCode);
    if (!r3.length) return { mode: "none-visible", filter: null };
    if (r3.length === e4.subtypes.length) return { mode: "all-visible", filter: null };
    const i3 = e4.fieldsIndex.get(e4.subtypeField)?.name ?? e4.subtypeField;
    return 1 === r3.length ? { mode: "in-use", filter: `${i3} = ${r3.getItemAt(0)}` } : { mode: "in-use", filter: `${i3} IN (${r3.join(", ")})` };
  }
  get floorFilter() {
    const { view: e4, layer: t } = this;
    return e4 && t ? o2({ view: e4, layer: t }) : null;
  }
  constructor(e4) {
    super(e4), this.layer = null, this.snappingSource = null, this.rulesTable = null, this._valid = null;
  }
  initialize() {
    if (!this.snappingSource || !this.layer) return void (this._valid = false);
    const { layer: e4, snappingSource: t } = this;
    if ("refresh" in e4) {
      const r3 = e4;
      this.addHandles(r3.on("refresh", () => t.refresh()));
    }
    this.loadRules(), this.addHandles([l(() => t.updating, (e5) => t.layerSource.updating = e5, w), l(() => t.availability, (e5) => t.layerSource.availability = e5, w)]);
  }
  getFetchCandidatesParameters(e4, t, r3) {
    if (!this.valid) return [];
    const { layer: i3, layerView: l3, floorFilter: o3, rulesTable: a2, subtypeFilter: u2 } = this, y2 = { distance: r3, mode: this.view?.type ?? "2d", point: e4, coordinateHelper: t.coordinateHelper, ...h2(), filter: l3 && "filter" in l3 ? l3.filter : null };
    if (o3 && (y2.filter = m3(y2.filter, o3)), "not-in-use" !== u2.mode && "all-visible" !== u2.mode) {
      if ("none-visible" === u2.mode) return [];
      y2.filter ? y2.filter.where = l2(y2.filter.where, u2.mode) : y2.filter = new d2({ where: u2.filter });
    }
    if (!this.attributeRulesEnabled) return [y2];
    const f3 = t.feature, v2 = "subtype-sublayer" === f3?.sourceLayer?.type ? f3.sourceLayer.parent : f3?.sourceLayer;
    if (a2 && f3 && x(this.view?.map) && (o(i3) || d(i3)) && (o(v2) || d(v2)) && this.view.map.utilityNetworks?.find((e5) => e5.isUtilityLayer(v2))) {
      if ("loaded" !== a2.loadStatus) return [];
      const e5 = [], t2 = i3.layerId, r4 = a2.getFeatureSQL(v2, f3)?.[t2];
      if (!r4) return [];
      const l4 = r4.anyVertex;
      let s5 = r4.endVertex;
      return s5 && l4 && s5 === l4 && (s5 = ""), s5 && e5.push({ ...y2, returnEdge: false, vertexMode: "ends", filter: m3(y2.filter, s5) }), l4 && e5.push({ ...y2, returnEdge: has("snapping-include-edges-when-applying-any-vertex-rule") ?? false, vertexMode: "all", filter: m3(y2.filter, l4) }), e5;
    }
    return [y2];
  }
  async loadRules() {
    this._valid = null;
    const { layer: e4, view: t, attributeRulesEnabled: i3 } = this;
    if (i3 && e4 && t && x(t?.map) && (o(e4) || d(e4))) try {
      await Promise.allSettled(t.map.utilityNetworks?.map((e5) => e5.load()) ?? []);
      const r3 = t.map.utilityNetworks?.find((t2) => t2.isUtilityLayer(e4));
      r3 && (this.rulesTable = await r3.getRulesTable(), await this.rulesTable?.load());
    } catch (l3) {
      return this._valid = false, void i.getLogger("esri.views.interactive.snapping.FeatureSnappingSourceInfo").error("Failed to load rules table for snapping source", e4.title);
    }
    this._valid = true;
  }
  remove() {
    this.destroy();
  }
  destroy() {
    this.snappingSource?.destroy();
  }
};
function h2() {
  return { returnEdge: true, vertexMode: "all" };
}
function m3(e4, t) {
  return null == e4 ? new d2({ where: t }) : e4.where ? new d2({ where: l2(e4.where, t) }) : new d2({ where: t });
}
__decorate([m({ constructOnly: true })], f2.prototype, "layer", void 0), __decorate([m({ constructOnly: true })], f2.prototype, "snappingSource", void 0), __decorate([m({ constructOnly: true })], f2.prototype, "view", void 0), __decorate([m({ value: false })], f2.prototype, "attributeRulesEnabled", null), __decorate([m()], f2.prototype, "layerView", null), __decorate([m()], f2.prototype, "rulesTable", void 0), __decorate([m()], f2.prototype, "valid", null), __decorate([m()], f2.prototype, "subtypeFilter", null), __decorate([m()], f2.prototype, "floorFilter", null), __decorate([m()], f2.prototype, "_valid", void 0), f2 = __decorate([a("esri.views.interactive.snapping.FeatureSnappingSourceInfo")], f2);

// node_modules/@arcgis/core/views/interactive/snapping/FeatureSnappingEngine.js
var H = class extends b {
  get updating() {
    return this._snappingSources.some((e4) => null == e4?.valid || true === e4.valid && true === e4.snappingSource?.updating) || this._updatingHandles.updating;
  }
  constructor(e4) {
    super(e4), this.options = null, this._domain = 1, this._updatingHandles = new h(), this._sourceModules = { featureService: { module: null, loader: null }, featureCollection: { module: null, loader: null }, graphics: { module: null, loader: null }, notes: { module: null, loader: null }, scene: { module: null, loader: null } };
  }
  initialize() {
    const e4 = u(() => this.options?._effectiveFeatureSources, (e5, t) => this._createSourceInfo(e5, t));
    this._snappingSources = e4, this.addHandles([c(e4), l(() => ({ rulesEnabled: !!this.options?.attributeRulesEnabled, sources: this._snappingSources.filter(N) }), ({ rulesEnabled: e5, sources: t }) => {
      for (const r3 of t) r3.attributeRulesEnabled = e5;
    }, U)]);
  }
  destroy() {
    this._set("options", null), this._updatingHandles.destroy();
  }
  async fetchCandidates(e4, t, r3, a2) {
    if (!(t & this._domain && null != this.options && this.options.effectiveFeatureEnabled)) return [];
    const n2 = [], o3 = this._computeScreenSizeDistanceParameters(e4, r3);
    for (const s5 of this._snappingSources) {
      if (!s5?.valid || !s5.snappingSource?.layerSource?.enabled || s5.layerView?.suspended) continue;
      const t2 = s5.getFetchCandidatesParameters(e4, r3, o3);
      for (const e5 of t2) n2.push(s5.snappingSource.fetchCandidates(e5, a2).then((e6) => e6.filter((e7) => !this._candidateIsExcluded(s5.snappingSource, e7, r3.excludeFeature))));
    }
    const c2 = (await A(n2)).flat();
    return this._addRightAngleCandidates(c2, e4, o3, r3), s(a2), y(e4, c2), c2;
  }
  _addRightAngleCandidates(e4, t, r3, a2) {
    const n2 = null != a2.vertexHandle ? a2.vertexHandle.rightSegment?.rightVertex?.pos : null != a2.editGeometryOperations && "polygon" === a2.editGeometryOperations.data.type ? a2.editGeometryOperations.data.parts[0]?.getFirstVertex()?.pos : null, s5 = null != a2.vertexHandle ? a2.vertexHandle.leftSegment?.leftVertex?.pos : null != a2.editGeometryOperations ? a2.editGeometryOperations.data.parts[0]?.getLastVertex()?.pos : null, { view: i3 } = this, o3 = m2(n2, i3, a2), c2 = m2(s5, i3, a2), u2 = e4.length;
    for (let l3 = 0; l3 < u2; l3++) this._addRightAngleCandidate(e4[l3], c2, t, r3, e4), this._addRightAngleCandidate(e4[l3], o3, t, r3, e4);
  }
  _addRightAngleCandidate(e4, t, r3, a2, n2) {
    if (null == t || !P(e4)) return;
    const s5 = e4.constraint.closestTo(t), i3 = (s5[0] - r3[0]) / a2.x, o3 = (s5[1] - r3[1]) / a2.y, { start: c2, end: u2 } = e4.constraint;
    if (i3 * i3 + o3 * o3 <= 1) {
      const r4 = b2(s3(s5), s3(c2)) > b2(s3(s5), s3(u2)) ? c2 : u2, a3 = new r2({ targetPoint: p(s5), otherVertex: t, otherVertexType: 0, previousVertex: r4, constraint: new Dt(t, s5), objectId: e4.objectId, isDraped: e4.isDraped, domain: 1 });
      n2.push(a3);
    }
  }
  _computeScreenSizeDistanceParameters(e4, t) {
    let r3 = null != this.options ? this.options.distance * ("touch" === t.pointer ? this.options.touchSensitivityMultiplier : 1) : 0;
    return null == this.view ? { x: r3, y: r3, z: r3, distance: r3 } : "2d" === this.view.type ? (r3 *= this.view.resolution, { x: r3, y: r3, z: r3, distance: r3 }) : this._computeScreenSizeDistanceParameters3D(e4, r3, this.view, t);
  }
  _computeScreenSizeDistanceParameters3D(e4, t, r3, a2) {
    const { spatialReference: n2 } = a2;
    r3.renderCoordsHelper.toRenderCoords(e4, n2, O);
    const s5 = r3.state.camera.computeScreenPixelSizeAt(O), i3 = s5 * r3.renderCoordsHelper.unitInMeters, o3 = i3 / ae(n2), c2 = i3 / ne(n2), p2 = t * o3, d3 = t * c2, m4 = s4(e4, n2, U2, r3), S = m4 ? E(m4, e4, o3, 0, 0, r3, a2) : 0, g = m4 ? E(m4, e4, 0, o3, 0, r3, a2) : 0, h3 = m4 ? E(m4, e4, 0, 0, c2, r3, a2) : 0;
    return { x: 0 === S ? 0 : p2 / S, y: 0 === g ? 0 : p2 / g, z: 0 === h3 ? 0 : d3 / h3, distance: s5 * t };
  }
  _candidateIsExcluded(e4, t, r3) {
    if (null == r3) return false;
    const a2 = this._getCandidateObjectId(t);
    if (null == a2) return false;
    const n2 = e4.layerSource.layer;
    return "graphics" === n2.type ? r3.uid === a2 : r3.sourceLayer === n2 && (!(!r3.attributes || !("objectIdField" in n2)) && r3.attributes[n2.objectIdField] === a2);
  }
  _getCandidateObjectId(e4) {
    return e4 instanceof e2 ? e4.objectId : null;
  }
  async _createSourceInfo(e4, t) {
    const r3 = e4.layer;
    r3.loaded || (await r3.load(), s(t));
    const { view: a2 } = this, n2 = await this._createFeatureSnappingSourceType(e4);
    return s(t), new f2(null == n2 ? {} : { snappingSource: n2, view: a2, layer: r3 });
  }
  async _createFeatureSnappingSourceType(e4) {
    switch (e4.layer.type) {
      case "feature":
      case "geojson":
      case "csv":
      case "oriented-imagery":
      case "subtype-group":
      case "wfs":
        return this._createFeatureSnappingSourceFeatureLayer(e4);
      case "graphics":
        return this._createFeatureSnappingSourceGraphicsLayer(e4);
      case "map-notes":
        return this._createFeatureSnappingSourceMapNotesLayer(e4);
      case "scene":
      case "building-scene":
        return this._createFeatureSnappingSourceSceneLayer(e4);
    }
    return null;
  }
  async _createFeatureSnappingSourceSceneLayer(e4) {
    const { view: t } = this;
    if (null == t || "3d" !== t.type) return null;
    return new (await this._getSourceModule("scene")).SceneLayerSnappingSource({ layerSource: e4, view: t });
  }
  async _createFeatureSnappingSourceFeatureLayer(e4) {
    switch (e4.layer.source?.type) {
      case "feature-layer":
      case "oriented-imagery":
        return new (await this._getSourceModule("featureService")).FeatureServiceSnappingSource({ spatialReference: this.spatialReference, view: this.view, layerSource: e4 });
      case "memory":
      case "csv":
      case "geojson":
      case "wfs":
        if ("mesh" === e4.layer.geometryType) return null;
        return new (await this._getSourceModule("featureCollection")).FeatureCollectionSnappingSource({ layerSource: e4, view: this.view });
    }
    return null;
  }
  async _createFeatureSnappingSourceGraphicsLayer(e4) {
    return new (await this._getSourceModule("graphics")).GraphicsSnappingSource({ getGraphicsLayers: () => [e4.layer], spatialReference: this.spatialReference, view: this.view, layerSource: e4 });
  }
  async _createFeatureSnappingSourceMapNotesLayer(e4) {
    return new (await this._getSourceModule("notes")).GraphicsSnappingSource({ getGraphicsLayers: () => e4.layer.sublayers?.toArray() ?? [], spatialReference: this.spatialReference, view: this.view, layerSource: e4 });
  }
  async _getSourceModule(e4) {
    const t = this._sourceModules[e4];
    if (null == t.loader) {
      const t2 = this._loadSourceModule(e4), r3 = { module: null, loader: t2 };
      this._sourceModules[e4] = r3;
      const a2 = await t2, n2 = { module: a2, loader: t2 };
      return this._sourceModules[e4] = n2, a2;
    }
    return null == t.module ? t.loader : t.module;
  }
  _loadSourceModule(e4) {
    const t = this._updatingHandles;
    switch (e4) {
      case "featureService":
        return t.addPromise(import("./FeatureServiceSnappingSource-IQMQ37QG.js"));
      case "featureCollection":
        return t.addPromise(import("./FeatureCollectionSnappingSource-7JOYMSCR.js"));
      case "graphics":
      case "notes":
        return t.addPromise(import("./GraphicsSnappingSource-RVDCOC25.js"));
      case "scene":
        return t.addPromise(import("./SceneLayerSnappingSource-L4LJZTXE.js"));
    }
  }
  get test() {
  }
};
function P(e4) {
  return (e4 instanceof i2 || e4 instanceof e3) && !z(e4);
}
function z({ constraint: { start: e4, end: t } }) {
  const r3 = v(e4, t), a2 = b2(s3(e4), s3(t));
  return r3 < e() || a2 / r3 < A2;
}
function E(e4, t, r3, a2, n2, s5, { spatialReference: i3 }) {
  const o3 = s2(U3, t);
  o3[0] += r3, o3[1] += a2, o3[2] += n2;
  const c2 = s4(o3, i3, U2, s5);
  return c2 ? f(c2, e4) : 1 / 0;
}
__decorate([m({ constructOnly: true })], H.prototype, "spatialReference", void 0), __decorate([m({ constructOnly: true })], H.prototype, "view", void 0), __decorate([m()], H.prototype, "options", void 0), __decorate([m({ readOnly: true })], H.prototype, "updating", null), __decorate([m()], H.prototype, "_snappingSources", void 0), H = __decorate([a("esri.views.interactive.snapping.FeatureSnappingEngine")], H);
var O = n();
var U3 = n();
var A2 = 1e-4;
export {
  H as FeatureSnappingEngine
};
//# sourceMappingURL=FeatureSnappingEngine-SWXZJT3B.js.map
