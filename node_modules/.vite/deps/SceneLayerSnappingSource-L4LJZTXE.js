import {
  r
} from "./chunk-5XYRAKJX.js";
import {
  i
} from "./chunk-HUA6ZZZG.js";
import "./chunk-TNKZDDMZ.js";
import "./chunk-OL6EYE44.js";
import "./chunk-BQ6DEXWK.js";
import {
  c as c3,
  p
} from "./chunk-3SCRAN3E.js";
import "./chunk-NTNXXNRP.js";
import "./chunk-GD72EK2J.js";
import {
  o
} from "./chunk-A2QKOXAQ.js";
import "./chunk-ALKEERWI.js";
import {
  A
} from "./chunk-U6CJFTOF.js";
import "./chunk-2JMKFI2D.js";
import "./chunk-QYAMBIRP.js";
import "./chunk-JHV6OBEB.js";
import {
  t
} from "./chunk-NA2LMHWN.js";
import {
  c as c2
} from "./chunk-RJMNQ6EU.js";
import "./chunk-XPA3C4DZ.js";
import "./chunk-2AOVWXAQ.js";
import "./chunk-ALR6N4CF.js";
import "./chunk-4X4BOGIG.js";
import "./chunk-Y4O7HJXV.js";
import "./chunk-7QPS6ATI.js";
import "./chunk-YYXR3KOD.js";
import "./chunk-NDFIZYZY.js";
import "./chunk-TLTSPUO7.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import "./chunk-ZCI5A4FF.js";
import "./chunk-2D47RURG.js";
import "./chunk-QNVJVDYZ.js";
import "./chunk-WDTGOP77.js";
import "./chunk-VYMBX5H5.js";
import {
  h
} from "./chunk-BPTFV5VM.js";
import "./chunk-BBYMM7CM.js";
import "./chunk-XTZAIV4X.js";
import "./chunk-63LDVRFI.js";
import "./chunk-K2OZ6WVC.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6KDQMJAI.js";
import "./chunk-UDHS2MGH.js";
import "./chunk-ENINOZUZ.js";
import "./chunk-XLOINTMG.js";
import {
  n
} from "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import "./chunk-2OFHDVO5.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-SMWUT52Z.js";
import "./chunk-AXZMNHTN.js";
import "./chunk-5T3MJDSR.js";
import "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import {
  b,
  m as m2
} from "./chunk-5EI5H4QX.js";
import {
  a2
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import {
  a as a3,
  c,
  e2 as e,
  l2 as l,
  s
} from "./chunk-GNMPGHLQ.js";
import "./chunk-QY7XKUIV.js";
import {
  N,
  a2 as a,
  m
} from "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/EdgeWorkerHandle.js
var a4 = class extends o {
  constructor(e2) {
    super("EdgeProcessingWorker", "extract", { extract: (e3) => [e3.dataBuffer], extractComponentsEdgeLocations: (e3) => [e3.dataBuffer], extractEdgeLocations: (e3) => [e3.dataBuffer] }, e2);
  }
  async process(e2, t2, r2) {
    if (r2) return c2(e2);
    return i2(await this.invoke(new o2(e2), t2));
  }
  async extractEdgeLocations(e2, t2) {
    const r2 = await this.invokeMethod("extractEdgeLocations", new o2(e2), t2);
    return t(r2);
  }
  async extractComponentsEdgeLocations(e2, t2) {
    const r2 = await this.invokeMethod("extractComponentsEdgeLocations", new o2(e2), t2);
    return t(r2);
  }
};
function i2(e2) {
  return { regular: { instancesData: t(e2.regular.instancesData), lodInfo: { lengths: new Float32Array(e2.regular.lodInfo.lengths) } }, silhouette: { instancesData: t(e2.silhouette.instancesData), lodInfo: { lengths: new Float32Array(e2.silhouette.lodInfo.lengths) } }, averageEdgeLength: e2.averageEdgeLength };
}
var o2 = class {
  constructor(r2) {
    this.dataBuffer = r2.data.buffer, this.writerSettings = r2.writerSettings, this.skipDeduplicate = r2.skipDeduplicate, this.indices = m(r2.indices) ? r2.indices.buffer : r2.indices, this.indicesType = m(r2.indices) ? a(r2.indices) ? "Uint32Array" : "Uint16Array" : "Array", this.indicesLength = r2.indicesLength;
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/sceneLayerSource/SceneLayerSnappingSourceWorkerHandle.js
var l2 = class extends b {
  constructor(e2) {
    super(e2), this.availability = 0, this._ids = /* @__PURE__ */ new Set();
  }
  destroy() {
    this._workerHandle.destroy(), this._workerHandle = null;
  }
  initialize() {
    this._workerHandle = new h2(this.schedule, { fetchAllEdgeLocations: (e2, t2) => this._fetchAllEdgeLocations(e2, t2) });
  }
  async fetchCandidates(e2, t2) {
    const r2 = e2.coordinateHelper, { point: o3 } = e2, s2 = u;
    this.renderCoordsHelper.toRenderCoords(o3, r2.spatialReference, s2);
    const n2 = e2.distance, a5 = "number" == typeof n2 ? n2 : n2.distance, d = await this._workerHandle.invoke({ bounds: A(s2[0], s2[1], s2[2], a5), returnEdge: e2.returnEdge, returnVertex: "none" !== e2.vertexMode }, t2);
    return d.candidates.sort((e3, t3) => e3.distance - t3.distance), d.candidates.map((e3) => this._convertCandidate(r2, e3));
  }
  async add(e2, t2) {
    this._ids.add(e2.id), await this._workerHandle.invokeMethod("add", e2, t2);
  }
  async remove(e2, t2) {
    this._ids.delete(e2.id), await this._workerHandle.invokeMethod("remove", e2, t2);
  }
  _convertCandidate(e2, t2) {
    switch (t2.type) {
      case "edge":
        return new i({ objectId: t2.objectId, targetPoint: p(this._convertRenderCoordinate(e2, t2.target)), edgeStart: this._convertRenderCoordinate(e2, t2.start), edgeEnd: this._convertRenderCoordinate(e2, t2.end), isDraped: false });
      case "vertex":
        return new r({ objectId: t2.objectId, targetPoint: p(this._convertRenderCoordinate(e2, t2.target)), isDraped: false });
    }
  }
  _convertRenderCoordinate({ spatialReference: e2 }, t2) {
    const r2 = n();
    return this.renderCoordsHelper.fromRenderCoords(t2, r2, e2), c3(r2);
  }
  async _fetchAllEdgeLocations(e2, t2) {
    const r2 = [], o3 = [];
    for (const { id: s2, uid: n2 } of e2.components) this._ids.has(s2) && r2.push((async () => {
      const e3 = await this.fetchEdgeLocations(s2, t2.signal), r3 = e3.locations.buffer;
      return o3.push(r3), { id: s2, uid: n2, objectIds: e3.objectIds, locations: r3, origin: e3.origin, type: e3.type };
    })());
    return { result: { components: (await Promise.all(r2)).filter(({ id: e3 }) => this._ids.has(e3)) }, transferList: o3 };
  }
};
__decorate([m2({ constructOnly: true })], l2.prototype, "renderCoordsHelper", void 0), __decorate([m2({ constructOnly: true })], l2.prototype, "fetchEdgeLocations", void 0), __decorate([m2({ constructOnly: true })], l2.prototype, "schedule", void 0), __decorate([m2({ readOnly: true })], l2.prototype, "availability", void 0), l2 = __decorate([a2("esri.views.interactive.snapping.featureSources.sceneLayerSource.SceneLayerSnappingSourceWorkerHandle")], l2);
var h2 = class extends o {
  constructor(e2, t2) {
    super("SceneLayerSnappingSourceWorker", "fetchCandidates", {}, e2, { strategy: "dedicated", client: t2 });
  }
};
var u = n();

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/I3SSnappingSource.js
var p2 = class extends b {
  get updating() {
    return this._updatingHandles.updating;
  }
  constructor(e2) {
    super(e2), this.availability = 1, this._updatingHandles = new h(), this._abortController = new AbortController();
  }
  destroy() {
    this._tracker = l(this._tracker), this._abortController = e(this._abortController), this._updatingHandles.destroy();
  }
  initialize() {
    const { view: e2 } = this, r2 = e2.resourceController;
    this._edgeWorker = new a4(h3(r2)), this._workerHandle = new l2({ renderCoordsHelper: this.view.renderCoordsHelper, schedule: h3(r2), fetchEdgeLocations: async (e3, r3) => {
      if (null == this._tracker) throw new Error("tracker-not-initialized");
      return this._tracker.fetchEdgeLocations(e3, this._edgeWorker, r3);
    } }), this._updatingHandles.addPromise(this._setupLayerView()), this.addHandles([c(this._workerHandle), c(this._edgeWorker)]);
  }
  async fetchCandidates(e2, r2) {
    return this._workerHandle.fetchCandidates(e2, r2);
  }
  refresh() {
  }
  async _setupLayerView() {
    if (this.destroyed) return;
    const e2 = this._abortController?.signal, r2 = await this.getLayerView();
    null == r2 || a3(e2) || (this._tracker = r2.trackSnappingSources({ add: (r3, t2) => {
      this._updatingHandles.addPromise(this._workerHandle.add({ id: r3, bounds: t2 }, e2));
    }, remove: (r3) => {
      this._updatingHandles.addPromise(this._workerHandle.remove({ id: r3 }, e2));
    } }));
  }
};
function h3(e2) {
  return (r2) => e2.immediate.schedule(r2);
}
__decorate([m2({ constructOnly: true })], p2.prototype, "getLayerView", void 0), __decorate([m2({ constructOnly: true })], p2.prototype, "view", void 0), __decorate([m2({ readOnly: true })], p2.prototype, "updating", null), __decorate([m2({ readOnly: true })], p2.prototype, "availability", void 0), p2 = __decorate([a2("esri.views.interactive.snapping.featureSources.I3SSnappingSource")], p2);

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/SceneLayerSnappingSource.js
var c4 = class extends b {
  get updating() {
    return this._i3sSources.some((e2) => e2.updating);
  }
  constructor(e2) {
    super(e2), this.availability = 1, this._i3sSources = [];
  }
  destroy() {
    this._i3sSources.forEach((e2) => e2.destroy()), this._i3sSources.length = 0;
  }
  initialize() {
    const { view: e2 } = this, r2 = this.layerSource.layer;
    this._i3sSources = "building-scene" === r2.type ? this._getBuildingSceneI3SSources(e2, r2) : [this._getSceneLayerI3SSource(e2, r2)];
  }
  async fetchCandidates(e2, r2) {
    const t2 = await Promise.all(this._i3sSources.map((t3) => t3.fetchCandidates(e2, r2)));
    return s(r2), t2.flat();
  }
  refresh() {
    this._i3sSources.forEach((e2) => e2.refresh());
  }
  _getBuildingSceneI3SSources(e2, r2) {
    return r2.allSublayers.toArray().map((t2) => "building-component" === t2.type ? new p2({ getLayerView: async () => (await e2.whenLayerView(r2)).whenSublayerView(t2), view: e2 }) : null).filter(N);
  }
  _getSceneLayerI3SSource(e2, r2) {
    return new p2({ getLayerView: async () => {
      const t2 = await e2.whenLayerView(r2);
      return "scene-layer-graphics-3d" === t2.type ? void 0 : t2;
    }, view: e2 });
  }
};
__decorate([m2({ constructOnly: true })], c4.prototype, "layerSource", void 0), __decorate([m2({ constructOnly: true })], c4.prototype, "view", void 0), __decorate([m2({ readOnly: true })], c4.prototype, "updating", null), __decorate([m2({ readOnly: true })], c4.prototype, "availability", void 0), c4 = __decorate([a2("esri.views.interactive.snapping.featureSources.SceneLayerSnappingSource")], c4);
export {
  c4 as SceneLayerSnappingSource
};
//# sourceMappingURL=SceneLayerSnappingSource-L4LJZTXE.js.map
