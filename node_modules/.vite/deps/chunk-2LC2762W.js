import {
  o as o3
} from "./chunk-W6HOAVT4.js";
import {
  C as C2,
  o as o2
} from "./chunk-DTZUXJMD.js";
import {
  c as c2
} from "./chunk-6YRQYUCY.js";
import {
  n
} from "./chunk-75XOUSSS.js";
import {
  s as s3
} from "./chunk-TH4EQWJJ.js";
import {
  m
} from "./chunk-3FUHCAX3.js";
import {
  P,
  y3 as y
} from "./chunk-PZ5RULLK.js";
import {
  z
} from "./chunk-H74Q4SYB.js";
import {
  _,
  c,
  o,
  r
} from "./chunk-AXZMNHTN.js";
import {
  f
} from "./chunk-5T3MJDSR.js";
import {
  C,
  I,
  O2,
  T,
  U2 as U,
  p,
  w
} from "./chunk-NMQNUPE4.js";
import {
  a
} from "./chunk-6SSZNBOK.js";
import {
  O,
  s as s2
} from "./chunk-GNMPGHLQ.js";
import {
  s2 as s
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/geometry/projection/projectXYZToVector.js
function t(r2, t2, f2, c3, i, m2) {
  return e[0] = r2, e[1] = t2, e[2] = f2, o2(e, c3, 0, i, m2, 0);
}
var e = n();

// node_modules/@arcgis/core/geometry/projectionUtils.js
var k = null;
var v = null;
var P2 = null;
var A = null;
var O3 = {};
var E = new s3();
function G() {
  return !!(v?.isLoaded() && P2?.isLoaded() && A?.isLoaded());
}
function U2() {
  return !!G() || (a(E), L(), false);
}
function b(n2, e2) {
  return !n2 || !e2 || (J(n2, e2) || U2());
}
function I2(n2, e2) {
  return !J(n2, e2) && !G();
}
async function L(n2) {
  null == k && (k = Promise.all([import("./projectOperator-U7ULNKRC.js").then((n3) => (v = n3, v.load())), import("./projectOperator-QPO6KSCZ.js").then((n3) => (P2 = n3, P2.load())), import("./geographicTransformationUtils-IOOIRY6G.js").then((n3) => (A = n3, A.load()))])), await k, s2(n2), E.notify();
}
function W(n2, e2, r2) {
  return Array.isArray(n2) ? 0 === n2.length ? [] : (r(n2), B(n2, n2[0].spatialReference, e2, r2)) : (o(n2), B([n2], n2.spatialReference, e2, r2)[0]);
}
function B(n2, e2, r2, t2) {
  if (null == e2 || null == r2) return n2;
  if (J(e2, r2, t2)) return n2.map((n3) => Q(n3, e2, r2));
  if (null == t2?.geographicTransformation && O2(e2)) {
    return n2.map((n3) => Q(n3, e2, f.WGS84)).map((n3) => F(n3, r2));
  }
  if (null == t2?.geographicTransformation && O2(r2)) {
    return n2.map((n3) => F(n3, f.WGS84)).map((n3) => Q(n3, f.WGS84, r2));
  }
  if (!G()) throw new q();
  if (!t2?.geographicTransformation) {
    if (t2?.extendedParams) t2 = { ...t2, geographicTransformation: A.getTransformation(e2, r2, t2.areaOfInterestExtent) || new c2() };
    else if (!t2?.areaOfInterestExtent) {
      const n3 = V(e2, r2);
      let o4 = O3[n3];
      o4 || (o4 = A.getTransformation(e2, r2) || new c2(), O3[n3] = o4), t2 = { geographicTransformation: o4 };
    }
  }
  return n2[0].spatialReference || (n2[0].spatialReference = e2), n2[0] instanceof c ? v.executeMany(n2, r2, t2) : P2.executeMany(n2, r2, t2);
}
function V(n2, e2) {
  return [n2.wkid?.toString() ?? "-1", n2.wkt?.toString() ?? "", n2.wkt2?.toString() ?? "", e2.wkid?.toString() ?? "-1", e2.wkt?.toString() ?? "", e2.wkt2?.toString() ?? ""].join();
}
function X(n2, e2) {
  const r2 = Y([n2], e2);
  return null != r2.pending ? { pending: r2.pending, geometry: null } : null != r2.geometries ? { pending: null, geometry: r2.geometries[0] } : { pending: null, geometry: null };
}
function Y(n2, e2) {
  if (!G()) {
    for (const r2 of n2) if (null != r2 && !T(r2.spatialReference, e2) && p(r2.spatialReference) && p(e2) && !J(r2.spatialReference, e2)) return a(E), { pending: L(), geometries: null };
  }
  return { pending: null, geometries: n2.map((n3) => null == n3 ? null : T(n3.spatialReference, e2) ? n3 : p(n3.spatialReference) && p(e2) ? F(n3, e2) : null) };
}
var q = class extends s {
  constructor() {
    super("projection:not-loaded", "projection engine not fully loaded yet, please call load()");
  }
};
function C3() {
  k = null, v = null, P2 = null, A = null, O3 = {};
}
var D = { get loadPromise() {
  return k;
} };
function F(n2, e2) {
  try {
    const r2 = W(n2, e2);
    if (null == r2) return null;
    "xmin" in n2 && "xmin" in r2 && (r2.zmin = n2.zmin, r2.zmax = n2.zmax);
    const t2 = o3(r2.type, n2.spatialReference, e2);
    return null != t2 && t2(r2), r2;
  } catch (r2) {
    if (!(r2 instanceof q)) throw r2;
    return null;
  }
}
async function H(n2, e2, r2) {
  const t2 = n2.spatialReference;
  return null != t2 && null != e2 && await N(t2, e2, null, r2), F(n2, e2);
}
function J(n2, e2, r2) {
  return !(r2?.areaOfInterestExtent || r2?.extendedParams || r2?.geographicTransformation) && (!!T(n2, e2) || p(n2) && p(e2) && !!C2(n2, e2));
}
function K(n2, e2) {
  if (T(n2, e2)) return true;
  if (!p(n2) || !p(e2)) return false;
  const r2 = I(n2) || C(n2) || w(n2), t2 = I(e2) || C(e2) || w(e2);
  return r2 && t2;
}
async function N(n2, e2, t2, o4) {
  if (G()) return O(o4);
  if (Array.isArray(n2)) {
    for (const { source: r2, dest: i, options: s4 } of n2) if (r2 && i && !J(r2, i, s4)) return L(o4);
  } else if (n2 && e2 && !J(n2, e2, t2)) return L(o4);
  return O(o4);
}
function Q(n2, e2, r2) {
  return n2 ? "x" in n2 ? _2(n2, e2, new _(), r2, 0) : "xmin" in n2 ? ln(n2, e2, new z(), r2, 0) : "rings" in n2 ? sn(n2, e2, new P(), r2, 0) : "paths" in n2 ? tn(n2, e2, new y(), r2, 0) : "points" in n2 ? en(n2, e2, new m(), r2, 0) : null : null;
}
function $(n2, e2, r2 = e2.spatialReference, t2 = 0) {
  return null != r2 && null != n2.spatialReference && null != _2(n2, n2.spatialReference, e2, r2, t2);
}
function _2(n2, e2, r2, t2, o4) {
  fn[0] = n2.x, fn[1] = n2.y;
  const i = n2.z;
  return fn[2] = void 0 !== i ? i : o4, o2(fn, e2, 0, fn, t2, 0) ? (r2.x = fn[0], r2.y = fn[1], r2.spatialReference = t2, void 0 !== i || U(t2) ? (r2.z = fn[2], r2.hasZ = true) : (r2.z = void 0, r2.hasZ = false), void 0 === n2.m ? (r2.m = void 0, r2.hasM = false) : (r2.m = n2.m, r2.hasM = true), r2) : null;
}
function nn(n2, e2, r2 = e2.spatialReference, t2 = 0) {
  return null != n2.spatialReference && null != r2 && null != en(n2, n2.spatialReference, e2, r2, t2);
}
function en(n2, e2, r2, t2, o4) {
  const { points: i, hasZ: s4, hasM: a2 } = n2, l = [], f2 = i.length, c3 = [];
  for (const u of i) c3.push(u[0], u[1], s4 ? u[2] : o4);
  if (!o2(c3, e2, 0, c3, t2, 0, f2)) return null;
  const p2 = s4 || U(t2);
  for (let u = 0; u < f2; ++u) {
    const n3 = 3 * u, e3 = c3[n3], r3 = c3[n3 + 1];
    p2 && a2 ? l.push([e3, r3, c3[n3 + 2], i[u][3]]) : p2 ? l.push([e3, r3, c3[n3 + 2]]) : a2 ? l.push([e3, r3, i[u][2]]) : l.push([e3, r3]);
  }
  return r2.points = l, r2.spatialReference = t2, r2.hasZ = s4, r2.hasM = a2, r2;
}
function rn(n2, e2, r2 = e2.spatialReference, t2 = 0) {
  return null != n2.spatialReference && null != r2 && null != tn(n2, n2.spatialReference, e2, r2, t2);
}
function tn(n2, e2, r2, t2, o4) {
  const { paths: i, hasZ: s4, hasM: a2 } = n2, l = [];
  if (!un(i, s4 ?? false, a2 ?? false, e2, l, t2, o4)) return null;
  const f2 = s4 || U(t2);
  return r2.paths = l, r2.spatialReference = t2, r2.hasZ = f2, r2.hasM = a2, r2;
}
function on(n2, e2, r2 = e2.spatialReference, t2 = 0) {
  return null != n2.spatialReference && null != r2 && null != sn(n2, n2.spatialReference, e2, r2, t2);
}
function sn(n2, e2, r2, t2, o4) {
  const { rings: i, hasZ: s4, hasM: a2 } = n2, l = [];
  if (!un(i, s4 ?? false, a2 ?? false, e2, l, t2, o4)) return null;
  const f2 = s4 || U(t2);
  return r2.rings = l, r2.spatialReference = t2, r2.hasZ = f2, r2.hasM = a2, r2;
}
function an(n2, e2, r2 = e2.spatialReference, t2 = 0) {
  return null != n2.spatialReference && null != r2 && null != ln(n2, n2.spatialReference, e2, r2, t2);
}
function ln(n2, e2, r2, t2, o4) {
  const { xmin: i, ymin: s4, xmax: a2, ymax: l, hasZ: f2, hasM: c3 } = n2, p2 = f2 ? n2.zmin : o4;
  if (!t(i, s4, p2, e2, fn, t2)) return null;
  const m2 = f2 || U(t2);
  r2.xmin = fn[0], r2.ymin = fn[1], m2 && (r2.zmin = fn[2]);
  const g = f2 ? n2.zmax : o4;
  return t(a2, l, g, e2, fn, t2) ? (r2.xmax = fn[0], r2.ymax = fn[1], m2 && (r2.zmax = fn[2]), c3 && (r2.mmin = n2.mmin, r2.mmax = n2.mmax), r2.spatialReference = t2, r2) : null;
}
function un(n2, e2, r2, t2, o4, i, s4 = 0) {
  const a2 = new Array();
  for (const u of n2) for (const n3 of u) a2.push(n3[0], n3[1], e2 ? n3[2] : s4);
  if (!o2(a2, t2, 0, a2, i, 0)) return false;
  let l = 0;
  o4.length = 0;
  const f2 = e2 || U(i);
  for (const u of n2) {
    const n3 = new Array();
    for (const e3 of u) f2 && r2 ? n3.push([a2[l++], a2[l++], a2[l++], e3[3]]) : f2 ? n3.push([a2[l++], a2[l++], a2[l++]]) : r2 ? (n3.push([a2[l++], a2[l++], e3[2]]), l++) : (n3.push([a2[l++], a2[l++]]), l++);
    o4.push(n3);
  }
  return true;
}
var fn = n();

export {
  t,
  G,
  U2 as U,
  b,
  I2 as I,
  L,
  W,
  B,
  X,
  Y,
  C3 as C,
  D,
  F,
  H,
  J,
  K,
  N,
  Q,
  $,
  nn,
  rn,
  on,
  an
};
//# sourceMappingURL=chunk-2LC2762W.js.map
