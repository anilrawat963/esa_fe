import {
  m as m3
} from "./chunk-2XM57LB5.js";
import {
  C as C2,
  C2 as C3,
  I,
  P,
  U,
  X,
  Y,
  _,
  _2,
  f2 as f,
  l,
  m as m2,
  rt,
  s,
  v,
  w,
  wn
} from "./chunk-JGWZMI5Q.js";
import {
  e as e2
} from "./chunk-ALLCMCHO.js";
import {
  e
} from "./chunk-WKTI47FV.js";
import {
  A,
  h as h3
} from "./chunk-U55FA2EK.js";
import {
  r
} from "./chunk-UYMV6HXW.js";
import {
  C
} from "./chunk-JE2NJSBU.js";
import {
  E
} from "./chunk-QNVJVDYZ.js";
import {
  M,
  b,
  h as h2,
  i,
  o
} from "./chunk-LTPHDYPK.js";
import {
  __decorate,
  __param
} from "./chunk-SS5CLIUY.js";
import {
  $,
  h,
  m2 as m
} from "./chunk-GNMPGHLQ.js";

// node_modules/@arcgis/core/views/2d/engine/ImageryBitmapSource.js
var l2 = class {
  constructor(l3, e3, t) {
    this.pixelBlock = l3, this.extent = e3, this.originalPixelBlock = t;
  }
  get width() {
    return null != this.pixelBlock ? this.pixelBlock.width : 0;
  }
  get height() {
    return null != this.pixelBlock ? this.pixelBlock.height : 0;
  }
  render(l3) {
    const e3 = this.pixelBlock;
    if (null == e3) return;
    const t = this.filter({ extent: this.extent, pixelBlock: this.originalPixelBlock ?? e3 });
    if (null == t.pixelBlock) return;
    t.pixelBlock.maskIsAlpha && (t.pixelBlock.premultiplyAlpha = true);
    const i2 = t.pixelBlock.getAsRGBA(), h4 = l3.createImageData(t.pixelBlock.width, t.pixelBlock.height);
    h4.data.set(i2), l3.putImageData(h4, 0, 0);
  }
  getRenderedRasterPixels() {
    const l3 = this.filter({ extent: this.extent, pixelBlock: this.pixelBlock });
    return null == l3.pixelBlock ? null : (l3.pixelBlock.maskIsAlpha && (l3.pixelBlock.premultiplyAlpha = true), { width: l3.pixelBlock.width, height: l3.pixelBlock.height, renderedRasterPixels: new Uint8Array(l3.pixelBlock.getAsRGBA().buffer) });
  }
};

// node_modules/@arcgis/core/views/2d/engine/Bitmap.js
function m4(t) {
  t instanceof ImageBitmap && t.close();
}
function x(t) {
  return t && "render" in t;
}
function g(t) {
  const e3 = document.createElement("canvas");
  return e3.width = t.width, e3.height = t.height, t.render(e3.getContext("2d")), e3;
}
function f2(t) {
  return x(t) ? t instanceof l2 ? t.getRenderedRasterPixels()?.renderedRasterPixels : g(t) : t;
}
var w2 = class extends e2 {
  constructor(t = null, e3 = false) {
    super(), this.blendFunction = "standard", this._sourceWidth = 0, this._sourceHeight = 0, this._textureInvalidated = false, this.stencilRef = 0, this.coordScale = [1, 1], this._height = void 0, this.pixelRatio = 1, this.resolution = 0, this.rotation = 0, this._source = null, this._texture = null, this._width = void 0, this.x = 0, this.y = 0, this.immutable = e3, this.source = t, this.requestRender = this.requestRender.bind(this);
  }
  destroy() {
    super.destroy(), this._texture && (this._texture.dispose(), this._texture = null), this._source && m4(this._source), null != this._uploadStatus && (this._uploadStatus.controller.abort(), this._uploadStatus = null);
  }
  get isSourceScaled() {
    return this.width !== this._sourceWidth || this.height !== this._sourceHeight;
  }
  get height() {
    return void 0 !== this._height ? this._height : this._sourceHeight;
  }
  set height(t) {
    this._height = t;
  }
  get source() {
    return this._source;
  }
  set source(t) {
    null == t && null == this._source || (this._source && m4(this._source), this._source = t, this.invalidateTexture(), this.requestRender());
  }
  get texture() {
    return this._texture;
  }
  get width() {
    return void 0 !== this._width ? this._width : this._sourceWidth;
  }
  set width(t) {
    this._width = t;
  }
  beforeRender(t) {
    super.beforeRender(t), this.updateTexture(t);
  }
  async setSourceAsync(i2, s3) {
    null != this._uploadStatus && this._uploadStatus.controller.abort();
    const r2 = new AbortController(), h4 = $();
    return h(s3, () => r2.abort()), h(r2, (t) => h4.reject(t)), this._uploadStatus = { controller: r2, resolver: h4 }, this.source = i2, h4.promise;
  }
  invalidateTexture() {
    this._textureInvalidated || (this._textureInvalidated = true, this._source instanceof HTMLImageElement ? (this._sourceHeight = this._source.naturalHeight, this._sourceWidth = this._source.naturalWidth) : this._source && (this._sourceHeight = this._source.height, this._sourceWidth = this._source.width));
  }
  transitionStep(t, e3) {
    t >= 64 && (this.fadeTransitionEnabled = false), super.transitionStep(t, e3);
  }
  setTransform(t) {
    const e3 = o(this.transforms.displayViewScreenMat3), [i2, a] = t.toScreenNoRotation([0, 0], [this.x, this.y]), l3 = this.resolution / this.pixelRatio / t.resolution, c = l3 * this.width, d = l3 * this.height, _3 = Math.PI * this.rotation / 180;
    M(e3, e3, r(i2, a)), M(e3, e3, r(c / 2, d / 2)), h2(e3, e3, -_3), M(e3, e3, r(-c / 2, -d / 2)), b(e3, e3, r(c, d)), i(this.transforms.displayViewScreenMat3, t.displayViewMat3, e3);
  }
  setSamplingProfile(t) {
    this._texture && (t.mips && !this._texture.descriptor.hasMipmap && this._texture.generateMipmap(), this._texture.setSamplingMode(t.samplingMode));
  }
  bind(t, e3) {
    this._texture && t.bindTexture(this._texture, e3);
  }
  async updateTexture({ context: t, painter: e3 }) {
    if (!this._textureInvalidated) return;
    if (this._textureInvalidated = false, this._texture || (this._texture = this._createTexture(t)), !this.source) return void this._texture.setData(null);
    this._texture.resize(this._sourceWidth, this._sourceHeight);
    const s3 = f2(this.source);
    try {
      if (null != this._uploadStatus) {
        const { controller: t2, resolver: i2 } = this._uploadStatus, r2 = { signal: t2.signal }, { width: h4, height: o3 } = this, u = this._texture, a = e3.textureUploadManager;
        await a.enqueueTextureUpdate({ data: s3, texture: u, width: h4, height: o3 }, r2), i2.resolve(), this._uploadStatus = null;
      } else this._texture.setData(s3);
      this.ready();
    } catch (r2) {
      m(r2);
    }
  }
  onDetach() {
    this.destroy();
  }
  _createTransforms() {
    return { displayViewScreenMat3: e() };
  }
  _createTexture(t) {
    const e3 = this.immutable, i2 = new h3(this._sourceWidth, this._sourceHeight);
    return i2.internalFormat = e3 ? E.RGBA8 : 6408, i2.wrapMode = 33071, i2.isImmutable = e3, new A(t, i2);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/BitmapShader.js
var v2 = class extends C3 {
};
__decorate([f(0, X)], v2.prototype, "position", void 0);
var b2 = class extends I {
};
var S = class extends w {
};
__decorate([m2(U)], S.prototype, "texture", void 0), __decorate([m2(rt)], S.prototype, "dvsMat3", void 0), __decorate([m2(X)], S.prototype, "coordScale", void 0), __decorate([m2(C2)], S.prototype, "opacity", void 0);
var w3 = class extends P {
  constructor() {
    super(...arguments), this.type = "BitmapShader";
  }
  vertex(t) {
    const o3 = this.config.dvsMat3.multiply(new Y(t.position.multiply(this.config.coordScale), 1));
    return { glPosition: new _(o3, 1), texcoord: t.position };
  }
  fragment(t) {
    const o3 = new v();
    let i2;
    return i2 = this.bicubic ? m3(this.config.texture, t.texcoord, this.config.coordScale) : wn(this.config.texture, t.texcoord), o3.fragColor = new _(i2.rgb.multiply(this.config.opacity), i2.a.multiply(this.config.opacity)), o3;
  }
};
__decorate([m2(S)], w3.prototype, "config", void 0), __decorate([_2], w3.prototype, "bicubic", void 0), __decorate([__param(0, l(v2))], w3.prototype, "vertex", null), __decorate([__param(0, l(b2))], w3.prototype, "fragment", null);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/bitmap/BitmapTechnique.js
var s2 = { nearest: { samplingMode: 9728, mips: false }, bilinear: { samplingMode: 9729, mips: false }, bicubic: { samplingMode: 9729, mips: false }, trilinear: { samplingMode: 9987, mips: true } };
var n = (e3, i2, t) => {
  if ("dynamic" === t.samplingMode) {
    const { state: t2 } = e3, n2 = i2.resolution / i2.pixelRatio / t2.resolution, o3 = Math.round(e3.pixelRatio) !== e3.pixelRatio, a = n2 > 1.05 || n2 < 0.95;
    return t2.rotation || a || o3 || i2.isSourceScaled || i2.rotation ? s2.bilinear : s2.nearest;
  }
  return s2[t.samplingMode];
};
var o2 = class extends s {
  constructor() {
    super(...arguments), this.name = "BrushBitmap", this.type = 4, this.shaders = { bitmap: new w3() };
  }
  render(i2, t) {
    const { context: o3, renderingOptions: a, painter: r2 } = i2;
    for (const p of t.bitmaps) {
      const t2 = p.texture;
      if (!p.source || !p.isReady || null == t2) continue;
      const c = n(i2, p, a);
      i2.timeline.begin(this.name), r2.setPipelineState({ depth: false, stencil: { test: { mask: 255, compare: 514, op: { fail: 7680, zFail: 7680, zPass: 7680 } }, write: false }, color: { write: [true, true, true, true], blendMode: "additive" === p.blendFunction ? "additive" : "composite" } }), p.setSamplingProfile(c);
      const { coordScale: m5, computedOpacity: d, transforms: l3 } = p, u = { texture: { texture: t2, unit: C }, dvsMat3: l3.displayViewScreenMat3, coordScale: m5, opacity: d };
      r2.submitDrawMesh(o3, { shader: this.shaders.bitmap, uniforms: { config: u }, defines: { bicubic: c === s2.bicubic }, optionalAttributes: null, useComputeBuffer: false }, r2.quadMesh, p), i2.timeline.end(this.name);
    }
  }
};

export {
  l2 as l,
  x,
  g,
  w2 as w,
  o2 as o
};
//# sourceMappingURL=chunk-62W3XEE6.js.map
