import {
  Y
} from "./chunk-QNVJVDYZ.js";
import {
  n
} from "./chunk-234CIOHE.js";
import "./chunk-V2H77UEV.js";
import "./chunk-4DGC7CBY.js";
import "./chunk-GNMPGHLQ.js";
import "./chunk-QY7XKUIV.js";
import "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/libs/basisu/BasisUEncoder.js
function s() {
  return t ??= (async () => {
    const s3 = await import("./basis_encoder-ZTTOTKDB.js"), t2 = await s3.default({ locateFile: (s4) => n(`esri/libs/basisu/${s4}`) });
    return t2.initializeBasis(), t2;
  })(), t;
}
var t;
function a() {
  t = null;
}

// node_modules/@arcgis/core/libs/dxtEncoder/DXTEncoder.js
function e() {
  return n2 ??= (async () => {
    const e2 = await import("./dxt_encoder-26YUGEJO.js");
    return await e2.default({ locateFile: (e3) => n(`esri/libs/dxtEncoder/${e3}`) });
  })(), n2;
}
var n2;
function r() {
  n2 = null;
}

// node_modules/@arcgis/core/views/support/TextureCompressionWorker.js
var l;
var s2;
var i = null;
var o = null;
var u = class {
  constructor(e2, t2) {
    this.internalFormat = e2, this.compressedTexture = t2;
  }
};
function c() {
  i = null, l = null, o = null, s2 = null, a(), r();
}
async function h(e2) {
  let t2;
  t2 = e2.data instanceof ImageBitmap ? w(e2.data) : y(e2.data, e2.width, e2.height, e2.components, e2.needsFlip);
  try {
    if (e2.hasS3TC) {
      o || await d();
      const n3 = new Uint8Array(t2.length);
      if (o?.encode(t2, e2.width, e2.height, e2.preMultiplyAlpha, n3)) {
        const e3 = U(n3, true), t3 = [n3.buffer];
        return { result: new u(e3?.internalFormat ?? null, e3?.textureData ?? null), transferList: t3 };
      }
      return { result: new u(null, null) };
    }
    if (e2.hasETC) {
      if (i || await f(), e2.preMultiplyAlpha && !o && await d(), e2.preMultiplyAlpha) {
        const n4 = new Uint8ClampedArray(t2.length);
        o?.premultiply(new Uint8Array(t2), e2.width, e2.height, n4), t2 = n4;
      }
      const n3 = p(t2, e2.width, e2.height, e2.hasMipmap), r2 = n3 ? m(n3) : null, a2 = r2?.compressedTexture?.levels.map((e3) => e3.buffer) || [];
      return { result: new u(r2?.internalFormat ?? null, r2?.compressedTexture ?? null), transferList: a2 };
    }
    return { result: new u(null, null) };
  } finally {
    t2 instanceof ImageBitmap && t2.close();
  }
}
async function f() {
  i || (i = await (l ??= s()), l = null);
}
async function d() {
  o || (o = await (s2 ??= e()), s2 = null);
}
function p(e2, t2, n3, r2, a2 = 255, l2 = 0, s3 = false, o2 = false) {
  if (!i) return null;
  const u2 = new i.BasisEncoder();
  u2.setPerceptual(!o2), u2.setCheckForAlpha(true), u2.setForceAlpha(false), u2.setRenormalize(o2), u2.setMipGen(r2), u2.setMipSRGB(!o2), u2.setCreateKTX2File(true), u2.setKTX2SRGBTransferFunc(!o2), u2.setQualityLevel(a2), u2.setCompressionLevel(l2);
  const c2 = new Uint8Array(e2.byteLength);
  u2.setSliceSourceImage(0, new Uint8Array(e2), t2, n3, s3);
  const h2 = u2.encode(c2), f2 = new Uint8Array(c2.buffer, 0, h2), d2 = new i.KTX2File(new Uint8Array(f2));
  return d2.isValid() ? (u2.delete(), f2) : (d2.close(), d2.delete(), u2.delete(), null);
}
function m(e2) {
  if (!i) return new u(null, null);
  const t2 = new i.KTX2File(new Uint8Array(e2));
  t2.startTranscoding();
  const [n3, r2] = t2.getHasAlpha() ? [1, Y.COMPRESSED_RGBA8_ETC2_EAC] : [0, Y.COMPRESSED_RGB8_ETC2], l2 = t2.getLevels(), s3 = [];
  for (let a2 = 0; a2 < l2; a2++) s3.push(new Uint8Array(t2.getImageTranscodedSizeInBytes(a2, 0, 0, n3))), t2.transcodeImage(s3[a2], a2, 0, 0, n3, 0, -1, -1);
  return t2.close(), t2.delete(), { internalFormat: r2, compressedTexture: { type: "compressed", levels: s3 } };
}
function w(e2) {
  const t2 = new OffscreenCanvas(e2.width, e2.height), n3 = t2.getContext("2d");
  n3.drawImage(e2, 0, 0);
  return n3.getImageData(0, 0, t2.width, t2.height).data;
}
function y(e2, t2, n3, r2, a2) {
  const l2 = new Uint8ClampedArray(e2).subarray(0, t2 * n3 * r2);
  if (!a2) return l2;
  const s3 = new Uint8ClampedArray(l2.length), i2 = t2 * r2;
  for (let o2 = 0; o2 < n3; o2++) {
    const e3 = o2 * i2, t3 = (n3 - o2 - 1) * i2;
    s3.set(l2.subarray(e3, e3 + i2), t3);
  }
  return s3;
}
var T = 31;
var A = 1;
var g = 2;
var C = 3;
var E = 4;
var S = 7;
var b = 21;
var _ = 131072;
function D(e2) {
  return e2.charCodeAt(0) + (e2.charCodeAt(1) << 8) + (e2.charCodeAt(2) << 16) + (e2.charCodeAt(3) << 24);
}
var M = D("DXT1");
var X = D("DXT3");
var R = D("DXT5");
function U(e2, t2) {
  const n3 = new Int32Array(e2.buffer, e2.byteOffset, T);
  let r2, l2;
  switch (n3[b]) {
    case M:
      r2 = 8, l2 = Y.COMPRESSED_RGB_S3TC_DXT1_EXT;
      break;
    case X:
      r2 = 16, l2 = Y.COMPRESSED_RGBA_S3TC_DXT3_EXT;
      break;
    case R:
      r2 = 16, l2 = Y.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      break;
    default:
      return null;
  }
  let s3 = 1, i2 = n3[E], o2 = n3[C];
  (3 & i2 || 3 & o2) && (i2 = i2 + 3 & -4, o2 = o2 + 3 & -4);
  const u2 = i2, c2 = o2;
  let h2, f2;
  n3[g] & _ && false !== t2 && (s3 = Math.max(1, n3[S]));
  let d2 = e2.byteOffset + n3[A] + 4;
  const p2 = [];
  for (let a2 = 0; a2 < s3; ++a2) f2 = (i2 + 3 >> 2) * (o2 + 3 >> 2) * r2, h2 = new Uint8Array(e2.buffer, d2, f2), p2.push(h2), d2 += f2, i2 = Math.max(1, i2 >> 1), o2 = Math.max(1, o2 >> 1);
  return { textureData: { type: "compressed", levels: p2 }, internalFormat: l2, width: u2, height: c2 };
}
export {
  u as TextureCompressionWorkerOutput,
  h as compress,
  p as compressRGBADataToKTX2,
  m as createTextureDataKTX2,
  c as destroy,
  f as initializeBasisEncoder,
  d as initializeDXTEncoder
};
//# sourceMappingURL=TextureCompressionWorker-5TD5VUSW.js.map
