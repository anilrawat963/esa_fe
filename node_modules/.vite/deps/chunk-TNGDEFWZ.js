import {
  a as a4,
  f as f2,
  h,
  o as o4,
  p
} from "./chunk-NQDCX3PB.js";
import {
  c2 as c,
  g,
  l,
  u as u2
} from "./chunk-CJAJ4FML.js";
import {
  B,
  C,
  U,
  q
} from "./chunk-XTEXJOLG.js";
import {
  o as o3
} from "./chunk-233ALXRM.js";
import {
  z
} from "./chunk-H74Q4SYB.js";
import {
  _
} from "./chunk-AXZMNHTN.js";
import {
  f
} from "./chunk-5T3MJDSR.js";
import {
  n as n2
} from "./chunk-234CIOHE.js";
import {
  t
} from "./chunk-V2H77UEV.js";
import {
  o as o2
} from "./chunk-XWE6BM2U.js";
import {
  r
} from "./chunk-SOIZOFSB.js";
import {
  n as n3
} from "./chunk-XXLHAM2M.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  i as i2,
  o
} from "./chunk-65HD3WXL.js";
import {
  a as a3,
  n,
  u3 as u
} from "./chunk-GNMPGHLQ.js";
import {
  a,
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/chunks/Zlib.js
var e;
var r2 = { exports: {} };
function i3() {
  return e || (e = 1, i12 = r2, void 0 !== (t8 = (function() {
    function t9() {
      this.pos = 0, this.bufferLength = 0, this.eof = false, this.buffer = null;
    }
    return t9.prototype = { ensureBuffer: function(t10) {
      var e7 = this.buffer, r14 = e7 ? e7.byteLength : 0;
      if (t10 < r14) return e7;
      for (var i13 = 512; i13 < t10; ) i13 <<= 1;
      for (var s7 = new Uint8Array(i13), f6 = 0; f6 < r14; ++f6) s7[f6] = e7[f6];
      return this.buffer = s7;
    }, getByte: function() {
      for (var t10 = this.pos; this.bufferLength <= t10; ) {
        if (this.eof) return null;
        this.readBlock();
      }
      return this.buffer[this.pos++];
    }, getBytes: function(t10) {
      var e7 = this.pos;
      if (t10) {
        this.ensureBuffer(e7 + t10);
        for (var r14 = e7 + t10; !this.eof && this.bufferLength < r14; ) this.readBlock();
        var i13 = this.bufferLength;
        r14 > i13 && (r14 = i13);
      } else {
        for (; !this.eof; ) this.readBlock();
        r14 = this.bufferLength;
      }
      return this.pos = r14, this.buffer.subarray(e7, r14);
    }, lookChar: function() {
      for (var t10 = this.pos; this.bufferLength <= t10; ) {
        if (this.eof) return null;
        this.readBlock();
      }
      return String.fromCharCode(this.buffer[this.pos]);
    }, getChar: function() {
      for (var t10 = this.pos; this.bufferLength <= t10; ) {
        if (this.eof) return null;
        this.readBlock();
      }
      return String.fromCharCode(this.buffer[this.pos++]);
    }, makeSubStream: function(t10, e7, r14) {
      for (var i13 = t10 + e7; this.bufferLength <= i13 && !this.eof; ) this.readBlock();
      return new Stream(this.buffer, t10, e7, r14);
    }, skip: function(t10) {
      t10 || (t10 = 1), this.pos += t10;
    }, reset: function() {
      this.pos = 0;
    } }, t9;
  })(), s6 = (function() {
    if (!self || !self.Uint32Array) return null;
    var e7 = new Uint32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), r14 = new Uint32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]), i13 = new Uint32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]), s7 = [new Uint32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9], f6 = [new Uint32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
    function o13(t9) {
      throw new Error(t9);
    }
    function n15(e8) {
      var r15 = 0, i14 = e8[r15++], s8 = e8[r15++];
      -1 != i14 && -1 != s8 || o13("Invalid header in flate stream"), 8 != (15 & i14) && o13("Unknown compression method in flate stream"), ((i14 << 8) + s8) % 31 != 0 && o13("Bad FCHECK in flate stream"), 32 & s8 && o13("FDICT bit set in flate stream"), this.bytes = e8, this.bytesPos = r15, this.codeSize = 0, this.codeBuf = 0, t8.call(this);
    }
    return n15.prototype = Object.create(t8.prototype), n15.prototype.getBits = function(t9) {
      for (var e8, r15 = this.codeSize, i14 = this.codeBuf, s8 = this.bytes, f7 = this.bytesPos; r15 < t9; ) void 0 === (e8 = s8[f7++]) && o13("Bad encoding in flate stream"), i14 |= e8 << r15, r15 += 8;
      return e8 = i14 & (1 << t9) - 1, this.codeBuf = i14 >> t9, this.codeSize = r15 -= t9, this.bytesPos = f7, e8;
    }, n15.prototype.getCode = function(t9) {
      for (var e8 = t9[0], r15 = t9[1], i14 = this.codeSize, s8 = this.codeBuf, f7 = this.bytes, n16 = this.bytesPos; i14 < r15; ) {
        var a16;
        void 0 === (a16 = f7[n16++]) && o13("Bad encoding in flate stream"), s8 |= a16 << i14, i14 += 8;
      }
      var h6 = e8[s8 & (1 << r15) - 1], u11 = h6 >> 16, l6 = 65535 & h6;
      return (0 == i14 || i14 < u11 || 0 == u11) && o13("Bad encoding in flate stream"), this.codeBuf = s8 >> u11, this.codeSize = i14 - u11, this.bytesPos = n16, l6;
    }, n15.prototype.generateHuffmanTable = function(t9) {
      for (var e8 = t9.length, r15 = 0, i14 = 0; i14 < e8; ++i14) t9[i14] > r15 && (r15 = t9[i14]);
      for (var s8 = 1 << r15, f7 = new Uint32Array(s8), o14 = 1, n16 = 0, a16 = 2; o14 <= r15; ++o14, n16 <<= 1, a16 <<= 1) for (var h6 = 0; h6 < e8; ++h6) if (t9[h6] == o14) {
        var u11 = 0, l6 = n16;
        for (i14 = 0; i14 < o14; ++i14) u11 = u11 << 1 | 1 & l6, l6 >>= 1;
        for (i14 = u11; i14 < s8; i14 += a16) f7[i14] = o14 << 16 | h6;
        ++n16;
      }
      return [f7, r15];
    }, n15.prototype.readBlock = function() {
      function t9(t10, e8, r15, i14, s8) {
        for (var f7 = t10.getBits(r15) + i14; f7-- > 0; ) e8[b5++] = s8;
      }
      var n16 = this.getBits(3);
      if (1 & n16 && (this.eof = true), 0 != (n16 >>= 1)) {
        var a16, h6;
        if (1 == n16) a16 = s7, h6 = f6;
        else if (2 == n16) {
          for (var u11 = this.getBits(5) + 257, l6 = this.getBits(5) + 1, c6 = this.getBits(4) + 4, d5 = Array(e7.length), b5 = 0; b5 < c6; ) d5[e7[b5++]] = this.getBits(3);
          for (var v6 = this.generateHuffmanTable(d5), g4 = 0, B4 = (b5 = 0, u11 + l6), p5 = new Array(B4); b5 < B4; ) {
            var y5 = this.getCode(v6);
            16 == y5 ? t9(this, p5, 2, 3, g4) : 17 == y5 ? t9(this, p5, 3, 3, g4 = 0) : 18 == y5 ? t9(this, p5, 7, 11, g4 = 0) : p5[b5++] = g4 = y5;
          }
          a16 = this.generateHuffmanTable(p5.slice(0, u11)), h6 = this.generateHuffmanTable(p5.slice(u11, B4));
        } else o13("Unknown block type in flate stream");
        for (var m6 = (x4 = this.buffer) ? x4.length : 0, k5 = this.bufferLength; ; ) {
          var w5 = this.getCode(a16);
          if (w5 < 256) k5 + 1 >= m6 && (m6 = (x4 = this.ensureBuffer(k5 + 1)).length), x4[k5++] = w5;
          else {
            if (256 == w5) return void (this.bufferLength = k5);
            var C5 = (w5 = r14[w5 -= 257]) >> 16;
            C5 > 0 && (C5 = this.getBits(C5)), g4 = (65535 & w5) + C5, w5 = this.getCode(h6), (C5 = (w5 = i13[w5]) >> 16) > 0 && (C5 = this.getBits(C5));
            var L3 = (65535 & w5) + C5;
            k5 + g4 >= m6 && (m6 = (x4 = this.ensureBuffer(k5 + g4)).length);
            for (var S4 = 0; S4 < g4; ++S4, ++k5) x4[k5] = x4[k5 - L3];
          }
        }
      } else {
        var A4, U5 = this.bytes, P4 = this.bytesPos;
        void 0 === (A4 = U5[P4++]) && o13("Bad block header in flate stream");
        var z3 = A4;
        void 0 === (A4 = U5[P4++]) && o13("Bad block header in flate stream"), z3 |= A4 << 8, void 0 === (A4 = U5[P4++]) && o13("Bad block header in flate stream");
        var H2 = A4;
        void 0 === (A4 = U5[P4++]) && o13("Bad block header in flate stream"), (H2 |= A4 << 8) != (65535 & ~z3) && o13("Bad uncompressed block length in flate stream"), this.codeBuf = 0, this.codeSize = 0;
        var T4 = this.bufferLength, x4 = this.ensureBuffer(T4 + z3), j3 = T4 + z3;
        this.bufferLength = j3;
        for (var E3 = T4; E3 < j3; ++E3) {
          if (void 0 === (A4 = U5[P4++])) {
            this.eof = true;
            break;
          }
          x4[E3] = A4;
        }
        this.bytesPos = P4;
      }
    }, n15;
  })()) && (i12.exports = s6)), r2.exports;
  var t8, i12, s6;
}
var s2 = o3(i3());

// node_modules/@arcgis/core/layers/support/rasterFormats/ImageCanvasDecoder.js
var i4 = class _i {
  constructor(t8) {
    this._canvas = null, this._ctx = null, t8 && (this._canvas = t8.canvas, this._ctx = t8.ctx || t8.canvas && t8.canvas.getContext("2d"));
  }
  decode(n15, s6, r14) {
    if (!n15 || n15.byteLength < 10) throw new s("imagecanvasdecoder: decode", "required a valid encoded data as input.");
    let { width: c6 = 0, height: h6 = 0, format: o13 } = s6;
    const { applyJpegMask: l6 } = s6;
    if (l6 && (!c6 || !h6)) throw new s("imagecanvasdecoder: decode", "image width and height are needed to apply jpeg mask directly to canvas");
    return new Promise((t8, d5) => {
      let g4 = null;
      "jpg" === o13 && l6 && (g4 = _i._getMask(n15, { width: c6, height: h6 }));
      const w5 = new Blob([new Uint8Array(n15)], { type: "image/" + o13 == "jpg" ? "jpeg" : o13 }), v6 = URL.createObjectURL(w5), m6 = new Image();
      let _3;
      m6.src = v6, m6.onload = () => {
        if (URL.revokeObjectURL(v6), a3(r14)) return void d5(u());
        c6 = m6.width, h6 = m6.height, this._canvas && this._ctx ? (this._canvas.width === c6 && this._canvas.height === h6 || (this._canvas.width = c6, this._canvas.height = h6), this._ctx.clearRect(0, 0, c6, h6)) : (this._canvas = document.createElement("canvas"), this._canvas.width = c6, this._canvas.height = h6, this._ctx = this._canvas.getContext("2d")), this._ctx.drawImage(m6, 0, 0);
        const n16 = this._ctx.getImageData(0, 0, c6, h6);
        let i12;
        if (_3 = n16.data, s6.renderOnCanvas) {
          if (g4) for (i12 = 0; i12 < g4.length; i12++) g4[i12] ? _3[4 * i12 + 3] = 255 : _3[4 * i12 + 3] = 0;
          return this._ctx.putImageData(n16, 0, 0), void t8(null);
        }
        const o14 = c6 * h6, l7 = new Uint8Array(o14), w6 = new Uint8Array(o14), p5 = new Uint8Array(o14);
        if (g4) for (i12 = 0; i12 < o14; i12++) l7[i12] = _3[4 * i12], w6[i12] = _3[4 * i12 + 1], p5[i12] = _3[4 * i12 + 2];
        else for (g4 = new Uint8Array(o14), i12 = 0; i12 < o14; i12++) l7[i12] = _3[4 * i12], w6[i12] = _3[4 * i12 + 1], p5[i12] = _3[4 * i12 + 2], g4[i12] = _3[4 * i12 + 3];
        t8({ width: c6, height: h6, pixels: [l7, w6, p5], mask: g4, pixelType: "u8" });
      }, m6.onerror = () => {
        URL.revokeObjectURL(v6), d5("cannot load image");
      };
    });
  }
  static _getMask(t8, e7) {
    let a16 = null;
    try {
      const i12 = new Uint8Array(t8), s6 = Math.ceil(i12.length / 2);
      let r14 = 0;
      const c6 = i12.length - 2;
      for (r14 = s6; r14 < c6 && (255 !== i12[r14] || 217 !== i12[r14 + 1]); r14++) ;
      if (r14 += 2, r14 < i12.length - 1) {
        const t9 = new s2(i12.subarray(r14)).getBytes();
        a16 = new Uint8Array(e7.width * e7.height);
        let s7 = 0;
        for (let e8 = 0; e8 < t9.length; e8++) for (let n15 = 7; n15 >= 0; n15--) a16[s7++] = t9[e8] >> n15 & 1;
      }
    } catch (i12) {
    }
    return a16;
  }
};

// node_modules/@arcgis/core/chunks/Jpg.js
var n4;
var r3 = { exports: {} };
function o5() {
  return n4 || (n4 = 1, e7 = r3, o13 = function() {
    var e8 = (function() {
      function e9(e10) {
        this.message = "JPEG error: " + e10;
      }
      return e9.prototype = new Error(), e9.prototype.name = "JpegError", e9.constructor = e9, e9;
    })();
    return (function() {
      if (!self || !self.Uint8ClampedArray) return null;
      var n15 = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), r14 = 4017, o14 = 799, a17 = 3406, t8 = 2276, i12 = 1567, s6 = 3784, c6 = 5793, f6 = 2896;
      function l6() {
        this.decodeTransform = null, this.colorTransform = -1;
      }
      function u11(e9, n16) {
        for (var r15, o15, a18 = 0, t9 = [], i13 = 16; i13 > 0 && !e9[i13 - 1]; ) i13--;
        t9.push({ children: [], index: 0 });
        var s7, c7 = t9[0];
        for (r15 = 0; r15 < i13; r15++) {
          for (o15 = 0; o15 < e9[r15]; o15++) {
            for ((c7 = t9.pop()).children[c7.index] = n16[a18]; c7.index > 0; ) c7 = t9.pop();
            for (c7.index++, t9.push(c7); t9.length <= r15; ) t9.push(s7 = { children: [], index: 0 }), c7.children[c7.index] = s7.children, c7 = s7;
            a18++;
          }
          r15 + 1 < i13 && (t9.push(s7 = { children: [], index: 0 }), c7.children[c7.index] = s7.children, c7 = s7);
        }
        return t9[0].children;
      }
      function h6(e9, n16, r15) {
        return 64 * ((e9.blocksPerLine + 1) * n16 + r15);
      }
      function v6(r15, o15, a18, t9, i13, s7, c7, f7, l7) {
        var u12 = a18.mcusPerLine, v7 = a18.progressive, m7 = o15, d6 = 0, b5 = 0;
        function k5() {
          if (b5 > 0) return b5--, d6 >> b5 & 1;
          if (255 === (d6 = r15[o15++])) {
            var n16 = r15[o15++];
            if (n16) throw new e8("unexpected marker " + (d6 << 8 | n16).toString(16));
          }
          return b5 = 7, d6 >>> 7;
        }
        function g4(n16) {
          for (var r16 = n16; ; ) {
            if ("number" == typeof (r16 = r16[k5()])) return r16;
            if ("object" != typeof r16) throw new e8("invalid huffman sequence");
          }
        }
        function C5(e9) {
          for (var n16 = 0; e9 > 0; ) n16 = n16 << 1 | k5(), e9--;
          return n16;
        }
        function w5(e9) {
          if (1 === e9) return 1 === k5() ? 1 : -1;
          var n16 = C5(e9);
          return n16 >= 1 << e9 - 1 ? n16 : n16 + (-1 << e9) + 1;
        }
        function x4(e9, r16) {
          var o16 = g4(e9.huffmanTableDC), a19 = 0 === o16 ? 0 : w5(o16);
          e9.blockData[r16] = e9.pred += a19;
          for (var t10 = 1; t10 < 64; ) {
            var i14 = g4(e9.huffmanTableAC), s8 = 15 & i14, c8 = i14 >> 4;
            if (0 !== s8) {
              var f8 = n15[t10 += c8];
              e9.blockData[r16 + f8] = w5(s8), t10++;
            } else {
              if (c8 < 15) break;
              t10 += 16;
            }
          }
        }
        function y5(e9, n16) {
          var r16 = g4(e9.huffmanTableDC), o16 = 0 === r16 ? 0 : w5(r16) << l7;
          e9.blockData[n16] = e9.pred += o16;
        }
        function D4(e9, n16) {
          e9.blockData[n16] |= k5() << l7;
        }
        var T4 = 0;
        function P4(e9, r16) {
          if (T4 > 0) T4--;
          else for (var o16 = s7, a19 = c7; o16 <= a19; ) {
            var t10 = g4(e9.huffmanTableAC), i14 = 15 & t10, f8 = t10 >> 4;
            if (0 !== i14) {
              var u13 = n15[o16 += f8];
              e9.blockData[r16 + u13] = w5(i14) * (1 << l7), o16++;
            } else {
              if (f8 < 15) {
                T4 = C5(f8) + (1 << f8) - 1;
                break;
              }
              o16 += 16;
            }
          }
        }
        var L3, A4 = 0;
        function _3(r16, o16) {
          for (var a19, t10, i14 = s7, f8 = c7, u13 = 0; i14 <= f8; ) {
            var h7 = n15[i14];
            switch (A4) {
              case 0:
                if (u13 = (t10 = g4(r16.huffmanTableAC)) >> 4, 0 == (a19 = 15 & t10)) u13 < 15 ? (T4 = C5(u13) + (1 << u13), A4 = 4) : (u13 = 16, A4 = 1);
                else {
                  if (1 !== a19) throw new e8("invalid ACn encoding");
                  L3 = w5(a19), A4 = u13 ? 2 : 3;
                }
                continue;
              case 1:
              case 2:
                r16.blockData[o16 + h7] ? r16.blockData[o16 + h7] += k5() << l7 : 0 === --u13 && (A4 = 2 === A4 ? 3 : 0);
                break;
              case 3:
                r16.blockData[o16 + h7] ? r16.blockData[o16 + h7] += k5() << l7 : (r16.blockData[o16 + h7] = L3 << l7, A4 = 0);
                break;
              case 4:
                r16.blockData[o16 + h7] && (r16.blockData[o16 + h7] += k5() << l7);
            }
            i14++;
          }
          4 === A4 && 0 === --T4 && (A4 = 0);
        }
        function U5(e9, n16, r16, o16, a19) {
          var t10 = r16 % u12;
          n16(e9, h6(e9, (r16 / u12 | 0) * e9.v + o16, t10 * e9.h + a19));
        }
        function z3(e9, n16, r16) {
          n16(e9, h6(e9, r16 / e9.blocksPerLine | 0, r16 % e9.blocksPerLine));
        }
        var I4, M4, Y2, q2, S4, H2, R4 = t9.length;
        H2 = v7 ? 0 === s7 ? 0 === f7 ? y5 : D4 : 0 === f7 ? P4 : _3 : x4;
        var j3, E3, J, V3, B4 = 0;
        for (E3 = 1 === R4 ? t9[0].blocksPerLine * t9[0].blocksPerColumn : u12 * a18.mcusPerColumn; B4 < E3; ) {
          var N2 = i13 ? Math.min(E3 - B4, i13) : E3;
          for (M4 = 0; M4 < R4; M4++) t9[M4].pred = 0;
          if (T4 = 0, 1 === R4) for (I4 = t9[0], S4 = 0; S4 < N2; S4++) z3(I4, H2, B4), B4++;
          else for (S4 = 0; S4 < N2; S4++) {
            for (M4 = 0; M4 < R4; M4++) for (J = (I4 = t9[M4]).h, V3 = I4.v, Y2 = 0; Y2 < V3; Y2++) for (q2 = 0; q2 < J; q2++) U5(I4, H2, B4, Y2, q2);
            B4++;
          }
          b5 = 0, (j3 = p5(r15, o15)) && j3.invalid && (console.log("decodeScan - unexpected MCU data, next marker is: " + j3.invalid), o15 = j3.offset);
          var G3 = j3 && j3.marker;
          if (!G3 || G3 <= 65280) throw new e8("marker was not found");
          if (!(G3 >= 65488 && G3 <= 65495)) break;
          o15 += 2;
        }
        return (j3 = p5(r15, o15)) && j3.invalid && (console.log("decodeScan - unexpected Scan data, next marker is: " + j3.invalid), o15 = j3.offset), o15 - m7;
      }
      function m6(n16, l7, u12) {
        var h7, v7, m7, d6, p6, b5, k5, g4, C5, w5, x4, y5, D4, T4, P4, L3, A4, _3 = n16.quantizationTable, U5 = n16.blockData;
        if (!_3) throw new e8("missing required Quantization Table.");
        for (var z3 = 0; z3 < 64; z3 += 8) C5 = U5[l7 + z3], w5 = U5[l7 + z3 + 1], x4 = U5[l7 + z3 + 2], y5 = U5[l7 + z3 + 3], D4 = U5[l7 + z3 + 4], T4 = U5[l7 + z3 + 5], P4 = U5[l7 + z3 + 6], L3 = U5[l7 + z3 + 7], C5 *= _3[z3], 0 !== (w5 | x4 | y5 | D4 | T4 | P4 | L3) ? (w5 *= _3[z3 + 1], x4 *= _3[z3 + 2], y5 *= _3[z3 + 3], D4 *= _3[z3 + 4], T4 *= _3[z3 + 5], P4 *= _3[z3 + 6], L3 *= _3[z3 + 7], v7 = (h7 = (h7 = c6 * C5 + 128 >> 8) + (v7 = c6 * D4 + 128 >> 8) + 1 >> 1) - v7, A4 = (m7 = x4) * s6 + (d6 = P4) * i12 + 128 >> 8, m7 = m7 * i12 - d6 * s6 + 128 >> 8, k5 = (p6 = (p6 = f6 * (w5 - L3) + 128 >> 8) + (k5 = T4 << 4) + 1 >> 1) - k5, b5 = (g4 = (g4 = f6 * (w5 + L3) + 128 >> 8) + (b5 = y5 << 4) + 1 >> 1) - b5, d6 = (h7 = h7 + (d6 = A4) + 1 >> 1) - d6, m7 = (v7 = v7 + m7 + 1 >> 1) - m7, A4 = p6 * t8 + g4 * a17 + 2048 >> 12, p6 = p6 * a17 - g4 * t8 + 2048 >> 12, g4 = A4, A4 = b5 * o14 + k5 * r14 + 2048 >> 12, b5 = b5 * r14 - k5 * o14 + 2048 >> 12, k5 = A4, u12[z3] = h7 + g4, u12[z3 + 7] = h7 - g4, u12[z3 + 1] = v7 + k5, u12[z3 + 6] = v7 - k5, u12[z3 + 2] = m7 + b5, u12[z3 + 5] = m7 - b5, u12[z3 + 3] = d6 + p6, u12[z3 + 4] = d6 - p6) : (A4 = c6 * C5 + 512 >> 10, u12[z3] = A4, u12[z3 + 1] = A4, u12[z3 + 2] = A4, u12[z3 + 3] = A4, u12[z3 + 4] = A4, u12[z3 + 5] = A4, u12[z3 + 6] = A4, u12[z3 + 7] = A4);
        for (var I4 = 0; I4 < 8; ++I4) C5 = u12[I4], 0 !== ((w5 = u12[I4 + 8]) | (x4 = u12[I4 + 16]) | (y5 = u12[I4 + 24]) | (D4 = u12[I4 + 32]) | (T4 = u12[I4 + 40]) | (P4 = u12[I4 + 48]) | (L3 = u12[I4 + 56])) ? (v7 = (h7 = 4112 + ((h7 = c6 * C5 + 2048 >> 12) + (v7 = c6 * D4 + 2048 >> 12) + 1 >> 1)) - v7, A4 = (m7 = x4) * s6 + (d6 = P4) * i12 + 2048 >> 12, m7 = m7 * i12 - d6 * s6 + 2048 >> 12, d6 = A4, k5 = (p6 = (p6 = f6 * (w5 - L3) + 2048 >> 12) + (k5 = T4) + 1 >> 1) - k5, b5 = (g4 = (g4 = f6 * (w5 + L3) + 2048 >> 12) + (b5 = y5) + 1 >> 1) - b5, A4 = p6 * t8 + g4 * a17 + 2048 >> 12, p6 = p6 * a17 - g4 * t8 + 2048 >> 12, g4 = A4, A4 = b5 * o14 + k5 * r14 + 2048 >> 12, b5 = b5 * r14 - k5 * o14 + 2048 >> 12, C5 = (C5 = (h7 = h7 + d6 + 1 >> 1) + g4) < 16 ? 0 : C5 >= 4080 ? 255 : C5 >> 4, w5 = (w5 = (v7 = v7 + m7 + 1 >> 1) + (k5 = A4)) < 16 ? 0 : w5 >= 4080 ? 255 : w5 >> 4, x4 = (x4 = (m7 = v7 - m7) + b5) < 16 ? 0 : x4 >= 4080 ? 255 : x4 >> 4, y5 = (y5 = (d6 = h7 - d6) + p6) < 16 ? 0 : y5 >= 4080 ? 255 : y5 >> 4, D4 = (D4 = d6 - p6) < 16 ? 0 : D4 >= 4080 ? 255 : D4 >> 4, T4 = (T4 = m7 - b5) < 16 ? 0 : T4 >= 4080 ? 255 : T4 >> 4, P4 = (P4 = v7 - k5) < 16 ? 0 : P4 >= 4080 ? 255 : P4 >> 4, L3 = (L3 = h7 - g4) < 16 ? 0 : L3 >= 4080 ? 255 : L3 >> 4, U5[l7 + I4] = C5, U5[l7 + I4 + 8] = w5, U5[l7 + I4 + 16] = x4, U5[l7 + I4 + 24] = y5, U5[l7 + I4 + 32] = D4, U5[l7 + I4 + 40] = T4, U5[l7 + I4 + 48] = P4, U5[l7 + I4 + 56] = L3) : (A4 = (A4 = c6 * C5 + 8192 >> 14) < -2040 ? 0 : A4 >= 2024 ? 255 : A4 + 2056 >> 4, U5[l7 + I4] = A4, U5[l7 + I4 + 8] = A4, U5[l7 + I4 + 16] = A4, U5[l7 + I4 + 24] = A4, U5[l7 + I4 + 32] = A4, U5[l7 + I4 + 40] = A4, U5[l7 + I4 + 48] = A4, U5[l7 + I4 + 56] = A4);
      }
      function d5(e9, n16) {
        for (var r15 = n16.blocksPerLine, o15 = n16.blocksPerColumn, a18 = new Int16Array(64), t9 = 0; t9 < o15; t9++) for (var i13 = 0; i13 < r15; i13++) m6(n16, h6(n16, t9, i13), a18);
        return n16.blockData;
      }
      function p5(e9, n16, r15) {
        function o15(n17) {
          return e9[n17] << 8 | e9[n17 + 1];
        }
        var a18 = e9.length - 1, t9 = r15 < n16 ? r15 : n16;
        if (n16 >= a18) return null;
        var i13 = o15(n16);
        if (i13 >= 65472 && i13 <= 65534) return { invalid: null, marker: i13, offset: n16 };
        for (var s7 = o15(t9); !(s7 >= 65472 && s7 <= 65534); ) {
          if (++t9 >= a18) return null;
          s7 = o15(t9);
        }
        return { invalid: i13.toString(16), marker: s7, offset: t9 };
      }
      return l6.prototype = { parse: function(r15) {
        function o15() {
          var e9 = r15[c7] << 8 | r15[c7 + 1];
          return c7 += 2, e9;
        }
        function a18() {
          var e9 = o15(), n16 = c7 + e9 - 2, a19 = p5(r15, n16, c7);
          a19 && a19.invalid && (console.log("readDataBlock - incorrect length, next marker is: " + a19.invalid), n16 = a19.offset);
          var t10 = r15.subarray(c7, n16);
          return c7 += t10.length, t10;
        }
        function t9(e9) {
          for (var n16 = Math.ceil(e9.samplesPerLine / 8 / e9.maxH), r16 = Math.ceil(e9.scanLines / 8 / e9.maxV), o16 = 0; o16 < e9.components.length; o16++) {
            R4 = e9.components[o16];
            var a19 = Math.ceil(Math.ceil(e9.samplesPerLine / 8) * R4.h / e9.maxH), t10 = Math.ceil(Math.ceil(e9.scanLines / 8) * R4.v / e9.maxV), i14 = n16 * R4.h, s8 = r16 * R4.v * 64 * (i14 + 1);
            R4.blockData = new Int16Array(s8), R4.blocksPerLine = a19, R4.blocksPerColumn = t10;
          }
          e9.mcusPerLine = n16, e9.mcusPerColumn = r16;
        }
        var i13, s7, c7 = 0, f7 = null, l7 = null, h7 = [], m7 = [], b5 = [], k5 = o15();
        if (65496 !== k5) throw new e8("SOI not found");
        for (k5 = o15(); 65497 !== k5; ) {
          var g4, C5, w5;
          switch (k5) {
            case 65504:
            case 65505:
            case 65506:
            case 65507:
            case 65508:
            case 65509:
            case 65510:
            case 65511:
            case 65512:
            case 65513:
            case 65514:
            case 65515:
            case 65516:
            case 65517:
            case 65518:
            case 65519:
            case 65534:
              var x4 = a18();
              65504 === k5 && 74 === x4[0] && 70 === x4[1] && 73 === x4[2] && 70 === x4[3] && 0 === x4[4] && (f7 = { version: { major: x4[5], minor: x4[6] }, densityUnits: x4[7], xDensity: x4[8] << 8 | x4[9], yDensity: x4[10] << 8 | x4[11], thumbWidth: x4[12], thumbHeight: x4[13], thumbData: x4.subarray(14, 14 + 3 * x4[12] * x4[13]) }), 65518 === k5 && 65 === x4[0] && 100 === x4[1] && 111 === x4[2] && 98 === x4[3] && 101 === x4[4] && (l7 = { version: x4[5] << 8 | x4[6], flags0: x4[7] << 8 | x4[8], flags1: x4[9] << 8 | x4[10], transformCode: x4[11] });
              break;
            case 65499:
              for (var y5 = o15() + c7 - 2; c7 < y5; ) {
                var D4 = r15[c7++], T4 = new Uint16Array(64);
                if (D4 >> 4) {
                  if (D4 >> 4 != 1) throw new e8("DQT - invalid table spec");
                  for (C5 = 0; C5 < 64; C5++) T4[n15[C5]] = o15();
                } else for (C5 = 0; C5 < 64; C5++) T4[n15[C5]] = r15[c7++];
                h7[15 & D4] = T4;
              }
              break;
            case 65472:
            case 65473:
            case 65474:
              if (i13) throw new e8("Only single frame JPEGs supported");
              o15(), (i13 = {}).extended = 65473 === k5, i13.progressive = 65474 === k5, i13.precision = r15[c7++], i13.scanLines = o15(), i13.samplesPerLine = o15(), i13.components = [], i13.componentIds = {};
              var P4, L3 = r15[c7++], A4 = 0, _3 = 0;
              for (g4 = 0; g4 < L3; g4++) {
                P4 = r15[c7];
                var U5 = r15[c7 + 1] >> 4, z3 = 15 & r15[c7 + 1];
                A4 < U5 && (A4 = U5), _3 < z3 && (_3 = z3);
                var I4 = r15[c7 + 2];
                w5 = i13.components.push({ h: U5, v: z3, quantizationId: I4, quantizationTable: null }), i13.componentIds[P4] = w5 - 1, c7 += 3;
              }
              i13.maxH = A4, i13.maxV = _3, t9(i13);
              break;
            case 65476:
              var M4 = o15();
              for (g4 = 2; g4 < M4; ) {
                var Y2 = r15[c7++], q2 = new Uint8Array(16), S4 = 0;
                for (C5 = 0; C5 < 16; C5++, c7++) S4 += q2[C5] = r15[c7];
                var H2 = new Uint8Array(S4);
                for (C5 = 0; C5 < S4; C5++, c7++) H2[C5] = r15[c7];
                g4 += 17 + S4, (Y2 >> 4 ? m7 : b5)[15 & Y2] = u11(q2, H2);
              }
              break;
            case 65501:
              o15(), s7 = o15();
              break;
            case 65498:
              o15();
              var R4, j3 = r15[c7++], E3 = [];
              for (g4 = 0; g4 < j3; g4++) {
                var J = i13.componentIds[r15[c7++]];
                R4 = i13.components[J];
                var V3 = r15[c7++];
                R4.huffmanTableDC = b5[V3 >> 4], R4.huffmanTableAC = m7[15 & V3], E3.push(R4);
              }
              var B4 = r15[c7++], N2 = r15[c7++], G3 = r15[c7++], O5 = v6(r15, c7, i13, E3, s7, B4, N2, G3 >> 4, 15 & G3);
              c7 += O5;
              break;
            case 65535:
              255 !== r15[c7] && c7--;
              break;
            default:
              if (255 === r15[c7 - 3] && r15[c7 - 2] >= 192 && r15[c7 - 2] <= 254) {
                c7 -= 3;
                break;
              }
              throw new e8("unknown marker " + k5.toString(16));
          }
          k5 = o15();
        }
        for (this.width = i13.samplesPerLine, this.height = i13.scanLines, this.jfif = f7, this.eof = c7, this.adobe = l7, this.components = [], g4 = 0; g4 < i13.components.length; g4++) {
          var Q = h7[(R4 = i13.components[g4]).quantizationId];
          Q && (R4.quantizationTable = Q), this.components.push({ output: d5(i13, R4), scaleX: R4.h / i13.maxH, scaleY: R4.v / i13.maxV, blocksPerLine: R4.blocksPerLine, blocksPerColumn: R4.blocksPerColumn });
        }
        this.numComponents = this.components.length;
      }, _getLinearizedBlockData: function(e9, n16) {
        var r15, o15, a18, t9, i13, s7, c7, f7, l7, u12, h7, v7 = this.width / e9, m7 = this.height / n16, d6 = 0, p6 = this.components.length, b5 = e9 * n16 * p6, k5 = new Uint8ClampedArray(b5), g4 = new Uint32Array(e9), C5 = 4294967288;
        for (c7 = 0; c7 < p6; c7++) {
          for (o15 = (r15 = this.components[c7]).scaleX * v7, a18 = r15.scaleY * m7, d6 = c7, h7 = r15.output, t9 = r15.blocksPerLine + 1 << 3, i13 = 0; i13 < e9; i13++) f7 = 0 | i13 * o15, g4[i13] = (f7 & C5) << 3 | 7 & f7;
          for (s7 = 0; s7 < n16; s7++) for (u12 = t9 * ((f7 = 0 | s7 * a18) & C5) | (7 & f7) << 3, i13 = 0; i13 < e9; i13++) k5[d6] = h7[u12 + g4[i13]], d6 += p6;
        }
        var w5 = this.decodeTransform;
        if (w5) for (c7 = 0; c7 < b5; ) for (f7 = 0, l7 = 0; f7 < p6; f7++, c7++, l7 += 2) k5[c7] = (k5[c7] * w5[l7] >> 8) + w5[l7 + 1];
        return k5;
      }, _isColorConversionNeeded: function() {
        return this.adobe ? !!this.adobe.transformCode : 3 === this.numComponents ? 0 !== this.colorTransform : 1 === this.colorTransform;
      }, _convertYccToRgb: function(e9) {
        for (var n16, r15, o15, a18 = 0, t9 = e9.length; a18 < t9; a18 += 3) n16 = e9[a18], r15 = e9[a18 + 1], o15 = e9[a18 + 2], e9[a18] = n16 - 179.456 + 1.402 * o15, e9[a18 + 1] = n16 + 135.459 - 0.344 * r15 - 0.714 * o15, e9[a18 + 2] = n16 - 226.816 + 1.772 * r15;
        return e9;
      }, _convertYcckToRgb: function(e9) {
        for (var n16, r15, o15, a18, t9 = 0, i13 = 0, s7 = e9.length; i13 < s7; i13 += 4) n16 = e9[i13], r15 = e9[i13 + 1], o15 = e9[i13 + 2], a18 = e9[i13 + 3], e9[t9++] = r15 * (-660635669420364e-19 * r15 + 437130475926232e-18 * o15 - 54080610064599e-18 * n16 + 48449797120281e-17 * a18 - 0.154362151871126) - 122.67195406894 + o15 * (-957964378445773e-18 * o15 + 817076911346625e-18 * n16 - 0.00477271405408747 * a18 + 1.53380253221734) + n16 * (961250184130688e-18 * n16 - 0.00266257332283933 * a18 + 0.48357088451265) + a18 * (-336197177618394e-18 * a18 + 0.484791561490776), e9[t9++] = 107.268039397724 + r15 * (219927104525741e-19 * r15 - 640992018297945e-18 * o15 + 659397001245577e-18 * n16 + 426105652938837e-18 * a18 - 0.176491792462875) + o15 * (-778269941513683e-18 * o15 + 0.00130872261408275 * n16 + 770482631801132e-18 * a18 - 0.151051492775562) + n16 * (0.00126935368114843 * n16 - 0.00265090189010898 * a18 + 0.25802910206845) + a18 * (-318913117588328e-18 * a18 - 0.213742400323665), e9[t9++] = r15 * (-570115196973677e-18 * r15 - 263409051004589e-19 * o15 + 0.0020741088115012 * n16 - 0.00288260236853442 * a18 + 0.814272968359295) - 20.810012546947 + o15 * (-153496057440975e-19 * o15 - 132689043961446e-18 * n16 + 560833691242812e-18 * a18 - 0.195152027534049) + n16 * (0.00174418132927582 * n16 - 0.00255243321439347 * a18 + 0.116935020465145) + a18 * (-343531996510555e-18 * a18 + 0.24165260232407);
        return e9;
      }, _convertYcckToCmyk: function(e9) {
        for (var n16, r15, o15, a18 = 0, t9 = e9.length; a18 < t9; a18 += 4) n16 = e9[a18], r15 = e9[a18 + 1], o15 = e9[a18 + 2], e9[a18] = 434.456 - n16 - 1.402 * o15, e9[a18 + 1] = 119.541 - n16 + 0.344 * r15 + 0.714 * o15, e9[a18 + 2] = 481.816 - n16 - 1.772 * r15;
        return e9;
      }, _convertCmykToRgb: function(e9) {
        for (var n16, r15, o15, a18, t9 = 0, i13 = 1 / 255, s7 = 0, c7 = e9.length; s7 < c7; s7 += 4) n16 = e9[s7] * i13, r15 = e9[s7 + 1] * i13, o15 = e9[s7 + 2] * i13, a18 = e9[s7 + 3] * i13, e9[t9++] = 255 + n16 * (-4.387332384609988 * n16 + 54.48615194189176 * r15 + 18.82290502165302 * o15 + 212.25662451639585 * a18 - 285.2331026137004) + r15 * (1.7149763477362134 * r15 - 5.6096736904047315 * o15 - 17.873870861415444 * a18 - 5.497006427196366) + o15 * (-2.5217340131683033 * o15 - 21.248923337353073 * a18 + 17.5119270841813) - a18 * (21.86122147463605 * a18 + 189.48180835922747), e9[t9++] = 255 + n16 * (8.841041422036149 * n16 + 60.118027045597366 * r15 + 6.871425592049007 * o15 + 31.159100130055922 * a18 - 79.2970844816548) + r15 * (-15.310361306967817 * r15 + 17.575251261109482 * o15 + 131.35250912493976 * a18 - 190.9453302588951) + o15 * (4.444339102852739 * o15 + 9.8632861493405 * a18 - 24.86741582555878) - a18 * (20.737325471181034 * a18 + 187.80453709719578), e9[t9++] = 255 + n16 * (0.8842522430003296 * n16 + 8.078677503112928 * r15 + 30.89978309703729 * o15 - 0.23883238689178934 * a18 - 14.183576799673286) + r15 * (10.49593273432072 * r15 + 63.02378494754052 * o15 + 50.606957656360734 * a18 - 112.23884253719248) + o15 * (0.03296041114873217 * o15 + 115.60384449646641 * a18 - 193.58209356861505) - a18 * (22.33816807309886 * a18 + 180.12613974708367);
        return e9;
      }, getData: function(n16, r15, o15) {
        if (this.numComponents > 4) throw new e8("Unsupported color mode");
        var a18 = this._getLinearizedBlockData(n16, r15);
        if (1 === this.numComponents && o15) {
          for (var t9 = a18.length, i13 = new Uint8ClampedArray(3 * t9), s7 = 0, c7 = 0; c7 < t9; c7++) {
            var f7 = a18[c7];
            i13[s7++] = f7, i13[s7++] = f7, i13[s7++] = f7;
          }
          return i13;
        }
        if (3 === this.numComponents && this._isColorConversionNeeded()) return this._convertYccToRgb(a18);
        if (4 === this.numComponents) {
          if (this._isColorConversionNeeded()) return o15 ? this._convertYcckToRgb(a18) : this._convertYcckToCmyk(a18);
          if (o15) return this._convertCmykToRgb(a18);
        }
        return a18;
      } }, l6;
    })();
  }, void 0 !== (a16 = o13()) && (e7.exports = a16)), r3.exports;
  var e7, o13, a16;
}
var a5 = o3(o5());

// node_modules/@arcgis/core/layers/support/rasterFormats/JpgPlus.js
var r4 = class {
  static decode(r14, n15 = false) {
    const s6 = new Uint8Array(r14), o13 = new a5();
    o13.parse(s6);
    const { width: a16, height: i12, numComponents: f6, eof: h6 } = o13, l6 = o13.getData(a16, i12, true), c6 = a16 * i12;
    let u11, g4 = null, p5 = 0, w5 = 0, m6 = 0;
    if (!n15 && h6 < s6.length - 1) try {
      const t8 = new s2(s6.subarray(h6)).getBytes();
      g4 = new Uint8Array(c6);
      let r15 = 0;
      for (p5 = 0; p5 < t8.length; p5++) for (m6 = 7; m6 >= 0; m6--) g4[r15++] = t8[p5] >> m6 & 1;
    } catch {
    }
    if (1 === f6 && l6.length === a16 * i12) {
      const t8 = new Uint8Array(l6.buffer);
      u11 = [t8, t8, t8];
    } else {
      for (u11 = [], p5 = 0; p5 < 3; p5++) u11.push(new Uint8Array(c6));
      for (m6 = 0, w5 = 0; w5 < c6; w5++) for (p5 = 0; p5 < 3; p5++) u11[p5][w5] = l6[m6++];
    }
    return { width: a16, height: i12, pixels: u11, mask: g4 };
  }
};

// node_modules/@arcgis/core/layers/support/rasterFormats/Lerc.js
var t2 = [{ pixelType: "S8", size: 1, ctor: Int8Array, range: [-128, 127] }, { pixelType: "U8", size: 1, ctor: Uint8Array, range: [0, 255] }, { pixelType: "S16", size: 2, ctor: Int16Array, range: [-32768, 32767] }, { pixelType: "U16", size: 2, ctor: Uint16Array, range: [0, 65536] }, { pixelType: "S32", size: 4, ctor: Int32Array, range: [-2147483648, 2147483647] }, { pixelType: "U32", size: 4, ctor: Uint32Array, range: [0, 4294967296] }, { pixelType: "F32", size: 4, ctor: Float32Array, range: [-34027999387901484e22, 34027999387901484e22] }, { pixelType: "F64", size: 8, ctor: Float64Array, range: [-17976931348623157e292, 17976931348623157e292] }];
var n5 = null;
function r5() {
  return n5 || (n5 = import("./lerc-wasm-T5VXWVPD.js").then((e7) => e7.l).then(({ default: t8 }) => t8({ locateFile: (t9) => n2(`esri/layers/support/rasterFormats/${t9}`) })).then((e7) => {
    l2(e7);
  }), n5);
}
var a6 = { getBlobInfo: null, decode: null };
function o6(e7) {
  return 16 + (e7 >> 3 << 3);
}
function s3(e7, t8, n15) {
  n15.set(e7.slice(t8, t8 + n15.length));
}
function l2(e7) {
  const { _malloc: n15, _free: r14, _lerc_getBlobInfo: l6, _lerc_getDataRanges: i12, _lerc_decode_4D: u11, asm: f6 } = e7;
  let c6;
  const h6 = Object.values(f6).find((t8) => t8 && "buffer" in t8 && t8.buffer === e7.HEAPU8.buffer), y5 = (e8) => {
    const t8 = e8.map((e9) => o6(e9)), r15 = t8.reduce((e9, t9) => e9 + t9), a16 = n15(r15);
    c6 = new Uint8Array(h6.buffer);
    let s6 = t8[0];
    t8[0] = a16;
    for (let n16 = 1; n16 < t8.length; n16++) {
      const e9 = t8[n16];
      t8[n16] = t8[n16 - 1] + s6, s6 = e9;
    }
    return t8;
  };
  a6.getBlobInfo = (e8) => {
    const t8 = 12, n16 = 3, a16 = new Uint8Array(4 * t8), o13 = new Uint8Array(8 * n16), [u12, f7, p5] = y5([e8.length, a16.length, o13.length]);
    c6.set(e8, u12), c6.set(a16, f7), c6.set(o13, p5);
    let g4 = l6(u12, e8.length, f7, p5, t8, n16);
    if (g4) throw r14(u12), new Error(`lerc-getBlobInfo: error code is ${g4}`);
    c6 = new Uint8Array(h6.buffer), s3(c6, f7, a16), s3(c6, p5, o13);
    const d5 = new Uint32Array(a16.buffer), b5 = new Float64Array(o13.buffer), [w5, A4, , m6, U5, x4, C5, V3, T4, D4, z3] = d5, F2 = { version: w5, depthCount: D4, width: m6, height: U5, validPixelCount: C5, bandCount: x4, blobSize: V3, maskCount: T4, dataType: A4, minValue: b5[0], maxValue: b5[1], maxZerror: b5[2], statistics: [], bandCountWithNoData: z3 };
    if (z3 && D4 > 1) return r14(u12), F2;
    if (1 === D4 && 1 === x4) return r14(u12), F2.statistics.push({ minValue: b5[0], maxValue: b5[1] }), F2;
    const I4 = D4 * x4 * 8, _3 = new Uint8Array(I4), k5 = new Uint8Array(I4);
    let B4 = u12, S4 = 0, v6 = 0, E3 = false;
    if (c6.byteLength < u12 + 2 * I4 ? (r14(u12), E3 = true, [B4, S4, v6] = y5([e8.length, I4, I4]), c6.set(e8, B4)) : [S4, v6] = y5([I4, I4]), c6.set(_3, S4), c6.set(k5, v6), g4 = i12(B4, e8.length, D4, x4, S4, v6), g4) throw r14(B4), E3 || r14(S4), new Error(`lerc-getDataRanges: error code is ${g4}`);
    c6 = new Uint8Array(h6.buffer), s3(c6, S4, _3), s3(c6, v6, k5);
    const O5 = new Float64Array(_3.buffer), $ = new Float64Array(k5.buffer), j3 = F2.statistics;
    for (let r15 = 0; r15 < x4; r15++) if (D4 > 1) {
      const e9 = O5.slice(r15 * D4, (r15 + 1) * D4), t9 = $.slice(r15 * D4, (r15 + 1) * D4), n17 = Math.min.apply(null, e9), a17 = Math.max.apply(null, t9);
      j3.push({ minValue: n17, maxValue: a17, depthStats: { minValues: e9, maxValues: t9 } });
    } else j3.push({ minValue: O5[r15], maxValue: $[r15] });
    return r14(B4), E3 || r14(S4), F2;
  }, a6.decode = (e8, n16) => {
    const { maskCount: a16, depthCount: o13, bandCount: l7, width: i13, height: f7, dataType: p5, bandCountWithNoData: g4 } = n16, d5 = t2[p5], b5 = i13 * f7, w5 = new Uint8Array(b5 * l7), A4 = b5 * o13 * l7 * d5.size, m6 = new Uint8Array(A4), U5 = new Uint8Array(l7), x4 = new Uint8Array(8 * l7), [C5, V3, T4, D4, z3] = y5([e8.length, w5.length, m6.length, U5.length, x4.length]);
    c6.set(e8, C5), c6.set(w5, V3), c6.set(m6, T4), c6.set(U5, D4), c6.set(x4, z3);
    const F2 = u11(C5, e8.length, a16, V3, o13, i13, f7, l7, p5, T4, D4, z3);
    if (F2) throw r14(C5), new Error(`lerc-decode: error code is ${F2}`);
    c6 = new Uint8Array(h6.buffer), s3(c6, T4, m6), s3(c6, V3, w5);
    let I4 = null;
    if (g4) {
      s3(c6, D4, U5), s3(c6, z3, x4), I4 = [];
      const e9 = new Float64Array(x4.buffer);
      for (let t8 = 0; t8 < U5.length; t8++) I4.push(U5[t8] ? e9[t8] : null);
    }
    return r14(C5), { data: m6, maskData: w5, noDataValues: I4 };
  };
}
function i5(e7, t8, n15, r14, a16) {
  if (n15 < 2) return e7;
  const o13 = new r14(t8 * n15);
  for (let s6 = 0, l6 = 0; s6 < t8; s6++) for (let r15 = 0, a17 = s6; r15 < n15; r15++, a17 += t8) o13[a17] = e7[l6++];
  return o13;
}
function u3(e7, n15 = {}) {
  const r14 = n15.inputOffset ?? 0, o13 = e7 instanceof Uint8Array ? e7.subarray(r14) : new Uint8Array(e7, r14), s6 = a6.getBlobInfo(o13), { data: l6, maskData: u11, noDataValues: f6 } = a6.decode(o13, s6), { width: c6, height: h6, bandCount: y5, depthCount: p5, dataType: g4, maskCount: d5, statistics: b5 } = s6, w5 = t2[g4], A4 = new w5.ctor(l6.buffer), m6 = [], U5 = [], x4 = c6 * h6, C5 = x4 * p5;
  for (let t8 = 0; t8 < y5; t8++) {
    const e8 = A4.subarray(t8 * C5, (t8 + 1) * C5);
    if (n15.returnInterleaved) m6.push(e8);
    else {
      const t9 = i5(e8, x4, p5, w5.ctor);
      m6.push(t9);
    }
    U5.push(u11.subarray(t8 * C5, (t8 + 1) * C5));
  }
  const V3 = 0 === d5 ? null : 1 === d5 ? U5[0] : new Uint8Array(x4);
  if (d5 > 1) {
    V3.set(U5[0]);
    for (let e8 = 1; e8 < U5.length; e8++) {
      const t8 = U5[e8];
      for (let e9 = 0; e9 < x4; e9++) V3[e9] = V3[e9] & t8[e9];
    }
  }
  const { noDataValue: T4 } = n15, D4 = null != T4 && w5.range[0] <= T4 && w5.range[1] >= T4;
  if (d5 > 0 && D4) for (let t8 = 0; t8 < y5; t8++) {
    const e8 = m6[t8], n16 = U5[t8] || V3;
    for (let t9 = 0; t9 < x4; t9++) 0 === n16[t9] && (e8[t9] = T4);
  }
  const z3 = d5 === y5 && y5 > 1 ? U5 : null, { pixelType: F2 } = w5;
  return { width: c6, height: h6, bandCount: y5, pixelType: F2, depthCount: p5, statistics: b5, pixels: m6, mask: V3, bandMasks: z3, noDataValues: f6 };
}

// node_modules/@arcgis/core/layers/support/rasterFormats/Lzw.js
function e2(e7, n15, t8, r14 = true) {
  if (n15 % 4 != 0 || t8 % 4 != 0) {
    const i12 = new ArrayBuffer(4 * Math.ceil(t8 / 4)), o13 = new Uint8Array(i12), l6 = new Uint8Array(e7, n15, t8);
    if (r14) for (let e8 = 0; e8 < o13.length; e8 += 4) o13[e8] = l6[e8 + 3], o13[e8 + 1] = l6[e8 + 2], o13[e8 + 2] = l6[e8 + 1], o13[e8 + 3] = l6[e8];
    else o13.set(l6);
    return new Uint32Array(o13.buffer);
  }
  if (r14) {
    const r15 = new Uint8Array(e7, n15, t8), i12 = new Uint8Array(r15.length);
    for (let e8 = 0; e8 < i12.length; e8 += 4) i12[e8] = r15[e8 + 3], i12[e8 + 1] = r15[e8 + 2], i12[e8 + 2] = r15[e8 + 1], i12[e8 + 3] = r15[e8];
    return new Uint32Array(i12.buffer);
  }
  return new Uint32Array(e7, n15, t8 / 4);
}
function n6() {
  const e7 = [];
  for (let n15 = 0; n15 <= 257; n15++) e7[n15] = [n15];
  return e7;
}
function t3(e7, n15) {
  for (let t8 = 0; t8 < n15.length; t8++) e7.push(n15[t8]);
}
var r6 = /* @__PURE__ */ new Set();
function i6(i12, o13, l6, f6 = true) {
  const s6 = e2(i12, o13, l6, f6);
  let a16 = 9, c6 = n6(), u11 = 32, h6 = c6.length, d5 = [], w5 = 1, g4 = s6[0], y5 = 0;
  const A4 = s6.length, U5 = 8 * (4 * A4 - l6), p5 = [];
  for (; null != g4; ) {
    if (u11 >= a16) u11 -= a16, y5 = g4 >>> 32 - a16, g4 <<= a16;
    else {
      y5 = g4 >>> 32 - u11, g4 = s6[w5++];
      const e8 = a16 - u11;
      u11 = 32 - e8, y5 = (y5 << e8) + (g4 >>> u11), g4 <<= e8;
    }
    if (257 === y5) break;
    if (256 === y5) {
      a16 = 9, c6 = n6(), h6 = c6.length, d5 = [];
      continue;
    }
    const e7 = c6[y5];
    if (null == e7) {
      if (y5 > c6.length) throw new Error("data integrity issue: code does not exist on code page");
      d5.push(d5[0]), c6[h6++] = d5.slice(), t3(p5, d5);
    } else t3(p5, e7), d5.push(e7[0]), d5.length > 1 && (c6[h6++] = d5.slice()), d5 = e7.slice();
    if (r6.has(h6) && a16++, 0 === u11 && (g4 = s6[w5++], u11 = 32), w5 > A4 || w5 === A4 && u11 <= U5) break;
  }
  return new Uint8Array(p5);
}
r6.add(511), r6.add(1023), r6.add(2047), r6.add(4095), r6.add(8191);

// node_modules/@arcgis/core/layers/support/rasterFormats/Qb3.js
var n7 = /* @__PURE__ */ new Set(["uint8", "int8", "uint16", "int16", "uint32", "int32", "int64", "uint64"]);
var r7 = /* @__PURE__ */ new Map([["uint8", { byteCount: 1, ctor: Uint8Array }], ["int8", { byteCount: 1, ctor: Int8Array }], ["uint16", { byteCount: 2, ctor: Uint16Array }], ["int16", { byteCount: 2, ctor: Int16Array }], ["uint32", { byteCount: 4, ctor: Uint32Array }], ["int32", { byteCount: 4, ctor: Int32Array }], ["uint64", { byteCount: 8, ctor: BigUint64Array }], ["int64", { byteCount: 8, ctor: BigInt64Array }]]);
var e3;
function o7() {
  return e3 ??= import("./qb3-wasm-WQD5RMZM.js").then(({ default: n15 }) => n15({ locateFile: (n16) => n2(`esri/layers/support/rasterFormats/${n16}`) })).then((t8) => {
    u4(t8);
  }), e3;
}
var i7 = { getBlobInfo: null, decode: null };
function a7(t8) {
  if (!r7.has(t8)) throw new Error("Unsupported data type: " + t8);
  return r7.get(t8);
}
function u4(t8) {
  const { _GetInfo: r14, _decode: e7, _malloc: o13, _free: u11, writeArrayToMemory: c6, UTF8ToString: l6 } = t8;
  i7.getBlobInfo = (t9) => {
    t9.length > 1e3 && (t9 = t9.slice(0, 1e3));
    const n15 = o13(t9.length);
    c6(t9, n15);
    const e8 = r14(n15, t9.length);
    if (u11(n15), !e8) return null;
    const i12 = l6(e8);
    u11(e8);
    try {
      const t10 = JSON.parse(i12);
      return { width: t10.xsize, height: t10.ysize, bandCount: t10.nbands, dataType: t10.dtype, mode: t10.mode, bandMap: t10.bandmap };
    } catch {
      return null;
    }
  }, i7.decode = (r15, o14) => {
    const { dataType: i12, width: u12, height: c7, bandCount: l7 } = o14;
    if (!n7.has(i12)) throw new Error("Unsupported data type: " + i12);
    const { _malloc: s6, _free: y5 } = t8, d5 = s6(r15.length);
    t8.writeArrayToMemory(r15, d5);
    const { ctor: h6, byteCount: f6 } = a7(i12), g4 = u12 * c7 * l7 * f6, b5 = s6(g4), p5 = s6(1024);
    if (0 === e7(d5, r15.length, b5, p5)) throw y5(d5), y5(b5), y5(p5), new Error("Decoding failed: " + t8.UTF8ToString(p5));
    const w5 = new h6(t8.HEAPU8.slice(b5, b5 + g4).buffer);
    if (y5(d5), y5(b5), y5(p5), w5 instanceof BigInt64Array || w5 instanceof BigUint64Array) {
      const t9 = new Float64Array(w5.length);
      for (let n15 = 0; n15 < w5.length; n15++) t9[n15] = Number(w5[n15]);
      return t9;
    }
    return w5;
  };
}
function c2(t8) {
  const n15 = new Uint8Array(t8), r14 = i7.getBlobInfo(n15);
  if (!r14) return null;
  const e7 = i7.decode(n15, r14);
  if (!e7) return null;
  const { width: o13, height: u11, bandCount: c6, dataType: l6 } = r14, { ctor: s6 } = a7(l6), y5 = s6 === BigInt64Array || s6 === BigUint64Array ? Float64Array : s6, d5 = Array.from({ length: c6 }, () => new y5(o13 * u11));
  for (let i12 = 0, a16 = 0; i12 < o13 * u11; i12++) for (let t9 = 0; t9 < c6; t9++) d5[t9][i12] = e7[a16++];
  return { width: o13, height: u11, pixels: d5 };
}

// node_modules/@arcgis/core/layers/support/rasterFormats/Raw.js
var e4 = (e7, r14) => {
  const a16 = r14.width * r14.height, n15 = r14.pixelType;
  return Math.floor(e7.byteLength / (a16 * t4(n15)));
};
var t4 = (e7) => {
  let t8 = 1;
  switch (e7) {
    case Uint8Array:
    case Int8Array:
      t8 = 1;
      break;
    case Uint16Array:
    case Int16Array:
      t8 = 2;
      break;
    case Uint32Array:
    case Int32Array:
    case Float32Array:
      t8 = 4;
      break;
    case Float64Array:
      t8 = 8;
  }
  return t8;
};
var r8 = (e7, t8) => {
  if (8 * e7.byteLength < t8) return null;
  const r14 = new Uint8Array(e7, 0, Math.ceil(t8 / 8)), a16 = new Uint8Array(t8);
  let n15 = 0, s6 = 0, l6 = 0, i12 = 0;
  for (l6 = 0; l6 < r14.length - 1; l6++) for (s6 = r14[l6], i12 = 7; i12 >= 0; i12--) a16[n15++] = s6 >> i12 & 1;
  for (i12 = 7; n15 < t8 - 1; ) s6 = r14[r14.length - 1], a16[n15++] = s6 >> i12 & 1, i12--;
  return a16;
};
var a8 = class {
  static decode(a16, n15) {
    const s6 = n15.pixelType, l6 = [], i12 = n15.width * n15.height, h6 = e4(a16, n15), { bandIds: c6, format: y5 } = n15, o13 = c6?.length || e4(a16, n15), b5 = a16.byteLength - a16.byteLength % (i12 * t4(s6)), f6 = new s6(a16, 0, i12 * h6);
    let u11, g4, A4, p5, d5 = null;
    if ("bip" === y5) for (u11 = 0; u11 < o13; u11++) {
      for (A4 = new s6(i12), p5 = c6 ? c6[u11] : u11, g4 = 0; g4 < i12; g4++) A4[g4] = f6[g4 * h6 + p5];
      l6.push(A4);
    }
    else if ("bsq" === y5) for (u11 = 0; u11 < o13; u11++) p5 = c6 ? c6[u11] : u11, l6.push(f6.subarray(p5 * i12, (p5 + 1) * i12));
    return b5 < a16.byteLength - 1 && (d5 = r8(a16.slice(b5), i12)), { pixels: l6, mask: d5 };
  }
};

// node_modules/@arcgis/core/layers/support/rasterDatasets/byteStreamUtils.js
function r9(r14, t8) {
  let n15 = 0, o13 = "", e7 = 0, f6 = 0;
  const c6 = r14.length;
  for (; n15 < c6; ) f6 = r14[n15++], e7 = f6 >> 4, e7 < 8 ? e7 = 1 : 15 === e7 ? (e7 = 4, f6 = (7 & f6) << 18 | (63 & r14[n15++]) << 12 | (63 & r14[n15++]) << 6 | 63 & r14[n15++]) : 14 === e7 ? (e7 = 3, f6 = (15 & f6) << 12 | (63 & r14[n15++]) << 6 | 63 & r14[n15++]) : (e7 = 2, f6 = (31 & f6) << 6 | 63 & r14[n15++]), (0 !== f6 || t8) && (o13 += String.fromCharCode(f6));
  return o13;
}

// node_modules/@arcgis/core/layers/support/rasterFormats/tiffTag.js
var e5 = (() => {
  const e7 = [];
  return e7[254] = "NEWSUBFILETYPE", e7[255] = "SUBFILETYPE", e7[256] = "IMAGEWIDTH", e7[257] = "IMAGELENGTH", e7[258] = "BITSPERSAMPLE", e7[259] = "COMPRESSION", e7[262] = "PHOTOMETRICINTERPRETATION", e7[263] = "THRESHHOLDING", e7[264] = "CELLWIDTH", e7[265] = "CELLLENGTH", e7[266] = "FILLORDER", e7[269] = "DOCUMENTNAME", e7[270] = "IMAGEDESCRIPTION", e7[271] = "MAKE", e7[272] = "MODEL", e7[273] = "STRIPOFFSETS", e7[274] = "ORIENTATION", e7[277] = "SAMPLESPERPIXEL", e7[278] = "ROWSPERSTRIP", e7[279] = "STRIPBYTECOUNTS", e7[280] = "MINSAMPLEVALUE", e7[281] = "MAXSAMPLEVALUE", e7[282] = "XRESOLUTION", e7[283] = "YRESOLUTION", e7[284] = "PLANARCONFIGURATION", e7[285] = "PAGENAME", e7[286] = "XPOSITION", e7[287] = "YPOSITION", e7[288] = "FREEOFFSETS", e7[289] = "FREEBYTECOUNTS", e7[290] = "GRAYRESPONSEUNIT", e7[291] = "GRAYRESPONSECURVE", e7[292] = "T4OPTIONS", e7[293] = "T6OPTIONS", e7[296] = "RESOLUTIONUNIT", e7[297] = "PAGENUMBER", e7[300] = "COLORRESPONSEUNIT", e7[301] = "TRANSFERFUNCTION", e7[305] = "SOFTWARE", e7[306] = "DATETIME", e7[315] = "ARTIST", e7[316] = "HOSTCOMPUTER", e7[317] = "PREDICTOR", e7[318] = "WHITEPOINT", e7[319] = "PRIMARYCHROMATICITIES", e7[320] = "COLORMAP", e7[321] = "HALFTONEHINTS", e7[322] = "TILEWIDTH", e7[323] = "TILELENGTH", e7[324] = "TILEOFFSETS", e7[325] = "TILEBYTECOUNTS", e7[326] = "BADFAXLINES", e7[327] = "CLEANFAXDATA", e7[328] = "CONSECUTIVEBADFAXLINES", e7[330] = "SUBIFD", e7[332] = "INKSET", e7[333] = "INKNAMES", e7[334] = "NUMBEROFINKS", e7[336] = "DOTRANGE", e7[337] = "TARGETPRINTER", e7[338] = "EXTRASAMPLES", e7[339] = "SAMPLEFORMAT", e7[340] = "SMINSAMPLEVALUE", e7[341] = "SMAXSAMPLEVALUE", e7[342] = "TRANSFERRANGE", e7[347] = "JPEGTABLES", e7[512] = "JPEGPROC", e7[513] = "JPEGIFOFFSET", e7[514] = "JPEGIFBYTECOUNT", e7[515] = "JPEGRESTARTINTERVAL", e7[517] = "JPEGLOSSLESSPREDICTORS", e7[518] = "JPEGPOINTTRANSFORM", e7[519] = "JPEGQTABLES", e7[520] = "JPEGDCTABLES", e7[521] = "JPEGACTABLES", e7[529] = "YCBCRCOEFFICIENTS", e7[530] = "YCBCRSUBSAMPLING", e7[531] = "YCBCRPOSITIONING", e7[532] = "REFERENCEBLACKWHITE", e7[700] = "XMP", e7[33550] = "GEOPIXELSCALE", e7[33922] = "GEOTIEPOINTS", e7[33432] = "COPYRIGHT", e7[42112] = "GDAL_METADATA", e7[42113] = "GDAL_NODATA", e7[50844] = "RPCCOEFFICIENT", e7[34264] = "GEOTRANSMATRIX", e7[34735] = "GEOKEYDIRECTORY", e7[34736] = "GEODOUBLEPARAMS", e7[34737] = "GEOASCIIPARAMS", e7[34665] = "EXIFIFD", e7[34853] = "GPSIFD", e7[40965] = "INTEROPERABILITYIFD", e7;
})();
var i8 = (() => {
  const i12 = e5.slice();
  return i12[36864] = "ExifVersion", i12[40960] = "FlashpixVersion", i12[40961] = "ColorSpace", i12[42240] = "Gamma", i12[37121] = "ComponentsConfiguration", i12[37122] = "CompressedBitsPerPixel", i12[40962] = "PixelXDimension", i12[40963] = "PixelYDimension", i12[37500] = "MakerNote", i12[37510] = "UserComment", i12[40964] = "RelatedSoundFile", i12[36867] = "DateTimeOriginal", i12[36868] = "DateTimeDigitized", i12[36880] = "OffsetTime", i12[36881] = "OffsetTimeOriginal", i12[36882] = "OffsetTimeDigitized", i12[37520] = "SubSecTime", i12[37521] = "SubSecTimeOriginal", i12[37522] = "SubSecTimeDigitized", i12[37888] = "Temperature", i12[37889] = "Humidity", i12[37890] = "Pressure", i12[37891] = "WaterDepth", i12[37892] = "Acceleration", i12[37893] = "CameraElevationAngle", i12[42016] = "ImageUniqueID", i12[42032] = "CameraOwnerName", i12[42033] = "BodySerialNumber", i12[42034] = "LensSpecification", i12[42035] = "LensMake", i12[42036] = "LensModel", i12[42037] = "LensSerialNumber", i12[33434] = "ExposureTime", i12[33437] = "FNumber", i12[34850] = "ExposureProgram", i12[34852] = "SpectralSensitivity", i12[34855] = "PhotographicSensitivity", i12[34856] = "OECF", i12[34864] = "SensitivityType", i12[34865] = "StandardOutputSensitivity", i12[34866] = "RecommendedExposureIndex", i12[34867] = "ISOSpeed", i12[34868] = "ISOSpeedLatitudeyyy", i12[34869] = "ISOSpeedLatitudezzz", i12[37377] = "ShutterSpeedValue", i12[37378] = "ApertureValue", i12[37379] = "BrightnessValue", i12[37380] = "ExposureBiasValue", i12[37381] = "MaxApertureValue", i12[37382] = "SubjectDistance", i12[37383] = "MeteringMode", i12[37384] = "LightSource", i12[37385] = "Flash", i12[37386] = "FocalLength", i12[37396] = "SubjectArea", i12[41483] = "FlashEnergy", i12[41484] = "SpatialFrequencyResponse", i12[41486] = "FocalPlaneXResolution", i12[41487] = "FocalPlaneYResolution", i12[41488] = "FocalPlaneResolutionUnit", i12[41492] = "SubjectLocation", i12[41493] = "ExposureIndex", i12[41495] = "SensingMethod", i12[41728] = "FileSource", i12[41729] = "SceneType", i12[41730] = "CFAPattern", i12[41985] = "CustomRendered", i12[41986] = "ExposureMode", i12[41987] = "WhiteBalance", i12[41988] = "DigitalZoomRatio", i12[41989] = "FocalLengthIn35mmFilm", i12[41990] = "SceneCaptureType", i12[41991] = "GainControl", i12[41992] = "Contrast", i12[41993] = "Saturation", i12[41994] = "Sharpness", i12[41995] = "DeviceSettingDescription", i12[41996] = "SubjectDistanceRange", i12;
})();
var o8 = ["GPSVersionID", "GPSLatitudeRef", "GPSLatitude", "GPSLongitudeRef", "GPSLongitude", "GPSAltitudeRef", "GPSAltitude", "GPSTimeStamp", "GPSSatellites", "GPSStatus", "GPSMeasureMode", "GPSDOP", "GPSSpeedRef", "GPSSpeed", "GPSTrackRef", "GPSTrack", "GPSImgDirectionRef", "GPSImgDirection", "GPSMapDatum", "GPSDestLatitudeRef", "GPSDestLatitude", "GPSDestLongitudeRef", "GPSDestLongitude", "GPSDestBearingRef", "GPSDestBearing", "GPSDestDistanceRef", "GPSDestDistance", "GPSProcessingMethod", "GPSAreaInformation", "GPSDateStamp", "GPSDifferential", "GPSHPositioningError"];
var t5 = (() => {
  const e7 = [];
  return e7[1024] = "GTModelTypeGeoKey", e7[1025] = "GTRasterTypeGeoKey", e7[1026] = "GTCitationGeoKey", e7[2048] = "GeographicTypeGeoKey", e7[2049] = "GeogCitationGeoKey", e7[2050] = "GeogGeodeticDatumGeoKey", e7[2051] = "GeogPrimeMeridianGeoKey", e7[2052] = "GeogLinearUnitsGeoKey", e7[2053] = "GeogLinearUnitSizeGeoKey", e7[2054] = "GeogAngularUnitsGeoKey", e7[2055] = "GeogAngularUnitSizeGeoKey", e7[2056] = "GeogEllipsoidGeoKey", e7[2057] = "GeogSemiMajorAxisGeoKey", e7[2058] = "GeogSemiMinorAxisGeoKey", e7[2059] = "GeogInvFlatteningGeoKey", e7[2061] = "GeogPrimeMeridianLongGeoKey", e7[2060] = "GeogAzimuthUnitsGeoKey", e7[3072] = "ProjectedCSTypeGeoKey", e7[3073] = "PCSCitationGeoKey", e7[3074] = "ProjectionGeoKey", e7[3075] = "ProjCoordTransGeoKey", e7[3076] = "ProjLinearUnitsGeoKey", e7[3077] = "ProjLinearUnitSizeGeoKey", e7[3078] = "ProjStdParallel1GeoKey", e7[3079] = "ProjStdParallel2GeoKey", e7[3080] = "ProjNatOriginLongGeoKey", e7[3081] = "ProjNatOriginLatGeoKey", e7[3082] = "ProjFalseEastingGeoKey", e7[3083] = "ProjFalseNorthingGeoKey", e7[3084] = "ProjFalseOriginLongGeoKey", e7[3085] = "ProjFalseOriginLatGeoKey", e7[3086] = "ProjFalseOriginEastingGeoKey", e7[3087] = "ProjFalseOriginNorthingGeoKey", e7[3088] = "ProjCenterLongGeoKey", e7[3090] = "ProjCenterEastingGeoKey", e7[3091] = "ProjCenterNorthingGeoKey", e7[3092] = "ProjScaleAtNatOriginGeoKey", e7[3093] = "ProjScaleAtCenterGeoKey", e7[3094] = "ProjAzimuthAngleGeoKey", e7[3095] = "ProjStraightVertPoleLongGeoKey", e7[4096] = "VerticalCSTypeGeoKey", e7[4097] = "VerticalCitationGeoKey", e7[4098] = "VerticalDatumGeoKey", e7[4099] = "VerticalUnitsGeoKey", e7;
})();
var S = (i12, o13) => {
  let t8 = (o13 || e5)[i12];
  return void 0 === t8 && (t8 = "unknown" + String(i12)), t8;
};
var E = /* @__PURE__ */ new Map([["EXIFIFD", i8], ["GPSIFD", o8]]);

// node_modules/@arcgis/core/layers/support/rasterFormats/utils.js
var r10 = (() => {
  const r14 = new ArrayBuffer(4), n15 = new Uint8Array(r14);
  return new Uint32Array(r14)[0] = 1, 1 === n15[0];
})();

// node_modules/@arcgis/core/layers/support/rasterFormats/TiffDecoder.js
var h2 = [0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8, -1, -1, -1, 8, 8, 8];
var g2 = 4294967296;
var E2 = /* @__PURE__ */ new Set([1, 5, 6, 7, 8, 34712, 34887]);
function I(e7, t8) {
  let n15 = "unknown";
  return 3 === e7 ? n15 = 64 === t8 ? "f64" : "f32" : 1 === e7 ? 1 === t8 ? n15 = "u1" : 2 === t8 ? n15 = "u2" : 4 === t8 ? n15 = "u4" : t8 <= 8 ? n15 = "u8" : t8 <= 16 ? n15 = "u16" : t8 <= 32 && (n15 = "u32") : 2 === e7 && (t8 <= 8 ? n15 = "s8" : t8 <= 16 ? n15 = "s16" : t8 <= 32 && (n15 = "s32")), n15;
}
function T(e7) {
  let t8 = null;
  switch (e7 ? e7.toLowerCase() : "f32") {
    case "u1":
    case "u2":
    case "u4":
    case "u8":
      t8 = Uint8Array;
      break;
    case "u16":
      t8 = Uint16Array;
      break;
    case "u32":
      t8 = Uint32Array;
      break;
    case "s8":
      t8 = Int8Array;
      break;
    case "s16":
      t8 = Int16Array;
      break;
    case "s32":
      t8 = Int32Array;
      break;
    case "f64":
      t8 = Float64Array;
      break;
    default:
      t8 = Float32Array;
  }
  return t8;
}
function w(e7, t8) {
  return { x: t8[0] * e7.x + t8[1] * e7.y + t8[2], y: t8[3] * e7.x + t8[4] * e7.y + t8[5] };
}
function p2(e7, t8) {
  return e7.get(t8)?.values;
}
function d(e7, t8) {
  return e7.get(t8)?.values;
}
function m2(e7, t8) {
  return e7.get(t8)?.values?.[0];
}
function y(e7, t8) {
  return e7.get(t8)?.values?.[0];
}
function A(e7, t8, n15, a16 = 0, i12 = e5, r14 = 4) {
  const l6 = 8 === r14, f6 = l6 ? B2(new DataView(e7, n15, 8), 0, t8) : new DataView(e7, n15, 2).getUint16(0, t8), u11 = 4 + 2 * r14, c6 = l6 ? 8 : 2, h6 = c6 + f6 * u11;
  if (n15 + h6 > e7.byteLength) return { success: false, ifd: null, nextIFD: null, requiredBufferSize: h6 };
  const g4 = 8 === r14 ? 8 : 4, E3 = n15 + h6 + g4 <= e7.byteLength ? W(new DataView(e7, n15 + h6, g4), 0, t8, 8 === r14) : null, I4 = n15 + c6, T4 = /* @__PURE__ */ new Map();
  let w5, p5, d5, m6, y5, A4 = 0, S4 = 0;
  for (let s6 = 0; s6 < f6; s6++) {
    p5 = new DataView(e7, I4 + u11 * s6, u11), d5 = p5.getUint16(0, t8), y5 = p5.getUint16(2, t8), m6 = S(d5, i12);
    const n16 = [];
    2 === r14 ? (A4 = p5.getUint16(4, t8), S4 = p5.getUint16(6, t8)) : 4 === r14 ? (A4 = p5.getUint32(4, t8), S4 = p5.getUint32(8, t8)) : 8 === r14 && (A4 = W(p5, 4, t8, true), S4 = W(p5, 12, t8, true), n16.push(p5.getUint32(12, t8)), n16.push(p5.getUint32(16, t8))), w5 = { id: d5, type: y5, valueCount: A4, valueOffset: S4, valueOffsets: n16, values: null }, N(e7, t8, w5, a16, false, r14), T4.set(m6, w5);
  }
  return { success: true, ifd: T4, nextIFD: E3, requiredBufferSize: h6 };
}
var S2 = (e7, t8) => u3(e7, { inputOffset: t8 }).pixels[0];
function M(e7, t8) {
  if (t8 % 8 == 0) return e7;
  const n15 = t8 > 16 ? 32 : t8 > 8 ? 16 : 8;
  n15 > 8 && (e7 = b(e7, 32 === n15 ? 4 : 2));
  const a16 = 32 === n15 ? Uint32Array : 16 === n15 ? Uint16Array : Uint8Array, i12 = new a16(e7), r14 = Math.floor(8 * e7.byteLength / t8 + 1e-6), s6 = new a16(r14), l6 = (1 << t8) - 1;
  let o13 = 0, f6 = 0, u11 = 0;
  for (let c6 = 0; c6 < r14; c6++) if (0 === f6 && (u11 = i12[o13++], f6 = n15), f6 >= t8) s6[c6] = u11 >>> f6 - t8 & l6, f6 -= t8;
  else {
    const e8 = t8 - f6;
    let a17 = (u11 & l6) << e8 & l6;
    u11 = i12[o13++], f6 = n15 - e8, a17 += u11 >>> f6, s6[c6] = a17;
  }
  return s6.buffer;
}
function P(e7, n15, a16) {
  const i12 = new a5();
  i12.parse(e7), i12.colorTransform = 6 === a16 ? -1 : 0;
  const r14 = i12.getData(i12.width, i12.height, 1 !== n15 && 4 !== n15);
  return new Uint8Array(r14.buffer);
}
function O(e7) {
  const t8 = new s2(e7).getBytes(), n15 = new ArrayBuffer(t8.length), a16 = new Uint8Array(n15);
  return a16.set(t8), a16;
}
function b(e7, t8) {
  const n15 = new Uint8Array(e7), a16 = new Uint8Array(n15.length);
  if (2 === t8) for (let i12 = 0; i12 < n15.length; i12 += 2) a16[i12] = n15[i12 + 1], a16[i12 + 1] = n15[i12];
  else if (4 === t8) for (let i12 = 0; i12 < n15.length; i12 += 4) a16[i12] = n15[i12 + 3], a16[i12 + 1] = n15[i12 + 2], a16[i12 + 2] = n15[i12 + 1], a16[i12 + 3] = n15[i12];
  else for (let i12 = 0; i12 < n15.length; i12 += 8) a16[i12] = n15[i12 + 7], a16[i12 + 1] = n15[i12 + 6], a16[i12 + 2] = n15[i12 + 5], a16[i12 + 3] = n15[i12 + 4], a16[i12 + 4] = n15[i12 + 3], a16[i12 + 5] = n15[i12 + 2], a16[i12 + 6] = n15[i12 + 1], a16[i12 + 7] = n15[i12];
  return a16.buffer;
}
async function x(e7, t8, a16, r14, s6) {
  const l6 = r10 === t8, o13 = y(a16, "BITSPERSAMPLE"), f6 = y(a16, "SAMPLESPERPIXEL") ?? 1, c6 = y(a16, "PHOTOMETRICINTERPRETATION"), h6 = y(a16, "SAMPLEFORMAT") ?? 1, g4 = I(h6, o13), E3 = y(a16, "COMPRESSION") ?? 1, w5 = T(g4);
  let p5, d5, m6;
  if (34887 === E3) return await r5(), S2(e7, r14);
  if (1 === E3) p5 = e7.slice(r14, r14 + s6), d5 = new Uint8Array(p5);
  else if (8 === E3 || 32946 === E3) d5 = new Uint8Array(e7, r14, s6), d5 = O(d5), p5 = d5.buffer;
  else if (6 === E3) d5 = new Uint8Array(e7, r14, s6), d5 = P(d5, f6, c6), p5 = d5.buffer;
  else if (7 === E3) {
    const t9 = a16.get("JPEGTABLES").values, n15 = t9.length - 2;
    d5 = new Uint8Array(n15 + s6 - 2);
    for (let e8 = 0; e8 < n15; e8++) d5[e8] = t9[e8];
    const i12 = new Uint8Array(e7, r14 + 2, s6 - 2);
    for (let e8 = 0; e8 < i12.length; e8++) d5[n15 + e8] = i12[e8];
    d5 = P(d5, f6, c6), p5 = d5.buffer;
  } else {
    if (5 !== E3) throw new Error("tiff-decode: unsupport compression " + E3);
    d5 = i6(e7, r14, s6, t8), p5 = d5.buffer;
  }
  if (p5 = M(p5, o13), l6 || o13 <= 8) m6 = new w5(p5);
  else {
    const e8 = o13 > 32 ? 8 : o13 > 16 ? 4 : 2;
    m6 = new w5(b(d5.buffer, e8));
  }
  const A4 = y(a16, "PREDICTOR") ?? 1, x4 = y(a16, "TILEWIDTH"), L3 = y(a16, "TILELENGTH");
  if (A4 > 1 && (5 === E3 || 8 === E3 || 32946 === E3) && x4 && L3) {
    const e8 = C2(a16), t9 = new w5(m6.length);
    t9.set(m6), m6 = j(t9, L3, x4, 3 === h6 && 3 === A4, e8 ? 1 : f6);
  }
  return m6;
}
async function L(e7, t8, n15) {
  const a16 = d(n15, "TILEOFFSETS");
  if (void 0 === a16) return null;
  const i12 = d(n15, "TILEBYTECOUNTS"), { width: r14, height: s6, pixelType: l6, tileWidth: o13, tileHeight: f6 } = k([n15]), u11 = C2(n15, t8), c6 = y(n15, "SAMPLESPERPIXEL") || t8.planes, h6 = r14 * s6, g4 = y(n15, "BITSPERSAMPLE"), E3 = 34887 === (y(n15, "COMPRESSION") ?? 1), I4 = T(l6), w5 = [];
  for (let T4 = 0; T4 < c6; T4++) w5.push(new I4(h6));
  let p5, m6, A4, S4, M4, P4, O5, b5, L3, D4, R4, U5, N2;
  const G3 = Math.ceil(r14 / o13), v6 = new Uint8Array(h6).fill(255);
  let F2 = false;
  if (g4 % 8 == 0) if (E3 && u11 && c6 > 1) {
    const l7 = Math.round(a16.length / c6);
    for (p5 = 0; p5 < l7; p5++) {
      P4 = Math.floor(p5 / G3) * f6, O5 = p5 % G3 * o13, b5 = P4 * r14 + O5;
      for (let l8 = 0; l8 < c6; l8++) {
        const u12 = p5 * c6 + l8;
        for (0 === i12[u12] ? (A4 = null, F2 = true) : A4 = await x(e7, t8.littleEndian, n15, a16[u12], i12[u12]), D4 = 0, L3 = b5, U5 = Math.min(o13, r14 - O5), R4 = Math.min(f6, s6 - P4), N2 = w5[l8], S4 = 0; S4 < R4; S4++) for (L3 = b5 + S4 * r14, D4 = S4 * o13, M4 = 0; M4 < U5; M4++, L3++, D4++) A4 ? N2[L3] = A4[D4] : v6[L3] = 0;
      }
    }
  } else for (p5 = 0; p5 < a16.length; p5++) for (P4 = Math.floor(p5 / G3) * f6, O5 = p5 % G3 * o13, b5 = P4 * r14 + O5, 0 === i12[p5] ? (A4 = null, F2 = true) : A4 = await x(e7, t8.littleEndian, n15, a16[p5], i12[p5]), D4 = 0, L3 = b5, U5 = Math.min(o13, r14 - O5), R4 = Math.min(f6, s6 - P4), m6 = 0; m6 < c6; m6++) if (N2 = w5[m6], u11 || E3) for (S4 = 0; S4 < R4; S4++) for (L3 = b5 + S4 * r14, D4 = o13 * f6 * m6 + S4 * o13, M4 = 0; M4 < U5; M4++, L3++, D4++) A4 ? N2[L3] = A4[D4] : v6[L3] = 0;
  else for (S4 = 0; S4 < R4; S4++) for (L3 = b5 + S4 * r14, D4 = S4 * o13 * c6 + m6, M4 = 0; M4 < U5; M4++, L3++, D4 += c6) A4 ? N2[L3] = A4[D4] : v6[L3] = 0;
  return { width: r14, height: s6, pixelType: l6, pixels: w5, mask: F2 ? v6 : void 0 };
}
var D = (e7, t8, n15) => {
  const a16 = r10 === t8.littleEndian, r14 = d(n15, "STRIPOFFSETS");
  if (void 0 === r14) return null;
  const { width: s6, height: l6, pixelType: o13 } = k([n15]), f6 = y(n15, "SAMPLESPERPIXEL") || t8.planes, c6 = y(n15, "PHOTOMETRICINTERPRETATION"), h6 = s6 * l6, g4 = y(n15, "BITSPERSAMPLE"), E3 = T(o13), I4 = new E3(h6 * f6), w5 = d(n15, "STRIPBYTECOUNTS"), p5 = y(n15, "ROWSPERSTRIP"), m6 = y(n15, "COMPRESSION") ?? 1;
  let A4, S4, b5, x4, L3, D4, R4, U5, N2;
  if (g4 % 8 == 0) for (A4 = 0; A4 < r14.length; A4++) {
    if (L3 = A4 * (p5 * s6) * f6, "u8" === o13 || "s8" === o13 || a16) 8 === m6 || 32946 === m6 ? (R4 = new Uint8Array(e7, r14[A4], w5[A4]), R4 = O(R4), D4 = R4.buffer) : 6 === m6 ? (R4 = new Uint8Array(e7, r14[A4], w5[A4]), R4 = P(R4, f6, c6), D4 = R4.buffer) : 5 === m6 ? (R4 = i6(e7, r14[A4], w5[A4], t8.littleEndian), D4 = R4.buffer) : D4 = e7.slice(r14[A4], r14[A4] + w5[A4]), D4 = M(D4, g4), x4 = new E3(D4);
    else {
      switch (6 === m6 || 8 === m6 || 32946 === m6 ? (R4 = new Uint8Array(e7, r14[A4], w5[A4]), U5 = O(R4), D4 = U5.buffer) : (D4 = new ArrayBuffer(w5[A4]), R4 = new Uint8Array(e7, r14[A4], w5[A4]), U5 = new Uint8Array(D4)), o13) {
        case "u16":
        case "s16":
          for (b5 = 0; b5 < R4.length; b5 += 2) U5[b5] = R4[b5 + 1], U5[b5 + 1] = R4[b5];
          break;
        case "u32":
        case "s32":
        case "f32":
          for (b5 = 0; b5 < R4.length; b5 += 4) U5[b5] = R4[b5 + 3], U5[b5 + 1] = R4[b5 + 2], U5[b5 + 2] = R4[b5 + 1], U5[b5 + 3] = R4[b5];
      }
      D4 = M(D4, g4), x4 = new E3(D4);
    }
    I4.set(x4, L3);
  }
  const C5 = [];
  if (1 === f6) C5.push(I4);
  else for (A4 = 0; A4 < f6; A4++) {
    for (N2 = new E3(h6), S4 = 0; S4 < h6; S4++) N2[S4] = I4[S4 * f6 + A4];
    C5.push(N2);
  }
  return { width: s6, height: l6, pixelType: o13, pixels: C5 };
};
var R = (e7, t8, n15) => {
  if (!(e7 && e7.length > 0 && t8 && n15)) return null;
  let a16, i12, r14;
  const s6 = e7[0].length, l6 = e7.length, o13 = new Uint8Array(s6);
  for (let f6 = 0; f6 < l6; f6++) if (a16 = e7[f6], i12 = t8[f6], r14 = n15[f6], 0 === f6) for (let e8 = 0; e8 < s6; e8++) o13[e8] = a16[e8] < i12 || a16[e8] > r14 ? 0 : 1;
  else for (let e8 = 0; e8 < s6; e8++) o13[e8] && (o13[e8] = a16[e8] < i12 || a16[e8] > r14 ? 0 : 1);
  return o13;
};
var U2 = (e7) => {
  if (!e7) return null;
  const t8 = e7.match(/<Item(.*?)Item>/gi);
  if (!t8 || 0 === t8.length) return null;
  const n15 = /* @__PURE__ */ new Map();
  let a16, i12, r14, s6, l6;
  for (let w5 = 0; w5 < t8.length; w5++) a16 = t8[w5], i12 = a16.slice(6, a16.indexOf(">")), s6 = a16.indexOf("sample="), s6 > -1 && (l6 = a16.slice(s6 + 8, a16.indexOf('"', s6 + 8))), s6 = a16.indexOf("name="), s6 > -1 && (i12 = a16.slice(s6 + 6, a16.indexOf('"', s6 + 6))), i12 && (r14 = a16.slice(a16.indexOf(">") + 1, a16.indexOf("</Item>")).trim(), null != l6 ? n15.has(i12) ? n15.get(i12)[l6] = r14 : n15.set(i12, [r14]) : n15.set(i12, r14)), l6 = null;
  const o13 = n15.get("STATISTICS_MINIMUM"), f6 = n15.get("STATISTICS_MAXIMUM"), u11 = n15.get("STATISTICS_MEAN"), c6 = n15.get("STATISTICS_STDDEV");
  let h6 = null;
  if (o13 && f6) {
    h6 = [];
    for (let e8 = 0; e8 < o13.length; e8++) h6.push({ min: parseFloat(o13[e8]), max: parseFloat(f6[e8]), avg: u11 && parseFloat(u11[e8]), stddev: c6 && parseFloat(c6[e8]) });
  }
  const g4 = n15.get("BandName"), E3 = n15.get("WavelengthMin"), I4 = n15.get("WavelengthMax");
  let T4 = null;
  if (g4) {
    T4 = [];
    for (let e8 = 0; e8 < g4.length; e8++) T4.push({ BandName: g4[e8], WavelengthMin: E3 && parseFloat(E3[e8]), WavelengthMax: I4 && parseFloat(I4[e8]) });
  }
  return { statistics: h6, bandProperties: T4, dataType: n15.get("DataType"), rawMetadata: n15 };
};
function N(e7, t8, n15, a16 = 0, i12 = false, r14 = 4) {
  if (n15.values) return true;
  const s6 = n15.type, l6 = n15.valueCount;
  let o13 = n15.valueOffset, f6 = [];
  const u11 = h2[s6], c6 = 8 * u11, E3 = l6 * u11, I4 = l6 * h2[s6] * 8;
  let T4, w5;
  const p5 = 8 === r14 ? 64 : 32, d5 = n15.valueOffsets;
  if (I4 > p5) {
    if (E3 > (i12 ? e7.byteLength : e7 ? e7.byteLength - o13 + a16 : 0)) return n15.offlineOffsetSize = [o13, E3], n15.values = null, false;
  }
  if (I4 <= p5) {
    if (!t8) if (p5 <= 32) o13 >>>= 32 - I4;
    else {
      const e8 = d5?.length ? d5[0] : o13 >>> 0, t9 = d5?.length ? d5[1] : Math.round((o13 - e8) / g2);
      I4 <= 32 ? (o13 = e8 >>> 32 - I4, d5[0] = o13) : (o13 = e8 * 2 ** (32 - I4) + (t9 >>> 32 - I4), d5[0] = e8, d5[1] = t9 >>> 32 - I4);
    }
    if (1 === l6 && c6 === p5) f6 = [o13];
    else if (64 === p5) {
      const e8 = d5?.length ? d5[0] : o13 >>> 0, t9 = d5?.length ? d5[1] : Math.round((o13 - e8) / g2);
      let n16 = e8, a17 = 32;
      for (w5 = 1; w5 <= l6; w5++) {
        const e9 = 32 - c6 * w5 % 32;
        if (a17 < c6) {
          const i13 = n16 << e9 >>> 32 - a17, r15 = t9 << 32 - a17 >>> 32 - a17;
          n16 = t9, f6.push(i13 + r15 * 2 ** (c6 - a17)), a17 -= 32 - (c6 - a17);
        } else f6.push(n16 << e9 >>> 32 - c6), a17 -= c6;
        0 === a17 && (a17 = 32, n16 = t9);
      }
    } else for (w5 = 1; w5 <= l6; w5++) {
      const e8 = 32 - c6 * w5;
      f6.push(o13 << e8 >>> 32 - c6);
    }
  } else {
    o13 -= a16, i12 && (o13 = 0);
    for (let n16 = o13; n16 < o13 + E3; n16 += u11) {
      switch (s6) {
        case 1:
        case 2:
        case 7:
          T4 = new DataView(e7, n16, 1).getUint8(0);
          break;
        case 3:
          T4 = new DataView(e7, n16, 2).getUint16(0, t8);
          break;
        case 4:
        case 13:
          T4 = new DataView(e7, n16, 4).getUint32(0, t8);
          break;
        case 5:
          T4 = new DataView(e7, n16, 4).getUint32(0, t8) / new DataView(e7, n16 + 4, 4).getUint32(0, t8);
          break;
        case 6:
          T4 = new DataView(e7, n16, 1).getInt8(0);
          break;
        case 8:
          T4 = new DataView(e7, n16, 2).getInt16(0, t8);
          break;
        case 9:
          T4 = new DataView(e7, n16, 4).getInt32(0, t8);
          break;
        case 10:
          T4 = new DataView(e7, n16, 4).getInt32(0, t8) / new DataView(e7, n16 + 4, 4).getInt32(0, t8);
          break;
        case 11:
          T4 = new DataView(e7, n16, 4).getFloat32(0, t8);
          break;
        case 12:
          T4 = new DataView(e7, n16, 8).getFloat64(0, t8);
          break;
        case 16:
        case 18:
          T4 = B2(new DataView(e7, n16, 8), 0, t8);
          break;
        case 17:
          T4 = V(new DataView(e7, n16, 8), 0, t8);
          break;
        default:
          T4 = null;
      }
      f6.push(T4);
    }
  }
  if (2 === s6) {
    let e8 = "";
    const t9 = f6;
    for (f6 = [], w5 = 0; w5 < t9.length; w5++) 0 === t9[w5] && "" !== e8 ? (f6.push(e8), e8 = "") : e8 += String.fromCharCode(t9[w5]);
    "" === e8 && 0 !== f6.length || f6.push(e8);
  }
  return n15.values = f6, true;
}
function k(e7) {
  const t8 = e7[0], n15 = y(t8, "TILEWIDTH"), a16 = y(t8, "TILELENGTH"), i12 = y(t8, "IMAGEWIDTH"), r14 = y(t8, "IMAGELENGTH"), s6 = y(t8, "BITSPERSAMPLE"), l6 = y(t8, "SAMPLESPERPIXEL"), o13 = y(t8, "SAMPLEFORMAT") ?? 1, f6 = I(o13, s6), u11 = C2(t8), c6 = p2(t8, "GDAL_NODATA");
  let h6 = null;
  c6?.length && (h6 = c6.map((e8) => parseFloat(e8)), h6.some((e8) => isNaN(e8)) && (h6 = null));
  const g4 = y(t8, "COMPRESSION") ?? 1;
  let T4;
  switch (g4) {
    case 1:
      T4 = "NONE";
      break;
    case 2:
    case 3:
    case 4:
    case 32771:
      T4 = "CCITT";
      break;
    case 5:
      T4 = "LZW";
      break;
    case 6:
    case 7:
      T4 = "JPEG";
      break;
    case 32773:
      T4 = "PACKBITS";
      break;
    case 8:
    case 32946:
      T4 = "DEFLATE";
      break;
    case 34712:
      T4 = "JPEG2000";
      break;
    case 34887:
      T4 = "LERC";
      break;
    default:
      T4 = String(g4);
  }
  let A4 = true, S4 = "";
  E2.has(g4) || (A4 = false, S4 += "unsupported tag compression " + g4), o13 > 3 && (A4 = false, S4 += "unsupported tag sampleFormat " + o13), s6 > 32 && 64 !== s6 && (A4 = false, S4 += "unsupported tag bitsPerSample " + s6);
  const M4 = m2(t8, "GEOASCIIPARAMS");
  let P4;
  if (M4) {
    const e8 = M4.split("|").find((e9) => e9.includes("ESRI PE String = ")), t9 = e8 ? e8.replace("ESRI PE String = ", "") : "";
    P4 = t9.startsWith("COMPD_CS") || t9.startsWith("PROJCS") || t9.startsWith("GEOGCS") ? { wkid: null, wkt: t9 } : null;
  }
  const O5 = d(t8, "GEOTIEPOINTS"), b5 = d(t8, "GEOPIXELSCALE"), x4 = d(t8, "GEOTRANSMATRIX"), L3 = t8.has("GEOKEYDIRECTORY") ? t8.get("GEOKEYDIRECTORY").data : null;
  let D4, R4, N2 = false, k5 = false;
  if (L3) {
    N2 = 2 === y(L3, "GTRasterTypeGeoKey");
    const e8 = y(L3, "GTModelTypeGeoKey");
    if (2 === e8) {
      const e9 = y(L3, "GeographicTypeGeoKey");
      e9 >= 1024 && e9 <= 32766 && (P4 = { wkid: e9 }), P4 || 32767 !== e9 || (k5 = true, P4 = { wkid: 4326 });
    } else if (1 === e8) {
      const e9 = y(L3, "ProjectedCSTypeGeoKey");
      e9 >= 1024 && e9 <= 32766 && (P4 = { wkid: e9 });
    }
  }
  if (b5 && O5 && O5.length >= 6 ? (D4 = [b5[0], 0, O5[3] - O5[0] * b5[0], 0, -Math.abs(b5[1]), O5[4] - O5[1] * b5[1]], N2 && (D4[2] -= 0.5 * D4[0] + 0.5 * D4[1], D4[5] -= 0.5 * D4[3] + 0.5 * D4[4])) : x4 && 16 === x4.length && (D4 = N2 ? [x4[0], x4[1], x4[3] - 0.5 * x4[0], x4[4], x4[5], x4[7] - 0.5 * x4[5]] : [x4[0], x4[1], x4[3], x4[4], x4[5], x4[7]]), D4) {
    const e8 = [{ x: 0, y: r14 }, { x: 0, y: 0 }, { x: i12, y: r14 }, { x: i12, y: 0 }];
    let t9, n16 = Number.POSITIVE_INFINITY, a17 = Number.POSITIVE_INFINITY, s7 = Number.NEGATIVE_INFINITY, l7 = Number.NEGATIVE_INFINITY;
    for (let i13 = 0; i13 < e8.length; i13++) t9 = w(e8[i13], D4), n16 = t9.x > n16 ? n16 : t9.x, s7 = t9.x < s7 ? s7 : t9.x, a17 = t9.y > a17 ? a17 : t9.y, l7 = t9.y < l7 ? l7 : t9.y;
    R4 = { xmin: n16, xmax: s7, ymin: a17, ymax: l7, spatialReference: P4 };
  } else R4 = { xmin: -0.5, ymin: 0.5 - r14, xmax: i12 - 0.5, ymax: 0.5, spatialReference: P4 };
  k5 && (R4.xmax - R4.xmin > 400 || Math.max(Math.abs(R4.xmin), Math.abs(R4.xmax)) > 361) && (P4 = null, R4.spatialReference = null);
  const F2 = G(e7);
  let B4, V3, W2, H2, Y2;
  if (F2.length > 0) {
    W2 = Math.round(Math.log(i12 / y(F2[0], "IMAGEWIDTH")) / Math.LN2);
    const e8 = F2[F2.length - 1];
    H2 = F2.length, B4 = y(e8, "TILEWIDTH"), V3 = y(e8, "TILELENGTH");
  }
  B4 = null != H2 && H2 > 0 ? B4 || n15 : null, V3 = null != H2 && H2 > 0 ? V3 || a16 : null, n15 && (Y2 = [{ maxCol: Math.ceil(i12 / n15) - 1, maxRow: Math.ceil(r14 / a16) - 1, minRow: 0, minCol: 0 }], F2.forEach((e8) => {
    Y2.push({ maxCol: Math.ceil(y(e8, "IMAGEWIDTH") / y(e8, "TILEWIDTH")) - 1, maxRow: Math.ceil(y(e8, "IMAGELENGTH") / y(e8, "TILELENGTH")) - 1, minRow: 0, minCol: 0 });
  }));
  const j3 = m2(e7[0], "GDAL_METADATA"), X2 = U2(j3);
  S4 += " " + _2({ width: i12, height: r14, tileWidth: n15, tileHeight: a16, planes: l6, ifds: e7 });
  const K2 = v(e7).length === F2.length + 1, J = F2?.length ? F2.map((e8) => ({ x: i12 / y(e8, "IMAGEWIDTH"), y: r14 / y(e8, "IMAGELENGTH") })) : void 0;
  return { width: i12, height: r14, tileWidth: n15, tileHeight: a16, planes: l6, isBSQ: u11, pixelType: f6, compression: T4, noData: h6, hasMaskBand: K2, isSupported: A4, pyramidResolutions: J, message: S4, extent: R4, isPseudoGeographic: k5, affine: b5 ? null : D4, firstPyramidLevel: W2, maximumPyramidLevel: H2, pyramidBlockWidth: B4, pyramidBlockHeight: V3, tileBoundary: Y2, metadata: X2 };
}
function C2(e7, t8) {
  const n15 = p2(e7, "PLANARCONFIGURATION");
  return n15 ? 2 === n15[0] : !!t8 && t8.isBSQ;
}
function G(e7) {
  return e7.filter((e8) => 1 === y(e8, "NEWSUBFILETYPE"));
}
function v(e7) {
  return e7.filter((e8) => {
    const t8 = !(4 & ~(y(e8, "NEWSUBFILETYPE") ?? 0)), n15 = 4 === y(e8, "PHOTOMETRICINTERPRETATION");
    return t8 && n15;
  });
}
function F(e7) {
  const { littleEndian: t8, isBigTiff: n15, firstIFDPos: a16 } = H(e7);
  let i12 = a16;
  const r14 = [];
  do {
    const a17 = Y(e7, t8, i12, 0, e5, n15 ? 8 : 4);
    if (!a17.success) break;
    r14.push(a17.ifd), i12 = a17.nextIFD;
  } while (i12 > 0);
  return { ...k(r14), littleEndian: t8, isBigTiff: n15, ifds: r14, pyramidIFDs: G(r14), maskIFDs: v(r14) };
}
function B2(e7, t8, n15) {
  const a16 = e7.getUint32(t8, n15), i12 = e7.getUint32(t8 + 4, n15);
  return n15 ? i12 * g2 + a16 : a16 * g2 + i12;
}
function V(e7, t8, n15) {
  let a16 = n15 ? e7.getInt32(t8, n15) : e7.getUint32(t8, n15), i12 = n15 ? e7.getUint32(t8 + 4, n15) : e7.getInt32(t8 + 4, n15);
  const r14 = (n15 ? a16 : i12) >= 0 ? 1 : -1;
  n15 ? a16 *= r14 : i12 *= r14;
  return r14 * (n15 ? i12 * g2 + a16 : a16 * g2 + i12);
}
function W(e7, t8, n15, a16) {
  return a16 ? B2(e7, t8, n15) : e7.getUint32(t8, n15);
}
function H(e7) {
  const t8 = new DataView(e7, 0, 16), n15 = t8.getUint16(0, false);
  let a16 = null;
  if (18761 === n15) a16 = true;
  else {
    if (19789 !== n15) throw new Error("unexpected endianess byte");
    a16 = false;
  }
  const i12 = t8.getUint16(2, a16);
  if (42 !== i12 && 43 !== i12) throw new Error("unexpected tiff identifier");
  let r14 = 4;
  const s6 = 43 === i12;
  if (s6) {
    const e8 = t8.getUint16(r14, a16);
    if (r14 += 2, 8 !== e8) throw new Error("unsupported bigtiff version");
    if (0 !== t8.getUint16(r14, a16)) throw new Error("unsupported bigtiff version");
    r14 += 2;
  }
  return { littleEndian: a16, isBigTiff: s6, firstIFDPos: W(t8, r14, a16, s6) };
}
function Y(t8, n15, a16, i12 = 0, r14 = e5, o13 = 4) {
  const u11 = A(t8, n15, a16, i12, r14, o13);
  let c6;
  const h6 = u11.ifd;
  if (h6) {
    if (E.forEach((e7, a17) => {
      h6.has(a17) && (c6 = h6.get(a17), c6.data = A(t8, n15, c6.valueOffset - i12, i12, e7).ifd);
    }), h6.has("GEOKEYDIRECTORY")) {
      c6 = h6.get("GEOKEYDIRECTORY");
      const e7 = c6.values;
      if (e7 && e7.length > 4) {
        const a17 = e7[0] + "." + e7[1] + "." + e7[2];
        c6.data = A(t8, n15, c6.valueOffset + 6 - i12, i12, t5, 2).ifd, c6.data && c6.data.set("GEOTIFFVersion", { id: 0, type: 2, valueCount: 1, valueOffset: null, values: [a17] });
      }
    }
    if (h6.has("XMP")) {
      c6 = h6.get("XMP");
      const t9 = c6.values;
      "number" == typeof t9[0] && 7 === c6.type && (c6.values = [r9(new Uint8Array(t9))]);
    }
  }
  return u11;
}
function _2(e7) {
  const { width: t8, height: n15, tileHeight: a16, tileWidth: i12 } = e7, r14 = e7.planes, s6 = i12 ? i12 * a16 : t8 * n15, l6 = y(e7.ifds[0], "BITSPERSAMPLE");
  let o13 = "";
  return s6 * r14 > 2 ** 30 / (l6 > 8 ? l6 / 8 : 1) && (o13 = i12 ? "tiled tiff exceeding 1 gigabits per tile is not supported" : "scanline tiff exceeding 1 gigabits is not supported"), o13;
}
function j(e7, t8, n15, a16, i12) {
  const r14 = a16 ? 4 : 1, s6 = n15 * r14 * i12;
  a16 && (e7 = new Uint8Array(e7.buffer));
  for (let f6 = 0; f6 < t8; f6++) {
    const t9 = f6 * s6;
    for (let n16 = i12; n16 < s6; n16++) e7[t9 + n16] += e7[t9 + n16 - i12];
  }
  if (!a16) return e7;
  const l6 = new Uint8Array(e7.length), o13 = n15 * i12;
  for (let f6 = 0; f6 < t8; f6++) {
    const t9 = f6 * s6;
    for (let n16 = 0; n16 < o13; n16++) for (let a17 = 0; a17 < r14; a17++) l6[t9 + n16 * r14 + a17] = e7[t9 + n16 + (r14 - a17 - 1) * o13];
  }
  return new Float32Array(l6.buffer);
}
async function X(e7, t8) {
  const { headerInfo: n15, ifd: a16, offsets: i12, sizes: s6 } = t8, l6 = [];
  for (let r14 = 0; r14 < i12.length; r14++) {
    s6[r14];
    const t9 = await x(e7, n15.littleEndian, a16, i12[r14], s6[r14] || e7.byteLength);
    l6.push(t9);
  }
  const o13 = C2(a16, n15), f6 = y(a16, "BITSPERSAMPLE"), u11 = I(y(a16, "SAMPLEFORMAT") ?? 1, f6), c6 = y(a16, "SAMPLESPERPIXEL") || n15.planes, h6 = T(u11), g4 = y(a16, "TILEWIDTH"), E3 = y(a16, "TILELENGTH"), w5 = y(a16, "COMPRESSION") ?? 1, p5 = g4 * E3;
  let d5;
  const m6 = [];
  let A4 = l6[0];
  const S4 = 34887 === w5;
  for (let r14 = 0; r14 < c6; r14++) {
    if (d5 = new h6(p5), l6.length === c6) A4 = l6[r14], A4.length === p5 && (d5 = A4);
    else if (A4.length) if (o13 || S4) d5 = A4.length === p5 ? A4 : A4.slice(p5 * r14, p5 * (r14 + 1));
    else for (let e8 = 0; e8 < p5; e8++) d5[e8] = A4[e8 * c6 + r14];
    m6.push(d5);
  }
  const M4 = n15.noData ? n15.noData[0] : t8.noDataValue, P4 = n15.metadata ? n15.metadata.statistics : null, O5 = P4 ? P4.map((e8) => e8.min) : null, b5 = P4 ? P4.map((e8) => e8.max) : null, L3 = { pixelType: u11, width: g4, height: E3, pixels: m6, noDataValue: M4 };
  return null != M4 ? g(L3, M4, { matchAllNoData: t8?.matchAllNoData }) : O5 && b5 && t8.applyMinMaxConstraint && (L3.mask = R(m6, O5, b5)), L3;
}
async function K(e7, t8 = {}) {
  const n15 = t8.pyramidLevel || 0, a16 = t8.headerInfo || F(e7), { ifds: i12, noData: s6 } = a16;
  if (0 === i12.length) throw new Error("no valid image file directory");
  const l6 = _2(a16);
  if (l6) throw l6;
  let o13 = null;
  const f6 = -1 === n15 ? i12[i12.length - 1] : i12[n15], u11 = s6 ?? t8.noDataValue;
  if (o13 = a16.tileWidth ? await L(e7, a16, f6) : D(e7, a16, f6), !o13) return o13;
  if (null != u11) {
    g(o13, u11, { matchAllNoData: null == s6 && t8?.matchAllNoData });
  }
  return o13;
}

// node_modules/@arcgis/core/layers/support/rasterFormats/RasterCodec.js
var w2 = (function(t8) {
  var e7, a16, i12, s6, r14, n15;
  function o13(t9) {
    var e8, a17, i13, s7, r15, n16, o14, h6, c6, l6, p5, d5, u11;
    for (this.data = t9, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, r15 = null; ; ) {
      switch (e8 = this.readUInt32(), h6 = (function() {
        var t10, e9;
        for (e9 = [], t10 = 0; t10 < 4; ++t10) e9.push(String.fromCharCode(this.data[this.pos++]));
        return e9;
      }).call(this).join(""), h6) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(e8);
          break;
        case "fcTL":
          r15 && this.animation.frames.push(r15), this.pos += 4, r15 = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, s7 = this.readUInt16(), i13 = this.readUInt16() || 100, r15.delay = 1e3 * s7 / i13, r15.disposeOp = this.data[this.pos++], r15.blendOp = this.data[this.pos++], r15.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for ("fdAT" === h6 && (this.pos += 4, e8 -= 4), t9 = (null != r15 ? r15.data : void 0) || this.imgData, p5 = 0; 0 <= e8 ? p5 < e8 : p5 > e8; 0 <= e8 ? ++p5 : --p5) t9.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (this.transparency.indexed = this.read(e8), (c6 = 255 - this.transparency.indexed.length) > 0) for (d5 = 0; 0 <= c6 ? d5 < c6 : d5 > c6; 0 <= c6 ? ++d5 : --d5) this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(e8)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(e8);
          }
          break;
        case "tEXt":
          n16 = (l6 = this.read(e8)).indexOf(0), o14 = String.fromCharCode.apply(String, l6.slice(0, n16)), this.text[o14] = String.fromCharCode.apply(String, l6.slice(n16 + 1));
          break;
        case "IEND":
          return r15 && this.animation.frames.push(r15), this.colors = (function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }).call(this), this.hasAlphaChannel = 4 === (u11 = this.colorType) || 6 === u11, a17 = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * a17, this.colorSpace = (function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }).call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += e8;
      }
      if (this.pos += 4, this.pos > this.data.length) throw new Error("Incomplete or corrupt PNG file");
    }
  }
  return o13.load = function(t9, e8, a17) {
    var i13;
    return "function" == typeof e8 && (a17 = e8), (i13 = new XMLHttpRequest()).open("GET", t9, true), i13.responseType = "arraybuffer", i13.onload = function() {
      var t10;
      return t10 = new o13(new Uint8Array(i13.response || i13.mozResponseArrayBuffer)), "function" == typeof (null != e8 ? e8.getContext : void 0) && t10.render(e8), "function" == typeof a17 ? a17(t10) : void 0;
    }, i13.send(null);
  }, a16 = 1, i12 = 2, e7 = 0, o13.prototype.read = function(t9) {
    var e8, a17;
    for (a17 = [], e8 = 0; 0 <= t9 ? e8 < t9 : e8 > t9; 0 <= t9 ? ++e8 : --e8) a17.push(this.data[this.pos++]);
    return a17;
  }, o13.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, o13.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, o13.prototype.decodePixels = function(t9) {
    var e8, a17, i13, s7, r15, n16, o14, h6, c6, p5, d5, u11, f6, m6, g4, w5, y5, b5, x4, k5, T4, C5, I4;
    if (null == t9 && (t9 = this.imgData), 0 === t9.length) return new Uint8Array(0);
    for (t9 = (t9 = new s2(t9)).getBytes(), w5 = (u11 = this.pixelBitlength / 8) * this.width, f6 = new Uint8Array(w5 * this.height), n16 = t9.length, g4 = 0, m6 = 0, a17 = 0; m6 < n16; ) {
      switch (t9[m6++]) {
        case 0:
          for (s7 = x4 = 0; x4 < w5; s7 = x4 += 1) f6[a17++] = t9[m6++];
          break;
        case 1:
          for (s7 = k5 = 0; k5 < w5; s7 = k5 += 1) e8 = t9[m6++], r15 = s7 < u11 ? 0 : f6[a17 - u11], f6[a17++] = (e8 + r15) % 256;
          break;
        case 2:
          for (s7 = T4 = 0; T4 < w5; s7 = T4 += 1) e8 = t9[m6++], i13 = (s7 - s7 % u11) / u11, y5 = g4 && f6[(g4 - 1) * w5 + i13 * u11 + s7 % u11], f6[a17++] = (y5 + e8) % 256;
          break;
        case 3:
          for (s7 = C5 = 0; C5 < w5; s7 = C5 += 1) e8 = t9[m6++], i13 = (s7 - s7 % u11) / u11, r15 = s7 < u11 ? 0 : f6[a17 - u11], y5 = g4 && f6[(g4 - 1) * w5 + i13 * u11 + s7 % u11], f6[a17++] = (e8 + Math.floor((r15 + y5) / 2)) % 256;
          break;
        case 4:
          for (s7 = I4 = 0; I4 < w5; s7 = I4 += 1) e8 = t9[m6++], i13 = (s7 - s7 % u11) / u11, r15 = s7 < u11 ? 0 : f6[a17 - u11], 0 === g4 ? y5 = b5 = 0 : (y5 = f6[(g4 - 1) * w5 + i13 * u11 + s7 % u11], b5 = i13 && f6[(g4 - 1) * w5 + (i13 - 1) * u11 + s7 % u11]), o14 = r15 + y5 - b5, h6 = Math.abs(o14 - r15), p5 = Math.abs(o14 - y5), d5 = Math.abs(o14 - b5), c6 = h6 <= p5 && h6 <= d5 ? r15 : p5 <= d5 ? y5 : b5, f6[a17++] = (e8 + c6) % 256;
          break;
        default:
          throw new Error("Invalid filter algorithm: " + t9[m6 - 1]);
      }
      g4++;
    }
    return f6;
  }, o13.prototype.decodePalette = function() {
    var t9, e8, a17, i13, s7, r15, n16, o14, h6;
    for (a17 = this.palette, r15 = this.transparency.indexed || [], s7 = new Uint8Array((r15.length || 0) + a17.length), i13 = 0, a17.length, t9 = 0, e8 = n16 = 0, o14 = a17.length; n16 < o14; e8 = n16 += 3) s7[i13++] = a17[e8], s7[i13++] = a17[e8 + 1], s7[i13++] = a17[e8 + 2], s7[i13++] = null != (h6 = r15[t9++]) ? h6 : 255;
    return s7;
  }, o13.prototype.copyToImageData = function(t9, e8) {
    var a17, i13, s7, r15, n16, o14, h6, c6, l6, p5, d5;
    if (i13 = this.colors, l6 = null, a17 = this.hasAlphaChannel, this.palette.length && (l6 = null != (d5 = this._decodedPalette) ? d5 : this._decodedPalette = this.decodePalette(), i13 = 4, a17 = true), c6 = (s7 = t9.data || t9).length, n16 = l6 || e8, r15 = o14 = 0, 1 === i13) for (; r15 < c6; ) h6 = l6 ? 4 * e8[r15 / 4] : o14, p5 = n16[h6++], s7[r15++] = p5, s7[r15++] = p5, s7[r15++] = p5, s7[r15++] = a17 ? n16[h6++] : this.transparency.grayscale && this.transparency.grayscale === p5 ? 0 : 255, o14 = h6;
    else for (; r15 < c6; ) h6 = l6 ? 4 * e8[r15 / 4] : o14, s7[r15++] = n16[h6++], s7[r15++] = n16[h6++], s7[r15++] = n16[h6++], s7[r15++] = a17 ? n16[h6++] : this.transparency.rgb && this.transparency.rgb[1] === n16[h6 - 3] && this.transparency.rgb[3] === n16[h6 - 2] && this.transparency.rgb[5] === n16[h6 - 1] ? 0 : 255, o14 = h6;
  }, o13.prototype.decode = function() {
    var t9;
    return t9 = new Uint8Array(this.width * this.height * 4), this.copyToImageData(t9, this.decodePixels()), t9;
  }, r14 = t8.document && t8.document.createElement("canvas"), n15 = r14 && r14.getContext("2d"), s6 = function(t9) {
    var e8;
    return n15.width = t9.width, n15.height = t9.height, n15.clearRect(0, 0, t9.width, t9.height), n15.putImageData(t9, 0, 0), (e8 = new Image()).src = r14.toDataURL(), e8;
  }, o13.prototype.decodeFrames = function(t9) {
    var e8, a17, i13, r15, n16, o14, h6, c6;
    if (this.animation) {
      for (c6 = [], a17 = n16 = 0, o14 = (h6 = this.animation.frames).length; n16 < o14; a17 = ++n16) e8 = h6[a17], i13 = t9.createImageData(e8.width, e8.height), r15 = this.decodePixels(new Uint8Array(e8.data)), this.copyToImageData(i13, r15), e8.imageData = i13, c6.push(e8.image = s6(i13));
      return c6;
    }
  }, o13.prototype.renderFrame = function(t9, s7) {
    var r15, n16, o14;
    return r15 = (n16 = this.animation.frames)[s7], o14 = n16[s7 - 1], 0 === s7 && t9.clearRect(0, 0, this.width, this.height), (null != o14 ? o14.disposeOp : void 0) === a16 ? t9.clearRect(o14.xOffset, o14.yOffset, o14.width, o14.height) : (null != o14 ? o14.disposeOp : void 0) === i12 && t9.putImageData(o14.imageData, o14.xOffset, o14.yOffset), r15.blendOp === e7 && t9.clearRect(r15.xOffset, r15.yOffset, r15.width, r15.height), t9.drawImage(r15.image, r15.xOffset, r15.yOffset);
  }, o13.prototype.animate = function(t9) {
    var e8, a17, i13, s7, r15, n16, o14 = this;
    return a17 = 0, n16 = this.animation, s7 = n16.numFrames, i13 = n16.frames, r15 = n16.numPlays, (e8 = function() {
      var n17, h6;
      if (n17 = a17++ % s7, h6 = i13[n17], o14.renderFrame(t9, n17), s7 > 1 && a17 / s7 < r15) return o14.animation._timeout = setTimeout(e8, h6.delay);
    })();
  }, o13.prototype.stopAnimation = function() {
    var t9;
    return clearTimeout(null != (t9 = this.animation) ? t9._timeout : void 0);
  }, o13.prototype.render = function(t9) {
    var e8, a17;
    return t9._png && t9._png.stopAnimation(), t9._png = this, t9.width = this.width, t9.height = this.height, e8 = t9.getContext("2d"), this.animation ? (this.decodeFrames(e8), this.animate(e8)) : (a17 = e8.createImageData(this.width, this.height), this.copyToImageData(a17, this.decodePixels()), e8.putImageData(a17, 0, 0));
  }, o13;
})(self);
var y2 = /* @__PURE__ */ new Set(["jpg", "png", "bmp", "gif"]);
async function b2(e7, s6) {
  if (!r10) throw new s("rasterCoded:decode", "lerc decoder is not supported on big endian platform");
  await r5();
  const { offset: r14 } = s6, { width: h6, height: c6, pixelType: l6, statistics: p5, depthCount: d5, noDataValues: u11, bandMasks: f6, pixels: m6, mask: w5 } = u3(e7, { inputOffset: r14, returnInterleaved: s6.returnInterleaved }), y5 = new c({ width: h6, height: c6, pixelType: l6.toLowerCase(), pixels: m6, mask: w5, statistics: p5.map(({ minValue: t8, maxValue: e8 }) => new l(t8, e8)), bandMasks: f6, depthCount: d5, noDataValues: u11 });
  return p5?.length || y5.updateStatistics(), y5;
}
async function x2(e7, i12) {
  await o7();
  const s6 = c2(e7);
  if (!s6) throw new s("rasterCodec:decode", "failed to decode the input data.");
  const { width: r14, height: n15, pixels: o13 } = s6, h6 = new c({ width: r14, height: n15, pixelType: "u16", pixels: o13 });
  return h6.updateStatistics(), h6;
}
async function k2(t8, i12) {
  const s6 = await K(t8, { ...i12, noDataValue: i12.tiffNoDataValue, matchAllNoData: i12.matchAllNoData });
  n(s6);
  const r14 = new c({ width: s6.width, height: s6.height, pixels: s6.pixels, pixelType: s6.pixelType.toLowerCase(), mask: s6.mask, bandMasks: s6.bandMasks, statistics: null });
  return r14.updateStatistics(), r14;
}
async function T2(t8, e7) {
  const i12 = await X(t8, e7.customOptions), s6 = new c({ width: i12.width, height: i12.height, pixels: i12.pixels, pixelType: i12.pixelType.toLowerCase(), mask: i12.mask, statistics: null });
  return s6.updateStatistics(), s6;
}
function C3(t8, e7) {
  const i12 = e7.pixelType || "u8", s6 = c.getPixelArrayConstructor(i12), r14 = "u8" === i12 ? t8 : new s6(t8.buffer), n15 = [], o13 = e7.planes || 1;
  if (1 === o13) n15.push(r14);
  else for (let a16 = 0; a16 < o13; a16++) {
    const i13 = (e7.width || 1) * (e7.height || t8.length), h7 = new s6(i13);
    for (let t9 = 0; t9 < i13; t9++) h7[t9] = r14[t9 * o13 + a16];
    n15.push(h7);
  }
  const h6 = new c({ width: e7.width || 1, height: e7.height || t8.length, pixels: n15, pixelType: i12, statistics: null });
  return h6.updateStatistics(), h6;
}
function I2(t8, e7) {
  return C3(new s2(new Uint8Array(t8)).getBytes(), e7);
}
function A2(t8, e7) {
  return C3(i6(t8, e7.offset, e7.eof, !e7.isInputBigEndian), e7);
}
function v2(t8, e7, i12) {
  const { pixelTypeCtor: s6 } = P2(e7.pixelType), r14 = (0, a8.decode)(t8, { width: e7.width, height: e7.height, pixelType: s6, format: i12 }), n15 = new c({ width: e7.width, height: e7.height, pixels: r14.pixels, pixelType: e7.pixelType, mask: r14.mask, statistics: null });
  return n15.updateStatistics(), n15;
}
function D2(t8, e7) {
  const i12 = r4.decode(t8, e7.hasNoZlibMask ?? void 0), s6 = new c({ width: i12.width, height: i12.height, pixels: i12.pixels, pixelType: "u8", mask: i12.mask, statistics: null });
  return s6.updateStatistics(), s6;
}
function U3(t8, e7) {
  const i12 = new Uint8Array(t8), s6 = new w2(i12), { width: r14, height: n15 } = e7, o13 = r14 * n15, h6 = s6.decode();
  let c6, l6 = 0, p5 = 0;
  const d5 = new Uint8Array(o13);
  for (l6 = 0; l6 < o13; l6++) d5[l6] = h6[4 * l6 + 3];
  const u11 = new c({ width: r14, height: n15, pixels: [], pixelType: "u8", mask: d5, statistics: [] });
  for (l6 = 0; l6 < 3; l6++) {
    for (c6 = new Uint8Array(o13), p5 = 0; p5 < o13; p5++) c6[p5] = h6[4 * p5 + l6];
    u11.addData({ pixels: c6 });
  }
  return u11.updateStatistics(), u11;
}
async function S3(t8, e7, i12, r14) {
  const n15 = new i4(), o13 = { applyJpegMask: false, format: e7, ...i12 }, h6 = await n15.decode(t8, o13, r14), c6 = new c(h6);
  return c6.updateStatistics(), c6;
}
function j2(e7) {
  if (null == e7) throw new s("rasterCodec:decode", "parameter encodeddata is required.");
  const a16 = new Uint8Array(e7, 0, 10);
  let i12 = "";
  return 255 === a16[0] && 216 === a16[1] ? i12 = "jpg" : 137 === a16[0] && 80 === a16[1] && 78 === a16[2] && 71 === a16[3] ? i12 = "png" : 67 === a16[0] && 110 === a16[1] && 116 === a16[2] && 90 === a16[3] && 73 === a16[4] && 109 === a16[5] && 97 === a16[6] && 103 === a16[7] && 101 === a16[8] && 32 === a16[9] ? i12 = "lerc" : 76 === a16[0] && 101 === a16[1] && 114 === a16[2] && 99 === a16[3] && 50 === a16[4] && 32 === a16[5] ? i12 = "lerc2" : 73 === a16[0] && 73 === a16[1] && 42 === a16[2] && 0 === a16[3] || 77 === a16[0] && 77 === a16[1] && 0 === a16[2] && 42 === a16[3] || 73 === a16[0] && 73 === a16[1] && 43 === a16[2] && 0 === a16[3] || 77 === a16[0] && 77 === a16[1] && 0 === a16[2] && 43 === a16[3] ? i12 = "tiff" : 71 === a16[0] && 73 === a16[1] && 70 === a16[2] ? i12 = "gif" : 66 === a16[0] && 77 === a16[1] ? i12 = "bmp" : 81 === a16[0] && 66 === a16[1] && 51 === a16[2] ? i12 = "qb3" : String.fromCharCode.apply(null, a16).toLowerCase().includes("error") && (i12 = "error"), i12;
}
function O2(e7) {
  let a16 = null;
  switch (e7) {
    case "lerc":
    case "lerc2":
      a16 = b2;
      break;
    case "jpg":
      a16 = D2;
      break;
    case "png":
      a16 = U3;
      break;
    case "bsq":
    case "bip":
      a16 = (t8, a17) => v2(t8, a17, e7);
      break;
    case "tiff":
      a16 = k2;
      break;
    case "deflate":
      a16 = I2;
      break;
    case "lzw":
      a16 = A2;
      break;
    case "qb3":
      a16 = x2;
      break;
    case "error":
      a16 = () => {
        throw new s("rasterCodec:decode", "input data contains error");
      };
      break;
    default:
      a16 = () => {
        throw new s("rasterCodec:decode", "unsupported raster format");
      };
  }
  return a16;
}
function P2(t8) {
  let e7 = null, a16 = null;
  switch (t8 ? t8.toLowerCase() : "f32") {
    case "u1":
    case "u2":
    case "u4":
    case "u8":
      a16 = 255, e7 = Uint8Array;
      break;
    case "u16":
      a16 = a16 || 65535, e7 = Uint16Array;
      break;
    case "u32":
      a16 = a16 || 2 ** 32 - 1, e7 = Uint32Array;
      break;
    case "s8":
      a16 = a16 || -128, e7 = Int8Array;
      break;
    case "s16":
      a16 = a16 || -32768, e7 = Int16Array;
      break;
    case "s32":
      a16 = a16 || 0 - 2 ** 31, e7 = Int32Array;
      break;
    default:
      e7 = Float32Array;
  }
  return { pixelTypeCtor: e7, noDataValue: a16 };
}
function M2(t8, e7 = 1) {
  if (!t8) return;
  const { pixels: i12, width: s6, height: r14, mask: n15 } = t8;
  if (!i12 || 0 === i12.length) return;
  const o13 = i12.length, h6 = s6 - 1, c6 = r14 - 1, l6 = [];
  let p5, d5, u11, f6, m6, g4, w5 = null;
  const y5 = c.getPixelArrayConstructor(t8.pixelType);
  if (0 === e7) {
    for (p5 = 0; p5 < o13; p5++) {
      for (m6 = i12[p5], g4 = new y5(h6 * c6), d5 = 0; d5 < c6; d5++) for (f6 = d5 * s6, u11 = 0; u11 < h6; u11++) g4[d5 * h6 + u11] = m6[f6 + u11];
      l6.push(g4);
    }
    if (null != n15) for (w5 = new Uint8Array(h6 * c6), d5 = 0; d5 < c6; d5++) for (f6 = d5 * s6, u11 = 0; u11 < h6; u11++) w5[d5 * h6 + u11] = n15[f6 + u11];
  } else {
    for (p5 = 0; p5 < o13; p5++) {
      for (m6 = i12[p5], g4 = new y5(h6 * c6), d5 = 0; d5 < c6; d5++) for (f6 = d5 * s6, u11 = 0; u11 < h6; u11++) g4[d5 * h6 + u11] = (m6[f6 + u11] + m6[f6 + u11 + 1] + m6[f6 + s6 + u11] + m6[f6 + s6 + u11 + 1]) / 4;
      l6.push(g4);
    }
    if (n15) for (w5 = new Uint8Array(h6 * c6), d5 = 0; d5 < c6; d5++) for (f6 = d5 * s6, u11 = 0; u11 < h6; u11++) w5[d5 * h6 + u11] = Math.min.apply(null, [n15[f6 + u11], n15[f6 + u11 + 1], n15[f6 + s6 + u11], n15[f6 + s6 + u11 + 1]]);
  }
  t8.width = h6, t8.height = c6, t8.mask = w5, t8.pixels = l6;
}
function L2(t8) {
  let e7 = j2(t8);
  return "lerc2" === e7 ? e7 = "lerc" : "error" === e7 && (e7 = ""), e7;
}
async function R2(e7, i12 = {}, s6) {
  if (null == e7) throw new s("rasterCodec:decode", "missing encodeddata parameter.");
  let r14 = i12.format?.toLowerCase();
  if (!("bsq" !== r14 && "bip" !== r14 || null != i12.width && null != i12.height)) throw new s("rasterCodec:decode", "requires width and height in options parameter.");
  if ("tiff" === r14 && i12.customOptions) return T2(e7, i12);
  if ((!r14 || "bsq" !== r14 && "bip" !== r14 && "deflate" !== r14 && "lzw" !== r14) && (r14 = j2(e7)), i12.useCanvas && y2.has(r14)) return S3(e7, r14, i12, s6);
  const n15 = O2(r14);
  let o13;
  i12.isPoint && (null != (i12 = { ...i12 }).width && i12.width++, null != i12.height && i12.height++);
  const { offsets: h6 } = i12;
  if (h6 && h6.length > 1) {
    const t8 = h6.map((t9, a16) => n15(e7.slice(t9, h6[a16 + 1]), i12)), s7 = await Promise.all(t8);
    o13 = s7[0], o13.pixels = s7.map((t9) => t9.pixels[0]);
    const r15 = s7.map((t9) => t9.mask);
    s7.some((t9) => null != t9) && (r15.forEach((t9, e8) => {
      null == t9 && (r15[e8] = new Uint8Array(o13.width * o13.height).fill(255));
    }), o13.bandMasks = r15, o13.mask = c.combineBandMasks(r15)), o13.updateStatistics();
  } else o13 = await n15(e7, { ...i12, offset: h6?.[0] ?? i12.offset });
  return "jpg" !== r14 && null != i12.noDataValue && 1 === o13.depthCount && g(o13, i12.noDataValue, { customFloatTolerance: i12.tolerance }), i12.isPoint && M2(o13), o13;
}

// node_modules/@arcgis/core/renderers/support/stretchRendererUtils.js
var n8 = new o({ none: "none", standardDeviation: "standard-deviation", histogramEqualization: "histogram-equalization", minMax: "min-max", percentClip: "percent-clip", sigmoid: "sigmoid" });
var a9 = { 0: "none", 3: "standardDeviation", 4: "histogramEqualization", 5: "minMax", 6: "percentClip", 9: "sigmoid" };

// node_modules/@arcgis/core/layers/support/rasterFunctions/stretchUtils.js
var i9 = 1;
var o9 = [0.299, 0.587, 0.114];
function a10(t8) {
  if (null == t8) return false;
  const { max: n15, min: e7, size: s6 } = t8;
  return (n15 - e7) / s6 === 1 && e7 >= -0.5 && 0.5 === Math.abs(e7 % 1) && n15 <= 255.5;
}
function r11(t8, n15 = 256) {
  const e7 = 255;
  n15 = Math.min(n15, e7 + 1);
  const { size: s6, counts: i12 } = t8, o13 = new Float64Array(s6);
  o13[0] = i12[0] / n15;
  for (let a16 = 1; a16 < s6; a16++) o13[a16] = o13[a16 - 1] + i12[a16] / n15;
  const r14 = new Uint8Array(n15), l6 = n15 / o13[o13.length - 1];
  if (s6 <= n15) {
    const i13 = a10(t8) ? Math.max(0, Math.round(t8.min + 0.5)) : 0;
    for (let t9 = i13; t9 < n15; t9++) r14[t9] = t9 >= s6 + i13 ? e7 : Math.min(e7, Math.trunc(o13[t9 - i13] * l6));
  } else {
    const t9 = o13.map((t10) => Math.min(255, Math.trunc(t10 * l6)));
    for (let e8 = 0; e8 < n15; e8++) r14[e8] = t9[Math.round(s6 / n15)];
    r14[n15 - 1] = 255;
  }
  return r14;
}
function l3(t8) {
  const { minCutOff: n15, maxCutOff: e7, gamma: s6, pixelType: i12, rounding: o13 } = t8;
  if (!["u8", "u16", "s8", "s16"].includes(i12)) return null;
  const a16 = n15.length, r14 = "s8" === i12 ? -127 : "s16" === i12 ? -32767 : 0, l6 = ["u16", "s16"].includes(i12) ? 65536 : 256, c6 = [], m6 = [], { minOutput: f6 = 0, maxOutput: h6 = 255 } = t8, d5 = h6 - f6;
  for (let u11 = 0; u11 < a16; u11++) m6[u11] = e7[u11] - n15[u11], c6[u11] = 0 === m6[u11] ? 0 : d5 / m6[u11];
  const g4 = [];
  if (s6 && s6.length >= a16) {
    const t9 = w3(a16, s6);
    for (let i13 = 0; i13 < a16; i13++) {
      const a17 = [];
      for (let u11 = 0; u11 < l6; u11++) {
        if (0 === m6[i13]) {
          a17[u11] = f6;
          continue;
        }
        const l7 = u11 + r14, c7 = (l7 - n15[i13]) / m6[i13];
        let g5 = 1;
        if (s6[i13] > 1 && (g5 -= (1 / d5) ** (c7 * t9[i13])), l7 < e7[i13] && l7 > n15[i13]) {
          const t10 = g5 * d5 * c7 ** (1 / s6[i13]) + f6;
          a17[u11] = "floor" === o13 ? Math.floor(t10) : "round" === o13 ? Math.round(t10) : t10;
        } else l7 >= e7[i13] ? a17[u11] = h6 : a17[u11] = f6;
      }
      g4[i13] = a17;
    }
  } else for (let u11 = 0; u11 < a16; u11++) {
    const t9 = [];
    for (let s7 = 0; s7 < l6; s7++) {
      const i13 = s7 + r14;
      if (i13 <= n15[u11]) t9[s7] = f6;
      else if (i13 >= e7[u11]) t9[s7] = h6;
      else {
        const e8 = (i13 - n15[u11]) * c6[u11] + f6;
        t9[s7] = "floor" === o13 ? Math.floor(e8) : "round" === o13 ? Math.round(e8) : e8;
      }
    }
    g4[u11] = t9;
  }
  if (null != t8.contrastOffset) {
    const n16 = u5(t8.contrastOffset, t8.brightnessOffset);
    for (let t9 = 0; t9 < a16; t9++) {
      const e8 = g4[t9];
      for (let t10 = 0; t10 < l6; t10++) e8[t10] = n16[e8[t10]];
    }
  }
  return { lut: g4, offset: r14 };
}
function u5(t8, n15) {
  const e7 = Math.min(Math.max(t8, -100), 100), s6 = Math.min(Math.max(n15 ?? 0, -100), 100), i12 = 255, o13 = 128, a16 = new Uint8Array(256);
  for (let r14 = 0; r14 < 256; r14++) {
    let t9 = 0;
    e7 > 0 && e7 < 100 ? t9 = (200 * r14 - 100 * i12 + 2 * i12 * s6) / (2 * (100 - e7)) + o13 : e7 <= 0 && e7 > -100 ? t9 = (200 * r14 - 100 * i12 + 2 * i12 * s6) * (100 + e7) / 2e4 + o13 : 100 === e7 ? (t9 = 200 * r14 - 100 * i12 + (i12 + 1) * (100 - e7) + 2 * i12 * s6, t9 = t9 > 0 ? i12 : 0) : -100 === e7 && (t9 = o13), a16[r14] = t9 > i12 ? i12 : t9 < 0 ? 0 : t9;
  }
  return a16;
}
function c3(t8, n15, e7) {
  const s6 = [];
  for (let i12 = 0; i12 < n15.length; i12++) {
    let a16 = 0, r14 = 0, l6 = 0;
    "min" in n15[i12] ? { min: a16, max: r14, avg: l6 } = n15[i12] : [a16, r14, l6] = n15[i12];
    let u11 = l6 ?? 0;
    "u8" !== t8 && (u11 = 255 * (u11 - a16) / (r14 - a16)), e7 && (u11 *= o9[i12]), s6.push(m3(u11));
  }
  return s6;
}
function m3(t8) {
  if (t8 <= 0 || t8 >= 255) return i9;
  const n15 = 255, e7 = t8 + (150 === t8 ? 0 : t8 < 150 ? 45 * Math.cos(0.01047 * t8) : 17 * Math.sin(0.021 * t8)), s6 = Math.log(t8 / n15), o13 = Math.log(e7 / n15);
  if (0 === o13) return i9;
  const a16 = s6 / o13;
  return isNaN(a16) ? i9 : Math.min(9.9, Math.max(0.01, a16));
}
function f3(t8, n15, e7) {
  let { min: s6, max: i12, count: o13, avg: a16, mode: r14, median: l6 } = d2(t8, n15, true);
  if (0 === o13) return { statistics: { min: 0, max: 0, avg: 0, stddev: 0, count: o13, mode: 0, median: 0 }, histogram: null };
  const u11 = { min: s6, max: i12, avg: a16, mode: r14, count: o13, median: l6 }, c6 = M3(t8, n15, a16, !e7.includeSkewnessKurtosis);
  c6 && (u11.stddev = c6.stddev, e7.includeSkewnessKurtosis && (u11.skewness = c6.skewness, u11.kurtosis = c6.kurtosis));
  const m6 = e7?.histogramSize ?? 256, f6 = !!e7?.pixelType && ["u8", "s8", "u4", "u2", "u1"].includes(e7.pixelType), g4 = !e7?.skipHistograms;
  if (null == l6) {
    const e8 = h3({ band: t8, mask: n15, min: s6, max: i12, size: 1e4, use8BitHistogram: f6 });
    if (l6 = x3(t8, n15, e8, 50), g4 && f6 && 256 === m6) return { statistics: u11, histogram: e8 };
  }
  if (!g4) return { statistics: u11, histogram: null };
  return { statistics: u11, histogram: h3({ band: t8, mask: n15, min: s6, max: i12, size: m6, use8BitHistogram: f6 && 256 === m6 }) };
}
function h3(t8) {
  const { band: n15, mask: e7, min: s6, max: i12, use8BitHistogram: o13 } = t8;
  if (o13) {
    const t9 = i12 - s6 + 1, o14 = new Uint32Array(t9);
    for (let i13 = 0; i13 < n15.length; i13++) e7 && !e7[i13] || o14[n15[i13] - s6]++;
    return { min: s6 - 0.5, max: i12 + 0.5, size: t9, counts: o14 };
  }
  const a16 = t8.size ?? 256, r14 = new Uint32Array(a16), l6 = (i12 - s6) / a16;
  if (0 === l6) {
    const t9 = e7 ? e7.reduce((t10, n16) => t10 + (n16 ? 1 : 0), 0) : n15.length;
    return { min: s6, max: i12, size: 1, counts: new Uint32Array(1).fill(t9) };
  }
  const u11 = new Uint32Array(a16 + 1), c6 = 1 / l6;
  for (let m6 = 0; m6 < n15.length; m6++) e7 && !e7[m6] || u11[Math.floor((n15[m6] - s6) * c6)]++;
  for (let m6 = 0; m6 < a16 - 1; m6++) r14[m6] = u11[m6];
  return r14[a16 - 1] = u11[a16 - 1] + u11[a16], { min: s6, max: i12, size: a16, counts: r14 };
}
function d2(t8, n15, e7 = false, s6 = false) {
  let i12 = 1 / 0, o13 = -1 / 0, a16 = 0, r14 = 0, l6 = 0, u11 = 0;
  const c6 = t8.length, m6 = /* @__PURE__ */ new Map();
  for (let p5 = 0; p5 < c6; p5++) {
    const e8 = t8[p5];
    if (!n15 || n15[p5]) {
      const t9 = (m6.get(e8) ?? 0) + 1;
      m6.set(e8, t9), t9 > u11 && (u11 = t9, l6 = e8), i12 = e8 < i12 ? e8 : i12, o13 = e8 > o13 ? e8 : o13, a16 += e8, r14++;
    }
  }
  const f6 = r14 > 0 ? a16 / r14 : 0;
  let h6 = i12 === o13 ? i12 : void 0, d5 = i12 === o13 ? i12 : void 0, g4 = i12 === o13 ? i12 : void 0;
  if (e7 && r14 > 0 && r14 < 2 ** 24) {
    let e8 = t8.slice();
    if (n15) {
      let s7 = 0;
      for (let i14 = 0; i14 < c6; i14++) {
        const o14 = t8[i14];
        n15[i14] && (e8[s7++] = o14);
      }
    }
    e8 = e8.slice(0, r14), e8.sort((t9, n16) => t9 - n16);
    const i13 = r14 >>> 1;
    h6 = r14 % 2 ? e8[Math.floor(i13)] : (e8[i13 - 1] + e8[i13]) / 2, s6 && (d5 = e8[Math.floor(0.25 * r14)], g4 = e8[Math.floor(0.75 * r14)]);
  }
  return { min: i12, max: o13, count: r14, avg: f6, mode: l6, median: h6, quartile1: d5, quartile3: g4 };
}
function x3(t8, n15, e7, s6 = 50) {
  const { counts: i12, min: o13, max: a16, size: r14 } = e7, l6 = i12.reduce((t9, n16) => t9 + n16) * (s6 /= 100);
  let u11 = 0, c6 = 0;
  for (; c6 < i12.length && (u11 += i12[c6], !(u11 >= l6 + 1)); c6++) ;
  const m6 = (a16 - o13) / r14, f6 = o13 + m6 * c6, h6 = o13 + m6 * (c6 + 1);
  if (1 === m6 && 0.5 === Math.abs(o13 % 1)) return f6 + 0.5;
  const d5 = t8.slice(0, i12[c6]).fill(0);
  for (let p5 = 0, x4 = 0; p5 < t8.length; p5++) if (!n15 || n15[p5]) {
    const n16 = t8[p5];
    n16 >= f6 && n16 < h6 && (d5[x4++] = n16);
  }
  d5.sort((t9, n16) => t9 - n16);
  const g4 = u11 - Math.floor(l6) - 1;
  return d5[Math.max(0, d5.length - 1 - g4)];
}
function M3(t8, n15, e7, s6 = false, i12 = false) {
  let o13 = 0, a16 = 0, r14 = 0, l6 = 0;
  for (let c6 = 0; c6 < t8.length; c6++) if (!n15 || n15[c6]) {
    const n16 = t8[c6] - e7, i13 = n16 * n16;
    if (o13 += i13, !s6) {
      const t9 = i13 * n16;
      a16 += t9;
      r14 += t9 * n16;
    }
    l6++;
  }
  if (l6 < 2) return null;
  o13 /= l6 - 1;
  const u11 = Math.sqrt(o13);
  if (s6) return { stddev: u11 };
  r14 /= l6;
  return { stddev: u11, skewness: i12 ? a16 * (l6 / ((l6 - 1) * (l6 - 2))) / o13 ** 1.5 : a16 / l6 / o13 ** 1.5, kurtosis: r14 / (o13 * o13) };
}
function k3(t8, n15) {
  const { pixels: e7, mask: s6, pixelType: i12, bandMasks: o13 } = t8, a16 = e7.map((t9, e8) => f3(t9, o13?.[e8] ?? s6, { pixelType: i12, ...n15 }));
  return { statistics: a16.map(({ statistics: t9 }) => t9), histograms: a16.map(({ histogram: t9 }) => t9) };
}
function y3(t8) {
  if (!t8?.pixels?.length) return null;
  const { pixels: n15, mask: e7, bandMasks: s6, pixelType: i12 } = t8, o13 = t8.width * t8.height, a16 = n15.length, r14 = [], l6 = [], u11 = 256;
  let c6, m6;
  for (let f6 = 0; f6 < a16; f6++) {
    let a17 = new Uint32Array(u11);
    const h6 = n15[f6], d5 = s6?.[f6] ?? e7;
    if ("u8" === i12) {
      if (c6 = 255, m6 = 0, d5) {
        for (let t9 = 0; t9 < o13; t9++) if (d5[t9]) {
          const n16 = h6[t9];
          c6 = n16 < c6 ? n16 : c6, m6 = n16 > m6 ? n16 : m6, a17[n16]++;
        }
      } else for (let t9 = 0; t9 < o13; t9++) {
        const n16 = h6[t9];
        c6 = n16 < c6 ? n16 : c6, m6 = n16 > m6 ? n16 : m6, a17[n16]++;
      }
      a17 = a17.slice(c6, m6 + 1);
    } else {
      let n16 = false;
      t8.statistics || (t8.updateStatistics(), n16 = true);
      const e8 = t8.statistics;
      c6 = e8[f6].minValue, m6 = e8[f6].maxValue;
      const s7 = (m6 - c6) / u11;
      if (0 === s7) {
        !e8 || t8.validPixelCount || n16 || t8.updateStatistics();
        const s8 = (t8.validPixelCount || t8.width * t8.height) / u11;
        for (let t9 = 0; t9 < u11; t9++) a17[t9] = Math.round(s8 * (t9 + 1)) - Math.round(s8 * t9);
      } else {
        const t9 = new Uint32Array(u11 + 1);
        for (let n17 = 0; n17 < o13; n17++) d5 && !d5[n17] || t9[Math.floor((h6[n17] - c6) / s7)]++;
        for (let n17 = 0; n17 < u11 - 1; n17++) a17[n17] = t9[n17];
        a17[u11 - 1] = t9[u11 - 1] + t9[u11];
      }
    }
    const g4 = "u8" === i12 ? c6 - 0.5 : c6, p5 = "u8" === i12 ? m6 + 0.5 : m6;
    r14.push({ min: g4, max: p5, size: a17.length, counts: a17 });
    let x4 = 0, M4 = 0, k5 = 0;
    for (let t9 = 0; t9 < a17.length; t9++) x4 += a17[t9], M4 += t9 * a17[t9];
    const y5 = M4 / x4;
    for (let t9 = 0; t9 < a17.length; t9++) k5 += a17[t9] * (t9 - y5) ** 2;
    const v6 = Math.sqrt(k5 / (x4 - 1)), b5 = (p5 - g4) / a17.length, O5 = (y5 + ("u8" === i12 ? 0 : 0.5)) * b5 + c6, w5 = v6 * b5;
    l6.push({ min: c6, max: m6, avg: O5, stddev: w5 });
  }
  return { statistics: l6, histograms: r14 };
}
function v3(t8) {
  const n15 = [];
  for (let e7 = 0; e7 < t8.length; e7++) {
    const { min: s6, max: i12, size: o13, counts: a16 } = t8[e7];
    let r14 = 0, l6 = 0;
    for (let t9 = 0; t9 < o13; t9++) r14 += a16[t9], l6 += t9 * a16[t9];
    const u11 = l6 / r14;
    let c6 = 0;
    for (let t9 = 0; t9 < o13; t9++) c6 += a16[t9] * (t9 - u11) ** 2;
    const m6 = (i12 - s6) / o13, f6 = (u11 + 0.5) * m6 + s6, h6 = Math.sqrt(c6 / (r14 - 1)) * m6;
    n15.push({ min: s6, max: i12, avg: f6, stddev: h6 });
  }
  return n15;
}
function b3(n15, i12) {
  const { pixelBlock: o13, bandIds: a16, returnHistogramLut: l6, rasterInfo: u11 } = i12;
  let c6 = null, m6 = null, f6 = n15.stretchType;
  if ("number" == typeof f6 && (f6 = a9[f6]), n15.dra) if ("minMax" === f6 && o13?.statistics) c6 = o13.statistics.map((t8) => [t8.minValue, t8.maxValue, 0, 0]);
  else {
    const t8 = y3(o13);
    c6 = null != t8 ? t8.statistics : null, m6 = null != t8 ? t8.histograms : null;
  }
  else c6 = n15.statistics?.length ? n15.statistics : u11.statistics, m6 = "histograms" in n15 ? n15.histograms : void 0, m6 || (m6 = u11.histograms);
  "percentClip" !== f6 && "histogramEqualization" !== f6 || m6?.length || (f6 = "minMax");
  const h6 = c6?.length || m6?.length || u11.bandCount, d5 = [], g4 = [];
  c6 && !Array.isArray(c6[0]) && (c6 = c6.map((t8) => [t8.min, t8.max, t8.avg, t8.stddev]));
  const [p5, x4] = u2(u11.pixelType);
  if (!c6?.length) {
    c6 = [];
    for (let t8 = 0; t8 < h6; t8++) c6.push([p5, x4, 1, 1]);
    "standardDeviation" === f6 && (f6 = "minMax");
  }
  switch (f6) {
    case "none":
      for (let t8 = 0; t8 < h6; t8++) d5[t8] = p5, g4[t8] = x4;
      break;
    case "minMax":
      for (let t8 = 0; t8 < h6; t8++) {
        const n16 = c6[t8];
        d5[t8] = n16[0], g4[t8] = n16[1];
      }
      break;
    case "standardDeviation":
      {
        const { numberOfStandardDeviations: t8 = 2 } = n15;
        for (let n16 = 0; n16 < h6; n16++) {
          const e7 = c6[n16];
          d5[n16] = e7[2] - t8 * e7[3], g4[n16] = e7[2] + t8 * e7[3], d5[n16] < e7[0] && (d5[n16] = e7[0]), g4[n16] > e7[1] && (g4[n16] = e7[1]);
        }
      }
      break;
    case "histogramEqualization":
      n(m6);
      for (let t8 = 0; t8 < h6; t8++) d5[t8] = m6[t8].min, g4[t8] = m6[t8].max;
      break;
    case "percentClip":
      n(m6);
      for (let t8 = 0; t8 < m6.length; t8++) {
        const e7 = m6[t8], s6 = new Uint32Array(e7.size), i13 = [...e7.counts];
        i13.length >= 20 && (i13[0] = i13[1] = i13[2] = i13[i13.length - 1] = i13[i13.length - 2] = 0);
        let o14 = 0;
        const a17 = (e7.max - e7.min) / e7.size, r14 = -0.5 === e7.min && 1 === a17 ? 0.5 : 0;
        for (let t9 = 0; t9 < e7.size; t9++) o14 += i13[t9], s6[t9] = o14;
        let l7 = (n15.minPercent || 0) * o14 / 100;
        d5[t8] = e7.min + r14;
        for (let n16 = 0; n16 < e7.size; n16++) if (s6[n16] > l7) {
          d5[t8] = e7.min + a17 * (n16 + r14);
          break;
        }
        l7 = (1 - (n15.maxPercent || 0) / 100) * o14, g4[t8] = e7.max + r14;
        for (let n16 = e7.size - 2; n16 >= 0; n16--) if (s6[n16] < l7) {
          g4[t8] = e7.min + a17 * (n16 + 2 - r14);
          break;
        }
        if (g4[t8] < d5[t8]) {
          const n16 = d5[t8];
          d5[t8] = g4[t8], g4[t8] = n16;
        }
      }
      break;
    default:
      for (let t8 = 0; t8 < h6; t8++) {
        const n16 = c6[t8];
        d5[t8] = n16[0], g4[t8] = n16[1];
      }
  }
  let M4, k5, v6;
  "histogramEqualization" === f6 ? (n(m6), k5 = m6[0].size || 256, M4 = 0, l6 && (v6 = m6.map((t8) => r11(t8)))) : (k5 = n15.max || 255, M4 = n15.min || 0);
  return O3({ minCutOff: d5, maxCutOff: g4, maxOutput: k5, minOutput: M4, histogramLut: v6 }, a16);
}
function O3(t8, n15) {
  if (null == n15 || 0 === n15.length) return t8;
  const e7 = Math.max.apply(null, n15), { minCutOff: s6, maxCutOff: i12, minOutput: o13, maxOutput: a16, histogramLut: r14 } = t8;
  return s6.length === n15.length || s6.length <= e7 ? t8 : { minCutOff: n15.map((t9) => s6[t9]), maxCutOff: n15.map((t9) => i12[t9]), histogramLut: r14 ? n15.map((t9) => r14[t9]) : null, minOutput: o13, maxOutput: a16 };
}
function w3(t8, n15) {
  const e7 = new Float32Array(t8);
  for (let s6 = 0; s6 < t8; s6++) n15[s6] > 1 ? n15[s6] > 2 ? e7[s6] = 6.5 + (n15[s6] - 2) ** 2.5 : e7[s6] = 6.5 + 100 * (2 - n15[s6]) ** 4 : e7[s6] = 1;
  return e7;
}
function z2(t8, e7) {
  if (!t8?.pixels?.length) return t8;
  const { mask: s6, bandMasks: i12, width: o13, height: a16, pixels: r14 } = t8, { minCutOff: l6, maxCutOff: u11, minOutput: c6, maxOutput: m6, gamma: f6 } = e7, h6 = o13 * a16, d5 = e7.outputPixelType || "u8", g4 = t8.pixels.map(() => c.createEmptyBand(d5, h6)), p5 = g4.length, x4 = m6 - c6, M4 = [], k5 = [];
  for (let n15 = 0; n15 < p5; n15++) k5[n15] = u11[n15] - l6[n15], M4[n15] = 0 === k5[n15] ? 0 : x4 / k5[n15];
  const y5 = d5.startsWith("u") || d5.startsWith("s"), v6 = f6 && f6.length >= p5, b5 = !!e7.isRenderer;
  if (v6) {
    const t9 = w3(p5, f6);
    for (let n15 = 0; n15 < p5; n15++) {
      const e8 = i12?.[n15] ?? s6;
      for (let s7 = 0; s7 < h6; s7++) if (null == e8 || e8[s7]) {
        if (0 === k5[n15]) {
          g4[n15][s7] = c6;
          continue;
        }
        const e9 = r14[n15][s7], i13 = (e9 - l6[n15]) / k5[n15];
        let o14 = 1;
        if (f6[n15] > 1 && (o14 -= (1 / x4) ** (i13 * t9[n15])), e9 < u11[n15] && e9 > l6[n15]) {
          const t10 = o14 * x4 * i13 ** (1 / f6[n15]) + c6;
          g4[n15][s7] = b5 ? Math.floor(t10) : y5 ? Math.round(t10) : t10;
        } else e9 >= u11[n15] ? g4[n15][s7] = m6 : g4[n15][s7] = c6;
      }
    }
  } else for (let n15 = 0; n15 < p5; n15++) {
    const t9 = i12?.[n15] ?? s6;
    for (let e8 = 0; e8 < h6; e8++) if (null == t9 || t9[e8]) {
      const t10 = r14[n15][e8];
      if (t10 < u11[n15] && t10 > l6[n15]) {
        const s7 = (t10 - l6[n15]) * M4[n15] + c6;
        g4[n15][e8] = b5 ? Math.floor(s7) : y5 ? Math.round(s7) : s7;
      } else t10 >= u11[n15] ? g4[n15][e8] = m6 : g4[n15][e8] = c6;
    }
  }
  const O5 = new c({ width: o13, height: a16, mask: s6, bandMasks: i12, pixels: g4, pixelType: d5 });
  return O5.updateStatistics(), O5;
}

// node_modules/@arcgis/core/layers/support/RasterBandInfo.js
var t6;
function n9(e7) {
  return e7 = Number(e7), isNaN(e7) ? void 0 : e7;
}
var _a;
var o10 = (_a = class extends n3 {
  constructor() {
    super(...arguments), this.name = null, this.minWavelength = void 0, this.maxWavelength = void 0, this.radianceBias = void 0, this.radianceGain = void 0, this.reflectanceBias = void 0, this.reflectanceGain = void 0, this.solarIrradiance = void 0;
  }
  clone() {
    return new t6({ name: this.name, minWavelength: this.minWavelength, maxWavelength: this.maxWavelength, radianceBias: this.radianceBias, radianceGain: this.radianceGain, reflectanceBias: this.reflectanceBias, reflectanceGain: this.reflectanceGain, solarIrradiance: this.solarIrradiance });
  }
}, t6 = _a, _a);
__decorate([m({ json: { name: "BandName", write: true } })], o10.prototype, "name", void 0), __decorate([m({ json: { read: { source: ["WavelengthMin", "Wavelength"], reader: (e7, a16) => n9(a16.WavelengthMin ?? a16.Wavelength) }, write: { target: "WavelengthMin" } } })], o10.prototype, "minWavelength", void 0), __decorate([m({ json: { name: "WavelengthMax", read: { reader: n9 }, write: true } })], o10.prototype, "maxWavelength", void 0), __decorate([m({ json: { name: "RadianceBias", read: { reader: n9 }, write: true } })], o10.prototype, "radianceBias", void 0), __decorate([m({ json: { name: "RadianceGain", read: { reader: n9 }, write: true } })], o10.prototype, "radianceGain", void 0), __decorate([m({ json: { name: "ReflectanceBias", read: { reader: n9 }, write: true } })], o10.prototype, "reflectanceBias", void 0), __decorate([m({ json: { name: "ReflectanceGain", read: { reader: n9 }, write: true } })], o10.prototype, "reflectanceGain", void 0), __decorate([m({ json: { name: "SolarIrradiance", read: { reader: n9 }, write: true } })], o10.prototype, "solarIrradiance", void 0), o10 = t6 = __decorate([a2("esri.layers.support.RasterBandInfo")], o10);

// node_modules/@arcgis/core/layers/support/rasterEnums.js
var a11 = i2()({ RSP_NearestNeighbor: "nearest", RSP_BilinearInterpolation: "bilinear", RSP_CubicConvolution: "cubic", RSP_Majority: "majority" });
var i10 = i2()({ esriNoDataMatchAny: "any", esriNoDataMatchAll: "all" });
var n10 = i2()({ U1: "u1", U2: "u2", U4: "u4", U8: "u8", S8: "s8", U16: "u16", S16: "s16", U32: "u32", S32: "s32", F32: "f32", F64: "f64", C64: "c64", C128: "c128", UNKNOWN: "unknown" });

// node_modules/@arcgis/core/layers/support/RasterSensorInfo.js
var a12;
function n11(o13) {
  return o13 = Number(o13), isNaN(o13) ? void 0 : o13;
}
var u6 = a12 = class extends n3 {
  constructor() {
    super(...arguments), this.acquisitionDate = void 0, this.cloudCover = void 0, this.productName = void 0, this.sensorName = null, this.sensorAzimuth = void 0, this.sensorElevation = void 0, this.sunAzimuth = void 0, this.sunElevation = void 0;
  }
  readAcquisitionDate(o13) {
    return new Date(o13);
  }
  writeAcquisitionDate(o13, e7) {
    e7.AcquisitionDate = o13.getTime();
  }
  clone() {
    return new a12({ acquisitionDate: this.acquisitionDate, cloudCover: this.cloudCover, productName: this.productName, sensorName: this.sensorName, sensorAzimuth: this.sensorAzimuth, sensorElevation: this.sensorElevation, sunAzimuth: this.sunAzimuth, sunElevation: this.sunElevation });
  }
};
__decorate([m({ type: Date, json: { name: "AcquisitionDate", write: true } })], u6.prototype, "acquisitionDate", void 0), __decorate([o2("acquisitionDate")], u6.prototype, "readAcquisitionDate", null), __decorate([r("acquisitionDate")], u6.prototype, "writeAcquisitionDate", null), __decorate([m({ json: { name: "CloudCover", read: { reader: n11 }, write: true } })], u6.prototype, "cloudCover", void 0), __decorate([m({ json: { name: "ProductName", write: true } })], u6.prototype, "productName", void 0), __decorate([m({ json: { name: "SensorName", write: true } })], u6.prototype, "sensorName", void 0), __decorate([m({ json: { name: "SensorAzimuth", read: { reader: n11 }, write: true } })], u6.prototype, "sensorAzimuth", void 0), __decorate([m({ json: { name: "SensorElevation", read: { reader: n11 }, write: true } })], u6.prototype, "sensorElevation", void 0), __decorate([m({ json: { name: "SunAzimuth", read: { reader: n11 }, write: true } })], u6.prototype, "sunAzimuth", void 0), __decorate([m({ json: { name: "SunElevation", read: { reader: n11 }, write: true } })], u6.prototype, "sunElevation", void 0), u6 = a12 = __decorate([a2("esri.layers.support.RasterSensorInfo")], u6);

// node_modules/@arcgis/core/layers/support/RasterStorageInfo.js
var p3;
var l4 = p3 = class extends n3 {
  constructor() {
    super(...arguments), this.blockWidth = void 0, this.blockHeight = void 0, this.compression = null, this.origin = null, this.firstPyramidLevel = null, this.maximumPyramidLevel = null, this.pyramidScalingFactor = 2, this.pyramidBlockWidth = null, this.pyramidBlockHeight = null, this.isBsqTile = false, this.isVirtualTileInfo = false, this.tileInfo = null, this.transposeInfo = null, this.blockBoundary = null;
  }
  clone() {
    return new p3({ blockWidth: this.blockWidth, blockHeight: this.blockHeight, compression: this.compression, origin: a(this.origin), firstPyramidLevel: this.firstPyramidLevel, maximumPyramidLevel: this.maximumPyramidLevel, pyramidResolutions: a(this.pyramidResolutions), pyramidScalingFactor: this.pyramidScalingFactor, pyramidBlockWidth: this.pyramidBlockWidth, pyramidBlockHeight: this.pyramidBlockHeight, isBsqTile: this.isBsqTile, isVirtualTileInfo: this.isVirtualTileInfo, tileInfo: a(this.tileInfo), transposeInfo: a(this.transposeInfo), blockBoundary: a(this.blockBoundary) });
  }
};
__decorate([m({ type: Number, json: { write: true } })], l4.prototype, "blockWidth", void 0), __decorate([m({ type: Number, json: { write: true } })], l4.prototype, "blockHeight", void 0), __decorate([m({ type: String, json: { write: true } })], l4.prototype, "compression", void 0), __decorate([m({ type: _, json: { write: true } })], l4.prototype, "origin", void 0), __decorate([m({ type: Number, json: { write: true } })], l4.prototype, "firstPyramidLevel", void 0), __decorate([m({ type: Number, json: { write: true } })], l4.prototype, "maximumPyramidLevel", void 0), __decorate([m({ json: { write: true } })], l4.prototype, "pyramidResolutions", void 0), __decorate([m({ type: Number, json: { write: true } })], l4.prototype, "pyramidScalingFactor", void 0), __decorate([m({ type: Number, json: { write: true } })], l4.prototype, "pyramidBlockWidth", void 0), __decorate([m({ type: Number, json: { write: true } })], l4.prototype, "pyramidBlockHeight", void 0), __decorate([m({ json: { write: true } })], l4.prototype, "isBsqTile", void 0), __decorate([m({ type: Boolean, json: { write: true } })], l4.prototype, "isVirtualTileInfo", void 0), __decorate([m({ json: { write: true } })], l4.prototype, "tileInfo", void 0), __decorate([m()], l4.prototype, "transposeInfo", void 0), __decorate([m({ json: { write: true } })], l4.prototype, "blockBoundary", void 0), l4 = p3 = __decorate([a2("esri.layers.support.RasterStorageInfo")], l4);

// node_modules/@arcgis/core/layers/support/RasterInfo.js
var u7;
var m4 = u7 = class extends n3 {
  constructor(t8) {
    super(t8), this.attributeTable = null, this.bandCount = null, this.colormap = null, this.extent = null, this.format = void 0, this.height = null, this.width = null, this.histograms = null, this.keyProperties = {}, this.multidimensionalInfo = null, this.noDataValue = null, this.pixelSize = null, this.pixelType = null, this.isPseudoSpatialReference = false, this.spatialReference = null, this.statistics = null, this.storageInfo = null, this.transform = null;
  }
  get bandInfos() {
    const t8 = this.keyProperties.BandProperties, { bandCount: e7 } = this;
    if (!t8?.length || t8.length < e7) {
      const t9 = [];
      for (let o14 = 1; o14 <= e7; o14++) t9.push(new o10({ name: "band_" + o14 }));
      return t9;
    }
    const o13 = t8.map((t9) => o10.fromJSON(t9));
    for (let i12 = 0; i12 < o13.length; i12++) o13[i12].name = o13[i12].name || "band_" + (i12 + 1);
    return o13;
  }
  get dataType() {
    const t8 = this.keyProperties?.DataType?.toLowerCase() ?? "generic";
    return "stdtime" === t8 ? "standard-time" : t8;
  }
  get nativeExtent() {
    return this._get("nativeExtent") || this.extent;
  }
  set nativeExtent(t8) {
    t8 && this._set("nativeExtent", t8);
  }
  get nativePixelSize() {
    if (null == this.transform || !this.transform.affectsPixelSize) return this.pixelSize;
    const t8 = this.nativeExtent;
    return { x: t8.width / this.width, y: t8.height / this.height };
  }
  get hasMultidimensionalTranspose() {
    return !!this.storageInfo?.transposeInfo;
  }
  get sensorInfo() {
    if (this.keyProperties?.SensorName) return u6.fromJSON(this.keyProperties);
  }
  clone() {
    return new u7({ attributeTable: a(this.attributeTable), bandCount: this.bandCount, colormap: a(this.colormap), extent: a(this.extent), format: this.format, height: this.height, width: this.width, histograms: a(this.histograms), keyProperties: a(this.keyProperties), multidimensionalInfo: a(this.multidimensionalInfo), noDataValue: this.noDataValue, pixelSize: a(this.pixelSize), pixelType: this.pixelType, isPseudoSpatialReference: this.isPseudoSpatialReference, spatialReference: a(this.spatialReference), statistics: a(this.statistics), storageInfo: a(this.storageInfo), transform: a(this.transform) });
  }
};
__decorate([m({ json: { write: true } })], m4.prototype, "attributeTable", void 0), __decorate([m({ json: { write: true } })], m4.prototype, "bandCount", void 0), __decorate([m({ readOnly: true })], m4.prototype, "bandInfos", null), __decorate([m({ json: { write: true } })], m4.prototype, "colormap", void 0), __decorate([m({ type: String, readOnly: true })], m4.prototype, "dataType", null), __decorate([m({ type: z, json: { write: true } })], m4.prototype, "extent", void 0), __decorate([m({ type: z, json: { write: true } })], m4.prototype, "nativeExtent", null), __decorate([m({ json: { write: true } })], m4.prototype, "nativePixelSize", null), __decorate([m({ json: { write: true } })], m4.prototype, "format", void 0), __decorate([m({ json: { write: true } })], m4.prototype, "height", void 0), __decorate([m({ json: { write: true } })], m4.prototype, "width", void 0), __decorate([m({ json: { write: true } })], m4.prototype, "hasMultidimensionalTranspose", null), __decorate([m({ json: { write: true } })], m4.prototype, "histograms", void 0), __decorate([m({ json: { write: true } })], m4.prototype, "keyProperties", void 0), __decorate([m({ json: { write: true } })], m4.prototype, "multidimensionalInfo", void 0), __decorate([m({ json: { write: true } })], m4.prototype, "noDataValue", void 0), __decorate([m({ json: { write: true } })], m4.prototype, "pixelSize", void 0), __decorate([m({ type: n10.apiValues, json: { write: true } })], m4.prototype, "pixelType", void 0), __decorate([m()], m4.prototype, "isPseudoSpatialReference", void 0), __decorate([m({ readOnly: true })], m4.prototype, "sensorInfo", null), __decorate([m({ type: f, json: { write: true } })], m4.prototype, "spatialReference", void 0), __decorate([m({ json: { write: true } })], m4.prototype, "statistics", void 0), __decorate([m({ type: l4, json: { write: true } })], m4.prototype, "storageInfo", void 0), __decorate([m({ json: { write: true } })], m4.prototype, "transform", void 0), m4 = u7 = __decorate([a2("esri.layers.support.RasterInfo")], m4);

// node_modules/@arcgis/core/layers/support/rasterFunctions/surfaceUtils.js
var s4 = 1;
var n12 = 1 / 111e3;
function a13(t8) {
  let { altitude: e7, azimuth: i12 } = t8;
  const { hillshadeType: s6, pixelSizePower: a16 = 1, pixelSizeFactor: o13 = 1, scalingType: l6, isGCS: r14, resolution: c6 } = t8, h6 = "multi-directional" === s6 ? 2 * t8.zFactor : t8.zFactor, { x: u11, y: f6 } = c6;
  let d5 = h6 / (8 * u11), p5 = h6 / (8 * f6);
  if (r14 && h6 > 1e-3 && (d5 /= n12, p5 /= n12), "adjusted" === l6) if (r14) {
    const t9 = u11 * n12, e8 = f6 * n12;
    d5 = (h6 + t9 ** a16 * o13) / (8 * t9), p5 = (h6 + e8 ** a16 * o13) / (8 * e8);
  } else d5 = (h6 + u11 ** a16 * o13) / (8 * u11), p5 = (h6 + f6 ** a16 * o13) / (8 * f6);
  let x4 = (90 - e7) * Math.PI / 180, w5 = Math.cos(x4), y5 = (360 - i12 + 90) * Math.PI / 180, m6 = Math.sin(x4) * Math.cos(y5), M4 = Math.sin(x4) * Math.sin(y5);
  const z3 = [315, 270, 225, 360, 180, 0], A4 = [60, 60, 60, 60, 60, 90], g4 = new Float32Array([3, 5, 3, 2, 1, 4]), F2 = g4.reduce((t9, e8) => t9 + e8), k5 = g4.map((t9) => t9 / F2), P4 = "multi-directional" === s6 ? z3.length : 1, S4 = new Float32Array(6), C5 = new Float32Array(6), T4 = new Float32Array(6);
  if ("multi-directional" === s6) for (let n15 = 0; n15 < P4; n15++) e7 = A4[n15], i12 = z3[n15], x4 = (90 - e7) * Math.PI / 180, w5 = Math.cos(x4), y5 = (360 - i12 + 90) * Math.PI / 180, m6 = Math.sin(x4) * Math.cos(y5), M4 = Math.sin(x4) * Math.sin(y5), S4[n15] = w5, C5[n15] = m6, T4[n15] = M4;
  else S4.fill(w5), C5.fill(m6), T4.fill(M4);
  return { resolution: c6, factor: [d5, p5], sinZcosA: m6, sinZsinA: M4, cosZ: w5, sinZcosAs: [...C5], sinZsinAs: [...T4], cosZs: [...S4], weights: [...k5], hillshadeType: ["traditional", "multi-directional"].indexOf(s6) };
}
function o11(t8, e7) {
  const { width: i12, height: n15 } = t8, a16 = i12 * n15, o13 = new Uint8Array(a16), l6 = null != t8.mask;
  let r14;
  if (l6) {
    r14 = new Uint8Array(t8.mask);
    for (let t9 = 0; t9 < r14.length; t9++) r14[t9] && (o13[t9] = 1, r14[t9] = 1);
  }
  const c6 = t8.pixels[0], h6 = new Float32Array(a16), u11 = new Float32Array(a16);
  let f6, d5 = 0;
  if (e7) {
    const { resolution: t9 } = e7, i13 = t9 ? (t9.x + t9.y) / 2 : 1;
    d5 = 200 * e7.zFactor / (i13 * i13), f6 = new Float32Array(a16);
  }
  const p5 = e7?.curvatureType;
  let x4, w5, y5, m6, M4, z3, A4, g4;
  for (let F2 = s4; F2 < n15 - s4; F2++) {
    const t9 = F2 * i12;
    for (let e8 = s4; e8 < i12 - s4; e8++) {
      const s6 = t9 + e8;
      if (!r14 || 0 !== r14[s6]) {
        if (r14) {
          if (r14[s6 - i12 - 1] + r14[s6 - i12] + r14[s6 - i12 + 1] + r14[s6 - 1] + r14[s6 + 1] + r14[s6 + i12 - 1] + r14[s6 + i12] + r14[s6 + i12 + 1] < 7) {
            o13[s6] = 0;
            continue;
          }
          x4 = r14[s6 - i12 - 1] ? c6[s6 - i12 - 1] : c6[s6], w5 = r14[s6 - i12] ? c6[s6 - i12] : c6[s6], y5 = r14[s6 - i12 + 1] ? c6[s6 - i12 + 1] : c6[s6], m6 = r14[s6 - 1] ? c6[s6 - 1] : c6[s6], M4 = r14[s6 + 1] ? c6[s6 + 1] : c6[s6], z3 = r14[s6 + i12 - 1] ? c6[s6 + i12 - 1] : c6[s6], A4 = r14[s6 + i12] ? c6[s6 + i12] : c6[s6], g4 = r14[s6 + i12 + 1] ? c6[s6 + i12 + 1] : c6[s6];
        } else x4 = c6[s6 - i12 - 1], w5 = c6[s6 - i12], y5 = c6[s6 - i12 + 1], m6 = c6[s6 - 1], M4 = c6[s6 + 1], z3 = c6[s6 + i12 - 1], A4 = c6[s6 + i12], g4 = c6[s6 + i12 + 1];
        if (h6[s6] = y5 + M4 + M4 + g4 - (x4 + m6 + m6 + z3), u11[s6] = z3 + A4 + A4 + g4 - (x4 + w5 + w5 + y5), null != f6) {
          const t10 = c6[s6], e9 = 0.5 * (m6 + M4) - t10, i13 = 0.5 * (w5 + A4) - t10;
          if ("standard" === p5) f6[s6] = -d5 * (e9 + i13);
          else {
            const t11 = (-x4 + y5 + z3 - g4) / 4, n16 = (-m6 + M4) / 2, a17 = (w5 - A4) / 2, o14 = n16 * n16, l7 = a17 * a17, r15 = o14 + l7;
            r15 && (f6[s6] = "profile" === p5 ? d5 * (e9 * o14 + i13 * l7 + t11 * n16 * a17) / r15 : -d5 * (e9 * l7 + i13 * o14 - t11 * n16 * a17) / r15);
          }
        }
      }
    }
  }
  return { outMask: l6 ? o13 : null, dzxs: h6, dzys: u11, curvatures: f6 };
}
function l5(t8, e7, i12) {
  for (let s6 = 0; s6 < i12; s6++) t8[s6 * e7] = t8[s6 * e7 + 1], t8[(s6 + 1) * e7 - 1] = t8[(s6 + 1) * e7 - 2];
  for (let s6 = 1; s6 < e7 - 1; s6++) t8[s6] = t8[s6 + e7], t8[s6 + (i12 - 1) * e7] = t8[s6 + (i12 - 2) * e7];
}
function r12(n15, r14) {
  if (!o4(n15)) return n15;
  const { factor: c6, sinZcosA: h6, sinZsinA: u11, cosZ: f6, sinZcosAs: d5, sinZsinAs: p5, cosZs: x4, weights: w5 } = a13(r14), [y5, m6] = c6, M4 = "traditional" === r14.hillshadeType, { width: z3, height: A4 } = n15, g4 = new Uint8Array(z3 * A4), { dzxs: F2, dzys: k5, outMask: P4 } = o11(n15);
  for (let t8 = s4; t8 < A4 - s4; t8++) {
    const e7 = t8 * z3;
    for (let t9 = s4; t9 < z3 - s4; t9++) {
      const i12 = e7 + t9;
      if (!P4 || P4[i12]) {
        const t10 = F2[i12] * y5, e8 = k5[i12] * m6, s6 = Math.sqrt(1 + t10 * t10 + e8 * e8);
        let n16 = 0;
        if (M4) {
          let i13 = 255 * (f6 + u11 * e8 - h6 * t10) / s6;
          i13 < 0 && (i13 = 0), n16 = i13;
        } else {
          const i13 = p5.length;
          for (let a16 = 0; a16 < i13; a16++) {
            let i14 = 255 * (x4[a16] + p5[a16] * e8 - d5[a16] * t10) / s6;
            i14 < 0 && (i14 = 0), n16 += i14 * w5[a16];
          }
        }
        g4[i12] = 255 & n16;
      }
    }
  }
  l5(g4, z3, A4);
  return new c({ width: z3, height: A4, pixels: [g4], mask: P4, pixelType: "u8", validPixelCount: n15.validPixelCount, statistics: [new l(0, 255)] });
}
function c4(t8, e7, s6, n15) {
  if (!o4(t8) || !o4(e7)) return;
  const { min: a16, max: o13 } = n15, l6 = t8.pixels[0], { pixels: r14, mask: c6 } = e7, h6 = r14[0], u11 = 255.00001 / (o13 - a16), f6 = new Uint8ClampedArray(h6.length), d5 = new Uint8ClampedArray(h6.length), p5 = new Uint8ClampedArray(h6.length), x4 = s6.length - 1;
  for (let i12 = 0; i12 < h6.length; i12++) {
    if (c6 && 0 === c6[i12]) continue;
    const t9 = Math.floor((h6[i12] - a16) * u11), [e8, n16] = s6[t9 < 0 ? 0 : t9 > x4 ? x4 : t9], o14 = l6[i12], r15 = o14 * n16, w5 = r15 * (1 - Math.abs(e8 % 2 - 1)), y5 = o14 - r15;
    switch (Math.floor(e8)) {
      case 0:
        f6[i12] = r15 + y5, d5[i12] = w5 + y5, p5[i12] = y5;
        break;
      case 1:
        f6[i12] = w5 + y5, d5[i12] = r15 + y5, p5[i12] = y5;
        break;
      case 2:
        f6[i12] = y5, d5[i12] = r15 + y5, p5[i12] = w5 + y5;
        break;
      case 3:
        f6[i12] = y5, d5[i12] = w5 + y5, p5[i12] = r15 + y5;
        break;
      case 4:
        f6[i12] = w5 + y5, d5[i12] = y5, p5[i12] = r15 + y5;
        break;
      case 5:
      case 6:
        f6[i12] = r15 + y5, d5[i12] = y5, p5[i12] = w5 + y5;
    }
  }
  t8.pixels = [f6, d5, p5], t8.updateStatistics();
}
function h4(e7, a16) {
  if (!o4(e7)) return e7;
  const r14 = a16.zFactor, c6 = a16.pixelSizePower ?? 1, h6 = a16.pixelSizeFactor ?? 1, u11 = a16.slopeType, f6 = a16.isGCS, { x: d5, y: p5 } = a16.resolution;
  let x4 = r14 / (8 * d5), w5 = r14 / (8 * p5);
  f6 && Math.abs(r14 - 1) < 1e-4 && (x4 /= n12, w5 /= n12), "adjusted" === u11 && (x4 = (r14 + d5 ** c6 * h6) / (8 * d5), w5 = (r14 + p5 ** c6 * h6) / (8 * p5));
  const { dzxs: y5, dzys: m6, outMask: M4 } = o11(e7), { width: z3, height: A4 } = e7, g4 = new Float32Array(z3 * A4);
  for (let t8 = s4; t8 < A4 - s4; t8++) {
    const e8 = t8 * z3;
    for (let t9 = s4; t9 < z3 - s4; t9++) {
      const i12 = e8 + t9;
      if (!M4 || M4[i12]) {
        const s6 = y5[i12] * x4, n15 = m6[i12] * w5, a17 = Math.sqrt(s6 * s6 + n15 * n15);
        g4[e8 + t9] = "percent-rise" === u11 ? 100 * a17 : 57.2957795 * Math.atan(a17);
      }
    }
  }
  l5(g4, z3, A4);
  const F2 = new c({ width: z3, height: A4, pixels: [g4], mask: M4, pixelType: "f32", validPixelCount: e7.validPixelCount });
  return F2.updateStatistics(), F2;
}
function u8(n15, a16 = {}) {
  if (!o4(n15)) return n15;
  const { resolution: r14 } = a16, c6 = r14 ? 1 / r14.x : 1, h6 = r14 ? 1 / r14.y : 1, { dzxs: u11, dzys: f6, outMask: d5 } = o11(n15), { width: p5, height: x4 } = n15, w5 = new Float32Array(p5 * x4);
  for (let t8 = s4; t8 < x4 - s4; t8++) {
    const e7 = t8 * p5;
    for (let t9 = s4; t9 < p5 - s4; t9++) {
      const i12 = e7 + t9;
      if (!d5 || d5[i12]) {
        const s6 = u11[i12] * c6, n16 = f6[i12] * h6;
        let a17 = -1;
        0 === s6 && 0 === n16 || (a17 = 90 - 57.29578 * Math.atan2(n16, -s6), a17 < 0 && (a17 += 360), 360 === a17 ? a17 = 0 : a17 > 360 && (a17 %= 360)), w5[e7 + t9] = a17;
      }
    }
  }
  l5(w5, p5, x4);
  return new c({ width: p5, height: x4, pixels: [w5], mask: d5, pixelType: "f32", validPixelCount: n15.validPixelCount, statistics: [new l(-1, 360)] });
}
function f4(e7, s6) {
  if (!o4(e7)) return e7;
  const { curvatures: n15, outMask: a16 } = o11(e7, s6), { width: r14, height: c6 } = e7;
  l5(n15, r14, c6);
  const h6 = new c({ width: r14, height: c6, pixels: [n15], mask: a16, pixelType: "f32", validPixelCount: e7.validPixelCount });
  return h6.updateStatistics(), h6;
}
function d3(t8, e7, i12) {
  const { hillshadeType: s6, altitude: n15, azimuth: a16, zFactor: o13, pixelSizeFactor: l6, pixelSizePower: r14, slopeType: c6 } = t8;
  return { hillshadeType: s6, altitude: n15, azimuth: a16, zFactor: o13, pixelSizePower: r14, pixelSizeFactor: l6, scalingType: "scaled" === c6 ? "adjusted" : "none", resolution: e7, isGCS: i12 };
}

// node_modules/@arcgis/core/renderers/support/colorRampUtils.js
var n13 = ["random", "ndvi", "ndvi2", "ndvi3", "elevation", "gray", "hillshade"];
var C4 = [{ id: "aspect", type: "multipart", colorRamps: [{ fromColor: [190, 190, 190], toColor: [255, 45, 8] }, { fromColor: [255, 45, 8], toColor: [255, 181, 61] }, { fromColor: [255, 181, 61], toColor: [255, 254, 52] }, { fromColor: [255, 254, 52], toColor: [0, 251, 50] }, { fromColor: [0, 251, 50], toColor: [255, 254, 52] }, { fromColor: [0, 253, 255], toColor: [0, 181, 255] }, { fromColor: [0, 181, 255], toColor: [26, 35, 253] }, { fromColor: [26, 35, 253], toColor: [255, 57, 251] }, { fromColor: [255, 57, 251], toColor: [255, 45, 8] }] }, { id: "black-to-white", fromColor: [0, 0, 0], toColor: [255, 255, 255] }, { id: "blue-bright", fromColor: [204, 204, 255], toColor: [0, 0, 224] }, { id: "blue-light-to-dark", fromColor: [211, 229, 232], toColor: [46, 100, 140] }, { id: "blue-green-bright", fromColor: [203, 245, 234], toColor: [48, 207, 146] }, { id: "blue-green-light-to-dark", fromColor: [216, 242, 237], toColor: [21, 79, 74] }, { id: "brown-light-to-dark", fromColor: [240, 236, 170], toColor: [102, 72, 48] }, { id: "brown-to-blue-green-diverging-right", type: "multipart", colorRamps: [{ fromColor: [156, 85, 31], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [33, 130, 145] }] }, { id: "brown-to-blue-green-diverging-dark", type: "multipart", colorRamps: [{ fromColor: [110, 70, 45], toColor: [204, 204, 102] }, { fromColor: [204, 204, 102], toColor: [48, 100, 102] }] }, { id: "coefficient-bias", fromColor: [214, 214, 255], toColor: [0, 57, 148] }, { id: "cold-to-hot-diverging", type: "multipart", colorRamps: [{ fromColor: [69, 117, 181], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [214, 47, 39] }] }, { id: "condition-number", type: "multipart", colorRamps: [{ fromColor: [0, 97, 0], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [255, 34, 0] }] }, { id: "cyan-to-purple", type: "multipart", colorRamps: [{ fromColor: [0, 245, 245], toColor: [0, 0, 245] }, { fromColor: [0, 0, 245], toColor: [245, 0, 245] }] }, { id: "cyan-light-to-blue-dark", type: "multipart", colorRamps: [{ fromColor: [182, 237, 240], toColor: [31, 131, 224] }, { fromColor: [31, 131, 224], toColor: [9, 9, 145] }] }, { id: "distance", fromColor: [255, 200, 0], toColor: [0, 0, 255] }, { id: "elevation1", type: "multipart", colorRamps: [{ fromColor: [175, 240, 233], toColor: [255, 255, 179] }, { fromColor: [255, 255, 179], toColor: [0, 128, 64] }, { fromColor: [0, 128, 64], toColor: [252, 186, 3] }, { fromColor: [252, 186, 3], toColor: [128, 0, 0] }, { fromColor: [120, 0, 0], toColor: [105, 48, 13] }, { fromColor: [105, 48, 13], toColor: [171, 171, 171] }, { fromColor: [171, 171, 171], toColor: [255, 252, 255] }] }, { id: "elevation2", type: "multipart", colorRamps: [{ fromColor: [118, 219, 211], toColor: [255, 255, 199] }, { fromColor: [255, 255, 199], toColor: [255, 255, 128] }, { fromColor: [255, 255, 128], toColor: [217, 194, 121] }, { fromColor: [217, 194, 121], toColor: [135, 96, 38] }, { fromColor: [135, 96, 38], toColor: [150, 150, 181] }, { fromColor: [150, 150, 181], toColor: [181, 150, 181] }, { fromColor: [181, 150, 181], toColor: [255, 252, 255] }] }, { id: "errors", fromColor: [255, 235, 214], toColor: [196, 10, 10] }, { id: "gray-light-to-dark", fromColor: [219, 219, 219], toColor: [69, 69, 69] }, { id: "green-bright", fromColor: [204, 255, 204], toColor: [14, 204, 14] }, { id: "green-light-to-dark", fromColor: [220, 245, 233], toColor: [34, 102, 51] }, { id: "green-to-blue", type: "multipart", colorRamps: [{ fromColor: [32, 204, 16], toColor: [0, 242, 242] }, { fromColor: [0, 242, 242], toColor: [2, 33, 227] }] }, { id: "orange-bright", fromColor: [255, 235, 204], toColor: [240, 118, 5] }, { id: "orange-light-to-dark", fromColor: [250, 233, 212], toColor: [171, 65, 36] }, { id: "partial-spectrum", type: "multipart", colorRamps: [{ fromColor: [242, 241, 162], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [255, 0, 0] }, { fromColor: [252, 3, 69], toColor: [176, 7, 237] }, { fromColor: [176, 7, 237], toColor: [2, 29, 173] }] }, { id: "partial-spectrum-1-diverging", type: "multipart", colorRamps: [{ fromColor: [135, 38, 38], toColor: [240, 149, 12] }, { fromColor: [240, 149, 12], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [74, 80, 181] }, { fromColor: [74, 80, 181], toColor: [39, 32, 122] }] }, { id: "partial-spectrum-2-diverging", type: "multipart", colorRamps: [{ fromColor: [115, 77, 42], toColor: [201, 137, 52] }, { fromColor: [201, 137, 52], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [91, 63, 176] }, { fromColor: [91, 63, 176], toColor: [81, 13, 97] }] }, { id: "pink-to-yellow-green-diverging-bright", type: "multipart", colorRamps: [{ fromColor: [158, 30, 113], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [99, 110, 45] }] }, { id: "pink-to-yellow-green-diverging-dark", type: "multipart", colorRamps: [{ fromColor: [97, 47, 73], toColor: [204, 204, 102] }, { fromColor: [204, 204, 102], toColor: [22, 59, 15] }] }, { id: "precipitation", type: "multipart", colorRamps: [{ fromColor: [194, 82, 60], toColor: [237, 161, 19] }, { fromColor: [237, 161, 19], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [0, 219, 0] }, { fromColor: [0, 219, 0], toColor: [32, 153, 143] }, { fromColor: [32, 153, 143], toColor: [11, 44, 122] }] }, { id: "prediction", type: "multipart", colorRamps: [{ fromColor: [40, 146, 199], toColor: [250, 250, 100] }, { fromColor: [250, 250, 100], toColor: [232, 16, 20] }] }, { id: "purple-bright", fromColor: [255, 204, 255], toColor: [199, 0, 199] }, { id: "purple-to-green-diverging-bright", type: "multipart", colorRamps: [{ fromColor: [77, 32, 150], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [20, 122, 11] }] }, { id: "purple-to-green-diverging-dark", type: "multipart", colorRamps: [{ fromColor: [67, 14, 89], toColor: [204, 204, 102] }, { fromColor: [204, 204, 102], toColor: [24, 79, 15] }] }, { id: "purple-blue-bright", fromColor: [223, 184, 230], toColor: [112, 12, 242] }, { id: "purple-blue-light-to-dark", fromColor: [229, 213, 242], toColor: [93, 44, 112] }, { id: "purple-red-bright", fromColor: [255, 204, 225], toColor: [199, 0, 99] }, { id: "purple-red-light-to-dark", fromColor: [250, 215, 246], toColor: [143, 17, 57] }, { id: "red-bright", fromColor: [255, 204, 204], toColor: [219, 0, 0] }, { id: "red-light-to-dark", fromColor: [255, 224, 224], toColor: [143, 10, 10] }, { id: "red-to-blue-diverging-bright", type: "multipart", colorRamps: [{ fromColor: [196, 69, 57], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [48, 95, 207] }] }, { id: "red-to-blue-diverging-dark", type: "multipart", colorRamps: [{ fromColor: [107, 13, 13], toColor: [204, 204, 102] }, { fromColor: [204, 204, 102], toColor: [13, 53, 97] }] }, { id: "red-to-green", type: "multipart", colorRamps: [{ fromColor: [245, 0, 0], toColor: [245, 245, 0] }, { fromColor: [245, 245, 0], toColor: [0, 245, 0] }] }, { id: "red-to-green-diverging-bright", type: "multipart", colorRamps: [{ fromColor: [186, 20, 20], toColor: [255, 255, 191] }, { fromColor: [255, 255, 191], toColor: [54, 145, 33] }] }, { id: "red-to-green-diverging-dark", type: "multipart", colorRamps: [{ fromColor: [97, 21, 13], toColor: [204, 204, 102] }, { fromColor: [204, 204, 102], toColor: [16, 69, 16] }] }, { id: "slope", type: "multipart", colorRamps: [{ fromColor: [56, 168, 0], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [255, 0, 0] }] }, { id: "spectrum-full-bright", type: "multipart", colorRamps: [{ fromColor: [255, 0, 0], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [0, 255, 255] }, { fromColor: [0, 255, 255], toColor: [0, 0, 255] }] }, { id: "spectrum-full-dark", type: "multipart", colorRamps: [{ fromColor: [153, 0, 0], toColor: [153, 153, 0] }, { fromColor: [153, 153, 0], toColor: [0, 153, 153] }, { fromColor: [0, 153, 153], toColor: [0, 0, 153] }] }, { id: "spectrum-full-light", type: "multipart", colorRamps: [{ fromColor: [255, 153, 153], toColor: [255, 255, 153] }, { fromColor: [255, 255, 153], toColor: [153, 255, 255] }, { fromColor: [153, 255, 255], toColor: [153, 153, 255] }] }, { id: "surface", type: "multipart", colorRamps: [{ fromColor: [112, 153, 89], toColor: [242, 238, 162] }, { fromColor: [242, 238, 162], toColor: [242, 206, 133] }, { fromColor: [242, 206, 133], toColor: [194, 140, 124] }, { fromColor: [194, 140, 124], toColor: [255, 242, 255] }] }, { id: "temperature", type: "multipart", colorRamps: [{ fromColor: [255, 252, 255], toColor: [255, 0, 255] }, { fromColor: [255, 0, 255], toColor: [0, 0, 255] }, { fromColor: [0, 0, 255], toColor: [0, 255, 255] }, { fromColor: [0, 255, 255], toColor: [0, 255, 0] }, { fromColor: [0, 255, 0], toColor: [255, 255, 0] }, { fromColor: [255, 255, 0], toColor: [255, 128, 0] }, { fromColor: [255, 128, 0], toColor: [128, 0, 0] }] }, { id: "white-to-black", fromColor: [255, 255, 255], toColor: [0, 0, 0] }, { id: "yellow-to-dark-red", type: "multipart", colorRamps: [{ fromColor: [255, 255, 128], toColor: [242, 167, 46] }, { fromColor: [242, 167, 46], toColor: [107, 0, 0] }] }, { id: "yellow-to-green-to-dark-blue", type: "multipart", colorRamps: [{ fromColor: [255, 255, 128], toColor: [56, 224, 9] }, { fromColor: [56, 224, 9], toColor: [26, 147, 171] }, { fromColor: [26, 147, 171], toColor: [12, 16, 120] }] }, { id: "yellow-to-red", fromColor: [245, 245, 0], toColor: [255, 0, 0] }, { id: "yellow-green-bright", fromColor: [236, 252, 204], toColor: [157, 204, 16] }, { id: "yellow-green-light-to-dark", fromColor: [215, 240, 175], toColor: [96, 107, 45] }];
var m5 = new o({ Aspect: "aspect", "Black to White": "black-to-white", "Blue Bright": "blue-bright", "Blue Light to Dark": "blue-light-to-dark", "Blue-Green Bright": "blue-green-bright", "Blue-Green Light to Dark": "blue-green-light-to-dark", "Brown Light to Dark": "brown-light-to-dark", "Brown to Blue Green Diverging, Bright": "brown-to-blue-green-diverging-right", "Brown to Blue Green Diverging, Dark": "brown-to-blue-green-diverging-dark", "Coefficient Bias": "coefficient-bias", "Cold to Hot Diverging": "cold-to-hot-diverging", "Condition Number": "condition-number", "Cyan to Purple": "cyan-to-purple", "Cyan-Light to Blue-Dark": "cyan-light-to-blue-dark", Distance: "distance", "Elevation #1": "elevation1", "Elevation #2": "elevation2", Errors: "errors", "Gray Light to Dark": "gray-light-to-dark", "Green Bright": "green-bright", "Green Light to Dark": "green-light-to-dark", "Green to Blue": "green-to-blue", "Orange Bright": "orange-bright", "Orange Light to Dark": "orange-light-to-dark", "Partial Spectrum": "partial-spectrum", "Partial Spectrum 1 Diverging": "partial-spectrum-1-diverging", "Partial Spectrum 2 Diverging": "partial-spectrum-2-diverging", "Pink to YellowGreen Diverging, Bright": "pink-to-yellow-green-diverging-bright", "Pink to YellowGreen Diverging, Dark": "pink-to-yellow-green-diverging-dark", Precipitation: "precipitation", Prediction: "prediction", "Purple Bright": "purple-bright", "Purple to Green Diverging, Bright": "purple-to-green-diverging-bright", "Purple to Green Diverging, Dark": "purple-to-green-diverging-dark", "Purple-Blue Bright": "purple-blue-bright", "Purple-Blue Light to Dark": "purple-blue-light-to-dark", "Purple-Red Bright": "purple-red-bright", "Purple-Red Light to Dark": "purple-red-light-to-dark", "Red Bright": "red-bright", "Red Light to Dark": "red-light-to-dark", "Red to Blue Diverging, Bright": "red-to-blue-diverging-bright", "Red to Blue Diverging, Dark": "red-to-blue-diverging-dark", "Red to Green": "red-to-green", "Red to Green Diverging, Bright": "red-to-green-diverging-bright", "Red to Green Diverging, Dark": "red-to-green-diverging-dark", Slope: "slope", "Spectrum-Full Bright": "spectrum-full-bright", "Spectrum-Full Dark": "spectrum-full-dark", "Spectrum-Full Light": "spectrum-full-light", Surface: "surface", Temperature: "temperature", "White to Black": "white-to-black", "Yellow to Dark Red": "yellow-to-dark-red", "Yellow to Green to Dark Blue": "yellow-to-green-to-dark-blue", "Yellow to Red": "yellow-to-red", "Yellow-Green Bright": "yellow-green-bright", "Yellow-Green Light to Dark": "yellow-green-light-to-dark" });
function a14(o13, r14) {
  if (!o13 || !r14 || o13.length !== r14.length) return false;
  for (let t8 = 0; t8 < o13.length; t8++) if (o13[t8] > r14[t8] + 2 || o13[t8] < r14[t8] - 2) return false;
  return true;
}
function g3(o13) {
  const r14 = o13.clone();
  return r14.fromColor = o13.toColor, r14.toColor = o13.fromColor, r14;
}
function p4(o13) {
  if ("multipart" === o13.type) {
    const r14 = o13.clone();
    return r14.colorRamps?.length ? (r14.colorRamps = r14.colorRamps.reverse().map((o14) => g3(o14)), r14) : r14;
  }
  return g3(o13);
}
function u9(o13, r14) {
  const t8 = r14 ?? C4;
  if ("algorithmic" === o13.type) {
    const r15 = o13.fromColor.toRgb(), l7 = o13.toColor.toRgb();
    return t8.find((o14) => a14(r15, o14.fromColor) && a14(l7, o14.toColor))?.id;
  }
  if (o13.weights?.length) return;
  const l6 = o13.colorRamps?.map((o14) => ({ fromColor: o14.fromColor.toRgb(), toColor: o14.toColor.toRgb() }));
  return t8.find((o14) => {
    const r15 = o14.colorRamps;
    return !(!l6 || !r15 || l6.length !== r15.length) && r15.every((o15, r16) => a14(l6[r16].fromColor, o15.fromColor) && a14(l6[r16].toColor, o15.toColor));
  })?.id;
}
function f5(o13, r14, t8 = false) {
  if (!o13) return;
  let l6 = false, e7 = u9(o13, r14);
  return null != e7 || t8 || (l6 = true, e7 = u9(o13 = p4(o13), r14)), e7 ? { id: e7, inverted: l6 } : void 0;
}
function s5(o13, r14 = false) {
  const t8 = "string" == typeof o13 ? o13 : f5(o13, void 0, r14)?.id;
  return t8 ? m5.toJSON(t8) : null;
}
function d4(o13, r14 = "esriCIELabAlgorithm") {
  const t8 = C4.find(({ id: r15 }) => r15 === o13);
  return t8 ? t8.colorRamps ? { type: "multipart", colorRamps: t8.colorRamps.map((o14) => ({ type: "algorithmic", algorithm: r14, fromColor: [...o14.fromColor], toColor: [...o14.toColor] })) } : { type: "algorithmic", algorithm: r14, fromColor: [...t8.fromColor], toColor: [...t8.toColor] } : null;
}
function c5(o13) {
  o13 ??= {};
  const r14 = o13.numColors || 256, t8 = o13.distanceOffset || 0, l6 = null != o13.isCustomInterval ? o13.isCustomInterval : null !== o13.distanceInterval && o13.distanceInterval !== 1 / (r14 - 1), e7 = o13.distanceInterval || 1 / (r14 - 1);
  return { ...o13, numColors: r14, distanceOffset: t8, interpolateAlpha: !!o13.interpolateAlpha, distanceInterval: e7, isCustomInterval: l6, weights: o13.weights };
}
function h5(o13, r14, t8) {
  const { numColors: l6, distanceOffset: e7, distanceInterval: i12, isCustomInterval: n15 } = t8, C5 = 0 === o13.s, m6 = 0 === r14.s;
  let a16 = o13.h, g4 = r14.h;
  C5 && !m6 ? a16 = g4 : m6 && !C5 && (r14 = { ...r14, h: a16 }, g4 = a16);
  let p5 = Math.abs(g4 - a16), u11 = 0;
  const f6 = 360;
  p5 < f6 / 2 ? u11 = (g4 - a16) * i12 : (p5 = f6 - p5, u11 = a16 > g4 ? p5 * i12 : -p5 * i12);
  const s6 = (r14.s - o13.s) * i12, d5 = (r14.v - o13.v) * i12;
  let { s: c6, v: h6 } = o13, b5 = a16;
  if (e7) {
    const o14 = e7 / i12;
    b5 = (b5 + o14 * u11 + f6) % f6, c6 += o14 * s6, h6 += o14 * d5;
  }
  const v6 = [];
  for (let y5 = 0; y5 < l6 - 1; y5++) v6.push({ h: b5, s: c6, v: h6 }), b5 = (b5 + u11 + f6) % f6, c6 += s6, h6 += d5;
  return v6.push(n15 ? { h: b5, s: c6, v: h6 } : r14), v6;
}
function b4(o13, r14, t8) {
  const { numColors: l6, distanceOffset: e7, distanceInterval: i12, isCustomInterval: n15 } = t8;
  let { l: C5, a: m6, b: a16 } = o13;
  const g4 = (r14.l - C5) * i12, p5 = (r14.a - m6) * i12, u11 = (r14.b - a16) * i12, f6 = [];
  if (e7) {
    const o14 = e7 / i12;
    C5 += o14 * g4, m6 += o14 * p5, a16 += o14 * u11;
  }
  for (let s6 = 0; s6 < l6 - 1; s6++) f6.push({ l: C5, a: m6, b: a16 }), C5 += g4, m6 += p5, a16 += u11;
  return f6.push(n15 ? { l: C5, a: m6, b: a16 } : r14), f6;
}
function v4(o13, r14, t8) {
  const { numColors: l6, distanceOffset: e7, distanceInterval: i12, isCustomInterval: n15 } = t8, C5 = o13.h, m6 = r14.h, a16 = 2 * Math.PI;
  let g4 = 0;
  if (C5 <= m6) {
    const o14 = m6 - C5, r15 = m6 - C5 - a16;
    g4 = Math.abs(r15) < Math.abs(o14) ? r15 : o14;
  } else {
    const o14 = m6 + a16 - C5, r15 = m6 - C5;
    g4 = Math.abs(r15) < Math.abs(o14) ? r15 : o14;
  }
  const p5 = g4 * i12, u11 = (r14.l - o13.l) * i12, f6 = (r14.c - o13.c) * i12;
  let { l: s6, c: d5, h: c6 } = o13;
  if (e7) {
    const o14 = e7 / i12;
    s6 += o14 * u11, d5 += o14 * f6, c6 = (c6 + o14 * p5 + a16) % a16;
  }
  const h6 = [];
  for (let b5 = 0; b5 < l6 - 1; b5++) h6.push({ l: s6, c: d5, h: c6 }), s6 += u11, d5 += f6, c6 = (c6 + p5 + a16) % a16;
  return h6.push(n15 ? { l: s6, c: d5, h: c6 } : r14), h6;
}
function y4(e7, i12) {
  const { fromColor: n15, toColor: C5 } = e7, m6 = 3 === n15.length ? [...n15, 255] : [...n15], a16 = 3 === C5.length ? [...C5, 255] : [...C5], g4 = e7.algorithm || "esriCIELabAlgorithm", p5 = c5(i12), { numColors: u11, distanceOffset: f6, isCustomInterval: s6, interpolateAlpha: d5 } = p5;
  if (1 === u11 && 0 === f6) return [m6];
  if (2 === u11 && 0 === f6 && !s6) return [m6, a16];
  const y5 = { r: m6[0], g: m6[1], b: m6[2] }, k5 = { r: a16[0], g: a16[1], b: a16[2] }, R4 = "esriCIELabAlgorithm" === g4 ? b4(C(y5), C(k5), p5) : "esriHSVAlgorithm" === g4 ? h5(B(y5), B(k5), p5) : v4(q(y5), q(k5), p5), w5 = [], B4 = m6[3] ?? 255, D4 = ((a16[3] ?? 255) - B4) / (u11 - 1);
  for (let o13 = 0; o13 < u11; o13++) {
    const { r: r14, g: t8, b: e8 } = U(R4[o13]), i13 = d5 ? Math.round(B4 + D4 * o13) : 255;
    w5.push([r14, t8, e8, i13]);
  }
  return w5;
}
function k4(o13, r14) {
  const { colorRamps: t8 } = o13;
  if (r14 ??= t8.map(({ start: o14, stop: r15 }) => null == o14 || null == r15 ? -1 : r15 - o14), r14.length !== t8.length || r14.some((o14) => o14 < 0)) return Array.from({ length: t8.length }, () => 1 / t8.length);
  const l6 = r14.reduce((o14, r15) => o14 + r15);
  return r14.map((o14) => o14 / l6);
}
function R3(o13, r14) {
  const { numColors: t8, interpolateAlpha: l6 } = c5(r14), e7 = k4(o13, r14?.weights), { colorRamps: i12 } = o13, n15 = [], C5 = 1 / (t8 - 1);
  let m6 = 0, a16 = false;
  for (let p5 = 0; p5 < i12.length; p5++) {
    const o14 = n15.length, r15 = a16 ? 0 : o14 * C5 - m6;
    m6 += e7[p5];
    let g5 = p5 === i12.length - 1 ? t8 - 1 - o14 : (e7[p5] - r15) / C5;
    if (a16 = Math.ceil(g5) === g5, g5 = Math.ceil(g5), 0 === g5) continue;
    const u11 = y4(i12[p5], { numColors: g5, interpolateAlpha: l6, distanceOffset: r15 / e7[p5], distanceInterval: C5 / e7[p5] });
    n15.push(...u11);
  }
  const g4 = [...i12[i12.length - 1].toColor];
  return 3 === g4.length && g4.push(255), n15.push(g4), n15;
}
function w4(o13, r14) {
  const t8 = t(o13) ? o13.toJSON() : o13;
  return "multipart" === t8.type ? R3(t8, r14) : y4(t8, r14);
}
function B3(o13, r14) {
  const t8 = w4(o13, r14), l6 = r14?.interpolateAlpha;
  return t8.forEach((o14, r15) => {
    o14.unshift(r15), l6 || o14.pop();
  }), t8;
}
function D3(r14) {
  const t8 = [];
  for (let l6 = 0; l6 < r14.length; l6 += 4) {
    const e7 = B({ r: r14[l6], g: r14[l6 + 1], b: r14[l6 + 2] });
    t8.push([e7.h / 60, e7.s / 100, 255 * e7.v / 100]);
  }
  return t8;
}
function I3(r14) {
  const t8 = B(r14);
  return { type: "HsvColor", Hue: t8.h, Saturation: t8.s, Value: t8.v, AlphaValue: 255 };
}
function A3(o13) {
  const r14 = o13.toJSON();
  return { Algorithm: r14?.Algorithm || "esriHSVAlgorithm", type: "AlgorithmicColorRamp", FromColor: I3(o13.fromColor), ToColor: I3(o13.toColor) };
}
function G2(o13) {
  const r14 = s5(o13);
  if (!r14) return null;
  if ("algorithmic" === o13.type) return { ...A3(o13), Name: r14 };
  if (o13.colorRamps) {
    const t8 = o13.colorRamps.map(A3);
    return { type: "MultiPartColorRamp", NumColorRamps: t8.length, ArrayOfColorRamp: t8, Name: r14 };
  }
  return null;
}
function P3(o13) {
  const r14 = [...o13].reverse().map((o14) => {
    const r15 = o14.toString(16);
    return r15.length < 2 ? "0" + r15 : r15;
  });
  return 4294967295 & Number.parseInt(r14.join(""), 16);
}

// node_modules/@arcgis/core/renderers/support/rasterRendererChecks.js
function n14(n15) {
  return ["u8", "s8"].includes(n15.pixelType) && null != n15.statistics?.[0]?.min && null != n15.statistics[0]?.max && 1 === n15.bandCount;
}
function t7(t8, e7) {
  const { attributeTable: u11, bandCount: r14 } = t8;
  if (null == u11 && n14(t8)) return true;
  if (null == u11 || r14 > 1) return false;
  if (e7) {
    if (null == u11.fields.find((n15) => n15.name.toLowerCase() === e7.toLowerCase())) return false;
  }
  return true;
}
function e6(n15) {
  const { bandCount: t8, dataType: e7, pixelType: u11 } = n15;
  return "elevation" === e7 || "generic" === e7 && 1 === t8 && ("s16" === u11 || "s32" === u11 || "f32" === u11 || "f64" === u11);
}
function u10(n15, t8 = false) {
  const { bandCount: e7, colormap: u11, pixelType: r14 } = n15;
  return 1 === e7 && (!!u11?.length || !t8 && "u8" === r14);
}
function r13(n15, t8 = false) {
  const { attributeTable: e7, bandCount: u11 } = n15;
  return 1 === u11 && (!t8 || null != e7 || null != n15.histograms);
}
function o12(n15) {
  const { dataType: t8 } = n15;
  return "vector-uv" === t8 || "vector-magdir" === t8;
}
function i11(n15) {
  const { dataType: t8 } = n15;
  return "vector-uv" === t8 || "vector-magdir" === t8;
}
function a15(n15) {
  return !!n15?.length && n15.length <= 16384;
}

// node_modules/@arcgis/core/renderers/support/RasterSymbolizer.js
var O4 = class extends n3 {
  constructor(e7) {
    super(e7), this.lookup = { rendererJSON: {} }, this.canRenderInWebGL = false;
  }
  bind() {
    const { rendererJSON: e7 } = this;
    if (!e7) return { success: false };
    let t8;
    switch (this.lookup = { rendererJSON: {} }, e7.type) {
      case "uniqueValue":
        t8 = this._updateUVRenderer(e7);
        break;
      case "rasterColormap":
        t8 = this._updateColormapRenderer(e7);
        break;
      case "rasterStretch":
        t8 = this._updateStretchRenderer(e7);
        break;
      case "classBreaks":
        t8 = this._updateClassBreaksRenderer(e7);
        break;
      case "rasterShadedRelief":
        t8 = this._updateShadedReliefRenderer(e7);
        break;
      case "vectorField":
        t8 = this._updateVectorFieldRenderer();
        break;
      case "flowRenderer":
        t8 = this._updateFlowRenderer();
    }
    return t8;
  }
  symbolize(e7) {
    let t8 = e7?.pixelBlock;
    if (!T3(t8)) return t8;
    if (e7.simpleStretchParams && "rasterStretch" === this.rendererJSON.type) return this.simpleStretch(t8, e7.simpleStretchParams);
    try {
      let r14;
      switch (t8.pixels.length > 3 && (t8 = t8.extractBands(e7.bandIds ?? [0, 1, 2])), this.rendererJSON.type) {
        case "uniqueValue":
        case "rasterColormap":
          r14 = this._symbolizeColormap(t8);
          break;
        case "classBreaks":
          r14 = this._symbolizeClassBreaks(t8);
          break;
        case "rasterStretch":
          r14 = this._symbolizeStretch(t8, e7.bandIds);
          break;
        case "rasterShadedRelief": {
          const s6 = e7.extent, a16 = s6.spatialReference.isGeographic, o13 = { x: (s6.xmax - s6.xmin) / t8.width, y: (s6.ymax - s6.ymin) / t8.height };
          r14 = this._symbolizeShadedRelief(t8, { isGCS: a16, resolution: o13 });
          break;
        }
      }
      return r14;
    } catch (s6) {
      return i.getLogger(this).error("symbolize", s6.message), t8;
    }
  }
  simpleStretch(e7, t8) {
    if (!T3(e7)) return e7;
    try {
      return e7.pixels.length > 3 && (e7 = e7.extractBands([0, 1, 2])), z2(e7, { ...t8, isRenderer: true });
    } catch (s6) {
      return i.getLogger(this).error("symbolize", s6.message), e7;
    }
  }
  generateWebGLParameters(e7) {
    const { rendererJSON: t8 } = this;
    switch (t8.type) {
      case "uniqueValue":
      case "rasterColormap":
      case "classBreaks":
        return this._generateColormapWebGLParams("classBreaks" === t8.type);
      case "rasterStretch":
        return this._generateStretchWebGLParams(e7.pixelBlock, t8, e7.bandIds);
      case "rasterShadedRelief":
        return this._generateShadedReliefWebGLParams(t8, e7.isGCS, e7.resolution ?? void 0);
      case "vectorField":
        return this._generateVectorFieldWebGLParams(t8);
      default:
        return null;
    }
  }
  _isLUTChanged(e7) {
    const t8 = this.lookup.rendererJSON;
    if (!t8) return true;
    const { rendererJSON: r14 } = this;
    if ("colorRamp" in r14 && r14.colorRamp) {
      const s6 = r14.colorRamp;
      if (e7) return JSON.stringify(s6) !== JSON.stringify(t8.colorRamp);
    }
    return JSON.stringify(r14) !== JSON.stringify(t8);
  }
  _symbolizeColormap(e7) {
    if (this._isLUTChanged()) {
      if (!this.bind().success) return e7;
    }
    return h(e7, this.lookup.colormapLut);
  }
  _symbolizeClassBreaks(e7) {
    const { canUseIndexedLUT: t8 } = this._analyzeClassBreaks(this.rendererJSON);
    if (this._isLUTChanged()) {
      if (!this.bind().success) return e7;
    }
    return t8 ? h(e7, this.lookup.colormapLut) : p(e7, this.lookup.remapLut ?? []);
  }
  _symbolizeStretch(e7, t8) {
    if (!e7) return null;
    const { rasterInfo: r14, lookup: s6 } = this, { pixelType: a16, bandCount: o13 } = r14, n15 = this.rendererJSON, l6 = ["u8", "u16", "s8", "s16"].includes(a16);
    let c6;
    const { dra: p5 } = n15, { gamma: b5 } = s6;
    if (p5 && (t8 = null), "histogramEqualization" === n15.stretchType) {
      const a17 = p5 ? null : s6.histogramLut, o14 = b3(n15, { rasterInfo: r14, pixelBlock: e7, bandIds: t8, returnHistogramLut: !a17 }), i12 = "u8" === r14.pixelType && !p5 && a10(r14.histograms?.[0]) ? e7 : z2(e7, { ...o14, gamma: b5, isRenderer: true });
      c6 = f2(i12, { lut: p5 ? o14.histogramLut : t8?.length ? t8.map((e8) => a17[e8]) : a17, offset: 0 });
    } else if (l6) {
      let i12;
      if (p5) {
        const s7 = b3(n15, { rasterInfo: r14, pixelBlock: e7, bandIds: t8 });
        i12 = l3({ pixelType: a16, ...s7, gamma: b5, rounding: "floor" });
      } else {
        if (this._isLUTChanged()) {
          if (!this.bind().success) return e7;
        }
        i12 = s6.stretchLut;
      }
      if (!i12) return e7;
      o13 > 1 && null != t8 && t8.length === e7?.pixels.length && i12.lut.length === o13 && (i12 = { lut: t8.map((e8) => i12.lut[e8]), offset: i12.offset }), c6 = f2(e7, i12);
    } else {
      const s7 = b3(n15, { rasterInfo: r14, pixelBlock: e7, bandIds: t8 });
      c6 = z2(e7, { ...s7, gamma: b5, isRenderer: true });
    }
    if (n15.colorRamp) {
      if (this._isLUTChanged(true)) {
        if (!this.bind().success) return e7;
      }
      c6 = h(c6, s6.colormapLut);
    }
    return c6;
  }
  _symbolizeShadedRelief(e7, t8) {
    const r14 = this.rendererJSON, s6 = { ...r14, ...t8 }, a16 = r12(e7, s6);
    if (!r14.colorRamp) return a16;
    if (this._isLUTChanged(true)) {
      if (!this.bind().success) return a16;
    }
    const { hsvMap: o13 } = this.lookup;
    if (!o13) return a16;
    const n15 = this.rasterInfo.statistics?.[0] ?? { min: 0, max: 8e3 };
    return c4(a16, e7, o13, n15), a16;
  }
  _isVectorFieldData() {
    const { bandCount: e7, dataType: t8 } = this.rasterInfo;
    return 2 === e7 && ("vector-magdir" === t8 || "vector-uv" === t8);
  }
  _updateVectorFieldRenderer() {
    return this._isVectorFieldData() ? { success: true } : { success: false, error: `Unsupported data type "${this.rasterInfo.dataType}"; VectorFieldRenderer only supports "vector-magdir" and "vector-uv".` };
  }
  _updateFlowRenderer() {
    return this._isVectorFieldData() ? { success: true } : { success: false, error: `Unsupported data type "${this.rasterInfo.dataType}"; FlowRenderer only supports "vector-magdir" and "vector-uv".` };
  }
  _updateUVRenderer(e7) {
    const { bandCount: t8, attributeTable: r14, pixelType: s6 } = this.rasterInfo, a16 = e7.field1;
    if (!a16) return { success: false, error: "Unsupported renderer; missing UniqueValueRenderer.field." };
    const o13 = e7.defaultSymbol, n15 = 1 === t8 && ["u8", "s8"].includes(s6);
    if (!t7(this.rasterInfo, a16) && !n15) return { success: false, error: "Unsupported data; UniqueValueRenderer is only supported on single band data with a valid raster attribute table." };
    const i12 = [];
    if (null != r14) {
      const t9 = r14.fields.find((e8) => "value" === e8.name.toLowerCase());
      if (!t9) return { success: false, error: "Unsupported data; the data's raster attribute table does not have a value field." };
      r14.features.forEach((r15) => {
        const s7 = e7.uniqueValueInfos?.find((e8) => String(e8.value) === String(r15.attributes[a16])), n16 = s7?.symbol?.color;
        n16 ? i12.push([r15.attributes[t9.name]].concat(n16)) : o13 && i12.push([r15.attributes[t9.name]].concat(o13.color));
      });
    } else {
      if ("value" !== a16.toLowerCase()) return { success: false, error: 'Unsupported renderer; UniqueValueRenderer.field must be "Value" when raster attribute table is not available.' };
      e7.uniqueValueInfos?.forEach((e8) => {
        const t9 = e8?.symbol?.color;
        t9 ? i12.push([parseInt("" + e8.value, 10)].concat(t9)) : o13 && i12.push([parseInt("" + e8.value, 10)].concat(o13?.color));
      });
    }
    if (0 === i12.length) return { success: false, error: "Invalid UniqueValueRenderer. Cannot find matching records in the raster attribute table." };
    const l6 = a4({ colormap: i12 });
    return this.lookup = { rendererJSON: e7, colormapLut: l6 }, this.canRenderInWebGL = a15(l6?.indexedColormap), { success: true };
  }
  _updateColormapRenderer(e7) {
    if (!u10(this.rasterInfo)) return { success: false, error: "Unsupported data; the data source does not have a colormap." };
    const t8 = e7.colormapInfos.map((e8) => [e8.value].concat(e8.color)).sort((e8, t9) => e8[0] - t9[0]);
    if (!t8 || 0 === t8.length) return { success: false, error: "Unsupported renderer; ColormapRenderer must have meaningful colormapInfos." };
    const r14 = a4({ colormap: t8 });
    return this.lookup = { rendererJSON: e7, colormapLut: r14 }, this.canRenderInWebGL = a15(r14?.indexedColormap), { success: true };
  }
  _updateShadedReliefRenderer(e7) {
    if (!e6(this.rasterInfo)) return { success: false, error: `Unsupported data type "${this.rasterInfo.dataType}"; ShadedReliefRenderer only supports "elevation", or single band float/s16 data.` };
    if (e7.colorRamp) {
      const t8 = B3(e7.colorRamp, { interpolateAlpha: true }), r14 = a4({ colormap: t8 }), s6 = D3(r14.indexedColormap);
      this.lookup = { rendererJSON: e7, colormapLut: r14, hsvMap: s6 };
    } else this.lookup = { rendererJSON: e7 };
    return this.canRenderInWebGL = true, { success: true };
  }
  _analyzeClassBreaks(e7) {
    const { attributeTable: t8, pixelType: r14 } = this.rasterInfo, s6 = t8?.fields.find((e8) => "value" === e8.name.toLowerCase()), a16 = t8?.fields.find((t9) => t9.name.toLowerCase() === e7.field.toLowerCase()), o13 = null != s6 && null !== a16;
    return { canUseIndexedLUT: ["u8", "u16", "s8", "s16"].includes(r14) || o13, tableValueField: s6, tableBreakField: a16 };
  }
  _updateClassBreaksRenderer(e7) {
    const { attributeTable: t8 } = this.rasterInfo, { canUseIndexedLUT: r14, tableValueField: s6, tableBreakField: a16 } = this._analyzeClassBreaks(e7), o13 = e7.classBreakInfos;
    if (!o13?.length) return { success: false, error: "Unsupported renderer; missing or invalid ClassBreaksRenderer.classBreakInfos." };
    const i12 = o13.sort((e8, t9) => e8.classMaxValue - t9.classMaxValue), l6 = i12[i12.length - 1];
    let u11 = e7.minValue;
    if (!r14) {
      const t9 = [];
      for (let e8 = 0; e8 < i12.length; e8++) t9.push({ value: i12[e8].classMinValue ?? u11, mappedColor: i12[e8].symbol.color }), u11 = i12[e8].classMaxValue;
      return t9.push({ value: l6.classMaxValue, mappedColor: l6.symbol.color }), this.lookup = { rendererJSON: e7, remapLut: t9 }, this.canRenderInWebGL = false, { success: true };
    }
    const p5 = [];
    if (null != t8 && null != s6 && null !== a16 && s6 !== a16) {
      const r15 = s6.name, o14 = a16.name, n15 = i12[i12.length - 1], { classMaxValue: l7 } = n15;
      u11 = e7.minValue;
      for (const e8 of t8.features) {
        const t9 = e8.attributes[r15], s7 = e8.attributes[o14], a17 = s7 === l7 ? n15 : s7 < u11 ? null : i12.find(({ classMaxValue: e9 }) => e9 > s7);
        a17 && p5.push([t9].concat(a17.symbol.color));
      }
    } else {
      const [t9, r15] = u2(this.rasterInfo.pixelType);
      u11 = Math.max(t9, Math.floor(e7.minValue));
      for (let e8 = 0; e8 < i12.length; e8++) {
        const t10 = i12[e8], s7 = Math.min(r15, Math.ceil(t10.classMaxValue));
        for (let e9 = u11; e9 < s7; e9++) p5.push([e9].concat(t10.symbol.color));
        u11 = s7;
      }
      l6.classMaxValue !== u11 && u11 !== r15 || p5.push([u11].concat(l6.symbol.color));
    }
    const d5 = a4({ colormap: p5, fillUnspecified: false });
    return this.lookup = { rendererJSON: e7, colormapLut: d5 }, this.canRenderInWebGL = a15(d5?.indexedColormap), { success: true };
  }
  _updateStretchRenderer(e7) {
    let { stretchType: t8, dra: r14 } = e7;
    if (!("none" === t8 || e7.statistics?.length || v5(this.rasterInfo.statistics) || r14)) return { success: false, error: "Unsupported renderer; StretchRenderer.customStatistics is required when dynamic range adjustment is not used." };
    const s6 = e7.histograms || this.rasterInfo.histograms;
    !V2(e7.stretchType) || s6?.length || r14 || (t8 = "minMax");
    const { computeGamma: a16, useGamma: o13, colorRamp: n15 } = e7;
    let { gamma: i12 } = e7;
    if (o13 && a16 && !i12?.length) {
      const t9 = e7.statistics?.length ? e7.statistics : this.rasterInfo.statistics;
      i12 = c3(this.rasterInfo.pixelType, t9);
    }
    const l6 = this.rasterInfo.pixelType, u11 = !r14 && ["u8", "u16", "s8", "s16"].includes(l6);
    if ("histogramEqualization" === t8) {
      const t9 = s6.map((e8) => r11(e8));
      this.lookup = { rendererJSON: e7, histogramLut: t9 };
    } else if (u11) {
      const t9 = b3(e7, { rasterInfo: this.rasterInfo }), r15 = l3({ pixelType: l6, ...t9, gamma: o13 ? i12 : null, rounding: "floor" });
      this.lookup = { rendererJSON: e7, stretchLut: r15 };
    } else this.lookup = { rendererJSON: e7 };
    if (n15 && !U4(n15)) {
      const t9 = B3(n15, { interpolateAlpha: true });
      this.lookup.colormapLut = a4({ colormap: t9 }), this.lookup.rendererJSON = e7;
    }
    return this.lookup.gamma = o13 && i12?.length ? i12 : null, this.canRenderInWebGL = "histogramEqualization" !== t8, { success: true };
  }
  _generateColormapWebGLParams(e7) {
    const { indexedColormap: t8, offset: r14 } = this.lookup.colormapLut || {};
    return { colormap: t8, colormapOffset: r14, isClassBreaks: e7, type: "lut" };
  }
  _generateStretchWebGLParams(e7, t8, r14) {
    const { colormapLut: s6 } = this.lookup, a16 = t8.colorRamp ? s6?.indexedColormap : null, o13 = t8.colorRamp ? s6?.offset : null;
    "histogramEqualization" === t8.stretchType && (t8 = { ...t8, stretchType: "minMax" });
    const { gamma: n15 } = this.lookup, i12 = !(!t8.useGamma || !n15?.some((e8) => 1 !== e8));
    let l6 = 0;
    null != e7 && (l6 = e7.getPlaneCount(), 2 === l6 && ((e7 = e7.clone()).statistics = [e7.statistics[0]], e7.pixels = [e7.pixels[0]]));
    const { bandCount: u11 } = this.rasterInfo, c6 = Math.min(3, r14?.length || l6 || u11, u11), p5 = a16 || i12 ? 1 : 255, d5 = new Float32Array(c6);
    if (i12 && n15) for (let m6 = 0; m6 < c6; m6++) n15[m6] > 1 ? n15[m6] > 2 ? d5[m6] = 6.5 + (n15[m6] - 2) ** 2.5 : d5[m6] = 6.5 + 100 * (2 - n15[m6]) ** 4 : d5[m6] = 1;
    const h6 = i12 && n15 ? [n15[0], n15[1] ?? n15[0], n15[2] ?? n15[0]] : [1, 1, 1], f6 = i12 ? [d5[0], d5[1] ?? d5[0], d5[2] ?? d5[0]] : [1, 1, 1];
    if (t8.dra && null == e7 && ("minMax" === t8.stretchType || "standardDeviation" === t8.stretchType)) return { bandCount: c6, minOutput: (t8.min ?? 0) / p5, maxOutput: (t8.max ?? 255) / p5, minCutOff: [0, 0, 0], maxCutOff: [1, 1, 1], factor: [1, 1, 1], useGamma: i12, gamma: h6, gammaCorrection: f6, colormap: a16, colormapOffset: o13, stretchType: t8.stretchType, dynamicRangeAdjustment: t8.dra, numberOfStandardDeviations: t8.numberOfStandardDeviations ?? 2, type: "stretch" };
    const { minCutOff: b5, maxCutOff: y5, minOutput: g4, maxOutput: x4 } = b3(t8, { rasterInfo: this.rasterInfo, pixelBlock: e7, bandIds: r14 });
    1 === b5.length && (b5[2] = b5[1] = b5[0]), 1 === y5.length && (y5[2] = y5[1] = y5[0]);
    const S4 = y5.map((e8, t9) => y5[t9] === b5[t9] ? 0 : (x4 - g4) / (y5[t9] - b5[t9]) / p5);
    return { bandCount: c6, minOutput: g4 / p5, maxOutput: x4 / p5, minCutOff: b5, maxCutOff: y5, factor: S4, useGamma: i12, gamma: h6, gammaCorrection: f6, colormap: a16, colormapOffset: o13, stretchType: t8.stretchType, type: "stretch" };
  }
  _generateShadedReliefWebGLParams(e7, t8 = false, r14 = { x: 0, y: 0 }) {
    const { colormapLut: s6 } = this.lookup, a16 = e7.colorRamp ? s6?.indexedColormap : null, o13 = e7.colorRamp ? s6?.offset : null, n15 = { ...e7, isGCS: t8, resolution: r14 }, i12 = a13(n15), l6 = this.rasterInfo.statistics?.[0];
    return { ...i12, minValue: l6?.min ?? 0, maxValue: l6?.max ?? 8e3, hillshadeType: "traditional" === e7.hillshadeType ? 0 : 1, type: "hillshade", colormap: a16, colormapOffset: o13 };
  }
  _generateVectorFieldWebGLParams(e7) {
    const { style: t8, inputUnit: r14, outputUnit: s6, visualVariables: a16, symbolTileSize: o13, flowRepresentation: n15 } = e7, i12 = this.rasterInfo.statistics?.[0].min ?? 0, l6 = this.rasterInfo.statistics?.[0].max ?? 50, u11 = a16?.find((e8) => "sizeInfo" === e8.type) ?? { maxDataValue: l6, maxSize: 0.8 * o13, minDataValue: i12, minSize: 0.2 * o13 }, c6 = u11.minDataValue ?? i12, p5 = u11.maxDataValue ?? l6, d5 = null != u11.maxSize && null != u11.minSize ? [u11.minSize / o13, u11.maxSize / o13] : [0.2, 0.8];
    if ("wind_speed" === t8) {
      const e8 = (d5[0] + d5[1]) / 2;
      d5[0] = d5[1] = e8;
    }
    const m6 = null != c6 && null != p5 ? [c6, p5] : null;
    let h6 = null;
    if ("classified_arrow" === t8) if (null != c6 && null != p5 && null != u11) {
      h6 = [];
      const e8 = (u11.maxDataValue - u11.minDataValue) / 5;
      for (let t9 = 0; t9 < 6; t9++) h6.push(u11.minDataValue + e8 * t9);
    } else h6 = [0, 1e-6, 3.5, 7, 10.5, 14];
    const f6 = "flow_to" === n15 === ("ocean_current_kn" === t8 || "ocean_current_m" === t8) ? 0 : Math.PI, b5 = a16?.find((e8) => "rotationInfo" === e8.type);
    return { breakValues: h6, dataRange: m6, inputUnit: r14, outputUnit: s6, symbolTileSize: o13, symbolPercentRange: d5, style: t8 || "single_arrow", rotation: f6, rotationType: this.rasterInfo.storageInfo?.tileInfo && "vector-uv" === this.rasterInfo.dataType ? "geographic" : b5?.rotationType || e7.rotationType, type: "vectorField" };
  }
};
function V2(e7) {
  return "percentClip" === e7 || "histogramEqualization" === e7;
}
function v5(e7) {
  return null != e7 && e7.length > 0 && null != e7[0].min && null != e7[0].max;
}
function T3(e7) {
  return o4(e7) && 0 !== e7.validPixelCount;
}
function U4(e7) {
  return "algorithmic" === e7.type && ["0,0,0,255", "0,0,0"].includes(e7.fromColor.join(",")) && ["255,255,255,255", "255,255,255"].includes(e7.toColor.join(","));
}
__decorate([m({ json: { write: true } })], O4.prototype, "rendererJSON", void 0), __decorate([m({ type: m4, json: { write: true } })], O4.prototype, "rasterInfo", void 0), __decorate([m({ json: { write: true } })], O4.prototype, "lookup", void 0), __decorate([m()], O4.prototype, "canRenderInWebGL", void 0), O4 = __decorate([a2("esri.renderers.support.RasterSymbolizer")], O4);

export {
  r9 as r,
  e5 as e,
  t5 as t,
  r10 as r2,
  N,
  k,
  C2 as C,
  G,
  v,
  H,
  Y,
  L2 as L,
  R2 as R,
  a11 as a,
  i10 as i,
  n10 as n,
  l4 as l,
  m4 as m,
  n12 as n2,
  a13 as a2,
  r12 as r3,
  c4 as c,
  h4 as h,
  u8 as u,
  f4 as f,
  d3 as d,
  n13 as n3,
  C4 as C2,
  m5 as m2,
  s5 as s,
  d4 as d2,
  w4 as w,
  B3 as B,
  D3 as D,
  G2,
  P3 as P,
  t7 as t2,
  e6 as e2,
  u10 as u2,
  r13 as r4,
  o12 as o,
  i11 as i2,
  a15 as a3,
  n8 as n4,
  a9 as a4,
  l3 as l2,
  u5 as u3,
  k3 as k2,
  y3 as y,
  v3 as v2,
  b3 as b,
  w3 as w2,
  z2 as z,
  O4 as O
};
//# sourceMappingURL=chunk-TNGDEFWZ.js.map
