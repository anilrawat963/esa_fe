import {
  N as N2,
  b,
  j,
  q
} from "./chunk-NTNXXNRP.js";
import {
  c,
  h
} from "./chunk-IGRCAVBL.js";
import {
  n as n4
} from "./chunk-B3BLJNSM.js";
import {
  _,
  n as n3
} from "./chunk-WDTGOP77.js";
import {
  H,
  o,
  s
} from "./chunk-VYMBX5H5.js";
import {
  a,
  n as n2
} from "./chunk-5ONGWFJ3.js";
import {
  n
} from "./chunk-75XOUSSS.js";
import {
  L
} from "./chunk-AZXJIEZ6.js";
import {
  N2 as N,
  T
} from "./chunk-NMQNUPE4.js";

// node_modules/@arcgis/core/views/support/angularMeasurementUtils.js
function j2(e, r) {
  if (null == e || null == r) return;
  const o2 = b2(e, r);
  return null != o2 ? c(o2, "radians", "geographic") : void 0;
}
var b2 = (() => {
  const e = n(), r = n();
  return (t, o2) => (o(e, t.x, t.y, t.z ?? 0), o(r, o2.x, o2.y, o2.z ?? 0), y(e, r, t.spatialReference, o2.spatialReference));
})();
var y = (() => {
  const e = n3(), r = n(), t = n();
  return (o2, s2, l, u) => {
    if (H(o2, s2)) return;
    const f = N2(l), d = N2(u);
    if (f && d && T(f, d) && n4(o2, l, r, f) && n4(s2, u, t, d)) {
      const { azimuth: e2 } = q(k, r, t, f);
      return null != e2 ? N(e2, "degrees", "radians") : void 0;
    }
    e[0] = s2[0] - o2[0], e[1] = s2[1] - o2[1];
    let h2 = L(_, e);
    return e[0] < 0 && (h2 = C - h2), h2;
  };
})();
function x(e, r, t, o2 = "absolute") {
  if (r && t) switch (o2) {
    case "absolute":
      return j2(r, t);
    case "relative":
      return w(z(e, r, t), "relative");
    case "relative-bilateral":
      return w(z(e, r, t), "relative-bilateral");
  }
}
function z(e, r, o2) {
  if (!e || !r || !o2) return;
  const i = b2(e, r), n5 = b2(r, o2);
  return null != i && null != n5 ? c(n5 - i, "radians", "geographic") : void 0;
}
function w(e, r) {
  if (null != e) switch (r) {
    case "absolute":
      return M(e);
    case "relative": {
      const r2 = R(e);
      let o2 = P.normalize(r2, 0, true);
      return -180 === o2 && (o2 = 180), c(o2, "degrees", "geographic");
    }
    case "relative-bilateral": {
      const r2 = R(e), o2 = Math.abs(P.normalize(r2, 0, true));
      return c(o2, "degrees", "geographic");
    }
  }
}
function M(e) {
  const r = R(e), o2 = I.normalize(r, 0, true);
  return c(o2, "degrees", "geographic");
}
var U = (() => {
  const e = n();
  return (r, t, n5, s2, a2, c2 = "geodesic") => {
    s(e, t);
    const f = R(a2);
    if ("geodesic" === c2) {
      const o2 = N2(n5);
      if (o2 && n4(e, n5, e, o2)) return j(r, e, f, s2, o2), r[2] = t[2], !!n4(r, o2, r, n5);
    }
    const p = h(f, "geographic", "arithmetic"), d = N(p, "degrees", "radians"), v = t[0] + s2 * Math.cos(d), j3 = t[1] + s2 * Math.sin(d), b3 = t[2];
    return o(r, v, j3, b3), true;
  };
})();
function R(e) {
  if (null != e) return h(V(e), e.rotationType, "geographic");
}
function q2(e) {
  if (null != e) return h(V(e), e.rotationType, "arithmetic");
}
function V(e) {
  return N(e.value, e.unit, "degrees");
}
var k = new b();
var C = 2 * Math.PI;
var I = a;
var P = new n2(-180, 180);

export {
  j2 as j,
  y,
  x,
  w,
  M,
  U,
  R,
  q2 as q
};
//# sourceMappingURL=chunk-VHCNEAMV.js.map
