import {
  F,
  L2 as L,
  N,
  Ne,
  f as f3,
  w
} from "./chunk-6KSX5BD3.js";
import "./chunk-BYU7VMB6.js";
import "./chunk-BTFBYI67.js";
import "./chunk-D3G5WIRR.js";
import "./chunk-Q3JOE7TC.js";
import "./chunk-URFJA5XM.js";
import {
  ue
} from "./chunk-LH5BO2EF.js";
import "./chunk-XPO6OCCI.js";
import "./chunk-43UUQEW5.js";
import "./chunk-UOYGNM27.js";
import "./chunk-QPBITBUR.js";
import "./chunk-PJJUVY7C.js";
import "./chunk-7VJQTJLO.js";
import "./chunk-VVMIB6RA.js";
import "./chunk-SQ4OSZIG.js";
import "./chunk-MA6OR5A6.js";
import "./chunk-RCHRSC54.js";
import "./chunk-ZEI5DZXH.js";
import "./chunk-RGWH5UES.js";
import {
  l as l3
} from "./chunk-CJZPTLIZ.js";
import "./chunk-2U5X5TIX.js";
import "./chunk-5D65KWSM.js";
import "./chunk-ABHLEPDK.js";
import "./chunk-4FQUAV7M.js";
import "./chunk-EVZ7KLPS.js";
import "./chunk-JSH3APTG.js";
import "./chunk-WQT2KLDB.js";
import "./chunk-UVDECGZC.js";
import "./chunk-VKFTCFFM.js";
import {
  s as s2
} from "./chunk-ZETARPSI.js";
import {
  f as f2
} from "./chunk-TCDV4P3G.js";
import {
  b2 as b,
  y
} from "./chunk-CZOYDK6P.js";
import "./chunk-RS755KXS.js";
import "./chunk-TMUM75KQ.js";
import "./chunk-KY5OS6CK.js";
import "./chunk-3U5UUY3S.js";
import "./chunk-UOYGMZIS.js";
import "./chunk-RXH2WNPA.js";
import "./chunk-TWU3GKHX.js";
import "./chunk-BGIBV6LL.js";
import "./chunk-UQXJMFRI.js";
import "./chunk-DY7N5RAZ.js";
import {
  j
} from "./chunk-6TCXGIIN.js";
import {
  l as l2
} from "./chunk-NP2TBOXH.js";
import "./chunk-WBYRWTBX.js";
import "./chunk-WFCLXKCE.js";
import "./chunk-WX3525ER.js";
import "./chunk-FHCV4NTV.js";
import "./chunk-HCTBVF3W.js";
import "./chunk-NH6FXYCM.js";
import "./chunk-YE4E5JCT.js";
import "./chunk-SXZO7ULH.js";
import "./chunk-H34D76ZQ.js";
import "./chunk-QTRET3PG.js";
import "./chunk-FMOL5XMB.js";
import "./chunk-VNSHGTPN.js";
import "./chunk-OEBAFVQK.js";
import "./chunk-76V6RN4F.js";
import "./chunk-DUZAVZR4.js";
import "./chunk-EK7HOTRR.js";
import "./chunk-5DFXT3PU.js";
import "./chunk-CKE7BUXC.js";
import "./chunk-B5SL7XHP.js";
import "./chunk-3VXANCFN.js";
import "./chunk-MBQEPUQX.js";
import "./chunk-ODQ5APZK.js";
import "./chunk-G5IXTUNN.js";
import "./chunk-ZNQKJRCD.js";
import "./chunk-BA6HYZ35.js";
import "./chunk-GCTH5LET.js";
import "./chunk-Q7VRQYAO.js";
import "./chunk-SJB744AD.js";
import "./chunk-WM2VG5F2.js";
import "./chunk-IXFJYDA2.js";
import "./chunk-TTLSEJNG.js";
import "./chunk-U73R3I4U.js";
import "./chunk-VGXUPJSS.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import "./chunk-DLM5SBNY.js";
import "./chunk-EKZRA6TO.js";
import "./chunk-M5SP6ZBM.js";
import "./chunk-FAA2FDN5.js";
import "./chunk-2HGIYEIL.js";
import "./chunk-XX3OKYJS.js";
import "./chunk-OTCNIJ2H.js";
import "./chunk-JGA5YJWL.js";
import "./chunk-GCI4MA3M.js";
import "./chunk-SJ2OBYX2.js";
import "./chunk-MDJNYPVI.js";
import "./chunk-Z6VKIQV2.js";
import "./chunk-4PXNA4MD.js";
import "./chunk-ZCI5A4FF.js";
import "./chunk-2D47RURG.js";
import "./chunk-7HTU7ZUX.js";
import "./chunk-647DAMHU.js";
import "./chunk-O6G3PPOK.js";
import "./chunk-ZKNZTIAS.js";
import "./chunk-OJMISN3F.js";
import "./chunk-EFV6H5NA.js";
import "./chunk-XDLV73DB.js";
import "./chunk-ARTU4L55.js";
import "./chunk-6VL5D5UP.js";
import "./chunk-6QHY54HZ.js";
import "./chunk-GXJJY3ND.js";
import "./chunk-5ONGWFJ3.js";
import "./chunk-PLNHHGHL.js";
import "./chunk-DFK6QMLO.js";
import "./chunk-BBYMM7CM.js";
import "./chunk-EM7Y2JZC.js";
import "./chunk-QZQPB5XR.js";
import "./chunk-AQFRVV3U.js";
import "./chunk-36OXW4YN.js";
import {
  p as p2
} from "./chunk-PEL3D3ZN.js";
import "./chunk-Q5KWD3VQ.js";
import "./chunk-BUQC3CLV.js";
import {
  t as t2
} from "./chunk-W5S3VUFT.js";
import "./chunk-7YH7T6CS.js";
import "./chunk-3T4IXPP4.js";
import "./chunk-XTZAIV4X.js";
import "./chunk-63LDVRFI.js";
import "./chunk-TJTOV6JD.js";
import "./chunk-C3FRY5U4.js";
import "./chunk-JNJX34GB.js";
import "./chunk-3STJRSDT.js";
import "./chunk-67Q6KVC6.js";
import "./chunk-23NJHA5Q.js";
import "./chunk-4LA6K4VI.js";
import "./chunk-KEZCWFAR.js";
import "./chunk-JZUJ34RR.js";
import "./chunk-PMGS7UDU.js";
import "./chunk-3GHCGAH2.js";
import "./chunk-HWUOAPTX.js";
import "./chunk-QHCKOBU7.js";
import "./chunk-K2OZ6WVC.js";
import "./chunk-MC6NAKKX.js";
import "./chunk-TF6255HN.js";
import "./chunk-GD4FJL3C.js";
import "./chunk-C5OQVQZF.js";
import "./chunk-F7DKSAOI.js";
import "./chunk-4SOQWNPG.js";
import "./chunk-LTULADK2.js";
import "./chunk-35ST7YRB.js";
import "./chunk-EDA5QFHZ.js";
import "./chunk-JW6DU3OK.js";
import "./chunk-CNYNCKEV.js";
import "./chunk-XL5QPCXN.js";
import "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-C5M24ACM.js";
import "./chunk-L4A2QJG4.js";
import "./chunk-W75DBJD7.js";
import "./chunk-6KDQMJAI.js";
import "./chunk-UDHS2MGH.js";
import {
  n
} from "./chunk-QF7FRVN6.js";
import "./chunk-ENINOZUZ.js";
import {
  b as b2
} from "./chunk-P6IKJIMO.js";
import "./chunk-MHV23XAQ.js";
import "./chunk-V2X4OKYI.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import "./chunk-MA3QDRC3.js";
import "./chunk-W6J7XCPU.js";
import "./chunk-ONXWBTTM.js";
import "./chunk-T7F6Q6JJ.js";
import {
  O
} from "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-7P2ANHQ3.js";
import "./chunk-XCKT47LJ.js";
import "./chunk-3FUHCAX3.js";
import "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import {
  U,
  l
} from "./chunk-2OFHDVO5.js";
import "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-5UPBUJPC.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-CCQFL76O.js";
import "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import "./chunk-7H3U4IJR.js";
import "./chunk-SMWUT52Z.js";
import "./chunk-AXZMNHTN.js";
import "./chunk-5T3MJDSR.js";
import "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import {
  V,
  Y,
  m as m2,
  p
} from "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import {
  o
} from "./chunk-XWE6BM2U.js";
import {
  r as r2
} from "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import {
  m,
  r3 as r,
  t3 as t
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import {
  e
} from "./chunk-4DGC7CBY.js";
import {
  f2 as f
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/layers/KnowledgeGraphLayer.js
var R = class extends p2(t2(f2(l3(b(j(l2(s2(b2)))))))) {
  constructor(e2) {
    super(e2), this._graphTypeLookup = /* @__PURE__ */ new Map(), this._namedTypesModified = false, this.dataManager = null, this.definitionSetMap = null, this.knowledgeGraph = null, this.layers = new (O.ofType(Ne))(), this.memberEntityTypes = null, this.memberRelationshipTypes = null, this.operationalLayerType = "KnowledgeGraphLayer", this.sublayerIdsCache = /* @__PURE__ */ new Map(), this.tables = new (O.ofType(Ne))(), this.type = "knowledge-graph", this.url = null, this.addHandles(l(() => this.layers.concat(this.tables), (e3, i2) => this._handleSublayersChange(e3, i2), U));
  }
  load(e2) {
    return this.addResolvingPromise(this._doLoad(e2)), Promise.resolve(this);
  }
  async _doLoad(e2) {
    try {
      await this.loadFromPortal({ supportedTypes: ["Knowledge Graph Layer"] }, e2);
    } catch (i2) {
      f(i2);
    }
    await this._fetchMetadata(), await this._initializeLayerProperties(), this.loadLayerAssumingLocalCache(), this._layersLoadedFromAuthoritativeItem() || await L(this);
  }
  async _fetchMetadata() {
    if (!this.url) throw new s("knowledge-graph:missing-url", "KnowledgeGraphLayer must be created with a url");
    const e2 = await ue(this.url);
    this.knowledgeGraph = e2, this._forEachGraphType((e3) => {
      e3.name && this._graphTypeLookup.set(e3.name, e3);
    });
  }
  async _initializeLayerProperties() {
    7 === this.originIdOf("inclusionModeDefinition") ? this._validateInclusionModeDefinition() : await this._initializeInclusionModeDefinition(), this._setMemberTypes(), this.dataManager = new N({ knowledgeGraph: this.knowledgeGraph, inclusionModeDefinition: this.inclusionModeDefinition });
  }
  async _initializeInclusionModeDefinition() {
    const e2 = this.definitionSetMap ? await f3(this.definitionSetMap, true) : { generateAllSublayers: true, namedTypeDefinitions: /* @__PURE__ */ new Map() };
    [...this.layers.toArray(), ...this.tables.toArray()].forEach((i2) => {
      const t3 = this._graphTypeLookup.get(i2.graphTypeName);
      t3 && !e2.namedTypeDefinitions.has(t3.name) && e2.namedTypeDefinitions.set(t3.name, { useAllData: true });
    }), this.setAtOrigin("inclusionModeDefinition", e2, t(this.originIdOf("definitionSetMap")));
  }
  _validateInclusionModeDefinition() {
    const { inclusionModeDefinition: e2 } = this;
    if (!e2) return;
    const { namedTypeDefinitions: i2 } = e2;
    if (i2?.size > 0) i2.forEach((e3, t3) => {
      const a2 = this._graphTypeLookup.get(t3);
      if (!a2) return i.getLogger(this).warn(`A named type, ${t3}, was in the inclusion list that wasn't in the data model and will be removed`), void i2.delete(t3);
      "relationship" !== a2.type && "entity" !== a2.type && (i.getLogger(this).warn(`A named type, ${t3}, was in the inclusion list that wasn't properly modeled and will be removed`), i2.delete(t3));
    });
    else if (!e2.generateAllSublayers) throw new s("knowledge-graph:composite-layer-constructor", "If an explicit inclusion definition is defined, at least one namedTypeDefinition must also be defined");
  }
  _setMemberTypes() {
    let e2 = [], i2 = [];
    const { inclusionModeDefinition: t3 } = this, a2 = t3?.namedTypeDefinitions;
    !t3 || t3.generateAllSublayers ? (e2 = this.knowledgeGraph.dataModel?.entityTypes ?? [], i2 = this.knowledgeGraph.dataModel?.relationshipTypes ?? []) : a2 && a2.size > 0 && a2.forEach((t4, a3) => {
      const s3 = this._graphTypeLookup.get(a3);
      switch (s3?.type) {
        case "relationship":
          i2.push(s3);
          break;
        case "entity":
          e2.push(s3);
      }
    }), this.memberEntityTypes = e2, this.memberRelationshipTypes = i2;
  }
  _forEachGraphType(e2) {
    [...this.knowledgeGraph.dataModel?.entityTypes ?? [], ...this.knowledgeGraph.dataModel?.relationshipTypes ?? []].forEach((i2) => {
      e2(i2);
    });
  }
  _refreshNamedTypes() {
    this._namedTypesModified = true;
    for (const e2 of this.layers) e2.emit("refresh", { dataChanged: true });
    for (const e2 of this.tables) e2.emit("refresh", { dataChanged: true });
  }
  async _handleNewRecords(e2) {
    const i2 = /* @__PURE__ */ new Set(), t3 = [];
    for (const a2 of e2) {
      if (!this._graphTypeLookup.has(a2.typeName)) continue;
      false === this.layers.concat(this.tables).some((e3) => e3.objectType.name === a2.typeName) && (this.dataManager.sublayerCaches.set(a2.typeName, /* @__PURE__ */ new Map()), i2.add(a2.typeName));
      e(this.sublayerIdsCache, a2.typeName, () => /* @__PURE__ */ new Set()).add(a2.id), t3.push(a2);
    }
    this.dataManager.addToLayer(t3);
    for (const a2 of i2) {
      const e3 = this._graphTypeLookup.get(a2);
      e3 && (this._addSublayer(e3), "entity" === e3.type ? this.dataManager.entityTypeNames.add(a2) : this.dataManager.relationshipTypeNames.add(a2));
    }
    await L(this, Array.from(i2)), this._refreshNamedTypes();
  }
  _createSublayers(e2, i2, t3) {
    e2.forEach((e3) => {
      const a2 = this._createSublayer(e3);
      t3(a2) && i2.push(a2), this._updateSublayerCaches(e3);
    });
  }
  _addSublayer(e2) {
    const i2 = this._createSublayer(e2);
    return i2.geometryType ? this.layers.push(i2) : this.tables.push(i2), i2;
  }
  _createSublayer(e2) {
    return new Ne({ objectType: e2, parentCompositeLayer: this, graphType: e2.type });
  }
  _updateSublayers(e2, i2) {
    i2.forEach((i3) => {
      i3.parentCompositeLayer = this;
      const t3 = e2.find((e3) => e3.type === i3.graphType && e3.name === i3.graphTypeName);
      t3 && (i3.objectType = t3, this._updateSublayerCaches(t3));
    });
  }
  _updateSublayerCaches({ name: e2 }) {
    if (!e2) return;
    const i2 = this.dataManager.sublayerCaches;
    i2.has(e2) || i2.set(e2, /* @__PURE__ */ new Map());
  }
  _saveUrlAsNewResource(e2, i2, t3, a2) {
    e2[i2] = "<pending>", t3.pendingOperations.push(K(this.inclusionModeDefinition).then((s3) => {
      const o2 = U2(a2);
      e2[i2] = o2.itemRelativeUrl, t3.toAdd.push({ resource: o2, content: { type: "blob", blob: s3 }, compress: false, finish: (e3) => {
        this.definitionSetMap = e3.url;
      } });
    }));
  }
  _displaysAllRecords(e2) {
    for (const [, { useAllData: i2 }] of e2.namedTypeDefinitions) if (!i2) return false;
    return true;
  }
  _handleSublayersChange(e2, i2) {
    i2 && (i2.forEach((e3) => {
      e3.parent = null;
    }), this.removeHandles("sublayers-owner")), e2 && (e2.forEach((e3) => {
      e3.parent = this;
    }), this.addHandles([e2.on("after-add", ({ item: e3 }) => {
      e3.parent = this;
    }), e2.on("after-remove", ({ item: e3 }) => {
      e3.parent = null;
    })], "sublayers-owner"));
  }
  _layersLoadedFromAuthoritativeItem() {
    const e2 = this.originIdOf("layers");
    return e2 >= 3 && e2 < 7;
  }
  readDefinitionSetMap(e2, i2, t3) {
    return p(e2, t3);
  }
  writeDefinitionSetMap(e2, i2, t3, a2) {
    const s3 = a2?.portalItem, o2 = a2?.resources, r3 = r(a2?.origin);
    if (!s3 || !o2 || null == r3) return void (e2 && (i2[t3] = m2(e2, a2)));
    const { inclusionModeDefinition: n2 } = this;
    if (!n2 || this._displaysAllRecords(n2)) return void (this.definitionSetMap = null);
    const l4 = this.originIdOf("inclusionModeDefinition");
    if (7 === l4 || this._namedTypesModified || r3 < l4) this._saveUrlAsNewResource(i2, t3, o2, s3);
    else if (r3 === l4 && e2) {
      const r4 = m2(e2, a2);
      Y(r4) ? this._saveUrlAsNewResource(i2, t3, o2, s3) : i2[t3] = r4;
    }
  }
  set inclusionModeDefinition(e2) {
    "loaded" !== this.loadStatus && "failed" !== this.loadStatus ? this._set("inclusionModeDefinition", e2) : i.getLogger(this).error("#inclusionModeDefinition", "inclusionModeDefinition cannot be changed after the layer is loaded.");
  }
  get sublayerCapabilities() {
    return F(this.knowledgeGraph);
  }
  loadLayerAssumingLocalCache() {
    const e2 = [...this.memberEntityTypes, ...this.memberRelationshipTypes];
    this.layers.length || 0 === this.originIdOf("tables") ? 0 === this.originIdOf("layers") ? this._createSublayers(e2, this.layers, (e3) => !!e3.geometryType) : this._updateSublayers(e2, this.layers) : this.layers = new O(), this.tables.length || 0 === this.originIdOf("layers") ? 0 === this.originIdOf("tables") ? this._createSublayers(e2, this.tables, (e3) => !e3.geometryType) : this._updateSublayers(e2, this.tables) : this.tables = new O(), this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.forEach((e3, i2) => {
      const t3 = e(this.sublayerIdsCache, i2, () => /* @__PURE__ */ new Set());
      e3.members?.forEach((e4) => {
        t3.add(e4.id);
      });
    });
  }
  async addRecords(e2) {
    await this.load(), await this._handleNewRecords(e2);
  }
  async createSublayerForNamedType(e2) {
    await this.load();
    const i2 = this._graphTypeLookup.get(e2);
    if (!i2) throw new s("knowledge-graph:missing-type", "The specified type does not exist in the layer's graph data model.");
    if (this.dataManager.sublayerCaches.has(e2)) throw new s("knowledge-graph:duplicate-type", "The specified type already exists as a sublayer.");
    this.dataManager.sublayerCaches.set(e2, /* @__PURE__ */ new Map()), e(this.sublayerIdsCache, e2, () => /* @__PURE__ */ new Set());
    const t3 = this._addSublayer(i2);
    return "entity" === i2.type ? this.dataManager.entityTypeNames.add(e2) : this.dataManager.relationshipTypeNames.add(e2), this.dataManager.inclusionModeDefinition && this.dataManager.inclusionModeDefinition.namedTypeDefinitions.set(e2, { useAllData: true }), await L(this, [e2]), this._refreshNamedTypes(), t3;
  }
  convertSublayerToDynamicData(e2) {
    if (!this.dataManager.inclusionModeDefinition) throw new s("knowledge-graph:fully-dynamic-membership", "This Knowledge Graph Layer already uses fully dynamic membership, individual sublayers cannot be converted");
    if (!this._graphTypeLookup.get(e2)) throw new s("knowledge-graph:missing-type", "The specified type does not exist in the layer's graph data model.");
    if (!this.dataManager.sublayerCaches.has(e2)) throw new s("knowledge-graph:duplicate-type", "The specified type does not exist as a sublayer.");
    const i2 = this.dataManager.inclusionModeDefinition.namedTypeDefinitions.get(e2);
    i2?.useAllData ? i.getLogger(this).warn("This Knowledge Graph Layer already uses dynamic membership for the sublayer - no conversion was made") : (this.dataManager.inclusionModeDefinition.namedTypeDefinitions.set(e2, { useAllData: true }), this.sublayerIdsCache.delete(e2), this._refreshNamedTypes());
  }
  convertSublayerToExplicitMembership(e2) {
    if (!this.dataManager.inclusionModeDefinition) throw new s("knowledge-graph:fully-dynamic-membership", "This Knowledge Graph Layer already uses fully dynamic membership, individual sublayers cannot be converted");
    if (!this._graphTypeLookup.get(e2)) throw new s("knowledge-graph:missing-type", "The specified type does not exist in the layer's graph data model.");
    const i2 = this.dataManager.inclusionModeDefinition.namedTypeDefinitions.get(e2);
    if (!i2 || i2.useAllData) {
      if (!this.dataManager.sublayerCaches.has(e2)) throw new s("knowledge-graph:duplicate-type", "The specified type does not exist as a sublayer.");
      this.sublayerIdsCache.set(e2, /* @__PURE__ */ new Set()), this.dataManager.inclusionModeDefinition.namedTypeDefinitions.set(e2, { useAllData: false, members: /* @__PURE__ */ new Map() }), this._refreshNamedTypes();
    } else i.getLogger(this).warn("This Knowledge Graph Layer already uses explicit membership for the sublayer - no conversion was made");
  }
  convertToFullyDynamicData() {
    this.dataManager.inclusionModeDefinition || i.getLogger(this).warn("This Knowledge Graph Layer already uses fully dynamic membership - no conversion was made"), this.sublayerIdsCache.clear(), this.dataManager.inclusionModeDefinition = null, this._refreshNamedTypes();
  }
  convertToExplicitMembership() {
    this.dataManager.inclusionModeDefinition && this.dataManager.inclusionModeDefinition.namedTypeDefinitions.size > 0 && i.getLogger(this).warn("This Knowledge Graph Layer already uses explicit membership - no conversion was made"), this.dataManager.inclusionModeDefinition = { generateAllSublayers: false, namedTypeDefinitions: /* @__PURE__ */ new Map() };
    for (const e2 of this.dataManager.sublayerCaches.keys()) e(this.sublayerIdsCache, e2, () => /* @__PURE__ */ new Set()), this.dataManager.inclusionModeDefinition.namedTypeDefinitions.set(e2, { useAllData: false, members: /* @__PURE__ */ new Map() });
    this._refreshNamedTypes();
  }
  async removeRecords(e2) {
    await this.load();
    const i2 = [];
    for (const t3 of e2) false === this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.get(t3.typeName)?.useAllData && this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.get(t3.typeName)?.members?.has(t3.id) && i2.push(t3);
    this.dataManager.removeFromLayer(i2);
    for (const t3 of i2) this.sublayerIdsCache.get(t3.typeName)?.delete(t3.id);
    return this._refreshNamedTypes(), i2;
  }
};
__decorate([m()], R.prototype, "dataManager", void 0), __decorate([m({ json: { write: { ignoreOrigin: true, writerEnsuresNonNull: true } } })], R.prototype, "definitionSetMap", void 0), __decorate([o("definitionSetMap")], R.prototype, "readDefinitionSetMap", null), __decorate([r2("definitionSetMap")], R.prototype, "writeDefinitionSetMap", null), __decorate([m()], R.prototype, "inclusionModeDefinition", null), __decorate([m()], R.prototype, "knowledgeGraph", void 0), __decorate([m({ type: O.ofType(Ne), json: { write: { ignoreOrigin: true } } })], R.prototype, "layers", void 0), __decorate([m()], R.prototype, "memberEntityTypes", void 0), __decorate([m()], R.prototype, "memberRelationshipTypes", void 0), __decorate([m({ type: ["KnowledgeGraphLayer"] })], R.prototype, "operationalLayerType", void 0), __decorate([m()], R.prototype, "sublayerCapabilities", null), __decorate([m()], R.prototype, "sublayerIdsCache", void 0), __decorate([m({ type: O.ofType(Ne), json: { write: { ignoreOrigin: true } } })], R.prototype, "tables", void 0), __decorate([m({ json: { read: false } })], R.prototype, "type", void 0), __decorate([m(y)], R.prototype, "url", void 0), R = __decorate([a("esri.layers.KnowledgeGraphLayer")], R);
var O2 = R;
async function K(e2) {
  const i2 = await w(e2);
  return new Blob([i2], { type: "application/x-protobuf" });
}
function U2(e2) {
  const i2 = `definitionSetMap-${n()}.dat`, t3 = V("knowledgeGraphLayer", i2);
  return e2.resourceFromPath(t3);
}
export {
  O2 as default
};
//# sourceMappingURL=KnowledgeGraphLayer-TR6XMII7.js.map
