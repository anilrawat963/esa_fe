import {
  c2 as c,
  f2,
  f3,
  i,
  i2 as i3,
  o as o2,
  p as p2,
  t as t2
} from "./chunk-YTJAN3CY.js";
import {
  e as e4,
  f as f4,
  n2 as n4,
  p as p3,
  t2 as t3,
  v
} from "./chunk-T6CRNJ3D.js";
import {
  a,
  f as f5,
  n as n3,
  p as p4,
  t as t4
} from "./chunk-Z4KE5G4E.js";
import {
  l
} from "./chunk-KEMYAF6M.js";
import {
  r as r2
} from "./chunk-7YJLACUB.js";
import {
  o as o3
} from "./chunk-HETHJJO6.js";
import {
  n as n5
} from "./chunk-CHC4AAHW.js";
import {
  d2,
  o
} from "./chunk-I4DSU5MJ.js";
import {
  n as n2
} from "./chunk-FCDWKXLA.js";
import {
  l as l2,
  r,
  u
} from "./chunk-KTMKDXZP.js";
import {
  i as i2
} from "./chunk-CT7HOWYG.js";
import {
  o2 as o4
} from "./chunk-BZBDEPRV.js";
import {
  p
} from "./chunk-MXP2VO3L.js";
import {
  d,
  f
} from "./chunk-OWSUTT7E.js";
import {
  e as e2
} from "./chunk-COMSADUT.js";
import {
  e
} from "./chunk-IT62DCG6.js";
import {
  s
} from "./chunk-WJ3E33GQ.js";
import {
  r as r3
} from "./chunk-YOYO2XMY.js";
import {
  e as e3
} from "./chunk-SZTZNZQW.js";
import {
  n,
  t
} from "./chunk-CFXCM2NO.js";

// node_modules/@arcgis/core/chunks/RealisticTree.glsl.js
function _(_2) {
  const z2 = new s(), { attributes: U, vertex: W, fragment: H, varyings: G } = z2, { output: q, offsetBackfaces: J, pbrMode: K, snowCover: Q, spherical: X } = _2, Y = 1 === K || 2 === K;
  if (f(W, _2), U.add("position", "vec3"), G.add("vpos", "vec3", { invariant: true }), z2.include(u, _2), z2.include(p2, _2), z2.include(n2, _2), z2.include(i2, _2), !o(q)) return z2.include(f3, _2), z2;
  d(z2.vertex, _2), z2.include(o2, _2), z2.include(o3), J && z2.include(c), G.add("vNormalWorld", "vec3"), G.add("localvpos", "vec3", { invariant: true }), z2.include(d2, _2), z2.include(i, _2), z2.include(t2, _2), z2.include(r2, _2), W.include(r), W.include(l2), W.uniforms.add(new e2("externalColor", (e5) => e5.externalColor, { supportsNaN: true })), G.add("vcolorExt", "vec4"), z2.include(_2.instancedDoublePrecision ? p4 : f5, _2), W.main.add(t`
    forwardNormalizedVertexColor();

    MaskedColor maskedColorExt =
      applySymbolColor(applyVVColor(applyInstanceColor(createMaskedFromNaNColor(externalColor))));

    vcolorExt = maskedColorExt.color;
    forwardColorMixMode(maskedColorExt.mask);

    bool alphaCut = opacityMixMode != ${t.int(l.ignore)} && vcolorExt.a < ${t.float(o4)};
    vpos = getVertexInLocalOriginSpace();

    localvpos = vpos - view[3].xyz;
    vpos = subtractOrigin(vpos);
    vNormalWorld = dpNormal(vvLocalNormal(normalModel()));
    vpos = addVerticalOffset(vpos, localOrigin);
    vec4 basePosition = transformPosition(proj, view, vpos);

    forwardViewPosDepth((view * vec4(vpos, 1.0)).xyz);
    forwardTextureCoordinates();
    forwardLinearDepthToReadShadowMap();
    gl_Position = alphaCut ? vec4(1e38, 1e38, 1e38, 1.0) :
    ${n(J, "offsetBackfacingClipPosition(basePosition, vpos, vNormalWorld, cameraPosition);", "basePosition;")}
  `);
  const { hasColorTexture: Z, hasColorTextureTransform: ee } = _2;
  return z2.include(f4, _2), H.include(t3, _2), z2.include(f2, _2), H.include(p, _2), z2.include(n5, _2), d(H, _2), t4(H), p3(H), v(H), H.uniforms.add(W.uniforms.get("localOrigin"), W.uniforms.get("view"), new e("ambient", (e5) => e5.ambient), new e("diffuse", (e5) => e5.diffuse), new r3("opacity", (e5) => e5.opacity), new r3("layerOpacity", (e5) => e5.layerOpacity)), Z && H.uniforms.add(new e3("tex", (e5) => e5.texture)), z2.include(n4, _2), H.include(n3, _2), H.include(i3), H.include(e4, _2), a(H), H.main.add(t`
      discardBySlice(vpos);
      discardByTerrainDepth();
      vec4 texColor = ${Z ? `texture(tex, ${ee ? "colorUV" : "vuv0"})` : " vec4(1.0)"};
      ${n(Z, `${n(_2.textureAlphaPremultiplied, "texColor.rgb /= texColor.a;")}
        discardOrAdjustAlpha(texColor);`)}
      vec3 viewDirection = normalize(vpos - cameraPosition);
      applyPBRFactors();
      float ssao = evaluateAmbientOcclusionInverse();
      ssao *= getBakedOcclusion();

      float additionalAmbientScale = additionalDirectedAmbientLight(vpos + localOrigin);
      vec3 additionalLight = ssao * mainLightIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;
      float shadow = readShadow(additionalAmbientScale, vpos);
      vec3 matColor = max(ambient, diffuse);
      ${_2.hasVertexColors ? t`vec3 albedo = mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, colorMixMode);
             float opacity_ = layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, opacityMixMode);` : t`vec3 albedo = mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, colorMixMode);
             float opacity_ = layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, opacityMixMode);`}

      vec3 shadingNormal = normalize(vNormalWorld);
      vec3 groundNormal = ${X ? "normalize(vpos + localOrigin)" : "vec3(0.0, 0.0, 1.0)"};

      ${n(Q, "vec3 faceNormal = screenDerivativeNormal(vpos);\n         float snow = getRealisticTreeSnow(faceNormal, shadingNormal, groundNormal);\n         albedo = mix(albedo, vec3(1), snow);")}

      ${t`albedo *= 1.2;
             vec3 viewForward = vec3(view[0][2], view[1][2], view[2][2]);
             float alignmentLightView = clamp(dot(viewForward, -mainLightDirection), 0.0, 1.0);
             float transmittance = 1.0 - clamp(dot(viewForward, shadingNormal), 0.0, 1.0);
             float treeRadialFalloff = vColor.r;
             float backLightFactor = 0.5 * treeRadialFalloff * alignmentLightView * transmittance * (1.0 - shadow);
             additionalLight += backLightFactor * mainLightIntensity;`}

      ${Y ? t`float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * mainLightIntensity[2];
            ${n(Q, "mrr = applySnowToMRR(mrr, snow);")}
            vec3 shadedColor = evaluateSceneLightingPBR(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight, viewDirection, groundNormal, mrr, additionalAmbientIrradiance);` : t`vec3 shadedColor = evaluateSceneLighting(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight);`}
      vec4 finalColor = vec4(shadedColor, opacity_);
      outputColorHighlightOID(finalColor, vpos, albedo ${n(Q, ", 1.0")});`), z2;
}
var z = Object.freeze(Object.defineProperty({ __proto__: null, build: _ }, Symbol.toStringTag, { value: "Module" }));

export {
  _,
  z
};
//# sourceMappingURL=chunk-HZVRMY4D.js.map
