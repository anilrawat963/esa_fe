import {
  y
} from "./chunk-D3G5WIRR.js";
import {
  S as S2,
  u as u2
} from "./chunk-Q3JOE7TC.js";
import {
  S,
  k,
  p
} from "./chunk-23NJHA5Q.js";
import {
  a
} from "./chunk-XL5QPCXN.js";
import {
  _
} from "./chunk-75XOUSSS.js";
import {
  u
} from "./chunk-CCQFL76O.js";
import {
  e
} from "./chunk-CSMCPN64.js";

// node_modules/@arcgis/core/symbols/support/utils.js
function f(e2) {
  const t = e2.symbolLayers?.at(-1);
  if (t && "outline" in t) return t?.outline?.size;
}
function m(e2) {
  if (!e2) return 0;
  if (S(e2)) {
    const t = f(e2);
    return null != t ? t : 0;
  }
  return e(y(e2)?.width);
}
function h(e2) {
  if (null == e2 || !("symbolLayers" in e2) || null == e2.symbolLayers) return false;
  switch (e2.type) {
    case "point-3d":
      return e2.symbolLayers.some((e3) => "object" === e3.type);
    case "line-3d":
      return e2.symbolLayers.some((e3) => "path" === e3.type);
    case "polygon-3d":
      return e2.symbolLayers.some((e3) => "object" === e3.type || "extrude" === e3.type);
    default:
      return false;
  }
}
function d(e2) {
  return e2.resource?.href ?? "";
}
function b(t, r) {
  if (!t) return null;
  let o = null;
  return S(t) ? o = w(t) : k(t) && (o = "cim" === t.type ? u2(t) : t.color ? new u(t.color) : null), o ? k2(o, r) : null;
}
function w(t) {
  const r = t.symbolLayers;
  if (!r) return null;
  let o = null;
  return r.forEach((e2) => {
    "object" === e2.type && e2.resource?.href || (o = "water" === e2.type ? e2.color : e2.material ? e2.material.color : null);
  }), o ? new u(o) : null;
}
function k2(t, r) {
  if (null == r || null == t) return t;
  const o = t.toRgba();
  return o[3] = o[3] * r, new u(o);
}
function j(t, r, o) {
  const n = t.symbolLayers;
  if (!n) return;
  const l = (t2, n2 = false) => {
    let l2 = r ?? t2 ?? null;
    return null != o?.override && (!l2 && n2 && (l2 = new u([255, 255, 255])), l2 && (l2.a = o.override)), k2(l2, o?.add);
  };
  n.forEach((e2) => {
    if ("water" === e2.type) return void (e2.color = k2(e2.color, o?.add));
    const t2 = null != e2.material ? e2.material.color : null, r2 = l(t2, "icon" === e2.type && null != e2.resource?.href);
    null == e2.material ? e2.material = new p({ color: r2 }) : e2.material.color = r2, "outline" in e2 && e2.outline?.color && null != o?.add && (e2.outline.color = k2(e2.outline.color, o.add)), "marker" in e2 && null != e2.marker && (e2.marker.color = l(e2.marker.color));
  });
}
function g(e2, t, r) {
  t = t ?? e2.color, null != r?.override && t && (t.a = r.override), t && (e2.color = k2(t, r?.add)), "outline" in e2 && e2.outline?.color && (e2.outline.color = k2(e2.outline.color, r?.add));
}
function L(t, r, o) {
  t && (r || null != o) && (r && (r = new u(r)), S(t) ? j(t, r, o) : k(t) && g(t, r, o));
}
async function v(e2, r) {
  const o = e2.symbolLayers;
  o && await a(o, async (e3) => z(e3, r));
}
async function z(e2, t) {
  switch (e2.type) {
    case "extrude":
      U(e2, t);
      break;
    case "icon":
    case "line":
    case "text":
      x(e2, t);
      break;
    case "path":
      O(e2, t);
      break;
    case "object":
      await E(e2, t);
  }
}
function x(e2, t) {
  const r = S3(t);
  null != r && (e2.size = r);
}
function S3(e2) {
  for (const t of e2) if ("number" == typeof t) return t;
  return null;
}
function U(e2, t) {
  const r = t[2];
  "number" == typeof r && (e2.size = r);
}
async function E(e2, t) {
  const { resourceSize: r, symbolSize: o } = await C(e2), n = R(t, r, o);
  null != n && (e2.width = D(t[0], o[0], r[0], n), e2.depth = D(t[1], o[1], r[1], n), e2.height = D(t[2], o[2], r[2], n));
}
function O(e2, t) {
  const r = R(t, _, [e2.width, void 0, e2.height]);
  null != r && (e2.width = D(t[0], e2.width, 1, r), e2.height = D(t[2], e2.height, 1, r));
}
function R(e2, t, r) {
  for (let o = 0; o < 3; o++) {
    const n = e2[o];
    switch (n) {
      case "symbol-value": {
        const e3 = r[o];
        return null != e3 ? e3 / t[o] : 1;
      }
      case "proportional":
        break;
      default:
        if (n && t[o]) return n / t[o];
    }
  }
  return null;
}
async function C(e2) {
  const { computeObjectLayerResourceSize: t } = await import("./symbolLayerUtils-2YKXAGK2.js"), r = await t(e2, 10), { width: o, height: n, depth: l } = e2, i2 = [o, l, n];
  let c = 1;
  for (let s = 0; s < 3; s++) {
    const e3 = i2[s];
    if (null != e3) {
      c = e3 / r[s];
      break;
    }
  }
  for (let s = 0; s < 3; s++) null == i2[s] && (i2[s] = r[s] * c);
  return { resourceSize: r, symbolSize: i2 };
}
function D(e2, t, r, o) {
  switch (e2) {
    case "proportional":
      return r * o;
    case "symbol-value":
      return null != t ? t : r;
    default:
      return e2;
  }
}
function J(e2, t) {
  const r = S3(t);
  if (null != r) switch (e2.type) {
    case "simple-marker":
      e2.size = r;
      break;
    case "picture-marker": {
      const t2 = e2.width / e2.height;
      t2 > 1 ? (e2.width = r, e2.height = r * t2) : (e2.width = r * t2, e2.height = r);
      break;
    }
    case "simple-line":
      e2.width = r;
      break;
    case "text":
      e2.font.size = r;
  }
}
async function M(e2, t) {
  if (e2 && t) return S(e2) ? v(e2, t) : void (k(e2) && J(e2, t));
}
function N(e2, t, r) {
  if (e2 && null != t) {
    if (S(e2)) {
      const o = e2.symbolLayers;
      o && o.forEach((e3) => {
        if ("object" === e3.type) switch (r) {
          case "tilt":
            e3.tilt = (e3.tilt ?? 0) + t;
            break;
          case "roll":
            e3.roll = (e3.roll ?? 0) + t;
            break;
          default:
            e3.heading = (e3.heading ?? 0) + t;
        }
        "icon" === e3.type && (e3.angle += t);
      });
    } else if (k(e2)) switch (e2.type) {
      case "simple-marker":
      case "picture-marker":
      case "text":
        e2.angle += t;
        break;
      case "cim":
        S2(e2, t, true);
    }
  }
}
function A(e2) {
  return null != e2 && "polygon-3d" === e2.type && e2.symbolLayers.some((e3) => "extrude" === e3.type);
}

export {
  m,
  h,
  d,
  b,
  L,
  M,
  N,
  A
};
//# sourceMappingURL=chunk-BTFBYI67.js.map
