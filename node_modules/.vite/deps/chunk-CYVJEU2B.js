import {
  T as T2,
  d as d2,
  l as l4
} from "./chunk-FDSAQJ3R.js";
import {
  c as c3,
  f as f4,
  o as o4
} from "./chunk-KDGDF37U.js";
import {
  g as g2
} from "./chunk-I4DSU5MJ.js";
import {
  n as n6
} from "./chunk-B3BLJNSM.js";
import {
  G,
  K as K2
} from "./chunk-ME5HHRVQ.js";
import {
  A as A5,
  O as O2,
  S as S2,
  d,
  h as h4,
  k as k3,
  q as q3,
  w as w2,
  x as x2,
  y2 as y4
} from "./chunk-6KSMNSLR.js";
import {
  b as b4,
  m as m3,
  v
} from "./chunk-JBTWCDRR.js";
import {
  I as I2,
  P as P3,
  S,
  V,
  b as b5,
  et,
  k as k2,
  v as v2,
  w2 as w
} from "./chunk-U6CJFTOF.js";
import {
  L as L2,
  O,
  U,
  Z as Z2,
  j2,
  k,
  q as q2
} from "./chunk-2JMKFI2D.js";
import {
  f as f3
} from "./chunk-QYAMBIRP.js";
import {
  n as n5
} from "./chunk-ALR6N4CF.js";
import {
  t as t3
} from "./chunk-4X4BOGIG.js";
import {
  i as i2
} from "./chunk-WHHIH5YU.js";
import {
  n as n3,
  r as r5
} from "./chunk-ZVTEFYZX.js";
import {
  E as E3,
  L,
  a as a3,
  m as m2,
  p as p2,
  s as s4,
  x,
  z as z2
} from "./chunk-LPUPM55U.js";
import {
  a as a4
} from "./chunk-U55FA2EK.js";
import {
  A as A4,
  R as R3,
  _ as _2
} from "./chunk-QNVJVDYZ.js";
import {
  n as n4,
  r as r8,
  t as t2
} from "./chunk-WDTGOP77.js";
import {
  A as A3,
  E as E4,
  H,
  I,
  K,
  P as P2,
  R as R2,
  X as X2,
  Z,
  _,
  c as c2,
  g,
  o as o3,
  p as p3,
  q,
  r as r7,
  s as s5,
  u,
  y as y3
} from "./chunk-VYMBX5H5.js";
import {
  A as A2
} from "./chunk-6VL5D5UP.js";
import {
  r as r6
} from "./chunk-5ONGWFJ3.js";
import {
  e as e3
} from "./chunk-K2OZ6WVC.js";
import {
  A,
  C,
  R,
  X,
  b as b3,
  c,
  h as h2,
  l as l3,
  n as n2,
  p,
  s as s3
} from "./chunk-XLOINTMG.js";
import {
  N,
  a as a2,
  n,
  o as o2,
  r as r3,
  t
} from "./chunk-75XOUSSS.js";
import {
  P
} from "./chunk-PZ5RULLK.js";
import {
  h as h3
} from "./chunk-OPJX4KXH.js";
import {
  y as y2
} from "./chunk-LTPHDYPK.js";
import {
  e as e2
} from "./chunk-3OVERDFX.js";
import {
  E as E2,
  T,
  r as r4
} from "./chunk-AZXJIEZ6.js";
import {
  e
} from "./chunk-Q75WYS7K.js";
import {
  z
} from "./chunk-H74Q4SYB.js";
import {
  h,
  l
} from "./chunk-2OFHDVO5.js";
import {
  f as f2,
  y
} from "./chunk-CSMCPN64.js";
import {
  M,
  b as b2,
  l as l2,
  o,
  r as r2,
  s as s2
} from "./chunk-SMWUT52Z.js";
import {
  j
} from "./chunk-AXZMNHTN.js";
import {
  f
} from "./chunk-5T3MJDSR.js";
import {
  E
} from "./chunk-NMQNUPE4.js";
import {
  b,
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  r2 as r
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/verticalOffsetUtils.js
var v3 = class {
  constructor() {
    this._transform = e3(), this._transformInverse = new b6({ value: this._transform }, h2, e3), this._transformInverseTranspose = new b6(this._transformInverse, s3, e3), this._transformTranspose = new b6({ value: this._transform }, s3, e3), this._transformInverseRotation = new b6({ value: this._transform }, y2, e2);
  }
  _invalidateLazyTransforms() {
    this._transformInverse.invalidate(), this._transformInverseTranspose.invalidate(), this._transformTranspose.invalidate(), this._transformInverseRotation.invalidate();
  }
  get transform() {
    return this._transform;
  }
  get inverse() {
    return this._transformInverse.value;
  }
  get inverseTranspose() {
    return this._transformInverseTranspose.value;
  }
  get inverseRotation() {
    return this._transformInverseRotation.value;
  }
  get transpose() {
    return this._transformTranspose.value;
  }
  setTransformMatrix(t7) {
    n2(this._transform, t7);
  }
  multiplyTransform(t7) {
    c(this._transform, this._transform, t7);
  }
  set(t7) {
    n2(this._transform, t7), this._invalidateLazyTransforms();
  }
  setAndInvalidateLazyTransforms(t7, s9) {
    this.setTransformMatrix(t7), this.multiplyTransform(s9), this._invalidateLazyTransforms();
  }
};
var b6 = class {
  constructor(t7, s9, r13) {
    this._original = t7, this._update = s9, this._dirty = true, this._transform = r13();
  }
  invalidate() {
    this._dirty = true;
  }
  get value() {
    return this._dirty && (this._update(this._transform, this._original.value), this._dirty = false), this._transform;
  }
};
var T3 = class {
  constructor(t7 = 0) {
    this.offset = t7, this.tmpVertex = n();
  }
  applyToVertex(t7, s9, r13) {
    const e8 = o3(q4, t7, s9, r13), i8 = u(z3, e8, this.localOrigin), a8 = this.offset / r7(i8);
    return q(this.tmpVertex, e8, i8, a8), this.tmpVertex;
  }
  applyToAabb(t7) {
    const s9 = A6, r13 = R4, e8 = B;
    for (let n11 = 0; n11 < 3; ++n11) s9[n11] = t7[0 + n11] + this.localOrigin[n11], r13[n11] = t7[3 + n11] + this.localOrigin[n11], e8[n11] = s9[n11];
    const i8 = this.applyToVertex(s9[0], s9[1], s9[2]);
    for (let n11 = 0; n11 < 3; ++n11) t7[n11] = i8[n11], t7[n11 + 3] = i8[n11];
    const a8 = (s10) => {
      const r14 = this.applyToVertex(s10[0], s10[1], s10[2]);
      for (let e9 = 0; e9 < 3; ++e9) t7[e9] = Math.min(t7[e9], r14[e9]), t7[e9 + 3] = Math.max(t7[e9 + 3], r14[e9]);
    };
    for (let n11 = 1; n11 < 8; ++n11) {
      for (let t8 = 0; t8 < 3; ++t8) e8[t8] = n11 & 1 << t8 ? r13[t8] : s9[t8];
      a8(e8);
    }
    let o8 = 0;
    for (let n11 = 0; n11 < 3; ++n11) {
      s9[n11] * r13[n11] < 0 && (o8 |= 1 << n11);
    }
    if (0 !== o8 && 7 !== o8) {
      for (let n11 = 0; n11 < 8; ++n11) if (0 === (o8 & n11)) {
        for (let t8 = 0; t8 < 3; ++t8) e8[t8] = o8 & 1 << t8 ? 0 : n11 & 1 << t8 ? s9[t8] : r13[t8];
        a8(e8);
      }
    }
    for (let n11 = 0; n11 < 3; ++n11) t7[n11] -= this.localOrigin[n11], t7[n11 + 3] -= this.localOrigin[n11];
    return t7;
  }
};
var x3 = class {
  constructor(t7 = 0) {
    this.componentLocalOriginLength = 0, this._totalOffset = 0, this._offset = 0, this._tmpVertex = n(), this._tmpMbs = P3(), this._tmpObb = new G(), this._resetOffset(t7);
  }
  _resetOffset(t7) {
    this._offset = t7, this._totalOffset = t7;
  }
  set offset(t7) {
    this._resetOffset(t7);
  }
  get offset() {
    return this._offset;
  }
  set componentOffset(t7) {
    this._totalOffset = this._offset + t7;
  }
  set localOrigin(t7) {
    this.componentLocalOriginLength = r7(t7);
  }
  applyToVertex(t7, s9, r13) {
    const e8 = o3(q4, t7, s9, r13), i8 = o3(z3, t7, s9, r13 + this.componentLocalOriginLength), a8 = this._totalOffset / r7(i8);
    return q(this._tmpVertex, e8, i8, a8), this._tmpVertex;
  }
  applyToAabb(t7) {
    const s9 = this.componentLocalOriginLength, r13 = t7[0], e8 = t7[1], i8 = t7[2] + s9, a8 = t7[3], o8 = t7[4], n11 = t7[5] + s9, h6 = Math.abs(r13), f6 = Math.abs(e8), l11 = Math.abs(i8), m11 = Math.abs(a8), c8 = Math.abs(o8), p8 = Math.abs(n11), _7 = 0.5 * (1 + Math.sign(r13 * a8)) * Math.min(h6, m11), u5 = 0.5 * (1 + Math.sign(e8 * o8)) * Math.min(f6, c8), g7 = 0.5 * (1 + Math.sign(i8 * n11)) * Math.min(l11, p8), M4 = Math.max(h6, m11), v7 = Math.max(f6, c8), b9 = Math.max(l11, p8), T4 = Math.sqrt(_7 * _7 + u5 * u5 + g7 * g7), x4 = Math.sign(h6 + r13), O5 = Math.sign(f6 + e8), y8 = Math.sign(l11 + i8), d7 = Math.sign(m11 + a8), V4 = Math.sign(c8 + o8), L4 = Math.sign(p8 + n11), j8 = this._totalOffset;
    if (T4 < j8) return t7[0] -= (1 - x4) * j8, t7[1] -= (1 - O5) * j8, t7[2] -= (1 - y8) * j8, t7[3] += d7 * j8, t7[4] += V4 * j8, t7[5] += L4 * j8, t7;
    const I5 = j8 / Math.sqrt(M4 * M4 + v7 * v7 + b9 * b9), w6 = j8 / T4, q7 = w6 - I5, z5 = -q7;
    return t7[0] += r13 * (x4 * z5 + w6), t7[1] += e8 * (O5 * z5 + w6), t7[2] += i8 * (y8 * z5 + w6), t7[3] += a8 * (d7 * q7 + I5), t7[4] += o8 * (V4 * q7 + I5), t7[5] += n11 * (L4 * q7 + I5), t7;
  }
  applyToMbs(t7) {
    const s9 = I2(t7), r13 = r7(s9), e8 = this._totalOffset / r13, i8 = q(k4, s9, s9, e8), a8 = t7[3] + t7[3] * this._totalOffset / r13;
    return V(this._tmpMbs, i8, a8), this._tmpMbs;
  }
  applyToObb(t7) {
    return K2(t7, this._totalOffset, this._totalOffset, 1, this._tmpObb), this._tmpObb;
  }
};
var O3 = class {
  constructor(t7 = 0) {
    this.offset = t7, this.sphere = P3(), this.tmpVertex = n();
  }
  applyToVertex(t7, s9, r13) {
    const e8 = this.objectTransform.transform, i8 = o3(q4, t7, s9, r13), a8 = E4(i8, i8, e8), o8 = this.offset / r7(a8);
    q(a8, a8, a8, o8);
    const m11 = this.objectTransform.inverse;
    return E4(this.tmpVertex, a8, m11), this.tmpVertex;
  }
  applyToMinMax(t7, s9) {
    const r13 = this.offset / r7(t7);
    q(t7, t7, t7, r13);
    const e8 = this.offset / r7(s9);
    q(s9, s9, s9, e8);
  }
  applyToAabb(t7) {
    const s9 = this.offset / Math.sqrt(t7[0] * t7[0] + t7[1] * t7[1] + t7[2] * t7[2]);
    t7[0] += t7[0] * s9, t7[1] += t7[1] * s9, t7[2] += t7[2] * s9;
    const r13 = this.offset / Math.sqrt(t7[3] * t7[3] + t7[4] * t7[4] + t7[5] * t7[5]);
    return t7[3] += t7[3] * r13, t7[4] += t7[4] * r13, t7[5] += t7[5] * r13, t7;
  }
  applyToBoundingSphere(t7) {
    const s9 = I2(t7), r13 = r7(s9), e8 = this.offset / r13, i8 = q(k4, s9, s9, e8), a8 = t7[3] + t7[3] * this.offset / r13;
    return V(this.sphere, i8, a8), this.sphere;
  }
};
var y5 = new O3();
function d3(t7) {
  return null != t7 ? (y5.offset = t7, y5) : null;
}
var V2 = new x3();
var j3 = new T3();
var q4 = n();
var z3 = n();
var A6 = n();
var R4 = n();
var B = n();
var k4 = n();

// node_modules/@arcgis/core/views/3d/webgl-engine/lighting/Lightsources.js
var i3 = class {
  constructor(s9 = o2()) {
    this.intensity = s9;
  }
};
var r9 = class {
  constructor(i8 = o2(), r13 = r3(0.57735, 0.57735, 0.57735)) {
    this.intensity = i8, this.direction = r13;
  }
};
var c4 = class {
  constructor(i8 = o2(), r13 = r3(0.57735, 0.57735, 0.57735), c8 = true, n11 = 1, o8 = 1) {
    this.intensity = i8, this.direction = r13, this.castShadows = c8, this.specularStrength = n11, this.environmentStrength = o8;
  }
};
var n7 = class {
  constructor() {
    this.r = [0], this.g = [0], this.b = [0];
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/LongVectorMath.js
function n8(t7, n11, e8) {
  (e8 = e8 || t7).length = t7.length;
  for (let l11 = 0; l11 < t7.length; l11++) e8[l11] = t7[l11] * n11[l11];
  return e8;
}
function e4(t7, n11, e8) {
  (e8 = e8 || t7).length = t7.length;
  for (let l11 = 0; l11 < t7.length; l11++) e8[l11] = t7[l11] * n11;
  return e8;
}
function l5(t7, n11, e8) {
  (e8 = e8 || t7).length = t7.length;
  for (let l11 = 0; l11 < t7.length; l11++) e8[l11] = t7[l11] + n11[l11];
  return e8;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lighting/SphericalHarmonics.js
function u2(t7) {
  return (t7 + 1) * (t7 + 1);
}
function l6(n11) {
  return r2(Math.floor(Math.sqrt(n11) - 1), 0, 2);
}
function m4(t7, n11, o8) {
  const r13 = t7[0], e8 = t7[1], i8 = t7[2], s9 = o8 || [];
  return s9.length = u2(n11), n11 >= 0 && (s9[0] = 0.28209479177), n11 >= 1 && (s9[1] = 0.4886025119 * r13, s9[2] = 0.4886025119 * i8, s9[3] = 0.4886025119 * e8), n11 >= 2 && (s9[4] = 1.09254843059 * r13 * e8, s9[5] = 1.09254843059 * e8 * i8, s9[6] = 0.31539156525 * (3 * i8 * i8 - 1), s9[7] = 1.09254843059 * r13 * i8, s9[8] = 0.54627421529 * (r13 * r13 - e8 * e8)), s9;
}
function p4(t7, n11) {
  const o8 = u2(t7), r13 = n11 || { r: [], g: [], b: [] };
  r13.r.length = r13.g.length = r13.b.length = o8;
  for (let e8 = 0; e8 < o8; e8++) r13.r[e8] = r13.g[e8] = r13.b[e8] = 0;
  return r13;
}
function b7(t7, n11) {
  const o8 = l6(n11.r.length);
  for (const e8 of t7) y3(P4, e8.direction), m4(P4, o8, v4), n8(v4, w3), e4(v4, e8.intensity[0], I3), l5(n11.r, I3), e4(v4, e8.intensity[1], I3), l5(n11.g, I3), e4(v4, e8.intensity[2], I3), l5(n11.b, I3);
  return n11;
}
function y6(t7, n11) {
  m4(P4, 0, v4);
  for (const o8 of t7) n11.r[0] += v4[0] * w3[0] * o8.intensity[0] * 4 * Math.PI, n11.g[0] += v4[0] * w3[0] * o8.intensity[1] * 4 * Math.PI, n11.b[0] += v4[0] * w3[0] * o8.intensity[2] * 4 * Math.PI;
  return n11;
}
function d4(t7, r13, e8, s9) {
  p4(r13, s9), o3(e8.intensity, 0, 0, 0);
  let c8 = false;
  const u5 = j4, l11 = M2, m11 = S3;
  u5.length = 0, l11.length = 0, m11.length = 0;
  for (const n11 of t7) n11 instanceof c4 && !c8 ? (s5(e8.direction, n11.direction), s5(e8.intensity, n11.intensity), e8.specularStrength = n11.specularStrength, e8.environmentStrength = n11.environmentStrength, e8.castShadows = n11.castShadows, c8 = true) : n11 instanceof c4 || n11 instanceof r9 ? u5.push(n11) : n11 instanceof i3 ? l11.push(n11) : n11 instanceof n7 && m11.push(n11);
  b7(u5, s9), y6(l11, s9);
  for (const n11 of m11) l5(s9.r, n11.r), l5(s9.g, n11.g), l5(s9.b, n11.b);
}
var j4 = [];
var M2 = [];
var S3 = [];
var v4 = [0];
var I3 = [0];
var P4 = n();
var w3 = [3.141593, 2.094395, 2.094395, 2.094395, 0.785398, 0.785398, 0.785398, 0.785398, 0.785398];

// node_modules/@arcgis/core/views/3d/webgl-engine/lighting/SceneLighting.js
var g3 = class {
  constructor() {
    this.color = n(), this.intensity = 1;
  }
};
var m5 = class {
  constructor() {
    this.direction = n(), this.ambient = new g3(), this.diffuse = new g3();
  }
};
var l7 = 0.4;
var _3 = class {
  constructor() {
    this._shOrder = 2, this._legacy = new m5(), this.globalFactor = 0.5, this.noonFactor = 0.5, this._sphericalHarmonics = new n7(), this._mainLight = new c4(n(), r3(1, 0, 0), false);
  }
  get legacy() {
    return this._legacy;
  }
  get sh() {
    return this._sphericalHarmonics;
  }
  get mainLight() {
    return this._mainLight;
  }
  set(i8) {
    d4(i8, this._shOrder, this._mainLight, this._sphericalHarmonics), this.updateLegacy();
  }
  updateLegacy() {
    s5(this._legacy.direction, this._mainLight.direction);
    const i8 = 1 / Math.PI;
    this._legacy.ambient.color[0] = 0.282095 * this._sphericalHarmonics.r[0] * i8, this._legacy.ambient.color[1] = 0.282095 * this._sphericalHarmonics.g[0] * i8, this._legacy.ambient.color[2] = 0.282095 * this._sphericalHarmonics.b[0] * i8, g(this._legacy.diffuse.color, this._mainLight.intensity, i8), s5(L3, this._legacy.diffuse.color), g(L3, L3, l7 * this.globalFactor), u(this._legacy.ambient.color, this._legacy.ambient.color, L3);
  }
  copyFrom(i8) {
    this._sphericalHarmonics.r = Array.from(i8.sh.r), this._sphericalHarmonics.g = Array.from(i8.sh.g), this._sphericalHarmonics.b = Array.from(i8.sh.b), s5(this._mainLight.direction, i8.mainLight.direction), s5(this._mainLight.intensity, i8.mainLight.intensity), this._mainLight.castShadows = i8.mainLight.castShadows, this._mainLight.specularStrength = i8.mainLight.specularStrength, this._mainLight.environmentStrength = i8.mainLight.environmentStrength, this.globalFactor = i8.globalFactor, this.noonFactor = i8.noonFactor;
  }
  lerpLighting(s9, h6, a8) {
    if (I(this._mainLight.intensity, s9.mainLight.intensity, h6.mainLight.intensity, a8), this._mainLight.environmentStrength = o(s9.mainLight.environmentStrength, h6.mainLight.environmentStrength, a8), this._mainLight.specularStrength = o(s9.mainLight.specularStrength, h6.mainLight.specularStrength, a8), s5(this._mainLight.direction, h6.mainLight.direction), this._mainLight.castShadows = h6.mainLight.castShadows, this.globalFactor = o(s9.globalFactor, h6.globalFactor, a8), this.noonFactor = o(s9.noonFactor, h6.noonFactor, a8), s9.sh.r.length === h6.sh.r.length) for (let t7 = 0; t7 < h6.sh.r.length; t7++) this._sphericalHarmonics.r[t7] = o(s9.sh.r[t7], h6.sh.r[t7], a8), this._sphericalHarmonics.g[t7] = o(s9.sh.g[t7], h6.sh.g[t7], a8), this._sphericalHarmonics.b[t7] = o(s9.sh.b[t7], h6.sh.b[t7], a8);
    else for (let i8 = 0; i8 < h6.sh.r.length; i8++) this._sphericalHarmonics.r[i8] = h6.sh.r[i8], this._sphericalHarmonics.g[i8] = h6.sh.g[i8], this._sphericalHarmonics.b[i8] = h6.sh.b[i8];
    this.updateLegacy();
  }
};
var L3 = n();

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderTechnique/ReloadableShaderModule.js
var t4 = class {
  constructor(t7, o8) {
    this._module = t7, this._load = o8;
  }
  get() {
    return this._module;
  }
  async reload() {
    return this._module = await this._load(), this._module;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Program.js
var r10 = class {
  constructor(r13, e8, i8) {
    this._context = r13, this.locations = i8, this._textures = /* @__PURE__ */ new Map(), this.source = a4() ? e8 : null, e8.attributeNames.forEach((t7) => {
      i8.has(t7) || console.error(`Missing VertexAttributeLocation for ${t7} used in shader`);
    }), this._glProgram = r13.programCache.acquire(e8.generate("vertex", true), e8.generate("fragment", true), i8), this._glProgram.stop = () => {
      throw new Error("Wrapped _glProgram used directly");
    }, this.bind = e8.generateBind(this), this.bindPass = e8.generateBindPass(this), this.bindDraw = e8.generateBindDraw(this);
  }
  dispose() {
    this._glProgram.dispose();
  }
  get glName() {
    return this._glProgram.glName;
  }
  get hasTransformFeedbackVaryings() {
    return this._glProgram.hasTransformFeedbackVaryings;
  }
  get compiled() {
    return this._glProgram.compiled;
  }
  setUniform1b(t7, r13) {
    this._glProgram.setUniform1i(t7, r13 ? 1 : 0);
  }
  setUniform1i(t7, r13) {
    this._glProgram.setUniform1i(t7, r13);
  }
  setUniform1f(t7, r13, e8) {
    this._glProgram.setUniform1f(t7, r13, e8);
  }
  setUniform2fv(t7, r13, e8) {
    this._glProgram.setUniform2fv(t7, r13, e8);
  }
  setUniform3fv(t7, r13, e8) {
    this._glProgram.setUniform3fv(t7, r13, e8);
  }
  setUniform4fv(t7, r13, e8) {
    this._glProgram.setUniform4fv(t7, r13, e8);
  }
  setUniformMatrix3fv(t7, r13, e8) {
    this._glProgram.setUniformMatrix3fv(t7, r13, false, e8);
  }
  setUniformMatrix4fv(t7, r13, e8) {
    this._glProgram.setUniformMatrix4fv(t7, r13, false, e8);
  }
  setUniformMatrices4fv(t7, r13, e8) {
    this._glProgram.setUniformMatrices4fv(t7, r13, false, e8);
  }
  setUniform1fv(t7, r13, e8) {
    this._glProgram.setUniform1fv(t7, r13, e8);
  }
  setUniform1iv(t7, r13) {
    this._glProgram.setUniform1iv(t7, r13);
  }
  setUniform2iv(t7, r13) {
    this._glProgram.setUniform2iv(t7, r13);
  }
  setUniform3iv(t7, r13) {
    this._glProgram.setUniform3iv(t7, r13);
  }
  setUniform4iv(t7, r13) {
    this._glProgram.setUniform4iv(t7, r13);
  }
  assertCompatibleVertexAttributeLocations(t7, r13) {
    let e8 = t7.locations;
    if (r13) {
      const t8 = new Map(e8);
      r13.forEach((r14, i8) => t8.set(i8, e8.size + r14)), e8 = t8;
    }
    e8.size !== this.locations.size && console.error(`VertexAttributeLocations are incompatible: ${e8}, ${this.locations}`), this.locations.forEach((t8, r14) => {
      e8.get(r14) !== t8 && console.error(`VertexAttributeLocations are incompatible: Program has ${r14} at position ${t8}, VAO has it at position ${e8.get(r14)}.`);
    });
  }
  stop() {
    this._textures.clear();
  }
  bindTexture(r13, e8) {
    e8?.glName || (a4() && console.error(`Texture sampler ${r13} has no given Texture in ${new Error().stack} `), e8 = this._context.emptyTexture);
    const i8 = this._ensureTextureUnit(r13, e8);
    this._context.useProgram(this), this.setUniform1i(r13, i8.unit), this._context.bindTexture(e8, i8.unit);
  }
  _ensureTextureUnit(t7, r13) {
    let e8 = this._textures.get(t7);
    return null == e8 ? (e8 = { texture: r13, unit: this._textures.size }, this._textures.set(t7, e8)) : e8.texture = r13, e8;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderTechnique/ShaderTechnique.js
var l8 = () => i.getLogger("esri.views.3d.webgl.ShaderTechnique");
var m6 = class {
  constructor(e8, i8, s9, n11) {
    this.primitiveType = _2.TRIANGLES, this.key = i8.key, this._program = new r10(e8.rctx, s9.get().build(i8), n11), this._pipeline = this.initializePipeline(i8), this.reload = async (o8) => {
      o8 && await s9.reload(), this.key.equals(i8.key) || l8().warn("Configuration was changed after construction, cannot reload shader.", s9), r(this._program), this._program = new r10(e8.rctx, s9.get().build(i8), n11), this._pipeline = this.initializePipeline(i8);
    };
  }
  destroy() {
    this._program = r(this._program), this._pipeline = null;
  }
  get program() {
    return this._program;
  }
  get compiled() {
    return this.program.compiled;
  }
  ensureAttributeLocations(e8) {
    this.program.assertCompatibleVertexAttributeLocations(e8);
  }
  getPipeline(e8, r13) {
    return this._pipeline;
  }
  initializePipeline(e8) {
    return T2({ blending: l4, colorWrite: d2 });
  }
};
function g4(e8, r13) {
  return g2(e8) ? { buffers: [A4] } : r13 ?? null;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/fov.js
function t5(t7, a8, n11) {
  return 2 * Math.atan(Math.sqrt(a8 * a8 + n11 * n11) * Math.tan(0.5 * t7) / a8);
}
function a5(t7, a8, n11) {
  return 2 * Math.atan(Math.sqrt(a8 * a8 + n11 * n11) * Math.tan(0.5 * t7) / n11);
}
function n9(t7, a8, n11) {
  return 2 * Math.atan(a8 * Math.tan(0.5 * t7) / Math.sqrt(a8 * a8 + n11 * n11));
}
function r11(t7, a8, n11) {
  return 2 * Math.atan(n11 * Math.tan(0.5 * t7) / Math.sqrt(a8 * a8 + n11 * n11));
}

// node_modules/@arcgis/core/views/3d/webgl/RenderCamera.js
var Z3;
var $ = Z3 = class extends b {
  constructor(t7) {
    super(t7), this._ray = b5(), this._viewport = r5(0, 0, 1, 1), this._padding = r5(0, 0, 0, 0), this._fov = 55 / 180 * Math.PI, this._nearFar = r8(1, 1e3), this._viewDirty = true, this._viewMatrix = e3(), this._viewProjectionDirty = true, this._viewProjectionMatrix = e3(), this._viewInverseTransposeMatrixDirty = true, this._viewInverseTransposeMatrix = e3(), this._frustumDirty = true, this._frustum = h4(), this._fullViewport = n3(), this._pixelRatio = 1, this.row = 0, this.column = 0, this._rows = 1, this._columns = 1, this._center = n(), this._up = n(), this.relativeElevation = 0;
  }
  get pixelRatio() {
    return this._pixelRatio;
  }
  set pixelRatio(t7) {
    this._pixelRatio = t7 > 0 ? t7 : 1;
  }
  get rows() {
    return this._rows;
  }
  set rows(t7) {
    this._rows = Math.max(1, t7);
  }
  get columns() {
    return this._columns;
  }
  set columns(t7) {
    this._columns = Math.max(1, t7);
  }
  get eye() {
    return this._ray.origin;
  }
  set eye(t7) {
    this._compareAndSetView(t7, this._ray.origin);
  }
  get center() {
    return this._center;
  }
  set center(t7) {
    this._compareAndSetView(t7, this._center, "_center");
  }
  get ray() {
    return c2(this._ray.direction, this.center, this.eye), this._ray;
  }
  get up() {
    return this._up;
  }
  set up(t7) {
    this._compareAndSetView(t7, this._up, "_up");
  }
  get viewMatrix() {
    return this._ensureViewClean(), this._viewMatrix;
  }
  set viewMatrix(t7) {
    n2(this._viewMatrix, t7), this.notifyChange("_viewMatrix"), this._viewDirty = false, this._viewInverseTransposeMatrixDirty = true, this._viewProjectionDirty = true, this._frustumDirty = true;
  }
  get viewForward() {
    return this._ensureViewClean(), o3(n(), -this._viewMatrix[2], -this._viewMatrix[6], -this._viewMatrix[10]);
  }
  get viewUp() {
    return this._ensureViewClean(), o3(n(), this._viewMatrix[1], this._viewMatrix[5], this._viewMatrix[9]);
  }
  get viewRight() {
    return this._ensureViewClean(), o3(n(), this._viewMatrix[0], this._viewMatrix[4], this._viewMatrix[8]);
  }
  get nearFar() {
    return this._nearFar;
  }
  get near() {
    return this._nearFar[0];
  }
  set near(t7) {
    this._nearFar[0] !== t7 && (this._nearFar[0] = t7, this._viewProjectionDirty = true, this._frustumDirty = true, this.notifyChange("_nearFar"));
  }
  get far() {
    return this._nearFar[1];
  }
  set far(t7) {
    this._nearFar[1] !== t7 && (this._nearFar[1] = t7, this._viewProjectionDirty = true, this._frustumDirty = true, this.notifyChange("_nearFar"));
  }
  get viewport() {
    return this._viewport;
  }
  set viewport(t7) {
    this.x = t7[0], this.y = t7[1], this.width = t7[2], this.height = t7[3];
  }
  get screenViewport() {
    if (1 === this.pixelRatio) return this._viewport;
    const t7 = m2(n3(), this._viewport, 1 / this.pixelRatio), i8 = this._get("screenViewport");
    return i8 && L(t7, i8) ? i8 : t7;
  }
  get screenPadding() {
    if (1 === this.pixelRatio) return this._padding;
    const t7 = m2(n3(), this._padding, 1 / this.pixelRatio), i8 = this._get("screenPadding");
    return i8 && L(t7, i8) ? i8 : t7;
  }
  get x() {
    return this._viewport[0];
  }
  set x(t7) {
    t7 += this._padding[3], this._viewport[0] !== t7 && (this._viewport[0] = t7, this._viewProjectionDirty = true, this._frustumDirty = true, this.notifyChange("_viewport"));
  }
  get y() {
    return this._viewport[1];
  }
  set y(t7) {
    t7 += this._padding[2], this._viewport[1] !== t7 && (this._viewport[1] = t7, this._viewProjectionDirty = true, this._frustumDirty = true, this.notifyChange("_viewport"));
  }
  get width() {
    return this._viewport[2];
  }
  set width(t7) {
    this._viewport[2] !== t7 && (this._viewport[2] = t7, this._viewProjectionDirty = true, this._frustumDirty = true, this.notifyChange("_viewport"));
  }
  get height() {
    return this._viewport[3];
  }
  set height(t7) {
    this._viewport[3] !== t7 && (this._viewport[3] = t7, this._viewProjectionDirty = true, this._frustumDirty = true, this.notifyChange("_viewport"));
  }
  get fullWidth() {
    return this._viewport[2] + this._padding[1] + this._padding[3];
  }
  set fullWidth(t7) {
    this.width = t7 - (this._padding[1] + this._padding[3]);
  }
  get fullHeight() {
    return this._viewport[3] + this._padding[0] + this._padding[2];
  }
  set fullHeight(t7) {
    this.height = t7 - (this._padding[0] + this._padding[2]);
  }
  get fullViewport() {
    return this._fullViewport[0] = this._viewport[0] - this._padding[3], this._fullViewport[1] = this._viewport[1] - this._padding[2], this._fullViewport[2] = this.fullWidth, this._fullViewport[3] = this.fullHeight, this._fullViewport;
  }
  get _aspect() {
    return this.width / this.height;
  }
  get padding() {
    return this._padding;
  }
  set padding(t7) {
    E3(this._padding, t7) || (this._viewport[0] += t7[3] - this._padding[3], this._viewport[1] += t7[2] - this._padding[2], this._viewport[2] -= t7[1] + t7[3] - (this._padding[1] + this._padding[3]), this._viewport[3] -= t7[0] + t7[2] - (this._padding[0] + this._padding[2]), a3(this._padding, t7), this._viewProjectionDirty = true, this._frustumDirty = true, this.notifyChange("_padding"), this.notifyChange("_viewport"));
  }
  get viewProjectionMatrix() {
    return this._viewProjectionDirty && (c(this._viewProjectionMatrix, this.projectionMatrix, this.viewMatrix), this._viewProjectionDirty = false), this._viewProjectionMatrix;
  }
  get projectionMatrix() {
    return this._projectionMatrixInternal;
  }
  get inverseProjectionMatrix() {
    return h2(e3(), this.projectionMatrix) || this._get("inverseProjectionMatrix") || e3();
  }
  get fov() {
    return this._fov;
  }
  set fov(t7) {
    this._fov = t7, this._viewProjectionDirty = true, this._frustumDirty = true;
  }
  get fovX() {
    return n9(this._fov, this.width, this.height);
  }
  set fovX(t7) {
    this._fov = t5(t7, this.width, this.height), this._viewProjectionDirty = true, this._frustumDirty = true;
  }
  get fovY() {
    return r11(this._fov, this.width, this.height);
  }
  set fovY(t7) {
    this._fov = a5(t7, this.width, this.height), this._viewProjectionDirty = true, this._frustumDirty = true;
  }
  get distance() {
    return p3(this.center, this.eye);
  }
  get frustum() {
    return this._recomputeFrustum(), this._frustum;
  }
  get viewInverseTransposeMatrix() {
    return (this._viewInverseTransposeMatrixDirty || this._viewDirty) && (h2(this._viewInverseTransposeMatrix, this.viewMatrix), s3(this._viewInverseTransposeMatrix, this._viewInverseTransposeMatrix), this._viewInverseTransposeMatrixDirty = false), this._viewInverseTransposeMatrix;
  }
  depthNDCToWorld(t7) {
    const { near: i8, far: e8 } = this;
    return 2 * i8 * e8 / (e8 + i8 - t7 * (e8 - i8));
  }
  get perRenderPixelRatio() {
    return Math.tan(this.fovX / 2) / (this.width / 2);
  }
  get perScreenPixelRatio() {
    return this.perRenderPixelRatio * this.pixelRatio;
  }
  get aboveGround() {
    return null != this.relativeElevation && this.relativeElevation >= 0;
  }
  get _projectionMatrixInternal() {
    const t7 = this.width, i8 = this.height, e8 = this.near * Math.tan(this.fovY / 2) * 2, r13 = e8 * this._aspect, s9 = e8 / this.rows, o8 = r13 / this.columns, n11 = -r13 / 2 + this.column * o8, h6 = n11 + o8, a8 = -e8 / 2 + this.row * s9, p8 = a8 + s9, u5 = A(e3(), n11 * (1 + 2 * this._padding[3] / t7), h6 * (1 + 2 * this._padding[1] / t7), a8 * (1 + 2 * this._padding[2] / i8), p8 * (1 + 2 * this._padding[0] / i8), this.near, this.far), l11 = this._get("projectionMatrix");
    return l11 && C(l11, u5) ? l11 : u5;
  }
  copyFrom(t7) {
    s5(this._ray.origin, t7.eye), this.center = t7.center, this.up = t7.up, a3(this._viewport, t7.viewport), this.notifyChange("_viewport"), a3(this._padding, t7.padding), this.notifyChange("_padding"), r4(this._nearFar, t7.nearFar), this.notifyChange("_nearFar"), this._fov = t7.fov, this.row = t7.row, this.column = t7.column, this.rows = t7.rows, this.columns = t7.columns, this.relativeElevation = t7.relativeElevation;
    const i8 = t7;
    return this._viewDirty = i8._viewDirty, this._viewDirty || (n2(this._viewMatrix, t7.viewMatrix), this.notifyChange("_viewMatrix")), this._viewProjectionDirty = true, this._frustumDirty = i8._frustumDirty, this._frustumDirty || (x2(this._frustum, t7.frustum), this._frustumDirty = false), i8._viewInverseTransposeMatrixDirty ? this._viewInverseTransposeMatrixDirty = true : (n2(this._viewInverseTransposeMatrix, t7.viewInverseTransposeMatrix), this._viewInverseTransposeMatrixDirty = false), a3(this._fullViewport, t7.fullViewport), this.pixelRatio = t7.pixelRatio, this;
  }
  copyViewFrom(t7) {
    this.eye = t7.eye, this.center = t7.center, this.up = t7.up, this.fov = t7.fov;
  }
  clone() {
    return new Z3().copyFrom(this);
  }
  equals(t7) {
    return H(this.eye, t7.eye) && H(this.center, t7.center) && H(this.up, t7.up) && E3(this._viewport, t7.viewport) && E3(this._padding, t7.padding) && E2(this.nearFar, t7.nearFar) && this._fov === t7.fov && this.pixelRatio === t7.pixelRatio && this.relativeElevation === t7.relativeElevation && this.row === t7.row && this.column === t7.column && this.rows === t7.rows && this.columns === t7.columns;
  }
  almostEquals(t7) {
    const i8 = Math.max(1, 1 / this.pixelRatio, 1 / t7.pixelRatio);
    if (Math.abs(t7.fov - this._fov) >= 1e-3 || x(t7.screenPadding, this.screenPadding) >= i8 || x(this.screenViewport, t7.screenViewport) >= i8 || this.row !== t7.row || this.column !== t7.column || this.rows !== t7.rows || this.columns !== t7.columns) return false;
    R2(rt, t7.eye, t7.center), R2(st, this.eye, this.center);
    const e8 = P2(rt, st), r13 = Z(rt), s9 = Z(st), o8 = 5e-4;
    return e8 * e8 >= (1 - 1e-10) * r13 * s9 && X2(t7.eye, this.eye) < Math.max(r13, s9) * o8 * o8;
  }
  computeRenderPixelSizeAt(t7) {
    return this.computeRenderPixelSizeAtDist(this._viewDirectionDistance(t7));
  }
  computeRenderPixelSizeAtDist(t7) {
    return t7 * this.perRenderPixelRatio;
  }
  computeScreenPixelSizeAt(t7) {
    return this.computeScreenPixelSizeAtDist(this._viewDirectionDistance(t7));
  }
  _viewDirectionDistance(t7) {
    return Math.abs(f3(this.viewForward, c2(rt, t7, this.eye)));
  }
  computeScreenPixelSizeAtDist(t7) {
    return t7 * this.perScreenPixelRatio;
  }
  computeDistanceFromRadius(t7, i8) {
    return t7 / Math.tan(Math.min(this.fovX, this.fovY) / (2 * (i8 || 1)));
  }
  getScreenCenter(t7 = f2()) {
    return t7[0] = (this.padding[3] + this.width / 2) / this.pixelRatio, t7[1] = (this.padding[0] + this.height / 2) / this.pixelRatio, t7;
  }
  getRenderCenter(t7, i8 = 0.5, e8 = 0.5) {
    return t7[0] = this.padding[3] + this.width * i8, t7[1] = this.padding[2] + this.height * e8, t7[2] = 0.5, t7;
  }
  setGLViewport(t7) {
    const i8 = this.viewport, e8 = this.padding;
    t7.setViewport(i8[0] - e8[3], i8[1] - e8[2], i8[2] + e8[1] + e8[3], i8[3] + e8[0] + e8[2]);
  }
  applyProjection(t7, i8) {
    t7 !== it && s5(it, t7), it[3] = 1, z2(it, it, this.projectionMatrix);
    const e8 = Math.abs(it[3]);
    g(it, it, 1 / e8);
    const s9 = this.fullViewport;
    i8[0] = o(0, s9[0] + s9[2], 0.5 + 0.5 * it[0]), i8[1] = o(0, s9[1] + s9[3], 0.5 + 0.5 * it[1]), i8[2] = 0.5 * (it[2] + 1), i8[3] = e8;
  }
  unapplyProjection(t7, i8) {
    const e8 = this.fullViewport;
    it[0] = (t7[0] / (e8[0] + e8[2]) * 2 - 1) * t7[3], it[1] = (t7[1] / (e8[1] + e8[3]) * 2 - 1) * t7[3], it[2] = (2 * t7[2] - 1) * t7[3], it[3] = t7[3], null != this.inverseProjectionMatrix && (z2(it, it, this.inverseProjectionMatrix), i8[0] = it[0], i8[1] = it[1], i8[2] = it[2]);
  }
  projectToScreen(t7, i8) {
    return this.projectToRenderScreen(t7, ot), this.renderToScreen(ot, i8), i8;
  }
  projectToRenderScreen(t7, i8) {
    if (it[0] = t7[0], it[1] = t7[1], it[2] = t7[2], it[3] = 1, z2(it, it, this.viewProjectionMatrix), 0 === it[3]) return null;
    const e8 = it;
    g(e8, e8, 1 / Math.abs(it[3]));
    const s9 = this.fullViewport, o8 = o(0, s9[0] + s9[2], 0.5 + 0.5 * e8[0]), n11 = o(0, s9[1] + s9[3], 0.5 + 0.5 * e8[1]);
    return "x" in i8 ? (i8.x = o8, i8.y = n11) : (i8[0] = o8, i8[1] = n11, i8.length > 2 && (i8[2] = 0.5 * (e8[2] + 1))), i8;
  }
  unprojectFromScreen(t7, i8) {
    return this.unprojectFromRenderScreen(this.screenToRender(t7, ot), i8);
  }
  unprojectFromRenderScreen(t7, i8) {
    if (c(et2, this.projectionMatrix, this.viewMatrix), !h2(et2, et2)) return null;
    const e8 = this.fullViewport;
    return it[0] = 2 * (t7[0] - e8[0]) / e8[2] - 1, it[1] = 2 * (t7[1] - e8[1]) / e8[3] - 1, it[2] = 2 * t7[2] - 1, it[3] = 1, z2(it, it, et2), 0 === it[3] ? null : (i8[0] = it[0] / it[3], i8[1] = it[1] / it[3], i8[2] = it[2] / it[3], i8);
  }
  constrainWindowSize(t7, i8, e8, r13) {
    const s9 = t7 * this.pixelRatio, o8 = i8 * this.pixelRatio, n11 = Math.max(s9 - e8 / 2, 0), h6 = Math.max(this.fullHeight - o8 - r13 / 2, 0), a8 = -Math.min(s9 - e8 / 2, 0), p8 = -Math.min(this.fullHeight - o8 - r13 / 2, 0), u5 = e8 - a8 - -Math.min(this.fullWidth - s9 - e8 / 2, 0), l11 = r13 - p8 - -Math.min(o8 - r13 / 2, 0);
    return [Math.round(n11), Math.round(h6), Math.round(u5), Math.round(l11)];
  }
  computeUp(t7) {
    1 === t7 ? this._computeUpGlobal() : this._computeUpLocal();
  }
  screenToRender(t7, i8) {
    const e8 = t7[0] * this.pixelRatio, r13 = this.fullHeight - t7[1] * this.pixelRatio;
    return i8[0] = e8, i8[1] = r13, i8;
  }
  renderToScreen(t7, i8) {
    const e8 = t7[0] / this.pixelRatio, r13 = (this.fullHeight - t7[1]) / this.pixelRatio;
    i8[0] = e8, i8[1] = r13;
  }
  _computeUpGlobal() {
    c2(rt, this.center, this.eye);
    const t7 = r7(this.center);
    t7 < 1 ? H(this._up, N) && (s5(this._up, N), this._markViewDirty(), this.notifyChange("_up")) : Math.abs(P2(rt, this.center)) > 0.9999 * r7(rt) * t7 || (_(st, rt, this.center), _(st, st, rt), A3(st, st), H(this._up, st) || (s5(this._up, st), this.notifyChange("_up"), this._markViewDirty()));
  }
  _computeUpLocal() {
    K(rt, this.eye, this.center), Math.abs(rt[2]) <= 0.9999 && (g(rt, rt, rt[2]), o3(rt, -rt[0], -rt[1], 1 - rt[2]), A3(rt, rt), H(this._up, rt) || (s5(this._up, rt), this.notifyChange("_up"), this._markViewDirty()));
  }
  _compareAndSetView(t7, i8, r13 = "") {
    "number" == typeof t7[0] && isFinite(t7[0]) && "number" == typeof t7[1] && isFinite(t7[1]) && "number" == typeof t7[2] && isFinite(t7[2]) ? H(t7, i8) || (s5(i8, t7), this._markViewDirty(), r13.length && this.notifyChange(r13)) : i.getLogger("esri.views.3d.webgl-engine.lib.RenderCamera").warn("RenderCamera vector contains invalid number, ignoring value");
  }
  _markViewDirty() {
    this._viewDirty = true, this._frustumDirty = true, this._viewProjectionDirty = true;
  }
  _recomputeFrustum() {
    this._frustumDirty && (y4(this.viewMatrix, this.projectionMatrix, this._frustum), this._frustumDirty = false);
  }
  _ensureViewClean() {
    this._viewDirty && (X(this._viewMatrix, this.eye, this.center, this.up), this.notifyChange("_viewMatrix"), this._viewDirty = false, this._viewInverseTransposeMatrixDirty = true);
  }
};
__decorate([m()], $.prototype, "_viewport", void 0), __decorate([m()], $.prototype, "_padding", void 0), __decorate([m()], $.prototype, "_fov", void 0), __decorate([m()], $.prototype, "_nearFar", void 0), __decorate([m()], $.prototype, "_viewDirty", void 0), __decorate([m()], $.prototype, "_viewMatrix", void 0), __decorate([m()], $.prototype, "_pixelRatio", void 0), __decorate([m()], $.prototype, "pixelRatio", null), __decorate([m()], $.prototype, "row", void 0), __decorate([m()], $.prototype, "column", void 0), __decorate([m()], $.prototype, "_rows", void 0), __decorate([m()], $.prototype, "rows", null), __decorate([m()], $.prototype, "_columns", void 0), __decorate([m()], $.prototype, "columns", null), __decorate([m()], $.prototype, "eye", null), __decorate([m()], $.prototype, "center", null), __decorate([m()], $.prototype, "_center", void 0), __decorate([m()], $.prototype, "up", null), __decorate([m()], $.prototype, "_up", void 0), __decorate([m()], $.prototype, "viewMatrix", null), __decorate([m({ readOnly: true })], $.prototype, "viewForward", null), __decorate([m({ readOnly: true })], $.prototype, "viewUp", null), __decorate([m({ readOnly: true })], $.prototype, "viewRight", null), __decorate([m({ readOnly: true })], $.prototype, "nearFar", null), __decorate([m()], $.prototype, "near", null), __decorate([m()], $.prototype, "far", null), __decorate([m()], $.prototype, "viewport", null), __decorate([m({ readOnly: true })], $.prototype, "screenViewport", null), __decorate([m({ readOnly: true })], $.prototype, "screenPadding", null), __decorate([m()], $.prototype, "x", null), __decorate([m()], $.prototype, "y", null), __decorate([m()], $.prototype, "width", null), __decorate([m()], $.prototype, "height", null), __decorate([m()], $.prototype, "fullWidth", null), __decorate([m()], $.prototype, "fullHeight", null), __decorate([m({ readOnly: true })], $.prototype, "_aspect", null), __decorate([m()], $.prototype, "padding", null), __decorate([m({ readOnly: true })], $.prototype, "projectionMatrix", null), __decorate([m({ readOnly: true })], $.prototype, "inverseProjectionMatrix", null), __decorate([m()], $.prototype, "fov", null), __decorate([m()], $.prototype, "fovX", null), __decorate([m()], $.prototype, "fovY", null), __decorate([m()], $.prototype, "viewInverseTransposeMatrix", null), __decorate([m({ readOnly: true })], $.prototype, "_projectionMatrixInternal", null), __decorate([m()], $.prototype, "relativeElevation", void 0), $ = Z3 = __decorate([a("esri.views.3d.webgl.RenderCamera")], $);
var tt = $;
var it = n3();
var et2 = e3();
var rt = n();
var st = n();
var ot = y();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/DepthRange.js
var _t = class _t {
  constructor(t7 = 1 / 0, r13 = -1 / 0) {
    this.near = t7, this.far = r13;
  }
  set(t7, r13) {
    this.near = t7, this.far = r13;
  }
  union(t7) {
    null != t7 && (this.near = Math.min(this.near, t7.near), this.far = Math.max(this.far, t7.far));
  }
  within(t7) {
    return this.near <= t7 && t7 <= this.far;
  }
  equals(t7) {
    return this.near === t7.near && this.far === t7.far;
  }
};
_t.Zero = new _t(0, 0);
_t.Infinite = new _t();
var t6 = _t;

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/IntersectorInterfaces.js
var e5 = class {
  constructor() {
    this.verticalOffset = 0, this.selectionMode = false, this.hud = true, this.selectOpaqueTerrainOnly = true, this.invisibleTerrain = false, this.backfacesTerrain = true, this.isFiltered = false, this.filteredLayerViewUids = [], this.store = 2, this.normalRequired = true, this.excludeLabels = false;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Intersector.js
var m7 = 1e-5;
var u3 = class {
  constructor(t7) {
    this.options = new e5(), this._results = new _4(), this.transform = new v3(), this.camera = new tt(), this.tolerance = m7, this.verticalOffset = null, this._ray = b5(), this._rayEnd = n(), this._rayBeginTransformed = n(), this._rayEndTransformed = n(), this.viewingMode = t7 ?? 1;
  }
  get results() {
    return this._results;
  }
  get ray() {
    return this._ray;
  }
  get rayBegin() {
    return this._ray.origin;
  }
  get rayEnd() {
    return this._rayEnd;
  }
  reset(t7, s9, i8) {
    this.resetWithRay(S(t7, s9, this._ray), i8);
  }
  resetWithRay(s9, i8) {
    this.camera = i8, s9 !== this._ray && v2(s9, this._ray), 0 !== this.options.verticalOffset ? 2 === this.viewingMode ? this._ray.origin[2] -= this.options.verticalOffset : this.verticalOffset = this.options.verticalOffset : this.verticalOffset = null, u(this._rayEnd, this._ray.origin, this._ray.direction), this._results.init(this._ray);
  }
  intersect(t7 = null, s9, i8, r13, e8) {
    this.point = s9, this.filterPredicate = r13, this.tolerance = i8 ?? m7;
    const n11 = d3(this.verticalOffset);
    if (t7 && t7.length > 0) {
      const s10 = e8 ? (t8) => {
        e8(t8) && this.intersectObject(t8);
      } : (t8) => {
        this.intersectObject(t8);
      };
      for (const i9 of t7) {
        const t8 = i9.getSpatialQueryAccelerator?.();
        null != t8 ? (null != n11 ? t8.forEachAlongRayWithVerticalOffset(this._ray.origin, this._ray.direction, s10, n11) : t8.forEachAlongRay(this._ray.origin, this._ray.direction, s10), this.options.selectionMode && this.options.hud && t8.forEachDegenerateObject(s10)) : i9.objects.forEach((t9) => s10(t9));
      }
    }
    this.sortResults();
  }
  intersectObject(t7) {
    const i8 = t7.geometries;
    if (!i8) return;
    const r13 = t7.effectiveTransformation, e8 = d3(this.verticalOffset);
    for (const n11 of i8) {
      if (!n11.visible) continue;
      const { material: i9, id: a8 } = n11;
      if (!i9.visible) continue;
      this.transform.setAndInvalidateLazyTransforms(r13, n11.transformation), E4(this._rayBeginTransformed, this.rayBegin, this.transform.inverse), E4(this._rayEndTransformed, this.rayEnd, this.transform.inverse);
      const o8 = this.transform.transform;
      null != e8 && (e8.objectTransform = this.transform), i9.intersect(n11, this.transform.transform, this, this._rayBeginTransformed, this._rayEndTransformed, (s9, i10, r14, e9) => this.handleObjectIntersection({ object: t7, geometryId: a8, primitiveIndex: r14 }, s9, i10, o8, e9));
    }
  }
  handleObjectIntersection(t7, s9, i8, r13, e8) {
    if (s9 < 0 || null != this.filterPredicate && !this.filterPredicate(this._ray.origin, this._rayEnd, s9)) return;
    const n11 = e8 ? this._results.hud : this._results;
    t7 = e8 ? new c3(t7, e8) : t7;
    const a8 = e8 ? (r14) => r14.set(1, t7, s9, i8) : (e9) => e9.set(4, t7, s9, i8, r13);
    if ((null == n11.min.distance || s9 < n11.min.distance) && a8(n11.min), 0 !== this.options.store && (null == n11.max.distance || s9 > n11.max.distance) && a8(n11.max), 2 === this.options.store) if (e8) {
      const t8 = new o4(this._ray);
      a8(t8), this._results.hud.all.push(t8);
    } else {
      const t8 = new f4(this._ray);
      a8(t8), this._results.all.push(t8);
    }
  }
  sortResults(t7 = this._results.all) {
    t7.sort((t8, s9) => t8.distance !== s9.distance ? (t8.distance ?? 0) - (s9.distance ?? 0) : t8.drapedLayerOrder !== s9.drapedLayerOrder ? y7(t8.drapedLayerOrder, s9.drapedLayerOrder) : y7(t8.renderPriority, s9.renderPriority));
  }
};
function y7(t7, s9) {
  return (s9 ?? -Number.MAX_VALUE) - (t7 ?? -Number.MAX_VALUE);
}
var _4 = class {
  constructor() {
    this.min = new f4(b5()), this.max = new f4(b5()), this.hud = { min: new o4(b5()), max: new o4(b5()), all: new Array() }, this.ground = new f4(b5()), this.all = [];
  }
  init(t7) {
    this.min.init(t7), this.max.init(t7), this.ground.init(t7), this.all.length = 0, this.hud.min.init(t7), this.hud.max.init(t7), this.hud.all.length = 0;
  }
};

// node_modules/@arcgis/core/views/3d/camera/intersectionUtils.js
var j5 = n();
var R5 = n();
var C2 = n();

// node_modules/@arcgis/core/geometry/support/polygonExtentClipping.js
function e6(t7, n11) {
  const r13 = [], e8 = [];
  return c5(r13, t7, n11, 0), c5(e8, r13, n11, 1), c5(r13, e8, n11, 2), c5(e8, r13, n11, 3), e8;
}
function c5(t7, n11, e8, c8) {
  const f6 = s6(e8, c8);
  if (t7.length = 0, n11.length) {
    1 === f6(i4, n11[0], n11[0]) && o5(t7, n11[0]);
    for (let e9 = 0; e9 < n11.length; e9++) {
      const c9 = n11[e9 === n11.length - 1 ? 0 : e9 + 1];
      switch (f6(i4, n11[e9], c9)) {
        case 1:
          o5(t7, c9);
          break;
        case 3:
          o5(t7, t2(i4));
          break;
        case 2:
          o5(t7, t2(i4)), o5(t7, c9);
      }
    }
  }
}
function o5(n11, r13) {
  0 !== n11.length && T(n11.at(-1), r13) || n11.push(r13);
}
function s6(t7, n11) {
  const r13 = 0 === n11 || 2 === n11 ? 0 : 1, e8 = t7[n11], c8 = 0 === n11 || 1 === n11 ? 1 : -1, o8 = 0 === r13 ? 1 : 0;
  return (t8, n12, s9) => {
    if (n12[r13] < e8 && s9[r13] < e8) return 1 === c8 ? 0 : 1;
    if (n12[r13] > e8 && s9[r13] > e8) return 1 === c8 ? 1 : 0;
    const i8 = (s9[o8] - n12[o8]) / (s9[r13] - n12[r13]), f6 = n12[o8] + i8 * (e8 - n12[r13]);
    return t8[r13] = e8, t8[o8] = f6, (n12[r13] < e8 ? 1 : -1) * c8 > 0 ? 2 : 3;
  };
}
var i4 = n4();

// node_modules/@arcgis/core/views/3d/support/cameraUtilsInternal.js
var l9 = n();
var u4 = n();
function h5() {
  return { direction: n(), up: n() };
}
function g5(m11, f6, p8, h6, g7) {
  let j8 = A3(l9, m11), b9 = P2(j8, h6);
  const d7 = b9 > 0;
  b9 = Math.abs(b9), b9 > 0.99 && (b9 = Math.abs(P2(f6, h6)), b9 < 0.99 ? (s5(j8, f6), d7 && g(j8, j8, -1)) : j8 = null);
  let v7 = 0;
  if (j8) {
    g(u4, h6, P2(h6, j8)), c2(j8, j8, u4);
    const s9 = P2(j8, g7) / (r7(j8) * r7(g7));
    _(u4, j8, g7);
    v7 = (P2(u4, h6) > 0 ? 1 : -1) * M(b2(s9));
  }
  const x4 = M(b2(-P2(h6, m11) / r7(m11)));
  return p8 ? (p8.heading = v7, p8.tilt = x4, p8) : { heading: v7, tilt: x4 };
}
function j6(t7, o8, s9, r13) {
  c2(b8, s9, o8), L2(r13, m3(o8, b8), t7) || t7 === s9 || s5(t7, s9);
}
var b8 = n();

// node_modules/@arcgis/core/chunks/cameraUtilsPlanar.js
var v6 = r3(0, 1, 0);
var A7 = r3(0, 0, 1);
var w4 = e3();
var C3 = n();
var E5 = n();
function H2(e8, i8, n11, c8 = h5()) {
  const { direction: m11, up: l11 } = c8;
  return R(w4, -s2(i8)), l3(w4, w4, s2(n11)), E4(m11, A7, w4), g(m11, m11, -1), E4(l11, v6, w4), c8;
}
function U2(e8, t7, r13, o8) {
  return g5(t7, r13, o8, A7, v6);
}
function V3(e8, t7, r13, o8) {
  const i8 = H2(e8, r13, o8), n11 = n();
  return g(n11, i8.direction, -t7), u(n11, n11, e8), { up: i8.up, eye: n11, heading: r13, tilt: o8 };
}
function _5(t7) {
  return M(t7);
}
function P5(e8) {
  return s2(e8);
}
function S4(e8, t7, r13, o8, i8) {
  const n11 = e8.renderSpatialReference, s9 = e8.spatialReference ?? t7.spatialReference;
  return i2(t7, C3, n11), i2(t7, E5, n11), C3[0] -= r13 / 2, E5[0] += r13 / 2, C3[1] -= o8 / 2, E5[1] += o8 / 2, n6(C3, n11, C3, s9), n6(E5, n11, E5, s9), i8 ? (i8.xmin = C3[0], i8.ymin = C3[1], i8.xmax = E5[0], i8.ymax = E5[1], i8.spatialReference = s9) : i8 = new z(C3[0], C3[1], E5[0], E5[1], s9), i8;
}
function k5(e8, t7) {
  const r13 = e8.frustum, { renderCoordsHelper: o8 } = e8, i8 = o8.getAltitude(t7), s9 = e8.spatialReference, a8 = e8.state.camera.eye, c8 = [], m11 = r13.planes[5];
  for (let l11 = 0; l11 < 4; l11++) {
    const e9 = r13.lines[l11];
    o8.intersectInfiniteManifold(k2(e9.origin, e9.direction), i8, O4) || I4(O4, r13, o8, e9.endpoint, i8), j6(O4, a8, O4, m11), c8.push(r8(O4[0], O4[1]));
  }
  return M3(e6(c8, o8.extent), o8, s9);
}
function I4(e8, t7, r13, o8, i8) {
  const n11 = t7.lines[11].direction, s9 = (i8 - r13.getAltitude(o8)) / n11[2];
  q(e8, o8, n11, s9);
}
function M3(e8, t7, r13) {
  const o8 = e8.map((e9) => (o3(O4, e9[0], e9[1], 0), t7.fromRenderCoords(O4, O4, r13), [O4[0], O4[1]]));
  return o8.length <= 2 ? new P({ spatialReference: r13 }) : (o8.push(o8[0].slice()), h3(o8) || o8.reverse(), new P({ rings: [o8], spatialReference: r13 }));
}
var O4 = n();
var z4 = Object.freeze(Object.defineProperty({ __proto__: null, directionToHeadingTilt: U2, eyeForCenterWithHeadingTilt: V3, eyeTiltToLookAtTilt: P5, headingTiltToDirectionUp: H2, lookAtTiltToEyeTilt: _5, toArea: k5, toExtent: S4 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/views/3d/state/Frustum.js
var _c = class _c {
  get planes() {
    return this.frustum;
  }
  get points() {
    return this._points;
  }
  get mutablePoints() {
    return this._points;
  }
  get direction() {
    return this._direction;
  }
  get origin() {
    return this._origin;
  }
  constructor(t7) {
    this.renderCoordsHelper = t7, this.frustum = h4(), this._points = k3(), this.lines = new Array(12), this._origin = n(), this._direction = n(), this._altitude = null;
    for (let i8 = 0; i8 < 12; i8++) this.lines[i8] = { origin: null, direction: n(), endpoint: null };
  }
  update(i8) {
    y4(i8.viewMatrix, i8.projectionMatrix, this.frustum, this._points), s5(this._origin, i8.eye), s5(this._direction, i8.viewForward), this._altitude = this.renderCoordsHelper.getAltitude(this._origin), this._updateLines();
  }
  updatePoints(i8) {
    for (let s9 = 0; s9 < this._points.length; s9++) s5(this._points[s9], i8[s9]);
    S2(this.frustum, this._points), this._updateLines();
  }
  get altitude() {
    return this._altitude;
  }
  intersectsSphere(t7) {
    return w2(this.frustum, t7);
  }
  intersectsRay(t7) {
    return O2(this.frustum, t7);
  }
  intersectsLineSegment(t7, i8) {
    return d(this.frustum, t7, i8);
  }
  intersectsPoint(t7) {
    return q3(this.frustum, t7);
  }
  _updateLines() {
    const t7 = this._points;
    for (let i8 = 0; i8 < 4; i8++) {
      const s9 = i8 + 4;
      d5(this.lines[i8], t7[i8], t7[s9]), d5(this.lines[i8 + 4], t7[i8], 3 === i8 ? t7[0] : t7[i8 + 1]), d5(this.lines[i8 + 8], t7[s9], 3 === i8 ? t7[4] : t7[s9 + 1]);
    }
  }
};
_c.planePointIndices = A5;
_c.nearFarLineIndices = [[0, 4], [1, 5], [2, 6], [3, 7]];
var c6 = _c;
function d5(t7, s9, e8) {
  t7.origin = s9, t7.endpoint = e8, K(t7.direction, s9, e8);
}

// node_modules/@arcgis/core/views/3d/environment/atmosphereUtils.js
var i5 = r3(parseFloat(Number(5802e-9).toFixed(6)), parseFloat(Number(13558e-9).toFixed(6)), parseFloat(Number(331e-7).toFixed(6)));
var m8 = 3;
var s7 = r3(m8 * parseFloat(Number(65e-8).toFixed(6)), m8 * parseFloat(Number(1881e-9).toFixed(6)), m8 * parseFloat(Number(85e-9).toFixed(6)));
var p5 = r3(parseFloat(Number(i5[0] + s7[0]).toFixed(6)), parseFloat(Number(i5[1] + s7[1]).toFixed(6)), parseFloat(Number(i5[2] + s7[2]).toFixed(6)));

// node_modules/@arcgis/core/views/3d/state/NearFarHeuristic.js
var P6 = 2;
var k6 = n();
var q6 = n();
var D = P3();
var F2 = b5();

// node_modules/@arcgis/core/views/3d/state/utils/viewUtils.js
function c7(i8, c8, f6) {
  i8.worldUpAtPosition(c8, e7), c2(m9, f6, c8);
  const n11 = r7(m9);
  return 0 === n11 ? 0 : b2(P2(m9, e7) / n11);
}
var e7 = n();
var m9 = n();

// node_modules/@arcgis/core/views/3d/support/earthUtils.js
function l10(e8, r13, u5) {
  const i8 = r13 / u5, s9 = s2(e8), l11 = Math.sin(i8 / 2), a8 = Math.cos(s9), c8 = 2 * l2(Math.sqrt(l11 * l11 / (a8 * a8)));
  return M(c8);
}

// node_modules/@arcgis/core/chunks/cameraUtilsSpherical.js
var tt2 = r3(0, 0, 1);
var et3 = A3(n(), r3(1, 1, 1));
var rt2 = e3();
var st2 = n();
var ot2 = n();
function at(t7, r13, s9, o8 = h5()) {
  _(st2, t7, tt2), 0 === P2(st2, st2) && _(st2, t7, et3), p(rt2, -s2(r13), t7), b3(rt2, rt2, -s2(s9), st2);
  const { up: a8, direction: c8 } = o8;
  return _(a8, st2, t7), A3(a8, a8), E4(a8, a8, rt2), A3(c8, t7), y3(c8, c8), E4(c8, c8, rt2), o8;
}
function nt(t7, e8, r13, s9) {
  const o8 = st2, a8 = ot2;
  return A3(o8, t7), _(ot2, o8, tt2), 0 === P2(ot2, ot2) && _(ot2, o8, et3), _(a8, ot2, o8), g5(e8, r13, s9, o8, a8);
}
function it2(t7, r13, o8, a8) {
  const n11 = { eye: n(), up: null, tilt: a8, heading: o8 }, i8 = st2;
  i8[0] = t7[0], i8[1] = t7[2], i8[2] = -t7[1];
  const c8 = r13, l11 = s2(o8), m11 = s2(a8), p8 = Math.sin(l11), u5 = Math.cos(l11), f6 = Math.sin(m11), y8 = Math.cos(m11), g7 = r7(i8);
  let M4;
  if (Math.abs(m11) < 1e-8) M4 = c8 + g7;
  else {
    const t8 = g7 / f6, e8 = l2(c8 / t8), r14 = Math.PI - m11 - e8;
    M4 = t8 * Math.sin(r14);
  }
  const j8 = y8 * c8, b9 = c8 * c8 * (f6 * f6), x4 = u5 * u5 * b9, T4 = M4 - j8, w6 = T4 * T4, R6 = x4 * (x4 + w6 - i8[1] * i8[1]);
  if (R6 < 0) return g(n11.eye, i8, M4 / g7), n11.tilt = 0, lt(n11, t7);
  const C4 = Math.sqrt(R6), S5 = i8[1] * T4, U3 = x4 + w6;
  let P7;
  if (P7 = u5 > 0 ? -C4 + S5 : C4 + S5, Math.abs(U3) < 1e-8) return g7 < 1e-8 ? (n11.eye[0] = 0, n11.eye[1] = 0, n11.eye[2] = c8) : g(n11.eye, i8, M4 / g7), n11.tilt = 0, ct(n11.eye), lt(n11, t7);
  n11.eye[1] = P7 / U3;
  const I5 = p8 * p8 * b9, H3 = f6 * c8, k7 = u5 * H3 * n11.eye[1], q7 = n11.eye[1] * n11.eye[1], A8 = 1 - q7, E6 = Math.sqrt(A8), _7 = x4 * q7 + I5 - 2 * k7 * E6 * T4 + A8 * w6;
  return Math.abs(_7) < 1e-8 ? (g(n11.eye, i8, M4 / g7), n11.tilt = 0, ct(n11.eye), lt(n11, t7)) : (n11.eye[0] = (A8 * (M4 * i8[0] - j8 * i8[0]) - H3 * E6 * (i8[0] * n11.eye[1] * u5 + i8[2] * p8)) / _7, n11.eye[2] = (A8 * (M4 * i8[2] - j8 * i8[2]) - H3 * E6 * (i8[2] * n11.eye[1] * u5 - i8[0] * p8)) / _7, g(n11.eye, n11.eye, M4), ct(n11.eye), lt(n11, t7));
}
function ct(t7) {
  const e8 = t7[1];
  t7[1] = -t7[2], t7[2] = e8;
}
function lt(t7, e8) {
  const r13 = at(e8, t7.heading, t7.tilt);
  return t7.up = r13.up, t7;
}
function mt(t7, e8, o8) {
  const a8 = r7(e8), n11 = Math.sqrt(o8 * o8 + a8 * a8 - 2 * o8 * a8 * Math.cos(Math.PI - t7)), i8 = l2(o8 / (n11 / Math.sin(t7)));
  return M(t7 - i8);
}
function pt(t7, r13, o8) {
  const a8 = s2(t7), n11 = r7(r13);
  return l2(o8 / (n11 / Math.sin(a8))) + a8;
}
function ut(s9, o8, a8, n11, i8) {
  let c8, l11, m11, p8;
  const u5 = o8.latitude, f6 = E(s9.spatialReference).radius, h6 = o8.longitude, d7 = l10(u5, a8, f6) / 2;
  c8 = h6 - d7, l11 = h6 + d7;
  const y8 = s2(u5), g7 = (1 + Math.sin(y8)) / (1 - Math.sin(y8)), M4 = (g7 + 1) * Math.tan(n11 / f6 / 2), j8 = M4 * M4;
  function b9(e8) {
    const r13 = Math.PI / 2;
    return (e8 = r6.normalize(e8, -r13)) > r13 && (e8 = Math.PI - e8), e8;
  }
  if (m11 = 1.5 * Math.PI - 2 * Math.atan(0.5 * (M4 + Math.sqrt(4 * g7 + j8))), p8 = m11 + n11 / f6, m11 = b9(m11), p8 = b9(p8), p8 < m11) {
    const t7 = p8;
    p8 = m11, m11 = t7;
  }
  if (m11 = Math.max(M(m11), -90), p8 = Math.min(M(p8), 90), l11 = A2.monotonic(c8, l11), l11 - c8 > 180) {
    const t7 = (l11 - c8 - 180) / 2;
    c8 += t7, l11 -= t7;
  }
  const v7 = s9.spatialReference && s9.spatialReference.isGeographic ? s9.spatialReference : f.WGS84;
  return i8 ? (i8.xmin = c8, i8.ymin = m11, i8.xmax = l11, i8.ymax = p8, i8.spatialReference = v7) : i8 = new z(c8, m11, l11, p8, v7), s9.spatialReference && s9.spatialReference.isWebMercator && j(i8, false, i8), i8;
}
function ft(t7, e8) {
  const { renderCoordsHelper: r13 } = t7, s9 = t7.state.camera.clone(), n11 = new c6(r13);
  s9.near = P6, n11.update(s9);
  const i8 = r13.getAltitude(e8), c8 = t7.spatialReference, l11 = r13.referenceEllipsoid.radius, m11 = s9.eye, p8 = 1 + p3(m11, e8) / (l11 + i8), u5 = Math.sqrt(p8 * p8 - 1), { minCurvature: f6, maxCurvature: h6, minSamples: d7, maxSamples: j8 } = Mt, b9 = gt(t7), v7 = r2((u5 - f6) / (h6 - f6), 0, 1), C4 = Math.round(o(d7, j8, v7)), S5 = s9.aboveGround, U3 = n11.planes[5], P7 = [], H3 = U(a2, jt, j2()), k7 = U(a2, bt, j2());
  s4(Ct, 0, 0, 0, 0);
  const q7 = (t8) => {
  };
  for (let a8 = 0; a8 < 4; a8++) {
    const t8 = 1 === a8 && !S5 || 3 === a8 && S5 ? 1 - b9 : 0, e9 = 1 === a8 && S5 || 3 === a8 && !S5 ? b9 : 1, s10 = n11.lines[a8], c9 = n11.lines[3 === a8 ? 0 : a8 + 1];
    for (let n12 = 0; n12 < C4; n12++) {
      const l12 = n12 / C4, p9 = 0 === n12 ? 0 : o(t8, e9, 1 === a8 ? 1 - (1 - l12) ** 2 : 3 === a8 ? l12 ** 2 : l12), u6 = I(xt, s10.origin, c9.origin, p9), f7 = q2(s10.direction, c9.direction, p9, vt);
      r13.intersectManifoldClosestSilhouette(k2(u6, f7), i8, Tt), j6(Tt, m11, Tt, U3), P7.push(t(Tt)), 0 !== P7.length && q7(X2(P7.at(-1), Tt));
      const h7 = (O(H3, Tt) ? 1 : 0) | (O(k7, Tt) ? 2 : 0);
      Ct[h7] = 1;
    }
  }
  P7.length > 2 && q7(X2(P7[0], P7.at(-1)));
  const A8 = ht(p2(Ct) > 1 ? dt(yt(P7, H3), k7) : [P7], r13, c8);
  return new P({ rings: A8, spatialReference: c8 });
}
function ht(t7, e8, r13) {
  const s9 = 2 * e();
  return t7.map((t8) => {
    const o8 = [];
    let a8 = false;
    for (const n11 of t8) e8.fromRenderCoords(n11, Tt, r13), Math.abs(n11[0]) < s9 && Math.abs(n11[1]) < s9 ? (o8.push([null, Tt[1]]), o8.push([null, Tt[1]]), a8 = true) : o8.push([Tt[0], Tt[1]]);
    if (a8) for (let e9 = 0; e9 < o8.length; e9++) {
      const t9 = o8[e9];
      if (null != t9[0]) continue;
      const r14 = o8[e9 + 1], s10 = o8.at(0 === e9 ? -1 : e9 - 1);
      t9[0] = s10[0], e9++;
      const a9 = o8.at(e9 === o8.length - 1 ? 0 : e9 + 1);
      r14[0] = a9[0];
    }
    return o8.push(o8[0]), h3(o8) || o8.reverse(), o8;
  });
}
function dt(t7, e8) {
  const r13 = [];
  for (const s9 of t7) r13.push(...yt(s9, e8));
  return r13;
}
function yt(t7, e8) {
  const r13 = [], s9 = [], o8 = e();
  for (let n11 = 0; n11 < t7.length; n11++) {
    const a9 = t7[n11], i8 = n11 === t7.length - 1 ? t7[0] : t7[n11 + 1], c8 = b4(a9, i8, Rt), l11 = Z2(e8, c8.origin, c8.vector, 0, Tt);
    switch (l11) {
      case 2:
        r13.push(a9);
        break;
      case 3:
        s9.push(a9);
        break;
      case 0:
      case 1: {
        const [t8, n12, i9] = 0 === l11 ? [1, r13, s9] : [-1, s9, r13], c9 = k(e8), m11 = q(n(), Tt, c9, t8 * o8), p8 = q(n(), Tt, c9, t8 * -o8);
        n12.push(a9), n12.push(m11), i9.push(p8);
      }
    }
  }
  const a8 = [];
  return r13.length && a8.push(r13), s9.length && a8.push(s9), a8;
}
function gt(t7) {
  const { renderCoordsHelper: e8, state: { camera: r13 } } = t7, { center: s9, eye: o8 } = r13, a8 = Math.abs(e8.getAltitude(s9)), n11 = Math.abs(Math.PI / 2 - c7(e8, s9, o8));
  return w(wt, e8.referenceEllipsoid.radius + a8), et(wt, n11, r13.distance, r13.fovY);
}
var Mt = { minCurvature: s2(5), maxCurvature: s2(50), minSamples: 1, maxSamples: 6 };
var jt = r3(1, 0, 0);
var bt = r3(0, 1, 0);
var vt = n();
var xt = n();
var Tt = n();
var wt = P3();
var Rt = v();
var Ct = n3();
var St = Object.freeze(Object.defineProperty({ __proto__: null, directionToHeadingTilt: nt, eyeForCenterWithHeadingTilt: it2, eyeTiltToLookAtTilt: pt, headingTiltToDirectionUp: at, lookAtTiltToEyeTilt: mt, toArea: ft, toExtent: ut }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/views/3d/webgl.js
var g6 = { OPAQUE: "opaque-color", TRANSPARENT: "transparent-color", COMPOSITE: "composite-color", FINAL: "final-color" };
var j7 = { SSAO: "ssao", LASERLINES: "laserline-color", ANTIALIASING: "aa-color", HIGHLIGHTS: "highlight-color", MAGNIFIER: "magnifier-color", OCCLUDED: "occluded-color", VIEWSHED: "viewshed-color", CUTFILL_DEPTH: "cutfill-depth", CUTFILL_COLOR: "cutfill-color", OPAQUE_TERRAIN: "opaque-terrain-color", OPAQUE_ENVIRONMENT: "opaque-environment-color", TRANSPARENT_ENVIRONMENT: "transparent-environment-color", FOCUSAREA: "focusarea", FOCUSAREA_COLOR: "focusarea-color" };
var N2 = n();

// node_modules/@arcgis/core/views/3d/webgl/RenderNode.js
var a7 = class extends b {
  constructor(e8) {
    super(e8), this.view = null, this.consumes = { required: [] }, this.produces = g6.COMPOSITE, this.requireGeometryDepth = false, this._dirty = true;
  }
  initialize() {
    this.addHandles([l(() => this.view.ready, (e8) => {
      e8 && this.view.stage?.renderer.addRenderNode(this);
    }, h)]);
  }
  destroy() {
    this.view.stage?.renderer?.removeRenderNode(this);
  }
  precompile() {
  }
  render() {
    throw new s("RenderNode:render-function-not-implemented", "render() is not implemented.");
  }
  get camera() {
    return this.view.state.camera.clone();
  }
  get sunLight() {
    return this.bindParameters.lighting.legacy;
  }
  get gl() {
    return this.view.stage.renderView.renderingContext.gl;
  }
  get techniques() {
    return this.view.stage.renderView.techniques;
  }
  acquireOutputFramebuffer() {
    const e8 = this._frameBuffer?.getTexture()?.descriptor, r13 = this.view.stage.renderer.fboCache.acquire(e8?.width ?? 640, e8?.height ?? 480, this.produces);
    return r13.fbo?.initializeAndBind(), r13;
  }
  bindRenderTarget() {
    return this._frameBuffer?.fbo?.initializeAndBind(), this._frameBuffer;
  }
  requestRender(e8) {
    switch (e8) {
      case 2:
        this.view.state.fading = true;
      case 1:
        this.view.stage?.renderView.requestRender(e8);
      case 0:
      case void 0:
        this._dirty = true;
    }
  }
  resetWebGLState() {
    this.renderingContext.resetState(), this.renderingContext.bindFramebuffer(this._frameBuffer?.fbo);
  }
  get fboCache() {
    return this.view.stage.renderer.fboCache;
  }
  get bindParameters() {
    return this.renderContext.bind;
  }
  get renderingContext() {
    return this.view.stage.renderView.renderingContext;
  }
  get renderContext() {
    return this.view.stage?.renderer.renderContext;
  }
  updateAnimation(e8) {
    return !!this._dirty && (this._dirty = false, true);
  }
  doRender(e8) {
    this._frameBuffer = e8.find(({ name: e9 }) => e9 === this.produces);
    try {
      return this.render(e8);
    } finally {
      this._frameBuffer = null;
    }
  }
};
__decorate([m({ constructOnly: true })], a7.prototype, "view", void 0), __decorate([m({ constructOnly: true })], a7.prototype, "consumes", void 0), __decorate([m()], a7.prototype, "produces", void 0), __decorate([m({ readOnly: true })], a7.prototype, "techniques", null), a7 = __decorate([a("esri.views.3d.webgl.RenderNode")], a7);

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/DefaultVertexBufferLayouts.js
var i7 = [];
var n10 = [new t3("position", 3, R3.FLOAT, 0, 12)];
var r12 = [new t3("position", 2, R3.FLOAT, 0, 8)];
var s8 = n5(r12);
var p7 = n5(n10);
var w5 = [new t3("position", 2, R3.FLOAT, 0, 12), new t3("uv0", 2, R3.HALF_FLOAT, 8, 12)];
var m10 = [new t3("position", 2, R3.FLOAT, 0, 16), new t3("uv0", 2, R3.FLOAT, 8, 16)];

export {
  d3 as d,
  t4 as t,
  m6 as m,
  g4 as g,
  tt,
  t6 as t2,
  u3 as u,
  j7 as j,
  a7 as a,
  i7 as i,
  s8 as s,
  i3 as i2,
  l7 as l,
  _3 as _
};
//# sourceMappingURL=chunk-CYVJEU2B.js.map
