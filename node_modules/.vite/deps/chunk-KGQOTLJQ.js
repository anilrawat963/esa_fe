import {
  t
} from "./chunk-F43BIMML.js";
import {
  l,
  r as r3
} from "./chunk-WDTGOP77.js";
import {
  o,
  r as r2
} from "./chunk-AZXJIEZ6.js";
import {
  r
} from "./chunk-SMWUT52Z.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/TextHelperCanvas.js
function a(a3, n4, c) {
  return a3.canvas || (a3.canvas = document.createElement("canvas")), a3.canvas.width = n4, a3.canvas.height = c, a3.canvas;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/FontMetrics.js
function e(e2) {
  const { size: c } = e2.definition, a3 = e2.fontString(c);
  let i2 = n.get(a3);
  if (!i2) {
    const u2 = a(o2, 0, 0).getContext("2d");
    e2.setFontProperties(u2, c);
    const x = u2.measureText(r4);
    i2 = new s(x.actualBoundingBoxAscent, x.actualBoundingBoxDescent), n.set(a3, i2);
  }
  return i2;
}
var n = /* @__PURE__ */ new Map();
var s = class {
  get maxHeight() {
    return this.maxAscent + this.maxDescent;
  }
  constructor(t2, e2) {
    this.maxAscent = t2, this.maxDescent = e2;
  }
};
var o2 = { canvas: null };
var r4 = (() => {
  let t2 = "";
  for (let e2 = 32; e2 < 127; e2++) t2 += String.fromCharCode(e2);
  return t2;
})();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/TextRenderer.js
var n2 = 1;
var r5 = class {
  constructor(t2, e2, i2, s3) {
    this.text = t2, this._alignment = e2, this._parameters = i2, this._maxSize = s3, this._textWidths = [], this._lineWidths = [], this._renderPixelRatio = null, this._metricsCached = null, this.key = `${t2}--${this._parameters.key}-${this._alignment}`, this._lines = t2.replaceAll(" ", "Â ").split(/\r?\n/);
  }
  get displayWidth() {
    return Math.ceil(this._displayWidth + 2 * this._horizontalPadding);
  }
  get displayHeight() {
    let t2 = this._metrics.firstLineAscent;
    for (let e2 = 0; e2 < this._lines.length - 1; e2++) t2 += this._lineSpacing;
    return t2 += this._metrics.lastLineDescent, Math.ceil(t2 + 2 * this._haloSize + 2 * this._verticalPadding);
  }
  get renderedWidth() {
    return this._toRoundedRenderUnit(this.displayWidth);
  }
  get renderedHeight() {
    return this._toRoundedRenderUnit(this.displayHeight);
  }
  get firstRenderedBaselinePosition() {
    return this._toRenderUnit(this._firstLineYOffset + this._metrics.firstLineAscent);
  }
  get _firstLineYOffset() {
    return this._verticalPadding + this._haloSize;
  }
  get _metrics() {
    if (null == this._metricsCached) {
      const t2 = a(o3, d, d).getContext("2d"), e2 = this._parameters.definition.pixelRatio, n4 = this._fontSize * e2;
      this._parameters.setFontProperties(t2, n4);
      let r6 = 2 * this._haloSize;
      const h2 = this._parameters.definition.font;
      "italic" !== h2.style && "oblique" !== h2.style && "bold" !== h2.weight && "bolder" !== h2.weight || (r6 += 0.3 * t2.measureText("A").width), this._textWidths.length = 0, this._lineWidths.length = 0;
      let a3 = 0, l4 = 0, c = 0, g = 0, m2 = 0;
      this._lines.forEach((i2, s3) => {
        const n5 = t2.measureText(i2), h3 = n5.width / e2, o4 = h3 + r6;
        this._textWidths.push(h3), this._lineWidths.push(o4), a3 = Math.max(a3, o4), g = Math.max(g, n5.actualBoundingBoxAscent / e2), m2 = Math.max(m2, n5.actualBoundingBoxDescent / e2), 0 === s3 && (l4 = n5.actualBoundingBoxAscent / e2), s3 === this._lines.length - 1 && (c = n5.actualBoundingBoxDescent / e2);
      });
      const f = e(this._parameters), u2 = Math.max(g, f.maxAscent), p = Math.max(m2, f.maxDescent), x = l4, R = "underline" === this._parameters.definition.font.decoration ? p : c, S = a3;
      this._metricsCached = new _(x, R, u2, p, S);
    }
    return this._metricsCached;
  }
  get _lineSpacing() {
    return (this._midLineHeight + this._linePadding) * this._parameters.definition.lineSpacingFactor;
  }
  get _midLineHeight() {
    return this._metrics.midLineHeight;
  }
  get _linePadding() {
    return this._midLineHeight * a2;
  }
  get _midLineAscent() {
    return this._metrics.maxLineAscent;
  }
  get _renderedFontSize() {
    return this._toRenderUnit(this._fontSize);
  }
  get _fontSize() {
    return this._parameters.definition.size;
  }
  get _renderedHaloSize() {
    return this._toRenderUnit(this._haloSize);
  }
  get _haloSize() {
    return this._parameters.haloSize;
  }
  get _horizontalPadding() {
    return this._hasBackground ? this._parameters.definition.background.padding[0] : 0;
  }
  get _verticalPadding() {
    return Math.max(this._hasBackground ? this._parameters.definition.background.padding[1] : 0, n2);
  }
  get _hasBackground() {
    return !!this._parameters.backgroundStyle;
  }
  get renderPixelRatio() {
    if (null == this._renderPixelRatio) {
      const t2 = this._parameters.definition.pixelRatio;
      this._renderPixelRatio = Math.min(t2, Math.min(this._maxSize[0] / this.displayWidth, this._maxSize[1] / this.displayHeight));
    }
    return this._renderPixelRatio;
  }
  _getLineXOffset(t2) {
    switch (this._alignment) {
      case 0:
        return this._horizontalPadding;
      case 1:
        return (this.displayWidth - this._lineWidths[t2]) / 2;
      case 2:
        return this.displayWidth - this._horizontalPadding - this._lineWidths[t2];
    }
  }
  render(t2, i2, s3) {
    t2.save();
    const n4 = i2 /= this.renderPixelRatio, r6 = s3 /= this.renderPixelRatio, h2 = this._haloSize, o4 = this._firstLineYOffset + this._metrics.firstLineAscent;
    i2 += h2, s3 += o4;
    const a3 = this._haloSize > 0;
    a3 && this._renderHalo(t2, n4, r6, h2, o4), this._parameters.setFontProperties(t2, this._renderedFontSize);
    for (let e2 = 0; e2 < this._lines.length; ++e2) {
      const n5 = this._lines[e2], r7 = this._getLineXOffset(e2);
      a3 && (t2.globalCompositeOperation = "destination-out", t2.fillStyle = "rgb(0, 0, 0)", this._fillText(t2, n5, i2 + r7, s3), this._renderLineDecoration(t2, i2 + r7, s3, this._textWidths[e2])), t2.globalCompositeOperation = "source-over", t2.fillStyle = this._parameters.textStyle, this._fillText(t2, n5, i2 + this._getLineXOffset(e2), s3), this._renderLineDecoration(t2, i2 + r7, s3, this._textWidths[e2]), s3 += this._lineSpacing;
    }
    if (t.TEXT_SHOW_BASELINE) {
      t2.strokeStyle = l2, t2.setLineDash([2, 2]), t2.lineWidth = 1;
      let e2 = r6 + o4;
      for (let i3 = 0; i3 < this._lines.length; ++i3) this._drawLine(t2, [n4, e2], [n4 + this.displayWidth, e2]), e2 += this._lineSpacing;
    }
    if (t.TEXT_SHOW_BORDER && (t2.strokeStyle = l2, t2.setLineDash([]), t2.lineWidth = 1, this._drawBox(t2, [n4, r6], [this.displayWidth, this.displayHeight])), this._hasBackground) {
      const e2 = this._parameters.definition.background.borderRadius * this.renderPixelRatio;
      this._roundedRect(t2, n4, r6, e2), t2.globalCompositeOperation = "destination-over", t2.fillStyle = this._parameters.backgroundStyle, t2.fill();
    }
    t2.restore();
  }
  _renderLineDecoration(t2, e2, i2, s3, n4 = false) {
    if ("none" === this._parameters.definition.font.decoration || 0 === s3) return;
    const r6 = 1, h2 = Math.max(this._parameters.definition.size / 16, r6);
    switch (this._parameters.definition.font.decoration) {
      case "underline":
        i2 += 2 * h2;
        break;
      case "line-through":
        i2 -= 0.33 * this._midLineAscent;
    }
    const o4 = n4 ? this._haloSize : 0;
    t2.strokeStyle = n4 ? this._parameters.haloStyle : this._parameters.textStyle, t2.lineWidth = this._toRenderUnit(h2 + 2 * o4), t2.beginPath(), t2.moveTo(this._toRenderUnit(e2 - o4), this._toRenderUnit(i2)), t2.lineTo(this._toRenderUnit(e2 + s3 + o4), this._toRenderUnit(i2)), t2.stroke();
  }
  _roundedRect(e2, i2, s3, n4) {
    i2 = this._toRenderUnit(i2), s3 = this._toRenderUnit(s3);
    const r6 = this.renderedWidth, h2 = this.renderedHeight;
    0 !== n4 ? (n4 = r(n4, 0, Math.floor(h2 / 2)), e2.beginPath(), e2.moveTo(i2, s3 + n4), e2.arcTo(i2, s3, i2 + n4, s3, n4), e2.lineTo(i2 + r6 - n4, s3), e2.arcTo(i2 + r6, s3, i2 + r6, s3 + n4, n4), e2.lineTo(i2 + r6, s3 + h2 - n4), e2.arcTo(i2 + r6, s3 + h2, i2 + r6 - n4, s3 + h2, n4), e2.lineTo(i2 + n4, s3 + h2), e2.arcTo(i2, s3 + h2, i2, s3 + h2 - n4, n4), e2.closePath()) : e2.rect(i2, s3, r6, h2);
  }
  _renderHalo(t2, e2, i2, n4, r6) {
    const h2 = this.renderedWidth, a3 = this.renderedHeight, l4 = a(o3, Math.max(h2, d), Math.max(a3, d)), _2 = l4.getContext("2d");
    _2.clearRect(0, 0, h2, a3), this._parameters.setFontProperties(_2, this._renderedFontSize), _2.fillStyle = this._parameters.haloStyle, _2.strokeStyle = this._parameters.haloStyle;
    const c = this._renderedHaloSize < 3;
    _2.lineJoin = c ? "miter" : "round", c ? this._renderHaloEmulated(_2, n4, r6) : this._renderHaloNative(_2, n4, r6);
    let g = r6;
    for (let s3 = 0; s3 < this._lines.length; ++s3) {
      const t3 = this._getLineXOffset(s3);
      this._renderLineDecoration(_2, n4 + t3, g, this._textWidths[s3], true), g += this._lineSpacing;
    }
    t2.globalAlpha = this._parameters.definition.halo.color[3], t2.drawImage(l4, 0, 0, h2, a3, this._toRenderUnit(e2), this._toRenderUnit(i2), h2, a3), t2.globalAlpha = 1;
  }
  _renderHaloEmulated(t2, e2, i2) {
    for (let s3 = 0; s3 < this._lines.length; ++s3) {
      const n4 = this._lines[s3], r6 = this._getLineXOffset(s3);
      for (const [s4, o4] of h) this._fillText(t2, n4, e2 + r6 + this._haloSize * s4, i2 + this._haloSize * o4);
      i2 += this._lineSpacing;
    }
  }
  _renderHaloNative(t2, e2, i2) {
    const s3 = 2 * this._haloSize;
    for (let n4 = 0; n4 < this._lines.length; ++n4) {
      const r6 = this._lines[n4], h2 = this._getLineXOffset(n4), o4 = 5, a3 = 0.1;
      for (let n5 = 0; n5 < o4; n5++) {
        const d2 = 1 - (o4 - 1) * a3 + n5 * a3;
        t2.lineWidth = this._toRenderUnit(d2 * s3), this._strokeText(t2, r6, e2 + h2, i2);
      }
      i2 += this._lineSpacing;
    }
  }
  get _displayWidth() {
    return this._metrics.displayWidth;
  }
  _toRenderUnit(t2) {
    return t2 * this.renderPixelRatio;
  }
  _toRoundedRenderUnit(t2) {
    return Math.round(t2 * this.renderPixelRatio);
  }
  _fillText(t2, e2, i2, s3) {
    t2.fillText(e2, this._toRenderUnit(i2), this._toRenderUnit(s3));
  }
  _strokeText(t2, e2, i2, s3) {
    t2.strokeText(e2, this._toRenderUnit(i2), this._toRenderUnit(s3));
  }
  _drawLine(t2, e2, i2) {
    t2.beginPath(), t2.moveTo(this._toRoundedRenderUnit(e2[0]) + 0.5, this._toRoundedRenderUnit(e2[1]) + 0.5), t2.lineTo(this._toRoundedRenderUnit(i2[0]) + 0.5, this._toRoundedRenderUnit(i2[1]) + 0.5), t2.stroke();
  }
  _drawBox(t2, e2, i2) {
    const s3 = this._toRenderUnit(e2[0]), n4 = this._toRenderUnit(e2[1]), r6 = this._toRenderUnit(i2[0]), h2 = this._toRenderUnit(i2[1]), o4 = Math.floor(s3) + 0.5, a3 = Math.ceil(s3 + r6) - 0.5, d2 = Math.floor(n4) + 0.5, l4 = Math.ceil(n4 + h2) - 0.5;
    t2.beginPath(), t2.moveTo(o4, d2), t2.lineTo(a3, d2), t2.lineTo(a3, l4), t2.lineTo(o4, l4), t2.lineTo(o4, d2), t2.stroke();
  }
};
var h = [];
{
  const t2 = 16;
  for (let e2 = 0; e2 < 360; e2 += 360 / t2) h.push([Math.cos(Math.PI * e2 / 180), Math.sin(Math.PI * e2 / 180)]);
}
var o3 = { canvas: null };
var a2 = 0.2;
var d = 512;
var l2 = "rgb(255, 0, 255, 0.5)";
var _ = class {
  get firstLineHeight() {
    return this.firstLineAscent + this.maxLineDescent;
  }
  get midLineHeight() {
    return this.maxLineAscent + this.maxLineDescent;
  }
  get lastLineHeight() {
    return this.maxLineAscent + this.lastLineDescent;
  }
  constructor(t2, e2, i2, s3, n4) {
    this.firstLineAscent = t2, this.lastLineDescent = e2, this.maxLineAscent = i2, this.maxLineDescent = s3, this.displayWidth = n4;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/placementUtils.js
var n3 = Object.freeze({ left: 0, center: 0.5, right: 1 });
var i = Object.freeze({ "bottom-left": r3(0, 0), bottom: r3(0.5, 0), "bottom-right": r3(1, 0), left: r3(0, 0.5), center: r3(0.5, 0.5), right: r3(1, 0.5), "top-left": r3(0, 1), top: r3(0.5, 1), "top-right": r3(1, 1) });
function s2(t2) {
  switch (t2) {
    case "left":
      return 0;
    case "right":
      return 2;
    default:
      return 1;
  }
}
function l3(t2, e2) {
  switch (e2) {
    case "bottom":
      return "left" === t2 ? "bottom-left" : "right" === t2 ? "bottom-right" : "bottom";
    case "center":
      return t2;
    case "top":
      return "left" === t2 ? "top-left" : "right" === t2 ? "top-right" : "top";
  }
}
function m(t2) {
  return "middle" === t2 ? "center" : t2;
}
function u(r6, n4) {
  switch (r6) {
    case "top":
      return o(n4, 0, n2);
    case "bottom":
      return o(n4, 0, -n2);
    default:
      return r2(n4, l);
  }
}

export {
  a,
  e,
  r5 as r,
  n3 as n,
  i,
  s2 as s,
  l3 as l,
  m,
  u
};
//# sourceMappingURL=chunk-KGQOTLJQ.js.map
