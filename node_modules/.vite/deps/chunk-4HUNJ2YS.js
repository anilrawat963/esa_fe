import {
  m
} from "./chunk-C6XCOYU5.js";
import {
  u
} from "./chunk-CCQFL76O.js";
import {
  N
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/widgets/Legend/support/colorRampUtils.js
var r = new u([64, 64, 64]);
function n(l, e) {
  const r2 = [], n2 = l.length - 1;
  return 5 === l.length ? r2.push(0, 2, 4) : r2.push(0, n2), l.map((l2, t2) => r2.includes(t2) ? m(l2, t2, n2, e) : null);
}
async function t(l, o, r2) {
  let t2 = false, u3 = [], s2 = [];
  if (l.stops) {
    const e = l.stops;
    u3 = e.map((l2) => l2.value), t2 = e.some((l2) => !!l2.label), t2 && (s2 = e.map((l2) => l2.label));
  }
  const i2 = u3[0], c2 = u3[u3.length - 1];
  if (null == i2 && null == c2) return null;
  const p = t2 ? null : n(u3, r2);
  return (await Promise.all(u3.map(async (e, r3) => {
    const n2 = "opacity" === l.type ? await a(e, l, o) : (await import("./visualVariableUtils-EKNNTOCH.js")).getColor(l, e), u4 = t2 ? s2[r3] : p?.[r3] ?? "";
    return null == n2 ? null : { value: e, color: n2, label: u4 };
  }))).filter(N).reverse();
}
async function a(e, o, n2) {
  const t2 = new u(n2 ?? r), a2 = (await import("./visualVariableUtils-EKNNTOCH.js")).getOpacity(o, e);
  return null != a2 && (t2.a = a2), t2;
}
function u2(l) {
  let e = false, o = [], r2 = [];
  o = l.map((l2) => l2.value), e = l.some((l2) => !!l2.label), e && (r2 = l.map((l2) => l2.label ?? ""));
  const t2 = o[0], a2 = o[o.length - 1];
  if (null == t2 && null == a2) return null;
  const u3 = e ? null : n(o);
  return o.map((o2, n2) => ({ value: o2, color: s(o2, l), label: e ? r2[n2] : u3?.[n2] ?? "" })).reverse();
}
function s(e, o) {
  const { startIndex: r2, endIndex: n2, weight: t2 } = i(e, o);
  if (r2 === n2) return o[r2].color;
  const a2 = u.blendColors(o[r2].color, o[n2].color, t2);
  return new u(a2);
}
function i(l, e) {
  let o = 0, r2 = e.length - 1;
  return e.some((e2, n2) => l < e2.value ? (r2 = n2, true) : (o = n2, false)), { startIndex: o, endIndex: r2, weight: (l - e[o].value) / (e[r2].value - e[o].value) };
}
function c(e, o) {
  let r2 = [];
  if (e && "multipart" === e.type) e.colorRamps.reverse().forEach((n2, t2) => {
    0 === t2 ? r2.push({ value: o.max, color: new u(n2.toColor), label: "high" }) : r2.push({ value: null, color: new u(n2.toColor), label: "" }), t2 === e.colorRamps.length - 1 ? r2.push({ value: o.min, color: new u(n2.fromColor), label: "low" }) : r2.push({ value: null, color: new u(n2.fromColor), label: "" });
  });
  else {
    let n2, t2;
    e && "algorithmic" === e.type ? (n2 = e.fromColor, t2 = e.toColor) : (n2 = [0, 0, 0, 1], t2 = [255, 255, 255, 1]), r2 = [{ value: o.max, color: new u(t2), label: "high" }, { value: o.min, color: new u(n2), label: "low" }];
  }
  return r2;
}

export {
  t,
  u2 as u,
  s,
  c
};
//# sourceMappingURL=chunk-4HUNJ2YS.js.map
