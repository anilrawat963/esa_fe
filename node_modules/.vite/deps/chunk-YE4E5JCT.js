import {
  o,
  t
} from "./chunk-SXZO7ULH.js";

// node_modules/@arcgis/core/symbols/cim/utils.js
function r(e) {
  return "function" == typeof e;
}
function n(e, t2, n2, o3) {
  return r(e) ? e(t2, n2, o3) : e;
}
function o2(e) {
  return [e.r, e.g, e.b, e.a];
}
var l = " /-,\n";
function i(e) {
  let t2 = e.length;
  for (; t2--; ) if (!l.includes(e.charAt(t2))) return false;
  return true;
}
function a(e, t2) {
  const r2 = [];
  let n2 = 0, o3 = -1;
  do {
    if (o3 = e.indexOf("[", n2), o3 >= n2) {
      if (o3 > n2) {
        const t3 = e.slice(n2, o3);
        r2.push([t3, null, i(t3)]);
      }
      if (n2 = o3 + 1, o3 = e.indexOf("]", n2), o3 >= n2) {
        if (o3 > n2) {
          const l2 = t2[e.slice(n2, o3)];
          l2 && r2.push([null, l2, false]);
        }
        n2 = o3 + 1;
      }
    }
  } while (-1 !== o3);
  if (n2 < e.length) {
    const t3 = e.slice(n2);
    r2.push([t3, null, i(t3)]);
  }
  return r2;
}
function s(e, t2, r2) {
  let n2 = "", o3 = null;
  for (const l2 of t2) {
    const [t3, r3, i2] = l2;
    if (null != t3 && "" !== t3) i2 ? o3 = t3 : (null != o3 && (n2 += o3, o3 = null), n2 += t3);
    else {
      const t4 = e.readAttribute(r3);
      null != t4 && "" !== t4 && (null !== o3 && (n2 += o3, o3 = null), n2 += t4);
    }
  }
  return u(n2, r2);
}
function c(e, t2, r2, n2) {
  let o3 = "", l2 = null;
  for (const i2 of t2) {
    const [t3, n3, a2] = i2;
    if (null != t3 && "" !== t3) a2 ? l2 = t3 : (null != l2 && (o3 += l2, l2 = null), o3 += t3);
    else {
      let t4 = n3;
      null != r2 && (t4 = W(n3, r2));
      const i3 = e.attributes[t4];
      null != i3 && "" !== i3 && (null != l2 && (o3 += l2, l2 = null), o3 += i3);
    }
  }
  return u(o3, n2);
}
function u(e, t2) {
  switch ("string" != typeof e && (e = String(e)), t2) {
    case "LowerCase":
      return e.toLowerCase();
    case "Allcaps":
      return e.toUpperCase();
    default:
      return e;
  }
}
function f(e, t2, r2, n2, o3, l2, i2 = true) {
  const a2 = t2 / o3, s2 = r2 / l2, c2 = Math.ceil(a2 / 2), u2 = Math.ceil(s2 / 2);
  for (let f2 = 0; f2 < l2; f2++) for (let r3 = 0; r3 < o3; r3++) {
    const M2 = 4 * (r3 + (i2 ? l2 - f2 - 1 : f2) * o3);
    let y2 = 0, m2 = 0, C2 = 0, p2 = 0, h2 = 0, I2 = 0, b2 = 0;
    const d2 = (f2 + 0.5) * s2;
    for (let n3 = Math.floor(f2 * s2); n3 < (f2 + 1) * s2; n3++) {
      const o4 = Math.abs(d2 - (n3 + 0.5)) / u2, l3 = (r3 + 0.5) * a2, i3 = o4 * o4;
      for (let s3 = Math.floor(r3 * a2); s3 < (r3 + 1) * a2; s3++) {
        let r4 = Math.abs(l3 - (s3 + 0.5)) / c2;
        const o5 = Math.sqrt(i3 + r4 * r4);
        o5 >= -1 && o5 <= 1 && (y2 = 2 * o5 * o5 * o5 - 3 * o5 * o5 + 1, y2 > 0 && (r4 = 4 * (s3 + n3 * t2), b2 += y2 * e[r4 + 3], C2 += y2, e[r4 + 3] < 255 && (y2 = y2 * e[r4 + 3] / 250), p2 += y2 * e[r4], h2 += y2 * e[r4 + 1], I2 += y2 * e[r4 + 2], m2 += y2));
      }
    }
    n2[M2] = p2 / m2, n2[M2 + 1] = h2 / m2, n2[M2 + 2] = I2 / m2, n2[M2 + 3] = b2 / C2;
  }
}
function M(e) {
  return e ? [e[0], e[1], e[2], e[3] / 255] : [0, 0, 0, 0];
}
function y(e) {
  return e.data?.symbol ?? null;
}
function m(e) {
  return "CIMVectorMarker" === e.type || "CIMPictureMarker" === e.type || "CIMBarChartMarker" === e.type || "CIMCharacterMarker" === e.type || "CIMPieChartMarker" === e.type || "CIMStackedBarChartMarker" === e.type;
}
function C(e) {
  return "CIMGradientStroke" === e.type || "CIMPictureStroke" === e.type || "CIMSolidStroke" === e.type;
}
function p(e) {
  return null != e && ("CIMGradientFill" === e.type || "CIMHatchFill" === e.type || "CIMPictureFill" === e.type || "CIMSolidFill" === e.type || "CIMWaterFill" === e.type);
}
function h(e) {
  return null != e && ("CIMMarkerPlacementAlongLineRandomSize" === e.type || "CIMMarkerPlacementAlongLineSameSize" === e.type || "CIMMarkerPlacementAlongLineVariableSize" === e.type || "CIMMarkerPlacementAtExtremities" === e.type || "CIMMarkerPlacementAtMeasuredUnits" === e.type || "CIMMarkerPlacementAtRatioPositions" === e.type || "CIMMarkerPlacementOnLine" === e.type || "CIMMarkerPlacementOnVertices" === e.type);
}
var I = (e, t2 = 0) => null == e || isNaN(e) ? t2 : e;
var b = (e, t2) => null != e ? e : t2;
var d = (e, t2) => e ?? t2;
var k = (e) => e.tintColor ? M(e.tintColor) : [255, 255, 255, 1];
var S = class {
  constructor(e) {
    this._import = e;
  }
  getImportPromise() {
    return null == this._promise && (this._promise = this._import().then((e) => this.module = e)), this._promise;
  }
};
function P(e) {
  return new S(e);
}
function g(e) {
  if (!e) return "normal";
  switch (e.toLowerCase()) {
    case "italic":
      return "italic";
    case "oblique":
      return "oblique";
    default:
      return "normal";
  }
}
function w(e) {
  if (!e) return "normal";
  switch (e.toLowerCase()) {
    case "bold":
      return "bold";
    case "bolder":
      return "bolder";
    case "lighter":
      return "lighter";
    default:
      return "normal";
  }
}
function L(e) {
  let t2 = "normal", r2 = "normal";
  if (e) {
    const n2 = e.toLowerCase();
    n2.includes("italic") ? t2 = "italic" : n2.includes("oblique") && (t2 = "oblique"), n2.includes("bold") ? r2 = "bold" : n2.includes("light") && (r2 = "lighter");
  }
  return { style: t2, weight: r2 };
}
function A(e) {
  return e.underline ? "underline" : e.strikethrough ? "line-through" : "none";
}
function T(e) {
  if (!e) return null;
  switch (e.type) {
    case "CIMPolygonSymbol":
      if (e.symbolLayers) for (const t2 of e.symbolLayers) {
        const e2 = T(t2);
        if (null != e2) return e2;
      }
      break;
    case "CIMTextSymbol":
      return T(e.symbol);
    case "CIMSolidFill":
      return e.color;
  }
  return null;
}
function N(e) {
  if (e) switch (e.type) {
    case "CIMPolygonSymbol":
    case "CIMLineSymbol": {
      const t2 = e.symbolLayers;
      if (t2) for (const e2 of t2) {
        const t3 = N(e2);
        if (null != t3) return t3;
      }
      break;
    }
    case "CIMTextSymbol":
      return N(e.symbol);
    case "CIMSolidStroke":
      return e.color;
  }
}
function x(e) {
  for (const t2 of e) if (t2.enable) switch (t2.type) {
    case "CIMSolidStroke":
    case "CIMGradientStroke":
    case "CIMPictureStroke":
      return true;
  }
  return false;
}
function v(e) {
  if (e) switch (e.type) {
    case "CIMPolygonSymbol":
    case "CIMLineSymbol":
      if (e.symbolLayers) for (const t2 of e.symbolLayers) {
        const e2 = v(t2);
        if (void 0 !== e2) return e2;
      }
      break;
    case "CIMTextSymbol":
      return v(e.symbol);
    case "CIMSolidStroke":
    case "CIMGradientStroke":
    case "CIMPictureStroke":
      return e.width;
  }
}
function F(e) {
  switch (e) {
    case "Left":
    default:
      return "left";
    case "Right":
      return "right";
    case "Center":
    case "Justify":
      return "center";
  }
}
function V(e) {
  switch (e) {
    case "Top":
    default:
      return "top";
    case "Center":
      return "middle";
    case "Baseline":
      return "baseline";
    case "Bottom":
      return "bottom";
  }
}
function z(e) {
  return (e ? Object.keys(e) : []).map((t2) => ({ name: t2, alias: t2, type: "string" == typeof e[t2] ? "esriFieldTypeString" : "esriFieldTypeDouble" }));
}
var G = (e) => e.includes("data:image/svg+xml");
function O(e) {
  if (!e) return null;
  switch (e.type) {
    case "CIMPointSymbol":
    case "CIMTextSymbol":
      return "esriGeometryPoint";
    case "CIMLineSymbol":
      return "esriGeometryPolyline";
    case "CIMPolygonSymbol":
      return "esriGeometryPolygon";
    default:
      return null;
  }
}
function D(e) {
  return e ? e.charAt(0).toLowerCase() + e.slice(1) : e;
}
function q(e, t2, r2, n2, o3, l2, i2 = true) {
  const { infos: a2 } = l2;
  let s2 = 1, c2 = 0, u2 = 0, f2 = 0, M2 = 1;
  for (const { absoluteAnchorPoint: C2, offsetX: p2, offsetY: h2, rotation: I2, size: b2, frameHeight: d2, rotateClockWise: k2, scaleSymbolsProportionally: S2 } of a2) {
    M2 = C2 ? 1 : s2;
    u2 = J(p2, h2, c2, M2, u2), f2 = $(p2, h2, c2, M2, f2), d2 && (S2 || i2) && (s2 *= b2 / d2), c2 = K(I2, k2, c2);
  }
  const y2 = J(n2, o3, c2, M2, u2), m2 = $(n2, o3, c2, M2, f2);
  return { size: e * s2, rotation: K(t2, r2, c2), offsetX: y2, offsetY: m2 };
}
function E(e) {
  if (null == e) return false;
  if (Array.isArray(e)) return e.every((e2) => E(e2));
  switch (typeof e) {
    case "string":
      return !!e;
    case "number":
      return !isNaN(e);
  }
}
function R(r2, n2) {
  if ("color" === n2 || "outlinecolor" === n2 || "backgroundcolor" === n2 || "borderlinecolor" === n2 || "tintcolor" === n2) return [...t[n2]];
  const o3 = o[r2];
  if (!o3) throw new Error(`InternalError: default value for type ${r2}.`);
  return o3[n2];
}
function _(e) {
  return e.split(" ").map((e2) => Number(e2));
}
function j(e) {
  return "string" == typeof e ? _(e) : e;
}
function B(e) {
  return e?.dashTemplate && (e.dashTemplate = j(e.dashTemplate)), e;
}
function H(e) {
  if (null == e) return "Normal";
  switch (e.type) {
    case "CIMTextSymbol":
      return e.textCase ?? "Normal";
    case "CIMPointSymbol":
    case "CIMLineSymbol":
    case "CIMPolygonSymbol":
      {
        const t2 = e.symbolLayers;
        if (!t2) return "Normal";
        for (const e2 of t2) if ("CIMVectorMarker" === e2.type) return H(e2);
      }
      break;
    case "CIMVectorMarker": {
      const t2 = e.markerGraphics;
      if (!t2) return "Normal";
      for (const e2 of t2) if (e2.symbol) return H(e2.symbol);
    }
  }
  return "Normal";
}
function U(t2) {
  if (t2) switch (t2.type) {
    case "CIMTextSymbol":
      return t2.height;
    case "CIMPointSymbol": {
      let r2 = 0;
      if (t2.symbolLayers) {
        for (const n2 of t2.symbolLayers) if (n2) switch (n2.type) {
          case "CIMCharacterMarker":
          case "CIMPictureMarker":
          case "CIMVectorMarker":
          case "CIMObjectMarker3D":
          case "CIMglTFMarker3D": {
            const t3 = n2.size ?? o.CIMVectorMarker.size;
            t3 > r2 && (r2 = t3);
            break;
          }
        }
      }
      return r2;
    }
    case "CIMLineSymbol":
    case "CIMPolygonSymbol": {
      let r2 = 0;
      if (t2.symbolLayers) {
        for (const n2 of t2.symbolLayers) if (n2) switch (n2.type) {
          case "CIMSolidStroke":
          case "CIMPictureStroke":
          case "CIMGradientStroke": {
            const e = n2.width;
            null != e && e > r2 && (r2 = e);
            break;
          }
          case "CIMCharacterMarker":
          case "CIMPictureMarker":
          case "CIMVectorMarker":
          case "CIMObjectMarker3D":
          case "CIMglTFMarker3D":
            if (n2.markerPlacement && h(n2.markerPlacement)) {
              const t3 = n2.size ?? o.CIMVectorMarker.size;
              t3 > r2 && (r2 = t3);
            }
            break;
          case "CIMPictureFill": {
            const e = n2.height;
            null != e && e > r2 && (r2 = e);
          }
        }
      }
      return r2;
    }
  }
}
function W(e, t2) {
  if (null !== t2) {
    const r2 = t2.get(e);
    return r2 ? r2.name : e;
  }
  return e;
}
function X(e) {
  return e.map((e2) => ({ ...e2, propertyName: D(e2.propertyName) }));
}
function Y(e) {
  const t2 = {};
  for (const r2 in e) {
    const n2 = e[r2];
    t2[D(r2)] = n2;
  }
  return t2;
}
function $(e, t2, r2, n2, o3) {
  const l2 = r2 * Math.PI / 180;
  if (l2) {
    const r3 = Math.cos(l2);
    return (Math.sin(l2) * e + r3 * t2) * n2 + o3;
  }
  return t2 * n2 + o3;
}
function J(e, t2, r2, n2, o3) {
  const l2 = r2 * Math.PI / 180;
  if (l2) {
    return (Math.cos(l2) * e - Math.sin(l2) * t2) * n2 + o3;
  }
  return e * n2 + o3;
}
function K(e, t2, r2) {
  return t2 ? r2 - e : r2 + e;
}
function Q(e, t2, r2) {
  const n2 = "Color" === r2 || "TintColor" === r2 || "ToColor" === r2, o3 = "Rotation" === r2 || "Angle" === r2 || "ToRotation" === r2;
  let l2 = t2[D(r2)];
  if (null != l2 && (n2 ? l2 = [l2[0] / 255, l2[1] / 255, l2[2] / 255, l2[3] / 255] : o3 && (l2 *= Math.PI / 180)), null == l2 && (l2 = R(t2.type, r2.toLowerCase()), null != l2 && (n2 ? l2 = [l2[0] / 255, l2[1] / 255, l2[2] / 255, l2[3]] : o3 && (l2 *= Math.PI / 180))), null != t2.primitiveName) {
    const i2 = e[t2.primitiveName];
    if (null != i2) {
      const e2 = i2[r2];
      null == e2 || ("string" == typeof e2 || "number" == typeof e2 || Array.isArray(e2) ? (l2 = e2, null != l2 && (n2 ? l2 = [l2[0] / 255, l2[1] / 255, l2[2] / 255, l2[3] / 255] : o3 && (l2 *= Math.PI / 180))) : (l2 = { valueExpressionInfo: e2, defaultValue: l2 }, null != l2 && (n2 ? l2 = { type: "Process", op: "ArcadeColor", value: l2 } : o3 && (l2 = { type: "Process", op: "Divide", left: l2, right: 180 / Math.PI }))));
    }
  }
  if (null == l2) throw new Error(`Failed to derive a value or an expression for "${r2}".`);
  return l2;
}
function Z(e, t2, r2) {
  if (null != t2[D(r2)]) return true;
  if (null != t2.primitiveName) {
    const n2 = e[t2.primitiveName];
    if (null != n2) {
      if (null != n2[r2]) return true;
    }
  }
  return false;
}
function ee(e, t2) {
  return Math.max(Math.min((e ?? t2) / 100, 1), 0);
}

export {
  n,
  o2 as o,
  a,
  s,
  c,
  f,
  M,
  y,
  m,
  C,
  p,
  h,
  I,
  b,
  d,
  k,
  P,
  g,
  w,
  L,
  A,
  T,
  N,
  x,
  v,
  F,
  V,
  z,
  G,
  O,
  D,
  q,
  E,
  R,
  j,
  B,
  H,
  U,
  X,
  Y,
  Q,
  Z,
  ee
};
//# sourceMappingURL=chunk-YE4E5JCT.js.map
