import {
  c as c2,
  e as e2,
  i as i3,
  j as j2,
  n as n6,
  p as p6
} from "./chunk-LR3ANSSR.js";
import {
  p as p7
} from "./chunk-XYIGNG2Z.js";
import {
  r as r5
} from "./chunk-IFKJBQCK.js";
import {
  b2 as b
} from "./chunk-CZOYDK6P.js";
import {
  j
} from "./chunk-6TCXGIIN.js";
import {
  l as l3
} from "./chunk-NP2TBOXH.js";
import "./chunk-4V63WUXV.js";
import "./chunk-H34D76ZQ.js";
import {
  o as o5
} from "./chunk-CKE7BUXC.js";
import "./chunk-Q7VRQYAO.js";
import {
  p as p4
} from "./chunk-WCWUUHUV.js";
import {
  n as n5,
  r as r4
} from "./chunk-WDTGOP77.js";
import "./chunk-VYMBX5H5.js";
import "./chunk-6QHY54HZ.js";
import "./chunk-DFK6QMLO.js";
import {
  t
} from "./chunk-OJBEN6CV.js";
import {
  p as p3
} from "./chunk-PEL3D3ZN.js";
import "./chunk-Q5KWD3VQ.js";
import "./chunk-BUQC3CLV.js";
import {
  t as t2
} from "./chunk-W5S3VUFT.js";
import "./chunk-7YH7T6CS.js";
import "./chunk-3T4IXPP4.js";
import "./chunk-XTZAIV4X.js";
import "./chunk-63LDVRFI.js";
import "./chunk-MC6NAKKX.js";
import "./chunk-TF6255HN.js";
import "./chunk-GD4FJL3C.js";
import "./chunk-C5OQVQZF.js";
import {
  p as p5
} from "./chunk-JRCD3NNE.js";
import "./chunk-CNYNCKEV.js";
import "./chunk-XL5QPCXN.js";
import {
  N,
  W,
  X
} from "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-W75DBJD7.js";
import {
  n as n2
} from "./chunk-QF7FRVN6.js";
import {
  b as b2
} from "./chunk-P6IKJIMO.js";
import "./chunk-MHV23XAQ.js";
import "./chunk-V2X4OKYI.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import {
  n
} from "./chunk-MA3QDRC3.js";
import "./chunk-W6J7XCPU.js";
import {
  o
} from "./chunk-ONXWBTTM.js";
import {
  f as f2
} from "./chunk-T7F6Q6JJ.js";
import {
  O
} from "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-7P2ANHQ3.js";
import {
  p as p2,
  u
} from "./chunk-XCKT47LJ.js";
import "./chunk-3FUHCAX3.js";
import {
  P as P2
} from "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import {
  s as s4
} from "./chunk-LTPHDYPK.js";
import {
  e,
  n as n4
} from "./chunk-3OVERDFX.js";
import {
  o as o3
} from "./chunk-FPMLKIDB.js";
import {
  I,
  _ as _3,
  o as o4
} from "./chunk-AZXJIEZ6.js";
import {
  u as u2
} from "./chunk-Q75WYS7K.js";
import {
  x2 as x,
  z
} from "./chunk-H74Q4SYB.js";
import {
  l as l2
} from "./chunk-2OFHDVO5.js";
import {
  l
} from "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import {
  m as m3
} from "./chunk-5UPBUJPC.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import {
  i as i2
} from "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import {
  M,
  c,
  r as r3
} from "./chunk-SMWUT52Z.js";
import {
  _ as _2
} from "./chunk-AXZMNHTN.js";
import {
  f
} from "./chunk-5T3MJDSR.js";
import {
  T
} from "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import {
  H,
  H2,
  P,
  V,
  Y,
  Z,
  _,
  m as m2,
  p,
  tt,
  ut,
  v
} from "./chunk-V2H77UEV.js";
import {
  s as s3
} from "./chunk-WRA2WBYC.js";
import {
  o as o2
} from "./chunk-XWE6BM2U.js";
import {
  r as r2
} from "./chunk-SOIZOFSB.js";
import {
  a as a2,
  n as n3
} from "./chunk-XXLHAM2M.js";
import {
  m,
  r3 as r
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import {
  L,
  s as s2
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/layers/support/GeoreferenceBase.js
var c3 = class extends f2 {
  projectOrWarn(e3, r6) {
    if (null == e3) return e3;
    const { geometry: t3, pending: c4 } = X(e3, r6);
    return c4 ? null : c4 || t3 ? t3 : (i.getLogger(this).warn("geometry could not be projected to the spatial reference", { georeference: this, geometry: e3, sourceSpatialReference: e3.spatialReference, targetSpatialReference: r6 }), null);
  }
};
c3 = __decorate([a("esri.layers.support.GeoreferenceBase")], c3);

// node_modules/@arcgis/core/layers/support/ControlPointsGeoreference.js
var C = e();
var N2 = n5();
var q = class extends n3 {
};
__decorate([m({ type: Number, json: { write: { isRequired: true } } })], q.prototype, "x", void 0), __decorate([m({ type: Number, json: { write: { isRequired: true } } })], q.prototype, "y", void 0), q = __decorate([a("esri.layers.support.ControlPointsGeoreference.ControlPointJSONType")], q);
var T2 = class extends a2(c3) {
  constructor(t3) {
    super(t3), this.controlPoints = null, this.height = 0, this.type = "control-points", this.width = 0;
  }
  readControlPoints(t3, o6) {
    const e3 = f.fromJSON(o6.spatialReference), r6 = n4(...o6.coefficients, 1);
    return t3.map((t4) => (o4(N2, t4.x, t4.y), j2(N2, N2, r6), { sourcePoint: t4, mapPoint: new _2({ x: N2[0], y: N2[1], spatialReference: e3 }) }));
  }
  writeControlPoints(t3, e3, r6, i4) {
    if (null == this.transform) {
      const t4 = new s("web-document-write:invalid-georeference", "Invalid 'controlPoints', 'width', 'height' configuration. Make sure the parent media element is loaded i.e. the ImageElement or VideoElement set as 'MediaLayer.source'.", { layer: i4?.layer, georeference: this });
      return void (i4?.messages ? i4.messages.push(t4) : i.getLogger(this).error(t4.name, t4.message));
    }
    null != t3 && O2(t3[0]) && (e3.controlPoints = t3.map((t4) => {
      const o6 = t4.sourcePoint;
      return { x: o6.x, y: o6.y };
    }), e3.spatialReference = t3[0].mapPoint.spatialReference.toJSON(), e3.coefficients = this.transform.slice(0, 8));
  }
  get coords() {
    if (null == this.controlPoints) return null;
    const t3 = this._updateTransform(C);
    if (null == t3 || !O2(this.controlPoints[0])) return null;
    const o6 = this.controlPoints[0].mapPoint.spatialReference;
    return K(t3, this.width, this.height, o6);
  }
  set coords(t3) {
    if (null == this.controlPoints || !O2(this.controlPoints[0])) return;
    const o6 = this.controlPoints[0].mapPoint.spatialReference;
    if (null == (t3 = this.projectOrWarn(t3, o6))) return;
    const { width: e3, height: r6 } = this, { rings: [[n7, s5, c4, a3]] } = t3, p9 = new p7({ sourcePoint: i2(0, r6), mapPoint: new _2({ x: n7[0], y: n7[1], spatialReference: o6 }) }), u7 = new p7({ sourcePoint: i2(0, 0), mapPoint: new _2({ x: s5[0], y: s5[1], spatialReference: o6 }) }), m4 = new p7({ sourcePoint: i2(e3, 0), mapPoint: new _2({ x: c4[0], y: c4[1], spatialReference: o6 }) }), f3 = new p7({ sourcePoint: i2(e3, r6), mapPoint: new _2({ x: a3[0], y: a3[1], spatialReference: o6 }) });
    O2(p9) && O2(u7) && O2(m4) && O2(f3) && (B(C, p9, u7, m4, f3), this.controlPoints = this.controlPoints.map(({ sourcePoint: t4 }) => (o4(N2, t4.x, t4.y), j2(N2, N2, C), { sourcePoint: t4, mapPoint: new _2({ x: N2[0], y: N2[1], spatialReference: o6 }) })));
  }
  get inverseTransform() {
    return null == this.transform ? null : s4(e(), this.transform);
  }
  get transform() {
    return this._updateTransform();
  }
  toMap(t3) {
    if (null == t3 || null == this.transform || null == this.controlPoints || !O2(this.controlPoints[0])) return null;
    o4(N2, t3.x, t3.y);
    const o6 = this.controlPoints[0].mapPoint.spatialReference;
    return j2(N2, N2, this.transform), new _2({ x: N2[0], y: N2[1], spatialReference: o6 });
  }
  toSource(t3) {
    if (null == t3 || null == this.inverseTransform || null == this.controlPoints || !O2(this.controlPoints[0])) return null;
    const o6 = this.controlPoints[0].mapPoint.spatialReference;
    return t3 = t3.normalize(), null == (t3 = X(t3, o6).geometry) ? null : (o4(N2, t3.x, t3.y), j2(N2, N2, this.inverseTransform), i2(N2[0], N2[1]));
  }
  toSourceNormalized(t3) {
    const o6 = this.toSource(t3);
    return null != o6 && (o6.x /= this.width, o6.y /= this.height), o6;
  }
  _updateTransform(t3) {
    const { controlPoints: o6, width: e3, height: r6 } = this;
    if (!(null != o6 && e3 > 0 && r6 > 0)) return null;
    const [n7, i4, s5, l4] = o6;
    if (!O2(n7)) return null;
    const c4 = n7.mapPoint.spatialReference, a3 = this._projectControlPoint(i4, c4), p9 = this._projectControlPoint(s5, c4), u7 = this._projectControlPoint(l4, c4);
    if (!a3.valid || !p9.valid || !u7.valid) return null;
    if (!O2(a3.controlPoint)) return null;
    null == t3 && (t3 = e());
    let m4 = null;
    return m4 = O2(p9.controlPoint) && O2(u7.controlPoint) ? B(t3, n7, a3.controlPoint, p9.controlPoint, u7.controlPoint) : O2(p9.controlPoint) ? k(t3, n7, a3.controlPoint, p9.controlPoint) : V2(t3, n7, a3.controlPoint), m4.every((t4) => 0 === t4) ? null : m4;
  }
  _projectControlPoint(t3, o6) {
    if (!O2(t3)) return { valid: true, controlPoint: t3 };
    const { sourcePoint: e3, mapPoint: r6 } = t3, { geometry: i4, pending: s5 } = X(r6, o6);
    return s5 ? { valid: false, controlPoint: null } : s5 || i4 ? { valid: true, controlPoint: new p7({ sourcePoint: e3, mapPoint: i4 }) } : (i.getLogger(this).warn("map point could not be projected to the spatial reference", { georeference: this, controlPoint: t3, sourceSpatialReference: r6.spatialReference, targetSpatialReference: o6 }), { valid: false, controlPoint: null });
  }
};
function O2(t3) {
  return null != t3?.sourcePoint && null != t3.mapPoint;
}
__decorate([m({ type: [p7], json: { write: { allowNull: false, isRequired: true, target: { controlPoints: { type: [q], isRequired: true }, coefficients: { type: [Number], isRequired: true }, spatialReference: { type: f, isRequired: true } } } } })], T2.prototype, "controlPoints", void 0), __decorate([o2("controlPoints")], T2.prototype, "readControlPoints", null), __decorate([r2("controlPoints")], T2.prototype, "writeControlPoints", null), __decorate([m({ clonable: false })], T2.prototype, "coords", null), __decorate([m({ type: Number, nonNullable: true, json: { write: { isRequired: true } } })], T2.prototype, "height", void 0), __decorate([m({ readOnly: true })], T2.prototype, "inverseTransform", null), __decorate([m({ readOnly: true })], T2.prototype, "transform", null), __decorate([m({ type: Number, nonNullable: true, json: { write: { isRequired: true } } })], T2.prototype, "width", void 0), T2 = __decorate([a("esri.layers.support.ControlPointsGeoreference")], T2);
var _4 = n5();
var M2 = n5();
var I2 = n5();
var L2 = n5();
var G = n5();
var J = n5();
var E = n5();
var U = n5();
var z2 = Math.PI / 2;
function A(t3, o6, e3) {
  o4(t3, e3.sourcePoint.x, e3.sourcePoint.y), o4(o6, e3.mapPoint.x, e3.mapPoint.y);
}
function V2(t3, o6, e3) {
  return A(_4, G, o6), A(M2, J, e3), I(I2, M2, _4, z2), I(L2, _4, M2, z2), I(E, J, G, -z2), I(U, G, J, -z2), H3(t3, _4, M2, I2, L2, G, J, E, U);
}
function k(t3, o6, e3, r6) {
  return A(_4, G, o6), A(M2, J, e3), A(I2, E, r6), _3(L2, _4, M2, 0.5), I(L2, I2, L2, Math.PI), _3(U, G, J, 0.5), I(U, E, U, Math.PI), H3(t3, _4, M2, I2, L2, G, J, E, U);
}
function B(t3, o6, e3, r6, n7) {
  return A(_4, G, o6), A(M2, J, e3), A(I2, E, r6), A(L2, U, n7), H3(t3, _4, M2, I2, L2, G, J, E, U);
}
var W2 = new Array(8).fill(0);
var D = new Array(8).fill(0);
function F(t3, o6, e3, r6, n7) {
  return t3[0] = o6[0], t3[1] = o6[1], t3[2] = e3[0], t3[3] = e3[1], t3[4] = r6[0], t3[5] = r6[1], t3[6] = n7[0], t3[7] = n7[1], t3;
}
function H3(t3, o6, e3, r6, n7, i4, l4, c4, a3) {
  return p6(t3, F(W2, o6, e3, r6, n7), F(D, i4, l4, c4, a3));
}
function K(t3, o6, e3, r6) {
  const n7 = r4(0, e3), s5 = r4(0, 0), l4 = r4(o6, 0), c4 = r4(o6, e3);
  return j2(n7, n7, t3), j2(s5, s5, t3), j2(l4, l4, t3), j2(c4, c4, t3), new P2({ rings: [[n7, s5, l4, c4, n7]], spatialReference: r6 });
}

// node_modules/@arcgis/core/layers/support/CornersGeoreference.js
var u3 = n5();
var y = class extends c3 {
  constructor(t3) {
    super(t3), this.bottomLeft = null, this.bottomRight = null, this.topLeft = null, this.topRight = null, this.type = "corners";
  }
  get coords() {
    let { topLeft: t3, topRight: o6, bottomLeft: e3, bottomRight: r6 } = this;
    if (null == t3 || null == o6 || null == e3 || null == r6) return null;
    const s5 = t3.spatialReference;
    return o6 = this.projectOrWarn(o6, s5), e3 = this.projectOrWarn(e3, s5), r6 = this.projectOrWarn(r6, s5), null == o6 || null == e3 || null == r6 ? null : new P2({ rings: [[[e3.x, e3.y], [t3.x, t3.y], [o6.x, o6.y], [r6.x, r6.y], [e3.x, e3.y]]], spatialReference: s5 });
  }
  set coords(t3) {
    const { topLeft: o6 } = this;
    if (null == o6) return;
    const e3 = o6.spatialReference;
    if (null == (t3 = this.projectOrWarn(t3, e3))) return;
    const { rings: [[r6, s5, i4, l4]] } = t3;
    this.bottomLeft = new _2({ x: r6[0], y: r6[1], spatialReference: e3 }), this.topLeft = new _2({ x: s5[0], y: s5[1], spatialReference: e3 }), this.topRight = new _2({ x: i4[0], y: i4[1], spatialReference: e3 }), this.bottomRight = new _2({ x: l4[0], y: l4[1], spatialReference: e3 });
  }
  toSourceNormalized(t3) {
    const { topLeft: s5, topRight: i4, bottomRight: p9, bottomLeft: c4 } = this;
    if (null == t3 || null == s5 || null == i4 || null == p9 || null == c4) return null;
    const m4 = s5.spatialReference;
    t3 = t3.normalize();
    const f3 = X(t3, m4).geometry;
    if (null == f3) return null;
    o4(u3, f3.x, f3.y);
    const y2 = p6(e(), [s5.x, s5.y, c4.x, c4.y, i4.x, i4.y, p9.x, p9.y], [0, 0, 0, 1, 1, 0, 1, 1]);
    return j2(u3, u3, y2), i2(u3[0], u3[1]);
  }
};
__decorate([m({ clonable: false })], y.prototype, "coords", null), __decorate([m({ type: _2 })], y.prototype, "bottomLeft", void 0), __decorate([m({ type: _2 })], y.prototype, "bottomRight", void 0), __decorate([m({ type: _2 })], y.prototype, "topLeft", void 0), __decorate([m({ type: _2 })], y.prototype, "topRight", void 0), y = __decorate([a("esri.layers.support.CornersGeoreference")], y);
var h = y;

// node_modules/@arcgis/core/layers/support/ExtentAndRotationGeoreference.js
var p8 = class extends c3 {
  constructor(t3) {
    super(t3), this.extent = null, this.rotation = 0, this.type = "extent-and-rotation";
  }
  get coords() {
    if (null == this.extent) return null;
    const { xmin: t3, ymin: e3, xmax: r6, ymax: o6, spatialReference: n7 } = this.extent;
    let s5;
    if (this.rotation) {
      const { x: n8, y: i4 } = this.extent.center, a3 = x2(n8, i4, this.rotation);
      s5 = [a3(t3, e3), a3(t3, o6), a3(r6, o6), a3(r6, e3)], s5.push(s5[0]);
    } else s5 = [[t3, e3], [t3, o6], [r6, o6], [r6, e3], [t3, e3]];
    return new P2({ rings: [s5], spatialReference: n7 });
  }
  set coords(t3) {
    if (null == t3 || null == this.extent) return;
    const r6 = this.extent.spatialReference;
    if (t3 = this.projectOrWarn(t3, r6), null == t3?.extent) return;
    const { rings: [[o6, n7, s5]], extent: { center: { x: i4, y: c4 } } } = t3, l4 = M(Math.PI / 2 - Math.atan2(n7[1] - o6[1], n7[0] - o6[0])), m4 = x2(i4, c4, -l4), [p9, u7] = m4(o6[0], o6[1]), [f3, y2] = m4(s5[0], s5[1]);
    this.extent = new z({ xmin: p9, ymin: u7, xmax: f3, ymax: y2, spatialReference: r6 }), this.rotation = l4;
  }
  toSourceNormalized(t3) {
    const { extent: e3, rotation: n7 } = this;
    if (null == t3 || null == e3) return null;
    const { xmin: s5, ymin: i4, xmax: a3, ymax: c4, center: m4, spatialReference: p9 } = e3;
    t3 = t3.normalize();
    const u7 = X(t3, p9).geometry;
    if (null == u7) return null;
    let f3 = u7.x, y2 = u7.y;
    return n7 && ([f3, y2] = x2(m4.x, m4.y, -n7)(f3, y2)), i2(c(f3, s5, a3, 0, 1), c(y2, c4, i4, 0, 1));
  }
};
function x2(t3, e3, r6) {
  const o6 = u2(r6), n7 = Math.cos(o6), s5 = Math.sin(o6);
  return (r7, o7) => [n7 * (r7 - t3) + s5 * (o7 - e3) + t3, n7 * (o7 - e3) - s5 * (r7 - t3) + e3];
}
__decorate([m({ clonable: false })], p8.prototype, "coords", null), __decorate([m({ type: z })], p8.prototype, "extent", void 0), __decorate([m({ type: Number })], p8.prototype, "rotation", void 0), p8 = __decorate([a("esri.layers.support.ExtentAndRotationGeoreference")], p8);
var u4 = p8;

// node_modules/@arcgis/core/layers/support/mediaUtils.js
function u5(e3) {
  return "media" === e3?.type;
}
function w(e3, t3) {
  const o6 = r(t3);
  return u5(e3) && !!e3.portalItem && null != o6 && o6 > 3;
}
function P3(n7, t3, r6) {
  if (!n7 || "control-points" === n7.type) return n7;
  const { coords: a3 } = n7;
  if (5 !== a3?.rings[0]?.length) return null;
  const [c4, p9, l4, y2] = a3.rings[0], { spatialReference: m4 } = a3;
  return new T2({ controlPoints: [new p7({ mapPoint: new _2({ x: c4[0], y: c4[1], spatialReference: m4 }), sourcePoint: i2(0, r6) }), new p7({ mapPoint: new _2({ x: p9[0], y: p9[1], spatialReference: m4 }), sourcePoint: i2(0, 0) }), new p7({ mapPoint: new _2({ x: l4[0], y: l4[1], spatialReference: m4 }), sourcePoint: i2(t3, 0) }), new p7({ mapPoint: new _2({ x: y2[0], y: y2[1], spatialReference: m4 }), sourcePoint: i2(t3, r6) })], width: t3, height: r6 });
}
function d(e3, n7, t3) {
  return { enabled: !w(t3?.layer, t3?.origin), ignoreOrigin: true };
}
var x3 = { json: { name: "url", type: String, write: { overridePolicy: d } } };
var g = { readOnly: true, json: { read: false, write: { target: "mediaType", overridePolicy: d } } };
var h2 = { types: { key: "type", base: c3, typeMap: { "control-points": T2, corners: h, "extent-and-rotation": u4 } }, json: { types: { key: "type", base: c3, typeMap: { "control-points": T2 } }, write: { overridePolicy: () => ({ enabled: true, ignoreOrigin: true }) } } };

// node_modules/@arcgis/core/layers/support/MediaElementBase.js
var u6 = class extends o(l3(u)) {
  constructor(e3) {
    super(e3), this.georeference = null, this.opacity = 1;
  }
  readGeoreference(e3) {
    return T2.fromJSON(e3);
  }
  writeGeoreference(e3, o6, t3, n7) {
    const i4 = n7?.resources?.pendingOperations, c4 = () => {
      const i5 = P3(this.georeference, this.contentWidth, this.contentHeight);
      if (i5) {
        if ("control-points" !== e3.type && i.getLogger(this).warn(`only georeference of type 'control-points' may be persisted. The georeference of type '${e3.type}' has been automatically converted.`), 4 !== i5.controlPoints?.length && n7?.messages) return void n7.messages.push(new s("property:unsupported", "only 'control-points' georeference with 4 control points may be persisted."));
        o6[t3] = i5.write({}, n7);
      }
    };
    if ("control-points" !== e3.type && !this.loaded && i4) return o6[t3] = {}, void i4.push(this.load().then(c4));
    c4();
  }
  get contentWidth() {
    return 0;
  }
  get contentHeight() {
    return 0;
  }
  toSource(e3) {
    const { georeference: r6, contentWidth: o6, contentHeight: t3 } = this;
    if (null == e3 || null == r6 || 0 === o6 || 0 === t3) return null;
    const s5 = r6.toSourceNormalized(e3);
    return null == s5 ? null : (s5.x *= o6, s5.y *= t3, s5);
  }
};
__decorate([m(h2)], u6.prototype, "georeference", void 0), __decorate([o2("georeference")], u6.prototype, "readGeoreference", null), __decorate([r2("georeference")], u6.prototype, "writeGeoreference", null), __decorate([m({ json: { read: false, write: false } })], u6.prototype, "opacity", void 0), u6 = __decorate([a("esri.layers.support.MediaElementBase")], u6);

// node_modules/@arcgis/core/layers/support/ImageElement.js
var w2;
var _a;
var E2 = (_a = class extends u6 {
  constructor(t3) {
    super(t3), this.animationOptions = null, this.content = null, this.image = null, this.type = "image", this[w2] = true, this.image = null;
  }
  load() {
    const t3 = this.image;
    if ("string" == typeof t3) {
      const e3 = p4(t3).then((t4) => {
        this._set("content", t4);
      });
      this.addResolvingPromise(e3);
    } else if (t3 instanceof HTMLImageElement) {
      const e3 = t3.decode().then(() => {
        this._set("content", t3);
      });
      this.addResolvingPromise(e3);
    } else t3 ? this._set("content", t3) : this.addResolvingPromise(Promise.reject(new s("image-element:invalid-image-type", "Invalid image type", { image: t3 })));
    return Promise.resolve(this);
  }
  get contentWidth() {
    return null == this.content ? 0 : this.content instanceof HTMLImageElement ? this.content.naturalWidth : this.content.width;
  }
  get contentHeight() {
    return null == this.content ? 0 : this.content instanceof HTMLImageElement ? this.content.naturalHeight : this.content.height;
  }
  readImage(t3, e3, r6) {
    return p(e3.url, r6);
  }
  writeImage(t3, e3, r6, o6) {
    if (null == t3) return;
    const n7 = o6?.portalItem, s5 = o6?.resources;
    if (!n7 || !s5) return void ("string" == typeof t3 && (e3[r6] = m2(t3, o6)));
    const a3 = U2(t3) ? t3 : null;
    if (a3) {
      if (null == v(a3)) return void (e3[r6] = a3);
      const t4 = m2(a3, { ...o6, verifyItemRelativeUrls: o6?.verifyItemRelativeUrls ? { writtenUrls: o6.verifyItemRelativeUrls.writtenUrls, rootPath: void 0 } : void 0 }, 1);
      if (n7 && t4 && !Y(t4)) return s5.toKeep.push({ resource: n7.resourceFromPath(t4), compress: false }), void (e3[r6] = t4);
    }
    e3[r6] = "<pending>", s5.pendingOperations.push(H4(t3).then((t4) => {
      const o7 = P4(t4, n7);
      e3[r6] = o7.itemRelativeUrl, s5.toAdd.push({ resource: o7, content: { type: "blob", blob: t4 }, compress: false, finish: (t5) => {
        this.image = t5.url;
      } });
    }));
  }
}, w2 = n6, _a);
function U2(t3) {
  return "string" == typeof t3 && !tt(t3) && !Z(t3);
}
async function H4(t3) {
  if ("string" == typeof t3) {
    if (tt(t3)) return ut(t3);
    return (await H2(t3, { responseType: "blob" })).data;
  }
  return new Promise((e3) => L3(t3).toBlob(e3));
}
function L3(t3) {
  if (t3 instanceof HTMLCanvasElement) return t3;
  const e3 = t3 instanceof HTMLImageElement ? t3.naturalWidth : t3.width, r6 = t3 instanceof HTMLImageElement ? t3.naturalHeight : t3.height, o6 = document.createElement("canvas"), i4 = o6.getContext("2d");
  return o6.width = e3, o6.height = r6, t3 instanceof HTMLImageElement ? i4.drawImage(t3, 0, 0, t3.width, t3.height) : t3 instanceof ImageData && i4.putImageData(t3, 0, 0), o6;
}
function P4(t3, e3) {
  const r6 = n2(), o6 = `${V("media", r6)}.${p5({ type: "blob", blob: t3 })}`;
  return e3.resourceFromPath(o6);
}
__decorate([m()], E2.prototype, "animationOptions", void 0), __decorate([m({ readOnly: true })], E2.prototype, "content", void 0), __decorate([m({ readOnly: true })], E2.prototype, "contentWidth", null), __decorate([m({ readOnly: true })], E2.prototype, "contentHeight", null), __decorate([m(x3)], E2.prototype, "image", void 0), __decorate([o2("image", ["url"])], E2.prototype, "readImage", null), __decorate([r2("image")], E2.prototype, "writeImage", null), __decorate([m(g)], E2.prototype, "type", void 0), E2 = __decorate([a("esri.layers.support.ImageElement")], E2);

// node_modules/@arcgis/core/layers/support/VideoElement.js
var b3;
var w3 = Symbol("canplay");
var _a2;
var V3 = (_a2 = class extends u6 {
  constructor(e3) {
    super(e3), this.autoplay = true, this.content = null, this.type = "video", this[b3] = true;
  }
  load() {
    const e3 = this.video;
    return "string" == typeof e3 ? this.addResolvingPromise(this._preProcessVideoUrl(e3).then(async (e4) => {
      const t3 = document.createElement("video");
      return t3.src = t.sanitizeUrl(_(e4)), t3.crossOrigin = "anonymous", t3.autoplay = this.autoplay, t3.muted = true, t3.loop = true, t3.playsInline = true, this._loadVideo(t3).then(() => {
        this._set("content", t3);
      });
    })) : e3 instanceof HTMLVideoElement ? this.addResolvingPromise(this._loadVideo(e3).then(() => {
      this._set("content", e3);
    })) : this.addResolvingPromise(Promise.reject(new s("video-element:invalid-video-type", "Invalid video type", { video: e3 }))), Promise.resolve(this);
  }
  get contentWidth() {
    return this.content?.videoWidth ?? 0;
  }
  get contentHeight() {
    return this.content?.videoHeight ?? 0;
  }
  get currentTime() {
    return this.content?.currentTime;
  }
  set currentTime(e3) {
    if (!this.content) return;
    const t3 = r3(e3, 0, this.content.duration);
    "fastSeek" in this.content ? this.content.fastSeek(t3) : this.content.currentTime = t3, this.content.play().then(() => {
      this.content?.pause();
    }).catch(() => {
    });
  }
  get duration() {
    return this.content?.duration;
  }
  set video(e3) {
    "not-loaded" === this.loadStatus ? this._set("video", e3) : i.getLogger(this).error("#video", "video cannot be changed after the element is loaded.");
  }
  writeVideo(e3, t3, r6, s5) {
    if (!e3) return void (s5?.messages && s5.messages.push(new s("video-element:unsupported-video", "video source is missing")));
    const i4 = _5(e3) ? e3 : null;
    if (!i4) return void (s5?.messages && s5.messages.push(new s("video-element:unsupported-video", "video source must be an absolute url")));
    !Y(i4) && s5?.blockedRelativeUrls && s5.blockedRelativeUrls.push(i4);
    const c4 = _(i4);
    !v(c4) ? t3[r6] = c4 : s5?.messages && s5.messages.push(new s("video-element:unsupported-video", "video source cannot be an item resource"));
  }
  async _preProcessVideoUrl(e3) {
    if (H(e3)) return P(e3);
    try {
      return await H2(e3, { method: "head" }), e3;
    } catch {
      try {
        return P(e3, true);
      } catch {
        return e3;
      }
    }
  }
  async _loadVideo(e3) {
    "anonymous" !== e3.crossOrigin && (e3.crossOrigin = "anonymous", Z(e3.src) || (e3.src = e3.src));
    try {
      await r5(e3, (e4) => this.addHandles(e4, w3)), this.autoplay && await e3.play().catch((e4) => {
        throw console.error(e4), e4;
      });
    } finally {
      this.removeHandles(w3);
    }
  }
}, b3 = e2, _a2);
function _5(e3) {
  return "string" == typeof e3 && !tt(e3) && !Z(e3);
}
__decorate([m()], V3.prototype, "autoplay", void 0), __decorate([m({ readOnly: true })], V3.prototype, "content", void 0), __decorate([m({ readOnly: true })], V3.prototype, "contentWidth", null), __decorate([m({ readOnly: true })], V3.prototype, "contentHeight", null), __decorate([m({ type: Number })], V3.prototype, "currentTime", null), __decorate([m({ type: Number })], V3.prototype, "duration", null), __decorate([m(x3)], V3.prototype, "video", null), __decorate([r2("video")], V3.prototype, "writeVideo", null), __decorate([m(g)], V3.prototype, "type", void 0), V3 = __decorate([a("esri.layers.support.VideoElement")], V3);

// node_modules/@arcgis/core/layers/support/LocalMediaElementSource.js
var w4 = { key: "type", defaultKeyValue: "image", base: u6, typeMap: { image: E2, video: V3 } };
var M3 = O.ofType(w4);
var I3 = class extends p2(m3(l)) {
  constructor(e3) {
    super(e3), this._index = new o5(), this._elementViewsMap = /* @__PURE__ */ new Map(), this._elementsIndexes = /* @__PURE__ */ new Map(), this._elementsChangedHandler = (e4) => {
      for (const s5 of e4.removed) {
        const e5 = this._elementViewsMap.get(s5);
        this._elementViewsMap.delete(s5), this._index.delete(e5), this.removeHandles(e5), e5.destroy(), this.notifyChange("fullExtent");
      }
      const { spatialReference: t3 } = this;
      for (const s5 of e4.added) {
        if (this._elementViewsMap.get(s5)) continue;
        const e5 = new i3({ spatialReference: t3, element: s5 });
        this._elementViewsMap.set(s5, e5);
        const r6 = l2(() => e5.coords, () => this._updateIndexForElement(e5, false));
        this._updateIndexForElement(e5, true), this.addHandles(r6, e5);
      }
      this._elementsIndexes.clear(), this.elements.forEach((e5, t4) => this._elementsIndexes.set(e5, t4)), this.emit("refresh");
    }, this.elements = new M3();
  }
  async load(e3) {
    if (s2(e3), !this.spatialReference) {
      const e4 = this.elements.find((e5) => null != e5.georeference?.coords);
      this._set("spatialReference", e4 ? e4.georeference.coords.spatialReference : f.WGS84);
    }
    return this._elementsChangedHandler({ added: this.elements.items, removed: [] }), this.addHandles(this.elements.on("change", this._elementsChangedHandler)), this;
  }
  destroy() {
    this._index.clear(), this._elementViewsMap.clear(), this._elementsIndexes.clear();
  }
  set elements(e3) {
    this._set("elements", n(e3, this._get("elements"), M3));
  }
  get fullExtent() {
    if ("not-loaded" === this.loadStatus) return null;
    const e3 = this._index.fullBounds;
    return null == e3 ? null : new z({ xmin: e3[0], ymin: e3[1], xmax: e3[2], ymax: e3[3], spatialReference: this.spatialReference });
  }
  set spatialReference(e3) {
    "not-loaded" === this.loadStatus ? this._set("spatialReference", e3) : i.getLogger(this).error("#spatialReference", "spatialReference cannot be changed after the source is loaded.");
  }
  async queryElements(e3, t3) {
    await this.load(), await N(e3.spatialReference, this.spatialReference, null, t3);
    const s5 = T(e3.spatialReference, this.spatialReference) ? e3 : W(e3, this.spatialReference);
    if (!s5) return [];
    const r6 = s5.normalize(), o6 = [];
    for (const n7 of r6) this._index.forEachInBounds(o3(n7), ({ normalizedCoords: e4, element: t4 }) => {
      null != e4 && x(n7, e4) && o6.push(t4);
    });
    return o6.sort((e4, t4) => this._elementsIndexes.get(e4) - this._elementsIndexes.get(t4)), o6;
  }
  hasElement(e3) {
    return this.elements.includes(e3);
  }
  _updateIndexForElement(e3, t3) {
    const s5 = e3.normalizedBounds, r6 = this._index.has(e3), o6 = null != s5;
    this._index.delete(e3), o6 && this._index.set(e3, s5), this.notifyChange("fullExtent"), t3 || (r6 !== o6 ? this.emit("refresh") : this.emit("change", { element: e3.element }));
  }
};
__decorate([m()], I3.prototype, "elements", null), __decorate([m({ readOnly: true })], I3.prototype, "fullExtent", null), __decorate([m()], I3.prototype, "spatialReference", null), I3 = __decorate([a("esri.layers.support.LocalMediaElementSource")], I3);

// node_modules/@arcgis/core/layers/MediaLayer.js
var L4 = class extends p3(t2(b(j(l3(b2))))) {
  constructor(e3) {
    super(e3), this.effectiveSource = null, this.georeference = null, this.copyright = null, this.operationalLayerType = "MediaLayer", this.spatialReference = null, this.type = "media", this._debouncedSaveOperations = L(async (e4, r6, o6) => {
      const { save: t3, saveAs: s5 } = await import("./mediaLayerUtils-MLI5UR2Z.js");
      switch (e4) {
        case 0:
          return t3(this, r6);
        case 1:
          return s5(this, o6, r6);
      }
    }), this.source = new I3();
  }
  load(e3) {
    return this.addResolvingPromise(this._doLoad(e3)), Promise.resolve(this);
  }
  async _doLoad(e3) {
    await this.loadFromPortal({ supportedTypes: ["Media Layer"] }, e3);
    let t3 = this.source;
    if (!t3) throw new s("media-layer:source-missing", "Set 'MediaLayer.source' before loading the layer.");
    const s5 = this._getSourceOverride(t3, this.georeference);
    s5 && (this.setAtOrigin("source", s5, "web-map"), this.setAtOrigin("source", s5, "web-scene"), t3 = s5);
    const i4 = c2(t3) ? new I3({ elements: new O([t3]) }) : t3;
    this._set("effectiveSource", i4), this.spatialReference && (i4.spatialReference = this.spatialReference), await i4.load(e3), this.spatialReference = i4.spatialReference;
  }
  destroy() {
    this.effectiveSource?.destroy(), this.effectiveSource !== this.source && this.source?.destroy();
  }
  readGeoreference(e3, r6) {
    return e3 && "itemId" in r6 && r6.itemId ? e3 : void 0;
  }
  get fullExtent() {
    return this.loaded ? this.effectiveSource.fullExtent : null;
  }
  get loaded() {
    return super.loaded;
  }
  get source() {
    return this._get("source");
  }
  set source(e3) {
    "loaded" !== this.loadStatus && "failed" !== this.loadStatus ? this._set("source", e3) : i.getLogger(this).error("#source", "source cannot be changed after the layer is loaded.");
  }
  castSource(e3) {
    return e3 ? Array.isArray(e3) ? new I3({ elements: new O(e3) }) : e3 instanceof O ? new I3({ elements: e3 }) : e3 : null;
  }
  readSource(e3, r6, o6) {
    if ("itemId" in r6 && r6.itemId) return;
    const t3 = this._createSource(r6);
    return t3?.read(r6, o6), t3;
  }
  writeSource(e3, r6, t3, s5) {
    if (e3 && e3 instanceof I3) {
      const r7 = e3.elements.length;
      if (1 !== r7) return void (s5?.messages && s5.messages.push(new s("media-layer:unsupported-source", `local media element source can only be persisted if it contains exactly one ImageElement, but it has ${r7}.`)));
      e3 = e3.elements.at(0);
    }
    c2(e3) ? e3.write(r6, s5) : s5?.messages && (e3 ? s5.messages.push(new s("media-layer:unsupported-source", "only media elements of type 'ImageElement' or 'VideoElement' can be persisted")) : s5.messages.push(new s("media-layer:unsupported-source", "the media layer is missing a source")));
  }
  async save(e3) {
    return this._debouncedSaveOperations(0, e3);
  }
  async saveAs(e3, r6) {
    return this._debouncedSaveOperations(1, r6, e3);
  }
  _createSource(e3) {
    if ("mediaType" in e3) switch (e3.mediaType) {
      case "image":
        return new E2();
      case "video":
        return new V3();
    }
    return null;
  }
  _getSourceOverride(e3, r6) {
    if (c2(e3) && 3 === this.originIdOf("source") && r6 && (5 === this.originIdOf("georeference") || 4 === this.originIdOf("georeference"))) {
      const o6 = e3.toJSON(), t3 = this._createSource(o6);
      return t3.read({ ...o6 }, { origin: "portal-item" }), t3.read({ georeference: r6 }, { origin: "web-map" }), t3.read({ georeference: r6 }, { origin: "web-scene" }), t3;
    }
    return null;
  }
};
__decorate([m({ readOnly: true })], L4.prototype, "effectiveSource", void 0), __decorate([m({ readOnly: true, json: { read: false, write: false, origins: { "web-document": { read: true } } } })], L4.prototype, "georeference", void 0), __decorate([o2("web-document", "georeference")], L4.prototype, "readGeoreference", null), __decorate([m({ type: String })], L4.prototype, "copyright", void 0), __decorate([m({ readOnly: true })], L4.prototype, "fullExtent", null), __decorate([m({ type: ["MediaLayer"] })], L4.prototype, "operationalLayerType", void 0), __decorate([m({ type: ["show", "hide"] })], L4.prototype, "listMode", void 0), __decorate([m({ nonNullable: true, json: { write: { enabled: true, allowNull: false, target: { url: { type: String }, mediaType: { type: ["image", "video"] }, georeference: { type: T2 } }, overridePolicy(e3, r6, o6) {
  return { enabled: true, allowNull: false, ignoreOrigin: w(this, o6?.origin) && c2(e3) && !!e3.georeference && e3.originIdOf("georeference") > 3 };
} } } })], L4.prototype, "source", null), __decorate([s3("source")], L4.prototype, "castSource", null), __decorate([o2("source", ["url"])], L4.prototype, "readSource", null), __decorate([r2("source")], L4.prototype, "writeSource", null), __decorate([m()], L4.prototype, "spatialReference", void 0), __decorate([m({ readOnly: true })], L4.prototype, "type", void 0), L4 = __decorate([a("esri.layers.MediaLayer")], L4);
var O3 = L4;
export {
  O3 as default
};
//# sourceMappingURL=MediaLayer-6RQ3MKFF.js.map
