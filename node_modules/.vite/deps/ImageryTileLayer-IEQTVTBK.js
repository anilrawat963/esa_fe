import {
  X,
  X2,
  e as e2,
  i as i6,
  m as m5,
  n as n3,
  o as o4,
  t as t4,
  u as u4
} from "./chunk-GWWDVBTJ.js";
import "./chunk-ECIORIM4.js";
import {
  c as c4,
  f as f4,
  o as o3
} from "./chunk-6INX4FGX.js";
import {
  N as N3,
  i2 as i5
} from "./chunk-ETHRUKGL.js";
import {
  C as C2,
  p as p3
} from "./chunk-BTNEC6LS.js";
import "./chunk-BTFBYI67.js";
import "./chunk-D3G5WIRR.js";
import "./chunk-Q3JOE7TC.js";
import {
  r as r3,
  t as t3
} from "./chunk-BJUALH6B.js";
import {
  j as j4
} from "./chunk-PGB6KL3Q.js";
import {
  i as i3
} from "./chunk-4274EV24.js";
import {
  $,
  b,
  c as c2,
  d as d2,
  i as i4,
  o as o2,
  p as p2,
  v as v4
} from "./chunk-EQUB4K44.js";
import {
  $ as $2,
  R,
  j as j3
} from "./chunk-GD72EK2J.js";
import {
  n as n2,
  u as u3
} from "./chunk-JBBUE342.js";
import {
  T,
  w
} from "./chunk-NEYJ2XGC.js";
import "./chunk-L2YWECQ7.js";
import "./chunk-5RPEIJ7N.js";
import {
  C,
  G,
  H,
  L as L2,
  N as N2,
  Y,
  e,
  k as k2,
  k2 as k3,
  l as l6,
  m as m4,
  r,
  r2,
  t as t2,
  v,
  v2 as v3,
  y
} from "./chunk-TNGDEFWZ.js";
import {
  E,
  W,
  v as v2
} from "./chunk-NQDCX3PB.js";
import "./chunk-QW7RJMQR.js";
import {
  c2 as c,
  i as i2
} from "./chunk-CJAJ4FML.js";
import {
  l as l4
} from "./chunk-CJZPTLIZ.js";
import {
  l as l5
} from "./chunk-JSH3APTG.js";
import "./chunk-WQT2KLDB.js";
import {
  d
} from "./chunk-UVDECGZC.js";
import {
  o,
  s as s3
} from "./chunk-VKFTCFFM.js";
import {
  s as s4
} from "./chunk-ZETARPSI.js";
import {
  f as f3
} from "./chunk-TCDV4P3G.js";
import {
  b2,
  d as d3,
  s as s5
} from "./chunk-CZOYDK6P.js";
import "./chunk-TMUM75KQ.js";
import "./chunk-RXH2WNPA.js";
import "./chunk-TWU3GKHX.js";
import "./chunk-BGIBV6LL.js";
import "./chunk-UQXJMFRI.js";
import "./chunk-DY7N5RAZ.js";
import {
  j as j2
} from "./chunk-6TCXGIIN.js";
import {
  l as l2
} from "./chunk-NP2TBOXH.js";
import "./chunk-FHCV4NTV.js";
import {
  g
} from "./chunk-HCTBVF3W.js";
import "./chunk-XTEXJOLG.js";
import "./chunk-YE4E5JCT.js";
import "./chunk-SXZO7ULH.js";
import "./chunk-H34D76ZQ.js";
import "./chunk-QTRET3PG.js";
import "./chunk-FMOL5XMB.js";
import "./chunk-VNSHGTPN.js";
import "./chunk-OEBAFVQK.js";
import "./chunk-EK7HOTRR.js";
import "./chunk-IXFJYDA2.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import "./chunk-233ALXRM.js";
import "./chunk-IRBX64M6.js";
import "./chunk-EKZRA6TO.js";
import "./chunk-M5SP6ZBM.js";
import "./chunk-SJ2OBYX2.js";
import "./chunk-ZCI5A4FF.js";
import "./chunk-2D47RURG.js";
import {
  z as z2
} from "./chunk-YP3WVJP3.js";
import "./chunk-M24KZOVI.js";
import "./chunk-6VL5D5UP.js";
import "./chunk-6QHY54HZ.js";
import "./chunk-GXJJY3ND.js";
import "./chunk-5ONGWFJ3.js";
import "./chunk-PLNHHGHL.js";
import "./chunk-4WTOIJXV.js";
import "./chunk-BBYMM7CM.js";
import "./chunk-EM7Y2JZC.js";
import {
  m as m3
} from "./chunk-QZQPB5XR.js";
import "./chunk-AQFRVV3U.js";
import {
  p
} from "./chunk-PEL3D3ZN.js";
import "./chunk-Q5KWD3VQ.js";
import "./chunk-BUQC3CLV.js";
import {
  t
} from "./chunk-W5S3VUFT.js";
import "./chunk-7YH7T6CS.js";
import {
  c as c3
} from "./chunk-3T4IXPP4.js";
import "./chunk-XTZAIV4X.js";
import "./chunk-63LDVRFI.js";
import "./chunk-C3FRY5U4.js";
import {
  q
} from "./chunk-JNJX34GB.js";
import "./chunk-3STJRSDT.js";
import "./chunk-67Q6KVC6.js";
import "./chunk-23NJHA5Q.js";
import "./chunk-4LA6K4VI.js";
import "./chunk-KEZCWFAR.js";
import "./chunk-JZUJ34RR.js";
import "./chunk-PMGS7UDU.js";
import "./chunk-3GHCGAH2.js";
import "./chunk-HWUOAPTX.js";
import "./chunk-QHCKOBU7.js";
import "./chunk-K2OZ6WVC.js";
import "./chunk-MC6NAKKX.js";
import "./chunk-TF6255HN.js";
import "./chunk-GD4FJL3C.js";
import "./chunk-C5OQVQZF.js";
import "./chunk-F7DKSAOI.js";
import "./chunk-4SOQWNPG.js";
import "./chunk-LTULADK2.js";
import "./chunk-35ST7YRB.js";
import "./chunk-EDA5QFHZ.js";
import "./chunk-CNYNCKEV.js";
import "./chunk-XL5QPCXN.js";
import "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-W75DBJD7.js";
import "./chunk-6KDQMJAI.js";
import "./chunk-UDHS2MGH.js";
import "./chunk-ENINOZUZ.js";
import {
  b as b3
} from "./chunk-P6IKJIMO.js";
import "./chunk-MHV23XAQ.js";
import "./chunk-V2X4OKYI.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import "./chunk-MA3QDRC3.js";
import "./chunk-W6J7XCPU.js";
import "./chunk-ONXWBTTM.js";
import {
  l as l3
} from "./chunk-T7F6Q6JJ.js";
import "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-7P2ANHQ3.js";
import "./chunk-XCKT47LJ.js";
import "./chunk-3FUHCAX3.js";
import "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import {
  z
} from "./chunk-H74Q4SYB.js";
import {
  l
} from "./chunk-2OFHDVO5.js";
import "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-5UPBUJPC.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import {
  s as s2
} from "./chunk-YY5PITIH.js";
import {
  u as u2
} from "./chunk-CCQFL76O.js";
import "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import "./chunk-7H3U4IJR.js";
import "./chunk-SMWUT52Z.js";
import {
  _
} from "./chunk-AXZMNHTN.js";
import {
  f as f2
} from "./chunk-5T3MJDSR.js";
import {
  k
} from "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import {
  I
} from "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import {
  m as m2
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a,
  m
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import {
  L,
  f2 as f,
  j,
  n,
  u3 as u
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  N,
  has
} from "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/graphic/ImageryTileGraphicOrigin.js
var t5;
var s6 = class extends s3 {
  get [(t5 = i3, o)]() {
    return this.layer;
  }
  constructor(r6) {
    super(), this[t5] = true, this.type = "imagery-tile", this.layer = r6;
  }
  get id() {
    return this.layer.id;
  }
};

// node_modules/@arcgis/core/layers/support/rasterDatasets/covJSONParser.js
function i7(e3) {
  return ["x", "e", "east", "long", "longitude"].includes(e3.toLowerCase());
}
function r4(e3) {
  return ["y", "n", "west", "lat", "latitude"].includes(e3.toLowerCase());
}
function o5(e3) {
  const { axes: l7 } = e3.domain, s7 = Object.keys(l7), a2 = [], o6 = [];
  let u8 = -1, m9 = -1, c7 = [];
  for (let t7 = 0; t7 < s7.length; t7++) {
    const e4 = s7[t7];
    i7(e4) ? u8 = t7 : r4(e4) && (m9 = t7);
    const n5 = l7[e4], d8 = [];
    if ("values" in n5) {
      n5.values.forEach((e6) => d8.push("string" == typeof e6 ? new Date(e6).getTime() : e6));
      const e5 = d8[1] - d8[0];
      a2.push([d8[0] - 0.5 * e5, d8[d8.length - 1] + 0.5 * e5]), o6.push(e5);
    } else {
      const { start: e5, stop: t8, num: l8 } = n5, s8 = (t8 - e5) / (l8 - 1);
      a2.push([e5 - 0.5 * s8, t8 + 0.5 * s8]), o6.push(s8);
      for (let n6 = 0; n6 < l8; n6++) d8.push(e5 + s8 * n6);
    }
    c7.push({ name: e4, values: d8, extent: [d8[0], d8[d8.length - 1]] });
  }
  u8 > -1 && -1 === m9 ? m9 = 0 === u8 ? 1 : 0 : m9 > -1 && -1 === u8 ? u8 = 0 === m9 ? 1 : 0 : -1 === m9 && -1 === u8 && (u8 = 0, m9 = 1), c7 = c7.filter((e4, t7) => !(t7 === u8 || t7 === m9));
  const { referencing: d7 } = e3.domain, f7 = d7.find((e4) => e4.coordinates.includes(s7[u8])).system.id, p6 = f7?.slice(f7.lastIndexOf("/") + 1), h3 = null == p6 || "CRS84" === p6 ? 4326 : Number(p6), g4 = new f2({ wkid: h3 }), [b6, y3] = a2[u8], [x2, j5] = a2[m9], v7 = new z({ xmin: b6, xmax: y3, ymin: x2, ymax: j5, spatialReference: g4 });
  return { width: Math.round(v7.width / o6[u8]), height: Math.round(v7.height / o6[m9]), extent: v7, dimensions: c7 };
}
function u5(e3) {
  const t7 = s2();
  return t7 ? e3[t7] ?? Object.values(e3)[0] : Object.values(e3)[0];
}
function m6() {
  return Math.round(255 * Math.random());
}
function c5(t7) {
  const n5 = {}, { parameters: l7 } = t7;
  if (!l7) return n5;
  for (const [s7, a2] of Object.entries(l7)) {
    const { type: t8, description: l8, unit: i8, categoryEncoding: r6, observedProperty: o6 } = a2;
    if ("Parameter" === t8 && (n5[s7] = {}, l8 && (n5[s7].description = u5(l8)), i8 && (n5[s7].unit = i8.label ? u5(i8.label) : null, n5[s7].symbol = i8.symbol?.value), r6)) {
      const t9 = Object.entries(r6).map((e3, t10) => ({ OID: t10, Value: Number(e3[1]), ClassName: e3[0].slice(e3[0].lastIndexOf("/") + 1), Count: 1 }));
      let l9 = false;
      o6?.categories?.length && (o6.categories.forEach((n6) => {
        if (!n6.id) return;
        const s8 = n6.id.slice(n6.id.lastIndexOf("/") + 1), a4 = t9.find((e3) => e3.ClassName === s8);
        if (!a4) return;
        const i9 = n6.label ? u5(n6.label) : null;
        if (a4.Label = i9, n6.preferredColor) {
          const t10 = u2.fromHex(n6.preferredColor);
          t10 && (l9 = true, a4.Red = t10.r, a4.Green = t10.g, a4.Blue = t10.b);
        }
      }), l9 && t9.forEach((e3) => {
        null == e3.Red && (e3.Red = m6(), e3.Green = m6(), e3.Blue = m6());
      }));
      const a3 = { objectIdFieldName: "", fields: [{ name: "OID", type: "esriFieldTypeOID", alias: "OID", domain: null }, { name: "Value", type: "esriFieldTypeInteger", alias: "Value", domain: null }, { name: "Count", type: "esriFieldTypeDouble", alias: "Count", domain: null }, { name: "ClassName", type: "esriFieldTypeString", alias: "ClassName", domain: null, length: 50 }, { name: "Label", type: "esriFieldTypeString", alias: "Label", domain: null, length: 50 }], features: t9.map((e3) => ({ attributes: e3 })) };
      l9 && a3.fields.push({ name: "Red", type: "esriFieldTypeInteger", alias: "Red", domain: null }, { name: "Green", type: "esriFieldTypeInteger", alias: "Green", domain: null }, { name: "Blue", type: "esriFieldTypeInteger", alias: "Blue", domain: null }), n5[s7].attributeTable = a3;
    }
  }
  return n5;
}
function d4(e3) {
  let t7 = Number.MAX_VALUE, n5 = -Number.MAX_VALUE;
  for (let l7 = 0; l7 < e3.length; l7++) {
    const s7 = e3[l7];
    null != s7 && (s7 < t7 && (t7 = s7), s7 > n5 && (n5 = s7));
  }
  return i2(t7, n5);
}
function f5(e3, t7, n5) {
  const l7 = e3.map((e4, n6) => ({ name: e4, count: t7[n6] })).sort((e4, t8) => e4.name > t8.name ? -1 : 1), s7 = (a2 = 1, (e4) => a2 *= e4.count);
  var a2;
  const i8 = [...l7.slice(1), { name: "", count: 1 }].reverse().map(s7).reverse();
  let r6 = 0;
  for (let o6 = e3.length - 1; o6 >= 0; o6--) {
    r6 += i8[l7.findIndex(({ name: t8 }) => t8 === e3[o6])] * (n5 % t7[o6]), n5 = Math.floor(n5 / t7[o6]);
  }
  return r6;
}
function p4(e3) {
  const { width: t7, height: n5, extent: l7, dimensions: a2 } = o5(e3), { ranges: i8 } = e3, r6 = Object.keys(i8).sort((e4, t8) => e4 < t8 ? -1 : 1), u8 = [];
  for (let s7 = 0; s7 < r6.length; s7++) {
    const e4 = r6[s7];
    a2?.length && u8.push({ name: e4, dimensions: a2 });
  }
  const m9 = c5(e3);
  u8.forEach((e4) => m9[e4.name] && Object.assign(e4, m9[e4.name]));
  const p6 = u8.length ? { variables: u8 } : void 0, h3 = [];
  for (let o6 = 0; o6 < r6.length; o6++) {
    const e4 = r6[o6], { values: l8, dataType: u9, axisNames: m10, shape: c7 } = i8[e4], p7 = c7.length > 2 ? o6 * c7.slice(0, -2).reduce((e5, t8) => e5 * t8) : 0, g5 = m10.slice(0, -2), b6 = c7.slice(0, -2), y3 = "float" === u9 ? "f32" : d4(l8), x2 = t7 * n5, j5 = l8.length / x2;
    for (let i9 = 0; i9 < j5; i9++) {
      const e5 = c.createEmptyBand(y3, x2), r7 = new Uint8Array(x2).fill(255);
      let u10 = false;
      const m11 = i9 * x2;
      for (let t8 = 0; t8 < x2; t8++) {
        const n6 = l8[m11 + t8];
        null == n6 ? (r7[t8] = 0, u10 = true) : e5[t8] = n6;
      }
      if (0 === o6 || a2?.length) {
        const l9 = new c({ width: t7, height: n5, mask: u10 ? r7 : null, pixels: [e5], pixelType: y3 });
        if (l9.updateStatistics(), a2?.length) {
          h3[f5(g5, b6, i9) + p7] = l9;
        } else h3.push(l9);
      } else {
        const t8 = h3[i9];
        t8.pixels.push(e5), u10 ? t8.mask && (t8.mask = c.combineBandMasks([t8.mask, r7])) : t8.mask = u10 ? r7 : null;
      }
    }
  }
  const g4 = Object.values(m9).find((e4) => e4.attributeTable)?.attributeTable;
  return { extent: l7, pixelBlocks: h3, multidimensionalInfo: p6, attributeTable: g4, bandNames: p6 ? void 0 : r6 };
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/InMemoryRaster.js
var f6 = class extends X {
  constructor() {
    super(...arguments), this.datasetFormat = "MEMORY", this.source = null;
  }
  get url() {
    return "";
  }
  fetchRawTile(t7, e3, s7, i8 = {}) {
    if (!this._pixelBlockTiles) {
      const { rasterInfo: r7 } = this, [o6, a2] = r7.storageInfo.tileInfo.size, { sliceId: l7 } = i8, { pixelBlocks: n5 } = this.source, m9 = { pixelBlock: null == l7 ? n5[0] : n5[l7], useBilinear: "thematic" !== r7.dataType, tileSize: { width: o6, height: a2 }, level: t7, row: e3, col: s7 }, p6 = this.rasterJobHandler ? this.rasterJobHandler.clipTile(m9, i8) : E(m9);
      return Promise.resolve(p6);
    }
    const r6 = this._pixelBlockTiles.get(`${t7}/${e3}/${s7}`);
    return Promise.resolve(r6);
  }
  async _open(t7) {
    const e3 = this.source, { pixelBlocks: s7, attributeTable: i8, statistics: r6, histograms: l7, name: m9, nativeExtent: p6, transform: c7, colormap: u8 } = e3, h3 = s7[0], { width: d7, height: f7, pixelType: g4 } = h3, x2 = e3.extent ?? new z({ xmin: -0.5, ymin: 0.5, xmax: d7 - 0.5, ymax: f7 - 0.5, spatialReference: new f2({ wkid: 3857 }) }), y3 = e3.isPseudoSpatialReference ?? !e3.extent, b6 = { x: x2.width / d7, y: x2.height / f7 }, I4 = { ...e3.keyProperties };
    e3.dataType && (I4.DataType = e3.dataType), e3.bandInfos && (I4.BandProperties = e3.bandInfos.map((t8) => t8.toJSON())), i8 && (I4.DataType = "Thematic");
    const v7 = new m4({ width: d7, height: f7, pixelType: g4, extent: x2, nativeExtent: p6, attributeTable: i8, colormap: u8, transform: c7, pixelSize: b6, spatialReference: x2.spatialReference, bandCount: h3.pixels.length, keyProperties: I4, multidimensionalInfo: e3.multidimensionalInfo, statistics: r6, isPseudoSpatialReference: y3, histograms: l7 });
    this.ioConfig.skipMapInfo && this.updateImageSpaceRasterInfo(v7), this.createRemoteDatasetStorageInfo(v7, 512, 512), this._set("rasterInfo", v7), this.updateTileInfo(), v7.multidimensionalInfo ? await this._buildMDimStats(e3.pixelBlocks, v7.multidimensionalInfo) : await this._buildInMemoryRaster(h3, { width: 512, height: 512 }, t7), v7.multidimensionalInfo || (this.source = null), this.datasetName = m9;
  }
  async _buildInMemoryRaster(t7, i8, r6) {
    const { rasterInfo: o6 } = this, a2 = o6.storageInfo.maximumPyramidLevel ?? 0, l7 = "thematic" !== o6.dataType, n5 = this.rasterJobHandler ? this.rasterJobHandler.split({ pixelBlock: t7, tileSize: i8, maximumPyramidLevel: a2, useBilinear: l7 }, r6) : Promise.resolve(W(t7, i8, a2, l7)), m9 = null != o6.statistics, p6 = null != o6.histograms, c7 = this.ioConfig.skipStatistics || m9 ? Promise.resolve({ statistics: null, histograms: null }) : this.rasterJobHandler ? this.rasterJobHandler.estimateStatisticsHistograms({ pixelBlock: t7 }, r6) : Promise.resolve(y(t7)), d7 = await j([n5, c7]);
    if (!d7[0].value && d7[1].value) throw new s("inmemory-raster:open", "failed to build in memory raster");
    this._pixelBlockTiles = d7[0].value, m9 || (o6.statistics = d7[1].value?.statistics), p6 || (o6.histograms = d7[1].value?.histograms);
  }
  async _buildMDimStats(t7, e3, s7) {
    for (let i8 = 0; i8 < e3.variables.length; i8++) {
      const r6 = e3.variables[i8];
      if (r6.statistics) continue;
      const o6 = r6.dimensions.map((t8) => new p3({ variableName: r6.name, dimensionName: t8.name, values: [t8.values?.[0] ?? t8.extent?.[0]], isSlice: true })), a2 = C2(o6, e3), n5 = null == a2 ? null : t7[a2];
      if (null == n5) continue;
      const m9 = this.rasterJobHandler ? await this.rasterJobHandler.computeStatisticsHistograms({ pixelBlock: n5 }, s7) : k3(n5);
      r6.statistics = m9.statistics, r6.histograms || (r6.histograms = m9.histograms);
    }
  }
};
__decorate([m2({ type: String, json: { write: true } })], f6.prototype, "datasetFormat", void 0), __decorate([m2()], f6.prototype, "source", void 0), __decorate([m2()], f6.prototype, "url", null), f6 = __decorate([a("esri.layers.support.rasterDatasets.InMemoryRaster")], f6);
var g2 = f6;

// node_modules/@arcgis/core/layers/support/rasterDatasets/CovJSONRaster.js
var m7 = class extends X {
  constructor() {
    super(...arguments), this.datasetFormat = "CovJSON";
  }
  fetchRawTile(e3, t7, r6, s7 = {}) {
    return this._inMemoryRaster.fetchRawTile(e3, t7, r6, s7);
  }
  async _open(e3) {
    const { extent: t7, pixelBlocks: r6, multidimensionalInfo: s7, attributeTable: a2, bandNames: o6 } = await this._fetchData(e3), { statistics: i8, histograms: n5 } = k3(r6[0]), m9 = o6?.map((e4) => ({ BandName: e4 })), h3 = { DataType: a2 ? "Thematic" : s7 ? "Scientific" : "Generic", BandProperties: m9 }, d7 = new g2({ source: { extent: t7, pixelBlocks: r6, attributeTable: a2 ? g.fromJSON(a2) : null, multidimensionalInfo: s7, statistics: i8, histograms: n5, keyProperties: h3, isPseudoSpatialReference: false } });
    await d7.open(), this._inMemoryRaster = d7;
    const u8 = this.source ? "" : this.url.slice(this.url.lastIndexOf("/") + 1);
    this._set("datasetName", u8.slice(0, u8.indexOf("."))), this._set("rasterInfo", d7.rasterInfo);
  }
  async _fetchData(e3) {
    const r6 = this.source ?? (await this.request(this.url, { signal: e3?.signal })).data, s7 = "imagery-tile-layer:open-coverage-json";
    if ("coverage" !== r6.type?.toLowerCase() || "grid" !== r6.domain?.domainType?.toLowerCase()) throw new s(s7, "Only coverage with Grid domain type is supported");
    if (!r6.ranges) throw new s(s7, "Missing ranges in the grid coverage data");
    if (!r6.domain.referencing?.length) throw new s(s7, "Missing domain referencing in the grid coverage data");
    const a2 = Object.values(r6.ranges);
    for (let n5 = 0; n5 < a2.length; n5++) {
      const { axisNames: e4, shape: r7, type: c7, values: l7 } = a2[n5];
      if (!("ndarray" === c7.toLowerCase() && l7?.length && e4?.length && r7?.length)) throw new s(s7, "Only ranges with valid NdArray, axisNames, shape, and inline values are supported");
      if (!(i7(e4[e4.length - 1]) && r4(e4[e4.length - 2]))) throw new s(s7, "Only row-major ordered pixel values are supported. X axis must be the last axis.");
    }
    return p4(r6);
  }
};
__decorate([m2({ type: String, json: { write: true } })], m7.prototype, "datasetFormat", void 0), __decorate([m2({ constructOnly: true })], m7.prototype, "source", void 0), m7 = __decorate([a("esri.layers.support.rasterDatasets.CovJSONRaster")], m7);
var h = m7;

// node_modules/@arcgis/core/layers/support/rasterDatasets/pamParser.js
function u6(e3, t7) {
  if (!e3 || !t7) return null;
  const n5 = [];
  for (let r6 = 0; r6 < e3.length; r6++) n5.push(e3[r6]), n5.push(t7[r6]);
  return n5;
}
function c6(e3) {
  const t7 = e2(e3, "GeodataXform"), n5 = d5(o4(t7, "SpatialReference/WKID") || t4(t7, "SpatialReference/WKT"));
  if ("typens:PolynomialXform" !== t7.getAttribute("xsi:type")) return { spatialReference: n5, transform: null };
  const r6 = o4(t7, "PolynomialOrder") ?? 1, a2 = u4(t7, "CoeffX/Double"), c7 = u4(t7, "CoeffY/Double"), m9 = u4(t7, "InverseCoeffX/Double"), p6 = u4(t7, "InverseCoeffY/Double"), S4 = u6(a2, c7), C3 = u6(m9, p6);
  return { spatialReference: n5, transform: S4 && C3 && S4.length && C3.length ? new u3({ spatialReference: n5, polynomialOrder: r6, forwardCoefficients: S4, inverseCoefficients: C3 }) : null };
}
function m8(e3) {
  const t7 = o4(e3, "NoDataValue"), n5 = e2(e3, "Histograms/HistItem"), r6 = o4(n5, "HistMin"), o6 = o4(n5, "HistMax"), f7 = o4(n5, "BucketCount"), u8 = t4(n5, "HistCounts")?.split("|").map((e4) => Number(e4));
  let c7, m9, d7, p6;
  n3(e3, "Metadata/MDI").forEach((e4) => {
    const t8 = Number(e4.textContent ?? e4.nodeValue);
    switch (e4.getAttribute("key").toUpperCase()) {
      case "STATISTICS_MINIMUM":
        c7 = t8;
        break;
      case "STATISTICS_MAXIMUM":
        m9 = t8;
        break;
      case "STATISTICS_MEAN":
        d7 = t8;
        break;
      case "STATISTICS_STDDEV":
        p6 = t8;
    }
  });
  const S4 = o4(e3, "Metadata/SourceBandIndex");
  return { noDataValue: t7, histogram: u8?.length && null != r6 && null != o6 ? { min: r6, max: o6, size: f7 || u8.length, counts: u8 } : null, sourceBandIndex: S4, statistics: null != c7 && null != m9 ? { min: c7, max: m9, avg: d7, stddev: p6 } : null };
}
function d5(e3) {
  if (!e3) return null;
  let r6 = Number(e3);
  if (!isNaN(r6) && 0 !== r6) return new f2({ wkid: r6 });
  if (e3 = String(e3).trim(), k(e3)) return new f2({ wkt2: e3 });
  const s7 = e3.toUpperCase();
  if (s7.startsWith("COMPD_CS")) {
    if (!s7.includes("VERTCS") || !s7.includes("GEOGCS") && !s7.startsWith("PROJCS")) return null;
    const n5 = s7.indexOf("VERTCS"), a2 = s7.indexOf("PROJCS"), i8 = a2 > -1 ? a2 : s7.indexOf("GEOGCS");
    if (-1 === i8) return null;
    const l7 = e3.slice(i8, e3.lastIndexOf("]", n5) + 1).trim(), o6 = e3.slice(n5, e3.lastIndexOf("]")).trim();
    r6 = p5(l7);
    const f7 = new f2(r6 ? { wkid: r6 } : { wkt: l7 }), u8 = p5(o6);
    return u8 && (f7.vcsWkid = u8), f7;
  }
  return s7.startsWith("GEOGCS") || s7.startsWith("PROJCS") ? (r6 = p5(e3), new f2(0 !== r6 ? { wkid: r6 } : { wkt: e3 })) : null;
}
function p5(e3) {
  const t7 = e3.replaceAll("]", "[").replaceAll('"', "").split("[").map((e4) => e4.trim()).filter((e4) => "" !== e4), n5 = t7[t7.length - 1].split(","), r6 = n5[0]?.toLowerCase();
  if (("epsg" === r6 || "esri" === r6) && e3.endsWith('"]]')) {
    const e4 = Number(n5[1]);
    if (!isNaN(e4) && 0 !== e4) return e4;
  }
  return 0;
}
function S(t7) {
  if ("pamdataset" !== t7?.documentElement.tagName?.toLowerCase()) return {};
  const n5 = { spatialReference: null, transform: null, metadata: {}, rasterBands: [], statistics: null, histograms: null };
  t7.documentElement.childNodes.forEach((e3) => {
    if (1 === e3.nodeType) {
      if (i6(e3, "SRS")) {
        if (!n5.spatialReference) {
          const t8 = t4(e3);
          n5.spatialReference = d5(t8);
        }
      } else if (i6(e3, "Metadata")) if ("xml:ESRI" === e3.getAttribute("domain")) {
        const { spatialReference: t8, transform: r6 } = c6(e3);
        n5.transform = r6, n5.spatialReference || (n5.spatialReference = t8);
      } else {
        n3(e3, "MDI").forEach((e4) => n5.metadata[e4.getAttribute("key")] = t4(e4));
      }
      else if (i6(e3, "PAMRasterBand")) {
        const t8 = m8(e3);
        null != t8.sourceBandIndex && null == n5.rasterBands[t8.sourceBandIndex] ? n5.rasterBands[t8.sourceBandIndex] = t8 : n5.rasterBands.push(t8);
      }
    }
  });
  const i8 = n5.rasterBands;
  if (i8.length) {
    const t8 = !!i8[0].statistics;
    n5.statistics = t8 ? i8.map((e3) => e3.statistics).filter(N) : null;
    const r6 = !!i8[0].histogram;
    n5.histograms = r6 ? i8.map((e3) => e3.histogram).filter(N) : null;
  }
  return n5;
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/ImageAuxRaster.js
var h2 = class extends X {
  fetchRawTile(t7, s7, e3, r6 = {}) {
    return this._inMemoryRaster.fetchRawTile(t7, s7, e3, r6);
  }
  async _open(t7) {
    const s7 = await this._fetchData(t7);
    let { spatialReference: e3, statistics: r6, histograms: o6, transform: a2 } = await this._fetchAuxiliaryData(t7);
    const l7 = !e3;
    l7 && (e3 = new f2({ wkid: 3857 })), o6?.length && null == r6 && (r6 = v3(o6));
    const { width: p6, height: c7 } = s7;
    let u8 = new z({ xmin: -0.5, ymin: 0.5 - c7, xmax: p6 - 0.5, ymax: 0.5, spatialReference: e3 });
    const h3 = a2 ? a2.forwardTransform(u8) : u8;
    let d7 = true;
    if (a2) {
      const t8 = a2.forwardCoefficients;
      d7 = t8 && 0 === t8[1] && 0 === t8[2], d7 && (a2 = null, u8 = h3);
    }
    const w3 = new g2({ source: { extent: h3, nativeExtent: u8, transform: a2, pixelBlocks: [s7], statistics: r6, histograms: o6, keyProperties: { DateType: "Processed" }, isPseudoSpatialReference: l7 }, ioConfig: { sampling: "closest", skipStatistics: true } });
    this.ioConfig.skipMapInfo && (w3.ioConfig.skipMapInfo = true), await w3.open(), w3.source = null, this._set("rasterInfo", w3.rasterInfo), this._inMemoryRaster = w3;
  }
  async _fetchData(t7) {
    const { data: e3 } = await this.request(this.url, { responseType: "array-buffer", signal: t7?.signal }), r6 = L2(e3).toUpperCase();
    if ("JPG" !== r6 && "PNG" !== r6 && "GIF" !== r6 && "BMP" !== r6) throw new s("image-aux-raster:open", "the data is not a supported format");
    this._set("datasetFormat", r6);
    const o6 = r6.toLowerCase(), a2 = "gif" === o6 || "bmp" === o6 || !has("ios"), i8 = await this.decodePixelBlock(e3, { format: o6, useCanvas: a2, hasNoZlibMask: true });
    if (null == i8) throw new s("image-aux-raster:open", "the data cannot be decoded");
    return i8;
  }
  async _fetchAuxiliaryData(t7) {
    const s7 = t7?.signal, { skipExtensions: o6 = [], skipMapInfo: a2 } = this.ioConfig, i8 = a2 || o6.includes("aux.xml") ? null : this.request(this.url + ".aux.xml", { responseType: "xml", signal: s7 }), n5 = this.datasetFormat, l7 = "JPG" === n5 ? "jgw" : "PNG" === n5 ? "pgw" : "BMP" === n5 ? "bpw" : null, m9 = l7 && o6.includes(l7) ? null : this.request(this.url.slice(0, this.url.lastIndexOf(".")) + "." + l7, { responseType: "text", signal: s7 }), c7 = await j([i8, m9]);
    if (s7?.aborted) throw u();
    const f7 = S(c7[0].value?.data);
    if (!f7.transform) {
      const t8 = c7[1].value ? c7[1].value.data.split("\n").slice(0, 6).map((t9) => Number(t9)) : null;
      f7.transform = 6 === t8?.length ? new u3({ forwardCoefficients: [t8[4], t8[5], t8[0], -t8[1], t8[2], -t8[3]] }) : null;
    }
    return f7;
  }
};
__decorate([m2({ type: String, json: { write: true } })], h2.prototype, "datasetFormat", void 0), h2 = __decorate([a("esri.layers.support.rasterDatasets.ImageAuxRaster")], h2);
var d6 = h2;

// node_modules/@arcgis/core/layers/support/rasterDatasets/ImageServerRaster.js
var g3 = class extends X {
  constructor() {
    super(...arguments), this._levelOffset = 0, this._tilemapCache = null, this._slices = null, this.datasetFormat = "RasterTileServer", this.tileType = null;
  }
  async fetchRawTile(e3, t7, i8, s7 = {}) {
    const { storageInfo: r6, extent: a2 } = this.rasterInfo, { transposeInfo: l7 } = r6, n5 = null != l7 && !!s7.transposedVariableName;
    if (this._slices && !n5 && null == s7.sliceId) return null;
    const o6 = n5 ? 0 : r6.maximumPyramidLevel - e3 + this._levelOffset, c7 = `${this.url}/tile/${o6}/${t7}/${i8}`, m9 = this._slices ? n5 ? { variable: s7.transposedVariableName } : { sliceId: s7.sliceId || 0 } : null;
    let u8, h3;
    if (r6.isBsqTile) {
      const e4 = (s7.bandIds?.length ? s7.bandIds : [0, 1, 2]).map((e5) => this.request(c7, { query: { ...m9, bandId: e5 }, responseType: "array-buffer", signal: s7.signal })), t8 = await Promise.all(e4), i9 = t8.map((e5) => e5.data.byteLength).reduce((e5, t9) => e5 + t9), r7 = new Uint8Array(i9);
      h3 = [];
      let a3 = 0;
      for (const { data: s8 } of t8) h3.push(a3), r7.set(new Uint8Array(s8), a3), a3 += s8.byteLength;
      u8 = r7.buffer;
    } else {
      u8 = (await this.request(c7, { query: m9, responseType: "array-buffer", signal: s7.signal })).data;
    }
    if (!u8) return null;
    const f7 = n5 ? l7.tileSize : r6.tileInfo.size, d7 = await this.decodePixelBlock(u8, { width: f7[0], height: f7[1], planes: h3?.length, offsets: h3, pixelType: null, isPoint: "Elevation" === this.tileType, returnInterleaved: n5, noDataValue: this.rasterInfo.noDataValue });
    if (null == d7) return null;
    const y3 = r6.blockBoundary[e3];
    if ("jpg" !== r6.compression || i8 > y3.minCol && i8 < y3.maxCol && t7 > y3.minRow && t7 < y3.maxRow) return d7;
    const { origin: x2, blockWidth: g4, blockHeight: v7 } = r6, { x: S4, y: I4 } = this.getPyramidPixelSize(e3), w3 = Math.round((a2.xmin - x2.x) / S4) % g4, b6 = Math.round((a2.xmax - x2.x) / S4) % g4 || g4, T2 = Math.round((x2.y - a2.ymax) / I4) % v7, M = Math.round((x2.y - a2.ymin) / I4) % v7 || v7, j5 = i8 === y3.minCol ? w3 : 0, _2 = t7 === y3.minRow ? T2 : 0, O = i8 === y3.maxCol ? b6 : g4, R2 = t7 === y3.maxRow ? M : v7;
    return v2(d7, { x: j5, y: _2 }, { width: O - j5, height: R2 - _2 }), d7;
  }
  getSliceIndex(e3) {
    if (!this._slices || null == e3 || 0 === e3.length) return null;
    const t7 = e3;
    for (let i8 = 0; i8 < this._slices.length; i8++) {
      const e4 = this._slices[i8].multidimensionalDefinition;
      if (e4.length === t7.length && !e4.some((e5) => {
        const i9 = t7.find((t8) => e5.variableName === t8.variableName && t8.dimensionName === e5.dimensionName);
        if (!i9) return true;
        return (Array.isArray(e5.values[0]) ? `${e5.values[0][0]}-${e5.values[0][1]}` : e5.values[0]) !== (Array.isArray(i9.values[0]) ? `${i9.values[0][0]}-${i9.values[0][1]}` : i9.values[0]);
      })) return i8;
    }
    return null;
  }
  async fetchVariableStatisticsHistograms(e3, t7) {
    const i8 = this.request(this.url + "/statistics", { query: { variable: e3, f: "json" }, signal: t7 }).then((e4) => e4.data?.statistics), s7 = this.request(this.url + "/histograms", { query: { variable: e3, f: "json" }, signal: t7 }).then((e4) => e4.data?.histograms), r6 = await Promise.all([i8, s7]);
    return r6[0] && r6[0].forEach((e4) => {
      e4.avg = e4.mean, e4.stddev = e4.standardDeviation;
    }), r6[1]?.[0]?.counts?.length || (r6[1] = null), { statistics: r6[0] || null, histograms: r6[1] || null };
  }
  async computeBestPyramidLevelForLocation(e3, t7 = {}) {
    if (!this._tilemapCache) return 0;
    let i8 = this.identifyPixelLocation(e3, 0, t7.datumTransformation);
    if (null === i8) return null;
    let s7 = 0;
    const { maximumPyramidLevel: r6 } = this.rasterInfo.storageInfo;
    let a2 = r6 - s7 + this._levelOffset;
    const l7 = i8.srcLocation;
    for (; a2 >= 0; ) {
      try {
        if ("available" === await this._tilemapCache.fetchAvailability(a2, i8.row, i8.col, t7)) break;
      } catch {
      }
      if (a2--, s7++, i8 = this.identifyPixelLocation(l7, s7, t7.datumTransformation), null === i8) return null;
    }
    return -1 === a2 || null == i8 ? null : s7;
  }
  async _open(e3) {
    const r6 = e3?.signal, a2 = this.sourceJSON ? { data: this.sourceJSON } : await this.request(this.url, { query: { f: "json" }, signal: r6 });
    a2.ssl && (this.url = this.url.replace(/^http:/i, "https:"));
    const l7 = a2.data;
    if (this.sourceJSON = l7, !l7) throw new s("imageserverraster:open", "cannot initialize tiled image service, missing service info");
    if (!l7.tileInfo) throw new s("imageserverraster:open", "use ImageryLayer to open non-tiled image services");
    this._fixScaleInServiceInfo();
    const n5 = ["jpg", "jpeg", "png", "png8", "png24", "png32", "mixed"];
    this.tileType = l7.cacheType, null == this.tileType && (n5.includes(l7.tileInfo.format.toLowerCase()) ? this.tileType = "Map" : "lerc" === l7.tileInfo.format.toLowerCase() ? this.tileType = "Elevation" : this.tileType = "Raster"), this.datasetName = l7.name?.slice(l7.name.indexOf("/") + 1) ?? "";
    const o6 = await this._fetchRasterInfo({ signal: r6 });
    if (null == o6) throw new s("image-server-raster:open", "cannot initialize image service");
    c4(o6, l7);
    const c7 = "Map" === this.tileType ? v5(l7.tileInfo, l7) : z2.fromJSON(l7.tileInfo);
    n(c7);
    const [f7, p6] = this._computeMinMaxLOD(o6, c7), { extent: d7, pixelSize: x2 } = o6, g4 = 0.5 / o6.width * x2.x, I4 = Math.max(x2.x, x2.y), { lods: w3 } = c7;
    ("Map" !== this.tileType && 0 !== l7.maxScale || Math.abs(x2.x - x2.y) > g4 || !w3.some((e4) => Math.abs(e4.resolution - I4) < g4)) && (x2.x = x2.y = f7.resolution, o6.width = Math.ceil((d7.xmax - d7.xmin) / x2.x - 0.1), o6.height = Math.ceil((d7.ymax - d7.ymin) / x2.y - 0.1));
    const b6 = f7.level - p6.level, [T2, M] = c7.size, j5 = [], _2 = [];
    w3.forEach((e4, t7) => {
      e4.level >= p6.level && e4.level <= f7.level && j5.push({ x: e4.resolution, y: e4.resolution }), t7 < w3.length - 1 && _2.push(Math.round(10 * e4.resolution / w3[t7 + 1].resolution) / 10);
    }), j5.sort((e4, t7) => e4.x - t7.x);
    const O = this.computeBlockBoundary(d7, T2, M, c7.origin, j5, b6), R2 = j5.length > 1 ? j5.slice(1) : null;
    let L3;
    l7.transposeInfo && (L3 = { tileSize: [l7.transposeInfo.rows, l7.transposeInfo.cols], packetSize: o6.keyProperties?._yxs.PacketSize ?? 0 });
    const z3 = _2.length <= 1 || _2.length >= 3 && _2.slice(0, -1).every((e4) => e4 === _2[0]) ? _2[0] ?? 2 : Math.round(10 / (p6.resolution / f7.resolution) ** (-1 / b6)) / 10;
    if (o6.storageInfo = new l6({ blockWidth: c7.size[0], blockHeight: c7.size[1], pyramidBlockWidth: c7.size[0], pyramidBlockHeight: c7.size[1], pyramidResolutions: R2, pyramidScalingFactor: z3, compression: c7.format, origin: c7.origin, firstPyramidLevel: 1, maximumPyramidLevel: b6, tileInfo: c7, isBsqTile: !!l7.bsq, transposeInfo: L3, blockBoundary: O }), S2(o6), this._set("rasterInfo", o6), l7.capabilities.toLowerCase().includes("tilemap")) {
      const e4 = { tileInfo: o6.storageInfo.tileInfo, parsedUrl: I(this.url), url: this.url, tileServers: [] };
      this._tilemapCache = new j4({ layer: e4 });
    }
  }
  async _fetchRasterInfo(e3) {
    const t7 = this.sourceJSON;
    if ("Map" === this.tileType) {
      const e4 = t7.fullExtent || t7.extent, i9 = Math.ceil((e4.xmax - e4.xmin) / t7.pixelSizeX - 0.1), s8 = Math.ceil((e4.ymax - e4.ymin) / t7.pixelSizeY - 0.1), r7 = f2.fromJSON(t7.spatialReference || e4.spatialReference), a3 = new _({ x: t7.pixelSizeX, y: t7.pixelSizeY, spatialReference: r7 });
      return new m4({ width: i9, height: s8, bandCount: 3, extent: z.fromJSON(e4), spatialReference: r7, pixelSize: a3, pixelType: "u8", statistics: null, keyProperties: { DataType: "processed" } });
    }
    const { signal: i8 } = e3, s7 = f4(this.url, this.sourceJSON, { signal: i8, query: this.ioConfig.customFetchParameters }), r6 = t7.hasMultidimensions ? this.request(`${this.url}/slices`, { query: { f: "json" }, signal: i8 }).then((e4) => e4.data?.slices).catch(() => null) : null, a2 = await Promise.all([s7, r6]);
    return this._slices = a2[1], a2[0];
  }
  _fixScaleInServiceInfo() {
    const { sourceJSON: e3 } = this;
    e3.minScale && e3.minScale < 0 && (e3.minScale = 0), e3.maxScale && e3.maxScale < 0 && (e3.maxScale = 0);
  }
  _computeMinMaxLOD(e3, t7) {
    const { pixelSize: i8 } = e3, s7 = 0.5 / e3.width * i8.x, { lods: r6 } = t7, a2 = t7.lodAt(Math.max.apply(null, r6.map((e4) => e4.level))), l7 = t7.lodAt(Math.min.apply(null, r6.map((e4) => e4.level))), { tileType: n5 } = this;
    if ("Map" === n5) return this._levelOffset = r6[0].level, [a2, l7];
    if ("Raster" === n5) {
      return [r6.find((e4) => e4.resolution === i8.x) ?? a2, l7];
    }
    const { minScale: o6, maxScale: c7 } = this.sourceJSON;
    let m9 = a2;
    c7 > 0 && (m9 = r6.find((e4) => Math.abs(e4.scale - c7) < s7), m9 || (m9 = r6.filter((e4) => e4.scale > c7).sort((e4, t8) => e4.scale > t8.scale ? 1 : -1)[0] ?? a2));
    let u8 = l7;
    return o6 > 0 && (u8 = r6.find((e4) => Math.abs(e4.scale - o6) < s7) ?? l7, this._levelOffset = u8.level - l7.level), [m9, u8];
  }
};
function v5(e3, t7) {
  if (!e3) return null;
  const { minScale: i8, maxScale: s7, minLOD: r6, maxLOD: a2 } = t7;
  if (null != r6 && null != a2) return z2.fromJSON({ ...e3, lods: e3.lods.filter(({ level: e4 }) => null != e4 && e4 >= r6 && e4 <= a2) });
  if (0 !== i8 && 0 !== s7) {
    const t8 = (e4) => Math.round(1e4 * e4) / 1e4, r7 = i8 ? t8(i8) : 1 / 0, a3 = s7 ? t8(s7) : -1 / 0;
    return z2.fromJSON({ ...e3, lods: e3.lods.filter((e4) => {
      const i9 = t8(e4.scale);
      return i9 <= r7 && i9 >= a3;
    }) });
  }
  return z2.fromJSON(e3);
}
function S2(e3) {
  const { extent: t7, spatialReference: i8 } = e3;
  t7.xmin > -1 && t7.xmax > 181 && i8?.wkid && i8.isGeographic && (e3.nativeExtent = e3.extent, e3.transform = new n2(), e3.extent = e3.transform.forwardTransform(t7));
}
__decorate([m2({ type: String, json: { write: true } })], g3.prototype, "datasetFormat", void 0), __decorate([m2()], g3.prototype, "tileType", void 0), g3 = __decorate([a("esri.layers.support.rasterDatasets.ImageServerRaster")], g3);
var I2 = g3;

// node_modules/@arcgis/core/layers/support/rasterDatasets/MRFRaster.js
var y2 = /* @__PURE__ */ new Map();
y2.set("Int8", "s8"), y2.set("UInt8", "u8"), y2.set("Int16", "s16"), y2.set("UInt16", "u16"), y2.set("Int32", "s32"), y2.set("UInt32", "u32"), y2.set("Float32", "f32"), y2.set("Float64", "f32"), y2.set("Double64", "f32");
var x = /* @__PURE__ */ new Map();
x.set("none", { blobExtension: ".til", isOneSegment: true, decoderFormat: "bip" }), x.set("lerc", { blobExtension: ".lrc", isOneSegment: false, decoderFormat: "lerc" }), x.set("deflate", { blobExtension: ".pzp", isOneSegment: true, decoderFormat: "deflate" }), x.set("jpeg", { blobExtension: ".pjg", isOneSegment: true, decoderFormat: "jpg" }), x.set("qb3", { blobExtension: ".pq3", isOneSegment: true, decoderFormat: "qb3" });
var b4 = class extends X {
  constructor() {
    super(...arguments), this._files = null, this._storageIndex = null, this.datasetFormat = "MRF";
  }
  async fetchRawTile(t7, e3, r6, s7 = {}) {
    const { blockWidth: o6, blockHeight: i8, blockBoundary: a2 } = this.rasterInfo.storageInfo, l7 = a2[t7];
    if (!l7 || l7.maxRow < e3 || l7.maxCol < r6 || l7.minRow > e3 || l7.minCol > r6) return null;
    const { bandCount: f7, pixelType: c7 } = this.rasterInfo, { ranges: m9, actualTileWidth: p6, actualTileHeight: h3 } = this._getTileLocation(t7, e3, r6);
    if (!m9 || 0 === m9.length) return null;
    if (0 === m9[0].from && 0 === m9[0].to) {
      const t8 = new Uint8Array(o6 * i8);
      return new c({ width: o6, height: i8, pixels: void 0, mask: t8, validPixelCount: 0 });
    }
    const { bandIds: u8 } = this.ioConfig, g4 = this._getBandSegmentCount(), d7 = [];
    let y3 = 0;
    for (y3 = 0; y3 < g4; y3++) u8 && !u8.includes(y3) || d7.push(this.request(this._files.data, { range: { from: m9[y3].from, to: m9[y3].to }, responseType: "array-buffer", signal: s7.signal }));
    const b6 = await Promise.all(d7), w3 = b6.map((t8) => t8.data.byteLength).reduce((t8, e4) => t8 + e4), I4 = new Uint8Array(w3), F = [];
    let R2 = 0;
    for (y3 = 0; y3 < g4; y3++) F.push(R2), I4.set(new Uint8Array(b6[y3].data), R2), R2 += b6[y3].data.byteLength;
    const A = x.get(this.rasterInfo.storageInfo.compression).decoderFormat, S4 = await this.decodePixelBlock(I4.buffer, { width: o6, height: i8, format: A, planes: u8?.length || f7, offsets: F, pixelType: c7 }).catch(() => null);
    if (null == S4) return null;
    let { noDataValue: _2 } = this.rasterInfo;
    if (null != _2 && "lerc" !== A && !S4.mask && (_2 = _2[0], null != _2)) {
      const t8 = S4.width * S4.height, e4 = new Uint8Array(t8);
      if (Math.abs(_2) > 1e24) for (y3 = 0; y3 < t8; y3++) Math.abs((S4.pixels[0][y3] - _2) / _2) > 1e-6 && (e4[y3] = 1);
      else for (y3 = 0; y3 < t8; y3++) S4.pixels[0][y3] !== _2 && (e4[y3] = 1);
      S4.mask = e4;
    }
    let M = 0, k5 = 0;
    if (p6 !== o6 || h3 !== i8) {
      let t8 = S4.mask;
      if (t8) for (y3 = 0; y3 < i8; y3++) if (k5 = y3 * o6, y3 < h3) for (M = p6; M < o6; M++) t8[k5 + M] = 0;
      else for (M = 0; M < o6; M++) t8[k5 + M] = 0;
      else for (t8 = new Uint8Array(o6 * i8), S4.mask = t8, y3 = 0; y3 < h3; y3++) for (k5 = y3 * o6, M = 0; M < p6; M++) t8[k5 + M] = 1;
    }
    return S4;
  }
  async _open(t7) {
    this.datasetName = this.url.slice(this.url.lastIndexOf("/") + 1);
    const e3 = t7 ? t7.signal : null, r6 = await this.request(this.url, { responseType: "xml", signal: e3 }), { rasterInfo: s7, files: o6 } = this._parseHeader(r6.data), { skipMapInfo: i8, skipExtensions: a2 = [] } = this.ioConfig;
    if (!a2.includes("aux.xml") && !i8) {
      const e4 = await this._fetchAuxiliaryData(t7);
      null != e4 && (s7.statistics = e4.statistics ?? s7.statistics, s7.histograms = e4.histograms, e4.histograms && null == s7.statistics && (s7.statistics = v3(e4.histograms)));
    }
    i8 && this.updateImageSpaceRasterInfo(s7), this._set("rasterInfo", s7), this._files = o6;
    const n5 = await this.request(o6.index, { responseType: "array-buffer", signal: e3 });
    this._storageIndex = w2(n5.data);
    const { blockWidth: l7, blockHeight: f7 } = this.rasterInfo.storageInfo, c7 = this.rasterInfo.storageInfo.pyramidScalingFactor, { width: m9, height: p6 } = this.rasterInfo, h3 = [], u8 = this._getBandSegmentCount();
    let g4 = 0, y3 = -1;
    for (; g4 < this._storageIndex.length; ) {
      y3++;
      const t8 = Math.ceil(m9 / l7 / c7 ** y3) - 1, e4 = Math.ceil(p6 / f7 / c7 ** y3) - 1;
      g4 += (t8 + 1) * (e4 + 1) * u8 * 4, h3.push({ maxRow: e4, maxCol: t8, minCol: 0, minRow: 0 });
    }
    this.rasterInfo.storageInfo.blockBoundary = h3, y3 > 0 && (this.rasterInfo.storageInfo.firstPyramidLevel = 1, this.rasterInfo.storageInfo.maximumPyramidLevel = y3), this.updateTileInfo();
  }
  _getBandSegmentCount() {
    return x.get(this.rasterInfo.storageInfo.compression).isOneSegment ? 1 : this.rasterInfo.bandCount;
  }
  _getTileLocation(t7, e3, r6) {
    const { blockWidth: s7, blockHeight: o6, pyramidScalingFactor: i8 } = this.rasterInfo.storageInfo, { width: a2, height: n5 } = this.rasterInfo, l7 = this._getBandSegmentCount();
    let f7, c7, m9, p6 = 0, h3 = 0;
    for (m9 = 0; m9 < t7; m9++) h3 = i8 ** m9, f7 = Math.ceil(a2 / s7 / h3), c7 = Math.ceil(n5 / o6 / h3), p6 += f7 * c7;
    h3 = i8 ** t7, f7 = Math.ceil(a2 / s7 / h3), c7 = Math.ceil(n5 / o6 / h3), p6 += e3 * f7 + r6, p6 *= 4 * l7;
    const u8 = this._storageIndex.subarray(p6, p6 + 4 * l7);
    let g4 = 0, d7 = 0;
    const y3 = [];
    for (let x2 = 0; x2 < l7; x2++) g4 = u8[4 * x2] * 2 ** 32 + u8[4 * x2 + 1], d7 = g4 + u8[4 * x2 + 2] * 2 ** 32 + u8[4 * x2 + 3] - 1, y3.push({ from: g4, to: d7 });
    return { ranges: y3, actualTileWidth: r6 < f7 - 1 ? s7 : Math.ceil(a2 / h3) - s7 * (f7 - 1), actualTileHeight: e3 < c7 - 1 ? o6 : Math.ceil(n5 / h3) - o6 * (c7 - 1) };
  }
  _parseHeader(t7) {
    const r6 = e2(t7, "MRF_META/Raster");
    if (!r6) throw new s("mrf:open", "not a valid MRF format");
    const s7 = e2(r6, "Size"), n5 = parseInt(s7.getAttribute("x"), 10), c7 = parseInt(s7.getAttribute("y"), 10), p6 = parseInt(s7.getAttribute("c"), 10), g4 = (t4(r6, "Compression") || "none").toLowerCase();
    if (!x.has(g4)) throw new s("mrf:open", "currently does not support compression " + g4);
    const d7 = t4(r6, "DataType") || "UInt8", b6 = y2.get(d7);
    if (null == b6) throw new s("mrf:open", "currently does not support pixel type " + d7);
    const w3 = e2(r6, "PageSize"), I4 = parseInt(w3.getAttribute("x"), 10), F = parseInt(w3.getAttribute("y"), 10), R2 = e2(r6, "DataValues");
    let A, S4;
    R2 && (S4 = R2.getAttribute("NoData"), null != S4 && (A = S4.trim().split(" ").map((t8) => parseFloat(t8))));
    if (e2(t7, "MRF_META/CachedSource")) throw new s("mrf:open", "currently does not support MRF referencing other data files");
    const _2 = e2(t7, "MRF_META/GeoTags"), M = e2(_2, "BoundingBox");
    let k5, j5 = false;
    if (null != M) {
      const t8 = parseFloat(M.getAttribute("minx")), e3 = parseFloat(M.getAttribute("miny")), r7 = parseFloat(M.getAttribute("maxx")), s8 = parseFloat(M.getAttribute("maxy")), i8 = t4(_2, "Projection") || "";
      let n6 = f2.WGS84;
      if ("LOCAL_CS[]" !== i8) if (i8.toLowerCase().startsWith("epsg:")) {
        const t9 = Number(i8.slice(5));
        isNaN(t9) || 0 === t9 || (n6 = new f2({ wkid: t9 }));
      } else n6 = d5(i8) ?? f2.WGS84;
      else j5 = true, n6 = new f2({ wkid: 3857 });
      k5 = new z(t8, e3, r7, s8), k5.spatialReference = n6;
    } else j5 = true, k5 = new z({ xmin: -0.5, ymin: 0.5 - c7, xmax: n5 - 0.5, ymax: 0.5, spatialReference: new f2({ wkid: 3857 }) });
    const C3 = e2(t7, "MRF_META/Rsets"), T2 = parseInt(C3?.getAttribute("scale") || "2", 10), L3 = k5.spatialReference, U = new l6({ origin: new _({ x: k5.xmin, y: k5.ymax, spatialReference: L3 }), blockWidth: I4, blockHeight: F, pyramidBlockWidth: I4, pyramidBlockHeight: F, compression: g4, pyramidScalingFactor: T2 }), B = new _({ x: k5.width / n5, y: k5.height / c7, spatialReference: L3 }), E3 = new m4({ width: n5, height: c7, extent: k5, isPseudoSpatialReference: j5, spatialReference: L3, bandCount: p6, pixelType: b6, pixelSize: B, noDataValue: A, storageInfo: U }), P = t4(t7, "datafile"), W2 = t4(t7, "IndexFile");
    return { rasterInfo: E3, files: { mrf: this.url, index: W2 || this.url.replace(".mrf", ".idx"), data: P || this.url.replace(".mrf", x.get(g4).blobExtension) } };
  }
  async _fetchAuxiliaryData(t7) {
    try {
      const { data: e3 } = await this.request(this.url + ".aux.xml", { responseType: "xml", signal: t7?.signal });
      return S(e3);
    } catch {
      return null;
    }
  }
};
function w2(t7) {
  if (t7.byteLength % 16 > 0) throw new Error("invalid array buffer must be multiples of 16");
  let e3, r6, s7, o6, i8, a2;
  if (r2) {
    for (r6 = new Uint8Array(t7), o6 = new ArrayBuffer(t7.byteLength), s7 = new Uint8Array(o6), i8 = 0; i8 < t7.byteLength / 4; i8++) for (a2 = 0; a2 < 4; a2++) s7[4 * i8 + a2] = r6[4 * i8 + 3 - a2];
    e3 = new Uint32Array(o6);
  } else e3 = new Uint32Array(t7);
  return e3;
}
__decorate([m2()], b4.prototype, "_files", void 0), __decorate([m2()], b4.prototype, "_storageIndex", void 0), __decorate([m2({ type: String, json: { write: true } })], b4.prototype, "datasetFormat", void 0), b4 = __decorate([a("esri.layers.support.rasterDatasets.MRFRaster")], b4);
var I3 = b4;

// node_modules/@arcgis/core/layers/support/rasterDatasets/DBFParser.js
function t6(e3) {
  const t7 = e3.fields, r6 = e3.records, n5 = t7.some((e4) => "oid" === e4.name.toLowerCase()) ? "OBJECTID" : "OID", i8 = [{ name: n5, type: "esriFieldTypeOID", alias: "OID" }].concat(t7.map((e4) => ({ name: e4.name, type: "esriFieldType" + e4.typeName, alias: e4.name }))), a2 = i8.map((e4) => e4.name), s7 = [];
  let o6 = 0, l7 = 0;
  return r6.forEach((e4) => {
    const t8 = {};
    for (t8[n5] = o6++, l7 = 1; l7 < a2.length; l7++) t8[a2[l7]] = e4[l7 - 1];
    s7.push({ attributes: t8 });
  }), { displayFieldName: "", fields: i8, features: s7 };
}
var r5 = class {
  static get supportedVersions() {
    return [5];
  }
  static parse(r6) {
    const n5 = new DataView(r6), i8 = 3 & n5.getUint8(0);
    if (3 !== i8) return { header: { version: i8 }, recordSet: null };
    const a2 = n5.getUint32(4, true), s7 = n5.getUint16(8, true), o6 = n5.getUint16(10, true), l7 = { version: i8, recordCount: a2, headerByteCount: s7, recordByteCount: o6 };
    let p6 = 32;
    const d7 = [], g4 = [];
    let h3;
    if (3 === i8) {
      for (; 13 !== n5.getUint8(p6); ) h3 = String.fromCharCode(n5.getUint8(p6 + 11)).trim(), d7.push({ name: r(new Uint8Array(r6, p6, 11)), type: h3, typeName: ["String", "Date", "Double", "Boolean", "String", "Integer"][["C", "D", "F", "L", "M", "N"].indexOf(h3)], length: n5.getUint8(p6 + 16) }), p6 += 32;
      if (p6 += 1, d7.length > 0) for (; g4.length < a2 && r6.byteLength - p6 > o6; ) {
        const t7 = [];
        32 === n5.getUint8(p6) ? (p6 += 1, d7.forEach((n6) => {
          if ("C" === n6.type) t7.push(r(new Uint8Array(r6, p6, n6.length)).trim());
          else if ("N" === n6.type) t7.push(parseInt(String.fromCharCode.apply(null, new Uint8Array(r6, p6, n6.length)).trim(), 10));
          else if ("F" === n6.type) t7.push(parseFloat(String.fromCharCode.apply(null, new Uint8Array(r6, p6, n6.length)).trim()));
          else if ("D" === n6.type) {
            const e3 = String.fromCharCode.apply(null, new Uint8Array(r6, p6, n6.length)).trim();
            t7.push(new Date(parseInt(e3.slice(0, 4), 10), parseInt(e3.slice(4, 6), 10) - 1, parseInt(e3.slice(6, 8), 10)));
          }
          p6 += n6.length;
        }), g4.push(t7)) : p6 += o6;
      }
    }
    return { header: l7, fields: d7, records: g4, recordSet: t6({ fields: d7, records: g4 }) };
  }
};

// node_modules/@arcgis/core/layers/support/rasterDatasets/TIFFRaster.js
var S3 = (e3, t7) => e3.get(t7)?.values;
var b5 = (e3, t7) => e3.get(t7)?.values?.[0];
var E2 = class extends X {
  constructor() {
    super(...arguments), this._files = null, this._headerInfo = null, this._bufferSize = 1048576, this._chunkSize = 10485760, this.datasetFormat = "TIFF";
  }
  async fetchRawTile(e3, t7, i8, r6 = {}) {
    if (!this._headerInfo?.isSupported || this.isBlockOutside(e3, t7, i8)) return null;
    const s7 = await this._fetchRawTiffTile(e3, t7, i8, false, r6);
    if (null != s7 && this._headerInfo.hasMaskBand) {
      const a2 = await this._fetchRawTiffTile(e3, t7, i8, true, r6);
      null != a2 && a2.pixels[0] instanceof Uint8Array && (s7.mask = a2.pixels[0]);
    }
    return s7;
  }
  async _open(e3) {
    const r6 = e3 ? e3.signal : null, { data: s7 } = await this.request(this.url, { range: { from: 0, to: this._bufferSize }, responseType: "array-buffer", signal: r6 });
    if (!s7) throw new s("tiffraster:open", "failed to open url " + this.url);
    this.datasetName = this.url.slice(this.url.lastIndexOf("/") + 1, this.url.lastIndexOf("."));
    const { littleEndian: a2, firstIFDPos: n5, isBigTiff: o6 } = H(s7), f7 = [], l7 = { fileChunk: s7, posIFD: n5, fileOffset: 0 };
    await this._readIFDs(f7, l7, a2, o6 ? 8 : 4, r6);
    const { imageInfo: u8, rasterInfo: c7 } = k4(f7), h3 = G(f7), p6 = v(f7);
    if (this._headerInfo = { littleEndian: a2, isBigTiff: o6, ifds: f7, pyramidIFDs: h3, maskIFDs: p6, ...u8 }, this._set("rasterInfo", c7), !u8.isSupported) throw new s("tiffraster:open", "this tiff is not supported: " + u8.message);
    if (!u8.tileWidth) throw new s("tiffraster:open", "none-tiled tiff is not optimized for access, convert to COG and retry.");
    c7.isPseudoSpatialReference && i.getLogger(this).warn("The spatial reference for this tiff is unsupported. Only EPSG spatial reference codes and Esri WKTs are supported.");
    const g4 = f7[0].get("PREDICTOR")?.values?.[0], x2 = f7[0].get("SAMPLEFORMAT")?.values?.[0];
    if (3 === x2 && 2 === g4) throw new s("tiffraster:open", "unsupported horizontal difference encoding. Predictor=3 is supported for floating point data");
    const { skipMapInfo: w3, skipExtensions: I4 = [] } = this.ioConfig;
    if (!I4.includes("aux.xml") && !w3) {
      const t7 = await this._fetchAuxiliaryMetaData(e3);
      null != t7 && D(t7, c7);
    }
    I4.includes("vat.dbf") || 1 !== c7.bandCount || "u8" !== c7.pixelType || w3 || (c7.attributeTable = await this._fetchAuxiliaryTable(e3), null != c7.attributeTable && (c7.keyProperties.DataType = "thematic")), w3 && this.updateImageSpaceRasterInfo(c7), this.updateTileInfo();
  }
  async _validateOrFetchHeaderBuffer(e3, t7) {
    let { fileChunk: i8, fileOffset: r6, posIFD: s7 } = e3;
    if (s7 + 8 >= i8.byteLength || s7 < 0) {
      r6 = s7 + r6;
      i8 = (await this.request(this.url, { range: { from: r6, to: r6 + this._bufferSize }, responseType: "array-buffer", signal: t7 })).data, s7 = 0;
    }
    return { fileChunk: i8, fileOffset: r6, posIFD: s7 };
  }
  async _readIFDs(e3, i8, r6, s7 = 4, a2) {
    if (!i8.posIFD) return null;
    i8 = await this._validateOrFetchHeaderBuffer(i8, a2);
    const n5 = await this._readIFD(i8, r6, e, s7, a2);
    if (!n5?.ifd) throw new s("tiffraster:open", "cannot parse tiff header. failed to open url " + this.url);
    if (e3.push(n5.ifd), !n5.nextIFD) return null;
    i8.posIFD = n5.nextIFD - i8.fileOffset, await this._readIFDs(e3, i8, r6, s7, a2);
  }
  async _readIFD(e3, t7, i8 = e, r6 = 4, s7) {
    let { fileChunk: a2, posIFD: n5, fileOffset: o6 } = e3;
    if (!e3.fileChunk) return null;
    const f7 = Y(a2, t7, n5, o6, i8, r6);
    if (f7.success) {
      const e4 = [];
      if (f7.ifd?.forEach((t8) => {
        t8.values || e4.push(t8);
      }), e4.length > 0 && await this._fillOffsets(e4, t7, f7.nextIFD, s7), f7.ifd?.has("GEOKEYDIRECTORY")) {
        const e5 = f7.ifd.get("GEOKEYDIRECTORY"), i9 = e5?.values;
        if (i9 && i9.length > 4) {
          const r7 = i9[0] + "." + i9[1] + "." + i9[2];
          n5 = e5.valueOffset + 6 - o6;
          const f8 = await this._validateOrFetchHeaderBuffer({ fileChunk: a2, posIFD: n5, fileOffset: o6 }, s7), l7 = await this._readIFD(f8, t7, t2, 2, s7);
          e5.data = l7?.ifd, e5.data && e5.data.set("GEOTIFFVersion", { id: 0, type: 2, valueCount: 1, valueOffset: null, values: [r7] });
        }
      }
      return f7;
    }
    if (f7.requiredBufferSize) {
      return a2 = (await this.request(this.url, { range: { from: o6, to: o6 + n5 + f7.requiredBufferSize + 8 }, responseType: "array-buffer", signal: s7 })).data, a2.byteLength < n5 + f7.requiredBufferSize ? null : (e3.fileChunk = a2, e3.fileOffset = o6, this._readIFD(e3, t7, i8, r6, s7));
    }
    return null;
  }
  async _fillOffsets(e3, t7, i8, r6) {
    const s7 = e3.filter((e4) => null != e4.offlineOffsetSize);
    if (0 === s7.length) return;
    const a2 = s7.map((e4) => e4.offlineOffsetSize), n5 = Math.min.apply(null, a2.map((e4) => e4[0])), o6 = Math.max.apply(null, a2.map((e4) => e4[0] + e4[1]));
    let f7 = 1 === a2.length || o6 - n5 <= this._bufferSize;
    if (!f7 && a2.length > 1) {
      a2.sort((e4, t8) => e4[0] - t8[0]);
      f7 = a2.reduce((e4, t8) => e4 === t8[0] ? t8[0] + t8[1] : 0, a2[0][0]) === o6;
    }
    if (f7) {
      const e4 = await this._fetchOffsets(n5, Math.max(o6, n5 + this._bufferSize), r6);
      return void s7.forEach((i9) => N2(e4, t7, i9, n5));
    }
    const l7 = s7.map(async (e4) => {
      const i9 = e4.offlineOffsetSize, s8 = await this._fetchOffsets(i9[0], i9[1] + i9[0], r6);
      N2(s8, t7, e4, i9[0]);
    });
    await Promise.all(l7);
  }
  async _fetchOffsets(e3, t7, i8) {
    const r6 = [], s7 = this._chunkSize, a2 = Math.ceil((t7 - e3) / s7);
    let n5 = e3;
    for (let l7 = 0; l7 < a2; l7++) r6.push(this.request(this.url, { range: { from: n5, to: l7 === a2 - 1 ? t7 : n5 + s7 - 1 }, responseType: "array-buffer", signal: i8 })), n5 += s7;
    const o6 = await Promise.all(r6);
    if (1 === a2) return o6[0].data;
    const f7 = new Uint8Array(t7 - e3 + 1);
    for (let l7 = 0; l7 < a2; l7++) f7.set(new Uint8Array(o6[l7].data), l7 * s7);
    return f7.buffer;
  }
  async _fetchRawTiffTile(e3, t7, i8, r6, s7 = {}) {
    const a2 = this._getTileLocation(e3, t7, i8, r6);
    if (!a2) return null;
    const { ranges: n5, actualTileWidth: o6, actualTileHeight: f7, ifd: l7 } = a2, u8 = n5.map((e4) => this.request(this.url, { range: e4, responseType: "array-buffer", signal: s7.signal })), c7 = await Promise.all(u8), h3 = c7.map((e4) => e4.data.byteLength).reduce((e4, t8) => e4 + t8), p6 = 1 === c7.length ? c7[0].data : new ArrayBuffer(h3), d7 = [0], m9 = [0];
    if (c7.length > 1) {
      const e4 = new Uint8Array(p6);
      for (let t8 = 0, i9 = 0; t8 < c7.length; t8++) {
        const r7 = c7[t8].data;
        e4.set(new Uint8Array(r7), i9), d7[t8] = i9, i9 += r7.byteLength, m9[t8] = r7.byteLength;
      }
    }
    const { blockWidth: y3, blockHeight: g4 } = this.getBlockWidthHeight(e3), x2 = await this.decodePixelBlock(p6, { format: "tiff", customOptions: { headerInfo: this._headerInfo, ifd: l7, offsets: d7, sizes: m9 }, width: y3, height: g4, planes: null, pixelType: null });
    if (null == x2) return null;
    let w3, I4, T2;
    if (o6 !== y3 || f7 !== g4) {
      let e4 = x2.mask;
      if (e4) for (w3 = 0; w3 < g4; w3++) if (T2 = w3 * y3, w3 < f7) for (I4 = o6; I4 < y3; I4++) e4[T2 + I4] = 0;
      else for (I4 = 0; I4 < y3; I4++) e4[T2 + I4] = 0;
      else for (e4 = new Uint8Array(y3 * g4), x2.mask = e4, w3 = 0; w3 < f7; w3++) for (T2 = w3 * y3, I4 = 0; I4 < o6; I4++) e4[T2 + I4] = 1;
    }
    return x2;
  }
  _getTileLocation(e3, t7, i8, r6 = false) {
    const { firstPyramidLevel: s7, blockBoundary: a2 } = this.rasterInfo.storageInfo, n5 = 0 === e3 ? 0 : e3 - (s7 - 1), { _headerInfo: o6 } = this;
    if (!o6) return null;
    const f7 = r6 ? o6.maskIFDs[n5] : 0 === n5 ? o6?.ifds[0] : o6?.pyramidIFDs[n5 - 1];
    if (!f7) return null;
    const l7 = C(f7, o6), u8 = S3(f7, "TILEOFFSETS");
    if (void 0 === u8) return null;
    const c7 = S3(f7, "TILEBYTECOUNTS"), { minRow: h3, minCol: p6, maxRow: d7, maxCol: m9 } = a2[n5];
    if (t7 > d7 || i8 > m9 || t7 < h3 || i8 < p6) return null;
    const y3 = b5(f7, "IMAGEWIDTH"), g4 = b5(f7, "IMAGELENGTH"), x2 = b5(f7, "TILEWIDTH"), I4 = b5(f7, "TILELENGTH"), T2 = [];
    if (l7) {
      const { bandCount: e4 } = this.rasterInfo;
      for (let r7 = 0; r7 < e4; r7++) {
        const e5 = r7 * (d7 + 1) * (m9 + 1) + t7 * (m9 + 1) + i8;
        T2[r7] = { from: u8[e5], to: u8[e5] + c7[e5] - 1 };
      }
    } else {
      const e4 = t7 * (m9 + 1) + i8;
      T2.push({ from: u8[e4], to: u8[e4] + c7[e4] - 1 });
    }
    for (let w3 = 0; w3 < T2.length; w3++) if (null == T2[w3].from || !T2[w3].to || T2[w3].to < 0) return null;
    return { ranges: T2, ifd: f7, actualTileWidth: i8 === m9 && y3 % x2 || x2, actualTileHeight: t7 === d7 && g4 % I4 || I4 };
  }
  async _fetchAuxiliaryMetaData(e3) {
    try {
      const { data: t7 } = await this.request(this.url + ".aux.xml", { responseType: "xml", signal: e3?.signal });
      return S(t7);
    } catch {
      return null;
    }
  }
  async _fetchAuxiliaryTable(e3) {
    try {
      const { data: t7 } = await this.request(this.url + ".vat.dbf", { responseType: "array-buffer", signal: e3?.signal }), i8 = r5.parse(t7);
      return i8?.recordSet ? g.fromJSON(i8.recordSet) : null;
    } catch {
      return null;
    }
  }
};
function k4(e3) {
  const t7 = k2(e3), { width: i8, height: r6, tileWidth: s7, tileHeight: u8, planes: c7, pixelType: h3, compression: d7, firstPyramidLevel: m9, maximumPyramidLevel: y3, pyramidBlockWidth: g4, pyramidBlockHeight: x2, pyramidResolutions: w3, tileBoundary: T2, affine: R2, metadata: _2 } = t7, F = t7.extent.spatialReference?.wkt || t7.extent.spatialReference?.wkid;
  let E3 = d5(F), k5 = !!t7.isPseudoGeographic;
  null == E3 && (k5 = true, E3 = new f2({ wkid: 3857 }));
  const D2 = new z({ ...t7.extent, spatialReference: E3 }), v7 = new _(D2 ? { x: D2.xmin, y: D2.ymax, spatialReference: E3 } : { x: 0, y: 0 }), P = new l6({ blockWidth: s7, blockHeight: u8, pyramidBlockWidth: g4, pyramidBlockHeight: x2, compression: d7, origin: v7, firstPyramidLevel: m9, maximumPyramidLevel: y3, pyramidResolutions: w3, blockBoundary: T2 }), B = new _({ x: (D2.xmax - D2.xmin) / i8, y: (D2.ymax - D2.ymin) / r6, spatialReference: E3 }), C3 = _2 ? { BandProperties: _2.bandProperties, DataType: _2.dataType } : {};
  let L3 = null;
  const z3 = b5(e3[0], "PHOTOMETRICINTERPRETATION"), j5 = S3(e3[0], "COLORMAP");
  if (z3 <= 3 && j5?.length > 3 && j5.length % 3 == 0) {
    L3 = [];
    const e4 = j5.length / 3;
    for (let t8 = 0; t8 < e4; t8++) L3.push([t8, j5[t8] >>> 8, j5[t8 + e4] >>> 8, j5[t8 + 2 * e4] >>> 8]);
  }
  const A = new m4({ width: i8, height: r6, bandCount: c7, pixelType: h3, pixelSize: B, storageInfo: P, spatialReference: E3, isPseudoSpatialReference: k5, keyProperties: C3, extent: D2, colormap: L3, statistics: _2 ? _2.statistics : null });
  if (R2?.length && (A.nativeExtent = new z({ xmin: -0.5, ymin: 0.5 - r6, xmax: i8 - 0.5, ymax: 0.5, spatialReference: E3 }), A.transform = new u3({ polynomialOrder: 1, forwardCoefficients: [R2[2] + R2[0] / 2, R2[5] - R2[3] / 2, R2[0], R2[3], -R2[1], -R2[4]] }), A.extent = A.transform.forwardTransform(A.nativeExtent), A.pixelSize = new _({ x: (D2.xmax - D2.xmin) / i8, y: (D2.ymax - D2.ymin) / r6, spatialReference: E3 }), P.origin.x = -0.5, P.origin.y = 0.5), w3) {
    const { x: e4, y: t8 } = A.pixelSize;
    w3.forEach((i9) => {
      i9.x *= e4, i9.y *= t8;
    });
  }
  return { imageInfo: t7, rasterInfo: A };
}
function D(e3, t7) {
  if (t7.statistics = e3.statistics ?? t7.statistics, t7.histograms = e3.histograms, e3.histograms && null == t7.statistics && (t7.statistics = v3(e3.histograms)), e3.transform && null == t7.transform) {
    t7.transform = e3.transform, t7.nativeExtent = t7.extent;
    const i8 = t7.transform.forwardTransform(t7.nativeExtent);
    t7.pixelSize = new _({ x: (i8.xmax - i8.xmin) / t7.width, y: (i8.ymax - i8.ymin) / t7.height, spatialReference: t7.spatialReference }), t7.extent = i8;
  }
  t7.isPseudoSpatialReference && e3.spatialReference && (t7.spatialReference = e3.spatialReference, t7.extent.spatialReference = t7.nativeExtent.spatialReference = t7.storageInfo.origin.spatialReference = t7.spatialReference);
}
__decorate([m2()], E2.prototype, "_files", void 0), __decorate([m2()], E2.prototype, "_headerInfo", void 0), __decorate([m2()], E2.prototype, "_bufferSize", void 0), __decorate([m2()], E2.prototype, "_chunkSize", void 0), __decorate([m2({ type: String, json: { write: true } })], E2.prototype, "datasetFormat", void 0), E2 = __decorate([a("esri.layers.support.rasterDatasets.TIFFRaster")], E2);
var v6 = E2;

// node_modules/@arcgis/core/layers/support/rasterDatasets/RasterFactory.js
var n4 = /* @__PURE__ */ new Map();
n4.set("MRF", { desc: "Meta Raster Format", constructor: I3 }), n4.set("TIFF", { desc: "GeoTIFF", constructor: v6 }), n4.set("RasterTileServer", { desc: "Raster Tile Server", constructor: I2 }), n4.set("JPG", { desc: "JPG Raster Format", constructor: d6 }), n4.set("PNG", { desc: "PNG Raster Format", constructor: d6 }), n4.set("GIF", { desc: "GIF Raster Format", constructor: d6 }), n4.set("BMP", { desc: "BMP Raster Format", constructor: d6 }), n4.set("CovJSON", { desc: "COVJSON Raster Format", constructor: h }), n4.set("MEMORY", { desc: "In Memory Raster Format", constructor: g2 });
var u7 = class {
  static get supportedFormats() {
    const t7 = /* @__PURE__ */ new Set();
    return n4.forEach((r6, e3) => t7.add(e3)), t7;
  }
  static async open(r6) {
    const { url: e3, ioConfig: s7, source: o6, sourceJSON: a2 } = r6;
    let c7 = r6.datasetFormat ?? s7?.datasetFormat;
    null == c7 && (e3.includes(".") ? c7 = e3.slice(e3.lastIndexOf(".") + 1).toUpperCase() : "coverage" === o6?.type?.toLowerCase() ? c7 = "CovJSON" : o6?.extent && o6.pixelblocks && (c7 = "MEMORY")), "OVR" === c7 || "TIF" === c7 ? c7 = "TIFF" : "JPG" === c7 || "JPEG" === c7 || "JFIF" === c7 ? c7 = "JPG" : "COVJSON" === c7 && (c7 = "CovJSON"), e3.toLowerCase().includes("/imageserver") && !e3.toLowerCase().includes("/wcsserver") && (c7 = "RasterTileServer");
    const u8 = { url: e3, source: o6, sourceJSON: a2, datasetFormat: c7, ioConfig: s7 ?? { bandIds: null, sampling: null } };
    if (Object.keys(u8).forEach((t7) => {
      null == u8[t7] && delete u8[t7];
    }), c7) {
      if (!this.supportedFormats.has(c7)) throw new s("rasterfactory:open", "not a supported format " + c7);
      if ("CRF" === c7) throw new s("rasterfactory:open", `cannot open raster: ${e3}`);
      const s8 = new (0, n4.get(c7).constructor)(u8);
      return await s8.open({ signal: r6.signal }), s8;
    }
    const i8 = Array.from(n4.keys()).filter((t7) => "CovJSON" !== t7 && "Memory" !== t7);
    let l7 = 0;
    const m9 = () => {
      if (c7 = i8[l7++], !c7) return null;
      if ("CRF" === c7) return null;
      const t7 = new (0, n4.get(c7).constructor)(u8);
      return t7.open({ signal: r6.signal }).then(() => t7).catch(() => m9());
    };
    return m9();
  }
  static register(t7, r6, e3) {
    n4.has(t7.toUpperCase()) || n4.set(t7.toUpperCase(), { desc: r6, constructor: e3 });
  }
};

// node_modules/@arcgis/core/layers/ImageryTileLayer.js
var Y2 = class extends p(t(b2(j2(o3(s4(X2(i5(l5(l4(f3(l2(l3(b3))))))))))))) {
  constructor(...e3) {
    super(...e3), this._primaryRasters = [], this.graphicOrigin = new s6(this), this.legendEnabled = true, this.isReference = null, this.listMode = "show", this.sourceJSON = null, this.version = null, this.type = "imagery-tile", this.operationalLayerType = "ArcGISTiledImageServiceLayer", this.popupEnabled = true, this.popupTemplate = null, this.screenSizePerspectiveEnabled = true, this.fields = null, this.source = void 0, this._debouncedSaveOperations = L(async (e4, t7, r6) => {
      const { save: s7, saveAs: i8 } = await import("./imageryUtils-K5KFGZOF.js");
      switch (e4) {
        case 0:
          return s7(this, t7);
        case 1:
          return i8(this, r6, t7);
      }
    });
  }
  normalizeCtorArgs(e3, t7) {
    return "string" == typeof e3 ? { url: e3, ...t7 } : e3;
  }
  load(e3) {
    const t7 = null != e3 ? e3.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Image Service"] }, e3).catch(f).then(() => this._openRaster(t7))), Promise.resolve(this);
  }
  set elevationInfo(e3) {
    "relative-to-scene" !== e3?.mode && this._set("elevationInfo", e3), this._validateElevationInfo(e3);
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  get rasterFields() {
    const e3 = [o2("Pixel Value"), c2("Raw Pixel Value")], t7 = this.raster?.rasterInfo ?? this.serviceRasterInfo, r6 = t7?.attributeTable;
    if (r6) {
      const t8 = v4(r6);
      e3.push(...t8);
    }
    const s7 = t7?.dataType, i8 = t7?.multidimensionalInfo;
    if (("vector-magdir" === s7 || "vector-uv" === s7) && null != i8) {
      const t8 = i8.variables[0].unit?.trim(), r7 = d2(t8), s8 = $();
      e3.push(r7, s8);
    }
    if (i8) {
      const t8 = p2(i8);
      e3.push(...t8);
    }
    return e3;
  }
  get renderer() {
    return super.renderer;
  }
  set renderer(e3) {
    super.renderer = e3;
  }
  createPopupTemplate(e3) {
    const { rasterFields: t7 } = this, r6 = e3?.visibleFieldNames ?? new Set(t7.map(({ name: e4 }) => e4).filter((e4) => e4 !== i4.rawServicePixelValue)), s7 = d({ fields: t7, title: this.title }, { ...e3, visibleFieldNames: r6 }), { rasterInfo: i8 } = this.raster;
    return s7?.fieldInfos && i8 && b(s7.fieldInfos, i8), s7;
  }
  async generateRasterInfo(e3, t7) {
    if (e3 = m(N3, e3), await this.load(), !e3 || "none" === e3.functionName?.toLowerCase()) return this.serviceRasterInfo;
    try {
      const { rasterInfo: r6 } = await this._openFunctionRaster(e3, t7);
      return r6;
    } catch (r6) {
      if (r6 instanceof s) throw r6;
      throw new s("imagery-tile-layer", "the given raster function is not supported");
    }
  }
  async save(e3) {
    return this._debouncedSaveOperations(0, e3);
  }
  async saveAs(e3, t7) {
    return this._debouncedSaveOperations(1, t7, e3);
  }
  supportsWrite() {
    const e3 = this._primaryRasters[0] ?? this.raster;
    return !!(this.loaded ? "RasterTileServer" === e3.datasetFormat && ("Raster" === e3.tileType || "Map" === e3.tileType) : this.url && /\/ImageServer(\/|\/?$)/i.test(this.url));
  }
  write(e3, t7) {
    if (this.supportsWrite()) return super.write(e3, t7);
    if (t7?.messages) {
      const e4 = `${t7.origin}/${t7.layerContainerType || "operational-layers"}`;
      t7.messages.push(new s("layer:unsupported", `Layers (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${e4}'`, { layer: this }));
    }
    return null;
  }
  async _openRaster(e3) {
    let t7 = false;
    if (this.raster) await this._openFromRaster(this.raster, e3), t7 = t3(this.raster), !t7 && this.rasterFunction && (this._primaryRasters = [this.raster], await this._initializeWithFunctionRaster(this.rasterFunction));
    else {
      const { url: t8, rasterFunction: r7, source: i8 } = this;
      if (!t8 && !i8) throw new s("imagery-tile-layer:open", "missing url or source parameter");
      i8 ? await this._openFromSource(i8, e3) : r7 ? await this._openFromUrlWithRasterFunction(t8, r7, e3) : await this._openFromUrl(t8, e3);
    }
    const r6 = this.raster.rasterInfo;
    if (!r6) throw new s("imagery-tile-layer:load", "cannot load resources on " + this.url);
    if (this._set("serviceRasterInfo", t7 ? r6 : this._primaryRasters[0].rasterInfo), this._set("spatialReference", r6.spatialReference), this.sourceJSON = this.sourceJSON || this.raster.sourceJSON, null != this.sourceJSON) {
      const e4 = "Map" === this.raster.tileType && null != this.sourceJSON.minLOD && null != this.sourceJSON.maxLOD ? this.sourceJSON : { ...this.sourceJSON, minScale: 0, maxScale: 0 };
      this.read(e4, { origin: "service" });
    } else this.read({ tileInfo: this.serviceRasterInfo?.storageInfo.tileInfo.toJSON() }, { origin: "service" });
    this.title || (this.title = this.raster.datasetName), "Map" === this.raster.tileType && (this.popupEnabled = false), this._configDefaultSettings(), this.addHandles(l(() => this.customParameters, (e4) => {
      this.raster && (this.raster.ioConfig.customFetchParameters = e4);
    }));
  }
  async _openFromRaster(e3, t7) {
    e3.rasterInfo || await e3.open({ signal: t7 }), this._primaryRasters = r3(e3), this.url || (this.url = this._primaryRasters[0].url);
  }
  async _openFromUrlWithRasterFunction(e3, t7, r6) {
    const i8 = [e3];
    t7 && w(t7.toJSON(), i8);
    const o6 = await Promise.all(i8.map((e4) => u7.open({ url: e4, sourceJSON: this.sourceJSON, ioConfig: { sampling: "closest", ...this.ioConfig, customFetchParameters: this.customParameters }, signal: r6 }))), a2 = o6.findIndex((e4) => null == e4);
    if (a2 > -1) throw new s("imagery-tile-layer:open", `cannot open raster: ${i8[a2]}`);
    return this._primaryRasters = o6, this._initializeWithFunctionRaster(t7);
  }
  async _openFromUrl(e3, t7) {
    const r6 = await u7.open({ url: e3, sourceJSON: this.sourceJSON, ioConfig: { sampling: "closest", ...this.ioConfig, customFetchParameters: this.customParameters }, signal: t7 });
    if (null == r6) throw new s("imagery-tile-layer:open", `cannot open raster: ${e3}`);
    this._primaryRasters = [r6], this.raster = r6;
  }
  async _openFromSource(e3, t7) {
    const r6 = "the tiled imagery data source is not supported", i8 = "coverage" === e3.type?.toLowerCase() ? "CovJSON" : e3.extent && e3.pixelBlock ? "MEMORY" : null;
    if (!i8) throw new s("imagery-tile-layer:open", r6);
    "MEMORY" === i8 && (e3 = { ...e3, pixelBlock: void 0, pixelBlocks: [e3.pixelBlock] });
    const o6 = await u7.open({ url: "", source: e3, datasetFormat: i8, ioConfig: { sampling: "closest", ...this.ioConfig, customFetchParameters: this.customParameters }, signal: t7 });
    if (null == o6) throw new s("imagery-tile-layer:open", r6);
    this._primaryRasters = [o6], this.rasterFunction ? await this._initializeWithFunctionRaster(this.rasterFunction) : this.raster = o6;
  }
  async _openFunctionRaster(e3, t7) {
    const r6 = { raster: this._primaryRasters[0] };
    this._primaryRasters.length > 1 && this._primaryRasters.forEach((e4) => r6[e4.url] = e4);
    const s7 = T(e3.functionDefinition?.toJSON() ?? e3.toJSON(), r6), i8 = new m5({ rasterFunction: s7 });
    return await i8.open(t7), i8;
  }
  async _initializeWithFunctionRaster(e3, t7) {
    try {
      this.raster = await this._openFunctionRaster(e3, t7);
    } catch (r6) {
      r6 instanceof s && i.getLogger(this).error("imagery-tile-layer:open", r6.message), i.getLogger(this).warn("imagery-tile-layer:open", "the raster function cannot be applied and is removed"), this._set("rasterFunction", null), this.raster = this._primaryRasters[0];
    }
  }
  _validateElevationInfo(e3) {
    j3(i.getLogger(this), $2("ImageryTile layers", "relative-to-scene", e3)), j3(i.getLogger(this), R("ImageryTile layers", e3));
  }
};
__decorate([m2({ clonable: false })], Y2.prototype, "_primaryRasters", void 0), __decorate([m2({ type: c3, value: null, json: { name: "layerDefinition.elevationInfo", write: true, origins: { "portal-item": { read: false, write: false }, "web-map": { read: false, write: false } } } })], Y2.prototype, "elevationInfo", null), __decorate([m2({ readOnly: true, clonable: false })], Y2.prototype, "graphicOrigin", void 0), __decorate([m2(d3)], Y2.prototype, "legendEnabled", void 0), __decorate([m2({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], Y2.prototype, "isReference", void 0), __decorate([m2({ type: ["show", "hide"] })], Y2.prototype, "listMode", void 0), __decorate([m2({ json: { read: true, write: true } })], Y2.prototype, "blendMode", void 0), __decorate([m2({ type: N3, json: { name: "renderingRule", write: true } })], Y2.prototype, "rasterFunction", void 0), __decorate([m2()], Y2.prototype, "sourceJSON", void 0), __decorate([m2({ readOnly: true, json: { origins: { service: { read: { source: "currentVersion" } } } } })], Y2.prototype, "version", void 0), __decorate([m2({ readOnly: true, json: { read: false } })], Y2.prototype, "type", void 0), __decorate([m2({ type: ["ArcGISTiledImageServiceLayer"] })], Y2.prototype, "operationalLayerType", void 0), __decorate([m2({ type: Boolean, value: true, json: { read: { source: "disablePopup", reader: (e3, t7) => !t7.disablePopup }, write: { target: "disablePopup", overridePolicy() {
  return { enabled: !this.loaded || "Raster" === this.raster.tileType };
}, writer(e3, t7, r6) {
  t7[r6] = !e3;
} } } })], Y2.prototype, "popupEnabled", void 0), __decorate([m2({ type: q, json: { read: { source: "popupInfo" }, write: { target: "popupInfo", overridePolicy() {
  return { enabled: !this.loaded || "Raster" === this.raster.tileType };
} } } })], Y2.prototype, "popupTemplate", void 0), __decorate([m2({ readOnly: true })], Y2.prototype, "defaultPopupTemplate", null), __decorate([m2(s5)], Y2.prototype, "screenSizePerspectiveEnabled", void 0), __decorate([m2({ readOnly: true, type: [m3] })], Y2.prototype, "fields", void 0), __decorate([m2({ readOnly: true, type: [m3] })], Y2.prototype, "rasterFields", null), __decorate([m2({ constructOnly: true })], Y2.prototype, "source", void 0), Y2 = __decorate([a("esri.layers.ImageryTileLayer")], Y2);
var q2 = Y2;
export {
  q2 as default
};
//# sourceMappingURL=ImageryTileLayer-IEQTVTBK.js.map
