import {
  o
} from "./chunk-233ALXRM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/chunks/lyr3DWorker.js
var e;
var t = { exports: {} };
function n() {
  return e || (e = 1, r = t, n2 = "undefined" != typeof document ? document.currentScript?.src : void 0, o3 = async function(r2 = {}) {
    var e2, t2, o4 = r2, a2 = "./this.program", i = (r3, e3) => {
      throw e3;
    }, s = "";
    function u(r3) {
      return o4.locateFile ? o4.locateFile(r3, s) : s + r3;
    }
    try {
      s = new URL(".", n2).href;
    } catch {
    }
    e2 = async (r3) => {
      var e3 = await fetch(r3, { credentials: "same-origin" });
      if (e3.ok) return e3.arrayBuffer();
      throw new Error(e3.status + " : " + e3.url);
    };
    var l, d, c, f, m, h, p, v, w, y, g, E, k, _, b = console.log.bind(console), F = console.error.bind(console), A = false, P = false;
    function S() {
      var r3 = f.buffer;
      m = new Int8Array(r3), p = new Int16Array(r3), o4.HEAPU8 = h = new Uint8Array(r3), v = new Uint16Array(r3), w = new Int32Array(r3), o4.HEAPU32 = y = new Uint32Array(r3), g = new Float32Array(r3), o4.HEAPF64 = E = new Float64Array(r3), k = new BigInt64Array(r3), _ = new BigUint64Array(r3);
    }
    function D() {
      if (o4.preRun) for ("function" == typeof o4.preRun && (o4.preRun = [o4.preRun]); o4.preRun.length; ) Y(o4.preRun.shift());
      H(G);
    }
    function T() {
      P = true, o4.noFSInit || Fr.initialized || Fr.init(), Gt._(), Fr.ignorePermissions = false;
    }
    function x() {
      if (o4.postRun) for ("function" == typeof o4.postRun && (o4.postRun = [o4.postRun]); o4.postRun.length; ) X(o4.postRun.shift());
      H(q);
    }
    var C, N = 0, M = null;
    function R(r3) {
      N++, o4.monitorRunDependencies?.(N);
    }
    function B(r3) {
      if (N--, o4.monitorRunDependencies?.(N), 0 == N && M) {
        var e3 = M;
        M = null, e3();
      }
    }
    function j(r3) {
      o4.onAbort?.(r3), F(r3 = "Aborted(" + r3 + ")"), A = true, r3 += ". Build with -sASSERTIONS for more info.";
      var e3 = new WebAssembly.RuntimeError(r3);
      throw c?.(e3), e3;
    }
    function W() {
      return u("lyr3DWorker.wasm");
    }
    function z(r3) {
      if (r3 == C && l) return new Uint8Array(l);
      throw "both async and sync fetching of the wasm failed";
    }
    async function O(r3) {
      if (!l) try {
        var t3 = await e2(r3);
        return new Uint8Array(t3);
      } catch {
      }
      return z(r3);
    }
    async function $(r3, e3) {
      try {
        var t3 = await O(r3);
        return await WebAssembly.instantiate(t3, e3);
      } catch (n3) {
        F(`failed to asynchronously prepare wasm: ${n3}`), j(n3);
      }
    }
    async function I(r3, e3, t3) {
      if (!r3 && "function" == typeof WebAssembly.instantiateStreaming) try {
        var n3 = fetch(e3, { credentials: "same-origin" });
        return await WebAssembly.instantiateStreaming(n3, t3);
      } catch (o5) {
        F(`wasm streaming compile failed: ${o5}`), F("falling back to ArrayBuffer instantiation");
      }
      return $(e3, t3);
    }
    function U() {
      return { a: Xt };
    }
    async function L() {
      function r3(r4, e4) {
        return Gt = r4.exports, f = Gt.Z, S(), se = Gt.aa, qt(Gt), B(), Gt;
      }
      function e3(e4) {
        return r3(e4.instance);
      }
      R();
      var t3 = U();
      return o4.instantiateWasm ? new Promise((e4, n3) => {
        o4.instantiateWasm(t3, (t4, n4) => {
          e4(r3(t4));
        });
      }) : (C ??= W(), e3(await I(l, C, t3)));
    }
    class V {
      name = "ExitStatus";
      constructor(r3) {
        this.message = `Program terminated with exit(${r3})`, this.status = r3;
      }
    }
    var H = (r3) => {
      for (; r3.length > 0; ) r3.shift()(o4);
    }, q = [], X = (r3) => q.push(r3), G = [], Y = (r3) => G.push(r3), K = true, J = (r3) => xt(r3), Q = () => Ct();
    class Z {
      constructor(r3) {
        this.excPtr = r3, this.ptr = r3 - 24;
      }
      set_type(r3) {
        y[this.ptr + 4 >> 2] = r3;
      }
      get_type() {
        return y[this.ptr + 4 >> 2];
      }
      set_destructor(r3) {
        y[this.ptr + 8 >> 2] = r3;
      }
      get_destructor() {
        return y[this.ptr + 8 >> 2];
      }
      set_caught(r3) {
        r3 = r3 ? 1 : 0, m[this.ptr + 12] = r3;
      }
      get_caught() {
        return 0 != m[this.ptr + 12];
      }
      set_rethrown(r3) {
        r3 = r3 ? 1 : 0, m[this.ptr + 13] = r3;
      }
      get_rethrown() {
        return 0 != m[this.ptr + 13];
      }
      init(r3, e3) {
        this.set_adjusted_ptr(0), this.set_type(r3), this.set_destructor(e3);
      }
      set_adjusted_ptr(r3) {
        y[this.ptr + 16 >> 2] = r3;
      }
      get_adjusted_ptr() {
        return y[this.ptr + 16 >> 2];
      }
    }
    var rr = (r3, e3, t3) => {
      throw new Z(r3).init(e3, t3), r3;
    }, er = () => {
      var r3 = w[+Pr.varargs >> 2];
      return Pr.varargs += 4, r3;
    }, tr = er, nr = { isAbs: (r3) => "/" === r3.charAt(0), splitPath: (r3) => /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/.exec(r3).slice(1), normalizeArray: (r3, e3) => {
      for (var t3 = 0, n3 = r3.length - 1; n3 >= 0; n3--) {
        var o5 = r3[n3];
        "." === o5 ? r3.splice(n3, 1) : ".." === o5 ? (r3.splice(n3, 1), t3++) : t3 && (r3.splice(n3, 1), t3--);
      }
      if (e3) for (; t3; t3--) r3.unshift("..");
      return r3;
    }, normalize: (r3) => {
      var e3 = nr.isAbs(r3), t3 = "/" === r3.slice(-1);
      return (r3 = nr.normalizeArray(r3.split("/").filter((r4) => !!r4), !e3).join("/")) || e3 || (r3 = "."), r3 && t3 && (r3 += "/"), (e3 ? "/" : "") + r3;
    }, dirname: (r3) => {
      var e3 = nr.splitPath(r3), t3 = e3[0], n3 = e3[1];
      return t3 || n3 ? (n3 && (n3 = n3.slice(0, -1)), t3 + n3) : ".";
    }, basename: (r3) => r3 && r3.match(/([^\/]+|\/)\/*$/)[1], join: (...r3) => nr.normalize(r3.join("/")), join2: (r3, e3) => nr.normalize(r3 + "/" + e3) }, or = () => (r3) => crypto.getRandomValues(r3), ar = (r3) => {
      (ar = or())(r3);
    }, ir = { resolve: (...r3) => {
      for (var e3 = "", t3 = false, n3 = r3.length - 1; n3 >= -1 && !t3; n3--) {
        var o5 = n3 >= 0 ? r3[n3] : Fr.cwd();
        if ("string" != typeof o5) throw new TypeError("Arguments to path.resolve must be strings");
        if (!o5) return "";
        e3 = o5 + "/" + e3, t3 = nr.isAbs(o5);
      }
      return (t3 ? "/" : "") + (e3 = nr.normalizeArray(e3.split("/").filter((r4) => !!r4), !t3).join("/")) || ".";
    }, relative: (r3, e3) => {
      function t3(r4) {
        for (var e4 = 0; e4 < r4.length && "" === r4[e4]; e4++) ;
        for (var t4 = r4.length - 1; t4 >= 0 && "" === r4[t4]; t4--) ;
        return e4 > t4 ? [] : r4.slice(e4, t4 - e4 + 1);
      }
      r3 = ir.resolve(r3).slice(1), e3 = ir.resolve(e3).slice(1);
      for (var n3 = t3(r3.split("/")), o5 = t3(e3.split("/")), a3 = Math.min(n3.length, o5.length), i2 = a3, s2 = 0; s2 < a3; s2++) if (n3[s2] !== o5[s2]) {
        i2 = s2;
        break;
      }
      var u2 = [];
      for (s2 = i2; s2 < n3.length; s2++) u2.push("..");
      return (u2 = u2.concat(o5.slice(i2))).join("/");
    } }, sr = "undefined" != typeof TextDecoder ? new TextDecoder() : void 0, ur = (r3, e3 = 0, t3 = NaN) => {
      for (var n3 = e3 + t3, o5 = e3; r3[o5] && !(o5 >= n3); ) ++o5;
      if (o5 - e3 > 16 && r3.buffer && sr) return sr.decode(r3.subarray(e3, o5));
      for (var a3 = ""; e3 < o5; ) {
        var i2 = r3[e3++];
        if (128 & i2) {
          var s2 = 63 & r3[e3++];
          if (192 != (224 & i2)) {
            var u2 = 63 & r3[e3++];
            if ((i2 = 224 == (240 & i2) ? (15 & i2) << 12 | s2 << 6 | u2 : (7 & i2) << 18 | s2 << 12 | u2 << 6 | 63 & r3[e3++]) < 65536) a3 += String.fromCharCode(i2);
            else {
              var l2 = i2 - 65536;
              a3 += String.fromCharCode(55296 | l2 >> 10, 56320 | 1023 & l2);
            }
          } else a3 += String.fromCharCode((31 & i2) << 6 | s2);
        } else a3 += String.fromCharCode(i2);
      }
      return a3;
    }, lr = [], dr = (r3) => {
      for (var e3 = 0, t3 = 0; t3 < r3.length; ++t3) {
        var n3 = r3.charCodeAt(t3);
        n3 <= 127 ? e3++ : n3 <= 2047 ? e3 += 2 : n3 >= 55296 && n3 <= 57343 ? (e3 += 4, ++t3) : e3 += 3;
      }
      return e3;
    }, cr = (r3, e3, t3, n3) => {
      if (!(n3 > 0)) return 0;
      for (var o5 = t3, a3 = t3 + n3 - 1, i2 = 0; i2 < r3.length; ++i2) {
        var s2 = r3.codePointAt(i2);
        if (s2 <= 127) {
          if (t3 >= a3) break;
          e3[t3++] = s2;
        } else if (s2 <= 2047) {
          if (t3 + 1 >= a3) break;
          e3[t3++] = 192 | s2 >> 6, e3[t3++] = 128 | 63 & s2;
        } else if (s2 <= 65535) {
          if (t3 + 2 >= a3) break;
          e3[t3++] = 224 | s2 >> 12, e3[t3++] = 128 | s2 >> 6 & 63, e3[t3++] = 128 | 63 & s2;
        } else {
          if (t3 + 3 >= a3) break;
          e3[t3++] = 240 | s2 >> 18, e3[t3++] = 128 | s2 >> 12 & 63, e3[t3++] = 128 | s2 >> 6 & 63, e3[t3++] = 128 | 63 & s2, i2++;
        }
      }
      return e3[t3] = 0, t3 - o5;
    }, fr = (r3, e3, t3) => {
      var n3 = dr(r3) + 1, o5 = new Array(n3), a3 = cr(r3, o5, 0, o5.length);
      return o5.length = a3, o5;
    }, mr = () => {
      if (!lr.length) {
        var r3 = null;
        if ("undefined" != typeof window && "function" == typeof window.prompt && null !== (r3 = window.prompt("Input: ")) && (r3 += "\n"), !r3) return null;
        lr = fr(r3);
      }
      return lr.shift();
    }, hr = { ttys: [], init() {
    }, shutdown() {
    }, register(r3, e3) {
      hr.ttys[r3] = { input: [], output: [], ops: e3 }, Fr.registerDevice(r3, hr.stream_ops);
    }, stream_ops: { open(r3) {
      var e3 = hr.ttys[r3.node.rdev];
      if (!e3) throw new Fr.ErrnoError(43);
      r3.tty = e3, r3.seekable = false;
    }, close(r3) {
      r3.tty.ops.fsync(r3.tty);
    }, fsync(r3) {
      r3.tty.ops.fsync(r3.tty);
    }, read(r3, e3, t3, n3, o5) {
      if (!r3.tty || !r3.tty.ops.get_char) throw new Fr.ErrnoError(60);
      for (var a3 = 0, i2 = 0; i2 < n3; i2++) {
        var s2;
        try {
          s2 = r3.tty.ops.get_char(r3.tty);
        } catch (u2) {
          throw new Fr.ErrnoError(29);
        }
        if (void 0 === s2 && 0 === a3) throw new Fr.ErrnoError(6);
        if (null == s2) break;
        a3++, e3[t3 + i2] = s2;
      }
      return a3 && (r3.node.atime = Date.now()), a3;
    }, write(r3, e3, t3, n3, o5) {
      if (!r3.tty || !r3.tty.ops.put_char) throw new Fr.ErrnoError(60);
      try {
        for (var a3 = 0; a3 < n3; a3++) r3.tty.ops.put_char(r3.tty, e3[t3 + a3]);
      } catch (i2) {
        throw new Fr.ErrnoError(29);
      }
      return n3 && (r3.node.mtime = r3.node.ctime = Date.now()), a3;
    } }, default_tty_ops: { get_char: (r3) => mr(), put_char(r3, e3) {
      null === e3 || 10 === e3 ? (b(ur(r3.output)), r3.output = []) : 0 != e3 && r3.output.push(e3);
    }, fsync(r3) {
      r3.output?.length > 0 && (b(ur(r3.output)), r3.output = []);
    }, ioctl_tcgets: (r3) => ({ c_iflag: 25856, c_oflag: 5, c_cflag: 191, c_lflag: 35387, c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }), ioctl_tcsets: (r3, e3, t3) => 0, ioctl_tiocgwinsz: (r3) => [24, 80] }, default_tty1_ops: { put_char(r3, e3) {
      null === e3 || 10 === e3 ? (F(ur(r3.output)), r3.output = []) : 0 != e3 && r3.output.push(e3);
    }, fsync(r3) {
      r3.output?.length > 0 && (F(ur(r3.output)), r3.output = []);
    } } }, pr = (r3) => {
      j();
    }, vr = { ops_table: null, mount: (r3) => vr.createNode(null, "/", 16895, 0), createNode(r3, e3, t3, n3) {
      if (Fr.isBlkdev(t3) || Fr.isFIFO(t3)) throw new Fr.ErrnoError(63);
      vr.ops_table ||= { dir: { node: { getattr: vr.node_ops.getattr, setattr: vr.node_ops.setattr, lookup: vr.node_ops.lookup, mknod: vr.node_ops.mknod, rename: vr.node_ops.rename, unlink: vr.node_ops.unlink, rmdir: vr.node_ops.rmdir, readdir: vr.node_ops.readdir, symlink: vr.node_ops.symlink }, stream: { llseek: vr.stream_ops.llseek } }, file: { node: { getattr: vr.node_ops.getattr, setattr: vr.node_ops.setattr }, stream: { llseek: vr.stream_ops.llseek, read: vr.stream_ops.read, write: vr.stream_ops.write, mmap: vr.stream_ops.mmap, msync: vr.stream_ops.msync } }, link: { node: { getattr: vr.node_ops.getattr, setattr: vr.node_ops.setattr, readlink: vr.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: vr.node_ops.getattr, setattr: vr.node_ops.setattr }, stream: Fr.chrdev_stream_ops } };
      var o5 = Fr.createNode(r3, e3, t3, n3);
      return Fr.isDir(o5.mode) ? (o5.node_ops = vr.ops_table.dir.node, o5.stream_ops = vr.ops_table.dir.stream, o5.contents = {}) : Fr.isFile(o5.mode) ? (o5.node_ops = vr.ops_table.file.node, o5.stream_ops = vr.ops_table.file.stream, o5.usedBytes = 0, o5.contents = null) : Fr.isLink(o5.mode) ? (o5.node_ops = vr.ops_table.link.node, o5.stream_ops = vr.ops_table.link.stream) : Fr.isChrdev(o5.mode) && (o5.node_ops = vr.ops_table.chrdev.node, o5.stream_ops = vr.ops_table.chrdev.stream), o5.atime = o5.mtime = o5.ctime = Date.now(), r3 && (r3.contents[e3] = o5, r3.atime = r3.mtime = r3.ctime = o5.atime), o5;
    }, getFileDataAsTypedArray: (r3) => r3.contents ? r3.contents.subarray ? r3.contents.subarray(0, r3.usedBytes) : new Uint8Array(r3.contents) : new Uint8Array(0), expandFileStorage(r3, e3) {
      var t3 = r3.contents ? r3.contents.length : 0;
      if (!(t3 >= e3)) {
        var n3 = 1048576;
        e3 = Math.max(e3, t3 * (t3 < n3 ? 2 : 1.125) >>> 0), 0 != t3 && (e3 = Math.max(e3, 256));
        var o5 = r3.contents;
        r3.contents = new Uint8Array(e3), r3.usedBytes > 0 && r3.contents.set(o5.subarray(0, r3.usedBytes), 0);
      }
    }, resizeFileStorage(r3, e3) {
      if (r3.usedBytes != e3) if (0 == e3) r3.contents = null, r3.usedBytes = 0;
      else {
        var t3 = r3.contents;
        r3.contents = new Uint8Array(e3), t3 && r3.contents.set(t3.subarray(0, Math.min(e3, r3.usedBytes))), r3.usedBytes = e3;
      }
    }, node_ops: { getattr(r3) {
      var e3 = {};
      return e3.dev = Fr.isChrdev(r3.mode) ? r3.id : 1, e3.ino = r3.id, e3.mode = r3.mode, e3.nlink = 1, e3.uid = 0, e3.gid = 0, e3.rdev = r3.rdev, Fr.isDir(r3.mode) ? e3.size = 4096 : Fr.isFile(r3.mode) ? e3.size = r3.usedBytes : Fr.isLink(r3.mode) ? e3.size = r3.link.length : e3.size = 0, e3.atime = new Date(r3.atime), e3.mtime = new Date(r3.mtime), e3.ctime = new Date(r3.ctime), e3.blksize = 4096, e3.blocks = Math.ceil(e3.size / e3.blksize), e3;
    }, setattr(r3, e3) {
      for (const t3 of ["mode", "atime", "mtime", "ctime"]) null != e3[t3] && (r3[t3] = e3[t3]);
      void 0 !== e3.size && vr.resizeFileStorage(r3, e3.size);
    }, lookup(r3, e3) {
      throw vr.doesNotExistError;
    }, mknod: (r3, e3, t3, n3) => vr.createNode(r3, e3, t3, n3), rename(r3, e3, t3) {
      var n3;
      try {
        n3 = Fr.lookupNode(e3, t3);
      } catch (a3) {
      }
      if (n3) {
        if (Fr.isDir(r3.mode)) for (var o5 in n3.contents) throw new Fr.ErrnoError(55);
        Fr.hashRemoveNode(n3);
      }
      delete r3.parent.contents[r3.name], e3.contents[t3] = r3, r3.name = t3, e3.ctime = e3.mtime = r3.parent.ctime = r3.parent.mtime = Date.now();
    }, unlink(r3, e3) {
      delete r3.contents[e3], r3.ctime = r3.mtime = Date.now();
    }, rmdir(r3, e3) {
      var t3 = Fr.lookupNode(r3, e3);
      for (var n3 in t3.contents) throw new Fr.ErrnoError(55);
      delete r3.contents[e3], r3.ctime = r3.mtime = Date.now();
    }, readdir: (r3) => [".", "..", ...Object.keys(r3.contents)], symlink(r3, e3, t3) {
      var n3 = vr.createNode(r3, e3, 41471, 0);
      return n3.link = t3, n3;
    }, readlink(r3) {
      if (!Fr.isLink(r3.mode)) throw new Fr.ErrnoError(28);
      return r3.link;
    } }, stream_ops: { read(r3, e3, t3, n3, o5) {
      var a3 = r3.node.contents;
      if (o5 >= r3.node.usedBytes) return 0;
      var i2 = Math.min(r3.node.usedBytes - o5, n3);
      if (i2 > 8 && a3.subarray) e3.set(a3.subarray(o5, o5 + i2), t3);
      else for (var s2 = 0; s2 < i2; s2++) e3[t3 + s2] = a3[o5 + s2];
      return i2;
    }, write(r3, e3, t3, n3, o5, a3) {
      if (e3.buffer === m.buffer && (a3 = false), !n3) return 0;
      var i2 = r3.node;
      if (i2.mtime = i2.ctime = Date.now(), e3.subarray && (!i2.contents || i2.contents.subarray)) {
        if (a3) return i2.contents = e3.subarray(t3, t3 + n3), i2.usedBytes = n3, n3;
        if (0 === i2.usedBytes && 0 === o5) return i2.contents = e3.slice(t3, t3 + n3), i2.usedBytes = n3, n3;
        if (o5 + n3 <= i2.usedBytes) return i2.contents.set(e3.subarray(t3, t3 + n3), o5), n3;
      }
      if (vr.expandFileStorage(i2, o5 + n3), i2.contents.subarray && e3.subarray) i2.contents.set(e3.subarray(t3, t3 + n3), o5);
      else for (var s2 = 0; s2 < n3; s2++) i2.contents[o5 + s2] = e3[t3 + s2];
      return i2.usedBytes = Math.max(i2.usedBytes, o5 + n3), n3;
    }, llseek(r3, e3, t3) {
      var n3 = e3;
      if (1 === t3 ? n3 += r3.position : 2 === t3 && Fr.isFile(r3.node.mode) && (n3 += r3.node.usedBytes), n3 < 0) throw new Fr.ErrnoError(28);
      return n3;
    }, mmap(r3, e3, t3, n3, o5) {
      if (!Fr.isFile(r3.node.mode)) throw new Fr.ErrnoError(43);
      var a3, i2, s2 = r3.node.contents;
      if (2 & o5 || !s2 || s2.buffer !== m.buffer) {
        if (i2 = true, !(a3 = pr())) throw new Fr.ErrnoError(48);
        s2 && ((t3 > 0 || t3 + e3 < s2.length) && (s2 = s2.subarray ? s2.subarray(t3, t3 + e3) : Array.prototype.slice.call(s2, t3, t3 + e3)), m.set(s2, a3));
      } else i2 = false, a3 = s2.byteOffset;
      return { ptr: a3, allocated: i2 };
    }, msync: (r3, e3, t3, n3, o5) => (vr.stream_ops.write(r3, e3, 0, n3, t3, false), 0) } }, wr = async (r3) => {
      var t3 = await e2(r3);
      return new Uint8Array(t3);
    }, yr = (...r3) => Fr.createDataFile(...r3), gr = [], Er = (r3, e3, t3, n3) => {
      "undefined" != typeof Browser && Browser.init();
      var o5 = false;
      return gr.forEach((a3) => {
        o5 || a3.canHandle(e3) && (a3.handle(r3, e3, t3, n3), o5 = true);
      }), o5;
    }, kr = (r3, e3, t3, n3, o5, a3, i2, s2, u2, l2) => {
      var d2 = e3 ? ir.resolve(nr.join2(r3, e3)) : r3;
      function c2(t4) {
        function c3(t5) {
          l2?.(), s2 || yr(r3, e3, t5, n3, o5, u2), a3?.(), B();
        }
        Er(t4, d2, c3, () => {
          i2?.(), B();
        }) || c3(t4);
      }
      R(), "string" == typeof t3 ? wr(t3).then(c2, i2) : c2(t3);
    }, _r = (r3) => {
      var e3 = { r: 0, "r+": 2, w: 577, "w+": 578, a: 1089, "a+": 1090 }[r3];
      if (void 0 === e3) throw new Error(`Unknown file open mode: ${r3}`);
      return e3;
    }, br = (r3, e3) => {
      var t3 = 0;
      return r3 && (t3 |= 365), e3 && (t3 |= 146), t3;
    }, Fr = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: false, ignorePermissions: true, filesystems: null, syncFSRequests: 0, readFiles: {}, ErrnoError: class {
      name = "ErrnoError";
      constructor(r3) {
        this.errno = r3;
      }
    }, FSStream: class {
      shared = {};
      get object() {
        return this.node;
      }
      set object(r3) {
        this.node = r3;
      }
      get isRead() {
        return 1 != (2097155 & this.flags);
      }
      get isWrite() {
        return !!(2097155 & this.flags);
      }
      get isAppend() {
        return 1024 & this.flags;
      }
      get flags() {
        return this.shared.flags;
      }
      set flags(r3) {
        this.shared.flags = r3;
      }
      get position() {
        return this.shared.position;
      }
      set position(r3) {
        this.shared.position = r3;
      }
    }, FSNode: class {
      node_ops = {};
      stream_ops = {};
      readMode = 365;
      writeMode = 146;
      mounted = null;
      constructor(r3, e3, t3, n3) {
        r3 || (r3 = this), this.parent = r3, this.mount = r3.mount, this.id = Fr.nextInode++, this.name = e3, this.mode = t3, this.rdev = n3, this.atime = this.mtime = this.ctime = Date.now();
      }
      get read() {
        return (this.mode & this.readMode) === this.readMode;
      }
      set read(r3) {
        r3 ? this.mode |= this.readMode : this.mode &= ~this.readMode;
      }
      get write() {
        return (this.mode & this.writeMode) === this.writeMode;
      }
      set write(r3) {
        r3 ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
      }
      get isFolder() {
        return Fr.isDir(this.mode);
      }
      get isDevice() {
        return Fr.isChrdev(this.mode);
      }
    }, lookupPath(r3, e3 = {}) {
      if (!r3) throw new Fr.ErrnoError(44);
      e3.follow_mount ??= true, nr.isAbs(r3) || (r3 = Fr.cwd() + "/" + r3);
      r: for (var t3 = 0; t3 < 40; t3++) {
        for (var n3 = r3.split("/").filter((r4) => !!r4), o5 = Fr.root, a3 = "/", i2 = 0; i2 < n3.length; i2++) {
          var s2 = i2 === n3.length - 1;
          if (s2 && e3.parent) break;
          if ("." !== n3[i2]) if (".." !== n3[i2]) {
            a3 = nr.join2(a3, n3[i2]);
            try {
              o5 = Fr.lookupNode(o5, n3[i2]);
            } catch (l2) {
              if (44 === l2?.errno && s2 && e3.noent_okay) return { path: a3 };
              throw l2;
            }
            if (!Fr.isMountpoint(o5) || s2 && !e3.follow_mount || (o5 = o5.mounted.root), Fr.isLink(o5.mode) && (!s2 || e3.follow)) {
              if (!o5.node_ops.readlink) throw new Fr.ErrnoError(52);
              var u2 = o5.node_ops.readlink(o5);
              nr.isAbs(u2) || (u2 = nr.dirname(a3) + "/" + u2), r3 = u2 + "/" + n3.slice(i2 + 1).join("/");
              continue r;
            }
          } else {
            if (a3 = nr.dirname(a3), Fr.isRoot(o5)) {
              r3 = a3 + "/" + n3.slice(i2 + 1).join("/");
              continue r;
            }
            o5 = o5.parent;
          }
        }
        return { path: a3, node: o5 };
      }
      throw new Fr.ErrnoError(32);
    }, getPath(r3) {
      for (var e3; ; ) {
        if (Fr.isRoot(r3)) {
          var t3 = r3.mount.mountpoint;
          return e3 ? "/" !== t3[t3.length - 1] ? `${t3}/${e3}` : t3 + e3 : t3;
        }
        e3 = e3 ? `${r3.name}/${e3}` : r3.name, r3 = r3.parent;
      }
    }, hashName(r3, e3) {
      for (var t3 = 0, n3 = 0; n3 < e3.length; n3++) t3 = (t3 << 5) - t3 + e3.charCodeAt(n3) | 0;
      return (r3 + t3 >>> 0) % Fr.nameTable.length;
    }, hashAddNode(r3) {
      var e3 = Fr.hashName(r3.parent.id, r3.name);
      r3.name_next = Fr.nameTable[e3], Fr.nameTable[e3] = r3;
    }, hashRemoveNode(r3) {
      var e3 = Fr.hashName(r3.parent.id, r3.name);
      if (Fr.nameTable[e3] === r3) Fr.nameTable[e3] = r3.name_next;
      else for (var t3 = Fr.nameTable[e3]; t3; ) {
        if (t3.name_next === r3) {
          t3.name_next = r3.name_next;
          break;
        }
        t3 = t3.name_next;
      }
    }, lookupNode(r3, e3) {
      var t3 = Fr.mayLookup(r3);
      if (t3) throw new Fr.ErrnoError(t3);
      for (var n3 = Fr.hashName(r3.id, e3), o5 = Fr.nameTable[n3]; o5; o5 = o5.name_next) {
        var a3 = o5.name;
        if (o5.parent.id === r3.id && a3 === e3) return o5;
      }
      return Fr.lookup(r3, e3);
    }, createNode(r3, e3, t3, n3) {
      var o5 = new Fr.FSNode(r3, e3, t3, n3);
      return Fr.hashAddNode(o5), o5;
    }, destroyNode(r3) {
      Fr.hashRemoveNode(r3);
    }, isRoot: (r3) => r3 === r3.parent, isMountpoint: (r3) => !!r3.mounted, isFile: (r3) => 32768 == (61440 & r3), isDir: (r3) => 16384 == (61440 & r3), isLink: (r3) => 40960 == (61440 & r3), isChrdev: (r3) => 8192 == (61440 & r3), isBlkdev: (r3) => 24576 == (61440 & r3), isFIFO: (r3) => 4096 == (61440 & r3), isSocket: (r3) => !(49152 & ~r3), flagsToPermissionString(r3) {
      var e3 = ["r", "w", "rw"][3 & r3];
      return 512 & r3 && (e3 += "w"), e3;
    }, nodePermissions: (r3, e3) => Fr.ignorePermissions || (!e3.includes("r") || 292 & r3.mode) && (!e3.includes("w") || 146 & r3.mode) && (!e3.includes("x") || 73 & r3.mode) ? 0 : 2, mayLookup(r3) {
      if (!Fr.isDir(r3.mode)) return 54;
      var e3 = Fr.nodePermissions(r3, "x");
      return e3 || (r3.node_ops.lookup ? 0 : 2);
    }, mayCreate(r3, e3) {
      if (!Fr.isDir(r3.mode)) return 54;
      try {
        return Fr.lookupNode(r3, e3), 20;
      } catch (t3) {
      }
      return Fr.nodePermissions(r3, "wx");
    }, mayDelete(r3, e3, t3) {
      var n3;
      try {
        n3 = Fr.lookupNode(r3, e3);
      } catch (a3) {
        return a3.errno;
      }
      var o5 = Fr.nodePermissions(r3, "wx");
      if (o5) return o5;
      if (t3) {
        if (!Fr.isDir(n3.mode)) return 54;
        if (Fr.isRoot(n3) || Fr.getPath(n3) === Fr.cwd()) return 10;
      } else if (Fr.isDir(n3.mode)) return 31;
      return 0;
    }, mayOpen: (r3, e3) => r3 ? Fr.isLink(r3.mode) ? 32 : Fr.isDir(r3.mode) && ("r" !== Fr.flagsToPermissionString(e3) || 576 & e3) ? 31 : Fr.nodePermissions(r3, Fr.flagsToPermissionString(e3)) : 44, checkOpExists(r3, e3) {
      if (!r3) throw new Fr.ErrnoError(e3);
      return r3;
    }, MAX_OPEN_FDS: 4096, nextfd() {
      for (var r3 = 0; r3 <= Fr.MAX_OPEN_FDS; r3++) if (!Fr.streams[r3]) return r3;
      throw new Fr.ErrnoError(33);
    }, getStreamChecked(r3) {
      var e3 = Fr.getStream(r3);
      if (!e3) throw new Fr.ErrnoError(8);
      return e3;
    }, getStream: (r3) => Fr.streams[r3], createStream: (r3, e3 = -1) => (r3 = Object.assign(new Fr.FSStream(), r3), -1 == e3 && (e3 = Fr.nextfd()), r3.fd = e3, Fr.streams[e3] = r3, r3), closeStream(r3) {
      Fr.streams[r3] = null;
    }, dupStream(r3, e3 = -1) {
      var t3 = Fr.createStream(r3, e3);
      return t3.stream_ops?.dup?.(t3), t3;
    }, doSetAttr(r3, e3, t3) {
      var n3 = r3?.stream_ops.setattr, o5 = n3 ? r3 : e3;
      n3 ??= e3.node_ops.setattr, Fr.checkOpExists(n3, 63), n3(o5, t3);
    }, chrdev_stream_ops: { open(r3) {
      var e3 = Fr.getDevice(r3.node.rdev);
      r3.stream_ops = e3.stream_ops, r3.stream_ops.open?.(r3);
    }, llseek() {
      throw new Fr.ErrnoError(70);
    } }, major: (r3) => r3 >> 8, minor: (r3) => 255 & r3, makedev: (r3, e3) => r3 << 8 | e3, registerDevice(r3, e3) {
      Fr.devices[r3] = { stream_ops: e3 };
    }, getDevice: (r3) => Fr.devices[r3], getMounts(r3) {
      for (var e3 = [], t3 = [r3]; t3.length; ) {
        var n3 = t3.pop();
        e3.push(n3), t3.push(...n3.mounts);
      }
      return e3;
    }, syncfs(r3, e3) {
      "function" == typeof r3 && (e3 = r3, r3 = false), Fr.syncFSRequests++, Fr.syncFSRequests > 1 && F(`warning: ${Fr.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
      var t3 = Fr.getMounts(Fr.root.mount), n3 = 0;
      function o5(r4) {
        return Fr.syncFSRequests--, e3(r4);
      }
      function a3(r4) {
        if (r4) return a3.errored ? void 0 : (a3.errored = true, o5(r4));
        ++n3 >= t3.length && o5(null);
      }
      t3.forEach((e4) => {
        if (!e4.type.syncfs) return a3(null);
        e4.type.syncfs(e4, r3, a3);
      });
    }, mount(r3, e3, t3) {
      var n3, o5 = "/" === t3, a3 = !t3;
      if (o5 && Fr.root) throw new Fr.ErrnoError(10);
      if (!o5 && !a3) {
        var i2 = Fr.lookupPath(t3, { follow_mount: false });
        if (t3 = i2.path, n3 = i2.node, Fr.isMountpoint(n3)) throw new Fr.ErrnoError(10);
        if (!Fr.isDir(n3.mode)) throw new Fr.ErrnoError(54);
      }
      var s2 = { type: r3, opts: e3, mountpoint: t3, mounts: [] }, u2 = r3.mount(s2);
      return u2.mount = s2, s2.root = u2, o5 ? Fr.root = u2 : n3 && (n3.mounted = s2, n3.mount && n3.mount.mounts.push(s2)), u2;
    }, unmount(r3) {
      var e3 = Fr.lookupPath(r3, { follow_mount: false });
      if (!Fr.isMountpoint(e3.node)) throw new Fr.ErrnoError(28);
      var t3 = e3.node, n3 = t3.mounted, o5 = Fr.getMounts(n3);
      Object.keys(Fr.nameTable).forEach((r4) => {
        for (var e4 = Fr.nameTable[r4]; e4; ) {
          var t4 = e4.name_next;
          o5.includes(e4.mount) && Fr.destroyNode(e4), e4 = t4;
        }
      }), t3.mounted = null;
      var a3 = t3.mount.mounts.indexOf(n3);
      t3.mount.mounts.splice(a3, 1);
    }, lookup: (r3, e3) => r3.node_ops.lookup(r3, e3), mknod(r3, e3, t3) {
      var n3 = Fr.lookupPath(r3, { parent: true }).node, o5 = nr.basename(r3);
      if (!o5) throw new Fr.ErrnoError(28);
      if ("." === o5 || ".." === o5) throw new Fr.ErrnoError(20);
      var a3 = Fr.mayCreate(n3, o5);
      if (a3) throw new Fr.ErrnoError(a3);
      if (!n3.node_ops.mknod) throw new Fr.ErrnoError(63);
      return n3.node_ops.mknod(n3, o5, e3, t3);
    }, statfs: (r3) => Fr.statfsNode(Fr.lookupPath(r3, { follow: true }).node), statfsStream: (r3) => Fr.statfsNode(r3.node), statfsNode(r3) {
      var e3 = { bsize: 4096, frsize: 4096, blocks: 1e6, bfree: 5e5, bavail: 5e5, files: Fr.nextInode, ffree: Fr.nextInode - 1, fsid: 42, flags: 2, namelen: 255 };
      return r3.node_ops.statfs && Object.assign(e3, r3.node_ops.statfs(r3.mount.opts.root)), e3;
    }, create: (r3, e3 = 438) => (e3 &= 4095, e3 |= 32768, Fr.mknod(r3, e3, 0)), mkdir: (r3, e3 = 511) => (e3 &= 1023, e3 |= 16384, Fr.mknod(r3, e3, 0)), mkdirTree(r3, e3) {
      var t3 = r3.split("/"), n3 = "";
      for (var o5 of t3) if (o5) {
        (n3 || nr.isAbs(r3)) && (n3 += "/"), n3 += o5;
        try {
          Fr.mkdir(n3, e3);
        } catch (a3) {
          if (20 != a3.errno) throw a3;
        }
      }
    }, mkdev: (r3, e3, t3) => (void 0 === t3 && (t3 = e3, e3 = 438), e3 |= 8192, Fr.mknod(r3, e3, t3)), symlink(r3, e3) {
      if (!ir.resolve(r3)) throw new Fr.ErrnoError(44);
      var t3 = Fr.lookupPath(e3, { parent: true }).node;
      if (!t3) throw new Fr.ErrnoError(44);
      var n3 = nr.basename(e3), o5 = Fr.mayCreate(t3, n3);
      if (o5) throw new Fr.ErrnoError(o5);
      if (!t3.node_ops.symlink) throw new Fr.ErrnoError(63);
      return t3.node_ops.symlink(t3, n3, r3);
    }, rename(r3, e3) {
      var t3, n3, o5 = nr.dirname(r3), a3 = nr.dirname(e3), i2 = nr.basename(r3), s2 = nr.basename(e3);
      if (t3 = Fr.lookupPath(r3, { parent: true }).node, n3 = Fr.lookupPath(e3, { parent: true }).node, !t3 || !n3) throw new Fr.ErrnoError(44);
      if (t3.mount !== n3.mount) throw new Fr.ErrnoError(75);
      var u2, l2 = Fr.lookupNode(t3, i2), d2 = ir.relative(r3, a3);
      if ("." !== d2.charAt(0)) throw new Fr.ErrnoError(28);
      if ("." !== (d2 = ir.relative(e3, o5)).charAt(0)) throw new Fr.ErrnoError(55);
      try {
        u2 = Fr.lookupNode(n3, s2);
      } catch (m2) {
      }
      if (l2 !== u2) {
        var c2 = Fr.isDir(l2.mode), f2 = Fr.mayDelete(t3, i2, c2);
        if (f2) throw new Fr.ErrnoError(f2);
        if (f2 = u2 ? Fr.mayDelete(n3, s2, c2) : Fr.mayCreate(n3, s2)) throw new Fr.ErrnoError(f2);
        if (!t3.node_ops.rename) throw new Fr.ErrnoError(63);
        if (Fr.isMountpoint(l2) || u2 && Fr.isMountpoint(u2)) throw new Fr.ErrnoError(10);
        if (n3 !== t3 && (f2 = Fr.nodePermissions(t3, "w"))) throw new Fr.ErrnoError(f2);
        Fr.hashRemoveNode(l2);
        try {
          t3.node_ops.rename(l2, n3, s2), l2.parent = n3;
        } catch (m2) {
          throw m2;
        } finally {
          Fr.hashAddNode(l2);
        }
      }
    }, rmdir(r3) {
      var e3 = Fr.lookupPath(r3, { parent: true }).node, t3 = nr.basename(r3), n3 = Fr.lookupNode(e3, t3), o5 = Fr.mayDelete(e3, t3, true);
      if (o5) throw new Fr.ErrnoError(o5);
      if (!e3.node_ops.rmdir) throw new Fr.ErrnoError(63);
      if (Fr.isMountpoint(n3)) throw new Fr.ErrnoError(10);
      e3.node_ops.rmdir(e3, t3), Fr.destroyNode(n3);
    }, readdir(r3) {
      var e3 = Fr.lookupPath(r3, { follow: true }).node;
      return Fr.checkOpExists(e3.node_ops.readdir, 54)(e3);
    }, unlink(r3) {
      var e3 = Fr.lookupPath(r3, { parent: true }).node;
      if (!e3) throw new Fr.ErrnoError(44);
      var t3 = nr.basename(r3), n3 = Fr.lookupNode(e3, t3), o5 = Fr.mayDelete(e3, t3, false);
      if (o5) throw new Fr.ErrnoError(o5);
      if (!e3.node_ops.unlink) throw new Fr.ErrnoError(63);
      if (Fr.isMountpoint(n3)) throw new Fr.ErrnoError(10);
      e3.node_ops.unlink(e3, t3), Fr.destroyNode(n3);
    }, readlink(r3) {
      var e3 = Fr.lookupPath(r3).node;
      if (!e3) throw new Fr.ErrnoError(44);
      if (!e3.node_ops.readlink) throw new Fr.ErrnoError(28);
      return e3.node_ops.readlink(e3);
    }, stat(r3, e3) {
      var t3 = Fr.lookupPath(r3, { follow: !e3 }).node;
      return Fr.checkOpExists(t3.node_ops.getattr, 63)(t3);
    }, fstat(r3) {
      var e3 = Fr.getStreamChecked(r3), t3 = e3.node, n3 = e3.stream_ops.getattr, o5 = n3 ? e3 : t3;
      return n3 ??= t3.node_ops.getattr, Fr.checkOpExists(n3, 63), n3(o5);
    }, lstat: (r3) => Fr.stat(r3, true), doChmod(r3, e3, t3, n3) {
      Fr.doSetAttr(r3, e3, { mode: 4095 & t3 | -4096 & e3.mode, ctime: Date.now(), dontFollow: n3 });
    }, chmod(r3, e3, t3) {
      var n3;
      n3 = "string" == typeof r3 ? Fr.lookupPath(r3, { follow: !t3 }).node : r3, Fr.doChmod(null, n3, e3, t3);
    }, lchmod(r3, e3) {
      Fr.chmod(r3, e3, true);
    }, fchmod(r3, e3) {
      var t3 = Fr.getStreamChecked(r3);
      Fr.doChmod(t3, t3.node, e3, false);
    }, doChown(r3, e3, t3) {
      Fr.doSetAttr(r3, e3, { timestamp: Date.now(), dontFollow: t3 });
    }, chown(r3, e3, t3, n3) {
      var o5;
      o5 = "string" == typeof r3 ? Fr.lookupPath(r3, { follow: !n3 }).node : r3, Fr.doChown(null, o5, n3);
    }, lchown(r3, e3, t3) {
      Fr.chown(r3, e3, t3, true);
    }, fchown(r3, e3, t3) {
      var n3 = Fr.getStreamChecked(r3);
      Fr.doChown(n3, n3.node, false);
    }, doTruncate(r3, e3, t3) {
      if (Fr.isDir(e3.mode)) throw new Fr.ErrnoError(31);
      if (!Fr.isFile(e3.mode)) throw new Fr.ErrnoError(28);
      var n3 = Fr.nodePermissions(e3, "w");
      if (n3) throw new Fr.ErrnoError(n3);
      Fr.doSetAttr(r3, e3, { size: t3, timestamp: Date.now() });
    }, truncate(r3, e3) {
      if (e3 < 0) throw new Fr.ErrnoError(28);
      var t3;
      t3 = "string" == typeof r3 ? Fr.lookupPath(r3, { follow: true }).node : r3, Fr.doTruncate(null, t3, e3);
    }, ftruncate(r3, e3) {
      var t3 = Fr.getStreamChecked(r3);
      if (e3 < 0 || !(2097155 & t3.flags)) throw new Fr.ErrnoError(28);
      Fr.doTruncate(t3, t3.node, e3);
    }, utime(r3, e3, t3) {
      var n3 = Fr.lookupPath(r3, { follow: true }).node;
      Fr.checkOpExists(n3.node_ops.setattr, 63)(n3, { atime: e3, mtime: t3 });
    }, open(r3, e3, t3 = 438) {
      if ("" === r3) throw new Fr.ErrnoError(44);
      var n3, a3;
      if (t3 = 64 & (e3 = "string" == typeof e3 ? _r(e3) : e3) ? 4095 & t3 | 32768 : 0, "object" == typeof r3) n3 = r3;
      else {
        a3 = r3.endsWith("/");
        var i2 = Fr.lookupPath(r3, { follow: !(131072 & e3), noent_okay: true });
        n3 = i2.node, r3 = i2.path;
      }
      var s2 = false;
      if (64 & e3) if (n3) {
        if (128 & e3) throw new Fr.ErrnoError(20);
      } else {
        if (a3) throw new Fr.ErrnoError(31);
        n3 = Fr.mknod(r3, 511 | t3, 0), s2 = true;
      }
      if (!n3) throw new Fr.ErrnoError(44);
      if (Fr.isChrdev(n3.mode) && (e3 &= -513), 65536 & e3 && !Fr.isDir(n3.mode)) throw new Fr.ErrnoError(54);
      if (!s2) {
        var u2 = Fr.mayOpen(n3, e3);
        if (u2) throw new Fr.ErrnoError(u2);
      }
      512 & e3 && !s2 && Fr.truncate(n3, 0), e3 &= -131713;
      var l2 = Fr.createStream({ node: n3, path: Fr.getPath(n3), flags: e3, seekable: true, position: 0, stream_ops: n3.stream_ops, ungotten: [], error: false });
      return l2.stream_ops.open && l2.stream_ops.open(l2), s2 && Fr.chmod(n3, 511 & t3), !o4.logReadFiles || 1 & e3 || r3 in Fr.readFiles || (Fr.readFiles[r3] = 1), l2;
    }, close(r3) {
      if (Fr.isClosed(r3)) throw new Fr.ErrnoError(8);
      r3.getdents && (r3.getdents = null);
      try {
        r3.stream_ops.close && r3.stream_ops.close(r3);
      } catch (e3) {
        throw e3;
      } finally {
        Fr.closeStream(r3.fd);
      }
      r3.fd = null;
    }, isClosed: (r3) => null === r3.fd, llseek(r3, e3, t3) {
      if (Fr.isClosed(r3)) throw new Fr.ErrnoError(8);
      if (!r3.seekable || !r3.stream_ops.llseek) throw new Fr.ErrnoError(70);
      if (0 != t3 && 1 != t3 && 2 != t3) throw new Fr.ErrnoError(28);
      return r3.position = r3.stream_ops.llseek(r3, e3, t3), r3.ungotten = [], r3.position;
    }, read(r3, e3, t3, n3, o5) {
      if (n3 < 0 || o5 < 0) throw new Fr.ErrnoError(28);
      if (Fr.isClosed(r3)) throw new Fr.ErrnoError(8);
      if (1 == (2097155 & r3.flags)) throw new Fr.ErrnoError(8);
      if (Fr.isDir(r3.node.mode)) throw new Fr.ErrnoError(31);
      if (!r3.stream_ops.read) throw new Fr.ErrnoError(28);
      var a3 = void 0 !== o5;
      if (a3) {
        if (!r3.seekable) throw new Fr.ErrnoError(70);
      } else o5 = r3.position;
      var i2 = r3.stream_ops.read(r3, e3, t3, n3, o5);
      return a3 || (r3.position += i2), i2;
    }, write(r3, e3, t3, n3, o5, a3) {
      if (n3 < 0 || o5 < 0) throw new Fr.ErrnoError(28);
      if (Fr.isClosed(r3)) throw new Fr.ErrnoError(8);
      if (!(2097155 & r3.flags)) throw new Fr.ErrnoError(8);
      if (Fr.isDir(r3.node.mode)) throw new Fr.ErrnoError(31);
      if (!r3.stream_ops.write) throw new Fr.ErrnoError(28);
      r3.seekable && 1024 & r3.flags && Fr.llseek(r3, 0, 2);
      var i2 = void 0 !== o5;
      if (i2) {
        if (!r3.seekable) throw new Fr.ErrnoError(70);
      } else o5 = r3.position;
      var s2 = r3.stream_ops.write(r3, e3, t3, n3, o5, a3);
      return i2 || (r3.position += s2), s2;
    }, mmap(r3, e3, t3, n3, o5) {
      if (2 & n3 && !(2 & o5) && 2 != (2097155 & r3.flags)) throw new Fr.ErrnoError(2);
      if (1 == (2097155 & r3.flags)) throw new Fr.ErrnoError(2);
      if (!r3.stream_ops.mmap) throw new Fr.ErrnoError(43);
      if (!e3) throw new Fr.ErrnoError(28);
      return r3.stream_ops.mmap(r3, e3, t3, n3, o5);
    }, msync: (r3, e3, t3, n3, o5) => r3.stream_ops.msync ? r3.stream_ops.msync(r3, e3, t3, n3, o5) : 0, ioctl(r3, e3, t3) {
      if (!r3.stream_ops.ioctl) throw new Fr.ErrnoError(59);
      return r3.stream_ops.ioctl(r3, e3, t3);
    }, readFile(r3, e3 = {}) {
      if (e3.flags = e3.flags || 0, e3.encoding = e3.encoding || "binary", "utf8" !== e3.encoding && "binary" !== e3.encoding) throw new Error(`Invalid encoding type "${e3.encoding}"`);
      var t3 = Fr.open(r3, e3.flags), n3 = Fr.stat(r3).size, o5 = new Uint8Array(n3);
      return Fr.read(t3, o5, 0, n3, 0), "utf8" === e3.encoding && (o5 = ur(o5)), Fr.close(t3), o5;
    }, writeFile(r3, e3, t3 = {}) {
      t3.flags = t3.flags || 577;
      var n3 = Fr.open(r3, t3.flags, t3.mode);
      if ("string" == typeof e3 && (e3 = new Uint8Array(fr(e3))), !ArrayBuffer.isView(e3)) throw new Error("Unsupported data type");
      Fr.write(n3, e3, 0, e3.byteLength, void 0, t3.canOwn), Fr.close(n3);
    }, cwd: () => Fr.currentPath, chdir(r3) {
      var e3 = Fr.lookupPath(r3, { follow: true });
      if (null === e3.node) throw new Fr.ErrnoError(44);
      if (!Fr.isDir(e3.node.mode)) throw new Fr.ErrnoError(54);
      var t3 = Fr.nodePermissions(e3.node, "x");
      if (t3) throw new Fr.ErrnoError(t3);
      Fr.currentPath = e3.path;
    }, createDefaultDirectories() {
      Fr.mkdir("/tmp"), Fr.mkdir("/home"), Fr.mkdir("/home/web_user");
    }, createDefaultDevices() {
      Fr.mkdir("/dev"), Fr.registerDevice(Fr.makedev(1, 3), { read: () => 0, write: (r4, e4, t4, n3, o5) => n3, llseek: () => 0 }), Fr.mkdev("/dev/null", Fr.makedev(1, 3)), hr.register(Fr.makedev(5, 0), hr.default_tty_ops), hr.register(Fr.makedev(6, 0), hr.default_tty1_ops), Fr.mkdev("/dev/tty", Fr.makedev(5, 0)), Fr.mkdev("/dev/tty1", Fr.makedev(6, 0));
      var r3 = new Uint8Array(1024), e3 = 0, t3 = () => (0 === e3 && (ar(r3), e3 = r3.byteLength), r3[--e3]);
      Fr.createDevice("/dev", "random", t3), Fr.createDevice("/dev", "urandom", t3), Fr.mkdir("/dev/shm"), Fr.mkdir("/dev/shm/tmp");
    }, createSpecialDirectories() {
      Fr.mkdir("/proc");
      var r3 = Fr.mkdir("/proc/self");
      Fr.mkdir("/proc/self/fd"), Fr.mount({ mount() {
        var e3 = Fr.createNode(r3, "fd", 16895, 73);
        return e3.stream_ops = { llseek: vr.stream_ops.llseek }, e3.node_ops = { lookup(r4, e4) {
          var t3 = +e4, n3 = Fr.getStreamChecked(t3), o5 = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: () => n3.path }, id: t3 + 1 };
          return o5.parent = o5, o5;
        }, readdir: () => Array.from(Fr.streams.entries()).filter(([r4, e4]) => e4).map(([r4, e4]) => r4.toString()) }, e3;
      } }, {}, "/proc/self/fd");
    }, createStandardStreams(r3, e3, t3) {
      r3 ? Fr.createDevice("/dev", "stdin", r3) : Fr.symlink("/dev/tty", "/dev/stdin"), e3 ? Fr.createDevice("/dev", "stdout", null, e3) : Fr.symlink("/dev/tty", "/dev/stdout"), t3 ? Fr.createDevice("/dev", "stderr", null, t3) : Fr.symlink("/dev/tty1", "/dev/stderr"), Fr.open("/dev/stdin", 0), Fr.open("/dev/stdout", 1), Fr.open("/dev/stderr", 1);
    }, staticInit() {
      Fr.nameTable = new Array(4096), Fr.mount(vr, {}, "/"), Fr.createDefaultDirectories(), Fr.createDefaultDevices(), Fr.createSpecialDirectories(), Fr.filesystems = { MEMFS: vr };
    }, init(r3, e3, t3) {
      Fr.initialized = true, r3 ??= o4.stdin, e3 ??= o4.stdout, t3 ??= o4.stderr, Fr.createStandardStreams(r3, e3, t3);
    }, quit() {
      for (var r3 of (Fr.initialized = false, Fr.streams)) r3 && Fr.close(r3);
    }, findObject(r3, e3) {
      var t3 = Fr.analyzePath(r3, e3);
      return t3.exists ? t3.object : null;
    }, analyzePath(r3, e3) {
      try {
        r3 = (n3 = Fr.lookupPath(r3, { follow: !e3 })).path;
      } catch (o5) {
      }
      var t3 = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null };
      try {
        var n3 = Fr.lookupPath(r3, { parent: true });
        t3.parentExists = true, t3.parentPath = n3.path, t3.parentObject = n3.node, t3.name = nr.basename(r3), n3 = Fr.lookupPath(r3, { follow: !e3 }), t3.exists = true, t3.path = n3.path, t3.object = n3.node, t3.name = n3.node.name, t3.isRoot = "/" === n3.path;
      } catch (o5) {
        t3.error = o5.errno;
      }
      return t3;
    }, createPath(r3, e3, t3, n3) {
      r3 = "string" == typeof r3 ? r3 : Fr.getPath(r3);
      for (var o5 = e3.split("/").reverse(); o5.length; ) {
        var a3 = o5.pop();
        if (a3) {
          var i2 = nr.join2(r3, a3);
          try {
            Fr.mkdir(i2);
          } catch (s2) {
            if (20 != s2.errno) throw s2;
          }
          r3 = i2;
        }
      }
      return i2;
    }, createFile(r3, e3, t3, n3, o5) {
      var a3 = nr.join2("string" == typeof r3 ? r3 : Fr.getPath(r3), e3), i2 = br(n3, o5);
      return Fr.create(a3, i2);
    }, createDataFile(r3, e3, t3, n3, o5, a3) {
      var i2 = e3;
      r3 && (r3 = "string" == typeof r3 ? r3 : Fr.getPath(r3), i2 = e3 ? nr.join2(r3, e3) : r3);
      var s2 = br(n3, o5), u2 = Fr.create(i2, s2);
      if (t3) {
        if ("string" == typeof t3) {
          for (var l2 = new Array(t3.length), d2 = 0, c2 = t3.length; d2 < c2; ++d2) l2[d2] = t3.charCodeAt(d2);
          t3 = l2;
        }
        Fr.chmod(u2, 146 | s2);
        var f2 = Fr.open(u2, 577);
        Fr.write(f2, t3, 0, t3.length, 0, a3), Fr.close(f2), Fr.chmod(u2, s2);
      }
    }, createDevice(r3, e3, t3, n3) {
      var o5 = nr.join2("string" == typeof r3 ? r3 : Fr.getPath(r3), e3), a3 = br(!!t3, !!n3);
      Fr.createDevice.major ??= 64;
      var i2 = Fr.makedev(Fr.createDevice.major++, 0);
      return Fr.registerDevice(i2, { open(r4) {
        r4.seekable = false;
      }, close(r4) {
        n3?.buffer?.length && n3(10);
      }, read(r4, e4, n4, o6, a4) {
        for (var i3 = 0, s2 = 0; s2 < o6; s2++) {
          var u2;
          try {
            u2 = t3();
          } catch (l2) {
            throw new Fr.ErrnoError(29);
          }
          if (void 0 === u2 && 0 === i3) throw new Fr.ErrnoError(6);
          if (null == u2) break;
          i3++, e4[n4 + s2] = u2;
        }
        return i3 && (r4.node.atime = Date.now()), i3;
      }, write(r4, e4, t4, o6, a4) {
        for (var i3 = 0; i3 < o6; i3++) try {
          n3(e4[t4 + i3]);
        } catch (s2) {
          throw new Fr.ErrnoError(29);
        }
        return o6 && (r4.node.mtime = r4.node.ctime = Date.now()), i3;
      } }), Fr.mkdev(o5, a3, i2);
    }, forceLoadFile(r3) {
      if (r3.isDevice || r3.isFolder || r3.link || r3.contents) return true;
      if ("undefined" != typeof XMLHttpRequest) throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
      try {
        r3.contents = t2(r3.url), r3.usedBytes = r3.contents.length;
      } catch (e3) {
        throw new Fr.ErrnoError(29);
      }
    }, createLazyFile(r3, e3, t3, n3, o5) {
      if ("undefined" != typeof XMLHttpRequest) throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
      var a3 = { isDevice: false, url: t3 }, i2 = Fr.createFile(r3, e3, a3, n3, o5);
      a3.contents ? i2.contents = a3.contents : a3.url && (i2.contents = null, i2.url = a3.url), Object.defineProperties(i2, { usedBytes: { get: function() {
        return this.contents.length;
      } } });
      var s2 = {};
      function u2(r4, e4, t4, n4, o6) {
        var a4 = r4.node.contents;
        if (o6 >= a4.length) return 0;
        var i3 = Math.min(a4.length - o6, n4);
        if (a4.slice) for (var s3 = 0; s3 < i3; s3++) e4[t4 + s3] = a4[o6 + s3];
        else for (s3 = 0; s3 < i3; s3++) e4[t4 + s3] = a4.get(o6 + s3);
        return i3;
      }
      return Object.keys(i2.stream_ops).forEach((r4) => {
        var e4 = i2.stream_ops[r4];
        s2[r4] = (...r5) => (Fr.forceLoadFile(i2), e4(...r5));
      }), s2.read = (r4, e4, t4, n4, o6) => (Fr.forceLoadFile(i2), u2(r4, e4, t4, n4, o6)), s2.mmap = (r4, e4, t4, n4, o6) => {
        Fr.forceLoadFile(i2);
        var a4 = pr();
        if (!a4) throw new Fr.ErrnoError(48);
        return u2(r4, m, a4, e4, t4), { ptr: a4, allocated: true };
      }, i2.stream_ops = s2, i2;
    } }, Ar = (r3, e3) => r3 ? ur(h, r3, e3) : "", Pr = { DEFAULT_POLLMASK: 5, calculateAt(r3, e3, t3) {
      if (nr.isAbs(e3)) return e3;
      var n3;
      if (n3 = -100 === r3 ? Fr.cwd() : Pr.getStreamFromFD(r3).path, 0 == e3.length) {
        if (!t3) throw new Fr.ErrnoError(44);
        return n3;
      }
      return n3 + "/" + e3;
    }, writeStat(r3, e3) {
      w[r3 >> 2] = e3.dev, w[r3 + 4 >> 2] = e3.mode, y[r3 + 8 >> 2] = e3.nlink, w[r3 + 12 >> 2] = e3.uid, w[r3 + 16 >> 2] = e3.gid, w[r3 + 20 >> 2] = e3.rdev, k[r3 + 24 >> 3] = BigInt(e3.size), w[r3 + 32 >> 2] = 4096, w[r3 + 36 >> 2] = e3.blocks;
      var t3 = e3.atime.getTime(), n3 = e3.mtime.getTime(), o5 = e3.ctime.getTime();
      return k[r3 + 40 >> 3] = BigInt(Math.floor(t3 / 1e3)), y[r3 + 48 >> 2] = t3 % 1e3 * 1e3 * 1e3, k[r3 + 56 >> 3] = BigInt(Math.floor(n3 / 1e3)), y[r3 + 64 >> 2] = n3 % 1e3 * 1e3 * 1e3, k[r3 + 72 >> 3] = BigInt(Math.floor(o5 / 1e3)), y[r3 + 80 >> 2] = o5 % 1e3 * 1e3 * 1e3, k[r3 + 88 >> 3] = BigInt(e3.ino), 0;
    }, writeStatFs(r3, e3) {
      w[r3 + 4 >> 2] = e3.bsize, w[r3 + 40 >> 2] = e3.bsize, w[r3 + 8 >> 2] = e3.blocks, w[r3 + 12 >> 2] = e3.bfree, w[r3 + 16 >> 2] = e3.bavail, w[r3 + 20 >> 2] = e3.files, w[r3 + 24 >> 2] = e3.ffree, w[r3 + 28 >> 2] = e3.fsid, w[r3 + 44 >> 2] = e3.flags, w[r3 + 36 >> 2] = e3.namelen;
    }, doMsync(r3, e3, t3, n3, o5) {
      if (!Fr.isFile(e3.node.mode)) throw new Fr.ErrnoError(43);
      if (2 & n3) return 0;
      var a3 = h.slice(r3, r3 + t3);
      Fr.msync(e3, a3, o5, t3, n3);
    }, getStreamFromFD: (r3) => Fr.getStreamChecked(r3), varargs: void 0, getStr: (r3) => Ar(r3) };
    function Sr(r3, e3, t3) {
      Pr.varargs = t3;
      try {
        var n3 = Pr.getStreamFromFD(r3);
        switch (e3) {
          case 0:
            if ((o5 = er()) < 0) return -28;
            for (; Fr.streams[o5]; ) o5++;
            return Fr.dupStream(n3, o5).fd;
          case 1:
          case 2:
          case 13:
          case 14:
            return 0;
          case 3:
            return n3.flags;
          case 4:
            var o5 = er();
            return n3.flags |= o5, 0;
          case 12:
            return o5 = tr(), p[o5 + 0 >> 1] = 2, 0;
        }
        return -28;
      } catch (a3) {
        if (void 0 === Fr || "ErrnoError" !== a3.name) throw a3;
        return -a3.errno;
      }
    }
    function Dr(r3, e3, t3) {
      Pr.varargs = t3;
      try {
        var n3 = Pr.getStreamFromFD(r3);
        switch (e3) {
          case 21509:
          case 21510:
          case 21511:
          case 21512:
          case 21524:
          case 21515:
            return n3.tty ? 0 : -59;
          case 21505:
            if (!n3.tty) return -59;
            if (n3.tty.ops.ioctl_tcgets) {
              var o5 = n3.tty.ops.ioctl_tcgets(n3), a3 = tr();
              w[a3 >> 2] = o5.c_iflag || 0, w[a3 + 4 >> 2] = o5.c_oflag || 0, w[a3 + 8 >> 2] = o5.c_cflag || 0, w[a3 + 12 >> 2] = o5.c_lflag || 0;
              for (var i2 = 0; i2 < 32; i2++) m[a3 + i2 + 17] = o5.c_cc[i2] || 0;
              return 0;
            }
            return 0;
          case 21506:
          case 21507:
          case 21508:
            if (!n3.tty) return -59;
            if (n3.tty.ops.ioctl_tcsets) {
              a3 = tr();
              var s2 = w[a3 >> 2], u2 = w[a3 + 4 >> 2], l2 = w[a3 + 8 >> 2], d2 = w[a3 + 12 >> 2], c2 = [];
              for (i2 = 0; i2 < 32; i2++) c2.push(m[a3 + i2 + 17]);
              return n3.tty.ops.ioctl_tcsets(n3.tty, e3, { c_iflag: s2, c_oflag: u2, c_cflag: l2, c_lflag: d2, c_cc: c2 });
            }
            return 0;
          case 21519:
            return n3.tty ? (a3 = tr(), w[a3 >> 2] = 0, 0) : -59;
          case 21520:
            return n3.tty ? -28 : -59;
          case 21531:
            return a3 = tr(), Fr.ioctl(n3, e3, a3);
          case 21523:
            if (!n3.tty) return -59;
            if (n3.tty.ops.ioctl_tiocgwinsz) {
              var f2 = n3.tty.ops.ioctl_tiocgwinsz(n3.tty);
              a3 = tr(), p[a3 >> 1] = f2[0], p[a3 + 2 >> 1] = f2[1];
            }
            return 0;
          default:
            return -28;
        }
      } catch (h2) {
        if (void 0 === Fr || "ErrnoError" !== h2.name) throw h2;
        return -h2.errno;
      }
    }
    function Tr(r3, e3, t3, n3) {
      Pr.varargs = n3;
      try {
        e3 = Pr.getStr(e3), e3 = Pr.calculateAt(r3, e3);
        var o5 = n3 ? er() : 0;
        return Fr.open(e3, t3, o5).fd;
      } catch (a3) {
        if (void 0 === Fr || "ErrnoError" !== a3.name) throw a3;
        return -a3.errno;
      }
    }
    var xr = () => j(""), Cr = {}, Nr = (r3) => {
      for (; r3.length; ) {
        var e3 = r3.pop();
        r3.pop()(e3);
      }
    };
    function Mr(r3) {
      return this.fromWireType(y[r3 >> 2]);
    }
    var Rr = {}, Br = {}, jr = {}, Wr = class extends Error {
      constructor(r3) {
        super(r3), this.name = "InternalError";
      }
    }, zr = (r3) => {
      throw new Wr(r3);
    }, Or = (r3, e3, t3) => {
      function n3(e4) {
        var n4 = t3(e4);
        n4.length !== r3.length && zr("Mismatched type converter count");
        for (var o6 = 0; o6 < r3.length; ++o6) Hr(r3[o6], n4[o6]);
      }
      r3.forEach((r4) => jr[r4] = e3);
      var o5 = new Array(e3.length), a3 = [], i2 = 0;
      e3.forEach((r4, e4) => {
        Br.hasOwnProperty(r4) ? o5[e4] = Br[r4] : (a3.push(r4), Rr.hasOwnProperty(r4) || (Rr[r4] = []), Rr[r4].push(() => {
          o5[e4] = Br[r4], ++i2 === a3.length && n3(o5);
        }));
      }), 0 === a3.length && n3(o5);
    }, $r = (r3) => {
      var e3 = Cr[r3];
      delete Cr[r3];
      var t3 = e3.rawConstructor, n3 = e3.rawDestructor, o5 = e3.fields, a3 = o5.map((r4) => r4.getterReturnType).concat(o5.map((r4) => r4.setterArgumentType));
      Or([r3], a3, (r4) => {
        var a4 = {};
        return o5.forEach((e4, t4) => {
          var n4 = e4.fieldName, i2 = r4[t4], s2 = r4[t4].optional, u2 = e4.getter, l2 = e4.getterContext, d2 = r4[t4 + o5.length], c2 = e4.setter, f2 = e4.setterContext;
          a4[n4] = { read: (r5) => i2.fromWireType(u2(l2, r5)), write: (r5, e5) => {
            var t5 = [];
            c2(f2, r5, d2.toWireType(t5, e5)), Nr(t5);
          }, optional: s2 };
        }), [{ name: e3.name, fromWireType: (r5) => {
          var e4 = {};
          for (var t4 in a4) e4[t4] = a4[t4].read(r5);
          return n3(r5), e4;
        }, toWireType: (r5, e4) => {
          for (var o6 in a4) if (!(o6 in e4) && !a4[o6].optional) throw new TypeError(`Missing field: "${o6}"`);
          var i2 = t3();
          for (o6 in a4) a4[o6].write(i2, e4[o6]);
          return null !== r5 && r5.push(n3, i2), i2;
        }, argPackAdvance: Gr, readValueFromPointer: Mr, destructorFunction: n3 }];
      });
    }, Ir = (r3) => {
      for (var e3 = ""; ; ) {
        var t3 = h[r3++];
        if (!t3) return e3;
        e3 += String.fromCharCode(t3);
      }
    }, Ur = class extends Error {
      constructor(r3) {
        super(r3), this.name = "BindingError";
      }
    }, Lr = (r3) => {
      throw new Ur(r3);
    };
    function Vr(r3, e3, t3 = {}) {
      var n3 = e3.name;
      if (r3 || Lr(`type "${n3}" must have a positive integer typeid pointer`), Br.hasOwnProperty(r3)) {
        if (t3.ignoreDuplicateRegistrations) return;
        Lr(`Cannot register type '${n3}' twice`);
      }
      if (Br[r3] = e3, delete jr[r3], Rr.hasOwnProperty(r3)) {
        var o5 = Rr[r3];
        delete Rr[r3], o5.forEach((r4) => r4());
      }
    }
    function Hr(r3, e3, t3 = {}) {
      return Vr(r3, e3, t3);
    }
    var qr = (r3, e3, t3) => {
      switch (e3) {
        case 1:
          return t3 ? (r4) => m[r4] : (r4) => h[r4];
        case 2:
          return t3 ? (r4) => p[r4 >> 1] : (r4) => v[r4 >> 1];
        case 4:
          return t3 ? (r4) => w[r4 >> 2] : (r4) => y[r4 >> 2];
        case 8:
          return t3 ? (r4) => k[r4 >> 3] : (r4) => _[r4 >> 3];
        default:
          throw new TypeError(`invalid integer width (${e3}): ${r3}`);
      }
    }, Xr = (r3, e3, t3, n3, o5) => {
      e3 = Ir(e3);
      const a3 = 0n === n3;
      let i2 = (r4) => r4;
      if (a3) {
        const r4 = 8 * t3;
        i2 = (e4) => BigInt.asUintN(r4, e4), o5 = i2(o5);
      }
      Hr(r3, { name: e3, fromWireType: i2, toWireType: (r4, e4) => ("number" == typeof e4 && (e4 = BigInt(e4)), e4), argPackAdvance: Gr, readValueFromPointer: qr(e3, t3, !a3), destructorFunction: null });
    }, Gr = 8, Yr = (r3, e3, t3, n3) => {
      Hr(r3, { name: e3 = Ir(e3), fromWireType: function(r4) {
        return !!r4;
      }, toWireType: function(r4, e4) {
        return e4 ? t3 : n3;
      }, argPackAdvance: Gr, readValueFromPointer: function(r4) {
        return this.fromWireType(h[r4]);
      }, destructorFunction: null });
    }, Kr = [], Jr = [0, 1, , 1, null, 1, true, 1, false, 1], Qr = (r3) => {
      r3 > 9 && 0 === --Jr[r3 + 1] && (Jr[r3] = void 0, Kr.push(r3));
    }, Zr = { toValue: (r3) => (r3 || Lr(`Cannot use deleted val. handle = ${r3}`), Jr[r3]), toHandle: (r3) => {
      switch (r3) {
        case void 0:
          return 2;
        case null:
          return 4;
        case true:
          return 6;
        case false:
          return 8;
        default: {
          const e3 = Kr.pop() || Jr.length;
          return Jr[e3] = r3, Jr[e3 + 1] = 1, e3;
        }
      }
    } }, re = { name: "emscripten::val", fromWireType: (r3) => {
      var e3 = Zr.toValue(r3);
      return Qr(r3), e3;
    }, toWireType: (r3, e3) => Zr.toHandle(e3), argPackAdvance: Gr, readValueFromPointer: Mr, destructorFunction: null }, ee = (r3) => Hr(r3, re), te = (r3, e3) => {
      switch (e3) {
        case 4:
          return function(r4) {
            return this.fromWireType(g[r4 >> 2]);
          };
        case 8:
          return function(r4) {
            return this.fromWireType(E[r4 >> 3]);
          };
        default:
          throw new TypeError(`invalid float width (${e3}): ${r3}`);
      }
    }, ne = (r3, e3, t3) => {
      Hr(r3, { name: e3 = Ir(e3), fromWireType: (r4) => r4, toWireType: (r4, e4) => e4, argPackAdvance: Gr, readValueFromPointer: te(e3, t3), destructorFunction: null });
    }, oe = (r3, e3) => Object.defineProperty(e3, "name", { value: r3 });
    function ae(r3) {
      for (var e3 = 1; e3 < r3.length; ++e3) if (null !== r3[e3] && void 0 === r3[e3].destructorFunction) return true;
      return false;
    }
    function ie(r3, e3, t3, n3, o5, a3) {
      var i2 = e3.length;
      i2 < 2 && Lr("argTypes array size mismatch! Must at least get return value and 'this' types!"), e3[1];
      var s2 = ae(e3), u2 = "void" !== e3[0].name, l2 = i2 - 2, d2 = new Array(l2), c2 = [], f2 = [];
      return oe(r3, function(...r4) {
        var t4;
        f2.length = 0, c2.length = 1, c2[0] = o5;
        for (var a4 = 0; a4 < l2; ++a4) d2[a4] = e3[a4 + 2].toWireType(f2, r4[a4]), c2.push(d2[a4]);
        function i3(r5) {
          if (s2) Nr(f2);
          else for (var n4 = 2; n4 < e3.length; n4++) {
            var o6 = 1 === n4 ? t4 : d2[n4 - 2];
            null !== e3[n4].destructorFunction && e3[n4].destructorFunction(o6);
          }
          if (u2) return e3[0].fromWireType(r5);
        }
        return i3(n3(...c2));
      });
    }
    var se, ue = (r3, e3, t3) => {
      if (void 0 === r3[e3].overloadTable) {
        var n3 = r3[e3];
        r3[e3] = function(...n4) {
          return r3[e3].overloadTable.hasOwnProperty(n4.length) || Lr(`Function '${t3}' called with an invalid number of arguments (${n4.length}) - expects one of (${r3[e3].overloadTable})!`), r3[e3].overloadTable[n4.length].apply(this, n4);
        }, r3[e3].overloadTable = [], r3[e3].overloadTable[n3.argCount] = n3;
      }
    }, le = (r3, e3, t3) => {
      o4.hasOwnProperty(r3) ? ((void 0 === t3 || void 0 !== o4[r3].overloadTable && void 0 !== o4[r3].overloadTable[t3]) && Lr(`Cannot register public name '${r3}' twice`), ue(o4, r3, r3), o4[r3].overloadTable.hasOwnProperty(t3) && Lr(`Cannot register multiple overloads of a function with the same number of arguments (${t3})!`), o4[r3].overloadTable[t3] = e3) : (o4[r3] = e3, o4[r3].argCount = t3);
    }, de = (r3, e3) => {
      for (var t3 = [], n3 = 0; n3 < r3; n3++) t3.push(y[e3 + 4 * n3 >> 2]);
      return t3;
    }, ce = (r3, e3, t3) => {
      o4.hasOwnProperty(r3) || zr("Replacing nonexistent public symbol"), void 0 !== o4[r3].overloadTable && void 0 !== t3 ? o4[r3].overloadTable[t3] = e3 : (o4[r3] = e3, o4[r3].argCount = t3);
    }, fe = [], me = (r3) => {
      var e3 = fe[r3];
      return e3 || (fe[r3] = e3 = se.get(r3)), e3;
    }, he = (r3, e3, t3 = false) => {
      function n3() {
        return me(e3);
      }
      r3 = Ir(r3);
      var o5 = n3();
      return "function" != typeof o5 && Lr(`unknown function pointer with signature ${r3}: ${e3}`), o5;
    };
    class pe extends Error {
    }
    var ve = (r3) => {
      var e3 = Pt(r3), t3 = Ir(e3);
      return Dt(e3), t3;
    }, we = (r3, e3) => {
      var t3 = [], n3 = {};
      function o5(r4) {
        n3[r4] || Br[r4] || (jr[r4] ? jr[r4].forEach(o5) : (t3.push(r4), n3[r4] = true));
      }
      throw e3.forEach(o5), new pe(`${r3}: ` + t3.map(ve).join([", "]));
    }, ye = (r3) => {
      const e3 = (r3 = r3.trim()).indexOf("(");
      return -1 === e3 ? r3 : r3.slice(0, e3);
    }, ge = (r3, e3, t3, n3, o5, a3, i2, s2) => {
      var u2 = de(e3, t3);
      r3 = Ir(r3), r3 = ye(r3), o5 = he(n3, o5, i2), le(r3, function() {
        we(`Cannot call ${r3} due to unbound types`, u2);
      }, e3 - 1), Or([], u2, (t4) => {
        var n4 = [t4[0], null].concat(t4.slice(1));
        return ce(r3, ie(r3, n4, null, o5, a3), e3 - 1), [];
      });
    }, Ee = (r3, e3, t3, n3, o5) => {
      e3 = Ir(e3);
      let a3 = (r4) => r4;
      if (0 === n3) {
        var i2 = 32 - 8 * t3;
        a3 = (r4) => r4 << i2 >>> i2, o5 = a3(o5);
      }
      Hr(r3, { name: e3, fromWireType: a3, toWireType: (r4, e4) => e4, argPackAdvance: Gr, readValueFromPointer: qr(e3, t3, 0 !== n3), destructorFunction: null });
    }, ke = (r3, e3, t3) => {
      var n3 = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array, BigInt64Array, BigUint64Array][e3];
      function o5(r4) {
        var e4 = y[r4 >> 2], t4 = y[r4 + 4 >> 2];
        return new n3(m.buffer, t4, e4);
      }
      Hr(r3, { name: t3 = Ir(t3), fromWireType: o5, argPackAdvance: Gr, readValueFromPointer: o5 }, { ignoreDuplicateRegistrations: true });
    }, _e = (r3, e3, t3) => cr(r3, h, e3, t3), be = (r3, e3) => {
      Hr(r3, { name: e3 = Ir(e3), fromWireType(r4) {
        for (var e4, t3 = y[r4 >> 2], n3 = r4 + 4, o5 = n3, a3 = 0; a3 <= t3; ++a3) {
          var i2 = n3 + a3;
          if (a3 == t3 || 0 == h[i2]) {
            var s2 = Ar(o5, i2 - o5);
            void 0 === e4 ? e4 = s2 : (e4 += String.fromCharCode(0), e4 += s2), o5 = i2 + 1;
          }
        }
        return Dt(r4), e4;
      }, toWireType(r4, e4) {
        var t3;
        e4 instanceof ArrayBuffer && (e4 = new Uint8Array(e4));
        var n3 = "string" == typeof e4;
        n3 || ArrayBuffer.isView(e4) && 1 == e4.BYTES_PER_ELEMENT || Lr("Cannot pass non-string to std::string"), t3 = n3 ? dr(e4) : e4.length;
        var o5 = St(4 + t3 + 1), a3 = o5 + 4;
        return y[o5 >> 2] = t3, n3 ? _e(e4, a3, t3 + 1) : h.set(e4, a3), null !== r4 && r4.push(Dt, o5), o5;
      }, argPackAdvance: Gr, readValueFromPointer: Mr, destructorFunction(r4) {
        Dt(r4);
      } });
    }, Fe = "undefined" != typeof TextDecoder ? new TextDecoder("utf-16le") : void 0, Ae = (r3, e3) => {
      for (var t3 = r3 >> 1, n3 = t3 + e3 / 2, o5 = t3; !(o5 >= n3) && v[o5]; ) ++o5;
      if (o5 - t3 > 16 && Fe) return Fe.decode(v.subarray(t3, o5));
      for (var a3 = "", i2 = t3; !(i2 >= n3); ++i2) {
        var s2 = v[i2];
        if (0 == s2) break;
        a3 += String.fromCharCode(s2);
      }
      return a3;
    }, Pe = (r3, e3, t3) => {
      if (t3 ??= 2147483647, t3 < 2) return 0;
      for (var n3 = e3, o5 = (t3 -= 2) < 2 * r3.length ? t3 / 2 : r3.length, a3 = 0; a3 < o5; ++a3) {
        var i2 = r3.charCodeAt(a3);
        p[e3 >> 1] = i2, e3 += 2;
      }
      return p[e3 >> 1] = 0, e3 - n3;
    }, Se = (r3) => 2 * r3.length, De = (r3, e3) => {
      for (var t3 = "", n3 = 0; !(n3 >= e3 / 4); n3++) {
        var o5 = w[r3 + 4 * n3 >> 2];
        if (!o5) break;
        t3 += String.fromCodePoint(o5);
      }
      return t3;
    }, Te = (r3, e3, t3) => {
      if (t3 ??= 2147483647, t3 < 4) return 0;
      for (var n3 = e3, o5 = n3 + t3 - 4, a3 = 0; a3 < r3.length; ++a3) {
        var i2 = r3.codePointAt(a3);
        if (i2 > 65535 && a3++, w[e3 >> 2] = i2, (e3 += 4) + 4 > o5) break;
      }
      return w[e3 >> 2] = 0, e3 - n3;
    }, xe = (r3) => {
      for (var e3 = 0, t3 = 0; t3 < r3.length; ++t3) r3.codePointAt(t3) > 65535 && t3++, e3 += 4;
      return e3;
    }, Ce = (r3, e3, t3) => {
      var n3, o5, a3, i2;
      t3 = Ir(t3), 2 === e3 ? (n3 = Ae, o5 = Pe, i2 = Se, a3 = (r4) => v[r4 >> 1]) : 4 === e3 && (n3 = De, o5 = Te, i2 = xe, a3 = (r4) => y[r4 >> 2]), Hr(r3, { name: t3, fromWireType: (r4) => {
        for (var t4, o6 = y[r4 >> 2], i3 = r4 + 4, s2 = 0; s2 <= o6; ++s2) {
          var u2 = r4 + 4 + s2 * e3;
          if (s2 == o6 || 0 == a3(u2)) {
            var l2 = n3(i3, u2 - i3);
            void 0 === t4 ? t4 = l2 : (t4 += String.fromCharCode(0), t4 += l2), i3 = u2 + e3;
          }
        }
        return Dt(r4), t4;
      }, toWireType: (r4, n4) => {
        "string" != typeof n4 && Lr(`Cannot pass non-string to C++ string type ${t3}`);
        var a4 = i2(n4), s2 = St(4 + a4 + e3);
        return y[s2 >> 2] = a4 / e3, o5(n4, s2 + 4, a4 + e3), null !== r4 && r4.push(Dt, s2), s2;
      }, argPackAdvance: Gr, readValueFromPointer: Mr, destructorFunction(r4) {
        Dt(r4);
      } });
    }, Ne = (r3, e3, t3, n3, o5, a3) => {
      Cr[r3] = { name: Ir(e3), rawConstructor: he(t3, n3), rawDestructor: he(o5, a3), fields: [] };
    }, Me = (r3, e3, t3, n3, o5, a3, i2, s2, u2, l2) => {
      Cr[r3].fields.push({ fieldName: Ir(e3), getterReturnType: t3, getter: he(n3, o5), getterContext: a3, setterArgumentType: i2, setter: he(s2, u2), setterContext: l2 });
    }, Re = (r3, e3) => {
      Hr(r3, { isVoid: true, name: e3 = Ir(e3), argPackAdvance: 0, fromWireType: () => {
      }, toWireType: (r4, e4) => {
      } });
    }, Be = (r3) => {
      do {
        var e3 = y[r3 >> 2], t3 = y[(r3 += 4) >> 2], n3 = y[(r3 += 4) >> 2];
        r3 += 4;
        var o5 = Ar(e3);
        Fr.createPath("/", nr.dirname(o5), true, true), Fr.createDataFile(o5, null, m.subarray(n3, n3 + t3), true, true, true);
      } while (y[r3 >> 2]);
    }, je = () => {
      throw 1 / 0;
    }, We = (r3, e3) => {
      var t3 = Br[r3];
      return void 0 === t3 && Lr(`${e3} has unknown type ${ve(r3)}`), t3;
    }, ze = (r3, e3, t3) => {
      var n3 = [], o5 = r3.toWireType(n3, t3);
      return n3.length && (y[e3 >> 2] = Zr.toHandle(n3)), o5;
    }, Oe = (r3, e3, t3) => (r3 = Zr.toValue(r3), e3 = We(e3, "emval::as"), ze(e3, t3, r3)), $e = {}, Ie = (r3) => {
      var e3 = $e[r3];
      return void 0 === e3 ? Ir(r3) : e3;
    }, Ue = [], Le = (r3, e3, t3, n3, o5) => (r3 = Ue[r3])(e3 = Zr.toValue(e3), e3[t3 = Ie(t3)], n3, o5), Ve = () => globalThis, He = (r3) => 0 === r3 ? Zr.toHandle(Ve()) : (r3 = Ie(r3), Zr.toHandle(Ve()[r3])), qe = (r3) => {
      var e3 = Ue.length;
      return Ue.push(r3), e3;
    }, Xe = (r3, e3) => {
      for (var t3 = new Array(r3), n3 = 0; n3 < r3; ++n3) t3[n3] = We(y[e3 + 4 * n3 >> 2], `parameter ${n3}`);
      return t3;
    }, Ge = (r3, e3, t3) => {
      var n3 = Xe(r3, e3), o5 = n3.shift();
      r3--;
      var a3 = new Array(r3), i2 = (e4, i3, s3, u2) => {
        for (var l2 = 0, d2 = 0; d2 < r3; ++d2) a3[d2] = n3[d2].readValueFromPointer(u2 + l2), l2 += n3[d2].argPackAdvance;
        var c2 = 1 === t3 ? Reflect.construct(i3, a3) : i3.apply(e4, a3);
        return ze(o5, s3, c2);
      }, s2 = `methodCaller<(${n3.map((r4) => r4.name).join(", ")}) => ${o5.name}>`;
      return qe(oe(s2, i2));
    }, Ye = (r3, e3) => (r3 = Zr.toValue(r3), e3 = Zr.toValue(e3), Zr.toHandle(r3[e3])), Ke = (r3) => {
      r3 > 9 && (Jr[r3 + 1] += 1);
    }, Je = () => Zr.toHandle([]), Qe = (r3) => Zr.toHandle(Ie(r3)), Ze = (r3) => {
      var e3 = Zr.toValue(r3);
      Nr(e3), Qr(r3);
    }, rt = (r3, e3, t3) => {
      r3 = Zr.toValue(r3), e3 = Zr.toValue(e3), t3 = Zr.toValue(t3), r3[e3] = t3;
    }, et = (r3, e3) => {
      var t3 = (r3 = We(r3, "_emval_take_value")).readValueFromPointer(e3);
      return Zr.toHandle(t3);
    }, tt = (r3, e3, t3, n3) => {
      var o5 = (/* @__PURE__ */ new Date()).getFullYear(), a3 = new Date(o5, 0, 1), i2 = new Date(o5, 6, 1), s2 = a3.getTimezoneOffset(), u2 = i2.getTimezoneOffset(), l2 = Math.max(s2, u2);
      y[r3 >> 2] = 60 * l2, w[e3 >> 2] = Number(s2 != u2);
      var d2 = (r4) => {
        var e4 = r4 >= 0 ? "-" : "+", t4 = Math.abs(r4);
        return `UTC${e4}${String(Math.floor(t4 / 60)).padStart(2, "0")}${String(t4 % 60).padStart(2, "0")}`;
      }, c2 = d2(s2), f2 = d2(u2);
      u2 < s2 ? (_e(c2, t3, 17), _e(f2, n3, 17)) : (_e(c2, n3, 17), _e(f2, t3, 17));
    }, nt = () => 2147483648, ot = (r3, e3) => Math.ceil(r3 / e3) * e3, at = (r3) => {
      var e3 = (r3 - f.buffer.byteLength + 65535) / 65536 | 0;
      try {
        return f.grow(e3), S(), 1;
      } catch (t3) {
      }
    }, it = (r3) => {
      var e3 = h.length;
      r3 >>>= 0;
      var t3 = nt();
      if (r3 > t3) return false;
      for (var n3 = 1; n3 <= 4; n3 *= 2) {
        var o5 = e3 * (1 + 0.2 / n3);
        o5 = Math.min(o5, r3 + 100663296);
        var a3 = Math.min(t3, ot(Math.max(r3, o5), 65536));
        if (at(a3)) return true;
      }
      return false;
    }, st = {}, ut = () => a2 || "./this.program", lt = () => {
      if (!lt.strings) {
        var r3 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.language || "C").replace("-", "_") + ".UTF-8", _: ut() };
        for (var e3 in st) void 0 === st[e3] ? delete r3[e3] : r3[e3] = st[e3];
        var t3 = [];
        for (var e3 in r3) t3.push(`${e3}=${r3[e3]}`);
        lt.strings = t3;
      }
      return lt.strings;
    }, dt = (r3, e3) => {
      var t3 = 0, n3 = 0;
      for (var o5 of lt()) {
        var a3 = e3 + t3;
        y[r3 + n3 >> 2] = a3, t3 += _e(o5, a3, 1 / 0) + 1, n3 += 4;
      }
      return 0;
    }, ct = (r3, e3) => {
      var t3 = lt();
      y[r3 >> 2] = t3.length;
      var n3 = 0;
      for (var o5 of t3) n3 += dr(o5) + 1;
      return y[e3 >> 2] = n3, 0;
    }, ft = 0, mt = () => K || ft > 0, ht = (r3) => {
      mt() || (o4.onExit?.(r3), A = true), i(r3, new V(r3));
    }, pt = (r3, e3) => {
      ht(r3);
    };
    function vt(r3) {
      try {
        var e3 = Pr.getStreamFromFD(r3);
        return Fr.close(e3), 0;
      } catch (t3) {
        if (void 0 === Fr || "ErrnoError" !== t3.name) throw t3;
        return t3.errno;
      }
    }
    var wt = (r3, e3, t3, n3) => {
      for (var o5 = 0, a3 = 0; a3 < t3; a3++) {
        var i2 = y[e3 >> 2], s2 = y[e3 + 4 >> 2];
        e3 += 8;
        var u2 = Fr.read(r3, m, i2, s2, n3);
        if (u2 < 0) return -1;
        if (o5 += u2, u2 < s2) break;
      }
      return o5;
    };
    function yt(r3, e3, t3, n3) {
      try {
        var o5 = Pr.getStreamFromFD(r3), a3 = wt(o5, e3, t3);
        return y[n3 >> 2] = a3, 0;
      } catch (i2) {
        if (void 0 === Fr || "ErrnoError" !== i2.name) throw i2;
        return i2.errno;
      }
    }
    var gt = 9007199254740992, Et = -9007199254740992, kt = (r3) => r3 < Et || r3 > gt ? NaN : Number(r3);
    function _t(r3, e3, t3, n3) {
      e3 = kt(e3);
      try {
        if (isNaN(e3)) return 61;
        var o5 = Pr.getStreamFromFD(r3);
        return Fr.llseek(o5, e3, t3), k[n3 >> 3] = BigInt(o5.position), o5.getdents && 0 === e3 && 0 === t3 && (o5.getdents = null), 0;
      } catch (a3) {
        if (void 0 === Fr || "ErrnoError" !== a3.name) throw a3;
        return a3.errno;
      }
    }
    var bt = (r3, e3, t3, n3) => {
      for (var o5 = 0, a3 = 0; a3 < t3; a3++) {
        var i2 = y[e3 >> 2], s2 = y[e3 + 4 >> 2];
        e3 += 8;
        var u2 = Fr.write(r3, m, i2, s2, n3);
        if (u2 < 0) return -1;
        if (o5 += u2, u2 < s2) break;
      }
      return o5;
    };
    function Ft(r3, e3, t3, n3) {
      try {
        var o5 = Pr.getStreamFromFD(r3), a3 = bt(o5, e3, t3);
        return y[n3 >> 2] = a3, 0;
      } catch (i2) {
        if (void 0 === Fr || "ErrnoError" !== i2.name) throw i2;
        return i2.errno;
      }
    }
    var At, Pt, St, Dt, Tt, xt, Ct, Nt = (r3, e3) => {
      r3 < 128 ? e3.push(r3) : e3.push(r3 % 128 | 128, r3 >> 7);
    }, Mt = (r3) => {
      for (var e3 = { i: "i32", j: "i64", f: "f32", d: "f64", e: "externref", p: "i32" }, t3 = { parameters: [], results: "v" == r3[0] ? [] : [e3[r3[0]]] }, n3 = 1; n3 < r3.length; ++n3) t3.parameters.push(e3[r3[n3]]);
      return t3;
    }, Rt = (r3, e3) => {
      var t3 = r3.slice(0, 1), n3 = r3.slice(1), o5 = { i: 127, p: 127, j: 126, f: 125, d: 124, e: 111 };
      for (var a3 of (e3.push(96), Nt(n3.length, e3), n3)) e3.push(o5[a3]);
      "v" == t3 ? e3.push(0) : e3.push(1, o5[t3]);
    }, Bt = (r3, e3) => {
      if ("function" == typeof WebAssembly.Function) return new WebAssembly.Function(Mt(e3), r3);
      var t3 = [1];
      Rt(e3, t3);
      var n3 = [0, 97, 115, 109, 1, 0, 0, 0, 1];
      Nt(t3.length, n3), n3.push(...t3), n3.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0);
      var o5 = new WebAssembly.Module(new Uint8Array(n3));
      return new WebAssembly.Instance(o5, { e: { f: r3 } }).exports.f;
    }, jt = (r3, e3) => {
      if (At) for (var t3 = r3; t3 < r3 + e3; t3++) {
        var n3 = me(t3);
        n3 && At.set(n3, t3);
      }
    }, Wt = (r3) => (At || (At = /* @__PURE__ */ new WeakMap(), jt(0, se.length)), At.get(r3) || 0), zt = [], Ot = () => {
      if (zt.length) return zt.pop();
      try {
        se.grow(1);
      } catch (F2) {
        if (!(F2 instanceof RangeError)) throw F2;
        throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";
      }
      return se.length - 1;
    }, $t = (r3, e3) => {
      se.set(r3, e3), fe[r3] = se.get(r3);
    }, It = (r3, e3) => {
      var t3 = Wt(r3);
      if (t3) return t3;
      var n3 = Ot();
      try {
        $t(n3, r3);
      } catch (F2) {
        if (!(F2 instanceof TypeError)) throw F2;
        var o5 = Bt(r3, e3);
        $t(n3, o5);
      }
      return At.set(r3, n3), n3;
    }, Ut = (...r3) => Fr.createPath(...r3), Lt = (...r3) => Fr.unlink(...r3), Vt = (...r3) => Fr.createLazyFile(...r3), Ht = (...r3) => Fr.createDevice(...r3);
    function qt(r3) {
      Pt = r3.$, o4._malloc = St = r3.ba, o4._free = Dt = r3.ca, Tt = r3.da, xt = r3.ea, Ct = r3.fa;
    }
    Fr.createPreloadedFile = kr, Fr.staticInit(), vr.doesNotExistError = new Fr.ErrnoError(44), vr.doesNotExistError.stack = "<generic error, no stack>", o4.noExitRuntime && (K = o4.noExitRuntime), o4.preloadPlugins && (gr = o4.preloadPlugins), o4.print && (b = o4.print), o4.printErr && (F = o4.printErr), o4.wasmBinary && (l = o4.wasmBinary), o4.arguments && o4.arguments, o4.thisProgram && (a2 = o4.thisProgram), o4.addRunDependency = R, o4.removeRunDependency = B, o4.addFunction = It, o4.UTF8ToString = Ar, o4.FS_createPreloadedFile = kr, o4.FS_unlink = Lt, o4.FS_createPath = Ut, o4.FS_createDevice = Ht, o4.FS_createDataFile = yr, o4.FS_createLazyFile = Vt;
    var Xt = { j: rr, w: Sr, N: Dr, O: Tr, P: xr, z: $r, y: Xr, U: Yr, S: ee, x: ne, n: ge, d: Ee, b: ke, T: be, r: Ce, A: Ne, c: Me, V: Re, R: Be, G: je, X: Oe, B: Le, a: Qr, Y: He, C: Ge, m: Ye, h: Ke, D: Je, i: Qe, s: Ze, W: rt, l: et, I: tt, H: it, K: dt, L: ct, Q: pt, u: vt, M: yt, J: _t, v: Ft, o: Yt, k: Qt, p: rn, t: en, F: nn, q: Zt, e: Kt, E: on, f: tn, g: Jt }, Gt = await L();
    function Yt(r3, e3) {
      var t3 = Q();
      try {
        return me(r3)(e3);
      } catch (n3) {
        if (J(t3), n3 !== n3 + 0) throw n3;
        Tt(1, 0);
      }
    }
    function Kt(r3, e3) {
      var t3 = Q();
      try {
        me(r3)(e3);
      } catch (n3) {
        if (J(t3), n3 !== n3 + 0) throw n3;
        Tt(1, 0);
      }
    }
    function Jt(r3, e3, t3, n3) {
      var o5 = Q();
      try {
        me(r3)(e3, t3, n3);
      } catch (a3) {
        if (J(o5), a3 !== a3 + 0) throw a3;
        Tt(1, 0);
      }
    }
    function Qt(r3, e3, t3) {
      var n3 = Q();
      try {
        return me(r3)(e3, t3);
      } catch (o5) {
        if (J(n3), o5 !== o5 + 0) throw o5;
        Tt(1, 0);
      }
    }
    function Zt(r3) {
      var e3 = Q();
      try {
        me(r3)();
      } catch (t3) {
        if (J(e3), t3 !== t3 + 0) throw t3;
        Tt(1, 0);
      }
    }
    function rn(r3, e3, t3, n3) {
      var o5 = Q();
      try {
        return me(r3)(e3, t3, n3);
      } catch (a3) {
        if (J(o5), a3 !== a3 + 0) throw a3;
        Tt(1, 0);
      }
    }
    function en(r3, e3, t3, n3, o5) {
      var a3 = Q();
      try {
        return me(r3)(e3, t3, n3, o5);
      } catch (i2) {
        if (J(a3), i2 !== i2 + 0) throw i2;
        Tt(1, 0);
      }
    }
    function tn(r3, e3, t3) {
      var n3 = Q();
      try {
        me(r3)(e3, t3);
      } catch (o5) {
        if (J(n3), o5 !== o5 + 0) throw o5;
        Tt(1, 0);
      }
    }
    function nn(r3, e3, t3, n3, o5, a3, i2, s2, u2, l2) {
      var d2 = Q();
      try {
        return me(r3)(e3, t3, n3, o5, a3, i2, s2, u2, l2);
      } catch (c2) {
        if (J(d2), c2 !== c2 + 0) throw c2;
        Tt(1, 0);
      }
    }
    function on(r3, e3, t3, n3) {
      var o5 = Q();
      try {
        me(r3)(e3, t3, n3);
      } catch (a3) {
        if (J(o5), a3 !== a3 + 0) throw a3;
        Tt(1, 0);
      }
    }
    function an() {
      function r3() {
        o4.calledRun = true, A || (T(), d?.(o4), o4.onRuntimeInitialized?.(), x());
      }
      N > 0 ? M = an : (D(), N > 0 ? M = an : o4.setStatus ? (o4.setStatus("Running..."), setTimeout(() => {
        setTimeout(() => o4.setStatus(""), 1), r3();
      }, 1)) : r3());
    }
    function sn() {
      if (o4.preInit) for ("function" == typeof o4.preInit && (o4.preInit = [o4.preInit]); o4.preInit.length > 0; ) o4.preInit.shift()();
    }
    return sn(), an(), P ? o4 : new Promise((r3, e3) => {
      d = r3, c = e3;
    });
  }, r.exports = o3, r.exports.default = o3), t.exports;
  var r, n2, o3;
}
var o2 = o(n());
var a = Object.freeze(Object.defineProperty({ __proto__: null, default: o2 }, Symbol.toStringTag, { value: "Module" }));
export {
  a as l
};
//# sourceMappingURL=lyr3DWorker-VLH7J62T.js.map
