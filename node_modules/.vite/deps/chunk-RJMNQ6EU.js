import {
  e as e2
} from "./chunk-XPA3C4DZ.js";
import {
  Q,
  t as t2
} from "./chunk-2AOVWXAQ.js";
import {
  t as t3
} from "./chunk-ALR6N4CF.js";
import {
  e
} from "./chunk-Y4O7HJXV.js";
import {
  A,
  K,
  P,
  _,
  c,
  o,
  p,
  s as s2,
  u
} from "./chunk-VYMBX5H5.js";
import {
  n
} from "./chunk-75XOUSSS.js";
import {
  b,
  s
} from "./chunk-SMWUT52Z.js";
import {
  r
} from "./chunk-A5XN2VFT.js";
import {
  t
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/bufferLayouts.js
var t4 = Q().vec3f("position").u16("componentIndex").freeze();
var i = Q().vec2u8("sideness").freeze();
var n2 = t2(i);
var s3 = Q().vec3f("position0").vec3f("position1").vec2i16("normalCompressed").u16("componentIndex").u8("variantOffset", { glNormalized: true }).u8("variantStroke").u8("variantExtension", { glNormalized: true }).freeze();
var a = Q().vec3f("position0").vec3f("position1").vec2i16("normalCompressed").vec2i16("normal2Compressed").u16("componentIndex").u8("variantOffset", { glNormalized: true }).u8("variantStroke").u8("variantExtension", { glNormalized: true }).freeze();
var f = t2(s3, 1);
var m = t2(a, 1);
var p2 = t3([n2, f]);
var u2 = t3([n2, m]);

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/Edge.js
var s4 = class {
  constructor() {
    this.position0 = n(), this.position1 = n(), this.faceNormal0 = n(), this.faceNormal1 = n(), this.componentIndex = 0, this.cosAngle = 0;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/edgePreprocessing.js
var p3 = -1;
function d(e3, t6, n3) {
  const c4 = e3.vertices.position, l2 = e3.vertices.componentIndex, i2 = I.position0, u5 = I.position1, h2 = I.faceNormal0, g3 = I.faceNormal1, { edges: d4, normals: v2 } = w(e3), x = d4.length / 4, j2 = t6.allocate(x);
  let y3 = 0;
  const N3 = x, E2 = n3?.allocate(N3);
  let b3 = 0, k2 = 0, D2 = 0;
  V.length = 0;
  for (let s5 = 0; s5 < x; ++s5) {
    const e4 = 4 * s5;
    c4.getVec(d4.data[e4], i2), c4.getVec(d4.data[e4 + 1], u5);
    const t7 = V.pushNew();
    t7.index = 4 * s5, t7.length = p(i2, u5);
  }
  V.sort((e4, t7) => t7.length - e4.length);
  const L2 = new Array(), U = new Array();
  V.forAll(({ length: e4, index: o2 }) => {
    const w3 = d4.data[o2], x2 = d4.data[o2 + 1], V2 = d4.data[o2 + 2], N4 = d4.data[o2 + 3], q2 = N4 === p3;
    if (c4.getVec(w3, i2), c4.getVec(x2, u5), q2) {
      const e5 = 3 * V2;
      o(h2, v2.data[e5], v2.data[e5 + 1], v2.data[e5 + 2]), s2(g3, h2), I.componentIndex = l2.get(w3), I.cosAngle = P(h2, g3);
    } else {
      let e5 = 3 * V2;
      if (o(h2, v2.data[e5], v2.data[e5 + 1], v2.data[e5 + 2]), e5 = 3 * N4, o(g3, v2.data[e5], v2.data[e5 + 1], v2.data[e5 + 2]), I.componentIndex = l2.get(w3), I.cosAngle = P(h2, g3), m2(I, M)) return;
      I.cosAngle < -0.9999 && s2(g3, h2);
    }
    k2 += e4, D2++, q2 || f2(I, P2) ? (t6.write(j2, y3++, I), L2.push(e4)) : A2(I, F) && (E2 && n3 && n3.write(E2, b3++, I), U.push(e4));
  });
  const q = new Float32Array(L2.reverse()), z = new Float32Array(U.reverse()), B = E2 && n3 ? { instancesData: E2.slice(0, b3), lodInfo: { lengths: z } } : void 0;
  return { regular: { instancesData: j2.slice(0, y3), lodInfo: { lengths: q } }, silhouette: B, averageEdgeLength: k2 / D2 };
}
function f2(e3, t6) {
  return e3.cosAngle < t6;
}
function m2(e3, t6) {
  return e3.cosAngle > t6;
}
function A2(t6, n3) {
  const o2 = b(t6.cosAngle);
  K(E, t6.position1, t6.position0);
  return o2 * (P(_(N, t6.faceNormal0, t6.faceNormal1), E) > 0 ? -1 : 1) > n3;
}
function w(e3) {
  const t6 = e3.faces.length / 3, n3 = e3.faces, o2 = e3.neighbors, s5 = e3.vertices.position;
  j.length = y.length = 0;
  for (let a4 = 0; a4 < t6; a4++) {
    const e4 = 3 * a4, t7 = o2[e4], r2 = o2[e4 + 1], u5 = o2[e4 + 2], h2 = n3[e4], g3 = n3[e4 + 1], d4 = n3[e4 + 2];
    s5.getVec(h2, b2), s5.getVec(g3, k), s5.getVec(d4, D), c(k, k, b2), c(D, D, b2), _(b2, k, D), A(b2, b2), y.pushArray(b2), (t7 === p3 || h2 < g3) && (j.push(h2), j.push(g3), j.push(a4), j.push(t7)), (r2 === p3 || g3 < d4) && (j.push(g3), j.push(d4), j.push(a4), j.push(r2)), (u5 === p3 || d4 < h2) && (j.push(d4), j.push(h2), j.push(a4), j.push(u5));
  }
  return { edges: j, normals: y };
}
var v = class {
  constructor() {
    this.index = 0, this.length = 0;
  }
};
var V = new r({ allocator: (e3) => e3 || new v(), deallocator: null });
var j = new r({ deallocator: null });
var y = new r({ deallocator: null });
var I = new s4();
var N = n();
var E = n();
var b2 = n();
var k = n();
var D = n();
var F = s(4);
var M = Math.cos(F);
var L = s(35);
var P2 = Math.cos(L);

// node_modules/@arcgis/core/views/3d/support/meshProcessing.js
function t5(t6, o2, n3) {
  const r2 = o2 / 3, c4 = new Uint32Array(n3 + 1), e3 = new Uint32Array(n3 + 1), s5 = (t7, o3) => {
    t7 < o3 ? c4[t7 + 1]++ : e3[o3 + 1]++;
  };
  for (let x = 0; x < r2; x++) {
    const o3 = t6[3 * x], n4 = t6[3 * x + 1], r3 = t6[3 * x + 2];
    s5(o3, n4), s5(n4, r3), s5(r3, o3);
  }
  let f5 = 0, l2 = 0;
  for (let x = 0; x < n3; x++) {
    const t7 = c4[x + 1], o3 = e3[x + 1];
    c4[x + 1] = f5, e3[x + 1] = l2, f5 += t7, l2 += o3;
  }
  const i2 = new Uint32Array(6 * r2), a4 = c4[n3], w3 = (t7, o3, n4) => {
    if (t7 < o3) {
      const r3 = c4[t7 + 1]++;
      i2[2 * r3] = o3, i2[2 * r3 + 1] = n4;
    } else {
      const r3 = e3[o3 + 1]++;
      i2[2 * a4 + 2 * r3] = t7, i2[2 * a4 + 2 * r3 + 1] = n4;
    }
  };
  for (let x = 0; x < r2; x++) {
    const o3 = t6[3 * x], n4 = t6[3 * x + 1], r3 = t6[3 * x + 2];
    w3(o3, n4, x), w3(n4, r3, x), w3(r3, o3, x);
  }
  const y3 = (t7, o3) => {
    const n4 = 2 * t7, r3 = o3 - t7;
    for (let c5 = 1; c5 < r3; c5++) {
      const t8 = i2[n4 + 2 * c5], o4 = i2[n4 + 2 * c5 + 1];
      let r4 = c5 - 1;
      for (; r4 >= 0 && i2[n4 + 2 * r4] > t8; r4--) i2[n4 + 2 * r4 + 2] = i2[n4 + 2 * r4], i2[n4 + 2 * r4 + 3] = i2[n4 + 2 * r4 + 1];
      i2[n4 + 2 * r4 + 2] = t8, i2[n4 + 2 * r4 + 3] = o4;
    }
  };
  for (let x = 0; x < n3; x++) y3(c4[x], c4[x + 1]), y3(a4 + e3[x], a4 + e3[x + 1]);
  const A3 = new Int32Array(3 * r2), U = (o3, n4) => o3 === t6[3 * n4] ? 0 : o3 === t6[3 * n4 + 1] ? 1 : o3 === t6[3 * n4 + 2] ? 2 : -1, u5 = (t7, o3) => {
    const n4 = U(t7, o3);
    A3[3 * o3 + n4] = -1;
  }, p6 = (t7, o3, n4, r3) => {
    const c5 = U(t7, o3);
    A3[3 * o3 + c5] = r3;
    const e4 = U(n4, r3);
    A3[3 * r3 + e4] = o3;
  };
  for (let x = 0; x < n3; x++) {
    let t7 = c4[x];
    const o3 = c4[x + 1];
    let n4 = e3[x];
    const r3 = e3[x + 1];
    for (; t7 < o3 && n4 < r3; ) {
      const o4 = i2[2 * t7], r4 = i2[2 * a4 + 2 * n4];
      o4 === r4 ? (p6(x, i2[2 * t7 + 1], r4, i2[2 * a4 + 2 * n4 + 1]), t7++, n4++) : o4 < r4 ? (u5(x, i2[2 * t7 + 1]), t7++) : (u5(r4, i2[2 * a4 + 2 * n4 + 1]), n4++);
    }
    for (; t7 < o3; ) u5(x, i2[2 * t7 + 1]), t7++;
    for (; n4 < r3; ) {
      u5(i2[2 * a4 + 2 * n4], i2[2 * a4 + 2 * n4 + 1]), n4++;
    }
  }
  return A3;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/edgeBufferWriters.js
var a2 = 0.7;
var c2 = class {
  updateSettings(t6) {
    this.settings = t6, this._edgeHashFunction = t6.reducedPrecision ? d2 : u3;
  }
  write(t6, e3, o2) {
    S.seed = this._edgeHashFunction(o2);
    const n3 = S.getIntRange(0, 255), r2 = S.getIntRange(0, this.settings.variants - 1), i2 = S.getFloat(), s5 = 255 * (0.5 * g(-(1 - Math.min(i2 / a2, 1)) + Math.max(0, i2 - a2) / (1 - a2), 1.2) + 0.5);
    t6.position0.setVec(e3, o2.position0), t6.position1.setVec(e3, o2.position1), t6.componentIndex.set(e3, o2.componentIndex), t6.variantOffset.set(e3, n3), t6.variantStroke.set(e3, r2), t6.variantExtension.set(e3, s5);
  }
};
var m3 = new Float32Array(6);
var f3 = new Uint32Array(m3.buffer);
var p4 = new Uint32Array(1);
function u3(t6) {
  return m3[0] = t6.position0[0], m3[1] = t6.position0[1], m3[2] = t6.position0[2], m3[3] = t6.position1[0], m3[4] = t6.position1[1], m3[5] = t6.position1[2], p4[0] = 31 * (31 * (31 * (31 * (31 * (166811 + f3[0]) + f3[1]) + f3[2]) + f3[3]) + f3[4]) + f3[5], p4[0];
}
function d2(t6) {
  const e3 = m3;
  e3[0] = h(t6.position0[0]), e3[1] = h(t6.position0[1]), e3[2] = h(t6.position0[2]), e3[3] = h(t6.position1[0]), e3[4] = h(t6.position1[1]), e3[5] = h(t6.position1[2]), p4[0] = 5381;
  for (let o2 = 0; o2 < f3.length; o2++) p4[0] = 31 * p4[0] + f3[o2];
  return p4[0];
}
var l = 1e4;
function h(t6) {
  return Math.round(t6 * l) / l;
}
function g(t6, e3) {
  return Math.abs(t6) ** e3 * Math.sign(t6);
}
var w2 = class {
  constructor() {
    this._commonWriter = new c2();
  }
  updateSettings(t6) {
    this._commonWriter.updateSettings(t6);
  }
  allocate(t6) {
    return s3.createBuffer(t6);
  }
  write(t6, n3, i2) {
    this._commonWriter.write(t6, n3, i2), u(N2, i2.faceNormal0, i2.faceNormal1), A(N2, N2);
    const { typedBuffer: s5, typedBufferStride: a4 } = t6.normalCompressed;
    e2(s5, n3, N2[0], N2[1], N2[2], a4);
  }
};
var y2 = class {
  constructor() {
    this._commonWriter = new c2();
  }
  updateSettings(t6) {
    this._commonWriter.updateSettings(t6);
  }
  allocate(t6) {
    return a.createBuffer(t6);
  }
  write(t6, e3, o2) {
    this._commonWriter.write(t6, e3, o2);
    {
      const { typedBuffer: n3, typedBufferStride: i2 } = t6.normalCompressed;
      e2(n3, e3, o2.faceNormal0[0], o2.faceNormal0[1], o2.faceNormal0[2], i2);
    }
    {
      const { typedBuffer: n3, typedBufferStride: i2 } = t6.normal2Compressed;
      e2(n3, e3, o2.faceNormal1[0], o2.faceNormal1[1], o2.faceNormal1[2], i2);
    }
  }
};
var N2 = n();
var S = new t();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/edgeProcessing.js
function c3(e3) {
  const t6 = f4(e3.data, e3.skipDeduplicate, e3.indices, e3.indicesLength);
  return p5.updateSettings(e3.writerSettings), d3.updateSettings(e3.writerSettings), d(t6, p5, d3);
}
function f4(i2, r2, n3, o2) {
  if (r2) {
    const e3 = t5(n3, o2, i2.count);
    return new u4(n3, o2, e3, i2);
  }
  const c4 = e(i2.buffer, i2.stride / 4, { originalIndices: n3 }), f5 = t5(c4.indices, o2, c4.uniqueCount);
  return { faces: c4.indices, facesLength: c4.indices.length, neighbors: f5, vertices: t4.createView(c4.buffer) };
}
var u4 = class {
  constructor(e3, t6, i2, s5) {
    this.faces = e3, this.facesLength = t6, this.neighbors = i2, this.vertices = s5;
  }
};
var p5 = new w2();
var d3 = new y2();
var a3 = Q().vec3f("position0").vec3f("position1");
var g2 = Q().vec3f("position0").vec3f("position1").u16("componentIndex");

export {
  t4 as t,
  d,
  c3 as c,
  f4 as f,
  a3 as a,
  g2 as g
};
//# sourceMappingURL=chunk-RJMNQ6EU.js.map
