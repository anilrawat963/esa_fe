import {
  c as c3
} from "./chunk-BZV32YR7.js";
import {
  i as i3
} from "./chunk-AJG2ZYEA.js";
import {
  i as i2
} from "./chunk-ZVTEFYZX.js";
import {
  a as a2
} from "./chunk-LPUPM55U.js";
import {
  o as o3,
  s
} from "./chunk-VYMBX5H5.js";
import {
  m as m3
} from "./chunk-63LDVRFI.js";
import {
  e as e3
} from "./chunk-K2OZ6WVC.js";
import {
  e,
  n as n3,
  u
} from "./chunk-C5OQVQZF.js";
import {
  c as c2,
  f,
  i,
  l,
  m as m2,
  n as n2,
  o as o2,
  r as r2,
  x
} from "./chunk-XLOINTMG.js";
import {
  c,
  n,
  o
} from "./chunk-75XOUSSS.js";
import {
  n as n4
} from "./chunk-LTPHDYPK.js";
import {
  e as e2
} from "./chunk-3OVERDFX.js";
import {
  r
} from "./chunk-SMWUT52Z.js";
import {
  b,
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  has
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/views/3d/support/debugFlags.js
var T = class extends b {
  constructor() {
    super(...arguments), this.SCENEVIEW_HITTEST_RETURN_INTERSECTOR = false, this.DECONFLICTOR_SHOW_VISIBLE = false, this.DECONFLICTOR_SHOW_INVISIBLE = false, this.DECONFLICTOR_SHOW_GRID = false, this.LABELS_SHOW_BORDER = false, this.TEXT_SHOW_BASELINE = false, this.TEXT_SHOW_BORDER = false, this.OVERLAY_DRAW_DEBUG_TEXTURE = false, this.OVERLAY_SHOW_CENTER = false, this.SHOW_POI = false, this.TESTS_DISABLE_OPTIMIZATIONS = false, this.TESTS_DISABLE_FAST_UPDATES = false, this.DRAW_MESH_GEOMETRY_NORMALS = false, this.FEATURE_TILE_FETCH_SHOW_TILES = false, this.FEATURE_TILE_TREE_SHOW_TILES = false, this.TERRAIN_TILE_TREE_SHOW_TILES = false, this.I3S_TREE_SHOW_TILES = false, this.I3S_SHOW_MODIFICATIONS = false, this.LOD_INSTANCE_RENDERER_DISABLE_UPDATES = false, this.LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL = false, this.EDGES_SHOW_HIDDEN_TRANSPARENT_EDGES = false, this.LINE_WIREFRAMES = false;
  }
};
__decorate([m()], T.prototype, "SCENEVIEW_HITTEST_RETURN_INTERSECTOR", void 0), __decorate([m()], T.prototype, "DECONFLICTOR_SHOW_VISIBLE", void 0), __decorate([m()], T.prototype, "DECONFLICTOR_SHOW_INVISIBLE", void 0), __decorate([m()], T.prototype, "DECONFLICTOR_SHOW_GRID", void 0), __decorate([m()], T.prototype, "LABELS_SHOW_BORDER", void 0), __decorate([m()], T.prototype, "TEXT_SHOW_BASELINE", void 0), __decorate([m()], T.prototype, "TEXT_SHOW_BORDER", void 0), __decorate([m()], T.prototype, "OVERLAY_DRAW_DEBUG_TEXTURE", void 0), __decorate([m()], T.prototype, "OVERLAY_SHOW_CENTER", void 0), __decorate([m()], T.prototype, "SHOW_POI", void 0), __decorate([m()], T.prototype, "TESTS_DISABLE_OPTIMIZATIONS", void 0), __decorate([m()], T.prototype, "TESTS_DISABLE_FAST_UPDATES", void 0), __decorate([m()], T.prototype, "DRAW_MESH_GEOMETRY_NORMALS", void 0), __decorate([m()], T.prototype, "FEATURE_TILE_FETCH_SHOW_TILES", void 0), __decorate([m()], T.prototype, "FEATURE_TILE_TREE_SHOW_TILES", void 0), __decorate([m()], T.prototype, "TERRAIN_TILE_TREE_SHOW_TILES", void 0), __decorate([m()], T.prototype, "I3S_TREE_SHOW_TILES", void 0), __decorate([m()], T.prototype, "I3S_SHOW_MODIFICATIONS", void 0), __decorate([m()], T.prototype, "LOD_INSTANCE_RENDERER_DISABLE_UPDATES", void 0), __decorate([m()], T.prototype, "LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL", void 0), __decorate([m()], T.prototype, "EDGES_SHOW_HIDDEN_TRANSPARENT_EDGES", void 0), __decorate([m()], T.prototype, "LINE_WIREFRAMES", void 0), T = __decorate([a("esri.views.3d.support.debugFlags")], T);
var t = new T();

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Float4sPassUniform.js
var e4 = class extends i3 {
  constructor(r5, e6, o4, s2) {
    super(r5, "vec4", 1, (o5, t3, c4) => o5.setUniform4fv(r5, e6(t3, c4), s2), o4);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/FloatsPassUniform.js
var r3 = class extends i3 {
  constructor(o4, r5, s2, t3) {
    super(o4, "float", 1, (s3, e6, f2) => s3.setUniform1fv(o4, r5(e6, f2), t3), s2);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/effects/geometry/olidUtils.js
function e5() {
  return !!has("enable-feature:objectAndLayerId-rendering");
}

// node_modules/@arcgis/core/views/3d/layers/support/FastSymbolUpdates.js
var j = class {
  constructor(t3) {
    this.field = t3;
  }
};
var M = class extends j {
  constructor(t3) {
    super(t3), this.minSize = [0, 0, 0], this.maxSize = [0, 0, 0], this.offset = [0, 0, 0], this.factor = [0, 0, 0], this.type = [0, 0, 0], this.fallback = [0, 0, 0];
  }
};
var I = class extends j {
  constructor(t3) {
    super(t3), this.colors = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], this.values = [0, 0, 0, 0, 0, 0, 0, 0], this.fallback = [0, 0, 0, 0];
  }
};
var N = class extends j {
  constructor(t3, o4 = 0) {
    super(t3), this.fallback = o4, this.values = [0, 0, 0, 0, 0, 0, 0, 0], this.opacityValues = [0, 0, 0, 0, 0, 0, 0, 0];
  }
};
var T2 = class {
};
function U(t3) {
  return null != t3;
}
function D(t3, o4) {
  t3 && t3.push(o4);
}
function F(t3, o4, e6, i4 = e3()) {
  const s2 = t3 || 0, r5 = o4 || 0, n5 = e6 || 0;
  return 0 !== s2 && x(i4, i4, -s2 / 180 * Math.PI), 0 !== r5 && l(i4, i4, r5 / 180 * Math.PI), 0 !== n5 && m2(i4, i4, n5 / 180 * Math.PI), i4;
}
function A(t3, o4, e6, i4, s2) {
  const r5 = t3.minSize, n5 = t3.maxSize;
  if (t3.useSymbolValue) {
    const t4 = i4.symbolSize[e6];
    return o4.minSize[e6] = t4, o4.maxSize[e6] = t4, o4.offset[e6] = o4.minSize[e6], o4.factor[e6] = 0, o4.type[e6] = 1, true;
  }
  if (U(t3.field)) return U(t3.stops) ? 2 === t3.stops.length && n3(t3.stops[0].size) && n3(t3.stops[1].size) ? (R(t3.stops[0].size, t3.stops[1].size, t3.stops[0].value, t3.stops[1].value, o4, e6), o4.type[e6] = 1, true) : (D(s2, "Could not convert size info: stops only supported with 2 elements"), false) : n3(r5) && n3(n5) && U(t3.minDataValue) && U(t3.maxDataValue) ? (R(r5, n5, t3.minDataValue, t3.maxDataValue, o4, e6), o4.type[e6] = 1, true) : "unknown" === t3.valueUnit ? (D(s2, "Could not convert size info: proportional size not supported"), false) : null != m3[t3.valueUnit] ? (o4.minSize[e6] = -1 / 0, o4.maxSize[e6] = 1 / 0, o4.offset[e6] = 0, o4.factor[e6] = 1 / m3[t3.valueUnit], o4.type[e6] = 1, true) : (D(s2, "Could not convert size info: scale-dependent size not supported"), false);
  if (!U(t3.field)) {
    if (t3.stops?.[0] && n3(t3.stops[0].size)) return o4.minSize[e6] = t3.stops[0].size, o4.maxSize[e6] = t3.stops[0].size, o4.offset[e6] = o4.minSize[e6], o4.factor[e6] = 0, o4.type[e6] = 1, true;
    if (n3(r5)) return o4.minSize[e6] = r5, o4.maxSize[e6] = r5, o4.offset[e6] = r5, o4.factor[e6] = 0, o4.type[e6] = 1, true;
  }
  return D(s2, "Could not convert size info: unsupported variant of sizeInfo"), false;
}
function R(t3, o4, e6, i4, s2, r5) {
  const n5 = Math.abs(i4 - e6) > 0 ? (o4 - t3) / (i4 - e6) : 0;
  s2.minSize[r5] = n5 > 0 ? t3 : o4, s2.maxSize[r5] = n5 > 0 ? o4 : t3, s2.offset[r5] = t3 - e6 * n5, s2.factor[r5] = n5;
}
function E(t3, o4, e6, i4) {
  if (t3.normalizationField || t3.valueRepresentation) return D(i4, "Could not convert size info: unsupported property"), null;
  if (!u(t3.field)) return D(i4, "Could not convert size info: field is not a string"), null;
  if (o4.size) {
    if (t3.field) if (o4.size.field) {
      if (t3.field !== o4.size.field) return D(i4, "Could not convert size info: multiple fields in use"), null;
    } else o4.size.field = t3.field;
  } else o4.size = new M(t3.field), s(o4.size.fallback, e6.fallbackSize);
  let s2;
  switch (t3.axis) {
    case "width":
      return s2 = A(t3, o4.size, 0, e6, i4), s2 ? o4 : null;
    case "height":
      return s2 = A(t3, o4.size, 2, e6, i4), s2 ? o4 : null;
    case "depth":
      return s2 = A(t3, o4.size, 1, e6, i4), s2 ? o4 : null;
    case "width-and-depth":
      return s2 = A(t3, o4.size, 0, e6, i4), s2 && A(t3, o4.size, 1, e6, i4), s2 ? o4 : null;
    case null:
    case void 0:
    case "all":
      return s2 = A(t3, o4.size, 0, e6, i4), s2 = s2 && A(t3, o4.size, 1, e6, i4), s2 = s2 && A(t3, o4.size, 2, e6, i4), s2 ? o4 : null;
    default:
      return D(i4, `Could not convert size info: unknown axis "${t3.axis}""`), null;
  }
}
function O(t3, o4, e6) {
  for (let s2 = 0; s2 < 3; ++s2) {
    let e7 = o4.unitInMeters;
    1 === t3.type[s2] && (e7 *= o4.modelSize[s2], t3.type[s2] = 2), t3.minSize[s2] = t3.minSize[s2] / e7, t3.maxSize[s2] = t3.maxSize[s2] / e7, t3.offset[s2] = t3.offset[s2] / e7, t3.factor[s2] = t3.factor[s2] / e7;
  }
  let i4;
  if (0 !== t3.type[0]) i4 = 0;
  else if (0 !== t3.type[1]) i4 = 1;
  else {
    if (0 === t3.type[2]) return D(e6, "No size axis contains a valid size or scale"), false;
    i4 = 2;
  }
  for (let s2 = 0; s2 < 3; ++s2) 0 === t3.type[s2] && (t3.minSize[s2] = t3.minSize[i4], t3.maxSize[s2] = t3.maxSize[i4], t3.offset[s2] = t3.offset[i4], t3.factor[s2] = t3.factor[i4], t3.type[s2] = t3.type[i4]);
  return true;
}
function _(t3, o4, e6) {
  t3[4 * o4] = e6.r / 255, t3[4 * o4 + 1] = e6.g / 255, t3[4 * o4 + 2] = e6.b / 255, t3[4 * o4 + 3] = e6.a;
}
function q(t3, o4, e6, i4) {
  if (t3.normalizationField) return D(i4, "Could not convert color info: unsupported property"), null;
  if (e(t3.field)) {
    if (!t3.stops) return D(i4, "Could not convert color info: missing stops or colors"), null;
    {
      if (t3.stops.length > 8) return D(i4, "Could not convert color info: too many color stops"), null;
      o4.color = new I(t3.field);
      const s2 = t3.stops;
      for (let t4 = 0; t4 < 8; ++t4) {
        const e7 = s2[Math.min(t4, s2.length - 1)];
        o4.color.values[t4] = e7.value, _(o4.color.colors, t4, e7.color);
      }
      a2(o4.color.fallback, e6.fallbackColor);
    }
  } else {
    if (!(t3.stops && t3.stops.length >= 0)) return D(i4, "Could not convert color info: no field and no colors/stops"), null;
    {
      const i5 = t3.stops && t3.stops.length >= 0 && t3.stops[0].color;
      o4.color = new I(null);
      for (let t4 = 0; t4 < 8; t4++) o4.color.values[t4] = 1 / 0, _(o4.color.colors, t4, i5);
      a2(o4.color.fallback, e6.fallbackColor);
    }
  }
  return o4;
}
function $(t3, o4, e6, i4) {
  if (t3.normalizationField) return D(i4, "Could not convert opacity info: unsupported property"), null;
  if (e(t3.field)) {
    if (!t3.stops) return D(i4, "Could not convert opacity info: missing stops or opacities"), null;
    {
      if (t3.stops.length > 8) return D(i4, "Could not convert opacity info: too many opacity stops"), null;
      o4.opacity = new N(t3.field, e6.fallbackColor[3]);
      const s2 = t3.stops;
      for (let t4 = 0; t4 < 8; ++t4) {
        const e7 = s2[Math.min(t4, s2.length - 1)];
        o4.opacity.values[t4] = e7.value, o4.opacity.opacityValues[t4] = e7.opacity;
      }
    }
  } else {
    if (!(t3.stops && t3.stops.length >= 0)) return D(i4, "Could not convert opacity info: no field and no opacities/stops"), null;
    {
      const i5 = t3.stops && t3.stops.length >= 0 ? t3.stops[0].opacity : 0;
      o4.opacity = { field: null, values: [0, 0, 0, 0, 0, 0, 0, 0], opacityValues: [0, 0, 0, 0, 0, 0, 0, 0], fallback: e6.fallbackColor[3] };
      for (let t4 = 0; t4 < 8; t4++) o4.opacity.values[t4] = 1 / 0, o4.opacity.opacityValues[t4] = i5;
    }
  }
  return o4;
}
function B(t3, o4, e6) {
  const i4 = 2 === e6 && "arithmetic" === t3.rotationType;
  o4.offset[e6] = i4 ? 90 : 0, o4.factor[e6] = i4 ? -1 : 1, o4.type[e6] = 1;
}
function L(t3, o4, e6) {
  if (!e(t3.field)) return D(e6, "Could not convert rotation info: field is not a string"), null;
  if (o4.rotation) {
    if (t3.field) if (o4.rotation.field) {
      if (t3.field !== o4.rotation.field) return D(e6, "Could not convert rotation info: multiple fields in use"), null;
    } else o4.rotation.field = t3.field;
  } else o4.rotation = { field: t3.field, offset: [0, 0, 0], factor: [1, 1, 1], type: [0, 0, 0] };
  switch (t3.axis) {
    case "tilt":
      return B(t3, o4.rotation, 0), o4;
    case "roll":
      return B(t3, o4.rotation, 1), o4;
    case null:
    case void 0:
    case "heading":
      return B(t3, o4.rotation, 2), o4;
    default:
      return D(e6, `Could not convert rotation info: unknown axis "${t3.axis}""`), null;
  }
}
var G = class {
  constructor({ supports: t3, modelSize: o4, symbolSize: e6, unitInMeters: i4, anchor: s2, scale: r5, rotation: n5, fallbackColor: l2, fallbackSize: a3 }) {
    this.supports = t3, this.modelSize = o4 ?? c(), this.symbolSize = e6 ?? c(), this.unitInMeters = i4 ?? 1, this.anchor = s2 ?? o(), this.scale = r5 ?? c(), this.rotation = n5 ?? o(), this.fallbackColor = l2 ?? i2(), this.fallbackSize = a3 ?? c();
  }
};
function H(t3, o4, e6) {
  if (!t3) return null;
  const i4 = t3.reduce((t4, i5) => {
    if (!t4) return t4;
    if (i5.valueExpression) return D(e6, "Could not convert visual variables: arcade expressions not supported"), null;
    switch (i5.type) {
      case "size":
        return o4.supports.size ? E(i5, t4, o4, e6) : t4;
      case "color":
        return o4.supports.color ? q(i5, t4, o4, e6) : t4;
      case "opacity":
        return o4.supports.opacity ? $(i5, t4, o4, e6) : null;
      case "rotation":
        return o4.supports.rotation ? L(i5, t4, e6) : t4;
      default:
        return null;
    }
  }, new T2());
  return !(t3.length > 0 && i4) || i4.size || i4.color || i4.opacity || i4.rotation ? i4?.size && !O(i4.size, o4, e6) ? null : i4 : null;
}
var J = class {
  constructor(t3, o4, e6) {
    this.visualVariables = t3, this.materialParameters = o4, this.requiresShaderTransformation = e6;
  }
};
function K(t3, o4) {
  if (!t3) return null;
  if (e5()) return null;
  if (t.TESTS_DISABLE_FAST_UPDATES) return null;
  const e6 = H(t3.visualVariables, o4);
  return e6 ? new J(e6, Y(e6, o4), !!e6.size) : null;
}
function Q(t3, o4, e6) {
  if (!o4 || !t3) return false;
  const i4 = t3.visualVariables, s2 = H(o4.visualVariables, e6);
  return !!s2 && (!!(W(i4.size, s2.size, "size") && W(i4.color, s2.color, "color") && W(i4.rotation, s2.rotation, "rotation") && W(i4.opacity, s2.opacity, "opacity")) && (t3.visualVariables = s2, t3.materialParameters = Y(s2, e6), t3.requiresShaderTransformation = !!s2.size, true));
}
function W(t3, o4, e6) {
  if (!!t3 != !!o4) return false;
  if (t3 && t3.field !== o4?.field) return false;
  if (t3 && "rotation" === e6) {
    const e7 = t3, i4 = o4;
    for (let t4 = 0; t4 < 3; t4++) if (e7.type[t4] !== i4.type[t4] || e7.offset[t4] !== i4.offset[t4] || e7.factor[t4] !== i4.factor[t4]) return false;
  }
  return true;
}
var X = class extends c3 {
  constructor(t3) {
    super(), this.vvSize = t3?.size ?? null, this.vvColor = t3?.color ?? null, this.vvOpacity = t3?.opacity ?? null;
  }
  get hasVVSize() {
    return !!this.vvSize;
  }
  get hasVVColor() {
    return !!this.vvColor;
  }
  get hasVVOpacity() {
    return !!this.vvOpacity;
  }
};
function Y(t3, s2) {
  const r5 = new X(t3);
  return r5.vvSize && (r5.vvSymbolAnchor = s2.anchor, o2(st), F(s2.rotation[2], s2.rotation[0], s2.rotation[1], st), r5.vvSymbolRotationMatrix = r5.vvSymbolRotationMatrix || e2(), n4(r5.vvSymbolRotationMatrix, st)), r5;
}
function Z(t3, o4, e6) {
  if (!t3.vvSize) return e6;
  n2(et, e6);
  const i4 = t3.vvSymbolRotationMatrix;
  return r2(st, i4[0], i4[1], i4[2], 0, i4[3], i4[4], i4[5], 0, i4[6], i4[7], i4[8], 0, 0, 0, 0, 1), c2(et, et, st), tt(it, t3, o4), f(et, et, it), i(et, et, t3.vvSymbolAnchor), et;
}
function tt(o4, e6, i4) {
  if (!e6.vvSize) return o3(o4, 1, 1, 1), o4;
  if (Number.isNaN(i4[0])) return s(o4, e6.vvSize.fallback);
  for (let s2 = 0; s2 < 3; ++s2) {
    const r5 = e6.vvSize.offset[s2] + i4[0] * e6.vvSize.factor[s2];
    o4[s2] = r(r5, e6.vvSize.minSize[s2], e6.vvSize.maxSize[s2]);
  }
  return o4;
}
function ot(t3, o4) {
  const e6 = null == t3 ? 0 : o4.attributes[t3];
  return "number" == typeof e6 && isFinite(e6) ? e6 : NaN;
}
var et = e3();
var it = n();
var st = e3();

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/VisualVariablePassParameters.js
var t2 = class extends X {
  constructor() {
    super(...arguments), this.renderOccluded = 1, this.isDecoration = false;
  }
};
var r4 = 8;

export {
  t,
  e5 as e,
  e4 as e2,
  r3 as r,
  G,
  K,
  Q,
  Z,
  tt,
  ot,
  t2,
  r4 as r2
};
//# sourceMappingURL=chunk-F43BIMML.js.map
