import {
  de
} from "./chunk-UTFQHSO2.js";
import "./chunk-F5JN6VXH.js";
import "./chunk-4YQFF2F7.js";
import {
  c as c3
} from "./chunk-B5JDN6EY.js";
import "./chunk-Y2DYCFJT.js";
import "./chunk-HUA6ZZZG.js";
import "./chunk-UP6PVI7I.js";
import {
  j as j2
} from "./chunk-QMZNFXS2.js";
import "./chunk-6AWERJZ7.js";
import {
  e as e4
} from "./chunk-I7PJIK77.js";
import "./chunk-Y2GQGUGW.js";
import "./chunk-GGINWBRK.js";
import "./chunk-IJG47UFZ.js";
import "./chunk-M6NE6PU7.js";
import "./chunk-Z3EPMK46.js";
import "./chunk-2XEDAAX5.js";
import "./chunk-BCL23HLU.js";
import "./chunk-H6PLTW7B.js";
import "./chunk-ZG2JXORT.js";
import "./chunk-OL6EYE44.js";
import "./chunk-36YQJD5W.js";
import "./chunk-BQ6DEXWK.js";
import "./chunk-3SCRAN3E.js";
import {
  R,
  j,
  q,
  y as y3
} from "./chunk-NTNXXNRP.js";
import {
  l as l3
} from "./chunk-CUJ626VQ.js";
import "./chunk-IGRCAVBL.js";
import {
  r as r2
} from "./chunk-TKBXUE73.js";
import {
  U as U2,
  c as c2,
  h as h3,
  t as t2
} from "./chunk-GD72EK2J.js";
import "./chunk-BRGWF4BT.js";
import "./chunk-B3BLJNSM.js";
import "./chunk-ALKEERWI.js";
import "./chunk-JBTWCDRR.js";
import "./chunk-U6CJFTOF.js";
import "./chunk-M5JMVUW2.js";
import "./chunk-2JMKFI2D.js";
import "./chunk-QYAMBIRP.js";
import {
  I as I2
} from "./chunk-XTEXJOLG.js";
import "./chunk-GVMCGYZ6.js";
import "./chunk-JHV6OBEB.js";
import "./chunk-WHHIH5YU.js";
import "./chunk-5LMH6D7V.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import "./chunk-RORL5XZJ.js";
import "./chunk-E64QZ35H.js";
import "./chunk-VATXM3AM.js";
import "./chunk-FXT57D73.js";
import "./chunk-CJCWAWMZ.js";
import "./chunk-PRKYHOVW.js";
import "./chunk-TCIOA3WX.js";
import "./chunk-5IXGYDQ3.js";
import "./chunk-RKVVFTIZ.js";
import "./chunk-WJ5RYEGC.js";
import "./chunk-7TAAMEZT.js";
import "./chunk-4POFO7MP.js";
import "./chunk-257FD5T2.js";
import "./chunk-ZNI54T6D.js";
import {
  e as e3
} from "./chunk-EKZRA6TO.js";
import "./chunk-M5SP6ZBM.js";
import {
  n as n3
} from "./chunk-JCA5ZKDG.js";
import "./chunk-E7PJOFGP.js";
import "./chunk-4VQDBNTM.js";
import {
  f as f6
} from "./chunk-3BNOOWTA.js";
import "./chunk-AIJLLSRB.js";
import "./chunk-VX2NEBRT.js";
import "./chunk-T3SYSTKO.js";
import "./chunk-QSGJ3ECU.js";
import {
  _ as _3
} from "./chunk-IPWH4LK2.js";
import "./chunk-52SEOH5H.js";
import "./chunk-7HTU7ZUX.js";
import "./chunk-WDTGOP77.js";
import {
  I
} from "./chunk-VYMBX5H5.js";
import {
  h as h2
} from "./chunk-BPTFV5VM.js";
import "./chunk-647DAMHU.js";
import "./chunk-O6G3PPOK.js";
import "./chunk-ZKNZTIAS.js";
import "./chunk-OJMISN3F.js";
import "./chunk-EFV6H5NA.js";
import {
  f as f5
} from "./chunk-XDLV73DB.js";
import "./chunk-ARTU4L55.js";
import "./chunk-4WTOIJXV.js";
import "./chunk-BBYMM7CM.js";
import {
  r
} from "./chunk-EM7Y2JZC.js";
import "./chunk-QZQPB5XR.js";
import "./chunk-AQFRVV3U.js";
import {
  n as n2
} from "./chunk-36OXW4YN.js";
import "./chunk-PEL3D3ZN.js";
import "./chunk-Q5KWD3VQ.js";
import "./chunk-BUQC3CLV.js";
import "./chunk-W5S3VUFT.js";
import "./chunk-7YH7T6CS.js";
import {
  c
} from "./chunk-3T4IXPP4.js";
import "./chunk-XTZAIV4X.js";
import "./chunk-63LDVRFI.js";
import "./chunk-TJTOV6JD.js";
import {
  _ as _4
} from "./chunk-C3FRY5U4.js";
import "./chunk-JNJX34GB.js";
import "./chunk-3STJRSDT.js";
import "./chunk-67Q6KVC6.js";
import {
  n
} from "./chunk-23NJHA5Q.js";
import "./chunk-4LA6K4VI.js";
import "./chunk-KEZCWFAR.js";
import "./chunk-JZUJ34RR.js";
import "./chunk-PMGS7UDU.js";
import "./chunk-3GHCGAH2.js";
import "./chunk-HWUOAPTX.js";
import "./chunk-QHCKOBU7.js";
import "./chunk-K2OZ6WVC.js";
import "./chunk-MC6NAKKX.js";
import "./chunk-TF6255HN.js";
import "./chunk-GD4FJL3C.js";
import "./chunk-C5OQVQZF.js";
import "./chunk-F7DKSAOI.js";
import {
  m as m6
} from "./chunk-4SOQWNPG.js";
import "./chunk-LTULADK2.js";
import "./chunk-35ST7YRB.js";
import "./chunk-EDA5QFHZ.js";
import {
  o as o4
} from "./chunk-GEGX35PE.js";
import "./chunk-6Z5KSPPF.js";
import "./chunk-CNYNCKEV.js";
import {
  d as d2
} from "./chunk-XL5QPCXN.js";
import {
  N as N3,
  W,
  X
} from "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-P6IKJIMO.js";
import "./chunk-MHV23XAQ.js";
import "./chunk-V2X4OKYI.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import "./chunk-MA3QDRC3.js";
import "./chunk-W6J7XCPU.js";
import "./chunk-ONXWBTTM.js";
import {
  f as f4
} from "./chunk-T7F6Q6JJ.js";
import {
  O
} from "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-7P2ANHQ3.js";
import "./chunk-XCKT47LJ.js";
import {
  m as m5
} from "./chunk-3FUHCAX3.js";
import {
  y3 as y2
} from "./chunk-PZ5RULLK.js";
import {
  z
} from "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import {
  _ as _2,
  m as m4
} from "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import {
  U,
  a as a3,
  f as f2,
  l as l2,
  w as w2
} from "./chunk-2OFHDVO5.js";
import {
  l
} from "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import {
  m as m3
} from "./chunk-5UPBUJPC.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import {
  u as u3
} from "./chunk-CCQFL76O.js";
import "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import "./chunk-7H3U4IJR.js";
import {
  P,
  o as o3
} from "./chunk-SMWUT52Z.js";
import {
  _
} from "./chunk-AXZMNHTN.js";
import {
  f as f3
} from "./chunk-5T3MJDSR.js";
import {
  G,
  G3 as G2,
  H,
  N2,
  ae,
  ne
} from "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import {
  b,
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import {
  $,
  T,
  a as a2,
  d,
  e,
  e2,
  f2 as f,
  m2,
  o,
  o2,
  s as s2,
  t,
  u2 as u,
  u3 as u2,
  w,
  y
} from "./chunk-GNMPGHLQ.js";
import {
  h,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  M,
  N,
  i
} from "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/views/analysis/AnalysisView.js
var n4 = class extends m3(l) {
  constructor() {
    super(...arguments), this.parent = null, this._userInteractive = false, this._interactiveViewModelCount = 0;
  }
  get interactive() {
    return this._interactiveViewModelCount > 0 || this._userInteractive;
  }
  set interactive(e10) {
    this._userInteractive = e10;
  }
  get updating() {
    return false;
  }
  get visible() {
    return (this.parent?.visible && !this.parent.suspended) ?? true;
  }
  set visible(e10) {
    this._overrideIfSome("visible", e10);
  }
  forceInteractive() {
    return this._interactiveViewModelCount++, e(() => this._interactiveViewModelCount--);
  }
};
__decorate([m({ constructOnly: true })], n4.prototype, "parent", void 0), __decorate([m({ constructOnly: true })], n4.prototype, "view", void 0), __decorate([m({ type: Boolean })], n4.prototype, "interactive", null), __decorate([m()], n4.prototype, "_userInteractive", void 0), __decorate([m({ readOnly: true })], n4.prototype, "updating", null), __decorate([m()], n4.prototype, "visible", null), __decorate([m()], n4.prototype, "_interactiveViewModelCount", void 0), n4 = __decorate([a("esri.views.analysis.AnalysisView")], n4);

// node_modules/@arcgis/core/views/2d/analysis/AnalysisView2D.js
var e5 = class extends n4 {
};
e5 = __decorate([a("esri.views.2d.analysis.AnalysisView2D")], e5);

// node_modules/@arcgis/core/views/analysis/ElevationProfile/elevationProfileInputVisualizationUtils.js
function o5(o10) {
  return t([l2(() => {
    const { analysis: i5, sketchGraphic: e10, toolState: t6, visible: s6 } = o10.analysisViewData, { geometryVisualizationVisible: r6 } = i5.viewOptions;
    return { geometryVisualizationVisible: r6, geometry: i5.geometry, sketchGraphic: e10, toolState: t6, visible: s6 };
  }, ({ geometryVisualizationVisible: i5, sketchGraphic: e10, toolState: t6, visible: s6 }) => {
    if (o10.remove(), s6) return i5 && null != e10 && "reshaping" !== t6 && "sketching" !== t6 ? o10.show(e10) : void 0;
  }, w2)]);
}

// node_modules/@arcgis/core/views/2d/analysis/ElevationProfile/ElevationProfileInputVisualization2D.js
var e6 = class extends b {
  constructor(o10) {
    super(o10);
  }
  initialize() {
    this.addHandles(o5({ analysisViewData: this.analysisViewData, remove: () => {
    }, show: () => {
    } }));
  }
  get updating() {
    return false;
  }
};
__decorate([m({ constructOnly: true })], e6.prototype, "view", void 0), __decorate([m({ constructOnly: true })], e6.prototype, "analysisViewData", void 0), __decorate([m()], e6.prototype, "updating", null), e6 = __decorate([a("esri.views.2d.analysis.ElevationProfile.ElevationProfileInputVisualization2D")], e6);

// node_modules/@arcgis/core/views/analysis/ElevationProfile/constants.js
var l4 = { noDataValue: -5e5, defaultQueryOptions: () => ({ noDataValue: l4.noDataValue, demResolution: "auto", maximumAutoTileRequests: 150, ignoreInvisibleLayers: true, signal: null }), updateThrottleMillis: 100, delayAfterPreviewMillis: 500, defaultDemResolution: N2(10, "centimeters", "meters"), densificationMaxSamples: 3e3, largeChartSamples: 1e4, maxTotalSamples: 1e5, maxChartRatio: 300, minSlopeSampleDistance: 10, formatPrecision: 1, profileLinesUpdateThrottleMillis: 100, hoveredPointsStyle: { size: 14, borderStyle: "solid", borderWidth: 3, borderColor: "#ffffff", boxShadow: "0px 0px 0px 5px rgba(255,255,255,0.2)" } };
function i2() {
  return l4;
}
var r3 = { progress: 1, hasZ: false, samples: [], statistics: null, spatialReference: null };

// node_modules/@arcgis/core/views/analysis/ElevationProfile/elevationProfileVisualizationUtils.js
function l5(l9, n9) {
  l9 ??= [];
  const r6 = l9.length - 1, e10 = [];
  let o10 = [];
  for (let t6 = 0; t6 <= r6; t6++) {
    const { x: n10, y: s6, z: u10 } = l9[t6];
    null != u10 && o10.push([n10, s6, u10]), t6 !== r6 && null != u10 || !o10.length || (e10.push(o10), o10 = []);
  }
  return j2(e10, n9, true);
}

// node_modules/@arcgis/core/views/2d/analysis/ElevationProfile/ElevationProfileLineVisualization2D.js
var d3 = class extends b {
  constructor(t6) {
    super(t6), this._graphic = new _4(), this._layer = new n2({ listMode: "hide", internal: true }), this._updateGeometryThrottled = l3((t7) => {
      if (!t7) return void (this._graphic.visible = false);
      const e10 = this._layer, r6 = this.view.map?.layers;
      r6 && (r6.includes(e10) || r6.add(e10), r6.reorder(e10, 0)), this._graphic.visible = true, this._graphic.geometry = l5(t7.samples, t7.spatialReference);
    }, i2().profileLinesUpdateThrottleMillis);
  }
  initialize() {
    this._layer.add(this._graphic), this.addHandles([f2(() => !this.analysisViewData.visible, () => {
      this._graphic.visible = false;
    }), l2(() => this._colorUpdateParameters, (t6) => this._updateColor(t6), w2), l2(() => this.analysisViewData.analysis.geometry, () => {
      this._graphic.visible = false;
    }, w2), l2(() => this._geometryUpdateParameters, (t6) => this._updateGeometryThrottled(t6), w2), this._updateGeometryThrottled]);
  }
  destroy() {
    this.view.map?.remove(this._layer), this._layer.destroy(), this._graphic.destroy();
  }
  get updating() {
    return this._updateGeometryThrottled.hasPendingUpdates();
  }
  get _result() {
    const { analysisViewData: t6 } = this;
    return t6.visible ? t6.results.find(({ available: t7, computation: e10, rawResult: r6 }) => t7 && e10.profile.viewOptions.lineVisible && true === r6?.hasZ) : null;
  }
  get _geometryUpdateParameters() {
    const t6 = this._result;
    return 1 !== t6?.progress ? null : { samples: t6.samples, spatialReference: this.view.spatialReference };
  }
  get _colorUpdateParameters() {
    const t6 = this._result?.computation.profile.color;
    return t6 ? { color: t6.toArray(), contrastColor: I2(t6).toArray() } : null;
  }
  _updateColor(t6) {
    t6 && (this._graphic.symbol = new n({ data: { type: "CIMSymbolReference", symbol: { type: "CIMLineSymbol", symbolLayers: [{ type: "CIMSolidStroke", capStyle: "Butt", color: t6.color, effects: [{ type: "CIMGeometricEffectDashes", dashTemplate: [5, 4], lineDashEnding: "FullGap", controlPointEnding: "NoConstraint" }], joinStyle: "Round", width: 1.5 }, { type: "CIMSolidStroke", capStyle: "Butt", color: t6.contrastColor, joinStyle: "Round", width: 1.5 }] } } }));
  }
};
__decorate([m({ constructOnly: true })], d3.prototype, "view", void 0), __decorate([m({ constructOnly: true })], d3.prototype, "analysisViewData", void 0), __decorate([m()], d3.prototype, "updating", null), __decorate([m()], d3.prototype, "_result", null), __decorate([m()], d3.prototype, "_geometryUpdateParameters", null), __decorate([m()], d3.prototype, "_colorUpdateParameters", null), d3 = __decorate([a("esri.views.2d.analysis.ElevationProfile.ElevationProfileLineVisualization2D")], d3);

// node_modules/@arcgis/core/views/analysis/ElevationProfile/ElevationProfileHoveredPointVisualization.js
var l6 = class extends b {
  constructor(o10) {
    super(o10), this.position = null, this.color = new u3("#ffffff"), this.element = a4();
  }
  initialize() {
    this.addHandles([l2(() => this._screenLocation, (o10) => {
      o10 && (this.element.style.transform = `translate(${o10.x}px, ${o10.y}px)`);
    }, w2), l2(() => this.color.toCss(), (o10) => {
      this.element.style.background = o10;
    }, w2)]), this.view.surface?.appendChild(this.element);
  }
  destroy() {
    this.element.remove();
  }
  get _screenLocation() {
    const { position: o10, view: e10 } = this;
    "3d" === e10.type ? (e10.commitProperty("size"), e10.commitProperty("camera")) : e10.commitProperty("center");
    const t6 = e10?.spatialReference, r6 = t6 ? X(o10, t6).geometry : null;
    return r6 && e10?.ready ? e10.toScreen(r6) : null;
  }
};
function a4() {
  const o10 = document.createElement("div"), { size: e10, borderStyle: t6, borderColor: r6, borderWidth: i5, boxShadow: s6 } = i2().hoveredPointsStyle, { style: n9 } = o10;
  return n9.display = "block", n9.position = "absolute", n9.top = "0", n9.left = "0", n9.contain = "strict", n9.boxSizing = "border-box", n9.width = `${e10}px`, n9.height = `${e10}px`, n9.marginTop = `-${e10 / 2}px`, n9.marginLeft = `-${e10 / 2}px`, n9.border = `${t6} ${i5}px ${r6}`, n9.borderRadius = `${e10}px`, n9.boxShadow = s6, o10;
}
__decorate([m()], l6.prototype, "position", void 0), __decorate([m({ type: u3 })], l6.prototype, "color", void 0), __decorate([m()], l6.prototype, "view", void 0), __decorate([m()], l6.prototype, "_screenLocation", null), l6 = __decorate([a("esri.views.analysis.ElevationProfile.ElevationProfileHoveredPointVisualization")], l6);

// node_modules/@arcgis/core/views/analysis/ElevationProfile/ElevationProfileHoveredPointsVisualization.js
var l7 = class extends b {
  constructor(o10) {
    super(o10), this._hoveredPoints = new O();
  }
  initialize() {
    const { analysisViewData: o10 } = this, { analysis: t6 } = o10;
    this.addHandles([l2(() => {
      const { hoveredPoints: e10, visible: r6, updating: i5 } = o10;
      return r6 ? i5 ? null : e10.map((o11, e11) => {
        const r7 = t6.profiles.at(e11);
        return true === r7?.viewOptions.hoveredPointVisible && null != o11 ? { hoveredPoint: o11, color: r7.color } : null;
      }).filter((o11) => !!o11) : [];
    }, (o11) => this._update(o11), w2), l2(() => t6.geometry, () => this._update([]), w2)]);
  }
  destroy() {
    this._hoveredPoints.drain((o10) => o10.destroy());
  }
  get updating() {
    return false;
  }
  _update(o10) {
    if (!o10) return;
    const { view: t6, _hoveredPoints: e10 } = this, r6 = o10.length;
    for (; e10.length > r6; ) e10.pop()?.destroy();
    for (; e10.length < r6; ) {
      const o11 = new l6({ view: t6 });
      e10.push(o11);
    }
    for (let i5 = 0; i5 < r6; ++i5) {
      const t7 = o10[i5], s6 = e10.at(r6 - 1 - i5);
      s6.position = t7.hoveredPoint, s6.color = t7.color;
    }
  }
};
__decorate([m()], l7.prototype, "view", void 0), __decorate([m()], l7.prototype, "analysisViewData", void 0), __decorate([m()], l7.prototype, "_hoveredPoints", void 0), __decorate([m()], l7.prototype, "updating", null), l7 = __decorate([a("esri.views.analysis.ElevationProfile.ElevationProfileHoveredPointsVisualization")], l7);

// node_modules/@arcgis/core/views/2d/analysis/ElevationProfile/ElevationProfileVisualization2D.js
var n5 = class extends b {
  constructor(i5) {
    super(i5);
  }
  initialize() {
    const { view: i5, analysisViewData: o10 } = this;
    this._hoveredPointsVisualization = new l7({ view: i5, analysisViewData: o10 }), this._inputVisualization = new e6({ view: i5, analysisViewData: o10 }), this._lineVisualization = new d3({ view: i5, analysisViewData: o10 });
  }
  destroy() {
    this._inputVisualization.destroy(), this._hoveredPointsVisualization.destroy(), this._lineVisualization.destroy();
  }
  get updating() {
    return this._hoveredPointsVisualization.updating || this._inputVisualization.updating || this._lineVisualization.updating;
  }
};
__decorate([m()], n5.prototype, "view", void 0), __decorate([m()], n5.prototype, "analysisViewData", void 0), __decorate([m()], n5.prototype, "updating", null), n5 = __decorate([a("esri.views.2d.analysis.ElevationProfile.ElevationProfileVisualization2D")], n5);

// node_modules/@arcgis/core/core/dedupeResult.js
function t3(t6, n9) {
  let o10, r6 = false;
  function e10(...e11) {
    const i5 = t6.apply(this, e11);
    return r6 && void 0 !== o10 && n9?.(o10, i5) ? o10 : (r6 = true, o10 = i5, i5);
  }
  return e10;
}

// node_modules/@arcgis/core/layers/support/ElevationQueryTileCache.js
var t4 = class {
  constructor(t6) {
    this._store = t6;
  }
  destroy() {
    this._store.destroy();
  }
  get(t6) {
    return this._store.get(t6);
  }
  put(t6, s6) {
    this._store.put(t6, s6);
  }
};

// node_modules/@arcgis/core/views/analysis/ElevationProfile/ElevationProfileError.js
var s3 = class extends s {
  constructor(r6, s6, e10) {
    super(r6, s6, e10), this.name = "unknown", this.name = r6;
  }
};

// node_modules/@arcgis/core/views/analysis/ElevationProfile/elevationProfileErrors.js
var e7 = class extends s3 {
  constructor() {
    super("too-complex", "The input geometry has too many points.");
  }
};
var o6 = class extends s3 {
  constructor() {
    super("invalid-geometry", "The input geometry is invalid.");
  }
};
var t5 = class extends s3 {
  constructor() {
    super("elevation-query-error", "Error querying elevation from provider.");
  }
};
var n6 = class extends s3 {
  constructor() {
    super("unknown", "Unknown error.");
  }
};

// node_modules/@arcgis/core/views/analysis/ElevationProfile/elevationProfileGeometryUtils.js
async function y4(e10, t6, s6, o10, i5, a6, h4) {
  let p2, m8, d4;
  const y6 = e10.spatialReference, j5 = y6.isGeographic || y6.isWebMercator;
  let v3 = 0;
  if (!j5) {
    const { execute: t7 } = await import("./lengthOperator-IB7SX5PM.js");
    s2(h4), v3 = t7(e10, { unit: "meters" }), s2(h4);
  }
  const P3 = 1 / ae(o10);
  if (j5) {
    await N3([{ source: y6, dest: o10 }, { source: y6, dest: f3.WGS84 }], h4);
    const n9 = q2(e10);
    p2 = R([n9], "meters")[0];
    const r6 = w3(p2, i5);
    if (C(e10, p2, r6) > a6) throw new e7();
    const j6 = R2(n9, t6, s6);
    ({ densifiedPath: m8, distances: d4 } = W2(j6, r6, P3)), m8 = W(m8, o10);
  } else {
    await N3([{ source: y6, dest: o10 }], h4), p2 = v3;
    const r6 = w3(p2, i5);
    if (C(e10, p2, r6) > a6) throw new e7();
    const l9 = R2(e10, t6, s6);
    ({ densifiedPath: m8, distances: d4 } = G3(l9, r6, P3)), s2(h4), m8 = W(m8, o10);
  }
  return { densifiedPath: m8, pathLength: p2 * P3, distances: d4 };
}
function w3(e10, t6) {
  const n9 = e10 / t6.densificationMaxSamples;
  return Math.max(t6.samplingDistance, n9);
}
function R2(e10, t6, n9) {
  if (null == t6) return P2(e10);
  const r6 = e10.spatialReference, s6 = t6.mode, o10 = h3(t6, r6);
  let i5 = null;
  switch (n9.type) {
    case "2d":
      i5 = j3(e10, s6, o10);
      break;
    case "3d":
      i5 = v(e10, s6, o10, n9);
  }
  return null == i5 ? P2(e10) : new y2({ hasZ: true, hasM: false, spatialReference: r6, paths: Z(e10.paths, i5) });
}
function j3({ hasZ: e10 }, t6, n9) {
  return "absolute-height" === t6 ? e10 ? ([e11, t7, r6]) => [e11, t7, r6 + n9] : ([e11, t7]) => [e11, t7, n9] : null;
}
function v({ spatialReference: e10, hasZ: t6 }, n9, r6, { elevationProvider: s6 }) {
  const o10 = (t7, n10, r7, o11) => s6?.getElevation(t7, n10, r7, e10, o11) ?? 0;
  switch (n9) {
    case "on-the-ground":
      return ([e11, t7]) => [e11, t7, o10(e11, t7, 0, "ground")];
    case "absolute-height":
      return t6 ? ([e11, t7, n10]) => [e11, t7, n10 + r6] : ([e11, t7]) => [e11, t7, r6];
    case "relative-to-ground":
      return t6 ? ([e11, t7, n10]) => [e11, t7, n10 + o10(e11, t7, n10, "ground") + r6] : ([e11, t7]) => [e11, t7, o10(e11, t7, 0, "ground") + r6];
    case "relative-to-scene":
      return t6 ? ([e11, t7, n10]) => [e11, t7, n10 + o10(e11, t7, n10, "scene") + r6] : ([e11, t7]) => [e11, t7, o10(e11, t7, 0, "scene") + r6];
    default:
      return null;
  }
}
function P2(e10) {
  return e10.hasZ ? new y2({ hasZ: false, hasM: false, spatialReference: e10.spatialReference, paths: Z(e10.paths, ([e11, t6]) => [e11, t6]) }) : e10;
}
function Z(e10, t6) {
  const n9 = e10.length, r6 = new Array(n9);
  for (let s6 = 0; s6 < n9; ++s6) {
    const n10 = e10[s6], o10 = n10.length, i5 = new Array(n10.length);
    r6[s6] = i5;
    for (let e11 = 0; e11 < o10; ++e11) i5[e11] = t6(n10[e11]);
  }
  return r6;
}
function M2(e10) {
  return U3(e10) && e10.paths.some((e11) => e11.length > 1);
}
function x(e10) {
  return S(e10) && M2(e10.geometry);
}
function S(e10) {
  return b2(e10) && U3(e10?.geometry);
}
function U3(e10) {
  return !b2(e10) && null != e10 && "polyline" === e10.type;
}
function b2(e10) {
  return null != e10 && "geometry" in e10;
}
function A(e10) {
  const t6 = e10?.layer;
  return null != t6 && "graphics" === t6.type && t6.internal;
}
function z2(t6, n9, s6, o10, i5) {
  const { spatialReference: c4, hasZ: u10 } = t6, l9 = { from: null, to: null, distance: 0, azimuth: 0, reverseAzimuth: 0, spatialReference: c4, metersPerSR: ae(c4) }, f7 = [], h4 = [];
  let p2 = 0;
  for (let r6 = 0; r6 < t6.paths.length; ++r6) {
    const a6 = t6.paths[r6], c5 = new Array(), u11 = new Array();
    let m8 = 0;
    for (let t7 = 1; t7 < a6.length; ++t7) {
      const r7 = a6[t7 - 1], f8 = a6[t7], h5 = o10(l9, r7, f8);
      let d4;
      for (d4 = m8; d4 < h5.distance && !P(d4, h5.distance); d4 += n9) c5.push(i5(h5, d4)), u11.push((p2 + d4) * s6);
      m8 = d4 - h5.distance, p2 += h5.distance, c5.push(f8), u11.push(p2 * s6);
    }
    f7[r6] = c5, h4[r6] = u11;
  }
  return { densifiedPath: new y2({ spatialReference: c4, hasZ: u10, paths: f7 }), distances: h4 };
}
function G3(e10, t6, n9) {
  const { hasZ: r6 } = e10;
  return z2(e10, t6, n9, E, r6 ? O2 : L);
}
function W2(e10, t6, n9) {
  const { hasZ: r6 } = e10;
  return z2(e10, t6, n9, k, r6 ? I3 : D);
}
function k(e10, t6, n9) {
  return e10.distance = 0, q(e10, t6, n9, e10.spatialReference), e10.from = t6, e10.to = n9, e10;
}
function E(e10, t6, n9) {
  return e10.from = t6, e10.to = n9, e10.distance = m4(n9, t6) * e10.metersPerSR, e10;
}
function D({ from: e10, azimuth: t6, spatialReference: n9 }, r6) {
  return j([0, 0], e10, t6, r6, n9);
}
function I3({ from: e10, to: n9, azimuth: r6, distance: s6, spatialReference: o10 }, i5) {
  const a6 = i5 / s6, c4 = [0, 0, o3(e10[2], n9[2], a6)];
  return j(c4, e10, r6, i5, o10), c4;
}
function L({ from: e10, to: t6, distance: n9 }, r6) {
  return _2([0, 0], e10, t6, r6 / n9);
}
function O2({ from: e10, to: t6, distance: n9 }, r6) {
  return I([0, 0, 0], e10, t6, r6 / n9);
}
function q2(e10) {
  return y3(e10.spatialReference) ? e10 : W(e10, f3.WGS84);
}
function B(e10) {
  return e10.paths.reduce((e11, t6) => e11 + t6.length, 0);
}
function C(e10, t6, n9) {
  return B(e10) + Math.floor(t6 / n9) + Math.max(0, e10.paths.reduce((e11) => 1 + e11, 0) - 1);
}

// node_modules/@arcgis/core/views/analysis/ElevationProfile/elevationProfileStatisticsUtils.js
function i3(t6, i5) {
  const o10 = t6.length;
  if (0 === o10) return null;
  const s6 = t6[0], m8 = s6.sampledZ;
  let c4 = m8, p2 = m8, h4 = 0, E3 = 0, f7 = null, g = null, x3 = null != m8 ? m8 : 0, _5 = 0, S3 = 0, d4 = null != m8 ? 1 : 0, C2 = 0, D2 = 0;
  const N4 = ae(i5), P3 = ne(i5), H3 = i2().minSlopeSampleDistance / N4, Z3 = 2 * H3, j5 = new v2(), y6 = new v2(), M4 = () => {
    G4(), j5.copy(y6), y6.reset();
  }, w4 = (t7, n9) => {
    M4(), t7 > 0 && t7 - j5.start <= Z3 && (t7 = j5.start + H3), y6.restart(t7, n9);
  }, G4 = () => {
    if (j5.isHole || y6.isHole) return;
    const t7 = y6.avgElevation - j5.avgElevation, n9 = y6.start - j5.start, e10 = t7 * P3, a6 = n9 * N4, i6 = N2(Math.atan2(e10, a6), "radians", "degrees");
    i6 > 0 ? (_5 += i6, f7 = u4(f7, i6), C2++) : i6 < 0 && (S3 -= i6, g = u4(g, -i6), D2++);
  };
  null != s6.sampledZ && w4(s6.distance, s6.sampledZ);
  for (let n9 = 1; n9 < o10; ++n9) {
    const e10 = t6[n9 - 1], l9 = t6[n9], a6 = l9.sampledZ;
    if (null == a6) {
      y6.isHole || M4();
      continue;
    }
    d4++, x3 += a6, c4 = r4(c4, a6), p2 = u4(p2, a6), y6.isHole || l9.distance - y6.start >= H3 ? w4(l9.distance, a6) : y6.insert(a6);
    const i6 = e10.sampledZ;
    if (null != i6) {
      const t7 = a6 - i6;
      t7 > 0 ? h4 += t7 : t7 < 0 && (E3 -= t7);
    }
  }
  return M4(), 0 === d4 ? null : { maxDistance: t6[o10 - 1].distance, minElevation: c4, maxElevation: p2, avgElevation: 0 === d4 ? null : x3 / d4, elevationGain: h4, elevationLoss: E3, maxPositiveSlope: f7, maxNegativeSlope: g, avgPositiveSlope: 0 === C2 ? null : _5 / C2, avgNegativeSlope: 0 === D2 ? null : S3 / D2 };
}
function o7(n9) {
  const e10 = n9.filter(N), l9 = e10.length;
  if (0 === l9) return null;
  const a6 = e10[0];
  if (1 === l9) return a6;
  let i5 = a6.maxDistance, o10 = a6.minElevation, s6 = a6.maxElevation, m8 = a6.maxPositiveSlope, v3 = a6.maxNegativeSlope;
  for (let t6 = 1; t6 < e10.length; ++t6) {
    const n10 = e10[t6];
    i5 = u4(i5, n10.maxDistance), o10 = r4(o10, n10.minElevation), s6 = u4(s6, n10.maxElevation), m8 = u4(m8, n10.maxPositiveSlope), v3 = u4(v3, n10.maxNegativeSlope);
  }
  return { maxDistance: i5, minElevation: o10, maxElevation: s6, avgElevation: null, elevationGain: null, elevationLoss: null, maxPositiveSlope: m8, maxNegativeSlope: v3, avgPositiveSlope: null, avgNegativeSlope: null };
}
function s4(t6) {
  let l9 = null, a6 = null, i5 = null;
  for (const o10 of t6) {
    if (null == o10) continue;
    const { statistics: t7, spatialReference: s6 } = o10;
    if (null == t7) continue;
    const v3 = ae(s6);
    l9 = u4(l9, m7(t7.maxDistance, v3));
    const c4 = ne(s6);
    i5 = r4(i5, m7(t7.minElevation, c4)), a6 = u4(a6, m7(t7.maxElevation, c4));
  }
  return { minDistance: 0, maxDistance: l9 ?? 0, minElevation: i5 ?? 0, maxElevation: a6 ?? 0 };
}
function r4(t6, n9) {
  return null == n9 ? t6 : null != t6 ? Math.min(t6, n9) : n9;
}
function u4(t6, n9) {
  return null == n9 ? t6 : null != t6 ? Math.max(t6, n9) : n9;
}
function m7(t6, n9) {
  return null != t6 && null != n9 ? t6 * n9 : null;
}
var v2 = class {
  constructor() {
    this._start = 0, this._totalElevation = 0, this._sampleCount = 0;
  }
  get avgElevation() {
    return this._totalElevation / this._sampleCount;
  }
  get isHole() {
    return 0 === this._sampleCount;
  }
  get start() {
    return this._start;
  }
  copy(t6) {
    this._start = t6._start, this._sampleCount = t6._sampleCount, this._totalElevation = t6._totalElevation;
  }
  reset() {
    this._start = 0, this._sampleCount = 0, this._totalElevation = 0;
  }
  restart(t6, n9) {
    this._start = t6, this._sampleCount = 1, this._totalElevation = n9;
  }
  insert(t6) {
    ++this._sampleCount, this._totalElevation += t6;
  }
};

// node_modules/@arcgis/core/views/analysis/ElevationProfile/elevationProfileTraversalUtils.js
function n7(n9, o10, t6 = []) {
  if (n9 >= o10) return t6;
  t6.push(n9);
  if (o10 - n9 < 2) return t6;
  const r6 = o10 - 1;
  t6.push(r6);
  const u10 = e8(n9 + 1, r6);
  for (; ; ) {
    const n10 = u10.next();
    if (n10.done) break;
    t6.push(n10.value);
  }
  return t6;
}
function* e8(n9, o10) {
  if (n9 >= o10) return;
  const t6 = n9 + Math.floor((o10 - n9) / 2);
  yield t6;
  const r6 = e8(n9, t6), u10 = e8(t6 + 1, o10);
  for (; ; ) {
    const n10 = r6.next(), e10 = u10.next();
    if (n10.done && e10.done) break;
    n10.done || (yield n10.value), e10.done || (yield e10.value);
  }
}

// node_modules/@arcgis/core/views/analysis/ElevationProfile/elevationProfileGenerationUtils.js
async function* j4(e10, t6) {
  const { view: n9, geometry: s6, elevationInfo: i5, providers: l9, options: a6 } = e10, u10 = n9.spatialReference;
  if (!u10 || null == s6 || !M2(s6)) throw new o6();
  const m8 = l9.length;
  if (0 === m8) return null;
  const w4 = Math.round(a6.maxTotalSamples / m8);
  if (B(s6) > w4) throw new e7();
  const g = await y4(s6, i5, n9, u10, a6, w4, t6);
  s2(t6);
  let v3 = 0;
  const P3 = new Array(m8), j5 = new Array(m8);
  for (let r6 = 0; r6 < m8; r6++) {
    const n10 = M3(g);
    P3[r6] = n10, v3 += n10.samples.length;
    const o10 = { ...e10, provider: l9[r6], result: n10, densificationResult: g };
    j5[r6] = R3(o10, t6)[Symbol.iterator]();
  }
  if (v3 > a6.maxTotalSamples) throw new e7();
  const Z3 = await Promise.all(j5.map((e11) => {
    const t7 = e11.next();
    return true === t7.done ? Promise.resolve(null) : t7.value;
  }));
  s2(t6);
  for (let r6 = 0; r6 < m8; r6++) P3[r6] = Z3[r6];
  yield P3, await T(e10.delayAfterPreview ?? i2().delayAfterPreviewMillis, null, t6.signal), s2(t6);
  const S3 = [];
  try {
    let e11;
    do {
      e11 = false;
      for (let t7 = 0; t7 < m8; t7++) {
        const r6 = j5[t7].next();
        false === r6.done && (S3.push({ resultPromise: r6.value, index: t7 }), e11 = true);
      }
    } while (e11);
  } finally {
    j5.forEach((e11) => e11.return?.());
  }
  for (const { resultPromise: o10, index: c4 } of S3) P3[c4] = await o10, s2(t6), yield P3;
  for (const r6 of P3) null != r6 && (r6.progress = 1);
  yield P3;
}
function* R3(t6, r6) {
  const { densificationResult: n9 } = t6, o10 = { ...t6, abortOptions: r6, densificationResult: n9 }, s6 = n7(0, o10.result.samples.length), i5 = s6.slice(0, o10.provider.numSamplesForPreview);
  yield Z2(o10, i5, true);
  const l9 = M(s6, o10.provider.numSamplesPerChunk);
  for (const e10 of l9) yield Z2(o10, e10, false);
}
async function Z2({ densificationResult: e10, result: t6, provider: r6, queue: n9, abortOptions: o10, cache: l9 }, a6, p2) {
  const { densifiedPath: f7, pathLength: m8 } = e10, d4 = t6.spatialReference, { samples: h4 } = t6, y6 = [];
  for (let s6 = 0; s6 < a6.length; s6++) {
    const e11 = h4[a6[s6]];
    y6[s6] = [...e11.coordinate];
  }
  try {
    return await n9.push({ geometry: new m5({ spatialReference: d4, points: y6, hasZ: f7.hasZ }), provider: r6, indices: a6, preview: p2, result: t6, parameters: { ...i2().defaultQueryOptions(), minDemResolution: p2 ? Math.round(m8 / r6.numSamplesForPreview) : Math.round(m8 / h4.length), cache: l9 } }, o10), { ...t6 };
  } catch (w4) {
    return d(w4) ? null : r3;
  }
}
function S2(e10) {
  return new _3({ priority: f5.ELEVATION_PROFILE, concurrency: 1, scheduler: e10, process: async (e11) => {
    s2(e11.parameters);
    try {
      await U4(e11);
    } catch (t6) {
      m2(t6);
    }
  } });
}
async function U4({ geometry: e10, provider: t6, indices: r6, preview: n9, result: o10, parameters: s6 }) {
  if (0 === r6.length) return;
  const i5 = (await b3(t6, e10, s6)).geometry, { hasZ: l9, points: a6 } = i5, c4 = s6.noDataValue, { samples: u10 } = o10;
  for (let p2 = 0; p2 < r6.length; p2++) {
    const e11 = u10[r6[p2]];
    if (e11.isHole) continue;
    const t7 = l9 ? a6[p2][2] : null;
    null === t7 || t7 === c4 ? e11.sampledZ = null : (o10.hasZ = true, e11.sampledZ = t7), e11.sampled = true;
  }
  x2(u10), o10.progress = n9 ? 0 : o10.progress + r6.length / u10.length, o10.statistics = i3(o10.samples, o10.spatialReference);
}
function x2(e10) {
  const t6 = e10.length - 1;
  let r6 = 0;
  for (let n9 = 1; n9 <= t6; n9++) {
    (e10[n9].sampled || n9 === t6) && (E2(e10, r6, n9), r6 = n9);
  }
}
function E2(e10, r6, n9) {
  if (n9 - r6 === 1) return;
  const o10 = e10[r6], s6 = o10.sampledZ, i5 = e10[n9], l9 = i5.sampledZ;
  if (null == s6 || null == l9) {
    for (let t6 = r6 + 1; t6 < n9; t6++) e10[t6].sampledZ = null;
    return;
  }
  const a6 = o10.distance, c4 = i5.distance - a6;
  for (let u10 = r6 + 1; u10 < n9; u10++) {
    const r7 = e10[u10], n10 = (r7.distance - a6) / c4;
    r7.sampledZ = o3(s6, l9, n10);
  }
}
function M3({ densifiedPath: e10, distances: t6 }) {
  const r6 = e10.spatialReference, n9 = G(r6), o10 = e10.paths, s6 = o10.length, i5 = [];
  let c4 = null, u10 = 0;
  for (let a6 = 0; a6 < s6; a6++) {
    const e11 = o10[a6], r7 = e11.length, s7 = t6[a6];
    for (let t7 = 0; t7 < r7; t7++) {
      const r8 = e11[t7], o11 = s7[t7];
      n9 && (r8[0] = z(r8[0], n9.valid[0], n9.valid[1])), c4 && 0 === t7 && A2(i5, c4, r8, u10, o11), i5.push(O3(r8, o11)), c4 = r8, u10 = o11;
    }
  }
  return { progress: 0, samples: i5, hasZ: false, statistics: null, spatialReference: r6 };
}
function A2(e10, t6, r6, n9, o10) {
  e10.push(T2(t6, n9)), e10.push(T2(r6, o10));
}
function O3(e10, t6) {
  return { coordinate: e10, distance: t6, sampledZ: null, sampled: false, isHole: false };
}
function T2(e10, t6) {
  return { coordinate: e10, distance: t6, sampledZ: null, sampled: true, isHole: true };
}
async function b3(e10, t6, r6) {
  try {
    return await e10.queryElevation(t6, r6);
  } catch (n9) {
    throw new t5();
  }
}
function F(e10, t6, r6) {
  if (!e10 || 0 === e10.length) return;
  const n9 = e10.length - 1, o10 = e10[0];
  if (t6 <= r6(o10)) return o10;
  const s6 = e10[n9];
  if (t6 >= r6(s6)) return s6;
  let i5 = 0, l9 = 0, a6 = n9;
  for (; i5 < a6; ) {
    l9 = i5 + Math.floor((a6 - i5) / 2);
    const o11 = e10[l9], s7 = r6(o11);
    if (s7 === t6) return o11;
    if (t6 < s7) {
      if (l9 > 0) {
        const n10 = e10[l9 - 1], i6 = r6(n10);
        if (t6 > i6) return t6 - i6 >= s7 - t6 ? o11 : n10;
      }
      a6 = l9;
    } else {
      if (l9 < n9) {
        const n10 = e10[l9 + 1], i6 = r6(n10);
        if (t6 < i6) return t6 - s7 >= i6 - t6 ? n10 : o11;
      }
      i5 = l9 + 1;
    }
  }
  return e10[l9];
}
function H2(e10) {
  return e10 > 0.999999 ? 1 : e10;
}

// node_modules/@arcgis/core/views/analysis/ElevationProfile/ElevationProfileController.js
var k2 = class extends b {
  constructor(t6) {
    super(t6), this.error = null, this._getStableEffectiveUnits = t3(() => {
      const t7 = s4(this._activeComputations.map((t8) => t8.result.rawResult)), e10 = this.analysis.displayUnits, o10 = e4(this.view);
      return { distance: G2(t7.maxDistance, "meters", e10.distance ?? o10), elevation: H(t7.maxElevation, "meters", e10.elevation ?? o10) };
    }, h), this._updateTask = null, this._queue = null, this._currentTileCache = null, this._parametersPerComputation = /* @__PURE__ */ new Map(), this._getStableUpdateParameters = t3(() => ({ stationary: this.view.stationary ?? true, activeComputations: this._activeComputations, generationParameters: this._generationParameters }), h), this._getStableGenerationParameters = t3(() => {
      const { view: t7, analysis: e10 } = this;
      return t7?.ready && this._queue ? { view: t7, geometry: e10.geometry, geometryIsValid: e10.valid, elevationInfo: this.elevationInfo, queue: this._queue, cache: this._tileCache, options: this._options, slicePlane: "3d" === t7.type ? t7.slice.plane : null } : null;
    }, h), this._getStableElevationInfo = t3(() => this.analysis.elevationInfo ?? V, o2), this._getStableOptions = t3(() => {
      const { densificationMaxSamples: t7, defaultDemResolution: e10, maxTotalSamples: o10 } = i2();
      let i5 = this._minDemResolution ?? e10;
      return i5 = parseFloat(i5.toFixed(2)), { samplingDistance: i5, densificationMaxSamples: Math.round(t7 / this._activeComputations.length), maxTotalSamples: o10 };
    }, h), this._updateThrottled = l3((t7) => this._update(t7), i2().updateThrottleMillis);
  }
  initialize() {
    this._computationsCollection = c3(() => this.analysis.profiles, (t7) => this.computationFactory.create({ controller: this, profile: t7, onInvalidate: (t8) => this._invalidateComputation(t8) }), { recycleItems: true }), this.addHandles([this._computationsCollection.on("change", () => {
      this._parametersPerComputation.clear(), this._updateThrottled(this._updateParameters);
    }), l2(() => this._updateParameters, (t7) => this._updateThrottled(t7), w2), this._updateThrottled]);
    const t6 = "3d" === this.view.type ? this.view.resourceController : void 0;
    this._queue = S2(t6?.scheduler), t6?.addUpdatingObject(this);
  }
  destroy() {
    this._abortUpdate(), this._parametersPerComputation.clear(), this._computationsCollection?.destroy(), this._queue = u(this._queue), this._currentTileCache = u(this._currentTileCache);
  }
  get effectiveDisplayUnits() {
    return this._getStableEffectiveUnits();
  }
  get progress() {
    let t6 = 0, e10 = 0;
    for (const o10 of this._activeComputations) t6++, e10 += o10.progress;
    return H2(t6 > 0 ? e10 / t6 : 0);
  }
  get updating() {
    const { progress: t6 } = this, e10 = !!this._queue?.updating, o10 = this._updateThrottled.hasPendingUpdates(), i5 = null != this._updateTask && !this._updateTask.finished;
    return e10 || o10 || i5 || t6 > 0 && t6 < 1;
  }
  get results() {
    return this._computations.map((t6) => t6.result);
  }
  get statistics() {
    return o7(this._activeComputations.map((t6) => t6.result.statistics));
  }
  get hoveredPoints() {
    return this._computations.map((t6) => t6.hoveredPoint);
  }
  onElevationChange(t6) {
    const { view: e10 } = this;
    return "3d" === e10?.type ? a3(() => e10.elevationProvider, "elevation-change", t6, { onListenerAdd: t6, onListenerRemove: t6 }) : e();
  }
  get _tileCache() {
    this._currentTileCache = u(this._currentTileCache);
    const t6 = this.view;
    if ("3d" === t6?.type) {
      const e10 = t6.basemapTerrain?.elevationQueryCache;
      if (null != e10) return e10;
    }
    return null == this._currentTileCache && (this._currentTileCache = new t4(new e3(20971520))), this._currentTileCache;
  }
  get _computations() {
    return this._computationsCollection?.toArray() ?? [];
  }
  get _activeComputations() {
    return this._computations.filter((t6) => t6.profile.enabled && t6.available);
  }
  get _minDemResolution() {
    const t6 = this._minDemResolutions;
    return t6.length > 0 ? i(t6) : null;
  }
  get _minDemResolutions() {
    const t6 = [];
    for (const { minDemResolution: e10 } of this._activeComputations) null != e10 && t6.push(e10);
    return t6;
  }
  get _updateParameters() {
    return this._getStableUpdateParameters();
  }
  get _generationParameters() {
    return this._getStableGenerationParameters();
  }
  get elevationInfo() {
    return this._getStableElevationInfo();
  }
  get _options() {
    return this._getStableOptions();
  }
  _update({ stationary: t6, activeComputations: e10, generationParameters: o10 }) {
    this._abortUpdate(), t6 && (null != o10 ? this._updateTask = d2(async (t7) => {
      this.error = null;
      const i5 = e10.filter((t8) => !this._isComputationValid(t8, o10));
      try {
        if (!o10.geometryIsValid) throw new o6();
        const e11 = j4({ ...o10, providers: i5 }, { signal: t7 });
        let s6 = false;
        for await (const r6 of e11) {
          s2(t7), s6 || (this._clearInvalidResults(o10), s6 = true);
          for (let t8 = 0; t8 < i5.length; t8++) i5[t8].setResult(r6[t8]);
        }
        for (const t8 of i5) this._parametersPerComputation.set(t8, o10);
      } catch (s6) {
        f(s6), this._abortUpdate(), this.error = s6 instanceof s3 ? s6 : new n6(), i5.forEach((t8) => {
          t8.clearResult();
        });
      }
    }) : this._clearResults());
  }
  _abortUpdate() {
    this._updateTask = e2(this._updateTask);
  }
  _isComputationValid(t6, e10) {
    return this._parametersPerComputation.has(t6) && this._parametersPerComputation.get(t6) === e10;
  }
  _invalidateComputation(t6) {
    this._parametersPerComputation.delete(t6), this._updateThrottled(this._updateParameters);
  }
  _clearInvalidResults(t6) {
    for (const e10 of this._computations) this._isComputationValid(e10, t6) || (e10.clearResult(), this._parametersPerComputation.delete(e10));
  }
  _clearResults() {
    for (const t6 of this._computations) t6.clearResult(), this._parametersPerComputation.delete(t6);
  }
};
__decorate([m({ constructOnly: true })], k2.prototype, "analysis", void 0), __decorate([m({ constructOnly: true })], k2.prototype, "analysisViewData", void 0), __decorate([m({ constructOnly: true })], k2.prototype, "computationFactory", void 0), __decorate([m({ constructOnly: true })], k2.prototype, "view", void 0), __decorate([m()], k2.prototype, "error", void 0), __decorate([m({ readOnly: true })], k2.prototype, "effectiveDisplayUnits", null), __decorate([m()], k2.prototype, "progress", null), __decorate([m()], k2.prototype, "updating", null), __decorate([m()], k2.prototype, "results", null), __decorate([m()], k2.prototype, "statistics", null), __decorate([m()], k2.prototype, "hoveredPoints", null), __decorate([m()], k2.prototype, "_updateTask", void 0), __decorate([m()], k2.prototype, "_queue", void 0), __decorate([m()], k2.prototype, "_tileCache", null), __decorate([m()], k2.prototype, "_computationsCollection", void 0), __decorate([m()], k2.prototype, "_computations", null), __decorate([m()], k2.prototype, "_activeComputations", null), __decorate([m({ readOnly: true })], k2.prototype, "_minDemResolution", null), __decorate([m()], k2.prototype, "_minDemResolutions", null), __decorate([m()], k2.prototype, "_updateParameters", null), __decorate([m()], k2.prototype, "_generationParameters", null), __decorate([m()], k2.prototype, "elevationInfo", null), __decorate([m()], k2.prototype, "_options", null), k2 = __decorate([a("esri.views.analysis.ElevationProfile.ElevationProfileController")], k2);
var V = new c({ ...U2 });

// node_modules/@arcgis/core/views/analysis/ElevationProfile/elevationProfileUnitUtils.js
function l8(t6, l9) {
  if (null == t6 || null == l9) return null;
  const { samples: i5, spatialReference: s6 } = t6, { distance: v3, elevation: r6 } = l9, u10 = ae(s6), c4 = ne(s6), m8 = i5.length, p2 = new Array(m8);
  for (let e10 = 0; e10 < m8; ++e10) {
    const n9 = i5[e10], t7 = n9.sampledZ, l10 = n9.coordinate;
    p2[e10] = { x: l10[0], y: l10[1], z: t7, distance: a5(n9.distance, u10, v3), elevation: o8(t7, c4, r6) };
  }
  return p2;
}
function i4(t6, l9) {
  if (null == t6 || null == l9 || null == t6.statistics || null == t6.spatialReference) return null;
  const { distance: i5, elevation: s6 } = l9, { statistics: v3, spatialReference: r6 } = t6, u10 = ae(r6), c4 = ne(r6);
  return { maxDistance: a5(v3.maxDistance, u10, i5), minElevation: o8(v3.minElevation, c4, s6), maxElevation: o8(v3.maxElevation, c4, s6), avgElevation: o8(v3.avgElevation, c4, s6), elevationGain: o8(v3.elevationGain, c4, s6), elevationLoss: o8(v3.elevationLoss, c4, s6), maxPositiveSlope: v3.maxPositiveSlope, maxNegativeSlope: v3.maxNegativeSlope, avgPositiveSlope: v3.avgPositiveSlope, avgNegativeSlope: v3.avgNegativeSlope };
}
function a5(e10, n9, l9) {
  return null == e10 ? null : N2(e10 * n9, "meters", l9);
}
function o8(e10, n9, l9) {
  return null == e10 ? null : N2(e10 * n9, "meters", l9);
}

// node_modules/@arcgis/core/views/analysis/ElevationProfile/ElevationProfileResult.js
var u5 = class extends f4 {
  constructor(t6) {
    super(t6), this._getSamplesMemoized = t2((t7, e10) => l8(t7, e10)), this._getStatisticsMemoized = t2((t7, e10) => i4(t7, e10)), this.rawResult = null;
  }
  get available() {
    const { computation: t6 } = this;
    return t6.profile.enabled && t6.available;
  }
  get profile() {
    return this.computation.profile;
  }
  get progress() {
    return H2(null != this.rawResult && this.computation.profile.enabled ? this.rawResult.progress : 0);
  }
  get samples() {
    return this._getSamplesMemoized(this.rawResult, this.computation.controller.effectiveDisplayUnits);
  }
  get statistics() {
    return this._getStatisticsMemoized(this.rawResult, this.computation.controller.effectiveDisplayUnits);
  }
  get hoveredPoint() {
    if (!this.computation.profile.enabled) return null;
    const t6 = this.computation.controller.analysisViewData.hoveredPosition;
    if (null == t6) return null;
    const { rawResult: e10, samples: o10 } = this;
    if (null == o10 || null == e10) return null;
    const r6 = o10.length;
    if (0 === r6) return null;
    const s6 = o10[r6 - 1].distance, i5 = F(o10, t6 * s6, (t7) => t7.distance);
    if (null == i5) return null;
    const { x: a6, y: p2, z: u10 } = i5;
    return null == u10 ? null : new _({ x: a6, y: p2, z: u10, spatialReference: e10.spatialReference });
  }
};
__decorate([m()], u5.prototype, "available", null), __decorate([m({ readOnly: true })], u5.prototype, "profile", null), __decorate([m({ readOnly: true })], u5.prototype, "progress", null), __decorate([m()], u5.prototype, "samples", null), __decorate([m()], u5.prototype, "statistics", null), __decorate([m({ constructOnly: true })], u5.prototype, "computation", void 0), __decorate([m()], u5.prototype, "rawResult", void 0), __decorate([m()], u5.prototype, "hoveredPoint", null), u5 = __decorate([a("esri.views.analysis.ElevationProfile.ElevationProfileResult")], u5);

// node_modules/@arcgis/core/views/analysis/ElevationProfile/ElevationProfileLineComputation.js
var p = class extends b {
  constructor(o10) {
    super(o10), this.result = new u5({ computation: this }), this.numSamplesForPreview = 30, this.numSamplesPerChunk = 200;
  }
  initialize() {
    this.addHandles([l2(() => {
      const { geometry: o10, elevationInfo: t6 } = this.controller.analysis;
      return [o10, t6];
    }, () => this.onInvalidate(this), U)]);
  }
  setResult(o10) {
    this.result.rawResult = o10;
  }
  clearResult() {
    this.setResult(null);
  }
  get progress() {
    return this.result.progress;
  }
  get hoveredPoint() {
    return this.result.hoveredPoint;
  }
  get available() {
    return true;
  }
  get minDemResolution() {
    return i2().defaultDemResolution;
  }
};
__decorate([m({ constructOnly: true })], p.prototype, "controller", void 0), __decorate([m({ constructOnly: true })], p.prototype, "profile", void 0), __decorate([m({ constructOnly: true })], p.prototype, "onInvalidate", void 0), __decorate([m()], p.prototype, "result", void 0), __decorate([m({ readOnly: true })], p.prototype, "progress", null), __decorate([m()], p.prototype, "hoveredPoint", null), __decorate([m()], p.prototype, "available", null), __decorate([m()], p.prototype, "numSamplesForPreview", void 0), __decorate([m()], p.prototype, "numSamplesPerChunk", void 0), __decorate([m({ readOnly: true })], p.prototype, "minDemResolution", null), p = __decorate([a("esri.views.analysis.ElevationProfile.ElevationProfileLineComputation")], p);

// node_modules/@arcgis/core/views/analysis/ElevationProfile/elevationProfileQuerySourceUtils.js
function u6(n9) {
  if (null == n9) return null;
  if (o4(n9)) return o9(n9);
  const r6 = n9.tileInfo;
  if (null == r6) return null;
  const u10 = r6.lods?.at(-1);
  return null == u10 ? null : u10.resolution * ae(r6.spatialReference);
}
function o9(l9) {
  if (null == l9) return null;
  const t6 = l9.layers.items.map(e9).filter(N);
  return i(t6) ?? null;
}
function e9(n9) {
  return n9 && "tileInfo" in n9 ? u6(n9) : null;
}

// node_modules/@arcgis/core/views/analysis/ElevationProfile/ElevationProfileLineGroundComputation.js
var u7 = class extends p {
  constructor() {
    super(...arguments), this.type = "ground", this.numSamplesForPreview = 50, this.numSamplesPerChunk = 1e3, this._getStableQueryElevationDependencies = t3(() => ({ ground: this._ground, groundLayers: this._getStableGroundLayers() }), h), this._getStableGroundLayers = t3(() => this._ground?.layers?.toArray(), h);
  }
  get minDemResolution() {
    return o9(this._ground);
  }
  get available() {
    return true === this._ground?.layers.some((e10) => e10.visible);
  }
  initialize() {
    this.addHandles([l2(() => this._queryElevationDependencies, () => this.onInvalidate(this))]);
  }
  async queryElevation(e10, r6) {
    const o10 = this._queryElevationDependencies;
    if (null == o10) throw new Error(`${this.declaredClass}: no dependencies`);
    const { ground: t6 } = o10;
    if (null == t6) throw new Error("No ground configured in the view");
    const n9 = await t6.queryElevation(e10, r6), s6 = ne(e10.spatialReference), a6 = ne(t6.layers.at(0).spatialReference);
    if (s6 !== a6) {
      const e11 = n9.geometry;
      e11.points = e11.points.map(([e12, o11, t7]) => [e12, o11, t7 === r6.noDataValue ? t7 : t7 * a6 / s6]);
    }
    return n9;
  }
  get _queryElevationDependencies() {
    return this._getStableQueryElevationDependencies();
  }
  get _ground() {
    return this.controller.view?.map?.ground;
  }
};
__decorate([m()], u7.prototype, "minDemResolution", null), __decorate([m()], u7.prototype, "available", null), __decorate([m()], u7.prototype, "_queryElevationDependencies", null), __decorate([m()], u7.prototype, "_ground", null), u7 = __decorate([a("esri.views.analysis.ElevationProfile.ElevationProfileLineGroundComputation")], u7);

// node_modules/@arcgis/core/views/analysis/ElevationProfile/elevationProfileLayerUtils.js
function r5(r6) {
  return r6?.map?.allLayers?.toArray().filter((r7) => ("graphics" !== r7.type || !r7.internal) && r7.visible).map((r7) => r7.uid) ?? [];
}

// node_modules/@arcgis/core/views/analysis/ElevationProfile/ElevationProfileLineInputComputation.js
var u8 = class extends p {
  constructor() {
    super(...arguments), this.type = "input", this.numSamplesForPreview = 50, this.numSamplesPerChunk = 500, this._getStableElevationDependencies = t3(() => {
      const { view: e10 } = this.controller;
      if (!e10) return null;
      const t6 = this._getStableElevationInfo();
      return { view: e10, stationary: !this._requiresElevationAlignment || e10.stationary, elevationInfo: t6, visibleLayerIds: this._getStableLayerIds(), spatialReference: this._getStableSpatialReference() };
    }, h), this._getStableElevationInfo = t3(() => this.controller.elevationInfo, o2), this._getStableSpatialReference = t3(() => this.controller.view?.spatialReference, o2), this._getStableLayerIds = t3(() => {
      const { view: e10 } = this.controller;
      return "3d" !== e10.type ? [] : r5(e10);
    }, h);
  }
  initialize() {
    const e10 = () => this.onInvalidate(this);
    this.addHandles([l2(() => this._queryElevationDependencies, e10, U), this.controller.onElevationChange(e10)]);
  }
  async queryElevation(e10, { noDataValue: t6, signal: o10 }) {
    const r6 = this._queryElevationDependencies;
    if (null == r6) throw new Error(`${this.declaredClass}: no dependencies`);
    const { view: i5, spatialReference: n9 } = r6;
    if (this._requiresElevationAlignment && "3d" === i5.type && n9) {
      const r7 = await r2.fromGeometry(e10).project(n9, o10);
      if (!r7) return { geometry: e10, noDataValue: t6 };
      const s6 = i5.elevationProvider;
      return r7.coordinates.forEach((e11) => {
        e11.z = s6.getElevation(e11.x, e11.y, 0, n9, "ground") ?? 0;
      }), { geometry: r7.export(), noDataValue: t6 };
    }
    return { geometry: e10, noDataValue: t6 };
  }
  get _requiresElevationAlignment() {
    return "on-the-ground" === this.controller.elevationInfo?.mode && "3d" === this.controller.view.type;
  }
  get _queryElevationDependencies() {
    return this._getStableElevationDependencies();
  }
};
__decorate([m()], u8.prototype, "_queryElevationDependencies", null), u8 = __decorate([a("esri.views.analysis.ElevationProfile.ElevationProfileLineInputComputation")], u8);

// node_modules/@arcgis/core/views/analysis/ElevationProfile/ElevationProfileLineQueryComputation.js
var n8 = class extends p {
  constructor() {
    super(...arguments), this.type = "query", this.numSamplesForPreview = 50, this.numSamplesPerChunk = 500;
  }
  get minDemResolution() {
    return u6(this.profile.source);
  }
  get available() {
    const { source: e10 } = this.profile;
    return !!e10 && (null == e10.visible || e10.visible) && (null == e10.layers || e10.layers.some((e11) => e11.visible));
  }
  initialize() {
    this.addHandles(l2(() => this.profile.source, () => this.onInvalidate(this), U));
  }
  queryElevation(e10, o10) {
    if (!this.profile.source) throw new Error("No source configured for the elevation profile line");
    return this.profile.source.queryElevation(e10, o10);
  }
};
__decorate([m({ readOnly: true })], n8.prototype, "minDemResolution", null), __decorate([m()], n8.prototype, "available", null), n8 = __decorate([a("esri.views.analysis.ElevationProfile.ElevationProfileLineQueryComputation")], n8);

// node_modules/@arcgis/core/views/analysis/ExclusiveOperationManager.js
var s5 = class {
  constructor() {
    this._currentOperationSignal = r(null);
  }
  get currentOperationType() {
    return this._currentOperationSignal.value?.type ?? null;
  }
  destroy() {
    this.stop();
  }
  async start(i5, s6, l9) {
    const p2 = this._currentOperationSignal.value;
    p2?.stop();
    const c4 = new AbortController(), u10 = l9?.signal, h4 = AbortSignal.any([c4.signal, u10].filter(N)), m8 = $();
    let g = false;
    const y6 = () => {
      g || (g = true, m8.reject(u2()));
    }, v3 = { type: i5, resolve: (r6) => {
      g || (g = true, m8.resolve(r6));
    }, reject: y6, promise: m8.promise, stop: () => c4.abort(), handles: [] };
    this._currentOperationSignal.value = v3, v3.handles.push(w(u10, () => {
      c4.abort();
    }), w(h4, () => {
      o(v3.handles), g || y6();
    }));
    try {
      return p2 && (await p2.promise.catch(() => {
      }), s2(h4)), await s6(v3, h4), await m8.promise;
    } finally {
      o(v3.handles), this._currentOperationSignal.value === v3 && (this._currentOperationSignal.value = null);
    }
  }
  stop() {
    this._currentOperationSignal.value?.stop();
  }
};

// node_modules/@arcgis/core/views/analysis/ElevationProfile/ElevationProfileTool.js
var L2 = class extends b {
  constructor(e10) {
    super(e10), this._sketchViewModels = new O(), this._updatingHandles = new h2(), this._operationManager = new s5();
  }
  initialize() {
    const { view: e10 } = this;
    this._graphicsLayer = new n2({ listMode: "hide", internal: true }), this.addHandles([l2(() => ({ map: e10.map, internalGraphicsLayer: this._graphicsLayer, state: this.state, geometryVisualizationVisible: this._analysis.viewOptions.geometryVisualizationVisible, visible: this.analysisViewData.visible }), ({ map: e11, internalGraphicsLayer: t6, state: s6, geometryVisualizationVisible: i5, visible: a6 }) => {
      I4(e11, t6);
      const r6 = this.sketchGraphic;
      switch (r6 && (r6.visible = a6), s6) {
        case "idle":
        case "reshaping-disabled":
          r6 && !i5 && (r6.visible = false), this._operationManager.stop(), this._ensureUpdatedSketchGraphic();
          break;
        case "reshaping":
          y(this._startReshape());
          break;
        case "awaiting-sketch":
          this.analysisViewData.interactive = true;
      }
    }, w2), l2(() => this._analysis.elevationInfo, (e11) => {
      this._graphicsLayer.elevationInfo = e11;
    }, w2)]);
  }
  destroy() {
    this._operationManager.destroy(), this._sketchViewModels.drain((e11) => u(e11));
    const e10 = this._graphicsLayer;
    this.view.map?.remove(e10), e10.destroy();
  }
  get sketchGraphic() {
    return this._get("sketchGraphic");
  }
  set sketchGraphic(e10) {
    e10 !== this._get("sketchGraphic") && (this._set("sketchGraphic", e10), this._updateAnalysisFromSketchGraphic());
  }
  get state() {
    const { visible: e10, interactive: t6 } = this.analysisViewData;
    if (!e10) return "idle";
    switch (this._operationManager.currentOperationType) {
      case "place":
        return this._sketching ? "sketching" : "awaiting-sketch";
      case "pick-feature":
        return "picking";
      default:
        return this._analysis.geometry ? t6 ? "reshaping" : "reshaping-disabled" : "idle";
    }
  }
  get updating() {
    return this._sketchViewModels.some((e10) => e10.updating) || this._updatingHandles.updating;
  }
  get _sketching() {
    return this._sketchViewModels.some((e10) => e10.createGraphic === this.sketchGraphic);
  }
  get _analysis() {
    return this.analysisViewData.analysis;
  }
  get _lineSymbol() {
    return V2(this.view.type);
  }
  place(e10) {
    return this._operationManager.start("place", async (t6) => {
      const s6 = this._createSketchViewModel(), i5 = this._analysis.clone();
      this._ensureUpdatedSketchGraphic();
      const a6 = this.sketchGraphic, o10 = this._analysis.elevationInfo, h4 = e(() => {
        this.sketchGraphic === a6 && (this._graphicsLayer.elevationInfo = o10);
      }), l9 = s6.on("create", (e11) => {
        switch (e11.state) {
          case "start":
            this._graphicsLayer.removeAll(), this.sketchGraphic = e11.graphic, this._analysis.elevationInfo = this._graphicsLayer.elevationInfo;
            break;
          case "active":
            this._updateAnalysisFromSketchGraphic();
            break;
          case "complete":
            this.sketchGraphic && (this._updateAnalysisFromSketchGraphic(), this._addSketchGraphic(this.sketchGraphic)), t6.stop();
            break;
          case "cancel":
            t6.stop();
        }
      });
      t6.handles.push(l9, e(() => (l9.remove(), s6.destroy(), this._sketchViewModels.remove(s6), this._updateAnalysisFromSketchGraphic(), this._analysis.valid ? a2(e10) || i5.equals(this._analysis) ? t6.reject() : void t6.resolve({}) : (this._clear(), t6.reject()))), h4), this._graphicsLayer.elevationInfo = O4, await this._updatingHandles.addPromise(y(s6.create("polyline")));
    }, e10);
  }
  async pickFeature(e10) {
    return this._operationManager.start("pick-feature", async (e11) => {
      const { view: t6 } = this;
      t6.closePopup();
      let s6 = null;
      const a6 = (a7) => {
        a7.defer(async () => {
          s6?.abort(), s6 = d2(async (s7) => {
            const { results: i5 } = await t6.hitTest(a7);
            s2(s7);
            let r6 = null;
            for (const e12 of i5) if ("graphic" === e12.type && x(e12.graphic) && !A(e12.graphic)) {
              r6 = e12.graphic;
              break;
            }
            r6 ? (a7.preventDefault(), a7.stopPropagation(), this.sketchGraphic = null, this._analysis.geometry = r6.geometry, this._analysis.elevationInfo = new c({ ...c2(r6) }), e11.resolve({ feature: r6 }), e11.stop()) : e11.reject();
          }), await s6.promise;
        });
      }, o10 = (t7) => {
        n3(t7) && (e11.reject(), e11.stop());
      };
      e11.handles.push(t6.on("immediate-click", a6, f6.TOOL), t6.on("key-down", o10, f6.TOOL), t6.acquireCursor("crosshair", "high"), e(() => {
        s6?.abort(), e11.reject();
      })), t6.focus();
    }, e10);
  }
  _startReshape() {
    const e10 = this._createSketchViewModel();
    return this._sketchViewModels.add(e10), this._operationManager.start("reshape", async (t6) => {
      const s6 = () => {
        const t7 = this._ensureUpdatedSketchGraphic();
        return t7 ? this._updatingHandles.addPromise(e10.update(t7, { tool: "reshape" })) : Promise.resolve();
      };
      if (!this._ensureUpdatedSketchGraphic()) return;
      const i5 = e10.on("update", (e11) => {
        this._updateAnalysisFromSketchGraphic(), "complete" === e11.state && ("reshaping" === this.state ? y(s6()) : t6.resolve());
      });
      t6.handles.push(i5, e(() => {
        i5.remove(), this._sketchViewModels.remove(e10), e10.destroy(), t6.resolve();
      })), await s6();
    });
  }
  _createSketchViewModel() {
    return new de({ layer: this._graphicsLayer, view: this.view, defaultCreateOptions: { mode: "click", hasZ: true }, updateOnGraphicClick: false, defaultUpdateOptions: { enableMoveAllGraphics: false, enableRotation: false, enableScaling: false, enableZ: false, highlightOptions: { enabled: false }, multipleSelectionEnabled: false, reshapeOptions: { shapeOperation: "none" }, toggleToolOnClick: false, tool: "reshape" }, polylineSymbol: this._lineSymbol, activeLineSymbol: this._lineSymbol });
  }
  _ensureUpdatedSketchGraphic() {
    const { geometry: e10 } = this._analysis;
    if (!e10) return this.sketchGraphic = null, this._graphicsLayer.removeAll(), null;
    const s6 = this.sketchGraphic ??= new _4({ symbol: this._lineSymbol, geometry: e10 });
    return s6.geometry = e10, this._addSketchGraphic(s6), s6;
  }
  _addSketchGraphic(e10) {
    const { graphics: t6 } = this._graphicsLayer;
    t6.includes(e10) || t6.add(e10), 1 !== t6.length && t6.removeMany(t6.filter((t7) => t7 !== e10));
  }
  _clear() {
    this.sketchGraphic = null, this._analysis.clear();
  }
  _updateAnalysisFromSketchGraphic() {
    let e10 = this.sketchGraphic?.geometry;
    U3(e10) || (e10 = null);
    const t6 = this._analysis;
    t6.geometry !== e10 && (t6.geometry = e10);
  }
};
function V2(e10) {
  if ("2d" === e10) {
    const e11 = { type: "CIMSolidStroke", enable: true, capStyle: "Butt", joinStyle: "Round", width: 1.5 };
    return new n({ data: { type: "CIMSymbolReference", symbol: { type: "CIMLineSymbol", symbolLayers: [{ ...e11, effects: [{ type: "CIMGeometricEffectDashes", dashTemplate: [5, 4], lineDashEnding: "FullGap", controlPointEnding: "NoConstraint" }], color: [0, 0, 0, 255] }, { ...e11, color: [255, 255, 255, 255] }] } } });
  }
  return new m6({ color: [0, 0, 0, 0] });
}
function I4(e10, t6) {
  t6 && (t6.removeFromParent(), e10?.add(t6));
}
__decorate([m({ constructOnly: true })], L2.prototype, "analysisViewData", void 0), __decorate([m({ constructOnly: true })], L2.prototype, "view", void 0), __decorate([m()], L2.prototype, "sketchGraphic", null), __decorate([m({ nonNullable: true })], L2.prototype, "state", null), __decorate([m()], L2.prototype, "updating", null), __decorate([m()], L2.prototype, "_sketching", null), __decorate([m()], L2.prototype, "_analysis", null), __decorate([m()], L2.prototype, "_lineSymbol", null), L2 = __decorate([a("esri.views.analysis.ElevationProfile.ElevationProfileTool")], L2);
var O4 = new c({ mode: "on-the-ground", offset: 0 });

// node_modules/@arcgis/core/views/2d/analysis/ElevationProfileAnalysisView2D.js
var u9 = class extends e5 {
  constructor(e10) {
    super(e10), this.type = "elevation-profile-view-2d", this.analysis = null, this.hoveredPosition = null;
  }
  initialize() {
    const { analysis: e10, view: o10 } = this;
    this._controller = new k2({ analysis: e10, analysisViewData: this, view: o10, computationFactory: { create: (e11) => {
      switch (e11.profile.type) {
        case "ground":
          return new u7(e11);
        case "input":
          return new u8(e11);
        case "query":
          return new n8(e11);
        case "scene":
          throw new s("elevation-profile-analysis-view-2d:unsupported", "The scene profile line type is not supported in 2D views.");
      }
    } } }), this._visualization = new n5({ view: o10, analysisViewData: this }), this._sketchTool = new L2({ view: o10, analysisViewData: this });
  }
  destroy() {
    this._controller?.destroy(), this._visualization?.destroy(), this._sketchTool?.destroy();
  }
  get effectiveDisplayUnits() {
    return this._controller?.effectiveDisplayUnits ?? { distance: "meters", elevation: "meters" };
  }
  get error() {
    return this._controller?.error;
  }
  get hoveredPoints() {
    return this._controller?.hoveredPoints ?? [];
  }
  get interactive() {
    return super.interactive;
  }
  set interactive(e10) {
    super.interactive = e10;
  }
  get progress() {
    return this._controller?.progress ?? 0;
  }
  get results() {
    return this._controller?.results ?? [];
  }
  get statistics() {
    return this._controller?.statistics;
  }
  get updating() {
    return true === this._controller?.updating || true === this._visualization?.updating || true === this._sketchTool?.updating;
  }
  get visible() {
    return super.visible;
  }
  set visible(e10) {
    super.visible = e10;
  }
  get sketchGraphic() {
    return this._sketchTool?.sketchGraphic;
  }
  get toolState() {
    return this._sketchTool?.state ?? "idle";
  }
  place(e10) {
    return this._sketchTool.place(e10);
  }
  pickFeature(e10) {
    return this._sketchTool.pickFeature(e10);
  }
};
__decorate([m({ readOnly: true })], u9.prototype, "type", void 0), __decorate([m({ constructOnly: true, nonNullable: true })], u9.prototype, "analysis", void 0), __decorate([m({ readOnly: true })], u9.prototype, "effectiveDisplayUnits", null), __decorate([m({ readOnly: true })], u9.prototype, "error", null), __decorate([m()], u9.prototype, "hoveredPosition", void 0), __decorate([m()], u9.prototype, "hoveredPoints", null), __decorate([m({ readOnly: true })], u9.prototype, "progress", null), __decorate([m({ readOnly: true })], u9.prototype, "results", null), __decorate([m({ readOnly: true })], u9.prototype, "statistics", null), __decorate([m({ readOnly: true })], u9.prototype, "updating", null), __decorate([m()], u9.prototype, "sketchGraphic", null), __decorate([m()], u9.prototype, "toolState", null), __decorate([m()], u9.prototype, "_controller", void 0), __decorate([m()], u9.prototype, "_visualization", void 0), __decorate([m()], u9.prototype, "_sketchTool", void 0), u9 = __decorate([a("esri.views.2d.analysis.ElevationProfileAnalysisView2D")], u9);
var y5 = u9;
export {
  y5 as default
};
//# sourceMappingURL=ElevationProfileAnalysisView2D-XP2R3342.js.map
