import {
  d as d3,
  e as e6,
  f as f2,
  i2
} from "./chunk-BLCKE43G.js";
import {
  t as t3
} from "./chunk-ECKVUXN3.js";
import {
  n as n3
} from "./chunk-CHC4AAHW.js";
import {
  d as d2
} from "./chunk-NDWECAKM.js";
import {
  i
} from "./chunk-CT7HOWYG.js";
import {
  e as e5,
  o2 as o
} from "./chunk-BZBDEPRV.js";
import {
  p
} from "./chunk-MXP2VO3L.js";
import {
  d,
  f,
  w
} from "./chunk-OWSUTT7E.js";
import {
  t as t2
} from "./chunk-WNQORCSA.js";
import {
  e as e2
} from "./chunk-COMSADUT.js";
import {
  e as e4
} from "./chunk-3PAAA3FK.js";
import {
  r
} from "./chunk-EGPAQBOO.js";
import {
  e
} from "./chunk-6GHQTYW5.js";
import {
  s as s2
} from "./chunk-WJ3E33GQ.js";
import {
  r as r2
} from "./chunk-YOYO2XMY.js";
import {
  e as e3
} from "./chunk-SZTZNZQW.js";
import {
  n as n2,
  t
} from "./chunk-CFXCM2NO.js";
import {
  a,
  n
} from "./chunk-ZVTEFYZX.js";
import {
  s
} from "./chunk-LPUPM55U.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/stippleTextureRepository.js
function u(t5) {
  return t5.pattern.map((e8) => Math.round(e8 * t5.pixelRatio));
}
function l(t5) {
  if (null == t5) return 1;
  const e8 = u(t5);
  return Math.floor(e8.reduce((t6, e9) => t6 + e9));
}

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/ensureColor4.js
function s3(t5) {
  return null == t5 ? a : 4 === t5.length ? t5 : s(c, t5[0], t5[1], t5[2], 1);
}
var c = n();

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/LineStipple.glsl.js
function c2(p2, c3) {
  if (!c3.stippleEnabled) return void p2.fragment.code.add(t`float getStippleAlpha(float lineWidth) { return 1.0; }
void discardByStippleAlpha(float stippleAlpha, float threshold) {}
vec4 blendStipple(vec4 color, float stippleAlpha) { return color; }`);
  const u2 = !(c3.draped && c3.stipplePreferContinuous), { vertex: S, fragment: h2 } = p2;
  c3.draped || (d(S, c3), S.uniforms.add(new r("worldToScreenPerDistanceRatio", ({ camera: e8 }) => 1 / e8.perScreenPixelRatio)).code.add(t`float computeWorldToScreenRatio(vec3 segmentCenter) {
float segmentDistanceToCamera = length(segmentCenter - cameraPosition);
return worldToScreenPerDistanceRatio / segmentDistanceToCamera;
}`)), p2.varyings.add("vStippleDistance", "float"), p2.varyings.add("vStippleDistanceLimits", "vec2"), p2.varyings.add("vStipplePatternStretch", "float"), S.code.add(t`
    float discretizeWorldToScreenRatio(float worldToScreenRatio) {
      float step = ${t.float(m)};

      float discreteWorldToScreenRatio = log(worldToScreenRatio);
      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;
      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);
      return discreteWorldToScreenRatio;
    }
  `), w(S), S.code.add(t`
    vec2 computeStippleDistanceLimits(float startPseudoScreen, float segmentLengthPseudoScreen, float segmentLengthScreen, float patternLength) {

      // First check if the segment is long enough to support fully screen space patterns.
      // Force sparse mode for segments that are very large in screen space even if it is not allowed,
      // to avoid imprecision from calculating with large floats.
      if (segmentLengthPseudoScreen >= ${u2 ? "patternLength" : "1e4"}) {
        // Round the screen length to get an integer number of pattern repetitions (minimum 1).
        float repetitions = segmentLengthScreen / (patternLength * pixelRatio);
        float flooredRepetitions = max(1.0, floor(repetitions + 0.5));
        float segmentLengthScreenRounded = flooredRepetitions * patternLength;

        float stretch = repetitions / flooredRepetitions;

        // We need to impose a lower bound on the stretch factor to prevent the dots from merging together when there is only 1 repetition.
        // 0.75 is the lowest possible stretch value for flooredRepetitions > 1, so it makes sense as lower bound.
        vStipplePatternStretch = max(0.75, stretch);

        return vec2(0.0, segmentLengthScreenRounded);
      }
      return vec2(startPseudoScreen, startPseudoScreen + segmentLengthPseudoScreen);
    }
  `), h2.uniforms.add(new e3("stipplePatternTexture", (e8) => e8.stippleTexture), new r2("stipplePatternPixelSizeInv", (e8) => 1 / f3(e8))), c3.stippleOffColorEnabled && h2.uniforms.add(new e2("stippleOffColor", (e8) => s3(e8.stippleOffColor))), p2.include(d3), h2.code.add(t`float getStippleSDF(out bool isClamped) {
float stippleDistanceClamped = noPerspectiveRead(clamp(vStippleDistance, vStippleDistanceLimits.x, vStippleDistanceLimits.y));
float lineSizeInv = noPerspectiveRead(vLineSizeInv);
vec2 aaCorrectedLimits = vStippleDistanceLimits + vec2(1.0, -1.0) / gl_FragCoord.w;
isClamped = vStippleDistance < aaCorrectedLimits.x || vStippleDistance > aaCorrectedLimits.y;
float u = stippleDistanceClamped * stipplePatternPixelSizeInv * lineSizeInv;
u = fract(u);
float sdf = texture(stipplePatternTexture, vec2(u, 0.5)).r;
return (sdf - 0.5) * vStipplePatternStretch + 0.5;
}
float getStippleSDF() {
bool ignored;
return getStippleSDF(ignored);
}
float getStippleAlpha(float lineWidth) {
bool isClamped;
float stippleSDF = getStippleSDF(isClamped);
float antiAliasedResult = clamp(stippleSDF * lineWidth + 0.5, 0.0, 1.0);
return isClamped ? floor(antiAliasedResult + 0.5) : antiAliasedResult;
}`), h2.code.add(t`
    void discardByStippleAlpha(float stippleAlpha, float threshold) {
     ${n2(!c3.stippleOffColorEnabled, "if (stippleAlpha < threshold) { discard; }")}
    }

    vec4 blendStipple(vec4 color, float stippleAlpha) {
      return ${c3.stippleOffColorEnabled ? "mix(color, stippleOffColor, stippleAlpha)" : "vec4(color.rgb, color.a * stippleAlpha)"};
    }
  `);
}
function f3(e8) {
  const t5 = e8.stipplePattern;
  return t5 ? l(e8.stipplePattern) / t5.pixelRatio : 1;
}
var m = 0.4;

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/AnimatedLine.glsl.js
function m2(t5, m3) {
  if (!m3.hasAnimation) return;
  const { attributes: r3, varyings: d4, vertex: l2, fragment: T } = t5;
  r3.add("timeStamps", "vec4"), d4.add("vTimeStamp", "float"), d4.add("vFirstTime", "float"), d4.add("vLastTime", "float"), d4.add("vTransitionType", "float"), l2.main.add(t`vTimeStamp = timeStamps.x;
vFirstTime = timeStamps.y;
vLastTime = timeStamps.z;
vTransitionType = timeStamps.w;`);
  const { animation: v } = m3;
  3 === v && T.constants.add("decayRate", "float", 2.3), T.code.add(t`
    float getTrailOpacity(float x) {
      ${s4(v)}
    }`), T.uniforms.add(new r2("timeElapsed", (e8) => e8.timeElapsed), new r2("trailLength", (e8) => e8.trailLength), new r2("speed", (e8) => e8.animationSpeed), new e2("timingOptions", (t6) => s(n4, t6.startTime, t6.endTime, t6.fadeInTime, t6.fadeOutTime))), T.code.add(t`float fadeIn(float x) {
return smoothstep(0.0, timingOptions[2], x);
}
float fadeOut(float x) {
return isinf(timingOptions[3]) ? 1.0 : smoothstep(timingOptions[3], 0.0, x);
}`), T.code.add(t`vec4 animate(vec4 color) {
float startTime = timingOptions[0];
float endTime = timingOptions[1];
float totalTime = vLastTime - vFirstTime;
float actualEndTime = int(vTransitionType) == 2 ? min(endTime, startTime + vLastTime / speed) : endTime;
vec4 animatedColor = color;
if (speed == 0.0) {
animatedColor.a *= getTrailOpacity((totalTime - (vTimeStamp - vFirstTime)) / trailLength);
animatedColor.a *= isinf(actualEndTime) ? 1.0 : fadeOut(timeElapsed - actualEndTime);
animatedColor.a *= fadeIn(timeElapsed - startTime);
return animatedColor;
}
float relativeStartTime = mod(startTime, totalTime);
float vHeadRelativeToFirst = mod((timeElapsed - relativeStartTime) * speed - vFirstTime, totalTime);
float vRelativeToHead = vHeadRelativeToFirst + vFirstTime - vTimeStamp;
bool inPreviousCycle = vRelativeToHead < 0.0;
vRelativeToHead += inPreviousCycle ? totalTime : 0.0;
float vAbsoluteTime = timeElapsed - vRelativeToHead / speed;
if (vAbsoluteTime > actualEndTime) {
vRelativeToHead = (timeElapsed - relativeStartTime) * speed - vTimeStamp;
vAbsoluteTime = timeElapsed - vRelativeToHead / speed;
}
animatedColor *= step(startTime, vAbsoluteTime);
animatedColor *= step(vAbsoluteTime, actualEndTime);
animatedColor.a *= isinf(actualEndTime) ? 1.0 : fadeOut(timeElapsed - actualEndTime);
animatedColor.a *= inPreviousCycle ? fadeOut(vHeadRelativeToFirst / speed) : 1.0;
animatedColor.a *= getTrailOpacity(vRelativeToHead / trailLength);
animatedColor.a *= int(vTransitionType) == 0 ? fadeIn(vAbsoluteTime - startTime) : 1.0;
animatedColor.a *= fadeIn(vTimeStamp - vFirstTime);
return animatedColor;
}`);
}
function s4(e8) {
  switch (e8) {
    case 2:
      return "return x >= 0.0 && x <= 1.0 ? 1.0 : 0.0;";
    case 3:
      return "float cutOff = exp(-decayRate);\n        return (exp(-decayRate * x) - cutOff) / (1.0 - cutOff);";
    default:
      return "return 1.0;";
  }
}
var n4 = n();

// node_modules/@arcgis/core/chunks/RibbonLine.glsl.js
var P = 1;
function j(j2) {
  const z2 = new s2(), { attributes: C, varyings: W, vertex: R, fragment: F } = z2, { applyMarkerOffset: A2, draped: V, output: T, capType: E2, stippleEnabled: O, falloffEnabled: M, roundJoins: N2, wireframe: $, innerColorEnabled: _, hasAnimation: k, hasScreenSizePerspective: B } = j2;
  F.include(t3), z2.include(f2, j2), z2.include(c2, j2), z2.include(d2, j2), z2.include(i, j2), z2.include(m2, j2);
  const H = A2 && !V;
  H && (R.uniforms.add(new r2("markerScale", (e8) => e8.markerScale)), z2.include(i2, { space: 2, hasScreenSizePerspective: B })), f(R, j2), R.uniforms.add(new t2("inverseProjectionMatrix", (e8) => e8.camera.inverseProjectionMatrix), new e("nearFar", (e8) => e8.camera.nearFar), new r2("miterLimit", (e8) => "miter" !== e8.join ? 0 : e8.miterLimit), new e4("viewport", (e8) => e8.camera.fullViewport)), R.constants.add("LARGE_HALF_FLOAT", "float", 65500), C.add("position", "vec3"), C.add("previousDelta", "vec4"), C.add("nextDelta", "vec4"), C.add("lineParameters", "vec2"), C.add("u0", "float"), W.add("vColor", "vec4"), W.add("vpos", "vec3", { invariant: true }), W.add("vLineDistance", "float"), W.add("vLineWidth", "float");
  const I = O;
  I && W.add("vLineSizeInv", "float");
  const J = 2 === E2, U = O && J, G = M || U;
  G && W.add("vLineDistanceNorm", "float"), J && (W.add("vSegmentSDF", "float"), W.add("vReverseSegmentSDF", "float")), R.code.add(t`vec2 perpendicular(vec2 v) {
return vec2(v.y, -v.x);
}
float interp(float ncp, vec4 a, vec4 b) {
return (-ncp - a.z) / (b.z - a.z);
}
vec2 rotate(vec2 v, float a) {
float s = sin(a);
float c = cos(a);
mat2 m = mat2(c, -s, s, c);
return m * v;
}`), R.code.add(t`vec4 projectAndScale(vec4 pos) {
vec4 posNdc = proj * pos;
posNdc.xy *= viewport.zw / posNdc.w;
return posNdc;
}`), R.code.add(t`void clip(
inout vec4 pos,
inout vec4 prev,
inout vec4 next,
bool isStartVertex
) {
float vnp = nearFar[0] * 0.99;
if (pos.z > -nearFar[0]) {
if (!isStartVertex) {
if (prev.z < -nearFar[0]) {
pos = mix(prev, pos, interp(vnp, prev, pos));
next = pos;
} else {
pos = vec4(0.0, 0.0, 0.0, 1.0);
}
} else {
if (next.z < -nearFar[0]) {
pos = mix(pos, next, interp(vnp, pos, next));
prev = pos;
} else {
pos = vec4(0.0, 0.0, 0.0, 1.0);
}
}
} else {
if (prev.z > -nearFar[0]) {
prev = mix(pos, prev, interp(vnp, pos, prev));
}
if (next.z > -nearFar[0]) {
next = mix(next, pos, interp(vnp, next, pos));
}
}
}`), w(R), R.constants.add("aaWidth", "float", O ? 0 : 1).main.add(t`bool isStartVertex = abs(abs(lineParameters.y) - 3.0) == 1.0;
vec3 prevPosition = position + previousDelta.xyz * previousDelta.w;
vec3 nextPosition = position + nextDelta.xyz * nextDelta.w;
float coverage = 1.0;
if (lineParameters.y == 0.0) {
gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
}
else {
vec4 pos  = view * vec4(position, 1.0);
vec4 prev = view * vec4(prevPosition, 1.0);
vec4 next = view * vec4(nextPosition, 1.0);
bool isJoin = abs(lineParameters.y) < 3.0;`), H && R.main.add(t`vec4 other = isStartVertex ? next : prev;
bool markersHidden = areWorldMarkersHidden(pos.xyz, other.xyz);
if (!isJoin && !markersHidden) {
pos.xyz += normalize(other.xyz - pos.xyz) * getWorldMarkerSize(pos.xyz) * 0.5;
}`), z2.include(e6), R.main.add(t`
      clip(pos, prev, next, isStartVertex);

      vec3 clippedPos = pos.xyz;
      vec3 clippedCenter = mix(pos.xyz, isStartVertex ? next.xyz : prev.xyz, 0.5);

      forwardViewPosDepth(pos.xyz);

      pos = projectAndScale(pos);
      next = projectAndScale(next);
      prev = projectAndScale(prev);

      vec2 left = (pos.xy - prev.xy);
      vec2 right = (next.xy - pos.xy);

      float leftLen = length(left);
      float rightLen = length(right);

      float lineSize = getSize(${n2(B, "clippedPos")});
      ${n2(O && B, "float patternLineSize = getSize(clippedCenter);")}
      ${n2(O && !B, "float patternLineSize = lineSize;")}

      if (lineSize < 1.0) {
        coverage = lineSize; // convert sub-pixel coverage to alpha
        lineSize = 1.0;
      }
      lineSize += aaWidth;

      float lineWidth = lineSize * pixelRatio;
      vLineWidth = noPerspectiveWrite(lineWidth, pos.w);
      ${I ? t`vLineSizeInv = noPerspectiveWrite(1.0 / lineSize, pos.w);` : ""}
  `);
  (O || J) && R.main.add(t`
      float isEndVertex = float(!isStartVertex);
      vec2 segmentOrigin = mix(pos.xy, prev.xy, isEndVertex);
      vec2 segment = mix(right, left, isEndVertex);
      ${J ? t`vec2 segmentEnd = mix(next.xy, pos.xy, isEndVertex);` : ""}
    `), R.main.add(t`left = (leftLen > 0.001) ? left/leftLen : vec2(0.0, 0.0);
right = (rightLen > 0.001) ? right/rightLen : vec2(0.0, 0.0);
vec2 capDisplacementDir = vec2(0, 0);
vec2 joinDisplacementDir = vec2(0, 0);
float displacementLen = lineWidth;
if (isJoin) {
bool isOutside = (left.x * right.y - left.y * right.x) * lineParameters.y > 0.0;
joinDisplacementDir = normalize(left + right);
joinDisplacementDir = perpendicular(joinDisplacementDir);
if (leftLen > 0.001 && rightLen > 0.001) {
float nDotSeg = dot(joinDisplacementDir, left);
displacementLen /= length(nDotSeg * left - joinDisplacementDir);
if (!isOutside) {
displacementLen = min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));
}
}
float subdivisionFactor = lineParameters.x;
if (isOutside && (displacementLen > miterLimit * lineWidth)) {`), N2 ? R.main.add(t`
        vec2 startDir = leftLen < 0.001 ? right : left;
        startDir = perpendicular(startDir);

        vec2 endDir = rightLen < 0.001 ? left : right;
        endDir = perpendicular(endDir);

        float factor = ${O ? t`min(1.0, subdivisionFactor * ${t.float((P + 2) / (P + 1))})` : t`subdivisionFactor`};

        float rotationAngle = acos(clamp(dot(startDir, endDir), -1.0, 1.0));
        joinDisplacementDir = rotate(startDir, -sign(lineParameters.y) * factor * rotationAngle);
      `) : R.main.add(t`if (leftLen < 0.001) {
joinDisplacementDir = right;
}
else if (rightLen < 0.001) {
joinDisplacementDir = left;
}
else {
joinDisplacementDir = (isStartVertex || subdivisionFactor > 0.0) ? right : left;
}
joinDisplacementDir = perpendicular(joinDisplacementDir);`);
  const q = 0 !== E2;
  return R.main.add(t`
        displacementLen = lineWidth;
      }
    } else {
      // CAP handling ---------------------------------------------------
      joinDisplacementDir = isStartVertex ? right : left;
      joinDisplacementDir = perpendicular(joinDisplacementDir);

      ${q ? t`capDisplacementDir = isStartVertex ? -right : left;` : ""}
    }
  `), R.main.add(t`
    // Displacement (in pixels) caused by join/or cap
    vec2 dpos = joinDisplacementDir * sign(lineParameters.y) * displacementLen + capDisplacementDir * displacementLen;
    float lineDistNorm = noPerspectiveWrite(sign(lineParameters.y), pos.w);

    vLineDistance = lineWidth * lineDistNorm;
    ${G ? t`vLineDistanceNorm = lineDistNorm;` : ""}

    pos.xy += dpos;
  `), J && R.main.add(t`vec2 segmentDir = normalize(segment);
vSegmentSDF = noPerspectiveWrite((isJoin && isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentOrigin, segmentDir)), pos.w);
vReverseSegmentSDF = noPerspectiveWrite((isJoin && !isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentEnd, -segmentDir)), pos.w);`), O && (V ? R.uniforms.add(new r("worldToScreenRatio", (e8) => 1 / e8.screenToPCSRatio)) : R.main.add(t`vec3 segmentCenter = mix((nextPosition + position) * 0.5, (position + prevPosition) * 0.5, isEndVertex);
float worldToScreenRatio = computeWorldToScreenRatio(segmentCenter);`), R.main.add(t`float segmentLengthScreenDouble = length(segment);
float segmentLengthScreen = segmentLengthScreenDouble * 0.5;
float discreteWorldToScreenRatio = discretizeWorldToScreenRatio(worldToScreenRatio);
float segmentLengthRender = length(mix(nextPosition - position, position - prevPosition, isEndVertex));
vStipplePatternStretch = worldToScreenRatio / discreteWorldToScreenRatio;`), V ? R.main.add(t`float segmentLengthPseudoScreen = segmentLengthScreen / pixelRatio * discreteWorldToScreenRatio / worldToScreenRatio;
float startPseudoScreen = u0 * discreteWorldToScreenRatio - mix(0.0, segmentLengthPseudoScreen, isEndVertex);`) : R.main.add(t`float startPseudoScreen = mix(u0, u0 - segmentLengthRender, isEndVertex) * discreteWorldToScreenRatio;
float segmentLengthPseudoScreen = segmentLengthRender * discreteWorldToScreenRatio;`), R.uniforms.add(new r2("stipplePatternPixelSize", (e8) => f3(e8))), R.main.add(t`float patternLength = patternLineSize * stipplePatternPixelSize;
vStippleDistanceLimits = computeStippleDistanceLimits(startPseudoScreen, segmentLengthPseudoScreen, segmentLengthScreen, patternLength);
vStippleDistance = mix(vStippleDistanceLimits.x, vStippleDistanceLimits.y, isEndVertex);
if (segmentLengthScreenDouble >= 0.001) {
vec2 stippleDisplacement = pos.xy - segmentOrigin;
float stippleDisplacementFactor = dot(segment, stippleDisplacement) / (segmentLengthScreenDouble * segmentLengthScreenDouble);
vStippleDistance += (stippleDisplacementFactor - isEndVertex) * (vStippleDistanceLimits.y - vStippleDistanceLimits.x);
}
vStippleDistanceLimits = noPerspectiveWrite(vStippleDistanceLimits, pos.w);
vStippleDistance = noPerspectiveWrite(vStippleDistance, pos.w);
vStippleDistanceLimits = isJoin ?
vStippleDistanceLimits :
isStartVertex ?
vec2(-1e34, vStippleDistanceLimits.y) :
vec2(vStippleDistanceLimits.x, 1e34);`)), R.main.add(t`
      // Convert back into NDC
      pos.xy = (pos.xy / viewport.zw) * pos.w;

      vColor = getColor();
      vColor.a = noPerspectiveWrite(vColor.a * coverage, pos.w);

      ${$ && !V ? "pos.z -= 0.001 * pos.w;" : ""}

      // transform final position to camera space for slicing
      vpos = (inverseProjectionMatrix * pos).xyz;
      gl_Position = pos;
      forwardObjectAndLayerIdColor();
    }`), z2.fragment.include(p, j2), z2.include(n3, j2), F.include(e5), F.main.add(t`discardBySlice(vpos);
discardByTerrainDepth();`), z2.include(d3), F.main.add(t`
    float lineWidth = noPerspectiveRead(vLineWidth);
    float lineDistance = noPerspectiveRead(vLineDistance);
    ${n2(G, t`float lineDistanceNorm = noPerspectiveRead(vLineDistanceNorm);`)}
  `), $ ? F.main.add(t`vec4 finalColor = vec4(1.0, 0.0, 1.0, 1.0);`) : (J && F.main.add(t`
        float sdf = noPerspectiveRead(min(vSegmentSDF, vReverseSegmentSDF));
        vec2 fragmentPosition = vec2(min(sdf, 0.0), lineDistance);

        float fragmentRadius = length(fragmentPosition);
        float fragmentCapSDF = (fragmentRadius - lineWidth) * 0.5; // Divide by 2 to transform from double pixel scale
        float capCoverage = clamp(0.5 - fragmentCapSDF, 0.0, 1.0);

        if (capCoverage < ${t.float(o)}) {
          discard;
        }
      `), U ? F.main.add(t`
      vec2 stipplePosition = vec2(
        min(getStippleSDF() * 2.0 - 1.0, 0.0),
        lineDistanceNorm
      );
      float stippleRadius = length(stipplePosition * lineWidth);
      float stippleCapSDF = (stippleRadius - lineWidth) * 0.5; // Divide by 2 to transform from double pixel scale
      float stippleCoverage = clamp(0.5 - stippleCapSDF, 0.0, 1.0);
      float stippleAlpha = step(${t.float(o)}, stippleCoverage);
      `) : F.main.add(t`float stippleAlpha = getStippleAlpha(lineWidth);`), 10 !== T && F.main.add(t`discardByStippleAlpha(stippleAlpha, ${t.float(o)});`), z2.include(d3), F.uniforms.add(new e2("intrinsicColor", (e8) => e8.color)).main.add(t`vec4 color = intrinsicColor * vColor;
color.a = noPerspectiveRead(color.a);`), _ && F.uniforms.add(new e2("innerColor", (e8) => e8.innerColor ?? e8.color), new r2("innerWidth", (e8, i3) => e8.innerWidth * i3.camera.pixelRatio)).main.add(t`float distToInner = abs(lineDistance) - innerWidth;
float innerAA = clamp(0.5 - distToInner, 0.0, 1.0);
float innerAlpha = innerColor.a + color.a * (1.0 - innerColor.a);
color = mix(color, vec4(innerColor.rgb, innerAlpha), innerAA);`), F.main.add(t`vec4 finalColor = blendStipple(color, stippleAlpha);`), M && (F.uniforms.add(new r2("falloff", (e8) => e8.falloff)), F.main.add(t`finalColor.a *= pow(max(0.0, 1.0 - abs(lineDistanceNorm)), falloff);`)), O || F.main.add(t`float featherStartDistance = max(lineWidth - 2.0, 0.0);
float value = abs(lineDistance);
float feather = (value - featherStartDistance) / (lineWidth - featherStartDistance);
finalColor.a *= 1.0 - clamp(feather, 0.0, 1.0);`), k && F.main.add(t`
        finalColor = animate(finalColor);

        ${n2(10 !== T, t`
            if (finalColor.a <= ${t.float(o)}) {
              discard;
            }`)}
      `)), F.main.add(t`outputColorHighlightOID(finalColor, vpos, finalColor.rgb);`), z2;
}
var z = Object.freeze(Object.defineProperty({ __proto__: null, build: j, ribbonlineNumRoundJoinSubdivisions: P }, Symbol.toStringTag, { value: "Module" }));

export {
  P,
  j,
  z
};
//# sourceMappingURL=chunk-ZP5CSWYG.js.map
