import {
  c2 as c
} from "./chunk-CJAJ4FML.js";
import {
  z
} from "./chunk-H74Q4SYB.js";
import {
  _
} from "./chunk-AXZMNHTN.js";
import {
  ae
} from "./chunk-NMQNUPE4.js";

// node_modules/@arcgis/core/layers/support/rasterFunctions/clipUtils.js
function a(e, n) {
  if (e.spatialReference.equals(n)) return e;
  const i = ae(e.spatialReference), a2 = ae(n);
  if (i === a2) return e;
  const r2 = i / a2;
  return { x: e.x * r2, y: e.y * r2 };
}
async function r(t, e, n) {
  if ("extent" === n.type) return m(t, e, n);
  const { width: a2, height: r2 } = t, h2 = new Uint8Array(a2 * r2);
  if (!(await import("./intersectsOperator-AYBKPYQQ.js")).execute(e, n)) return new c({ pixelType: t.pixelType, width: a2, height: r2, mask: h2, maskIsAlpha: false, pixels: [...t.pixels] });
  if ("polyline" === n.type) return s(t, e, n);
  return (await import("./containsOperator-7M3Y7E2P.js")).execute(n, e) ? t : o(t, e, n);
}
function o(t, e, n) {
  if (!t) return t;
  const { width: a2, height: r2 } = t, o2 = h({ geometry: n, size: [a2, r2], srcExtent: e, srcMask: t.mask });
  return new c({ pixelType: t.pixelType, width: a2, height: r2, mask: o2, maskIsAlpha: false, pixels: [...t.pixels] });
}
function h(t) {
  const { geometry: e, size: n, srcExtent: i, srcMask: a2 } = t, [r2, o2] = n;
  let h2;
  const m2 = i.width / r2, s2 = i.height / o2, { xmin: l2, ymax: p2 } = i;
  if ("extent" === e.type) {
    const t2 = (e.xmin - l2) / m2, n2 = (e.xmax - l2) / m2, i2 = (p2 - e.ymax) / s2, a3 = (p2 - e.ymin) / s2;
    h2 = [[[t2, i2], [t2, a3], [n2, a3], [n2, i2], [t2, i2]]];
  } else h2 = e.rings.map((t2) => t2.map(([t3, e2]) => [(t3 - l2) / m2, (p2 - e2) / s2]));
  return x(h2, n, a2);
}
function x(t, e, n) {
  const [i, a2] = e, r2 = new OffscreenCanvas(i, a2).getContext("2d");
  r2.fillStyle = "#f00", r2.beginPath(), t.forEach((t2) => {
    r2.moveTo(t2[0][0], t2[0][1]);
    for (let e2 = 0; e2 < t2.length; e2++) r2.lineTo(t2[e2][0], t2[e2][1]);
    r2.closePath();
  }), r2.fill();
  const o2 = r2.getImageData(0, 0, i, a2).data, h2 = i * a2, x2 = new Uint8Array(h2);
  let m2 = false;
  for (let s2 = 0; s2 < h2; s2++) n && !n[s2] || (o2[4 * s2 + 3] > 127 ? x2[s2] = 255 : m2 = true);
  return m2 || n ? x2 : void 0;
}
function m(t, e, n) {
  const { width: a2, height: r2 } = t, o2 = new Uint8Array(a2 * r2), h2 = e.width / a2, x2 = e.height / r2;
  if (n.width / h2 < 0.5 || n.height / x2 < 0.5) return new c({ pixelType: t.pixelType, width: a2, height: r2, mask: o2, pixels: [...t.pixels] });
  const { xmin: m2, xmax: s2, ymin: l2, ymax: p2 } = e, { xmin: f, xmax: c2, ymin: y, ymax: M } = n, u = Math.max(m2, f), w = Math.min(s2, c2), d = Math.max(l2, y), g = Math.min(p2, M), T = 0.5 * h2, k = 0.5 * x2;
  if (w - u < T || g - d < k || w < m2 + T || u > s2 - T || d > p2 - k || g < l2 + k) return new c({ pixelType: t.pixelType, width: a2, height: r2, mask: o2, pixels: [...t.pixels] });
  const R = Math.max(0, (u - m2) / h2), j = Math.min(a2, Math.max(0, (w - m2) / h2)), A = Math.max(0, (p2 - g) / x2), z2 = Math.min(r2, Math.max(0, (p2 - d) / x2)), U = Math.round(R), E = Math.round(j) - 1, P = Math.round(A), S = Math.round(z2) - 1;
  if (U === E && R % 1 > 0.5 && j % 1 < 0.5 || P === S && A % 1 > 0.5 && z2 % 1 < 0.5) return new c({ pixelType: t.pixelType, width: a2, height: r2, mask: o2, pixels: [...t.pixels] });
  if (0 === U && 0 === P && E === a2 && S === r2) return t;
  const v = t.mask;
  for (let i = P; i <= S; i++) for (let t2 = U; t2 <= E; t2++) {
    const e2 = i * a2 + t2;
    o2[e2] = v ? v[e2] : 255;
  }
  return new c({ pixelType: t.pixelType, width: a2, height: r2, mask: o2, pixels: [...t.pixels] });
}
function s(t, e, n) {
  const { width: a2, height: r2 } = t, o2 = new Uint8Array(a2 * r2), h2 = e.width / a2, x2 = e.height / r2, { xmin: m2, ymax: s2 } = e, { paths: l2 } = n, p2 = t.mask;
  for (let i = 0; i < l2.length; i++) {
    const t2 = l2[i];
    for (let e2 = 0; e2 < t2.length - 1; e2++) {
      const [n2, i2] = t2[e2], [l3, f] = t2[e2 + 1], c2 = Math.min(i2, f), y = Math.max(i2, f), M = Math.max(0, Math.floor((s2 - y) / x2)), u = Math.min(r2 - 1, Math.floor((s2 - c2) / x2));
      if (!(u < M)) if (M === u) {
        const t3 = Math.min(n2, l3), e3 = Math.max(n2, l3), i3 = Math.max(0, Math.floor((t3 - m2) / h2)), r3 = Math.min(a2 - 1, Math.floor((e3 - m2) / h2));
        if (r3 < i3) continue;
        const x3 = M * a2;
        for (let n3 = x3 + i3; n3 <= x3 + r3; n3++) o2[n3] = p2 ? p2[n3] : 255;
      } else {
        const t3 = (n2 - m2) / h2, e3 = (l3 - n2) / (f - i2) / h2, r3 = x2 * e3;
        for (let n3 = M; n3 <= u; n3++) {
          const h3 = e3 * (s2 - n3 * x2 - i2) + t3, m3 = Math.max(0, Math.floor(r3 > 0 ? h3 - r3 : h3)), l4 = Math.min(a2 - 1, Math.floor(r3 > 0 ? h3 : h3 - r3));
          if (l4 < m3) continue;
          const f2 = n3 * a2;
          for (let t4 = f2 + m3; t4 <= f2 + l4; t4++) o2[t4] = p2 ? p2[t4] : 255;
        }
      }
    }
  }
  return new c({ pixelType: t.pixelType, width: a2, height: r2, mask: o2, pixels: [...t.pixels] });
}
function l(t, e) {
  const { extent: i } = p(t, e, new _({ x: t.pixelSize.x, y: t.pixelSize.y, spatialReference: t.spatialReference })), { extent: a2 } = t.extent;
  if (i.xmax = Math.min(i.xmax, a2.xmax), i.ymax = Math.min(i.ymax, a2.ymax), i.xmin < i.xmax && i.ymin < i.ymax) {
    const { x: e2, y: n } = t.pixelSize, a3 = Math.round(i.width / e2), r2 = Math.round(i.height / n);
    t.extent = i, t.width = a3, t.height = r2;
  }
}
function p(t, n, i, r2 = true) {
  const { spatialReference: o2 } = t, { x: h2, y: x2 } = a(i, o2);
  let m2, s2, l2;
  const p2 = "extent" === n.type ? n : n.extent;
  let { xmin: f, xmax: c2, ymax: y, ymin: M } = p2;
  const { xmin: u, ymax: w } = t.extent;
  return r2 ? (f = u + (f > u ? h2 * Math.round((f - u) / h2) : 0), y = w - (y < w ? x2 * Math.round((w - y) / x2) : 0), c2 = u + (c2 > u ? h2 * Math.round((c2 - u) / h2) : 0), M = w - (M < w ? x2 * Math.round((w - M) / x2) : 0), m2 = new z({ xmin: f, ymax: y, xmax: c2, ymin: M, spatialReference: o2 }), s2 = Math.round(m2.width / h2), l2 = Math.round(m2.height / x2)) : (s2 = Math.floor((c2 - f) / h2 + 0.8), l2 = Math.floor((y - M) / x2 + 0.8), f = u + (f > u ? h2 * Math.floor((f - u) / h2 + 0.1) : 0), y = w - (y < w ? x2 * Math.floor((w - y) / x2 + 0.1) : 0), c2 = f + s2 * h2, M = y - l2 * x2, m2 = new z({ xmin: f, ymax: y, xmax: c2, ymin: M, spatialReference: o2 })), { extent: m2, width: s2, height: l2 };
}

export {
  r,
  h,
  l,
  p
};
//# sourceMappingURL=chunk-L2YWECQ7.js.map
