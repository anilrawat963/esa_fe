import {
  C,
  E,
  P as P2,
  a,
  b2 as b,
  g2 as g,
  i as i4,
  j,
  o as o2,
  p2,
  s as s2,
  s2 as s3
} from "./chunk-OVCUKFGI.js";
import {
  T
} from "./chunk-VDZWDLQQ.js";
import {
  r,
  t as t2
} from "./chunk-XZMK6YI6.js";
import "./chunk-AO5WTXLR.js";
import {
  d,
  f as f2,
  y
} from "./chunk-2ZH6SNCD.js";
import {
  B as B2
} from "./chunk-P6XHDW5Y.js";
import "./chunk-EC6KNOF4.js";
import "./chunk-BH5ZTBHN.js";
import "./chunk-6UYFHUML.js";
import "./chunk-OOOA6BWY.js";
import "./chunk-JCVDJALY.js";
import "./chunk-G4TISAAI.js";
import "./chunk-CXUJAI27.js";
import "./chunk-FAA2FDN5.js";
import {
  I as I2
} from "./chunk-J4LH6NQT.js";
import {
  B,
  H,
  I,
  L,
  Le,
  P,
  Q,
  R,
  Se,
  U,
  _,
  de,
  e as e2,
  ge,
  n as n3,
  oe,
  p,
  q,
  r as r2,
  s,
  s2 as s4,
  te,
  v,
  ye
} from "./chunk-AH42IBBP.js";
import "./chunk-ZGTANDVY.js";
import "./chunk-5LMO3VQI.js";
import "./chunk-ZHSPVODX.js";
import "./chunk-2HGIYEIL.js";
import "./chunk-XX3OKYJS.js";
import "./chunk-OTCNIJ2H.js";
import "./chunk-JGA5YJWL.js";
import "./chunk-GCI4MA3M.js";
import "./chunk-SJ2OBYX2.js";
import "./chunk-MDJNYPVI.js";
import "./chunk-Z6VKIQV2.js";
import {
  i as i2,
  n
} from "./chunk-4PXNA4MD.js";
import "./chunk-ZCI5A4FF.js";
import "./chunk-2D47RURG.js";
import "./chunk-PLNHHGHL.js";
import "./chunk-BBYMM7CM.js";
import "./chunk-QZQPB5XR.js";
import "./chunk-AQFRVV3U.js";
import "./chunk-3GHCGAH2.js";
import "./chunk-HWUOAPTX.js";
import "./chunk-QHCKOBU7.js";
import "./chunk-K2OZ6WVC.js";
import "./chunk-MC6NAKKX.js";
import "./chunk-TF6255HN.js";
import "./chunk-GD4FJL3C.js";
import {
  e,
  i as i3,
  n as n2,
  o,
  t
} from "./chunk-C5OQVQZF.js";
import "./chunk-6KDQMJAI.js";
import "./chunk-UDHS2MGH.js";
import "./chunk-QF7FRVN6.js";
import "./chunk-ENINOZUZ.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-7P2ANHQ3.js";
import "./chunk-XCKT47LJ.js";
import "./chunk-3FUHCAX3.js";
import "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-5UPBUJPC.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-7H3U4IJR.js";
import "./chunk-SMWUT52Z.js";
import {
  c
} from "./chunk-AXZMNHTN.js";
import {
  f
} from "./chunk-5T3MJDSR.js";
import "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import "./chunk-5EI5H4QX.js";
import "./chunk-ZIE53VIV.js";
import "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import "./chunk-GNMPGHLQ.js";
import {
  i3 as i
} from "./chunk-QY7XKUIV.js";
import "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/arcade/arcadeAsyncRuntime.js
var ee = () => i.getLogger("esri.arcade.arcadeAsyncRuntime");
var te2 = Symbol("uninitialized");
function ne(e3) {
  if (e3 === te2) throw new n(null, "InvalidIdentifier", null);
}
function re(e3) {
  return ne(e3), e3;
}
function oe2(t3, n4) {
  const r3 = r(n4);
  if (null !== t3.localScope) {
    const e3 = t3.localScope[r3];
    if (void 0 !== e3) return { scope: t3.localScope, id: r3, var: e3 };
  }
  const o3 = t3.globalScope[r3];
  if (void 0 !== o3) return { scope: t3.globalScope, id: r3, var: o3 };
  throw new n(t3, "InvalidIdentifier", n4);
}
function ae(t3, n4, r3 = "InvalidIdentifier") {
  const o3 = r(n4);
  if (null !== t3.localScope) {
    const e3 = t3.localScope[o3];
    if (void 0 !== e3) return ne(e3), e3.value;
  }
  const a2 = t3.globalScope[o3];
  if (void 0 !== a2) return ne(a2), a2.value;
  throw new n(t3, r3, n4);
}
var ie = function() {
};
async function se(e3, t3) {
  const n4 = [];
  for (let r3 = 0; r3 < t3.arguments.length; r3++) n4.push(await we(e3, t3.arguments[r3]));
  return n4;
}
async function ce(e3, t3, n4) {
  if (true === t3.preparsed) return n4(e3, null, t3.arguments);
  return n4(e3, t3, await se(e3, t3));
}
ie.prototype = Object.freeze(/* @__PURE__ */ Object.create(null));
var le = class extends r2 {
  constructor(e3, t3, n4, r3) {
    super(), this.definition = e3, this.context = t3, this._params = n4, this._locals = r3;
  }
  createFunction(e3) {
    return (...t3) => {
      const n4 = { spatialReference: this.context.spatialReference, console: this.context.console, lrucache: this.context.lrucache, timeZone: this.context.timeZone ?? null, exports: this.context.exports, libraryResolver: this.context.libraryResolver, interceptor: this.context.interceptor, services: this.context.services, abortSignal: this.context.abortSignal, localScope: new ie(), depthCounter: { depth: e3.depthCounter.depth + 1 }, globalScope: this.context.globalScope, track: this.context.track };
      if (n4.depthCounter.depth > 64) throw new n(e3, "MaximumCallDepth", null);
      return ue(n4, this.definition.body, this._params, this._locals, t3, null);
    };
  }
  call(e3, t3) {
    return pe(e3, t3, (n4, r3, o3) => {
      const a2 = { spatialReference: e3.spatialReference, services: e3.services, console: e3.console, libraryResolver: e3.libraryResolver, exports: e3.exports, lrucache: e3.lrucache, timeZone: e3.timeZone ?? null, interceptor: e3.interceptor, localScope: new ie(), abortSignal: e3.abortSignal, globalScope: e3.globalScope, depthCounter: { depth: e3.depthCounter.depth + 1 }, track: e3.track };
      if (a2.depthCounter.depth > 64) throw new n(e3, "MaximumCallDepth", t3);
      return ue(a2, this.definition.body, this._params, this._locals, o3, t3);
    });
  }
  marshalledCall(e3, t3, n4, r3) {
    return r3(e3, t3, async (o3, a2, i5) => {
      const s5 = { spatialReference: e3.spatialReference, services: e3.services, globalScope: n4.globalScope, depthCounter: { depth: e3.depthCounter.depth + 1 }, libraryResolver: e3.libraryResolver, exports: e3.exports, console: e3.console, abortSignal: e3.abortSignal, lrucache: e3.lrucache, timeZone: e3.timeZone ?? null, interceptor: e3.interceptor, localScope: new ie(), track: e3.track };
      return i5 = i5.map((t4) => !L(t4) || t4 instanceof s4 ? t4 : n3(t4, e3, r3)), n3(await ue(s5, this.definition.body, this._params, this._locals, i5, t3), n4, r3);
    });
  }
};
async function ue(e3, t3, n4, r3, o3, a2) {
  if (n4.length !== o3.length) throw new n(e3, "WrongNumberOfParameters", a2);
  if (null != e3.localScope) {
    for (let t4 = 0; t4 < n4.length; t4++) e3.localScope[n4[t4]] = { value: o3[t4] };
    for (const t4 of r3) e3.localScope[t4] = te2;
  }
  const i5 = await de2(e3, t3);
  if (i5 instanceof R) return i5.value;
  if (i5 === _) throw new n(e3, "UnexpectedToken", a2);
  if (i5 === I) throw new n(e3, "UnexpectedToken", a2);
  return i5 instanceof v ? i5.value : i5;
}
var fe = class _fe extends s {
  constructor(e3) {
    super(), this.moduleGlobalContext = e3;
  }
  global(t3) {
    const n4 = r(t3), r3 = this.moduleGlobalContext.globalScope[n4];
    if (ne(r3), L(r3.value) && !(r3.value instanceof s4)) {
      const e3 = new s4();
      return e3.fn = r3.value, e3.parameterEvaluator = ce, e3.context = this.moduleGlobalContext, this.moduleGlobalContext.globalScope[n4] = { value: e3 }, e3;
    }
    return r3.value;
  }
  setGlobal(t3, n4) {
    if (L(n4)) throw new n(null, "AssignModuleFunction", null);
    const r3 = r(t3);
    if (void 0 === this.moduleGlobalContext.globalScope[r3]) throw new n(null, "ModuleExportNotFound", null);
    this.moduleGlobalContext.globalScope[r3] = { value: n4 };
  }
  hasGlobal(t3) {
    return this.moduleGlobalContext.exports.has(r(t3));
  }
  static async load(e3, n4) {
    const { globals: a2, exports: i5 } = i4(n4), s5 = new Xe();
    for (const t3 of a2) t3 in s5 || (s5[t3] = te2);
    const c2 = e3.spatialReference ?? f.WebMercator, l = { lrucache: e3.lrucache, interceptor: e3.interceptor, services: e3.services, console: e3.console ?? tt, abortSignal: e3.abortSignal ?? t2, timeZone: e3.timeZone ?? null, spatialReference: c2, track: null, depthCounter: { depth: 1 }, libraryResolver: new s2(e3.libraryResolver._moduleSingletons, n4.loadedModules), exports: i5, localScope: null, globalScope: s5 };
    return await Ae(l, n4), new _fe(l);
  }
};
async function pe(e3, t3, n4) {
  if (true === t3.preparsed) return n4(e3, null, t3.arguments);
  return n4(e3, t3, await se(e3, t3));
}
async function we(e3, t3) {
  t3.breakpoint && await t3.breakpoint();
  try {
    switch (t3.type) {
      case "UpdateExpression":
        return await Ie(e3, t3);
      case "AssignmentExpression":
        return await Oe(e3, t3);
      case "TemplateLiteral":
        return await We(e3, t3);
      case "Identifier":
        return qe(e3, t3);
      case "MemberExpression":
        return await Le2(e3, t3);
      case "Literal":
        return t3.value;
      case "CallExpression":
        return await Pe(e3, t3);
      case "UnaryExpression":
        return await _e(e3, t3);
      case "BinaryExpression":
        return await Ze(e3, t3);
      case "LogicalExpression":
        return await ze(e3, t3);
      case "ArrayExpression":
        return await De(e3, t3);
      case "ObjectExpression":
        return await he(e3, t3);
      default:
        throw new n(e3, "Unrecognized", t3);
    }
  } catch (n4) {
    throw i2(e3, t3, n4);
  }
}
async function de2(e3, t3) {
  t3.breakpoint && await t3.breakpoint();
  try {
    switch (t3.type) {
      case "ImportDeclaration":
        return await Be(e3, t3);
      case "ExportNamedDeclaration":
        return await Ge(e3, t3);
      case "VariableDeclaration":
        return await Ue(e3, t3);
      case "BlockStatement":
        return await Ae(e3, t3);
      case "FunctionDeclaration":
        return await Ee(e3, t3);
      case "ReturnStatement":
        return await Ce(e3, t3);
      case "IfStatement":
        return await Re(e3, t3);
      case "ExpressionStatement":
        return await Me(e3, t3);
      case "ForStatement":
        return await ge2(e3, t3);
      case "WhileStatement":
        return await me(e3, t3);
      case "ForInStatement":
        return await Fe(e3, t3);
      case "ForOfStatement":
        return await ke(e3, t3);
      case "BreakStatement":
        return _;
      case "EmptyStatement":
        return P;
      case "ContinueStatement":
        return I;
      default:
        throw new n(e3, "Unrecognized", t3);
    }
  } catch (n4) {
    throw i2(e3, t3, n4);
  }
}
async function he(e3, t3) {
  const n4 = [];
  for (let i5 = 0; i5 < t3.properties.length; i5++) {
    const r4 = t3.properties[i5], o4 = await we(e3, r4.value), a3 = "Identifier" === r4.key.type ? r4.key.name : await we(e3, r4.key);
    n4[i5] = { key: a3, value: o4 };
  }
  const r3 = /* @__PURE__ */ Object.create(null), o3 = /* @__PURE__ */ new Map();
  for (let i5 = 0; i5 < n4.length; i5++) {
    const a3 = n4[i5];
    if (L(a3.value)) throw new n(e3, "NoFunctionInDictionary", t3);
    if (false === e(a3.key)) throw new n(e3, "KeyMustBeString", t3);
    let s5 = a3.key.toString();
    const c2 = s5.toLowerCase();
    o3.has(c2) ? s5 = o3.get(c2) : o3.set(c2, s5), a3.value === P ? r3[s5] = null : r3[s5] = a3.value;
  }
  const a2 = new p(r3);
  return a2.immutable = false, a2;
}
async function me(e3, t3) {
  let n4 = await we(e3, t3.test);
  if (false === n4) return P;
  if (true !== n4) throw new n(e3, "BooleanConditionRequired", t3);
  for (; true === n4; ) {
    const r3 = await de2(e3, t3.body);
    if (r3 === _) break;
    if (r3 instanceof R) return r3;
    if (n4 = await we(e3, t3.test), true !== n4 && false !== n4) throw new n(e3, "BooleanConditionRequired", t3);
  }
  return P;
}
async function ge2(e3, t3) {
  try {
    for (null !== t3.init && ("VariableDeclaration" === t3.init.type ? await de2(e3, t3.init) : await we(e3, t3.init)); ; ) {
      if (null !== t3.test) {
        const n5 = await we(e3, t3.test);
        if (true === e3.abortSignal?.aborted) throw new n(e3, "Cancelled", t3);
        if (false === n5) break;
        if (true !== n5) throw new n(e3, "BooleanConditionRequired", t3);
      }
      const n4 = await de2(e3, t3.body);
      if (n4 === _) break;
      if (n4 instanceof R) return n4;
      null !== t3.update && await we(e3, t3.update);
    }
    return P;
  } catch (n4) {
    throw n4;
  }
}
async function ye2(e3, t3, n4, r3, o3 = "i") {
  const a2 = n4.length;
  for (let i5 = 0; i5 < a2; i5++) {
    if ("k" === o3) {
      if (i5 >= n4.length) throw new n(e3, "OutOfBounds", t3);
      r3.scope[r3.id] = { value: n4[i5] };
    } else r3.scope[r3.id] = { value: i5 };
    const a3 = await de2(e3, t3.body);
    if (a3 === _) break;
    if (a3 instanceof R) return a3;
  }
  return P;
}
async function be(e3, t3, n4, r3, o3 = "i") {
  const a2 = n4.length();
  for (let i5 = 0; i5 < a2; i5++) {
    r3.scope[r3.id] = "k" === o3 ? { value: n4.get(i5) } : { value: i5 };
    const a3 = await de2(e3, t3.body);
    if (a3 === _) break;
    if (a3 instanceof R) return a3;
  }
  return P;
}
async function ve(e3, t3, n4, r3) {
  const o3 = n4.iterator(e3.abortSignal);
  let a2;
  for (; null != (a2 = await o3.next()); ) {
    const o4 = I2.createFromGraphicLikeObject(a2.geometry, a2.attributes, n4, e3.timeZone);
    o4._underlyingGraphic = a2, r3.scope[r3.id] = { value: o4 };
    const i5 = await de2(e3, t3.body);
    if (i5 === _) break;
    if (i5 instanceof R) return i5;
  }
  return P;
}
async function xe(e3, t3, n4, r3) {
  for (const o3 of n4.keys()) {
    const a2 = n4.field(o3);
    r3.scope[r3.id] = { value: p.containerEntry(o3, a2) };
    const i5 = await de2(e3, t3.body);
    if (i5 === _) break;
    if (i5 instanceof R) return i5;
  }
  return P;
}
async function Se2(e3, t3, n4, r3) {
  for (const o3 of f2(n4)) {
    const a2 = d(n4, o3, e3, t3, 1);
    r3.scope[r3.id] = { value: p.containerEntry(o3, a2) };
    const i5 = await de2(e3, t3.body);
    if (i5 === _) break;
    if (i5 instanceof R) return i5;
  }
  return P;
}
async function Fe(e3, t3) {
  const n4 = await we(e3, t3.right);
  "VariableDeclaration" === t3.left.type && await de2(e3, t3.left);
  const r3 = oe2(e3, "VariableDeclaration" === t3.left.type ? t3.left.declarations[0].id : t3.left);
  return o(n4) || e(n4) ? await ye2(e3, t3, n4, r3) : te(n4) ? await be(e3, t3, n4, r3) : n4 instanceof p || Q(n4) ? await ye2(e3, t3, n4.keys(), r3, "k") : B(n4) ? await ve(e3, t3, n4, r3) : U(n4) ? await ye2(e3, t3, f2(n4), r3, "k") : P;
}
async function ke(e3, t3) {
  const n4 = await we(e3, t3.right);
  "VariableDeclaration" === t3.left.type && await de2(e3, t3.left);
  const r3 = oe2(e3, "VariableDeclaration" === t3.left.type ? t3.left.declarations[0].id : t3.left);
  return o(n4) || e(n4) ? await ye2(e3, t3, n4, r3, "k") : te(n4) ? await be(e3, t3, n4, r3, "k") : n4 instanceof p || Q(n4) ? await xe(e3, t3, n4, r3) : B(n4) ? await ve(e3, t3, n4, r3) : U(n4) ? await Se2(e3, t3, n4, r3) : P;
}
async function Ie(e3, t3) {
  const n4 = t3.argument;
  if ("CallExpression" === n4.type) throw new n(e3, "NeverReach", t3);
  if ("MemberExpression" === n4.type) {
    const r4 = await we(e3, n4.object);
    let o4, a3;
    if (true === n4.computed) o4 = await we(e3, n4.property);
    else {
      if ("Identifier" !== n4.property.type) throw new n(e3, "Unrecognized", t3);
      o4 = n4.property.name;
    }
    if (o(r4)) {
      if (!n2(o4)) throw new n(e3, "ArrayAccessMustBeNumber", t3);
      if (o4 < 0 && (o4 = r4.length + o4), o4 < 0 || o4 >= r4.length) throw new n(e3, "OutOfBounds", t3);
      a3 = Se(r4[o4]), r4[o4] = "++" === t3.operator ? a3 + 1 : a3 - 1;
    } else if (r4 instanceof p) {
      if (false === e(o4)) throw new n(e3, "KeyAccessorMustBeString", t3);
      if (true !== r4.hasField(o4)) throw new n(e3, "FieldNotFound", t3, { key: o4 });
      a3 = Se(r4.field(o4)), r4.setField(o4, "++" === t3.operator ? a3 + 1 : a3 - 1);
    } else if (r4 instanceof fe) {
      if (false === e(o4)) throw new n(e3, "ModuleAccessorMustBeString", t3);
      if (true !== r4.hasGlobal(o4)) throw new n(e3, "ModuleExportNotFound", t3);
      a3 = Se(r4.global(o4)), r4.setGlobal(o4, "++" === t3.operator ? a3 + 1 : a3 - 1);
    } else {
      if (!H(r4)) throw te(r4) ? new n(e3, "Immutable", t3) : new n(e3, "InvalidParameter", t3);
      if (false === e(o4)) throw new n(e3, "KeyAccessorMustBeString", t3);
      if (true !== r4.hasField(o4)) throw new n(e3, "FieldNotFound", t3, { key: o4 });
      a3 = Se(r4.field(o4)), r4.setField(o4, "++" === t3.operator ? a3 + 1 : a3 - 1);
    }
    return false === t3.prefix ? a3 : "++" === t3.operator ? a3 + 1 : a3 - 1;
  }
  const r3 = oe2(e3, n4), o3 = Se(re(r3.var).value), a2 = "++" === t3.operator ? o3 + 1 : o3 - 1;
  return r3.scope[r3.id] = { value: a2 }, false === t3.prefix ? o3 : "++" === t3.operator ? o3 + 1 : o3 - 1;
}
function je(e3, t3, n4, r3, o3) {
  switch (t3) {
    case "=":
      return e3 === P ? null : e3;
    case "/=":
      return Se(n4) / Se(e3);
    case "*=":
      return Se(n4) * Se(e3);
    case "-=":
      return Se(n4) - Se(e3);
    case "+=":
      return e(n4) || e(e3) ? ge(n4) + ge(e3) : Se(n4) + Se(e3);
    case "%=":
      return Se(n4) % Se(e3);
    default:
      throw new n(o3, "UnsupportedOperator", r3);
  }
}
async function Oe(e3, t3) {
  const n4 = t3.left;
  if ("MemberExpression" === n4.type) {
    const r4 = await we(e3, n4.object);
    let o4;
    if (true === n4.computed) o4 = await we(e3, n4.property);
    else {
      if ("Identifier" !== n4.property.type) throw new n(e3, "InvalidIdentifier", t3);
      o4 = n4.property.name;
    }
    const a2 = await we(e3, t3.right);
    if (o(r4)) {
      if (!n2(o4)) throw new n(e3, "ArrayAccessMustBeNumber", t3);
      if (o4 < 0 && (o4 = r4.length + o4), o4 < 0 || o4 > r4.length) throw new n(e3, "OutOfBounds", t3);
      if (o4 === r4.length) {
        if ("=" !== t3.operator) throw new n(e3, "OutOfBounds", t3);
        r4[o4] = je(a2, t3.operator, r4[o4], t3, e3);
      } else r4[o4] = je(a2, t3.operator, r4[o4], t3, e3);
    } else if (r4 instanceof p) {
      if (false === e(o4)) throw new n(e3, "KeyAccessorMustBeString", t3);
      if (true === r4.hasField(o4)) r4.setField(o4, je(a2, t3.operator, r4.field(o4), t3, e3));
      else {
        if ("=" !== t3.operator) throw new n(e3, "FieldNotFound", t3, { key: o4 });
        r4.setField(o4, je(a2, t3.operator, null, t3, e3));
      }
    } else if (r4 instanceof fe) {
      if (false === e(o4)) throw new n(e3, "KeyAccessorMustBeString", t3);
      if (true !== r4.hasGlobal(o4)) throw new n(e3, "ModuleExportNotFound", t3);
      r4.setGlobal(o4, je(a2, t3.operator, r4.global(o4), t3, e3));
    } else {
      if (!H(r4)) throw te(r4) ? new n(e3, "Immutable", t3) : new n(e3, "InvalidParameter", t3);
      if (false === e(o4)) throw new n(e3, "KeyAccessorMustBeString", t3);
      if (true === r4.hasField(o4)) r4.setField(o4, je(a2, t3.operator, r4.field(o4), t3, e3));
      else {
        if ("=" !== t3.operator) throw new n(e3, "FieldNotFound", t3, { key: o4 });
        r4.setField(o4, je(a2, t3.operator, null, t3, e3));
      }
    }
    return P;
  }
  const r3 = oe2(e3, n4), o3 = await we(e3, t3.right);
  return r3.scope[r3.id] = { value: je(o3, t3.operator, "=" !== t3.operator ? re(r3.var).value : null, t3, e3) }, P;
}
async function Me(e3, t3) {
  const n4 = await we(e3, t3.expression);
  return n4 === P ? P : new v(n4);
}
async function Re(e3, t3) {
  const n4 = await we(e3, t3.test);
  if (true === n4) return de2(e3, t3.consequent);
  if (false === n4) return null !== t3.alternate ? de2(e3, t3.alternate) : P;
  throw new n(e3, "BooleanConditionRequired", t3);
}
async function Ae(e3, t3) {
  return Ne(e3, t3, 0);
}
async function Ne(e3, t3, n4) {
  if (n4 >= t3.body.length) return P;
  const r3 = await de2(e3, t3.body[n4]);
  return r3 instanceof R || r3 === _ || r3 === I || n4 === t3.body.length - 1 ? r3 : Ne(e3, t3, n4 + 1);
}
async function Ce(e3, t3) {
  if (null === t3.argument) return new R(P);
  const n4 = await we(e3, t3.argument);
  return new R(n4);
}
async function Ee(t3, n4) {
  if (null != t3.localScope) throw ee().error("Function declarations are only valid in global scope."), new n(t3, "NeverReach", n4);
  const r3 = r(n4.id);
  if (!(r3 in t3.globalScope)) throw ee().error(`Function "${r3}" not declared.`), new n(t3, "NeverReach", n4);
  const o3 = s3(n4), i5 = n4.params.map((t4) => r(t4)), s5 = Array.from(o3).filter((e3) => !i5.includes(e3));
  return t3.globalScope[r3] = { value: new le(n4, t3, i5, s5) }, P;
}
async function Be(e3, t3) {
  const n4 = oe2(e3, t3.specifiers[0].local), r3 = e3.libraryResolver;
  if (null == r3) throw ee().error("Internal error: module loader not initialized"), new n(e3, "NeverReach", t3);
  const o3 = r3.loadLibrary(n4.id);
  let a2;
  return r3._moduleSingletons?.has(o3.uri) ? a2 = r3._moduleSingletons.get(o3.uri) : (a2 = await fe.load(e3, o3.syntax), r3._moduleSingletons?.set(o3.uri, a2)), n4.scope[n4.id] = { value: a2 }, P;
}
async function Ge(e3, t3) {
  return await de2(e3, t3.declaration), P;
}
async function Ue(e3, t3) {
  for (const n4 of t3.declarations) await Ke(e3, n4);
  return P;
}
async function Ke(e3, t3) {
  let n4 = null;
  n4 = null === t3.init ? null : await we(e3, t3.init), n4 === P && (n4 = null);
  const r3 = oe2(e3, t3.id);
  r3.scope[r3.id] = { value: n4 };
}
async function Le2(e3, t3) {
  const n4 = await we(e3, t3.object);
  if (null === n4) throw new n(e3, "MemberOfNull", t3);
  if (false === t3.computed) {
    if ("Identifier" === t3.property.type) {
      if (n4 instanceof p || Q(n4)) return n4.field(t3.property.name);
      if (n4 instanceof c) return d(n4, t3.property.name, e3, t3);
      if (n4 instanceof fe) {
        if (!n4.hasGlobal(t3.property.name)) throw new n(e3, "InvalidIdentifier", t3);
        return n4.global(t3.property.name);
      }
      throw new n(e3, "InvalidMemberAccessKey", t3);
    }
    throw new n(e3, "InvalidMemberAccessKey", t3);
  }
  let r3 = await we(e3, t3.property);
  if (n4 instanceof p || Q(n4)) {
    if (e(r3)) return n4.field(r3);
    throw new n(e3, "InvalidMemberAccessKey", t3);
  }
  if (n4 instanceof fe) {
    if (e(r3)) return n4.global(r3);
    throw new n(e3, "InvalidMemberAccessKey", t3);
  }
  if (n4 instanceof c) {
    if (e(r3)) return d(n4, r3, e3, t3);
    throw new n(e3, "InvalidMemberAccessKey", t3);
  }
  if (o(n4)) {
    if (n2(r3) && isFinite(r3) && Math.floor(r3) === r3) {
      if (r3 < 0 && (r3 = n4.length + r3), r3 >= n4.length || r3 < 0) throw new n(e3, "OutOfBounds", t3);
      return n4[r3];
    }
    throw new n(e3, "InvalidMemberAccessKey", t3);
  }
  if (te(n4)) {
    if (n2(r3) && isFinite(r3) && Math.floor(r3) === r3) {
      if (r3 < 0 && (r3 = n4.length() + r3), r3 >= n4.length() || r3 < 0) throw new n(e3, "OutOfBounds", t3);
      return n4.get(r3);
    }
    throw new n(e3, "InvalidMemberAccessKey", t3);
  }
  if (e(n4)) {
    if (n2(r3) && isFinite(r3) && Math.floor(r3) === r3) {
      if (r3 < 0 && (r3 = n4.length + r3), r3 >= n4.length || r3 < 0) throw new n(e3, "OutOfBounds", t3);
      return n4[r3];
    }
    throw new n(e3, "InvalidMemberAccessKey", t3);
  }
  throw new n(e3, "InvalidMemberAccessKey", t3);
}
async function _e(e3, t3) {
  const n4 = await we(e3, t3.argument);
  if (t(n4)) {
    if ("!" === t3.operator) return !n4;
    if ("-" === t3.operator) return -1 * Se(n4);
    if ("+" === t3.operator) return 1 * Se(n4);
    if ("~" === t3.operator) return ~Se(n4);
    throw new n(e3, "UnsupportUnaryOperator", t3);
  }
  if ("-" === t3.operator) return -1 * Se(n4);
  if ("+" === t3.operator) return 1 * Se(n4);
  if ("~" === t3.operator) return ~Se(n4);
  throw new n(e3, "UnsupportUnaryOperator", t3);
}
async function De(e3, t3) {
  const n4 = [];
  for (let r3 = 0; r3 < t3.elements.length; r3++) n4.push(await we(e3, t3.elements[r3]));
  for (let r3 = 0; r3 < n4.length; r3++) {
    if (L(n4[r3])) throw new n(e3, "NoFunctionInArray", t3);
    n4[r3] === P && (n4[r3] = null);
  }
  return n4;
}
async function Ze(e3, t3) {
  const n4 = await we(e3, t3.left), r3 = await we(e3, t3.right);
  switch (t3.operator) {
    case "|":
    case "<<":
    case ">>":
    case ">>>":
    case "^":
    case "&":
      return Le(Se(n4), Se(r3), t3.operator);
    case "==":
      return ye(n4, r3);
    case "!=":
      return !ye(n4, r3);
    case "<":
    case ">":
    case "<=":
    case ">=":
      return de(n4, r3, t3.operator);
    case "+":
      return e(n4) || e(r3) ? ge(n4) + ge(r3) : Se(n4) + Se(r3);
    case "-":
      return Se(n4) - Se(r3);
    case "*":
      return Se(n4) * Se(r3);
    case "/":
      return Se(n4) / Se(r3);
    case "%":
      return Se(n4) % Se(r3);
    default:
      throw new n(e3, "UnsupportedOperator", t3);
  }
}
async function ze(e3, t3) {
  const n4 = await we(e3, t3.left);
  if (!t(n4)) throw new n(e3, "LogicalExpressionOnlyBoolean", t3);
  switch (t3.operator) {
    case "||": {
      if (true === n4) return n4;
      const r3 = await we(e3, t3.right);
      if (t(r3)) return r3;
      throw new n(e3, "LogicExpressionOrAnd", t3);
    }
    case "&&": {
      if (false === n4) return n4;
      const r3 = await we(e3, t3.right);
      if (t(r3)) return r3;
      throw new n(e3, "LogicExpressionOrAnd", t3);
    }
    default:
      throw new n(e3, "LogicExpressionOrAnd", t3);
  }
}
function qe(e3, t3) {
  return ae(e3, t3);
}
async function Pe(e3, t3) {
  if ("MemberExpression" === t3.callee.type) {
    const n5 = await we(e3, t3.callee.object);
    if (!(n5 instanceof fe)) throw new n(e3, "FunctionNotFound", t3);
    const r3 = false === t3.callee.computed ? t3.callee.property.name : await we(e3, t3.callee.property);
    if (!n5.hasGlobal(r3)) throw new n(e3, "FunctionNotFound", t3);
    const o3 = n5.global(r3);
    if (!L(o3)) throw new n(e3, "CallNonFunction", t3);
    return o3.call(e3, t3);
  }
  if ("Identifier" !== t3.callee.type) throw new n(e3, "FunctionNotFound", t3);
  const n4 = ae(e3, t3.callee, "FunctionNotFound");
  if (L(n4)) return n4.call(e3, t3);
  throw new n(e3, "CallNonFunction", t3);
}
async function We(e3, t3) {
  let n4 = "", r3 = 0;
  for (const o3 of t3.quasis) if (n4 += o3.value ? o3.value.cooked : "", false === o3.tail) {
    if (t3.expressions[r3]) {
      const o4 = await we(e3, t3.expressions[r3]);
      if (L(o4)) throw new n(e3, "NoFunctionInTemplateLiteral", t3);
      n4 += ge(o4);
    }
    r3++;
  }
  return n4;
}
async function Ve(e3, t3) {
  oe(null === t3.arguments ? [] : t3.arguments, 3, 3, e3, t3);
  const n4 = await we(e3, t3.arguments[0]);
  if (false === t(n4)) throw new n(e3, "BooleanConditionRequired", t3);
  return we(e3, n4 ? t3.arguments[1] : t3.arguments[2]);
}
async function Te(e3, t3) {
  oe(null === t3.arguments ? [] : t3.arguments, 2, 3, e3, t3);
  const n4 = await we(e3, t3.arguments[0]);
  if (3 === t3.arguments.length) {
    const r3 = await we(e3, t3.arguments[1]), o3 = y(n4, r3);
    return null != o3 && "" !== o3 ? o3 : we(e3, t3.arguments[2]);
  }
  return null == n4 || "" === n4 ? we(e3, t3.arguments[1]) : n4;
}
async function Ye(e3, t3) {
  if (t3.arguments.length < 2) throw new n(e3, "WrongNumberOfParameters", t3);
  if (2 === t3.arguments.length) return we(e3, t3.arguments[1]);
  if ((t3.arguments.length - 1) % 2 == 0) throw new n(e3, "WrongNumberOfParameters", t3);
  return $e(e3, t3, 1, await we(e3, t3.arguments[0]));
}
async function $e(e3, t3, n4, r3) {
  const o3 = await we(e3, t3.arguments[n4]);
  if (ye(o3, r3)) return we(e3, t3.arguments[n4 + 1]);
  const a2 = t3.arguments.length - n4;
  return 1 === a2 ? we(e3, t3.arguments[n4]) : 2 === a2 ? null : 3 === a2 ? we(e3, t3.arguments[n4 + 2]) : $e(e3, t3, n4 + 2, r3);
}
async function He(e3, t3) {
  if (t3.arguments.length < 3) throw new n(e3, "WrongNumberOfParameters", t3);
  if (t3.arguments.length % 2 == 0) throw new n(e3, "WrongNumberOfParameters", t3);
  const n4 = await we(e3, t3.arguments[0]);
  if (false === t(n4)) throw new n(e3, "BooleanConditionRequired", t3.arguments[0]);
  return Je(e3, t3, 0, n4);
}
async function Je(e3, t3, n4, r3) {
  if (true === r3) return we(e3, t3.arguments[n4 + 1]);
  if (3 === t3.arguments.length - n4) return we(e3, t3.arguments[n4 + 2]);
  const o3 = await we(e3, t3.arguments[n4 + 2]);
  if (false === t(o3)) throw new n(e3, "ModuleExportNotFound", t3.arguments[n4 + 2]);
  return Je(e3, t3, n4 + 2, o3);
}
function Qe() {
  const e3 = /* @__PURE__ */ Object.create(null);
  j(e3, ce), E(e3, ce), P2(e3, ce, qe), g(e3, ce), C(e3, ce), a(e3, ce), b(e3, ce), B2({ functions: e3, compiled: false, signatures: null, evaluateIdentifier: null, mode: "async", standardFunction: ce, standardFunctionAsync: pe }), e3.iif = Ve, e3.defaultvalue = Te, e3.decode = Ye, e3.when = He;
  const t3 = function() {
    this.textformatting = { value: p.textFormatting() };
  };
  t3.prototype = /* @__PURE__ */ Object.create(null), t3.prototype.infinity = Object.freeze({ value: Number.POSITIVE_INFINITY }), t3.prototype.pi = Object.freeze({ value: Math.PI });
  for (const [n4, r3] of Object.entries(e3)) t3.prototype[n4] = Object.freeze({ value: new e2(r3) });
  return t3;
}
var Xe = Qe();
function et(e3) {
  const t3 = { mode: "async", compiled: false, functions: /* @__PURE__ */ Object.create(null), signatures: [], standardFunction: ce, standardFunctionAsync: pe, evaluateIdentifier: qe };
  for (let n4 = 0; n4 < e3.length; n4++) e3[n4].registerFunctions(t3);
  for (const [n4, r3] of Object.entries(t3.functions)) Xe.prototype[n4] = Object.freeze({ value: new e2(r3) });
  for (let n4 = 0; n4 < t3.signatures.length; n4++) o2(t3.signatures[n4], "async");
}
function tt(e3) {
  console.log(e3);
}
function nt(n4, a2) {
  const i5 = new Set(Object.keys(a2?.vars || {}).map((t3) => r(t3))), s5 = new Set(Object.keys(a2?.customfunctions || {}).map((t3) => r(t3))), { globals: c2, exports: l } = i4(n4);
  return async (e3) => {
    const o3 = e3.spatialReference ?? f.WebMercator;
    let a3 = null;
    n4.usesModules && (a3 = new s2(/* @__PURE__ */ new Map(), n4.loadedModules));
    const f3 = new Xe();
    for (const t3 of s5) null != e3.customfunctions && t3 in e3.customfunctions ? f3[t3] = { value: new e2(e3.customfunctions[t3]) } : f3[t3] = te2;
    for (const t3 of i5) {
      if (null == e3.vars || !(t3 in e3.vars)) {
        t3 in f3 || (f3[t3] = te2);
        continue;
      }
      const n5 = e3.vars[t3] ?? null;
      i3(n5) ? f3[t3] = { value: I2.createFromGraphic(n5, e3.timeZone ?? null) } : f3[t3] = { value: n5 };
    }
    for (const t3 of c2) t3 in f3 || (f3[t3] = te2);
    const d2 = { lrucache: e3.lrucache, interceptor: e3.interceptor, services: e3.services, console: e3.console ?? tt, abortSignal: e3.abortSignal ?? t2, timeZone: e3.timeZone ?? null, spatialReference: o3, track: e3.track, depthCounter: { depth: 1 }, libraryResolver: a3, exports: l, localScope: null, globalScope: f3 }, h = await Ae(d2, n4);
    if (h instanceof R || h instanceof v) {
      const e4 = h.value;
      if (q(e4)) return null;
      if (L(e4)) throw new n(d2, "IllegalResult", null);
      return e4;
    }
    if (q(h)) return null;
    if (h === _) throw new n(d2, "IllegalResult", null);
    if (h === I) throw new n(d2, "IllegalResult", null);
    throw new n(d2, "NeverReach", null);
  };
}
function rt(e3, t3) {
  return nt(e3, t3)(t3);
}
et([p2]), et([T]);
export {
  rt as executeScript,
  et as extend,
  nt as prepareScript
};
//# sourceMappingURL=arcadeAsyncRuntime-UVDATYBL.js.map
