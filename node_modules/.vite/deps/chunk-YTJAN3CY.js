import {
  a
} from "./chunk-T6CRNJ3D.js";
import {
  l,
  o2 as o3,
  r as r3
} from "./chunk-KEMYAF6M.js";
import {
  F,
  e as e2,
  i,
  o as o2,
  t as t2,
  v
} from "./chunk-HETHJJO6.js";
import {
  t as t4
} from "./chunk-KOVWXXQR.js";
import {
  o as o4
} from "./chunk-S2SKSSUG.js";
import {
  d2 as d
} from "./chunk-I4DSU5MJ.js";
import {
  d as d2
} from "./chunk-NDWECAKM.js";
import {
  c,
  e as e3,
  r as r2,
  u
} from "./chunk-KTMKDXZP.js";
import {
  d as d3,
  e as e6,
  o2 as o5,
  t as t3
} from "./chunk-BZBDEPRV.js";
import {
  p
} from "./chunk-MXP2VO3L.js";
import {
  f,
  p as p2
} from "./chunk-OWSUTT7E.js";
import {
  e as e4
} from "./chunk-66Y6I5GR.js";
import {
  r as r4
} from "./chunk-YOYO2XMY.js";
import {
  e as e5
} from "./chunk-SZTZNZQW.js";
import {
  n as n4,
  t
} from "./chunk-CFXCM2NO.js";
import {
  n as n3
} from "./chunk-ZVTEFYZX.js";
import {
  o
} from "./chunk-VYMBX5H5.js";
import {
  r
} from "./chunk-K2OZ6WVC.js";
import {
  n as n2
} from "./chunk-75XOUSSS.js";
import {
  j
} from "./chunk-LTPHDYPK.js";
import {
  e
} from "./chunk-3OVERDFX.js";
import {
  n
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl.js
function o6(o7, a2) {
  switch (o7.fragment.code.add(t`vec3 screenDerivativeNormal(vec3 positionView) {
return normalize(cross(dFdx(positionView), dFdy(positionView)));
}`), a2.normalType) {
    case 1:
      o7.attributes.add("normalCompressed", "vec2"), o7.vertex.code.add(t`vec3 decompressNormal(vec2 normal) {
float z = 1.0 - abs(normal.x) - abs(normal.y);
return vec3(normal + sign(normal) * min(z, 0.0), z);
}
vec3 normalModel() {
return decompressNormal(normalCompressed);
}`);
      break;
    case 0:
      o7.attributes.add("normal", "vec3"), o7.vertex.code.add(t`vec3 normalModel() {
return normal;
}`);
      break;
    default:
      n(a2.normalType);
    case 2:
    case 3:
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexNormal.glsl.js
function d4(o7, a2) {
  switch (a2.normalType) {
    case 0:
    case 1:
      o7.include(o6, a2), o7.varyings.add("vNormalWorld", "vec3"), o7.varyings.add("vNormalView", "vec3"), o7.vertex.uniforms.add(new t2("transformNormalGlobalFromModel", (r6) => r6.transformNormalGlobalFromModel), new t3("transformNormalViewFromGlobal", (r6) => r6.transformNormalViewFromGlobal)).code.add(t`void forwardNormal() {
vNormalWorld = transformNormalGlobalFromModel * normalModel();
vNormalView = transformNormalViewFromGlobal * vNormalWorld;
}`);
      break;
    case 2:
      o7.vertex.code.add(t`void forwardNormal() {}`);
      break;
    default:
      n(a2.normalType);
    case 3:
  }
}
var f2 = class extends v {
  constructor() {
    super(...arguments), this.transformNormalViewFromGlobal = e();
  }
};
var c2 = class extends F {
  constructor() {
    super(...arguments), this.transformNormalGlobalFromModel = e(), this.toMapSpace = n3();
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/Offset.glsl.js
function c3(c5) {
  c5.vertex.code.add(t`vec4 offsetBackfacingClipPosition(vec4 posClip, vec3 posWorld, vec3 normalWorld, vec3 camPosWorld) {
vec3 camToVert = posWorld - camPosWorld;
bool isBackface = dot(camToVert, normalWorld) > 0.0;
if (isBackface) {
posClip.z += 0.0000003 * posClip.w;
}
return posClip;
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/InstanceColor.glsl.js
function t5(t6, a2) {
  a2.instancedColor ? (t6.attributes.add("instanceColor", "vec4"), t6.vertex.include(r2), t6.vertex.include(e3), t6.vertex.include(c), t6.vertex.code.add(t`
      MaskedColor applyInstanceColor(MaskedColor color) {
        return multiplyMaskedColors( color, createMaskedFromUInt8NaNColor(${"instanceColor"}));
      }
    `)) : t6.vertex.code.add(t`MaskedColor applyInstanceColor(MaskedColor color) {
return color;
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/InstancedDoublePrecision.glsl.js
var x = e();
function p3(r6, n5) {
  const { hasModelTransformation: g, instancedDoublePrecision: u2, instanced: p4, output: f5, hasVertexTangents: w } = n5;
  g && (r6.vertex.uniforms.add(new t4("model", (e7) => e7.modelTransformation ?? r)), r6.vertex.uniforms.add(new t3("normalLocalOriginFromModel", (r7) => (j(x, r7.modelTransformation ?? r), x)))), p4 && u2 && (r6.attributes.add("instanceModelOriginHi", "vec3"), r6.attributes.add("instanceModelOriginLo", "vec3"), r6.attributes.add("instanceModel", "mat3"), r6.attributes.add("instanceModelNormal", "mat3"));
  const _ = r6.vertex;
  u2 && (_.include(e2, n5), _.uniforms.add(new e4("viewOriginHi", (e7) => o3(o(M, e7.camera.viewInverseTransposeMatrix[3], e7.camera.viewInverseTransposeMatrix[7], e7.camera.viewInverseTransposeMatrix[11]), M)), new e4("viewOriginLo", (e7) => r3(o(M, e7.camera.viewInverseTransposeMatrix[3], e7.camera.viewInverseTransposeMatrix[7], e7.camera.viewInverseTransposeMatrix[11]), M)))), _.code.add(t`
    vec3 getVertexInLocalOriginSpace() {
      return ${g ? u2 ? "(model * vec4(instanceModel * localPosition().xyz, 1.0)).xyz" : "(model * localPosition()).xyz" : u2 ? "instanceModel * localPosition().xyz" : "localPosition().xyz"};
    }

    vec3 subtractOrigin(vec3 _pos) {
      ${u2 ? t`
          // Issue: (should be resolved now with invariant position) https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/56280
          vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -instanceModelOriginHi, -instanceModelOriginLo);
          return _pos - originDelta;` : "return vpos;"}
    }
    `), _.code.add(t`
    vec3 dpNormal(vec4 _normal) {
      return normalize(${g ? u2 ? "normalLocalOriginFromModel * (instanceModelNormal * _normal.xyz)" : "normalLocalOriginFromModel * _normal.xyz" : u2 ? "instanceModelNormal * _normal.xyz" : "_normal.xyz"});
    }
    `), 3 === f5 && (p2(_), _.code.add(t`
    vec3 dpNormalView(vec4 _normal) {
      return normalize((viewNormal * ${g ? u2 ? "vec4(normalLocalOriginFromModel * (instanceModelNormal * _normal.xyz), 1.0)" : "vec4(normalLocalOriginFromModel * _normal.xyz, 1.0)" : u2 ? "vec4(instanceModelNormal * _normal.xyz, 1.0)" : "_normal"}).xyz);
    }
    `)), w && _.code.add(t`
    vec4 dpTransformVertexTangent(vec4 _tangent) {
      ${g ? u2 ? "return vec4(normalLocalOriginFromModel * (instanceModelNormal * _tangent.xyz), _tangent.w);" : "return vec4(normalLocalOriginFromModel * _tangent.xyz, _tangent.w);" : u2 ? "return vec4(instanceModelNormal * _tangent.xyz, _tangent.w);" : "return _tangent;"}
    }`);
}
var M = n2();

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/SymbolColor.glsl.js
function i2(i4, s) {
  i4.varyings.add("colorMixMode", "int"), i4.varyings.add("opacityMixMode", "int"), i4.vertex.uniforms.add(new o4("symbolColorMixMode", (o7) => l[o7.colorMixMode])), s.hasSymbolColors ? (i4.vertex.include(r2), i4.vertex.include(e3), i4.vertex.include(c), i4.attributes.add("symbolColor", "vec4"), i4.vertex.code.add(t`
    MaskedColor applySymbolColor(MaskedColor color) {
      return multiplyMaskedColors(color, createMaskedFromUInt8NaNColor(${"symbolColor"}));
    }
  `)) : i4.vertex.code.add(t`MaskedColor applySymbolColor(MaskedColor color) {
return color;
}`), i4.vertex.code.add(t`
    void forwardColorMixMode(bvec4 mask) {
      colorMixMode = mask.r ? ${t.int(l.ignore)} : symbolColorMixMode;
      opacityMixMode = mask.a ? ${t.int(l.ignore)} : symbolColorMixMode;
    }
  `);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/DiscardOrAdjustAlpha.glsl.js
function f3(o7, r6) {
  l2(o7, r6, new r4("textureAlphaCutoff", (o8) => o8.textureAlphaCutoff));
}
function l2(o7, t6, f5) {
  const s = o7.fragment, l3 = t6.alphaDiscardMode, u2 = 0 === l3;
  2 !== l3 && 3 !== l3 || s.uniforms.add(f5), s.code.add(t`
    void discardOrAdjustAlpha(inout vec4 color) {
      ${1 === l3 ? "color.a = 1.0;" : `if (color.a < ${u2 ? t.float(o5) : "textureAlphaCutoff"}) {
              discard;
             } ${n4(2 === l3, "else { color.a = 1.0; }")}`}
    }
  `);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/default/DefaultMaterialAuxiliaryPasses.glsl.js
function f4(f5, g) {
  const { vertex: x2, fragment: O, varyings: j2 } = f5, { hasColorTexture: h, alphaDiscardMode: w } = g, V = h && 1 !== w, { output: C, normalType: b, hasColorTextureTransform: A } = g;
  switch (C) {
    case 2:
      f(x2, g), f5.include(o2), O.include(p, g), f5.include(d, g), V && O.uniforms.add(new e5("tex", (o7) => o7.texture)), x2.main.add(t`vpos = getVertexInLocalOriginSpace();
vpos = subtractOrigin(vpos);
vpos = addVerticalOffset(vpos, localOrigin);
gl_Position = transformPosition(proj, view, vpos);
forwardTextureCoordinates();`), f5.include(f3, g), O.main.add(t`
        discardBySlice(vpos);
        ${n4(V, t`vec4 texColor = texture(tex, ${A ? "colorUV" : "vuv0"});
                discardOrAdjustAlpha(texColor);`)}`);
      break;
    case 4:
    case 5:
    case 6:
    case 7:
    case 10:
      f(x2, g), f5.include(o2), f5.include(d, g), f5.include(u, g), f5.include(a, g), O.include(p, g), f5.include(d2, g), i(f5), j2.add("depth", "float", { invariant: true }), V && O.uniforms.add(new e5("tex", (o7) => o7.texture)), x2.main.add(t`vpos = getVertexInLocalOriginSpace();
vpos = subtractOrigin(vpos);
vpos = addVerticalOffset(vpos, localOrigin);
gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);
forwardTextureCoordinates();
forwardObjectAndLayerIdColor();`), f5.include(f3, g), O.main.add(t`
        discardBySlice(vpos);
        ${n4(V, t`vec4 texColor = texture(tex, ${A ? "colorUV" : "vuv0"});
               discardOrAdjustAlpha(texColor);`)}
        ${10 === C ? t`outputObjectAndLayerIdColor();` : t`outputDepth(depth);`}`);
      break;
    case 3: {
      f(x2, g), f5.include(o2), f5.include(o6, g), f5.include(d4, g), f5.include(d, g), f5.include(u, g), V && O.uniforms.add(new e5("tex", (o8) => o8.texture)), 2 === b && j2.add("vPositionView", "vec3", { invariant: true });
      const o7 = 0 === b || 1 === b;
      x2.main.add(t`
        vpos = getVertexInLocalOriginSpace();
        ${o7 ? t`vNormalWorld = dpNormalView(vvLocalNormal(normalModel()));` : t`vPositionView = (view * vec4(vpos, 1.0)).xyz;`}
        vpos = subtractOrigin(vpos);
        vpos = addVerticalOffset(vpos, localOrigin);
        gl_Position = transformPosition(proj, view, vpos);
        forwardTextureCoordinates();`), O.include(p, g), f5.include(f3, g), O.main.add(t`
        discardBySlice(vpos);
        ${n4(V, t`vec4 texColor = texture(tex, ${A ? "colorUV" : "vuv0"});
                discardOrAdjustAlpha(texColor);`)}

        ${2 === b ? t`vec3 normal = screenDerivativeNormal(vPositionView);` : t`vec3 normal = normalize(vNormalWorld);
                    if (gl_FrontFacing == false){
                      normal = -normal;
                    }`}
        fragColor = vec4(0.5 + 0.5 * normal, 1.0);`);
      break;
    }
    case 9:
      f(x2, g), f5.include(o2), f5.include(d, g), f5.include(u, g), V && O.uniforms.add(new e5("tex", (o7) => o7.texture)), x2.main.add(t`vpos = getVertexInLocalOriginSpace();
vpos = subtractOrigin(vpos);
vpos = addVerticalOffset(vpos, localOrigin);
gl_Position = transformPosition(proj, view, vpos);
forwardTextureCoordinates();`), O.include(p, g), f5.include(f3, g), f5.include(d3, g), O.main.add(t`
        discardBySlice(vpos);
        ${n4(V, t`vec4 texColor = texture(tex, ${A ? "colorUV" : "vuv0"});
                discardOrAdjustAlpha(texColor);`)}
        calculateOcclusionAndOutputHighlight();`);
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/MixExternalColor.glsl.js
function i3(i4) {
  i4.include(e6), i4.code.add(t`
    vec3 mixExternalColor(vec3 internalColor, vec3 textureColor, vec3 externalColor, int mode) {
      // workaround for artifacts in macOS using Intel Iris Pro
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475
      vec3 internalMixed = internalColor * textureColor;
      vec3 allMixed = internalMixed * externalColor;

      if (mode == ${t.int(1)}) {
        return allMixed;
      }
      if (mode == ${t.int(2)}) {
        return internalMixed;
      }
      if (mode == ${t.int(3)}) {
        return externalColor;
      }

      // tint (or something invalid)
      float vIn = rgb2v(internalMixed);
      vec3 hsvTint = rgb2hsv(externalColor);
      vec3 hsvOut = vec3(hsvTint.x, hsvTint.y, vIn * hsvTint.z);
      return hsv2rgb(hsvOut);
    }

    float mixExternalOpacity(float internalOpacity, float textureOpacity, float externalOpacity, int mode) {
      // workaround for artifacts in macOS using Intel Iris Pro
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475
      float internalMixed = internalOpacity * textureOpacity;
      float allMixed = internalMixed * externalOpacity;

      if (mode == ${t.int(2)}) {
        return internalMixed;
      }
      if (mode == ${t.int(3)}) {
        return externalOpacity;
      }

      // multiply or tint (or something invalid)
      return allMixed;
    }
  `);
}

export {
  o6 as o,
  d4 as d,
  f2 as f,
  c2 as c,
  c3 as c2,
  t5 as t,
  p3 as p,
  i2 as i,
  f3 as f2,
  f4 as f3,
  i3 as i2
};
//# sourceMappingURL=chunk-YTJAN3CY.js.map
