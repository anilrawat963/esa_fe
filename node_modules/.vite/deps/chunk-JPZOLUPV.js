import {
  i as i2
} from "./chunk-GG4AQJJO.js";
import {
  t
} from "./chunk-4X4BOGIG.js";
import {
  u
} from "./chunk-JE2NJSBU.js";
import {
  N,
  R
} from "./chunk-QNVJVDYZ.js";
import {
  i3 as i,
  l3 as l,
  s2 as s
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/DisplayRecord.js
var _t = class _t {
  constructor(t5, e3, s6, i4, r3, h3, n3) {
    this.instanceId = t5, this.textureKey = e3, this.indexStart = s6, this.indexCount = i4, this.vertexStart = r3, this.vertexCount = h3, this.overlaps = n3;
  }
  updateBaseOffsets(t5) {
    this.vertexStart += t5.vertexFrom, this.indexStart += t5.indexFrom;
  }
  clone() {
    return new _t(this.instanceId, this.textureKey, this.indexStart, this.indexCount, this.vertexStart, this.vertexCount, this.overlaps);
  }
  static write(t5, e3, s6, i4, r3, h3, n3, a3) {
    t5.push(e3), t5.push(s6), t5.push(i4), t5.push(r3), t5.push(h3), t5.push(n3), t5.push(a3);
  }
  serialize(t5) {
    return t5.push(this.instanceId), t5.push(this.textureKey), t5.push(this.indexStart), t5.push(this.indexCount), t5.push(this.vertexStart), t5.push(this.vertexCount), t5.push(this.overlaps), t5;
  }
  static deserialize(e3) {
    const s6 = e3.readInt32(), i4 = e3.readInt32(), r3 = e3.readInt32(), h3 = e3.readInt32(), n3 = e3.readInt32(), a3 = e3.readInt32(), u2 = e3.readInt32();
    return new _t(s6, i4, r3, h3, n3, a3, u2);
  }
};
_t.byteSizeHint = 7 * Uint32Array.BYTES_PER_ELEMENT;
_t.estimatedMemory = 40;
var t2 = _t;

// node_modules/@arcgis/core/views/2d/engine/webgl/util/serializationUtils.js
function e(e3, n3) {
  if (null !== n3) {
    e3.push(n3.length);
    for (const r3 of n3) r3.serialize(e3);
    return e3;
  }
  e3.push(0);
}
function n(e3, n3, r3) {
  const t5 = e3.readInt32(), o4 = new Array(t5);
  for (let i4 = 0; i4 < o4.length; i4++) o4[i4] = n3.deserialize(e3, r3);
  return o4;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/DisplayEntity.js
var _e = class _e {
  static estimateMemory(i4) {
    return 24 + t2.estimatedMemory * i4;
  }
  constructor(t5, i4) {
    this.id = t5, this.sortKey = i4, this.records = [];
  }
  serialize(t5) {
    return t5.push(this.id), t5.writeF32(this.sortKey), e(t5, this.records), t5;
  }
  static deserialize(i4) {
    const s6 = i4.readInt32(), o4 = i4.readF32(), a3 = new _e(s6, o4);
    return a3.records = n(i4, t2) ?? [], a3;
  }
};
_e.byteSizeHint = 2 * Uint32Array.BYTES_PER_ELEMENT + t2.byteSizeHint;
var e2 = _e;

// node_modules/@arcgis/core/views/2d/engine/webgl/number.js
var n2 = new Float32Array(1);
var t3 = new Uint32Array(n2.buffer);
function a(r3) {
  return n2[0] = r3, t3[0];
}
function h(r3) {
  return t3[0] = r3, n2[0];
}
function s2(n3, t5) {
  return 65535 & n3 | t5 << 16;
}
function y(n3) {
  const t5 = a(n3), r3 = t5 >>> 31;
  let u2 = t5 >>> 23 & 255, o4 = 8388607 & t5;
  return u2 -= 127, u2 > 15 ? r3 << 15 | 31744 : u2 < -25 ? 0 : (u2 < -14 && (o4 += 8388608, o4 /= 2 ** (-14 - u2), u2 = -15), u2 += 15, o4 /= 8192, o4 = A(o4, 1023), r3 << 15 | u2 << 10 | o4);
}
function A(n3, t5) {
  const r3 = Math.floor(n3), u2 = n3 - r3;
  return r3 < t5 && (u2 > 0.5 || 0.5 === u2 && r3 % 2 == 1) ? r3 + 1 : r3;
}
function b(n3) {
  let t5 = n3 >>> 15, r3 = n3 >> 10 & 31, u2 = 1023 & n3;
  return t5 = t5 ? -1 : 1, r3 -= 15, u2 /= 1024, r3 > -15 ? u2 += 1 : r3 = -14, t5 * 2 ** r3 * u2;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/mesh/utils.js
function t4(t5) {
  const r3 = t5.map(({ name: e3, count: t6, type: r4 }) => `${e3}.${t6}.${r4}`).join(",");
  return l(r3);
}
function r(e3, t5, o4, a3, c2, n3, s6) {
  if (e3.primitiveName === t5) {
    let t6 = a3?.readWithDefault(c2, n3, e3[o4] && s6);
    return "text" === e3.type && (t6 = t6.toString()), void (e3[o4] = t6);
  }
  if ("type" in e3 && null != e3.type) {
    if (e3.effects) for (const i4 of e3.effects) r(i4, t5, o4, a3, c2, n3, s6);
    switch (e3.type) {
      case "CIMPointSymbol":
      case "CIMLineSymbol":
      case "CIMPolygonSymbol":
        if (e3.symbolLayers) for (const i4 of e3.symbolLayers) r(i4, t5, o4, a3, c2, n3, s6);
        break;
      case "CIMTextSymbol":
        e3.symbol && r(e3.symbol, t5, o4, a3, c2, n3, s6);
        break;
      case "CIMHatchFill":
        e3.lineSymbol && r(e3.lineSymbol, t5, o4, a3, c2, n3, s6);
        break;
      case "CIMPictureMarker":
      case "CIMCharacterMarker":
      case "CIMVectorMarker":
        if (e3.markerPlacement && r(e3.markerPlacement, t5, o4, a3, c2, n3, s6), "CIMVectorMarker" === e3.type && e3.markerGraphics) for (const i4 of e3.markerGraphics) r(i4, t5, o4, a3, c2, n3, s6), r(i4.symbol, t5, o4, a3, c2, n3, s6);
    }
  }
}
var o = 400;
function a2(e3) {
  const t5 = Math.max(1.25 * e3.width, 20);
  return null != e3.effects && e3.effects.length > 0 ? o : t5;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/mesh/dataViewUtils.js
function o2(e3, o4, s6, f2) {
  const r3 = s6.packPrecisionFactor ?? 1;
  switch (s6.type) {
    case R.BYTE:
      if (1 === s6.count) e3.setInt8(f2 + s6.offset, o4 * r3);
      else for (let t5 = 0; t5 < s6.count; t5++) {
        const n3 = t5 * Int8Array.BYTES_PER_ELEMENT;
        e3.setInt8(f2 + s6.offset + n3, o4[t5] * r3);
      }
      break;
    case R.UNSIGNED_BYTE:
      if (1 === s6.count) e3.setUint8(f2 + s6.offset, o4 * r3);
      else for (let t5 = 0; t5 < s6.count; t5++) {
        const n3 = t5 * Uint8Array.BYTES_PER_ELEMENT;
        e3.setUint8(f2 + s6.offset + n3, o4[t5] * r3);
      }
      break;
    case R.SHORT:
      if (1 === s6.count) e3.setInt16(f2 + s6.offset, o4 * r3, true);
      else for (let t5 = 0; t5 < s6.count; t5++) {
        const n3 = t5 * Int16Array.BYTES_PER_ELEMENT;
        e3.setInt16(f2 + s6.offset + n3, o4[t5] * r3, true);
      }
      break;
    case R.UNSIGNED_SHORT:
      if (1 === s6.count) e3.setUint16(f2 + s6.offset, o4 * r3, true);
      else for (let t5 = 0; t5 < s6.count; t5++) {
        const n3 = t5 * Uint16Array.BYTES_PER_ELEMENT;
        e3.setUint16(f2 + s6.offset + n3, o4[t5] * r3, true);
      }
      break;
    case R.INT:
      if (1 === s6.count) e3.setInt32(f2 + s6.offset, o4 * r3, true);
      else for (let t5 = 0; t5 < s6.count; t5++) {
        const n3 = t5 * Int32Array.BYTES_PER_ELEMENT;
        e3.setInt32(f2 + s6.offset + n3, o4[t5] * r3, true);
      }
      break;
    case R.UNSIGNED_INT:
      if (1 === s6.count) e3.setUint32(f2 + s6.offset, o4 * r3, true);
      else for (let t5 = 0; t5 < s6.count; t5++) {
        const n3 = t5 * Uint32Array.BYTES_PER_ELEMENT;
        e3.setUint32(f2 + s6.offset + n3, o4[t5] * r3, true);
      }
      break;
    case R.FLOAT:
      if (1 === s6.count) e3.setFloat32(f2 + s6.offset, o4 * r3, true);
      else for (let t5 = 0; t5 < s6.count; t5++) {
        const n3 = t5 * Float32Array.BYTES_PER_ELEMENT;
        e3.setFloat32(f2 + s6.offset + n3, o4[t5] * r3, true);
      }
      break;
    case R.HALF_FLOAT:
      if (1 === s6.count) e3.setUint16(f2 + s6.offset, y(o4 * r3), true);
      else for (let n3 = 0; n3 < s6.count; n3++) {
        const E = n3 * Uint16Array.BYTES_PER_ELEMENT;
        e3.setUint16(f2 + s6.offset + E, y(o4[n3] * r3), true);
      }
  }
}
function s3(t5, o4, s6) {
  switch (o4.type) {
    case R.BYTE: {
      if (1 === o4.count) return t5.getInt8(s6 + o4.offset);
      const e3 = [];
      for (let n3 = 0; n3 < o4.count; n3++) {
        const f2 = n3 * Int8Array.BYTES_PER_ELEMENT;
        e3.push(t5.getInt8(s6 + o4.offset + f2));
      }
      return e3;
    }
    case R.UNSIGNED_BYTE: {
      if (1 === o4.count) return t5.getUint8(s6 + o4.offset);
      const e3 = [];
      for (let n3 = 0; n3 < o4.count; n3++) {
        const f2 = n3 * Uint8Array.BYTES_PER_ELEMENT;
        e3.push(t5.getUint8(s6 + o4.offset + f2));
      }
      return e3;
    }
    case R.SHORT: {
      if (1 === o4.count) return t5.getInt16(s6 + o4.offset, true);
      const e3 = [];
      for (let n3 = 0; n3 < o4.count; n3++) {
        const f2 = n3 * Int16Array.BYTES_PER_ELEMENT;
        e3.push(t5.getInt16(s6 + o4.offset + f2, true));
      }
      return e3;
    }
    case R.UNSIGNED_SHORT: {
      if (1 === o4.count) return t5.getUint16(s6 + o4.offset, true);
      const e3 = [];
      for (let n3 = 0; n3 < o4.count; n3++) {
        const f2 = n3 * Uint16Array.BYTES_PER_ELEMENT;
        e3.push(t5.getUint16(s6 + o4.offset + f2, true));
      }
      return e3;
    }
    case R.INT: {
      if (1 === o4.count) return t5.getInt32(s6 + o4.offset, true);
      const e3 = [];
      for (let n3 = 0; n3 < o4.count; n3++) {
        const f2 = n3 * Int32Array.BYTES_PER_ELEMENT;
        e3.push(t5.getInt32(s6 + o4.offset + f2, true));
      }
      return e3;
    }
    case R.UNSIGNED_INT: {
      if (1 === o4.count) return t5.getUint32(s6 + o4.offset, true);
      const e3 = [];
      for (let n3 = 0; n3 < o4.count; n3++) {
        const f2 = n3 * Uint32Array.BYTES_PER_ELEMENT;
        e3.push(t5.getUint32(s6 + o4.offset + f2, true));
      }
      return e3;
    }
    case R.FLOAT: {
      if (1 === o4.count) return t5.getFloat32(s6 + o4.offset, true);
      const e3 = [];
      for (let n3 = 0; n3 < o4.count; n3++) {
        const f2 = n3 * Float32Array.BYTES_PER_ELEMENT;
        e3.push(t5.getFloat32(s6 + o4.offset + f2, true));
      }
      return e3;
    }
    case R.HALF_FLOAT: {
      if (1 === o4.count) return b(t5.getUint16(s6 + o4.offset, true));
      const n3 = [];
      for (let f2 = 0; f2 < o4.count; f2++) {
        const r3 = f2 * Uint16Array.BYTES_PER_ELEMENT;
        n3.push(b(t5.getUint16(s6 + o4.offset + r3, true)));
      }
      return n3;
    }
  }
}

// node_modules/@arcgis/core/views/2d/engine/webgl/collisions/LabelMetric.js
var r2 = 2;
var h2 = class _h {
  constructor(e3, i4, t5, s6, r3, h3, a3, n3, l3, o4, d2, c2 = [], u2 = 0, f2 = 0) {
    this.displayId = e3, this.labelClassId = i4, this.labelIdHash = t5, this.hash = s6, this.anchorX = r3, this.anchorY = h3, this.directionX = a3, this.directionY = n3, this.maxScale = l3, this.minScale = o4, this.referenceBounds = d2, this.bounds = c2, this.recordStart = u2, this.recordCount = f2, this.priority = 0, this._colliders = null, this.uniqueSymbol = null, this.selectedForRendering = false;
  }
  get xTile() {
    return this.anchorX;
  }
  get yTile() {
    return this.anchorY;
  }
  colliders(i4) {
    if (!this._colliders) {
      const t5 = i4.attributeView, s6 = u;
      let h3 = this.referenceBounds?.size ?? 0;
      const a3 = i4.layerView.labelingCollisionInfos[0].vvEvaluators[0];
      if (null != a3) {
        const e3 = a3(t5.getVisualVariableData(this.displayId, 0));
        h3 = isNaN(e3) || null == e3 || e3 === 1 / 0 ? h3 : e3;
      }
      const n3 = this.minScale ? i4.layerView.view.featuresTilingScheme.scaleToZoom(this.minScale) : 0, l3 = this.maxScale ? i4.layerView.view.featuresTilingScheme.scaleToZoom(this.maxScale) : 25, o4 = this.directionX * (s6 + h3 / 2), d2 = this.directionY * (s6 + h3 / 2);
      this._colliders = this.bounds.map((e3) => ({ labelId: this.labelIdHash, xTile: this.anchorX, yTile: this.anchorY, dxPixels: e3.x - e3.halfWidth + o4, dyPixels: e3.y - e3.halfHeight + d2, hard: true, partIndex: 1, width: e3.width + r2, height: e3.height + r2, angle: 0, xScreen: 0, yScreen: 0, dxScreen: 0, dyScreen: 0, enabled: true, minLod: n3, maxLod: l3 }));
    }
    return this._colliders;
  }
  get id() {
    return this.displayId;
  }
  serialize(e3) {
    e3.push(this.displayId), e3.push(this.labelClassId), e3.push(this.labelIdHash), e3.push(this.hash), e3.push(this.recordStart), e3.push(this.recordCount), e3.writeF32(this.anchorX), e3.writeF32(this.anchorY), e3.writeF32(this.directionX), e3.writeF32(this.directionY), e3.writeF32(this.maxScale), e3.writeF32(this.minScale), this.referenceBounds ? (e3.writeF32(this.referenceBounds.size), e3.writeF32(this.referenceBounds.offsetX), e3.writeF32(this.referenceBounds.offsetY)) : (e3.writeF32(0), e3.writeF32(0), e3.writeF32(0)), e(e3, this.bounds);
  }
  static deserialize(e3) {
    const t5 = e3.readInt32(), r3 = e3.readInt32(), a3 = e3.readInt32(), n3 = e3.readInt32(), l3 = e3.readInt32(), o4 = e3.readInt32(), d2 = e3.readF32(), c2 = e3.readF32(), u2 = e3.readF32(), f2 = e3.readF32(), m2 = e3.readF32(), F = e3.readF32(), w = e3.readF32(), I = e3.readF32(), p2 = e3.readF32(), S = n(e3, i2) ?? [];
    return new _h(t5, r3, a3, n3, d2, c2, u2, f2, m2, F, { size: w, offsetX: I, offsetY: p2 }, S, l3, o4);
  }
};

// node_modules/@arcgis/core/views/webgl/getDataTypeBytes.js
function s4(s6) {
  switch (s6) {
    case R.BYTE:
    case R.UNSIGNED_BYTE:
      return 1;
    case R.SHORT:
    case R.UNSIGNED_SHORT:
    case R.HALF_FLOAT:
      return 2;
    case R.FLOAT:
    case R.INT:
    case R.UNSIGNED_INT:
      return 4;
  }
}

// node_modules/@arcgis/core/views/2d/engine/webgl/Utils.js
var s5 = () => i.getLogger("esri.views.2d.engine.webgl.Utils");
function o3(t5) {
  switch (t5) {
    case N.UNSIGNED_BYTE:
      return 1;
    case N.UNSIGNED_SHORT_4_4_4_4:
      return 2;
    case N.FLOAT:
      return 4;
    default:
      return void s5().error(new s("webgl-utils", `Unable to handle type ${t5}`));
  }
}
function i3(t5) {
  switch (t5) {
    case N.UNSIGNED_BYTE:
      return Uint8Array;
    case N.UNSIGNED_SHORT_4_4_4_4:
      return Uint16Array;
    case N.FLOAT:
      return Float32Array;
    default:
      return void s5().error(new s("webgl-utils", `Unable to handle type ${t5}`));
  }
}
function c(e3) {
  let t5 = 0;
  const r3 = e3.map((e4) => {
    const r4 = new t(e4.name, e4.count, e4.type, t5, 0, e4.normalized || false);
    return t5 += e4.count * s4(e4.type), r4;
  });
  return r3.forEach((e4) => e4.stride = t5), r3;
}
var l2 = (e3) => {
  const t5 = /* @__PURE__ */ new Map();
  for (const r3 of e3) t5.set(r3.name, r3.location);
  return t5;
};
var m = /* @__PURE__ */ new Map();
var $ = (e3, t5) => {
  if (!m.has(e3)) {
    const r3 = { bufferLayout: c(t5), attributes: l2(t5) };
    m.set(e3, r3);
  }
  return m.get(e3);
};
var f = (e3) => e3.includes("data:image/svg+xml");
function d(e3) {
  const t5 = [];
  for (let r3 = 0; r3 < e3.length; r3++) t5.push(e3.charCodeAt(r3));
  return t5;
}
function p(e3) {
  if (null == e3) return "";
  const { type: t5 } = e3;
  switch (t5) {
    case "CIMMarkerPlacementAlongLineRandomSize":
      return `${t5}-${e3.seed}-${e3.randomization}`;
    case "CIMMarkerPlacementAlongLineVariableSize":
      return `${t5}-${e3.maxRandomOffset}-${e3.numberOfSizes}-${e3.seed}-${e3.variationMethod}`;
    case "CIMMarkerPlacementAtExtremities":
      return `${t5}-${e3.extremityPlacement}-${e3.offsetAlongLine}`;
    case "CIMMarkerPlacementAtRatioPositions":
      return `${t5}-${e3.beginPosition}-${e3.endPosition}-${e3.flipFirst}-${JSON.stringify(e3.positionArray)}`;
    case "CIMMarkerPlacementAtMeasuredUnits":
      return `${t5}-${e3.interval}-${e3.skipMarkerRate}-${e3.placeAtExtremities}`;
    case "CIMMarkerPlacementInsidePolygon":
      return `${t5}-${e3.stepX}-${e3.stepY}-${e3.randomness}-${e3.gridType}-${e3.seed}-${e3.shiftOddRows}`;
    case "CIMMarkerPlacementOnLine":
      return `${t5}-${e3.relativeTo}-${e3.startPointOffset}`;
    case "CIMMarkerPlacementOnVertices":
      return `${t5}-${e3.placeOnControlPoints}-${e3.placeOnEndPoints}-${e3.placeOnRegularVertices}`;
    case "CIMMarkerPlacementPolygonCenter":
      return `${t5}-${e3.method}`;
    default:
      return `${t5}`;
  }
}

export {
  t2 as t,
  n,
  e2 as e,
  a,
  h,
  s2 as s,
  t4 as t2,
  r,
  a2,
  o2 as o,
  s3 as s2,
  h2,
  o3 as o2,
  i3 as i,
  $,
  f,
  d,
  p
};
//# sourceMappingURL=chunk-JPZOLUPV.js.map
