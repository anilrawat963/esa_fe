import {
  n as n4
} from "./chunk-G7FTSXBC.js";
import {
  S as S2
} from "./chunk-2QMXQ3D5.js";
import {
  n as n2
} from "./chunk-4KVWUPLK.js";
import {
  c
} from "./chunk-NOLINR6O.js";
import {
  i as i3
} from "./chunk-HIGI45S6.js";
import {
  c as c2
} from "./chunk-2KBTJPSU.js";
import {
  i as i4
} from "./chunk-5D65KWSM.js";
import {
  n as n3
} from "./chunk-ABHLEPDK.js";
import {
  A as A2,
  c as c3
} from "./chunk-EVZ7KLPS.js";
import {
  d
} from "./chunk-UVDECGZC.js";
import {
  o as o2,
  s as s6
} from "./chunk-VKFTCFFM.js";
import {
  c as c4,
  l as l5,
  u as u3
} from "./chunk-CZOYDK6P.js";
import {
  m as m4,
  u as u2
} from "./chunk-RS755KXS.js";
import {
  oe,
  p as p2
} from "./chunk-KY5OS6CK.js";
import {
  l as l2
} from "./chunk-NP2TBOXH.js";
import {
  a as a3
} from "./chunk-H34D76ZQ.js";
import {
  Z
} from "./chunk-2HGIYEIL.js";
import {
  r as r3
} from "./chunk-7HTU7ZUX.js";
import {
  b
} from "./chunk-647DAMHU.js";
import {
  R,
  i as i2
} from "./chunk-EFV6H5NA.js";
import {
  f as f2
} from "./chunk-PLNHHGHL.js";
import {
  m as m3
} from "./chunk-QZQPB5XR.js";
import {
  q
} from "./chunk-JNJX34GB.js";
import {
  S
} from "./chunk-23NJHA5Q.js";
import {
  y
} from "./chunk-PMGS7UDU.js";
import {
  y2
} from "./chunk-MC6NAKKX.js";
import {
  l as l3
} from "./chunk-TF6255HN.js";
import {
  l as l4
} from "./chunk-XXBJY7RN.js";
import {
  s as s5
} from "./chunk-ONXWBTTM.js";
import {
  O
} from "./chunk-YDTPM7OQ.js";
import {
  u
} from "./chunk-XCKT47LJ.js";
import {
  z
} from "./chunk-H74Q4SYB.js";
import {
  U,
  l
} from "./chunk-2OFHDVO5.js";
import {
  f
} from "./chunk-5T3MJDSR.js";
import {
  A,
  H2 as H,
  V,
  p2 as p
} from "./chunk-V2H77UEV.js";
import {
  s as s4
} from "./chunk-WRA2WBYC.js";
import {
  o
} from "./chunk-XWE6BM2U.js";
import {
  r as r2
} from "./chunk-SOIZOFSB.js";
import {
  m as m2,
  r3 as r,
  t3 as t
} from "./chunk-5EI5H4QX.js";
import {
  a2,
  m,
  s,
  w,
  x
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  n
} from "./chunk-6SSZNBOK.js";
import {
  e
} from "./chunk-4DGC7CBY.js";
import {
  s as s3
} from "./chunk-GNMPGHLQ.js";
import {
  a,
  i3 as i,
  s2
} from "./chunk-QY7XKUIV.js";
import {
  has
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/layers/mixins/ArcGISMapService.js
var h = (h3) => {
  const f4 = h3;
  let b2 = class extends f4 {
    constructor() {
      super(...arguments), this.capabilities = void 0, this.copyright = null, this.fullExtent = null, this.legendEnabled = true, this.spatialReference = null, this.version = void 0, this._allLayersAndTablesMap = null;
    }
    readCapabilities(e4, r4) {
      const t2 = r4.capabilities && r4.capabilities.split(",").map((e5) => e5.toLowerCase().trim());
      if (!t2) return { operations: { supportsExportMap: false, supportsExportTiles: false, supportsIdentify: false, supportsQuery: false, supportsTileMap: false }, exportMap: null, exportTiles: null };
      const s9 = this.type, o3 = "tile" !== s9 && !!r4.supportsDynamicLayers, a4 = t2.includes("query"), p4 = t2.includes("map"), l6 = !!r4.exportTilesAllowed, n5 = t2.includes("tilemap"), c5 = t2.includes("data"), u4 = "tile" !== s9 && (!r4.tileInfo || o3), y3 = "tile" !== s9 && (!r4.tileInfo || o3), d2 = "tile" !== s9, m6 = "tile" !== s9 && o3 && r4.currentVersion >= 11.1, h4 = r4.cimVersion ? r3.parse(r4.cimVersion) : null, f5 = h4?.greaterEqual(1, 4) ?? false, b3 = h4?.greaterEqual(2, 0) ?? false;
      return { operations: { supportsExportMap: p4, supportsExportTiles: l6, supportsIdentify: a4, supportsQuery: c5, supportsTileMap: n5 }, exportMap: p4 ? { supportsArcadeExpressionForLabeling: f5, supportsCIMSymbols: b3, supportsDynamicLayers: o3, supportsSublayerOrderBy: m6, supportsSublayerDefinitionExpression: y3, supportsSublayerVisibility: u4, supportsSublayersChanges: d2 } : null, exportTiles: l6 ? { maxExportTilesCount: +r4.maxExportTilesCount } : null };
    }
    readVersion(e4, r4) {
      let t2 = r4.currentVersion;
      return t2 || (t2 = r4.hasOwnProperty("capabilities") || r4.hasOwnProperty("tables") ? 10 : r4.hasOwnProperty("supportedImageFormatTypes") ? 9.31 : 9.3), t2;
    }
    async fetchRelatedService(e4) {
      const r4 = this.portalItem;
      if (!r4 || !a3(r4)) return null;
      this._relatedFeatureServicePromise || (this._relatedFeatureServicePromise = r4.fetchRelatedItems({ relationshipType: "Service2Service", direction: "reverse" }, e4).then((e5) => e5.find((e6) => "Feature Service" === e6.type) ?? null, () => null));
      const t2 = await this._relatedFeatureServicePromise;
      return s3(e4), t2 ? { itemId: t2.id, url: t2.url } : null;
    }
    async fetchSublayerInfo(e4, t2) {
      const { source: s9 } = e4;
      if (this?.portalItem && "tile" === this.type && "map-layer" === s9?.type && a3(this.portalItem) && e4.originIdOf("url") < 2) {
        const r4 = await this.fetchRelatedService(t2);
        r4 && (e4.url = V(r4.url, s9.mapLayerId.toString()), e4.layerItemId = r4.itemId);
      }
      const { url: i7 } = e4;
      let a4;
      if ("data-layer" === s9.type) {
        a4 = (await H(i7, { responseType: "json", query: { f: "json", ...this.customParameters, token: this.apiKey }, ...t2 })).data;
      } else if (i7 && e4.originIdOf("url") > 2) try {
        const e5 = await this._fetchAllLayersAndTablesFromService(i7), r4 = p(i7)?.sublayer ?? s9.mapLayerId;
        a4 = e5.get(r4);
      } catch {
      }
      else {
        let r4 = e4.id;
        "map-layer" === s9?.type && (r4 = s9.mapLayerId);
        try {
          a4 = (await this.fetchAllLayersAndTables(t2)).get(r4);
        } catch {
        }
      }
      return a4;
    }
    async fetchAllLayersAndTables(e4) {
      return this._fetchAllLayersAndTablesFromService(this.parsedUrl?.path, e4);
    }
    async _fetchAllLayersAndTablesFromService(e4, i7) {
      await this.load(i7), this._allLayersAndTablesMap ||= /* @__PURE__ */ new Map();
      const a4 = p(e4), p4 = e(this._allLayersAndTablesMap, a4?.url.path, () => H(V(a4?.url.path, "/layers"), { responseType: "json", query: { f: "json", ...this.customParameters, token: this.apiKey } }).then((e5) => {
        const r4 = /* @__PURE__ */ new Map(), { layers: t2, tables: s9 } = e5.data, o3 = [...t2 ?? [], ...s9 ?? []];
        for (const i8 of o3) r4.set(i8.id, i8);
        return { result: r4 };
      }, (e5) => ({ error: e5 }))), l6 = await p4;
      if (s3(i7), "result" in l6) return l6.result;
      throw l6.error;
    }
  };
  return __decorate([m2({ readOnly: true })], b2.prototype, "capabilities", void 0), __decorate([o("service", "capabilities", ["capabilities", "cimVersion", "currentVersion", "exportTilesAllowed", "maxExportTilesCount", "supportsDynamicLayers", "tileInfo"])], b2.prototype, "readCapabilities", null), __decorate([m2({ json: { read: { source: "copyrightText" } } })], b2.prototype, "copyright", void 0), __decorate([m2({ type: z })], b2.prototype, "fullExtent", void 0), __decorate([m2(u3)], b2.prototype, "id", void 0), __decorate([m2({ type: Boolean, json: { origins: { service: { read: { enabled: false } } }, read: { source: "showLegend" }, write: { target: "showLegend" } } })], b2.prototype, "legendEnabled", void 0), __decorate([m2(l5)], b2.prototype, "popupEnabled", void 0), __decorate([m2({ type: f })], b2.prototype, "spatialReference", void 0), __decorate([m2({ readOnly: true })], b2.prototype, "version", void 0), __decorate([o("service", "version", ["currentVersion", "capabilities", "tables", "supportedImageFormatTypes"])], b2.prototype, "readVersion", null), b2 = __decorate([a2("esri.layers.mixins.ArcGISMapService")], b2), b2;
};

// node_modules/@arcgis/core/graphic/isMapImageGraphicOrigin.js
var i5 = Symbol("isMapImageGraphicOriginSymbol");

// node_modules/@arcgis/core/graphic/MapImageGraphicOrigin.js
var e2;
var s7 = class extends s6 {
  get [(e2 = i5, o2)]() {
    return this.layer;
  }
  constructor(r4, i7) {
    super(), this[e2] = true, this.type = "map-image", this.layer = r4, this.sublayer = i7;
  }
  get id() {
    return `${this.layer.id}:__${this.sublayer.id}__`;
  }
};

// node_modules/@arcgis/core/graphic/isTileGraphicOrigin.js
var i6 = Symbol("isTileGraphicOriginSymbol");

// node_modules/@arcgis/core/graphic/TileGraphicOrigin.js
var e3;
var s8 = class extends s6 {
  get [(e3 = i6, o2)]() {
    return this.layer;
  }
  constructor(r4, i7) {
    super(), this[e3] = true, this.type = "tile", this.layer = r4, this.sublayer = i7;
  }
  get id() {
    return `${this.layer.id}:__${this.sublayer.id}__`;
  }
};

// node_modules/@arcgis/core/layers/support/Sublayer.js
var X;
function Y(e4) {
  return "esriSMS" === e4?.type;
}
function Z2(e4, r4, t2) {
  const i7 = t2.minimumWritableOrigin || t2.origin;
  return !!i7 && e4.originIdOf(r4) >= r(i7);
}
function ee(e4, r4, t2) {
  const i7 = Z2(this, r4, t2);
  return { ignoreOrigin: true, allowNull: i7, enabled: !!t2 && ("map-image" === t2.layer?.type && (t2.writeSublayerStructure || i7)) };
}
function re(e4, r4, t2) {
  return { enabled: !!t2 && ("tile" === t2.layer?.type && (Z2(this, r4, t2) || this._isOverridden(r4))) };
}
function te(e4, r4, t2) {
  return { ignoreOrigin: true, enabled: t2 && t2.writeSublayerStructure || false };
}
function ie(e4, r4, t2) {
  return { ignoreOrigin: true, enabled: !!t2?.writeSublayerStructure && this.originIdOf(r4) > 2 };
}
function oe2(e4, r4, t2) {
  return { ignoreOrigin: true, enabled: !!t2 && (t2.writeSublayerStructure || Z2(this, r4, t2)) };
}
var se = 0;
var ae = /* @__PURE__ */ new Set(["layer", "parent", "loaded", "loadStatus", "loadError", "loadWarnings"]);
var _a;
var le = (_a = class extends l2(s5(u)) {
  constructor(e4) {
    super(e4), this.attributeTableTemplate = null, this.capabilities = void 0, this.maxScaleRange = { minScale: 0, maxScale: 0 }, this.fields = null, this.fullExtent = null, this.geometryType = null, this.globalIdField = null, this.isTable = false, this.legendEnabled = true, this.objectIdField = null, this.parent = null, this.popupEnabled = true, this.popupTemplate = null, this.relationships = null, this.sourceJSON = null, this.spatialReference = null, this.title = null, this.typeIdField = null, this.type = "sublayer", this.types = null, this._lastParsedUrl = null;
  }
  async load(e4) {
    return this.addResolvingPromise(this.reload(e4)), this;
  }
  readCapabilities(e4, r4) {
    r4 = r4.layerDefinition || r4;
    const { attachment: t2, operations: { supportsQuery: i7, supportsQueryAttachments: o3 }, query: { supportsFormatPBF: s9, supportsOrderBy: a4, supportsPagination: l6 }, data: { supportsAttachment: n5 }, queryRelated: p4 } = c(r4, this.url);
    return { attachment: { supportsOrderByFields: t2?.supportsOrderByFields ?? false, supportsResize: t2?.supportsResize ?? false, supportsTypeWildcard: t2?.supportsTypeWildcard ?? false }, exportMap: { supportsModification: !!r4.canModifyLayer }, operations: { supportsQuery: i7, supportsQueryAttachments: o3 }, data: { supportsAttachment: n5 }, query: { supportsFormatPBF: s9, supportsOrderBy: a4, supportsPagination: l6 }, queryRelated: p4 };
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  set definitionExpression(e4) {
    this._setAndNotifyLayer("definitionExpression", e4);
  }
  get effectiveScaleRange() {
    const { minScale: e4, maxScale: r4 } = this;
    return { minScale: e4, maxScale: r4 };
  }
  readMaxScaleRange(e4, r4) {
    return { minScale: (r4 = r4.layerDefinition || r4).minScale ?? 0, maxScale: r4.maxScale ?? 0 };
  }
  get fieldsIndex() {
    return new Z(this.fields || []);
  }
  set floorInfo(e4) {
    this._setAndNotifyLayer("floorInfo", e4);
  }
  readGlobalIdFieldFromService(e4, r4) {
    if ((r4 = r4.layerDefinition || r4).globalIdField) return r4.globalIdField;
    if (r4.fields) {
      for (const t2 of r4.fields) if ("esriFieldTypeGlobalID" === t2.type) return t2.name;
    }
  }
  get graphicOrigin() {
    if (!this.layer) return null;
    switch (this.layer.type) {
      case "tile":
        return new s8(this.layer, this);
      case "map-image":
        return new s7(this.layer, this);
    }
  }
  get id() {
    const e4 = this._get("id");
    return e4 ?? se++;
  }
  set id(e4) {
    this._get("id") !== e4 && (false !== this.layer?.capabilities?.exportMap?.supportsDynamicLayers ? this._set("id", e4) : this._logLockedError("id", "capability not available 'layer.capabilities.exportMap.supportsDynamicLayers'"));
  }
  readIsTable(e4, r4) {
    return "Table" === r4.type;
  }
  set labelingInfo(e4) {
    this._setAndNotifyLayer("labelingInfo", e4);
  }
  writeLabelingInfo(e4, r4, t2, i7) {
    e4 && e4.length && (r4.layerDefinition = { drawingInfo: { labelingInfo: e4.map((e5) => e5.write({}, i7)) } });
  }
  set labelsVisible(e4) {
    this._setAndNotifyLayer("labelsVisible", e4);
  }
  set layer(e4) {
    this._set("layer", e4), this.sublayers?.forEach((r4) => r4.layer = e4);
  }
  set listMode(e4) {
    this._set("listMode", e4);
  }
  set minScale(e4) {
    this._setAndNotifyLayer("minScale", e4);
  }
  readMinScale(e4, r4) {
    return r4.minScale || r4.layerDefinition?.minScale || 0;
  }
  set maxScale(e4) {
    this._setAndNotifyLayer("maxScale", e4);
  }
  readMaxScale(e4, r4) {
    return r4.maxScale || r4.layerDefinition?.maxScale || 0;
  }
  readObjectIdFieldFromService(e4, r4) {
    if ((r4 = r4.layerDefinition || r4).objectIdField) return r4.objectIdField;
    const t2 = r4.fields?.find((e5) => "esriFieldTypeOID" === e5.type);
    return t2?.name;
  }
  set opacity(e4) {
    this._setAndNotifyLayer("opacity", e4);
  }
  readOpacity(e4, r4) {
    const { layerDefinition: t2 } = r4;
    return 1 - 0.01 * (t2?.transparency ?? t2?.drawingInfo?.transparency ?? 0);
  }
  writeOpacity(e4, r4, t2, i7) {
    r4.layerDefinition = { drawingInfo: { transparency: 100 - 100 * e4 } };
  }
  set orderBy(e4) {
    this._setAndNotifyLayer("orderBy", e4);
  }
  writeParent(e4, r4) {
    this.parent && this.parent !== this.layer ? r4.parentLayerId = s(this.parent.id) : r4.parentLayerId = -1;
  }
  get queryTask() {
    if (!this.layer) return null;
    const { capabilities: e4, fieldsIndex: r4, layer: t2, url: i7 } = this, { spatialReference: o3 } = t2, s9 = "gdbVersion" in t2 ? t2.gdbVersion : void 0, a4 = has("featurelayer-pbf") && e4?.query.supportsFormatPBF;
    return new S2({ fieldsIndex: r4, gdbVersion: s9, pbfSupported: a4, queryAttachmentsSupported: e4?.operations?.supportsQueryAttachments ?? false, sourceSpatialReference: o3, url: i7 });
  }
  set renderer(e4) {
    if (y2(e4, this.fieldsIndex), e4) {
      for (const r4 of e4.symbols) if (S(r4)) {
        i.getLogger(this).warn("Sublayer renderer should use 2D symbols");
        break;
      }
    }
    this._setAndNotifyLayer("renderer", e4);
  }
  get source() {
    return this._get("source") || new i2({ mapLayerId: this.id });
  }
  set source(e4) {
    this._setAndNotifyLayer("source", e4);
  }
  set sublayers(e4) {
    this._handleSublayersChange(e4, this._get("sublayers")), this._set("sublayers", e4);
  }
  castSublayers(e4) {
    return w(O.ofType(X), e4);
  }
  writeSublayers(e4, r4, t2) {
    this.sublayers?.length && (r4[t2] = this.sublayers.map((e5) => e5.id).toArray().reverse());
  }
  readTitle(e4, r4) {
    return r4.layerDefinition?.name ?? r4.name;
  }
  readTypeIdField(e4, r4) {
    let t2 = (r4 = r4.layerDefinition || r4).typeIdField;
    if (t2 && r4.fields) {
      t2 = t2.toLowerCase();
      const e5 = r4.fields.find((e6) => e6.name.toLowerCase() === t2);
      e5 && (t2 = e5.name);
    }
    return t2;
  }
  get url() {
    const e4 = this.layer?.parsedUrl ?? this._lastParsedUrl, r4 = this.source;
    if (!e4) return null;
    if (this._lastParsedUrl = e4, "map-layer" === r4?.type) return `${e4.path}/${r4.mapLayerId}`;
    const t2 = { layer: JSON.stringify({ source: this.source }) };
    return `${e4.path}/dynamicLayer?${A(t2)}`;
  }
  set url(e4) {
    this._overrideIfSome("url", e4);
  }
  set visible(e4) {
    this._setAndNotifyLayer("visible", e4);
  }
  writeVisible(e4, r4, t2, i7) {
    r4[t2] = this.getAtOrigin("defaultVisibility", "service") || e4;
  }
  clone() {
    const { store: e4 } = n(this), r4 = new X();
    return n(r4).store = e4.clone(ae), this.commitProperty("url"), r4._lastParsedUrl = this._lastParsedUrl, r4;
  }
  createPopupTemplate(e4) {
    return d(this, e4);
  }
  createQuery() {
    return new b({ returnGeometry: true, where: this.definitionExpression || "1=1" });
  }
  async createFeatureLayer() {
    if (this.hasOwnProperty("sublayers")) return null;
    const e4 = (await import("./FeatureLayer-67ZFNT6Z.js")).default, { layer: r4, url: t2 } = this;
    let i7;
    if (t2 && this.originIdOf("url") > 2) i7 = new e4({ url: t2 });
    else {
      if (!r4?.parsedUrl) throw new s2("createFeatureLayer:missing-information", "Cannot create a FeatureLayer without a url or a parent layer");
      {
        const t3 = r4.parsedUrl;
        i7 = new e4({ url: t3.path }), t3 && this.source && ("map-layer" === this.source.type ? i7.layerId = this.source.mapLayerId : i7.dynamicDataSource = this.source);
      }
    }
    return null != r4?.refreshInterval && (i7.refreshInterval = r4.refreshInterval), this.definitionExpression && (i7.definitionExpression = this.definitionExpression), this.floorInfo && (i7.floorInfo = a(this.floorInfo)), this.originIdOf("labelingInfo") > 2 && (i7.labelingInfo = a(this.labelingInfo)), this.originIdOf("labelsVisible") > 0 && (i7.labelsVisible = this.labelsVisible), this.originIdOf("legendEnabled") > 0 && (i7.legendEnabled = this.legendEnabled), this.originIdOf("visible") > 0 && (i7.visible = this.visible), this.originIdOf("minScale") > 0 && (i7.minScale = this.minScale), this.originIdOf("maxScale") > 0 && (i7.maxScale = this.maxScale), this.originIdOf("opacity") > 0 && (i7.opacity = this.opacity), this.originIdOf("popupTemplate") > 0 && (i7.popupTemplate = a(this.popupTemplate)), this.originIdOf("renderer") > 2 && (i7.renderer = a(this.renderer)), "data-layer" === this.source?.type && (i7.dynamicDataSource = this.source.clone()), this.originIdOf("title") > 0 && (i7.title = this.title), "map-image" === r4?.type && r4.originIdOf("customParameters") > 0 && (i7.customParameters = r4.customParameters), "tile" === r4?.type && r4.originIdOf("customParameters") > 0 && (i7.customParameters = r4.customParameters), i7;
  }
  getField(e4) {
    return this.fieldsIndex.get(e4);
  }
  getFeatureType(e4) {
    return oe(this.types, this.typeIdField, e4);
  }
  getFieldDomain(e4, r4) {
    const t2 = r4?.feature, i7 = this.getFeatureType(t2);
    if (i7) {
      const r5 = i7.domains && i7.domains[e4];
      if (r5 && "inherited" !== r5.type) return r5;
    }
    return this._getLayerDomain(e4);
  }
  async queryAttachments(e4, r4) {
    await this.load(), e4 = p2.from(e4);
    const t2 = this.capabilities;
    if (!t2?.data?.supportsAttachment) throw new s2("queryAttachments:not-supported", "this layer doesn't support attachments");
    const { attachmentTypes: i7, objectIds: s9, globalIds: a4, num: l6, size: n5, start: p4, where: u4 } = e4;
    if (!t2?.operations?.supportsQueryAttachments) {
      if (i7?.length > 0 || a4?.length > 0 || n5?.length > 0 || l6 || p4 || u4) throw new s2("queryAttachments:option-not-supported", "when 'capabilities.operations.supportsQueryAttachments' is false, only objectIds is supported", e4);
    }
    if (!(s9?.length || a4?.length || u4)) throw new s2("queryAttachments:invalid-query", "'objectIds', 'globalIds', or 'where' are required to perform attachment query", e4);
    return !t2?.attachment?.supportsOrderByFields && e4.orderByFields?.length && ((e4 = e4.clone()).orderByFields = null), this.queryTask.executeAttachmentQuery(e4, r4);
  }
  async queryFeatureCount(e4 = this.createQuery(), r4) {
    if (await this.load(), !this.capabilities.operations.supportsQuery) throw new s2("queryFeatureCount:not-supported", "this layer doesn't support queries.");
    if (!this.url) throw new s2("queryFeatureCount:not-supported", "this layer has no url.");
    const t2 = this.layer?.apiKey;
    return await this.queryTask.executeForCount(e4, { ...r4, query: { ...this.layer?.customParameters, token: t2 } });
  }
  async queryFeatures(e4 = this.createQuery(), r4) {
    if (await this.load(), !this.capabilities.operations.supportsQuery) throw new s2("queryFeatures:not-supported", "this layer doesn't support queries.");
    if (!this.url) throw new s2("queryFeatures:not-supported", "this layer has no url.");
    const t2 = await this.queryTask.execute(e4, { ...r4, query: { ...this.layer?.customParameters, token: this.layer?.apiKey } });
    if (t2?.features) {
      const e5 = this.graphicOrigin;
      for (const r5 of t2.features) r5.sourceLayer = this, r5.origin = e5;
    }
    return t2;
  }
  async queryObjectIds(e4 = this.createQuery(), r4) {
    if (await this.load(), !this.capabilities.operations.supportsQuery) throw new s2("queryObjectIds:not-supported", "this layer doesn't support queries.");
    if (!this.url) throw new s2("queryObjectIds:not-supported", "this layer has no url.");
    const t2 = this.layer?.apiKey;
    return await this.queryTask.executeForIds(e4, { ...r4, query: { ...this.layer?.customParameters, token: t2 } });
  }
  async queryRelatedFeatures(e4, r4) {
    if (await this.load(), !this.capabilities.operations.supportsQuery) throw new s2("queryRelatedFeatures:not-supported", "this layer doesn't support queries.");
    if (!this.url) throw new s2("queryRelatedFeatures:not-supported", "this layer has no url.");
    const t2 = this.layer?.apiKey;
    return await this.queryTask.executeRelationshipQuery(e4, { ...r4, query: { ...this.layer?.customParameters, token: t2 } });
  }
  async queryRelatedFeaturesCount(e4, r4) {
    if (await this.load(), !this.capabilities.operations.supportsQuery) throw new s2("queryRelatedFeaturesCount:not-supported", "this layer doesn't support queries.");
    if (!this.capabilities.queryRelated.supportsCount) throw new s2("queryRelatedFeaturesCount:not-supported", "this layer doesn't support query related counts.");
    if (!this.url) throw new s2("queryRelatedFeaturesCount:not-supported", "this layer has no url.");
    const t2 = this.layer?.apiKey;
    return await this.queryTask.executeRelationshipQueryForCount(e4, { ...r4, query: { ...this.layer?.customParameters, token: t2 } });
  }
  async reload(e4) {
    if ("not-loaded" === this.loadStatus) return this.load(e4).then(() => {
    });
    const { layer: r4, url: i7 } = this;
    if (!r4 && !i7) throw new s2("sublayer:missing-layer", "Sublayer can't be loaded without being part of a layer", { sublayer: this });
    const s9 = r4 ? await r4.fetchSublayerInfo(this, e4) : (await H(i7, { query: { f: "json" }, ...e4 })).data;
    if (this.loaded && this.originIdOf("url") > 2) {
      const e5 = /* @__PURE__ */ new Set(["drawingInfo", "maxScale", "minScale", "name"]);
      if (null != s9) for (const r5 of Object.keys(s9)) e5.has(r5) && delete s9[r5];
    }
    s9 && (this.sourceJSON = { ...this.sourceJSON, ...s9 }, this.read({ layerDefinition: s9 }, { origin: "service", layer: r4, url: f2(i7) }));
  }
  toExportImageJSON(e4) {
    const r4 = { id: this.id, source: this.source?.toJSON() || { mapLayerId: this.id, type: "mapLayer" } }, t2 = l3(e4, this.definitionExpression);
    null != t2 && (r4.definitionExpression = t2);
    const i7 = ["renderer", "labelingInfo", "opacity", "labelsVisible"].reduce((e5, r5) => (e5[r5] = this.originIdOf(r5), e5), {}), o3 = Object.keys(i7).some((e5) => i7[e5] > 2);
    if (o3) {
      const e5 = r4.drawingInfo = {};
      if (i7.renderer > 2 && (e5.renderer = this.renderer ? this.renderer.toJSON() : null), i7.labelsVisible > 2 && (e5.showLabels = this.labelsVisible), this.labelsVisible && i7.labelingInfo > 2) if (this.labelingInfo) {
        !this.loaded && this.labelingInfo?.some((e6) => !e6.labelPlacement) && i.getLogger(this).warnOnce(`A Sublayer (title: ${this.title}, id: ${this.id}) has an undefined 'labelPlacement' and so labels cannot be displayed. Either define a valid 'labelPlacement' or call Sublayer.load() to use a default value based on geometry type.`, { sublayer: this });
        let r5 = this.labelingInfo;
        null != this.geometryType && (r5 = c3(this.labelingInfo, y.toJSON(this.geometryType))), e5.showLabels = true, e5.labelingInfo = r5.filter((e6) => e6.labelPlacement).map((e6) => e6.toJSON({ origin: "service", layer: this.layer }));
      } else e5.showLabels = false;
      i7.opacity > 2 && (e5.transparency = 100 - 100 * this.opacity), this._assignDefaultSymbolColors(e5.renderer);
    }
    return (this.layer?.capabilities?.exportMap?.supportsSublayerOrderBy ?? false) && this.originIdOf("orderBy") > 2 && (r4.orderBy = this.orderBy?.map((e5) => e5.toJSON()) ?? null), r4;
  }
  _assignDefaultSymbolColors(e4) {
    this._forEachSimpleMarkerSymbols(e4, (e5) => {
      e5.color || "esriSMSX" !== e5.style && "esriSMSCross" !== e5.style || (e5.outline?.color ? e5.color = e5.outline.color : e5.color = [0, 0, 0, 0]);
    });
  }
  _forEachSimpleMarkerSymbols(e4, r4) {
    if (e4) {
      const t2 = ("uniqueValueInfos" in e4 ? e4.uniqueValueInfos : "classBreakInfos" in e4 ? e4.classBreakInfos : null) ?? [];
      for (const e5 of t2) Y(e5.symbol) && r4(e5.symbol);
      "symbol" in e4 && Y(e4.symbol) && r4(e4.symbol), "defaultSymbol" in e4 && Y(e4.defaultSymbol) && r4(e4.defaultSymbol);
    }
  }
  _setAndNotifyLayer(e4, r4) {
    const t2 = this.layer, i7 = this._get(e4);
    let o3, s9;
    switch (e4) {
      case "definitionExpression":
      case "floorInfo":
        o3 = "supportsSublayerDefinitionExpression";
        break;
      case "minScale":
      case "maxScale":
      case "visible":
        o3 = "supportsSublayerVisibility";
        break;
      case "labelingInfo":
      case "labelsVisible":
      case "opacity":
      case "renderer":
      case "source":
        o3 = "supportsDynamicLayers", s9 = "supportsModification";
        break;
      case "orderBy":
        o3 = "supportsSublayerOrderBy", s9 = "supportsModification";
    }
    const a4 = n(this).getDefaultOrigin();
    if ("service" !== a4) {
      if (o3 && false === this.layer?.capabilities?.exportMap?.[o3]) return void this._logLockedError(e4, `capability not available 'layer.capabilities.exportMap.${o3}'`);
      if (s9 && false === this.capabilities?.exportMap[s9]) return void this._logLockedError(e4, `capability not available 'capabilities.exportMap.${s9}'`);
    }
    "source" !== e4 || "not-loaded" === this.loadStatus ? (this._set(e4, r4), "service" !== a4 && i7 !== r4 && t2?.emit && t2.emit("sublayer-update", { propertyName: e4, target: this })) : this._logLockedError(e4, "'source' can't be changed after calling sublayer.load()");
  }
  _handleSublayersChange(e4, r4) {
    r4 && (r4.forEach((e5) => {
      e5.parent = null, e5.layer = null;
    }), this.removeAllHandles()), e4 && (e4.forEach((e5) => {
      e5.parent = this, e5.layer = this.layer;
    }), this.addHandles([e4.on("after-add", ({ item: e5 }) => {
      e5.parent = this, e5.layer = this.layer;
    }), e4.on("after-remove", ({ item: e5 }) => {
      e5.parent = null, e5.layer = null;
    }), e4.on("before-changes", (e5) => {
      (this.layer?.capabilities?.exportMap?.supportsSublayersChanges ?? 1) || (i.getLogger(this).error(new s2("sublayer:sublayers-non-modifiable", "Sublayer can't be added, moved, or removed from the layer's sublayers", { sublayer: this, layer: this.layer })), e5.preventDefault());
    })]));
  }
  _logLockedError(e4, r4) {
    const { layer: t2, declaredClass: i7 } = this;
    i.getLogger(i7).error(new s2("sublayer:locked", `Property '${String(e4)}' can't be changed on Sublayer from the layer '${t2?.id}'`, { reason: r4, sublayer: this, layer: t2 }));
  }
  _getLayerDomain(e4) {
    return this.fieldsIndex.get(e4)?.domain ?? null;
  }
}, X = _a, _a.test = { isMapImageLayerOverridePolicy: (e4) => e4 === ie || e4 === te || e4 === ee, isTileImageLayerOverridePolicy: (e4) => e4 === re }, _a);
__decorate([m2({ type: c4, json: { name: "attributeTableInfo", write: { overridePolicy: ee }, origins: { "web-scene": { write: false } } } })], le.prototype, "attributeTableTemplate", void 0), __decorate([m2({ readOnly: true })], le.prototype, "capabilities", void 0), __decorate([o("service", "capabilities", ["layerDefinition.canModifyLayer", "layerDefinition.capabilities"])], le.prototype, "readCapabilities", null), __decorate([m2()], le.prototype, "defaultPopupTemplate", null), __decorate([m2({ type: String, value: null, json: { name: "layerDefinition.definitionExpression", write: { allowNull: true, overridePolicy: ee } } })], le.prototype, "definitionExpression", null), __decorate([m2({ readOnly: true })], le.prototype, "effectiveScaleRange", null), __decorate([o("service", "maxScaleRange", ["minScale", "maxScale"])], le.prototype, "readMaxScaleRange", null), __decorate([m2({ type: [m3], json: { origins: { service: { read: { source: "layerDefinition.fields" } } } } })], le.prototype, "fields", void 0), __decorate([m2({ readOnly: true })], le.prototype, "fieldsIndex", null), __decorate([m2({ type: i3, value: null, json: { name: "layerDefinition.floorInfo", read: { source: "layerDefinition.floorInfo" }, write: { target: "layerDefinition.floorInfo", overridePolicy: ee }, origins: { "web-scene": { read: false, write: false } } } })], le.prototype, "floorInfo", null), __decorate([m2({ type: z, json: { read: { source: "layerDefinition.extent" } } })], le.prototype, "fullExtent", void 0), __decorate([m2({ type: y.apiValues, json: { origins: { service: { name: "layerDefinition.geometryType", read: { reader: y.read } } } } })], le.prototype, "geometryType", void 0), __decorate([m2({ type: String })], le.prototype, "globalIdField", void 0), __decorate([o("service", "globalIdField", ["layerDefinition.globalIdField", "layerDefinition.fields"])], le.prototype, "readGlobalIdFieldFromService", null), __decorate([m2({ readOnly: true })], le.prototype, "graphicOrigin", null), __decorate([m2({ type: x, json: { write: { ignoreOrigin: true } } })], le.prototype, "id", null), __decorate([m2({ readOnly: true })], le.prototype, "isTable", void 0), __decorate([o("service", "isTable", ["type"])], le.prototype, "readIsTable", null), __decorate([m2({ value: null, type: [A2], json: { read: { source: "layerDefinition.drawingInfo.labelingInfo" }, write: { target: "layerDefinition.drawingInfo.labelingInfo", overridePolicy: ie } } })], le.prototype, "labelingInfo", null), __decorate([r2("labelingInfo")], le.prototype, "writeLabelingInfo", null), __decorate([m2({ type: Boolean, value: true, json: { read: { source: "layerDefinition.drawingInfo.showLabels" }, write: { target: "layerDefinition.drawingInfo.showLabels", overridePolicy: te } } })], le.prototype, "labelsVisible", null), __decorate([m2({ value: null })], le.prototype, "layer", null), __decorate([m2({ type: String, json: { write: { overridePolicy: re } } })], le.prototype, "layerItemId", void 0), __decorate([m2({ type: Boolean, value: true, json: { origins: { service: { read: { enabled: false } } }, read: { source: "showLegend" }, write: { target: "showLegend", overridePolicy: oe2 } } })], le.prototype, "legendEnabled", void 0), __decorate([m2({ type: ["show", "hide", "hide-children"], value: "show", json: { read: false, write: false, origins: { "web-scene": { read: true, write: true } } } })], le.prototype, "listMode", null), __decorate([m2({ type: Number, value: 0, json: { write: { overridePolicy: te } } })], le.prototype, "minScale", null), __decorate([o("minScale", ["minScale", "layerDefinition.minScale"])], le.prototype, "readMinScale", null), __decorate([m2({ type: Number, value: 0, json: { write: { overridePolicy: te } } })], le.prototype, "maxScale", null), __decorate([o("maxScale", ["maxScale", "layerDefinition.maxScale"])], le.prototype, "readMaxScale", null), __decorate([m2()], le.prototype, "objectIdField", void 0), __decorate([o("service", "objectIdField", ["layerDefinition.objectIdField", "layerDefinition.fields"])], le.prototype, "readObjectIdFieldFromService", null), __decorate([m2({ type: Number, value: 1, json: { write: { target: "layerDefinition.drawingInfo.transparency", overridePolicy: te } } })], le.prototype, "opacity", null), __decorate([o("opacity", ["layerDefinition.drawingInfo.transparency", "layerDefinition.transparency"])], le.prototype, "readOpacity", null), __decorate([r2("opacity")], le.prototype, "writeOpacity", null), __decorate([m2({ value: null, type: [n3], json: { name: "layerDefinition.orderBy", read: { reader: i4 }, write: { overridePolicy: ee }, origins: { "web-scene": { read: false, write: false } } } })], le.prototype, "orderBy", null), __decorate([m2({ json: { type: x, write: { target: "parentLayerId", writerEnsuresNonNull: true, overridePolicy: te } } })], le.prototype, "parent", void 0), __decorate([r2("parent")], le.prototype, "writeParent", null), __decorate([m2({ type: Boolean, value: true, json: { read: { source: "disablePopup", reader: (e4, r4) => !r4.disablePopup }, write: { target: "disablePopup", overridePolicy: oe2, writer(e4, r4, t2) {
  r4[t2] = !e4;
} } } })], le.prototype, "popupEnabled", void 0), __decorate([m2({ type: q, json: { read: { source: "popupInfo" }, write: { target: "popupInfo", overridePolicy: oe2 } } })], le.prototype, "popupTemplate", void 0), __decorate([m2({ readOnly: true })], le.prototype, "queryTask", null), __decorate([m2({ type: [n2], readOnly: true, json: { origins: { service: { read: { source: "layerDefinition.relationships" } } } } })], le.prototype, "relationships", void 0), __decorate([m2({ types: m4, value: null, json: { name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy: ie }, origins: { "web-scene": { types: u2, name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy: ie } } } } })], le.prototype, "renderer", null), __decorate([m2({ types: { key: "type", base: null, typeMap: { "data-layer": R, "map-layer": i2 } }, cast(e4) {
  if (e4) {
    if ("mapLayerId" in e4) return m(i2, e4);
    if ("dataSource" in e4) return m(R, e4);
  }
  return e4;
}, json: { name: "layerDefinition.source", write: { overridePolicy: te } } })], le.prototype, "source", null), __decorate([m2()], le.prototype, "sourceJSON", void 0), __decorate([m2({ type: f, json: { origins: { service: { read: { source: "layerDefinition.extent.spatialReference" } } } } })], le.prototype, "spatialReference", void 0), __decorate([m2({ value: null, json: { type: [x], write: { target: "subLayerIds", allowNull: true, overridePolicy: te } } })], le.prototype, "sublayers", null), __decorate([s4("sublayers")], le.prototype, "castSublayers", null), __decorate([r2("sublayers")], le.prototype, "writeSublayers", null), __decorate([m2({ type: String, json: { name: "name", write: { overridePolicy: oe2 } } })], le.prototype, "title", void 0), __decorate([o("service", "title", ["name", "layerDefinition.name"])], le.prototype, "readTitle", null), __decorate([m2({ type: String })], le.prototype, "typeIdField", void 0), __decorate([m2({ json: { read: false }, readOnly: true, value: "sublayer" })], le.prototype, "type", void 0), __decorate([o("typeIdField", ["layerDefinition.typeIdField"])], le.prototype, "readTypeIdField", null), __decorate([m2({ type: [c2], json: { origins: { service: { read: { source: "layerDefinition.types" } } } } })], le.prototype, "types", void 0), __decorate([m2({ type: String, json: { name: "layerUrl", write: { overridePolicy: re } } })], le.prototype, "url", null), __decorate([m2({ type: Boolean, value: true, json: { read: { source: "defaultVisibility" }, write: { target: "defaultVisibility", overridePolicy: te } } })], le.prototype, "visible", null), __decorate([r2("visible")], le.prototype, "writeVisible", null), le = X = __decorate([a2("esri.layers.support.Sublayer")], le);

// node_modules/@arcgis/core/layers/mixins/SublayersOwner.js
function p3(e4, r4) {
  const s9 = [], t2 = {};
  return e4 ? (e4.forEach((e5) => {
    const o3 = new le();
    if (o3.read(e5, r4), t2[o3.id] = o3, null != e5.parentLayerId && -1 !== e5.parentLayerId) {
      const r5 = t2[e5.parentLayerId];
      r5.sublayers || (r5.sublayers = []), r5.sublayers.unshift(o3);
    } else s9.unshift(o3);
  }), s9) : s9;
}
var h2 = O.ofType(le);
function f3(e4, r4) {
  e4 && e4.forEach((e5) => {
    r4(e5), e5.sublayers && e5.sublayers.length && f3(e5.sublayers, r4);
  });
}
var m5 = (m6) => {
  const S3 = m6;
  let v = class extends S3 {
    constructor(...e4) {
      super(...e4), this.allSublayers = new l4({ getCollections: () => [this.sublayers], getChildrenFunction: (e5) => e5.sublayers }), this.sublayersSourceJSON = { 2: {}, 3: {}, 4: {}, 5: {}, 6: {} }, this.subtables = null, this.addHandles([l(() => this.sublayers, (e5, r4) => this._handleSublayersChange(e5, r4), U), l(() => this.subtables, (e5, r4) => this._handleSublayersChange(e5, r4), U)]);
    }
    destroy() {
      this.allSublayers.destroy();
    }
    readSublayers(e4, r4) {
      if (!r4 || !e4) return;
      const { sublayersSourceJSON: s9 } = this, t2 = r(r4.origin);
      if (t2 < 2) return;
      if (s9[t2] = { context: r4, visibleLayers: e4.visibleLayers || s9[t2].visibleLayers, layers: e4.layers || s9[t2].layers }, t2 > 2) return;
      this._set("serviceSublayers", this.createSublayersForOrigin("service").sublayers);
      const { sublayers: o3, origin: a4 } = this.createSublayersForOrigin("web-document"), l6 = n(this);
      l6.setDefaultOrigin(a4), this._set("sublayers", new h2(o3)), l6.setDefaultOrigin("user");
    }
    findSublayerById(e4) {
      return this.allSublayers.find((r4) => r4.id === e4);
    }
    createServiceSublayers() {
      return this.createSublayersForOrigin("service").sublayers;
    }
    createSublayersForOrigin(e4) {
      let r4;
      const s9 = r("web-document" === e4 ? "web-map" : e4);
      let t2 = 2, o3 = this.sublayersSourceJSON[2].layers, a4 = this.sublayersSourceJSON[2].context, l6 = null;
      const i7 = [3, 4, 5].filter((e5) => e5 <= s9);
      for (const y3 of i7) {
        const e5 = this.sublayersSourceJSON[y3];
        n4(e5.layers) && (t2 = y3, o3 = e5.layers, a4 = e5.context, e5.visibleLayers && (l6 = { visibleLayers: e5.visibleLayers, context: e5.context }));
      }
      const n5 = [3, 4, 5].filter((e5) => e5 > t2 && e5 <= s9);
      let u4 = null;
      for (const y3 of n5) {
        const { layers: e5, visibleLayers: s10, context: t3 } = this.sublayersSourceJSON[y3];
        e5 && (u4 = { layers: e5, context: t3 }, r4 ??= y3), s10 && (l6 = { visibleLayers: s10, context: t3 });
      }
      const b2 = p3(o3, a4), m7 = /* @__PURE__ */ new Map(), S4 = /* @__PURE__ */ new Set();
      if (u4) for (const y3 of u4.layers) m7.set(y3.id, y3);
      if (l6?.visibleLayers) for (const y3 of l6.visibleLayers) S4.add(y3);
      return f3(b2, (e5) => {
        u4 && e5.read(m7.get(e5.id), u4.context), l6 && e5.read({ defaultVisibility: S4.has(e5.id) }, l6.context);
      }), { origin: t(t2), originWithPartialOverrides: r4 ? t(r4) : null, sublayers: new h2({ items: b2 }) };
    }
    read(e4, r4) {
      super.read(e4, r4), this.readSublayers(e4, r4);
    }
    _handleSublayersChange(e4, r4) {
      r4 && (r4.forEach((e5) => {
        e5.parent = null, e5.layer = null;
      }), this.removeHandles("sublayers-owner")), e4 && (e4.forEach((e5) => {
        e5.parent = this, e5.layer = this;
      }), this.addHandles([e4.on("after-add", ({ item: e5 }) => {
        e5.parent = this, e5.layer = this;
      }), e4.on("after-remove", ({ item: e5 }) => {
        e5.parent = null, e5.layer = null;
      })], "sublayers-owner"), "tile" === this.type && this.addHandles(e4.on("before-changes", (e5) => {
        i.getLogger("esri.layers.TileLayer").error(new s2("tilelayer:sublayers-non-modifiable", "Sublayer can't be added, moved, or removed from the layer's sublayers", { layer: this })), e5.preventDefault();
      }), "sublayers-owner"));
    }
  };
  return __decorate([m2({ readOnly: true })], v.prototype, "allSublayers", void 0), __decorate([m2({ readOnly: true, type: O.ofType(le) })], v.prototype, "serviceSublayers", void 0), __decorate([m2({ value: null, type: h2, json: { read: false, write: { allowNull: true, ignoreOrigin: true } } })], v.prototype, "sublayers", void 0), __decorate([m2({ readOnly: true })], v.prototype, "sublayersSourceJSON", void 0), __decorate([m2({ type: h2, json: { read: { source: "tables" } } })], v.prototype, "subtables", void 0), v = __decorate([a2("esri.layers.mixins.SublayersOwner")], v), v;
};

export {
  h,
  le,
  m5 as m
};
//# sourceMappingURL=chunk-JDUZCRWC.js.map
