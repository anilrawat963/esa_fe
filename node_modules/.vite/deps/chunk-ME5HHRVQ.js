import {
  k
} from "./chunk-2JMKFI2D.js";
import {
  c,
  o as o3
} from "./chunk-QYAMBIRP.js";
import {
  O as O2,
  X as X2,
  x
} from "./chunk-GVMCGYZ6.js";
import {
  e as e5,
  r as r3
} from "./chunk-JHV6OBEB.js";
import {
  f as f3
} from "./chunk-MEDXVTKR.js";
import {
  a as a2
} from "./chunk-5LMH6D7V.js";
import {
  n as n3
} from "./chunk-ZVTEFYZX.js";
import {
  z
} from "./chunk-LPUPM55U.js";
import {
  n as n4
} from "./chunk-WDTGOP77.js";
import {
  N as N2,
  Q,
  R,
  X,
  Z,
  d,
  e as e4,
  f as f2,
  g,
  l,
  m,
  o as o2,
  q,
  r as r2,
  u
} from "./chunk-VYMBX5H5.js";
import {
  e as e3
} from "./chunk-K2OZ6WVC.js";
import {
  C,
  o
} from "./chunk-DTZUXJMD.js";
import {
  N,
  a,
  e,
  n,
  r
} from "./chunk-75XOUSSS.js";
import {
  f,
  p
} from "./chunk-LTPHDYPK.js";
import {
  e as e2,
  n as n2
} from "./chunk-3OVERDFX.js";
import {
  E,
  O
} from "./chunk-NMQNUPE4.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Attribute.js
var s = class {
  constructor(s2, t2, i = t2) {
    this.data = s2, this.size = t2, this.stride = i;
  }
};
var t = class extends s {
  constructor(s2, t2, i, e6 = false, c2 = i) {
    super(s2, i, c2), this.indices = t2, this.exclusive = e6;
  }
};

// node_modules/@arcgis/core/views/3d/support/dito.js
var m2 = 1e-6;
var f4 = n();
var h = n();
function u2(t2, r4) {
  const { data: n5, size: i } = t2, o4 = n5.length / i;
  if (o4 <= 0) return;
  const s2 = new tt(t2);
  it(f4, s2.minProj, s2.maxProj), st(f4, f4, 0.5), ot(h, s2.maxProj, s2.minProj);
  const a3 = nt(h), m3 = new rt();
  m3.quality = a3, o4 < 14 && (t2 = new s(new Float64Array(s2.buffer, 112, 42), 3));
  const u3 = n(), j2 = n(), P2 = n(), b2 = n(), x3 = n(), I3 = n(), N5 = n();
  switch (l2(s2, t2, N5, u3, j2, P2, b2, x3, I3, m3)) {
    case 1:
      return void O3(f4, h, r4);
    case 2:
      return void K(t2, b2, r4);
  }
  w(t2, N5, u3, j2, P2, b2, x3, I3, m3), L(t2, m3.b0, m3.b1, m3.b2, D, H);
  const V3 = n();
  ot(V3, H, D), m3.quality = nt(V3), m3.quality < a3 ? Z2(m3.b0, m3.b1, m3.b2, D, H, V3, r4) : O3(f4, h, r4);
}
function l2(t2, r4, n5, i, o4, s2, e6, a3, c2, f5) {
  if (A(t2, i, o4), ft(i, o4) < m2) return 1;
  ot(e6, i, o4), ct(e6, e6);
  return q2(r4, i, e6, s2) < m2 ? 2 : (ot(a3, o4, s2), ct(a3, a3), ot(c2, s2, i), ct(c2, c2), at(n5, a3, e6), ct(n5, n5), Y(r4, n5, e6, a3, c2, f5), 0);
}
var j = n();
var P = n();
var b = n();
var x2 = n();
var I = n();
var N3 = n();
var V = n();
var y = n();
function w(t2, r4, n5, i, o4, s2, e6, a3, c2) {
  M(t2, r4, n5, j, P), void 0 !== j[0] && (ot(b, j, n5), ct(b, b), ot(x2, j, i), ct(x2, x2), ot(I, j, o4), ct(I, I), at(N3, x2, s2), ct(N3, N3), at(V, I, e6), ct(V, V), at(y, b, a3), ct(y, y), Y(t2, N3, s2, x2, b, c2), Y(t2, V, e6, I, x2, c2), Y(t2, y, a3, b, I, c2)), void 0 !== P[0] && (ot(b, P, n5), ct(b, b), ot(x2, P, i), ct(x2, x2), ot(I, P, o4), ct(I, I), at(N3, x2, s2), ct(N3, N3), at(V, I, e6), ct(V, V), at(y, b, a3), ct(y, y), Y(t2, N3, s2, x2, b, c2), Y(t2, V, e6, I, x2, c2), Y(t2, y, a3, b, I, c2));
}
function A(t2, r4, n5) {
  let i = ft(t2.maxVert[0], t2.minVert[0]), o4 = 0;
  for (let s2 = 1; s2 < 7; ++s2) {
    const r5 = ft(t2.maxVert[s2], t2.minVert[s2]);
    r5 > i && (i = r5, o4 = s2);
  }
  et(r4, t2.minVert[o4]), et(n5, t2.maxVert[o4]);
}
var g2 = [0, 0, 0];
function q2(t2, r4, n5, i) {
  const { data: o4, size: s2 } = t2;
  let e6 = Number.NEGATIVE_INFINITY, a3 = 0;
  for (let c2 = 0; c2 < o4.length; c2 += s2) {
    g2[0] = o4[c2] - r4[0], g2[1] = o4[c2 + 1] - r4[1], g2[2] = o4[c2 + 2] - r4[2];
    const t3 = n5[0] * g2[0] + n5[1] * g2[1] + n5[2] * g2[2], i2 = n5[0] * n5[0] + n5[1] * n5[1] + n5[2] * n5[2], s3 = g2[0] * g2[0] + g2[1] * g2[1] + g2[2] * g2[2] - t3 * t3 / i2;
    s3 > e6 && (e6 = s3, a3 = c2);
  }
  return et(i, o4, a3), e6;
}
var d2 = n4();
function M(t2, r4, n5, i, o4) {
  G(t2, r4, d2, o4, i);
  const s2 = ht(n5, r4);
  d2[1] - m2 <= s2 && (i[0] = void 0), d2[0] + m2 >= s2 && (o4[0] = void 0);
}
var F = n();
var T = n();
var v = n();
var E2 = n();
var p2 = n();
var z2 = n();
function Y(t2, r4, n5, i, o4, s2) {
  if (mt(r4) < m2) return;
  at(F, n5, r4), at(T, i, r4), at(v, o4, r4), S(t2, r4, d2), p2[1] = d2[0], E2[1] = d2[1], z2[1] = E2[1] - p2[1];
  const e6 = [n5, i, o4], a3 = [F, T, v];
  for (let c2 = 0; c2 < 3; ++c2) {
    S(t2, e6[c2], d2), p2[0] = d2[0], E2[0] = d2[1], S(t2, a3[c2], d2), p2[2] = d2[0], E2[2] = d2[1], z2[0] = E2[0] - p2[0], z2[2] = E2[2] - p2[2];
    const n6 = nt(z2);
    n6 < s2.quality && (et(s2.b0, e6[c2]), et(s2.b1, r4), et(s2.b2, a3[c2]), s2.quality = n6);
  }
}
var _ = n();
function S(t2, r4, n5) {
  const { data: i, size: o4 } = t2;
  n5[0] = Number.POSITIVE_INFINITY, n5[1] = Number.NEGATIVE_INFINITY;
  for (let s2 = 0; s2 < i.length; s2 += o4) {
    const t3 = i[s2] * r4[0] + i[s2 + 1] * r4[1] + i[s2 + 2] * r4[2];
    n5[0] = Math.min(n5[0], t3), n5[1] = Math.max(n5[1], t3);
  }
}
function G(t2, r4, n5, i, o4) {
  const { data: s2, size: e6 } = t2;
  et(i, s2), et(o4, i), n5[0] = ht(_, r4), n5[1] = n5[0];
  for (let a3 = e6; a3 < s2.length; a3 += e6) {
    const t3 = s2[a3] * r4[0] + s2[a3 + 1] * r4[1] + s2[a3 + 2] * r4[2];
    t3 < n5[0] && (n5[0] = t3, et(i, s2, a3)), t3 > n5[1] && (n5[1] = t3, et(o4, s2, a3));
  }
}
function O3(t2, n5, i) {
  i.center = t2, i.halfSize = g(n5, n5, 0.5), i.quaternion = r3;
}
var k2 = n();
var B = n();
var C2 = n();
var D = n();
var H = n();
var J = n();
function K(t2, r4, n5) {
  et(k2, r4), Math.abs(r4[0]) > Math.abs(r4[1]) && Math.abs(r4[0]) > Math.abs(r4[2]) ? k2[0] = 0 : Math.abs(r4[1]) > Math.abs(r4[2]) ? k2[1] = 0 : k2[2] = 0, mt(k2) < m2 && (k2[0] = k2[1] = k2[2] = 1), at(B, r4, k2), ct(B, B), at(C2, r4, B), ct(C2, C2), L(t2, r4, B, C2, D, H), ot(J, H, D), Z2(r4, B, C2, D, H, J, n5);
}
function L(t2, r4, n5, i, o4, s2) {
  S(t2, r4, d2), o4[0] = d2[0], s2[0] = d2[1], S(t2, n5, d2), o4[1] = d2[0], s2[1] = d2[1], S(t2, i, d2), o4[2] = d2[0], s2[2] = d2[1];
}
var Q2 = n();
var R2 = n();
var U = n();
var W = n2(1, 0, 0, 0, 1, 0, 0, 0, 1);
var X3 = e5();
function Z2(t2, r4, n5, i, e6, a3, c2) {
  W[0] = t2[0], W[1] = t2[1], W[2] = t2[2], W[3] = r4[0], W[4] = r4[1], W[5] = r4[2], W[6] = n5[0], W[7] = n5[1], W[8] = n5[2], c2.quaternion = ut(X3, W), it(Q2, i, e6), st(Q2, Q2, 0.5), st(R2, t2, Q2[0]), st(U, r4, Q2[1]), it(R2, R2, U), st(U, n5, Q2[2]), c2.center = u(R2, R2, U), c2.halfSize = g(Q2, a3, 0.5);
}
var $ = 7;
var tt = class {
  constructor(t2) {
    this.minVert = new Array($), this.maxVert = new Array($);
    const r4 = 64 * $;
    this.buffer = new ArrayBuffer(r4);
    let n5 = 0;
    this.minProj = new Float64Array(this.buffer, n5, $), n5 += 8 * $, this.maxProj = new Float64Array(this.buffer, n5, $), n5 += 8 * $;
    for (let a3 = 0; a3 < $; ++a3) this.minVert[a3] = new Float64Array(this.buffer, n5, 3), n5 += 24;
    for (let a3 = 0; a3 < $; ++a3) this.maxVert[a3] = new Float64Array(this.buffer, n5, 3), n5 += 24;
    for (let a3 = 0; a3 < $; ++a3) this.minProj[a3] = Number.POSITIVE_INFINITY, this.maxProj[a3] = Number.NEGATIVE_INFINITY;
    const i = new Array($), o4 = new Array($), { data: s2, size: e6 } = t2;
    for (let a3 = 0; a3 < s2.length; a3 += e6) {
      let t3 = s2[a3];
      t3 < this.minProj[0] && (this.minProj[0] = t3, i[0] = a3), t3 > this.maxProj[0] && (this.maxProj[0] = t3, o4[0] = a3), t3 = s2[a3 + 1], t3 < this.minProj[1] && (this.minProj[1] = t3, i[1] = a3), t3 > this.maxProj[1] && (this.maxProj[1] = t3, o4[1] = a3), t3 = s2[a3 + 2], t3 < this.minProj[2] && (this.minProj[2] = t3, i[2] = a3), t3 > this.maxProj[2] && (this.maxProj[2] = t3, o4[2] = a3), t3 = s2[a3] + s2[a3 + 1] + s2[a3 + 2], t3 < this.minProj[3] && (this.minProj[3] = t3, i[3] = a3), t3 > this.maxProj[3] && (this.maxProj[3] = t3, o4[3] = a3), t3 = s2[a3] + s2[a3 + 1] - s2[a3 + 2], t3 < this.minProj[4] && (this.minProj[4] = t3, i[4] = a3), t3 > this.maxProj[4] && (this.maxProj[4] = t3, o4[4] = a3), t3 = s2[a3] - s2[a3 + 1] + s2[a3 + 2], t3 < this.minProj[5] && (this.minProj[5] = t3, i[5] = a3), t3 > this.maxProj[5] && (this.maxProj[5] = t3, o4[5] = a3), t3 = s2[a3] - s2[a3 + 1] - s2[a3 + 2], t3 < this.minProj[6] && (this.minProj[6] = t3, i[6] = a3), t3 > this.maxProj[6] && (this.maxProj[6] = t3, o4[6] = a3);
    }
    for (let a3 = 0; a3 < $; ++a3) {
      let t3 = i[a3];
      et(this.minVert[a3], s2, t3), t3 = o4[a3], et(this.maxVert[a3], s2, t3);
    }
  }
};
var rt = class {
  constructor() {
    this.b0 = r(1, 0, 0), this.b1 = r(0, 1, 0), this.b2 = r(0, 0, 1), this.quality = 0;
  }
};
function nt(t2) {
  return t2[0] * t2[1] + t2[0] * t2[2] + t2[1] * t2[2];
}
function it(t2, r4, n5) {
  t2[0] = r4[0] + n5[0], t2[1] = r4[1] + n5[1], t2[2] = r4[2] + n5[2];
}
function ot(t2, r4, n5) {
  t2[0] = r4[0] - n5[0], t2[1] = r4[1] - n5[1], t2[2] = r4[2] - n5[2];
}
function st(t2, r4, n5) {
  t2[0] = r4[0] * n5, t2[1] = r4[1] * n5, t2[2] = r4[2] * n5;
}
function et(t2, r4, n5 = 0) {
  t2[0] = r4[n5], t2[1] = r4[n5 + 1], t2[2] = r4[n5 + 2];
}
function at(t2, r4, n5) {
  const i = r4[0], o4 = r4[1], s2 = r4[2], e6 = n5[0], a3 = n5[1], c2 = n5[2];
  t2[0] = o4 * c2 - s2 * a3, t2[1] = s2 * e6 - i * c2, t2[2] = i * a3 - o4 * e6;
}
function ct(t2, r4) {
  const n5 = r4[0] * r4[0] + r4[1] * r4[1] + r4[2] * r4[2];
  if (n5 > 0) {
    const i = 1 / Math.sqrt(n5);
    t2[0] = r4[0] * i, t2[1] = r4[1] * i, t2[2] = r4[2] * i;
  }
}
function mt(t2) {
  return t2[0] * t2[0] + t2[1] * t2[1] + t2[2] * t2[2];
}
function ft(t2, r4) {
  const n5 = r4[0] - t2[0], i = r4[1] - t2[1], o4 = r4[2] - t2[2];
  return n5 * n5 + i * i + o4 * o4;
}
function ht(t2, r4) {
  return t2[0] * r4[0] + t2[1] * r4[1] + t2[2] * r4[2];
}
function ut(t2, r4) {
  const n5 = r4[0] + r4[4] + r4[8];
  if (n5 > 0) {
    let i = Math.sqrt(n5 + 1);
    t2[3] = 0.5 * i, i = 0.5 / i, t2[0] = (r4[5] - r4[7]) * i, t2[1] = (r4[6] - r4[2]) * i, t2[2] = (r4[1] - r4[3]) * i;
  } else {
    let n6 = 0;
    r4[4] > r4[0] && (n6 = 1), r4[8] > r4[3 * n6 + n6] && (n6 = 2);
    const i = (n6 + 1) % 3, o4 = (n6 + 2) % 3;
    let s2 = Math.sqrt(r4[3 * n6 + n6] - r4[3 * i + i] - r4[3 * o4 + o4] + 1);
    t2[n6] = 0.5 * s2, s2 = 0.5 / s2, t2[3] = (r4[3 * i + o4] - r4[3 * o4 + i]) * s2, t2[i] = (r4[3 * i + n6] + r4[3 * n6 + i]) * s2, t2[o4] = (r4[3 * o4 + n6] + r4[3 * n6 + o4]) * s2;
  }
  return t2;
}

// node_modules/@arcgis/core/views/3d/support/orientedBoundingBox.js
var G2 = class _G {
  constructor(t2 = a, a3 = lt, e6 = r3) {
    this._data = [t2[0], t2[1], t2[2], a3[0], a3[1], a3[2], e6[0], e6[1], e6[2], e6[3]];
  }
  clone() {
    return _G.fromData(this._data);
  }
  invalidate() {
    this._data[3] = -1;
  }
  get isValid() {
    return this._data[3] >= 0;
  }
  static fromData(t2) {
    const a3 = new _G();
    return a3._copyFromData(t2), a3;
  }
  static fromJSON(t2) {
    return new _G(t2.center, t2.halfSize, t2.quaternion);
  }
  copy(t2) {
    this._copyFromData(t2.data);
  }
  _copyFromData(t2) {
    for (let a3 = 0; a3 < 10; ++a3) this._data[a3] = t2[a3];
  }
  get center() {
    return o2(c.get(), this._data[0], this._data[1], this._data[2]);
  }
  get centerX() {
    return this._data[0];
  }
  get centerY() {
    return this._data[1];
  }
  get centerZ() {
    return this._data[2];
  }
  getCenter(t2) {
    return t2[0] = this._data[0], t2[1] = this._data[1], t2[2] = this._data[2], t2;
  }
  set center(t2) {
    this._data[0] = t2[0], this._data[1] = t2[1], this._data[2] = t2[2];
  }
  setCenter(t2, a3, e6) {
    this._data[0] = t2, this._data[1] = a3, this._data[2] = e6;
  }
  get halfSize() {
    return o2(c.get(), this._data[3], this._data[4], this._data[5]);
  }
  get halfSizeX() {
    return this._data[3];
  }
  get halfSizeY() {
    return this._data[4];
  }
  get halfSizeZ() {
    return this._data[5];
  }
  getHalfSize(t2) {
    return t2[0] = this._data[3], t2[1] = this._data[4], t2[2] = this._data[5], t2;
  }
  set halfSize(t2) {
    this._data[3] = t2[0], this._data[4] = t2[1], this._data[5] = t2[2];
  }
  get quaternion() {
    return X2(o3.get(), this._data[6], this._data[7], this._data[8], this._data[9]);
  }
  getQuaternion(t2) {
    return t2[0] = this._data[6], t2[1] = this._data[7], t2[2] = this._data[8], t2[3] = this._data[9], t2;
  }
  set quaternion(t2) {
    this._data[6] = t2[0], this._data[7] = t2[1], this._data[8] = t2[2], this._data[9] = t2[3];
  }
  get data() {
    return this._data;
  }
  getCorners(t2) {
    const a3 = this._data, e6 = X2(I2, a3[6], a3[7], a3[8], a3[9]);
    for (let s2 = 0; s2 < 8; ++s2) {
      const i = t2[s2];
      i[0] = (1 & s2 ? -1 : 1) * a3[3], i[1] = (2 & s2 ? -1 : 1) * a3[4], i[2] = (4 & s2 ? -1 : 1) * a3[5], Q(i, i, e6), i[0] += a3[0], i[1] += a3[1], i[2] += a3[2];
    }
  }
  doesIntersectFrustumConservativeApproximation(t2) {
    return this.intersectPlane(t2[0]) <= 0 && this.intersectPlane(t2[1]) <= 0 && this.intersectPlane(t2[2]) <= 0 && this.intersectPlane(t2[3]) <= 0 && this.intersectPlane(t2[4]) <= 0 && this.intersectPlane(t2[5]) <= 0;
  }
  get radius() {
    const t2 = this._data[3], a3 = this._data[4], e6 = this._data[5];
    return Math.sqrt(t2 * t2 + a3 * a3 + e6 * e6);
  }
  intersectSphere(t2) {
    X4[0] = this._data[0] - t2[0], X4[1] = this._data[1] - t2[1], X4[2] = this._data[2] - t2[2];
    const a3 = this.getQuaternion(O4);
    return O2(I2, a3), Q(X4, X4, I2), f2(X4, X4), Y2[0] = Math.min(X4[0], this._data[3]), Y2[1] = Math.min(X4[1], this._data[4]), Y2[2] = Math.min(X4[2], this._data[5]), X(Y2, X4) < t2[3] * t2[3];
  }
  intersectSphereWithMBS(t2, a3 = this.radius) {
    const e6 = this._data;
    X4[0] = e6[0] - t2[0], X4[1] = e6[1] - t2[1], X4[2] = e6[2] - t2[2];
    const s2 = t2[3], i = s2 + a3;
    return !(Z(X4) > i * i) && (I2[0] = -e6[6], I2[1] = -e6[7], I2[2] = -e6[8], I2[3] = e6[9], Q(X4, X4, I2), f2(X4, X4), Y2[0] = Math.min(X4[0], e6[3]), Y2[1] = Math.min(X4[1], e6[4]), Y2[2] = Math.min(X4[2], e6[5]), X(Y2, X4) < s2 * s2);
  }
  intersectPlane(t2) {
    const a3 = t2[0] * this._data[0] + t2[1] * this._data[1] + t2[2] * this._data[2] + t2[3], e6 = this.projectedRadius(k(t2));
    return a3 > e6 ? 1 : a3 < -e6 ? -1 : 0;
  }
  intersectRay(t2, a3, e6 = 0) {
    const s2 = this._data, i = I2;
    i[0] = -s2[6], i[1] = -s2[7], i[2] = -s2[8], i[3] = s2[9], X4[0] = t2[0] - s2[0], X4[1] = t2[1] - s2[1], X4[2] = t2[2] - s2[2];
    const r4 = Q(X4, X4, I2), n5 = Q(Y2, a3, I2);
    let o4 = -1 / 0, h2 = 1 / 0;
    const c2 = this.getHalfSize(ht2);
    for (let d3 = 0; d3 < 3; d3++) {
      const t3 = r4[d3], a4 = n5[d3], s3 = c2[d3] + e6;
      if (Math.abs(a4) > 1e-6) {
        const e7 = (s3 - t3) / a4, i2 = (-s3 - t3) / a4;
        o4 = Math.max(o4, Math.min(e7, i2)), h2 = Math.min(h2, Math.max(e7, i2));
      } else if (t3 > s3 || t3 < -s3) return false;
    }
    return o4 <= h2;
  }
  projectedArea(e6, s2, i, n5) {
    const o4 = this.getQuaternion(O4);
    O2(I2, o4), X4[0] = e6[0] - this._data[0], X4[1] = e6[1] - this._data[1], X4[2] = e6[2] - this._data[2], Q(X4, X4, I2);
    const h2 = this.getHalfSize(ht2), _2 = X4[0] < -h2[0] ? -1 : X4[0] > h2[0] ? 1 : 0, m3 = X4[1] < -h2[1] ? -1 : X4[1] > h2[1] ? 1 : 0, f5 = X4[2] < -h2[2] ? -1 : X4[2] > h2[2] ? 1 : 0, g3 = Math.abs(_2) + Math.abs(m3) + Math.abs(f5);
    if (0 === g3) return 1 / 0;
    const p3 = 1 === g3 ? 4 : 6, M2 = 6 * (_2 + 3 * m3 + 9 * f5 + 13);
    p(ct2, o4), f(ct2, ct2, h2);
    const b2 = this.getCenter(nt2);
    for (let t2 = 0; t2 < p3; t2++) {
      const a3 = V2[M2 + t2];
      o2(X4, ((1 & a3) << 1) - 1, (2 & a3) - 1, ((4 & a3) >> 1) - 1), N2(X4, X4, ct2), u(E3, b2, X4), E3[3] = 1, z(E3, E3, s2);
      const e7 = 1 / Math.max(1e-6, E3[3]);
      N4[2 * t2] = E3[0] * e7, N4[2 * t2 + 1] = E3[1] * e7;
    }
    const j2 = 2 * p3 - 2;
    let S2 = N4[0] * (N4[3] - N4[j2 + 1]) + N4[j2] * (N4[1] - N4[j2 - 1]);
    for (let t2 = 2; t2 < j2; t2 += 2) S2 += N4[t2] * (N4[t2 + 3] - N4[t2 - 1]);
    return Math.abs(S2) * i * n5 * 0.125;
  }
  projectedRadius(t2) {
    const a3 = this.getQuaternion(O4);
    return O2(I2, a3), Q(X4, t2, I2), Math.abs(X4[0] * this._data[3]) + Math.abs(X4[1] * this._data[4]) + Math.abs(X4[2] * this._data[5]);
  }
  minimumDistancePlane(t2) {
    return t2[0] * this._data[0] + t2[1] * this._data[1] + t2[2] * this._data[2] + t2[3] - this.projectedRadius(k(t2));
  }
  maximumDistancePlane(t2) {
    return t2[0] * this._data[0] + t2[1] * this._data[1] + t2[2] * this._data[2] + t2[3] + this.projectedRadius(k(t2));
  }
  toAaBoundingBox(a3) {
    const e6 = this.getQuaternion(O4), s2 = p(ct2, e6), i = this._data[3] * Math.abs(s2[0]) + this._data[4] * Math.abs(s2[3]) + this._data[5] * Math.abs(s2[6]), r4 = this._data[3] * Math.abs(s2[1]) + this._data[4] * Math.abs(s2[4]) + this._data[5] * Math.abs(s2[7]), n5 = this._data[3] * Math.abs(s2[2]) + this._data[4] * Math.abs(s2[5]) + this._data[5] * Math.abs(s2[8]);
    a3[0] = this._data[0] - i, a3[1] = this._data[1] - r4, a3[2] = this._data[2] - n5, a3[3] = this._data[0] + i, a3[4] = this._data[1] + r4, a3[5] = this._data[2] + n5;
  }
  transform(t2, a3, e6, s2 = 0, i = a2(e6), r4 = a2(a3), n5 = C(a3, r4)) {
    if (e6 === i) a3.isGeographic ? et2(this, t2, a3, s2, r4) : at2(this, t2, a3, s2, r4, n5);
    else if (a3.isWGS84 && (e6.isWebMercator || O(e6))) L2(a3, this, e6, t2, s2);
    else if (a3.isWebMercator && O(e6)) $2(a3, this, e6, t2, s2);
    else {
      const i2 = this.getCenter(nt2);
      i2[2] += s2, o(i2, a3, 0, i2, e6, 0), t2.center = i2, this !== t2 && (t2.quaternion = this.getQuaternion(O4), t2.halfSize = this.getHalfSize(ht2));
    }
  }
};
var I2 = e5();
var O4 = e5();
var T2 = e5();
var X4 = n();
var Y2 = n();
var E3 = n3();
function J2(t2, a3 = new G2()) {
  return u2(t2, a3), a3;
}
var N4 = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.2];
var V2 = (() => {
  const t2 = new Int8Array(162);
  let a3 = 0;
  const e6 = (e7) => {
    for (let s2 = 0; s2 < e7.length; s2++) t2[a3 + s2] = e7[s2];
    a3 += 6;
  };
  return e6([6, 2, 3, 1, 5, 4]), e6([0, 2, 3, 1, 5, 4]), e6([0, 2, 3, 7, 5, 4]), e6([0, 1, 3, 2, 6, 4]), e6([0, 1, 3, 2, 0, 0]), e6([0, 1, 5, 7, 3, 2]), e6([0, 1, 3, 7, 6, 4]), e6([0, 1, 3, 7, 6, 2]), e6([0, 1, 5, 7, 6, 2]), e6([0, 1, 5, 4, 6, 2]), e6([0, 1, 5, 4, 0, 0]), e6([0, 1, 3, 7, 5, 4]), e6([0, 2, 6, 4, 0, 0]), e6([0, 0, 0, 0, 0, 0]), e6([1, 3, 7, 5, 0, 0]), e6([2, 3, 7, 6, 4, 0]), e6([2, 3, 7, 6, 0, 0]), e6([2, 3, 1, 5, 7, 6]), e6([0, 1, 5, 7, 6, 2]), e6([0, 1, 5, 7, 6, 4]), e6([0, 1, 3, 7, 6, 4]), e6([4, 5, 7, 6, 2, 0]), e6([4, 5, 7, 6, 0, 0]), e6([4, 5, 1, 3, 7, 6]), e6([0, 2, 3, 7, 5, 4]), e6([6, 2, 3, 7, 5, 4]), e6([6, 2, 3, 1, 5, 4]), t2;
})();
function K2(t2, a3, e6, s2, i) {
  const n5 = t2.getQuaternion(O4);
  i.quaternion = n5, O2(I2, n5);
  const o4 = t2.getCenter(nt2), h2 = t2.getHalfSize(ht2);
  if (1 === s2) {
    Q(mt2, o4, I2), f2(ft2, mt2), l(ut2, ft2, h2), R(ut2, ft2, ut2);
    const s3 = r2(ut2);
    u(ut2, ft2, h2);
    const r4 = r2(ut2);
    if (s3 < e6) i.center = o4, o2(mt2, e6, e6, e6), i.halfSize = u(mt2, h2, mt2);
    else {
      const n6 = r4 > 0 ? 1 + a3 / r4 : 1, o5 = s3 > 0 ? 1 + e6 / s3 : 1, c2 = (o5 + n6) / 2, _2 = (o5 - n6) / 2;
      g(ut2, ft2, _2), i.halfSize = q(ut2, ut2, h2, c2), g(ut2, ft2, c2), q(ut2, ut2, h2, _2), m(mt2, mt2), e4(mt2, ut2, mt2);
      const m3 = t2.getQuaternion(T2);
      i.center = Q(mt2, mt2, m3);
    }
  } else {
    i.center = q(mt2, o4, N, (e6 + a3) / 2);
    const t3 = Q(mt2, N, I2);
    f2(t3, t3), i.halfSize = q(ft2, h2, t3, (e6 - a3) / 2);
  }
  return i;
}
function L2(t2, a3, e6, s2, i) {
  a3.getCenter(nt2), nt2[2] += i;
  const r4 = a2(e6);
  o(nt2, t2, 0, nt2, r4, 0), tt2(r4, a3, nt2, e6, s2);
}
function $2(t2, a3, e6, s2, i) {
  a3.getCenter(nt2), nt2[2] += i, tt2(t2, a3, nt2, e6, s2);
}
function tt2(a3, e6, s2, i, r4) {
  const n5 = e6.getQuaternion(O4), o4 = p(ct2, n5), h2 = e6.getHalfSize(ht2);
  for (let t2 = 0; t2 < 8; ++t2) {
    for (let a4 = 0; a4 < 3; ++a4) rt2[a4] = h2[a4] * (t2 & 1 << a4 ? -1 : 1);
    for (let a4 = 0; a4 < 3; ++a4) {
      let e7 = s2[a4];
      for (let t3 = 0; t3 < 3; ++t3) e7 += rt2[t3] * o4[3 * t3 + a4];
      st2[3 * t2 + a4] = e7;
    }
  }
  o(st2, a3, 0, st2, i, 0, 8), J2(it2, r4);
}
function at2(t2, a3, e6, s2, i = a2(e6), o4 = C(e6, i)) {
  t2.getCorners(_t), t2.getCenter(rt2), rt2[2] += s2, f3(e6, rt2, dt, i), a3.setCenter(dt[12], dt[13], dt[14]);
  const h2 = 2 * Math.sqrt(1 + dt[0] + dt[5] + dt[10]);
  I2[0] = (dt[6] - dt[9]) / h2, I2[1] = (dt[8] - dt[2]) / h2, I2[2] = (dt[1] - dt[4]) / h2, I2[3] = 0.25 * h2;
  const m3 = t2.getQuaternion(O4);
  a3.quaternion = x(I2, I2, m3), O2(I2, I2), o2(ft2, 0, 0, 0);
  const f5 = a3.getCenter(ot2);
  for (const r4 of _t) r4[2] += s2, o4(r4, 0, r4, 0), R(mt2, r4, f5), Q(mt2, mt2, I2), f2(mt2, mt2), d(ft2, ft2, mt2);
  a3.halfSize = ft2;
}
function et2(t2, a3, e6, s2, i = a2(e6)) {
  const n5 = E(e6), o4 = 1 + Math.max(0, s2) / (n5.radius + t2.centerZ);
  t2.getCenter(rt2), rt2[2] += s2, o(rt2, e6, 0, rt2, i, 0), a3.center = rt2;
  const h2 = t2.getQuaternion(O4);
  a3.quaternion = h2, O2(I2, h2), o2(mt2, 0, 0, 1), Q(mt2, mt2, I2);
  const _2 = t2.getHalfSize(ht2);
  o2(mt2, _2[0] * Math.abs(mt2[0]), _2[1] * Math.abs(mt2[1]), _2[2] * Math.abs(mt2[2])), g(mt2, mt2, n5.inverseFlattening), u(mt2, _2, mt2), a3.halfSize = g(mt2, mt2, o4);
}
var st2 = new Array(24);
var it2 = new s(st2, 3);
var rt2 = n();
var nt2 = n();
var ot2 = n();
var ht2 = n();
var ct2 = e2();
var dt = e3();
var _t = [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]];
var mt2 = n();
var ft2 = n();
var ut2 = n();
var lt = e(-1, -1, -1);

export {
  s,
  t,
  G2 as G,
  K2 as K
};
//# sourceMappingURL=chunk-ME5HHRVQ.js.map
