import {
  G
} from "./chunk-NMQNUPE4.js";
import {
  h
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/geometry/support/coordsUtils.js
function r(n) {
  if (!n) return null;
  if (Array.isArray(n)) return n;
  const t = n.hasZ, r2 = n.hasM;
  if ("point" === n.type) return r2 && t ? [n.x, n.y, n.z, n.m] : t ? [n.x, n.y, n.z] : r2 ? [n.x, n.y, n.m] : [n.x, n.y];
  if ("polygon" === n.type) return n.rings.slice();
  if ("polyline" === n.type) return n.paths.slice();
  if ("multipoint" === n.type) return n.points.map((n2) => [n2]);
  if ("extent" === n.type) {
    const t2 = n.clone().normalize();
    if (!t2) return null;
    let r3 = false, e2 = false;
    return t2.forEach((n2) => {
      n2.hasZ && (r3 = true), n2.hasM && (e2 = true);
    }), t2.map((n2) => {
      const t3 = [[n2.xmin, n2.ymin], [n2.xmin, n2.ymax], [n2.xmax, n2.ymax], [n2.xmax, n2.ymin], [n2.xmin, n2.ymin]];
      if (r3 && n2.hasZ) {
        const r4 = 0.5 * (n2.zmax - n2.zmin);
        for (let n3 = 0; n3 < t3.length; n3++) t3[n3].push(r4);
      }
      if (e2 && n2.hasM) {
        const r4 = 0.5 * (n2.mmax - n2.mmin);
        for (let n3 = 0; n3 < t3.length; n3++) t3[n3].push(r4);
      }
      return t3;
    });
  }
  return null;
}
function e(n, t) {
  const r2 = t[0] - n[0], e2 = t[1] - n[1];
  if (n.length > 2 && t.length > 2) {
    const i2 = n[2] - t[2];
    return Math.sqrt(r2 * r2 + e2 * e2 + i2 * i2);
  }
  return Math.sqrt(r2 * r2 + e2 * e2);
}
function i(n, t, r2) {
  const e2 = n[0] + r2 * (t[0] - n[0]), i2 = n[1] + r2 * (t[1] - n[1]);
  return n.length > 2 && t.length > 2 ? [e2, i2, n[2] + r2 * (t[2] - n[2])] : [e2, i2];
}
function o(n, t, r2, e2) {
  return s(n, t, r2[e2], r2[e2 + 1]);
}
function s(n, t, r2, e2) {
  const [i2, o2] = t, [s2, f] = r2, [u2, l2] = e2, c2 = u2 - s2, a2 = l2 - f, h3 = c2 * c2 + a2 * a2, p2 = (i2 - s2) * c2 + (o2 - f) * a2, y2 = Math.min(1, Math.max(0, p2 / h3));
  return n[0] = s2 + c2 * y2, n[1] = f + a2 * y2, n;
}
function u(n, t, r2, e2, i2, o2) {
  let s2 = r2, f = e2, u2 = i2 - s2, l2 = o2 - f;
  if (0 !== u2 || 0 !== l2) {
    const r3 = ((n - s2) * u2 + (t - f) * l2) / (u2 * u2 + l2 * l2);
    r3 > 1 ? (s2 = i2, f = o2) : r3 > 0 && (s2 += u2 * r3, f += l2 * r3);
  }
  return u2 = n - s2, l2 = t - f, u2 * u2 + l2 * l2;
}
function l(n, t) {
  return i(n, t, 0.5);
}
function c(n) {
  const t = n.length;
  let r2 = 0;
  for (let i2 = 0; i2 < t - 1; ++i2) r2 += e(n[i2], n[i2 + 1]);
  return r2;
}
function a(n, t) {
  if (t <= 0) return n[0];
  const r2 = n.length;
  let o2 = 0;
  for (let s2 = 0; s2 < r2 - 1; ++s2) {
    const r3 = e(n[s2], n[s2 + 1]);
    if (t - o2 < r3) {
      const e2 = (t - o2) / r3;
      return i(n[s2], n[s2 + 1], e2);
    }
    o2 += r3;
  }
  return n[r2 - 1];
}
function h2(n, t = 0, r2 = 1) {
  let e2 = 0;
  const i2 = n.length;
  let o2 = n[0];
  for (let s2 = 1; s2 < i2; s2++) {
    const i3 = n[s2];
    e2 += (i3[t] - o2[t]) * (i3[r2] + o2[r2]), o2 = i3;
  }
  if (p(n)) {
    const i3 = n[0];
    e2 += (i3[t] - o2[t]) * (i3[r2] + o2[r2]);
  }
  return e2 >= 0;
}
function p(t) {
  const r2 = t.length;
  return r2 > 0 && !h(t[0], t[r2 - 1]);
}
function y(n) {
  "rings" in n && (m(n), g(n));
}
function m(n) {
  if ("rings" in n) for (const t of n.rings) p(t) && t.push(t[0].slice());
}
function g(n) {
  if (!("rings" in n)) return false;
  if (0 === n.rings.length || h2(n.rings[0])) return false;
  for (const t of n.rings) t.reverse();
  return true;
}
function x(n) {
  if ("polygon" !== n.type && "polyline" !== n.type) return n;
  return M("polygon" === n.type ? n.rings : n.paths, n.spatialReference), n;
}
function M(n, r2) {
  const e2 = G(r2);
  if (!e2) return;
  const i2 = e2.valid[0], o2 = e2.valid[1], s2 = o2 - i2;
  for (const t of n) {
    let n2 = 1 / 0, r3 = -1 / 0;
    for (const s3 of t) {
      const t2 = z(s3[0], i2, o2);
      n2 = Math.min(n2, t2), r3 = Math.max(r3, t2), s3[0] = t2;
    }
    const e3 = r3 - n2;
    s2 - e3 < e3 && t.forEach((n3) => {
      n3[0] < 0 && (n3[0] += s2);
    });
  }
}
function z(n, t, r2) {
  const e2 = r2 - t;
  return n < t ? r2 - (t - n) % e2 : n > r2 ? t + (n - t) % e2 : n;
}
function v(n, t) {
  if (n === t) return true;
  if (n.type !== t.type) return false;
  if ("point" === n.type || "mesh" === n.type || "extent" === n.type) return true;
  if ("multipoint" === n.type) return n.points.length === t.points.length;
  const [r2, e2] = "polyline" === n.type ? [n.paths, t.paths] : [n.rings, t.rings];
  return r2.length === e2.length && r2.every((n2, t2) => n2.length === e2[t2].length);
}

export {
  r,
  e,
  o,
  s,
  u,
  l,
  c,
  a,
  h2 as h,
  y,
  m,
  x,
  M,
  z,
  v
};
//# sourceMappingURL=chunk-OPJX4KXH.js.map
