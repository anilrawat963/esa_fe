import {
  E,
  F,
  I,
  N as N2,
  O,
  S as S2,
  T,
  T2,
  _ as _2,
  a as a3,
  a2 as a4,
  a3 as a5,
  c,
  c2,
  d,
  d2,
  e as e2,
  f,
  f2,
  f3,
  f4,
  f5,
  g,
  h,
  h2,
  i as i4,
  k,
  l2 as l3,
  l3 as l4,
  l4 as l5,
  l5 as l6,
  m,
  m2,
  n as n3,
  o as o4,
  o2 as o5,
  o3 as o7,
  o4 as o8,
  p,
  p2,
  r as r4,
  r2 as r5,
  s as s2,
  s2 as s3,
  s3 as s4,
  s4 as s5,
  s5 as s7,
  u as u4,
  u2 as u5,
  x,
  y
} from "./chunk-27W5ILTF.js";
import {
  s2 as s6
} from "./chunk-2GRS3IMC.js";
import {
  o as o6
} from "./chunk-RQGBRVDD.js";
import {
  h2 as h3,
  r as r3
} from "./chunk-JPZOLUPV.js";
import {
  r
} from "./chunk-F7RQDGE7.js";
import {
  i as i3
} from "./chunk-GG4AQJJO.js";
import {
  a as a2
} from "./chunk-U5TTP5E5.js";
import {
  _,
  a as a6
} from "./chunk-VR2ODL2Y.js";
import {
  u as u3
} from "./chunk-NH6FXYCM.js";
import {
  dt,
  lt
} from "./chunk-XX3OKYJS.js";
import {
  e
} from "./chunk-GCI4MA3M.js";
import {
  n as n2
} from "./chunk-B5A4L35M.js";
import {
  M,
  i as i2
} from "./chunk-52SEOH5H.js";
import {
  r as r2
} from "./chunk-UYMV6HXW.js";
import {
  o as o3,
  st,
  tt
} from "./chunk-JE2NJSBU.js";
import {
  n
} from "./chunk-WDTGOP77.js";
import {
  B,
  S,
  l as l2,
  o as o2,
  u as u2,
  v
} from "./chunk-AZXJIEZ6.js";
import {
  u
} from "./chunk-CSMCPN64.js";
import {
  o
} from "./chunk-4DGC7CBY.js";
import {
  a,
  i3 as i,
  l3 as l,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  N
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/animated/ComputedAnimatedParams.js
function i5(i7) {
  let { pixelDimensions: t, texelDimensions: s9, baseSize: r8, referenceSize: n5, strokeWidth: o9, sizeRatio: f6 } = i7;
  if (t || (t = i7.sprite.sdf ? [0, 0] : [i7.sprite.width, i7.sprite.height]), s9 || (s9 = i7.sprite.sdf ? [0, 0] : t), null != i7.patternHeight) {
    const e4 = i7.patternHeight / t[1];
    t[1] *= e4, t[0] *= e4;
  }
  -1 === r8 && (r8 = t[1]), r8 = u(r8), n5 = u(n5), o9 = u(o9);
  const p3 = (i7.sprite.sdfDecodeCoeff ?? 1) * f6;
  return { ...i7, pixelDimensions: t, texelDimensions: s9, baseSize: r8, referenceSize: n5, strokeWidth: o9, sdfDecodeCoeff: p3 };
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/animated/AnimatedMarkerMeshWriter.js
var M2 = 64;
var g2 = 64;
var v2 = 2;
var w = class extends o4 {
  get vertexSpec() {
    return { createComputedParams: i5, optionalAttributes: { zoomRange: a5, value1Position2Value2: s4, lineLength: l4 }, attributes: { id: m2, bitset: y, pos: F, offset: f3.marker, uv: O.marker, animationPointerAndBaseSizeAndReferenceSize: d, sizing: x, angle: N2 } };
  }
  _write(e4, i7, r8) {
    const s9 = this.evaluatedMeshParams.sprite, { textureBinding: n5 } = s9;
    e4.recordStart(this.instanceId, this.attributeLayout, n5);
    const o9 = i7.getDisplayId();
    if (this.shift && "esriGeometryPolyline" === i7.geometryType) {
      if (!r8) {
        const r9 = a2.fromFeatureSetReaderCIM(i7);
        r9 && this._writeParticles(e4, i7, r9);
      }
    } else if (null != this.evaluatedMeshParams.placement) this._writePlacedMarkers(e4, i7);
    else if ("esriGeometryPolygon" === i7.geometryType) {
      const t = i7.readCentroidForDisplay();
      if (!t) return;
      const [r9, s10] = t.coords;
      this._writeQuad(e4, o9, r9, s10);
    } else if ("esriGeometryPoint" === i7.geometryType) {
      const t = i7.readXForDisplay(), r9 = i7.readYForDisplay();
      this._writeQuad(e4, o9, t, r9);
    } else {
      const t = i7.readGeometryForDisplay();
      t && t.forEachVertex((t2, i8) => {
        this._writeQuad(e4, o9, t2, i8);
      });
    }
    e4.recordEnd();
  }
  _writePlacedMarkers(s9, n5) {
    const o9 = a2.fromFeatureSetReaderCIM(n5)?.clone();
    if (!o9) return;
    const a8 = -1, c4 = e2.getPlacement(o9, a8, this.evaluatedMeshParams.placement, u(1), s9.id);
    if (!c4) return;
    const l8 = n5.getDisplayId();
    let m3 = c4.next(), d4 = null;
    for (; null != m3; ) {
      const e4 = m3.tx, t = -m3.ty;
      if (Math.abs(e4) > r || Math.abs(t) > r) {
        m3 = c4.next();
        continue;
      }
      const r8 = -m3.getAngle();
      s9.recordBounds(e4, t, M2, g2), this.shift ? d4 && this._writeQuad(s9, l8, d4[0], d4[1], void 0, r8) : this._writeQuad(s9, l8, e4, t, void 0, r8), d4 = [e4, t], m3 = c4.next();
    }
  }
  _writeParticles(e4, t, i7) {
    const r8 = t.getDisplayId();
    for (; i7.nextPath(); ) {
      const t2 = [];
      for (; i7.nextPoint(); ) t2.push([i7.x, i7.y]);
      const s9 = _3(t2);
      let n5 = 0;
      for (let e5 = 1; e5 < t2.length; e5++) {
        const i8 = t2[e5][0] - t2[e5 - 1][0], r9 = t2[e5][1] - t2[e5 - 1][1], s10 = Math.sqrt(i8 * i8 + r9 * r9);
        n5 += s10;
      }
      const o9 = (t3) => {
        for (const i8 of s9) {
          const { a: s10, b: o10 } = i8;
          this._writeQuad(e4, r8, s10.position[0], s10.position[1], [s10.distance - t3, o10.position[0], o10.position[1], o10.distance - t3], this.evaluatedMeshParams.angleToLine ? Math.atan2(s10.direction[1], s10.direction[0]) : 0, n5, true);
        }
      }, { placement: a8 } = this.evaluatedMeshParams;
      if (!a8 || "placementTemplate" in a8 || "CIMMarkerPlacementOnVertices" === a8.type) {
        let e5;
        if (a8 && "CIMMarkerPlacementOnVertices" !== a8.type) e5 = a8.placementTemplate;
        else {
          e5 = [0];
          for (const t4 of s9) {
            const { a: i8, b: r9 } = t4, s10 = i8.position[0] - r9.position[0], n6 = i8.position[1] - r9.position[1], o10 = Math.sqrt(s10 * s10 + n6 * n6);
            e5.push(o10);
          }
        }
        let t3 = -1 * n5;
        for (; t3 < (1 + v2 / 2) * n5; ) for (const i8 of e5) t3 += i8, o9(t3);
      } else "CIMMarkerPlacementAtExtremities" === a8.type ? "JustBegin" === a8.extremityPlacement ? o9(1) : "JustEnd" === a8.extremityPlacement ? (o9(n5 - 1), o9(-1)) : "Both" === a8.extremityPlacement && (o9(1), o9(n5 - 1)) : "CIMMarkerPlacementOnLine" === a8.type && ("LineBeginning" === a8.relativeTo ? o9(1) : "LineEnd" === a8.relativeTo ? (o9(n5 - 1), o9(-1)) : "LineMiddle" === a8.relativeTo && o9(n5 / 2));
    }
  }
  _writeQuad(e4, t, i7, r8, n5, o9 = 0, a8 = 0, c4 = false) {
    const l8 = this.evaluatedMeshParams.sprite, { rect: m3 } = l8, d4 = m3.x + tt, p3 = m3.y + tt, h6 = m3.x + m3.width - tt, u7 = m3.y + m3.height - tt, f6 = e4.vertexCount();
    c4 || e4.recordBounds(i7, r8, M2, M2);
    const x4 = { texXmin: d4, texYmin: p3, texXmax: h6, texYmax: u7, value1Position2Value2: n5, angle: o9 / o6, lineLength: a8 };
    for (let s9 = 0; s9 < 4; s9++) this._writeVertex(e4, t, i7, r8, x4);
    e4.indexEnsureSize(6), e4.indexWrite(f6), e4.indexWrite(f6 + 1), e4.indexWrite(f6 + 2), e4.indexWrite(f6 + 1), e4.indexWrite(f6 + 3), e4.indexWrite(f6 + 2);
  }
};
function _3(e4) {
  const t = [];
  let i7 = 0;
  for (let r8 = 1; r8 < e4.length; r8++) {
    const s9 = e4[r8 - 1], n5 = e4[r8], o9 = n5[0] - s9[0], a8 = n5[1] - s9[1], c4 = Math.sqrt(o9 * o9 + a8 * a8), l8 = o9 / c4, m3 = a8 / c4;
    t.push({ a: { position: s9, distance: i7, direction: [l8, m3] }, b: { position: n5, distance: i7 + c4, direction: [l8, m3] } }), i7 += c4;
  }
  return t;
}
var b = class extends w {
  constructor() {
    super(...arguments), this.shift = false;
  }
};
var C = class extends w {
  constructor() {
    super(...arguments), this.shift = true;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/animated/AnimatedPolyMeshWriters.js
var C2 = class extends o4 {
  _write(t, s9, i7) {
    const r8 = i7 ?? a2.fromFeatureSetReaderCIM(s9);
    if (!r8) return;
    const n5 = this.evaluatedMeshParams.sprite, { textureBinding: o9 } = n5;
    t.recordStart(this.instanceId, this.attributeLayout, o9);
    const a8 = s9.getDisplayId();
    this._writePoly(t, a8, r8.asOptimized()), t.recordEnd();
  }
};
var z = class extends C2 {
  constructor() {
    super(...arguments), this.vertexSpec = { createComputedParams: i5, attributes: { id: m2, bitset: y, pos: F, offset: f3.fill, tlbr: S2, animationPointerAndBaseSizeAndReferenceSize: d, sizing: x }, optionalAttributes: { zoomRange: a5, value1Position2Value2: p, lineLength: r5 } };
  }
  _writePoly(t, e4, i7) {
    const r8 = this._clip(i7);
    if (!r8) return;
    i7 = r8;
    const o9 = [], a8 = t.vertexCount();
    let h6;
    if (h(o9, i7)) {
      if (0 === o9.length) return;
      h6 = 0;
      for (const s9 of o9) {
        const r9 = i7.coords[2 * s9], n5 = i7.coords[2 * s9 + 1];
        this._writeVertex(t, e4, r9, n5), h6++;
      }
    } else {
      const { coords: r9, lengths: n5 } = i7, o10 = a6(r9, n5);
      h6 = o10.vertexCount;
      for (let s9 = 0; s9 < o10.buffer.length / 2; s9++) {
        const i8 = o10.buffer[2 * s9], r10 = o10.buffer[2 * s9 + 1];
        this._writeVertex(t, e4, i8, r10);
      }
    }
    if (h6 > 0) {
      t.indexEnsureSize(h6);
      for (let e5 = 0; e5 < h6; e5++) t.indexWrite(e5 + a8);
    }
  }
  _clip(t) {
    const e4 = this.hasEffects;
    return g(t, e4 ? 256 : 8);
  }
};
var j = class {
  constructor() {
    this.id = 0, this.bitset = 0, this.indexCount = 0, this.vertexCount = 0, this.vertexFrom = 0, this.vertexBounds = 0, this.pathLength = 0;
  }
};
var S3 = 65535;
var T3 = class extends C2 {
  constructor() {
    super(...arguments), this.vertexSpec = { createComputedParams: i5, attributes: { id: m2, bitset: y, pos: F, offset: f3.line, tlbr: S2, animationPointerAndBaseSizeAndReferenceSize: d, sizing: x, accumulatedDistance: k, normal: T, segmentDirection: u4 }, optionalAttributes: { zoomRange: a5, value1Position2Value2: p, lineLength: l4 } }, this._tessParams = new d2(), this._currentWrite = new j(), this._tessellationOptions = { halfWidth: 0, pixelCoordRatio: 1, offset: 0, wrapDistance: S3, textured: false }, this._lineLength = 0, this._lineTessellator = new _((t, e4, s9, i7, r8, n5, o9, a8, h6, l8, m3) => this._writeTesselatedVertex(t, e4, s9, i7, r8, n5, o9, a8, h6, l8, m3, this._lineLength), this._writeTriangle.bind(this), false);
  }
  _writePoly(s9, i7, n5) {
    const o9 = 64, a8 = false, h6 = p2(a2.fromOptimized(n5, "esriGeometryPolyline"), o9);
    if (null == h6) return;
    const { _currentWrite: l8, _tessellationOptions: m3 } = this, { baseSize: u7, capType: c4, joinType: d4, miterLimit: f6 } = this.evaluatedMeshParams, p3 = u(0.5 * u7);
    m3.halfWidth = p3, m3.capType = f(c4 || "Round"), m3.joinType = m(d4 || "Round"), m3.miterLimit = f6 || 2, l8.out = s9, l8.id = i7, l8.vertexCount = 0, l8.indexCount = 0, l8.vertexFrom = s9.vertexCount(), l8.vertexBounds = 1;
    for (const { line: t, start: e4, pathLength: r8 } of h6) {
      m3.initialDistance = e4 % S3, l8.pathLength = r8, this._lineLength = 0;
      for (let e5 = 1; e5 < t.length; e5++) {
        const s10 = t[e5].x - t[e5 - 1].x, i8 = t[e5].y - t[e5 - 1].y;
        this._lineLength += Math.sqrt(s10 * s10 + i8 * i8);
      }
      this._lineTessellator.tessellate(t, m3, a8);
    }
  }
  _writeTesselatedVertex(t, e4, s9, i7, r8, n5, o9, a8, h6, l8, m3, u7) {
    const { out: c4, id: d4, vertexBounds: f6, pathLength: p3 } = this._currentWrite;
    return this.hasEffects && c4.recordBounds(t, e4, f6, f6), this._tessParams.extrusionOffsetX = o9, this._tessParams.extrusionOffsetY = a8, this._tessParams.normalX = h6, this._tessParams.normalY = l8, this._tessParams.directionX = r8, this._tessParams.directionY = n5, this._tessParams.distance = m3, this._tessParams.pathLength = p3, this._tessParams.lineLength = u7, this._writeVertex(c4, d4, t, e4, this._tessParams), this._currentWrite.vertexFrom + this._currentWrite.vertexCount++;
  }
  _writeTriangle(t, e4, s9) {
    const { out: i7 } = this._currentWrite;
    i7.indexEnsureSize(3), i7.indexWrite(t), i7.indexWrite(e4), i7.indexWrite(s9), this._currentWrite.indexCount += 3;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/segmentUtils.js
function e3(t, e4, n5) {
  return t[0] = e4[0] - n5[0], t[1] = e4[1] - n5[1], t;
}
function n4(t, e4) {
  return Math.sqrt(t * t + e4 * e4);
}
function s8(t) {
  const e4 = n4(t[0], t[1]);
  t[0] /= e4, t[1] /= e4;
}
function i6(t, e4) {
  return n4(t[0] - e4[0], t[1] - e4[1]);
}
function r6(t, e4) {
  return t[e4 + 1];
}
function h4(t) {
  return t.length - 1;
}
function a7(t) {
  let e4 = 0;
  for (let n5 = 0; n5 < h4(t); n5++) e4 += d3(t, n5);
  return e4;
}
function d3(t, e4, n5 = 1) {
  let [s9, i7] = r6(t, e4);
  return [s9, i7] = [Math.round(s9), Math.round(i7)], Math.sqrt(s9 * s9 + i7 * i7) * n5;
}
var u6 = class _u {
  constructor(t, e4, n5, s9, i7) {
    this._segments = t, this._index = e4, this._distance = n5, this._xStart = s9, this._yStart = i7, this._done = false;
  }
  static create(t) {
    return new _u(t, 0, 0, t[0][0], t[0][1]);
  }
  clone() {
    return new _u(this._segments, this._index, this._distance, this.xStart, this.yStart);
  }
  equals(t) {
    return this._index === t._index || t._index === this._index - 1 && (0 === this._distance || 1 === t._distance) || t._index === this._index + 1 && (1 === this._distance || 0 === t._distance);
  }
  leq(t) {
    return this._index < t._index || this._index === t._index && this._distance <= t._distance;
  }
  geq(t) {
    return this._index > t._index || this._index === t._index && this._distance >= t._distance;
  }
  get _segment() {
    return this._segments[this._index + 1];
  }
  get angle() {
    const t = this.dy, e4 = (0 * t + -1 * -this.dx) / (1 * this.length);
    let n5 = Math.acos(e4);
    return t > 0 && (n5 = 2 * Math.PI - n5), n5;
  }
  get xStart() {
    return this._xStart;
  }
  get yStart() {
    return this._yStart;
  }
  get x() {
    return this.xStart + this.distance * this.dx;
  }
  get y() {
    return this.yStart + this.distance * this.dy;
  }
  get dx() {
    return this._segment[0];
  }
  get dy() {
    return this._segment[1];
  }
  get xMidpoint() {
    return this.xStart + 0.5 * this.dx;
  }
  get yMidpoint() {
    return this.yStart + 0.5 * this.dy;
  }
  get xEnd() {
    return this.xStart + this.dx;
  }
  get yEnd() {
    return this.yStart + this.dy;
  }
  get length() {
    const { dx: t, dy: e4 } = this;
    return Math.sqrt(t * t + e4 * e4);
  }
  get remainingLength() {
    return this.length * (1 - this._distance);
  }
  get backwardLength() {
    return this.length * this._distance;
  }
  get distance() {
    return this._distance;
  }
  get done() {
    return this._done;
  }
  hasPrev() {
    return this._index - 1 >= 0;
  }
  hasNext() {
    return this._index + 1 < h4(this._segments);
  }
  next() {
    return this.hasNext() ? (this._xStart += this.dx, this._yStart += this.dy, this._distance = 0, this._index += 1, this) : null;
  }
  prev() {
    return this.hasPrev() ? (this._index -= 1, this._xStart -= this.dx, this._yStart -= this.dy, this._distance = 1, this) : (this._done = true, null);
  }
  _seekBackwards(t, e4) {
    const n5 = this.backwardLength;
    if (t <= n5) return this._distance = (n5 - t) / this.length, this;
    let s9 = this.backwardLength;
    for (; this.prev(); ) {
      if (s9 + this.length > t) return this._seekBackwards(t - s9);
      s9 += this.length;
    }
    return this._distance = 0, e4 ? this : null;
  }
  seek(t, e4 = false) {
    if (t < 0) return this._seekBackwards(Math.abs(t), e4);
    if (t <= this.remainingLength) return this._distance = (this.backwardLength + t) / this.length, this;
    let n5 = this.remainingLength;
    for (; this.next(); ) {
      if (n5 + this.length > t) return this.seek(t - n5, e4);
      n5 += this.length;
    }
    return this._distance = 1, e4 ? this : null;
  }
};
function c3(e4, n5, s9, i7 = true) {
  const r8 = a7(e4), h6 = u6.create(e4), d4 = r8 / 2;
  if (!i7) return h6.seek(d4), void (h6.x < o3 && h6.y < o3 && h6.x >= 0 && h6.y >= 0 && s9(h6.clone(), 0, d4 + 0 * n5, r8));
  const c4 = Math.max((r8 - n5) / 2, 0), o9 = Math.floor(c4 / n5), _5 = d4 - o9 * n5;
  h6.seek(_5);
  for (let a8 = -o9; a8 <= o9; a8++) h6.x < o3 && h6.y < o3 && h6.x >= 0 && h6.y >= 0 && s9(h6.clone(), a8, d4 + a8 * n5, r8), h6.seek(n5);
}
function l7(t, e4) {
  const n5 = e4;
  for (let s9 = 0; s9 < t.length; s9++) {
    let e5 = t[s9];
    x2(e5, n5);
    const i7 = [];
    i7.push(e5[0]);
    for (let t2 = 1; t2 < e5.length; t2++) {
      const [n6, s10] = e5[t2 - 1], [r8, h6] = e5[t2], a8 = r8 - n6, d4 = h6 - s10;
      i7.push([a8, d4]);
    }
    t[s9] = i7, e5 = i7;
  }
  return t;
}
function x2(t, n5) {
  const r8 = 1e-6;
  if (n5 <= 0) return;
  const h6 = t.length;
  if (h6 < 3) return;
  const a8 = [];
  let d4 = 0;
  a8.push(0);
  for (let e4 = 1; e4 < h6; e4++) d4 += i6(t[e4], t[e4 - 1]), a8.push(d4);
  n5 = Math.min(n5, 0.2 * d4);
  const u7 = [];
  u7.push(t[0][0]), u7.push(t[0][1]);
  const c4 = t[h6 - 1][0], o9 = t[h6 - 1][1], _5 = e3([0, 0], t[0], t[1]);
  s8(_5), t[0][0] += n5 * _5[0], t[0][1] += n5 * _5[1], e3(_5, t[h6 - 1], t[h6 - 2]), s8(_5), t[h6 - 1][0] += n5 * _5[0], t[h6 - 1][1] += n5 * _5[1];
  for (let e4 = 1; e4 < h6; e4++) a8[e4] += n5;
  a8[h6 - 1] += n5;
  const l8 = 0.5 * n5;
  for (let e4 = 1; e4 < h6 - 1; e4++) {
    let s9 = 0, i7 = 0, d5 = 0;
    for (let h7 = e4 - 1; h7 >= 0 && !(a8[h7 + 1] < a8[e4] - l8); h7--) {
      const u8 = l8 + a8[h7 + 1] - a8[e4], c5 = a8[h7 + 1] - a8[h7], o10 = a8[e4] - a8[h7] < l8 ? 1 : u8 / c5;
      if (Math.abs(o10) < r8) break;
      const _6 = o10 * o10, x4 = o10 * u8 - 0.5 * _6 * c5, g3 = o10 * c5 / n5, f6 = t[h7 + 1], y3 = t[h7][0] - f6[0], k3 = t[h7][1] - f6[1];
      s9 += g3 / x4 * (f6[0] * o10 * u8 + 0.5 * _6 * (u8 * y3 - c5 * f6[0]) - _6 * o10 * c5 * y3 / 3), i7 += g3 / x4 * (f6[1] * o10 * u8 + 0.5 * _6 * (u8 * k3 - c5 * f6[1]) - _6 * o10 * c5 * k3 / 3), d5 += g3;
    }
    for (let u8 = e4 + 1; u8 < h6 && !(a8[u8 - 1] > a8[e4] + l8); u8++) {
      const h7 = l8 - a8[u8 - 1] + a8[e4], c5 = a8[u8] - a8[u8 - 1], o10 = a8[u8] - a8[e4] < l8 ? 1 : h7 / c5;
      if (Math.abs(o10) < r8) break;
      const _6 = o10 * o10, x4 = o10 * h7 - 0.5 * _6 * c5, g3 = o10 * c5 / n5, f6 = t[u8 - 1], y3 = t[u8][0] - f6[0], k3 = t[u8][1] - f6[1];
      s9 += g3 / x4 * (f6[0] * o10 * h7 + 0.5 * _6 * (h7 * y3 - c5 * f6[0]) - _6 * o10 * c5 * y3 / 3), i7 += g3 / x4 * (f6[1] * o10 * h7 + 0.5 * _6 * (h7 * k3 - c5 * f6[1]) - _6 * o10 * c5 * k3 / 3), d5 += g3;
    }
    u7.push(s9 / d5), u7.push(i7 / d5);
  }
  u7.push(c4), u7.push(o9);
  for (let e4 = 0, s9 = 0; e4 < h6; e4++) t[e4][0] = u7[s9++], t[e4][1] = u7[s9++];
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/labels/LabelMeshWriter.js
var S4 = 1;
var z2 = 0;
var D = 128;
function A(e4, t, r8) {
  return l(`${e4}${t}${r8}`);
}
function j2(e4, t, r8, s9, o9) {
  return l(`${e4}${t}${r8}${s9 * 2 ** (_2 - o9)}`);
}
function G(e4, t, r8) {
  return l(`${e4}${t}${r8}`);
}
function Z(e4, t, r8, s9, o9) {
  return l(`${e4}${o9}${t}${r8 * 2 ** (_2 - s9)}`);
}
var k2 = o((e4) => {
  let t = 0;
  if (0 === e4) return 1 / 0;
  for (; !(e4 % 2); ) t++, e4 /= 2;
  return t;
});
var F2 = class extends E {
  constructor() {
    super(...arguments), this._zoomLevel = 0;
  }
  _write(e4, t, i7, r8) {
    if (this._zoomLevel = r8 || 0, null != i7) throw new Error("InternalError: EffectGeometry not support for LabelMeshWriter");
    switch (t.geometryType) {
      case "esriGeometryPoint": {
        const i8 = t.readXForDisplay(), r9 = t.readYForDisplay();
        this._writePoint(e4, i8, r9, 0, t);
        break;
      }
      case "esriGeometryEnvelope":
      case "esriGeometryPolygon": {
        const i8 = t.readCentroidForDisplay();
        if (!i8) return;
        const [r9, s9] = i8.coords;
        this._writePoint(e4, r9, s9, 0, t);
        break;
      }
      case "esriGeometryMultipoint": {
        let i8 = 0;
        const r9 = a2.fromFeatureSetReader(t);
        if (r9?.nextPath()) for (; r9.nextPoint(); ) this._writePoint(e4, r9.x, r9.y, i8++, t);
        break;
      }
      case "esriGeometryPolyline":
        this._writeLines(e4, t);
    }
  }
  _getMetricDir() {
    const { horizontalAlignment: e4, verticalAlignment: t } = this.evaluatedMeshParams;
    return ["center" === e4 ? 0 : "right" === e4 ? -1 : 1, "middle" === t ? 0 : "bottom" === t ? -1 : 1];
  }
  _createLineLabelMetric(e4, t, i7, r8, s9, o9) {
    const [n5, a8] = this._getMetricDir(), l8 = this.evaluatedMeshParams.scaleInfo?.maxScale ?? 0, c4 = this.evaluatedMeshParams.scaleInfo?.minScale ?? 0, h6 = this.evaluatedMeshParams.labelClassId;
    return new h3(e4, h6, t, i7, r8, s9, n5, a8, l8, c4, o9);
  }
  _writePoint(e4, t, i7, r8, s9) {
    if (t < 0 || t > o3 || i7 < 0 || i7 > o3) return;
    const o9 = this._getShaping();
    if (!o9) return;
    const n5 = s9.getDisplayId(), a8 = this.evaluatedMeshParams.labelClassId, l8 = A(this.evaluatedMeshParams.layerId, s9.getObjectId(), r8), c4 = G(s9.getObjectId(), a8, r8), [h6, m3] = this._getMetricDir(), d4 = this.evaluatedMeshParams.scaleInfo?.maxScale ?? 0, u7 = this.evaluatedMeshParams.scaleInfo?.minScale ?? 0, f6 = this._getPointReferenceBounds() || { offsetX: 0, offsetY: 0, size: 0 };
    e4.metricStart(new h3(n5, a8, l8, c4, t, i7, h6, m3, d4, u7, f6)), this._writeGlyphs(e4, n5, t, i7, o9, 0, f6, void 0, false), e4.metricBoxWrite(o9.boundsT), e4.metricEnd();
  }
  _getPointReferenceBounds() {
    if (!this._references) return null;
    for (const e4 of this._references) {
      const t = e4.getBoundsInfo();
      if (t) return t;
    }
    return null;
  }
  _writeLines(e4, t) {
    const { scaleInfo: i7, verticalAlignment: r8 } = this.evaluatedMeshParams, s9 = this.evaluatedMeshParams.repeatLabelDistance || 128, o9 = this._getShaping("middle");
    if (!o9) return;
    const n5 = (e5, t2, i8, r9) => this._placeSubdivGlyphs(e5, t2, i8, r9), a8 = (o9.bounds.width + s9) / (1 << S4);
    this._current = { out: e4, id: t.getDisplayId(), objId: t.getObjectId(), shaping: o9, zoomRange: s2(i7, this.getTileInfo()), referenceBounds: this._getPointReferenceBounds() || { offsetX: 0, offsetY: 0, size: 0 }, offsetDirection: null, pathIndex: 0 }, this._verticalPlacement = "bottom" === r8 ? "above" : "top" === r8 ? "below" : null, this._verticalPlacement ? this._writeAboveAndBelowAlong(t, n5, a8) : this._writeCenterAlong(t, n5, a8);
  }
  _writeAboveAndBelowAlong(e4, t, i7) {
    const { repeatLabel: r8 } = this.evaluatedMeshParams, { shaping: s9 } = this._current, o9 = s9.bounds.halfHeight, n5 = e4.readGeometryForDisplay();
    if (!n5) return;
    const a8 = new e();
    dt(a8, n5, false, false, "esriGeometryPolyline", 1);
    const l8 = $(new e(), a8, o9), c4 = $(new e(), a8, -o9), h6 = lt(c4, "esriGeometryPolyline", false, false), m3 = lt(l8, "esriGeometryPolyline", false, false), d4 = l7(m3.paths, s9.bounds.width), u7 = l7(h6.paths, s9.bounds.width);
    this._current.offsetDirection = "above";
    for (let f6 = 0; f6 < d4.length; f6++) this._current.pathIndex = f6, c3(d4[f6], i7, t, !!r8);
    this._current.offsetDirection = "below";
    for (let f6 = 0; f6 < u7.length; f6++) this._current.pathIndex = f6, c3(u7[f6], i7, t, !!r8);
  }
  _writeCenterAlong(e4, t, i7) {
    const { repeatLabel: r8 } = this.evaluatedMeshParams, { shaping: s9 } = this._current, o9 = l7(e4.readLegacyGeometryForDisplay().paths, s9.bounds.width);
    for (let n5 = 0; n5 < o9.length; n5++) this._current.pathIndex = n5, c3(o9[n5], i7, t, !!r8);
  }
  _placeSubdivGlyphs(e4, t, i7, r8) {
    const { allowOverrun: s9, labelPosition: o9, repeatLabelDistance: n5, layerId: a8, labelClassId: l8 } = this.evaluatedMeshParams, { objId: c4, shaping: h6, pathIndex: m3 } = this._current, d4 = this._current.zoomRange[0], u7 = k2(t), f6 = this._current.shaping.bounds.width / (1 << S4), g3 = Math.sqrt(n5 || D) / (1 << S4), _5 = Math.min(i7, r8 - i7), p3 = h6.isMultiline ? _2 : Math.log2(_5 / (g3 + f6 / 2)), b2 = 0 === t ? p3 : Math.min(u7, p3), x4 = Math.max(d4, this._zoomLevel + S4 - b2), v4 = this._zoomLevel - x4, M3 = h6.bounds.width / 2 * 2 ** v4, P2 = j2(a8, c4, m3, t, this._zoomLevel), y3 = Z(c4, m3, t, this._zoomLevel, l8);
    this._current.shaping.isMultiline ? 0 === t && this._placeStraight(e4, x4, P2, y3) : s9 && v4 < 0 ? this._placeStraightAlong(e4, d4, P2, y3) : "parallel" === o9 ? this._placeStraightAlong(e4, x4, P2, y3) : "curved" === o9 && this._placeCurved(e4, x4, M3, P2, y3);
  }
  _placeStraight(e4, t, i7, r8) {
    const { out: s9, id: o9, shaping: n5, referenceBounds: a8 } = this._current, { x: l8, y: c4 } = e4;
    s9.metricStart(this._createLineLabelMetric(o9, i7, r8, l8, c4)), s9.metricBoxWrite(n5.boundsT);
    const h6 = e4.angle * (180 / Math.PI) % 360, m3 = (e4.angle * (180 / Math.PI) + 180) % 360;
    if (!this._verticalPlacement || this._verticalPlacement === this._current.offsetDirection) {
      const e5 = { clipAngle: h6, mapAligned: true, isLineLabel: true, minZoom: t };
      this._writeGlyphs(s9, o9, l8, c4, n5, 0, a8, e5, false);
    }
    if (!this._verticalPlacement || this._verticalPlacement !== this._current.offsetDirection) {
      const e5 = { clipAngle: m3, mapAligned: true, isLineLabel: true, minZoom: t };
      this._writeGlyphs(s9, o9, l8, c4, n5, 0, a8, e5, false);
    }
    s9.metricEnd();
  }
  _placeCurved(e4, t, i7, r8, s9) {
    const { out: o9, id: n5 } = this._current;
    o9.metricStart(this._createLineLabelMetric(n5, r8, s9, e4.x, e4.y));
    const a8 = e4.clone(), l8 = e4.angle * (180 / Math.PI) % 360, c4 = (e4.angle * (180 / Math.PI) + 180) % 360;
    this._verticalPlacement && this._verticalPlacement !== this._current.offsetDirection || (this._placeFirst(a8, t, 1, l8), this._placeBack(e4, a8, t, i7, 1, l8), this._placeForward(e4, a8, t, i7, 1, l8)), this._verticalPlacement && this._verticalPlacement === this._current.offsetDirection || (this._placeFirst(a8, t, 0, c4), this._placeBack(e4, a8, t, i7, 0, c4), this._placeForward(e4, a8, t, i7, 0, c4)), o9.metricEnd();
  }
  _placeStraightAlong(e4, i7, n5, a8) {
    const { out: l8, id: c4, shaping: h6, zoomRange: m3, referenceBounds: u7 } = this._current, { boxBorderLineColor: f6, boxBackgroundColor: g3 } = this.evaluatedMeshParams, _5 = e4.clone(), p3 = e4.angle * (180 / Math.PI) % 360, b2 = (e4.angle * (180 / Math.PI) + 180) % 360, x4 = h6.glyphs.length > 0 && !(!f6 && !g3);
    if (l8.metricStart(this._createLineLabelMetric(c4, n5, a8, e4.x, e4.y)), x4) {
      const n6 = Math.max(i7, m3[0], 0), a9 = Math.min(_2, m3[1]), f7 = M(n2(), -e4.angle), g4 = { minZoom: n6, maxZoom: a9, clipAngle: p3, mapAligned: true, isLineLabel: true }, _6 = u(this.evaluatedMeshParams.offsetX), x5 = u(this.evaluatedMeshParams.offsetY);
      if (!this._verticalPlacement || this._verticalPlacement === this._current.offsetDirection) {
        const t = r2(_6, -1 * x5), [i8, r8] = h6.shapeBackground(i2(n2(), f7, t));
        l8.recordStart(this.instanceId, this.attributeLayout, h6.glyphs[0].textureBinding), this._writeTextBox(l8, c4, e4.x, e4.y, r8, u7, g4), l8.recordEnd();
      }
      if (!this._verticalPlacement || this._verticalPlacement !== this._current.offsetDirection) {
        const t = r2(_6, x5), [i8, r8] = h6.shapeBackground(i2(n2(), f7, t));
        g4.clipAngle = b2, l8.recordStart(this.instanceId, this.attributeLayout, h6.glyphs[0].textureBinding), this._writeTextBox(l8, c4, e4.x, e4.y, r8, u7, g4), l8.recordEnd();
      }
    }
    this._verticalPlacement && this._verticalPlacement !== this._current.offsetDirection || this._placeFirst(_5, i7, 1, p3, true), this._verticalPlacement && this._verticalPlacement === this._current.offsetDirection || this._placeFirst(_5, i7, 0, b2, true), l8.metricEnd();
  }
  _placeBack(e4, t, i7, r8, s9, o9) {
    const n5 = e4.clone();
    let a8 = e4.backwardLength + z2;
    for (; n5.prev() && !(a8 >= r8); ) this._placeOnSegment(n5, t, a8, i7, -1, s9, o9), a8 += n5.length + z2;
  }
  _placeForward(e4, t, i7, r8, s9, o9) {
    const n5 = e4.clone();
    let a8 = e4.remainingLength + z2;
    for (; n5.next() && !(a8 >= r8); ) this._placeOnSegment(n5, t, a8, i7, 1, s9, o9), a8 += n5.length + z2;
  }
  _placeFirst(e4, i7, s9, a8, l8 = false) {
    const { out: c4, id: h6, shaping: m3, zoomRange: u7, referenceBounds: f6 } = this._current, g3 = m3.glyphs, _5 = u(this.evaluatedMeshParams.offsetX), p3 = u(this.evaluatedMeshParams.offsetY), b2 = r2(_5, p3), x4 = M(n2(), -e4.angle);
    S(b2, b2, x4);
    for (const t of g3) {
      const r8 = t.x > m3.bounds.x ? s9 : 1 - s9, o9 = r8 * e4.remainingLength + (1 - r8) * e4.backwardLength, n5 = Math.abs(t.x + t.width / 2 - m3.bounds.x), d4 = Math.max(0, this._zoomLevel + Math.log2(n5 / (o9 + z2))), g4 = Math.max(i7, l8 ? 0 : d4);
      if (t.maxZoom = Math.min(u7[1], _2), t.angle = e4.angle + (1 - s9) * Math.PI, t.minZoom = Math.max(u7[0], g4), this._writeLineGlyph(c4, h6, e4.x, e4.y, t, a8, f6, true), (s9 || this._current.offsetDirection) && this._isVisible(t.minZoom, t.maxZoom)) {
        const e5 = new i3(t.bounds.x + b2[0], t.bounds.y + b2[1], t.bounds.width, t.bounds.height);
        c4.metricBoxWrite(e5);
      }
    }
  }
  _placeOnSegment(e4, i7, s9, a8, l8, c4, h6) {
    const { out: m3, id: u7, shaping: f6, referenceBounds: g3 } = this._current, _5 = f6.glyphs, p3 = e4.dx / e4.length, b2 = e4.dy / e4.length, x4 = { x: e4.x + s9 * -l8 * p3, y: e4.y + s9 * -l8 * b2 }, M3 = u(this.evaluatedMeshParams.offsetX), P2 = u(this.evaluatedMeshParams.offsetY), y3 = r2(M3, P2), w2 = M(n2(), -e4.angle);
    S(y3, y3, w2);
    for (const t of _5) {
      const i8 = t.x > f6.bounds.x ? c4 : 1 - c4;
      if (!(i8 && 1 === l8 || !i8 && -1 === l8)) continue;
      const r8 = Math.abs(t.x + t.width / 2 - f6.bounds.x), o9 = Math.max(0, this._zoomLevel + Math.log2(r8 / s9) - 0.1), n5 = Math.max(a8, this._zoomLevel + Math.log2(r8 / (s9 + e4.length + z2)));
      if (0 !== o9 && (t.angle = e4.angle + (1 - c4) * Math.PI, t.minZoom = n5, t.maxZoom = o9, this._writeLineGlyph(m3, u7, x4.x, x4.y, t, h6, g3, true), (c4 || this._current.offsetDirection) && this._isVisible(t.minZoom, t.maxZoom))) {
        const e5 = new i3(t.bounds.x + y3[0], t.bounds.y + y3[1], t.bounds.width, t.bounds.height);
        m3.metricBoxWrite(e5);
      }
    }
  }
  _writeLineGlyph(e4, t, i7, r8, s9, o9, n5, a8) {
    if (i7 < 0 || i7 > o3 || r8 < 0 || r8 > o3) return;
    e4.recordStart(this.instanceId, this.attributeLayout, s9.textureBinding);
    const { texcoords: l8, offsets: c4 } = s9, { fontSize: h6, haloSize: m3, outlineSize: d4 } = this._textMeshTransformProps;
    this._writeQuad(e4, t, i7, r8, { texcoords: l8, offsets: c4, fontSize: h6, haloSize: m3, outlineSize: d4, color: a3(this.evaluatedMeshParams.color), isBackground: false, referenceBounds: n5, minZoom: Math.max(this._current.zoomRange[0], s9.minZoom), maxZoom: Math.min(this._current.zoomRange[1], s9.maxZoom), clipAngle: o9, mapAligned: a8, isLineLabel: true }), e4.recordEnd();
  }
  _packedZoom(e4) {
    return Math.floor(e4 * st) / st;
  }
  _isVisible(e4, t) {
    let i7 = Math.max(this._current.zoomRange[0], e4), r8 = Math.min(this._current.zoomRange[1], t);
    i7 = this._packedZoom(i7), r8 = this._packedZoom(r8);
    const s9 = this._packedZoom(this._zoomLevel);
    return i7 <= s9 && s9 <= r8;
  }
};
function $(e4, t, i7) {
  const { coords: r8, lengths: s9 } = t, o9 = n(), n5 = n(), d4 = n(), f6 = n(), g3 = n(), _5 = n(), p3 = 2;
  let b2 = 0;
  for (let u7 = 0; u7 < s9.length; u7++) {
    const t2 = s9[u7];
    for (let s10 = 0; s10 < t2; s10++) {
      const u8 = p3 * (s10 + b2 - 1), x4 = p3 * (s10 + b2), v4 = p3 * (s10 + b2 + 1);
      s10 > 0 ? o2(o9, r8[u8], r8[u8 + 1]) : o2(o9, 0, 0), o2(n5, r8[x4], r8[x4 + 1]), s10 < t2 - 1 ? o2(d4, r8[v4], r8[v4 + 1]) : o2(d4, 0, 0), 0 === s10 ? o2(f6, 0, 0) : (B(f6, n5, o9), v(f6, f6), o2(f6, f6[1], -f6[0])), s10 === t2 - 1 ? o2(g3, 0, 0) : (B(g3, d4, n5), v(g3, g3), o2(g3, g3[1], -g3[0])), u2(_5, f6, g3), v(_5, _5);
      const M3 = _5[0] * g3[0] + _5[1] * g3[1];
      0 !== M3 && l2(_5, _5, M3), l2(_5, _5, i7), e4.coords.push(n5[0] + _5[0], n5[1] + _5[1]);
    }
    e4.lengths.push(t2), b2 += t2;
  }
  return e4;
}

// node_modules/@arcgis/core/views/2d/layers/features/support/DictionaryValue.js
var r7 = class extends s6 {
  constructor(e4) {
    super(), this._value = e4;
  }
  resize(e4) {
  }
  read(e4, r8) {
    return this._value;
  }
  readWithDefault(e4, r8, t) {
    return this._value;
  }
  hasArcadeDependency(e4) {
    return false;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/mesh/MeshWriterInputEvaluator.js
var y2 = () => i.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator");
async function h5(e4, r8, t, s9) {
  const { defaultValue: o9, valueExpressionInfo: a8, value: i7 } = r8;
  if (a8) {
    if ("dictionary-template" === a8.type) return { ...r8, computed: e4.createDictionaryTemplateField(a8, t), defaultValue: o9 };
    const { expression: i8 } = a8, n5 = await e4.createComputedField({ expression: i8 }, s9);
    return n5 ? { ...r8, computed: n5, defaultValue: o9 } : null;
  }
  return { ...r8, computed: new r7(i7), defaultValue: o9 };
}
async function v3(e4, r8, t) {
  const { valueExpressionInfo: s9 } = r8, o9 = "dictionary-template" === s9.type ? e4.createDictionaryTemplateField(s9, t) : await e4.createComputedField({ expression: s9.expression });
  return o9 ? { ...r8, computed: o9 } : null;
}
function P(e4) {
  return "object" == typeof e4 && null != e4 && (!(!("valueExpressionInfo" in e4) || !e4.valueExpressionInfo) || "type" in e4 && "Process" === e4.type && "op" in e4 && "Random" === e4.op);
}
function _4(e4) {
  if (Array.isArray(e4)) {
    for (const r8 of e4) if (_4(r8)) return true;
  }
  if ("object" == typeof e4) {
    if (P(e4)) return true;
    for (const r8 in e4) {
      if (_4(e4[r8])) return true;
    }
  }
  return false;
}
var I2 = class _I {
  static async create(r8, t, s9, o9) {
    const a8 = {}, i7 = /* @__PURE__ */ new Map(), m3 = /* @__PURE__ */ new Map(), f6 = /* @__PURE__ */ new Map(), l8 = /* @__PURE__ */ new Map(), d4 = /* @__PURE__ */ new Map(), u7 = /* @__PURE__ */ new Map();
    for (const y3 in s9) {
      const I3 = s9[y3];
      if (null != I3 && "object" == typeof I3) if (Array.isArray(I3)) {
        if ("object" == typeof I3[0]) throw new Error(`InternalError: Cannot handle ${y3}. Nested array params are not supported`);
        a8[y3] = I3;
      } else {
        if ("valueExpressionInfo" in I3) {
          if (I3.value) {
            a8[y3] = I3.value;
            continue;
          }
          const e4 = await v3(r8, I3, o9);
          if (!e4) {
            a8[y3] = I3.defaultValue;
            continue;
          }
          i7.set(y3, e4), a8[y3] = null;
          continue;
        }
        switch (I3.type) {
          case "cim-effect-infos":
            if (I3.effectInfos.some((e4) => e4.overrides.length)) {
              m3.set(y3, { effects: await Promise.all(I3.effectInfos.map(async (t2) => {
                const s10 = t2.overrides.map((e4) => h5(r8, e4, o9, false));
                return { effect: t2.effect, compiledOverrides: (await Promise.all(s10)).filter(N) };
              })) });
              break;
            }
            a8[y3] = I3.effectInfos.map((e4) => e4.effect);
            break;
          case "cim-marker-placement-param":
            I3.overrides.length && f6.set(y3, { placementInfo: I3, compiledOverrides: (await Promise.all(I3.overrides.map((e4) => h5(r8, e4, o9, false)))).filter(N) }), a8[y3] = I3.placement;
            break;
          case "text-rasterization-param": {
            if (I3.overrides.length) {
              const t2 = I3.overrides.map((e4) => h5(r8, e4, o9, I3.useLegacyLabelEvaluationRules ?? false));
              l8.set(y3, { compiledOverrides: (await Promise.all(t2)).filter(N), rasterizationParam: I3, objectIdToResourceId: /* @__PURE__ */ new Map() });
              continue;
            }
            const s10 = { type: "cim-rasterization-info", resource: I3.resource };
            a8[y3] = await t.fetchResourceImmediate(s10) ?? null;
            break;
          }
          case "sprite-rasterization-param": {
            if (I3.overrides.length) {
              const t2 = I3.overrides.map((e4) => h5(r8, e4, o9, false));
              l8.set(y3, { compiledOverrides: (await Promise.all(t2)).filter(N), rasterizationParam: I3, objectIdToResourceId: /* @__PURE__ */ new Map() });
              continue;
            }
            if ("animated" === I3.resource.type) {
              l8.set(y3, { compiledOverrides: [], rasterizationParam: I3, objectIdToResourceId: /* @__PURE__ */ new Map() });
              continue;
            }
            const s10 = { type: "cim-rasterization-info", resource: I3.resource };
            a8[y3] = await t.fetchResourceImmediate(s10) ?? null;
            break;
          }
          case "cim-marker-transform-param": {
            const { params: e4 } = I3;
            if (_4(e4)) {
              const t2 = { compiledMarkerInfos: [] };
              await Promise.all(e4.map(async (e5) => {
                const s10 = { props: {} };
                for (const t3 in e5) if (P(e5[t3])) {
                  const a9 = await v3(r8, e5[t3], o9);
                  s10.compiledExpressionMap || (s10.compiledExpressionMap = /* @__PURE__ */ new Map());
                  const i8 = s10.compiledExpressionMap;
                  a9 && i8.set(t3, a9);
                } else s10.props[t3] = e5[t3];
                t2.compiledMarkerInfos.push(s10);
              })), d4.set(y3, t2);
            } else a8[y3] = { type: "cim-marker-transform-info", infos: e4 };
            break;
          }
          case "animation-params": {
            const { params: e4 } = I3, s10 = r4(e4);
            if (_4(s10)) {
              const e5 = await Promise.all(s10.map((e6) => c(e6, r8)));
              u7.set(y3, { params: e5, propertyIdToResourceId: /* @__PURE__ */ new Map(), key: y3 });
            } else {
              const e5 = s3(s10), r9 = await t.fetchResourceImmediate({ type: "animation-info", resource: e5 });
              null != r9 && "sprite" === r9.type && (a8[y3] = { dataRow: r9.rect.y, dataColumn: r9.rect.x });
            }
            break;
          }
          default:
            a8[y3] = I3;
        }
      }
      else a8[y3] = I3;
    }
    return new _I(s9, a8, i7, m3, f6, l8, d4, u7);
  }
  constructor(e4, r8, t, s9, a8, i7, n5, c4) {
    this.inputMeshParams = e4, this._resolvedMeshParams = r8, this._dynamicProperties = t, this._dynamicEffectProperties = s9, this._dynamicPlacementProperties = a8, this._dynamicAsyncProperties = i7, this._dynamicTransformProperties = n5, this._dynamicAsyncAnimations = c4, this.evaluator = (e5) => e5, this._arcadeDependencies = /* @__PURE__ */ new Set();
    for (const p3 of this._expressions()) u3(this._arcadeDependencies, p3);
  }
  get hasDynamicProperties() {
    return !!(this._dynamicProperties.size || this._dynamicAsyncProperties.size || this._dynamicEffectProperties.size || this._dynamicTransformProperties.size || this._dynamicPlacementProperties.size || this._dynamicAsyncAnimations.size);
  }
  get evaluatedMeshParams() {
    return this._evaluatedMeshParams || (this._evaluatedMeshParams = this.evaluator(this._resolvedMeshParams)), this._evaluatedMeshParams;
  }
  enqueueRequest(e4, s9, o9) {
    for (const i7 of this._dynamicAsyncProperties.values()) {
      const c4 = a(i7.rasterizationParam.resource);
      "animated" === i7.rasterizationParam.resource.type && i7.rasterizationParam.resource.randomizeStartTime && (c4.primitiveName = "__RESERVED__PRIMITIVE__NAME__", c4.startGroup = o5(s9.getObjectId() || 0));
      for (const { primitiveName: e5, propertyName: t, computed: a8, defaultValue: m3, valueExpressionInfo: f6 } of i7.compiledOverrides) try {
        const r8 = "animated" === i7.rasterizationParam.resource.type ? c4.primitiveName : e5;
        r3(c4, r8, t, a8, s9, o9, m3);
      } catch (n5) {
        y2().errorOnce(new s("invalid-arcade-expression", "Encountered an error when evaluating the arcade expression", { error: n5, valueExpressionInfo: f6 }));
      }
      const p3 = e4.enqueueRequest({ type: "cim-rasterization-info", resource: c4 });
      i7.objectIdToResourceId.set(s9.getObjectId(), p3);
    }
    for (const r8 of this._dynamicAsyncAnimations.values()) {
      const t = r8.params.map((e5) => l3(e5, s9, o9)).map(n3).map((e5) => e5.simplify()), a8 = a4(t), n5 = e4.enqueueRequest({ type: "animation-info", resource: a8 });
      r8.propertyIdToResourceId.set(s9.getObjectId() + "." + r8.key, n5);
    }
  }
  evaluateMeshParams(e4, r8, t) {
    for (const [s9, o9] of this._dynamicProperties.entries()) this._resolvedMeshParams[s9] = o9.computed.readWithDefault(r8, t, o9.defaultValue);
    for (const [s9, o9] of this._dynamicPlacementProperties.entries()) for (const { computed: e5, defaultValue: a8, propertyName: i7 } of o9.compiledOverrides) {
      const n5 = e5.readWithDefault(r8, t, a8);
      o9.placementInfo.placement[i7] = n5, this._resolvedMeshParams[s9] = o9.placementInfo.placement;
    }
    for (const [s9, o9] of this._dynamicEffectProperties.entries()) for (const e5 of o9.effects) {
      for (const { computed: s10, defaultValue: o10, propertyName: a8 } of e5.compiledOverrides) {
        const i7 = s10.readWithDefault(r8, t, o10);
        e5.effect[a8] = i7;
      }
      this._resolvedMeshParams[s9] = o9.effects.map((e6) => e6.effect);
    }
    for (const [s9, o9] of this._dynamicTransformProperties.entries()) {
      const e5 = { type: "cim-marker-transform-info", infos: [] };
      for (const s10 of o9.compiledMarkerInfos) {
        const o10 = { ...s10.props };
        if (s10.compiledExpressionMap) for (const [e6, a8] of s10.compiledExpressionMap) {
          const s11 = a8.computed.readWithDefault(r8, t, a8.defaultValue);
          o10[e6] = "number" == typeof s11 || "boolean" == typeof s11 ? s11 : a8.defaultValue;
        }
        e5.infos.push(o10);
      }
      this._resolvedMeshParams[s9] = e5;
    }
    for (const [s9, o9] of this._dynamicAsyncProperties.entries()) {
      const t2 = o9.objectIdToResourceId.get(r8.getObjectId());
      if (null == t2) continue;
      const a8 = e4.getResource(t2);
      this._resolvedMeshParams[s9] = a8;
    }
    for (const [s9, o9] of this._dynamicAsyncAnimations.entries()) {
      const t2 = o9.propertyIdToResourceId.get(r8.getObjectId() + "." + s9);
      if (null == t2) continue;
      const a8 = e4.getResource(t2);
      this._resolvedMeshParams[s9] = { dataRow: a8.rect.y, dataColumn: a8.rect.x };
    }
    return this._evaluatedMeshParams = this.evaluator(this._resolvedMeshParams), this.evaluatedMeshParams;
  }
  hasArcadeDependency(e4) {
    return this._arcadeDependencies.has(e4);
  }
  *_expressions() {
    for (const e4 of this._dynamicProperties.values()) yield e4.computed;
    for (const e4 of this._dynamicEffectProperties.values()) for (const r8 of e4.effects) for (const e5 of r8.compiledOverrides) yield e5.computed;
    for (const e4 of this._dynamicPlacementProperties.values()) for (const r8 of e4.compiledOverrides) yield r8.computed;
    for (const e4 of this._dynamicAsyncProperties.values()) for (const r8 of e4.compiledOverrides) yield r8.computed;
    for (const e4 of this._dynamicTransformProperties.values()) for (const r8 of e4.compiledMarkerInfos) if (null != r8.compiledExpressionMap) for (const e5 of r8.compiledExpressionMap.values()) yield e5.computed;
    for (const e4 of this._dynamicAsyncAnimations.values()) for (const r8 of e4.params) yield* f2(r8);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/mesh/MeshWriterRegistry.js
var x3 = class {
  async createMeshWriter(r8, e4, t, i7, s9) {
    const a8 = this._getMeshWriter(i7.techniqueType), o9 = await I2.create(r8, e4, i7.inputParams, s9), n5 = new a8(i7.id, o9, i7.optionalAttributes, t);
    return await n5.loadDependencies(), n5;
  }
  _getMeshWriter(d4) {
    switch (d4) {
      case 13:
        return c2;
      case 11:
        return s5;
      case 9:
        return h2;
      case 26:
        return o7;
      case 14:
        return u5;
      case 24:
        return f4;
      case 27:
        return o8;
      case 10:
        return f5;
      case 21:
        return I;
      case 28:
        return s7;
      case 30:
        return E;
      case 19:
        return T2;
      case 31:
        return l6;
      case 15:
        return l5;
      case 17:
        return i4;
      case 18:
        return F2;
      case 2:
        return b;
      case 3:
        return C;
      case 0:
        return z;
      case 1:
        return T3;
      default:
        throw new Error("Internal Error: Mesh writer not in the registry");
    }
  }
};

export {
  r7 as r,
  x3 as x
};
//# sourceMappingURL=chunk-QHMSLY43.js.map
