import {
  e as e3
} from "./chunk-M5JMVUW2.js";
import {
  S,
  j2 as j,
  k
} from "./chunk-2JMKFI2D.js";
import {
  e as e2
} from "./chunk-Y4O7HJXV.js";
import {
  t
} from "./chunk-YYXR3KOD.js";
import {
  o as o2
} from "./chunk-VYMBX5H5.js";
import {
  e,
  i,
  o
} from "./chunk-QHCKOBU7.js";
import {
  h
} from "./chunk-OPJX4KXH.js";
import {
  s
} from "./chunk-SMWUT52Z.js";
import {
  ae,
  ne
} from "./chunk-NMQNUPE4.js";

// node_modules/@arcgis/core/geometry/support/polygonUtils.js
function i2(r, o3, s2) {
  const n = m(e4, r, o3, s2) ? k(e4) : [0, 0, 1];
  return Math.abs(n[2]) > Math.cos(s(80)) ? 2 : Math.abs(n[1]) > Math.abs(n[0]) ? 1 : 0;
}
function m(t2, a2, n, i3) {
  const m2 = ((t3) => !Array.isArray(t3[0]))(a2) ? (t3, r) => a2[3 * t3 + r] : (t3, r) => a2[t3][r], e5 = i3 ? ae(i3) / ne(i3) : 1;
  return S(t2, (t3, r) => o2(t3, m2(r, 0) * e5, m2(r, 1) * e5, m2(r, 2)), n);
}
var e4 = j();

// node_modules/@arcgis/core/geometry/support/triangulationUtils.js
function c(t2) {
  const r = h2(t2.rings, t2.hasZ, 1, t2.spatialReference), i3 = new Array();
  let c2 = 0, a2 = 0;
  for (const o3 of r.polygons) {
    const t3 = o3.count, l = o3.index, f2 = i(r.position, 3 * l, 3 * t3), h3 = o3.holeIndices.map((n) => n - l), g3 = t(e3(f2, h3, 3));
    i3.push({ position: f2, faces: g3 }), c2 += f2.length, a2 += g3.length;
  }
  const g2 = f(i3, c2, a2), u = Array.isArray(g2.position) ? e2(g2.position, 3, { originalIndices: g2.faces }) : e2(g2.position.buffer, 6, { originalIndices: g2.faces });
  return g2.position = o(new Float64Array(u.buffer)), g2.faces = u.indices, g2;
}
function f(n, t2, e5) {
  if (1 === n.length) return n[0];
  const o3 = e(t2), i3 = new Array(e5);
  let l = 0, c2 = 0, f2 = 0;
  for (const r of n) {
    for (let n2 = 0; n2 < r.position.length; n2++) o3[l++] = r.position[n2];
    for (const n2 of r.faces) i3[c2++] = n2 + f2;
    f2 = l / 3;
  }
  return { position: o3, faces: t(i3) };
}
function h2(n, t2, e5, o3) {
  const s2 = n.length, i3 = new Array(s2), l = new Array(s2), c2 = new Array(s2);
  let f2 = 0;
  for (let r = 0; r < s2; ++r) f2 += n[r].length;
  let h3 = 0, u = 0, p = 0;
  const d = e(3 * f2);
  let m2 = 0;
  for (let r = s2 - 1; r >= 0; r--) {
    const f3 = n[r], y = 1 === e5 && g(f3, t2, o3);
    if (y && 1 !== s2) i3[h3++] = f3;
    else {
      let n2 = f3.length;
      for (let t3 = 0; t3 < h3; ++t3) n2 += i3[t3].length;
      const e6 = { index: m2, pathLengths: new Array(h3 + 1), count: n2, holeIndices: new Array(h3) };
      e6.pathLengths[0] = f3.length, f3.length > 0 && (c2[p++] = { index: m2, count: f3.length }), m2 = y ? a(f3, f3.length - 1, -1, d, m2, f3.length, t2) : a(f3, 0, 1, d, m2, f3.length, t2);
      for (let o4 = 0; o4 < h3; ++o4) {
        const n3 = i3[o4];
        e6.holeIndices[o4] = m2, e6.pathLengths[o4 + 1] = n3.length, n3.length > 0 && (c2[p++] = { index: m2, count: n3.length }), m2 = a(n3, 0, 1, d, m2, n3.length, t2);
      }
      h3 = 0, e6.count > 0 && (l[u++] = e6);
    }
  }
  for (let r = 0; r < h3; ++r) {
    const n2 = i3[r];
    n2.length > 0 && (c2[p++] = { index: m2, count: n2.length }), m2 = a(n2, 0, 1, d, m2, n2.length, t2);
  }
  return l.length = u, c2.length = p, { position: d, polygons: l, outlines: c2 };
}
function a(n, t2, e5, o3, r, s2, i3) {
  r *= 3;
  for (let l = 0; l < s2; ++l) {
    const s3 = n[t2];
    o3[r++] = s3[0], o3[r++] = s3[1], o3[r++] = i3 && s3[2] ? s3[2] : 0, t2 += e5;
  }
  return r / 3;
}
function g(n, e5, o3) {
  if (!e5) return !h(n);
  const r = n.length - 1;
  switch (i2(n, r, o3)) {
    case 0:
      return !h(n, 1, 2);
    case 1:
      return !h(n, 0, 2);
    case 2:
      return !h(n, 0, 1);
  }
}

export {
  i2 as i,
  c,
  h2 as h
};
//# sourceMappingURL=chunk-C7T2CCN3.js.map
