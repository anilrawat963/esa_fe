import {
  h as h2,
  i as i3,
  m as m3,
  s as s3,
  x as x2
} from "./chunk-ECIORIM4.js";
import {
  B,
  D as D3,
  N as N2,
  N2 as N3,
  W as W2,
  ae,
  d,
  h,
  i as i2,
  j as j2,
  l as l4,
  p as p3,
  p2 as p4,
  q,
  u as u2,
  z as z3
} from "./chunk-ETHRUKGL.js";
import {
  C as C2,
  D as D2,
  U,
  b,
  g as g3,
  p as p2,
  r as r3,
  s as s2,
  v,
  y as y3
} from "./chunk-BTNEC6LS.js";
import {
  n as n2,
  t
} from "./chunk-BJUALH6B.js";
import {
  T as T2
} from "./chunk-NEYJ2XGC.js";
import {
  p,
  r as r2
} from "./chunk-L2YWECQ7.js";
import {
  $,
  C,
  H as H2,
  Q,
  W,
  ce,
  fe,
  ie,
  j,
  ne,
  re
} from "./chunk-5RPEIJ7N.js";
import {
  O,
  R,
  a as a2,
  k2 as k,
  l as l2
} from "./chunk-TNGDEFWZ.js";
import {
  D,
  N,
  T,
  l2 as l3,
  u2 as u
} from "./chunk-NQDCX3PB.js";
import {
  g as g2
} from "./chunk-CJAJ4FML.js";
import {
  y as y2
} from "./chunk-CZOYDK6P.js";
import {
  g
} from "./chunk-HCTBVF3W.js";
import {
  _
} from "./chunk-IRBX64M6.js";
import {
  l,
  z as z2
} from "./chunk-YP3WVJP3.js";
import {
  P
} from "./chunk-PZ5RULLK.js";
import {
  z
} from "./chunk-H74Q4SYB.js";
import {
  r
} from "./chunk-7H3U4IJR.js";
import {
  _ as _2
} from "./chunk-AXZMNHTN.js";
import {
  f
} from "./chunk-5T3MJDSR.js";
import {
  G
} from "./chunk-NMQNUPE4.js";
import {
  H2 as H,
  y2 as y
} from "./chunk-V2H77UEV.js";
import {
  o
} from "./chunk-XWE6BM2U.js";
import {
  n
} from "./chunk-XXLHAM2M.js";
import {
  m as m2
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a,
  m,
  x
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  w
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/layers/support/rasterDatasets/BaseRaster.js
var U2 = 8;
var Q2 = 256;
var $2 = 0;
var X = class extends n {
  constructor() {
    super(...arguments), this._tileFetchQueue = new _({ concurrency: 32, process: (e2, t3) => this._fetchRawTile(e2.pyramidLevel, e2.row, e2.col, { ...e2.options, signal: t3 }) }), this.datasetName = null, this.datasetFormat = null, this.hasUniqueSourceStorageInfo = true, this.rasterInfo = null, this.ioConfig = { sampling: "closest" };
  }
  normalizeCtorArgs(e2) {
    return e2?.ioConfig && (e2 = { ...e2, ioConfig: { resolution: null, bandIds: null, sampling: "closest", tileInfo: z2.create(), ...e2.ioConfig } }), e2;
  }
  get _isGlobalWrappableSource() {
    const { rasterInfo: e2 } = this, t3 = $(e2.spatialReference);
    return null != t3 && e2.extent.width >= t3 / 2;
  }
  get _hasNoneOrGCSShiftTransform() {
    const { transform: e2 } = this.rasterInfo;
    return null == e2 || "gcs-shift" === e2.type;
  }
  set rasterJobHandler(e2) {
    this._set("rasterJobHandler", e2), t(this) && this.primaryRasters?.rasters?.forEach((t3) => t3.rasterJobHandler = e2);
  }
  get rasterId() {
    return this.url || "rasterId-" + $2++;
  }
  set url(e2) {
    this._set("url", y(e2, i.getLogger(this)));
  }
  async open(e2) {
    return this._openPromise ??= j().then(() => this._open(e2)), this._openPromise;
  }
  async fetchTile(e2, t3, o3, r5 = {}) {
    const n4 = r5.tileInfo || this.rasterInfo.storageInfo.tileInfo, s4 = this.getTileExtentFromTileInfo(e2, t3, o3, n4);
    if (!s4) throw new s("imagery-tile:out-of-bounds", "Level for fetch tile out of range");
    return r5 = { noClip: true, ...r5 }, this.fetchPixels(s4, n4.size[0], n4.size[1], r5);
  }
  async identify(e2, t3 = {}) {
    e2 = m(_2, e2).clone().normalize();
    const { multidimensionalDefinition: i5, timeExtent: o3 } = t3, { rasterInfo: r5 } = this, { hasMultidimensionalTranspose: n4, multidimensionalInfo: s4 } = r5;
    let { transposedVariableName: l6 } = t3;
    const c2 = null != s4 && n4 && (null != o3 || y3(i5));
    if (c2 && !l6) {
      l6 = null != i5 && i5.length > 0 ? i5[0].variableName ?? void 0 : s4.variables[0].name, t3 = { ...t3, transposedVariableName: l6 };
    }
    t3 = this._getRequestOptionsWithSliceId(t3);
    const { spatialReference: u5, extent: h4 } = r5, { datumTransformation: p6 } = t3;
    let d2 = W(e2, u5, p6);
    if (!h4.intersects(d2)) return { location: d2, value: null };
    if (null != r5.transform) {
      const e3 = r5.transform.inverseTransform(d2);
      if (!r5.nativeExtent.intersects(e3)) return { location: e3, value: null };
      d2 = e3;
    }
    let x3 = 0;
    const y4 = null != l6 && null != s4 && r5.hasMultidimensionalTranspose;
    if (t(this)) {
      const e3 = this.primaryRasters.rasters[0];
      if (y4) return e3.identify(d2, t3);
      const { pixelSize: o4 } = r5, n5 = 3, s5 = o4.x * n5 / 2, l7 = o4.y * n5 / 2, a3 = new z({ xmin: d2.x - s5, xmax: d2.x + s5, ymin: d2.y - l7, ymax: d2.y + l7, spatialReference: u5 }), c3 = { interpolation: "nearest", multidimensionalDefinition: i5, sliceId: t3.sliceId, bandIds: t3.bandIds }, { pixelBlock: m5 } = await e3.fetchPixels(a3, n5, n5, c3), { pixelBlock: h5 } = await this.fetchPixels(a3, n5, n5, c3);
      if (null == m5) return { location: d2, value: null };
      const p7 = Math.floor(n5 * n5 * 0.5), x4 = !m5.mask || m5.mask[p7] ? m5.pixels.map((e4) => e4[p7]) : null;
      let g5;
      return null != h5 && (g5 = !h5.mask || h5.mask[p7] ? h5.pixels.map((e4) => e4[p7]) : void 0), { location: d2, value: x4, processedValue: g5, pyramidLevel: 0 };
    }
    if (!y4) {
      if (t3.srcResolution) {
        x3 = fe(t3.srcResolution, r5, this.ioConfig.sampling).pyramidLevel;
      } else if (x3 = await this.computeBestPyramidLevelForLocation(e2, t3), null == x3) return { location: d2, value: null };
    }
    const g4 = this.identifyPixelLocation(d2, x3, null, y4);
    if (null === g4) return { location: d2, value: null };
    const { row: R2, col: S, rowOffset: b2, colOffset: k2, blockWidth: v2 } = g4, T3 = await this._tileFetchQueue.push({ pyramidLevel: x3, row: R2, col: S, options: t3 }, { signal: t3.signal });
    if (!T3?.pixels?.length) return { location: d2, value: null };
    const P2 = b2 * v2 + k2;
    return this._processIdentifyResult(T3, { srcLocation: d2, position: P2, pyramidLevel: x3, useTransposedTile: !!y4, requestSomeSlices: c2, identifyOptions: t3 });
  }
  async fetchPixels(e2, t3, i5, o3 = {}) {
    e2 = ce(e2), o3 = this._getRequestOptionsWithSliceId(o3);
    const { _hasNoneOrGCSShiftTransform: r5 } = this;
    if (o3.requestRawData && r5) return this._fetchPixels(e2, t3, i5, o3);
    const n4 = $(e2.spatialReference), s4 = ne(e2);
    if (null == n4 || 0 === s4 || 1 === s4 && this._isGlobalWrappableSource && r5) return this._fetchPixels(e2, t3, i5, o3);
    if (s4 >= 3) return { extent: e2, pixelBlock: null };
    const l6 = [], { xmin: a3, xmax: c2 } = e2, m5 = Math.round(n4 / (c2 - a3) * t3), u5 = m5 - Math.round((n4 / 2 - a3) / (c2 - a3) * t3);
    let h4 = 0;
    const p6 = [];
    for (let g4 = 0; g4 <= s4; g4++) {
      const r6 = new z({ xmin: 0 === g4 ? a3 : -n4 / 2, xmax: g4 === s4 ? c2 - n4 * g4 : n4 / 2, ymin: e2.ymin, ymax: e2.ymax, spatialReference: e2.spatialReference }), d3 = 0 === g4 ? m5 - u5 : g4 === s4 ? t3 - h4 : m5;
      h4 += d3, p6.push(d3);
      const x4 = o3.disableWrapAround && g4 > 0 ? null : this._fetchPixels(r6, d3, i5, o3);
      l6.push(x4);
    }
    const d2 = (await Promise.all(l6)).map((e3) => e3?.pixelBlock);
    let x3 = null;
    const y4 = { width: t3, height: i5 };
    if (this.rasterJobHandler) {
      x3 = (await this.rasterJobHandler.mosaicAndTransform({ srcPixelBlocks: d2, srcMosaicSize: y4, destDimension: null, coefs: null, sampleSpacing: null, interpolation: "nearest", alignmentInfo: null, blockWidths: p6 }, o3)).pixelBlock;
    } else x3 = T(d2, y4, { blockWidths: p6 });
    return { extent: e2, srcExtent: H2(e2, this.rasterInfo.spatialReference, o3.datumTransformation), pixelBlock: x3 };
  }
  async fetchRawPixels(e2, t3, i5, o3 = {}) {
    t3 = { x: Math.floor(t3.x), y: Math.floor(t3.y) };
    const r5 = await this._fetchRawTiles(e2, t3, i5, o3), { nativeExtent: n4, nativePixelSize: s4, storageInfo: l6 } = this.rasterInfo, a3 = 2 ** e2, c2 = s4.x * a3, m5 = s4.y * a3, u5 = new z({ xmin: n4.xmin + c2 * t3.x, xmax: n4.xmin + c2 * (t3.x + i5.width - 1), ymin: n4.ymax - m5 * (t3.y + i5.height - 1), ymax: n4.ymax - m5 * t3.y, spatialReference: n4.spatialReference });
    if (!r5) return { extent: u5, srcExtent: u5, pixelBlock: null };
    const { pixelBlocks: h4, mosaicSize: p6 } = r5;
    if (1 === h4.length && null != h4[0] && h4[0].width === i5.width && h4[0].height === i5.height) return { extent: u5, srcExtent: u5, pixelBlock: r5.pixelBlocks[0] };
    const d2 = e2 > 0 ? l6.pyramidBlockWidth : l6.blockWidth, x3 = e2 > 0 ? l6.pyramidBlockHeight : l6.blockHeight, y4 = { x: t3.x % d2, y: t3.y % x3 };
    let g4;
    if (this.rasterJobHandler) {
      g4 = (await this.rasterJobHandler.mosaicAndTransform({ srcPixelBlocks: h4, srcMosaicSize: p6, destDimension: i5, clipOffset: y4, clipSize: i5, coefs: null, sampleSpacing: null, interpolation: o3.interpolation, alignmentInfo: null, blockWidths: null }, o3)).pixelBlock;
    } else g4 = T(h4, p6, { clipOffset: y4, clipSize: i5 });
    return { extent: u5, srcExtent: u5, pixelBlock: g4 };
  }
  fetchRawTile(e2, t3, o3, r5) {
    throw new s("BaseRaster:read-not-implemented", "fetchRawTile() is not implemented");
  }
  computeExtent(e2) {
    return H2(this.rasterInfo.extent, e2);
  }
  decodePixelBlock(e2, t3) {
    return !this.rasterJobHandler || t3.useCanvas ? R(e2, t3) : this.rasterJobHandler.decode({ data: e2, options: t3 });
  }
  async request(e2, i5, o3 = 0) {
    const { customFetchParameters: r5 } = this.ioConfig, { range: n4, query: s4, headers: l6 } = i5;
    o3 = o3 ?? i5.retryCount ?? this.ioConfig.retryCount;
    const a3 = n4 ? { Range: `bytes=${n4.from}-${n4.to}` } : null;
    try {
      return await H(e2, { ...i5, query: { ...s4, ...r5 }, headers: { ...l6, ...a3 } });
    } catch (c2) {
      if (o3 > 0) return o3--, this.request(e2, i5, o3);
      throw c2;
    }
  }
  getSliceIndex(e2) {
    const { multidimensionalInfo: t3 } = this.rasterInfo;
    return null == t3 || null == e2 || 0 === e2.length ? null : C2(e2, t3);
  }
  getTileExtentFromTileInfo(e2, t3, i5, o3) {
    const r5 = o3.lodAt(e2);
    return r5 ? this.getTileExtent({ x: r5.resolution, y: r5.resolution }, t3, i5, o3.origin, o3.spatialReference, o3.size) : null;
  }
  updateTileInfo() {
    const { storageInfo: e2, spatialReference: t3, extent: i5, pixelSize: o3 } = this.rasterInfo, { pyramidResolutions: r5 } = e2;
    if (!e2.tileInfo) {
      const n4 = [], s4 = e2.maximumPyramidLevel || 0;
      let l6 = (o3.x + o3.y) / 2, a3 = 1 / 0.0254 * 96 * l6;
      for (let e3 = 0; e3 <= s4 && (n4.unshift(new l({ level: s4 - e3, resolution: l6, scale: a3 })), e3 !== s4); e3++) if (r5) {
        const t4 = (r5[e3].x + r5[e3].y) / 2;
        a3 *= t4 / l6, l6 = t4;
      } else l6 *= 2, a3 *= 2;
      const c2 = new _2({ x: i5.xmin, y: i5.ymax, spatialReference: t3 });
      e2.tileInfo = new z2({ origin: c2, size: [e2.blockWidth, e2.blockHeight], spatialReference: t3, lods: n4 }), e2.isVirtualTileInfo = true;
    }
  }
  createRemoteDatasetStorageInfo(e2, t3 = 512, i5 = 512, o3) {
    const { width: r5, height: n4, nativeExtent: s4, pixelSize: l6, spatialReference: a3 } = e2, c2 = new _2({ x: s4.xmin, y: s4.ymax, spatialReference: a3 });
    null == o3 && (o3 = Math.max(0, Math.round(Math.log(Math.max(r5, n4)) / Math.LN2 - 8)));
    const f2 = this.computeBlockBoundary(s4, 512, 512, { x: s4.xmin, y: s4.ymax }, [l6], o3);
    e2.storageInfo = new l2({ blockWidth: t3, blockHeight: i5, pyramidBlockWidth: t3, pyramidBlockHeight: i5, origin: c2, firstPyramidLevel: 1, maximumPyramidLevel: o3, blockBoundary: f2 });
  }
  async computeBestPyramidLevelForLocation(e2, t3 = {}) {
    return 0;
  }
  computeBlockBoundary(e2, t3, i5, o3, r5, n4 = 0, s4 = 2) {
    if (1 === r5.length && n4 > 0) {
      r5 = [...r5];
      let { x: e3, y: t4 } = r5[0];
      for (let i6 = 0; i6 < n4; i6++) e3 *= s4, t4 *= s4, r5.push({ x: e3, y: t4 });
    }
    const l6 = [], { x: a3, y: c2 } = o3;
    for (let f2 = 0; f2 < r5.length; f2++) {
      const { x: o4, y: n5 } = r5[f2];
      l6.push({ minCol: Math.floor((e2.xmin - a3 + 0.1 * o4) / t3 / o4), maxCol: Math.floor((e2.xmax - a3 - 0.1 * o4) / t3 / o4), minRow: Math.floor((c2 - e2.ymax + 0.1 * n5) / i5 / n5), maxRow: Math.floor((c2 - e2.ymin - 0.1 * n5) / i5 / n5) });
    }
    return l6;
  }
  getPyramidPixelSize(e2) {
    const { nativePixelSize: t3 } = this.rasterInfo, { pyramidResolutions: i5, pyramidScalingFactor: o3 } = this.rasterInfo.storageInfo;
    if (0 === e2) return t3;
    if (null != i5 && i5.length) return i5[e2 - 1];
    const r5 = o3 ** e2;
    return { x: t3.x * r5, y: t3.y * r5 };
  }
  identifyPixelLocation(e2, t3, i5, o3) {
    const { spatialReference: r5, nativeExtent: n4, storageInfo: s4 } = this.rasterInfo, { maximumPyramidLevel: l6, origin: a3, transposeInfo: c2 } = s4, f2 = o3 && null != c2 ? c2.tileSize[0] : s4.blockWidth, m5 = o3 && null != c2 ? c2.tileSize[1] : s4.blockHeight, u5 = W(e2, r5, i5);
    if (!n4.intersects(u5)) return null;
    if (t3 < 0 || t3 > l6) return null;
    const h4 = this.getPyramidPixelSize(t3), { x: p6, y: d2 } = h4, x3 = (a3.y - u5.y) / d2 / m5, y4 = (u5.x - a3.x) / p6 / f2, g4 = Math.min(m5 - 1, Math.floor((x3 - Math.floor(x3)) * m5)), I = Math.min(f2 - 1, Math.floor((y4 - Math.floor(y4)) * f2));
    return { pyramidLevel: t3, row: Math.floor(x3), col: Math.floor(y4), rowOffset: g4, colOffset: I, blockWidth: f2, srcLocation: u5 };
  }
  getTileExtent(e2, t3, i5, o3, r5, n4) {
    const [s4, l6] = n4, a3 = o3.x + i5 * s4 * e2.x, c2 = a3 + s4 * e2.x, m5 = o3.y - t3 * l6 * e2.y, u5 = m5 - l6 * e2.y;
    return new z({ xmin: a3, xmax: c2, ymin: u5, ymax: m5, spatialReference: r5 });
  }
  getBlockWidthHeight(e2) {
    return { blockWidth: e2 > 0 ? this.rasterInfo.storageInfo.pyramidBlockWidth : this.rasterInfo.storageInfo.blockWidth, blockHeight: e2 > 0 ? this.rasterInfo.storageInfo.pyramidBlockHeight : this.rasterInfo.storageInfo.blockHeight };
  }
  isBlockOutside(e2, t3, i5) {
    const o3 = this.rasterInfo.storageInfo.blockBoundary[e2];
    return !o3 || o3.maxRow < t3 || o3.maxCol < i5 || o3.minRow > t3 || o3.minCol > i5;
  }
  updateImageSpaceRasterInfo(e2) {
    const { pixelSize: t3 } = e2, { width: i5, height: o3 } = e2, r5 = f.WebMercator;
    e2.spatialReference = r5, e2.extent = e2.nativeExtent = new z({ xmin: -0.5, ymax: 0.5, xmax: i5 - 0.5, ymin: 0.5 - o3, spatialReference: r5 }), e2.isPseudoSpatialReference = true, e2.transform = null, e2.pixelSize = new _2({ x: 1, y: 1, spatialReference: r5 });
    const { extent: n4, storageInfo: s4 } = e2;
    if (s4) {
      s4.origin = new _2({ x: n4.xmin, y: n4.ymax, spatialReference: r5 });
      const { pyramidResolutions: i6, tileInfo: o4 } = s4;
      if (i6 && i6.forEach((e3) => {
        e3.x /= t3.x, e3.y /= t3.y;
      }), o4) {
        o4.origin = s4.origin;
        const t4 = (e2.nativePixelSize.x + e2.nativePixelSize.y) / 2;
        o4.lods.forEach((e3, i7) => {
          e3.resolution = t4 * 2 ** i7, e3.scale = 96 * e3.resolution / 0.0254;
        });
      }
    }
  }
  async _fetchPixels(e2, t3, i5, o3 = {}) {
    let r5 = ne(e2);
    if (r5 >= 2) return { extent: e2, pixelBlock: null };
    const n4 = this._getSourceDataInfo(e2, t3, i5, o3), { pyramidLevel: s4, srcResolution: l6, srcExtent: a3, srcWidth: c2, srcHeight: f2, ul: u5 } = n4;
    if (0 === c2 || 0 === f2) return { extent: e2, srcExtent: a3, pixelBlock: null };
    const { rasterInfo: h4 } = this, p6 = h4.transform, d2 = "gcs-shift" === p6?.type, x3 = null != $(e2.spatialReference);
    !d2 && x3 || (r5 = ne(n4.srcExtent, d2));
    const y4 = await this._fetchRawTiles(s4, u5, { width: c2, height: f2, wrapCount: r5 }, o3);
    if (!y4) return { extent: e2, srcExtent: a3, pixelBlock: null };
    const g4 = h4.storageInfo, I = s4 > 0 ? g4.pyramidBlockWidth : g4.blockWidth, R2 = s4 > 0 ? g4.pyramidBlockHeight : g4.blockHeight;
    let { x: w2, y: S } = h4.pixelSize;
    if (s4 > 0) {
      const { pyramidResolutions: e3, pyramidScalingFactor: t4 } = g4;
      if (null != e3 && e3[s4 - 1]) ({ x: w2, y: S } = e3[s4 - 1]);
      else {
        const e4 = t4 ** s4;
        w2 *= e4, S *= e4;
      }
    }
    const b2 = h4.spatialReference, k2 = new _2({ x: w2, y: S, spatialReference: b2 }), v2 = I === c2 && R2 === f2 && u5.x % I === 0 && u5.y % R2 === 0, T3 = new _2({ x: (e2.xmax - e2.xmin) / t3, y: (e2.ymax - e2.ymin) / i5, spatialReference: e2.spatialReference }), P2 = !e2.spatialReference.equals(b2), B2 = b2.isGeographic ? 1e-9 : 1e-4, { datumTransformation: _3 } = o3;
    if (!P2 && v2 && 1 === y4.pixelBlocks.length && I === t3 && R2 === i5 && K(l6, T3, B2)) return { extent: e2, srcExtent: a3, srcTilePixelSize: k2, pixelBlock: y4.pixelBlocks[0] };
    const M = x3 && null != $(a3.spatialReference) && this._hasNoneOrGCSShiftTransform, C3 = o3.requestProjectedLocalDirections && this.rasterInfo.dataType.startsWith("vector");
    C3 && !this.rasterJobHandler && await j();
    const E = this.rasterJobHandler ? await this.rasterJobHandler.getProjectionOffsetGrid({ projectedExtent: e2, srcBufferExtent: y4.extent, pixelSize: T3.toJSON(), datumTransformation: _3, rasterTransform: p6, hasWrapAround: r5 > 0 || M, isAdaptive: false !== this.ioConfig.optimizeProjectionAccuracy, includeGCSGrid: C3 }, o3) : re({ projectedExtent: e2, srcBufferExtent: y4.extent, pixelSize: T3, datumTransformation: _3, rasterTransform: p6, hasWrapAround: r5 > 0 || M, isAdaptive: false, includeGCSGrid: C3 });
    let D4;
    const O2 = !o3.requestRawData, A = { rows: E.spacing[0], cols: E.spacing[1] }, q2 = this._hasNoneOrGCSShiftTransform ? this._getRasterTileAlignmentInfo(s4, y4.extent.xmin) : void 0, { pixelBlocks: N4, mosaicSize: V, isPartiallyFilled: U3 } = y4;
    let Q4 = null;
    if (this.rasterJobHandler) {
      const e3 = await this.rasterJobHandler.mosaicAndTransform({ srcPixelBlocks: N4, srcMosaicSize: V, destDimension: O2 ? { width: t3, height: i5 } : null, coefs: O2 ? E.coefficients : null, sampleSpacing: O2 ? A : null, projectDirections: C3, gcsGrid: C3 ? E.gcsGrid : null, isUV: "vector-uv" === this.rasterInfo.dataType, interpolation: o3.interpolation, alignmentInfo: q2, blockWidths: null }, o3);
      ({ pixelBlock: D4, localNorthDirections: Q4 } = e3);
    } else {
      const e3 = T(N4, V, { alignmentInfo: q2 });
      D4 = O2 ? N(e3, { width: t3, height: i5 }, E.coefficients, A, o3.interpolation) : e3, C3 && E.gcsGrid && (Q4 = D({ width: t3, height: i5 }, E.gcsGrid), D4 = u(D4, this.rasterInfo.dataType, Q4));
    }
    return o3.requestRawData || C3 ? { extent: e2, srcExtent: a3, srcTilePixelSize: k2, pixelBlock: D4, transformGrid: E, localNorthDirections: Q4, isPartiallyFilled: U3 } : { extent: e2, srcExtent: a3, srcTilePixelSize: k2, pixelBlock: D4 };
  }
  async _fetchRawTiles(e2, t3, i5, o3) {
    const { origin: r5, blockBoundary: n4 } = this.rasterInfo.storageInfo, { blockWidth: s4, blockHeight: l6 } = this.getBlockWidthHeight(e2);
    let { x: a3, y: c2 } = t3, { width: m5, height: u5, wrapCount: h4 } = i5;
    const p6 = this._getRasterTileAlignmentInfo(e2, 0);
    o3.buffer && (a3 -= o3.buffer.cols, c2 -= o3.buffer.rows, m5 += 2 * o3.buffer.cols, u5 += 2 * o3.buffer.rows);
    let d2 = 0, x3 = 0, y4 = 0;
    if (h4 && null != p6) {
      ({ worldColumnCountFromOrigin: x3, originColumnOffset: y4, rightPadding: d2 } = p6);
      x3 * p6.blockWidth - d2 >= a3 + m5 && (d2 = 0);
    }
    const g4 = Math.floor(a3 / s4), I = Math.floor(c2 / l6), R2 = Math.floor((a3 + m5 + d2 - 1) / s4), w2 = Math.floor((c2 + u5 + d2 - 1) / l6), S = n4[e2];
    if (!S) return null;
    const { minRow: b2, minCol: k2, maxCol: v2, maxRow: T3 } = S;
    if (0 === h4 && (w2 < b2 || R2 < k2 || I > T3 || g4 > v2)) return null;
    const P2 = new Array();
    let B2 = false;
    const _3 = null == this.ioConfig.allowPartialFill ? o3.allowPartialFill : this.ioConfig.allowPartialFill;
    for (let f2 = I; f2 <= w2; f2++) for (let t4 = g4; t4 <= R2; t4++) {
      let i6 = t4;
      if (!o3.disableWrapAround && h4 && null != p6 && x3 <= t4 && (i6 = t4 - x3 - y4), f2 >= b2 && i6 >= k2 && T3 >= f2 && v2 >= i6) {
        const t5 = this._tileFetchQueue.push({ pyramidLevel: e2, row: f2, col: i6, options: o3 }, { signal: o3.signal });
        _3 ? P2.push(new Promise((e3) => {
          t5.then((t6) => e3(t6)).catch(() => {
            B2 = true, e3(null);
          });
        })) : P2.push(t5);
      } else P2.push(Promise.resolve(null));
    }
    if (0 === P2.length) return null;
    const M = await Promise.all(P2), C3 = { height: (w2 - I + 1) * l6, width: (R2 - g4 + 1) * s4 }, { spatialReference: W3 } = this.rasterInfo, L = this.getPyramidPixelSize(e2), { x: j3, y: z4 } = L;
    return { extent: new z({ xmin: r5.x + g4 * s4 * j3, xmax: r5.x + (R2 + 1) * s4 * j3, ymin: r5.y - (w2 + 1) * l6 * z4, ymax: r5.y - I * l6 * z4, spatialReference: W3 }), pixelBlocks: M, mosaicSize: C3, isPartiallyFilled: B2 };
  }
  _fetchRawTile(e2, t3, i5, o3) {
    const { storageInfo: r5 } = this.rasterInfo, s4 = null != r5.transposeInfo && !!o3.transposedVariableName;
    if (!s4) {
      const o4 = r5.blockBoundary[e2];
      if (!o4) return Promise.resolve(null);
      const { minRow: n4, minCol: s5, maxCol: l7, maxRow: a4 } = o4;
      if (t3 < n4 || i5 < s5 || t3 > a4 || i5 > l7) return Promise.resolve(null);
    }
    const l6 = s4 ? o3.transposeVariableName : o3.sliceId, a3 = this.rasterInfo.storageInfo.isBsqTile ? o3.bandIds : null, c2 = i3(this.rasterId, l6, a3), f2 = `${e2}/${t3}/${i5}`;
    let m5 = m3(c2, o3.registryId, f2);
    if (null == m5) {
      const r6 = new AbortController();
      m5 = this.fetchRawTile(e2, t3, i5, { ...o3, signal: r6.signal }), h2(c2, o3.registryId, f2, m5, r6), m5.catch(() => x2(c2, o3.registryId, f2));
    }
    return o3.signal && w(o3, () => {
      s3(c2, o3.registryId, f2);
    }), m5;
  }
  _computeMagDirValues(e2) {
    const { bandCount: t3, dataType: i5 } = this.rasterInfo;
    if (!(2 === t3 && "vector-magdir" === i5 || "vector-uv" === i5) || 2 !== e2?.length || !e2[0]?.length) return null;
    const o3 = e2[0].length;
    if ("vector-magdir" === i5) {
      const t4 = e2[1].map((e3) => (e3 + 360) % 360);
      return [e2[0], t4];
    }
    const [r5, n4] = e2, s4 = [], l6 = [];
    for (let a3 = 0; a3 < o3; a3++) {
      const [e3, t4] = l3([r5[a3], n4[a3]]);
      s4.push(e3), l6.push(t4);
    }
    return [s4, l6];
  }
  _getRasterTileAlignmentInfo(e2, t3) {
    return null == this._rasterTileAlignmentInfo && (this._rasterTileAlignmentInfo = ie(this.rasterInfo)), null == this._rasterTileAlignmentInfo.pyramidsInfo ? null : { startX: t3, halfWorldWidth: this._rasterTileAlignmentInfo.halfWorldWidth, hasGCSSShiftTransform: this._rasterTileAlignmentInfo.hasGCSSShiftTransform, ...this._rasterTileAlignmentInfo.pyramidsInfo[e2] };
  }
  _getSourceDataInfo(e2, t3, i5, o3 = {}) {
    const r5 = { datumTransformation: o3.datumTransformation, pyramidLevel: 0, pyramidResolution: null, srcExtent: null, srcHeight: 0, srcResolution: null, srcWidth: 0, ul: { x: 0, y: 0 } };
    o3.srcResolution && (r5.srcResolution = o3.srcResolution, this._updateSourceDataInfo(e2, r5));
    const n4 = this.rasterInfo.storageInfo.maximumPyramidLevel || 0, { srcWidth: s4, srcHeight: l6, pyramidLevel: a3 } = r5, c2 = s4 / t3, f2 = l6 / i5, u5 = a3 < n4 && c2 * f2 >= 16, h4 = a3 === n4 && this._requireTooManySrcTiles(s4, l6, t3, i5);
    if (u5 || h4 || (0 === s4 || 0 === l6)) {
      const s5 = new _2({ x: (e2.xmax - e2.xmin) / t3, y: (e2.ymax - e2.ymin) / i5, spatialReference: e2.spatialReference });
      let l7 = C(s5, this.rasterInfo.spatialReference, e2, r5.datumTransformation);
      const h5 = !l7 || o3.srcResolution && l7.x + l7.y < o3.srcResolution.x + o3.srcResolution.y;
      if (u5 && o3.srcResolution && h5) {
        const e3 = Math.round(Math.log(Math.max(c2, f2)) / Math.LN2) - 1;
        if (n4 - a3 + 3 >= e3) {
          const t4 = 2 ** e3;
          l7 = { x: o3.srcResolution.x * t4, y: o3.srcResolution.y * t4 };
        }
      }
      l7 && (r5.srcResolution = l7, this._updateSourceDataInfo(e2, r5));
    }
    return this._requireTooManySrcTiles(r5.srcWidth, r5.srcHeight, t3, i5) && (r5.srcWidth = 0, r5.srcHeight = 0), r5;
  }
  _requireTooManySrcTiles(e2, t3, i5, o3) {
    const { tileInfo: r5 } = this.rasterInfo.storageInfo, n4 = Math.ceil(e2 / r5.size[0]) * Math.ceil(t3 / r5.size[1]), s4 = e2 / i5, l6 = t3 / o3, a3 = Math.max(1, (i5 + o3) / 1024);
    return n4 >= Q2 * a3 || s4 > U2 || l6 > U2;
  }
  _updateSourceDataInfo(e2, t3) {
    t3.srcWidth = 0, t3.srcHeight = 0;
    const { rasterInfo: i5 } = this, o3 = i5.spatialReference, { srcResolution: r5, datumTransformation: n4 } = t3, { pyramidLevel: s4, pyramidResolution: l6, excessiveReading: a3 } = fe(r5, i5, this.ioConfig.sampling);
    if (a3) return;
    let c2 = t3.srcExtent || H2(e2, o3, n4);
    if (null == c2) return;
    const f2 = i5.transform;
    f2 && (c2 = f2.inverseTransform(c2)), t3.srcExtent = c2;
    const { origin: m5 } = i5.storageInfo, { width: u5, height: h4, ul: p6 } = n2(c2, m5, l6, s4);
    t3.pyramidLevel = s4, t3.pyramidResolution = l6, t3.srcWidth = u5, t3.srcHeight = h4, t3.ul = p6;
  }
  _getRequestOptionsWithSliceId(e2) {
    return null != this.rasterInfo.multidimensionalInfo && null == e2.sliceId && (e2 = { ...e2, sliceId: this.getSliceIndex(e2.multidimensionalDefinition) }), e2;
  }
  _processIdentifyResult(e2, t3) {
    const { srcLocation: i5, position: o3, pyramidLevel: r5, useTransposedTile: n4 } = t3, s4 = e2.pixels[0].length / e2.width / e2.height;
    if (!(!e2.mask || e2.mask[o3])) return { location: i5, value: null };
    const { multidimensionalInfo: l6 } = this.rasterInfo;
    if (null == l6 || !n4) {
      const t4 = e2.pixels.map((e3) => e3[o3]), n5 = { location: i5, value: t4, pyramidLevel: r5 }, s5 = this._computeMagDirValues(t4.map((e3) => [e3]));
      return s5?.length && (n5.magdirValue = s5.map((e3) => e3[0])), n5;
    }
    let a3 = e2.pixels.map((e3) => e3.slice(o3 * s4, o3 * s4 + s4)), c2 = this._computeMagDirValues(a3);
    const { requestSomeSlices: f2, identifyOptions: m5 } = t3;
    let u5 = s2(l6, m5.transposedVariableName);
    if (f2) {
      const e3 = r3(u5, m5.multidimensionalDefinition, m5.timeExtent);
      a3 = a3.map((t4) => e3.map((e4) => t4[e4])), c2 = c2?.map((t4) => e3.map((e4) => t4[e4])), u5 = e3.map((e4) => u5[e4]);
    }
    const h4 = e2.noDataValues || this.rasterInfo.noDataValue, p6 = { pixels: a3, pixelType: e2.pixelType };
    let x3;
    null != h4 && (g2(p6, h4), x3 = p6.mask);
    return { location: i5, value: null, dataSeries: u5.map((e3, t4) => {
      const i6 = { value: 0 === x3?.[t4] ? null : a3.map((e4) => e4[t4]), multidimensionalDefinition: e3.multidimensionalDefinition.map((e4) => new p2({ ...e4, isSlice: true })) };
      return c2?.length && (i6.magdirValue = [c2[0][t4], c2[1][t4]]), i6;
    }), pyramidLevel: r5 };
  }
};
function K(e2, t3, i5) {
  return Math.abs(e2.x - t3.x) < i5 && Math.abs(e2.y - t3.y) < i5;
}
__decorate([m2()], X.prototype, "_rasterTileAlignmentInfo", void 0), __decorate([m2()], X.prototype, "_tileFetchQueue", void 0), __decorate([m2({ readOnly: true })], X.prototype, "_isGlobalWrappableSource", null), __decorate([m2({ readOnly: true })], X.prototype, "_hasNoneOrGCSShiftTransform", null), __decorate([m2()], X.prototype, "_openPromise", void 0), __decorate([m2()], X.prototype, "rasterJobHandler", null), __decorate([m2({ readOnly: true })], X.prototype, "rasterId", null), __decorate([m2(y2)], X.prototype, "url", null), __decorate([m2({ type: String, json: { write: true } })], X.prototype, "datasetName", void 0), __decorate([m2({ type: String, json: { write: true } })], X.prototype, "datasetFormat", void 0), __decorate([m2()], X.prototype, "hasUniqueSourceStorageInfo", void 0), __decorate([m2()], X.prototype, "rasterInfo", void 0), __decorate([m2()], X.prototype, "ioConfig", void 0), __decorate([m2()], X.prototype, "sourceJSON", void 0), X = __decorate([a("esri.layers.support.rasterDatasets.BaseRaster")], X);

// node_modules/@arcgis/core/layers/support/rasterDatasets/FunctionRaster.js
var p5 = 40;
var m4 = class extends X {
  constructor() {
    super(...arguments), this.datasetFormat = "Function", this.tileType = "Raster", this.rasterFunction = null, this._clippingGeometry = /* @__PURE__ */ new Map();
  }
  async fetchPixels(t3, e2, r5, s4 = {}) {
    const { rasters: i5, rasterIds: o3 } = this.primaryRasters;
    let l6 = false;
    const { interpolation: c2 } = s4, p6 = this.rasterFunction.flatWebGLFunctionChain?.hasFocalFunction;
    !s4.requestRawData && p6 && (l6 = 1 === i5.length && !s4.skipRasterFunction, s4 = { ...s4, interpolation: "bilinear", requestRawData: l6 }), s4.requestRawData && i5.length > 1 && !this.hasUniqueSourceStorageInfo && (l6 = false, s4 = { ...s4, requestRawData: false });
    const m5 = i5.map((i6) => i6.fetchPixels(t3, e2, r5, s4)), u5 = await Promise.all(m5), h4 = u5.map((t4) => t4.pixelBlock), d2 = l6 || s4.requestRawData ? u5.map((t4) => t4.srcTilePixelSize) : null;
    if (s4.skipRasterFunction || h4.every((t4) => null == t4)) return u5[0];
    const f2 = u5.find((t4) => null != t4.pixelBlock)?.extent ?? t3;
    let y4 = this.rasterJobHandler ? await this.rasterJobHandler.process({ extent: f2, primaryPixelBlocks: h4, primaryPixelSizes: d2, primaryRasterIds: o3 }) : this.rasterFunction.process({ extent: f2, primaryPixelBlocks: h4, primaryPixelSizes: d2, primaryRasterIds: o3 });
    const { transformGrid: g4 } = u5[0];
    if (!l6 || null == y4 || null == g4) {
      const t4 = s4.noClip ? null : this.getClippingGeometry(f2.spatialReference);
      return !s4.noClip && null != y4 && t4 && (y4 = await r2(y4, f2, t4)), { ...u5[0], pixelBlock: y4 };
    }
    const x3 = { rows: g4.spacing[0], cols: g4.spacing[1] };
    let R2;
    if (this.rasterJobHandler) {
      R2 = (await this.rasterJobHandler.mosaicAndTransform({ srcPixelBlocks: [y4], srcMosaicSize: { width: y4.width, height: y4.height }, destDimension: { width: e2, height: r5 }, coefs: g4.coefficients, sampleSpacing: x3, projectDirections: false, gcsGrid: null, isUV: false, interpolation: c2, alignmentInfo: void 0, blockWidths: null }, s4)).pixelBlock;
    } else R2 = N(y4, { width: e2, height: r5 }, g4.coefficients, x3, c2);
    const w2 = s4.noClip ? null : this.getClippingGeometry(t3.spatialReference);
    return s4.noClip || null == R2 || null == w2 || (R2 = await r2(R2, t3, w2)), { extent: t3, srcExtent: u5[0].srcExtent, pixelBlock: R2 };
  }
  getClippingGeometry(t3) {
    const e2 = this._clippingGeometry.get("0");
    if (!t3 || !e2) return e2;
    const r5 = h3(t3);
    let s4 = this._clippingGeometry.get(r5);
    return null != s4 || (s4 = t3.equals(e2.spatialReference) ? e2 : Q(e2, t3), this._clippingGeometry.set(r5, s4)), s4;
  }
  async _open(t3) {
    const { rasterFunction: r5 } = this;
    r5.isRoot = true, this.primaryRasters?.rasters?.length ? r5.sourceRasters = this.primaryRasters.rasters : (this.primaryRasters = r5.getPrimaryRasters(), this.rasterJobHandler && this.primaryRasters.rasters?.forEach((t4) => t4.rasterJobHandler = this.rasterJobHandler));
    const { rasters: s4, rasterIds: i5 } = this.primaryRasters, o3 = s4.map((e2) => e2.rasterInfo ? void 0 : e2.open(t3));
    await Promise.all(o3);
    const a3 = s4.map(({ rasterInfo: t4 }) => t4), n4 = r5.bind({ rasterInfos: a3, rasterIds: i5 });
    if (r5.rawSourceRasterInfos = a3, !n4.success || 0 === a3.length) throw new s("raster-function:open", `cannot bind the function: ${n4.error ?? ""}`);
    const l6 = "Table" === r5.functionName ? r5 : r5.functionArguments?.raster;
    "Table" === l6?.functionName && (r5.rasterInfo.attributeTable = g.fromJSON(l6.functionArguments.attributeTableAsRecordSet)), await this.syncJobHandler();
    const p6 = a3[0];
    this.hasUniqueSourceStorageInfo = 1 === a3.length || a3.slice(1).every((t4) => u3(t4, p6)), this.set("sourceJSON", s4[0].sourceJSON), this.set("rasterInfo", r5.rasterInfo), await this._updateClipGeometry();
  }
  async syncJobHandler() {
    return this.rasterJobHandler?.updateRasterFunction(this.rasterFunction);
  }
  async _updateClipGeometry() {
    const t3 = this.rasterFunction.getClippingGeometries()[0];
    let e2 = t3?.clippingGeometry;
    if (e2 && "inside" === t3.clippingType) {
      const { extent: t4 } = this.rasterInfo, r5 = await import("./densifyOperator-WZ67EQPF.js"), s4 = await import("./differenceOperator-MFTG55RR.js");
      let o3 = r5.execute(P.fromExtent(t4), 2 * (t4.width + t4.height) / p5);
      o3 = Q(o3, e2.spatialReference), e2 = s4.execute(o3, e2);
    }
    this._clippingGeometry.clear(), e2 && this._clippingGeometry.set("0", e2);
  }
};
function u3(t3, e2) {
  const { storageInfo: r5, pixelSize: s4, spatialReference: i5, extent: o3 } = t3, { storageInfo: a3, pixelSize: n4, spatialReference: l6, extent: c2 } = e2;
  return s4.x === n4.x && s4.y === n4.y && i5.equals(l6) && o3.equals(c2) && r5.blockHeight === a3.blockHeight && r5.blockWidth === a3.blockWidth && r5.maximumPyramidLevel === a3.maximumPyramidLevel && r5.firstPyramidLevel === a3.firstPyramidLevel && r5.pyramidBlockWidth === a3.pyramidBlockWidth && r5.pyramidBlockHeight === a3.pyramidBlockHeight && r5.pyramidScalingFactor === a3.pyramidScalingFactor;
}
function h3(t3) {
  return String(t3.wkid ?? t3.wkt ?? t3.wkt2);
}
__decorate([m2({ type: String, json: { write: true } })], m4.prototype, "datasetFormat", void 0), __decorate([m2()], m4.prototype, "tileType", void 0), __decorate([m2()], m4.prototype, "rasterFunction", void 0), __decorate([m2()], m4.prototype, "primaryRasters", void 0), m4 = __decorate([a("esri.layers.support.rasterDatasets.FunctionRaster")], m4);

// node_modules/@arcgis/core/layers/mixins/ImageryTileMixin.js
var Q3 = 1e3;
var X2 = (X3) => {
  const Y = X3;
  let Z = class extends Y {
    constructor(...e2) {
      super(...e2), this._isConstructedFromFunctionRaster = false, this.bandIds = null, this.copyright = null, this.interpolation = null, this.multidimensionalSubset = null, this.raster = null, this.serviceRasterInfo = null, this.sourceJSON = null, this.spatialReference = null, this.symbolizer = null, this._isConstructedFromFunctionRaster = t(e2[0]?.raster);
    }
    destroy() {
      this._shutdownJobHandler();
    }
    get fullExtent() {
      return this.serviceRasterInfo?.extent;
    }
    set multidimensionalDefinition(e2) {
      this._set("multidimensionalDefinition", e2), this.updateRenderer();
    }
    set rasterFunction(e2) {
      "none" === e2?.functionName?.toLowerCase() && (e2 = void 0), this._set("rasterFunction", e2), this.updateRasterFunction();
    }
    set url(e2) {
      this._set("url", y(e2, i.getLogger(this)));
    }
    get renderer() {
      if ("imagery-tile" !== this.type) return this.internalRenderer;
      const { activePresetRendererName: e2, presetRenderers: t3 } = this;
      if (e2) {
        const i5 = t3?.find(({ name: t4 }) => t4 === e2);
        return i5?.renderer.clone();
      }
      return this.internalRenderer;
    }
    set renderer(e2) {
      "imagery-tile" === this.type && (this.activePresetRendererName = null), this.internalRenderer = e2;
    }
    set internalRenderer(e2) {
      null == e2 && null == this.rasterFunction ? this._configDefaultRenderer("override") : (this._set("internalRenderer", e2), this.updateRenderer());
    }
    readRenderer(e2, t3, i5) {
      const r5 = t3?.layerDefinition?.drawingInfo?.renderer;
      return d(r5, i5) || void 0;
    }
    async computeStatisticsHistograms(e2, t3) {
      await this.load(t3), e2 = m(j2, e2).clone();
      const { serviceRasterInfo: r5 } = this;
      if (null == r5) throw new s("imagery-tile-mixin:compute-statistics-histograms", "serviceRasterInfo must be specified");
      const { geometry: s4 } = e2;
      if (null == s4) throw new s("imagery-tile-mixin:compute-statistics-histograms", "geometry must be specified");
      let n4 = s4;
      const { spatialReference: a3 } = r5;
      if (!s4.spatialReference.equals(a3)) {
        await j();
        const e3 = "extent" === s4.type ? H2(s4, a3) : Q(s4, a3);
        if (null == e3) throw new s("imagery-tile-mixin:compute-statistics-histograms", "geometry cannot be projected to the data source");
        n4 = e3;
      }
      const l6 = e2.pixelSize ?? new _2({ x: r5.pixelSize.x, y: r5.pixelSize.y, spatialReference: a3 }), { extent: u5, width: c2, height: p6 } = p(r5, n4, l6), d2 = await this.fetchPixels(u5, c2, p6, { ...t3, interpolation: "nearest" });
      if (null == d2.pixelBlock) throw new s("imagery-tile-mixin:compute-statistics-histograms", "failed to fetch pixels");
      const h4 = await r2(d2.pixelBlock, u5, n4), f2 = this._rasterJobHandler;
      return f2 ? f2.computeStatisticsHistograms({ pixelBlock: h4 }, t3) : k(h4);
    }
    normalizeRasterFetchOptions(e2) {
      const { multidimensionalInfo: t3 } = this.serviceRasterInfo ?? {};
      if (null == t3) return e2;
      const i5 = g3({ rasterInfo: this.raster.rasterInfo, multidimensionalDefinition: e2.multidimensionalDefinition || this.multidimensionalDefinition, timeExtent: e2.timeExtent ?? this.timeExtent, multidimensionalSubset: this.multidimensionalSubset });
      return { ...e2, multidimensionalDefinition: i5, timeExtent: void 0 };
    }
    async updateRasterFunction() {
      return this.loaded && "imagery-tile" === this.type && (this.rasterFunction || this._cachedRasterFunctionJson) && JSON.stringify(this.rasterFunction) !== JSON.stringify(this._cachedRasterFunctionJson) ? (this._cachedRasterFunctionJson = this.rasterFunction?.toJSON(), this._rasterFunctionUpdatePromise = this._updateRasterFunction(), this._rasterFunctionUpdatePromise) : this._rasterFunctionUpdatePromise;
    }
    async updateRenderer() {
      const { loaded: e2, symbolizer: t3, renderer: i5 } = this;
      if (!e2 || !t3 || !i5) return;
      const { rasterInfo: r5 } = this.raster, s4 = v(r5, { multidimensionalDefinition: this.multidimensionalDefinition, multidimensionalSubset: this.multidimensionalSubset }), n4 = s4?.name, o3 = D3(r5, n4);
      return this._updateSymbolizer(t3, i5, n4, o3);
    }
    async applyRenderer(e2, t3, i5) {
      const r5 = e2?.pixelBlock;
      if (!(null != r5 && r5.pixels && r5.pixels.length > 0)) return null;
      await this.updateRenderer();
      const s4 = this.bandIds ?? [], { pixelBlock: n4 } = await this._symbolize({ pixelData: e2, simpleStretchParams: t3, bandIds: s4, symbolizer: this.symbolizer }, i5);
      return n4;
    }
    getRawDisplayBandIds() {
      let { bandIds: e2, raster: t3 } = this;
      if (this.rasterFunction && t(t3)) {
        const i5 = t3.rasterFunction.rawInputBandIds;
        e2 = e2?.length && i5?.length && 1 !== t3.rasterInfo.bandCount ? e2.map((e3) => i5[Math.min(e3, i5.length - 1)]) : i5;
      }
      return e2 && e2.length > 3 && e2.every((e3, t4) => e3 === t4) ? null : e2;
    }
    getTileUrl(e2, t3, i5) {
      return "RasterTileServer" === this.raster.datasetFormat ? `${this.url}/tile/${e2}/${t3}/${i5}` : "";
    }
    getCompatibleTileInfo(e2, t3, i5 = false) {
      if (!this.loaded || null == t3) return null;
      if (i5 && e2.equals(this.spatialReference)) return this.tileInfo;
      const r5 = G(e2);
      return z2.create({ size: 256, spatialReference: e2, origin: r5 ? { x: r5.origin[0], y: r5.origin[1] } : { x: t3.xmin, y: t3.ymax } });
    }
    getCompatibleFullExtent(e2) {
      return this.loaded ? (this._compatibleFullExtent?.spatialReference.equals(e2) || (this._compatibleFullExtent = this.raster.computeExtent(e2)), this._compatibleFullExtent) : null;
    }
    async fetchTile(e2, i5, r5, s4 = {}) {
      if (ee(this), s4.requestAsImageElement) {
        const n5 = this.getTileUrl(e2, i5, r5);
        return H(n5, { responseType: "image", query: { ...this.refreshParameters, ...this.raster.ioConfig.customFetchParameters }, signal: s4.signal }).then((e3) => e3.data);
      }
      const { serviceRasterInfo: n4 } = this;
      if (null != n4.multidimensionalInfo && null == (s4 = this.normalizeRasterFetchOptions(s4)).multidimensionalDefinition) {
        const t3 = s4.tileInfo || n4.storageInfo.tileInfo, o3 = this.raster.getTileExtentFromTileInfo(e2, i5, r5, t3);
        if (o3) return { extent: o3, pixelBlock: null };
      }
      return await this._initJobHandler(), await this.updateRasterFunction(), "raster-shaded-relief" === this.renderer?.type && (s4 = { ...s4, buffer: { cols: 1, rows: 1 } }), this.raster.fetchTile(e2, i5, r5, s4);
    }
    async fetchPixels(e2, t3, i5, r5 = {}) {
      if (null != this.serviceRasterInfo.multidimensionalInfo && null == (r5 = this.normalizeRasterFetchOptions(r5)).multidimensionalDefinition) return { extent: e2, pixelBlock: null };
      await this._initJobHandler(), await this.updateRasterFunction(), t3 = Math.round(t3), i5 = Math.round(i5);
      const s4 = await this.raster.fetchPixels(e2, t3, i5, r5);
      return r5.bandIds?.length && !this.raster.rasterInfo.storageInfo.isBsqTile && (s4.pixelBlock = s4.pixelBlock?.extractBands(r5.bandIds)), s4;
    }
    async getSamples(e2, t3) {
      if (await this.load(), (e2 = m(h, e2).clone()).interpolation && "nearest" !== e2.interpolation) throw new s("imagery-tile-mixin:get-samples", "only nearest interpolation is currently supported");
      const r5 = e2.mosaicRule?.multidimensionalDefinition, s4 = { ...t3, multidimensionalDefinition: r5 }, n4 = (await this._getSampleLocations(e2)).map((e3) => this.identify(e3, s4).then((t4) => (t4.location = e3, t4))), a3 = (await Promise.all(n4)).flatMap((e3, t4) => this._convertRasterIdentifyResultToSample(e3, t4));
      return new p4({ samples: a3 });
    }
    async identify(e2, t3 = {}) {
      await this.load(), e2 = m(_2, e2).clone().normalize();
      const { raster: r5, serviceRasterInfo: s4 } = this;
      if (null != s4?.multidimensionalInfo) {
        if (!(s4.hasMultidimensionalTranspose && !(!y3(t3.multidimensionalDefinition) && !t3.transposedVariableName)) && null == (t3 = this.normalizeRasterFetchOptions(t3)).multidimensionalDefinition) return { location: e2, value: null };
      }
      const n4 = this.multidimensionalSubset?.areaOfInterest;
      if (n4 && !n4.contains(e2)) throw new s("imagery-tile-mixin:identify", "the request cannot be fulfilled when falling outside of the multidimensional subset");
      let a3;
      if (this.serviceRasterInfo?.storageInfo.isBsqTile) {
        const e3 = t(r5) ? this.getRawDisplayBandIds() : this.bandIds;
        a3 = e3?.length ? e3 : void 0;
      }
      return r5.identify(e2, { ...t3, bandIds: a3 });
    }
    hasStandardTime() {
      const e2 = this.serviceRasterInfo?.multidimensionalInfo;
      if (null == e2 || "standard-time" !== this.serviceRasterInfo?.dataType) return false;
      const t3 = this.multidimensionalDefinition, i5 = t3?.[0]?.variableName;
      return e2.variables.some((e3) => e3.name === i5 && (!t3?.[0].dimensionName || e3.dimensions.some((e4) => "StdTime" === e4.name)));
    }
    getStandardTimeValue(e2) {
      return new Date(U(e2)).toISOString();
    }
    getMultidimensionalSubsetVariables(e2) {
      const t3 = e2 ?? this.serviceRasterInfo?.multidimensionalInfo;
      return D2(this.multidimensionalSubset, t3);
    }
    _configDefaultSettings() {
      this._configDefaultInterpolation(), this.multidimensionalDefinition || (this.multidimensionalDefinition = b(this.raster.rasterInfo, { multidimensionalSubset: this.multidimensionalSubset })), this.rasterFunction && t(this.raster) && (this._cachedRasterFunctionJson = this.rasterFunction.toJSON()), this._configDefaultRenderer();
    }
    async _initJobHandler() {
      if (!this._rasterJobHandler) return super._initJobHandler().then(async () => {
        if (!this._rasterJobHandler) return;
        ee(this);
        const { raster: e2 } = this;
        e2.rasterJobHandler = this._rasterJobHandler, t(e2) && e2.syncJobHandler(), this.rasterFunction && await this.updateRasterFunction().catch(() => {
        }), this.renderer && this.updateRenderer();
      }).catch(() => {
      });
    }
    _shutdownJobHandler() {
      super._shutdownJobHandler(), this.raster && (this.raster.rasterJobHandler = null);
    }
    async _getSampleLocations(e2) {
      const { geometry: t3 } = e2;
      if ("point" === t3.type) return [t3];
      const { spatialReference: i5, type: r5 } = t3;
      if ("multipoint" === r5) return t3.points.map((e3) => new _2({ x: e3[0], y: e3[1], spatialReference: i5 }));
      if ("polyline" === r5) {
        let r6 = t3;
        if (e2.sampleCount || e2.sampleDistance) {
          const i6 = await import("./densifyOperator-WZ67EQPF.js"), s5 = (await import("./lengthOperator-IB7SX5PM.js")).execute(t3, { unit: "meters" }), n5 = Math.min(e2.sampleCount || 100, Q3);
          let o4 = e2.sampleDistance;
          if (!o4) {
            o4 = s5 / (n5 + (2 === r6.paths[0].length ? 1 : 0));
          }
          r6 = i6.execute(t3, o4, { unit: "meters" });
        }
        return r6.paths.flatMap((e3) => e3.map((e4) => new _2({ x: e4[0], y: e4[1], spatialReference: i5 })));
      }
      const s4 = Math.min(e2.sampleCount || 100, Q3), n4 = "extent" === t3.type, o3 = n4 ? t3 : t3.extent, a3 = Math.sqrt(o3.width * o3.height / s4), l6 = o3.height / a3, u5 = o3.width / a3, { xmin: c2, ymax: p6 } = o3, d2 = [];
      for (let h4 = 0; h4 < l6; h4++) for (let e3 = 0; e3 < u5; e3++) {
        const r6 = new _2({ x: c2 + (e3 + 0.5) * a3, y: p6 - (h4 + 0.5) * a3, spatialReference: i5 });
        (n4 || t3.contains(r6)) && d2.push(r6);
      }
      return d2;
    }
    _configDefaultInterpolation() {
      if (null == this.interpolation) {
        ee(this);
        const { raster: e2 } = this, t3 = N3(e2.rasterInfo, e2.tileType, this.sourceJSON?.defaultResamplingMethod);
        this._set("interpolation", t3);
      }
    }
    _configDefaultRenderer(e2 = "no") {
      ee(this);
      const { rasterInfo: t3 } = this.raster, i5 = v(t3, { multidimensionalDefinition: this.multidimensionalDefinition, multidimensionalSubset: this.multidimensionalSubset }), s4 = i5?.name, n4 = q({ variableName: s4, rasterFunctionName: this.rasterFunction?.functionName, presetRenderers: this.presetRenderers });
      if (!this.bandIds && t3.bandCount > 1 && (this.bandIds = n4?.bandIds ?? W2(t3)), !this.renderer || "override" === e2) {
        const e3 = z3(this.raster), i6 = n4?.renderer ?? B(t3, { bandIds: this.bandIds, variableName: s4, rasterFunctionColorRamp: e3 }), r5 = t3.statistics, o4 = r5 && r5.length > 0 ? r5[0] : null, a4 = o4?.max ?? 0, l7 = o4?.min ?? 0;
        "WCSServer" === this.raster.datasetFormat && "raster-stretch" === i6.type && (a4 > 1e24 || l7 < -1e24) && (i6.dynamicRangeAdjustment = true, i6.customStatistics = null, "none" === i6.stretchType && (i6.stretchType = "min-max")), this.renderer = i6;
      }
      const o3 = ae({ ...this.renderer.toJSON(), variableName: s4 }), a3 = D3(t3, s4);
      this.symbolizer ? (this.symbolizer.rendererJSON = o3, this.symbolizer.rasterInfo = a3) : this.symbolizer = new O({ rendererJSON: o3, rasterInfo: a3 });
      const l6 = this.symbolizer.bind();
      if (l6.success) {
        if ("auto" === e2) {
          const { colormap: e3 } = this.raster.rasterInfo, t4 = this.renderer;
          if (null != e3 && "raster-colormap" === t4.type) {
            const e4 = B(this.raster.rasterInfo);
            JSON.stringify(e4) !== JSON.stringify(t4) && this._configDefaultRenderer("override");
          } else if ("raster-stretch" === t4.type) {
            const e4 = this.bandIds?.length, i6 = t4.customStatistics?.length;
            !t4.dynamicRangeAdjustment && i6 && e4 && i6 !== e4 && this._configDefaultRenderer("override");
          }
        }
      } else i.getLogger(this).warn("imagery-tile-mixin", l6.error || "The given renderer is not supported by the layer."), "auto" === e2 && this._configDefaultRenderer("override");
    }
    async _updateRasterFunction() {
      if (this._isConstructedFromFunctionRaster && t(this.raster)) {
        const e3 = this.raster.rasterFunction.toJSON();
        return void (!this.rasterFunction && e3 && this._set("rasterFunction", N2.fromJSON(e3)));
      }
      let e2, t3 = this.raster, i5 = false;
      t(t3) ? (e2 = t3.primaryRasters.rasters, t3 = e2[0], i5 = true) : e2 = [t3];
      const { rasterFunction: r5 } = this;
      if (r5) {
        const i6 = { raster: t3 };
        e2.length > 1 && e2.forEach((e3) => i6[e3.url] = e3);
        const s5 = T2(r5.functionDefinition?.toJSON() ?? r5.toJSON(), i6), n5 = new m4({ rasterFunction: s5 });
        n5.rasterJobHandler = this._rasterJobHandler, await n5.open(), this.raster = n5;
      } else this.raster = t3, await t3.open();
      if (this._cachedRendererJson = void 0, !i5 && !r5) return;
      const { bandIds: s4 } = this, { bandCount: n4 } = this.raster.rasterInfo, o3 = s4?.length ? s4.some((e3) => e3 >= n4) : n4 >= 3;
      s4 && (o3 || this.renderer && "raster-stretch" !== this.renderer.type) && this._set("bandIds", null), this._configDefaultRenderer("auto");
    }
    _convertRasterIdentifyResultToSample(e2, t3) {
      const { rasterInfo: i5 } = this.raster, r5 = i5.storageInfo.pyramidScalingFactor ** (e2.pyramidLevel ?? 0), s4 = (i5.pixelSize.x + i5.pixelSize.y) / 2 * r5;
      if (!e2.dataSeries?.length) return [new i2({ location: e2.location, pixelValue: e2.value, locationId: t3, resolution: s4 })];
      const n4 = [];
      return e2.dataSeries.forEach(({ value: i6, multidimensionalDefinition: r6 }, o3) => {
        const a3 = { Variables: r6[0].variableName, Dimensions: r6.flatMap(({ dimensionName: e3 }) => e3).join(",") };
        for (const { dimensionName: e3, values: t4 } of r6) {
          a3[e3] = Array.isArray(t4[0]) ? t4[0][0] : t4[0];
          const i7 = t4[t4.length - 1];
          a3[`${e3}_Max`] = Array.isArray(i7) ? i7[i7.length - 1] : i7;
        }
        const l6 = new i2({ location: e2.location, pixelValue: i6, rasterId: o3, locationId: t3, resolution: s4, attributes: a3 });
        n4.push(l6);
      }), n4;
    }
  };
  function ee(e2) {
    if (!e2.raster || !e2.serviceRasterInfo) throw new s("imagery-tile", "no raster");
  }
  return __decorate([m2({ clonable: false })], Z.prototype, "_cachedRasterFunctionJson", void 0), __decorate([m2({ clonable: false })], Z.prototype, "_compatibleFullExtent", void 0), __decorate([m2({ clonable: false })], Z.prototype, "_isConstructedFromFunctionRaster", void 0), __decorate([m2({ clonable: false })], Z.prototype, "_rasterFunctionUpdatePromise", void 0), __decorate([m2({ type: [x], json: { write: { overridePolicy() {
    return { enabled: !this.loaded || "Raster" === this.raster.tileType || "0,1,2" !== this.bandIds?.join(",") };
  } } } })], Z.prototype, "bandIds", void 0), __decorate([m2({ json: { origins: { service: { read: { source: "copyrightText" } } } } })], Z.prototype, "copyright", void 0), __decorate([m2({ json: { read: false } })], Z.prototype, "fullExtent", null), __decorate([m2({ json: { write: { overridePolicy() {
    return { enabled: !this.loaded || "Raster" === this.raster.tileType || "bilinear" !== this.interpolation };
  } } } }), r(a2)], Z.prototype, "interpolation", void 0), __decorate([m2()], Z.prototype, "ioConfig", void 0), __decorate([m2({ type: [p2], json: { write: true } })], Z.prototype, "multidimensionalDefinition", null), __decorate([m2({ type: u2, json: { write: true } })], Z.prototype, "multidimensionalSubset", void 0), __decorate([m2()], Z.prototype, "raster", void 0), __decorate([m2({ type: N2 })], Z.prototype, "rasterFunction", null), __decorate([m2()], Z.prototype, "serviceRasterInfo", void 0), __decorate([m2()], Z.prototype, "sourceJSON", void 0), __decorate([m2({ readOnly: true, type: f, json: { read: false } })], Z.prototype, "spatialReference", void 0), __decorate([m2({ type: z2 })], Z.prototype, "tileInfo", void 0), __decorate([m2(y2)], Z.prototype, "url", null), __decorate([m2()], Z.prototype, "renderer", null), __decorate([m2({ types: l4, json: { name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy() {
    const e2 = "raster-stretch" === this.renderer?.type && "none" === this.renderer.stretchType && !this.renderer.useGamma;
    return { enabled: !this.loaded || "Raster" === this.raster.tileType || !e2 };
  } }, origins: { "web-scene": { types: p3, name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy: (e2) => ({ enabled: e2 && "vector-field" !== e2.type }) } } } } })], Z.prototype, "internalRenderer", null), __decorate([o("internalRenderer")], Z.prototype, "readRenderer", null), __decorate([m2({ clonable: false })], Z.prototype, "symbolizer", void 0), Z = __decorate([a("esri.layers.mixins.ImageryTileMixin")], Z), Z;
};

// node_modules/@arcgis/core/layers/support/rasterDatasets/xmlUtilities.js
function n3(e2, t3) {
  if (!e2 || !t3) return [];
  let l6 = t3;
  t3.includes("/") ? (l6 = t3.slice(0, t3.indexOf("/")), t3 = t3.slice(t3.indexOf("/") + 1)) : t3 = "";
  const r5 = [];
  if (t3) {
    const u6 = n3(e2, l6);
    for (let e3 = 0; e3 < u6.length; e3++) {
      n3(u6[e3], t3).forEach((n4) => r5.push(n4));
    }
    return r5;
  }
  const u5 = e2.getElementsByTagNameNS("*", l6);
  if (!u5 || 0 === u5.length) return [];
  for (let n4 = 0; n4 < u5.length; n4++) r5.push(u5[n4] || u5.item(n4));
  return r5;
}
function e(t3, l6) {
  if (!t3 || !l6) return null;
  let r5 = l6;
  l6.includes("/") ? (r5 = l6.slice(0, l6.indexOf("/")), l6 = l6.slice(l6.indexOf("/") + 1)) : l6 = "";
  const u5 = n3(t3, r5);
  return u5.length > 0 ? l6 ? e(u5[0], l6) : u5[0] : null;
}
function t2(n4, t3 = null) {
  const l6 = t3 ? e(n4, t3) : n4;
  let r5;
  return l6 ? (r5 = l6.textContent || l6.nodeValue, r5 ? r5.trim() : null) : null;
}
function l5(e2, t3) {
  const l6 = n3(e2, t3), r5 = [];
  let u5;
  for (let n4 = 0; n4 < l6.length; n4++) u5 = l6[n4].textContent || l6[n4].nodeValue, u5 && (u5 = u5.trim(), "" !== u5 && r5.push(u5));
  return r5;
}
function r4(n4, e2 = null) {
  const l6 = t2(n4, e2);
  return l6?.split(" ").map((n5) => Number(n5)) ?? [];
}
function u4(n4, e2) {
  return l5(n4, e2).map((n5) => Number(n5));
}
function o2(n4, e2) {
  const l6 = t2(n4, e2);
  return Number(l6);
}
function i4(n4, e2) {
  const t3 = n4?.nodeName?.toLowerCase(), l6 = e2.toLowerCase();
  return t3.slice(t3.lastIndexOf(":") + 1) === l6;
}
function c(n4) {
  return n4.nodeName.slice(n4.nodeName.lastIndexOf(":") + 1);
}

export {
  X,
  m4 as m,
  X2,
  n3 as n,
  e,
  t2 as t,
  l5 as l,
  r4 as r,
  u4 as u,
  o2 as o,
  i4 as i,
  c
};
//# sourceMappingURL=chunk-GWWDVBTJ.js.map
