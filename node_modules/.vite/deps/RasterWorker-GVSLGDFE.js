import {
  n,
  t,
  u as u3
} from "./chunk-JBBUE342.js";
import {
  T as T2
} from "./chunk-NEYJ2XGC.js";
import "./chunk-L2YWECQ7.js";
import {
  j as j2,
  re
} from "./chunk-5RPEIJ7N.js";
import {
  O,
  R,
  k2 as k,
  y
} from "./chunk-TNGDEFWZ.js";
import {
  D,
  E,
  N,
  T,
  W,
  f2 as f,
  j,
  u,
  u2
} from "./chunk-NQDCX3PB.js";
import {
  c as c3
} from "./chunk-QW7RJMQR.js";
import {
  c2
} from "./chunk-CJAJ4FML.js";
import "./chunk-DY7N5RAZ.js";
import "./chunk-XTEXJOLG.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import "./chunk-233ALXRM.js";
import "./chunk-QZQPB5XR.js";
import "./chunk-AQFRVV3U.js";
import "./chunk-PMGS7UDU.js";
import "./chunk-GD4FJL3C.js";
import "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import {
  c
} from "./chunk-6YRQYUCY.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-3FUHCAX3.js";
import "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import {
  z
} from "./chunk-H74Q4SYB.js";
import "./chunk-CCQFL76O.js";
import "./chunk-GY6YF4EN.js";
import {
  r
} from "./chunk-7H3U4IJR.js";
import "./chunk-SMWUT52Z.js";
import {
  _
} from "./chunk-AXZMNHTN.js";
import "./chunk-5T3MJDSR.js";
import "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import "./chunk-GNMPGHLQ.js";
import "./chunk-QY7XKUIV.js";
import "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/layers/support/rasterTransforms/IdentityTransform.js
var e;
var p = e = class extends t {
  constructor() {
    super(...arguments), this.type = "identity";
  }
  clone() {
    return new e();
  }
};
__decorate([r({ IdentityXform: "identity" })], p.prototype, "type", void 0), p = e = __decorate([a("esri.layers.support.rasterTransforms.IdentityTransform")], p);

// node_modules/@arcgis/core/layers/support/rasterTransforms/utils.js
var n2 = { GCSShiftXform: n, IdentityXform: p, PolynomialXform: u3 };
function f2(r2) {
  const o = r2?.type;
  if (!o) return null;
  const t2 = n2[r2?.type];
  if (t2) {
    const o2 = new t2();
    return o2.read(r2), o2;
  }
  return null;
}

// node_modules/@arcgis/core/layers/support/RasterWorker.js
function B(e2) {
  if (!e2) return { result: null, transferList: [] };
  const { pixelBlock: r2, transferList: t2 } = e2.getTransferableObject();
  return { result: r2, transferList: t2 };
}
var N2 = class {
  convertVectorFieldData(e2) {
    const r2 = c2.fromJSON(e2.pixelBlock), t2 = B(f(r2, e2.type));
    return Promise.resolve(t2);
  }
  convertPixelBlockToFeatures(r2) {
    const t2 = j({ pixelBlock: c2.fromJSON(r2.pixelBlock), extent: z.fromJSON(r2.extent), fieldNames: r2.fieldNames, skipFactor: r2.skipFactor, skipSpatialReference: true, pixelIdOffset: r2.pixelIdOffset, imageRowSize: r2.imageRowSize });
    return Promise.resolve(t2);
  }
  computeStatisticsHistograms(e2) {
    const r2 = c2.fromJSON(e2.pixelBlock), t2 = k(r2, { histogramSize: e2.histogramSize, includeSkewnessKurtosis: e2.includeSkewnessKurtosis });
    return Promise.resolve(t2);
  }
  async decode(e2) {
    return B(await R(e2.data, e2.options));
  }
  symbolize(r2) {
    r2.pixelBlock = c2.fromJSON(r2.pixelBlock), r2.extent = r2.extent ? z.fromJSON(r2.extent) : null;
    const t2 = B(this.symbolizer.symbolize(r2));
    return Promise.resolve(t2);
  }
  highlightPixels(e2) {
    const r2 = c2.fromJSON(e2.pixelBlock), t2 = c2.fromJSON(e2.renderedPixelBlock);
    return u(r2, t2, e2.highlightOptions), Promise.resolve(t2.toJSON());
  }
  async updateSymbolizer(e2) {
    this.symbolizer = O.fromJSON(e2.symbolizerJSON), e2.histograms && "rasterStretch" === this.symbolizer?.rendererJSON.type && (this.symbolizer.rendererJSON.histograms = e2.histograms);
  }
  async updateRasterFunction(e2) {
    this.rasterFunction = T2(e2.rasterFunctionJSON);
  }
  async process(t2) {
    return B(this.rasterFunction.process({ extent: z.fromJSON(t2.extent), primaryPixelBlocks: t2.primaryPixelBlocks.map((e2) => null != e2 ? c2.fromJSON(e2) : null), primaryPixelSizes: t2.primaryPixelSizes?.map((e2) => null != e2 ? _.fromJSON(e2) : null), primaryRasterIds: t2.primaryRasterIds }));
  }
  stretch(e2) {
    const r2 = B(this.symbolizer.simpleStretch(c2.fromJSON(e2.srcPixelBlock), e2.stretchParams));
    return Promise.resolve(r2);
  }
  estimateStatisticsHistograms(e2) {
    const r2 = y(c2.fromJSON(e2.srcPixelBlock));
    return Promise.resolve(r2);
  }
  split(e2) {
    const r2 = W(c2.fromJSON(e2.srcPixelBlock), e2.tileSize, e2.maximumPyramidLevel ?? 0, false === e2.useBilinear), t2 = [];
    let o;
    return r2 && (o = /* @__PURE__ */ new Map(), r2.forEach((e3, r3) => {
      if (e3) {
        const { pixelBlock: s, transferList: i } = e3.getTransferableObject();
        o.set(r3, s), i.forEach((e4) => {
          t2.includes(e4) || t2.push(e4);
        });
      }
    })), Promise.resolve({ result: o, transferList: t2 });
  }
  clipTile(e2) {
    const r2 = c2.fromJSON(e2.pixelBlock), t2 = B(E({ ...e2, pixelBlock: r2 }));
    return Promise.resolve(t2);
  }
  async mosaicAndTransform(e2) {
    const r2 = e2.srcPixelBlocks.map((e3) => e3 ? new c2(e3) : null), t2 = T(r2, e2.srcMosaicSize, { blockWidths: e2.blockWidths, alignmentInfo: e2.alignmentInfo, clipOffset: e2.clipOffset, clipSize: e2.clipSize });
    let o, i = t2;
    e2.coefs && (i = N(t2, e2.destDimension, e2.coefs, e2.sampleSpacing, e2.interpolation)), e2.projectDirections && e2.gcsGrid && (o = D(e2.destDimension, e2.gcsGrid), i = u2(i, e2.isUV ? "vector-uv" : "vector-magdir", o));
    const { result: n3, transferList: l } = B(i);
    return { result: { pixelBlock: n3, localNorthDirections: o }, transferList: l };
  }
  async createFlowMesh(e2, r2) {
    const t2 = { data: new Float32Array(e2.flowData.buffer), mask: new Uint8Array(e2.flowData.maskBuffer), width: e2.flowData.width, height: e2.flowData.height }, { vertexData: s, indexData: o } = await c3(e2.meshType, e2.simulationSettings, t2, r2.signal);
    return { result: { vertexBuffer: s.buffer, indexBuffer: o.buffer }, transferList: [s.buffer, o.buffer] };
  }
  async getProjectionOffsetGrid(r2) {
    const s = z.fromJSON(r2.projectedExtent), o = z.fromJSON(r2.srcBufferExtent);
    let i = null;
    r2.datumTransformationSteps?.length && (i = new c({ steps: r2.datumTransformationSteps })), await j2();
    const n3 = r2.rasterTransform ? f2(r2.rasterTransform) : null;
    return re({ ...r2, projectedExtent: s, srcBufferExtent: o, datumTransformation: i, rasterTransform: n3 });
  }
};
export {
  N2 as default
};
//# sourceMappingURL=RasterWorker-GVSLGDFE.js.map
