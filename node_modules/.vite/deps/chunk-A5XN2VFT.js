import {
  S,
  b,
  r,
  z
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/core/heapSort.js
var o = (o3, t2, n3, e2) => {
  let i = t2, c = t2;
  const l2 = n3 >>> 1, d = o3[i - 1];
  for (; c <= l2; ) {
    c = i << 1, c < n3 && e2(o3[c - 1], o3[c]) < 0 && ++c;
    const t3 = o3[c - 1];
    if (e2(t3, d) <= 0) break;
    o3[i - 1] = t3, i = c;
  }
  o3[i - 1] = d;
};
var t = (o3, t2) => o3 < t2 ? -1 : o3 > t2 ? 1 : 0;
function n(n3, e2, i, c) {
  void 0 === e2 && (e2 = 0), void 0 === i && (i = n3.length), void 0 === c && (c = t);
  for (let t2 = i >>> 1; t2 > e2; t2--) o(n3, t2, i, c);
  const l2 = e2 + 1;
  for (let t2 = i - 1; t2 > e2; t2--) {
    const i2 = n3[e2];
    n3[e2] = n3[t2], n3[t2] = i2, o(n3, l2, t2, c);
  }
}
function* e(n3, e2, i, c) {
  void 0 === e2 && (e2 = 0), void 0 === i && (i = n3.length), void 0 === c && (c = t);
  for (let t2 = i >>> 1; t2 > e2; t2--) o(n3, t2, i, c), yield;
  const l2 = e2 + 1;
  for (let t2 = i - 1; t2 > e2; t2--) {
    const i2 = n3[e2];
    n3[e2] = n3[t2], n3[t2] = i2, o(n3, l2, t2, c), yield;
  }
}

// node_modules/@arcgis/core/core/PooledArray.js
var l = 1.5;
var n2 = 1.1;
var r2 = class {
  constructor(h) {
    this.data = [], this._length = 0, this._allocator = void 0, this._deallocator = () => null, this._shrink = () => {
    }, this._hint = new b(), h && (h.initialSize && (this.data = new Array(h.initialSize)), h.allocator && (this._allocator = h.allocator), void 0 !== h.deallocator && (this._deallocator = h.deallocator), h.shrink && (this._shrink = () => o2(this)));
  }
  toArray() {
    return this.data.slice(0, this.length);
  }
  filter(t2) {
    const h = new Array();
    for (let i = 0; i < this._length; i++) {
      const s = this.data[i];
      t2(s) && h.push(s);
    }
    return h;
  }
  at(t2) {
    if ((t2 = Math.trunc(t2) || 0) < 0 && (t2 += this._length), !(t2 < 0 || t2 >= this._length)) return this.data[t2];
  }
  includes(t2, h) {
    const i = this.data.indexOf(t2, h);
    return -1 !== i && i < this.length;
  }
  get length() {
    return this._length;
  }
  set length(t2) {
    if (t2 > this._length) {
      if (this._allocator) {
        for (; this._length < t2; ) this.data[this._length++] = this._allocator(this.data[this._length]);
        return;
      }
      this._length = t2;
    } else {
      if (this._deallocator) for (let h = t2; h < this._length; ++h) this.data[h] = this._deallocator(this.data[h]);
      this._length = t2, this._shrink();
    }
  }
  clear() {
    this.length = 0;
  }
  prune() {
    this.clear(), this.data = [];
  }
  push(t2) {
    this.data[this._length++] = t2;
  }
  pushArray(t2, h = t2.length) {
    for (let i = 0; i < h; i++) this.data[this._length++] = t2[i];
  }
  fill(t2, h) {
    for (let i = 0; i < h; i++) this.data[this._length++] = t2;
  }
  pushNew() {
    this._allocator && (this.data[this.length] = this._allocator(this.data[this.length]));
    const t2 = this.data[this._length];
    return ++this._length, t2;
  }
  unshift(t2) {
    this.data.unshift(t2), this._length++, o2(this);
  }
  pop() {
    if (0 === this.length) return;
    const t2 = this.data[this.length - 1];
    return this.length = this.length - 1, this._shrink(), t2;
  }
  remove(t2) {
    const i = S(this.data, r(t2), this.length, this._hint);
    if (-1 !== i) return this.data.splice(i, 1), this.length = this.length - 1, t2;
  }
  removeUnordered(t2) {
    return this.removeUnorderedIndex(S(this.data, r(t2), this.length, this._hint));
  }
  removeUnorderedIndex(t2) {
    if (!(t2 >= this.length || t2 < 0)) return this.swapElements(t2, this.length - 1), this.pop();
  }
  removeUnorderedMany(t2, h = t2.length, s) {
    this.length = z(this.data, t2, this.length, h, this._hint, s), this._shrink();
  }
  front() {
    if (0 !== this.length) return this.data[0];
  }
  back() {
    if (0 !== this.length) return this.data[this.length - 1];
  }
  swapElements(t2, h) {
    if (t2 >= this.length || h >= this.length || t2 === h) return;
    const i = this.data[t2];
    this.data[t2] = this.data[h], this.data[h] = i;
  }
  sort(t2) {
    n(this.data, 0, this.length, t2);
  }
  iterableSort(t2) {
    return e(this.data, 0, this.length, t2);
  }
  some(t2, h) {
    for (let i = 0; i < this.length; ++i) if (t2.call(h, this.data[i], i, this.data)) return true;
    return false;
  }
  find(t2, h) {
    const { data: i, length: s } = this;
    for (let a = 0; a < s; ++a) if (t2.call(h, i[a])) return i[a];
  }
  filterInPlace(t2, h) {
    let i = 0;
    for (let s = 0; s < this._length; ++s) {
      const a = this.data[s];
      t2.call(h, a, s, this.data) && (this.data[s] = this.data[i], this.data[i] = a, i++);
    }
    if (this._deallocator) for (let s = i; s < this._length; s++) this.data[s] = this._deallocator(this.data[s]);
    return this._length = i, this._shrink(), this;
  }
  forAll(t2, h) {
    const { data: i, length: s } = this;
    for (let a = 0; a < s; ++a) t2.call(h, i[a], a, i);
  }
  forEach(t2, h) {
    this.data.slice(0, this.length).forEach(t2, h);
  }
  map(t2, h) {
    const i = new Array(this.length);
    for (let s = 0; s < this.length; ++s) i[s] = t2.call(h, this.data[s], s, this.data);
    return i;
  }
  reduce(t2, h) {
    let i = h;
    for (let s = 0; s < this.length; ++s) i = t2(i, this.data[s], s, this.data);
    return i;
  }
  has(t2) {
    const h = this.length, i = this.data;
    for (let s = 0; s < h; ++s) if (i[s] === t2) return true;
    return false;
  }
  *[Symbol.iterator]() {
    for (let t2 = 0; t2 < this.length; t2++) yield this.data[t2];
  }
};
function o2(t2) {
  t2.data.length > l * t2.length && (t2.data.length = Math.floor(t2.length * n2));
}

export {
  r2 as r
};
//# sourceMappingURL=chunk-A5XN2VFT.js.map
