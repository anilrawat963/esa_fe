import {
  g
} from "./chunk-LPZJF2LT.js";
import "./chunk-XBGTYNWI.js";
import "./chunk-GUGACYLU.js";
import "./chunk-K5WXOTTP.js";
import {
  C,
  i,
  l,
  m as m3,
  u as u3,
  w
} from "./chunk-C6XCOYU5.js";
import {
  h,
  m as m2
} from "./chunk-BTFBYI67.js";
import "./chunk-D3G5WIRR.js";
import {
  k
} from "./chunk-Q3JOE7TC.js";
import "./chunk-DRHU543D.js";
import "./chunk-F7RQDGE7.js";
import "./chunk-GG4AQJJO.js";
import "./chunk-OGWYK5MD.js";
import "./chunk-U5TTP5E5.js";
import "./chunk-QENBEP2X.js";
import "./chunk-VZQ643XD.js";
import "./chunk-SMJWJAIA.js";
import "./chunk-SIUG2XLL.js";
import {
  E
} from "./chunk-XTEXJOLG.js";
import "./chunk-NH6FXYCM.js";
import "./chunk-YE4E5JCT.js";
import "./chunk-SXZO7ULH.js";
import "./chunk-VNSHGTPN.js";
import "./chunk-S5ZM63JC.js";
import "./chunk-EK7HOTRR.js";
import "./chunk-U73R3I4U.js";
import "./chunk-VGXUPJSS.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import "./chunk-EKZRA6TO.js";
import "./chunk-M5SP6ZBM.js";
import "./chunk-2HGIYEIL.js";
import "./chunk-GCI4MA3M.js";
import "./chunk-SJ2OBYX2.js";
import "./chunk-MDJNYPVI.js";
import "./chunk-Z6VKIQV2.js";
import "./chunk-4PXNA4MD.js";
import "./chunk-B5A4L35M.js";
import "./chunk-52SEOH5H.js";
import "./chunk-UYMV6HXW.js";
import "./chunk-JE2NJSBU.js";
import "./chunk-WCWUUHUV.js";
import {
  c
} from "./chunk-MUBG7EZN.js";
import "./chunk-6IHS6RYH.js";
import "./chunk-OJBEN6CV.js";
import "./chunk-TU5E6NPS.js";
import "./chunk-Q5KWD3VQ.js";
import "./chunk-BUQC3CLV.js";
import "./chunk-67Q6KVC6.js";
import {
  S
} from "./chunk-23NJHA5Q.js";
import "./chunk-4LA6K4VI.js";
import "./chunk-KEZCWFAR.js";
import "./chunk-JZUJ34RR.js";
import "./chunk-HWUOAPTX.js";
import "./chunk-QHCKOBU7.js";
import "./chunk-K2OZ6WVC.js";
import "./chunk-MC6NAKKX.js";
import "./chunk-TF6255HN.js";
import "./chunk-GD4FJL3C.js";
import "./chunk-C5OQVQZF.js";
import {
  u as u2
} from "./chunk-F7DKSAOI.js";
import {
  m
} from "./chunk-4SOQWNPG.js";
import "./chunk-LTULADK2.js";
import "./chunk-35ST7YRB.js";
import "./chunk-EDA5QFHZ.js";
import "./chunk-CNYNCKEV.js";
import "./chunk-XL5QPCXN.js";
import "./chunk-C5M24ACM.js";
import "./chunk-L4A2QJG4.js";
import "./chunk-6KDQMJAI.js";
import "./chunk-UDHS2MGH.js";
import "./chunk-ENINOZUZ.js";
import "./chunk-P6IKJIMO.js";
import "./chunk-MHV23XAQ.js";
import "./chunk-V2X4OKYI.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import "./chunk-MA3QDRC3.js";
import "./chunk-W6J7XCPU.js";
import "./chunk-ONXWBTTM.js";
import "./chunk-T7F6Q6JJ.js";
import "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-7P2ANHQ3.js";
import "./chunk-XCKT47LJ.js";
import "./chunk-3FUHCAX3.js";
import "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import "./chunk-2OFHDVO5.js";
import "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-5UPBUJPC.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import {
  u
} from "./chunk-CCQFL76O.js";
import {
  e
} from "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import "./chunk-7H3U4IJR.js";
import "./chunk-SMWUT52Z.js";
import "./chunk-AXZMNHTN.js";
import "./chunk-5T3MJDSR.js";
import "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import "./chunk-5EI5H4QX.js";
import "./chunk-ZIE53VIV.js";
import "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import "./chunk-GNMPGHLQ.js";
import {
  a
} from "./chunk-QY7XKUIV.js";
import "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/smartMapping/renderers/support/referenceSizeUtils.js
function t(e2) {
  switch (e2) {
    case "circle":
      return { rings: [[[8.5, 0.2], [7.06, 0.33], [5.66, 0.7], [4.35, 1.31], [3.16, 2.14], [2.14, 3.16], [1.31, 4.35], [0.7, 5.66], [0.33, 7.06], [0.2, 8.5], [0.33, 9.94], [0.7, 11.34], [1.31, 12.65], [2.14, 13.84], [3.16, 14.86], [4.35, 15.69], [5.66, 16.3], [7.06, 16.67], [8.5, 16.8], [9.94, 16.67], [11.34, 16.3], [12.65, 15.69], [13.84, 14.86], [14.86, 13.84], [15.69, 12.65], [16.3, 11.34], [16.67, 9.94], [16.8, 8.5], [16.67, 7.06], [16.3, 5.66], [15.69, 4.35], [14.86, 3.16], [13.84, 2.14], [12.65, 1.31], [11.34, 0.7], [9.94, 0.33], [8.5, 0.2]]] };
    case "square":
      return { rings: [[[0.5, 0.5], [0.5, 16.5], [16.5, 16.5], [16.5, 0.5], [0.5, 0.5]]] };
    case "diamond":
      return { rings: [[[8.5, 0.5], [0.2, 8.5], [8.5, 16.5], [16.5, 8.5], [8.5, 0.5]]] };
    case "hexagon-pointy":
      return { rings: [[[15.86, 12.75], [15.86, 4.25], [8.5, 0], [1.14, 4.25], [1.14, 12.75], [8.5, 17], [15.86, 12.75]]] };
    case "hexagon-flat":
      return { rings: [[[12.75, 15.86], [17, 8.5], [12.75, 1.14], [4.25, 1.14], [0, 8.5], [4.25, 15.86], [12.75, 15.86]]] };
  }
}
function l2(e2) {
  return "CIMVectorMarker" === e2?.type ? e2.markerGraphics?.[0] : void 0;
}
function c2(e2) {
  return "CIMPolygonSymbol" === e2?.symbol?.type ? e2.symbol.symbolLayers?.[0] : void 0;
}
function s(e2, r) {
  "CIMVectorMarker" === e2?.type && null != r && (e2.size = r);
}
function m4(e2, r) {
  const n3 = l2(e2);
  n3 && null != r && (n3.geometry = t(r));
}
function y(e2, r) {
  const n3 = c2(l2(e2));
  n3 && null != r && (n3.color = r.toArray());
}
function u4(e2, r, n3) {
  const t2 = c2(l2(e2));
  t2 && null != r && n3 && (t2.colorLocked = r);
}
function f(r, n3) {
  const { outerRingSize: t2, innerDotSize: o, type: i3, color: a2, colorLocked: l4, primitiveOverrides: c3 } = n3, f2 = "CIMPolygonSymbol" === r.data.symbol?.type ? r.data.symbol.symbolLayers : null;
  if (2 === f2?.length) for (const e2 of f2) {
    const r2 = "reference-size-outer-ring" === e2.primitiveName;
    s(e2, r2 ? t2 : o), m4(e2, i3), y(e2, a2), u4(e2, l4, r2);
  }
  return null != t2 && null != o && (r.data.primitiveOverrides = null), void 0 !== c3 && (r.data.primitiveOverrides = a(c3)), r;
}

// node_modules/@arcgis/core/smartMapping/renderers/support/spikeUtils.js
var i2 = "spike-height-override";
var l3 = e(8);
var n2 = e(20);
function u5(e2) {
  const { strokeColor: o, strokeWidth: r, symbolStyle: i3 } = e2, l4 = i3?.includes("solid-fill") || i3?.includes("gradient-fill");
  let n3 = o?.toArray(), a2 = false;
  return i3?.includes("outline") && l4 ? a2 = true : n3 = e2.color?.toArray(), { type: "CIMSolidStroke", effects: p(i3), enable: true, colorLocked: a2, capStyle: "Round", joinStyle: "Round", lineStyle3D: "Strip", miterLimit: 4, width: r ?? e(1), color: n3 };
}
function p(e2) {
  if (!e2?.includes("closed")) return [{ type: "CIMGeometricEffectAddControlPoints", angleTolerance: 90, primitiveName: "spike-control-points" }, { type: "CIMGeometricEffectSuppress", suppress: true, invert: true, primitiveName: "spike-stroke-suppress" }];
}
function m5(e2) {
  const { color: o, symbolStyle: t2 } = e2, r = t2?.includes("solid-fill"), i3 = t2?.includes("gradient-fill");
  if (!r && !i3 || !o) return;
  if (r) return { type: "CIMSolidFill", enable: true, colorLocked: false, color: o?.toArray() };
  const l4 = o.clone();
  return l4.a = 0, { type: "CIMGradientFill", enable: true, angle: 90, colorRamp: { type: "CIMMultipartColorRamp", colorRamps: [{ type: "CIMLinearContinuousColorRamp", fromColor: o.toArray(), toColor: l4.toArray() }], weights: [1] }, gradientMethod: "Linear", gradientSize: 70, gradientSizeUnits: "Relative", gradientType: "Continuous" };
}
function d(t2, r) {
  const { defaultHeight: l4, baseWidth: n3, color: a2, strokeColor: s2, primitiveOverrides: c3, symbolStyle: f2, strokeWidth: p2 } = r, d2 = "CIMPointSymbol" === t2.data.symbol?.type ? t2.data.symbol : null, C3 = d2?.symbolLayers;
  if (!C3) return t2;
  const v2 = d2.effects, S3 = v2?.find((e2) => "CIMGeometricEffectTaperedPolygon" === e2.type), $ = v2?.find((e2) => "CIMGeometricEffectRadial" === e2.type && e2.primitiveName === i2);
  null != n3 && S3 && (S3.fromWidth = n3), null != l4 && $ && ($.length = l4);
  const h2 = C3?.find((e2) => "CIMSolidStroke" === e2.type), M2 = C3?.find((e2) => "CIMSolidFill" === e2.type), g3 = C3?.find((e2) => "CIMGradientFill" === e2.type), I2 = "CIMMultipartColorRamp" === g3?.colorRamp?.type && "CIMLinearContinuousColorRamp" === g3.colorRamp.colorRamps[0]?.type ? g3.colorRamp.colorRamps[0] : null;
  if (f2) {
    const o = M2?.color ?? I2?.fromColor ?? h2?.color, t3 = a2 ?? (o ? new u(o) : void 0), i3 = h2?.color ?? o, l5 = s2 ?? (i3 ? new u(i3) : void 0), n4 = f2.includes("solid-fill"), c4 = f2.includes("gradient-fill");
    if (n4 || c4 || y2(C3, M2 ?? g3), t3) {
      if (n4) y2(C3, g3), M2 ? M2.color = t3?.toArray() : C3.push(m5({ ...r, color: t3 }));
      else if (c4) if (y2(C3, M2), g3) {
        if (I2 && a2) {
          const e2 = t3.clone();
          e2.a = 0, I2.fromColor = t3.toArray(), I2.toColor = e2.toArray();
        }
      } else C3.push(m5({ ...r, color: t3 }));
    }
    if (h2) {
      const e2 = u5({ ...r, strokeColor: l5, color: t3 });
      h2.effects = e2.effects, h2.color = e2.color, h2.width = e2.width, h2.colorLocked = e2.colorLocked;
    }
  } else if (h2 && (s2 && (h2.color = s2.toArray()), null != p2 && (h2.width = p2)), M2 && a2 && (M2.color = a2.toArray()), I2 && a2) {
    const e2 = a2.clone();
    e2.a = 0, I2.fromColor = a2.toArray(), I2.toColor = e2.toArray();
  }
  return void 0 !== c3 && (t2.data.primitiveOverrides = a(c3)), t2;
}
function y2(e2, o) {
  if (!o) return;
  const t2 = e2.indexOf(o);
  -1 !== t2 && e2.splice(t2, 1);
}

// node_modules/@arcgis/core/widgets/Legend/support/sizeRampUtils.js
var w2 = 30;
var S2 = 12;
var g2 = 24;
var v = [255, 255, 255];
var z = [200, 200, 200];
var k2 = [128, 128, 128];
var j = 20;
var x = 5;
function V(e2) {
  return "esri.symbols.SimpleMarkerSymbol" === e2.declaredClass;
}
function I(e2) {
  return "esri.symbols.PictureMarkerSymbol" === e2.declaredClass;
}
function M(e2) {
  return "esri.symbols.SimpleLineSymbol" === e2.declaredClass;
}
function U(e2) {
  return "esri.symbols.TextSymbol" === e2.declaredClass;
}
function C2(e2, t2) {
  const l4 = e2.length - 1;
  return e2.map((e3, i3) => m3(e3, i3, l4, t2));
}
async function L(e2, t2, i3, o, r, s2, n3) {
  const a2 = t2.legendOptions, u6 = a2?.customValues, c3 = n3 || await E2(e2, i3), b = t2.stops, d2 = !!c3, h2 = !!u6, w3 = null != t2.minSize && null != t2.maxSize, S3 = b && b.length > 1, v2 = !!t2.target;
  if (!d2 || !h2 && !(w3 || S3 && !v2)) return;
  const z2 = h(c3);
  let k3 = false, j2 = null, x2 = null;
  j2 = z2 && !S3 ? u3([t2.minDataValue, t2.maxDataValue]) : u6 ?? await H(t2, c3, o, r?.type);
  const V2 = e2?.authoringInfo, I2 = "univariate-color-size" === V2?.type, M2 = I2 && "above-and-below" === V2?.univariateTheme, U2 = !!C(e2, "reference-size"), L2 = !!C(e2, "spike");
  if (!j2 && S3 && (j2 = b.map((e3) => e3.value), k3 = b.some((e3) => !!e3.label), "flow" === e2.type && (j2 = u3(j2)), k3 && (x2 = b.map((e3) => e3.label))), z2 && null != j2 && j2?.length > 2 && !M2 && (j2 = [j2[0], j2[j2.length - 1]]), !j2) return null;
  I2 && 5 !== j2?.length && (j2 = O({ minSize: j2[0], maxSize: j2[j2.length - 1] }));
  const T2 = z2 ? D(e2, j2) : null, P2 = m2(c3), q2 = k3 ? null : C2(j2, s2), B2 = await Promise.all(j2.map(async (l4, i4) => {
    let s3 = z2 ? T2[i4] : await F(t2, c3, l4, o, r?.type), n4 = s3;
    U2 && (s3 *= g2 / t2.maxSize || 1, n4 = g2);
    const a3 = G(c3, s3, e2, i4);
    L2 && "cim" === a3.type && (n4 = await g(a3));
    return { value: l4, symbol: a3, label: k3 ? x2[i4] : q2[i4], size: n4, outlineSize: P2 };
  }));
  return B2.reverse();
}
function D(e2, t2) {
  const l4 = e2?.authoringInfo, i3 = "univariate-color-size" === l4?.type;
  let o = [S2, w2];
  if (i3) {
    const e3 = t2[0], l5 = t2[t2.length - 1], i4 = S2, r = w2;
    o = t2.map((t3) => i4 + (t3 - e3) / (l5 - e3) * (r - i4));
  }
  return i3 && "below" === l4?.univariateTheme && o.reverse(), o;
}
function T(e2, t2) {
  const l4 = e2.classBreakInfos, i3 = l4.length, o = i3 < 2 || !(t2 >= 2) ? l4[0].symbol.clone() : l4[i3 - 1].symbol.clone(), r = e2.visualVariables?.some((e3) => "color" === e3.type);
  return r && (o.type.includes("3d") ? q(o) : B(o)), o;
}
async function E2(l4, i3) {
  if ("flow" === l4.type) return w(l4, i3);
  if ("pie-chart" === l4.type) return new u2({ color: null, outline: l4.outline?.width ? l4.outline : new m() });
  let o = null, u6 = null;
  if ("simple" === l4.type) o = l4.symbol;
  else if ("class-breaks" === l4.type) {
    const e2 = l4.classBreakInfos;
    o = e2 && e2[0] && e2[0].symbol, u6 = e2.length > 1;
  } else if ("unique-value" === l4.type) {
    const e2 = l4.uniqueValueInfos;
    o = e2?.[0]?.symbol, u6 = null != e2 && e2.length > 1;
  }
  if (!o || P(o)) return null;
  if (o = o.clone(), i3 || u6) if (o.type.includes("3d")) q(o);
  else if (C(l4, "reference-size") && "cim" === o.type) f(o, { color: i3 ?? ("class-breaks" !== l4.type ? new u(z) : null) });
  else if (C(l4, "spike") && "cim" === o.type) {
    const l5 = new u(z), r = new u(k2), n3 = "CIMPointSymbol" === o.data.symbol?.type ? o.data.symbol : null, a2 = !!n3?.symbolLayers?.find(({ type: e2 }) => "CIMSolidStroke" === e2)?.colorLocked;
    let u7, m6 = i3 ?? void 0;
    if (m6) {
      const e2 = E(m6), i4 = c();
      (!i4 && e2 > 225 || i4 && e2 < 25) && (m6 = l5, u7 = a2 ? r : l5);
    } else m6 = l5, u7 = a2 ? r : l5;
    d(o, { color: m6, strokeColor: u7 });
  } else B(o);
  return o;
}
function P(e2) {
  return S(e2) ? e2.symbolLayers?.some((e3) => "fill" === e3?.type) ?? false : e2?.type.includes("fill") ?? false;
}
function q(e2) {
  "line-3d" === e2.type ? e2.symbolLayers.forEach((e3) => {
    e3.material = { color: k2 };
  }) : e2.symbolLayers.forEach((e3) => {
    "icon" !== e3.type || e3.resource?.href ? e3.material = { color: z } : (e3.material = { color: v }, e3.outline = { color: k2, size: 1.5 });
  });
}
function B(t2) {
  const l4 = c();
  if ("cim" === t2.type) k(t2, new u(z));
  else if (t2.type.includes("line")) t2.color = k2;
  else if (t2.color = l4 ? k2 : v, "simple-marker" === t2.type) if (t2.outline) {
    const e2 = t2.outline?.color?.toHex();
    "#ffffff" === e2 && (t2.outline.color = k2);
  } else t2.outline = { color: k2, width: 1.5 };
}
async function H(e2, t2, i3, o) {
  const r = (await import("./visualVariableUtils-EKNNTOCH.js")).getSizeRangeAtScale(e2, i3, o), s2 = r && O(r);
  if (!r || !s2) return;
  let n3 = s2.map((t3) => R(t3, e2, r));
  n3 = u3(n3);
  for (let l4 = 1; l4 < n3.length - 1; l4++) {
    const r2 = await A(e2, t2, n3[l4], n3[l4 - 1], i3, o);
    r2 && (n3[l4] = r2[0], s2[l4] = r2[1]);
  }
  return n3;
}
function O(e2) {
  const t2 = e2.minSize, l4 = e2.maxSize, i3 = x, o = (l4 - t2) / (i3 - 1), r = [];
  for (let s2 = 0; s2 < i3; s2++) r.push(t2 + o * s2);
  return r;
}
function R(e2, t2, l4) {
  const i3 = l4.minSize, o = l4.maxSize, r = t2.minDataValue, s2 = t2.maxDataValue;
  let n3;
  if (e2 <= i3) n3 = r;
  else if (e2 >= o) n3 = s2;
  else {
    n3 = (e2 - i3) / (o - i3) * (s2 - r) + r;
  }
  return n3;
}
async function A(e2, t2, r, s2, n3, a2) {
  const u6 = await F(e2, t2, r, n3, a2), m6 = await F(e2, t2, s2, n3, a2), c3 = i(r), p2 = c3.fractional, f2 = j;
  let y3 = c3.integer, b = null, d2 = null;
  r > 0 && r < 1 && (b = 10 ** p2, y3 = i(r *= b).integer);
  for (let i3 = y3 - 1; i3 >= 0; i3--) {
    const s3 = 10 ** i3;
    let c4 = Math.floor(r / s3) * s3, p3 = Math.ceil(r / s3) * s3;
    null != b && (c4 /= b, p3 /= b);
    let y4 = (c4 + p3) / 2;
    [, y4] = u3([c4, y4, p3], { indexes: [1] });
    const h2 = await F(e2, t2, c4, n3, a2), w3 = await F(e2, t2, p3, n3, a2), S3 = await F(e2, t2, y4, n3, a2), g3 = l(u6, h2, m6, null), v2 = l(u6, w3, m6, null), z2 = l(u6, S3, m6, null);
    let k3 = g3.previous <= f2, j2 = v2.previous <= f2;
    if (k3 && j2 && (g3.previous <= v2.previous ? (k3 = true, j2 = false) : (j2 = true, k3 = false)), k3 ? d2 = [c4, h2] : j2 ? d2 = [p3, w3] : z2.previous <= f2 && (d2 = [y4, S3]), d2) break;
  }
  return d2;
}
async function F(e2, t2, l4, i3, o) {
  const { getSize: r } = await import("./visualVariableUtils-EKNNTOCH.js");
  return r(e2, l4, { scale: i3, view: o, shape: "simple-marker" === t2.type ? t2.style : null });
}
function G(e2, t2, l4, i3) {
  "univariate-color-size" === l4?.authoringInfo?.type && "above-and-below" === l4?.authoringInfo?.univariateTheme && "class-breaks" === l4.type && (e2 = T(l4, i3));
  const o = e2.clone();
  if (S(o)) h(o) || o.symbolLayers.forEach((e3) => {
    "fill" !== e3.type && (e3.size = t2);
  });
  else if (V(o)) o.size = t2;
  else if (I(o)) {
    const e3 = o.width, l5 = o.height;
    o.height = t2, o.width = t2 * (e3 / l5);
  } else M(o) ? o.width = t2 : U(o) ? o.font && (o.font.size = t2) : "cim" === o.type && C(l4, "reference-size") ? f(o, { innerDotSize: t2, outerRingSize: g2 }) : "cim" === o.type && C(l4, "spike") && d(o, { defaultHeight: t2, primitiveOverrides: null });
  return o;
}
export {
  L as getRampStops,
  w2 as realWorldMaxSize,
  S2 as realWorldMinSize
};
//# sourceMappingURL=sizeRampUtils-DSHPOELR.js.map
