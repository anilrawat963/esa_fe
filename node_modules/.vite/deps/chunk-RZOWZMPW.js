import {
  a,
  c
} from "./chunk-U55FA2EK.js";
import {
  O
} from "./chunk-QNVJVDYZ.js";
import {
  has
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/views/webgl/reservedWordsGLSL3.js
var e = ["layout", "centroid", "smooth", "case", "mat2x2", "mat2x3", "mat2x4", "mat3x2", "mat3x3", "mat3x4", "mat4x2", "mat4x3", "mat4x4", "uint", "uvec2", "uvec3", "uvec4", "samplerCubeShadow", "sampler2DArray", "sampler2DArrayShadow", "isampler2D", "isampler3D", "isamplerCube", "isampler2DArray", "usampler2D", "usampler3D", "usamplerCube", "usampler2DArray", "coherent", "restrict", "readonly", "writeonly", "resource", "atomic_uint", "noperspective", "patch", "sample", "subroutine", "common", "partition", "active", "filter", "image1D", "image2D", "image3D", "imageCube", "iimage1D", "iimage2D", "iimage3D", "iimageCube", "uimage1D", "uimage2D", "uimage3D", "uimageCube", "image1DArray", "image2DArray", "iimage1DArray", "iimage2DArray", "uimage1DArray", "uimage2DArray", "image1DShadow", "image2DShadow", "image1DArrayShadow", "image2DArrayShadow", "imageBuffer", "iimageBuffer", "uimageBuffer", "sampler1DArray", "sampler1DArrayShadow", "isampler1D", "isampler1DArray", "usampler1D", "usampler1DArray", "isampler2DRect", "usampler2DRect", "samplerBuffer", "isamplerBuffer", "usamplerBuffer", "sampler2DMS", "isampler2DMS", "usampler2DMS", "sampler2DMSArray", "isampler2DMSArray", "usampler2DMSArray", "trunc", "round", "roundEven", "isnan", "isinf", "floatBitsToInt", "floatBitsToUint", "intBitsToFloat", "uintBitsToFloat", "packSnorm2x16", "unpackSnorm2x16", "packUnorm2x16", "unpackUnorm2x16", "packHalf2x16", "unpackHalf2x16", "outerProduct", "transpose", "determinant", "inverse", "texture", "textureSize", "textureProj", "textureLod", "textureOffset", "texelFetch", "texelFetchOffset", "textureProjOffset", "textureLodOffset", "textureProjLod", "textureProjLodOffset", "textureGrad", "textureGradOffset", "textureProjGrad", "textureProjGradOffset"];

// node_modules/@arcgis/core/views/webgl/testUtils.js
var e2 = { enableCache: false };

// node_modules/@arcgis/core/views/webgl/ShaderTranspiler.js
var r = ["precision", "highp", "mediump", "lowp", "attribute", "const", "uniform", "varying", "break", "continue", "do", "for", "while", "if", "else", "in", "out", "inout", "float", "int", "void", "bool", "true", "false", "discard", "return", "mat2", "mat3", "mat4", "vec2", "vec3", "vec4", "ivec2", "ivec3", "ivec4", "uvec2", "uvec3", "uvec4", "bvec2", "bvec3", "bvec4", "sampler1D", "sampler2D", "sampler3D", "usampler1D", "usampler2D", "usampler3D", "samplerCube", "sampler1DShadow", "sampler2DShadow", "struct", "asm", "class", "union", "enum", "typedef", "template", "this", "packed", "goto", "switch", "default", "inline", "noinline", "volatile", "public", "static", "extern", "external", "interface", "long", "short", "double", "half", "fixed", "unsigned", "input", "output", "hvec2", "hvec3", "hvec4", "dvec2", "dvec3", "dvec4", "fvec2", "fvec3", "fvec4", "sampler2DRect", "sampler3DRect", "sampler2DRectShadow", "sizeof", "cast", "namespace", "using"];
var a2 = ["<<=", ">>=", "++", "--", "<<", ">>", "<=", ">=", "==", "!=", "&&", "||", "+=", "-=", "*=", "/=", "%=", "&=", "^^", "^=", "|=", "(", ")", "[", "]", ".", "!", "~", "*", "/", "%", "+", "-", "<", ">", "&", "^", "|", "?", ":", "=", ",", ";", "{", "}"];
var o = ["abs", "acos", "all", "any", "asin", "atan", "ceil", "clamp", "cos", "cross", "dFdx", "dFdy", "degrees", "distance", "dot", "equal", "exp", "exp2", "faceforward", "floor", "fract", "gl_BackColor", "gl_BackLightModelProduct", "gl_BackLightProduct", "gl_BackMaterial", "gl_BackSecondaryColor", "gl_ClipPlane", "gl_ClipVertex", "gl_Color", "gl_DepthRange", "gl_DepthRangeParameters", "gl_EyePlaneQ", "gl_EyePlaneR", "gl_EyePlaneS", "gl_EyePlaneT", "gl_Fog", "gl_FogCoord", "gl_FogFragCoord", "gl_FogParameters", "gl_FragColor", "gl_FragCoord", "gl_FragData", "gl_FragDepth", "gl_FragDepthEXT", "gl_FrontColor", "gl_FrontFacing", "gl_FrontLightModelProduct", "gl_FrontLightProduct", "gl_FrontMaterial", "gl_FrontSecondaryColor", "gl_LightModel", "gl_LightModelParameters", "gl_LightModelProducts", "gl_LightProducts", "gl_LightSource", "gl_LightSourceParameters", "gl_MaterialParameters", "gl_MaxClipPlanes", "gl_MaxCombinedTextureImageUnits", "gl_MaxDrawBuffers", "gl_MaxFragmentUniformComponents", "gl_MaxLights", "gl_MaxTextureCoords", "gl_MaxTextureImageUnits", "gl_MaxTextureUnits", "gl_MaxVaryingFloats", "gl_MaxVertexAttribs", "gl_MaxVertexTextureImageUnits", "gl_MaxVertexUniformComponents", "gl_ModelViewMatrix", "gl_ModelViewMatrixInverse", "gl_ModelViewMatrixInverseTranspose", "gl_ModelViewMatrixTranspose", "gl_ModelViewProjectionMatrix", "gl_ModelViewProjectionMatrixInverse", "gl_ModelViewProjectionMatrixInverseTranspose", "gl_ModelViewProjectionMatrixTranspose", "gl_MultiTexCoord0", "gl_MultiTexCoord1", "gl_MultiTexCoord2", "gl_MultiTexCoord3", "gl_MultiTexCoord4", "gl_MultiTexCoord5", "gl_MultiTexCoord6", "gl_MultiTexCoord7", "gl_Normal", "gl_NormalMatrix", "gl_NormalScale", "gl_ObjectPlaneQ", "gl_ObjectPlaneR", "gl_ObjectPlaneS", "gl_ObjectPlaneT", "gl_Point", "gl_PointCoord", "gl_PointParameters", "gl_PointSize", "gl_Position", "gl_ProjectionMatrix", "gl_ProjectionMatrixInverse", "gl_ProjectionMatrixInverseTranspose", "gl_ProjectionMatrixTranspose", "gl_SecondaryColor", "gl_TexCoord", "gl_TextureEnvColor", "gl_TextureMatrix", "gl_TextureMatrixInverse", "gl_TextureMatrixInverseTranspose", "gl_TextureMatrixTranspose", "gl_Vertex", "greaterThan", "greaterThanEqual", "inversesqrt", "length", "lessThan", "lessThanEqual", "log", "log2", "matrixCompMult", "max", "min", "mix", "mod", "normalize", "not", "notEqual", "pow", "radians", "reflect", "refract", "sign", "sin", "smoothstep", "sqrt", "step", "tan", "texture2D", "texture2DLod", "texture2DProj", "texture2DProjLod", "textureCube", "textureCubeLod", "texture2DLodEXT", "texture2DProjLodEXT", "textureCubeLodEXT", "texture2DGradEXT", "texture2DProjGradEXT", "textureCubeGradEXT", "textureSize", "texelFetch"];
var n = 999;
var i = 9999;
var l = 0;
var s = 1;
var c2 = 2;
var u = 3;
var d = 4;
var g = 5;
var p = 6;
var f = 7;
var _ = 8;
var h = 9;
var x = 10;
var m = 11;
var y = ["block-comment", "line-comment", "preprocessor", "operator", "integer", "float", "ident", "builtin", "keyword", "whitespace", "eof", "integer"];
function w() {
  var e5, t, w2, M2 = 0, v2 = 0, b2 = n, T2 = [], P2 = [], C2 = 1, k2 = 0, j2 = 0, D2 = false, E2 = false, F2 = "";
  return function(e6) {
    return P2 = [], null !== e6 ? S2(e6.replace ? e6.replace(/\r\n/g, "\n") : e6) : V2();
  };
  function L2(e6) {
    e6.length && P2.push({ type: y[b2], data: e6, position: j2, line: C2, column: k2 });
  }
  function S2(t2) {
    var r3;
    for (M2 = 0, w2 = (F2 += t2).length; e5 = F2[M2], M2 < w2; ) {
      switch (r3 = M2, b2) {
        case l:
          M2 = R();
          break;
        case s:
          M2 = O2();
          break;
        case c2:
          M2 = G();
          break;
        case u:
          M2 = U();
          break;
        case d:
          M2 = z();
          break;
        case m:
          M2 = B();
          break;
        case g:
          M2 = A();
          break;
        case i:
          M2 = N();
          break;
        case h:
          M2 = I();
          break;
        case n:
          M2 = X2();
      }
      if (r3 !== M2) if ("\n" === F2[r3]) k2 = 0, ++C2;
      else ++k2;
    }
    return v2 += M2, F2 = F2.slice(M2), P2;
  }
  function V2(e6) {
    return T2.length && L2(T2.join("")), b2 = x, L2("(eof)"), P2;
  }
  function X2() {
    return T2 = T2.length ? [] : T2, "/" === t && "*" === e5 ? (j2 = v2 + M2 - 1, b2 = l, t = e5, M2 + 1) : "/" === t && "/" === e5 ? (j2 = v2 + M2 - 1, b2 = s, t = e5, M2 + 1) : "#" === e5 ? (b2 = c2, j2 = v2 + M2, M2) : /\s/.test(e5) ? (b2 = h, j2 = v2 + M2, M2) : (D2 = /\d/.test(e5), E2 = /[^\w_]/.test(e5), j2 = v2 + M2, b2 = D2 ? d : E2 ? u : i, M2);
  }
  function I() {
    return /[^\s]/g.test(e5) ? (L2(T2.join("")), b2 = n, M2) : (T2.push(e5), t = e5, M2 + 1);
  }
  function G() {
    return "\r" !== e5 && "\n" !== e5 || "\\" === t ? (T2.push(e5), t = e5, M2 + 1) : (L2(T2.join("")), b2 = n, M2);
  }
  function O2() {
    return G();
  }
  function R() {
    return "/" === e5 && "*" === t ? (T2.push(e5), L2(T2.join("")), b2 = n, M2 + 1) : (T2.push(e5), t = e5, M2 + 1);
  }
  function U() {
    if ("." === t && /\d/.test(e5)) return b2 = g, M2;
    if ("/" === t && "*" === e5) return b2 = l, M2;
    if ("/" === t && "/" === e5) return b2 = s, M2;
    if ("." === e5 && T2.length) {
      for (; q(T2); ) ;
      return b2 = g, M2;
    }
    if (";" === e5 || ")" === e5 || "(" === e5) {
      if (T2.length) for (; q(T2); ) ;
      return L2(e5), b2 = n, M2 + 1;
    }
    var r3 = 2 === T2.length && "=" !== e5;
    if (/[\w_\d\s]/.test(e5) || r3) {
      for (; q(T2); ) ;
      return b2 = n, M2;
    }
    return T2.push(e5), t = e5, M2 + 1;
  }
  function q(e6) {
    for (var t2, r3, o2 = 0; ; ) {
      if (t2 = a2.indexOf(e6.slice(0, e6.length + o2).join("")), r3 = a2[t2], -1 === t2) {
        if (o2-- + e6.length > 0) continue;
        r3 = e6.slice(0, 1).join("");
      }
      return L2(r3), j2 += r3.length, (T2 = T2.slice(r3.length)).length;
    }
  }
  function B() {
    return /[^a-fA-F0-9]/.test(e5) ? (L2(T2.join("")), b2 = n, M2) : (T2.push(e5), t = e5, M2 + 1);
  }
  function z() {
    return "." === e5 || /[eE]/.test(e5) ? (T2.push(e5), b2 = g, t = e5, M2 + 1) : "x" === e5 && 1 === T2.length && "0" === T2[0] ? (b2 = m, T2.push(e5), t = e5, M2 + 1) : /[^\d]/.test(e5) ? (L2(T2.join("")), b2 = n, M2) : (T2.push(e5), t = e5, M2 + 1);
  }
  function A() {
    return "f" === e5 && (T2.push(e5), t = e5, M2 += 1), /[eE]/.test(e5) || "-" === e5 && /[eE]/.test(t) ? (T2.push(e5), t = e5, M2 + 1) : /[^\d]/.test(e5) ? (L2(T2.join("")), b2 = n, M2) : (T2.push(e5), t = e5, M2 + 1);
  }
  function N() {
    if (/[^\d\w_]/.test(e5)) {
      var a4 = T2.join("");
      return b2 = r.indexOf(a4) > -1 ? _ : o.indexOf(a4) > -1 ? f : p, L2(T2.join("")), b2 = n, M2;
    }
    return T2.push(e5), t = e5, M2 + 1;
  }
}
function M(e5) {
  var t = w(), r3 = [];
  return r3 = (r3 = r3.concat(t(e5))).concat(t(null));
}
function v(e5) {
  return M(e5);
}
function b(e5) {
  return e5.map((e6) => "eof" !== e6.type ? e6.data : "").join("");
}
var T = /* @__PURE__ */ new Set(["GL_OES_standard_derivatives", "GL_EXT_frag_depth", "GL_EXT_draw_buffers", "GL_EXT_shader_texture_lod"]);
function P(e5, t = "100", r3 = "300 es") {
  const a4 = /^\s*#version\s+([0-9]+(\s+[a-zA-Z]+)?)\s*/;
  for (const o2 of e5) if ("preprocessor" === o2.type) {
    const e6 = a4.exec(o2.data);
    if (e6) {
      const a5 = e6[1].replaceAll(/\s{2,}/g, " ");
      if (a5 === r3) return a5;
      if (a5 === t) return o2.data = "#version " + r3, t;
      throw new Error("unknown glsl version: " + a5);
    }
  }
  return e5.splice(0, 0, { type: "preprocessor", data: "#version " + r3 }, { type: "whitespace", data: "\n" }), null;
}
function C(e5, t) {
  for (let r3 = t - 1; r3 >= 0; r3--) {
    const t2 = e5[r3];
    if ("whitespace" !== t2.type && "block-comment" !== t2.type) {
      if ("keyword" !== t2.type) break;
      if ("attribute" === t2.data || "in" === t2.data) return true;
    }
  }
  return false;
}
function k(e5, t, r3, a4) {
  a4 = a4 || r3;
  for (const o2 of e5) if ("ident" === o2.type && o2.data === r3) {
    a4 in t ? t[a4]++ : t[a4] = 0;
    return k(e5, t, a4 + "_" + t[a4], a4);
  }
  return r3;
}
function j(e5, t, r3 = "afterVersion") {
  function a4(e6, t2) {
    for (let r4 = t2; r4 < e6.length; r4++) {
      const t3 = e6[r4];
      if ("operator" === t3.type && ";" === t3.data) return r4;
    }
    return null;
  }
  function o2(e6) {
    let t2 = -1, o3 = 0, n4 = -1;
    for (let i3 = 0; i3 < e6.length; i3++) {
      const l4 = e6[i3];
      if ("preprocessor" === l4.type && (/#(if|ifdef|ifndef)\s+.+/.test(l4.data) ? ++o3 : /#endif\s*.*/.test(l4.data) && --o3), "afterVersion" !== r3 && "afterPrecision" !== r3 || "preprocessor" === l4.type && l4.data.startsWith("#version") && (n4 = Math.max(n4, i3)), "afterPrecision" === r3 && "keyword" === l4.type && "precision" === l4.data) {
        const t3 = a4(e6, i3);
        if (null === t3) throw new Error("precision statement not followed by any semicolons!");
        n4 = Math.max(n4, t3);
      }
      t2 < n4 && 0 === o3 && (t2 = i3);
    }
    return t2 + 1;
  }
  const n3 = { data: "\n", type: "whitespace" }, i2 = (t2) => t2 < e5.length && /[^\r\n]$/.test(e5[t2].data);
  let l3 = o2(e5);
  i2(l3 - 1) && e5.splice(l3++, 0, n3);
  for (const s3 of t) e5.splice(l3++, 0, s3);
  i2(l3 - 1) && i2(l3) && e5.splice(l3, 0, n3);
}
function D(e5, t, r3, a4 = "lowp") {
  j(e5, [{ type: "keyword", data: "out" }, { type: "whitespace", data: " " }, { type: "keyword", data: a4 }, { type: "whitespace", data: " " }, { type: "keyword", data: r3 }, { type: "whitespace", data: " " }, { type: "ident", data: t }, { type: "operator", data: ";" }], "afterPrecision");
}
function E(e5, t, r3, a4, o2 = "lowp") {
  j(e5, [{ type: "keyword", data: "layout" }, { type: "operator", data: "(" }, { type: "keyword", data: "location" }, { type: "whitespace", data: " " }, { type: "operator", data: "=" }, { type: "whitespace", data: " " }, { type: "integer", data: a4.toString() }, { type: "operator", data: ")" }, { type: "whitespace", data: " " }, { type: "keyword", data: "out" }, { type: "whitespace", data: " " }, { type: "keyword", data: o2 }, { type: "whitespace", data: " " }, { type: "keyword", data: r3 }, { type: "whitespace", data: " " }, { type: "ident", data: t }, { type: "operator", data: ";" }], "afterPrecision");
}
function F(e5, t) {
  let r3, a4, o2 = -1;
  for (let n3 = t; n3 < e5.length; n3++) {
    const t2 = e5[n3];
    if ("operator" === t2.type && ("[" === t2.data && (r3 = n3), "]" === t2.data)) {
      a4 = n3;
      break;
    }
    "integer" === t2.type && (o2 = parseInt(t2.data, 10));
  }
  return r3 && a4 && e5.splice(r3, a4 - r3 + 1), o2;
}
function L(t, r3) {
  if (t.startsWith("#version 300")) return t;
  const a4 = V(t);
  if (null != a4) return a4;
  const o2 = v(t);
  if ("300 es" === P(o2, "100", "300 es")) return t;
  let n3 = null, i2 = null;
  const l3 = {}, s3 = {};
  for (let c4 = 0; c4 < o2.length; ++c4) {
    const t2 = o2[c4];
    switch (t2.type) {
      case "keyword":
        35633 === r3 && "attribute" === t2.data ? t2.data = "in" : "varying" === t2.data && (t2.data = 35633 === r3 ? "out" : "in");
        break;
      case "builtin":
        if (/^texture(2D|Cube)(Proj)?(Lod|Grad)?(EXT)?$/.test(t2.data.trim()) && (t2.data = t2.data.replaceAll(/(2D|Cube|EXT)/g, "")), 35632 === r3 && "gl_FragColor" === t2.data && (n3 || (n3 = k(o2, l3, "fragColor"), D(o2, n3, "vec4")), t2.data = n3), 35632 === r3 && "gl_FragData" === t2.data) {
          const e5 = F(o2, c4 + 1), r4 = k(o2, l3, "fragData");
          E(o2, r4, "vec4", e5, "mediump"), t2.data = r4;
        } else 35632 === r3 && "gl_FragDepthEXT" === t2.data && (i2 || (i2 = k(o2, l3, "gl_FragDepth")), t2.data = i2);
        break;
      case "ident":
        if (e.includes(t2.data)) {
          if (35633 === r3 && C(o2, c4)) throw new Error("attribute in vertex shader uses a name that is a reserved word in glsl 300 es");
          t2.data in s3 || (s3[t2.data] = k(o2, l3, t2.data)), t2.data = s3[t2.data];
        }
    }
  }
  for (let e5 = o2.length - 1; e5 >= 0; --e5) {
    const t2 = o2[e5];
    if ("preprocessor" === t2.type) {
      const r4 = t2.data.match(/#extension\s+(.*):/);
      if (r4?.[1] && T.has(r4[1].trim())) {
        const t3 = o2[e5 + 1];
        o2.splice(e5, t3 && "whitespace" === t3.type ? 2 : 1);
      }
      const a5 = t2.data.match(/#ifdef\s+(.*)/);
      a5?.[1] && T.has(a5[1].trim()) && (t2.data = "#if 1");
      const n4 = t2.data.match(/#ifndef\s+(.*)/);
      n4?.[1] && T.has(n4[1].trim()) && (t2.data = "#if 0");
    }
  }
  return X(t, b(o2));
}
var S = /* @__PURE__ */ new Map();
function V(e5) {
  return e2.enableCache ? S.get(e5) : null;
}
function X(e5, r3) {
  return e2.enableCache && S.set(e5, r3), r3;
}

// node_modules/@arcgis/core/views/webgl/Program.js
var n2 = 4294967295;
var r2 = !!has("esri-tests-disable-gpu-memory-measurements");
var s2 = class {
  constructor(e5, s3, m3, h3, f3 = /* @__PURE__ */ new Map(), l3 = []) {
    this._context = e5, this._refCount = 1, this._compiled = false, this._linesOfCode = 0, this._nameToUniformLocation = /* @__PURE__ */ new Map(), this._nameToUniform1 = /* @__PURE__ */ new Map(), this._nameToUniform1v = /* @__PURE__ */ new Map(), this._nameToUniform2 = /* @__PURE__ */ new Map(), this._nameToUniform3 = /* @__PURE__ */ new Map(), this._nameToUniform4 = /* @__PURE__ */ new Map(), this._nameToUniformMatrix3 = /* @__PURE__ */ new Map(), this._nameToUniformMatrix4 = /* @__PURE__ */ new Map(), e5 || console.error("RenderingContext isn't initialized!"), 0 === s3.length && console.error("Shaders source should not be empty!"), s3 = L(s3, 35633), m3 = L(m3, 35632), this._vShader = a3(this._context, 35633, s3), this._fShader = a3(this._context, 35632, m3), c3.enabled && (this._linesOfCode = s3.match(/\n/g).length + m3.match(/\n/g).length + 2, e5.instanceCounter.increment(O.LinesOfCode, this._vShader, this._linesOfCode)), this._vShader && this._fShader || console.error("Error loading shaders!"), e5.instanceCounter.increment(O.Shader, this), c() && (this.vertexShader = s3, this.fragmentShader = m3), this.usedMemory = r2 ? 0 : s3.length + m3.length;
    const _3 = this._context.gl, g2 = _3.createProgram();
    _3.attachShader(g2, this._vShader), _3.attachShader(g2, this._fShader), h3.forEach((t, e6) => _3.bindAttribLocation(g2, t, e6)), this.hasTransformFeedbackVaryings = !!l3?.length, this.hasTransformFeedbackVaryings && _3.transformFeedbackVaryings(g2, l3, _3.SEPARATE_ATTRIBS), _3.linkProgram(g2), c() && !_3.getProgramParameter(g2, _3.LINK_STATUS) && console.error(`Could not link shader
validated: ${_3.getProgramParameter(g2, _3.VALIDATE_STATUS)}, gl error ${_3.getError()}, vertex: ${_3.getShaderParameter(this._vShader, _3.COMPILE_STATUS)}, fragment: ${_3.getShaderParameter(this._fShader, _3.COMPILE_STATUS)}, info log: ${_3.getProgramInfoLog(g2)}, vertex source: ${this.vertexShader}, fragment source: ${this.fragmentShader}`);
    for (const [t, o2] of f3) {
      const e6 = _3.getUniformBlockIndex(g2, t);
      e6 < n2 && _3.uniformBlockBinding(g2, e6, o2);
    }
    this._glName = g2, e5.instanceCounter.increment(O.Program, this);
  }
  get glName() {
    return this._glName;
  }
  get hasGLName() {
    return null != this._glName;
  }
  get compiled() {
    return !!this._compiled || (this._context.capabilities.parallelShaderCompile && null != this.glName ? (this._compiled = !!this._context.gl.getProgramParameter(this.glName, 37297), this._compiled) : (this._compiled = true, true));
  }
  dispose() {
    if (--this._refCount > 0) return;
    const t = this._context.gl, e5 = this._context.instanceCounter;
    this._nameToUniformLocation.forEach((t2) => t2 && e5.decrement(O.Uniform, t2)), this._nameToUniformLocation.clear(), this._vShader && (this._linesOfCode > 0 && (e5.decrement(O.LinesOfCode, this._vShader, this._linesOfCode), this._linesOfCode = 0), t.deleteShader(this._vShader), this._vShader = null, e5.decrement(O.Shader, this)), this._fShader && (t.deleteShader(this._fShader), this._fShader = null), this._glName && (t.deleteProgram(this._glName), this._glName = null, e5.decrement(O.Program, this));
  }
  ref() {
    ++this._refCount;
  }
  _getUniformLocation(t) {
    const e5 = this._nameToUniformLocation.get(t);
    if (void 0 !== e5) return e5;
    if (this.glName) {
      const e6 = this._context.gl.getUniformLocation(this.glName, t);
      return this._nameToUniformLocation.set(t, e6), e6 && this._context.instanceCounter.increment(O.Uniform, e6), e6;
    }
    return null;
  }
  hasUniform(t) {
    return null != this._getUniformLocation(t);
  }
  setUniform1i(t, e5, o2) {
    l2(o2, e5);
    const i2 = this._nameToUniform1.get(t);
    void 0 !== i2 && e5 === i2 || (this._context.gl.uniform1i(this._getUniformLocation(t), e5), this._nameToUniform1.set(t, e5));
  }
  setUniform1iv(t, e5, o2) {
    _2(o2, e5), f2(this._nameToUniform1v, t, e5) && this._context.gl.uniform1iv(this._getUniformLocation(t), e5);
  }
  setUniform2iv(t, e5, o2) {
    _2(o2, e5), f2(this._nameToUniform2, t, e5) && this._context.gl.uniform2iv(this._getUniformLocation(t), e5);
  }
  setUniform3iv(t, e5, o2) {
    _2(o2, e5), f2(this._nameToUniform3, t, e5) && this._context.gl.uniform3iv(this._getUniformLocation(t), e5);
  }
  setUniform4iv(t, e5, o2) {
    _2(o2, e5), f2(this._nameToUniform4, t, e5) && this._context.gl.uniform4iv(this._getUniformLocation(t), e5);
  }
  setUniform1f(t, e5, o2) {
    l2(o2, e5);
    const i2 = this._nameToUniform1.get(t);
    void 0 !== i2 && e5 === i2 || (this._context.gl.uniform1f(this._getUniformLocation(t), e5), this._nameToUniform1.set(t, e5));
  }
  setUniform1fv(t, e5, o2) {
    _2(o2, e5), f2(this._nameToUniform1v, t, e5) && this._context.gl.uniform1fv(this._getUniformLocation(t), e5);
  }
  setUniform2f(t, e5, o2, i2) {
    l2(i2, e5, o2);
    const n3 = this._nameToUniform2.get(t);
    void 0 === n3 ? (this._context.gl.uniform2f(this._getUniformLocation(t), e5, o2), this._nameToUniform2.set(t, [e5, o2])) : e5 === n3[0] && o2 === n3[1] || (this._context.gl.uniform2f(this._getUniformLocation(t), e5, o2), n3[0] = e5, n3[1] = o2);
  }
  setUniform2fv(t, e5, o2) {
    _2(o2, e5), f2(this._nameToUniform2, t, e5) && this._context.gl.uniform2fv(this._getUniformLocation(t), e5);
  }
  setUniform3f(t, e5, o2, i2, n3) {
    l2(n3, e5, o2, i2);
    const r3 = this._nameToUniform3.get(t);
    void 0 === r3 ? (this._context.gl.uniform3f(this._getUniformLocation(t), e5, o2, i2), this._nameToUniform3.set(t, [e5, o2, i2])) : e5 === r3[0] && o2 === r3[1] && i2 === r3[2] || (this._context.gl.uniform3f(this._getUniformLocation(t), e5, o2, i2), r3[0] = e5, r3[1] = o2, r3[2] = i2);
  }
  setUniform3fv(t, e5, o2) {
    _2(o2, e5);
    const i2 = this._getUniformLocation(t);
    null != i2 && f2(this._nameToUniform3, t, e5) && this._context.gl.uniform3fv(i2, e5);
  }
  setUniform4f(t, e5, o2, i2, n3, r3) {
    l2(r3, e5, o2, i2, n3);
    const s3 = this._nameToUniform4.get(t);
    void 0 === s3 ? (this._context.gl.uniform4f(this._getUniformLocation(t), e5, o2, i2, n3), this._nameToUniform4.set(t, [e5, o2, i2, n3])) : void 0 !== s3 && e5 === s3[0] && o2 === s3[1] && i2 === s3[2] && n3 === s3[3] || (this._context.gl.uniform4f(this._getUniformLocation(t), e5, o2, i2, n3), s3[0] = e5, s3[1] = o2, s3[2] = i2, s3[3] = n3);
  }
  setUniform4fv(t, e5, o2) {
    _2(o2, e5);
    const i2 = this._getUniformLocation(t);
    null != i2 && f2(this._nameToUniform4, t, e5) && this._context.gl.uniform4fv(i2, e5);
  }
  setUniformMatrix3fv(t, e5, o2 = false, i2) {
    _2(i2, e5);
    const n3 = this._getUniformLocation(t);
    null != n3 && f2(this._nameToUniformMatrix3, t, e5) && this._context.gl.uniformMatrix3fv(n3, o2, e5);
  }
  setUniformMatrix4fv(t, e5, o2 = false, i2) {
    _2(i2, e5);
    const n3 = this._getUniformLocation(t);
    if (null != n3) {
      const i3 = this._nameToUniformMatrix4, r3 = i3.get(t);
      let s3 = false;
      if (r3) {
        const o3 = e5.length;
        if (r3.length !== o3) i3.set(t, Array.from(e5)), s3 = true;
        else for (let t2 = 0; t2 < o3; ++t2) {
          const i4 = e5[t2];
          if (r3[t2] !== i4) {
            for (r3[t2] = i4; t2 < o3; ++t2) r3[t2] = e5[t2];
            s3 = true;
            break;
          }
        }
      } else i3.set(t, Array.from(e5)), s3 = true;
      s3 && this._context.gl.uniformMatrix4fv(n3, o2, e5);
    }
  }
  setUniformMatrices4fv(t, e5, o2 = false, i2) {
    _2(i2, e5);
    const n3 = this._getUniformLocation(t);
    null != n3 && f2(this._nameToUniformMatrix4, t, e5) && this._context.gl.uniformMatrix4fv(n3, o2, e5);
  }
  stop() {
  }
};
function a3(e5, o2, i2) {
  const n3 = e5.gl, r3 = n3.createShader(o2);
  return n3.shaderSource(r3, i2), n3.compileShader(r3), c() && !n3.getShaderParameter(r3, n3.COMPILE_STATUS) && (console.error("Compile error in ".concat(35633 === o2 ? "vertex" : "fragment", " shader")), console.error(n3.getShaderInfoLog(r3)), console.error(m2(i2))), r3;
}
function m2(t) {
  let e5 = 2;
  return t.replaceAll("\n", () => "\n" + h2(e5++) + ":");
}
function h2(t) {
  return t >= 1e3 ? t.toString() : ("  " + t).slice(-3);
}
function f2(t, e5, o2) {
  const i2 = t.get(e5);
  if (!i2) return t.set(e5, Array.from(o2)), true;
  const n3 = o2.length;
  if (i2.length !== n3) return t.set(e5, Array.from(o2)), true;
  for (let r3 = 0; r3 < n3; ++r3) {
    const t2 = o2[r3];
    if (i2[r3] !== t2) {
      for (i2[r3] = t2; r3 < n3; ++r3) i2[r3] = o2[r3];
      return true;
    }
  }
  return false;
}
var c3 = { enabled: false };
var l2 = a() ? (t, ...e5) => _2(t, e5) : () => {
};
var _2 = a() ? (t, e5) => {
  if (t?.supportsNaN) return;
  const o2 = e5.length;
  for (let i2 = 0; i2 < o2; ++i2) {
    const t2 = e5[i2];
    Number.isNaN(t2) && console.error(`Got ${t2} as uniform value from ${new Error().stack}`);
  }
} : () => {
};

// node_modules/@arcgis/core/views/webgl/ShaderCompiler.js
var e3 = class {
  constructor(e5) {
    this._readFile = e5;
  }
  resolveIncludes(e5) {
    return this._resolve(e5);
  }
  _resolve(e5, t = /* @__PURE__ */ new Map()) {
    if (t.has(e5)) return t.get(e5);
    const r3 = this._read(e5);
    if (!r3) throw new Error(`cannot find shader file ${e5}`);
    const s3 = /^[^\S\n]*#include\s+<(\S+)>[^\S\n]?/gm;
    let n3 = s3.exec(r3);
    const l3 = [];
    for (; null != n3; ) l3.push({ path: n3[1], start: n3.index, length: n3[0].length }), n3 = s3.exec(r3);
    let a4 = 0, h3 = "";
    return l3.forEach((e6) => {
      h3 += r3.slice(a4, e6.start), h3 += t.has(e6.path) ? "" : this._resolve(e6.path, t), a4 = e6.start + e6.length;
    }), h3 += r3.slice(a4), t.set(e5, h3), h3;
  }
  _read(e5) {
    return this._readFile(e5);
  }
};

// node_modules/@arcgis/core/views/webgl/ProgramTemplate.js
function e4(e5, t, n3, o2 = "") {
  return new s2(e5, o2 + t.vertexShader, o2 + t.fragmentShader, n3);
}

export {
  s2 as s,
  e3 as e,
  e4 as e2
};
//# sourceMappingURL=chunk-RZOWZMPW.js.map
