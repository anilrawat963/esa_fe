import {
  n as n2,
  n2 as n3,
  y as y2
} from "./chunk-P77QHDEC.js";
import {
  n as n4
} from "./chunk-E77VVW2C.js";
import {
  i as i3
} from "./chunk-UXLDVCDU.js";
import {
  r2 as r
} from "./chunk-43423NKQ.js";
import {
  b
} from "./chunk-T5PAMHK6.js";
import {
  d as d4
} from "./chunk-PZZ55S55.js";
import "./chunk-ALLCMCHO.js";
import "./chunk-RZOWZMPW.js";
import "./chunk-7LPDSYJP.js";
import "./chunk-VIDAPS4J.js";
import "./chunk-QTS3W27E.js";
import "./chunk-3RABUJDL.js";
import {
  t as t3,
  t2 as t4
} from "./chunk-VIMURIWZ.js";
import "./chunk-U3B7YMY7.js";
import {
  D,
  l
} from "./chunk-PG6JVA4Q.js";
import {
  c,
  o as o2,
  t as t2
} from "./chunk-XMUWUWWP.js";
import "./chunk-F75XORHS.js";
import {
  o,
  s as s3
} from "./chunk-VKFTCFFM.js";
import "./chunk-JPZOLUPV.js";
import {
  u as u2
} from "./chunk-F7RQDGE7.js";
import "./chunk-GG4AQJJO.js";
import {
  t
} from "./chunk-VZQ643XD.js";
import {
  d as d3
} from "./chunk-SMJWJAIA.js";
import {
  p,
  y
} from "./chunk-FHCV4NTV.js";
import "./chunk-M5JMVUW2.js";
import "./chunk-XTEXJOLG.js";
import "./chunk-SXZO7ULH.js";
import "./chunk-ALR6N4CF.js";
import "./chunk-4X4BOGIG.js";
import {
  n
} from "./chunk-IOJ4QFRL.js";
import {
  s
} from "./chunk-Q7VRQYAO.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import {
  e as e4
} from "./chunk-EKZRA6TO.js";
import "./chunk-M5SP6ZBM.js";
import "./chunk-XX3OKYJS.js";
import "./chunk-OTCNIJ2H.js";
import "./chunk-JGA5YJWL.js";
import "./chunk-GCI4MA3M.js";
import "./chunk-SJ2OBYX2.js";
import "./chunk-IXRRTVLJ.js";
import "./chunk-EKM7KERW.js";
import {
  e as e6
} from "./chunk-WKTI47FV.js";
import "./chunk-T3SYSTKO.js";
import {
  A,
  h as h2
} from "./chunk-U55FA2EK.js";
import "./chunk-SHPBZTDJ.js";
import {
  p as p3
} from "./chunk-ZCI5A4FF.js";
import {
  p as p2
} from "./chunk-ZSZK67ZL.js";
import "./chunk-IPWH4LK2.js";
import {
  h,
  s as s2
} from "./chunk-7CDU3B2L.js";
import "./chunk-B5A4L35M.js";
import "./chunk-52SEOH5H.js";
import {
  e as e5
} from "./chunk-JUZ3H47H.js";
import "./chunk-UYMV6HXW.js";
import "./chunk-JE2NJSBU.js";
import "./chunk-2D47RURG.js";
import "./chunk-QNVJVDYZ.js";
import "./chunk-WDTGOP77.js";
import "./chunk-VYMBX5H5.js";
import "./chunk-BPTFV5VM.js";
import {
  z
} from "./chunk-YP3WVJP3.js";
import "./chunk-M24KZOVI.js";
import {
  f as f2
} from "./chunk-XDLV73DB.js";
import "./chunk-ARTU4L55.js";
import "./chunk-DFK6QMLO.js";
import "./chunk-4WTOIJXV.js";
import "./chunk-BBYMM7CM.js";
import "./chunk-EM7Y2JZC.js";
import "./chunk-BUQC3CLV.js";
import {
  _ as _2
} from "./chunk-C3FRY5U4.js";
import "./chunk-JNJX34GB.js";
import "./chunk-3STJRSDT.js";
import "./chunk-67Q6KVC6.js";
import "./chunk-23NJHA5Q.js";
import "./chunk-4LA6K4VI.js";
import "./chunk-KEZCWFAR.js";
import "./chunk-JZUJ34RR.js";
import "./chunk-PMGS7UDU.js";
import "./chunk-3GHCGAH2.js";
import "./chunk-HWUOAPTX.js";
import "./chunk-QHCKOBU7.js";
import "./chunk-K2OZ6WVC.js";
import "./chunk-MC6NAKKX.js";
import "./chunk-TF6255HN.js";
import "./chunk-GD4FJL3C.js";
import "./chunk-C5OQVQZF.js";
import "./chunk-F7DKSAOI.js";
import "./chunk-4SOQWNPG.js";
import "./chunk-LTULADK2.js";
import "./chunk-35ST7YRB.js";
import "./chunk-EDA5QFHZ.js";
import "./chunk-6KDQMJAI.js";
import "./chunk-UDHS2MGH.js";
import "./chunk-ENINOZUZ.js";
import "./chunk-V2X4OKYI.js";
import "./chunk-XLOINTMG.js";
import "./chunk-MA3QDRC3.js";
import "./chunk-W6J7XCPU.js";
import "./chunk-ONXWBTTM.js";
import "./chunk-T7F6Q6JJ.js";
import "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-7P2ANHQ3.js";
import "./chunk-XCKT47LJ.js";
import "./chunk-3FUHCAX3.js";
import "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import {
  d as d2,
  e as e3,
  i as i2
} from "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import "./chunk-2OFHDVO5.js";
import "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-5UPBUJPC.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-CCQFL76O.js";
import "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import "./chunk-7H3U4IJR.js";
import "./chunk-SMWUT52Z.js";
import {
  _
} from "./chunk-AXZMNHTN.js";
import "./chunk-5T3MJDSR.js";
import {
  T
} from "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import {
  Bt,
  H2 as H
} from "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import {
  e
} from "./chunk-4DGC7CBY.js";
import {
  d,
  e2,
  f2 as f,
  j,
  m2,
  u2 as u
} from "./chunk-GNMPGHLQ.js";
import {
  a,
  i3 as i
} from "./chunk-QY7XKUIV.js";
import "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/graphic/isVectorTileGraphicOrigin.js
var i4 = Symbol("isVectorTileGraphicOrigin");
function n5(n8) {
  return !!n8 && i4 in n8;
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/RectangleBinPack.js
var e7 = class {
  constructor(e8, t7) {
    this._width = 0, this._height = 0, this._free = [], this._width = e8, this._height = t7, this._free.push(new t(0, 0, e8, t7));
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  allocate(e8, t7) {
    if (e8 > this._width || t7 > this._height) return new t();
    let i6 = null, s6 = -1;
    for (let h8 = 0; h8 < this._free.length; ++h8) {
      const w = this._free[h8];
      e8 <= w.width && t7 <= w.height && (null === i6 || w.y <= i6.y && w.x <= i6.x) && (i6 = w, s6 = h8);
    }
    return null === i6 ? new t() : (this._free.splice(s6, 1), i6.width < i6.height ? (i6.width > e8 && this._free.push(new t(i6.x + e8, i6.y, i6.width - e8, t7)), i6.height > t7 && this._free.push(new t(i6.x, i6.y + t7, i6.width, i6.height - t7))) : (i6.width > e8 && this._free.push(new t(i6.x + e8, i6.y, i6.width - e8, i6.height)), i6.height > t7 && this._free.push(new t(i6.x, i6.y + t7, e8, i6.height - t7))), new t(i6.x, i6.y, e8, t7));
  }
  release(h8) {
    for (let e8 = 0; e8 < this._free.length; ++e8) {
      const t7 = this._free[e8];
      if (t7.y === h8.y && t7.height === h8.height && t7.x + t7.width === h8.x) t7.width += h8.width;
      else if (t7.x === h8.x && t7.width === h8.width && t7.y + t7.height === h8.y) t7.height += h8.height;
      else if (h8.y === t7.y && h8.height === t7.height && h8.x + h8.width === t7.x) t7.x = h8.x, t7.width += h8.width;
      else {
        if (h8.x !== t7.x || h8.width !== t7.width || h8.y + h8.height !== t7.y) continue;
        t7.y = h8.y, t7.height += h8.height;
      }
      this._free.splice(e8, 1), this.release(h8);
    }
    this._free.push(h8);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/GlyphMosaic.js
var h3 = class {
  constructor(e8, s6, i6) {
    this.width = 0, this.height = 0, this._dirties = [], this._glyphData = [], this._currentPage = 0, this._glyphIndex = {}, this._textures = [], this._rangePromises = /* @__PURE__ */ new Map(), this.width = e8, this.height = s6, this._glyphSource = i6, this._binPack = new e7(e8 - 4, s6 - 4), this._glyphData.push(new Uint8Array(e8 * s6)), this._dirties.push(true), this._textures.push(void 0);
  }
  getGlyphItems(s6, i6) {
    const h8 = [], r4 = this._glyphSource, n8 = /* @__PURE__ */ new Set(), o3 = 1 / 256;
    for (const t7 of i6) {
      const e8 = Math.floor(t7 * o3);
      n8.add(e8);
    }
    const a6 = [];
    return n8.forEach((t7) => {
      const e8 = s6 + t7;
      if (this._rangePromises.has(e8)) a6.push(this._rangePromises.get(e8));
      else {
        const i7 = r4.getRange(s6, t7).then(() => {
          this._rangePromises.delete(e8);
        }, () => {
          this._rangePromises.delete(e8);
        });
        this._rangePromises.set(e8, i7), a6.push(i7);
      }
    }), Promise.all(a6).then(() => {
      let n9 = this._glyphIndex[s6];
      n9 || (n9 = {}, this._glyphIndex[s6] = n9);
      for (const o4 of i6) {
        const i7 = n9[o4];
        if (i7) {
          h8[o4] = { sdf: true, rect: i7.rect, metrics: i7.metrics, page: i7.page, code: o4 };
          continue;
        }
        const a7 = r4.getGlyph(s6, o4);
        if (!a7?.metrics) continue;
        const l2 = a7.metrics;
        let c4;
        if (0 === l2.width) c4 = new t(0, 0, 0, 0);
        else {
          const e8 = 3, s7 = l2.width + 2 * e8, i8 = l2.height + 2 * e8;
          let h9 = s7 % 4 ? 4 - s7 % 4 : 4, r5 = i8 % 4 ? 4 - i8 % 4 : 4;
          1 === h9 && (h9 = 5), 1 === r5 && (r5 = 5), c4 = this._binPack.allocate(s7 + h9, i8 + r5), c4.isEmpty && (this._dirties[this._currentPage] || (this._glyphData[this._currentPage] = null), this._currentPage = this._glyphData.length, this._glyphData.push(new Uint8Array(this.width * this.height)), this._dirties.push(true), this._textures.push(void 0), this._binPack = new e7(this.width - 4, this.height - 4), c4 = this._binPack.allocate(s7 + h9, i8 + r5));
          const n10 = this._glyphData[this._currentPage], o5 = a7.bitmap;
          let g, _3;
          if (o5) for (let t7 = 0; t7 < i8; t7++) {
            g = s7 * t7, _3 = this.width * (c4.y + t7 + 1) + c4.x;
            for (let t8 = 0; t8 < s7; t8++) n10[_3 + t8 + 1] = o5.at(g + t8);
          }
        }
        n9[o4] = { rect: c4, metrics: l2, tileIDs: null, page: this._currentPage }, h8[o4] = { sdf: true, rect: c4, metrics: l2, page: this._currentPage, code: o4 }, this._dirties[this._currentPage] = true;
      }
      return h8;
    });
  }
  removeGlyphs(t7) {
    for (const e8 in this._glyphIndex) {
      const s6 = this._glyphIndex[e8];
      if (!s6) continue;
      let i6;
      for (const e9 in s6) if (i6 = s6[e9], i6.tileIDs.delete(t7), 0 === i6.tileIDs.size) {
        const t8 = this._glyphData[i6.page], h8 = i6.rect;
        let r4, n8;
        for (let e10 = 0; e10 < h8.height; e10++) for (r4 = this.width * (h8.y + e10) + h8.x, n8 = 0; n8 < h8.width; n8++) t8[r4 + n8] = 0;
        delete s6[e9], this._dirties[i6.page] = true;
      }
    }
  }
  bind(t7, e8, h8, r4 = 0) {
    if (!this._textures[h8]) {
      const e9 = new h2(this.width, this.height);
      e9.pixelFormat = 6406, e9.wrapMode = 33071, this._textures[h8] = new A(t7, e9, new Uint8Array(this.width * this.height));
    }
    const n8 = this._textures[h8];
    n8.setSamplingMode(e8), this._dirties[h8] && n8.setData(this._glyphData[h8]), t7.bindTexture(n8, r4), this._dirties[h8] = false;
  }
  destroy() {
    this.dispose();
  }
  dispose() {
    this._glyphData.length = 0, this._binPack = null;
    for (const t7 of this._textures) t7 && t7.dispose();
    this._textures.length = 0;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/GlyphSource.js
var s4 = class {
  constructor(t7) {
    if (this._metrics = [], !t7) return void (this._allBitmaps = null);
    const e8 = /* @__PURE__ */ new Map();
    let s6 = 0;
    for (; t7.next(); ) switch (t7.tag()) {
      case 1: {
        const a7 = t7.getMessage();
        for (; a7.next(); ) switch (a7.tag()) {
          case 3: {
            const t8 = a7.getMessage();
            let r5, n8, i6, c4, o3, g, h8;
            for (; t8.next(); ) switch (t8.tag()) {
              case 1:
                r5 = t8.getUInt32();
                break;
              case 2:
                n8 = t8.getBytes();
                break;
              case 3:
                i6 = t8.getUInt32();
                break;
              case 4:
                c4 = t8.getUInt32();
                break;
              case 5:
                o3 = t8.getSInt32();
                break;
              case 6:
                g = t8.getSInt32();
                break;
              case 7:
                h8 = t8.getUInt32();
                break;
              default:
                t8.skip();
            }
            if (t8.release(), r5) {
              const t9 = n8?.length ?? 0;
              this._metrics[r5] = { width: i6, height: c4, left: o3, top: g, advance: h8, startOffset: s6, length: t9 }, e8.set(r5, n8), s6 += t9;
            }
            break;
          }
          default:
            a7.skip();
        }
        a7.release();
        break;
      }
      default:
        t7.skip();
    }
    const a6 = new Uint8Array(s6), r4 = this._metrics;
    for (const [n8, i6] of e8) {
      const { startOffset: t8, length: e9 } = r4[n8];
      if (i6) for (let s7 = 0; s7 < e9; ++s7) a6[t8 + s7] = i6[s7];
    }
    this._allBitmaps = a6;
  }
  getMetrics(t7) {
    return this._metrics[t7];
  }
  getBitmap(t7) {
    if (!this._allBitmaps) return;
    const e8 = this._metrics[t7];
    if (void 0 === e8) return;
    const { startOffset: s6, length: a6 } = e8;
    return 0 !== a6 ? new n6(this._allBitmaps, s6, a6) : void 0;
  }
};
var a3 = class {
  constructor() {
    this._ranges = [];
  }
  get ranges() {
    return this._ranges;
  }
  getRange(t7) {
    return this._ranges[t7];
  }
  addRange(t7, e8) {
    this._ranges[t7] = e8;
  }
};
var r2 = class {
  constructor(t7) {
    this._glyphInfo = {}, this._baseURL = t7;
  }
  getRange(a6, r4) {
    const n8 = this._getFontStack(a6);
    if (n8.getRange(r4)) return Promise.resolve();
    const i6 = 256 * r4, c4 = i6 + 255;
    if (this._baseURL) {
      const o3 = this._baseURL.replace("{fontstack}", a6).replace("{range}", i6 + "-" + c4);
      return H(o3, { responseType: "array-buffer" }).then((t7) => {
        n8.addRange(r4, new s4(new n(new Uint8Array(t7.data), new DataView(t7.data))));
      }).catch(() => {
        n8.addRange(r4, new s4());
      });
    }
    return n8.addRange(r4, new s4()), Promise.resolve();
  }
  getGlyph(t7, e8) {
    const s6 = this._getFontStack(t7);
    if (!s6) return;
    const a6 = Math.floor(e8 / 256), r4 = s6.getRange(a6);
    return r4 ? { metrics: r4.getMetrics(e8), bitmap: r4.getBitmap(e8) } : void 0;
  }
  _getFontStack(t7) {
    let e8 = this._glyphInfo[t7];
    return e8 || (e8 = this._glyphInfo[t7] = new a3()), e8;
  }
};
var n6 = class {
  constructor(t7, e8, s6) {
    this._array = t7, this._start = e8, this.length = s6;
  }
  at(t7) {
    return 0 <= t7 && t7 < this.length ? this._array[this._start + t7] : void 0;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/SpriteMosaic.js
var a4 = "dasharray-";
var r3 = class _r {
  constructor(t7, s6, e8 = 0) {
    this._size = [], this._mosaicsData = [], this._textures = [], this._dirties = [], this._maxItemSize = 0, this._currentPage = 0, this._pageWidth = 0, this._pageHeight = 0, this._mosaicRects = {}, this.pixelRatio = 1, s6 <= 0 && console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"), this._pageWidth = t7, this._pageHeight = s6, e8 > 0 && (this._maxItemSize = e8), this._binPack = new e7(t7 - 4, s6 - 4);
  }
  destroy() {
    this.dispose();
  }
  dispose() {
    this._binPack = null, this._mosaicsData.length = 0, this._mosaicRects = {};
    for (const t7 of this._textures) t7 && t7.dispose();
    this._textures.length = 0;
  }
  getWidth(t7) {
    return t7 >= this._size.length ? -1 : this._size[t7][0];
  }
  getHeight(t7) {
    return t7 >= this._size.length ? -1 : this._size[t7][1];
  }
  getPageSize(t7) {
    return t7 >= this._size.length ? null : this._size[t7];
  }
  setSpriteSource(t7) {
    if (this.dispose(), this.pixelRatio = t7.devicePixelRatio, 0 === this._mosaicsData.length) {
      this._binPack = new e7(this._pageWidth - 4, this._pageHeight - 4);
      const t8 = Math.floor(this._pageWidth), s6 = Math.floor(this._pageHeight), e8 = new Uint32Array(t8 * s6);
      this._mosaicsData[0] = e8, this._dirties.push(true), this._size.push([this._pageWidth, this._pageHeight]), this._textures.push(void 0);
    }
    this._sprites = t7;
  }
  getSpriteItem(t7, i6 = false) {
    let s6, e8, h8 = this._mosaicRects[t7];
    if (h8) return h8;
    if (!this._sprites || "loaded" !== this._sprites.loadStatus) return null;
    if (t7 && t7.startsWith(a4) ? ([s6, e8] = this._rasterizeDash(t7), i6 = true) : s6 = this._sprites.getSpriteInfo(t7), !s6?.width || !s6.height || s6.width < 0 || s6.height < 0) return null;
    const r4 = s6.width, o3 = s6.height, [n8, _3, g] = this._allocateImage(r4, o3);
    return n8.width <= 0 ? null : (this._copy(n8, s6, _3, g, i6, e8), h8 = { type: "sprite", rect: n8, width: r4, height: o3, sdf: s6.sdf, simplePattern: false, rasterizationScale: s6.pixelRatio ?? 1, samplingMode: "Linear", page: _3 }, this._mosaicRects[t7] = h8, h8);
  }
  getSpriteItems(t7) {
    const i6 = {};
    for (const s6 of t7) i6[s6.name] = this.getSpriteItem(s6.name, s6.repeat);
    return i6;
  }
  getMosaicItemPosition(t7, i6) {
    const s6 = this.getSpriteItem(t7, i6), e8 = s6?.rect;
    if (!e8) return null;
    e8.width = s6.width, e8.height = s6.height;
    const h8 = s6.width, a6 = s6.height, r4 = 2;
    return { tl: [e8.x + r4, e8.y + r4], br: [e8.x + r4 + h8, e8.y + r4 + a6], page: s6.page };
  }
  bind(t7, i6, s6 = 0, a6 = 0) {
    if (s6 >= this._size.length || s6 >= this._mosaicsData.length) return;
    if (!this._textures[s6]) {
      const i7 = new h2(this._size[s6][0], this._size[s6][1]);
      i7.wrapMode = 33071, this._textures[s6] = new A(t7, i7, new Uint8Array(this._mosaicsData[s6].buffer));
    }
    const r4 = this._textures[s6];
    r4.setSamplingMode(i6), this._dirties[s6] && r4.setData(new Uint8Array(this._mosaicsData[s6].buffer)), t7.bindTexture(r4, a6), this._dirties[s6] = false;
  }
  static _copyBits(t7, i6, s6, e8, h8, a6, r4, o3, n8, _3, g) {
    let c4 = e8 * i6 + s6, p5 = o3 * a6 + r4;
    if (g) {
      p5 -= a6;
      for (let r5 = -1; r5 <= _3; r5++, c4 = ((r5 + _3) % _3 + e8) * i6 + s6, p5 += a6) for (let i7 = -1; i7 <= n8; i7++) h8[p5 + i7] = t7[c4 + (i7 + n8) % n8];
    } else for (let l2 = 0; l2 < _3; l2++) {
      for (let i7 = 0; i7 < n8; i7++) h8[p5 + i7] = t7[c4 + i7];
      c4 += i6, p5 += a6;
    }
  }
  _copy(t7, i6, s6, e8, h8, a6) {
    if (!this._sprites || "loaded" !== this._sprites.loadStatus || s6 >= this._mosaicsData.length) return;
    const o3 = new Uint32Array(a6 ? a6.buffer : this._sprites.image.buffer), n8 = this._mosaicsData[s6], _3 = 2, g = a6 ? i6.width : this._sprites.width;
    _r._copyBits(o3, g, i6.x, i6.y, n8, e8[0], t7.x + _3, t7.y + _3, i6.width, i6.height, h8), this._dirties[s6] = true;
  }
  _allocateImage(t7, e8) {
    t7 += 2, e8 += 2;
    const h8 = Math.max(t7, e8);
    if (this._maxItemSize && this._maxItemSize < h8) {
      const i6 = new t(0, 0, t7, e8);
      return this._mosaicsData.push(new Uint32Array(t7 * e8)), this._dirties.push(true), this._size.push([t7, e8]), this._textures.push(void 0), [i6, this._mosaicsData.length - 1, [t7, e8]];
    }
    let a6 = t7 % 4 ? 4 - t7 % 4 : 4, r4 = e8 % 4 ? 4 - e8 % 4 : 4;
    1 === a6 && (a6 = 5), 1 === r4 && (r4 = 5);
    const o3 = this._binPack.allocate(t7 + a6, e8 + r4);
    return o3.width <= 0 ? (this._dirties[this._currentPage] || (this._mosaicsData[this._currentPage] = null), this._currentPage = this._mosaicsData.length, this._mosaicsData.push(new Uint32Array(this._pageWidth * this._pageHeight)), this._dirties.push(true), this._size.push([this._pageWidth, this._pageHeight]), this._textures.push(void 0), this._binPack = new e7(this._pageWidth - 4, this._pageHeight - 4), this._allocateImage(t7, e8)) : [o3, this._currentPage, [this._pageWidth, this._pageHeight]];
  }
  _rasterizeDash(i6) {
    const s6 = /\[(.*?)\]/, e8 = i6.match(s6);
    if (!e8) return null;
    const h8 = e8[1].split(",").map(Number), a6 = i6.slice(i6.lastIndexOf("-") + 1), [r4, o3, n8] = u2(h8, a6);
    return [{ x: 0, y: 0, width: o3, height: n8, sdf: true, pixelRatio: 1 }, new Uint8Array(r4.buffer)];
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileHandler.js
var h4 = class {
  constructor(t7, e8, s6, r4) {
    this._layer = t7, this._styleRepository = e8, this.devicePixelRatio = s6, this._sourceDataMaxLOD = r4, this._spriteMosaic = null, this._glyphMosaic = null, this._connection = null, this._spriteSourceAbortController = null, this._startOptionsInputSignal = null, this._inputSignalEventListener = null;
  }
  destroy() {
    this._connection?.close(), this._connection = null, this._styleRepository = null, this._layer = null, this._spriteMosaic?.destroy(), this._spriteMosaic = null, this._glyphMosaic = null, this._spriteSourceAbortController = e2(this._spriteSourceAbortController), this._spriteSourcePromise = null, this._inputSignalEventListener && this._startOptionsInputSignal?.removeEventListener("abort", this._inputSignalEventListener), this._startOptionsInputSignal = null, this._inputSignalEventListener = null;
  }
  get spriteMosaic() {
    return this._spriteSourcePromise.then(() => this._spriteMosaic);
  }
  get glyphMosaic() {
    return this._glyphMosaic;
  }
  async start(t7) {
    this._requestSprite(t7);
    const s6 = this._layer.currentStyleInfo.glyphsUrl, r4 = new r2(s6 ? Bt(s6, { ...this._layer.customParameters, token: this._layer.apiKey }) : null);
    this._glyphMosaic = new h3(1024, 1024, r4), this._broadcastPromise = p3("WorkerTileHandler", { client: this, schedule: t7.schedule, signal: t7.signal }).then((s7) => {
      if (this._layer && (this._connection?.close(), this._connection = s7, this._layer && !this._connection.closed)) {
        const r5 = s7.broadcast("setStyle", { style: this._layer.currentStyleInfo.style, sourceDataMaxLOD: this._sourceDataMaxLOD }, t7);
        Promise.all(r5).catch((t8) => m2(t8));
      }
    });
  }
  _requestSprite(t7) {
    this._spriteSourceAbortController?.abort();
    const e8 = new AbortController();
    this._spriteSourceAbortController = e8;
    const r4 = t7?.signal;
    this._inputSignalEventListener && this._startOptionsInputSignal?.removeEventListener("abort", this._inputSignalEventListener), this._startOptionsInputSignal = null, r4 && (this._inputSignalEventListener = p4(e8), r4.addEventListener("abort", this._inputSignalEventListener, { once: true }));
    const { signal: i6 } = e8, o3 = { ...t7, signal: i6 };
    this._spriteSourcePromise = this._layer.loadSpriteSource(this.devicePixelRatio, o3), this._spriteSourcePromise.then((t8) => {
      f(i6), this._spriteMosaic = new r3(1024, 1024, 250), this._spriteMosaic.setSpriteSource(t8);
    });
  }
  async updateStyle(t7) {
    const e8 = [];
    for (const s6 of t7) 4 === s6.type ? e8.push({ type: 4, data: { spriteSource: null } }) : e8.push(s6);
    return await this._broadcastPromise, this._broadcastPromise = Promise.all(this._connection.broadcast("updateStyle", e8)), this._broadcastPromise;
  }
  setSpriteSource(t7) {
    const e8 = new r3(1024, 1024, 250);
    return e8.setSpriteSource(t7), this._spriteMosaic = e8, this._spriteSourcePromise = Promise.resolve(t7), this._spriteSourceAbortController = null, e8;
  }
  async setStyle(t7, e8, s6) {
    await this._broadcastPromise, this._styleRepository = t7, this._sourceDataMaxLOD = s6, this._requestSprite();
    const r4 = new r2(this._layer.currentStyleInfo.glyphsUrl ? Bt(this._layer.currentStyleInfo.glyphsUrl, { ...this._layer.customParameters, token: this._layer.apiKey }) : null);
    return this._glyphMosaic = new h3(1024, 1024, r4), this._broadcastPromise = Promise.all(this._connection.broadcast("setStyle", { style: e8, sourceDataMaxLOD: this._sourceDataMaxLOD })), this._broadcastPromise;
  }
  async fetchTileData(t7, e8) {
    const s6 = await this._getRefKeys(t7, e8);
    return this._getSourcesData(Object.keys(this._layer.sourceNameToSource), s6, e8);
  }
  async fetchTilePBFs(t7) {
    const e8 = Object.keys(this._layer.sourceNameToSource), s6 = {}, r4 = await this._getRefKeys(t7, s6), i6 = [], o3 = [];
    for (let n8 = 0; n8 < r4.length; n8++) if (null == r4[n8].value || null == e8[n8]) o3.push(null);
    else {
      const t8 = r4[n8].value, a6 = this._getTilePayload(t8, e8[n8], s6);
      a6.then((e9) => {
        i6.push({ ...e9, key: t8 });
      }), o3.push(a6);
    }
    return Promise.all(o3).then(() => i6);
  }
  async parseTileData(t7, e8) {
    const s6 = t7 && t7.data;
    if (!s6) return null;
    const { sourceName2DataAndRefKey: r4, transferList: i6 } = s6;
    return 0 === Object.keys(r4).length ? null : this._broadcastPromise.then(() => this._connection.invoke("createTileAndParse", { key: t7.key.id, sourceName2DataAndRefKey: r4, styleLayerUIDs: t7.styleLayerUIDs }, { ...e8, transferList: i6 }));
  }
  async getSprites(t7) {
    return await this._spriteSourcePromise, this._spriteMosaic.getSpriteItems(t7);
  }
  getGlyphs(t7) {
    return this._glyphMosaic.getGlyphItems(t7.font, t7.codePoints);
  }
  async _getTilePayload(t7, e8, s6) {
    const i6 = e5.pool.acquire(t7.id), o3 = this._layer.sourceNameToSource[e8], { level: n8, row: a6, col: l2 } = i6;
    e5.pool.release(i6);
    try {
      return { protobuff: await o3.requestTile(n8, a6, l2, s6), sourceName: e8 };
    } catch (c4) {
      if (d(c4)) throw c4;
      return { protobuff: null, sourceName: e8 };
    }
  }
  async _getRefKeys(t7, e8) {
    const s6 = this._layer.sourceNameToSource, r4 = new Array();
    for (const i6 in s6) {
      const o3 = s6[i6].getRefKey(t7, e8);
      r4.push(o3);
    }
    return j(r4);
  }
  _getSourcesData(t7, e8, s6) {
    const r4 = [];
    for (let i6 = 0; i6 < e8.length; i6++) if (null == e8[i6].value || null == t7[i6]) r4.push(null);
    else {
      const o3 = e8[i6].value, n8 = this._getTilePayload(o3, t7[i6], s6);
      r4.push(n8);
    }
    return j(r4).then((t8) => {
      const s7 = {}, r5 = [];
      for (let i6 = 0; i6 < t8.length; i6++) {
        const o3 = t8[i6].value;
        if (o3 && (o3.protobuff && o3.protobuff.byteLength > 0)) {
          const t9 = e8[i6].value.id;
          s7[o3.sourceName] = { refKey: t9, protobuff: o3.protobuff }, r5.push(o3.protobuff);
        }
      }
      return { sourceName2DataAndRefKey: s7, transferList: r5 };
    });
  }
};
function p4(t7) {
  return () => t7.abort();
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileManager.js
var n7 = 1e-6;
var a5 = (e8, i6) => e8 + 1 / (1 << 2 * i6);
var c2 = class {
  constructor(i6, t7) {
    this._tiles = /* @__PURE__ */ new Map(), this._tileCache = new e4(40, (e8) => e8.dispose()), this._viewSize = [0, 0], this._visibleTiles = /* @__PURE__ */ new Map(), this.acquireTile = i6.acquireTile, this.releaseTile = i6.releaseTile, this.tileInfoView = i6.tileInfoView, this._container = t7;
  }
  destroy() {
    for (const e8 of this._tiles.values()) e8.dispose();
    this._tiles = null, this._tileCache.clear(), this._tileCache = null;
  }
  update(e8) {
    this._updateCacheSize(e8);
    const i6 = this.tileInfoView, t7 = i6.getTileCoverage(e8.state, 0, true, "smallest");
    if (!t7) return true;
    const { spans: s6, lodInfo: l2 } = t7, { level: n8 } = l2, a6 = this._tiles, c4 = /* @__PURE__ */ new Set(), h8 = /* @__PURE__ */ new Set();
    for (const { row: o3, colFrom: _3, colTo: f4 } of s6) for (let e9 = _3; e9 <= f4; e9++) {
      const i7 = e5.getId(n8, o3, l2.normalizeCol(e9), l2.getWorldForColumn(e9)), t8 = this._getOrAcquireTile(i7);
      c4.add(i7), t8.processed() ? this._addToContainer(t8) : h8.add(new e5(i7));
    }
    for (const [o3, r4] of a6) r4.isCoverage = c4.has(o3);
    for (const o3 of h8) this._findPlaceholdersForMissingTiles(o3, c4);
    let d6 = false;
    for (const [o3, r4] of a6) r4.neededForCoverage = c4.has(o3), r4.neededForCoverage || r4.isHoldingForFade && i6.intersects(t7, r4.key) && c4.add(o3), r4.isFading && (d6 = true);
    for (const o3 of this._tiles.keys()) c4.has(o3) || this._releaseTile(o3);
    return s2.pool.release(t7), !d6;
  }
  clear() {
    this._tiles.clear(), this._tileCache.clear(), this._visibleTiles.clear();
  }
  clearCache() {
    this._tileCache.clear();
  }
  getIntersectingTiles(e8, l2, o3, r4, n8) {
    const a6 = [0, 0], c4 = [0, 0];
    r4.toMap(a6, e8 - o3, l2 + o3), r4.toMap(c4, e8 + o3, l2 - o3);
    const h8 = Math.min(a6[0], c4[0]), d6 = Math.min(a6[1], c4[1]), _3 = Math.max(a6[0], c4[0]), f4 = Math.max(a6[1], c4[1]), T2 = e3(h8, d6, _3, f4), u4 = i2(), p5 = [];
    for (const i6 of this._visibleTiles.values()) this.tileInfoView.getTileBounds(u4, i6.key), d2(T2, u4) && p5.push(i6);
    if (null != n8 && n8.length > 0) {
      const e9 = new Set(p5.map((e10) => e10.id)), i6 = n8.filter((i7) => !e9.has(i7.tileKey.id)).map((e10) => this._visibleTiles.get(e10.tileKey.id)).filter((e10) => void 0 !== e10);
      p5.push(...i6);
    }
    return p5;
  }
  _findPlaceholdersForMissingTiles(e8, i6) {
    const t7 = [];
    for (const l2 of this._tiles.values()) this._addPlaceholderChild(t7, l2, e8, i6);
    const s6 = t7.reduce(a5, 0);
    Math.abs(1 - s6) < n7 || this._addPlaceholderParent(e8.id, i6);
  }
  _addPlaceholderChild(e8, i6, t7, s6) {
    i6.key.level <= t7.level || !i6.hasData() || d5(t7, i6.key) && (this._addToContainer(i6), s6.add(i6.id), e8.push(i6.key.level - t7.level));
  }
  _addPlaceholderParent(e8, i6) {
    const t7 = this._tiles;
    let s6 = e8;
    for (; ; ) {
      if (s6 = h5(s6), !s6 || i6.has(s6)) return;
      const e9 = t7.get(s6);
      if (e9?.hasData()) return this._addToContainer(e9), void i6.add(e9.id);
    }
  }
  _getOrAcquireTile(e8) {
    let i6 = this._tiles.get(e8);
    return i6 || (i6 = this._tileCache.pop(e8), i6 || (i6 = this.acquireTile(new e5(e8))), this._tiles.set(e8, i6), i6);
  }
  _releaseTile(e8) {
    const i6 = this._tiles.get(e8);
    this.releaseTile(i6), this._removeFromContainer(i6), this._tiles.delete(e8), i6.hasData() ? this._tileCache.put(e8, i6, 1) : i6.dispose();
  }
  _addToContainer(e8) {
    let i6;
    const t7 = [], s6 = this._container;
    if (s6.contains(e8)) return;
    const l2 = this._visibleTiles;
    for (const o3 of l2.values()) this._canConnectDirectly(e8, o3) && t7.push(o3), null == i6 && this._canConnectDirectly(o3, e8) && (i6 = o3);
    if (null != i6) {
      for (const s7 of t7) i6.childrenTiles.delete(s7), e8.childrenTiles.add(s7), s7.parentTile = e8;
      i6.childrenTiles.add(e8), e8.parentTile = i6;
    } else for (const o3 of t7) e8.childrenTiles.add(o3), o3.parentTile = e8;
    l2.set(e8.id, e8), s6.addChild(e8);
  }
  _removeFromContainer(e8) {
    if (this._visibleTiles.delete(e8.id), this._container.removeChild(e8), null != e8.parentTile) {
      e8.parentTile.childrenTiles.delete(e8);
      for (const i6 of e8.childrenTiles) null != e8.parentTile && e8.parentTile.childrenTiles.add(i6);
    }
    for (const i6 of e8.childrenTiles) i6.parentTile = e8.parentTile;
    e8.parentTile = null, e8.childrenTiles.clear();
  }
  _canConnectDirectly(e8, i6) {
    const t7 = e8.key;
    let { level: s6, row: l2, col: o3, world: r4 } = i6.key;
    const n8 = this._visibleTiles;
    for (; s6 > 0; ) {
      if (s6--, l2 >>= 1, o3 >>= 1, t7.level === s6 && t7.row === l2 && t7.col === o3 && t7.world === r4) return true;
      if (n8.has(`${s6}/${l2}/${o3}/${r4}`)) return false;
    }
    return false;
  }
  _updateCacheSize(e8) {
    const i6 = e8.state.size;
    if (i6[0] === this._viewSize[0] && i6[1] === this._viewSize[1]) return;
    const t7 = Math.ceil(i6[0] / o2) + 1, s6 = Math.ceil(i6[1] / o2) + 1;
    this._viewSize[0] = i6[0], this._viewSize[1] = i6[1], this._tileCache.maxSize = 5 * t7 * s6;
  }
};
function h5(e8) {
  const [i6, t7, s6, l2] = e8.split("/"), o3 = parseInt(i6, 10);
  return 0 === o3 ? null : `${o3 - 1}/${parseInt(t7, 10) >> 1}/${parseInt(s6, 10) >> 1}/${parseInt(l2, 10)}`;
}
function d5(e8, i6) {
  const t7 = i6.level - e8.level;
  return e8.row === i6.row >> t7 && e8.col === i6.col >> t7 && e8.world === i6.world;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/RenderableTile.js
var t5 = class extends r {
  _createTransforms() {
    return { displayViewScreenMat3: e6(), tileMat3: e6() };
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VectorTileContainer.js
var c3 = 1e-6;
function h6(e8, t7) {
  if (e8) {
    const s6 = e8.getLayoutProperty("visibility");
    if (!s6 || 1 !== s6.getValue() && (void 0 === e8.minzoom || e8.minzoom < t7 + c3) && (void 0 === e8.maxzoom || e8.maxzoom >= t7 - c3)) return true;
  }
  return false;
}
var u3 = class extends n4 {
  constructor(e8) {
    super(e8), this._backgroundTiles = [], this._computeDisplayInfoView(e8);
  }
  destroy() {
    super.destroy(), this.removeAllChildren(), this._spriteMosaic?.dispose(), this._spriteMosaic = null, this._glyphMosaic?.dispose(), this._glyphMosaic = null, null != this._symbolFader && (this._symbolFader.clear(), this._symbolFader = null), this._styleRepository = null, this._backgroundTiles = [];
  }
  get fading() {
    return this._symbolFader?.fading ?? false;
  }
  get symbolFader() {
    return this._symbolFader;
  }
  get symbolRepository() {
    return this._symbolFader?.symbolRepository;
  }
  setStyleResources(e8, t7, r4, o3) {
    if (this._spriteMosaic = e8, this._glyphMosaic = t7, this._styleRepository = r4, this.tileInfoView = o3, this._computeDisplayInfoView(o3), null == this._symbolFader) {
      const e9 = (e10, t8) => {
        e10.allSymbolsFadingOut = true, e10.lastOpacityUpdate = t8, n2(e10, t8, true), e10.decluttered = true, e10.requestRender();
      };
      this._symbolFader = new n3("vector-tile", this._styleRepository, e9, this.children, t2);
    }
    this._symbolFader.styleRepository = r4;
  }
  setSpriteMosaic(e8) {
    this._spriteMosaic?.dispose(), this._spriteMosaic = e8;
  }
  deleteStyleLayers(e8) {
    null != this._symbolFader && this._symbolFader.deleteStyleLayers(e8);
  }
  createRenderParams(e8) {
    return { ...super.createRenderParams(e8), renderPass: null, styleLayer: null, styleLayerUID: -1, glyphMosaic: this._glyphMosaic, spriteMosaic: this._spriteMosaic, hasClipping: !!this._clippingInfos };
  }
  doRender(e8) {
    !this.visible || 1 !== e8.drawPhase && 64 !== e8.drawPhase || void 0 === this._spriteMosaic || super.doRender(e8);
  }
  addChild(e8) {
    return super.addChild(e8), null != this._symbolFader ? this._symbolFader.addTile(e8) : e8.decluttered = true, this.requestRender(), e8;
  }
  removeChild(e8) {
    return null != this._symbolFader && this._symbolFader.removeTile(e8), this.requestRender(), super.removeChild(e8);
  }
  renderChildren(e8) {
    const { drawPhase: t7 } = e8;
    64 !== t7 ? this._doRender(e8) : super.renderChildren(e8);
  }
  removeAllChildren() {
    for (let e8 = 0; e8 < this.children.length; e8++) {
      const t7 = this.children[e8];
      null != this._symbolFader && this._symbolFader.removeTile(t7), t7.dispose();
    }
    super.removeAllChildren();
  }
  getStencilTarget() {
    return this.children.filter((e8) => e8.neededForCoverage && e8.hasData());
  }
  restartDeclutter() {
    null != this._symbolFader && this._symbolFader.restartDeclutter();
  }
  _doRender(e8) {
    const { context: t7, state: s6 } = e8, r4 = this._styleRepository;
    if (!r4) return;
    const i6 = r4.layers, l2 = this._displayInfo.scaleToZoom(s6.scale);
    r4.backgroundBucketIds.length > 0 && (e8.renderPass = "background", this._renderBackgroundLayers(e8, r4.backgroundBucketIds, l2)), super.renderChildren(e8), 1 === e8.drawPhase && this._fade(l2, s6);
    const o3 = this.children.filter((e9) => e9.visible && e9.hasData());
    if (!o3 || 0 === o3.length) return t7.bindVAO(null), t7.setStencilTestEnabled(true), void t7.setBlendingEnabled(true);
    for (const n8 of o3) n8.triangleCount = 0;
    t7.setStencilWriteMask(0), t7.setColorMask(true, true, true, true), t7.setStencilOp(7680, 7680, 7681), t7.setStencilTestEnabled(true), t7.setBlendingEnabled(false), t7.setDepthTestEnabled(true), t7.setDepthWriteEnabled(true), t7.setDepthFunction(515), t7.setClearDepth(1), t7.clear(256), e8.renderPass = "opaque";
    for (let n8 = i6.length - 1; n8 >= 0; n8--) this._renderStyleLayer(i6[n8], e8, o3);
    t7.setDepthWriteEnabled(false), t7.setBlendingEnabled(true), t7.setBlendFunctionSeparate(1, 771, 1, 771), e8.renderPass = "translucent";
    for (let n8 = 0; n8 < i6.length; n8++) this._renderStyleLayer(i6[n8], e8, o3);
    t7.bindVAO(null), t7.setStencilTestEnabled(true), t7.setBlendingEnabled(true);
    for (const n8 of o3) n8.debugInfo.display.triangleCount = n8.triangleCount;
  }
  _fade(e8, t7) {
    null != this._symbolFader && (this._symbolFader.update(e8, t7) || this.requestRender());
  }
  _renderStyleLayer(e8, t7, s6) {
    const { displayLevel: r4, painter: i6, renderPass: l2 } = t7;
    if (void 0 === e8) return;
    const o3 = e8.getLayoutProperty("visibility");
    if (o3 && 1 === o3.getValue()) return;
    let n8;
    switch (e8.type) {
      case 0:
        return;
      case 1:
        if ("opaque" !== l2 && "translucent" !== t7.renderPass) return;
        n8 = "vtlFill";
        break;
      case 2:
        if ("translucent" !== l2) return;
        n8 = "vtlLine";
        break;
      case 4:
        if ("translucent" !== l2) return;
        n8 = "vtlCircle";
        break;
      case 3:
        if ("translucent" !== l2) return;
        n8 = "vtlSymbol";
    }
    if (s6 = 3 === e8.type ? s6.filter((e9) => e9.decluttered) : s6.filter((e9) => e9.neededForCoverage), "vtlSymbol" !== n8 && (0 === s6.length || void 0 !== e8.minzoom && e8.minzoom >= r4 + c3 || void 0 !== e8.maxzoom && e8.maxzoom < r4 - c3)) return;
    const a6 = e8.uid;
    t7.styleLayerUID = a6, t7.styleLayer = e8;
    for (const d6 of s6) if (d6.layerData.has(a6)) {
      i6.renderObjects(t7, s6, n8);
      break;
    }
  }
  _renderBackgroundLayers(t7, i6, l2) {
    const { context: n8, painter: c4, state: u4 } = t7, y3 = this._styleRepository;
    let p5 = false;
    for (const e8 of i6) {
      if (0 === y3.getLayerById(e8).type && h6(y3.getLayerById(e8), l2)) {
        p5 = true;
        break;
      }
    }
    if (!p5) return;
    const m4 = this.tileInfoView, f4 = m4.getTileCoverage(t7.state, 0, true, "smallest"), { spans: g, lodInfo: b3 } = f4, { level: _3 } = b3, F = i2(), v = [];
    if (this._renderPasses) {
      const e8 = this._renderPasses[0];
      null != this._clippingInfos && (e8.brushes[0].prepareState(t7), e8.brushes[0].drawMany(t7, this._clippingInfos));
    }
    const C = this._backgroundTiles;
    let R, T2 = 0;
    for (const { row: a6, colFrom: h8, colTo: I2 } of g) for (let t8 = h8; t8 <= I2; t8++) {
      if (T2 < C.length) R = C[T2], R.key.set(_3, a6, b3.normalizeCol(t8), b3.getWorldForColumn(t8)), m4.getTileBounds(F, R.key, false), R.x = F[0], R.y = F[3], R.resolution = m4.getTileResolution(_3);
      else {
        const i7 = new e5(_3, a6, b3.normalizeCol(t8), b3.getWorldForColumn(t8)), l3 = m4.getTileBounds(i2(), i7), n9 = m4.getTileResolution(_3);
        R = new t5(i7, n9, l3[0], l3[3], o2, o2, t2, t2), C.push(R);
      }
      R.setTransform(u4), v.push(R), T2++;
    }
    n8.setStencilWriteMask(0), n8.setColorMask(true, true, true, true), n8.setStencilOp(7680, 7680, 7681), n8.setStencilFunction(514, 0, 255), n8.setStencilTestEnabled(true);
    for (const e8 of i6) {
      const s6 = y3.getLayerById(e8);
      0 === s6.type && h6(s6, l2) && (t7.styleLayerUID = s6.uid, t7.styleLayer = s6, c4.renderObjects(t7, v, "vtlBackground"));
    }
    s2.pool.release(f4);
  }
  _computeDisplayInfoView(e8) {
    let s6 = e8.tileInfo.lods[0].scale;
    const i6 = Math.max(25, e8.tileInfo.lods.length), l2 = [];
    for (let t7 = 0; t7 <= i6; t7++) l2.push(s6), s6 /= 2;
    this._displayInfo = z.create({ scales: l2, size: o2, spatialReference: e8.spatialReference, numLODs: i6 });
  }
};

// node_modules/@arcgis/core/graphic/VectorTileGraphicOrigin.js
var i5;
var s5 = class extends s3 {
  get [(i5 = i4, o)]() {
    return this.layer;
  }
  constructor(r4, e8, t7) {
    super(), this[i5] = true, this.type = "vector-tile", this.layer = r4, this.layerId = e8, this.layerIndex = t7;
  }
  get id() {
    return `${this.layer.id}:__${this.layerId}__:__${this.layerIndex}__`;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VectorTileFeatureIndex.js
var h7 = (e8, t7) => {
  const s6 = e8.vtlSymbol.sourceTile, r4 = t7.vtlSymbol.sourceTile;
  return s6.level !== r4.level ? s6.level - r4.level : s6.row !== r4.row ? s6.row - r4.row : s6.col !== r4.col ? s6.col - r4.col : e8.styleLayerUID - t7.styleLayerUID;
};
var m3 = class _m {
  constructor(e8, t7, s6, r4, i6) {
    this.tileKey = e8, this._tileLayerData = t7, this._styleRepository = s6, this._tileHandler = r4, this._parentLayer = i6, this._index = null, this._tileKeyToPBF = /* @__PURE__ */ new Map();
  }
  static create(e8, t7, s6, r4, i6) {
    return new _m(e8, t7, s6, r4, i6);
  }
  clear() {
    this._index?.clear(), this._tileKeyToPBF.clear();
  }
  async queryAttributes(e8, t7, s6, i6, o3) {
    if (0 === this._tileLayerData.size || !this._styleRepository || !this._tileHandler) return [];
    null === this._index && (this._index = new s(100, f3), await this._indexLayers());
    const l2 = [];
    return this._queryIndex(l2, e8, t7, s6, this.tileKey.level, i6), o3 && o3?.length > 0 && await this._getSymbolsAttributes(l2, o3), l2;
  }
  async _indexLayers() {
    const e8 = this.tileKey, t7 = this._styleRepository.layers, s6 = await this._getTilePayload(e8);
    for (const [r4, i6] of this._tileLayerData) {
      const o3 = t7[r4], l2 = s6.find((e9) => e9.sourceName === o3.source);
      if (!l2) continue;
      const { protobuff: n8, key: a6 } = l2;
      if (3 !== i6.type) {
        const t8 = 1 << e8.level - a6.level, s7 = e8.row - a6.row * t8, r5 = e8.col - a6.col * t8;
        this._indexLayer(o3, n8, e8.level, t8, s7, r5);
      }
    }
  }
  _indexLayer(e8, t7, r4, i6, n8, h8) {
    const m4 = e8.sourceLayer, f4 = e8.getFeatureFilter(), d6 = r4, _3 = r4 + 1, p5 = d3(d6), g = new n(new Uint8Array(t7), new DataView(t7));
    for (; g.next(); ) switch (g.tag()) {
      case 3: {
        const t8 = g.getMessage(), s6 = new t4(t8);
        if (t8.release(), s6.name !== m4) continue;
        const y3 = s6.getData(), w = s6.extent / i6, b3 = w * h8 - p5, x = w * n8 - p5, L = b3 + w + 2 * p5, v = x + w + 2 * p5, I2 = w / o2, T2 = t2 / w, D2 = w * h8, P2 = w * n8;
        for (; y3.nextTag(2); ) {
          const t9 = y3.getMessage(), i7 = new t3(t9, s6);
          if (t9.release(), f4 && !f4.filter(i7, r4)) continue;
          const o3 = i7.values || {}, l2 = o3._minzoom, n9 = o3._maxzoom;
          if (l2 && l2 >= 10 * _3 || n9 && n9 <= 10 * d6) continue;
          const c4 = e8.getFeatureInflatedBounds(i7, d6, s6.extent, I2);
          null == c4 || c4[0] > L || c4[1] > v || c4[2] < b3 || c4[3] < x || (c4[0] = (c4[0] - D2) * T2, c4[1] = (c4[1] - P2) * T2, c4[2] = (c4[2] - D2) * T2, c4[3] = (c4[3] - P2) * T2, this._index.insert(new D(e8, i7, c4, T2, D2, P2)));
        }
        break;
      }
      default:
        g.skip();
    }
    g.release();
  }
  async _getSymbolsAttributes(e8, t7) {
    if (!t7 || 0 === t7.length) return e8;
    const s6 = [];
    if (t7.sort(h7), t7.length > 0) {
      let e9 = 0, { styleLayerUID: r5 } = t7[0];
      for (let o3 = 1; o3 < t7.length; o3++) {
        const { styleLayerUID: i7 } = t7[o3];
        i7 !== r5 && (s6.push({ from: e9, to: o3, styleLayerUID: r5, sourceTileKey: t7[o3 - 1].vtlSymbol.sourceTile }), e9 = o3, r5 = i7);
      }
      const i6 = t7.length - 1;
      s6.push({ from: e9, to: t7.length, styleLayerUID: r5, sourceTileKey: t7[i6].vtlSymbol.sourceTile });
    }
    const r4 = this._styleRepository.layers;
    for (const i6 of s6) {
      const s7 = await this._getTilePayload(i6.sourceTileKey), o3 = r4[i6.styleLayerUID], l2 = !!o3 && s7.find((e9) => e9.sourceName === o3.source);
      l2 && this._addSymbolsAttributes(e8, t7.slice(i6.from, i6.to).map((e9) => e9.vtlSymbol.featureIndex), i6.styleLayerUID, l2);
    }
    return e8;
  }
  _addSymbolsAttributes(t7, s6, r4, o3) {
    const l2 = this._styleRepository.layers, n8 = o3.key, a6 = this.tileKey, y3 = 1 << a6.level - n8.level, c4 = a6.row - n8.row * y3, u4 = a6.col - n8.col * y3;
    this._getSymbolAttributes(o3.protobuff, s6, r4, y3, c4, u4).forEach((s7) => {
      const { attributes: o4, tilePoint: n9 } = s7;
      t7.push({ layerId: l2[r4].id, layerIndex: r4, graphic: new _2({ attributes: o4, origin: new s5(this._parentLayer, l2[r4].id, r4) }), tilePoint: n9 });
    });
  }
  _getSymbolAttributes(e8, t7, r4, i6, o3, n8) {
    const y3 = [], u4 = this._styleRepository.layers;
    let h8 = 0;
    t7.sort((e9, t8) => e9 - t8);
    const m4 = new n(new Uint8Array(e8), new DataView(e8));
    for (; m4.next(); ) switch (m4.tag()) {
      case 3: {
        const e9 = m4.getMessage(), s6 = new t4(e9);
        if (e9.release(), s6.name !== u4[r4].sourceLayer) continue;
        const f4 = s6.getData(), d6 = s6.extent / i6, _3 = t2 / d6, p5 = d6 * n8, g = d6 * o3;
        let w = 0;
        for (; f4.nextTag(2); ) {
          const e10 = f4.getMessage();
          if (w++ === t7[h8]) {
            const t8 = new t3(e10, s6), r5 = t8.values, i7 = t8.getGeometry(), o4 = null != i7 ? [_3 * (i7[0][0].x - p5), _3 * (i7[0][0].y - g)] : null;
            y3.push({ attributes: r5, tilePoint: o4 }), h8++;
          }
          if (e10.release(), h8 === t7.length) return y3;
        }
        break;
      }
      default:
        m4.skip();
    }
    return m4.release(), y3;
  }
  _queryIndex(t7, s6, r4, o3, l2, a6) {
    const y3 = c * o3 * (window.devicePixelRatio || 1);
    return this._index?.search({ minX: s6 - y3, minY: r4 - y3, maxX: s6 + y3, maxY: r4 + y3 }, (n8) => {
      const { layer: y4, feature: c4 } = n8;
      y4.isIntersectingFeature(s6, r4, o3, c4, l2, a6, n8) && t7.push({ layerId: y4.id, layerIndex: y4.uid, tilePoint: null, graphic: new _2({ attributes: c4.values, origin: new s5(this._parentLayer, n8.layer.id, n8.layer.uid) }) });
    }), t7;
  }
  async _getTilePayload(e8) {
    return e(this._tileKeyToPBF, e8.id, () => this._tileHandler.fetchTilePBFs(e8)).then((e9) => e9);
  }
};
var f3 = (e8) => ({ minX: e8.bounds[0], minY: e8.bounds[1], maxX: e8.bounds[2], maxY: e8.bounds[3] });

// node_modules/@arcgis/core/views/2d/tiling/TileInfoViewPOT.js
var t6 = class extends h {
  constructor() {
    super(...arguments), this._fullCacheLodInfos = null, this._levelByScale = {};
  }
  getTileParentId(e8) {
    const l2 = e5.pool.acquire(e8), t7 = 0 === l2.level ? null : e5.getId(l2.level - 1, l2.row >> 1, l2.col >> 1, l2.world);
    return e5.pool.release(l2), t7;
  }
  getTileCoverage(e8, l2, s6 = true, t7) {
    const o3 = super.getTileCoverage(e8, l2, s6, t7);
    if (!o3) return o3;
    const i6 = 1 << o3.lodInfo.level;
    return o3.spans = o3.spans.filter((e9) => e9.row >= 0 && e9.row < i6), o3;
  }
  scaleToLevel(e8) {
    if (this._fullCacheLodInfos || this._initializeFullCacheLODs(this._lodInfos), this._levelByScale[e8]) return this._levelByScale[e8];
    {
      const l2 = this._fullCacheLodInfos;
      if (e8 > l2[0].scale) return l2[0].level;
      let s6, t7;
      for (let o3 = 0; o3 < l2.length - 1; o3++) if (t7 = l2[o3 + 1], e8 > t7.scale) return s6 = l2[o3], s6.level + (s6.scale - e8) / (s6.scale - t7.scale);
      return l2[l2.length - 1].level;
    }
  }
  _initializeFullCacheLODs(l2) {
    let s6;
    if (0 === l2[0].level) s6 = l2.map((e8) => ({ level: e8.level, resolution: e8.resolution, scale: e8.scale }));
    else {
      const l3 = this.tileInfo.size[0], t7 = this.tileInfo.spatialReference;
      s6 = z.create({ size: l3, spatialReference: t7 }).lods.map((e8) => ({ level: e8.level, resolution: e8.resolution, scale: e8.scale }));
    }
    for (let e8 = 0; e8 < s6.length; e8++) this._levelByScale[s6[e8].scale] = s6[e8].level;
    this._fullCacheLodInfos = s6;
  }
};

// node_modules/@arcgis/core/views/2d/layers/VectorTileLayerView2D.js
var I = 2;
var Q = 8;
var S = 512;
var P = class extends i3(b(d4)) {
  constructor() {
    super(...arguments), this._styleChanges = [], this._fetchQueue = null, this._parseQueue = null, this._tileHandlerPromise = null, this._isTileHandlerReady = false, this._styeChanged = false, this._spriteSourceChanged = false;
  }
  get fading() {
    return this._vectorTileContainer?.fading ?? false;
  }
  get hasVisibleFeatures() {
    const e8 = this._vectorTileContainer.children;
    for (const t7 of e8) if (t7.hasFeatures()) return true;
    return false;
  }
  get spriteSourceChanged() {
    return this._spriteSourceChanged;
  }
  get styleChanged() {
    return this._styeChanged;
  }
  async hitTest(e8, t7) {
    const i6 = this._tileHandlerPromise, s6 = this._vectorTileContainer?.symbolFader;
    if (!i6 || !this._isTileHandlerReady || !s6) return;
    await i6;
    let r4 = null;
    const a6 = this._vectorTileContainer?.symbolRepository;
    a6 && (r4 = a6.querySymbols(t7, I, s6.decluttererOffset, {}));
    const l2 = this.view.state, n8 = this._tileManager.getIntersectingTiles(t7.x, t7.y, I, l2, r4);
    if ((!n8 || 0 === n8.length) && 0 === r4?.length) return null;
    e8 = e8.clone().normalize();
    const o3 = [], h8 = [];
    for (const u4 of n8) o3.push(this._queryTile(h8, e8, I, this.view.state.rotation, u4, r4?.filter((e9) => e9.tileKey.id === u4.id)));
    return await Promise.all(o3), h8;
  }
  update(e8) {
    if (this._tileHandlerPromise && this._isTileHandlerReady) return e8.pixelRatio !== this._tileHandler.devicePixelRatio ? (this._tileHandler.devicePixelRatio = e8.pixelRatio, void this._loadStyle()) : void (this._styleChanges.length > 0 ? this._tileHandlerPromise = this._applyStyleChanges() : (this._pauseQueues(), this._fetchQueue.state = e8.state, this._parseQueue.state = e8.state, this._tileManager.update(e8) || this.requestUpdate(), this._resumeQueues()));
  }
  attach() {
    const { style: e8 } = this.layer.currentStyleInfo;
    this._styleRepository = new l(e8), this._tileInfoView = new t6(this.layer.tileInfo, this.layer.fullExtent), this._vectorTileContainer = new u3(this._tileInfoView), this._tileHandler = new h4(this.layer, this._styleRepository, window.devicePixelRatio || 1, this.layer.tileInfo.lods.length - 1), this.container.addChild(this._vectorTileContainer), this._start(), this.addAttachHandles([this.layer.on("paint-change", (e9) => {
      if (this._styeChanged = true, e9.isDataDriven) this._styleChanges.push({ type: 0, data: e9 }), this.requestUpdate();
      else {
        const t7 = this._styleRepository, i6 = t7.getLayerById(e9.layer);
        if (!i6) return;
        const s6 = 3 === i6.type;
        t7.setPaintProperties(e9.layer, e9.paint), s6 && this._vectorTileContainer?.restartDeclutter(), this._vectorTileContainer?.requestRender();
      }
    }), this.layer.on("layout-change", (e9) => {
      const t7 = this._styleRepository, i6 = t7.getLayerById(e9.layer);
      if (!i6) return;
      this._styeChanged = true;
      const s6 = y(i6.layout, e9.layout);
      if (null != s6) {
        if (p(s6, "visibility") && 1 === b2(s6)) return t7.setLayoutProperties(e9.layer, e9.layout), 3 === i6.type && this._vectorTileContainer?.restartDeclutter(), void this._vectorTileContainer?.requestRender();
        this._styleChanges.push({ type: 1, data: e9 }), this.requestUpdate();
      }
    }), this.layer.on("style-layer-visibility-change", (e9) => {
      const t7 = this._styleRepository, i6 = t7.getLayerById(e9.layer);
      i6 && (this._styeChanged = true, t7.setStyleLayerVisibility(e9.layer, e9.visibility), 3 === i6.type && this._vectorTileContainer?.restartDeclutter(), this._vectorTileContainer?.requestRender());
    }), this.layer.on("style-layer-change", (e9) => {
      this._styleChanges.push({ type: 2, data: e9 }), this._styeChanged = true, this.requestUpdate();
    }), this.layer.on("delete-style-layer", (e9) => {
      this._styleChanges.push({ type: 3, data: e9 }), this._styeChanged = true, this.requestUpdate();
    }), this.layer.on("load-style", () => this._loadStyle()), this.layer.on("spriteSource-change", (e9) => {
      this._spriteSourceChanged = true, this._styleChanges.push({ type: 4, data: e9 });
      const t7 = this._styleRepository.layers;
      for (const i6 of t7) switch (i6.type) {
        case 3:
          i6.getLayoutProperty("icon-image") && this._styleChanges.push({ type: 1, data: { layer: i6.id, layout: i6.layout } });
          break;
        case 2:
          i6.getPaintProperty("line-pattern") && this._styleChanges.push({ type: 0, data: { layer: i6.id, paint: i6.paint, isDataDriven: i6.isPainterDataDriven() } });
          break;
        case 1:
          i6.getLayoutProperty("fill-pattern") && this._styleChanges.push({ type: 0, data: { layer: i6.id, paint: i6.paint, isDataDriven: i6.isPainterDataDriven() } });
      }
      this.requestUpdate();
    })]);
  }
  detach() {
    this._stop(), this.container.removeAllChildren(), this._vectorTileContainer = u(this._vectorTileContainer), this._tileHandler = u(this._tileHandler);
  }
  viewChange() {
    this.requestUpdate();
  }
  moveEnd() {
    this.requestUpdate();
  }
  supportsSpatialReference(e8) {
    return T(this.layer.tileInfo?.spatialReference, e8);
  }
  canResume() {
    let e8 = super.canResume();
    const { currentStyleInfo: t7 } = this.layer;
    if (e8 && t7?.layerDefinition) {
      const i6 = this.view.scale, { minScale: s6, maxScale: r4 } = t7.layerDefinition;
      t7?.layerDefinition && (s6 && s6 < i6 && (e8 = false), r4 && r4 > i6 && (e8 = false));
    }
    return e8;
  }
  isUpdating() {
    return this.fading;
  }
  acquireTile(e8) {
    const t7 = this._createVectorTile(e8);
    return this._updatingHandles.addPromise(this._fetchQueue.push(t7.key).then((e9) => this._parseQueue.push({ key: t7.key, data: e9 })).then((e9) => {
      t7.once("attach", () => this.requestUpdate()), t7.setData(e9), this.requestUpdate();
    }).catch((e9) => {
      d(e9) || i.getLogger(this).error(e9);
    })), t7;
  }
  releaseTile(e8) {
    const t7 = e8.key.id;
    this._fetchQueue.abort(t7), this._parseQueue.abort(t7), this.requestUpdate();
  }
  async doRefresh() {
    if (!this.attached) return;
    if (this.suspended) return this._tileManager.clear(), void this.requestUpdate();
    this._isTileHandlerReady = false, this._pauseQueues(), this._clearQueues(), this._tileManager.clearCache(), this._resumeQueues();
    const e8 = this._vectorTileContainer.children, t7 = [];
    try {
      for (const i6 of e8) {
        const e9 = this._updatingHandles.addPromise(this._fetchQueue.push(i6.key).then((e10) => this._parseQueue.push({ key: i6.key, data: e10 })).then((e10) => i6.setData(e10)).finally(() => i6.featureIndex = null));
        t7.push(e9);
      }
      await Promise.all(t7);
    } catch (s6) {
      i.getLogger(this).error("error refreshing vector-tiles layer-view", s6), this._resumeQueues(), this._isTileHandlerReady = true;
    }
    this._isTileHandlerReady = true, this.requestUpdate();
  }
  _start() {
    if (this._stop(), this._tileManager = new c2({ acquireTile: (e9) => this.acquireTile(e9), releaseTile: (e9) => this.releaseTile(e9), tileInfoView: this._tileInfoView }, this._vectorTileContainer), !this.layer.currentStyleInfo) return;
    const e8 = new AbortController(), t7 = this._tileHandler.start({ signal: e8.signal }).then(() => {
      this._fetchQueue = new p2({ tileInfoView: this._tileInfoView, process: (e9, t8) => this._getTileData(e9, t8), concurrency: 15, scheduler: this.scheduler, priority: f2.MAPVIEW_FETCH_QUEUE }), this._parseQueue = new p2({ tileInfoView: this._tileInfoView, process: (e9, t8) => this._parseTileData(e9, t8), concurrency: 8, scheduler: this.scheduler, priority: f2.MAPVIEW_VECTOR_TILE_PARSING_QUEUE }), this.requestUpdate(), this._isTileHandlerReady = true;
    });
    this._tileHandler.spriteMosaic.then((e9) => {
      this._vectorTileContainer.setStyleResources(e9, this._tileHandler.glyphMosaic, this._styleRepository, this._tileInfoView), this.requestUpdate();
    }), this._tileHandlerAbortController = e8, this._tileHandlerPromise = t7;
  }
  _stop() {
    if (!this._tileHandlerAbortController || !this._vectorTileContainer) return;
    const e8 = this._tileHandlerAbortController;
    e8 && e8.abort(), this._tileHandlerPromise = null, this._isTileHandlerReady = false, this._fetchQueue = u(this._fetchQueue), this._parseQueue = u(this._parseQueue), this._tileManager = u(this._tileManager), this._vectorTileContainer.removeAllChildren();
  }
  async _getTileData(e8, t7) {
    return this._tileHandler.fetchTileData(e8, t7);
  }
  async _parseTileData(e8, t7) {
    return this._tileHandler.parseTileData(e8, t7);
  }
  async _applyStyleChanges() {
    this._isTileHandlerReady = false, this._pauseQueues(), this._clearQueues(), this._tileManager.clearCache();
    const e8 = this._styleChanges;
    try {
      await this._tileHandler.updateStyle(e8);
    } catch (l2) {
      i.getLogger(this).error("error applying vector-tiles style update", l2.message), this._resumeQueues(), this._isTileHandlerReady = true;
    }
    const t7 = this._styleRepository, s6 = /* @__PURE__ */ new Set();
    e8.forEach((e9) => {
      if (3 !== e9.type) return;
      const i6 = e9.data, r5 = t7.getLayerById(i6.layer);
      r5 && s6.add(r5.uid);
    });
    const r4 = /* @__PURE__ */ new Set();
    e8.forEach((e9) => {
      let i6;
      switch (e9.type) {
        case 0:
          t7.setPaintProperties(e9.data.layer, e9.data.paint), i6 = e9.data.layer;
          break;
        case 1:
          t7.setLayoutProperties(e9.data.layer, e9.data.layout), i6 = e9.data.layer;
          break;
        case 3:
          return void t7.deleteStyleLayer(e9.data.layer);
        case 2:
          t7.setStyleLayer(e9.data.layer, e9.data.index), i6 = e9.data.layer.id;
          break;
        case 4:
          this._vectorTileContainer.setSpriteMosaic(this._tileHandler.setSpriteSource(e9.data.spriteSource));
      }
      if (i6) {
        const e10 = t7.getLayerById(i6);
        e10 && r4.add(e10.uid);
      }
    });
    const a6 = this._vectorTileContainer.children;
    if (s6.size > 0) {
      const e9 = Array.from(s6);
      this._vectorTileContainer.deleteStyleLayers(e9);
      for (const t8 of a6) t8.deleteLayerData(e9);
    }
    if (this._resumeQueues(), r4.size > 0) {
      const e9 = Array.from(r4), t8 = [];
      for (const i6 of a6) {
        const s7 = this._updatingHandles.addPromise(this._fetchQueue.push(i6.key).then((t9) => this._parseQueue.push({ key: i6.key, data: t9, styleLayerUIDs: e9 })).then((e10) => i6.setData(e10)).finally(() => i6.featureIndex = null));
        t8.push(s7);
      }
      await Promise.all(t8);
    }
    this._styleChanges = [], this._isTileHandlerReady = true, this.requestUpdate();
  }
  async _loadStyle() {
    const { style: e8 } = this.layer.currentStyleInfo, i6 = a(e8);
    this._isTileHandlerReady = false, this._pauseQueues(), this._clearQueues(), this._styleRepository = new l(i6), this._vectorTileContainer.destroy(), this._tileManager.clear(), this._tileHandlerAbortController.abort(), this._tileHandlerAbortController = new AbortController();
    const { signal: s6 } = this._tileHandlerAbortController;
    try {
      this._tileHandlerPromise = this._tileHandler.setStyle(this._styleRepository, i6, this.layer.tileInfo.lods.length - 1), await this._tileHandlerPromise;
    } catch (n8) {
      if (!d(n8)) throw n8;
    }
    if (s6.aborted) return this._resumeQueues(), this._isTileHandlerReady = true, this._styeChanged = false, this._spriteSourceChanged = false, void this.requestUpdate();
    const a6 = await this._tileHandler.spriteMosaic, l2 = this._vectorTileContainer;
    this._tileInfoView = new t6(this.layer.tileInfo, this.layer.fullExtent), l2.setStyleResources(a6, this._tileHandler.glyphMosaic, this._styleRepository, this._tileInfoView), this._tileManager = new c2({ acquireTile: (e9) => this.acquireTile(e9), releaseTile: (e9) => this.releaseTile(e9), tileInfoView: this._tileInfoView }, this._vectorTileContainer), this._resumeQueues(), this._isTileHandlerReady = true, this.requestUpdate(), this._styeChanged = false, this._spriteSourceChanged = false;
  }
  _createVectorTile(e8) {
    const t7 = this._tileInfoView.getTileBounds(i2(), e8), i6 = this._tileInfoView.getTileResolution(e8.level);
    return new y2(e8, i6, t7[0], t7[3], 512, 512, this._styleRepository);
  }
  async _queryTile(e8, t7, i6, s6, r4, a6) {
    if (0 === r4.layerData.size) return;
    const l2 = this._ensureTileIndex(r4), n8 = this._tileInfoView.getTileBounds(i2(), r4.key, true), o3 = Q * S * ((t7.x - n8[0]) / (n8[2] - n8[0])), h8 = Q * S * (1 - (t7.y - n8[1]) / (n8[3] - n8[1])), c4 = await l2.queryAttributes(o3, h8, i6, s6, a6);
    for (const u4 of c4) u4.graphic.geometry = this._tileToMapPoint(u4.tilePoint, r4.transforms.tileUnitsToPixels), e8.push({ type: "graphic", layer: this.layer, graphic: u4.graphic, mapPoint: t7.clone() });
    e8.sort((e9, t8) => (n5(t8.graphic.origin) ? t8.graphic.origin.layerIndex : 0) - (n5(e9.graphic.origin) ? e9.graphic.origin.layerIndex : 0));
  }
  _tileToMapPoint(e8, t7) {
    if (!e8) return null;
    const i6 = e8[0] * t7[0] + e8[1] * t7[3] + t7[6], s6 = e8[0] * t7[1] + e8[1] * t7[4] + t7[7], r4 = this.view.state, a6 = [0, 0];
    return r4.toMap(a6, [i6, s6]), new _({ x: a6[0], y: a6[1], spatialReference: r4.spatialReference });
  }
  _ensureTileIndex(e8) {
    let t7 = e8.featureIndex;
    return t7 || (t7 = m3.create(e8.key, e8.layerData, this._styleRepository, this._tileHandler, this.layer), e8.featureIndex = t7), t7;
  }
  _pauseQueues() {
    this._fetchQueue.pause(), this._parseQueue.pause();
  }
  _resumeQueues() {
    this._fetchQueue.resume(), this._parseQueue.resume();
  }
  _clearQueues() {
    this._fetchQueue.clear(), this._parseQueue.clear();
  }
};
function b2(e8) {
  if (null == e8) return 0;
  switch (e8.type) {
    case "partial":
      return Object.keys(e8.diff).length;
    case "complete":
      return Math.max(Object.keys(e8.oldValue).length, Object.keys(e8.newValue).length);
    case "collection":
      return Object.keys(e8.added).length + Object.keys(e8.changed).length + Object.keys(e8.removed).length;
  }
}
__decorate([m()], P.prototype, "_isTileHandlerReady", void 0), P = __decorate([a2("esri.views.2d.layers.VectorTileLayerView2D")], P);
var V = P;
export {
  V as default
};
//# sourceMappingURL=VectorTileLayerView2D-DAUMUXKS.js.map
