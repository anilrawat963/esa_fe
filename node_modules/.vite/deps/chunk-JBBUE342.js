import {
  z
} from "./chunk-H74Q4SYB.js";
import {
  r as r2
} from "./chunk-7H3U4IJR.js";
import {
  _
} from "./chunk-AXZMNHTN.js";
import {
  o
} from "./chunk-XWE6BM2U.js";
import {
  r
} from "./chunk-SOIZOFSB.js";
import {
  n
} from "./chunk-XXLHAM2M.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";

// node_modules/@arcgis/core/layers/support/rasterTransforms/BaseRasterTransform.js
var t = class extends n {
  get affectsPixelSize() {
    return false;
  }
  forwardTransform(r3) {
    return r3;
  }
  inverseTransform(r3) {
    return r3;
  }
};
__decorate([m()], t.prototype, "affectsPixelSize", null), __decorate([m({ json: { write: true } })], t.prototype, "spatialReference", void 0), t = __decorate([a("esri.layers.support.rasterTransforms.BaseRasterTransform")], t);

// node_modules/@arcgis/core/layers/support/rasterTransforms/GCSShiftTransform.js
var a2;
var n2 = a2 = class extends t {
  constructor() {
    super(...arguments), this.type = "gcs-shift", this.tolerance = 1e-8;
  }
  forwardTransform(r3) {
    return "point" === (r3 = r3.clone()).type ? (r3.x > 180 + this.tolerance && (r3.x -= 360), r3) : (r3.xmin >= 180 - this.tolerance ? (r3.xmax -= 360, r3.xmin -= 360) : r3.xmax > 180 + this.tolerance && (r3.xmin = -180, r3.xmax = 180), r3);
  }
  inverseTransform(r3) {
    return "point" === (r3 = r3.clone()).type ? (r3.x < -this.tolerance && (r3.x += 360), r3) : (r3.xmin < -this.tolerance && (r3.xmin += 360, r3.xmax += 360), r3);
  }
  clone() {
    return new a2({ tolerance: this.tolerance });
  }
};
__decorate([r2({ GCSShiftXform: "gcs-shift" })], n2.prototype, "type", void 0), __decorate([m()], n2.prototype, "tolerance", void 0), n2 = a2 = __decorate([a("esri.layers.support.rasterTransforms.GCSShiftTransform")], n2);

// node_modules/@arcgis/core/layers/support/rasterTransforms/PolynomialTransform.js
var p;
function a3(e, r3, o2) {
  const { x: t2, y: i } = r3;
  if (o2 < 2) {
    return { x: e[0] + t2 * e[2] + i * e[4], y: e[1] + t2 * e[3] + i * e[5] };
  }
  if (2 === o2) {
    const r4 = t2 * t2, o3 = i * i, s2 = t2 * i;
    return { x: e[0] + t2 * e[2] + i * e[4] + r4 * e[6] + s2 * e[8] + o3 * e[10], y: e[1] + t2 * e[3] + i * e[5] + r4 * e[7] + s2 * e[9] + o3 * e[11] };
  }
  const s = t2 * t2, n3 = i * i, f = t2 * i, l = s * t2, p2 = s * i, a4 = t2 * n3, c2 = i * n3;
  return { x: e[0] + t2 * e[2] + i * e[4] + s * e[6] + f * e[8] + n3 * e[10] + l * e[12] + p2 * e[14] + a4 * e[16] + c2 * e[18], y: e[1] + t2 * e[3] + i * e[5] + s * e[7] + f * e[9] + n3 * e[11] + l * e[13] + p2 * e[15] + a4 * e[17] + c2 * e[19] };
}
function c(e, r3, o2) {
  const { xmin: t2, ymin: i, xmax: s, ymax: f, spatialReference: l } = r3;
  let p2 = [];
  if (o2 < 2) p2.push({ x: t2, y: f }), p2.push({ x: s, y: f }), p2.push({ x: t2, y: i }), p2.push({ x: s, y: i });
  else {
    let e2 = 10;
    for (let r4 = 0; r4 < e2; r4++) p2.push({ x: t2, y: i + (f - i) * r4 / (e2 - 1) }), p2.push({ x: s, y: i + (f - i) * r4 / (e2 - 1) });
    e2 = 8;
    for (let r4 = 1; r4 <= e2; r4++) p2.push({ x: t2 + (s - t2) * r4 / e2, y: i }), p2.push({ x: t2 + (s - t2) * r4 / e2, y: f });
  }
  p2 = p2.map((r4) => a3(e, r4, o2));
  const c2 = p2.map((e2) => e2.x), m3 = p2.map((e2) => e2.y);
  return new z({ xmin: Math.min.apply(null, c2), xmax: Math.max.apply(null, c2), ymin: Math.min.apply(null, m3), ymax: Math.max.apply(null, m3), spatialReference: l });
}
function m2(e) {
  const [r3, o2, t2, i, s, n3] = e, f = t2 * n3 - s * i, l = s * i - t2 * n3;
  return [(s * o2 - r3 * n3) / f, (t2 * o2 - r3 * i) / l, n3 / f, i / l, -s / f, -t2 / l];
}
var u = p = class extends t {
  constructor() {
    super(...arguments), this.polynomialOrder = 1, this.type = "polynomial";
  }
  readForwardCoefficients(e, r3) {
    const { coeffX: o2, coeffY: t2 } = r3;
    if (!o2?.length || !t2?.length || o2.length !== t2.length) return null;
    const i = [];
    for (let s = 0; s < o2.length; s++) i.push(o2[s]), i.push(t2[s]);
    return i;
  }
  writeForwardCoefficients(e, r3, o2) {
    const t2 = [], i = [];
    for (let s = 0; s < e?.length; s++) s % 2 == 0 ? t2.push(e[s]) : i.push(e[s]);
    r3.coeffX = t2, r3.coeffY = i;
  }
  get inverseCoefficients() {
    let e = this._get("inverseCoefficients");
    const r3 = this._get("forwardCoefficients");
    return !e && r3 && this.polynomialOrder < 2 && (e = m2(r3)), e;
  }
  set inverseCoefficients(e) {
    this._set("inverseCoefficients", e);
  }
  readInverseCoefficients(e, r3) {
    const { inverseCoeffX: o2, inverseCoeffY: t2 } = r3;
    if (!o2?.length || !t2?.length || o2.length !== t2.length) return null;
    const i = [];
    for (let s = 0; s < o2.length; s++) i.push(o2[s]), i.push(t2[s]);
    return i;
  }
  writeInverseCoefficients(e, r3, o2) {
    const t2 = [], i = [];
    for (let s = 0; s < e?.length; s++) s % 2 == 0 ? t2.push(e[s]) : i.push(e[s]);
    r3.inverseCoeffX = t2, r3.inverseCoeffY = i;
  }
  get affectsPixelSize() {
    return this.polynomialOrder > 0;
  }
  forwardTransform(e) {
    if ("point" === e.type) {
      const r3 = a3(this.forwardCoefficients, e, this.polynomialOrder);
      return new _({ x: r3.x, y: r3.y, spatialReference: e.spatialReference });
    }
    return c(this.forwardCoefficients, e, this.polynomialOrder);
  }
  inverseTransform(e) {
    if ("point" === e.type) {
      const r3 = a3(this.inverseCoefficients, e, this.polynomialOrder);
      return new _({ x: r3.x, y: r3.y, spatialReference: e.spatialReference });
    }
    return c(this.inverseCoefficients, e, this.polynomialOrder);
  }
  clone() {
    return new p({ polynomialOrder: this.polynomialOrder, forwardCoefficients: this.forwardCoefficients ? [...this.forwardCoefficients] : null, inverseCoefficients: this.inverseCoefficients ? [...this.inverseCoefficients] : null });
  }
};
__decorate([m({ json: { write: true } })], u.prototype, "polynomialOrder", void 0), __decorate([m()], u.prototype, "forwardCoefficients", void 0), __decorate([o("forwardCoefficients", ["coeffX", "coeffY"])], u.prototype, "readForwardCoefficients", null), __decorate([r("forwardCoefficients")], u.prototype, "writeForwardCoefficients", null), __decorate([m({ json: { write: true } })], u.prototype, "inverseCoefficients", null), __decorate([o("inverseCoefficients", ["inverseCoeffX", "inverseCoeffY"])], u.prototype, "readInverseCoefficients", null), __decorate([r("inverseCoefficients")], u.prototype, "writeInverseCoefficients", null), __decorate([m()], u.prototype, "affectsPixelSize", null), __decorate([r2({ PolynomialXform: "polynomial" })], u.prototype, "type", void 0), u = p = __decorate([a("esri.layers.support.rasterTransforms.PolynomialTransform")], u);

export {
  t,
  n2 as n,
  u
};
//# sourceMappingURL=chunk-JBBUE342.js.map
