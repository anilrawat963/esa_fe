import {
  n as n5
} from "./chunk-GIKMBX7P.js";
import {
  a as a4
} from "./chunk-ZUQ2O3KU.js";
import {
  t
} from "./chunk-7VJQTJLO.js";
import "./chunk-RS755KXS.js";
import "./chunk-TMUM75KQ.js";
import "./chunk-UOYGMZIS.js";
import "./chunk-RXH2WNPA.js";
import "./chunk-TWU3GKHX.js";
import "./chunk-BGIBV6LL.js";
import "./chunk-UQXJMFRI.js";
import "./chunk-DY7N5RAZ.js";
import "./chunk-WX3525ER.js";
import "./chunk-FHCV4NTV.js";
import {
  g as g2
} from "./chunk-HCTBVF3W.js";
import {
  T as T2
} from "./chunk-BICOKFED.js";
import {
  p as p5,
  v as v2
} from "./chunk-53VTQ5YY.js";
import "./chunk-NH6FXYCM.js";
import "./chunk-YE4E5JCT.js";
import "./chunk-SXZO7ULH.js";
import "./chunk-QTRET3PG.js";
import "./chunk-FMOL5XMB.js";
import "./chunk-VNSHGTPN.js";
import "./chunk-OEBAFVQK.js";
import {
  a as a3,
  l
} from "./chunk-S5K4XWUR.js";
import "./chunk-QNW4D2V2.js";
import "./chunk-XAI6T5FU.js";
import "./chunk-QNDHLVDC.js";
import "./chunk-ZT4KW2M5.js";
import "./chunk-FHQNDU7E.js";
import "./chunk-IOJ4QFRL.js";
import "./chunk-EK7HOTRR.js";
import {
  m as m4,
  m2 as m5,
  m3 as m6,
  n as n4
} from "./chunk-ZNQKJRCD.js";
import "./chunk-BA6HYZ35.js";
import "./chunk-GCTH5LET.js";
import {
  c as c3,
  d as d2,
  p as p3,
  v,
  z
} from "./chunk-CNPDGNWO.js";
import {
  F,
  I as I2,
  M as M2,
  N as N3,
  T,
  U as U2
} from "./chunk-SJB744AD.js";
import {
  $,
  C as C2,
  P,
  c as c2,
  d,
  j as j2,
  m as m3,
  q
} from "./chunk-WM2VG5F2.js";
import {
  a as a2,
  n as n3
} from "./chunk-IXFJYDA2.js";
import "./chunk-TTLSEJNG.js";
import {
  C,
  M,
  N as N2,
  U,
  c,
  w
} from "./chunk-U73R3I4U.js";
import {
  s as s3
} from "./chunk-VGXUPJSS.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import "./chunk-EKZRA6TO.js";
import "./chunk-M5SP6ZBM.js";
import "./chunk-2HGIYEIL.js";
import "./chunk-XX3OKYJS.js";
import "./chunk-OTCNIJ2H.js";
import "./chunk-JGA5YJWL.js";
import "./chunk-GCI4MA3M.js";
import "./chunk-SJ2OBYX2.js";
import "./chunk-MDJNYPVI.js";
import "./chunk-Z6VKIQV2.js";
import "./chunk-4PXNA4MD.js";
import {
  at
} from "./chunk-6RE6OSTE.js";
import "./chunk-QSGJ3ECU.js";
import "./chunk-GBN36VHC.js";
import {
  p as p6
} from "./chunk-ZCI5A4FF.js";
import "./chunk-52SEOH5H.js";
import "./chunk-2D47RURG.js";
import "./chunk-7HTU7ZUX.js";
import "./chunk-WDTGOP77.js";
import {
  b
} from "./chunk-647DAMHU.js";
import {
  m as m7
} from "./chunk-O6G3PPOK.js";
import {
  p as p4
} from "./chunk-ZKNZTIAS.js";
import "./chunk-OJMISN3F.js";
import {
  R
} from "./chunk-EFV6H5NA.js";
import "./chunk-6VL5D5UP.js";
import "./chunk-6QHY54HZ.js";
import "./chunk-GXJJY3ND.js";
import "./chunk-5ONGWFJ3.js";
import {
  f
} from "./chunk-PLNHHGHL.js";
import "./chunk-BBYMM7CM.js";
import {
  i as i2,
  m as m2,
  p as p2
} from "./chunk-QZQPB5XR.js";
import {
  i as i3
} from "./chunk-AQFRVV3U.js";
import "./chunk-63LDVRFI.js";
import {
  _
} from "./chunk-C3FRY5U4.js";
import "./chunk-JNJX34GB.js";
import "./chunk-3STJRSDT.js";
import "./chunk-67Q6KVC6.js";
import "./chunk-23NJHA5Q.js";
import "./chunk-4LA6K4VI.js";
import "./chunk-KEZCWFAR.js";
import "./chunk-JZUJ34RR.js";
import "./chunk-PMGS7UDU.js";
import "./chunk-3GHCGAH2.js";
import "./chunk-HWUOAPTX.js";
import "./chunk-QHCKOBU7.js";
import "./chunk-K2OZ6WVC.js";
import {
  Fe,
  Ie,
  be,
  e2 as e,
  ge,
  we,
  xe
} from "./chunk-MC6NAKKX.js";
import "./chunk-TF6255HN.js";
import "./chunk-GD4FJL3C.js";
import "./chunk-C5OQVQZF.js";
import "./chunk-F7DKSAOI.js";
import "./chunk-4SOQWNPG.js";
import "./chunk-LTULADK2.js";
import "./chunk-35ST7YRB.js";
import "./chunk-EDA5QFHZ.js";
import "./chunk-CNYNCKEV.js";
import "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-C5M24ACM.js";
import "./chunk-L4A2QJG4.js";
import "./chunk-6KDQMJAI.js";
import "./chunk-UDHS2MGH.js";
import "./chunk-ENINOZUZ.js";
import "./chunk-P6IKJIMO.js";
import "./chunk-MHV23XAQ.js";
import "./chunk-V2X4OKYI.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import "./chunk-MA3QDRC3.js";
import "./chunk-W6J7XCPU.js";
import "./chunk-ONXWBTTM.js";
import "./chunk-T7F6Q6JJ.js";
import "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-7P2ANHQ3.js";
import {
  u
} from "./chunk-XCKT47LJ.js";
import "./chunk-3FUHCAX3.js";
import "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import {
  j
} from "./chunk-2OFHDVO5.js";
import "./chunk-TFJXG32O.js";
import {
  O
} from "./chunk-DDOCCRD4.js";
import "./chunk-5UPBUJPC.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-CCQFL76O.js";
import "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import {
  r
} from "./chunk-7H3U4IJR.js";
import "./chunk-SMWUT52Z.js";
import "./chunk-AXZMNHTN.js";
import "./chunk-5T3MJDSR.js";
import "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import {
  H2 as H,
  g2 as g
} from "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import {
  n as n2
} from "./chunk-XXLHAM2M.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import {
  E,
  n,
  p,
  s as s2
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  I,
  N,
  has
} from "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/smartMapping/support/binningUtils.js
function i4(e3, i6) {
  if (!e3.view) throw new s(`${i6}:missing-parameters`, "'view' parameter is required for binning");
  if (e3.sqlExpression) throw new s(`${i6}:invalid-parameters`, "'sqlExpression' parameter is not supported for binning");
  if ("3d" === e3.view.type) throw new s(`${i6}:invalid-parameters`, "3d view is not supported for binning");
}

// node_modules/@arcgis/core/smartMapping/statistics/support/WorkerClient.js
var n6 = class _n {
  constructor() {
    this.connection = null;
  }
  async open(t2) {
    this.connection = await p6("statsWorker", { strategy: "distributed", signal: t2 });
  }
  destroy() {
    this.connection?.close();
  }
  static getInstance() {
    return _n.instance || (_n.instance = new _n()), _n.instance;
  }
  async summaryStatistics(e3, n8) {
    if (!this.connection) throw new s("worker-client:summary-statistics", "connection is required");
    return this.connection.invoke("summaryStatistics", { attribute: e3, features: n8 });
  }
  async uniqueValues(e3, n8) {
    if (!this.connection) throw new s("worker-client:unique-values", "connection is required");
    return this.connection.invoke("uniqueValues", { attribute: e3, features: n8 });
  }
  async classBreaks(e3, n8) {
    if (!this.connection) throw new s("worker-client:class-breaks", "connection is required");
    return this.connection.invoke("classBreaks", { attribute: e3, features: n8 });
  }
  async histogram(e3, n8) {
    if (!this.connection) throw new s("worker-client:histogram", "connection is required");
    return this.connection.invoke("histogram", { attribute: e3, features: n8 });
  }
  async heatmapStatistics(e3, n8) {
    if (!this.connection) throw new s("worker-client:heatmap-statistics", "connection is required");
    return this.connection.invoke("heatmapStatistics", { attribute: e3, features: n8 });
  }
};

// node_modules/@arcgis/core/rest/query/executeQuery.js
async function f2(t2, o4, r4, e3, n8) {
  return m8(o4, await c4(t2, o4, r4, e3, n8), r4, e3);
}
async function c4(t2, o4, r4, e3, n8) {
  const i6 = { ...e3 }, u6 = p7(o4, r4), f3 = null != o4.outStatistics?.[0], c6 = has("featurelayer-pbf-statistics"), m10 = !f3 || c6;
  let d4;
  if ("pbf" === r4?.format && m10) try {
    d4 = await n5(t2, u6, i6, n8);
  } catch (y) {
    if ("query:parsing-pbf" !== y.name) throw y;
    r4.format = "json";
  }
  return "json" !== r4?.format && m10 || (d4 = await a4(t2, u6, i6, n8)), l2(r4?.fieldsIndex, d4.fields), d4;
}
function l2(t2, o4) {
  if (null != t2 && null != o4) for (const r4 of o4) {
    const o5 = t2.get(r4.name);
    o5 && Object.assign(r4, o5.toJSON());
  }
}
async function m8(t2, r4, e3, n8) {
  const s8 = e3?.infoFor3D;
  if (!d3(t2, s8) || null == s8 || !r4.assetMaps || !r4.features?.length) return g2.fromJSON(r4);
  const { meshFeatureSetFromJSON: a5 } = await p(import("./meshFeatureSet-AS7I4OCS.js"), n8);
  return a5(t2, s8, r4);
}
function p7(o4, s8) {
  let a5 = b.from(o4);
  a5.sourceSpatialReference = a5.sourceSpatialReference ?? s8?.sourceSpatialReference ?? null, (s8?.gdbVersion || s8?.dynamicDataSource) && (a5 = a5 === o4 ? a5.clone() : a5, a5.gdbVersion = o4.gdbVersion || s8.gdbVersion, a5.dynamicDataSource = o4.dynamicDataSource ? R.from(o4.dynamicDataSource) : s8.dynamicDataSource);
  const i6 = s8?.infoFor3D;
  if (null != i6 && d3(o4, i6)) {
    a5 = a5 === o4 ? a5.clone() : a5, a5.formatOf3DObjects = null;
    const n8 = a3(i6), s9 = l(i6);
    for (const t2 of i6.queryFormats) {
      if (t2 === n8) {
        a5.formatOf3DObjects = t2;
        break;
      }
      t2 !== s9 || a5.formatOf3DObjects || (a5.formatOf3DObjects = t2);
    }
    if (!a5.formatOf3DObjects) throw new s("query:unsupported-3d-query-formats", "Could not find any supported 3D object query format. Only supported formats are 3D_glb and 3D_gltf");
    if (null == a5.outFields || !a5.outFields.includes("*")) {
      a5 = a5 === o4 ? a5.clone() : a5, null == a5.outFields && (a5.outFields = []);
      const { originX: t2, originY: r4, originZ: e3, translationX: n9, translationY: s10, translationZ: u6, scaleX: f3, scaleY: c6, scaleZ: l4, rotationX: m10, rotationY: p10, rotationZ: d4, rotationDeg: y } = i6.transformFieldRoles;
      a5.outFields.push(t2, r4, e3, n9, s10, u6, f3, c6, l4, m10, p10, d4, y);
    }
  }
  return a5;
}
function d3(t2, o4) {
  return null != o4 && true === t2.returnGeometry && "xyFootprint" !== t2.multipatchOption && !t2.outStatistics;
}

// node_modules/@arcgis/core/rest/generateRenderer.js
async function l3(t2, i6, s8, a5) {
  const l4 = f(t2), { source: o4, checkValueRange: u6 } = i6, { classificationDefinition: c6 } = s8, f3 = { ...s8.toJSON(), f: "json" };
  let m10 = null;
  if (m10 = "class-breaks-definition" === c6?.type ? c6.classificationField : c6?.attributeField, o4) {
    const e3 = { source: o4?.toJSON() };
    f3.layer = JSON.stringify(e3);
  }
  f3.classificationDef && (f3.classificationDef = JSON.stringify(f3.classificationDef));
  let p10 = { query: f3 };
  a5 && (p10 = { ...a5, ...p10 });
  const y = { url: l4.path, field: m10, checkValueRange: u6 }, V4 = l4.path + "/generateRenderer";
  return H(V4, p10).then((e3) => r2(y, e3));
}
function r2(e3, t2) {
  const { field: n8, checkValueRange: l4, url: r4 } = e3, u6 = t2?.data;
  if (!u6) return;
  if (!l4) {
    const e4 = o(u6);
    return Promise.resolve(e4);
  }
  const c6 = new p4({ statisticType: "min", onStatisticField: n8 }), f3 = new p4({ statisticType: "max", onStatisticField: n8 }), m10 = new b({ outStatistics: [c6, f3] });
  return f2(r4, m10).then((e4) => {
    const t3 = e4.features[0].attributes;
    let n9 = null, i6 = null;
    for (const s8 in t3) s8.toLowerCase().startsWith("min") ? n9 = t3[s8] : i6 = t3[s8];
    return o(u6, n9, i6);
  });
}
function o(e3, n8, i6) {
  if ("classBreaks" === e3.type) {
    const s9 = t(e3);
    return { classBreaks: s9.classBreakInfos.map((e4, t2) => (0 === t2 && null != n8 && (e4.minValue = n8), t2 === s9.classBreakInfos.length - 1 && null != i6 && (e4.maxValue = i6), { minValue: e4.minValue, maxValue: e4.maxValue, label: e4.label })), normalizationTotal: s9.normalizationTotal };
  }
  const { uniqueValueInfos: s8 } = e3;
  return { uniqueValues: s8?.map((e4, t2) => (0 === t2 && null != n8 && (e4.value = n8), t2 === s8.length - 1 && null != i6 && (e4.value = i6), { count: e4.count, value: e4.value, label: e4.label })) ?? [] };
}

// node_modules/@arcgis/core/rest/support/GenerateRendererParameters.js
var s4 = class extends n2 {
  constructor(r4) {
    super(r4), this.classificationDefinition = null, this.where = null;
  }
};
__decorate([m({ json: { name: "classificationDef", write: true } })], s4.prototype, "classificationDefinition", void 0), __decorate([m({ type: String, json: { write: true } })], s4.prototype, "where", void 0), s4 = __decorate([a("esri.rest.support.GenerateRendererParameters")], s4);

// node_modules/@arcgis/core/rest/support/UniqueValueDefinition.js
var s5 = class extends n2 {
  constructor(t2) {
    super(t2), this.type = "unique-value-definition", this.attributeField = null, this.attributeField2 = null, this.attributeField3 = null, this.fieldDelimiter = null;
  }
  get uniqueValueFields() {
    const t2 = [];
    return this.attributeField && t2.push(this.attributeField), this.attributeField2 && t2.push(this.attributeField2), this.attributeField3 && t2.push(this.attributeField3), t2;
  }
};
__decorate([r({ uniqueValueDef: "unique-value-definition" })], s5.prototype, "type", void 0), __decorate([m()], s5.prototype, "attributeField", void 0), __decorate([m()], s5.prototype, "attributeField2", void 0), __decorate([m()], s5.prototype, "attributeField3", void 0), __decorate([m({ json: { write: true } })], s5.prototype, "fieldDelimiter", void 0), __decorate([m({ json: { write: true } })], s5.prototype, "uniqueValueFields", null), s5 = __decorate([a("esri.rest.support.UniqueValueDefinition")], s5);

// node_modules/@arcgis/core/smartMapping/statistics/support/predominanceUtils.js
var e2 = "no_dominant_category";
function u2(n8) {
  return { expression: r3(n8, { returnFieldName: true, defaultValue: `'${e2}'` }) };
}
function r3(e3, l4) {
  const { returnFieldName: u6, defaultValue: r4, layer: t2 } = l4, i6 = [];
  if (u6 && r4) {
    const n8 = e3.map((n9) => `${n9} <= 0`).join(" AND ");
    i6.push(`WHEN ${n8} THEN ${r4}`);
  }
  for (const o4 of e3) {
    const l5 = e3.reduce((n8, a5) => (o4 !== a5 && n8.push(`${o4} > ${a5}`), n8), []).join(" AND "), r5 = t2 && M(t2, o4), s8 = u6 && `'${o4}'` ? `'${o4}'` : r5 ? N2(o4) : o4;
    i6.push(`WHEN ${l5} THEN ${s8}`);
  }
  return `CASE ${i6.join(" ")} ELSE ${r4 || "0"} END`;
}
function i5(n8) {
  return n8 && n8.map((n9) => `$feature["${n9}"];`).join("\n") + "\n" || "";
}
function o2(n8, a5 = false) {
  const e3 = n8.map((n9) => `"${n9}"`), l4 = "\n  if(value != null && value >= 0) {\n    if (totalValue == null) { totalValue = 0; }\n    totalValue = totalValue + value;\n  }\n  ";
  return `
  var fieldNames = [ ${e3.join(", ")} ];
  var numFields = ${e3.length};
  var maxValueField = null;
  var maxValue = -Infinity;
  var value, i, totalValue = null;

  for(i = 0; i < numFields; i++) {
    value = $feature[fieldNames[i]];

    if(value > 0) {
      if(value > maxValue) {
        maxValue = value;
        maxValueField = fieldNames[i];
      }
      else if (value == maxValue) {
        maxValueField = null;
      }
    }
    ${a5 ? l4 : ""}
  }
  `;
}
function s6(n8) {
  const a5 = o2(n8);
  return `
  ${i5(n8)}
  ${a5}
  return maxValueField;
  `;
}

// node_modules/@arcgis/core/smartMapping/support/adapters/LayerAdapter.js
var p8 = class extends u {
  constructor(o4) {
    super(o4), this.adapterName = "layer-adapter";
  }
};
__decorate([m({ readOnly: true })], p8.prototype, "adapterName", void 0), __decorate([m({ constructOnly: true })], p8.prototype, "layer", void 0), __decorate([m()], p8.prototype, "geometryType", void 0), __decorate([m()], p8.prototype, "objectIdField", void 0), __decorate([m()], p8.prototype, "supportsSQLExpression", void 0), __decorate([m()], p8.prototype, "hasQueryEngine", void 0), __decorate([m()], p8.prototype, "minScale", void 0), __decorate([m()], p8.prototype, "maxScale", void 0), __decorate([m()], p8.prototype, "fullExtent", void 0), p8 = __decorate([a("esri.smartMapping.support.adapters.LayerAdapter")], p8);

// node_modules/@arcgis/core/smartMapping/support/adapters/support/utils.js
var E2 = /_value$/i;
var S = Math.LOG10E;
var T3 = { SECOND: 1e3, MINUTE: 6e4, HOUR: 36e5 };
var V = 10;
function $2(t2) {
  return t2.map((t3) => t3.toJSON());
}
function z2(t2, e3) {
  const n8 = [], i6 = t2.layer, l4 = "featureReduction" in i6 ? i6.featureReduction : null, o4 = "binning" === l4?.type, r4 = null != l4 && "fields" in l4 ? l4.fields?.map((t3) => t3.name?.toLowerCase()).filter(Boolean) : [];
  if (!o4 || !e3) return n8;
  for (const a5 of e3) r4.includes(a5.toLowerCase()) || n8.push(a5);
  return n8;
}
function j3(t2, e3, n8) {
  const i6 = [];
  if (e3) for (const l4 of e3) {
    const e4 = t2.getField(l4);
    e4 && n8 && "availableFields" in n8 && !n8.availableFields?.includes(e4.name) && i6.push(e4.name);
  }
  return i6;
}
function q2(t2, e3) {
  const n8 = t2 && t2.features;
  if (0 === n8?.length) return { avg: null, count: 0, max: null, median: null, min: null, nullcount: 0, stddev: null, sum: null, variance: null };
  const i6 = n8?.[0]?.attributes, l4 = {};
  for (const o4 in i6) l4[o4.replace(E2, "").toLowerCase()] = i6[o4];
  return null != l4.totalcount && l4.totalcount >= l4.count && (l4.nullcount = l4.totalcount - l4.count), delete l4.totalcount, l4.min === l4.max && null != l4.min && null == l4.stddev && (l4.stddev = l4.variance = 0), e3 && (["min", "max", "avg", "stddev", "sum", "variance"].forEach((t3) => {
    null != l4[t3] && (l4[t3] = Math.ceil(l4[t3]));
  }), l4.min === l4.max && null != l4.min && (l4.avg = l4.min, l4.stddev = l4.variance = 0)), l4;
}
function C3(t2) {
  const e3 = [], n8 = t2.classBreaks, i6 = n8[0].minValue, l4 = n8[n8.length - 1].maxValue;
  n8.forEach((t3) => {
    e3.push([t3.minValue, t3.maxValue]);
  });
  const o4 = { field: t2.field, normalizationType: t2.normalizationType, normalizationField: t2.normalizationField, normalizationTotal: t2.normalizationTotal, layer: t2.layer };
  return { min: i6, max: l4, intervals: e3, sqlExpr: b2(o4), excludeZerosExpr: t2.where, normTotal: t2.normalizationTotal };
}
function b2(t2) {
  const { field: e3, normalizationType: n8, normalizationField: i6, normalizationTotal: l4, layer: o4 } = t2, r4 = M(o4, e3);
  let a5 = e3;
  return "percent-of-total" === n8 ? a5 = `((${r4 ? N2(e3) : e3} / ${l4}) * 100)` : "log" === n8 ? a5 = `(log(${e3}) * ${S})` : "field" === n8 ? a5 = `(${r4 ? N2(e3) : e3} / ${i6})` : "natural-log" === n8 ? a5 = `(log(${r4 ? N2(e3) : e3}))` : "square-root" === n8 && (a5 = `(power(${r4 ? N2(e3) : e3}, 0.5))`), a5;
}
function O2(t2, e3) {
  let n8;
  if (e3 = e3.toLowerCase(), t2) {
    for (const i6 in t2) if (i6.toLowerCase() !== e3) {
      n8 = t2[i6];
      break;
    }
  }
  return n8;
}
function L(t2, e3) {
  let n8;
  if (e3 = e3.toLowerCase(), t2) {
    for (const i6 in t2) if (i6.toLowerCase() === e3) {
      n8 = t2[i6];
      break;
    }
  }
  return n8;
}
function R2(t2, e3, n8, i6, l4) {
  const o4 = {}, r4 = "countOFExpr";
  t2 && t2.features && t2.features.forEach((t3) => {
    const e4 = t3.attributes, n9 = O2(e4, r4), i7 = L(e4, r4);
    null != n9 && null != i7 && 0 !== n9 && (o4[n9] = i7);
  });
  const a5 = [];
  return j2(e3, n8, i6).forEach((t3, e4) => {
    const n9 = (e4 + 1).toString();
    a5.push({ minValue: t3[0], maxValue: t3[1], count: o4.hasOwnProperty(n9) ? o4[n9] : 0 });
  }), { bins: a5, minValue: e3, maxValue: n8, normalizationTotal: l4 };
}
async function D(t2, n8) {
  const i6 = t2 && t2.features, { field: l4, field2: o4, field3: r4, fieldDelimiter: a5, layer: s8, view: u6, signal: c6, labels: m10 } = n8, f3 = `countOF${!(!l4 || !o4) ? "Expr" : l4 || "Expr"}`, d4 = {};
  let p10 = false;
  for (const e3 of i6) {
    const t3 = e3.attributes, n9 = L(t3, f3);
    let i7 = l4 ? L(t3, l4) : O2(t3, f3), s9 = o4 ? L(t3, o4) : null, u7 = r4 ? L(t3, r4) : null;
    null === i7 && 0 === n9 && (p10 = true), (null == i7 || "string" == typeof i7 && "" === i7.trim()) && (i7 = null), o4 && (null == s9 || "string" == typeof s9 && "" === s9.trim()) && (s9 = null), r4 && (null == u7 || "string" == typeof u7 && "" === u7.trim()) && (u7 = null);
    let c7 = i7;
    o4 && (c7 = `${m3(c7)}${a5}${m3(s9)}`, r4 && (c7 = `${c7}${a5}${m3(u7)}`)), null == d4[c7] ? d4[c7] = { count: n9, data: c7 } : d4[c7].count = d4[c7].count + n9;
  }
  if (l4 && p10) {
    const t3 = l4 + " is NULL";
    try {
      const e3 = await s8.queryFeatureCount({ whereClause: t3, view: u6, signal: c6 });
      return d4.null.count = d4.null.count + e3, N4(d4, m10);
    } catch {
      return s2(c6), N4(d4, m10);
    }
  }
  return N4(d4, m10);
}
function N4(t2, e3) {
  if (e3) for (const n8 in t2) t2[n8].label = e3[n8];
  return { count: t2 };
}
async function U3(t2, e3, l4) {
  const o4 = t2 ? l4.getField(t2) : null, r4 = o4 ? l4.getFieldDomain(o4.name) : null;
  if (r4) return r4;
  const { uniqueValueInfos: a5 } = await l4.uniqueValues({ field: t2, sqlWhere: e3.sqlWhere, features: e3.features, useFeaturesInView: e3.useFeaturesInView, view: e3.view, signal: e3.signal }), s8 = a5.map((t3) => new p2({ code: t3.value }));
  return new i2({ codedValues: s8 });
}
async function I3(t2, e3) {
  if (!t2.returnAllCodedValues) return [];
  const { field: n8, field2: i6, field3: l4 } = t2;
  if (n8 && !i6) {
    const t3 = n8 ? e3.getField(n8) : null, i7 = t3 ? e3.getFieldDomain(t3.name) : null;
    return i7 ? [i7] : [];
  }
  const o4 = [];
  return n8 && (o4.push(U3(n8, t2, e3)), i6 && (o4.push(U3(i6, t2, e3)), l4 && o4.push(U3(l4, t2, e3)))), Promise.all(o4);
}
function Q(t2, e3) {
  return C(t2, /* @__PURE__ */ new Date(0), e3, "milliseconds").sqlExpression;
}
function M3(t2, e3) {
  return `EXTRACT(${e3} FROM ${t2}) * ${T3[e3]}`;
}
function P2(t2) {
  if (!t2) return null;
  return N2(["HOUR", "MINUTE", "SECOND"].map((e3) => `(${M3(t2, e3)})`).join(" + "));
}
function _2(t2) {
  return { viewingMode: "2d" === t2.type ? "map" : t2.viewingMode, scale: t2.scale, spatialReference: t2.spatialReference?.toJSON() };
}
function B(t2, e3) {
  const n8 = new Set(t2.map((t3) => t3.value)), i6 = e3.filter((t3) => !n8.has(t3));
  for (const l4 of i6) t2.push({ value: l4, count: 0 });
  t2.sort((t3, n9) => e3.indexOf(t3.value) - e3.indexOf(n9.value));
  for (const l4 of t2) l4.value === e2 && (l4.value = null);
  return { predominantCategoryInfos: t2 };
}
function W(e3) {
  const n8 = "featureReduction" in e3 ? e3.featureReduction : null;
  return ((null != n8 && "fields" in n8 ? n8.fields : null) ?? []).map((t2) => {
    const n9 = k(t2, e3.fieldsIndex);
    return n9 ? new m2({ type: n9, name: t2.name, alias: t2.alias }) : null;
  }).filter(N);
}
function k(t2, e3) {
  switch (t2.statisticType) {
    case "avg":
    case "avg_angle":
      return "double";
    case "count":
      return "integer";
    case "min":
    case "max":
    case "sum":
      return t2.onStatisticField ? e3.get(t2.onStatisticField)?.type ?? null : t2.onStatisticExpression ? "string" === t2.onStatisticExpression.returnType ? null : "double" : null;
    case "mode":
      return t2.onStatisticField ? e3.get(t2.onStatisticField)?.type ?? null : t2.onStatisticExpression ? "string" === t2.onStatisticExpression.returnType ? "string" : "double" : null;
    default:
      return null;
  }
}
function A(t2, e3) {
  return U(e3) ? Q(t2, e3?.name) : xe(e3) ? P2(e3?.name) : null;
}
function H2(t2, e3, n8) {
  let i6 = null;
  for (const l4 of n8) {
    const n9 = l4 ? t2.getField(l4) : null, o4 = Z(t2, { ...e3, field: l4, outStatisticTypes: { include: ["min", "max", "sum", "count"] } }, n9, true, true);
    i6 ? i6.outStatistics = i6.outStatistics.concat(o4.outStatistics) : i6 = o4;
  }
  return i6.where = t2.createQuery()?.where, i6;
}
function J(t2, e3, n8, i6) {
  return e3.map((e4) => {
    const l4 = new p4();
    let o4 = null, r4 = null, a5 = `${e4}_value${i6 ? `_${i6}` : ""}`;
    if ("variance" === e4) o4 = "var", r4 = n8;
    else if ("nullcount" === e4) {
      const e5 = t2.objectIdField;
      o4 = "count", r4 = e5 && t2.getField(e5) ? e5 : "1", a5 = "totalcount_value";
    } else "median" === e4 ? (o4 = "percentile-continuous", r4 = n8, l4.statisticParameters = { value: 0.5 }) : (o4 = e4, r4 = n8);
    return l4.statisticType = o4, l4.onStatisticField = r4, l4.outStatisticFieldName = a5, l4;
  });
}
function Z(t2, e3, n8, i6 = true, l4 = false) {
  const { field: r4, normalizationType: a5, normalizationField: s8, normalizationTotal: u6, minValue: c6, maxValue: p10, filter: y } = e3, v3 = t2.supportsSQLExpression ? A(t2, n8) || e3.sqlExpression : null, x2 = b2({ field: r4, normalizationType: a5, normalizationField: s8, normalizationTotal: u6, layer: t2 }), w2 = v3 || x2, F2 = w2 ? N3(w2, c6, p10) : null, E4 = F({ field: r4, normalizationField: s8, normalizationType: a5 }), S3 = U2(e3.sqlWhere, E4), T5 = U2(S3, F2), V4 = d({ normalizationField: s8, normalizationType: a5, sqlExpression: v3, supportsSQLExpression: t2.supportsSQLExpression, minValue: c6, maxValue: p10 }), $4 = Fe(t2.getField(r4 ?? void 0)), { include: z3, exclude: j5 } = e3.outStatisticTypes || {}, q4 = c2.filter((t3) => (!z3 || z3.includes(t3)) && (!j5 || !j5.includes(t3)) && ("nullcount" === t3 ? V4 : !$4 || "count" === t3) && ("median" !== t3 || i6)), C4 = t2.createQuery();
  return C4.where = U2(C4.where, T5), C4.sqlFormat = v3 ? "standard" : null, C4.outStatistics = J(t2, q4, w2, l4 ? r4 : void 0), X(C4, y), C4;
}
function G(t2, e3, n8 = true) {
  const { fields: i6, filter: l4 } = e3, { include: o4, exclude: r4 } = e3.outStatisticTypes || {}, s8 = c2.filter((t3) => (!o4 || o4.includes(t3)) && (!r4 || !r4.includes(t3)) && ("median" !== t3 || n8)), c6 = new v2();
  c6.where = U2(t2.createQuery()?.where, e3.sqlWhere) ?? void 0;
  const m10 = "new_value";
  return c6.outPivots = [new p5({ sourceFields: i6, valueFieldName: m10 })], c6.outStatistics = J(t2, s8, m10), X(c6, l4), c6;
}
function X(t2, e3) {
  e3 && (t2.geometry = e3.geometry, t2.spatialRelationship = e3.spatialRelationship, t2.timeExtent = t2.timeExtent?.intersection(e3.timeExtent) ?? e3.timeExtent, t2.distance = e3.distance, t2.units = e3.units);
}
function K(t2, e3) {
  const { field: n8, field2: i6, field3: l4, sqlExpression: o4 } = e3, r4 = !(!n8 || !i6), a5 = t2.createQuery();
  return a5.where = U2(a5.where, e3.sqlWhere), a5.sqlFormat = o4 ? "standard" : null, a5.outStatistics = [Y(r4 ? null : n8, r4 ? "1" : o4)].filter(Boolean), a5.groupByFieldsForStatistics = [n8 || o4, i6, l4].filter(Boolean), X(a5, e3.filter), a5;
}
function Y(t2, e3) {
  const n8 = "countOF" + (t2 || "Expr"), i6 = new p4();
  return i6.statisticType = "count", i6.onStatisticField = e3 ? "1" : t2, i6.outStatisticFieldName = n8, i6;
}
function tt(t2, e3, n8, i6 = V, l4, o4, r4) {
  const { min: a5, max: s8, normTotal: u6, excludeZerosExpr: c6 } = e3, m10 = e3.intervals || j2(a5, s8, i6), f3 = e3.sqlExpr || n8;
  return et(t2, m10, f3, c6, l4, o4, r4).then((t3) => ({ bins: t3.map((t4, e4) => ({ minValue: m10[e4][0], maxValue: m10[e4][1], count: "fulfilled" === t4.status ? t4.value : 0 })), minValue: a5, maxValue: s8, normalizationTotal: u6 }));
}
function et(t2, e3, n8, i6, l4, o4, r4) {
  const a5 = [], s8 = e3.length;
  for (let u6 = 0; u6 < s8; u6++) {
    const t3 = U2(i6, U2(n8 + " >= " + e3[u6][0], null !== e3[u6][1] ? n8 + (u6 === s8 - 1 ? " <= " : " < ") + e3[u6][1] : ""));
    a5.push(t3);
  }
  return Promise.allSettled(a5.map((e4) => t2.queryFeatureCount({ whereClause: e4, view: l4, filter: o4, signal: r4 })));
}

// node_modules/@arcgis/core/smartMapping/support/adapters/support/histogramUtils.js
var V2 = "countOFExpr";
var j4 = "lowerBoundary";
var E3 = "upperBoundary";
function q3(e3, i6, t2) {
  const a5 = e3.valueExpression || e3.sqlExpression, r4 = e3.signal;
  if (!a5) {
    const { field: a6, normalizationType: o4, normalizationField: l4 } = e3, s8 = a6 ? i6.getField(a6) : null, m10 = U(s8) || xe(s8), u6 = { field: a6, normalizationType: o4, normalizationField: l4, normalizationTotal: t2, layer: i6 };
    return { sqlExpression: m10 ? A(i6, s8) : b2(u6), sqlWhere: m10 ? null : e3.sqlWhere || F({ field: a6, normalizationType: o4, normalizationField: l4 }), filter: e3.filter, signal: r4 };
  }
  return { valueExpression: e3.valueExpression, sqlExpression: e3.sqlExpression, sqlWhere: e3.sqlWhere, filter: e3.filter, signal: r4 };
}
async function I4(e3, i6, n8) {
  const { field: t2, normalizationType: a5, normalizationField: r4, signal: o4 } = e3, l4 = F({ field: t2, normalizationType: a5, normalizationField: r4 }), s8 = new s4({ classificationDefinition: q({ field: t2, normalizationType: a5, normalizationField: r4, classificationMethod: e3.classificationMethod, standardDeviationInterval: e3.standardDeviationInterval, definedInterval: e3.definedInterval, breakCount: e3.numBins || V }), where: U2(l4, n8) });
  return i6.generateRenderer(s8, o4).then((e4) => {
    const { normalizationTotal: n9, classBreaks: o5 } = e4;
    return C3({ field: t2, normalizationType: a5, normalizationField: r4, normalizationTotal: n9, classBreaks: o5, where: l4, layer: i6 });
  });
}
async function M4(i6, t2, a5, o4, d4) {
  const { field: p10, sqlExpression: f3, normalizationField: c6, classificationMethod: z3, normalizationType: x2 } = i6, w2 = p10 ? t2.getField(p10) : null, h = xe(w2), F2 = be(w2) || h, B2 = i6.numBins || V;
  if (F2) {
    if (x2 || z3) throw new s(`${t2.adapterName}:not-supported`, "NormalizationType and classificationMethod are not supported for date-only and time-only fields");
    const i7 = (o4 - a5) / B2 / 1e3, n8 = i7 / 86400;
    return new m5({ field: p10, expression: f3, interval: { unit: h ? "seconds" : "days", value: Math.ceil(h ? i7 : n8) }, start: a5, end: o4 });
  }
  if ("defined-interval" === z3) return new m6({ field: p10, expression: f3, normalizationField: c6, normalizationTotal: d4, normalizationType: x2, interval: i6.definedInterval ?? Math.ceil((o4 - a5) / B2), start: x2 ? null : a5, end: x2 ? null : o4, normalizationMinValue: x2 ? a5 : null, normalizationMaxValue: x2 ? o4 : null });
  if ("manual" === z3) throw new s(`${t2.adapterName}:not-supported`, "Layer does not support manual classificationMethod");
  if ("natural-breaks" === z3 || "quantile" === z3 || "standard-deviation" === z3) {
    const n8 = b2({ field: p10, normalizationField: c6, normalizationTotal: d4, normalizationType: x2, layer: t2 }), r4 = null !== i6.minValue && null !== i6.maxValue ? N3(n8, i6.minValue, i6.maxValue) : void 0, o5 = await I4(i6, t2, r4);
    if (!o5.intervals) throw new s(`${t2.adapterName}:invalid`, "Invalid intervals returned from generate renderer");
    const l4 = [a5, ...o5.intervals.map((e3) => e3[1])];
    return new n4({ field: x2 ? null : p10, expression: x2 ? n8 : f3, boundaries: l4 });
  }
  return new m4({ field: p10, normalizationField: c6, normalizationTotal: d4, normalizationType: x2, expression: f3, numBins: B2, start: x2 ? null : a5, end: x2 ? null : o4, normalizationMinValue: x2 ? a5 : null, normalizationMaxValue: x2 ? o4 : null });
}
function g3(e3, i6, n8, t2) {
  return null != n8 && null != t2 ? Promise.resolve({ min: n8, max: t2 }) : i6.summaryStatistics({ ...e3, outStatisticTypes: { include: ["min", "max"] } }).then((e4) => ({ min: e4.min, max: e4.max }));
}
async function b3(e3, n8, r4, l4) {
  const { field: s8, minValue: m10, maxValue: u6, filter: d4, view: f3 } = e3, y = s8 ? n8.getField(s8) : null, z3 = Ie(y) || we(y), x2 = q3(e3, n8, r4), { min: v3, max: T5 } = await g3(x2, n8, m10, u6);
  if (null == v3 || null == T5) return { query: null, min: v3, max: T5 };
  const h = new p4({ statisticType: "count", outStatisticFieldName: V2, onStatisticField: "1" }), { where: F2, timeExtent: B2 } = l4 || {}, j5 = U2(F2, x2.sqlWhere), E4 = "lowerBoundary", I5 = "upperBoundary", b5 = new T2({ binParameters: await M4(e3, n8, v3, T5, r4), outStatistics: [h], binOrder: e3.sortOrder, where: j5, timeExtent: B2, lowerBoundaryAlias: E4, upperBoundaryAlias: I5, outTimeZone: f3?.timeZone && z3 ? O(f3.timeZone) : null });
  return X(b5, d4), { query: b5, min: v3, max: T5 };
}
function D2(e3, i6 = false) {
  if ("string" != typeof e3) return e3;
  return (i6 ? /* @__PURE__ */ new Date(`1970-01-01T${e3}Z`) : new Date(e3)).getTime();
}
function P3(e3, i6, t2) {
  const a5 = xe(i6);
  return { ...t2, bins: e3.features.map((e4) => ({ minValue: D2(e4.attributes[j4], a5), maxValue: D2(e4.attributes[E3], a5), count: e4.attributes[V2] })) };
}
function S2(e3, i6, n8) {
  const { valueExpression: t2, view: a5 } = e3, { featuresJSON: r4, graphics: o4, fieldInfos: l4 } = i6, s8 = { field: e3.field, valueExpression: t2, normalizationType: e3.normalizationType, normalizationField: e3.normalizationField, normalizationTotal: n8, minValue: e3.minValue, maxValue: e3.maxValue, standardDeviationInterval: e3.standardDeviationInterval, classificationMethod: e3.classificationMethod, numBins: e3.numBins };
  return t2 && a5 && (r4 || o4) && (s8.viewInfoParams = _2(a5), s8.timeZone = a5.timeZone, s8.fieldInfos = l4), s8;
}

// node_modules/@arcgis/core/smartMapping/support/adapters/InMemoryLayerAdapter.js
var $3 = 5;
var G2 = null;
var R3 = class extends p8 {
  constructor() {
    super(...arguments), this._hasLocalSource = false, this.adapterName = "in-memory-layer-adapter";
  }
  destroy() {
    this.workerClient?.destroy();
  }
  async _waitForLayerViewUpdate(e3) {
    if (!e3) throw new s(`${this.adapterName}:insufficient-data`, "layerView is required to fetch the features");
    const t2 = new AbortController(), i6 = j(() => !e3.updating, t2.signal);
    await E(i6, 5e3, t2).catch((e4) => {
      throw i.getLogger(this).warn("LayerView is taking too long to update. Aborting fetch from layerView."), e4;
    });
  }
  async _fetchFeatureSetFromMemory(e3, t2, a5) {
    const i6 = this.layer;
    if (this._hasLocalSource && "queryFeatures" in i6) return i6.queryFeatures(e3);
    if (!t2) throw new s(`${this.adapterName}:insufficient-data`, "view is required to fetch the features from layerView");
    const s8 = await t2.whenLayerView(this.layer);
    return await this._waitForLayerViewUpdate(s8), s8.queryFeatures(e3, { signal: a5 });
  }
  async _fetchFeaturesFromMemory(e3, t2, a5, i6) {
    const s8 = this.layer, o4 = "json" === i6;
    if (this._hasLocalSource && "queryFeatures" in s8) {
      const e4 = await s8.queryFeatures(t2);
      return o4 ? $2(e4.features) : e4.features;
    }
    if (await this._waitForLayerViewUpdate(e3), o4 && "queryFeaturesJSON" in e3 && e3.queryFeaturesJSON) {
      const { features: r4 } = await e3.queryFeaturesJSON(t2, { signal: a5 });
      return r4;
    }
    if (!("queryFeatures" in e3)) throw new s(`${this.adapterName}:not-supported`, "'queryFeatures' is not supported on the layerView");
    const n8 = await e3.queryFeatures(t2, { signal: a5 });
    return o4 ? $2(n8.features) : n8.features;
  }
  _fetchFeaturesForStats(e3, t2) {
    return w({ field: e3.field, field2: e3.field2, field3: e3.field3, normalizationField: e3.normalizationField, valueExpression: e3.valueExpression }).then((r4) => this.getSampleFeatures({ sampleSize: -1, view: e3.view, returnGeometry: e3.returnGeometry, filter: e3.filter, requiredFields: r4, signal: e3.signal }, t2));
  }
  async _summaryStatsFromClientQuery(e3, t2) {
    const { view: r4, signal: a5 } = e3, i6 = Z(this, e3, t2), s8 = await this._fetchFeatureSetFromMemory(i6, r4, a5), o4 = q2(s8, U(t2) || xe(t2));
    return C2(o4, e3.outStatisticTypes);
  }
  async _getNormalizationTotalFromMemory(e3, t2, a5) {
    const { featuresJSON: i6, graphics: s8, layerView: o4, query: n8 } = t2, l4 = { include: ["sum"] }, u6 = (!i6 && !s8 && o4 && "querySummaryStatistics" in o4 ? await o4.querySummaryStatistics(n8, { field: e3 }, { signal: a5 }) : i6 ? await this.workerClient.summaryStatistics({ field: e3, outStatisticTypes: l4 }, i6) : await d2({ attribute: { field: e3, outStatisticTypes: l4 }, features: s8 ?? [] })).sum;
    if (null == u6) throw new s(`${this.adapterName}:invalid`, "invalid normalizationTotal");
    return u6;
  }
  async _summaryStatsFromMemory(e3, t2) {
    const { view: r4, field: a5, valueExpression: i6, normalizationType: s8, signal: o4 } = e3, n8 = { field: a5, valueExpression: i6, normalizationType: s8, normalizationField: e3.normalizationField, normalizationTotal: e3.normalizationTotal, minValue: e3.minValue, maxValue: e3.maxValue, outStatisticTypes: e3.outStatisticTypes }, { featuresJSON: l4, graphics: u6, layerView: m10, query: y, fieldInfos: c6 } = await this._processStatsFromMemoryParams({ ...e3, layerViewFunc: "querySummaryStatistics" });
    return i6 && r4 && (l4 || u6) && (n8.fieldType = t2?.type ? i3.toJSON(t2.type) : null, n8.viewInfoParams = _2(r4), n8.timeZone = r4.timeZone, n8.fieldInfos = c6), "percent-of-total" === s8 && null == e3.normalizationTotal && (n8.normalizationTotal = await this._getNormalizationTotalFromMemory(a5, { featuresJSON: l4, graphics: u6, layerView: m10, query: y }, o4)), !l4 && !u6 && m10 && "querySummaryStatistics" in m10 ? m10.querySummaryStatistics(y, n8, { signal: o4 }) : l4 ? this.workerClient.summaryStatistics(n8, l4) : d2({ attribute: n8, features: u6 });
  }
  async _getFilteredFeatures(e3, t2) {
    let r4 = e3;
    const a5 = t2?.geometry;
    if ("intersects" === t2?.spatialRelationship && a5) {
      const t3 = await import("./intersectionOperator-YMHGZAQ2.js");
      r4 = e3.filter(({ geometry: e4 }) => !(!e4 || !t3.execute(e4, a5)));
    }
    return e3.length && "declaredClass" in e3[0] && "esri.Graphic" === e3[0].declaredClass ? { graphics: r4 } : { featuresJSON: r4 };
  }
  async _processStatsFromMemoryParams(e3) {
    const { features: t2, filter: r4 } = e3;
    if (t2?.length) return this._getFilteredFeatures(t2, r4);
    const { view: a5, field: i6, field2: s8, field3: o4, normalizationField: n8, valueExpression: l4, layerViewFunc: u6, signal: m10 } = e3;
    let p10 = e3.returnGeometry;
    if (null == p10 && l4) {
      if (!G2) {
        const { arcadeUtils: e5 } = await e();
        G2 = e5;
      }
      const e4 = G2.hasGeometryOperations(l4);
      e4 && await G2.enableGeometryOperations(), p10 = e4;
    }
    let y = null, c6 = null, f3 = null, d4 = null, h = null;
    if (a5) try {
      const e4 = "subtype-sublayer" === this.layer.type ? this.layer.parent : this.layer;
      y = await a5.whenLayerView(e4), c6 = null != u6 && null != y && u6 in y && "function" == typeof y[u6];
    } catch {
      c6 = false;
    }
    if (c6) try {
      await this._waitForLayerViewUpdate(y);
      const e4 = await w({ field: i6, field2: s8, field3: o4, normalizationField: n8, valueExpression: l4 });
      j3(this, e4, y).length ? c6 = false : (f3 = this.layer.createQuery(), f3.outFields = e4, f3.returnGeometry = false, X(f3, r4)), y.suspended && (c6 = false);
    } catch {
      c6 = false;
    }
    return c6 || (d4 = await this._fetchFeaturesForStats({ field: i6, field2: s8, field3: o4, valueExpression: l4, normalizationField: n8, returnGeometry: p10, filter: r4, view: a5, signal: m10 }, "json"), h = (await w({ valueExpression: l4 })).map((e4) => this.getField(e4)?.toJSON()).filter(Boolean)), { layerView: y, query: f3, featuresJSON: d4, fieldInfos: h };
  }
  async _uvFromClientQuery(e3, t2) {
    const { view: r4, signal: a5 } = e3, i6 = K(this, e3), s8 = await this._fetchFeatureSetFromMemory(i6, r4, a5), o4 = await D(s8, { layer: this, field: e3.field, field2: e3.field2, field3: e3.field3, fieldDelimiter: c, view: e3.view, signal: e3.signal });
    return $(o4, t2, e3.returnAllCodedValues, c);
  }
  async _uvFromMemory(e3, t2) {
    const { view: r4, field: a5, valueExpression: i6, returnAllCodedValues: s8, signal: o4 } = e3, { featuresJSON: n8, graphics: l4, layerView: u6, query: m10, fieldInfos: p10 } = await this._processStatsFromMemoryParams({ ...e3, layerViewFunc: "queryUniqueValues" }), y = { field: a5, field2: e3.field2, field3: e3.field3, fieldDelimiter: c, valueExpression: i6, domains: t2, returnAllCodedValues: s8 };
    return i6 && r4 && (n8 || l4) && (y.viewInfoParams = _2(r4), y.timeZone = r4.timeZone, y.fieldInfos = p10), !n8 && !l4 && u6 && "queryUniqueValues" in u6 ? u6.queryUniqueValues(m10, y, { signal: o4 }) : n8 ? this.workerClient.uniqueValues(y, n8) : p3({ attribute: y, features: l4 });
  }
  _histogramForField(e3) {
    let t2 = null;
    return t2 = null != e3.minValue && null != e3.maxValue ? Promise.resolve({ min: e3.minValue, max: e3.maxValue }) : this.summaryStatistics({ ...e3, outStatisticTypes: { include: ["min", "max", "count"] } }).then((e4) => {
      if (!e4.count) throw new s(`${this.adapterName}:insufficient-data`, "Either the layer has no features or none of the features have data for the field");
      return { min: e4.min, max: e4.max };
    }), t2.then((t3) => tt(this, { min: t3.min, max: t3.max }, e3.field, e3.numBins ?? void 0, e3.view, e3.filter, e3.signal));
  }
  async _histogramFromQueryAttributeBinsFromMemory(e3) {
    const { field: t2, normalizationType: r4, signal: a5 } = e3, i6 = await this._processStatsFromMemoryParams({ ...e3, layerViewFunc: "queryAttributeBins" }), { featuresJSON: s8, graphics: o4, layerView: n8, query: l4 } = i6, u6 = "percent-of-total" === r4 ? e3.normalizationTotal ?? await this._getNormalizationTotalFromMemory(t2, i6, a5) : void 0;
    if (!n8 || !("queryAttributeBins" in n8) || s8 || o4) {
      const t3 = S2(e3, i6, u6);
      return s8 ? this.workerClient.histogram(t3, s8) : v({ attribute: t3, features: o4 });
    }
    const { query: m10, min: p10, max: y } = await b3(e3, this, u6, l4);
    if (!m10) return { bins: [], minValue: p10, maxValue: y, normalizationTotal: u6 };
    const c6 = await n8.queryAttributeBins(m10, { signal: a5 });
    return P3(c6, t2 ? this.getField(t2) : null, { minValue: p10, maxValue: y, normalizationTotal: u6 });
  }
  async _histogramFromMemory(e3) {
    const { field: t2, signal: r4 } = e3, a5 = await this._processStatsFromMemoryParams({ ...e3, layerViewFunc: "queryHistogram" }), { featuresJSON: i6, graphics: s8, layerView: o4, query: n8 } = a5, l4 = "percent-of-total" === e3.normalizationType ? e3.normalizationTotal ?? await this._getNormalizationTotalFromMemory(t2, a5, r4) : void 0, u6 = S2(e3, a5, l4);
    return !i6 && !s8 && o4 && "queryHistogram" in o4 ? o4.queryHistogram(n8, u6, { signal: r4 }) : i6 ? this.workerClient.histogram(u6, i6) : v({ attribute: u6, features: s8 });
  }
  _classBreaksFromInterpolation(e3) {
    const { minValue: t2, maxValue: r4 } = e3, a5 = e3.numClasses || $3, i6 = [], s8 = (r4 - t2) / a5;
    for (let l4 = 0; l4 < a5; l4++) {
      const e4 = t2 + l4 * s8;
      i6.push({ minValue: e4, maxValue: e4 + s8 });
    }
    i6[a5 - 1].maxValue = r4;
    const o4 = { classBreaks: i6, normalizationTotal: e3.normalizationTotal }, n8 = P(o4, e3.classificationMethod);
    return Promise.resolve(n8);
  }
  async _classBreaksFromMemory(e3) {
    const { view: t2, field: r4, valueExpression: a5, signal: i6 } = e3, { featuresJSON: s8, graphics: o4, layerView: n8, query: l4, fieldInfos: u6 } = await this._processStatsFromMemoryParams({ ...e3, layerViewFunc: "queryClassBreaks" }), m10 = { field: r4, valueExpression: a5, normalizationType: e3.normalizationType, normalizationField: e3.normalizationField, normalizationTotal: e3.normalizationTotal, minValue: e3.minValue, maxValue: e3.maxValue, standardDeviationInterval: e3.standardDeviationInterval, classificationMethod: e3.classificationMethod, numClasses: e3.numClasses };
    return a5 && t2 && (s8 || o4) && (m10.viewInfoParams = _2(t2), m10.timeZone = t2.timeZone, m10.fieldInfos = u6), "percent-of-total" === e3.normalizationType && null == e3.normalizationTotal && (m10.normalizationTotal = await this._getNormalizationTotalFromMemory(r4, { featuresJSON: s8, graphics: o4, layerView: n8, query: l4 }, i6)), !s8 && !o4 && n8 && "queryClassBreaks" in n8 ? n8.queryClassBreaks(l4, m10, { signal: i6 }) : s8 ? this.workerClient.classBreaks(m10, s8) : c3({ attribute: m10, features: o4 });
  }
  async _heatmapStatsFromMemory(e3) {
    const { view: t2, field: r4, radius: a5, signal: s8 } = e3;
    n(t2, "InMemoryLayerAdapter: must have a view");
    try {
      const r5 = await t2.whenLayerView(this.layer);
      if ("queryHeatmapStatistics" in r5 && !r5.updating && !e3.filter) return await r5.queryHeatmapStatistics({ field: e3.field, radius: e3.radius });
    } catch {
      s2(s8);
    }
    const { featuresJSON: n8, graphics: l4 } = await this._processStatsFromMemoryParams({ ...e3, returnGeometry: true }), u6 = new m7({ extent: t2.extent, tolerance: "2d" === t2.type ? t2.state.resolution : t2.pixelSizeAt?.(t2.center) }), p10 = { field: r4, radius: a5, transform: s3(u6), spatialReference: t2.spatialReference?.toJSON(), size: t2.size };
    return n8?.length || l4?.length ? n8 ? this.workerClient.heatmapStatistics(p10, n8) : z({ attribute: p10, features: l4 }) : { min: null, max: null };
  }
  getField(e3 = "") {
    return this.layer.getField(e3);
  }
  getFieldUsageInfo(e3) {
    return this.getField(e3) ? { supportsLabelingInfo: true, supportsRenderer: true, supportsPopupTemplate: true, supportsLayerQuery: true, supportsStatistics: true } : null;
  }
  getFieldDomain(e3, t2) {
    return this.layer.getFieldDomain(e3, t2);
  }
  createQuery() {
    return this.layer.createQuery();
  }
  async summaryStatistics(e3) {
    const { field: t2, valueExpression: a5, sqlExpression: i6, features: s8, view: o4 } = e3, n8 = t2 ? this.getField(t2) : null, l4 = !!a5, u6 = "3d" === o4?.type;
    if (!a5 && i6 && !this.supportsSQLExpression) throw new s(`${this.adapterName}:not-supported`, "Layer does not support standardized SQL expression for queries");
    return l4 || s8 || u6 ? this._summaryStatsFromMemory(e3, n8) : this._summaryStatsFromClientQuery(e3, n8);
  }
  async uniqueValues(e3) {
    const { valueExpression: t2, sqlExpression: a5, features: i6, view: s8 } = e3, o4 = await I3(e3, this), n8 = !!t2, l4 = "3d" === s8?.type;
    if (!t2 && a5 && !this.supportsSQLExpression) throw new s(`${this.adapterName}:not-supported`, "Layer does not support standardized SQL expression for queries");
    return n8 || i6 || l4 ? this._uvFromMemory(e3, o4) : this._uvFromClientQuery(e3, o4);
  }
  async histogram(e3) {
    const { features: t2, valueExpression: a5, normalizationType: i6, sqlExpression: s8 } = e3, o4 = t2 || !!a5;
    if (!a5 && s8 && !this.supportsSQLExpression) throw new s(`${this.adapterName}:not-supported`, "Layer does not support standardized SQL expression for queries");
    return o4 || i6 ? this._histogramFromMemory(e3) : this._histogramForField(e3);
  }
  async classBreaks(e3) {
    return false !== e3.analyzeData ? this._classBreaksFromMemory(e3) : this._classBreaksFromInterpolation(e3);
  }
  async queryFeatureCount(e3) {
    const { whereClause: t2, view: a5, signal: i6 } = e3;
    if (!a5) throw new s(`${this.adapterName}:insufficient-data`, "view is required to fetch the features from layerView");
    const s8 = this.layer.createQuery();
    s8.where = U2(s8.where, t2);
    const o4 = await a5.whenLayerView(this.layer);
    return await j(() => !o4.updating, i6), o4.queryFeatureCount(s8, { signal: i6 });
  }
  async generateRenderer(e3, t2) {
    throw new s(`${this.adapterName}:not-supported`, "Layer does not support generateRenderer operation");
  }
  async predominantCategories(e3) {
    const { fields: t2, view: r4, signal: a5, filter: i6 } = e3, s8 = s6(t2), o4 = await this._uvFromMemory({ valueExpression: s8, view: r4, signal: a5, filter: i6 });
    return B(o4.uniqueValueInfos, t2);
  }
  async heatmapStatistics(e3) {
    return this._heatmapStatsFromMemory(e3);
  }
  async getSampleFeatures(e3, a5) {
    const { view: i6, sampleSize: s8, requiredFields: o4, returnGeometry: n8, filter: l4, signal: u6 } = e3, m10 = this.layer.createQuery(), p10 = 1;
    if (m10.outSpatialReference = i6?.spatialReference, m10.returnGeometry = !!n8, m10.outFields = o4, X(m10, l4), !i6) throw new s(`${this.adapterName}:not-supported`, "view is required to get sample features for Layer");
    const y = await i6.whenLayerView(this.layer);
    if (j3(this, o4, y).length) throw new s(`${this.adapterName}:not-supported`, "Required fields need to be passed in the outFields for Layer");
    const c6 = await this._fetchFeaturesFromMemory(y, m10, u6, a5), f3 = null != s8 && s8 > 0 && s8 <= c6.length ? s8 : c6.length;
    return I(c6, f3, p10);
  }
  load(e3) {
    const t2 = this.layer.load(e3).then(async (t3) => {
      this.geometryType = t3.geometryType, this.objectIdField = t3.objectIdField, this.supportsSQLExpression = "stream" === t3.type || !!t3.capabilities?.query?.supportsSqlExpression, this.minScale = t3.minScale, this.maxScale = t3.maxScale, this.fullExtent = "fullExtent" in t3 ? t3.fullExtent : t3.parent?.fullExtent, this._hasLocalSource = false, this.hasQueryEngine = true, this.workerClient = n6.getInstance(), await this.workerClient.open(e3.signal);
    });
    return this.addResolvingPromise(t2), Promise.resolve(this);
  }
};
__decorate([m({ readOnly: true })], R3.prototype, "adapterName", void 0), __decorate([m({ constructOnly: true })], R3.prototype, "layer", void 0), R3 = __decorate([a("esri.smartMapping.support.adapters.InMemoryLayerAdapter")], R3);

// node_modules/@arcgis/core/smartMapping/support/adapters/FeatureLayerAdapter.js
var Y2 = 5;
var ee = 2e4;
var te = 4e5;
var ie = class extends R3 {
  constructor() {
    super(...arguments), this.adapterName = "feature-layer-adapter";
  }
  _isStatsSupportedOnService() {
    const e3 = this.layer;
    if (!e3.capabilities?.query?.supportsStatistics || "multipatch" === this.geometryType && !g(e3.url) && e3.version < 10.5) throw new s(`${this.adapterName}:not-supported`, "Layer does not support statistics query");
    return Promise.resolve();
  }
  _fetchFeaturesFromService(e3, t2) {
    return this.layer.queryFeatures(e3, { signal: t2 }).then((e4) => e4.features);
  }
  _fetchFeaturesJSONFromService(e3, t2) {
    return this._fetchFeaturesFromService(e3, t2).then($2);
  }
  _summaryStatsFromGenRend(e3) {
    const t2 = e3.normalizationType, i6 = e3.normalizationField;
    return this.classBreaks({ field: e3.field, numClasses: Y2, classificationMethod: "standard-deviation", standardDeviationInterval: 0.25, normalizationType: t2, normalizationField: "field" === t2 ? i6 : void 0, minValue: e3.minValue, maxValue: e3.maxValue, filter: e3.filter, signal: e3.signal }).then((t3) => {
      let i7, s8, r4;
      if (t3.classBreakInfos?.some((e4) => (e4.hasAvg && (i7 = e4), !!i7)), i7) {
        const e4 = i7.maxValue - i7.minValue;
        s8 = i7.minValue + e4 / 2, r4 = 4 * e4;
      }
      const a5 = { min: t3.minValue, max: t3.maxValue, avg: s8, stddev: r4 };
      return C2(a5, e3.outStatisticTypes);
    });
  }
  async _summaryStatsFromServiceQuery(e3, t2) {
    await this._isStatsSupportedOnService(), "percent-of-total" === e3.normalizationType && (e3.normalizationTotal = await this._getNormalizationTotal(e3.field, e3.normalizationType, e3.filter));
    const i6 = U(t2) || xe(t2), s8 = "capabilities" in this.layer ? this.layer.capabilities : null, r4 = Z(this, e3, t2, s8?.query?.supportsPercentileStatistics ?? false), a5 = await this.layer.queryFeatures(r4, { signal: e3.signal }), o4 = q2(a5, i6);
    return C2(o4, e3.outStatisticTypes);
  }
  async _summaryStatsForFieldsBasic(e3) {
    const { outStatisticTypes: t2, fields: i6 } = e3, s8 = 50, r4 = [];
    for (let n8 = 0; n8 < i6.length; n8 += s8) {
      const t3 = i6.slice(n8, n8 + s8), a6 = H2(this, e3, t3);
      r4.push(this.layer.queryFeatures(a6, { signal: e3.signal }));
    }
    const a5 = (await Promise.all(r4)).flatMap((e4) => e4.features).map((e4) => e4.attributes).reduce((e4, t3) => Object.assign(e4, t3), {}), o4 = {};
    for (const n8 in a5) {
      const e4 = n8.match(/^(\w+)_value_/);
      if (null == a5[n8] || !e4) continue;
      switch (e4[1]) {
        case "min":
          o4.min = null == o4.min ? a5[n8] : Math.min(o4.min, a5[n8]);
          break;
        case "max":
          o4.max = null == o4.max ? a5[n8] : Math.max(o4.max, a5[n8]);
          break;
        case "sum":
          o4.sum = (o4.sum || 0) + a5[n8];
          break;
        case "count":
          o4.count = (o4.count || 0) + a5[n8];
      }
    }
    return C2(o4, t2);
  }
  async _summaryStatsForFieldsAdvanced(e3, t2) {
    const { outStatisticTypes: i6, fields: s8 } = e3, r4 = i6?.exclude?.includes("variance") || i6?.include && !i6.include.includes("variance"), a5 = i6?.exclude?.includes("stddev") || i6?.include && !i6.include.includes("stddev");
    if (null == t2.sum || !t2.count || r4 && a5) return t2;
    t2.avg = t2.sum / t2.count;
    const o4 = 50, n8 = [];
    for (let u6 = 0; u6 < s8.length; u6 += o4) {
      const i7 = s8.slice(u6, u6 + o4), r5 = H2(this, e3, i7);
      r5.outStatistics = [];
      for (const e4 of i7) {
        const i8 = `sumOfSquares_${e4}`, s9 = `(power(${M(this.layer, e4) ? N2(e4) : e4} - ${t2.avg}, 2))`, a6 = new p4({ statisticType: "sum", onStatisticField: s9, outStatisticFieldName: i8 });
        r5.outStatistics.push(a6);
      }
      n8.push(this.layer.queryFeatures(r5, { signal: e3.signal }));
    }
    const l4 = (await Promise.all(n8)).reduce((e4, t3) => e4 + Object.values(t3.features[0].attributes).reduce((e5, t4) => e5 + t4, 0), 0);
    return t2.variance = l4 / (t2.count - 1), t2.stddev = Math.sqrt(t2.variance), C2(t2, i6);
  }
  async _summaryStatsForFields(e3) {
    const t2 = await this._summaryStatsForFieldsBasic(e3);
    return this._summaryStatsForFieldsAdvanced(e3, t2);
  }
  async _summaryStatsUsingQueryPivot(e3) {
    await this._isStatsSupportedOnService();
    const t2 = "capabilities" in this.layer ? this.layer.capabilities : null, i6 = G(this, e3, t2?.query?.supportsPercentileStatistics ?? false), s8 = await this.layer.queryPivot(i6, { signal: e3.signal }), r4 = q2(s8, false);
    return C2(r4, e3.outStatisticTypes);
  }
  _uvFromGenRenderer(e3, t2) {
    const i6 = e3.field ?? void 0, s8 = new s5({ attributeField: i6 }), r4 = new s4({ classificationDefinition: s8 });
    return this.generateRenderer(r4, e3.signal).then((e4) => {
      const t3 = {}, s9 = this.getField(i6);
      return e4.uniqueValues.forEach((e5) => {
        let i7 = e5.value;
        null != i7 && "" !== i7 && ("string" != typeof i7 || "" !== i7.trim() && "<null>" !== i7.toLowerCase()) || (i7 = null), null == t3[i7] ? t3[i7] = { count: e5.count, data: ge(s9) && i7 ? Number(i7) : i7 } : t3[i7].count = t3[i7].count + e5.count;
      }), { count: t3 };
    }).then((i7) => $(i7, [t2], e3.returnAllCodedValues));
  }
  async _uvFromServiceQuery(e3, t2) {
    return this._isStatsSupportedOnService().then(() => this.layer.queryFeatures(K(this, e3), { signal: e3.signal })).then((t3) => D(t3, { layer: this, field: e3.field, field2: e3.field2, field3: e3.field3, fieldDelimiter: c, view: e3.view, signal: e3.signal })).then((i6) => $(i6, t2, e3.returnAllCodedValues, c));
  }
  _getNormalizationTotal(e3, t2, i6, s8) {
    return e3 && "percent-of-total" === t2 ? this.summaryStatistics({ field: e3, outStatisticTypes: { include: ["sum"] }, filter: i6, signal: s8 }).then((e4) => e4.sum) : Promise.resolve(null);
  }
  _histogramForExpr(e3) {
    return this._getNormalizationTotal(e3.field, e3.normalizationType, e3.filter, e3.signal).then((t2) => {
      const i6 = q3(e3, this, t2);
      return g3(i6, this, e3.minValue, e3.maxValue).then((s8) => {
        const r4 = s8.min, a5 = s8.max;
        if (null == r4 || null == a5) return { bins: [], minValue: r4, maxValue: a5, normalizationTotal: t2 };
        const o4 = e3.numBins || V, n8 = j2(r4, a5, o4), l4 = se(i6.sqlExpression, n8, null != e3.minValue && null != e3.maxValue), u6 = new p4({ statisticType: "count", outStatisticFieldName: "countOFExpr", onStatisticField: "1" }), c6 = this.layer.createQuery();
        return c6.where = U2(c6.where, i6.sqlWhere), c6.sqlFormat = "standard", c6.outStatistics = [u6], c6.groupByFieldsForStatistics = [l4], c6.orderByFields = [l4], X(c6, e3.filter), this._isStatsSupportedOnService().then(() => this.layer.queryFeatures(c6, { signal: i6.signal })).then((e4) => R2(e4, r4, a5, o4, t2));
      });
    });
  }
  async _histogramForFields(e3) {
    const { min: t2, max: i6 } = await g3({ fields: e3.fields, sqlWhere: e3.sqlWhere, filter: e3.filter, signal: e3.signal }, this, e3.minValue, e3.maxValue);
    if (null == t2 || null == i6) return { bins: [], minValue: t2, maxValue: i6 };
    const s8 = "newField", r4 = e3.numBins || V, a5 = se(s8, j2(t2, i6, r4), null != e3.minValue && null != e3.maxValue), o4 = new p4({ statisticType: "count", outStatisticFieldName: "countOFExpr", onStatisticField: s8 }), n8 = new v2(), { where: l4, timeExtent: u6 } = this.createQuery();
    return n8.where = U2(l4, e3.sqlWhere), n8.outPivots = [new p5({ sourceFields: e3.fields, valueFieldName: s8 })], n8.outStatistics = [o4], n8.groupByFieldsForStatistics = [a5], n8.orderByFields = [a5], n8.timeExtent = u6, X(n8, e3.filter), this._isStatsSupportedOnService().then(() => this.layer.queryPivot(n8, { signal: e3.signal })).then((e4) => R2(e4, t2, i6, r4));
  }
  async _histogramFromQueryAttributeBins(e3) {
    const { field: t2, normalizationType: i6, filter: s8, signal: r4 } = e3, a5 = await this._getNormalizationTotal(t2, i6, s8, r4), { query: o4, min: n8, max: l4 } = await b3(e3, this, a5, this.createQuery());
    if (!o4) return { bins: [], minValue: n8, maxValue: l4, normalizationTotal: a5 };
    const u6 = await this.layer.queryAttributeBins(o4, { signal: r4 });
    return P3(u6, t2 ? this.getField(t2) : null, { minValue: n8, maxValue: l4, normalizationTotal: a5 });
  }
  _classBreaksFromGenRend(e3) {
    const { field: t2, normalizationType: i6, normalizationField: s8, normalizationTotal: r4, signal: a5 } = e3, o4 = F({ field: t2, normalizationType: i6, normalizationField: s8 }), n8 = b2({ field: t2, normalizationType: i6, normalizationField: s8, normalizationTotal: r4, layer: this }), l4 = N3(n8, e3.minValue, e3.maxValue), u6 = q({ field: t2, normalizationType: i6, normalizationField: s8, classificationMethod: e3.classificationMethod, standardDeviationInterval: e3.standardDeviationInterval, breakCount: e3.numClasses || Y2 }), c6 = new s4({ classificationDefinition: u6 });
    return c6.where = U2(o4, l4), this.generateRenderer(c6, a5).then((t3) => P(t3, e3.classificationMethod));
  }
  async summaryStatistics(e3) {
    const { field: t2, fields: i6, normalizationType: a5, valueExpression: o4, sqlExpression: n8, view: u6, features: c6, useFeaturesInView: m10 } = e3, p10 = t2 ? this.getField(t2) : null, h = U(p10) || xe(p10), d4 = o4 && !(n8 && this.supportsSQLExpression), y = this._hasLocalSource || c6 || m10, f3 = u6 && "3d" === u6.type;
    if (i6?.length) {
      const t3 = { ...e3, fields: i6 };
      if (!this.layer.capabilities?.operations?.supportsQueryPivot) return await this._summaryStatsForFields(t3);
      try {
        return await this._summaryStatsUsingQueryPivot(t3);
      } catch {
        return await this._summaryStatsForFields(t3);
      }
    }
    if (y || d4) return d4 || c6 || m10 || f3 || this._hasLocalSource && !this.layer.capabilities.query.supportsStatistics ? this._summaryStatsFromMemory(e3, p10) : this._summaryStatsFromClientQuery(e3, p10);
    if (!this.supportsSQLExpression && (h || n8 || "natural-log" === a5 || "square-root" === a5)) throw new s(`${this.adapterName}:not-supported`, "Layer does not support standardized SQL expression for queries");
    return (a5 && !this.supportsSQLExpression ? this._summaryStatsFromGenRend(e3) : this._summaryStatsFromServiceQuery(e3, p10)).catch(() => (s2(e3.signal), this._summaryStatsFromMemory(e3, p10)));
  }
  async uniqueValues(e3) {
    const { valueExpression: t2, sqlExpression: i6, features: s8, useFeaturesInView: a5, signal: o4 } = e3, n8 = t2 && !(i6 && this.supportsSQLExpression), l4 = this._hasLocalSource || s8 || a5 || n8, u6 = e3.view, c6 = u6 && "3d" === u6.type, m10 = await I3(e3, this);
    return l4 ? n8 || s8 || a5 || c6 || this._hasLocalSource && !this.layer.capabilities.query.supportsStatistics ? this._uvFromMemory(e3, m10) : this._uvFromClientQuery(e3, m10) : this._uvFromServiceQuery(e3, m10).catch((t3) => (s2(o4), !e3.field || e3.field2 || e3.field3 || e3.filter ? t3 : this._uvFromGenRenderer(e3, m10[0]))).catch(() => (s2(o4), c6 ? this._uvFromMemory(e3, m10) : this._uvFromClientQuery(e3, m10)));
  }
  async histogram(e3) {
    const { field: t2, normalizationType: i6, normalizationField: a5, classificationMethod: o4, view: n8, filter: u6, signal: c6 } = e3, m10 = t2 ? this.getField(t2) : null, p10 = U(m10) || xe(m10), h = e3.valueExpression || e3.sqlExpression, d4 = e3.valueExpression && !(e3.sqlExpression && this.supportsSQLExpression), y = this._hasLocalSource || e3.features || e3.useFeaturesInView || d4, f3 = this.supportsSQLExpression, F2 = !o4 || "equal-interval" === o4, S3 = e3.minValue, w2 = e3.maxValue, v3 = null != S3 && null != w2, x2 = e3.numBins || V;
    if (e3.fields?.length) {
      if (!f3) throw new s(`${this.adapterName}:not-supported`, "Layer does not support standardized SQL expression for queries");
      if (!this.layer.capabilities?.operations?.supportsQueryPivot) throw new s(`${this.adapterName}:not-supported`, "Layer does not support pivot queries");
      return this._histogramForFields(e3);
    }
    if (y) return this._histogramFromMemory(e3);
    if (this.layer.capabilities?.operations?.supportsQueryBins && e3.useQueryAttributeBins) try {
      return await this._histogramFromQueryAttributeBins(e3);
    } catch {
      return s2(c6), this._histogramFromQueryAttributeBinsFromMemory(e3);
    }
    if ((h || f3) && F2) {
      if (!f3 && (h || "natural-log" === i6 || "square-root" === i6)) throw new s(`${this.adapterName}:not-supported`, "Layer does not support standardized SQL expression for queries");
      return this._histogramForExpr(e3);
    }
    if (p10 && F2) throw new s(`${this.adapterName}:not-supported`, "Normalization and date field are not allowed when layer does not support standardized SQL expression for queries");
    return i6 || !F2 ? I4(e3, this).then((r4) => {
      if (!v3) return tt(this, r4, t2, x2, n8, u6, c6);
      if (S3 > r4.max || w2 < r4.min) throw new s(`${this.adapterName}:insufficient-data`, "Range defined by 'minValue' and 'maxValue' does not intersect available data range of the field");
      if (F2) return tt(this, { min: S3, max: w2, sqlExpr: r4.sqlExpr, excludeZerosExpr: r4.excludeZerosExpr }, t2, x2, n8, u6, c6);
      {
        const s8 = { field: t2, normalizationType: i6, normalizationField: a5, normalizationTotal: r4.normTotal, layer: this }, o5 = b2(s8), l4 = N3(o5, S3, w2);
        return I4(e3, this, l4).then((e4) => tt(this, e4, t2, x2, n8, u6, c6));
      }
    }) : this._histogramForField(e3);
  }
  async classBreaks(e3) {
    const t2 = false !== e3.analyzeData, i6 = this._hasLocalSource || e3.features || e3.useFeaturesInView || e3.valueExpression || e3.filter;
    if (t2 && i6) return this._classBreaksFromMemory(e3);
    return (t2 ? this._classBreaksFromGenRend(e3) : this._classBreaksFromInterpolation(e3)).catch(() => (s2(e3.signal), this._classBreaksFromMemory(e3)));
  }
  async queryFeatureCount(e3) {
    if (this._hasLocalSource) throw new s(`${this.adapterName}:not-supported`, "Layer does not support count query");
    const t2 = this.layer, i6 = t2.createQuery();
    return i6.where = U2(i6.where, e3.whereClause), X(i6, e3.filter), t2.queryFeatureCount(i6, { signal: e3.signal });
  }
  async generateRenderer(e3, t2) {
    const i6 = this.layer;
    if (this._hasLocalSource || i6.version < 10.1) throw new s(`${this.adapterName}:not-supported`, "Layer does not support generateRenderer operation (requires ArcGIS Server version 10.1+)");
    const r4 = i6.createQuery();
    return e3.where = U2(e3.where, r4.where), l3(i6.parsedUrl?.path ?? "", { source: i6.dynamicDataSource ?? void 0, gdbVersion: i6.gdbVersion ?? void 0 }, e3, { signal: t2 });
  }
  async predominantCategories(e3) {
    if (!this._hasLocalSource && !this.supportsSQLExpression) throw new s(`${this.adapterName}:not-supported`, "Layer does not support advanced SQL expressions and standardized queries");
    const { fields: t2, view: i6, signal: r4, filter: a5 } = e3, o4 = s6(t2), n8 = u2(t2), l4 = i6 && this._hasLocalSource ? await this._uvFromMemory({ valueExpression: o4, view: i6, signal: r4, filter: a5 }) : await this._uvFromServiceQuery({ sqlExpression: n8.expression, valueExpression: o4, signal: r4, filter: a5 });
    return B(l4.uniqueValueInfos, t2);
  }
  async getSampleFeatures(e3, s8) {
    const { view: a5, requiredFields: o4, returnGeometry: n8, filter: l4, signal: u6 } = e3, c6 = e3.sampleSize;
    if (null == c6 || 0 === c6) return [];
    const m10 = this.layer.createQuery(), p10 = 1, h = "json" === s8;
    m10.outSpatialReference = a5?.spatialReference, m10.returnGeometry = !!n8, m10.outFields = o4, X(m10, l4);
    let d4 = [], y = false;
    if (a5) try {
      const r4 = await a5.whenLayerView(this.layer);
      if (y = !j3(this, o4, r4).length, y) {
        if (c6 >= 1 && !e3.filter && "getSampleFeatures" in r4) {
          await this._waitForLayerViewUpdate(r4);
          const e4 = await r4.getSampleFeatures({ minFeatureCount: c6, sampleSize: c6 });
          if (null != e4) return h ? e4 : e4.map((e5) => _.fromJSON(e5));
        }
        if (d4 = await this._fetchFeaturesFromMemory(r4, m10, u6, s8), d4.length >= c6 && c6 > 0) return I(d4, c6, p10);
      }
    } catch (f3) {
      s2(u6);
    }
    try {
      if (this._hasLocalSource) return y ? d4 : h ? await this._fetchFeaturesJSONFromService(m10, u6) : await this._fetchFeaturesFromService(m10, u6);
      const t2 = await this.queryFeatureCount({ view: a5, filter: l4, signal: u6 }), s9 = this.layer.capabilities.query.maxRecordCount;
      let r4 = -1 === c6 ? t2 : c6;
      if (r4 = s9 && r4 > s9 ? s9 : r4, t2 <= d4.length || d4.length >= s9) return d4;
      if (m10.maxAllowableOffset = e3.resolution || (a5 ? a5.extent.width / a5.width / a5.scale : at(this.layer.spatialReference)) * te, t2 <= r4) return h ? await this._fetchFeaturesJSONFromService(m10, u6) : await this._fetchFeaturesFromService(m10, u6);
      if (t2 <= ee) {
        const e4 = this.layer.createQuery();
        X(e4, l4);
        const t3 = await this.layer.queryObjectIds();
        return m10.objectIds = I(t3, r4, p10), h ? await this._fetchFeaturesJSONFromService(m10, u6) : await this._fetchFeaturesFromService(m10, u6);
      }
      return this.layer.capabilities?.query?.supportsPagination && (m10.num = Math.min(r4, ee)), h ? await this._fetchFeaturesJSONFromService(m10, u6) : await this._fetchFeaturesFromService(m10, u6);
    } catch (f3) {
      return s2(u6), d4;
    }
  }
  load(e3) {
    const t2 = this.layer.load(e3).then(async (t3) => {
      this.geometryType = t3.geometryType, this.objectIdField = t3.objectIdField, this.supportsSQLExpression = t3.capabilities?.query?.supportsSqlExpression, this._hasLocalSource = "parquet" === t3.type || !t3.url && !!t3.source, this.hasQueryEngine = this._hasLocalSource, this.minScale = t3.minScale, this.maxScale = t3.maxScale, this.fullExtent = t3.fullExtent, this.workerClient = n6.getInstance(), await this.workerClient.open(e3.signal);
    });
    return this.addResolvingPromise(t2), Promise.resolve(this);
  }
};
function se(e3, t2, i6) {
  const s8 = [], r4 = t2.length;
  return t2.forEach((t3, a5) => {
    const [o4, n8] = t3;
    let l4 = null;
    l4 = 0 !== a5 || i6 ? a5 !== r4 - 1 || i6 ? U2(`${e3} >= ${o4}`, `${e3} ${a5 === r4 - 1 ? " <= " : " < "} ${n8}`) : `${e3} >= ${o4}` : `${e3} < ${n8}`, s8.push("WHEN (" + l4 + ") THEN " + (a5 + 1));
  }), ["CASE", s8.join(" "), "ELSE 0", "END"].join(" ");
}
__decorate([m({ readOnly: true })], ie.prototype, "adapterName", void 0), __decorate([m({ constructOnly: true })], ie.prototype, "layer", void 0), ie = __decorate([a("esri.smartMapping.support.adapters.FeatureLayerAdapter")], ie);

// node_modules/@arcgis/core/smartMapping/support/adapters/CSVLayerAdapter.js
var u3 = class extends ie {
  constructor() {
    super(...arguments), this.adapterName = "csv-layer-adapter";
  }
  async _createGenerateRendererResult(e3, r4, i6, n8, l4) {
    const p10 = e3?.features, c6 = p10?.length;
    if (!c6) throw new s("csv-layer-adapter:insufficient-data", "No features are available to calculate statistics");
    const u6 = $2(p10);
    let d4 = null;
    if ("percent-of-total" === n8) {
      if (d4 = (await this.workerClient.summaryStatistics({ field: r4 }, u6)).sum, null == d4) throw new s("csv-layer-adapter:invalid", "invalid normalizationTotal");
    }
    if ("class-breaks-definition" === l4?.type) {
      const e4 = (await I2({ field: r4, normalizationType: n8, normalizationField: i6, normalizationTotal: d4 }, u6)).filter((e5) => Number.isFinite(e5));
      return a2({ definition: l4, values: e4, normalizationTotal: d4 });
    }
    const f3 = (await I2({ field: r4 }, u6)).filter((e4) => null != e4 && "string" == typeof e4 && "" !== e4.trim());
    return n3(f3);
  }
  generateRenderer(e3, t2) {
    const r4 = e3.classificationDefinition;
    let i6 = null, s8 = null, o4 = null;
    "class-breaks-definition" === r4?.type ? (i6 = r4.classificationField, s8 = r4.normalizationField, o4 = r4.normalizationType) : i6 = r4?.attributeField;
    const a5 = this.layer;
    return w({ field: i6, normalizationField: s8 }).then((l4) => {
      const p10 = a5.createQuery();
      return p10.returnGeometry = false, p10.outFields = l4, p10.where = U2(p10.where, e3.where), a5.queryFeatures(p10, { signal: t2 }).then((e4) => this._createGenerateRendererResult(e4, i6, s8, o4, r4));
    });
  }
  load(e3) {
    const t2 = this.layer.load(e3).then(async (t3) => {
      this.geometryType = t3.geometryType, this.objectIdField = t3.objectIdField, this.supportsSQLExpression = true, this._hasLocalSource = false, this.hasQueryEngine = true, this.workerClient = n6.getInstance(), await this.workerClient.open(e3.signal);
    });
    return this.addResolvingPromise(t2), Promise.resolve(this);
  }
};
__decorate([m({ readOnly: true })], u3.prototype, "adapterName", void 0), u3 = __decorate([a("esri.smartMapping.support.adapters.CSVLayerAdapter")], u3);

// node_modules/@arcgis/core/smartMapping/support/adapters/FeatureLayerBinningAdapter.js
var T4 = class extends ie {
  constructor() {
    super(...arguments), this.adapterName = "feature-layer-binning-adapter";
  }
  async _getNormalizationTotalFromMemory(e3, t2, r4) {
    const { featuresJSON: i6, graphics: s8, layerView: o4, query: n8 } = t2, l4 = { include: ["sum"] }, u6 = (!i6 && !s8 && o4 && "queryAggregateSummaryStatistics" in o4 ? await o4.queryAggregateSummaryStatistics(n8, { field: e3, outStatisticTypes: l4 }, { signal: r4 }) : i6 ? await this.workerClient.summaryStatistics({ field: e3 }, i6) : await d2({ attribute: { field: e3, outStatisticTypes: l4 }, features: s8 })).sum;
    if (null == u6) throw new s(`${this.adapterName}:invalid`, "invalid normalizationTotal");
    return u6;
  }
  async _processStatsFromMemoryParams(e3) {
    const { features: t2, filter: i6 } = e3;
    if (t2?.length) return this._getFilteredFeatures(t2, i6);
    const { view: s8, field: o4, field2: n8, field3: l4, normalizationField: u6, valueExpression: m10, returnGeometry: p10, layerViewFunc: y, signal: g4 } = e3;
    let d4 = null, c6 = null, h = null, w2 = null, F2 = null;
    if (s8) try {
      if (d4 = await s8.whenLayerView(this.layer), n(d4), c6 = null != y && y in d4 && "function" == typeof d4[y], c6) {
        await this._waitForLayerViewUpdate(d4);
        const e4 = await w({ field: o4, field2: n8, field3: l4, normalizationField: u6, valueExpression: m10 });
        z2(this, e4).length ? c6 = false : (h = "createAggregateQuery" in d4 ? d4.createAggregateQuery() : null, h ? (h.outFields = e4, h.returnGeometry = false, X(h, i6)) : c6 = false), d4.suspended && (c6 = false);
      }
    } catch {
      c6 = false;
    }
    if (!c6 && (F2 = W(this.layer).map((e4) => e4.toJSON()), w2 = await this._fetchFeaturesForStats({ field: o4, field2: n8, field3: l4, valueExpression: m10, normalizationField: u6, returnGeometry: p10, filter: i6, view: s8, signal: g4 }, "json"), !w2?.length)) throw new s(`${this.adapterName}:insufficient-data`, "No features are available to calculate statistics");
    return { layerView: d4, query: h, featuresJSON: w2, fieldInfos: F2 };
  }
  async _summaryStatsFromMemory(e3, t2) {
    const { view: a5, field: r4, valueExpression: i6, normalizationType: s8, signal: o4 } = e3, l4 = { field: r4, valueExpression: i6, normalizationType: s8, normalizationField: e3.normalizationField, normalizationTotal: e3.normalizationTotal, minValue: e3.minValue, maxValue: e3.maxValue, outStatisticTypes: e3.outStatisticTypes }, { featuresJSON: u6, graphics: p10, layerView: y, query: g4, fieldInfos: d4 } = await this._processStatsFromMemoryParams({ ...e3, layerViewFunc: "queryAggregateSummaryStatistics" });
    return i6 && a5 && (u6 || p10) && (l4.fieldType = t2?.type ? i3.toJSON(t2.type) : null, l4.viewInfoParams = _2(a5), l4.timeZone = a5.timeZone, l4.fieldInfos = d4), "percent-of-total" === s8 && null == e3.normalizationTotal && (l4.normalizationTotal = await this._getNormalizationTotalFromMemory(r4, { featuresJSON: u6, graphics: p10, layerView: y, query: g4 }, o4)), !u6 && !p10 && y && "queryAggregateSummaryStatistics" in y ? y.queryAggregateSummaryStatistics(g4, l4, { signal: o4 }) : u6 ? this.workerClient.summaryStatistics(l4, u6) : d2({ attribute: l4, features: p10 });
  }
  async _uvFromMemory(e3, t2) {
    const { view: a5, field: r4, valueExpression: i6, returnAllCodedValues: s8, signal: o4 } = e3, { featuresJSON: n8, graphics: l4, layerView: u6, query: m10, fieldInfos: y } = await this._processStatsFromMemoryParams({ ...e3, layerViewFunc: "queryAggregateUniqueValues" }), g4 = { field: r4, field2: e3.field2, field3: e3.field3, fieldDelimiter: c, valueExpression: i6, domains: t2, returnAllCodedValues: s8 };
    return i6 && a5 && (n8 || l4) && (g4.viewInfoParams = _2(a5), g4.timeZone = a5.timeZone, g4.fieldInfos = y), !n8 && !l4 && u6 && "queryAggregateUniqueValues" in u6 ? u6.queryAggregateUniqueValues(m10, g4, { signal: o4 }) : n8 ? this.workerClient.uniqueValues(g4, n8) : p3({ attribute: g4, features: l4 });
  }
  async _histogramFromMemory(e3) {
    const { view: t2, field: a5, valueExpression: r4, signal: i6 } = e3, { featuresJSON: s8, graphics: o4, layerView: n8, query: l4, fieldInfos: u6 } = await this._processStatsFromMemoryParams({ ...e3, layerViewFunc: "queryAggregateHistogram" }), m10 = { field: a5, valueExpression: r4, normalizationType: e3.normalizationType, normalizationField: e3.normalizationField, normalizationTotal: e3.normalizationTotal, minValue: e3.minValue, maxValue: e3.maxValue, standardDeviationInterval: e3.standardDeviationInterval, classificationMethod: e3.classificationMethod, numBins: e3.numBins };
    return r4 && t2 && (s8 || o4) && (m10.viewInfoParams = _2(t2), m10.timeZone = t2.timeZone, m10.fieldInfos = u6), "percent-of-total" === e3.normalizationType && null == e3.normalizationTotal && (m10.normalizationTotal = await this._getNormalizationTotalFromMemory(a5, { featuresJSON: s8, graphics: o4, layerView: n8, query: l4 }, i6)), !s8 && !o4 && n8 && "queryAggregateHistogram" in n8 ? n8.queryAggregateHistogram(l4, m10, { signal: i6 }) : s8 ? this.workerClient.histogram(m10, s8) : v({ attribute: m10, features: o4 });
  }
  async _classBreaksFromMemory(e3) {
    const { view: t2, field: a5, valueExpression: r4, signal: i6 } = e3, { featuresJSON: s8, graphics: o4, layerView: n8, query: l4, fieldInfos: u6 } = await this._processStatsFromMemoryParams({ ...e3, layerViewFunc: "queryAggregateClassBreaks" }), m10 = { field: a5, valueExpression: r4, normalizationType: e3.normalizationType, normalizationField: e3.normalizationField, normalizationTotal: e3.normalizationTotal, minValue: e3.minValue, maxValue: e3.maxValue, standardDeviationInterval: e3.standardDeviationInterval, classificationMethod: e3.classificationMethod, numClasses: e3.numClasses };
    return r4 && t2 && (s8 || o4) && (m10.viewInfoParams = _2(t2), m10.timeZone = t2.timeZone, m10.fieldInfos = u6), "percent-of-total" === e3.normalizationType && null == e3.normalizationTotal && (m10.normalizationTotal = await this._getNormalizationTotalFromMemory(a5, { featuresJSON: s8, graphics: o4, layerView: n8, query: l4 }, i6)), !s8 && !o4 && n8 && "queryAggregateClassBreaks" in n8 ? n8.queryAggregateClassBreaks(l4, m10, { signal: i6 }) : s8 ? this.workerClient.classBreaks(m10, s8) : c3({ attribute: m10, features: o4 });
  }
  getField(e3 = "") {
    const t2 = W(this.layer);
    return t2?.find((t3) => t3.name.toLowerCase() === e3?.toLowerCase());
  }
  getFieldUsageInfo(e3) {
    return this.getField(e3) ? { supportsLabelingInfo: true, supportsRenderer: true, supportsPopupTemplate: true, supportsLayerQuery: false, supportsStatistics: true } : null;
  }
  getFieldDomain(e3, t2) {
    return null;
  }
  async summaryStatistics(e3) {
    const { field: t2 } = e3, r4 = t2 ? this.getField(t2) : null, i6 = U(r4) || xe(r4), s8 = e3.sqlExpression && !e3.valueExpression && !t2;
    if (i6 || s8) throw new s(`${this.adapterName}:not-supported`, "Date field and sqlExpression are not supported");
    return this._summaryStatsFromMemory(e3, r4);
  }
  async uniqueValues(e3) {
    const t2 = await I3(e3, this);
    return this._uvFromMemory(e3, t2);
  }
  async histogram(e3) {
    const { field: t2 } = e3, r4 = t2 ? this.getField(t2) : null, i6 = U(r4) || xe(r4), s8 = e3.sqlExpression && !e3.valueExpression && !t2;
    if (i6 || s8) throw new s(`${this.adapterName}:not-supported`, "Date field and sqlExpression are not supported");
    return this._histogramFromMemory(e3);
  }
  async classBreaks(e3) {
    return (false !== e3.analyzeData ? this._classBreaksFromMemory(e3) : this._classBreaksFromInterpolation(e3)).catch(() => (s2(e3.signal), this._classBreaksFromMemory(e3)));
  }
  async queryFeatureCount(e3) {
    const t2 = await e3.view?.whenLayerView(this.layer);
    if (!t2 || !("queryAggregateCount" in t2) || !t2.queryAggregateCount) throw new s(`${this.adapterName}:not-supported`, "LayerView is not supported.");
    await this._waitForLayerViewUpdate(t2);
    const r4 = t2.createAggregateQuery();
    return r4.where = U2(r4.where, e3.whereClause), X(r4, e3.filter), t2.queryAggregateCount(r4, { signal: e3.signal });
  }
  generateRenderer(e3, t2) {
    throw new s(`${this.adapterName}:not-supported`, "'generateRenderer' is not supported.");
  }
  heatmapStatistics(e3) {
    throw new s(`${this.adapterName}:not-supported`, "'heatmapStatistics' is not supported.");
  }
  async predominantCategories(e3) {
    const { fields: t2, view: a5, signal: r4 } = e3, i6 = s6(t2), s8 = await this._uvFromMemory({ valueExpression: i6, view: a5, signal: r4 });
    return B(s8.uniqueValueInfos, t2);
  }
  async getSampleFeatures(e3, r4) {
    const { view: i6, sampleSize: s8, requiredFields: o4, returnGeometry: n8, filter: l4, signal: u6 } = e3;
    if (!i6) throw new s(`${this.adapterName}:not-supported`, "'view' is required to get sample features for binning.");
    if ("3d" === i6.type) throw new s(`${this.adapterName}:not-supported`, "3d 'view' is not supported to get sample features for binning.");
    const m10 = await i6.whenLayerView(this.layer);
    if (!("queryAggregateJSON" in m10 && m10.queryAggregateJSON && "queryAggregates" in m10 && m10.queryAggregates)) throw new s(`${this.adapterName}:not-supported`, "LayerView is not supported.");
    await this._waitForLayerViewUpdate(m10);
    if (z2(this, o4).length) throw new s(`${this.adapterName}:insufficient-data`, "Layer does not have required fields");
    const p10 = 1, y = "json" === r4, g4 = m10.createAggregateQuery();
    g4.outSpatialReference = i6?.spatialReference, g4.returnGeometry = !!n8, g4.outFields = o4, X(g4, l4);
    const { features: d4 } = y ? await m10.queryAggregateJSON(g4, { signal: u6 }) : await m10.queryAggregates(g4, { signal: u6 });
    return d4.length && null != s8 && s8 > 0 && s8 <= d4.length ? I(d4, s8, p10) : d4;
  }
  load(e3) {
    const t2 = this.layer.load(e3).then(async (t3) => {
      const r4 = "featureReduction" in t3 ? t3.featureReduction : null;
      if ("binning" !== r4?.type && "cluster" !== r4?.type) throw new s(`${this.adapterName}:invalid-parameters`, `Feature reduction type ${r4?.type} is not supported`);
      this.geometryType = "cluster" === r4?.type ? "point" : "polygon", this.objectIdField = null, this.supportsSQLExpression = false, this._hasLocalSource = false, this.hasQueryEngine = true, this.minScale = t3.minScale, this.maxScale = t3.maxScale, this.fullExtent = t3.fullExtent, this.workerClient = n6.getInstance(), await this.workerClient.open(e3.signal);
    });
    return this.addResolvingPromise(t2), Promise.resolve(this);
  }
};
__decorate([m({ readOnly: true })], T4.prototype, "adapterName", void 0), T4 = __decorate([a("esri.smartMapping.support.adapters.FeatureLayerBinningAdapter")], T4);
var x = T4;

// node_modules/@arcgis/core/smartMapping/support/adapters/SceneLayerAdapter.js
var A2 = class extends p8 {
  constructor(e3) {
    super(e3), this._featureLayerAdapter = null, this.workerClient = null, this.adapterName = "scene-layer-adapter";
  }
  destroy() {
    this.workerClient?.destroy();
  }
  _hasCachedStatistics(e3) {
    return this.layer.hasCachedStatistics(e3);
  }
  _updateQuery(e3, t2 = [], r4 = []) {
    if (!e3 || !r4.length) return e3;
    const a5 = this.layer.objectIdField, s8 = e3.clone(), i6 = t2.filter((e4) => {
      const t3 = this.layer.getField(e4);
      return !r4.includes(t3.name);
    }), o4 = i6.some((e4) => this.layer.getField(e4).name === a5);
    return s8.outFields = o4 ? i6 : [...i6, a5], s8;
  }
  async _fetchFeaturesFromMemory(e3, t2, r4) {
    if (!e3) throw new s("scene-layer-adapter:insufficient-data", "view is required to fetch the features from layerView");
    const n8 = await e3.whenLayerView(this.layer), l4 = new AbortController(), u6 = l4.signal, p10 = j(() => !n8.updating, u6);
    await E(p10, 5e3, l4);
    const m10 = j3(this, r4, n8);
    s2(u6);
    const c6 = this._updateQuery(t2, r4 ?? [], m10), d4 = await n8.queryFeatures(c6, { signal: u6 });
    s2(u6);
    const h = d4.features;
    return m10.length ? n8.whenGraphicAttributes(h, m10) : h;
  }
  async _fetchFeaturesJSONFromMemory(e3, t2, r4) {
    return this._fetchFeaturesFromMemory(e3, t2, r4).then($2);
  }
  _fetchFeaturesForStats(e3, t2) {
    return w({ field: e3.field, normalizationField: e3.normalizationField, valueExpression: e3.valueExpression }).then((r4) => this.getSampleFeatures({ sampleSize: -1, view: e3.view, returnGeometry: e3.returnGeometry, requiredFields: r4, signal: e3.signal }, t2));
  }
  async _processStatsFromMemoryParams(e3) {
    const t2 = e3.features;
    if (t2?.length) {
      return t2.length && "declaredClass" in t2[0] && "esri.Graphic" === t2[0].declaredClass ? { graphics: t2 } : { featuresJSON: t2 };
    }
    const { view: r4, field: s8, normalizationField: i6, valueExpression: o4, signal: n8 } = e3, l4 = await this._fetchFeaturesForStats({ field: s8, valueExpression: o4, normalizationField: i6, view: r4, signal: n8 }, null);
    if (!l4?.length) throw new s("scene-layer-adapter:insufficient-data", "No features are available to calculate statistics");
    return { graphics: l4 };
  }
  _getCachedStatistics(e3, t2) {
    const r4 = this.layer;
    return e3.valueExpression || e3.sqlExpression || e3.sqlWhere || e3.minValue || e3.maxValue ? Promise.reject(new s("scene-layer-adapter:not-supported", "This Layer does not support calculating statistics when 'valueExpression', 'sqlExpression', 'sqlWhere', 'minValue' or 'maxValue' is specified")) : r4.queryCachedStatistics(t2?.name, { signal: e3.signal }).then((e4) => {
      const t3 = e4.stats, { min: r5, max: a5, totalValuesCount: s8 } = t3;
      let { avg: i6, stddev: o4, sum: n8, variance: l4, count: u6 } = t3;
      return 0 === r5 && 0 === a5 || (i6 = 0 === i6 ? null : i6, n8 = 0 === n8 ? null : n8, o4 = 0 === o4 ? null : o4, l4 = 0 === l4 ? null : l4, u6 = 0 === u6 ? null : u6), null == u6 && (null != n8 && null != i6 ? u6 = Math.round(n8 / i6) : null != s8 && (u6 = s8)), { avg: i6, count: u6, max: a5, min: r5, stddev: o4, sum: n8, variance: l4 };
    });
  }
  async _getNormalizationTotal(e3, t2, r4) {
    const s8 = { include: ["sum"] }, i6 = (t2 ? await this.workerClient.summaryStatistics({ field: e3, outStatisticTypes: s8 }, t2) : await d2({ attribute: { field: e3, outStatisticTypes: s8 }, features: r4 })).sum;
    if (null == i6) throw new s("scene-layer-adapter:invalid", "invalid normalizationTotal");
    return i6;
  }
  async _getSummaryStatisticsFromMemory(e3, t2) {
    const { view: r4, field: a5, normalizationField: s8, valueExpression: i6 } = e3, { featuresJSON: o4, graphics: n8 } = await this._processStatsFromMemoryParams(e3), l4 = { field: a5, valueExpression: i6, normalizationType: e3.normalizationType, normalizationField: s8, normalizationTotal: e3.normalizationTotal, minValue: e3.minValue, maxValue: e3.maxValue, outStatisticTypes: e3.outStatisticTypes };
    return e3.valueExpression && r4 && o4 && (l4.fieldType = t2?.type ? i3.toJSON(t2.type) : null, l4.viewInfoParams = _2(r4), l4.timeZone = r4.timeZone), "percent-of-total" === e3.normalizationType && null == e3.normalizationTotal && (l4.normalizationTotal = await this._getNormalizationTotal(a5, o4, n8)), o4 ? this.workerClient.summaryStatistics(l4, o4) : d2({ attribute: l4, features: n8 });
  }
  _getCachedStatisticsForUniqueValues(e3, r4) {
    const s8 = this.layer, i6 = r4?.name, o4 = r4 && e3.field ? this.getFieldDomain(e3.field) : null;
    return e3.valueExpression || e3.sqlExpression || e3.sqlWhere ? Promise.reject(new s("scene-layer-adapter:not-supported", "This Layer does not support calculating statistics when 'valueExpression', 'sqlExpression' or 'sqlWhere' is specified")) : s8.queryCachedStatistics(i6, { signal: e3.signal }).then((a5) => {
      const o5 = a5.stats;
      if (!o5.mostFrequentValues) throw new Error();
      const n8 = a5.labels?.labels, l4 = {}, u6 = [], c6 = "countOF" + i6;
      o5.mostFrequentValues.forEach((e4) => {
        const a6 = new _({ attributes: {} });
        a6.attributes[i6] = r4 && r4.name !== s8.objectIdField && (ge(r4) || U(r4)) ? Number(e4.value) : e4.value, a6.attributes[c6] = e4.count, u6.push(a6);
      }), n8 && n8.forEach((e4) => {
        l4[e4.value] = e4.label;
      });
      const d4 = new g2({ features: u6 });
      return D(d4, { layer: this, field: e3.field, labels: l4, view: e3.view, signal: e3.signal });
    }).then((t2) => $(t2, [o4], e3.returnAllCodedValues));
  }
  async _getUniqueValuesFromMemory(e3, t2) {
    const { view: r4, field: a5, field2: s8, field3: i6, valueExpression: o4, returnAllCodedValues: n8 } = e3, l4 = { field: a5, field2: s8, field3: i6, fieldDelimiter: c, valueExpression: o4, domains: t2, returnAllCodedValues: n8 }, { featuresJSON: u6, graphics: p10 } = await this._processStatsFromMemoryParams(e3);
    return e3.valueExpression && r4 && u6 && (l4.viewInfoParams = _2(r4), l4.timeZone = r4.timeZone), u6 ? this.workerClient.uniqueValues(l4, u6) : p3({ attribute: l4, features: p10 });
  }
  _getCachedStatisticsForHistogram(e3, t2) {
    const r4 = this.layer;
    return e3.valueExpression || e3.sqlExpression || e3.sqlWhere || e3.normalizationType ? Promise.reject(new s("scene-layer-adapter:not-supported", "This Layer does not support calculating statistics when 'valueExpression' or 'sqlExpression' or 'sqlWhere' or 'normalizationType' is specified")) : r4.queryCachedStatistics(t2 && t2.name, { signal: e3.signal }).then((t3) => {
      const r5 = t3.stats, { minValue: a5, maxValue: s8 } = e3, i6 = null != a5 ? a5 : r5.min, o4 = null != s8 ? s8 : r5.max, n8 = e3.numBins || 10, l4 = V3(r5.histogram, i6, o4, n8);
      return R2(l4, i6, o4, n8);
    });
  }
  async _getClassBreaksFromMemory(e3) {
    const { view: t2, field: r4, normalizationField: a5, valueExpression: s8 } = e3, { featuresJSON: i6, graphics: o4 } = await this._processStatsFromMemoryParams(e3), n8 = { field: r4, valueExpression: s8, normalizationType: e3.normalizationType, normalizationField: a5, normalizationTotal: e3.normalizationTotal, minValue: e3.minValue, maxValue: e3.maxValue, standardDeviationInterval: e3.standardDeviationInterval, classificationMethod: e3.classificationMethod, numClasses: e3.numClasses };
    return e3.valueExpression && t2 && i6 && (n8.viewInfoParams = _2(t2), n8.timeZone = t2.timeZone), "percent-of-total" === e3.normalizationType && null == e3.normalizationTotal && (n8.normalizationTotal = await this._getNormalizationTotal(r4, i6, o4)), i6 ? this.workerClient.classBreaks(n8, i6) : c3({ attribute: n8, features: o4 });
  }
  async _getHistogramFromMemory(e3) {
    const { view: t2, field: r4 } = e3, { featuresJSON: a5, graphics: s8 } = await this._processStatsFromMemoryParams(e3), i6 = { field: r4, valueExpression: e3.valueExpression, normalizationType: e3.normalizationType, normalizationField: e3.normalizationField, normalizationTotal: e3.normalizationTotal, minValue: e3.minValue, maxValue: e3.maxValue, standardDeviationInterval: e3.standardDeviationInterval, classificationMethod: e3.classificationMethod, numBins: e3.numBins };
    return e3.valueExpression && t2 && a5 && (i6.viewInfoParams = _2(t2), i6.timeZone = t2.timeZone), "percent-of-total" === e3.normalizationType && null == e3.normalizationTotal && (i6.normalizationTotal = await this._getNormalizationTotal(r4, a5, s8)), a5 ? this.workerClient.histogram(i6, a5) : v({ attribute: i6, features: s8 });
  }
  getField(e3) {
    return this.layer.getField(e3 ?? "");
  }
  getFieldUsageInfo(e3) {
    const t2 = this.getField(e3);
    if (!t2) return null;
    const r4 = this.layer.getFieldUsageInfo(t2.name);
    return { supportsLabelingInfo: r4.supportsLabelingInfo, supportsPopupTemplate: r4.supportsPopupTemplate, supportsRenderer: r4.supportsRenderer, supportsLayerQuery: r4.supportsLayerQuery, supportsStatistics: true };
  }
  getFieldDomain(e3, t2) {
    return this._featureLayerAdapter ? this._featureLayerAdapter.getFieldDomain(e3, t2) : null;
  }
  createQuery() {
    return this.layer.createQuery();
  }
  summaryStatistics(e3) {
    const t2 = this.getField(e3.field);
    if (this._featureLayerAdapter) return this._featureLayerAdapter.summaryStatistics(e3);
    if (e3.filter) throw new s("scene-layer-adapter:not-supported", "filter is not supported");
    return this._hasCachedStatistics(t2?.name) ? this._getCachedStatistics(e3, t2).catch(() => (s2(e3.signal), this._getSummaryStatisticsFromMemory(e3, t2))) : this._getSummaryStatisticsFromMemory(e3, t2);
  }
  async uniqueValues(e3) {
    if (this._featureLayerAdapter) return this._featureLayerAdapter.uniqueValues(e3);
    if (e3.filter) throw new s("scene-layer-adapter:not-supported", "filter is not supported");
    const t2 = await I3(e3, this), { field: r4, field2: s8 } = e3, o4 = r4 && s8, n8 = this.getField(r4);
    return !o4 && n8 && this._hasCachedStatistics(n8.name) ? this._getCachedStatisticsForUniqueValues(e3, n8).catch(() => (s2(e3.signal), this._getUniqueValuesFromMemory(e3, t2))) : this._getUniqueValuesFromMemory(e3, t2);
  }
  histogram(e3) {
    const t2 = this.getField(e3.field);
    if (this._featureLayerAdapter) return this._featureLayerAdapter.histogram(e3);
    if (e3.filter) throw new s("scene-layer-adapter:not-supported", "filter is not supported");
    return t2 && this._hasCachedStatistics(t2.name) ? this._getCachedStatisticsForHistogram(e3, t2).catch(() => (s2(e3.signal), this._getHistogramFromMemory(e3))) : this._getHistogramFromMemory(e3);
  }
  classBreaks(e3) {
    const t2 = this.getField(e3.field);
    if (this._featureLayerAdapter) return this._featureLayerAdapter.classBreaks(e3);
    if (e3.filter) throw new s("scene-layer-adapter:not-supported", "filter is not supported");
    return this._hasCachedStatistics(t2?.name) ? Promise.reject(new s("scene-layer-adapter:not-supported", "Cached stats not supported")) : this._getClassBreaksFromMemory(e3);
  }
  queryFeatureCount(e3) {
    return this._featureLayerAdapter ? this._featureLayerAdapter.queryFeatureCount(e3) : Promise.reject(new s("scene-layer-adapter:not-supported", "SceneLayer without associated FeatureLayer does not support count query"));
  }
  generateRenderer(e3, t2) {
    return this._featureLayerAdapter ? this._featureLayerAdapter.generateRenderer(e3, t2) : Promise.reject(new s("scene-layer-adapter:not-supported", "SceneLayer without associated FeatureLayer does not support generateRenderer operation"));
  }
  heatmapStatistics(e3) {
    return this._featureLayerAdapter ? this._featureLayerAdapter.heatmapStatistics(e3) : Promise.reject(new s("scene-layer-adapter:not-supported", "SceneLayer without associated FeatureLayer does not support heatmapStatistics operation"));
  }
  async predominantCategories(e3) {
    if (this._featureLayerAdapter) return this._featureLayerAdapter.predominantCategories(e3);
    throw new s("scene-layer-adapter:not-supported", "SceneLayer without associated FeatureLayer does not support predominantCategories");
  }
  async getSampleFeatures(e3, t2) {
    if (e3.filter) throw new s("scene-layer-adapter:not-supported", "filter is not supported");
    const { view: s8, sampleSize: o4, requiredFields: n8, returnGeometry: l4, signal: u6 } = e3, p10 = 1, m10 = "json" === t2, c6 = this.createQuery();
    c6.outFields = n8, c6.returnGeometry = !!l4, c6.where = null, c6.num = o4;
    let d4 = [];
    try {
      if (d4 = m10 ? await this._fetchFeaturesJSONFromMemory(s8, c6, n8) : await this._fetchFeaturesFromMemory(s8, c6, n8), d4.length && null != o4 && o4 > 0 && o4 <= d4.length) return I(d4, o4, p10);
    } catch (y) {
      s2(u6);
    }
    let h = null;
    if (this._featureLayerAdapter) {
      const r4 = { ...e3 };
      delete r4.view, h = await this._featureLayerAdapter.getSampleFeatures(r4, t2);
    }
    return h?.length ? h : I(d4, d4.length, p10);
  }
  load(e3) {
    const t2 = this.layer.load(e3).then(async (t3) => {
      this.workerClient = n6.getInstance(), await this.workerClient.open(e3.signal);
      const r4 = t3.associatedLayer;
      if (this.geometryType = t3.geometryType, null != r4) {
        this._featureLayerAdapter = new ie({ layer: r4 });
        return this._featureLayerAdapter.load(e3).then(() => {
          this.objectIdField = this._featureLayerAdapter.objectIdField, this.supportsSQLExpression = this._featureLayerAdapter.supportsSQLExpression, this.minScale = this._featureLayerAdapter.minScale, this.maxScale = this._featureLayerAdapter.maxScale, this.fullExtent = this._featureLayerAdapter.fullExtent;
        });
      }
      this.objectIdField = t3.objectIdField, this.supportsSQLExpression = false, this.hasQueryEngine = false, this.fullExtent = t3.fullExtent;
    });
    return this.addResolvingPromise(t2), Promise.resolve(this);
  }
};
function V3(e3, r4 = e3.minimum, a5 = e3.maximum, s8) {
  const i6 = [];
  for (let t2 = 0; t2 < s8; t2++) i6[t2] = 0;
  const o4 = e3.counts.length, n8 = e3.minimum, l4 = e3.maximum;
  for (let t2 = 0; t2 < o4; t2++) {
    const u7 = (t2 + 0.5) / o4, p10 = ((1 - u7) * n8 + u7 * l4 - r4) / (a5 - r4) * s8;
    p10 >= 0 && p10 <= s8 && (i6[p10 === s8 ? s8 - 1 : Math.floor(p10)] += e3.counts[t2]);
  }
  const u6 = [];
  return i6.forEach((e4, r5) => {
    const a6 = new _({ attributes: {} });
    a6.attributes.EXPR_1 = r5 + 1, a6.attributes.countOFExpr = e4, u6.push(a6);
  }), new g2({ features: u6 });
}
__decorate([m({ readOnly: true })], A2.prototype, "adapterName", void 0), __decorate([m({ constructOnly: true })], A2.prototype, "layer", void 0), A2 = __decorate([a("esri.smartMapping.support.adapters.SceneLayerAdapter")], A2);

// node_modules/@arcgis/core/smartMapping/support/adapters/PointCloudLayerAdapter.js
var o3 = class extends A2 {
  constructor(e3) {
    super(e3), this.adapterName = "point-cloud-layer-adapter";
  }
  getField(e3) {
    return this.layer.fieldsIndex.get(e3 ?? "");
  }
  getFieldUsageInfo(e3) {
    const r4 = this.getField(e3);
    if (!r4) return null;
    const t2 = this._hasCachedStatistics(r4.name);
    return { supportsLabelingInfo: t2, supportsPopupTemplate: t2, supportsRenderer: t2, supportsLayerQuery: false, supportsStatistics: t2 };
  }
  getFieldDomain() {
    return null;
  }
  load(e3) {
    const r4 = this.layer.load(e3).then(() => {
      this.geometryType = "point", this.objectIdField = null, this.supportsSQLExpression = false, this.hasQueryEngine = false;
    });
    return this.addResolvingPromise(r4), Promise.resolve(this);
  }
};
__decorate([m({ readOnly: true })], o3.prototype, "adapterName", void 0), o3 = __decorate([a("esri.smartMapping.support.adapters.PointCloudLayerAdapter")], o3);

// node_modules/@arcgis/core/smartMapping/support/adapters/StreamLayerAdapter.js
var c5 = class extends R3 {
  constructor() {
    super(...arguments), this.adapterName = "stream-layer-adapter";
  }
  async _summaryStatsFromClientQuery(t2, r4) {
    const { signal: s8, view: a5 } = t2, c6 = Z(this, t2, r4);
    c6.outStatistics = c6.outStatistics?.filter((t3) => "totalcount_value" !== t3.outStatisticFieldName);
    const u6 = await this._fetchFeatureSetFromMemory(c6, a5, s8), l4 = q2(u6, U(r4) || xe(r4));
    return C2(l4, t2.outStatisticTypes);
  }
};
__decorate([m({ readOnly: true })], c5.prototype, "adapterName", void 0), c5 = __decorate([a("esri.smartMapping.support.adapters.StreamLayerAdapter")], c5);

// node_modules/@arcgis/core/smartMapping/support/adapters/support/layerUtils.js
var n7 = { 0: { adapter: ie, type: "catalog", label: "CatalogLayer" }, 1: { adapter: ie, type: "catalog-footprint", label: "CatalogFootprintLayer" }, 2: { adapter: u3, type: "csv", label: "CSVLayer" }, 3: { adapter: ie, type: "feature", label: "FeatureLayer" }, 5: { adapter: ie, type: "imagery", label: "ImageryLayer" }, 4: { adapter: ie, type: "geojson", label: "GeoJSONLayer" }, 6: { adapter: ie, type: "knowledge-graph-sublayer", label: "KnowledgeGraphSublayer" }, 7: { adapter: R3, type: "ogc-feature", label: "OGCFeatureLayer" }, 8: { adapter: ie, type: "oriented-imagery", label: "OrientedImageryLayer" }, 9: { adapter: ie, type: "parquet", label: "ParquetLayer" }, 10: { adapter: o3, type: "point-cloud", label: "PointCloudLayer" }, 11: { adapter: A2, type: "scene", label: "SceneLayer" }, 12: { adapter: c5, type: "stream", label: "StreamLayer" }, 13: { adapter: ie, type: "subtype-group", label: "SubtypeGroupLayer" }, 14: { adapter: ie, type: "subtype-sublayer", label: "SubtypeSublayer" }, 15: { adapter: ie, type: "wfs", label: "WFSLayer" } };
var u4 = [0, 1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
var m9 = [2, 3, 4, 7, 6, 8, 9, 12, 15];
function b4(e3) {
  return e3.map((e4) => n7[e4].label);
}
function s7(e3, a5 = u4, t2) {
  if (e3 instanceof p8) return e3;
  const y = L2(e3, a5);
  return y ? t2 ? new x({ layer: e3 }) : new y({ layer: e3 }) : null;
}
function L2(e3, a5 = u4) {
  let r4 = null;
  return a5.some((a6) => {
    const t2 = e3.type === n7[a6].type;
    return t2 && (r4 = n7[a6].adapter), t2;
  }), r4;
}

// node_modules/@arcgis/core/smartMapping/statistics/uniqueValues.js
async function u5(u6) {
  if (!u6?.layer || !u6.field && !u6.valueExpression) throw new s("unique-values:missing-parameters", "'layer' and 'field' or 'valueExpression' parameters are required");
  const p10 = u6.valueExpression || u6.sqlExpression, f3 = p10 && !u6.sqlExpression;
  if (p10) {
    if (f3) {
      if (!u6.view) throw new s("unique-values:missing-parameters", "View is required when 'valueExpression' is specified");
    } else if (!u6.valueExpression) throw new s("unique-values:missing-parameters", "'valueExpression' parameters are required");
  }
  u6.forBinning && i4(u6, "unique-values");
  const { layer: m10, ...d4 } = u6, v3 = [...u4, 5], w2 = u6.forBinning ? m9 : v3, c6 = s7(m10, w2, u6.forBinning);
  if (!c6) throw new s("unique-values:invalid-parameters", "'layer' must be one of these types: " + b4(w2).join(", "));
  const q4 = { layerAdapter: c6, ...d4 }, x2 = null != q4.signal ? { signal: q4.signal } : null;
  await c6.load(x2);
  const y = await w({ field: q4.field, field2: q4.field2, field3: q4.field3, valueExpression: q4.valueExpression }), E4 = T(c6, y, "unique-values:invalid-parameters");
  if (E4) throw E4;
  q4.filter && !q4.filter.spatialRelationship && (q4.filter.spatialRelationship = "intersects");
  const g4 = M2(q4.filter, "summary-statistics:invalid-parameters");
  if (g4) throw g4;
  return q4;
}
async function p9(e3) {
  const { layerAdapter: i6, ...s8 } = await u5(e3);
  return i6.uniqueValues(s8);
}
export {
  p9 as default
};
//# sourceMappingURL=uniqueValues-H2RDORR7.js.map
