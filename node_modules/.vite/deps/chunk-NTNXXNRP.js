import {
  d,
  i,
  t
} from "./chunk-YLAGKT2D.js";
import {
  P,
  y3 as y
} from "./chunk-PZ5RULLK.js";
import {
  f
} from "./chunk-5T3MJDSR.js";
import {
  C,
  N2 as N,
  c
} from "./chunk-NMQNUPE4.js";
import {
  m
} from "./chunk-ZIE53VIV.js";
import {
  s2 as s
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/geometry/support/geodesicUtils.js
function u(e) {
  if (!e) return null;
  const t2 = e.wkid;
  if (t2) return d[t2];
  const n = e.wkt2 ?? e.wkt;
  return n ? m2(n) : null;
}
function m2(e) {
  const t2 = t.exec(e);
  if (!t2 || 2 !== t2.length) return null;
  const n = t2[1].split(",");
  if (!n || n.length < 3) return null;
  const s2 = parseFloat(n[1]), i2 = parseFloat(n[2]);
  if (isNaN(s2) || isNaN(i2)) return null;
  return { a: s2, f: 0 === i2 ? 0 : 1 / i2 };
}
function d2(e) {
  const t2 = u(e);
  if (g(t2)) return t2;
  const n = t2.a * (1 - t2.f);
  return Object.assign(t2, { b: n, eSq: 1 - (n / t2.a) ** 2, radius: (2 * t2.a + n) / 3, densificationRatio: 1e4 / ((2 * t2.a + n) / 3) });
}
function g(e) {
  return null != e && "b" in e && "eSq" in e && "radius" in e;
}
function w(e, t2, n) {
  const { a: s2, eSq: i2 } = d2(n), r = Math.sqrt(i2), a = Math.sin(t2[1] * i), c2 = s2 * t2[0] * i;
  let h;
  if (i2 > 0) {
    h = s2 * ((1 - i2) * (a / (1 - i2 * (a * a)) - 1 / (2 * r) * Math.log((1 - r * a) / (1 + r * a)))) * 0.5;
  } else h = s2 * a;
  return e[0] = c2, e[1] = h, e;
}
function y2(e) {
  return c(e) && !!u(e);
}
function v(n, s2 = "square-meters") {
  if (n.some((e) => !y2(e.spatialReference))) throw new s("geodesic-areas:invalid-spatial-reference", "the input geometries spatial reference is not supported");
  const i2 = [];
  for (let e = 0; e < n.length; e++) {
    const t2 = n[e], s3 = t2.spatialReference, { radius: r2, densificationRatio: a2 } = d2(s3), o2 = r2 * a2;
    i2.push(z(t2, o2));
  }
  const r = [], a = [0, 0], o = [0, 0];
  for (let e = 0; e < i2.length; e++) {
    const { rings: n2, spatialReference: c2 } = i2[e];
    let h = 0;
    for (let e2 = 0; e2 < n2.length; e2++) {
      const t2 = n2[e2];
      w(a, t2[0], c2), w(o, t2[t2.length - 1], c2);
      let s3 = o[0] * a[1] - a[0] * o[1];
      for (let e3 = 0; e3 < t2.length - 1; e3++) w(a, t2[e3 + 1], c2), w(o, t2[e3], c2), s3 += o[0] * a[1] - a[0] * o[1];
      h += s3;
    }
    h = N(h, "square-meters", s2), r.push(h / -2);
  }
  return r;
}
function R(n, s2 = "meters") {
  if (!n) throw new s("geodesic-lengths:invalid-geometries", "the input geometries type is not supported");
  if (n.some((e) => !y2(e.spatialReference))) throw new s("geodesic-lengths:invalid-spatial-reference", "the input geometries spatial reference is not supported");
  const i2 = [];
  for (let e = 0; e < n.length; e++) {
    const r = n[e], { spatialReference: a } = r, o = "polyline" === r.type ? r.paths : r.rings;
    let c2 = 0;
    for (let e2 = 0; e2 < o.length; e2++) {
      const t2 = o[e2];
      let n2 = 0;
      for (let e3 = 1; e3 < t2.length; e3++) {
        const s3 = t2[e3 - 1][0], i3 = t2[e3][0], r2 = t2[e3 - 1][1], o2 = t2[e3][1];
        if (r2 !== o2 || s3 !== i3) {
          const e4 = new b();
          q(e4, [s3, r2], [i3, o2], a), n2 += e4.distance;
        }
      }
      c2 += n2;
    }
    c2 = N(c2, "meters", s2), i2.push(c2);
  }
  return i2;
}
function z(t2, s2) {
  if ("polyline" !== t2.type && "polygon" !== t2.type) throw new s("geodesic-densify:invalid-geometry", "the input geometry is neither polyline nor polygon");
  const { spatialReference: o } = t2;
  if (!y2(o)) throw new s("geodesic-densify:invalid-spatial-reference", "the input geometry spatial reference is not supported");
  const c2 = "polyline" === t2.type ? t2.paths : t2.rings, h = [], l = [0, 0], p = new b();
  for (const e of c2) {
    const t3 = [];
    h.push(t3), t3.push([e[0][0], e[0][1]]);
    let n, i2, r = e[0][0], a = e[0][1];
    for (let c3 = 0; c3 < e.length - 1; c3++) {
      if (n = e[c3 + 1][0], i2 = e[c3 + 1][1], r === n && a === i2) continue;
      const h2 = [r, a];
      q(p, [r, a], [n, i2], o);
      const { azimuth: f3, distance: u2 } = p, m3 = u2 / s2;
      if (m3 > 1) {
        for (let e2 = 1; e2 <= m3 - 1; e2++) {
          j(l, h2, f3, e2 * s2, o), t3.push(l.slice());
        }
        j(l, h2, f3, (u2 + Math.floor(m3 - 1) * s2) / 2, o), t3.push(l.slice());
      }
      j(l, h2, f3, u2, o), t3.push(l.slice()), r = l[0], a = l[1];
    }
  }
  const f2 = m(f, o);
  return "polyline" === t2.type ? new y({ paths: h, spatialReference: f2 }) : new P({ rings: h, spatialReference: f2 });
}
var b = class {
  constructor(e = 0, t2 = void 0, n = void 0) {
    this.distance = e, this.azimuth = t2, this.reverseAzimuth = n;
  }
};
function j(e, t2, n, s2, i2) {
  const r = t2[0], a = t2[1], c2 = r * i, h = a * i, l = (n ?? 0) * i, { a: p, b: f2, f: u2 } = d2(i2), m3 = Math.sin(l), g2 = Math.cos(l), M = (1 - u2) * Math.tan(h), w2 = 1 / Math.sqrt(1 + M * M), y3 = M * w2, v2 = Math.atan2(M, g2), R2 = w2 * m3, z2 = R2 * R2, b2 = 1 - z2, j2 = b2 * (p * p - f2 * f2) / (f2 * f2), q2 = 1 + j2 / 16384 * (4096 + j2 * (j2 * (320 - 175 * j2) - 768)), x = j2 / 1024 * (256 + j2 * (j2 * (74 - 47 * j2) - 128));
  let A, N3, S, P2 = s2 / (f2 * q2), k = 2 * Math.PI;
  for (; Math.abs(P2 - k) > 1e-12; ) {
    S = Math.cos(2 * v2 + P2), A = Math.sin(P2), N3 = Math.cos(P2);
    k = P2, P2 = s2 / (f2 * q2) + x * A * (S + x / 4 * (N3 * (2 * S * S - 1) - x / 6 * S * (4 * A * A - 3) * (4 * S * S - 3)));
  }
  const F = y3 * A - w2 * N3 * g2, U = Math.atan2(y3 * N3 + w2 * A * g2, (1 - u2) * Math.sqrt(z2 + F * F)), C2 = u2 / 16 * b2 * (4 + u2 * (4 - 3 * b2)), E = Math.atan2(A * m3, w2 * N3 - y3 * A * g2) - (1 - C2) * u2 * R2 * (P2 + C2 * A * (S + C2 * N3 * (2 * S * S - 1)));
  return e[0] = (c2 + E) / i, e[1] = U / i, e;
}
function q(e, t2, n, s2) {
  const i2 = t2[0] * i, r = t2[1] * i, a = n[0] * i, c2 = n[1] * i, { a: h, b: l, f: p, radius: f2 } = d2(s2), u2 = a - i2, m3 = Math.atan((1 - p) * Math.tan(r)), g2 = Math.atan((1 - p) * Math.tan(c2)), M = Math.sin(m3), w2 = Math.cos(m3), y3 = Math.sin(g2), v2 = Math.cos(g2);
  let R2, z2, b2, j2, q2, x, A, N3, S, P2, k = 1e3, F = u2;
  do {
    if (A = Math.sin(F), N3 = Math.cos(F), b2 = Math.sqrt(v2 * A * (v2 * A) + (w2 * y3 - M * v2 * N3) * (w2 * y3 - M * v2 * N3)), 0 === b2) return e.distance = 0, e.azimuth = void 0, e.reverseAzimuth = void 0, e;
    q2 = M * y3 + w2 * v2 * N3, x = Math.atan2(b2, q2), S = w2 * v2 * A / b2, z2 = 1 - S * S, j2 = q2 - 2 * M * y3 / z2, isNaN(j2) && (j2 = 0), P2 = p / 16 * z2 * (4 + p * (4 - 3 * z2)), R2 = F, F = u2 + (1 - P2) * p * S * (x + P2 * b2 * (j2 + P2 * q2 * (2 * j2 * j2 - 1)));
  } while (Math.abs(F - R2) > 1e-12 && --k > 0);
  if (0 === k) {
    const t3 = f2, n2 = Math.acos(Math.sin(r) * Math.sin(c2) + Math.cos(r) * Math.cos(c2) * Math.cos(a - i2)) * t3, s3 = a - i2, h2 = Math.sin(s3) * Math.cos(c2), l2 = Math.cos(r) * Math.sin(c2) - Math.sin(r) * Math.cos(c2) * Math.cos(s3), p2 = Math.atan2(h2, l2);
    return e.azimuth = p2 / i, e.distance = n2, e.reverseAzimuth = void 0, e;
  }
  const U = z2 * (h * h - l * l) / (l * l), C2 = U / 1024 * (256 + U * (U * (74 - 47 * U) - 128)), E = l * (1 + U / 16384 * (4096 + U * (U * (320 - 175 * U) - 768))) * (x - C2 * b2 * (j2 + C2 / 4 * (q2 * (2 * j2 * j2 - 1) - C2 / 6 * j2 * (4 * b2 * b2 - 3) * (4 * j2 * j2 - 3)))), G = Math.atan2(v2 * Math.sin(F), w2 * y3 - M * v2 * Math.cos(F)), I = Math.atan2(w2 * Math.sin(F), w2 * y3 * Math.cos(F) - M * v2);
  return e.azimuth = G / i, e.distance = E, e.reverseAzimuth = I / i, e;
}
function N2(e) {
  return y2(e) ? e : C(e) ? f.WGS84 : null;
}

export {
  y2 as y,
  v,
  R,
  b,
  j,
  q,
  N2 as N
};
//# sourceMappingURL=chunk-NTNXXNRP.js.map
