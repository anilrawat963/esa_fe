import {
  has
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/core/MemCache.js
var t = -3;
var s = t - 1;
var i = !!has("esri-tests-disable-gpu-memory-measurements");
var h = class {
  get size() {
    return this._size;
  }
  constructor(t2 = 10485760) {
    this._maxSize = t2, this._db = /* @__PURE__ */ new Map(), this._size = 0, this._hit = 0, this._miss = 0, this._users = /* @__PURE__ */ new Map(), this._sizeLimits = /* @__PURE__ */ new Map();
  }
  destroy() {
    this.clearAll(), this._sizeLimits.clear(), this._users.clear(), this._db = null;
  }
  register(t2) {
    this._users.set(t2.id.slice(0, -1), t2);
  }
  deregister(t2) {
    this.clear(t2), this._sizeLimits.delete(t2), this._users.delete(t2.id.slice(0, -1));
  }
  get maxSize() {
    return this._maxSize;
  }
  set maxSize(t2) {
    this._maxSize = Math.max(t2, -1), this._checkSize();
  }
  getSize(t2, s2) {
    const i2 = this._db.get(t2.id + s2);
    return i2?.size ?? 0;
  }
  put(e, h2, r2, o, n2) {
    h2 = e.id + h2;
    const a = this._db.get(h2);
    if (a && (this._size -= a.size, e.size -= a.size, this._db.delete(h2), a.entry !== r2 && this._notifyRemove(h2, a.entry, a.size, 0)), o > this._maxSize) return void this._notifyRemove(h2, r2, o, 0);
    if (void 0 === r2) return void console.warn("Refusing to cache undefined entry ");
    if (!o || o < 0) return i || console.warn(`Refusing to cache entry with size ${o} for key ${h2}`), void this._notifyRemove(h2, r2, 0, 0);
    const c = 1 + Math.max(n2, s) - t;
    this._db.set(h2, new _(r2, o, c)), this._size += o, e.size += o, this._checkSize();
  }
  updateSize(t2, s2) {
    s2 = t2.id + s2;
    const i2 = this._db.get(s2);
    if (!i2) return;
    this._size -= i2.size, t2.size -= i2.size;
    let e = i2.entry.usedMemory;
    for (; e > this._maxSize; ) {
      const t3 = this._notifyRemove(s2, i2.entry, e, 1);
      if (!(null != t3 && t3 > 0)) return void this._db.delete(s2);
      e = t3;
    }
    i2.size = e, this._size += e, t2.size += e, this._checkSize();
  }
  pop(t2, s2) {
    s2 = t2.id + s2;
    const i2 = this._db.get(s2);
    if (i2) return this._size -= i2.size, t2.size -= i2.size, this._db.delete(s2), ++this._hit, i2.entry;
    ++this._miss;
  }
  get(t2, s2) {
    s2 = t2.id + s2;
    const i2 = this._db.get(s2);
    if (void 0 !== i2) return this._db.delete(s2), i2.lives = i2.lifetime, this._db.set(s2, i2), ++this._hit, i2.entry;
    ++this._miss;
  }
  peek(t2, s2) {
    const i2 = this._db.get(t2.id + s2);
    return i2 ? ++this._hit : ++this._miss, i2?.entry;
  }
  get performanceInfo() {
    const s2 = { Size: Math.round(this._size / 1048576) + "/" + Math.round(this._maxSize / 1048576) + "MB", "Hit rate": Math.round(100 * this._getHitRate()) + "%", Entries: this._db.size.toString() }, i2 = {}, e = new Array();
    this._db.forEach((t2, s3) => {
      const h3 = t2.lifetime;
      e[h3] = (e[h3] || 0) + t2.size, this._users.forEach((e2) => {
        const { id: h4, name: r3 } = e2;
        if (s3.startsWith(h4)) {
          const s4 = i2[r3] || 0;
          i2[r3] = s4 + t2.size;
        }
      });
    });
    const h2 = {};
    this._users.forEach((t2) => {
      const s3 = t2.name;
      if ("hitRate" in t2 && "number" == typeof t2.hitRate && !isNaN(t2.hitRate) && t2.hitRate > 0) {
        const e2 = i2[s3] || 0;
        i2[s3] = e2, h2[s3] = Math.round(100 * t2.hitRate) + "%";
      } else h2[s3] = "0%";
    });
    const r2 = Object.keys(i2);
    r2.sort((t2, s3) => i2[s3] - i2[t2]), r2.forEach((t2) => s2[t2] = Math.round(i2[t2] / 2 ** 20) + "MB / " + h2[t2]);
    for (let o = e.length - 1; o >= 0; --o) {
      const i3 = e[o];
      i3 && (s2["Priority " + (o + t - 1)] = Math.round(i3 / this._size * 100) + "%");
    }
    return s2;
  }
  resetStats() {
    this._hit = this._miss = 0, this._users.forEach((t2) => t2.resetHitRate());
  }
  clear(t2) {
    const s2 = t2.id;
    this._db.forEach((t3, i2) => {
      i2.startsWith(s2) && (this._size -= t3.size, this._db.delete(i2), this._notifyRemove(i2, t3.entry, t3.size, 0));
    }), t2.size = 0;
  }
  clearAll() {
    this._db.forEach((t2, s2) => this._notifyRemove(s2, t2.entry, t2.size, 0)), this._users.forEach((t2) => t2.size = 0), this._size = 0, this._db.clear();
  }
  *values(t2) {
    for (const [s2, i2] of this._db) s2.startsWith(t2.id) && (yield i2.entry);
  }
  _getHitRate() {
    return this._hit / (this._hit + this._miss);
  }
  _notifyRemove(t2, s2, i2, e) {
    const h2 = this._users.get(t2.split(n)[0])?.removeFunc, r2 = h2?.(s2, e, i2);
    return "number" == typeof r2 ? r2 : null;
  }
  _checkSize() {
    this._sizeLimits.forEach((t2, s2) => this._checkSizeLimits(t2, s2)), this._checkSizeLimits(this.maxSize);
  }
  setMaxSize(t2, s2) {
    null == s2 || s2 <= 0 ? this._sizeLimits.delete(t2) : this._sizeLimits.set(t2, s2);
  }
  _checkSizeLimits(t2, s2) {
    const i2 = s2 ?? this;
    if (i2.size <= t2) return;
    const e = s2?.id;
    let h2 = true;
    for (; h2; ) {
      h2 = false;
      for (const [r2, o] of this._db) if (0 === o.lifetime && (!e || r2.startsWith(e))) {
        const e2 = s2 ?? this._users.get(r2.split(n)[0]);
        if (this._purgeItem(r2, o, e2), i2.size <= 0.9 * t2) return;
        h2 ||= this._db.has(r2);
      }
    }
    for (const [r2, o] of this._db) if (!e || r2.startsWith(e)) {
      const e2 = s2 ?? this._users.get(r2.split(n)[0]);
      if (this._purgeItem(r2, o, e2), i2.size <= 0.9 * t2) return;
    }
  }
  _purgeItem(t2, s2, i2) {
    if (this._db.delete(t2), s2.lives <= 1) {
      this._size -= s2.size, i2 && (i2.size -= s2.size);
      const e = this._notifyRemove(t2, s2.entry, s2.size, 1);
      null != e && e > 0 && (this._size += e, i2 && (i2.size += e), s2.lives = s2.lifetime, s2.size = e, this._db.set(t2, s2));
    } else --s2.lives, this._db.set(t2, s2);
  }
};
var r = new h(0);
var _ = class {
  constructor(t2, s2, i2) {
    this.entry = t2, this.size = s2, this.lifetime = i2, this.lives = i2;
  }
};
var n = ":";

export {
  t,
  h
};
//# sourceMappingURL=chunk-M5SP6ZBM.js.map
