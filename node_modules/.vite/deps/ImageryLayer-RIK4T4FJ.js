import {
  c as c4,
  f as f8,
  o as o5,
  p as p6
} from "./chunk-6INX4FGX.js";
import {
  B as B2,
  E,
  N,
  W,
  ae,
  d as d4,
  h,
  i2 as i7,
  j as j3,
  l as l10,
  p as p4,
  p2 as p5,
  q as q2,
  u as u4,
  y as y2
} from "./chunk-ETHRUKGL.js";
import {
  D,
  b as b4,
  f as f7,
  g as g2,
  p as p3
} from "./chunk-BTNEC6LS.js";
import "./chunk-BTFBYI67.js";
import "./chunk-D3G5WIRR.js";
import "./chunk-Q3JOE7TC.js";
import "./chunk-BJUALH6B.js";
import {
  i as i5
} from "./chunk-S34IG7TQ.js";
import {
  $,
  V as V2,
  a as a5,
  b as b2,
  c as c2,
  d as d2,
  f as f6,
  i as i6,
  m as m6,
  n as n4,
  o as o4,
  p as p2,
  v as v2
} from "./chunk-EQUB4K44.js";
import {
  $ as $2,
  R as R2,
  j as j2
} from "./chunk-GD72EK2J.js";
import {
  t as t2
} from "./chunk-TG6K2MFM.js";
import {
  B,
  G2 as G,
  L as L2,
  O,
  P as P3,
  R,
  a as a4,
  i as i4,
  l as l7,
  m as m5,
  n as n2,
  n4 as n3,
  s as s9
} from "./chunk-TNGDEFWZ.js";
import {
  l2 as l8,
  u as u3
} from "./chunk-NQDCX3PB.js";
import "./chunk-QW7RJMQR.js";
import {
  c2 as c,
  u as u2
} from "./chunk-CJAJ4FML.js";
import {
  i as i3,
  s as s7
} from "./chunk-TF4EQP5K.js";
import {
  s as s8
} from "./chunk-ZUQ2O3KU.js";
import {
  t as t3
} from "./chunk-JVMNF6GR.js";
import {
  l as l5
} from "./chunk-CJZPTLIZ.js";
import {
  l as l6
} from "./chunk-JSH3APTG.js";
import "./chunk-WQT2KLDB.js";
import {
  d
} from "./chunk-UVDECGZC.js";
import {
  o as o3,
  s as s5
} from "./chunk-VKFTCFFM.js";
import {
  s as s6
} from "./chunk-ZETARPSI.js";
import {
  f as f3
} from "./chunk-TCDV4P3G.js";
import {
  b2 as b3,
  d as d3,
  l as l9,
  s as s10,
  w,
  y
} from "./chunk-CZOYDK6P.js";
import "./chunk-TMUM75KQ.js";
import "./chunk-RXH2WNPA.js";
import {
  V
} from "./chunk-TWU3GKHX.js";
import "./chunk-BGIBV6LL.js";
import "./chunk-UQXJMFRI.js";
import "./chunk-DY7N5RAZ.js";
import {
  j
} from "./chunk-6TCXGIIN.js";
import {
  l as l2
} from "./chunk-NP2TBOXH.js";
import "./chunk-FHCV4NTV.js";
import {
  g
} from "./chunk-HCTBVF3W.js";
import "./chunk-XTEXJOLG.js";
import "./chunk-YE4E5JCT.js";
import "./chunk-SXZO7ULH.js";
import "./chunk-H34D76ZQ.js";
import "./chunk-QTRET3PG.js";
import "./chunk-FMOL5XMB.js";
import "./chunk-VNSHGTPN.js";
import "./chunk-OEBAFVQK.js";
import "./chunk-QNW4D2V2.js";
import "./chunk-XAI6T5FU.js";
import "./chunk-QNDHLVDC.js";
import "./chunk-ZT4KW2M5.js";
import "./chunk-FHQNDU7E.js";
import "./chunk-IOJ4QFRL.js";
import "./chunk-EK7HOTRR.js";
import "./chunk-IXFJYDA2.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import "./chunk-233ALXRM.js";
import "./chunk-EKZRA6TO.js";
import "./chunk-M5SP6ZBM.js";
import {
  Z
} from "./chunk-2HGIYEIL.js";
import "./chunk-OTCNIJ2H.js";
import "./chunk-JGA5YJWL.js";
import "./chunk-GCI4MA3M.js";
import "./chunk-SJ2OBYX2.js";
import "./chunk-Z6VKIQV2.js";
import "./chunk-ZCI5A4FF.js";
import "./chunk-2D47RURG.js";
import {
  b
} from "./chunk-647DAMHU.js";
import "./chunk-O6G3PPOK.js";
import {
  s as s4
} from "./chunk-ZKNZTIAS.js";
import "./chunk-OJMISN3F.js";
import "./chunk-EFV6H5NA.js";
import {
  P as P2
} from "./chunk-6VL5D5UP.js";
import "./chunk-6QHY54HZ.js";
import "./chunk-GXJJY3ND.js";
import "./chunk-5ONGWFJ3.js";
import {
  f as f5,
  s as s3,
  u
} from "./chunk-PLNHHGHL.js";
import "./chunk-BBYMM7CM.js";
import {
  m as m3
} from "./chunk-QZQPB5XR.js";
import "./chunk-AQFRVV3U.js";
import {
  p
} from "./chunk-PEL3D3ZN.js";
import "./chunk-Q5KWD3VQ.js";
import "./chunk-BUQC3CLV.js";
import {
  t
} from "./chunk-W5S3VUFT.js";
import "./chunk-7YH7T6CS.js";
import {
  c as c3
} from "./chunk-3T4IXPP4.js";
import "./chunk-XTZAIV4X.js";
import "./chunk-63LDVRFI.js";
import {
  _ as _2
} from "./chunk-C3FRY5U4.js";
import {
  q
} from "./chunk-JNJX34GB.js";
import "./chunk-3STJRSDT.js";
import "./chunk-67Q6KVC6.js";
import "./chunk-23NJHA5Q.js";
import "./chunk-4LA6K4VI.js";
import "./chunk-KEZCWFAR.js";
import "./chunk-JZUJ34RR.js";
import {
  l as l4
} from "./chunk-PMGS7UDU.js";
import "./chunk-3GHCGAH2.js";
import "./chunk-HWUOAPTX.js";
import "./chunk-QHCKOBU7.js";
import "./chunk-K2OZ6WVC.js";
import "./chunk-MC6NAKKX.js";
import "./chunk-TF6255HN.js";
import {
  f as f4,
  v
} from "./chunk-GD4FJL3C.js";
import "./chunk-C5OQVQZF.js";
import "./chunk-F7DKSAOI.js";
import "./chunk-4SOQWNPG.js";
import "./chunk-LTULADK2.js";
import "./chunk-35ST7YRB.js";
import "./chunk-EDA5QFHZ.js";
import "./chunk-CNYNCKEV.js";
import "./chunk-XL5QPCXN.js";
import "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-W75DBJD7.js";
import "./chunk-6KDQMJAI.js";
import "./chunk-UDHS2MGH.js";
import "./chunk-ENINOZUZ.js";
import {
  b as b5
} from "./chunk-P6IKJIMO.js";
import {
  m as m4
} from "./chunk-MHV23XAQ.js";
import "./chunk-V2X4OKYI.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import "./chunk-MA3QDRC3.js";
import "./chunk-W6J7XCPU.js";
import "./chunk-ONXWBTTM.js";
import {
  l as l3
} from "./chunk-T7F6Q6JJ.js";
import "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-7P2ANHQ3.js";
import "./chunk-XCKT47LJ.js";
import "./chunk-3FUHCAX3.js";
import {
  P
} from "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import {
  z
} from "./chunk-H74Q4SYB.js";
import {
  l
} from "./chunk-2OFHDVO5.js";
import "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-5UPBUJPC.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-CCQFL76O.js";
import "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import {
  r as r2
} from "./chunk-7H3U4IJR.js";
import "./chunk-SMWUT52Z.js";
import {
  _
} from "./chunk-AXZMNHTN.js";
import {
  f as f2
} from "./chunk-5T3MJDSR.js";
import {
  A,
  ge,
  pe,
  we
} from "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import {
  H2 as H,
  I
} from "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import {
  o as o2
} from "./chunk-XWE6BM2U.js";
import {
  r
} from "./chunk-SOIZOFSB.js";
import {
  n
} from "./chunk-XXLHAM2M.js";
import {
  m as m2,
  s2
} from "./chunk-5EI5H4QX.js";
import {
  a as a2,
  a2 as a3,
  i as i2,
  m,
  x
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import {
  o
} from "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import {
  L,
  f2 as f
} from "./chunk-GNMPGHLQ.js";
import {
  a,
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/graphic/ImageryGraphicOrigin.js
var e;
var s11 = class extends s5 {
  get [(e = i5, o3)]() {
    return this.layer;
  }
  constructor(r3) {
    super(), this[e] = true, this.type = "imagery", this.layer = r3;
  }
  get id() {
    return this.layer.id;
  }
};

// node_modules/@arcgis/core/layers/support/rasterFunctions/rasterFunctionSchema.js
var e2 = { StretchFunction: { arguments: { ComputeGamma: { isDataset: false, isPublic: false, name: "ComputeGamma", type: "RasterFunctionVariable", value: false }, DRA: { isDataset: false, isPublic: false, name: "DRA", type: "RasterFunctionVariable", value: false }, EstimateStatsHistogram: { isDataset: false, isPublic: false, name: "EstimateStatsHistogram", type: "RasterFunctionVariable", value: false }, Gamma: { displayName: "Gamma", isDataset: false, isPublic: false, name: "Gamma", type: "RasterFunctionVariable" }, Histograms: { isDataset: false, isPublic: false, name: "Histograms", type: "RasterFunctionVariable" }, Max: { isDataset: false, isPublic: false, name: "Max", type: "RasterFunctionVariable", value: 255 }, MaxPercent: { isDataset: false, isPublic: false, name: "MaxPercent", type: "RasterFunctionVariable", value: 0.5 }, Min: { isDataset: false, isPublic: false, name: "Min", type: "RasterFunctionVariable", value: 0 }, MinPercent: { isDataset: false, isPublic: false, name: "MinPercent", type: "RasterFunctionVariable", value: 0.25 }, NumberOfStandardDeviations: { isDataset: false, isPublic: false, name: "NumberOfStandardDeviation", type: "RasterFunctionVariable", value: 2 }, Raster: { isDataset: true, isPublic: false, name: "Raster", type: "RasterFunctionVariable" }, SigmoidStrengthLevel: { isDataset: false, isPublic: false, name: "SigmoidStrengthLevel", type: "RasterFunctionVariable", value: 2 }, Statistics: { isDataset: false, isPublic: false, name: "Statistics", type: "RasterFunctionVariable" }, StretchType: { isDataset: false, isPublic: false, name: "StretchType", type: "RasterFunctionVariable", value: 0 }, type: "StretchFunctionArguments", UseGamma: { isDataset: false, isPublic: false, name: "UseGamma", type: "RasterFunctionVariable", value: false } }, description: "Enhances an image by adjusting the range of values displayed. This does not alter the underlying pixel values. If a pixel has a value outside of the specified range, it will appear as either the minimum or maximum value.", function: { description: "Enhances an image by adjusting the range of values displayed. This does not alter the underlying pixel values. If a pixel has a value outside of the specified range, it will appear as either the minimum or maximum value.", name: "Stretch", pixelType: "UNKNOWN", type: "StretchFunction" }, functionType: 0, name: "Stretch", thumbnail: "" }, RemapFunction: { name: "Remap", description: "Changes pixel values by assigning new values to ranges of pixel values or using an external table.", function: { type: "RemapFunction", pixelType: "UNKNOWN", name: "Remap", description: "Changes pixel values by assigning new values to ranges of pixel values or using an external table." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, UseTable: { name: "UseTable", isPublic: false, isDataset: false, value: false, type: "RasterFunctionVariable" }, InputRanges: { name: "InputRanges", isPublic: false, isDataset: false, type: "RasterFunctionVariable", displayName: "Input Ranges" }, OutputValues: { name: "OutputValues", isPublic: false, isDataset: false, type: "RasterFunctionVariable", displayName: "Output Values" }, NoDataRanges: { name: "NoDataRanges", isPublic: false, isDataset: false, type: "RasterFunctionVariable", displayName: "NoData Ranges" }, Table: { name: "Table", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, InputField: { name: "InputField", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, OutputField: { name: "OutputField", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, InputMaxField: { name: "InputMaxField", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, RemapTableType: { name: "RemapTableType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, AllowUnmatched: { name: "AllowUnmatched", isPublic: false, isDataset: false, value: true, type: "RasterFunctionVariable" }, type: "RemapFunctionArguments" }, functionType: 0, thumbnail: "" }, ColormapFunction: { name: "Colormap", description: "Changes pixel values to display the raster data as either a grayscale or a red, green, blue (RGB) image, based on a colormap or a color ramp.", function: { type: "ColormapFunction", pixelType: "UNKNOWN", name: "Colormap", description: "Changes pixel values to display the raster data as either a grayscale or a red, green, blue (RGB) image, based on a colormap or a color ramp." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, ColorSchemeType: { name: "ColorSchemeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, Colormap: { name: "Colormap", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, ColormapName: { name: "ColormapName", isPublic: false, isDataset: false, value: "Gray", type: "RasterFunctionVariable" }, ColorRamp: { name: "ColorRamp", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, type: "ColormapFunctionArguments" }, functionType: 0, thumbnail: "" }, ShadedReliefFunction: { name: "Shaded Relief", description: "Creates a multiband, color coded, 3D representation of the surface, with the sun's relative position taken into account for shading the image.", function: { type: "ShadedReliefFunction", pixelType: "UNKNOWN", name: "Shaded Relief", description: "Creates a multiband, color coded, 3D representation of the surface, with the sun's relative position taken into account for shading the image." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, ColorSchemeType: { name: "ColorSchemeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, ColorRamp: { name: "ColorRamp", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, HillshadeType: { name: "HillshadeType", isPublic: false, isDataset: false, value: 0, type: "RasterFunctionVariable" }, Colormap: { name: "Colormap", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, Azimuth: { name: "Azimuth", isPublic: false, isDataset: false, value: 315, type: "RasterFunctionVariable" }, Altitude: { name: "Altitude", isPublic: false, isDataset: false, value: 45, type: "RasterFunctionVariable" }, SlopeType: { name: "SlopeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, ZFactor: { name: "ZFactor", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, PSPower: { name: "PSPower", isPublic: false, isDataset: false, value: 0.664, type: "RasterFunctionVariable" }, PSZFactor: { name: "PSZFactor", isPublic: false, isDataset: false, value: 0.024, type: "RasterFunctionVariable" }, RemoveEdgeEffect: { name: "RemoveEdgeEffect", isPublic: false, isDataset: false, value: false, type: "RasterFunctionVariable" }, type: "ShadedReliefFunctionArguments" }, functionType: 0, thumbnail: "" }, HillshadeFunction: { name: "Hillshade", description: "Creates a 3D representation of the surface, with the sun's relative position taken into account for shading the image", function: { type: "HillshadeFunction", pixelType: "UNKNOWN", name: "Hillshade", description: "Creates a 3D representation of the surface, with the sun's relative position taken into account for shading the image" }, arguments: { DEM: { name: "DEM", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, HillshadeType: { name: "HillshadeType", isPublic: false, isDataset: false, value: 0, type: "RasterFunctionVariable" }, Azimuth: { name: "Azimuth", isPublic: false, isDataset: false, value: 315, type: "RasterFunctionVariable" }, Altitude: { name: "Altitude", isPublic: false, isDataset: false, value: 45, type: "RasterFunctionVariable" }, SlopeType: { name: "SlopeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, ZFactor: { name: "ZFactor", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, PSPower: { name: "PSPower", isPublic: false, isDataset: false, value: 0.664, type: "RasterFunctionVariable" }, PSZFactor: { name: "PSZFactor", isPublic: false, isDataset: false, value: 0.024, type: "RasterFunctionVariable" }, RemoveEdgeEffect: { name: "RemoveEdgeEffect", isPublic: false, isDataset: false, value: false, type: "RasterFunctionVariable" }, type: "HillshadeFunctionArguments" }, functionType: 0, thumbnail: "" }, ResampleFunction: { name: "Resample", description: "Changes the cell size of a raster.", function: { type: "ResampleFunction", pixelType: "UNKNOWN", name: "Resample", description: "Changes the cell size of a raster." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, ResamplingType: { name: "ResamplingType", isPublic: false, isDataset: false, value: 0, type: "RasterFunctionVariable" }, InputCellSize: { name: "InputCellsize", isPublic: false, isDataset: false, value: { x: 0, y: 0 }, type: "RasterFunctionVariable" }, OutputCellSize: { name: "OutputCellsize", isPublic: false, isDataset: false, value: { x: 0, y: 0 }, type: "RasterFunctionVariable" }, type: "ResampleFunctionArguments" }, functionType: 0, thumbnail: "" } };

// node_modules/@arcgis/core/layers/support/imageryRendererUtils.js
var c5 = /* @__PURE__ */ new Set(["u1", "u2", "u4", "u8", "s8", "u16", "s16"]);
var m7 = { simple_scalar: "Simple Scalar", wind_barb: "Wind Barb", single_arrow: "Single Arrow", beaufort_kn: "Beaufort Wind (Knots)", beaufort_m: "Beaufort Wind (MetersPerSecond)", ocean_current_m: "Ocean Current (MetersPerSecond)", ocean_current_kn: "Ocean Current (Knots)" };
var f9 = /* @__PURE__ */ new Set(["raster-stretch", "unique-value", "class-breaks", "raster-shaded-relief", "vector-field", "raster-colormap"]);
function p7(e5) {
  return f9.has(e5.type);
}
function g3(n11, t6) {
  if (!n11 || !t6) return a(n11 || t6);
  const r3 = a(n11);
  if (r3.functionDefinition && t6.rasterFunctionDefinition) {
    const e5 = t6.rasterFunctionDefinition;
    (e5.thumbnail || e5.thumbnailEx) && (e5.thumbnail = e5.thumbnailEx = void 0), d5(r3.functionDefinition.arguments, t6), r3.rasterFunctionDefinition = r3.functionDefinition.toJSON();
  } else if ("none" !== t6.functionName?.toLowerCase()) {
    b6(r3.functionArguments).Raster = t6;
  }
  return r3;
}
function d5(e5, n11) {
  for (const t6 in e5) "raster" === t6.toLowerCase() && ("RasterFunctionVariable" === e5[t6].type ? (e5[t6] = n11.rasterFunctionDefinition, e5[t6].type = "RasterFunctionTemplate") : "RasterFunctionTemplate" === e5[t6].type && d5(e5[t6].arguments, n11));
}
function h2(n11) {
  const t6 = a(e2[n11.functionName + "Function"]), o6 = n11.functionArguments;
  for (const e5 in o6) "raster" === e5.toLowerCase() ? (t6.arguments[e5] = h2(o6[e5]), t6.arguments[e5].type = "RasterFunctionTemplate") : "colormap" === e5.toLowerCase() ? (t6.arguments[e5].value = V3(o6[e5]), t6.arguments.ColorSchemeType.value = 0) : t6.arguments[e5].value = o6[e5];
  return t6;
}
function y3(e5, n11) {
  switch (n11 = n11 || {}, e5.type) {
    case "raster-stretch":
      return S(e5, n11);
    case "class-breaks":
      return w2(e5, n11);
    case "unique-value":
      return F(e5, n11);
    case "raster-colormap":
      return N2(e5, n11);
    case "vector-field":
      return T(e5, n11);
    case "raster-shaded-relief":
      return v3(e5, n11);
    case "flow":
      throw new Error("Unsupported rendering rule.");
  }
}
function b6(e5) {
  const n11 = e5?.Raster ?? e5?.raster;
  return n11 && "esri.layers.support.RasterFunction" === n11.declaredClass ? b6(n11.functionArguments) : e5;
}
var R3 = { none: 0, standardDeviation: 3, histogramEqualization: 4, minMax: 5, percentClip: 6, sigmoid: 9 };
function T(e5, t6) {
  const r3 = new N();
  r3.functionName = "VectorFieldRenderer";
  const { dataType: o6, bandNames: a10 } = t6, i12 = "vector-uv" === o6;
  let s13, u9;
  if (a10 && 2 === a10.length) {
    const e6 = a10.map((e7) => e7.toLowerCase());
    s13 = e6.indexOf("magnitude"), u9 = e6.indexOf("direction");
  }
  -1 !== s13 && null !== s13 || (s13 = 0, u9 = 1);
  const c13 = "arithmetic" === e5.rotationType ? 1 : 2, f11 = "flow-from" === e5.flowRepresentation ? 0 : 1, p19 = e5.visualVariables ? e5.visualVariables.find((e6) => "Magnitude" === e6.field) : new V(), g4 = { magnitudeBandID: s13, directionBandID: u9, isUVComponents: i12, referenceSystem: c13, massFlowAngleRepresentation: f11, symbolTileSize: 50, symbolTileSizeUnits: 100, calculationMethod: "Vector Average", symbologyName: m7[e5.style.toLowerCase().replace("-", "_")], minimumMagnitude: p19.minDataValue, maximumMagnitude: p19.maxDataValue, minimumSymbolSize: p19.minSize, maximumSymbolSize: p19.maxSize };
  r3.functionArguments = g4;
  const d8 = h2(r3);
  return t6.convertToRFT ? N.fromJSON({ rasterFunctionDefinition: d8 }) : r3;
}
function v3(e5, t6) {
  const r3 = t6.convertToRFT;
  if ("elevation" !== t6.dataType && ("generic" !== t6.dataType || 1 !== t6.bandCount || "s16" !== t6.pixelType && "s32" !== t6.pixelType && "f32" !== t6.pixelType && "f64" !== t6.pixelType)) return new N();
  const i12 = new N();
  i12.functionName = "Hillshade";
  const s13 = "traditional" === e5.hillshadeType ? 0 : 1, u9 = "none" === e5.scalingType ? 1 : 3, l16 = { HillshadeType: s13, SlopeType: u9, ZFactor: e5.zFactor };
  return 0 === s13 && (l16.Azimuth = e5.azimuth, l16.Altitude = e5.altitude), 3 === u9 && (l16.PSPower = e5.pixelSizePower, l16.PSZFactor = e5.pixelSizeFactor), i12.functionArguments = l16, i12.variableName = "Raster", e5.colorRamp && (i12.functionName = "ShadedRelief", r3 ? l16.ColorRamp = G(e5.colorRamp) : l16.Colormap = B(e5.colorRamp)), r3 ? new N({ rasterFunctionDefinition: h2(i12) }) : i12;
}
function S(e5, t6) {
  const r3 = t6.convertToRFT, s13 = new N();
  s13.functionName = "Stretch";
  const l16 = R3[n3.toJSON(e5.stretchType)], c13 = "u8", m11 = e5.customStatistics?.map((e6) => [e6.min, e6.max, e6.avg ?? 0, e6.stddev ?? 1]), f11 = { StretchType: l16, Statistics: m11, DRA: e5.dynamicRangeAdjustment, UseGamma: e5.useGamma, Gamma: e5.gamma, ComputeGamma: e5.computeGamma };
  if (null != e5.outputMin && (f11.Min = e5.outputMin), null != e5.outputMax && (f11.Max = e5.outputMax), l16 === R3.standardDeviation ? (f11.NumberOfStandardDeviations = e5.numberOfStandardDeviations, s13.outputPixelType = c13) : l16 === R3.percentClip ? (f11.MinPercent = e5.minPercent, f11.MaxPercent = e5.maxPercent, s13.outputPixelType = c13) : l16 === R3.minMax ? s13.outputPixelType = c13 : l16 === R3.sigmoid && (f11.SigmoidStrengthLevel = e5.sigmoidStrengthLevel), s13.functionArguments = f11, s13.variableName = "Raster", e5.colorRamp) {
    const u9 = e5.colorRamp, l17 = new N();
    if (r3) l17.functionArguments = { ColorRamp: G(u9) };
    else {
      const n11 = s9(u9, true);
      if (n11) l17.functionArguments = { colorRampName: n11 };
      else if (!t6.convertColorRampToColormap || "algorithmic" !== u9.type && "multipart" !== u9.type) {
        const n12 = e5.colorRamp.toJSON();
        "algorithmic" === n12.type ? n12.algorithm = n12.algorithm || "esriCIELabAlgorithm" : "multipart" === n12.type && n12.colorRamps?.length && n12.colorRamps.forEach((e6) => e6.algorithm = e6.algorithm || "esriCIELabAlgorithm"), l17.functionArguments = { colorRamp: n12 };
      } else l17.functionArguments = { Colormap: B(u9) };
    }
    return l17.variableName = "Raster", l17.functionName = "Colormap", l17.functionArguments.Raster = s13, r3 ? new N({ rasterFunctionDefinition: h2(l17) }) : l17;
  }
  return r3 ? new N({ rasterFunctionDefinition: h2(s13) }) : s13;
}
function w2(e5, t6) {
  const r3 = [], o6 = [], a10 = [], i12 = [], s13 = 1e-4, { pixelType: u9, rasterAttributeTable: l16 } = t6, c13 = null == l16 ? null : l16.features, m11 = C(l16);
  if (m11 && c13 && Array.isArray(c13) && e5.classBreakInfos) {
    e5.classBreakInfos.forEach((n11, t7) => {
      const r5 = n11.symbol?.color;
      let o8;
      r5?.a && null != n11.minValue && null != n11.maxValue && c13.forEach((a11) => {
        null != n11.minValue && null != n11.maxValue && (o8 = a11.attributes[e5.field], (o8 >= n11.minValue && o8 < n11.maxValue || t7 === e5.classBreakInfos.length - 1 && o8 >= n11.minValue) && i12.push([a11.attributes[m11], r5.r, r5.g, r5.b]));
      });
    });
    const r4 = u9 ? x2(i12, u9) : i12, o7 = new N();
    return o7.functionName = "Colormap", o7.functionArguments = {}, o7.functionArguments.Colormap = r4, o7.variableName = "Raster", t6.convertToRFT ? new N({ rasterFunctionDefinition: h2(o7) }) : o7;
  }
  e5.classBreakInfos.forEach((e6, n11) => {
    if (null == e6.minValue || null == e6.maxValue) return;
    const t7 = e6.symbol && e6.symbol.color;
    t7?.a ? (0 === n11 ? r3.push(e6.minValue, e6.maxValue + s13) : r3.push(e6.minValue + s13, e6.maxValue + s13), o6.push(n11), i12.push([n11, t7.r, t7.g, t7.b])) : a10.push(e6.minValue, e6.maxValue);
  });
  const f11 = u9 ? x2(i12, u9) : i12, p19 = new N();
  p19.functionName = "Remap", p19.functionArguments = { InputRanges: r3, OutputValues: o6, NoDataRanges: a10 }, p19.variableName = "Raster";
  const g4 = new N();
  return g4.functionName = "Colormap", g4.functionArguments = { Colormap: f11, Raster: p19 }, t6.convertToRFT ? new N({ rasterFunctionDefinition: h2(g4) }) : g4;
}
function x2(e5, n11) {
  const r3 = c5.has(n11) ? u2(n11) : null;
  return r3 && e5.push([Math.floor(r3[0] - 1), 0, 0, 0], [Math.ceil(r3[1] + 1), 0, 0, 0]), e5;
}
function C(e5) {
  if (null == e5) return;
  const { fields: n11 } = e5, t6 = n11?.find((e6) => e6?.name && "value" === e6.name.toLowerCase());
  return t6?.name;
}
function F(e5, t6) {
  const r3 = [], { pixelType: o6, rasterAttributeTable: a10 } = t6, i12 = null == a10 ? null : a10.features, s13 = C(a10), u9 = e5.defaultSymbol?.color?.toRgb(), l16 = e5.uniqueValueInfos;
  if (l16) if (i12) {
    if (s13) {
      const n11 = /* @__PURE__ */ new Map();
      l16.forEach((e6) => {
        const t8 = e6.value, r4 = A2(e6);
        null != t8 && r4?.a && n11.set(String(t8), r4.toRgb());
      });
      const t7 = e5.field;
      t7 && i12.forEach(({ attributes: e6 }) => {
        const o7 = String(e6[t7]), a11 = e6[s13], i13 = n11.get(o7);
        i13 ? r3.push([a11, ...i13]) : u9 && r3.push([a11, ...u9]);
      });
    }
  } else for (let n11 = 0; n11 < l16.length; n11++) {
    const e6 = l16[n11], t7 = A2(e6), o7 = +e6.value;
    if (t7?.a) {
      if (isNaN(o7)) return null;
      r3.push([o7, t7.r, t7.g, t7.b]);
    }
  }
  const c13 = o6 ? x2(r3, o6) : r3, m11 = new N();
  return m11.functionName = "Colormap", m11.functionArguments = {}, m11.functionArguments.Colormap = c13, m11.variableName = "Raster", t6.convertToRFT ? new N({ rasterFunctionDefinition: h2(m11) }) : m11;
}
function A2(e5) {
  return "polygon-3d" === e5.symbol?.type ? e5.symbol.symbolLayers?.find((e6) => "fill" === e6.type)?.material?.color : e5.symbol?.color;
}
function N2(e5, t6) {
  const r3 = e5.extractColormap();
  if (!r3 || 0 === r3.length) return null;
  const { pixelType: o6 } = t6, a10 = o6 ? x2(r3, o6) : r3, i12 = new N();
  return i12.functionName = "Colormap", i12.functionArguments = {}, i12.functionArguments.Colormap = a10, t6.convertToRFT ? new N({ rasterFunctionDefinition: h2(i12) }) : i12;
}
function V3(e5) {
  const n11 = [], t6 = [];
  return e5.forEach((e6) => {
    n11.push(e6[0]), t6.push(P3([...e6.slice(1), 255]));
  }), { type: "RasterColormap", values: n11, colors: t6 };
}

// node_modules/@arcgis/core/layers/support/ExportImageServiceParameters.js
var d6 = class extends n {
  constructor() {
    super(...arguments), this.layer = null, this.requestRawData = false, this.compression = void 0, this.lercVersion = 2;
  }
  get adjustAspectRatio() {
    return this.layer.adjustAspectRatio;
  }
  writeAdjustAspectRatio(e5, t6, r3) {
    this.layer.version < 10.3 || (t6[r3] = e5);
  }
  get bandIds() {
    return this.layer.bandIds;
  }
  get compressionQuality() {
    return this.layer.compressionQuality;
  }
  writeCompressionQuality(e5, t6, r3) {
    this.format && this.format.toLowerCase().includes("jpg") && null != e5 && (t6[r3] = e5);
  }
  get compressionTolerance() {
    return this.layer.compressionTolerance;
  }
  writeCompressionTolerance(e5, t6, r3) {
    "lerc" === this.format && null != e5 && (t6[r3] = e5);
  }
  get format() {
    return this.requestRawData || "vector-field" === this.layer.renderer?.type ? "lerc" : this.layer.format;
  }
  get interpolation() {
    return this.layer.interpolation;
  }
  get noData() {
    return this.layer.noData;
  }
  get noDataInterpretation() {
    return this.layer.noDataInterpretation;
  }
  get pixelType() {
    const { layer: e5 } = this;
    return e5.pixelType !== e5.serviceRasterInfo.pixelType ? e5.pixelType : void 0;
  }
  writeLercVersion(e5, t6, r3) {
    "lerc" === this.format && this.layer.version >= 10.5 && (t6[r3] = e5);
  }
  get version() {
    const e5 = this.layer;
    return e5.commitProperty("bandIds"), e5.commitProperty("format"), e5.commitProperty("compressionQuality"), e5.commitProperty("compressionTolerance"), e5.commitProperty("interpolation"), e5.commitProperty("noData"), e5.commitProperty("noDataInterpretation"), e5.commitProperty("mosaicRule"), e5.commitProperty("rasterFunction"), e5.commitProperty("adjustAspectRatio"), e5.commitProperty("pixelFilter"), e5.commitProperty("pixelType"), e5.commitProperty("definitionExpression"), e5.commitProperty("multidimensionalSubset"), (this._get("version") || 0) + 1;
  }
  set version(e5) {
    this._set("version", e5);
  }
  get mosaicRule() {
    const e5 = this.layer;
    let t6 = e5.mosaicRule;
    const r3 = e5.definitionExpression;
    return t6 ? r3 && r3 !== t6.where && (t6 = t6.clone(), t6.where = r3) : r3 && (t6 = new y2({ where: r3 })), t6;
  }
  get rasterFunction() {
    const e5 = this.layer;
    let { rasterFunction: t6 } = e5;
    const r3 = e5.pixelFilter, o6 = !e5.format || e5.format.includes("jpg") || e5.format.includes("png");
    this.requestRawData || (t6 = this._addResampleRasterFunction(t6));
    const i12 = e5.multidimensionalSubset?.areaOfInterest;
    return i12 && (t6 = f10(t6, i12)), this.requestRawData || !o6 || r3 || "vector-field" === e5.renderer?.type || (t6 = this.combineRendererWithRenderingRule(t6)), t6;
  }
  combineRendererWithRenderingRule(e5) {
    const t6 = this.layer, { rasterInfo: r3, renderer: o6 } = t6;
    if (e5 = e5 || t6.rasterFunction, !o6 || !p7(o6)) return e5;
    return g3(y3(o6, { rasterAttributeTable: r3.attributeTable, pixelType: r3.pixelType, dataType: r3.dataType, bandNames: r3.bandInfos.map(({ name: e6 }) => e6), convertColorRampToColormap: t6.version < 10.6, convertToRFT: !!e5?.rasterFunctionDefinition, bandCount: r3.bandCount }), e5);
  }
  _addResampleRasterFunction(e5) {
    if (!("vector-field" === this.layer.renderer?.type) || "Resample" === e5?.functionName) return e5;
    const t6 = "esriImageServiceDataTypeVector-UV" === this.layer.serviceDataType ? 7 : 10, r3 = this.layer.serviceRasterInfo.pixelSize;
    let o6 = new N({ functionName: "Resample", functionArguments: { ResamplingType: t6, InputCellSize: r3 } });
    return o6 = e5?.rasterFunctionDefinition ? new N({ rasterFunctionDefinition: h2(o6) }) : o6, g3(o6, e5);
  }
};
function f10(e5, t6) {
  const r3 = new N({ functionName: "Clip", functionArguments: { ClippingGeometry: t6.toJSON(), ClippingType: 1 } });
  return g3(r3, e5);
}
__decorate([m2()], d6.prototype, "layer", void 0), __decorate([m2()], d6.prototype, "requestRawData", void 0), __decorate([m2({ json: { write: true } })], d6.prototype, "adjustAspectRatio", null), __decorate([r("adjustAspectRatio")], d6.prototype, "writeAdjustAspectRatio", null), __decorate([m2({ json: { write: true } })], d6.prototype, "bandIds", null), __decorate([m2({ json: { write: true } })], d6.prototype, "compression", void 0), __decorate([m2({ json: { write: true } })], d6.prototype, "compressionQuality", null), __decorate([r("compressionQuality")], d6.prototype, "writeCompressionQuality", null), __decorate([m2({ json: { write: true } })], d6.prototype, "compressionTolerance", null), __decorate([r("compressionTolerance")], d6.prototype, "writeCompressionTolerance", null), __decorate([m2({ json: { write: true } })], d6.prototype, "format", null), __decorate([m2({ type: String, json: { read: { reader: a4.read }, write: { writer: a4.write } } })], d6.prototype, "interpolation", null), __decorate([m2({ json: { write: true } })], d6.prototype, "noData", null), __decorate([m2({ type: String, json: { read: { reader: i4.read }, write: { writer: i4.write } } })], d6.prototype, "noDataInterpretation", null), __decorate([m2({ type: n2.apiValues, json: { read: n2.read, write: n2.write } })], d6.prototype, "pixelType", null), __decorate([m2({ json: { write: true } })], d6.prototype, "lercVersion", void 0), __decorate([r("lercVersion")], d6.prototype, "writeLercVersion", null), __decorate([m2({ type: Number })], d6.prototype, "version", null), __decorate([m2({ json: { write: true } })], d6.prototype, "mosaicRule", null), __decorate([m2({ json: { write: true, name: "renderingRule" } })], d6.prototype, "rasterFunction", null), d6 = __decorate([a3("esri.layers.support.ExportImageServiceParameters")], d6);

// node_modules/@arcgis/core/rest/support/FindImagesParameters.js
var i8 = class extends l3(n) {
  constructor(o6) {
    super(o6), this.fromGeometry = null, this.toGeometry = null, this.objectIds = null, this.where = null, this.maxCount = null;
  }
};
__decorate([m2({ type: _, json: { read: true } })], i8.prototype, "fromGeometry", void 0), __decorate([m2({ type: _, json: { read: true, write: true } })], i8.prototype, "toGeometry", void 0), __decorate([m2({ json: { write: true } })], i8.prototype, "objectIds", void 0), __decorate([m2({ type: String, json: { write: true } })], i8.prototype, "where", void 0), __decorate([m2({ type: Number, json: { write: true } })], i8.prototype, "maxCount", void 0), i8 = __decorate([a3("esri.rest.support.FindImagesParameters")], i8);

// node_modules/@arcgis/core/rest/support/CameraInfoMixin.js
var e3 = (e5) => {
  const s13 = e5;
  let i12 = class extends s13 {
    constructor() {
      super(...arguments), this.make = null, this.model = null, this.focalLength = null, this.pixelSize = null, this.rows = null, this.cols = null;
    }
  };
  return __decorate([m2({ json: { write: true } })], i12.prototype, "make", void 0), __decorate([m2({ json: { write: true } })], i12.prototype, "model", void 0), __decorate([m2({ json: { write: true } })], i12.prototype, "focalLength", void 0), __decorate([m2({ json: { write: true } })], i12.prototype, "pixelSize", void 0), __decorate([m2({ json: { write: true } })], i12.prototype, "rows", void 0), __decorate([m2({ json: { write: true } })], i12.prototype, "cols", void 0), i12 = __decorate([a3("esri.rest.support.CameraInfoMixin")], i12), i12;
};

// node_modules/@arcgis/core/rest/support/ImageInspectionInfo.js
var n5 = class extends e3(n) {
  constructor() {
    super(...arguments), this.id = null, this.referenceUri = null, this.acquisitionDate = null, this.cameraID = null, this.center = null, this.perspectiveCenter = null, this.orientation = null;
  }
  writeAcquisitionDate(t6, o6) {
    o6.acquisitionDate = t6?.getTime();
  }
};
__decorate([m2({ json: { write: true } })], n5.prototype, "id", void 0), __decorate([m2({ json: { name: "uri", write: true } })], n5.prototype, "referenceUri", void 0), __decorate([m2({ type: Date, json: { write: true } })], n5.prototype, "acquisitionDate", void 0), __decorate([r("acquisitionDate")], n5.prototype, "writeAcquisitionDate", null), __decorate([m2({ json: { write: true } })], n5.prototype, "cameraID", void 0), __decorate([m2({ type: _, json: { write: true } })], n5.prototype, "center", void 0), __decorate([m2({ type: _, json: { write: true } })], n5.prototype, "perspectiveCenter", void 0), __decorate([m2({ json: { write: true } })], n5.prototype, "orientation", void 0), n5 = __decorate([a3("esri.rest.support.ImageInspectionInfo")], n5);
var c6 = n5;

// node_modules/@arcgis/core/rest/support/FindImagesResult.js
var p8 = class extends n {
  constructor() {
    super(...arguments), this.images = null;
  }
};
__decorate([m2({ type: [c6], json: { write: true } })], p8.prototype, "images", void 0), p8 = __decorate([a3("esri.rest.support.FindImagesResult")], p8);

// node_modules/@arcgis/core/rest/support/ImageAngleParameters.js
var n6;
var l11 = n6 = class extends n {
  constructor(e5) {
    super(e5), this.angleNames = null, this.point = null, this.spatialReference = null, this.rasterId = null;
  }
  clone() {
    return new n6(a({ angleNames: this.angleNames, point: this.point, spatialReference: this.spatialReference, rasterId: this.rasterId }));
  }
};
__decorate([m2({ type: [String], json: { name: "angleName", write: true } })], l11.prototype, "angleNames", void 0), __decorate([m2({ type: _, json: { write: true } })], l11.prototype, "point", void 0), __decorate([m2({ type: f2, json: { write: true } })], l11.prototype, "spatialReference", void 0), __decorate([m2({ type: x, json: { write: true } })], l11.prototype, "rasterId", void 0), l11 = n6 = __decorate([a3("esri.rest.support.ImageAngleParameters")], l11);

// node_modules/@arcgis/core/rest/support/ImageAngleResult.js
var p9 = class extends n {
  constructor(r3) {
    super(r3), this.north = null, this.up = null, this.spatialReference = null;
  }
};
__decorate([m2({ type: Number, json: { write: true } })], p9.prototype, "north", void 0), __decorate([m2({ type: Number, json: { write: true } })], p9.prototype, "up", void 0), __decorate([m2({ type: f2, json: { write: true } })], p9.prototype, "spatialReference", void 0), p9 = __decorate([a3("esri.rest.support.ImageAngleResult")], p9);

// node_modules/@arcgis/core/rest/support/imageMeasureUtils.js
var u5 = new o({ esriMensurationPoint: "point", esriMensurationCentroid: "centroid", esriMensurationDistanceAndAngle: "distance-and-angle", esriMensurationAreaAndPerimeter: "area-and-perimeter", esriMensurationHeightFromBaseAndTop: "base-and-top", esriMensurationHeightFromBaseAndTopShadow: "base-and-top-shadow", esriMensurationHeightFromTopAndTopShadow: "top-and-top-shadow", esriMensurationPoint3D: "point-3D", esriMensurationCentroid3D: "centroid-3D", esriMensurationDistanceAndAngle3D: "distance-and-angle-3D", esriMensurationAreaAndPerimeter3D: "area-and-perimeter-3D" });
var p10 = class extends n {
  constructor() {
    super(...arguments), this.value = null, this.displayValue = null, this.uncertainty = null;
  }
};
__decorate([m2({ type: Number, json: { read: true, write: true } })], p10.prototype, "value", void 0), __decorate([m2({ type: String, json: { read: true, write: true } })], p10.prototype, "displayValue", void 0), __decorate([m2({ type: Number, json: { read: true, write: true } })], p10.prototype, "uncertainty", void 0), p10 = __decorate([a3("esri.rest.support.imageMeasureUtils.BaseImageMeasureResultValue")], p10);
var d7 = class extends p10 {
  constructor() {
    super(...arguments), this.unit = null;
  }
};
__decorate([m2({ type: String, json: { read: we.read, write: we.write } })], d7.prototype, "unit", void 0), d7 = __decorate([a3("esri.rest.support.imageMeasureUtils.ImageMeasureResultLengthValue")], d7);
var l12 = class extends p10 {
  constructor() {
    super(...arguments), this.unit = null;
  }
};
__decorate([m2({ type: String, json: { read: pe.read, write: pe.write } })], l12.prototype, "unit", void 0), l12 = __decorate([a3("esri.rest.support.imageMeasureUtils.ImageMeasureResultAreaValue")], l12);
var c7 = class extends p10 {
  constructor() {
    super(...arguments), this.unit = null;
  }
};
__decorate([m2({ type: String, json: { read: ge.read, write: ge.write } })], c7.prototype, "unit", void 0), c7 = __decorate([a3("esri.rest.support.imageMeasureUtils.ImageMeasureResultAngleValue")], c7);

// node_modules/@arcgis/core/rest/support/BaseImageMeasureParameters.js
var a6 = class extends n {
  constructor(r3) {
    super(r3), this.type = null, this.measureOperation = null, this.mosaicRule = null, this.pixelSize = null, this.raster = void 0;
  }
};
__decorate([m2()], a6.prototype, "type", void 0), __decorate([m2({ type: u5.apiValues, json: { read: u5.read, write: u5.write } })], a6.prototype, "measureOperation", void 0), __decorate([m2({ type: y2, json: { write: true } })], a6.prototype, "mosaicRule", void 0), __decorate([m2({ type: _, json: { write: true } })], a6.prototype, "pixelSize", void 0), __decorate([m2({ json: { write: true } })], a6.prototype, "raster", void 0), a6 = __decorate([a3("esri.rest.support.BaseImageMeasureParameters")], a6);

// node_modules/@arcgis/core/rest/support/ImageAreaParameters.js
var u6;
var y4 = u6 = class extends a6 {
  constructor(e5) {
    super(e5), this.type = "area-perimeter", this.geometry = null, this.is3D = false, this.linearUnit = "meters", this.areaUnit = "square-meters";
  }
  writeGeometry(e5, r3, t6) {
    null != e5 && (r3.geometryType = v(e5), r3[t6] = e5.toJSON());
  }
  get measureOperation() {
    return this.is3D ? "area-and-perimeter-3D" : "area-and-perimeter";
  }
  clone() {
    return new u6(a({ geometry: this.geometry, is3D: this.is3D, linearUnit: this.linearUnit, areaUnit: this.areaUnit, mosaicRule: this.mosaicRule, pixelSize: this.pixelSize, raster: this.raster }));
  }
};
__decorate([m2({ types: l4, json: { name: "fromGeometry", read: true, write: true } })], y4.prototype, "geometry", void 0), __decorate([r("geometry")], y4.prototype, "writeGeometry", null), __decorate([m2({ type: u5.apiValues, json: { write: u5.write } })], y4.prototype, "measureOperation", null), __decorate([m2({ json: { read: true } })], y4.prototype, "is3D", void 0), __decorate([m2({ type: String, json: { read: we.read, write: we.write } })], y4.prototype, "linearUnit", void 0), __decorate([m2({ type: String, json: { read: pe.read, write: pe.write } })], y4.prototype, "areaUnit", void 0), y4 = u6 = __decorate([a3("esri.rest.support.ImageAreaParameters")], y4);

// node_modules/@arcgis/core/rest/support/BaseImageMeasureResult.js
var t4 = class extends n {
  constructor(r3) {
    super(r3), this.name = null, this.sensorName = null;
  }
};
__decorate([m2({ type: String, json: { read: true, write: true } })], t4.prototype, "name", void 0), __decorate([m2({ type: String, json: { read: true, write: true } })], t4.prototype, "sensorName", void 0), t4 = __decorate([a3("esri.rest.support.BaseImageMeasureResult")], t4);

// node_modules/@arcgis/core/rest/support/ImageAreaResult.js
var a7 = class extends t4 {
  constructor() {
    super(...arguments), this.area = null, this.perimeter = null;
  }
};
__decorate([m2({ type: l12, json: { read: true, write: true } })], a7.prototype, "area", void 0), __decorate([m2({ type: d7, json: { read: true, write: true } })], a7.prototype, "perimeter", void 0), a7 = __decorate([a3("esri.rest.support.ImageAreaResult")], a7);

// node_modules/@arcgis/core/rest/support/ImageBoundaryParameters.js
var a8 = class extends l3(n) {
  constructor(r3) {
    super(r3), this.outSpatialReference = null;
  }
};
__decorate([m2({ type: f2, json: { name: "outSR", write: true } })], a8.prototype, "outSpatialReference", void 0), a8 = __decorate([a3("esri.rest.support.ImageBoundaryParameters")], a8);

// node_modules/@arcgis/core/rest/support/ImageBoundaryResult.js
var i9 = class extends n {
  constructor() {
    super(...arguments), this.area = null, this.geometry = null;
  }
  readGeometry(r3, o6) {
    return null == r3 ? null : r3.rings ? P.fromJSON(r3) : z.fromJSON(r3);
  }
};
__decorate([m2({ type: Number, json: { write: true } })], i9.prototype, "area", void 0), __decorate([m2({ types: l4, json: { name: "shape", write: true } })], i9.prototype, "geometry", void 0), __decorate([o2("geometry")], i9.prototype, "readGeometry", null), i9 = __decorate([a3("esri.rest.support.ImageBoundaryResult")], i9);

// node_modules/@arcgis/core/rest/support/ImageDistanceParameters.js
var y5;
var u7 = y5 = class extends a6 {
  constructor(e5) {
    super(e5), this.type = "distance-angle", this.fromGeometry = null, this.toGeometry = null, this.is3D = false, this.linearUnit = "meters", this.angularUnit = "degrees";
  }
  writeFromGeometry(e5, r3, t6) {
    null != e5 && (r3.geometryType = v(e5), r3[t6] = e5.toJSON());
  }
  get measureOperation() {
    return this.is3D ? "distance-and-angle-3D" : "distance-and-angle";
  }
  clone() {
    return new y5(a({ fromGeometry: this.fromGeometry, toGeometry: this.toGeometry, is3D: this.is3D, linearUnit: this.linearUnit, angularUnit: this.angularUnit, mosaicRule: this.mosaicRule, pixelSize: this.pixelSize, raster: this.raster }));
  }
};
__decorate([m2({ type: _, json: { read: true, write: true } })], u7.prototype, "fromGeometry", void 0), __decorate([r("fromGeometry")], u7.prototype, "writeFromGeometry", null), __decorate([m2({ type: _, json: { read: true, write: true } })], u7.prototype, "toGeometry", void 0), __decorate([m2({ type: u5.apiValues, json: { write: u5.write } })], u7.prototype, "measureOperation", null), __decorate([m2({ json: { read: true } })], u7.prototype, "is3D", void 0), __decorate([m2({ type: String, json: { read: we.read, write: we.write } })], u7.prototype, "linearUnit", void 0), __decorate([m2({ type: String, json: { read: ge.read, write: ge.write } })], u7.prototype, "angularUnit", void 0), u7 = y5 = __decorate([a3("esri.rest.support.ImageDistanceParameters")], u7);

// node_modules/@arcgis/core/rest/support/ImageDistanceResult.js
var p11 = class extends t4 {
  constructor() {
    super(...arguments), this.distance = null, this.azimuthAngle = null, this.elevationAngle = null;
  }
};
__decorate([m2({ type: d7, json: { read: true, write: true } })], p11.prototype, "distance", void 0), __decorate([m2({ type: c7, json: { read: true, write: true } })], p11.prototype, "azimuthAngle", void 0), __decorate([m2({ type: c7, json: { read: true, write: true } })], p11.prototype, "elevationAngle", void 0), p11 = __decorate([a3("esri.rest.support.ImageDistanceResult")], p11);

// node_modules/@arcgis/core/rest/support/ImageGPSInfoParameters.js
var y6 = class extends l3(n) {
  constructor(o6) {
    super(o6), this.geometry = null, this.objectIds = null, this.spatialRelationship = "intersects", this.timeExtent = null, this.where = null;
  }
  writeGeometry(o6, t6, r3) {
    null != o6 && (t6.geometryType = v(o6), t6[r3] = JSON.stringify(o6.toJSON()));
  }
};
__decorate([m2({ types: l4, json: { read: f4, write: true } })], y6.prototype, "geometry", void 0), __decorate([r("geometry")], y6.prototype, "writeGeometry", null), __decorate([m2({ json: { write: true } })], y6.prototype, "objectIds", void 0), __decorate([r2(s4, { ignoreUnknown: false, name: "spatialRel" })], y6.prototype, "spatialRelationship", void 0), __decorate([m2({ type: m4, json: { name: "time", write: true } })], y6.prototype, "timeExtent", void 0), __decorate([m2({ type: String, json: { write: true } })], y6.prototype, "where", void 0), y6 = __decorate([a3("esri.rest.support.ImageGPSInfoParameters")], y6);

// node_modules/@arcgis/core/rest/support/CameraInfo.js
var p12 = class extends e3(n) {
  constructor() {
    super(...arguments), this.id = null;
  }
};
__decorate([m2({ json: { write: true } })], p12.prototype, "id", void 0), p12 = __decorate([a3("esri.rest.support.CameraInfo")], p12);
var c8 = p12;

// node_modules/@arcgis/core/rest/support/ImageGPSInfo.js
var p13 = class extends n {
  constructor() {
    super(...arguments), this.id = null, this.name = null, this.acquisitionDate = null, this.cameraID = null, this.center = null, this.gps = null, this.orientation = null;
  }
  writeAcquisitionDate(o6, t6) {
    t6.acquisitionDate = o6?.getTime();
  }
};
__decorate([m2({ json: { write: true } })], p13.prototype, "id", void 0), __decorate([m2({ json: { write: true } })], p13.prototype, "name", void 0), __decorate([m2({ type: Date, json: { write: true } })], p13.prototype, "acquisitionDate", void 0), __decorate([r("acquisitionDate")], p13.prototype, "writeAcquisitionDate", null), __decorate([m2({ json: { write: true } })], p13.prototype, "cameraID", void 0), __decorate([m2({ type: _, json: { write: true } })], p13.prototype, "center", void 0), __decorate([m2({ json: { write: true } })], p13.prototype, "gps", void 0), __decorate([m2({ json: { write: true } })], p13.prototype, "orientation", void 0), p13 = __decorate([a3("esri.rest.support.ImageGPSInfo")], p13);
var n7 = p13;

// node_modules/@arcgis/core/rest/support/ImageGPSInfoResult.js
var m8 = class extends n {
  constructor() {
    super(...arguments), this.images = null, this.cameras = null;
  }
};
__decorate([m2({ type: [n7], json: { write: true } })], m8.prototype, "images", void 0), __decorate([m2({ type: [c8], json: { write: true } })], m8.prototype, "cameras", void 0), m8 = __decorate([a3("esri.rest.support.ImageGPSInfoResult")], m8);

// node_modules/@arcgis/core/rest/support/ImageHeightParameters.js
var y7;
var l13 = y7 = class extends a6 {
  constructor(e5) {
    super(e5), this.type = "height", this.fromGeometry = null, this.toGeometry = null, this.operationType = "base-and-top", this.linearUnit = "meters";
  }
  writeFromGeometry(e5, r3, t6) {
    null != e5 && (r3.geometryType = v(e5), r3[t6] = e5.toJSON());
  }
  get measureOperation() {
    return this.operationType;
  }
  clone() {
    return new y7(a({ fromGeometry: this.fromGeometry, toGeometry: this.toGeometry, operationType: this.operationType, linearUnit: this.linearUnit, mosaicRule: this.mosaicRule, pixelSize: this.pixelSize, raster: this.raster }));
  }
};
__decorate([m2({ type: _, json: { read: true } })], l13.prototype, "fromGeometry", void 0), __decorate([r("fromGeometry")], l13.prototype, "writeFromGeometry", null), __decorate([m2({ type: _, json: { read: true, write: true } })], l13.prototype, "toGeometry", void 0), __decorate([m2({ type: u5.apiValues, json: { write: u5.write } })], l13.prototype, "measureOperation", null), __decorate([m2({ json: { read: true } })], l13.prototype, "operationType", void 0), __decorate([m2({ type: String, json: { read: we.read, write: we.write } })], l13.prototype, "linearUnit", void 0), l13 = y7 = __decorate([a3("esri.rest.support.ImageHeightParameters")], l13);

// node_modules/@arcgis/core/rest/support/ImageHeightResult.js
var p14 = class extends t4 {
  constructor() {
    super(...arguments), this.height = null;
  }
};
__decorate([m2({ type: d7, json: { read: true, write: true } })], p14.prototype, "height", void 0), p14 = __decorate([a3("esri.rest.support.ImageHeightResult")], p14);

// node_modules/@arcgis/core/rest/support/ImageIdentifyParameters.js
var c9;
var y8 = c9 = class extends n {
  constructor(t6) {
    super(t6), this.geometry = null, this.rasterFunctions = null, this.pixelSize = null, this.returnGeometry = true, this.returnCatalogItems = true, this.returnPixelValues = true, this.maxItemCount = null, this.timeExtent = null, this.raster = void 0, this.viewId = void 0, this.processAsMultidimensional = false;
  }
  writeGeometry(t6, e5, r3) {
    null != t6 && (e5.geometryType = v(t6), e5[r3] = JSON.stringify(t6.toJSON()));
  }
  set mosaicRule(t6) {
    let e5 = t6;
    e5?.mosaicMethod && (e5 = y2.fromJSON({ ...e5.toJSON(), mosaicMethod: e5.mosaicMethod, mosaicOperation: e5.mosaicOperation })), this._set("mosaicRule", e5);
  }
  writeMosaicRule(t6, e5, r3) {
    null != t6 && (e5[r3] = JSON.stringify(t6.toJSON()));
  }
  set rasterFunction(t6) {
    let e5 = t6;
    e5?.rasterFunction && (e5 = N.fromJSON({ ...e5.toJSON(), rasterFunction: e5.rasterFunction, rasterFunctionArguments: e5.rasterFunctionArguments })), this._set("rasterFunction", e5);
  }
  writeRasterFunction(t6, e5, r3) {
    null != t6 && (e5[r3] = JSON.stringify(t6.toJSON())), t6.rasterFunctionDefinition && (e5[r3] = JSON.stringify(t6.rasterFunctionDefinition));
  }
  writeRasterFunctions(t6, e5, r3) {
    null != t6 && (e5[r3] = JSON.stringify(t6.map((t7) => t7.rasterFunctionDefinition || t7.toJSON())));
  }
  writePixelSize(t6, e5, r3) {
    null != t6 && (e5[r3] = JSON.stringify(t6));
  }
  writeTimeExtent(t6, e5, r3) {
    if (null != t6) {
      const o6 = null != t6.start ? t6.start.getTime() : null, i12 = null != t6.end ? t6.end.getTime() : null;
      e5[r3] = null != o6 ? null != i12 ? `${o6},${i12}` : `${o6}` : null;
    }
  }
  clone() {
    return new c9(a({ geometry: this.geometry, mosaicRule: this.mosaicRule, rasterFunction: this.rasterFunction, rasterFunctions: this.rasterFunctions, pixelSize: this.pixelSize, returnGeometry: this.returnGeometry, returnCatalogItems: this.returnCatalogItems, returnPixelValues: this.returnPixelValues, maxItemCount: this.maxItemCount, processAsMultidimensional: this.processAsMultidimensional, raster: this.raster, viewId: this.viewId, timeExtent: this.timeExtent }));
  }
};
__decorate([m2({ types: l4, json: { write: true } })], y8.prototype, "geometry", void 0), __decorate([r("geometry")], y8.prototype, "writeGeometry", null), __decorate([m2({ type: y2, json: { write: true } })], y8.prototype, "mosaicRule", null), __decorate([r("mosaicRule")], y8.prototype, "writeMosaicRule", null), __decorate([m2({ type: N, json: { write: true, name: "renderingRule" } })], y8.prototype, "rasterFunction", null), __decorate([r("rasterFunction")], y8.prototype, "writeRasterFunction", null), __decorate([m2({ type: [N], json: { write: true, name: "renderingRules" } })], y8.prototype, "rasterFunctions", void 0), __decorate([r("rasterFunctions")], y8.prototype, "writeRasterFunctions", null), __decorate([m2({ type: _, json: { write: true } })], y8.prototype, "pixelSize", void 0), __decorate([r("pixelSize")], y8.prototype, "writePixelSize", null), __decorate([m2({ type: Boolean, json: { write: true } })], y8.prototype, "returnGeometry", void 0), __decorate([m2({ type: Boolean, json: { write: true } })], y8.prototype, "returnCatalogItems", void 0), __decorate([m2({ type: Boolean, json: { write: true } })], y8.prototype, "returnPixelValues", void 0), __decorate([m2({ type: Number, json: { write: true } })], y8.prototype, "maxItemCount", void 0), __decorate([m2({ type: m4, json: { write: { target: "time" } } })], y8.prototype, "timeExtent", void 0), __decorate([r("timeExtent")], y8.prototype, "writeTimeExtent", null), __decorate([m2({ json: { write: true } })], y8.prototype, "raster", void 0), __decorate([m2({ json: { write: true } })], y8.prototype, "viewId", void 0), __decorate([m2({ type: Boolean, json: { write: true } })], y8.prototype, "processAsMultidimensional", void 0), y8 = c9 = __decorate([a3("esri.rest.support.ImageIdentifyParameters")], y8);

// node_modules/@arcgis/core/rest/support/ImageIdentifyResult.js
var p15 = class extends n {
  constructor() {
    super(...arguments), this.catalogItemVisibilities = null, this.catalogItems = null, this.location = null, this.name = null, this.objectId = null, this.processedValues = null, this.properties = null, this.value = null;
  }
};
__decorate([m2({ json: { write: true } })], p15.prototype, "catalogItemVisibilities", void 0), __decorate([m2({ type: g, json: { write: true } })], p15.prototype, "catalogItems", void 0), __decorate([m2({ type: _, json: { write: true } })], p15.prototype, "location", void 0), __decorate([m2({ json: { write: true } })], p15.prototype, "name", void 0), __decorate([m2({ json: { write: true } })], p15.prototype, "objectId", void 0), __decorate([m2({ json: { write: true } })], p15.prototype, "processedValues", void 0), __decorate([m2({ json: { write: true } })], p15.prototype, "properties", void 0), __decorate([m2({ json: { write: true } })], p15.prototype, "value", void 0), p15 = __decorate([a3("esri.rest.support.ImageIdentifyResult")], p15);

// node_modules/@arcgis/core/rest/support/ImagePixelLocationParameters.js
var m9;
var c10 = m9 = class extends n {
  constructor(r3) {
    super(r3), this.geometries = null, this.rasterId = null;
  }
  writeGeometry(r3, e5, o6) {
    e5.geometries = { geometryType: "esriGeometryPoint", geometries: r3.map((r4) => r4.toJSON()) };
  }
  clone() {
    return new m9({ geometries: this.geometries?.map((r3) => r3.clone()) ?? [], rasterId: this.rasterId });
  }
};
__decorate([m2({ type: [_], json: { write: true } })], c10.prototype, "geometries", void 0), __decorate([r("geometries")], c10.prototype, "writeGeometry", null), __decorate([m2({ type: x, json: { write: true } })], c10.prototype, "rasterId", void 0), c10 = m9 = __decorate([a3("esri.rest.support.ImagePixelLocationParameters")], c10);

// node_modules/@arcgis/core/rest/support/ImagePixelLocationResult.js
var t5 = class extends n {
  constructor() {
    super(...arguments), this.geometries = null;
  }
};
__decorate([m2({ json: { write: true } })], t5.prototype, "geometries", void 0), t5 = __decorate([a3("esri.rest.support.ImagePixelLocationResult")], t5);

// node_modules/@arcgis/core/rest/support/ImagePointParameters.js
var c11;
var l14 = c11 = class extends a6 {
  constructor(e5) {
    super(e5), this.type = "point", this.geometry = null, this.is3D = false;
  }
  writeGeometry(e5, r3, t6) {
    null != e5 && (r3.geometryType = v(e5), r3[t6] = e5.toJSON());
  }
  get measureOperation() {
    const { is3D: e5, geometry: r3 } = this;
    return "point" === r3.type ? e5 ? "point-3D" : "point" : e5 ? "centroid-3D" : "centroid";
  }
  clone() {
    return new c11(a({ geometry: this.geometry, is3D: this.is3D, mosaicRule: this.mosaicRule, pixelSize: this.pixelSize, raster: this.raster }));
  }
};
__decorate([m2({ types: l4, json: { name: "fromGeometry", read: f4 } })], l14.prototype, "geometry", void 0), __decorate([r("geometry")], l14.prototype, "writeGeometry", null), __decorate([m2({ type: u5.apiValues, json: { read: u5.read, write: u5.write } })], l14.prototype, "measureOperation", null), __decorate([m2({ json: { read: true } })], l14.prototype, "is3D", void 0), l14 = c11 = __decorate([a3("esri.rest.support.ImagePointParameters")], l14);

// node_modules/@arcgis/core/rest/support/ImagePointResult.js
var p16 = class extends t4 {
  constructor() {
    super(...arguments), this.point = null;
  }
};
__decorate([m2({ type: _, json: { name: "point.value", read: true, write: true } })], p16.prototype, "point", void 0), p16 = __decorate([a3("esri.rest.support.ImagePointResult")], p16);

// node_modules/@arcgis/core/rest/support/ImageToMapMultirayParameters.js
var l15 = class extends l3(n) {
  constructor(e5) {
    super(e5), this.geometries = [], this.rasterIds = null, this.outSpatialReference = null;
  }
  writeGeometries(e5, r3, o6) {
    r3.geometries = e5?.length ? { geometryType: v(e5[0]), geometries: e5.map((e6) => ({ ...e6.toJSON(), spatialReference: void 0 })) } : null;
  }
};
__decorate([m2({ types: [l4] })], l15.prototype, "geometries", void 0), __decorate([r("geometries")], l15.prototype, "writeGeometries", null), __decorate([m2({ type: [x], json: { write: true } })], l15.prototype, "rasterIds", void 0), __decorate([m2({ type: f2, json: { name: "outSR", write: true } })], l15.prototype, "outSpatialReference", void 0), l15 = __decorate([a3("esri.rest.support.ImageToMapMultirayParameters")], l15);

// node_modules/@arcgis/core/rest/support/ImageToMapParameters.js
var n8 = class extends l3(n) {
  constructor(o6) {
    super(o6), this.geometry = null, this.rasterId = null, this.outSpatialReference = null, this.depthOffset = 0, this.adjust = false;
  }
  writeGeometry(o6, e5, t6) {
    null != o6 && (e5.geometryType = v(o6), e5[t6] = { ...o6.toJSON(), spatialReference: void 0 });
  }
};
__decorate([m2({ types: l4, json: { read: f4, write: true } })], n8.prototype, "geometry", void 0), __decorate([r("geometry")], n8.prototype, "writeGeometry", null), __decorate([m2({ json: { write: true } })], n8.prototype, "rasterId", void 0), __decorate([m2({ type: f2, json: { name: "outSR", write: true } })], n8.prototype, "outSpatialReference", void 0), __decorate([m2({ json: { name: "options.DOff", write: true } })], n8.prototype, "depthOffset", void 0), __decorate([m2({ json: { name: "options.Adjust", write: true } })], n8.prototype, "adjust", void 0), n8 = __decorate([a3("esri.rest.support.ImageToMapParameters")], n8);

// node_modules/@arcgis/core/rest/support/ImageUrlParameters.js
var p17 = class extends l3(n) {
  constructor(r3) {
    super(r3), this.referenceUri = null, this.rasterId = null;
  }
};
__decorate([m2({ type: String, json: { name: "uri", write: true } })], p17.prototype, "referenceUri", void 0), __decorate([m2({ type: Number, json: { write: true } })], p17.prototype, "rasterId", void 0), p17 = __decorate([a3("esri.rest.support.ImageUrlParameters")], p17);

// node_modules/@arcgis/core/rest/support/ImageUrlResult.js
var e4 = class extends n {
  constructor() {
    super(...arguments), this.url = null;
  }
};
__decorate([m2({ json: { name: "imageURL", write: true } })], e4.prototype, "url", void 0), e4 = __decorate([a3("esri.rest.support.ImageUrlResult")], e4);

// node_modules/@arcgis/core/rest/support/ImageVolumeParameters.js
var n9 = new o({ 0: "constant", 1: "plane", 2: "minimum", 3: "maximum", 4: "average" }, { useNumericKeys: true });
var u8 = class extends l3(n) {
  constructor() {
    super(...arguments), this.geometries = [], this.mosaicRule = null, this.pixelSize = null, this.constantZ = null, this.baseType = "plane";
  }
  writeGeometries(o6, e5, r3) {
    o6?.length && (e5.geometryType = v(o6[0]), e5.geometries = o6.map((o7) => o7.toJSON()));
  }
};
__decorate([m2({ types: [l4] })], u8.prototype, "geometries", void 0), __decorate([r("geometries")], u8.prototype, "writeGeometries", null), __decorate([m2({ type: y2, json: { write: true } })], u8.prototype, "mosaicRule", void 0), __decorate([m2({ type: _, json: { write: true } })], u8.prototype, "pixelSize", void 0), __decorate([m2({ json: { write: true } })], u8.prototype, "constantZ", void 0), __decorate([m2({ type: n9.apiValues, json: { read: n9.read, write: n9.write } })], u8.prototype, "baseType", void 0), u8 = __decorate([a3("esri.rest.support.ImageVolumeParameters")], u8);

// node_modules/@arcgis/core/rest/support/ImageVolume.js
var s12 = class extends n {
  constructor() {
    super(...arguments), this.area = null, this.cut = null, this.fill = null, this.maxZ = null, this.minZ = null, this.meanZ = null, this.cutCellCount = null, this.fillCellCount = null;
  }
};
__decorate([m2({ json: { write: true } })], s12.prototype, "area", void 0), __decorate([m2({ json: { write: true } })], s12.prototype, "cut", void 0), __decorate([m2({ json: { write: true } })], s12.prototype, "fill", void 0), __decorate([m2({ json: { name: "maxz", write: true } })], s12.prototype, "maxZ", void 0), __decorate([m2({ json: { name: "minz", write: true } })], s12.prototype, "minZ", void 0), __decorate([m2({ json: { name: "meanz", write: true } })], s12.prototype, "meanZ", void 0), __decorate([m2({ json: { write: true } })], s12.prototype, "cutCellCount", void 0), __decorate([m2({ json: { write: true } })], s12.prototype, "fillCellCount", void 0), s12 = __decorate([a3("esri.rest.support.ImageVolume")], s12);
var i10 = s12;

// node_modules/@arcgis/core/rest/support/ImageVolumeResult.js
var p18 = class extends n {
  constructor() {
    super(...arguments), this.volumes = [];
  }
};
__decorate([m2({ type: [i10], json: { write: true } })], p18.prototype, "volumes", void 0), p18 = __decorate([a3("esri.rest.support.ImageVolumeResult")], p18);

// node_modules/@arcgis/core/rest/support/MapToImageParameters.js
var a9 = class extends l3(n) {
  constructor(r3) {
    super(r3), this.geometry = null, this.rasterId = null, this.visibleOnly = false;
  }
  writeGeometry(r3, o6, e5) {
    null != r3 && (o6.geometryType = v(r3), o6[e5] = JSON.stringify(r3));
  }
};
__decorate([m2({ types: l4, json: { read: f4, write: true } })], a9.prototype, "geometry", void 0), __decorate([r("geometry")], a9.prototype, "writeGeometry", null), __decorate([m2({ json: { write: true } })], a9.prototype, "rasterId", void 0), __decorate([m2({ json: { name: "options.VisibleOnly", write: true } })], a9.prototype, "visibleOnly", void 0), a9 = __decorate([a3("esri.rest.support.MapToImageParameters")], a9);

// node_modules/@arcgis/core/rest/support/MeasureAreaFromImageResult.js
var i11 = class extends n {
  constructor() {
    super(...arguments), this.geometry = null, this.length = null, this.area = null, this.center = null;
  }
  readCenter(e5, r3) {
    return e5.spatialReference || (e5 = { ...e5, spatialReference: r3.Shape.spatialReference }), _.fromJSON(e5);
  }
};
__decorate([m2({ types: l4, json: { name: "Shape", read: f4, write: true } })], i11.prototype, "geometry", void 0), __decorate([m2({ json: { name: "Length", write: true } })], i11.prototype, "length", void 0), __decorate([m2({ json: { name: "Area", write: true } })], i11.prototype, "area", void 0), __decorate([m2({ type: _, json: { name: "Center", write: true } })], i11.prototype, "center", void 0), __decorate([o2("center")], i11.prototype, "readCenter", null), i11 = __decorate([a3("esri.rest.support.MeasureAreaFromImageResult")], i11);

// node_modules/@arcgis/core/rest/support/MeasureFromImageParameters.js
var c12;
var y9 = c12 = class extends n {
  constructor(r3) {
    super(r3), this.geometry = null, this.rasterId = void 0;
  }
  writeGeometry(r3, o6, e5) {
    null != r3 && (o6.geometryType = v(r3), o6[e5] = { ...r3.toJSON(), spatialReference: void 0 });
  }
  clone() {
    const r3 = a({ geometry: this.geometry, rasterId: this.rasterId });
    return new c12(r3);
  }
};
__decorate([m2({ types: l4, json: { name: "fromGeometry", read: f4, write: true } })], y9.prototype, "geometry", void 0), __decorate([r("geometry")], y9.prototype, "writeGeometry", null), __decorate([m2({ json: { write: true } })], y9.prototype, "rasterId", void 0), y9 = c12 = __decorate([a3("esri.rest.support.MeasureFromImageParameters")], y9);

// node_modules/@arcgis/core/rest/support/MeasureLengthFromImageResult.js
var m10 = class extends n {
  constructor() {
    super(...arguments), this.geometry = null, this.length = null;
  }
};
__decorate([m2({ types: l4, json: { name: "Shape", read: f4, write: true } })], m10.prototype, "geometry", void 0), __decorate([m2({ json: { name: "Length", write: true } })], m10.prototype, "length", void 0), m10 = __decorate([a3("esri.rest.support.MeasureLengthFromImageResult")], m10);

// node_modules/@arcgis/core/rest/imageService.js
function B3(t6) {
  const e5 = t6?.time;
  if (e5 && (null != e5.start || null != e5.end)) {
    const r3 = [];
    null != e5.start && r3.push(e5.start), null == e5.end || r3.includes(e5.end) || r3.push(e5.end), t6.time = r3.join(",");
  }
}
async function D2(t6, r3, o6) {
  r3 = m(j3, r3);
  const s13 = f5(t6), p19 = r3.geometry ? [r3.geometry] : [], u9 = await P2(p19), c13 = r3.toJSON();
  B3(c13);
  const f11 = u9?.[0];
  null != f11 && (c13.geometry = st(f11));
  const l16 = u({ ...s13.query, f: "json", ...c13 });
  return s3(l16, o6);
}
async function k(r3, o6, a10) {
  const s13 = (o6 = m(u8, o6)).toJSON();
  s13.geometries = JSON.stringify(s13.geometries);
  const p19 = f5(r3), u9 = u({ ...p19.query, f: "json", ...s13 }), c13 = s3(u9, a10), { data: f11 } = await H(`${p19.path}/calculateVolume`, c13);
  return p18.fromJSON({ volumes: f11.results });
}
async function z2(o6, a10, s13) {
  const p19 = (a10 = m(l11, a10)).toJSON();
  null != p19.angleName && (p19.angleName = p19.angleName.join(",")), a10?.point?.spatialReference?.imageCoordinateSystem && (p19.point.spatialReference = nt(a10.point.spatialReference)), a10?.spatialReference?.imageCoordinateSystem && (p19.spatialReference = mt(a10.spatialReference));
  const u9 = f5(o6), l16 = u({ ...u9.query, f: "json", ...p19 }), g4 = s3(l16, s13), { data: y10 } = await H(`${u9.path}/computeAngles`, g4);
  return y10.spatialReference = y10.spatialReference ? null != y10.spatialReference.geodataXform ? new f2({ wkid: 0, imageCoordinateSystem: y10.spatialReference }) : f2.fromJSON(y10.spatialReference) : null, "NaN" === y10.north && (y10.north = null), "NaN" === y10.up && (y10.up = null), new p9(y10);
}
async function E2(r3, o6, a10) {
  const s13 = (o6 = m(c10, o6)).toJSON(), { geometries: p19 } = o6;
  if (p19) for (let t6 = 0; t6 < p19.length; t6++) p19[t6].spatialReference?.imageCoordinateSystem && (s13.geometries.geometries[t6].spatialReference = nt(p19[t6].spatialReference));
  const u9 = f5(r3), c13 = u({ ...u9.query, f: "json", ...s13 }), f11 = s3(c13, a10), { data: l16 } = await H(`${u9.path}/computePixelLocation`, f11);
  return t5.fromJSON(l16);
}
async function X(e5, r3, o6) {
  const a10 = await D2(e5, r3, o6), s13 = f5(e5), { data: m11 } = await H(`${s13.path}/computeStatisticsHistograms`, a10), { statistics: i12 } = m11;
  return i12?.length && i12.forEach((t6) => {
    t6.avg = t6.mean, t6.stddev = t6.standardDeviation;
  }), { statistics: i12, histograms: m11.histograms };
}
async function K(e5, r3, o6) {
  const a10 = await D2(e5, r3, o6), s13 = f5(e5), { data: m11 } = await H(`${s13.path}/computeHistograms`, a10);
  return { histograms: m11.histograms };
}
async function Q(r3, o6, s13) {
  const p19 = (o6 = m(h, o6)).toJSON();
  B3(p19), p19.outFields?.length && (p19.outFields = p19.outFields.join(","));
  const u9 = await P2(o6.geometry), c13 = u9?.[0];
  null != c13 && (p19.geometry = st(c13));
  const f11 = f5(r3), l16 = u({ ...f11.query, f: "json", ...p19 }), g4 = s3(l16, s13), { data: y10 } = await H(`${f11.path}/getSamples`, g4), j4 = y10.samples.map((t6) => {
    const e5 = "NaN" === t6.value || "" === t6.value ? null : t6.value.split(" ").map((t7) => Number(t7));
    return { ...t6, pixelValue: e5 };
  });
  return p5.fromJSON({ samples: j4 });
}
async function W2(r3, o6, s13) {
  o6 = m(y8, o6);
  const p19 = f5(r3), u9 = o6.geometry ? [o6.geometry] : [];
  return P2(u9).then((e5) => {
    const r4 = o6.toJSON(), a10 = e5?.[0];
    null != a10 && (r4.geometry = JSON.stringify(st(a10)));
    const n11 = u({ ...p19.query, f: "json", ...r4 }), u10 = s3(n11, s13);
    return H(p19.path + "/identify", u10);
  }).then((t6) => p15.fromJSON(t6.data));
}
async function Y(t6, r3, o6) {
  r3 = m(l13, r3);
  const a10 = await et(t6, r3, [r3.fromGeometry, r3.toGeometry], o6);
  return p14.fromJSON(a10);
}
async function Z2(t6, r3, o6) {
  r3 = m(y4, r3);
  const a10 = await et(t6, r3, [r3.geometry], o6);
  return a7.fromJSON(a10);
}
async function _3(t6, r3, o6) {
  r3 = m(l14, r3);
  const a10 = await et(t6, r3, [r3.geometry], o6);
  return p16.fromJSON(a10);
}
async function tt(t6, r3, o6) {
  r3 = m(u7, r3);
  const a10 = await et(t6, r3, [r3.fromGeometry, r3.toGeometry], o6);
  return p11.fromJSON(a10);
}
async function et(e5, r3, o6, s13) {
  const p19 = f5(e5), u9 = await P2(o6), c13 = r3.toJSON();
  null != u9[0] && (c13.fromGeometry = JSON.stringify(st(u9[0]))), null != u9[1] && (c13.toGeometry = JSON.stringify(st(u9[1])));
  const f11 = u({ ...p19.query, f: "json", ...c13 }), l16 = s3(f11, s13), { data: g4 } = await H(p19.path + "/measure", l16);
  return g4;
}
async function rt(t6, e5, r3) {
  const o6 = await at(t6, e5, r3);
  return m10.fromJSON(o6);
}
async function ot(t6, e5, r3) {
  const o6 = await at(t6, e5, r3);
  return i11.fromJSON(o6);
}
async function at(r3, o6, a10) {
  o6 = m(y9, o6);
  const s13 = f5(r3), p19 = o6.toJSON(), u9 = u({ ...s13.query, f: "json", ...p19 }), c13 = s3(u9, a10), { data: f11 } = await H(s13.path + "/measureFromImage", c13);
  return f11;
}
function st(t6) {
  const e5 = t6.toJSON();
  return t6.spatialReference?.imageCoordinateSystem && (e5.spatialReference = nt(t6.spatialReference)), e5;
}
function nt(t6) {
  const { imageCoordinateSystem: e5 } = t6;
  if (e5) {
    const { id: t7, referenceServiceName: r3 } = e5;
    return null != t7 ? r3 ? { icsid: t7, icsns: r3 } : { icsid: t7 } : { ics: e5 };
  }
  return t6.toJSON();
}
function mt(t6, e5) {
  if (!t6.imageCoordinateSystem) return A(t6);
  const r3 = nt(t6), { icsid: o6, icsns: a10 } = r3;
  return null == o6 || null != a10 && !e5?.toLowerCase().includes("/" + a10.toLowerCase() + "/") ? JSON.stringify(r3) : `0:${o6}`;
}
async function it(r3, o6, a10) {
  o6 = m(a8, o6);
  const s13 = f5(r3), p19 = o6.toJSON();
  o6.outSpatialReference && (p19.outSR = mt(o6.outSpatialReference));
  const u9 = u({ ...s13.query, f: "json", ...p19 }), c13 = s3(u9, a10), { data: f11 } = await H(s13.path + "/queryBoundary", c13);
  return i9.fromJSON(f11);
}
async function pt(r3, o6, s13) {
  const p19 = (o6 = m(y6, o6)).toJSON();
  B3(p19), p19.objectIds?.length && (p19.objectIds = p19.objectIds.join(",")), p19.geometry || p19.objectIds || p19.time || p19.where || (p19.where = "1=1");
  const u9 = await P2(o6.geometry), c13 = u9?.[0];
  null != c13 && (p19.geometry = st(c13));
  const f11 = c13?.spatialReference ?? o6.geometry?.spatialReference;
  f11 && (p19.inSR = mt(f11));
  const l16 = f5(r3), g4 = u({ ...l16.query, f: "json", ...p19 }), y10 = s3(g4, s13), { data: j4 } = await H(`${l16.path}/queryGPSInfo`, y10);
  return m8.fromJSON(j4);
}
async function ut(r3, a10, s13) {
  const p19 = (a10 = m(n8, a10)).toJSON();
  a10.geometry.spatialReference.imageCoordinateSystem && (p19.geometry = st(a10.geometry)), a10.depthOffset && a10.adjust || delete p19.options;
  const u9 = f5(r3), c13 = u({ ...u9.query, f: "json", ...p19 }), f11 = s3(c13, s13), { data: l16 } = await H(`${u9.path}/imageToMap`, f11);
  return f4(l16);
}
async function ct(r3, a10, s13) {
  const p19 = (a10 = m(l15, a10)).toJSON();
  a10.rasterIds?.length && (p19.rasterIds = a10.rasterIds.join(","));
  const u9 = f5(r3), c13 = u({ ...u9.query, f: "json", ...p19 }), f11 = s3(c13, s13), { data: l16 } = await H(`${u9.path}/imageToMapMultiray`, f11);
  return f4(l16);
}
async function ft(r3, s13, p19) {
  const u9 = (s13 = m(a9, s13)).toJSON(), c13 = await P2(s13.geometry), f11 = c13?.[0];
  null != f11 && (u9.geometry = st(f11)), s13.visibleOnly || delete u9.options;
  const l16 = f11?.spatialReference ?? s13.geometry?.spatialReference;
  l16 && (u9.inSR = mt(l16));
  const g4 = f5(r3), y10 = u({ ...g4.query, f: "json", ...u9 }), j4 = s3(y10, p19), { data: d8 } = await H(`${g4.path}/mapToImage`, j4);
  return f4(d8);
}
async function lt(r3, o6, a10) {
  const s13 = (o6 = m(p17, o6)).toJSON(), p19 = f5(r3), u9 = u({ ...p19.query, f: "json", ...s13 }), c13 = s3(u9, a10), { data: f11 } = await H(`${p19.path}/getImageUrl`, c13);
  return e4.fromJSON(f11);
}
async function gt(r3, o6, s13) {
  const c13 = (o6 = m(i8, o6)).toJSON(), f11 = await P2([o6.fromGeometry, o6.toGeometry]);
  null != f11[0] && (c13.fromGeometry = st(f11[0]), f11[0].spatialReference && (c13.inSR = mt(f11[0].spatialReference))), null != f11[1] && (c13.toGeometry = st(f11[1])), o6.objectIds?.length && (c13.objectIds = c13.objectIds.join(","));
  const l16 = f5(r3), g4 = u({ ...l16.query, f: "json", ...c13 }), y10 = s3(g4, s13), { data: j4 } = await H(`${l16.path}/find`, y10);
  return p8.fromJSON(j4);
}

// node_modules/@arcgis/core/rest/imageService/getCatalogItemRasterInfo.js
async function n10(n11, m11, p19) {
  const f11 = f5(n11), u9 = u({ ...f11?.query, f: "json" }), h3 = s3(u9, p19), d8 = `${f11?.path}/${m11}/info`, c13 = H(`${d8}`, h3), g4 = H(`${d8}/keyProperties`, h3), x3 = await Promise.allSettled([c13, g4]), y10 = "fulfilled" === x3[0].status ? x3[0].value.data : null, v4 = "fulfilled" === x3[1].status ? x3[1].value.data : null;
  let P4 = null;
  y10.statistics?.length && (P4 = y10.statistics.map((e5) => ({ min: e5[0], max: e5[1], avg: e5[2], stddev: e5[3] })));
  const S2 = z.fromJSON(y10.extent), j4 = Math.ceil(S2.width / y10.pixelSizeX - 0.1), w3 = Math.ceil(S2.height / y10.pixelSizeY - 0.1), b7 = S2.spatialReference, k2 = new _({ x: y10.pixelSizeX, y: y10.pixelSizeY, spatialReference: b7 }), z3 = y10.histograms?.length ? y10.histograms : null, L3 = new l7({ origin: y10.origin, blockWidth: y10.blockWidth, blockHeight: y10.blockHeight, firstPyramidLevel: y10.firstPyramidLevel, maximumPyramidLevel: y10.maxPyramidLevel });
  return new m5({ width: j4, height: w3, bandCount: y10.bandCount, extent: S2, spatialReference: b7, pixelSize: k2, pixelType: y10.pixelType.toLowerCase(), statistics: P4, histograms: z3, keyProperties: v4, storageInfo: L3 });
}

// node_modules/@arcgis/core/layers/mixins/ArcGISImageService.js
var Be = /* @__PURE__ */ new Set(["png", "png8", "png24", "png32", "jpg", "bmp", "gif", "jpgpng", "lerc", "tiff"]);
var Le = i2(a2, { min: 0, max: 255 });
function ze(e5) {
  const t6 = JSON.stringify(e5), i12 = t6.includes('"rasterFunctionDefinition":{'), r3 = i12 ? t6.match(/"type":"(.*?FunctionArguments")/gi) : t6.match(/"rasterFunction":"(.*?")/gi), s13 = r3?.map((e6) => i12 ? e6.slice(8, -18) : e6.slice(18, -1));
  return s13 ? s13.join("/") : null;
}
var He = (m11) => {
  const h3 = m11;
  let He2 = class extends h3 {
    constructor() {
      super(...arguments), this._functionRasterInfos = {}, this._serviceSupportsMosaicRule = null, this.adjustAspectRatio = null, this.bandIds = void 0, this.capabilities = null, this.compressionQuality = void 0, this.compressionTolerance = 0.01, this.copyright = null, this.defaultMosaicRule = null, this.definitionExpression = null, this.exportImageServiceParameters = null, this.rasterInfo = null, this.fields = null, this.fullExtent = null, this.hasMultidimensions = false, this.imageMaxHeight = 4100, this.imageMaxWidth = 4100, this.interpolation = void 0, this.minScale = 0, this.maxScale = 0, this.multidimensionalInfo = null, this.multidimensionalSubset = null, this.noData = null, this.noDataInterpretation = void 0, this.objectIdField = null, this.geometryType = "polygon", this.typeIdField = null, this.types = [], this.pixelFilter = null, this.raster = void 0, this.sourceType = null, this.viewId = void 0, this.symbolizer = null, this.rasterFunctionInfos = null, this.serviceDataType = null, this.spatialReference = null, this.pixelType = null, this.serviceRasterInfo = null, this.sourceJSON = null, this.url = null, this.version = void 0;
    }
    initialize() {
      this._set("exportImageServiceParameters", new d6({ layer: this }));
    }
    readServiceSupportsMosaicRule(e5, t6) {
      return this._isMosaicRuleSupported(t6);
    }
    get _rasterFunctionNamesIndex() {
      const e5 = /* @__PURE__ */ new Map();
      return !this.rasterFunctionInfos || null != this.rasterFunctionInfos && this.rasterFunctionInfos.length < 1 || null != this.rasterFunctionInfos && this.rasterFunctionInfos.forEach((t6) => {
        e5.set(t6.name.toLowerCase().replaceAll(/ /gi, "_"), t6.name);
      }), e5;
    }
    readBandIds(e5, t6) {
      if (Array.isArray(e5) && e5.length > 0 && e5.every((e6) => "number" == typeof e6)) return e5;
    }
    readCapabilities(e5, t6) {
      return this._readCapabilities(t6);
    }
    writeCompressionQuality(e5, t6, i12) {
      null != e5 && "lerc" !== this.format && (t6[i12] = e5);
    }
    writeCompressionTolerance(e5, t6, i12) {
      "lerc" === this.format && null != e5 && (t6[i12] = e5);
    }
    readDefaultMosaicRule(e5, t6) {
      return this._serviceSupportsMosaicRule ? y2.fromJSON(t6) : null;
    }
    get fieldsIndex() {
      return this.fields ? new Z(this.fields) : null;
    }
    set format(e5) {
      e5 && Be.has(e5.toLowerCase()) && this._set("format", e5.toLowerCase());
    }
    readFormat(e5, t6) {
      return "esriImageServiceDataTypeVector-UV" === t6.serviceDataType || "esriImageServiceDataTypeVector-MagDir" === t6.serviceDataType || null != this.pixelFilter ? "lerc" : "jpgpng";
    }
    readMinScale(e5, t6) {
      return null != t6.minLOD && null != t6.maxLOD ? e5 : 0;
    }
    readMaxScale(e5, t6) {
      return null != t6.minLOD && null != t6.maxLOD ? e5 : 0;
    }
    set mosaicRule(e5) {
      let t6 = e5;
      t6?.mosaicMethod && (t6 = y2.fromJSON({ ...t6.toJSON(), mosaicMethod: t6.mosaicMethod, mosaicOperation: t6.mosaicOperation })), this._set("mosaicRule", t6);
    }
    readMosaicRule(e5, t6) {
      const i12 = e5 || t6.mosaicRule;
      return i12 ? y2.fromJSON(i12) : this._isMosaicRuleSupported(t6) ? y2.fromJSON(t6) : null;
    }
    writeMosaicRule(e5, t6, i12) {
      const { mosaicRule: r3 } = this;
      this._isValidCustomizedMosaicRule(r3) && (t6[i12] = r3.toJSON());
    }
    writeNoData(e5, t6, i12) {
      null != e5 && "number" == typeof e5 && (t6[i12] = Le(e5));
    }
    readObjectIdField(e5, t6) {
      if (!e5) {
        const i12 = t6.fields.find((e6) => "esriFieldTypeOID" === e6.type || "oid" === e6.type);
        e5 = i12?.name;
      }
      return e5;
    }
    get parsedUrl() {
      return I(this.url);
    }
    readSourceType(e5, t6) {
      return this._isMosaicDataset(t6) ? "mosaic-dataset" : "raster-dataset";
    }
    get renderer() {
      const { activePresetRendererName: e5, presetRenderers: t6 } = this;
      if (e5) {
        const i12 = t6?.find(({ name: t7 }) => t7 === e5);
        return i12?.renderer.clone();
      }
      return this.internalRenderer;
    }
    set renderer(e5) {
      this.activePresetRendererName = null, this.internalRenderer = e5;
    }
    set internalRenderer(e5) {
      this.loaded && (e5 = this._configRenderer(e5)), this._set("internalRenderer", e5);
    }
    readRenderer(e5, t6, i12) {
      const r3 = t6?.layerDefinition?.drawingInfo?.renderer, s13 = d4(r3, i12);
      return null == s13 ? null : ("vector-field" === s13.type && t6.symbolTileSize && !r3.symbolTileSize && (s13.symbolTileSize = t6.symbolTileSize), p7(s13) || i.getLogger(this).warn("ArcGISImageService", "Imagery layer doesn't support given renderer type."), s13);
    }
    writeRenderer(e5, t6, i12) {
      t6.layerDefinition = t6.layerDefinition || {}, t6.layerDefinition.drawingInfo = t6.layerDefinition.drawingInfo || {}, t6.layerDefinition.drawingInfo.renderer = e5.toJSON(), "vector-field" === e5.type && (t6.symbolTileSize = e5.symbolTileSize);
    }
    get rasterFields() {
      const e5 = this.fields?.map((e6) => e6.clone()) ?? [];
      e5.push(o4()), "mosaic-dataset" === this.sourceType && this.fields?.length && e5.push(m6()), this.version >= 10.4 && null != this.rasterFunctionInfos && this.rasterFunctionInfos.some(({ name: e6 }) => "none" === e6.toLowerCase()) && e5.push(c2()), null != this.rasterFunctionInfos && this.rasterFunctionInfos.filter(({ name: e6 }) => "none" !== e6.toLowerCase()).forEach(({ name: t7 }) => e5.push(f6(t7)));
      const { rasterInfo: t6 } = this;
      if (this._isVectorDataSet()) {
        const i13 = t6?.multidimensionalInfo?.variables[0].unit?.trim(), r3 = d2(i13), s13 = $();
        e5.push(r3, s13);
      }
      if (t6?.multidimensionalInfo && "raster-dataset" === this.sourceType) {
        const i13 = p2(t6.multidimensionalInfo);
        e5.push(...i13);
      }
      const i12 = t6?.attributeTable;
      if (null != i12) {
        const t7 = v2(i12);
        e5.push(...t7);
      }
      return e5;
    }
    set rasterFunction(e5) {
      let t6 = e5;
      t6?.rasterFunction && (t6 = N.fromJSON({ ...t6.toJSON(), rasterFunction: t6.rasterFunction, rasterFunctionArguments: t6.rasterFunctionArguments })), this._set("rasterFunction", t6);
    }
    readRasterFunction(e5, t6) {
      const i12 = t6.rasterFunctionInfos;
      return t6.renderingRule || i12?.length && "None" !== i12[0].name ? this._isRFTJson(t6.renderingRule) ? N.fromJSON({ rasterFunctionDefinition: t6.renderingRule }) : N.fromJSON(t6.renderingRule || { rasterFunctionInfos: t6.rasterFunctionInfos }) : null;
    }
    readSpatialReference(e5, t6) {
      const i12 = e5 || t6.extent.spatialReference;
      return i12 ? f2.fromJSON(i12) : null;
    }
    writePixelType(e5, t6, i12) {
      null != this.serviceRasterInfo && this.pixelType === this.serviceRasterInfo.pixelType || (t6[i12] = n2.toJSON(e5));
    }
    readVersion(e5, t6) {
      let i12 = t6.currentVersion;
      return i12 || (i12 = t6.hasOwnProperty("fields") || t6.hasOwnProperty("timeInfo") ? 10 : 9.3), i12;
    }
    applyFilter(e5) {
      let t6 = e5;
      return this.pixelFilter && (t6 = this._clonePixelData(e5), this.pixelFilter(t6)), t6;
    }
    async applyRenderer(e5, t6) {
      let i12 = e5, { renderer: r3, symbolizer: s13, pixelFilter: n11 } = this;
      const { isRawData: a10 } = e5;
      if (a10 && "lerc" !== this.format && (r3 ??= B2(this.rasterInfo, { bandIds: this.bandIds, variableName: this.rasterFunction ? null : this.mosaicRule?.multidimensionalDefinition?.[0].variableName }), s13 || (this.symbolizer = new O({ rendererJSON: r3.toJSON(), rasterInfo: this.rasterInfo }), s13 = this.symbolizer)), (a10 || !this._isPicture()) && r3 && s13 && !n11) {
        await this._updateSymbolizer(s13, r3);
        const { bandIds: n12 } = this;
        i12 = await this._symbolize({ pixelData: e5, bandIds: n12, symbolizer: s13 }, t6);
      }
      return i12;
    }
    async highlightPixels(e5, t6) {
      const i12 = e5.highlightOptions.map((e6) => {
        const t7 = { ...e6 }, { bandId: i13 } = t7;
        if (null == i13) t7.bandId = 0;
        else {
          const e7 = this.bandIds?.length ? this.bandIds.indexOf(i13) : i13;
          if (e7 < 0 || e7 > 2) return;
          t7.bandId = e7;
        }
        return t7;
      }).filter((e6) => null != e6), r3 = this._rasterJobHandler;
      r3 ? await r3.highlightPixels({ ...e5, highlightOptions: i12 }, t6) : u3(e5.pixelBlock, e5.renderedPixelBlock, i12);
    }
    destroy() {
      this._shutdownJobHandler();
    }
    async calculateVolume(e5, t6) {
      if (!(await this._fetchCapabilities(t6?.signal)).operations.supportsCalculateVolume) throw new s("imagery-layer:compute-pixel-space-locations", "this operation is not supported on the input image service");
      return e5 = a(e5), this.mosaicRule && null == e5.mosaicRule && (e5.mosaicRule = this.mosaicRule), k(this.url, e5, this._getRequestOptions(t6));
    }
    async computeAngles(e5, t6) {
      if (!(await this._fetchCapabilities(t6?.signal)).operations.supportsComputeAngles) throw new s("imagery-layer:compute-angles", "this operation is not supported on the input image service");
      return z2(this.url, e5, this._getRequestOptions(t6));
    }
    async computePixelSpaceLocations(e5, t6) {
      if (!(await this._fetchCapabilities(t6?.signal)).operations.supportsComputePixelLocation) throw new s("imagery-layer:compute-pixel-space-locations", "this operation is not supported on the input image service");
      return E2(this.url, e5, this._getRequestOptions(t6));
    }
    async computeHistograms(e5, t6) {
      if (!(await this._fetchCapabilities(t6?.signal)).operations.supportsComputeHistograms) throw new s("imagery-layer:compute-histograms", "this operation is not supported on the input image service");
      return e5 = a(e5), this._applyMosaicAndRenderingRules(e5), K(this.url, e5, this._getRequestOptions(t6));
    }
    async computeStatisticsHistograms(e5, t6) {
      if (!(await this._fetchCapabilities(t6?.signal)).operations.supportsComputeStatisticsHistograms) throw new s("imagery-layer:compute-statistics-histograms", "this operation is not supported on the input image service");
      return e5 = a(e5), this._applyMosaicAndRenderingRules(e5), X(this.url, e5, this._getRequestOptions(t6));
    }
    async measureHeight(e5, t6) {
      const i12 = await this._fetchCapabilities(t6?.signal);
      if (!("base-and-top" === e5.operationType ? i12.mensuration.supportsHeightFromBaseAndTop : "base-and-top-shadow" === e5.operationType ? i12.mensuration.supportsHeightFromBaseAndTopShadow : i12.mensuration.supportsHeightFromTopAndTopShadow)) throw new s("imagery-layer:measure-height", "this operation is not supported on the input image service");
      return e5 = a(e5), this._applyMosaicRule(e5), Y(this.url, e5, this._getRequestOptions(t6));
    }
    async measureAreaAndPerimeter(e5, t6) {
      const i12 = await this._fetchCapabilities(t6?.signal);
      if (!(i12.mensuration.supportsAreaAndPerimeter && (!e5.is3D || i12.mensuration.supports3D))) throw new s("imagery-layer:measure-area-and-perimeter", "this operation is not supported on the input image service");
      return e5 = a(e5), this._applyMosaicRule(e5), Z2(this.url, e5, this._getRequestOptions(t6));
    }
    async measureDistanceAndAngle(e5, t6) {
      const i12 = await this._fetchCapabilities(t6?.signal);
      if (!(i12.mensuration.supportsDistanceAndAngle && (!e5.is3D || i12.mensuration.supports3D))) throw new s("imagery-layer:measure-distance-and-angle", "this operation is not supported on the input image service");
      return e5 = a(e5), this._applyMosaicRule(e5), tt(this.url, e5, this._getRequestOptions(t6));
    }
    async measurePointOrCentroid(e5, t6) {
      const i12 = await this._fetchCapabilities(t6?.signal);
      if (!(i12.mensuration.supportsPointOrCentroid && (!e5.is3D || i12.mensuration.supports3D))) throw new s("imagery-layer:measure-point-or-centroid", "this operation is not supported on the input image service");
      return e5 = a(e5), this._applyMosaicRule(e5), _3(this.url, e5, this._getRequestOptions(t6));
    }
    async measureLengthFromImage(e5, t6) {
      if (!(await this._fetchCapabilities(t6?.signal)).operations.supportsMeasureFromImage) throw new s("imagery-layer:measure-length-from-image", "this operation is not supported on the input image service");
      if ("polyline" !== e5.geometry.type) throw new s("imagery-layer:measure-length-from-image", "this input geometry must be a polyline");
      return rt(this.url, e5, this._getRequestOptions(t6));
    }
    async measureAreaFromImage(e5, t6) {
      if (!(await this._fetchCapabilities(t6?.signal)).operations.supportsMeasureFromImage) throw new s("imagery-layer:measure-area-from-image", "this operation is not supported on the input image service");
      if ("polygon" !== e5.geometry.type) throw new s("imagery-layer:measure-area-from-image", "this input geometry must be a polygon");
      return ot(this.url, e5, this._getRequestOptions(t6));
    }
    getField(e5) {
      const { fieldsIndex: t6 } = this;
      return null != t6 ? t6.get(e5) : void 0;
    }
    getFieldDomain(e5, t6) {
      const i12 = this.getField(e5);
      return i12 ? i12.domain : null;
    }
    fetchImage(e5, t6, i12, n11 = {}) {
      if (s2(i.getLogger(this), "`ImageryLayer.fetchImage` is deprecated in favor of 'ImageryLayer.fetchPixels'.", { replacement: "ImageryLayer.fetchPixels", version: "4.33", warnOnce: true }), null == e5 || null == t6 || null == i12) throw new s("imagery-layer:fetch-image", "Insufficient parameters for requesting an image. A valid extent, width and height values are required.");
      return this.internalFetchImage(e5, t6, i12, n11);
    }
    async internalFetchImage(e5, t6, i12, r3 = {}) {
      await this._updateCurrentRasterInfo();
      const { exportImageServiceParameters: s13 } = this;
      let n11 = false;
      r3.requestRawData && (await this._initJobHandler(), s13.requestRawData || "lerc" === this.format || (n11 = true, s13.requestRawData = true));
      const a10 = this.getExportImageServiceParameters(e5, t6, i12, r3.timeExtent);
      if (n11 && (s13.requestRawData = false), null == a10) {
        if (r3.requestAsImageElement && this._canRequestImageElement(this.format)) {
          const e6 = document.createElement("canvas");
          if (e6.width = t6, e6.height = i12, r3.returnImageBitmap) {
            return { imageBitmap: await t2(e6, `${Ge(this.parsedUrl)}/exportImage`, r3.signal) };
          }
          return { imageOrCanvasElement: e6 };
        }
        const { bandIds: s14, rasterInfo: n12 } = this, a11 = (s14?.length || n12.bandCount) ?? 0, o7 = t6 * i12, l17 = n12.pixelType, u10 = [];
        for (let e6 = 0; e6 < a11; e6++) u10.push(c.createEmptyBand(l17, o7));
        return { pixelData: { pixelBlock: new c({ width: t6, height: i12, pixels: u10, mask: new Uint8Array(o7), pixelType: l17 }), extent: e5 } };
      }
      const o6 = !!r3.requestAsImageElement && !this.pixelFilter, l16 = o6 && !!r3.returnImageBitmap, u9 = { imageServiceParameters: a10, imageProps: { extent: e5, width: t6, height: i12, format: this.format }, requestAsImageElement: o6, returnImageBitmap: l16, signal: r3.signal };
      return this._requestArrayBuffer(u9);
    }
    async fetchPixels(e5, t6, i12, r3 = {}) {
      await this._initJobHandler(), r3.applyRendering && this._updateCurrentRasterInfo();
      const s13 = r3.applyRendering ? void 0 : new d6({ layer: this, requestRawData: true, interpolation: r3.interpolation ?? "nearest", bandIds: r3.bandIds ?? [] }), n11 = this.getExportImageServiceParameters(e5, t6, i12, r3.timeExtent, s13);
      if (null == n11) return { extent: e5, pixelBlock: null };
      delete n11.pixelType, r3.bandIds || delete n11.bandIds, delete n11.compressionQuality;
      const a10 = { imageServiceParameters: n11, imageProps: { extent: e5, width: t6, height: i12, format: this.format }, requestAsImageElement: false, returnImageBitmap: false, signal: r3.signal }, { pixelData: o6 } = await this._requestArrayBuffer(a10);
      return o6 ?? { extent: e5, pixelBlock: null };
    }
    fetchKeyProperties(e5) {
      return H(Ge(this.parsedUrl) + "/keyProperties", { query: this._getQueryParams({ renderingRule: this.version >= 10.3 ? e5?.rasterFunction : null }) }).then((e6) => e6.data);
    }
    fetchRasterAttributeTable(e5) {
      return this.version < 10.1 ? Promise.reject(new s("#fetchRasterAttributeTable()", "Failed to get rasterAttributeTable")) : H(Ge(this.parsedUrl) + "/rasterAttributeTable", { query: this._getQueryParams({ renderingRule: this.version >= 10.3 ? e5?.rasterFunction : null }) }).then((e6) => g.fromJSON(e6.data));
    }
    getCatalogItemRasterInfo(e5, t6) {
      const i12 = { ...t6, query: this._getQueryParams() };
      return n10(Ge(this.parsedUrl), e5, i12);
    }
    async getCatalogItemICSInfo(e5, t6) {
      const { data: r3 } = await H(Ge(this.parsedUrl) + "/" + e5 + "/info/ics", { query: this._getQueryParams(), ...t6 }), s13 = r3?.ics;
      if (!s13) return;
      let n11 = null;
      try {
        n11 = (await H(Ge(this.parsedUrl) + "/" + e5 + "/info", { query: this._getQueryParams(), ...t6 })).data.extent;
      } catch {
      }
      if (!n11?.spatialReference) return { ics: s13, icsToPixelTransform: null, icsExtent: null, northDirection: null };
      const a10 = this.version >= 10.7 ? H(Ge(this.parsedUrl) + "/" + e5 + "/info/icstopixel", { query: this._getQueryParams(), ...t6 }).then((e6) => e6.data).catch(() => ({})) : {}, o6 = n11.spatialReference, l16 = { geometries: JSON.stringify({ geometryType: "esriGeometryEnvelope", geometries: [n11] }), inSR: A(o6), outSR: "0:" + e5 }, u9 = H(Ge(this.parsedUrl) + "/project", { query: this._getQueryParams(l16), ...t6 }).then((e6) => e6.data).catch(() => ({})), p19 = 5, m12 = (n11.xmin + n11.xmax) / 2, c13 = (n11.ymax - n11.ymin) / (p19 + 1), h4 = n11.ymin + c13, d8 = [];
      for (let i12 = 0; i12 < p19; i12++) d8.push({ x: m12, y: h4 + c13 * i12 });
      const f11 = { geometries: JSON.stringify({ geometryType: "esriGeometryPoint", geometries: d8 }), inSR: A(o6), outSR: "0:" + e5 }, g4 = H(Ge(this.parsedUrl) + "/project", { query: this._getQueryParams(f11), ...t6 }).then((e6) => e6.data).catch(() => ({})), R4 = await Promise.all([a10, u9, g4]);
      let w3 = R4[0].ipxf;
      if (null == w3) {
        const e6 = s13.geodataXform?.xf_0;
        "topup" === e6?.name?.toLowerCase() && 6 === e6?.coefficients?.length && (w3 = { affine: { name: "ics [sensor: Frame] to pixel (column, row) transformation", coefficients: e6.coefficients, cellsizeRatio: 0, type: "GeometricXform" } });
      }
      const b7 = z.fromJSON(R4[1]?.geometries?.[0]);
      b7 && (b7.spatialReference = new f2({ wkid: 0, imageCoordinateSystem: s13 }));
      const S2 = R4[2].geometries ? R4[2].geometries.filter((e6) => null != e6?.x && null != e6.y && "NaN" !== e6.x && "NaN" !== e6.y) : [], x3 = S2.length;
      if (x3 < 3) return { ics: s13, icsToPixelTransform: w3, icsExtent: b7, northDirection: null };
      let _4 = 0, F3 = 0, D3 = 0, O2 = 0;
      for (let i12 = 0; i12 < x3; i12++) _4 += S2[i12].x, F3 += S2[i12].y, D3 += S2[i12].x * S2[i12].x, O2 += S2[i12].x * S2[i12].y;
      const T2 = (x3 * O2 - _4 * F3) / (x3 * D3 - _4 * _4);
      let C2 = 0;
      const M = S2[p19 - 1].x > S2[0].x, P4 = S2[p19 - 1].y > S2[0].y;
      return T2 === 1 / 0 ? C2 = P4 ? 90 : 270 : 0 === T2 ? C2 = M ? 0 : 180 : T2 > 0 ? C2 = M ? 180 * Math.atan(T2) / Math.PI : 180 * Math.atan(T2) / Math.PI + 180 : T2 < 0 && (C2 = P4 ? 180 + 180 * Math.atan(T2) / Math.PI : 360 + 180 * Math.atan(T2) / Math.PI), { ics: s13, icsToPixelTransform: w3, icsExtent: b7, northDirection: C2 };
    }
    async generateRasterInfo(e5, t6) {
      e5 = m(N, e5);
      const i12 = { ...t6, query: this._getQueryParams() };
      if (!e5 || "none" === e5.functionName?.toLowerCase() || this._isVectorFieldResampleFunction(e5)) return this.serviceRasterInfo ?? f8(Ge(this.parsedUrl), this.sourceJSON, i12);
      const r3 = ze(e5);
      if (!r3) throw new s("imagery-layer:generate-raster-info", "the rendering rule is not supported");
      if (this._functionRasterInfos[r3]) return this._functionRasterInfos[r3];
      const n11 = p6(Ge(this.parsedUrl), e5, i12);
      this._functionRasterInfos[r3] = n11;
      try {
        return await n11;
      } catch (a10) {
        throw this._functionRasterInfos[r3] = null, a10;
      }
    }
    getExportImageServiceParameters(e5, t6, i12, r3, s13) {
      e5 = e5.clone().shiftCentralMeridian();
      const n11 = mt(e5.spatialReference, Ge(this.parsedUrl));
      s13 ??= this.exportImageServiceParameters;
      const a10 = s13.toJSON(), { bandIds: o6, noData: l16 } = a10;
      let { renderingRule: u9 } = a10;
      const p19 = this.rasterFunction?.rasterFunctionDefinition, m12 = this.renderer?.type, c13 = !m12 || "raster-stretch" === m12 || "raster-colormap" === m12 || "unique-value" === m12 || "class-breaks" === m12 || "raster-shaded-relief" === m12;
      if (o6?.length && this._hasRasterFunction(this.rasterFunction) && !p19 && c13) {
        const e6 = { rasterFunction: "ExtractBand", rasterFunctionArguments: { BandIds: o6 } };
        if ("Stretch" === u9.rasterFunction) e6.rasterFunctionArguments.Raster = u9.rasterFunctionArguments.Raster, u9.rasterFunctionArguments.Raster = e6;
        else if ("Colormap" === u9.rasterFunction) {
          const t7 = u9.rasterFunctionArguments.Raster;
          "Stretch" === t7?.rasterFunction ? (e6.rasterFunctionArguments.Raster = t7.rasterFunctionArguments.Raster, t7.rasterFunctionArguments.Raster = e6) : (e6.rasterFunctionArguments.Raster = t7, u9.rasterFunctionArguments.Raster = e6);
        } else e6.rasterFunctionArguments.Raster = u9, u9 = e6;
        a10.bandIds = void 0;
      } else a10.bandIds = o6?.join(",");
      Array.isArray(l16) && l16.length > 0 && (a10.noData = l16.join(","));
      const h4 = this._processMultidimensionalIntersection(null, r3, s13.mosaicRule);
      if (h4.isOutSide) return null;
      a10.mosaicRule = null != h4.mosaicRule ? JSON.stringify(h4.mosaicRule) : null, r3 = h4.timeExtent, a10.renderingRule = this._getRenderingRuleString(N.fromJSON(u9));
      const d8 = {};
      if (null != r3) {
        const { start: e6, end: t7 } = r3.toJSON();
        e6 && t7 && e6 === t7 ? d8.time = "" + e6 : null == e6 && null == t7 || (d8.time = `${e6 ?? "null"},${t7 ?? "null"}`);
      }
      return { bbox: e5.xmin + "," + e5.ymin + "," + e5.xmax + "," + e5.ymax, bboxSR: n11, imageSR: n11, size: t6 + "," + i12, ...a10, ...d8 };
    }
    async getSamples(e5, t6) {
      const i12 = await this._fetchCapabilities(t6?.signal);
      if (!i12?.operations.supportsGetSamples) throw new s("imagery-layer:get-samples", "getSamples operation is not supported on the input image service");
      e5 = a(e5);
      const { raster: r3 } = this;
      return r3 && null == e5.raster && (e5.raster = r3), Q(this.url, e5, this._getRequestOptions(t6));
    }
    async identify(e5, t6) {
      if (!(await this._fetchCapabilities(t6?.signal)).operations.supportsIdentify) throw new s("imagery-layer:identify", "identify operation is not supported on the input image service");
      e5 = a(e5), this.version < 10.91 && "extent" === e5.geometry?.type && (e5.geometry = P.fromExtent(e5.geometry));
      const i12 = this._processMultidimensionalIntersection(e5.geometry, e5.timeExtent, e5.mosaicRule || this.mosaicRule);
      if (i12.isOutSide) throw new s("imagery-layer:identify", "the request cannot be fulfilled when falling outside of the multidimensional subset");
      e5.timeExtent = i12.timeExtent, e5.mosaicRule = i12.mosaicRule;
      const { raster: r3, rasterFunction: a10 } = this;
      return a10 && null == e5.rasterFunction && (e5.rasterFunction = a10), r3 && null == e5.raster && (e5.raster = r3), W2(this.url, e5, this._getRequestOptions(t6));
    }
    async imageToMap(e5, t6) {
      if (!(await this._fetchCapabilities(t6?.signal)).operations.supportsImageToMap) throw new s("imagery-layer:image-to-map", "imageToMap operation is not supported on the input image service");
      return ut(Ge(this.parsedUrl), e5, this._getRequestOptions(t6));
    }
    async imageToMapMultiray(e5, t6) {
      if (!(await this._fetchCapabilities(t6?.signal)).operations.supportsImageToMapMultiray) throw new s("imagery-layer:image-to-map-multiray", "imageToMapMultiray operation is not supported on the input image service");
      return ct(Ge(this.parsedUrl), e5, this._getRequestOptions(t6));
    }
    async mapToImage(e5, t6) {
      if (!(await this._fetchCapabilities(t6?.signal)).operations.supportsMapToImage) throw new s("imagery-layer:map-to-image", "mapToImage operation is not supported on the input image service");
      return ft(Ge(this.parsedUrl), e5, this._getRequestOptions(t6));
    }
    async findImages(e5, t6) {
      if (!(await this._fetchCapabilities(t6?.signal)).operations.supportsFindImages) throw new s("imagery-layer:find-images", "findImages operation is not supported on the input image service");
      return gt(Ge(this.parsedUrl), e5, this._getRequestOptions(t6));
    }
    async getImageUrl(e5, t6) {
      if (!(await this._fetchCapabilities(t6?.signal)).operations.supportsGetImageUrl) throw new s("imagery-layer:get-image-url", "getImageUrl operation is not supported on the input image service");
      return lt(Ge(this.parsedUrl), e5, this._getRequestOptions(t6));
    }
    createQuery() {
      return new b({ outFields: ["*"], returnGeometry: true, where: this.definitionExpression || "1=1" });
    }
    async queryBoundary(e5, t6) {
      if (!(await this._fetchCapabilities(t6?.signal)).operations.supportsQueryBoundary) throw new s("imagery-layer:query-boundary", "queryBoundary operation is not supported on the input image service");
      return e5 = e5 ?? { outSpatialReference: this.spatialReference }, it(Ge(this.parsedUrl), e5, this._getRequestOptions(t6));
    }
    async queryRasters(e5, t6) {
      ({ query: e5, requestOptions: t6 } = await this._prepareForQuery(e5, t6));
      const i12 = await s8(this.url, e5, t6), r3 = this.graphicOrigin;
      return i12.features.forEach((e6) => {
        e6.layer = this, e6.origin = r3;
      }), i12;
    }
    async queryObjectIds(e5, t6) {
      return { query: e5, requestOptions: t6 } = await this._prepareForQuery(e5, t6), i3(this.url, e5, t6);
    }
    async queryGPSInfo(e5, t6) {
      if (!(await this._fetchCapabilities(t6?.signal)).operations.supportsQueryGPSInfo) throw new s("imagery-layer:query-gps-info", "queryGPSInfo operation is not supported on the input image service");
      return e5 = e5 ?? { where: "1=1" }, pt(Ge(this.parsedUrl), e5, this._getRequestOptions(t6));
    }
    async queryRasterCount(e5, t6) {
      return { query: e5, requestOptions: t6 } = await this._prepareForQuery(e5, t6), s7(this.url, e5, t6);
    }
    async queryVisibleRasters(e5, t6) {
      if (!e5) throw new s("imagery-layer: query-visible-rasters", "missing query parameter");
      await this.load();
      const { pixelSize: i12, returnDomainValues: r3, returnTopmostRaster: n11, showNoDataRecords: a10 } = t6 || { pixelSize: null, returnDomainValues: false, returnTopmostRaster: false, showNoDataRecords: false };
      let o6 = false, l16 = null, u9 = null;
      const p19 = i6.servicePixelValue.toLowerCase(), m12 = this._rasterFunctionNamesIndex;
      if (null != e5.outFields && (o6 = e5.outFields.some((e6) => !e6.toLowerCase().startsWith(p19)), this.version >= 10.4)) {
        const t7 = e5.outFields.filter((e6) => e6.toLowerCase().startsWith(p19) && e6.length > p19.length).map((e6) => {
          const t8 = e6.slice(p19.length + 1);
          return [this._updateRenderingRulesFunctionName(t8, m12), t8];
        });
        l16 = t7.map((e6) => new N({ functionName: e6[0] })), u9 = t7.map((e6) => e6[1]);
        const { rasterFunction: i13 } = this;
        0 === l16.length ? i13?.functionName ? (l16.push(i13), u9.push(i13.functionName)) : l16 = null : i13?.functionName && !l16.some((e6) => e6.functionName === i13.functionName) && (l16.push(i13), u9.push(i13.functionName));
      }
      const c13 = null == e5.outSpatialReference || e5.outSpatialReference.equals(this.spatialReference), { multidimensionalSubset: h4 } = this;
      let d8 = e5.timeExtent || this.timeExtent;
      if (h4) {
        const { isOutside: t7, intersection: i13 } = f7(h4, { geometry: e5.geometry, timeExtent: e5.timeExtent, multidimensionalDefinition: this.exportImageServiceParameters.mosaicRule?.multidimensionalDefinition });
        if (t7) throw new s("imagery-layer:query-visible-rasters", "the request cannot be fulfilled when falling outside of the multidimensional subset");
        null != i13?.timeExtent && (d8 = i13.timeExtent);
      }
      const f11 = this._combineMosaicRuleWithTimeExtent(this.exportImageServiceParameters.mosaicRule, d8);
      let g4 = e5.geometry;
      this.version < 10.91 && "extent" === g4?.type && (g4 = P.fromExtent(g4));
      const y10 = this._getQueryParams({ geometry: g4, timeExtent: d8, mosaicRule: f11, rasterFunction: this.version < 10.4 ? this.rasterFunction : null, rasterFunctions: l16, pixelSize: i12, returnCatalogItems: o6, returnGeometry: c13, raster: this.raster, maxItemCount: n11 ? 1 : null });
      delete y10.f;
      const I2 = new y8(y10);
      try {
        await this._generateRasterInfo(this.rasterFunction);
        const i13 = await W2(this.url, I2, { signal: t6?.signal, query: { ...this.customParameters } }), s13 = e5.outFields, n12 = null != i13.value && i13.value.toLowerCase().includes("nodata"), l17 = o6 && !c13 && i13?.catalogItems?.features.length && (a10 || !n12), p20 = this.multidimensionalInfo && "raster-dataset" === this.sourceType ? g2({ rasterInfo: this.rasterInfo, multidimensionalDefinition: f11?.multidimensionalDefinition, timeExtent: d8, multidimensionalSubset: this.multidimensionalSubset }) : null;
        if (!l17) return this._processVisibleRastersResponse(i13, { returnDomainValues: r3, templateRRFunctionNames: u9, showNoDataRecords: a10, templateFields: s13, effectiveMultidimensionalDefinition: p20 });
        const m13 = this.objectIdField || "ObjectId", h5 = i13.catalogItems?.features ?? [], g5 = h5.map((e6) => e6.attributes?.[m13]), y11 = new b({ objectIds: g5, returnGeometry: true, outSpatialReference: e5.outSpatialReference, outFields: [m13] }), R4 = await this.queryRasters(y11);
        return R4?.features?.length && R4.features.forEach((t7) => {
          h5.forEach((i14) => {
            i14.attributes[m13] === t7.attributes[m13] && t7.geometry && (i14.geometry = t7.geometry.clone(), null != e5.outSpatialReference && (i14.geometry.spatialReference = e5.outSpatialReference));
          });
        }), this._processVisibleRastersResponse(i13, { returnDomainValues: r3, templateRRFunctionNames: u9, showNoDataRecords: a10, templateFields: s13, effectiveMultidimensionalDefinition: p20 });
      } catch {
        throw new s("imagery-layer:query-visible-rasters", "encountered error when querying visible rasters");
      }
    }
    async fetchVariableStatisticsHistograms(e5, t6) {
      const r3 = H(Ge(this.parsedUrl) + "/statistics", { query: this._getQueryParams({ variable: e5 }), signal: t6 }).then((e6) => e6.data?.statistics), s13 = H(Ge(this.parsedUrl) + "/histograms", { query: this._getQueryParams({ variable: e5 }), signal: t6 }).then((e6) => e6.data?.histograms), n11 = await Promise.all([r3, s13]);
      return n11[0] && n11[0].forEach((e6) => {
        e6.avg = e6.mean, e6.stddev = e6.standardDeviation;
      }), { statistics: n11[0] || null, histograms: n11[1] || null };
    }
    getMultidimensionalSubsetVariables(e5) {
      const t6 = e5 ?? this.serviceRasterInfo.multidimensionalInfo;
      return D(this.multidimensionalSubset, t6);
    }
    async _fetchService(e5) {
      await this._fetchServiceInfo(e5), this.rasterInfo || (this.rasterInfo = this.serviceRasterInfo);
      const t6 = this.sourceJSON, i12 = null != this.serviceRasterInfo ? Promise.resolve(this.serviceRasterInfo) : f8(Ge(this.parsedUrl), t6, { signal: e5, query: this._getQueryParams() }).then((e6) => (this._set("serviceRasterInfo", e6), this._set("multidimensionalInfo", e6.multidimensionalInfo), c4(e6, t6), e6)), r3 = this._hasRasterFunction(this.rasterFunction) ? this._generateRasterInfo(this.rasterFunction, { signal: e5 }) : null, s13 = this._getRasterFunctionInfos();
      return Promise.all([i12, r3, s13]).then((e6) => {
        e6[1] ? this._set("rasterInfo", e6[1]) : this._set("rasterInfo", e6[0]), e6[2] && this._set("rasterFunctionInfos", e6[2]), this.internalRenderer && !this._isSupportedRenderer(this.internalRenderer) && (this._set("internalRenderer", null), i.getLogger(this).warn("ArcGISImageService", "Switching to the default renderer. Renderer applied is not valid for this Imagery Layer")), this._set("internalRenderer", this._configRenderer(this.renderer)), this.addHandles([l(() => this.rasterFunction, (e7) => {
          (this.renderer || this.symbolizer || this.popupEnabled && this.popupTemplate) && this._generateRasterInfo(e7).then((e8) => {
            e8 && (this.rasterInfo = e8);
          });
        })]);
        const { serviceRasterInfo: t7 } = this;
        null != t7.multidimensionalInfo && this._updateMultidimensionalDefinition(t7);
      });
    }
    _combineMosaicRuleWithTimeExtent(e5, t6) {
      const i12 = this.timeInfo, { multidimensionalInfo: r3 } = this.serviceRasterInfo;
      if (null == e5 || null == r3 || null == t6 || null == i12?.startField) return e5;
      const { startField: s13 } = i12, n11 = r3.variables.some((e6) => e6.dimensions.some((e7) => e7.name === s13)) ? s13 : "StdTime";
      if (e5 = e5.clone(), "mosaic-dataset" === this.sourceType) return e5.multidimensionalDefinition = e5.multidimensionalDefinition?.filter((e6) => e6.dimensionName !== n11), this._cleanupMultidimensionalDefinition(e5);
      e5.multidimensionalDefinition = e5.multidimensionalDefinition || [];
      const a10 = e5.multidimensionalDefinition.filter((e6) => e6.dimensionName === n11), o6 = null != t6.start ? t6.start.getTime() : null, l16 = null != t6.end ? t6.end.getTime() : null, u9 = null == o6 || null == l16 || o6 === l16, p19 = u9 ? [o6 || l16] : [[o6, l16]], m12 = this.version >= 10.8;
      if (a10.length) a10.forEach((e6) => {
        e6.dimensionName === n11 && (m12 ? (e6.dimensionName = null, e6.isSlice = false, e6.values = []) : (e6.isSlice = u9, e6.values = p19));
      });
      else if (!m12) {
        const t7 = e5.multidimensionalDefinition.filter((e6) => null != e6.variableName && null == e6.dimensionName);
        t7.length ? t7.forEach((e6) => {
          e6.dimensionName = n11, e6.isSlice = u9, e6.values = p19;
        }) : e5.multidimensionalDefinition.push(new p3({ variableName: "", dimensionName: n11, isSlice: u9, values: p19 }));
      }
      return this._cleanupMultidimensionalDefinition(e5);
    }
    _cleanupMultidimensionalDefinition(e5) {
      return null == e5 ? null : (e5.multidimensionalDefinition && (e5.multidimensionalDefinition = e5.multidimensionalDefinition.filter((e6) => !(!e6.variableName && !e6.dimensionName)), 0 === e5.multidimensionalDefinition.length && (e5.multidimensionalDefinition = null)), "mosaic-dataset" !== this.sourceType && null == e5.multidimensionalDefinition ? null : e5);
    }
    async _prepareForQuery(e5, t6) {
      if (!(await this._fetchCapabilities(t6?.signal)).operations.supportsQuery) throw new s("imagery-layer:query-rasters", "query operation is not supported on the input image service");
      return e5 = null != e5 ? m(b, e5) : this.createQuery(), t6 = this._getRequestOptions(t6), this.raster && (t6.query = { ...t6.query, raster: this.raster }), { query: e5, requestOptions: t6 };
    }
    _isSupportedRenderer(e5) {
      const { rasterInfo: t6, rasterFunction: i12 } = this;
      return "unique-value" === e5.type && this._hasRasterFunction(i12) && 1 === t6?.bandCount && ["u8", "s8"].includes(t6.pixelType) || null != t6 && null != e5 && E(t6).includes(e5.type);
    }
    async _fetchCapabilities(e5) {
      return this.capabilities || await this._fetchServiceInfo(e5), this.capabilities;
    }
    async _fetchServiceInfo(e5) {
      let t6 = this.sourceJSON;
      if (!t6) {
        const { data: r3, ssl: s13 } = await H(Ge(this.parsedUrl), { query: this._getQueryParams(), signal: e5 });
        t6 = r3, this.sourceJSON = t6, s13 && (this.url = this.url.replace(/^http:/i, "https:"));
      }
      if (t6.capabilities?.toLowerCase().split(",").map((e6) => e6.trim()).indexOf("tilesonly") > -1) throw new s("imagery-layer:fetch-service-info", "use ImageryTileLayer to open tiles-only image services");
      this.read(t6, { origin: "service", url: this.parsedUrl });
    }
    _isMosaicDataset(e5) {
      return e5.serviceSourceType ? "esriImageServiceSourceTypeMosaicDataset" === e5.serviceSourceType : e5.fields?.length > 0;
    }
    _isMosaicRuleSupported(e5) {
      if (!e5) return false;
      const t6 = this._isMosaicDataset(e5), i12 = e5.currentVersion >= 10.71 && e5.hasMultidimensions && !(e5.fields?.length > 1);
      return t6 || i12;
    }
    _isVectorFieldResampleFunction(e5) {
      if (null == e5) return false;
      const { functionName: t6, functionArguments: i12 } = e5, r3 = "resample" === t6?.toLowerCase(), s13 = i12?.ResampleType || i12?.resampleType;
      return r3 && (7 === s13 || 10 === s13);
    }
    _isPicture() {
      return !this.format || this.format.includes("jpg") || this.format.includes("png");
    }
    _configRenderer(e5) {
      const t6 = this._isPicture(), { rasterInfo: i12 } = this;
      if (!t6 && !this.pixelFilter || this._isVectorDataSet()) {
        const t7 = this.mosaicRule?.multidimensionalDefinition?.[0].variableName, r3 = q2({ variableName: t7, rasterFunctionName: this.rasterFunction?.functionName, presetRenderers: this.presetRenderers });
        if (!this.bandIds && i12.bandCount >= 3) {
          const e6 = r3?.bandIds ?? W(i12);
          !e6 || 3 === i12.bandCount && 0 === e6[0] && 1 === e6[1] && 2 === e6[2] || (this.bandIds = e6);
        }
        e5 || (e5 = r3?.renderer ?? B2(i12, { bandIds: this.bandIds, variableName: this.rasterFunction ? null : t7 }));
        const s13 = ae(e5.toJSON());
        this.symbolizer ? (this.symbolizer.rendererJSON = s13, this.symbolizer.rasterInfo = i12) : this.symbolizer = new O({ rendererJSON: s13, rasterInfo: i12 }), this.symbolizer.bind().success || (this.symbolizer = null);
      }
      return e5;
    }
    _clonePixelData(e5) {
      return null == e5 ? e5 : { extent: e5.extent && e5.extent.clone(), pixelBlock: null != e5.pixelBlock ? e5.pixelBlock.clone() : null };
    }
    _getQueryParams(e5) {
      null != e5?.renderingRule && "string" != typeof e5.renderingRule && (e5.renderingRule = this._getRenderingRuleString(e5.renderingRule));
      const { raster: t6, viewId: i12 } = this;
      return { raster: t6, viewId: i12, f: "json", ...e5, ...this.customParameters };
    }
    _getRequestOptions(e5) {
      return { ...e5, query: { ...e5?.query, ...this.customParameters } };
    }
    _decodePixelBlock(e5, t6, i12) {
      return this._rasterJobHandler ? this._rasterJobHandler.decode({ data: e5, options: t6 }) : R(e5, t6, i12);
    }
    async _getRasterFunctionInfos(e5) {
      const t6 = this.sourceJSON.rasterFunctionInfos;
      if (this.loaded) return t6;
      if (t6 && this.version >= 10.3) {
        if (1 === t6.length && "none" === t6[0].name.toLowerCase()) return t6;
        const r3 = await H(Ge(this.parsedUrl) + "/rasterFunctionInfos", { query: this._getQueryParams(), signal: e5 });
        return r3.data?.rasterFunctionInfos;
      }
      return null;
    }
    _canRequestImageElement(e5) {
      return !this.pixelFilter && (!e5 || e5.includes("png"));
    }
    async _requestArrayBuffer(e5) {
      const { imageProps: t6, requestAsImageElement: r3, returnImageBitmap: n11, signal: a10 } = e5;
      if (r3 && this._canRequestImageElement(t6.format)) {
        const r4 = `${Ge(this.parsedUrl)}/exportImage`, { data: s13 } = await H(r4, { responseType: n11 ? "blob" : "image", query: this._getQueryParams({ f: "image", ...this.refreshParameters, ...e5.imageServiceParameters }), signal: a10 });
        if (s13 instanceof Blob) {
          return { imageBitmap: await t2(s13, r4, a10), params: t6 };
        }
        return { imageOrCanvasElement: s13, params: t6 };
      }
      const o6 = this._initJobHandler(), l16 = H(Ge(this.parsedUrl) + "/exportImage", { responseType: "array-buffer", query: this._getQueryParams({ f: "image", ...e5.imageServiceParameters }), signal: a10 }), u9 = (await Promise.all([l16, o6]))[0].data, p19 = t6.format || "jpgpng";
      let m12 = p19;
      if ("bsq" !== m12 && "bip" !== m12 && (m12 = L2(u9)), !m12) throw new s("imagery-layer:fetch-image", "unsupported format signature " + String.fromCharCode.apply(null, new Uint8Array(u9)));
      const c13 = { signal: a10 }, h4 = "gif" === p19 || "bmp" === p19 || p19.includes("png") && ("png" === m12 || "jpg" === m12) ? R(u9, { useCanvas: true, ...t6 }, c13) : this._decodePixelBlock(u9, { width: t6.width, height: t6.height, planes: null, pixelType: null, noDataValue: null, format: p19 }, c13);
      return { pixelData: { pixelBlock: await h4, extent: t6.extent }, params: t6 };
    }
    _generateRasterInfo(e5, t6) {
      return this.generateRasterInfo(e5, t6).catch(() => null);
    }
    _isValidCustomizedMosaicRule(e5) {
      return e5 && JSON.stringify(e5.toJSON()) !== JSON.stringify(this.defaultMosaicRule?.toJSON());
    }
    _updateMultidimensionalDefinition(e5) {
      if (this._isValidCustomizedMosaicRule(this.mosaicRule)) return;
      let t6 = b4(e5, { multidimensionalSubset: this.multidimensionalSubset });
      if (null != t6 && t6.length > 0) {
        this.mosaicRule = this.mosaicRule || new y2();
        const e6 = this.mosaicRule.multidimensionalDefinition;
        !this.sourceJSON.defaultVariableName && this.rasterFunction && "none" !== this.rasterFunction.functionName?.toLowerCase() && t6.forEach((e7) => e7.variableName = ""), t6 = t6.filter(({ variableName: e7, dimensionName: t7 }) => e7 && "*" !== e7 || t7), !e6?.length && t6.length && (this.mosaicRule.multidimensionalDefinition = t6);
      }
    }
    _processVisibleRastersResponse(e5, i12) {
      i12 = i12 || {};
      const r3 = e5.value, { templateRRFunctionNames: s13, showNoDataRecords: n11, returnDomainValues: a10, templateFields: o6 } = i12, l16 = e5.processedValues;
      let u9 = e5.catalogItems?.features, p19 = e5.properties?.Values?.map((e6) => e6.replaceAll(/ /gi, ", ")) || [];
      const m12 = this.objectIdField || "ObjectId", c13 = "string" == typeof r3 && r3.toLowerCase().includes("nodata"), h4 = [];
      if (r3 && !u9 && (!c13 || n11)) {
        const e6 = {};
        e6[m12] = 0;
        p19 = [r3], u9 = [new _2({ geometry: this.fullExtent, attributes: e6 })], this.multidimensionalInfo && "raster-dataset" === this.sourceType && V2(this.rasterFields, e6, i12.effectiveMultidimensionalDefinition);
      }
      if (!u9) return [];
      this._updateResponseFieldNames(u9, o6), c13 && !n11 && (u9 = []);
      const { itemPixelValue: d8, servicePixelValue: f11 } = i6, g4 = this.rasterFields.some((e6) => e6.name === d8), y10 = this.graphicOrigin;
      for (let t6 = 0; t6 < u9.length; t6++) {
        const e6 = u9[t6];
        if (null != r3) {
          const i13 = p19[t6], a11 = this.rasterFunction && l16 && l16.length > 0 && s13 && s13.length > 0 && s13.includes(this.rasterFunction.functionName) ? l16[s13.indexOf(this.rasterFunction.functionName)] : r3;
          if ("nodata" === i13.toLowerCase() && !n11) continue;
          g4 && (e6.attributes[d8] = i13), e6.attributes[f11] = a11, this._updateFeatureWithMagDirValues(e6, i13);
          const o7 = this.fields && this.fields.length > 0;
          let u10 = this.rasterFunction && null != this.serviceRasterInfo.attributeTable ? o7 ? i13 : r3 : a11;
          this.rasterFunction || (u10 = o7 ? i13 : r3), this._updateFeatureWithRasterAttributeTableValues(e6, u10);
        }
        if (e6.sourceLayer = e6.layer = this, e6.origin = y10, a10 && this._updateFeatureWithDomainValues(e6), s13 && l16 && s13.length === l16.length) for (let t7 = 0; t7 < s13.length; t7++) {
          const i13 = `${i6.servicePixelValue}.${s13[t7]}`;
          e6.attributes[i13] = l16[t7];
        }
        h4.push(u9[t6]);
      }
      return h4;
    }
    _processMultidimensionalIntersection(e5, t6, i12) {
      const { multidimensionalSubset: r3 } = this;
      if (!r3) return { isOutSide: false, timeExtent: t6, mosaicRule: i12 = this._combineMosaicRuleWithTimeExtent(i12, t6) };
      if (r3) {
        const { isOutside: i13, intersection: s13 } = f7(r3, { geometry: e5, timeExtent: t6 });
        if (i13) return { isOutSide: true, timeExtent: null, mosaicRule: null };
        null != s13?.timeExtent && (t6 = s13.timeExtent);
      }
      if (i12 = this._combineMosaicRuleWithTimeExtent(i12, t6), i12?.multidimensionalDefinition) {
        const { isOutside: e6 } = f7(r3, { multidimensionalDefinition: i12.multidimensionalDefinition });
        if (e6) return { isOutSide: true, timeExtent: null, mosaicRule: null };
      }
      return { isOutSide: false, timeExtent: t6, mosaicRule: i12 };
    }
    _updateFeatureWithRasterAttributeTableValues(e5, t6) {
      const i12 = this.rasterInfo.attributeTable || this.serviceRasterInfo.attributeTable;
      if (null == i12) return;
      const { features: r3, fields: s13 } = i12, n11 = s13.map((e6) => e6.name).find((e6) => "value" === e6.toLowerCase());
      if (!n11) return;
      const a10 = r3.filter((e6) => e6.attributes[n11] === (null != t6 ? parseInt(t6, 10) : null));
      a10 && a10[0] && s13.forEach((t7) => {
        const i13 = a5 + t7.name;
        e5.attributes[i13] = a10[0].attributes[t7.name];
      });
    }
    _updateFeatureWithMagDirValues(e5, t6) {
      if (!this._isVectorDataSet()) return;
      const i12 = t6.split(/,\s*/).map((e6) => parseFloat(e6)), r3 = i12.map((e6) => [e6]), s13 = i12.map((e6) => ({ minValue: e6, maxValue: e6, noDataValue: null })), n11 = new c({ height: 1, width: 1, pixelType: "f32", pixels: r3, statistics: s13 });
      null != this.pixelFilter && this.pixelFilter({ pixelBlock: n11, extent: new z(0, 0, 0, 0, this.spatialReference) });
      const a10 = "esriImageServiceDataTypeVector-MagDir" === this.serviceDataType ? [n11.pixels[0][0], n11.pixels[1][0]] : l8([n11.pixels[0][0], n11.pixels[1][0]]);
      e5.attributes[i6.magnitude] = a10[0], e5.attributes[i6.direction] = a10[1];
    }
    _updateFeatureWithDomainValues(e5) {
      const t6 = this.fields && this.fields.filter((e6) => e6.domain && "coded-value" === e6.domain.type);
      null != t6 && t6.forEach((t7) => {
        const i12 = e5.attributes[t7.name];
        if (null != i12) {
          const r3 = t7.domain.codedValues.find((e6) => e6.code === i12);
          r3 && (e5.attributes[t7.name] = r3.name);
        }
      });
    }
    _updateResponseFieldNames(e5, t6) {
      if (!t6 || t6.length < 1) return;
      const i12 = this.fieldsIndex;
      null != i12 && e5.forEach((e6) => {
        if (e6?.attributes) for (const r3 of t6) {
          const t7 = i12.get(r3)?.name;
          t7 && t7 !== r3 && (e6.attributes[r3] = e6.attributes[t7], delete e6.attributes[t7]);
        }
      });
    }
    _getRenderingRuleString(e5) {
      if (e5) {
        let t6 = e5.toJSON();
        return t6 = t6.rasterFunctionDefinition ?? t6, (t6.thumbnail || t6.thumbnailEx) && (t6.thumbnail = t6.thumbnailEx = null), JSON.stringify(t6);
      }
      return null;
    }
    _hasRasterFunction(e5) {
      return null != e5?.functionName && "none" !== e5.functionName.toLowerCase();
    }
    _updateRenderingRulesFunctionName(e5, t6) {
      if (!e5 || e5.length < 1) return;
      if ("Raw" === e5) return e5.replace("Raw", "None");
      const i12 = e5.toLowerCase().replaceAll(/ /gi, "_");
      return t6.has(i12) ? t6.get(i12) : e5;
    }
    _isRFTJson(e5) {
      return e5?.name && e5.arguments && e5.function && e5.hasOwnProperty("functionType");
    }
    _isVectorDataSet() {
      return "esriImageServiceDataTypeVector-UV" === this.serviceDataType || "esriImageServiceDataTypeVector-MagDir" === this.serviceDataType;
    }
    _applyMosaicAndRenderingRules(e5) {
      const { raster: t6, mosaicRule: i12, rasterFunction: r3 } = this;
      r3 && null == e5.rasterFunction && (e5.rasterFunction = r3), i12 && null == e5.mosaicRule && (e5.mosaicRule = i12), t6 && null == e5.raster && (e5.raster = t6);
    }
    async _updateCurrentRasterInfo(e5) {
      if (this.renderer || this.symbolizer) {
        const t6 = await this._generateRasterInfo(this.rasterFunction, { signal: e5 });
        t6 && (this.rasterInfo = t6);
      }
    }
    _applyMosaicRule(e5) {
      const { raster: t6, mosaicRule: i12 } = this;
      i12 && null == e5.mosaicRule && (e5.mosaicRule = i12), t6 && null == e5.raster && (e5.raster = t6);
    }
    _readCapabilities(e5) {
      const t6 = e5.capabilities ? e5.capabilities.toLowerCase().split(",").map((e6) => e6.trim()) : ["image", "catalog"], { currentVersion: i12, maxRecordCount: r3 } = e5, s13 = t6.includes("image"), n11 = "esriImageServiceDataTypeElevation" === e5.serviceDataType, a10 = !(!e5.spatialReference && !e5.extent?.spatialReference), o6 = t6.includes("edit"), l16 = t6.includes("mensuration") && a10, u9 = null == e5.mensurationCapabilities ? [] : e5.mensurationCapabilities.toLowerCase().split(",").map((e6) => e6.trim()), p19 = l16 && u9.includes("basic"), m12 = this._isMosaicDataset(e5) && t6.includes("catalog"), c13 = t6.includes("download"), h4 = i12 >= 10.7 && n11 || i12 >= 11.4 && (n11 || l16 && u9.includes("3d")), d8 = m12 && e5.fields && e5.fields.length > 0, f11 = d8 && e5.supportsAdvancedQueries ? e5.advancedQueryCapabilities : void 0;
      return { data: { supportsAttachment: false }, operations: { supportsComputeHistograms: s13, supportsExportImage: s13, supportsIdentify: s13, supportsImageToMap: i12 >= 11.2 && m12, supportsImageToMapMultiray: i12 >= 11.2 && m12, supportsMapToImage: i12 >= 11.2 && m12, supportsFindImages: i12 >= 11.2 && m12, supportsGetImageUrl: i12 >= 11.3 && c13, supportsMeasure: l16, supportsMeasureFromImage: i12 >= 11.2, supportsDownload: c13, supportsQuery: d8, supportsGetSamples: i12 >= 10.2 && s13, supportsProject: i12 >= 10.3 && s13, supportsComputeStatisticsHistograms: i12 >= 10.4 && s13, supportsQueryBoundary: i12 >= 10.6 && s13, supportsCalculateVolume: h4, supportsComputePixelLocation: i12 >= 10.7 && m12, supportsComputeAngles: i12 >= 10.91, supportsQueryGPSInfo: i12 >= 11.2 && m12, supportsAdd: o6, supportsDelete: o6, supportsEditing: o6, supportsUpdate: o6, supportsCalculate: false, supportsTruncate: false, supportsValidateSql: false, supportsChangeTracking: false, supportsQueryAttachments: false, supportsResizeAttachments: false, supportsSync: false, supportsExceedsLimitStatistics: false, supportsQueryAnalytics: false, supportsQueryBins: false, supportsQueryPivot: false, supportsQueryTopFeatures: false, supportsAsyncConvert3D: false }, query: { maxRecordCount: r3, maxRecordCountFactor: void 0, maxUniqueIDCount: void 0, supportsStatistics: !!f11?.supportsStatistics, supportsOrderBy: !!f11?.supportsOrderBy, supportsDistinct: !!f11?.supportsDistinct, supportsPagination: !!f11?.supportsPagination, supportsPaginationOnAggregatedQueries: !!f11?.supportsPaginationOnAggregatedQueries, supportsStandardizedQueriesOnly: !!f11?.useStandardizedQueries, supportsPercentileStatistics: !!f11?.supportsPercentileStatistics, supportsCentroid: !!f11?.supportsReturningGeometryCentroid, supportsCentroidOnDegeneratedQuantizedGeometry: false, supportsCurrentUser: false, supportsDegeneratedQuantizedGeometry: false, supportsDistance: !!f11?.supportsQueryWithDistance, supportsExtent: !!f11?.supportsReturningQueryExtent, supportsGeometryProperties: !!f11?.supportsReturningGeometryProperties, supportsHavingClause: !!f11?.supportsHavingClause, supportsQuantization: false, supportsQuantizationEditMode: false, supportsQueryGeometry: false, supportsResultType: false, supportsReturnMesh: false, supportsMaxRecordCountFactor: false, supportsSqlExpression: f11?.supportsSqlExpression ?? !!f11, supportsTopFeaturesQuery: false, supportsQueryByAnonymous: false, supportsQueryByOthers: false, supportsHistoricMoment: false, supportsFormatPBF: false, supportsDisjointSpatialRelationship: false, supportsCacheHint: false, supportsSpatialAggregationStatistics: false, supportedSpatialAggregationStatistics: { envelope: false, centroid: false, convexHull: false }, supportsDefaultSpatialReference: !!f11?.supportsDefaultSR, supportsFullTextSearch: false, supportsCompactGeometry: false, standardMaxRecordCount: void 0, tileMaxRecordCount: void 0, supportsTrueCurve: false }, mensuration: { supportsDistanceAndAngle: p19, supportsAreaAndPerimeter: p19, supportsPointOrCentroid: p19, supportsHeightFromBaseAndTop: l16 && u9.includes("base-top height"), supportsHeightFromBaseAndTopShadow: l16 && u9.includes("base-top shadow height"), supportsHeightFromTopAndTopShadow: l16 && u9.includes("top-top shadow height"), supports3D: l16 && u9.includes("3d") } };
    }
  };
  function Ge(e5) {
    return e5?.path ?? "";
  }
  return __decorate([m2({ clonable: false })], He2.prototype, "_functionRasterInfos", void 0), __decorate([m2({ readOnly: true })], He2.prototype, "_serviceSupportsMosaicRule", void 0), __decorate([o2("_serviceSupportsMosaicRule", ["currentVersion", "fields"])], He2.prototype, "readServiceSupportsMosaicRule", null), __decorate([m2({ readOnly: true })], He2.prototype, "_rasterFunctionNamesIndex", null), __decorate([m2()], He2.prototype, "adjustAspectRatio", void 0), __decorate([m2({ type: [x], json: { write: true } })], He2.prototype, "bandIds", void 0), __decorate([o2("bandIds")], He2.prototype, "readBandIds", null), __decorate([m2({ readOnly: true, json: { read: false } })], He2.prototype, "capabilities", void 0), __decorate([o2("service", "capabilities", ["capabilities", "currentVersion", "serviceDataType"])], He2.prototype, "readCapabilities", null), __decorate([m2({ type: Number })], He2.prototype, "compressionQuality", void 0), __decorate([r("compressionQuality")], He2.prototype, "writeCompressionQuality", null), __decorate([m2({ type: Number })], He2.prototype, "compressionTolerance", void 0), __decorate([r("compressionTolerance")], He2.prototype, "writeCompressionTolerance", null), __decorate([m2({ json: { read: { source: "copyrightText" } } })], He2.prototype, "copyright", void 0), __decorate([m2({ readOnly: true, dependsOn: ["_serviceSupportsMosaicRule"] })], He2.prototype, "defaultMosaicRule", void 0), __decorate([o2("defaultMosaicRule", ["defaultMosaicMethod"])], He2.prototype, "readDefaultMosaicRule", null), __decorate([m2({ type: String, json: { name: "layerDefinition.definitionExpression", write: { enabled: true, allowNull: true } } })], He2.prototype, "definitionExpression", void 0), __decorate([m2({ readOnly: true, constructOnly: true })], He2.prototype, "exportImageServiceParameters", void 0), __decorate([m2()], He2.prototype, "rasterInfo", void 0), __decorate([m2({ readOnly: true, type: [m3] })], He2.prototype, "fields", void 0), __decorate([m2({ readOnly: true })], He2.prototype, "fieldsIndex", null), __decorate([m2({ type: ["png", "png8", "png24", "png32", "jpg", "bmp", "gif", "jpgpng", "lerc", "tiff", "bip", "bsq"], json: { write: true } })], He2.prototype, "format", null), __decorate([o2("service", "format", ["serviceDataType"])], He2.prototype, "readFormat", null), __decorate([m2({ type: z })], He2.prototype, "fullExtent", void 0), __decorate([m2({ readOnly: true })], He2.prototype, "hasMultidimensions", void 0), __decorate([m2({ json: { read: { source: "maxImageHeight" } } })], He2.prototype, "imageMaxHeight", void 0), __decorate([m2({ json: { read: { source: "maxImageWidth" } } })], He2.prototype, "imageMaxWidth", void 0), __decorate([m2({ type: String, json: { type: a4.jsonValues, read: a4.read, write: a4.write } })], He2.prototype, "interpolation", void 0), __decorate([m2()], He2.prototype, "minScale", void 0), __decorate([o2("service", "minScale")], He2.prototype, "readMinScale", null), __decorate([m2()], He2.prototype, "maxScale", void 0), __decorate([o2("service", "maxScale")], He2.prototype, "readMaxScale", null), __decorate([m2({ type: y2 })], He2.prototype, "mosaicRule", null), __decorate([o2("mosaicRule", ["mosaicRule", "defaultMosaicMethod"])], He2.prototype, "readMosaicRule", null), __decorate([r("mosaicRule")], He2.prototype, "writeMosaicRule", null), __decorate([m2()], He2.prototype, "multidimensionalInfo", void 0), __decorate([m2({ type: u4, json: { write: true } })], He2.prototype, "multidimensionalSubset", void 0), __decorate([m2({ json: { type: x } })], He2.prototype, "noData", void 0), __decorate([r("noData")], He2.prototype, "writeNoData", null), __decorate([m2({ type: String, json: { type: i4.jsonValues, read: i4.read, write: i4.write } })], He2.prototype, "noDataInterpretation", void 0), __decorate([m2({ type: String, readOnly: true, json: { read: { source: ["fields"] } } })], He2.prototype, "objectIdField", void 0), __decorate([o2("objectIdField")], He2.prototype, "readObjectIdField", null), __decorate([m2({ readOnly: true })], He2.prototype, "geometryType", void 0), __decorate([m2({})], He2.prototype, "typeIdField", void 0), __decorate([m2({})], He2.prototype, "types", void 0), __decorate([m2({ readOnly: true })], He2.prototype, "parsedUrl", null), __decorate([m2({ type: Function })], He2.prototype, "pixelFilter", void 0), __decorate([m2()], He2.prototype, "raster", void 0), __decorate([m2({ readOnly: true })], He2.prototype, "sourceType", void 0), __decorate([o2("sourceType", ["serviceSourceType", "fields"])], He2.prototype, "readSourceType", null), __decorate([m2()], He2.prototype, "viewId", void 0), __decorate([m2()], He2.prototype, "renderer", null), __decorate([m2({ types: l10, json: { name: "layerDefinition.drawingInfo.renderer", origins: { "web-scene": { types: p4, name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy: (e5) => ({ enabled: e5 && "vector-field" !== e5.type }) } } } } })], He2.prototype, "internalRenderer", null), __decorate([o2("internalRenderer")], He2.prototype, "readRenderer", null), __decorate([r("internalRenderer")], He2.prototype, "writeRenderer", null), __decorate([m2({ clonable: false })], He2.prototype, "symbolizer", void 0), __decorate([m2(w)], He2.prototype, "opacity", void 0), __decorate([m2({ readOnly: true })], He2.prototype, "rasterFields", null), __decorate([m2({ constructOnly: true })], He2.prototype, "rasterFunctionInfos", void 0), __decorate([m2({ type: N, json: { name: "renderingRule" } })], He2.prototype, "rasterFunction", null), __decorate([o2("rasterFunction", ["renderingRule", "rasterFunctionInfos"])], He2.prototype, "readRasterFunction", null), __decorate([m2({ readOnly: true })], He2.prototype, "serviceDataType", void 0), __decorate([m2({ readOnly: true, type: f2 })], He2.prototype, "spatialReference", void 0), __decorate([o2("spatialReference", ["spatialReference", "extent"])], He2.prototype, "readSpatialReference", null), __decorate([m2({ type: n2.apiValues, json: { read: n2.read, type: n2.jsonValues } })], He2.prototype, "pixelType", void 0), __decorate([r("pixelType")], He2.prototype, "writePixelType", null), __decorate([m2({ constructOnly: true, type: m5 })], He2.prototype, "serviceRasterInfo", void 0), __decorate([m2()], He2.prototype, "sourceJSON", void 0), __decorate([m2(y)], He2.prototype, "url", void 0), __decorate([m2({ readOnly: true })], He2.prototype, "version", void 0), __decorate([o2("version", ["currentVersion", "fields", "timeInfo"])], He2.prototype, "readVersion", null), He2 = __decorate([a3("esri.layers.mixins.ArcGISImageService")], He2), He2;
};

// node_modules/@arcgis/core/layers/ImageryLayer.js
var $3 = class extends p(l6(t(b3(j(o5(He(i7(f3(s6(l5(l2(l3(b5))))))))))))) {
  constructor(...e5) {
    super(...e5), this.graphicOrigin = new s11(this), this.isReference = null, this.operationalLayerType = "ArcGISImageServiceLayer", this.popupEnabled = true, this.popupTemplate = null, this.screenSizePerspectiveEnabled = true, this.type = "imagery", this._debouncedSaveOperations = L(async (e6, r3, t6) => {
      const { save: o6, saveAs: i12 } = await import("./imageryUtils-K5KFGZOF.js");
      switch (e6) {
        case 0:
          return o6(this, r3);
        case 1:
          return i12(this, t6, r3);
      }
    });
  }
  normalizeCtorArgs(e5, r3) {
    return "string" == typeof e5 ? { url: e5, ...r3 } : e5;
  }
  load(e5) {
    const r3 = null != e5 ? e5.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Image Service"] }, e5).catch(f).then(() => this._fetchService(r3))), Promise.resolve(this);
  }
  set elevationInfo(e5) {
    "relative-to-scene" !== e5?.mode && this._set("elevationInfo", e5), this._validateElevationInfo(e5);
  }
  get legendEnabled() {
    return !this._isPreviewLayer && (this._get("legendEnabled") ?? true);
  }
  set legendEnabled(e5) {
    this._set("legendEnabled", e5);
  }
  get listMode() {
    return this._isPreviewLayer ? "hide" : this._get("listMode");
  }
  set listMode(e5) {
    this._set("listMode", e5);
  }
  writeOperationalLayerType(e5, r3, t6) {
    const o6 = "vector-field" === this.renderer?.type;
    r3[t6] = o6 ? "ArcGISImageServiceVectorLayer" : "ArcGISImageServiceLayer";
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  get _isPreviewLayer() {
    return !(!this.raster || !this.url?.toLowerCase().includes("/rasterrendering/imageserver"));
  }
  createPopupTemplate(e5) {
    const { rasterFields: r3 } = this, t6 = /* @__PURE__ */ new Set(), o6 = i6.itemPixelValue.toLowerCase(), i12 = "raster-dataset" === this.sourceType, s13 = n4.toLowerCase(), a10 = `${i6.servicePixelValue.toLowerCase()}.`;
    for (const l16 of r3) {
      const e6 = l16.name.toLowerCase();
      e6 === o6 || e6.startsWith(a10) || i12 && e6.startsWith(s13) || t6.add(l16.name);
    }
    const p19 = d({ fields: r3, title: this.title }, { ...e5, visibleFieldNames: t6 }), { rasterInfo: n11 } = this;
    return p19?.fieldInfos && n11 && b2(p19.fieldInfos, n11), p19;
  }
  queryFeatures(e5, r3) {
    return this.queryRasters(e5, r3).then((e6) => {
      if (e6?.features) for (const r4 of e6.features) r4.layer = r4.sourceLayer = this, r4.origin = this.graphicOrigin;
      return e6;
    });
  }
  queryFeatureCount(e5, r3) {
    return this.queryRasterCount(e5, r3);
  }
  redraw() {
    this.emit("redraw");
  }
  async save(e5) {
    return this._debouncedSaveOperations(0, e5);
  }
  async saveAs(e5, r3) {
    return this._debouncedSaveOperations(1, r3, e5);
  }
  serviceSupportsSpatialReference(e5) {
    return t3(this, e5);
  }
  write(e5, r3) {
    if (!this._isPreviewLayer) return super.write(e5, r3);
    if (r3?.messages) {
      const e6 = `${r3.origin}/${r3.layerContainerType || "operational-layers"}`;
      r3.messages.push(new s("layer:unsupported", `Imagery preview layer (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${e6}'`, { layer: this }));
    }
    return null;
  }
  _validateElevationInfo(e5) {
    j2(i.getLogger(this), $2("Imagery layers", "relative-to-scene", e5)), j2(i.getLogger(this), R2("Imagery layers", e5));
  }
};
__decorate([m2({ type: c3, value: null, json: { name: "layerDefinition.elevationInfo", write: true, origins: { "portal-item": { read: false, write: false }, "web-map": { read: false, write: false } } } })], $3.prototype, "elevationInfo", null), __decorate([m2({ readOnly: true, clonable: false })], $3.prototype, "graphicOrigin", void 0), __decorate([m2(d3)], $3.prototype, "legendEnabled", null), __decorate([m2({ type: ["show", "hide"] })], $3.prototype, "listMode", null), __decorate([m2({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], $3.prototype, "isReference", void 0), __decorate([m2({ type: ["ArcGISImageServiceLayer"], json: { origins: { "web-map": { type: ["ArcGISImageServiceLayer", "ArcGISImageServiceVectorLayer"], read: false, write: { target: "layerType", ignoreOrigin: true } } } } })], $3.prototype, "operationalLayerType", void 0), __decorate([r("web-map", "operationalLayerType")], $3.prototype, "writeOperationalLayerType", null), __decorate([m2(l9)], $3.prototype, "popupEnabled", void 0), __decorate([m2({ type: q, json: { read: { source: "popupInfo" }, write: { target: "popupInfo" } } })], $3.prototype, "popupTemplate", void 0), __decorate([m2({ readOnly: true })], $3.prototype, "defaultPopupTemplate", null), __decorate([m2(s10)], $3.prototype, "screenSizePerspectiveEnabled", void 0), __decorate([m2({ readOnly: true, json: { read: false } })], $3.prototype, "type", void 0), __decorate([m2({ readOnly: true })], $3.prototype, "_isPreviewLayer", null), $3 = __decorate([a3("esri.layers.ImageryLayer")], $3);
var F2 = $3;
export {
  F2 as default
};
//# sourceMappingURL=ImageryLayer-RIK4T4FJ.js.map
