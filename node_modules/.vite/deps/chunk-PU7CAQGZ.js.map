{
  "version": 3,
  "sources": ["../../@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/MultipassGeometryTest.glsl.js", "../../@arcgis/core/chunks/LineCallout.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.34/esri/copyright.txt for details.\n*/\nimport{ReadDepth as e}from\"../output/ReadDepth.glsl.js\";import{glsl as t}from\"../../shaderModules/glsl.js\";import{Texture2DBindUniform as o}from\"../../shaderModules/Texture2DBindUniform.js\";function r(r){r.include(e),r.uniforms.add(new o(\"geometryDepthTexture\",e=>e.geometryDepth?.attachment)),r.code.add(t`bool geometryDepthTest(vec2 pos, float elementDepth) {\nfloat geometryDepth = linearDepthFromTexture(geometryDepthTexture, pos);\nreturn (elementDepth < (geometryDepth - 1.0));\n}`)}export{r as multipassGeometryTest};\n", "/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.34/esri/copyright.txt for details.\n*/\nimport{set as e}from\"../core/libs/gl-matrix-2/math/vec2.js\";import{create as i}from\"../core/libs/gl-matrix-2/factories/vec2f64.js\";import{ZEROS as r}from\"../core/libs/gl-matrix-2/factories/vec4f64.js\";import{RejectBySlice as o}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{AlignPixel as t}from\"../views/3d/webgl-engine/core/shaderLibrary/hud/AlignPixel.glsl.js\";import{HUD as n}from\"../views/3d/webgl-engine/core/shaderLibrary/hud/HUD.glsl.js\";import{HUDVisibility as a}from\"../views/3d/webgl-engine/core/shaderLibrary/hud/HUDVisibility.glsl.js\";import{multipassGeometryTest as l}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassGeometryTest.glsl.js\";import{addScreenSizePerspectiveAlignment as d}from\"../views/3d/webgl-engine/core/shaderLibrary/util/ScreenSizePerspective.glsl.js\";import{Float2BindUniform as s}from\"../views/3d/webgl-engine/core/shaderModules/Float2BindUniform.js\";import{Float2PassUniform as c}from\"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js\";import{Float4BindUniform as p}from\"../views/3d/webgl-engine/core/shaderModules/Float4BindUniform.js\";import{Float4PassUniform as g}from\"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";import{FloatPassUniform as f}from\"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";import{If as v,glsl as S}from\"../views/3d/webgl-engine/core/shaderModules/glsl.js\";import{ShaderBuilder as m}from\"../views/webgl/ShaderBuilder.js\";function h(i){const h=new m,{vertex:u,fragment:b}=h,{terrainDepthTest:z}=i;return u.include(t),h.include(n,i),h.vertex.include(o,i),h.attributes.add(\"uv0\",\"vec2\"),u.uniforms.add(new p(\"viewport\",e=>e.camera.fullViewport),new f(\"lineSize\",(e,i)=>e.size>0?Math.max(1,e.size)*i.camera.pixelRatio:0),new s(\"pixelToNDC\",i=>e(w,2/i.camera.fullViewport[2],2/i.camera.fullViewport[3])),new f(\"borderSize\",(e,i)=>e.borderColor?i.camera.pixelRatio:0),new c(\"screenOffset\",(i,r)=>e(w,i.horizontalScreenOffset*r.camera.pixelRatio,0))),h.varyings.add(\"coverageSampling\",\"vec4\"),h.varyings.add(\"lineSizes\",\"vec2\"),z&&h.varyings.add(\"depth\",\"float\"),i.occlusionTestEnabled&&h.include(a),i.hasScreenSizePerspective&&d(u),u.main.add(S`\n    ProjectHUDAux projectAux;\n    vec4 endPoint = projectPositionHUD(projectAux);\n\n    vec3 vpos = projectAux.posModel;\n    if (rejectBySlice(vpos)) {\n      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n      return;\n    }\n    ${v(i.occlusionTestEnabled,S`if (!testHUDVisibility(endPoint)) {\n             gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n             return;\n           }`)}\n\n    ${i.hasScreenSizePerspective?S`vec3 perspectiveFactor = screenSizePerspectiveScaleFactor(projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\n               vec2 screenOffsetScaled = applyScreenSizePerspectiveScaleFactorVec2(screenOffset, perspectiveFactor);`:\"vec2 screenOffsetScaled = screenOffset;\"}\n    // Add view dependent polygon offset to get exact same original starting point. This is mostly used to get the\n    // correct depth value\n    vec3 posView = (view * vec4(position, 1.0)).xyz;\n    ${v(z,\"depth = posView.z;\")}\n\n    applyHUDViewDependentPolygonOffset(centerOffsetAndDistance.w, projectAux.absCosAngle, posView);\n    vec4 startPoint = proj * vec4(posView, 1.0);\n\n    // Apply screen offset to both start and end point\n    vec2 screenOffsetNorm = screenOffsetScaled * 2.0 / viewport.zw;\n    startPoint.xy += screenOffsetNorm * startPoint.w;\n    endPoint.xy += screenOffsetNorm * endPoint.w;\n\n    // Align start and end to pixel origin\n    vec4 startAligned = alignToPixelOrigin(startPoint, viewport.zw);\n    vec4 endAligned = alignToPixelOrigin(endPoint, viewport.zw);\n    ${v(i.hudDepth,i.hudDepthAlignStart?\"endAligned = vec4(endAligned.xy / endAligned.w * startAligned.w, startAligned.zw);\":\"startAligned = vec4(startAligned.xy / startAligned.w * endAligned.w, endAligned.zw);\")}\n    vec4 projectedPosition = mix(startAligned, endAligned, uv0.y);\n\n    // The direction of the line in screen space\n    vec2 screenSpaceDirection = normalize(endAligned.xy / endAligned.w - startAligned.xy / startAligned.w);\n    vec2 perpendicularScreenSpaceDirection = vec2(screenSpaceDirection.y, -screenSpaceDirection.x);\n    ${i.hasScreenSizePerspective?S`float lineSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(lineSize, perspectiveFactor);\n               float borderSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(borderSize, perspectiveFactor);`:S`float lineSizeScaled = lineSize;\n               float borderSizeScaled = borderSize;`}\n    float halfPixelSize = lineSizeScaled * 0.5;\n\n    // Compute full ndc offset, adding 1px padding for doing anti-aliasing and the border size\n    float padding = 1.0 + borderSizeScaled;\n    vec2 ndcOffset = (-halfPixelSize - padding + uv0.x * (lineSizeScaled + padding + padding)) * pixelToNDC;\n\n    // Offset x/y from the center of the line in screen space\n    projectedPosition.xy += perpendicularScreenSpaceDirection * ndcOffset * projectedPosition.w;\n\n    // Compute a coverage varying which we can use in the fragment shader to determine\n    // how much a pixel is actually covered by the line (i.e. to anti alias the line).\n    // This works by computing two coordinates that can be linearly interpolated and then\n    // subtracted to find out how far away from the line edge we are.\n    float edgeDirection = (uv0.x * 2.0 - 1.0);\n\n    float halfBorderSize = 0.5 * borderSizeScaled;\n    float halfPixelSizeAndBorder = halfPixelSize + halfBorderSize;\n    float outerEdgeCoverageSampler = edgeDirection * (halfPixelSizeAndBorder + halfBorderSize + 1.0);\n\n    float isOneSided = float(lineSizeScaled < 2.0 && borderSize < 2.0);\n\n    coverageSampling = vec4(\n      // Edge coordinate\n      outerEdgeCoverageSampler,\n\n      // Border edge coordinate\n      outerEdgeCoverageSampler - halfPixelSizeAndBorder * isOneSided,\n\n      // Line offset\n      halfPixelSize - 0.5,\n\n      // Border offset\n      halfBorderSize - 0.5 + halfPixelSizeAndBorder * (1.0 - isOneSided)\n    );\n\n    lineSizes = vec2(lineSizeScaled, borderSizeScaled);\n    gl_Position = projectedPosition;`),b.uniforms.add(new g(\"uColor\",e=>e.color??r),new g(\"borderColor\",e=>e.borderColor??r)),z&&(b.include(l,i),b.uniforms.add(new s(\"inverseViewport\",e=>e.inverseViewport))),b.main.add(S`\n    ${v(z,\"if( geometryDepthTest(gl_FragCoord.xy * inverseViewport, depth) ){ discard; }\")}\n\n    vec2 coverage = min(1.0 - clamp(abs(coverageSampling.xy) - coverageSampling.zw, 0.0, 1.0), lineSizes);\n\n    float borderAlpha = uColor.a * borderColor.a * coverage.y;\n    float colorAlpha = uColor.a * coverage.x;\n\n    float finalAlpha = mix(borderAlpha, 1.0, colorAlpha);\n    ${v(!i.hudDepth,S`vec3 finalRgb = mix(borderColor.rgb * borderAlpha, uColor.rgb, colorAlpha);\n           fragColor = vec4(finalRgb, finalAlpha);`)}`),h}const w=i(),u=Object.freeze(Object.defineProperty({__proto__:null,build:h},Symbol.toStringTag,{value:\"Module\"}));export{u as L,h as b};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAI8L,SAASA,GAAEA,IAAE;AAAC,EAAAA,GAAE,QAAQC,EAAC,GAAED,GAAE,SAAS,IAAI,IAAIE,GAAE,wBAAuB,CAAAA,OAAGA,GAAE,eAAe,UAAU,CAAC,GAAEF,GAAE,KAAK,IAAI;AAAA;AAAA;AAAA,EAG/S;AAAC;;;ACH+7C,SAAS,EAAEG,IAAE;AAAC,QAAMC,KAAE,IAAI,KAAE,EAAC,QAAOC,IAAE,UAAS,EAAC,IAAED,IAAE,EAAC,kBAAiB,EAAC,IAAED;AAAE,SAAOE,GAAE,QAAQ,CAAC,GAAED,GAAE,QAAQ,GAAED,EAAC,GAAEC,GAAE,OAAO,QAAQ,GAAED,EAAC,GAAEC,GAAE,WAAW,IAAI,OAAM,MAAM,GAAEC,GAAE,SAAS,IAAI,IAAIC,GAAE,YAAW,CAAAA,OAAGA,GAAE,OAAO,YAAY,GAAE,IAAI,EAAE,YAAW,CAACA,IAAEH,OAAIG,GAAE,OAAK,IAAE,KAAK,IAAI,GAAEA,GAAE,IAAI,IAAEH,GAAE,OAAO,aAAW,CAAC,GAAE,IAAI,EAAE,cAAa,CAAAA,OAAG,EAAE,GAAE,IAAEA,GAAE,OAAO,aAAa,CAAC,GAAE,IAAEA,GAAE,OAAO,aAAa,CAAC,CAAC,CAAC,GAAE,IAAI,EAAE,cAAa,CAACG,IAAEH,OAAIG,GAAE,cAAYH,GAAE,OAAO,aAAW,CAAC,GAAE,IAAIG,GAAE,gBAAe,CAACH,IAAEI,OAAI,EAAE,GAAEJ,GAAE,yBAAuBI,GAAE,OAAO,YAAW,CAAC,CAAC,CAAC,GAAEH,GAAE,SAAS,IAAI,oBAAmB,MAAM,GAAEA,GAAE,SAAS,IAAI,aAAY,MAAM,GAAE,KAAGA,GAAE,SAAS,IAAI,SAAQ,OAAO,GAAED,GAAE,wBAAsBC,GAAE,QAAQI,EAAC,GAAEL,GAAE,4BAA0B,EAAEE,EAAC,GAAEA,GAAE,KAAK,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MASxoEG,GAAEL,GAAE,sBAAqB;AAAA;AAAA;AAAA,aAGlB,CAAC;AAAA;AAAA,MAERA,GAAE,2BAAyB;AAAA,wHACqF,yCAAyC;AAAA;AAAA;AAAA;AAAA,MAIzJK,GAAE,GAAE,oBAAoB,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAazBA,GAAEL,GAAE,UAASA,GAAE,qBAAmB,uFAAqF,sFAAsF,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAM9MA,GAAE,2BAAyB;AAAA,sHACmF;AAAA,oDAChE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qCAqCf,GAAE,EAAE,SAAS,IAAI,IAAIG,GAAE,UAAS,CAAAA,OAAGA,GAAE,SAAO,CAAC,GAAE,IAAIA,GAAE,eAAc,CAAAA,OAAGA,GAAE,eAAa,CAAC,CAAC,GAAE,MAAI,EAAE,QAAQC,IAAEJ,EAAC,GAAE,EAAE,SAAS,IAAI,IAAI,EAAE,mBAAkB,CAAAG,OAAGA,GAAE,eAAe,CAAC,IAAG,EAAE,KAAK,IAAI;AAAA,MACrNE,GAAE,GAAE,+EAA+E,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAQpFA,GAAE,CAACL,GAAE,UAAS;AAAA,mDAC+B,CAAC,EAAE,GAAEC;AAAC;AAAC,IAAM,IAAE,EAAE;AAAV,IAAY,IAAE,OAAO,OAAO,OAAO,eAAe,EAAC,WAAU,MAAK,OAAM,EAAC,GAAE,OAAO,aAAY,EAAC,OAAM,SAAQ,CAAC,CAAC;",
  "names": ["r", "a", "e", "i", "h", "u", "e", "r", "n"]
}
