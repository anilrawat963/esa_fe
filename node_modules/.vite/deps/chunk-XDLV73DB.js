import {
  E
} from "./chunk-ARTU4L55.js";
import {
  r as r2
} from "./chunk-EM7Y2JZC.js";
import {
  f,
  h,
  l as l2
} from "./chunk-2OFHDVO5.js";
import {
  r2 as r
} from "./chunk-5EI5H4QX.js";
import {
  s as s2
} from "./chunk-R54Q5TGA.js";
import {
  n as n2
} from "./chunk-45CFSCQX.js";
import {
  C,
  a,
  d,
  k,
  l2 as l,
  u3 as u,
  y
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  A,
  j,
  n
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/views/support/Yield.js
var o = Symbol("Yield");

// node_modules/@arcgis/core/views/support/PromiseQueue.js
var l3 = class {
  constructor() {
    this._tasks = new Array(), this._numPendingTasks = r2(0), this._readyToRun = r2(false);
  }
  get length() {
    return this._tasks.length;
  }
  get updating() {
    return this._numPendingTasks.value > 0;
  }
  get readyToRun() {
    return this._readyToRun.value;
  }
  _updateReadyToRun() {
    this._readyToRun.value = this._tasks.length > 0;
  }
  destroy() {
    this.cancelAll();
  }
  runTask(t) {
    if (0 === this.length) return o;
    for (; !t.done && this._process(t); ) t.madeProgress();
  }
  push(t, e, s3) {
    return this._addTask((r3, o2) => new d2(r3, o2, t, e, s3), Array.prototype.push);
  }
  unshift(t, e, s3) {
    return this._addTask((r3, o2) => new d2(r3, o2, t, e, s3), Array.prototype.unshift);
  }
  pushGenerator(t, e, s3) {
    return this._addTask((r3, o2) => new _(r3, o2, t, e, s3), Array.prototype.push);
  }
  _process(e) {
    if (0 === this._tasks.length) return false;
    const s3 = this._tasks.shift();
    this._updateReadyToRun();
    try {
      if (a(s3.signal)) this._cancelTask(s3, u());
      else switch (s3.type) {
        case 0:
          this._processSimple(s3, e);
          break;
        case 1:
          this._processGenerator(s3, e);
          break;
        case 2:
          this._processIterator(s3, e);
          break;
        default:
          n(s3);
      }
    } catch (a2) {
      s3.reject(a2);
    }
    return true;
  }
  cancelAll() {
    const t = u();
    for (const e of this._tasks) this._cancelTask(e, t);
    this._tasks.length = 0, this._updateReadyToRun();
  }
  _cancelTask(t, e) {
    if (t.abortCallback) {
      const s3 = t.abortCallback(e);
      2 === t.type && t.iterator.return && h2(t.iterator.return()), C(s3) ? s3.then(t.resolve, t.reject) : t.resolve(s3);
    } else 2 === t.type && t.iterator.throw && h2(t.iterator.throw(e)), t.reject(e);
  }
  _onIteratorResult(t, e) {
    e.done ? t.resolve(e.value) : (this._tasks.unshift(t), this._updateReadyToRun());
  }
  _processSimple(t, e) {
    const s3 = t.callback(e);
    C(s3) ? s3.then(t.resolve, t.reject) : t.resolve(s3);
  }
  _processGenerator(t, e) {
    const s3 = t.generatorFunction(e), r3 = new k2(t.resolve, t.reject, s3, t.signal, t.abortCallback);
    this._processIterator(r3, e);
  }
  _processIterator(t, e) {
    const s3 = t.iterator.next(e);
    C(s3) ? s3.then((e2) => this._onIteratorResult(t, e2), t.reject) : this._onIteratorResult(t, s3);
  }
  _addTask(t, e) {
    return new Promise((s3, r3) => {
      const o2 = t(s3, r3);
      e.call(this._tasks, o2), ++this._numPendingTasks.value, this._updateReadyToRun();
    }).finally(() => --this._numPendingTasks.value);
  }
};
function h2(t) {
  C(t) ? t.then(u2, u2) : u2(t);
}
function u2(t) {
  d(t) || t instanceof Error || t instanceof s || null != t && "object" == typeof t && "done" in t && t.done || i.getLogger("esri.layers.support.PromiseQueue").warn("Generator iterator was aborted, but it is not done.");
}
var p = class {
  constructor(t, e, s3 = void 0, r3 = void 0) {
    this.resolve = t, this.reject = e, this.signal = s3, this.abortCallback = r3;
  }
};
var d2 = class extends p {
  constructor(t, e, s3, r3, o2) {
    super(t, e, r3, o2), this.callback = s3, this.type = 0;
  }
};
var _ = class extends p {
  constructor(t, e, s3, r3, o2) {
    super(t, e, r3, o2), this.generatorFunction = s3, this.type = 1;
  }
};
var k2 = class extends p {
  constructor(t, e, s3, r3, o2) {
    super(t, e, r3, o2), this.iterator = s3, this.type = 2;
  }
};

// node_modules/@arcgis/core/views/support/Scheduler.js
function I() {
  return new S();
}
var f2 = { RESOURCE_CONTROLLER_IMMEDIATE: "immediate", RESOURCE_CONTROLLER: "schedule", SLIDE: "slide", STREAM_DATA_LOADER: "stream loader", ELEVATION_QUERY: "elevation query", TERRAIN_SURFACE: "terrain", SURFACE_GEOMETRY_UPDATES: "surface geometry updates", LOD_RENDERER: "LoD renderer", GRAPHICS_CORE: "Graphics3D", I3S_CONTROLLER: "I3S", POINT_CLOUD_LAYER: "point cloud", FEATURE_TILE_FETCHER: "feature fetcher", STREAM_CONTROLLER: "stream controller", OVERLAY: "overlay", OVERLAY_RENDERER: "overlay renderer", STAGE: "stage", GRAPHICS_DECONFLICTOR: "graphics deconflictor", FILTER_VISIBILITY: "Graphics3D filter visibility", SCALE_VISIBILITY: "Graphics3D scale visibility", FRUSTUM_VISIBILITY: "Graphics3D frustum visibility", POINT_OF_INTEREST_FREQUENT: "POI frequent", POINT_OF_INTEREST_INFREQUENT: "POI infrequent", LABELER: "labeler", FEATURE_QUERY_ENGINE: "feature query", FEATURE_TILE_TREE: "feature tile tree", FEATURE_TILE_TREE_ACTIVE: "fast feature tile tree", ELEVATION_ALIGNMENT: "elevation alignment", ELEVATION_ALIGNMENT_SCENE: "elevation alignment scene", TEXT_TEXTURE_ATLAS: "text texture atlas", TEXTURE_UNLOAD: "texture unload", LINE_OF_SIGHT_TOOL: "line of sight tool", LINE_OF_SIGHT_TOOL_INTERACTIVE: "interactive line of sight tool", ELEVATION_PROFILE: "elevation profile", SNAPPING: "snapping", SHADOW_ACCUMULATOR: "shadow accumulator", CLOUDS_GENERATOR: "clouds generator", FLOW_GENERATOR: "flow generator", MAPVIEW_FETCH_QUEUE: "mapview fetch queue", MAPVIEW_LAYERVIEW_UPDATE: "mapview layerview update", MAPVIEW_VECTOR_TILE_PARSING_QUEUE: "mapview vector tile parsing queue", NONE: 0, TEST_PRIO: 1 };
var p2 = 0;
var L = /* @__PURE__ */ new Map([[f2.RESOURCE_CONTROLLER_IMMEDIATE, p2], [f2.RESOURCE_CONTROLLER, 4], [f2.SLIDE, p2], [f2.STREAM_DATA_LOADER, p2], [f2.ELEVATION_QUERY, p2], [f2.TERRAIN_SURFACE, 1], [f2.SURFACE_GEOMETRY_UPDATES, 1], [f2.LOD_RENDERER, 2], [f2.GRAPHICS_CORE, 2], [f2.I3S_CONTROLLER, 2], [f2.POINT_CLOUD_LAYER, 2], [f2.FEATURE_TILE_FETCHER, 2], [f2.STREAM_CONTROLLER, 2], [f2.CLOUDS_GENERATOR, 2], [f2.OVERLAY, 4], [f2.OVERLAY_RENDERER, 4], [f2.STAGE, 4], [f2.GRAPHICS_DECONFLICTOR, 4], [f2.FILTER_VISIBILITY, 4], [f2.SCALE_VISIBILITY, 4], [f2.FRUSTUM_VISIBILITY, 4], [f2.POINT_OF_INTEREST_FREQUENT, 6], [f2.POINT_OF_INTEREST_INFREQUENT, 30], [f2.LABELER, 8], [f2.FEATURE_QUERY_ENGINE, 8], [f2.FEATURE_TILE_TREE, 16], [f2.FEATURE_TILE_TREE_ACTIVE, p2], [f2.ELEVATION_ALIGNMENT, 12], [f2.ELEVATION_ALIGNMENT_SCENE, 14], [f2.TEXT_TEXTURE_ATLAS, 12], [f2.TEXTURE_UNLOAD, 12], [f2.LINE_OF_SIGHT_TOOL, 16], [f2.LINE_OF_SIGHT_TOOL_INTERACTIVE, p2], [f2.SNAPPING, p2], [f2.SHADOW_ACCUMULATOR, 30], [f2.FLOW_GENERATOR, 12], [f2.MAPVIEW_FETCH_QUEUE, p2], [f2.MAPVIEW_LAYERVIEW_UPDATE, 2], [f2.MAPVIEW_VECTOR_TILE_PARSING_QUEUE, p2]]);
function A2(e) {
  return L.has(e) ? L.get(e) : "number" == typeof e ? e : 1;
}
var O = n2(6.5);
var N = n2(1);
var b = n2(30);
var k3 = n2(1e3 / 30);
var P = n2(100);
var U = 0.9;
var S = class {
  get updating() {
    return this._updating.value;
  }
  _updatingChanged() {
    this._updating.value = this._tasks.some((e) => e.needsUpdate);
  }
  constructor() {
    this._updating = r2(true), this._microTaskQueued = false, this._frameNumber = 0, this.performanceInfo = { total: new s2("total"), tasks: /* @__PURE__ */ new Map() }, this._frameTaskTimes = /* @__PURE__ */ new Map(), this._budget = new y2(), this.state = 1, this._tasks = new Array(), this._runQueue = new Array(), this._load = 0, this._forceTask = false, this._debug = false, this._debugHandle = l2(() => E.SCHEDULER_LOG_SLOW_TASKS, (e) => this._debug = e, h);
    for (const e of Object.keys(f2)) this.performanceInfo.tasks.set(f2[e], new s2(String(f2[e])));
  }
  destroy() {
    this._tasks.forEach((e) => e.remove()), this._tasks.length = 0, this._runQueue.length = 0, l(this._debugHandle), this._microTaskQueued = false, this._updatingChanged();
  }
  taskRunningChanged(e) {
    this._updatingChanged(), e && this._budget.remaining > 0 && !this._microTaskQueued && (this._microTaskQueued = true, queueMicrotask(() => {
      this._microTaskQueued && (this._microTaskQueued = false, this._budget.remaining > 0 && this._schedule() && this._runFrame());
    }));
  }
  registerTask(e, t) {
    const s3 = new C2(this, e, t);
    return this._tasks.push(s3), this._updatingChanged(), this.performanceInfo.tasks.has(e) || this.performanceInfo.tasks.set(e, new s2(e)), s3;
  }
  get load() {
    return this._load;
  }
  frame(e) {
    if (this._startFrameTaskTimes(), this._updateBudget(e)) {
      const e2 = this._budget.now();
      return this._runFrame(), this._recordFrameTaskTimes(this._budget.now() - e2), true;
    }
    return this._recordFrameTaskTimes(0), false;
  }
  _updateBudget(e) {
    this._test && (this._test.usedBudget = 0), ++this._frameNumber;
    let t = O, s3 = e.frameDuration, r3 = N;
    switch (this.state) {
      case 2:
        t = n2(0), s3 = n2(Math.max(P, e.frameDuration)), r3 = b;
        break;
      case 1:
        s3 = n2(Math.max(k3, e.frameDuration));
    }
    return s3 = n2(s3 - e.elapsedFrameTime - t), 2 !== this.state && s3 < N && !this._forceTask ? (this._forceTask = true, false) : (s3 = n2(Math.max(s3, r3)), this._budget.reset(s3), this._updateLoad(), this._schedule());
  }
  _runFrame() {
    switch (this._forceTask = false, this._microTaskQueued = false, this.state) {
      case 2:
        this._runIdle();
        break;
      case 1:
        this._runInteracting();
        break;
      default:
        this._runAnimating();
    }
    this._test && (this._test.usedBudget = this._budget.elapsed);
  }
  stopFrame() {
    this._budget.reset(n2(0)), this._budget.madeProgress();
  }
  removeTask(t) {
    j(this._tasks, t), j(this._runQueue, t), this._updatingChanged();
  }
  _updateTask(e) {
    this._tasks.forEach((t) => {
      t.name === e && t.setPriority(e);
    });
  }
  _getState(e) {
    if (this._runQueue.some((t2) => t2.name === e)) return "s";
    let t = "i";
    return this._tasks.forEach((s3) => {
      s3.name === e && s3.needsUpdate && (s3.schedulePriority <= 1 ? t = "r" : "r" !== t && (t = "w"));
    }), t;
  }
  _getRuntime(e) {
    let t = 0;
    return this._tasks.forEach((s3) => {
      s3.name === e && (t += s3.runtime);
    }), t;
  }
  _resetRuntimes() {
    this._tasks.forEach((e) => e.runtime = 0);
  }
  _getRunning() {
    const e = /* @__PURE__ */ new Map();
    if (this._tasks.forEach((t2) => {
      t2.needsUpdate && e.set(t2.name, (e.get(t2.name) || 0) + 1);
    }), 0 === e.size) return null;
    let t = "";
    return e.forEach((e2, s3) => {
      t += e2 > 1 ? ` ${e2}x ${s3}` : ` ${s3}`;
    }), t;
  }
  _runIdle() {
    this._run();
  }
  _runInteracting() {
    this._run();
  }
  _runAnimating() {
    this._run();
  }
  _updateLoad() {
    const e = this._tasks.reduce((e2, t) => t.needsUpdate ? ++e2 : e2, 0);
    this._load = this._load * U + e * (1 - U);
  }
  _schedule() {
    for (A(this._runQueue, (e) => !!e.needsUpdate || (e.schedulePriority = e.basePriority, false)), this._tasks.forEach((e) => {
      e.basePriority === p2 && e.needsUpdate && !this._runQueue.includes(e) && e.blockFrame !== this._frameNumber && this._runQueue.unshift(e);
    }); 0 === this._runQueue.length; ) {
      let e = false, t = 0;
      if (this._tasks.forEach((s3) => {
        if (s3.needsUpdate && 0 !== s3.schedulePriority && s3.basePriority !== p2 && s3.blockFrame !== this._frameNumber) if (e = true, t = Math.max(t, s3.basePriority), 1 === s3.schedulePriority) s3.schedulePriority = 0, this._runQueue.push(s3);
        else --s3.schedulePriority;
      }), !e) return this._updatingChanged(), false;
    }
    return this._updatingChanged(), true;
  }
  _run() {
    do {
      for (; this._runQueue.length > 0; ) {
        const t = this._budget.now(), s3 = this._runQueue.pop();
        this._budget.resetProgress();
        try {
          s3.task.runTask(this._budget) === o && (s3.blockFrame = this._frameNumber);
        } catch (e) {
          i.getLogger("esri.views.support.Scheduler").error(`Exception in task "${s3.name}"`, e), s3.blockFrame = this._frameNumber;
        }
        !this._budget.hasProgressed && s3.blockFrame !== this._frameNumber && s3.needsUpdate && (s3.name, f2.I3S_CONTROLLER, s3.blockFrame = this._frameNumber), s3.schedulePriority = s3.basePriority;
        const i2 = this._budget.now() - t;
        if (s3.runtime += i2, this._frameTaskTimes.set(s3.priority, this._frameTaskTimes.get(s3.priority) + i2), this._budget.remaining <= 0) return void this._updatingChanged();
      }
    } while (this._schedule());
    this._updatingChanged();
  }
  _startFrameTaskTimes() {
    for (const e of Object.keys(f2)) this._frameTaskTimes.set(f2[e], 0);
  }
  _recordFrameTaskTimes(e) {
    this._frameTaskTimes.forEach((e2, t) => this.performanceInfo.tasks.get(t).push(e2)), this.performanceInfo.total.push(e);
  }
  get test() {
    return this._test;
  }
};
var C2 = class {
  get task() {
    return this._task.value;
  }
  get readyToRun() {
    return this._queue.readyToRun;
  }
  get updating() {
    return this._queue.updating;
  }
  constructor(e, t, r3) {
    this._scheduler = e, this.name = t, this.blockFrame = 0, this.runtime = 0, this._queue = new l3(), this._handles = new r(), this._basePriority = A2(t), this.schedulePriority = this._basePriority, this._task = r2(null != r3 ? r3 : this._queue), this._handles.add(f(() => this.task.readyToRun, (t2) => e.taskRunningChanged(t2)));
  }
  remove() {
    this.processQueue(F), this._scheduler.removeTask(this), this.schedule = G.schedule, this.reschedule = G.reschedule, this.scheduleGenerator = G.scheduleGenerator, this._handles.destroy();
  }
  get basePriority() {
    return this._basePriority;
  }
  setPriority(e) {
    if (this.name === e) return;
    this.name = e;
    const t = A2(e);
    this._basePriority !== p2 && 0 === this.schedulePriority || (this.schedulePriority = t), this._basePriority = t;
  }
  get priority() {
    return this.name;
  }
  set priority(e) {
    this.setPriority(e);
  }
  get needsUpdate() {
    return this.readyToRun || !this.task.destroyed && this.task.readyToRun;
  }
  schedule(e, t, s3) {
    return this._queue.push(e, t, s3);
  }
  reschedule(e, t, s3) {
    return this._queue.unshift(e, t, s3);
  }
  scheduleGenerator(e, t, s3) {
    return this._queue.pushGenerator(e, t, s3);
  }
  processQueue(e) {
    return this._queue.runTask(e);
  }
};
var y2 = class {
  constructor() {
    this._begin = performance?.now() ?? 0, this._budget = 0, this._done = false, this._progressed = false, this._enabled = true;
  }
  run(e) {
    return !this.done && (true === e() && this.madeProgress(), true);
  }
  get done() {
    return this._done;
  }
  get budget() {
    return this._budget;
  }
  madeProgress() {
    return this._progressed = true, this._done = this.elapsed >= this._budget && this._enabled, this._done;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._enabled = e;
  }
  reset(e) {
    this._begin = this.now(), this._budget = e, this.resetProgress();
  }
  get remaining() {
    return Math.max(this._budget - this.elapsed, 0);
  }
  now() {
    return performance.now();
  }
  get elapsed() {
    return this.now() - this._begin;
  }
  resetProgress() {
    this._progressed = false, this._done = false;
  }
  get hasProgressed() {
    return this._progressed;
  }
};
var F = new y2();
F.enabled = false;
var D = class {
  remove() {
  }
  processQueue() {
  }
  schedule(e, t, s3) {
    try {
      if (a(t)) {
        const e2 = u();
        return s3 ? Promise.resolve(s3(e2)) : Promise.reject(e2);
      }
      return k(e(F));
    } catch (r3) {
      return Promise.reject(r3);
    }
  }
  reschedule(e, t, s3) {
    return this.schedule(e, t, s3);
  }
  async scheduleGenerator(e, t, s3) {
    if (a(t)) {
      const e2 = u();
      if (s3) return s3(e2);
      throw e2;
    }
    const r3 = e(F);
    for (; ; ) {
      const e2 = r3.next(F), i2 = C(e2) ? await e2 : e2;
      if (a(t)) {
        const e3 = u();
        if (s3) {
          const t3 = s3(e3), i3 = r3.return(null);
          return C(i3) && await y(i3), t3;
        }
        const t2 = r3.throw(e3);
        throw C(t2) && await y(t2), e3;
      }
      if (i2.done) return i2.value;
    }
  }
};
var G = new D();

export {
  o,
  l3 as l,
  I,
  f2 as f,
  F,
  G
};
//# sourceMappingURL=chunk-XDLV73DB.js.map
