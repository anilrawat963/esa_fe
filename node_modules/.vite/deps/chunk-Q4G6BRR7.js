import {
  P as P3,
  z
} from "./chunk-ZP5CSWYG.js";
import {
  t as t9
} from "./chunk-KDOWKZ3H.js";
import {
  u as u4
} from "./chunk-6WSJV2UJ.js";
import {
  a3 as a2,
  a5 as a3,
  b as b3,
  c as c3,
  c2 as c4,
  d as d2,
  e2 as e4,
  e3 as e6,
  f as f2,
  i2 as i3,
  i3 as i4,
  i4 as i5,
  m as m3,
  n as n5,
  p as p2,
  r as r9,
  s as s6,
  t as t6,
  u as u6,
  x
} from "./chunk-VIIQX37N.js";
import {
  t as t7
} from "./chunk-KEMYAF6M.js";
import {
  g as g2,
  m as m4,
  t as t5
} from "./chunk-CYVJEU2B.js";
import {
  T,
  d,
  r as r10
} from "./chunk-FDSAQJ3R.js";
import {
  a,
  b as b2,
  o as o3,
  t as t3,
  t2 as t4,
  u as u5
} from "./chunk-I4DSU5MJ.js";
import {
  e as e5,
  t2 as t8
} from "./chunk-F43BIMML.js";
import {
  o2 as o4
} from "./chunk-BZBDEPRV.js";
import {
  t as t2
} from "./chunk-ME5HHRVQ.js";
import {
  S
} from "./chunk-ZP6KSK4N.js";
import {
  B,
  M,
  b,
  v
} from "./chunk-JBTWCDRR.js";
import {
  I as I2,
  N,
  P as P2
} from "./chunk-U6CJFTOF.js";
import {
  X,
  j2,
  k,
  m as m2,
  w
} from "./chunk-2JMKFI2D.js";
import {
  Q
} from "./chunk-2AOVWXAQ.js";
import {
  f
} from "./chunk-MEDXVTKR.js";
import {
  t
} from "./chunk-NDFIZYZY.js";
import {
  m,
  s as s5
} from "./chunk-TLTSPUO7.js";
import {
  n as n3,
  r as r7,
  s as s3
} from "./chunk-ZVTEFYZX.js";
import {
  s as s2
} from "./chunk-LPUPM55U.js";
import {
  _
} from "./chunk-QNVJVDYZ.js";
import {
  E,
  H as H2,
  I,
  P,
  c as c2,
  g,
  o as o2,
  p,
  r as r8,
  s as s4,
  u as u3
} from "./chunk-VYMBX5H5.js";
import {
  e as e3,
  n as n4
} from "./chunk-XTZAIV4X.js";
import {
  e as e2,
  r as r6
} from "./chunk-K2OZ6WVC.js";
import {
  e2 as e7
} from "./chunk-MC6NAKKX.js";
import {
  o
} from "./chunk-DTZUXJMD.js";
import {
  H,
  c,
  n as n2
} from "./chunk-XLOINTMG.js";
import {
  n,
  r as r4
} from "./chunk-75XOUSSS.js";
import {
  r as r5
} from "./chunk-AZXJIEZ6.js";
import {
  i as i2
} from "./chunk-TFJXG32O.js";
import {
  y
} from "./chunk-CSMCPN64.js";
import {
  r as r3
} from "./chunk-SMWUT52Z.js";
import {
  e4 as e,
  r2
} from "./chunk-5EI5H4QX.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  u as u2
} from "./chunk-45CFSCQX.js";
import {
  s,
  u2 as u
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i
} from "./chunk-QY7XKUIV.js";
import {
  j,
  r
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/VertexAttribute.js
function n6(n9) {
  return "position" === n9;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/renderers/utils.js
function n7(t12, e10) {
  return null == t12 && (t12 = []), t12.push(e10), t12;
}
function r11(t12, e10) {
  if (null == t12) return null;
  const n9 = t12.filter((t13) => t13 !== e10);
  return 0 === n9.length ? null : n9;
}
function l(t12, n9, r13, l4, i8) {
  o5[0] = t12.get(n9, 0), o5[1] = t12.get(n9, 1), o5[2] = t12.get(n9, 2), t7(o5, s7, 3), r13.set(i8, 0, s7[0]), l4.set(i8, 0, s7[1]), r13.set(i8, 1, s7[2]), l4.set(i8, 1, s7[3]), r13.set(i8, 2, s7[4]), l4.set(i8, 2, s7[5]);
}
var o5 = n();
var s7 = new Float32Array(6);

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Object3D.js
var W = class {
  constructor(i8 = {}) {
    this.id = e(), this._highlightIds = /* @__PURE__ */ new Set(), this._shaderTransformation = null, this._visible = true, this.castShadow = i8.castShadow ?? true, this.usesVerticalDistanceToGround = i8.usesVerticalDistanceToGround ?? false, this.graphicUid = i8.graphicUid, this.layerViewUid = i8.layerViewUid, i8.isElevationSource && (this.lastValidElevationBB = new A()), this._geometries = i8.geometries ? Array.from(i8.geometries) : new Array();
  }
  dispose() {
    this._geometries.length = 0;
  }
  get layer() {
    return this._layer;
  }
  set layer(t12) {
    s5(null == this._layer || null == t12, "Object3D can only be added to a single Layer"), this._layer = t12;
  }
  addGeometry(t12) {
    t12.visible = this._visible, this._geometries.push(t12);
    for (const i8 of this._highlightIds) t12.addHighlight(i8);
    this._emit("geometryAdded", { object: this, geometry: t12 }), this._highlightIds.size && this._emit("highlightChanged", this), this._invalidateBoundingVolume();
  }
  removeGeometry(t12) {
    const i8 = this._geometries.splice(t12, 1)[0];
    if (i8) {
      for (const t13 of this._highlightIds) i8.removeHighlight(t13);
      this._emit("geometryRemoved", { object: this, geometry: i8 }), this._highlightIds.size && this._emit("highlightChanged", this), this._invalidateBoundingVolume();
    }
  }
  removeAllGeometries() {
    for (; this._geometries.length > 0; ) this.removeGeometry(0);
  }
  geometryVertexAttributeUpdated(t12, i8, e10 = false) {
    this._emit("attributesChanged", { object: this, geometry: t12, attribute: i8, sync: e10 }), n6(i8) && this._invalidateBoundingVolume();
  }
  get visible() {
    return this._visible;
  }
  set visible(t12) {
    if (this._visible !== t12) {
      this._visible = t12;
      for (const t13 of this._geometries) t13.visible = this._visible;
      this._emit("visibilityChanged", this);
    }
  }
  maskOccludee() {
    const t12 = new r9();
    for (const i8 of this._geometries) i8.occludees = n7(i8.occludees, t12);
    return this._emit("occlusionChanged", this), t12;
  }
  removeOcclude(t12) {
    for (const i8 of this._geometries) i8.occludees = r11(i8.occludees, t12);
    this._emit("occlusionChanged", this);
  }
  highlight(t12) {
    const i8 = new c3(t12);
    for (const e10 of this._geometries) e10.addHighlight(i8);
    return this._emit("highlightChanged", this), this._highlightIds.add(i8), i8;
  }
  removeHighlight(t12) {
    this._highlightIds.delete(t12);
    for (const i8 of this._geometries) i8.removeHighlight(t12);
    this._emit("highlightChanged", this);
  }
  removeStateID(t12) {
    0 === t12.channel ? this.removeHighlight(t12) : this.removeOcclude(t12);
  }
  getCombinedStaticTransformation(t12, e10) {
    return c(e10, this.transformation, t12.transformation);
  }
  getCombinedShaderTransformation(t12, e10 = e2()) {
    return c(e10, this.effectiveTransformation, t12.transformation);
  }
  get boundingVolumeWorldSpace() {
    return this._bvWorldSpace || (this._bvWorldSpace = this._bvWorldSpace || new M2(), this._validateBoundingVolume(this._bvWorldSpace, 0)), this._bvWorldSpace;
  }
  get boundingVolumeObjectSpace() {
    return this._bvObjectSpace || (this._bvObjectSpace = this._bvObjectSpace || new M2(), this._validateBoundingVolume(this._bvObjectSpace, 1)), this._bvObjectSpace;
  }
  _validateBoundingVolume(t12, i8) {
    const e10 = 1 === i8;
    for (const s10 of this._geometries) {
      const i9 = s10.boundingInfo;
      i9 && T2(i9, t12, e10 ? s10.transformation : this.getCombinedShaderTransformation(s10));
    }
    N(t12.bounds, I(U, t12.min, t12.max, 0.5));
    for (const s10 of this._geometries) {
      const i9 = s10.boundingInfo;
      if (null == i9) continue;
      const o8 = e10 ? s10.transformation : this.getCombinedShaderTransformation(s10), r13 = m2(o8);
      E(U, i9.center, o8);
      const a6 = p(U, I2(t12.bounds)), m7 = i9.radius * r13;
      t12.bounds[3] = Math.max(t12.bounds[3], a6 + m7);
    }
  }
  _invalidateBoundingVolume() {
    const t12 = this._bvWorldSpace?.bounds;
    this._bvObjectSpace = this._bvWorldSpace = void 0, this.layer && t12 && this.layer.notifyObjectBBChanged(this, t12);
  }
  _emit(t12, i8) {
    this.layer?.events.emit(t12, i8);
  }
  get geometries() {
    return this._geometries;
  }
  get transformation() {
    return this._transformation ?? r6;
  }
  set transformation(t12) {
    this._transformation = n2(this._transformation ?? e2(), t12), this._invalidateBoundingVolume(), this._emit("transformationChanged", this);
  }
  get shaderTransformation() {
    return this._shaderTransformation;
  }
  set shaderTransformation(t12) {
    this._shaderTransformation = t12 ? n2(this._shaderTransformation ?? e2(), t12) : null, this._invalidateBoundingVolume(), this._emit("shaderTransformationChanged", this);
  }
  get effectiveTransformation() {
    return this.shaderTransformation ?? this.transformation;
  }
  get test() {
  }
};
var A = class {
  constructor() {
    this._data = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE];
  }
  get min() {
    return r4(this._data[0], this._data[1], this._data[2]);
  }
  get max() {
    return r4(this._data[3], this._data[4], this._data[5]);
  }
  minWith(t12) {
    const { _data: i8 } = this;
    i8[0] = Math.min(i8[0], t12[0]), i8[1] = Math.min(i8[1], t12[1]), i8[2] = Math.min(i8[2], t12[2]);
  }
  maxWith(t12) {
    const { _data: i8 } = this;
    i8[3] = Math.max(i8[3], t12[0]), i8[4] = Math.max(i8[4], t12[1]), i8[5] = Math.max(i8[5], t12[2]);
  }
  assignMinMax(t12, i8) {
    for (let e10 = 0; e10 < 3; ++e10) this._data[0 + e10] = t12[e10], this._data[3 + e10] = i8[e10];
  }
  isEmpty() {
    return this._data[3] < this._data[0] && this._data[4] < this._data[1] && this._data[5] < this._data[2];
  }
};
var M2 = class extends A {
  constructor() {
    super(...arguments), this.bounds = P2();
  }
};
function T2(t12, i8, e10) {
  const o8 = t12.bbMin, r13 = t12.bbMax;
  if (H(e10)) {
    const t13 = o2(C, e10[12], e10[13], e10[14]);
    return u3(B2, o8, t13), u3(O, r13, t13), i8.minWith(B2), void i8.maxWith(O);
  }
  if (E(B2, o8, e10), H2(o8, r13)) return i8.minWith(B2), void i8.maxWith(B2);
  E(O, r13, e10), i8.minWith(B2), i8.minWith(O), i8.maxWith(B2), i8.maxWith(O);
  for (let s10 = 0; s10 < 3; ++s10) s4(B2, o8), s4(O, r13), B2[s10] = r13[s10], O[s10] = o8[s10], E(B2, B2, e10), E(O, O, e10), i8.minWith(B2), i8.minWith(O), i8.maxWith(B2), i8.maxWith(O);
}
var C = n();
var B2 = n();
var O = n();
var U = n();

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/RibbonLineTechnique.js
var S2 = class extends m4 {
  constructor(e10, t12) {
    super(e10, t12, new t5(z, () => import("./RibbonLine.glsl-KJ6K65IJ.js")), v2(t12).locations), this.primitiveType = t12.wireframe ? _.LINES : _.TRIANGLE_STRIP;
  }
  _makePipelineState(e10, i8) {
    const { oitPass: r13, output: s10, hasOccludees: h2, hasPolygonOffset: m7 } = e10, P4 = 0 === r13, g4 = 2 === r13;
    return T({ blending: o3(s10) ? a2(r13) : null, depthTest: { func: p2(r13) }, depthWrite: i4(e10), drawBuffers: g2(s10, d2(r13, s10)), colorWrite: d, stencilWrite: h2 ? f2 : null, stencilTest: h2 ? i8 ? t6 : c4 : null, polygonOffset: P4 || g4 ? m7 ? _2 : null : b3 });
  }
  initializePipeline(e10) {
    if (e10.occluder) {
      const t12 = e10.hasPolygonOffset ? _2 : null, { output: i8, hasOccludees: r13 } = e10;
      this._occluderPipelineTransparent = T({ blending: r10, polygonOffset: t12, depthTest: n5, depthWrite: null, colorWrite: d, stencilWrite: null, stencilTest: r13 ? e6 : null, drawBuffers: g2(i8) }), this._occluderPipelineOpaque = T({ blending: r10, polygonOffset: t12, depthTest: r13 ? n5 : a3, depthWrite: null, colorWrite: d, stencilWrite: r13 ? i5 : null, stencilTest: r13 ? u6 : null, drawBuffers: g2(i8) }), this._occluderPipelineMaskWrite = T({ blending: null, polygonOffset: t12, depthTest: a3, depthWrite: null, colorWrite: null, stencilWrite: r13 ? f2 : null, stencilTest: r13 ? t6 : null, drawBuffers: g2(i8) });
    }
    return this._occludeePipeline = this._makePipelineState(e10, true), this._makePipelineState(e10, false);
  }
  getPipeline(e10, t12) {
    if (e10) return this._occludeePipeline;
    switch (t12) {
      case 11:
        return this._occluderPipelineTransparent ?? super.getPipeline();
      case 10:
        return this._occluderPipelineOpaque ?? super.getPipeline();
      default:
        return this._occluderPipelineMaskWrite ?? super.getPipeline();
    }
  }
};
var _2 = { factor: 0, units: -4 };
function v2(t12) {
  const i8 = Q().vec3f("position").vec4f16("previousDelta").vec4f16("nextDelta").f32("u0").vec2f16("lineParameters");
  return t12.hasVVColor ? i8.f32("colorFeatureAttribute") : i8.vec4u8("color", { glNormalized: true }), t12.hasVVSize ? i8.f32("sizeFeatureAttribute") : i8.f32("size"), t12.hasVVOpacity && i8.f32("opacityFeatureAttribute"), e5() && i8.vec4u8("olidColor"), t12.hasAnimation && i8.vec4f16("timeStamps"), i8;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/RibbonLineTechniqueConfiguration.js
var i6 = class extends e4 {
  constructor(o8) {
    super(), this.spherical = o8, this.capType = 0, this.emissionSource = 0, this.hasPolygonOffset = false, this.writeDepth = false, this.draped = false, this.stippleEnabled = false, this.stippleOffColorEnabled = false, this.stipplePreferContinuous = true, this.roundJoins = false, this.applyMarkerOffset = false, this.hasVVSize = false, this.hasVVColor = false, this.hasVVOpacity = false, this.falloffEnabled = false, this.innerColorEnabled = false, this.hasOccludees = false, this.occluder = false, this.terrainDepthTest = false, this.cullAboveTerrain = false, this.wireframe = false, this.discardInvisibleFragments = false, this.animation = 2, this.hasScreenSizePerspective = false, this.textureCoordinateType = 0, this.occlusionPass = false, this.hasVVInstancing = false, this.hasSliceTranslatedView = true, this.overlayEnabled = false, this.snowCover = false;
  }
  get hasAnimation() {
    return 0 !== this.animation;
  }
};
__decorate([i3({ count: 3 })], i6.prototype, "capType", void 0), __decorate([i3({ count: 8 })], i6.prototype, "emissionSource", void 0), __decorate([i3()], i6.prototype, "hasPolygonOffset", void 0), __decorate([i3()], i6.prototype, "writeDepth", void 0), __decorate([i3()], i6.prototype, "draped", void 0), __decorate([i3()], i6.prototype, "stippleEnabled", void 0), __decorate([i3()], i6.prototype, "stippleOffColorEnabled", void 0), __decorate([i3()], i6.prototype, "stipplePreferContinuous", void 0), __decorate([i3()], i6.prototype, "roundJoins", void 0), __decorate([i3()], i6.prototype, "applyMarkerOffset", void 0), __decorate([i3()], i6.prototype, "hasVVSize", void 0), __decorate([i3()], i6.prototype, "hasVVColor", void 0), __decorate([i3()], i6.prototype, "hasVVOpacity", void 0), __decorate([i3()], i6.prototype, "falloffEnabled", void 0), __decorate([i3()], i6.prototype, "innerColorEnabled", void 0), __decorate([i3()], i6.prototype, "hasOccludees", void 0), __decorate([i3()], i6.prototype, "occluder", void 0), __decorate([i3()], i6.prototype, "terrainDepthTest", void 0), __decorate([i3()], i6.prototype, "cullAboveTerrain", void 0), __decorate([i3()], i6.prototype, "wireframe", void 0), __decorate([i3()], i6.prototype, "discardInvisibleFragments", void 0), __decorate([i3({ count: 4 })], i6.prototype, "animation", void 0), __decorate([i3()], i6.prototype, "hasScreenSizePerspective", void 0);

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/RibbonLineMaterial.js
var J = class extends s6 {
  constructor(t12, e10) {
    super(t12, q), this.produces = /* @__PURE__ */ new Map([[2, (t13) => t3(t13) || o3(t13) && 8 === this.parameters.renderOccluded], [3, (t13) => b2(t13)], [10, (t13) => a(t13) && 8 === this.parameters.renderOccluded], [11, (t13) => a(t13) && 8 === this.parameters.renderOccluded], [4, (t13) => o3(t13) && this.parameters.writeDepth && 8 !== this.parameters.renderOccluded], [8, (t13) => o3(t13) && !this.parameters.writeDepth && 8 !== this.parameters.renderOccluded], [18, (t13) => u5(t13)]]), this._configuration = new i6(e10);
  }
  getConfiguration(t12, e10) {
    super.getConfiguration(t12, e10, this._configuration), this._configuration.oitPass = e10.oitPass, this._configuration.draped = 18 === e10.slot;
    const i8 = null != this.parameters.stipplePattern && 9 !== t12;
    return this._configuration.stippleEnabled = i8, this._configuration.stippleOffColorEnabled = i8 && null != this.parameters.stippleOffColor, this._configuration.stipplePreferContinuous = i8 && this.parameters.stipplePreferContinuous, this._configuration.hasSlicePlane = this.parameters.hasSlicePlane, this._configuration.roundJoins = "round" === this.parameters.join, this._configuration.capType = this.parameters.cap, this._configuration.applyMarkerOffset = null != this.parameters.markerParameters && H3(this.parameters.markerParameters), this._configuration.hasPolygonOffset = this.parameters.hasPolygonOffset, this._configuration.writeDepth = this.parameters.writeDepth, this._configuration.hasVVSize = this.parameters.hasVVSize, this._configuration.hasVVColor = this.parameters.hasVVColor, this._configuration.hasVVOpacity = this.parameters.hasVVOpacity, this._configuration.innerColorEnabled = this.parameters.innerWidth > 0 && null != this.parameters.innerColor, this._configuration.falloffEnabled = this.parameters.falloff > 0, this._configuration.hasOccludees = e10.hasOccludees, this._configuration.occluder = 8 === this.parameters.renderOccluded, this._configuration.terrainDepthTest = e10.terrainDepthTest && o3(t12), this._configuration.cullAboveTerrain = e10.cullAboveTerrain, this._configuration.wireframe = this.parameters.wireframe, this._configuration.animation = this.parameters.animation, this._configuration.emissionSource = this.hasEmissions ? 1 : 0, this._configuration.hasScreenSizePerspective = !!this.parameters.screenSizePerspective, this._configuration;
  }
  get visible() {
    return this.parameters.color[3] >= o4 || null != this.parameters.stipplePattern && (this.parameters.stippleOffColor?.[3] ?? 0) > o4;
  }
  setParameters(t12, e10) {
    t12.animation = this.parameters.animation, super.setParameters(t12, e10);
  }
  intersectDraped({ attributes: t12, screenToWorldRatio: i8 }, r13, s10, a6, n9) {
    if (!r13.options.selectionMode) return;
    const o8 = t12.get("size");
    let l4 = this.parameters.width;
    if (this.parameters.vvSize) {
      const i9 = t12.get("sizeFeatureAttribute").data[0];
      Number.isNaN(i9) ? l4 *= this.parameters.vvSize.fallback[0] : l4 *= r3(this.parameters.vvSize.offset[0] + i9 * this.parameters.vvSize.factor[0], this.parameters.vvSize.minSize[0], this.parameters.vvSize.maxSize[0]);
    } else o8 && (l4 *= o8.data[0]);
    const h2 = s10[0], c7 = s10[1], m7 = (l4 / 2 + 4) * i8;
    let p5 = Number.MAX_VALUE, u8 = 0;
    const f6 = t12.get("position").data, d7 = I3(this.parameters, t12) ? f6.length - 2 : f6.length - 5;
    for (let g4 = 0; g4 < d7; g4 += 3) {
      const t13 = f6[g4], i9 = f6[g4 + 1], r14 = (g4 + 3) % f6.length, s11 = h2 - t13, a7 = c7 - i9, n10 = f6[r14] - t13, o9 = f6[r14 + 1] - i9, l5 = r3((n10 * s11 + o9 * a7) / (n10 * n10 + o9 * o9), 0, 1), m8 = n10 * l5 - s11, d8 = o9 * l5 - a7, b5 = m8 * m8 + d8 * d8;
      b5 < p5 && (p5 = b5, u8 = g4 / 3);
    }
    p5 < m7 * m7 && a6(n9.distance, n9.normal, u8);
  }
  intersect(i8, r13, u8, f6, d7, g4) {
    const { options: b5, camera: _3, rayBegin: P4, rayEnd: w2 } = u8;
    if (!b5.selectionMode || !i8.visible || !_3) return;
    if (!m(r13)) return void i.getLogger("esri.views.3d.webgl-engine.materials.RibbonLineMaterial").error("intersection assumes a translation-only matrix");
    const z2 = i8.attributes, A3 = z2.get("position").data;
    let C2 = this.parameters.width;
    if (this.parameters.vvSize) {
      const t12 = z2.get("sizeFeatureAttribute").data[0];
      Number.isNaN(t12) || (C2 *= r3(this.parameters.vvSize.offset[0] + t12 * this.parameters.vvSize.factor[0], this.parameters.vvSize.minSize[0], this.parameters.vvSize.maxSize[0]));
    } else z2.has("size") && (C2 *= z2.get("size").data[0]);
    const O3 = tt;
    r5(O3, u8.point);
    const L = C2 * _3.pixelRatio / 2 + 4 * _3.pixelRatio;
    o2(mt[0], O3[0] - L, O3[1] + L, 0), o2(mt[1], O3[0] + L, O3[1] + L, 0), o2(mt[2], O3[0] + L, O3[1] - L, 0), o2(mt[3], O3[0] - L, O3[1] - L, 0);
    for (let t12 = 0; t12 < 4; t12++) if (!_3.unprojectFromRenderScreen(mt[t12], pt[t12])) return;
    w(_3.eye, pt[0], pt[1], ut), w(_3.eye, pt[1], pt[2], ft), w(_3.eye, pt[2], pt[3], dt), w(_3.eye, pt[3], pt[0], gt);
    let M3 = Number.MAX_VALUE, V = 0;
    const R2 = I3(this.parameters, z2) ? A3.length - 2 : A3.length - 5;
    for (let t12 = 0; t12 < R2; t12 += 3) {
      K[0] = A3[t12] + r13[12], K[1] = A3[t12 + 1] + r13[13], K[2] = A3[t12 + 2] + r13[14];
      const e10 = (t12 + 3) % A3.length;
      if (Q2[0] = A3[e10] + r13[12], Q2[1] = A3[e10 + 1] + r13[13], Q2[2] = A3[e10 + 2] + r13[14], X(ut, K) < 0 && X(ut, Q2) < 0 || X(ft, K) < 0 && X(ft, Q2) < 0 || X(dt, K) < 0 && X(dt, Q2) < 0 || X(gt, K) < 0 && X(gt, Q2) < 0) continue;
      const i9 = _3.projectToRenderScreen(K, et), s10 = _3.projectToRenderScreen(Q2, it);
      if (null == i9 || null == s10) continue;
      if (i9[2] < 0 && s10[2] > 0) {
        c2(Z, K, Q2);
        const t13 = _3.frustum, e11 = -X(t13[4], K) / P(Z, k(t13[4]));
        if (g(Z, Z, e11), u3(K, K, Z), !_3.projectToRenderScreen(K, i9)) continue;
      } else if (i9[2] > 0 && s10[2] < 0) {
        c2(Z, Q2, K);
        const t13 = _3.frustum, e11 = -X(t13[4], Q2) / P(Z, k(t13[4]));
        if (g(Z, Z, e11), u3(Q2, Q2, Z), !_3.projectToRenderScreen(Q2, s10)) continue;
      } else if (i9[2] < 0 && s10[2] < 0) continue;
      i9[2] = 0, s10[2] = 0;
      const a6 = M(b(i9, s10, at), O3);
      a6 < M3 && (M3 = a6, s4(rt, K), s4(st, Q2), V = t12 / 3);
    }
    if (M3 < L * L) {
      let t12 = Number.MAX_VALUE;
      if (B(b(rt, st, at), b(P4, w2, nt), $)) {
        c2($, $, P4);
        const e10 = r8($);
        g($, $, 1 / e10), t12 = e10 / p(P4, w2);
      }
      g4(t12, $, V);
    }
  }
  get hasEmissions() {
    return this.parameters.emissiveStrength > 0;
  }
  createBufferWriter() {
    return new X2(v2(this.parameters), this.parameters);
  }
  createGLMaterial(t12) {
    return new Y(t12);
  }
  validateParameters(t12) {
    "miter" !== t12.join && (t12.miterLimit = 0), null != t12.markerParameters && (t12.markerScale = t12.markerParameters.width / t12.width);
  }
  update(t12) {
    const { hasAnimation: e10 } = this.parameters;
    return !!e10 && (this.setParameters({ timeElapsed: u2(t12.time) }, false), 0 !== t12.dt);
  }
};
var Y = class extends t4 {
  constructor() {
    super(...arguments), this._stipplePattern = null;
  }
  dispose() {
    super.dispose(), this._stippleTextures?.release(this._stipplePattern), this._stipplePattern = null;
  }
  beginSlot(t12) {
    const e10 = this._material.parameters.stipplePattern;
    return this._stipplePattern !== e10 && (this._material.setParameters({ stippleTexture: this._stippleTextures.swap(e10, this._stipplePattern) }), this._stipplePattern = e10), this.getTechnique(S2, t12);
  }
};
var q = class extends t8 {
  constructor() {
    super(...arguments), this.width = 0, this.color = s3, this.join = "miter", this.cap = 0, this.miterLimit = 5, this.writeDepth = true, this.hasPolygonOffset = false, this.stippleTexture = null, this.stipplePreferContinuous = true, this.markerParameters = null, this.markerScale = 1, this.hasSlicePlane = false, this.vvFastUpdate = false, this.isClosed = false, this.falloff = 0, this.innerWidth = 0, this.wireframe = false, this.timeElapsed = 0, this.animation = 0, this.animationSpeed = 1, this.trailLength = 1, this.startTime = 0, this.endTime = 1 / 0, this.fadeInTime = 0, this.fadeOutTime = 1 / 0, this.emissiveStrength = 0;
  }
  get transparent() {
    return this.color[3] < 1 || this.hasAnimation || null != this.stipplePattern && (this.stippleOffColor?.[3] ?? 0) < 1;
  }
  get hasAnimation() {
    return 0 !== this.animation;
  }
};
var X2 = class {
  constructor(t12, e10) {
    this.layout = t12, this._parameters = e10;
    const i8 = e10.stipplePattern ? 1 : 0;
    switch (this._parameters.join) {
      case "miter":
      case "bevel":
        this.numJoinSubdivisions = i8;
        break;
      case "round":
        this.numJoinSubdivisions = P3 + i8;
    }
  }
  _isClosed(t12) {
    return I3(this._parameters, t12);
  }
  allocate(t12) {
    return this.layout.createBuffer(t12);
  }
  elementCount(t12) {
    const e10 = 2, i8 = t12.get("position").indices.length / 2 + 1, r13 = this._isClosed(t12);
    let s10 = r13 ? 2 : 2 * e10;
    return s10 += ((r13 ? i8 : i8 - 1) - (r13 ? 0 : 1)) * (2 * this.numJoinSubdivisions + 4), s10 += 2, this._parameters.wireframe && (s10 = 2 + 4 * (s10 - 2)), s10;
  }
  write(t12, e10, i8, r13, s10, n9) {
    const o8 = this.layout, l4 = i8.get("position"), h2 = l4.indices, m7 = l4.data.length / 3, f6 = i8.get("distanceToStart")?.data;
    h2 && h2.length !== 2 * (m7 - 1) && console.warn("RibbonLineMaterial does not support indices");
    const g4 = o8.fields.has("sizeFeatureAttribute");
    let b5 = 1, S3 = null;
    if (g4) {
      const t13 = i8.get("sizeFeatureAttribute");
      1 === t13.data.length ? b5 = t13.data[0] : S3 = t13.data;
    } else b5 = i8.get("size")?.data[0] ?? 1;
    let v4 = [1, 1, 1, 1], P4 = 0, j4 = null;
    const E3 = o8.fields.has("colorFeatureAttribute");
    if (E3) {
      const t13 = i8.get("colorFeatureAttribute");
      1 === t13.data.length ? P4 = t13.data[0] : j4 = t13.data;
    } else v4 = i8.get("color")?.data ?? v4;
    const w2 = i8.get("timeStamps")?.data, y3 = w2 && o8.fields.has("timeStamps"), T3 = o8.fields.has("opacityFeatureAttribute");
    let z2 = 0, A3 = null;
    if (T3) {
      const t13 = i8.get("opacityFeatureAttribute");
      1 === t13.data.length ? z2 = t13.data[0] : A3 = t13.data;
    }
    const C2 = new Float32Array(s10.buffer), O3 = t(s10.buffer), L = new Uint8Array(s10.buffer), V = o8.stride / 4;
    let R2 = n9 * V;
    const x3 = R2;
    let F = 0;
    const N2 = f6 ? (t13, e11, i9) => F = f6[i9] : (t13, e11, i9) => F += p(t13, e11), U2 = C2.BYTES_PER_ELEMENT / O3.BYTES_PER_ELEMENT, D = 4 / U2, B3 = e5(), W2 = (t13, e11, i9, s11, a6, n10, o9, l5) => {
      C2[R2++] = e11[0], C2[R2++] = e11[1], C2[R2++] = e11[2], x(t13, e11, O3, R2 * U2), R2 += D, x(i9, e11, O3, R2 * U2), R2 += D, C2[R2++] = l5;
      let h3 = R2 * U2;
      if (O3[h3++] = a6, O3[h3++] = n10, R2 = Math.ceil(h3 / U2), E3) C2[R2] = j4?.[o9] ?? P4;
      else {
        const t14 = Math.min(4 * o9, v4.length - 4), e12 = 4 * R2;
        L[e12] = 255 * v4[t14], L[e12 + 1] = 255 * v4[t14 + 1], L[e12 + 2] = 255 * v4[t14 + 2], L[e12 + 3] = 255 * v4[t14 + 3];
      }
      if (R2++, C2[R2++] = S3?.[o9] ?? b5, T3 && (C2[R2++] = A3?.[o9] ?? z2), B3) {
        let t14 = 4 * R2;
        r13 ? (L[t14++] = r13[0], L[t14++] = r13[1], L[t14++] = r13[2], L[t14++] = r13[3]) : (L[t14++] = 0, L[t14++] = 0, L[t14++] = 0, L[t14++] = 0), R2 = Math.ceil(0.25 * t14);
      }
      y3 && (h3 = R2 * U2, O3[h3++] = s11[0], O3[h3++] = s11[1], O3[h3++] = s11[2], O3[h3++] = s11[3], R2 = Math.ceil(h3 / U2));
    };
    R2 += V, o2(lt, l4.data[0], l4.data[1], l4.data[2]), y3 && s2(ct, w2[0], w2[1], w2[2], w2[3]), t12 && E(lt, lt, t12);
    const J2 = this._isClosed(i8);
    if (J2) {
      const e11 = l4.data.length - 3;
      o2(ot, l4.data[e11], l4.data[e11 + 1], l4.data[e11 + 2]), t12 && E(ot, ot, t12);
    } else o2(ht, l4.data[3], l4.data[4], l4.data[5]), t12 && E(ht, ht, t12), W2(lt, lt, ht, ct, 1, -4, 0, 0), W2(lt, lt, ht, ct, 1, 4, 0, 0), s4(ot, lt), s4(lt, ht), y3 && s2(ct, w2[4], w2[5], w2[6], w2[7]);
    const Y2 = J2 ? 0 : 1, q2 = J2 ? m7 : m7 - 1;
    for (let p5 = Y2; p5 < q2; p5++) {
      const e11 = (p5 + 1) % m7 * 3;
      o2(ht, l4.data[e11], l4.data[e11 + 1], l4.data[e11 + 2]), t12 && E(ht, ht, t12), N2(ot, lt, p5), W2(ot, lt, ht, ct, 0, -1, p5, F), W2(ot, lt, ht, ct, 0, 1, p5, F);
      const i9 = this.numJoinSubdivisions;
      for (let t13 = 0; t13 < i9; ++t13) {
        const e12 = (t13 + 1) / (i9 + 1);
        W2(ot, lt, ht, ct, e12, -1, p5, F), W2(ot, lt, ht, ct, e12, 1, p5, F);
      }
      if (W2(ot, lt, ht, ct, 1, -2, p5, F), W2(ot, lt, ht, ct, 1, 2, p5, F), s4(ot, lt), s4(lt, ht), y3) {
        const t13 = (p5 + 1) % m7 * 4;
        s2(ct, w2[t13], w2[t13 + 1], w2[t13 + 2], w2[t13 + 3]);
      }
    }
    J2 ? (o2(ht, l4.data[3], l4.data[4], l4.data[5]), t12 && E(ht, ht, t12), F = N2(ot, lt, q2), W2(ot, lt, ht, ct, 0, -1, Y2, F), W2(ot, lt, ht, ct, 0, 1, Y2, F)) : (F = N2(ot, lt, q2), W2(ot, lt, lt, ct, 0, -5, q2, F), W2(ot, lt, lt, ct, 0, 5, q2, F)), G(C2, x3 + V, C2, x3, V);
    return R2 = G(C2, R2 - V, C2, R2, V), this._parameters.wireframe && this._addWireframeVertices(s10, x3, R2, V), null;
  }
  _addWireframeVertices(t12, e10, i8, r13) {
    const s10 = new Float32Array(t12.buffer, i8 * Float32Array.BYTES_PER_ELEMENT), a6 = new Float32Array(t12.buffer, e10 * Float32Array.BYTES_PER_ELEMENT, i8 - e10);
    let n9 = 0;
    const o8 = (t13) => n9 = G(a6, t13, s10, n9, r13);
    for (let l4 = 0; l4 < a6.length - 1; l4 += 2 * r13) o8(l4), o8(l4 + 2 * r13), o8(l4 + 1 * r13), o8(l4 + 2 * r13), o8(l4 + 1 * r13), o8(l4 + 3 * r13);
  }
};
function G(t12, e10, i8, r13, s10) {
  for (let a6 = 0; a6 < s10; a6++) i8[r13++] = t12[e10++];
  return r13;
}
function I3(t12, e10) {
  if (!t12.isClosed) return false;
  return e10.get("position").indices.length > 2;
}
function H3(t12) {
  return 1 === t12.anchor && t12.hideOnShortSegments && "begin-end" === t12.placement && t12.worldSpace;
}
var K = n();
var Q2 = n();
var Z = n();
var $ = n();
var tt = n();
var et = y();
var it = y();
var rt = n();
var st = n();
var at = v();
var nt = v();
var ot = n();
var lt = n();
var ht = n();
var ct = n3();
var mt = [y(), y(), y(), y()];
var pt = [n(), n(), n(), n()];
var ut = j2();
var ft = j2();
var dt = j2();
var gt = j2();

// node_modules/@arcgis/core/views/3d/support/ElevationProvider.js
var r12 = class {
  constructor(e10, r13 = null, t12 = 0) {
    this.array = e10, this.spatialReference = r13, this.offset = t12;
  }
};
function t10(e10) {
  return "array" in e10;
}
function a4(r13, a6, n9 = "ground") {
  if (t9(a6)) return r13.getElevation(a6.x, a6.y, a6.z || 0, a6.spatialReference, n9);
  if (t10(a6)) {
    let e10 = a6.offset;
    return r13.getElevation(a6.array[e10++], a6.array[e10++], a6.array[e10] || 0, a6.spatialReference ?? r13.spatialReference, n9);
  }
  return r13.getElevation(a6[0], a6[1], a6[2] || 0, r13.spatialReference, n9);
}

// node_modules/@arcgis/core/views/3d/layers/graphics/elevationAlignmentUtils.js
function l2(e10, t12, n9, o8, i8, a6, s10, l4, c7, u8, f6) {
  const d7 = b4[f6.mode];
  let m7, g4, p5 = 0;
  if (o(e10, t12, n9, o8, c7.spatialReference, i8, l4)) return d7?.requiresAlignment(f6) ? (p5 = d7.applyElevationAlignmentBuffer(o8, i8, a6, s10, l4, c7, u8, f6), m7 = a6, g4 = s10) : (m7 = o8, g4 = i8), o(m7, c7.spatialReference, g4, a6, u8.spatialReference, s10, l4) ? p5 : void 0;
}
function c5(e10, t12, n9, o8, r13) {
  const l4 = (t9(e10) ? e10.z : t10(e10) ? e10.array[e10.offset + 2] : e10[2]) || 0;
  switch (n9.mode) {
    case "on-the-ground": {
      const n10 = a4(t12, e10, "ground") ?? 0;
      return r13.verticalDistanceToGround = 0, r13.sampledElevation = n10, void (r13.z = n10);
    }
    case "relative-to-ground": {
      const i8 = a4(t12, e10, "ground") ?? 0, a6 = n9.geometryZWithOffset(l4, o8);
      return r13.verticalDistanceToGround = a6, r13.sampledElevation = i8, void (r13.z = a6 + i8);
    }
    case "relative-to-scene": {
      const i8 = a4(t12, e10, "scene") ?? 0, a6 = n9.geometryZWithOffset(l4, o8);
      return r13.verticalDistanceToGround = a6, r13.sampledElevation = i8, void (r13.z = a6 + i8);
    }
    case "absolute-height": {
      const i8 = n9.geometryZWithOffset(l4, o8), a6 = a4(t12, e10, "ground") ?? 0;
      return r13.verticalDistanceToGround = i8 - a6, r13.sampledElevation = a6, void (r13.z = i8);
    }
    default:
      return void (r13.z = 0);
  }
}
function u7(e10, t12, n9, o8) {
  return c5(e10, t12, n9, o8, j3), j3.z;
}
function f3(e10, t12, n9) {
  return "on-the-ground" === t12 && "on-the-ground" === n9 ? e10.staysOnTheGround : t12 === n9 || "on-the-ground" !== t12 && "on-the-ground" !== n9 ? null == t12 || null == n9 ? e10.definedChanged : 1 : e10.onTheGroundChanged;
}
function d3(e10) {
  return "relative-to-ground" === e10 || "relative-to-scene" === e10;
}
function m5(e10) {
  return "absolute-height" !== e10;
}
function g3(t12, n9, r13, i8, a6) {
  c5(n9, r13, a6, i8, j3), p3(t12, j3.verticalDistanceToGround);
  const s10 = j3.sampledElevation, l4 = n2(R, t12.transformation);
  O2[0] = n9.x, O2[1] = n9.y, O2[2] = j3.z;
  return f(n9.spatialReference, O2, l4, i8.spatialReference) ? t12.transformation = l4 : console.warn("Could not locate symbol object properly, it might be misplaced"), s10;
}
function p3(e10, t12) {
  for (let n9 = 0; n9 < e10.geometries.length; ++n9) {
    const o8 = e10.geometries[n9].getMutableAttribute("centerOffsetAndDistance");
    o8 && o8.data[3] !== t12 && (o8.data[3] = t12, e10.geometryVertexAttributeUpdated(e10.geometries[n9], "centerOffsetAndDistance"));
  }
}
function v3(e10, t12, n9, o8, r13, i8) {
  let a6 = 0;
  const s10 = i8.spatialReference;
  t12 *= 3, o8 *= 3;
  for (let l4 = 0; l4 < r13; ++l4) {
    const r14 = e10[t12], l5 = e10[t12 + 1], c7 = e10[t12 + 2], u8 = i8.getElevation(r14, l5, c7, s10, "ground") ?? 0;
    a6 += u8, n9[o8] = r14, n9[o8 + 1] = l5, n9[o8 + 2] = u8, t12 += 3, o8 += 3;
  }
  return a6 / r13;
}
function h(e10, t12, n9, o8, r13, i8, a6, s10) {
  let l4 = 0;
  const c7 = s10.calculateOffsetRenderUnits(a6), u8 = s10.featureExpressionInfoContext, f6 = i8.spatialReference;
  t12 *= 3, o8 *= 3;
  for (let d7 = 0; d7 < r13; ++d7) {
    const r14 = e10[t12], a7 = e10[t12 + 1], s11 = e10[t12 + 2], d8 = i8.getElevation(r14, a7, s11, f6, "ground") ?? 0;
    l4 += d8, n9[o8] = r14, n9[o8 + 1] = a7, n9[o8 + 2] = null == u8 ? s11 + d8 + c7 : d8 + c7, t12 += 3, o8 += 3;
  }
  return l4 / r13;
}
function E2(e10, t12, n9, o8, r13, i8, a6, s10) {
  let l4 = 0;
  const c7 = s10.calculateOffsetRenderUnits(a6), u8 = s10.featureExpressionInfoContext, f6 = i8.spatialReference;
  t12 *= 3, o8 *= 3;
  for (let d7 = 0; d7 < r13; ++d7) {
    const r14 = e10[t12], a7 = e10[t12 + 1], s11 = e10[t12 + 2], d8 = i8.getElevation(r14, a7, s11, f6, "scene") ?? 0;
    l4 += d8, n9[o8] = r14, n9[o8 + 1] = a7, n9[o8 + 2] = null == u8 ? s11 + d8 + c7 : d8 + c7, t12 += 3, o8 += 3;
  }
  return l4 / r13;
}
function y2(e10) {
  const t12 = e10.meterUnitOffset, n9 = e10.featureExpressionInfoContext;
  return 0 !== t12 || null != n9;
}
function A2(e10, t12, n9, o8, r13, i8, a6, s10) {
  const l4 = s10.calculateOffsetRenderUnits(a6), c7 = s10.featureExpressionInfoContext;
  t12 *= 3, o8 *= 3;
  for (let u8 = 0; u8 < r13; ++u8) {
    const r14 = e10[t12], i9 = e10[t12 + 1], a7 = e10[t12 + 2];
    n9[o8] = r14, n9[o8 + 1] = i9, n9[o8 + 2] = null == c7 ? a7 + l4 : l4, t12 += 3, o8 += 3;
  }
  return 0;
}
var x2 = class {
  constructor() {
    this.verticalDistanceToGround = 0, this.sampledElevation = 0, this.z = 0;
  }
};
var b4 = { "absolute-height": { applyElevationAlignmentBuffer: A2, requiresAlignment: y2 }, "on-the-ground": { applyElevationAlignmentBuffer: v3, requiresAlignment: () => true }, "relative-to-ground": { applyElevationAlignmentBuffer: h, requiresAlignment: () => true }, "relative-to-scene": { applyElevationAlignmentBuffer: E2, requiresAlignment: () => true } };
var R = e2();
var j3 = new x2();
var O2 = n();

// node_modules/@arcgis/core/views/3d/layers/graphics/featureExpressionInfoUtils.js
var c6 = () => i.getLogger("esri.views.3d.layers.graphics.featureExpressionInfoUtils");
function o6(e10) {
  return { cachedResult: e10.cachedResult, arcade: e10.arcade ? { func: e10.arcade.func, context: e10.arcade.modules.arcadeUtils.createExecContext(null, { sr: e10.arcade.context.spatialReference }), modules: e10.arcade.modules } : null };
}
async function a5(e10, r13, c7, o8) {
  const u8 = e10?.expression;
  if ("string" != typeof u8) return null;
  const a6 = m6(u8);
  if (null != a6) return { cachedResult: a6 };
  const s10 = await e7();
  s(c7);
  const l4 = s10.arcadeUtils, i8 = l4.createSyntaxTree(u8);
  return l4.dependsOnView(i8) ? (null != o8 && o8.error("Expressions containing '$view' are not supported on ElevationInfo"), { cachedResult: 0 }) : { arcade: { func: l4.createFunction(i8), context: l4.createExecContext(null, { sr: r13 }), modules: s10 } };
}
function s8(e10, t12, r13) {
  return e10.arcadeUtils.createFeature(t12.attributes, t12.geometry, r13);
}
function l3(e10, t12) {
  if (null != e10 && !p4(e10)) {
    if (!t12 || !e10.arcade) return void c6().errorOncePerTick("Arcade support required but not provided");
    const n9 = t12;
    n9._geometry && (n9._geometry = u4(n9._geometry)), e10.arcade.modules.arcadeUtils.updateExecContext(e10.arcade.context, t12);
  }
}
function i7(e10) {
  if (null != e10) {
    if (p4(e10)) return e10.cachedResult;
    const t12 = e10.arcade;
    let r13 = t12?.modules.arcadeUtils.executeFunction(t12.func, t12.context);
    return "number" != typeof r13 && (e10.cachedResult = 0, r13 = 0), r13;
  }
  return 0;
}
function d4(e10, t12 = false) {
  let r13 = e10?.featureExpressionInfo;
  const n9 = r13?.expression;
  return t12 || "0" === n9 || (r13 = null), r13 ?? null;
}
var f4 = { cachedResult: 0 };
function p4(e10) {
  return null != e10.cachedResult;
}
function m6(e10) {
  return "0" === e10 ? 0 : null;
}

// node_modules/@arcgis/core/views/3d/layers/graphics/ElevationContext.js
var o7 = class _o {
  constructor() {
    this._meterUnitOffset = 0, this._renderUnitOffset = 0, this._unit = "meters", this._metersPerElevationInfoUnit = 1, this._featureExpressionInfoContext = null, this.mode = null, this.centerInElevationSR = null;
  }
  get featureExpressionInfoContext() {
    return this._featureExpressionInfoContext;
  }
  get meterUnitOffset() {
    return this._meterUnitOffset;
  }
  get unit() {
    return this._unit;
  }
  set unit(e10) {
    this._unit = e10, this._metersPerElevationInfoUnit = n4(e10);
  }
  get requiresSampledElevationInfo() {
    return "absolute-height" !== this.mode;
  }
  reset() {
    this.mode = null, this._meterUnitOffset = 0, this._renderUnitOffset = 0, this._featureExpressionInfoContext = null, this.unit = "meters";
  }
  set offsetMeters(t12) {
    this._meterUnitOffset = t12, this._renderUnitOffset = 0;
  }
  set offsetElevationInfoUnits(t12) {
    this._meterUnitOffset = t12 * this._metersPerElevationInfoUnit, this._renderUnitOffset = 0;
  }
  addOffsetRenderUnits(t12) {
    this._renderUnitOffset += t12;
  }
  geometryZWithOffset(t12, e10) {
    const n9 = this.calculateOffsetRenderUnits(e10);
    return null != this.featureExpressionInfoContext ? n9 : t12 + n9;
  }
  calculateOffsetRenderUnits(t12) {
    let e10 = this._meterUnitOffset;
    const s10 = this.featureExpressionInfoContext;
    return null != s10 && (e10 += i7(s10) * this._metersPerElevationInfoUnit), e10 / t12.unitInMeters + this._renderUnitOffset;
  }
  setFromElevationInfo(t12) {
    this.mode = t12.mode, this.unit = e3(t12.unit) ? t12.unit : "meters", this.offsetElevationInfoUnits = t12.offset ?? 0;
  }
  setFeatureExpressionInfoContext(t12) {
    this._featureExpressionInfoContext = t12;
  }
  updateFeatureExpressionInfoContextForGraphic(t12, e10, n9) {
    t12.arcade ? (this._featureExpressionInfoContext = o6(t12), this.updateFeatureExpressionFeature(e10, n9)) : this._featureExpressionInfoContext = t12;
  }
  updateFeatureExpressionFeature(t12, e10) {
    const n9 = this.featureExpressionInfoContext;
    n9?.arcade && (n9.cachedResult = void 0, l3(this._featureExpressionInfoContext, t12.geometry ? s8(n9.arcade.modules, t12, e10) : null));
  }
  static fromElevationInfo(t12) {
    const e10 = new _o();
    return null != t12 && e10.setFromElevationInfo(t12), e10;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/DirtyEvents.js
var e8 = ["layerObjectAdded", "layerObjectRemoved", "layerObjectsAdded", "layerObjectsRemoved", "transformationChanged", "shaderTransformationChanged", "visibilityChanged", "occlusionChanged", "highlightChanged", "geometryAdded", "geometryRemoved", "attributesChanged"];

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/WebGLLayer.js
var d5 = class {
  constructor(e10, t12, o8 = "") {
    this.stage = e10, this.apiLayerViewUid = o8, this.id = e(), this.events = new i2(), this.visible = true, this.sliceable = false, this._objectsAdded = new Array(), this._handles = new r2(), this._objects = /* @__PURE__ */ new Map(), this._pickable = true, this.visible = t12?.visible ?? true, this._pickable = t12?.pickable ?? true, this.updatePolicy = t12?.updatePolicy ?? 0, e10.addLayer(this);
    for (const s10 of e8) this._handles.add(this.events.on(s10, (t13) => e10.handleEvent(s10, t13)));
  }
  destroy() {
    this._handles.size && (this._handles.destroy(), this.stage.removeLayer(this), this.invalidateSpatialQueryAccelerator());
  }
  get objects() {
    return this._objects;
  }
  getObject(e10) {
    return r(this._objects.get(e10));
  }
  set pickable(e10) {
    this._pickable = e10;
  }
  get pickable() {
    return this._pickable && this.visible;
  }
  add(e10) {
    this._objects.set(e10.id, e10), e10.layer = this, this.events.emit("layerObjectAdded", e10), null != this._octree && this._objectsAdded.push(e10);
  }
  remove(t12) {
    this._objects.delete(t12.id) && (this.events.emit("layerObjectRemoved", t12), t12.layer = null, null != this._octree && (j(this._objectsAdded, t12) || this._octree.remove([t12])));
  }
  addMany(e10) {
    for (const t12 of e10) this._objects.set(t12.id, t12), t12.layer = this;
    this.events.emit("layerObjectsAdded", e10), null != this._octree && this._objectsAdded.push(...e10);
  }
  removeMany(t12) {
    const s10 = new Array();
    for (const e10 of t12) this._objects.delete(e10.id) && s10.push(e10);
    if (0 !== s10.length && (this.events.emit("layerObjectsRemoved", s10), s10.forEach((e10) => e10.layer = null), null != this._octree)) {
      for (let t13 = 0; t13 < s10.length; ) j(this._objectsAdded, s10[t13]) ? (s10[t13] = s10[s10.length - 1], s10.length -= 1) : ++t13;
      this._octree.remove(s10);
    }
  }
  commit() {
    this.stage.commitLayer(this);
  }
  sync() {
    1 !== this.updatePolicy && this.stage.syncLayer(this.id);
  }
  notifyObjectBBChanged(e10, t12) {
    null == this._octree || this._objectsAdded.includes(e10) || this._octree.update(e10, t12);
  }
  getSpatialQueryAccelerator() {
    return null == this._octree && this._objects.size > 50 ? (this._octree = new S((e10) => e10.boundingVolumeWorldSpace.bounds), this._octree.add(this._objects.values())) : null != this._octree && this._objectsAdded.length > 0 && (this._octree.add(this._objectsAdded), this._objectsAdded.length = 0), this._octree;
  }
  invalidateSpatialQueryAccelerator() {
    this._octree = u(this._octree), this._objectsAdded.length = 0;
  }
  get test() {
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/LocalOriginFactory.js
var s9 = class {
  constructor(r13, s10) {
    this.vec3 = r13, this.id = s10;
  }
};
function t11(t12, o8, c7, e10) {
  return new s9(r4(t12, o8, c7), e10);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/testUtils.js
var n8 = { stableRendering: false };
var e9 = { rootOrigin: null };

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/GridLocalOriginFactory.js
var f5 = class {
  constructor(i8) {
    this._originSR = i8, this._rootOriginId = "root/" + e(), this._origins = /* @__PURE__ */ new Map(), this._objects = /* @__PURE__ */ new Map(), this._gridSize = 5e5;
  }
  getOrigin(t12) {
    const r13 = this._origins.get(this._rootOriginId);
    if (null == r13) {
      const i8 = e9.rootOrigin;
      if (null != i8) return this._origins.set(this._rootOriginId, t11(i8[0], i8[1], i8[2], this._rootOriginId)), this.getOrigin(t12);
      const r14 = t11(t12[0] + Math.random() - 0.5, t12[1] + Math.random() - 0.5, t12[2] + Math.random() - 0.5, this._rootOriginId);
      return this._origins.set(this._rootOriginId, r14), r14;
    }
    const o8 = this._gridSize, s10 = Math.round(t12[0] / o8), e10 = Math.round(t12[1] / o8), n9 = Math.round(t12[2] / o8), h2 = `${s10}/${e10}/${n9}`;
    let m7 = this._origins.get(h2);
    const g4 = 0.5 * o8;
    if (c2(d6, t12, r13.vec3), d6[0] = Math.abs(d6[0]), d6[1] = Math.abs(d6[1]), d6[2] = Math.abs(d6[2]), d6[0] < g4 && d6[1] < g4 && d6[2] < g4) {
      if (m7) {
        const r14 = Math.max(...d6);
        c2(d6, t12, m7.vec3), d6[0] = Math.abs(d6[0]), d6[1] = Math.abs(d6[1]), d6[2] = Math.abs(d6[2]);
        if (Math.max(...d6) < r14) return m7;
      }
      return r13;
    }
    return m7 || (m7 = t11(s10 * o8, e10 * o8, n9 * o8, h2), this._origins.set(h2, m7)), m7;
  }
  _drawOriginBox(t12, i8 = r7(1, 1, 0, 1)) {
    const r13 = window.view, a6 = r13.stage, c7 = i8.toString();
    if (!this._objects.has(c7)) {
      this._material = new J({ width: 2, color: i8 }, false);
      const t13 = new d5(a6, { pickable: false }), r14 = new W({ castShadow: false });
      t13.add(r14), this._objects.set(c7, r14);
    }
    const f6 = this._objects.get(c7), d7 = [0, 1, 5, 4, 0, 2, 1, 7, 6, 2, 0, 1, 3, 7, 5, 4, 6, 2, 0], l4 = d7.length, _3 = new Array(3 * l4), p5 = new Array(), j4 = 0.5 * this._gridSize;
    for (let o8 = 0; o8 < l4; o8++) _3[3 * o8] = t12[0] + (1 & d7[o8] ? j4 : -j4), _3[3 * o8 + 1] = t12[1] + (2 & d7[o8] ? j4 : -j4), _3[3 * o8 + 2] = t12[2] + (4 & d7[o8] ? j4 : -j4), o8 > 0 && p5.push(o8 - 1, o8);
    o(_3, this._originSR, 0, _3, r13.renderSpatialReference, 0, l4);
    const b5 = new m3(this._material, [["position", new t2(_3, p5, 3, true)]], null, 2);
    f6.addGeometry(b5);
  }
  get test() {
  }
};
var d6 = n();

export {
  n6 as n,
  l,
  W,
  d5 as d,
  t11 as t,
  n8 as n2,
  J,
  f5 as f,
  r12 as r,
  a4 as a,
  l2,
  c5 as c,
  u7 as u,
  f3 as f2,
  d3 as d2,
  m5 as m,
  g3 as g,
  p3 as p,
  x2 as x,
  a5 as a2,
  d4 as d3,
  f4 as f3,
  o7 as o
};
//# sourceMappingURL=chunk-Q4G6BRR7.js.map
