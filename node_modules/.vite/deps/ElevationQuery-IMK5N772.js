import {
  r
} from "./chunk-TKBXUE73.js";
import {
  e
} from "./chunk-M24KZOVI.js";
import {
  _ as _2
} from "./chunk-XL5QPCXN.js";
import {
  N,
  W
} from "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-3FUHCAX3.js";
import "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import {
  E,
  c as c2,
  i as i2,
  o,
  z
} from "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import {
  l
} from "./chunk-TFJXG32O.js";
import "./chunk-SMWUT52Z.js";
import {
  _,
  y
} from "./chunk-AXZMNHTN.js";
import {
  f as f2
} from "./chunk-5T3MJDSR.js";
import {
  ae
} from "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import {
  f2 as f,
  n,
  p
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  c
} from "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/layers/support/ElevationQueryContext.js
var s2 = class {
  constructor(e3, t3) {
    this.layer = e3, this.parameters = t3;
  }
};
var l2 = class extends s2 {
  constructor(e3, t3, i4) {
    super(e3, i4), this.outSpatialReference = t3, this.type = "geometry";
  }
  selectTilesAtLOD(e3) {
    if (e3 < 0) this.geometry.coordinates.forEach((e4) => e4.tile = null);
    else {
      const { tileInfo: t3, tilemapCache: i4 } = this.layer, s3 = a2(t3, i4)[e3].level;
      this.geometry.coordinates.forEach((e4) => e4.tile = t3.tileAt(s3, e4.x, e4.y));
    }
  }
  allElevationTilesFetched() {
    return !this.geometry.coordinates.some((e3) => !e3.elevationTile);
  }
  clearElevationTiles() {
    for (const e3 of this.geometry.coordinates) e3.elevationTile !== this.outsideExtentTile && (e3.elevationTile = null);
  }
  populateElevationTiles(e3) {
    for (const t3 of this.geometry.coordinates) !t3.elevationTile && t3.tile?.id && (t3.elevationTile = e3[t3.tile.id]);
  }
  remapTiles(e3) {
    for (const t3 of this.geometry.coordinates) {
      const i4 = t3.tile?.id;
      t3.tile = i4 ? e3[i4] : null;
    }
  }
  getTilesToFetch() {
    return c(this.geometry.coordinates.filter(({ tile: e3, elevationTile: t3 }) => e3?.id && !t3), (e3, t3) => e3.tile?.id === t3.tile?.id).map(({ tile: e3 }) => e3);
  }
  forEachTileToFetch(e3) {
    for (const t3 of this.geometry.coordinates) t3.tile && !t3.elevationTile && e3(t3.tile, () => t3.tile = null);
  }
};
var n2 = class extends s2 {
  constructor(e3, t3, i4, s3) {
    super(e3, i4), this.maskExtents = s3, this.type = "extent", this.elevationTiles = [], this._candidateTiles = [], this._fetchedCandidates = /* @__PURE__ */ new Set(), this.extent = t3.clone().intersection(e3.fullExtent);
  }
  selectTilesAtLOD(e3, t3) {
    const i4 = this._maximumLodForRequests(t3), s3 = Math.min(i4, e3);
    s3 < 0 ? this._candidateTiles.length = 0 : this._selectCandidateTilesCoveringExtentAt(s3);
  }
  _maximumLodForRequests(e3) {
    const { tileInfo: t3, tilemapCache: i4 } = this.layer, s3 = a2(t3, i4);
    if (!e3) return s3.length - 1;
    const l4 = this.extent;
    if (null == l4) return -1;
    for (let n3 = s3.length - 1; n3 >= 0; n3--) {
      const i5 = s3[n3], o3 = i5.resolution * t3.size[0], a4 = i5.resolution * t3.size[1];
      if (Math.ceil(l4.width / o3) * Math.ceil(l4.height / a4) <= e3) return n3;
    }
    return -1;
  }
  allElevationTilesFetched() {
    return this._candidateTiles.length === this.elevationTiles.length;
  }
  clearElevationTiles() {
    this.elevationTiles.length = 0, this._fetchedCandidates.clear();
  }
  populateElevationTiles(e3) {
    for (const t3 of this._candidateTiles) {
      const i4 = t3.id && e3[t3.id];
      i4 && (this._fetchedCandidates.add(t3), this.elevationTiles.push(i4));
    }
  }
  remapTiles(e3) {
    this._candidateTiles = r2(this._candidateTiles.map((t3) => e3[t3.id]));
  }
  getTilesToFetch() {
    return this._candidateTiles;
  }
  forEachTileToFetch(e3, t3) {
    const i4 = this._candidateTiles;
    this._candidateTiles = [], i4.forEach((i5) => {
      if (this._fetchedCandidates.has(i5)) return void t3?.(i5);
      let s3 = false;
      e3(i5, () => s3 = true), s3 ? t3?.(i5) : this._candidateTiles.push(i5);
    }), this._candidateTiles = r2(this._candidateTiles, t3);
  }
  _selectCandidateTilesCoveringExtentAt(e3) {
    this._candidateTiles.length = 0;
    const t3 = this.extent;
    if (null == t3) return;
    const { tileInfo: s3, tilemapCache: l4 } = this.layer, n3 = a2(s3, l4)[e3], o3 = s3.tileAt(n3.level, t3.xmin, t3.ymin), r3 = o3.extent, c5 = n3.resolution * s3.size[0], h2 = n3.resolution * s3.size[1], d = Math.ceil((t3.xmax - r3[0]) / c5), f3 = Math.ceil((t3.ymax - r3[1]) / h2);
    for (let a4 = 0; a4 < f3; a4++) for (let e4 = 0; e4 < d; e4++) {
      const t4 = new e(o3.level, o3.row - a4, o3.col + e4);
      s3.updateTileInfo(t4), this._tileIsMasked(t4) || this._candidateTiles.push(t4);
    }
  }
  _tileIsMasked(e3) {
    return this.maskExtents?.some((i4) => z(i4, e3.extent)) ?? false;
  }
};
function o2(e3) {
  return null != e3?.tileInfo;
}
function a2(e3, t3) {
  const i4 = e3.lods;
  if (o2(t3)) {
    const { effectiveMinLOD: e4, effectiveMaxLOD: s3 } = t3;
    return i4.filter((t4) => t4.level >= e4 && t4.level <= s3);
  }
  return i4;
}
function r2(e3, i4) {
  const s3 = {}, l4 = [];
  for (const t3 of e3) {
    const e4 = t3.id;
    e4 && !s3[e4] ? (s3[e4] = t3, l4.push(t3)) : i4?.(t3);
  }
  const n3 = l4.sort((e4, t3) => e4.level - t3.level);
  return n3.filter((e4, s4) => {
    for (let l5 = 0; l5 < s4; l5++) {
      const s5 = n3[l5].extent;
      if (s5 && z(s5, e4.extent)) return i4?.(e4), false;
    }
    return true;
  });
}

// node_modules/@arcgis/core/layers/support/ElevationSamplerData.js
var t = class {
  constructor(t3, h2) {
    this.data = t3, this.safeWidth = 0.99999999 * (t3.width - 1), this.dx = (t3.width - 1) / (h2[2] - h2[0]), this.dy = (t3.width - 1) / (h2[3] - h2[1]), this.x0 = h2[0], this.y1 = h2[3];
  }
};

// node_modules/@arcgis/core/layers/support/ElevationTile.js
var t2 = class {
  constructor(t3, e3 = null) {
    if (this.key = t3, null != e3) {
      const s3 = t3.extent;
      this._samplerData = new t(e3, s3);
    }
  }
  get zmin() {
    return null != this._samplerData ? this._samplerData.data.minValue : 0;
  }
  get zmax() {
    return null != this._samplerData ? this._samplerData.data.maxValue : 0;
  }
  get hasNoDataValues() {
    return !!this._samplerData?.data.hasNoDataValues;
  }
  sample(a4, t3) {
    if (null == this._samplerData) return;
    const { safeWidth: s3, data: l4, dx: r3, dy: n3, y1: i4, x0: u } = this._samplerData, { width: o3, values: m2, noDataValue: h2 } = l4, p4 = e2(n3 * (i4 - t3), 0, s3), D2 = e2(r3 * (a4 - u), 0, s3), d = Math.floor(p4), f3 = Math.floor(D2), _3 = d * o3 + f3, c5 = _3 + o3, x2 = m2[_3], V2 = m2[c5], g2 = m2[_3 + 1], y2 = m2[c5 + 1];
    if (x2 !== h2 && V2 !== h2 && g2 !== h2 && y2 !== h2) {
      const a5 = D2 - f3, t4 = x2 + (g2 - x2) * a5;
      return t4 + (V2 + (y2 - V2) * a5 - t4) * (p4 - d);
    }
  }
};
function e2(a4, t3, e3) {
  return a4 < t3 ? t3 : a4 > e3 ? e3 : a4;
}

// node_modules/@arcgis/core/layers/support/ElevationSampler.js
var i3 = class extends l {
  queryElevation(e3) {
    const t3 = this.projectIfRequired(e3, this.spatialReference);
    if (!t3) return null;
    switch (e3.type) {
      case "point":
        return a3(e3, t3, this);
      case "polyline":
        return l3(e3, t3, this);
      case "multipoint":
        return c3(e3, t3, this);
      default:
        return null;
    }
  }
  projectIfRequired(e3, t3) {
    if (null == e3) return null;
    const o3 = e3.spatialReference;
    if (o3.equals(t3)) return e3;
    const s3 = y(e3, t3);
    return s3 || i.getLogger(this).error(`Cannot project geometry spatial reference (wkid:${o3.wkid}) to elevation sampler spatial reference (wkid:${t3.wkid})`), s3;
  }
};
function a3(e3, t3, r3) {
  return e3.hasZ = true, e3.z = r3.elevationAt(t3.x, t3.y), e3;
}
function l3(e3, t3, r3) {
  p2.spatialReference = t3.spatialReference;
  const o3 = e3.hasM && !e3.hasZ;
  for (let s3 = 0; s3 < e3.paths.length; s3++) {
    const n3 = e3.paths[s3], i4 = t3.paths[s3];
    for (let e4 = 0; e4 < n3.length; e4++) {
      const t4 = n3[e4], s4 = i4[e4];
      p2.x = s4[0], p2.y = s4[1], o3 && (t4[3] = t4[2]), t4[2] = r3.elevationAt(p2.x, p2.y);
    }
  }
  return e3.hasZ = true, e3;
}
function c3(e3, t3, r3) {
  p2.spatialReference = t3.spatialReference;
  const o3 = e3.hasM && !e3.hasZ;
  for (let s3 = 0; s3 < e3.points.length; s3++) {
    const n3 = e3.points[s3], i4 = t3.points[s3];
    p2.x = i4[0], p2.y = i4[1], o3 && (n3[3] = n3[2]), n3[2] = r3.elevationAt(p2.x, p2.y);
  }
  return e3.hasZ = true, e3;
}
i3 = __decorate([a("esri.layers.support.ElevationSampler")], i3);
var p2 = new _();

// node_modules/@arcgis/core/layers/support/TileElevationSampler.js
var p3 = class extends i3 {
  get spatialReference() {
    return this.extent.spatialReference;
  }
  constructor(t3) {
    const e3 = t3.noDataValue, o3 = "tiles" in t3 ? t3.tiles.map((o4) => new c4({ tile: o4, tileInfo: t3.tileInfo, noDataValue: e3 })) : t3.samplers;
    super({ noDataValue: e3, samplers: o3 });
    const n3 = o3[0];
    if (n3) {
      this.extent = n3.extent.clone();
      const { min: t4, max: e4 } = n3.demResolution;
      this.demResolution = { min: t4, max: e4 };
      for (let n4 = 1; n4 < o3.length; n4++) {
        const t5 = o3[n4];
        this.extent.union(t5.extent), this.demResolution.min = Math.min(this.demResolution.min, t5.demResolution.min), this.demResolution.max = Math.max(this.demResolution.max, t5.demResolution.max);
      }
    } else {
      const e4 = "tileInfo" in t3 ? t3.tileInfo : null;
      this.extent = c2(i2(), e4?.spatialReference ?? f2.WGS84), this.demResolution = { min: 0, max: 0 };
    }
  }
  elevationAt(t3, o3) {
    let n3;
    for (const e3 of this.samplers) if (e3.containsAt(t3, o3) && (n3 = e3.elevationAt(t3, o3), n3 !== e3.noDataValue)) return n3;
    return null != n3 ? n3 : (i.getLogger(this).warn("#elevationAt()", `Point used to sample elevation (${t3}, ${o3}) is outside of the sampler`), this.noDataValue);
  }
};
__decorate([m({ constructOnly: true })], p3.prototype, "noDataValue", void 0), __decorate([m({ constructOnly: true })], p3.prototype, "samplers", void 0), p3 = __decorate([a("esri.layers.support.TileElevationSampler")], p3);
var c4 = class extends i3 {
  get spatialReference() {
    return this.extent.spatialReference;
  }
  constructor(t3) {
    super(t3);
    const e3 = t3.tile.key.extent;
    this.extent = c2(e3, t3.tileInfo.spatialReference), this.extent.zmin = t3.tile.zmin, this.extent.zmax = t3.tile.zmax;
    const n3 = ae(t3.tileInfo.spatialReference), i4 = t3.tileInfo.lodAt(t3.tile.key.level).resolution * n3;
    this.demResolution = { min: i4, max: i4 };
  }
  contains(t3) {
    const e3 = this.projectIfRequired(t3, this.spatialReference);
    return null != e3 && this.containsAt(e3.x, e3.y);
  }
  containsAt(t3, e3) {
    return E(this.tile.key.extent, t3, e3);
  }
  elevationAt(t3, e3) {
    return this.containsAt(t3, e3) ? this.tile.sample(t3, e3) ?? this.noDataValue : this.noDataValue;
  }
};
__decorate([m({ constructOnly: true })], c4.prototype, "tile", void 0), __decorate([m({ constructOnly: true })], c4.prototype, "noDataValue", void 0), __decorate([m({ constructOnly: true })], c4.prototype, "tileInfo", void 0), c4 = __decorate([a("esri.layers.support.TileElevationSampler.SingleTileElevationSampler")], c4);

// node_modules/@arcgis/core/layers/support/ElevationQuery.js
async function h(e3, n3, a4) {
  if (e3 = a4?.ignoreInvisibleLayers ? e3.filter((e4) => e4.visible) : e3.slice(), !e3.length) throw new s(G, "Elevation queries require at least one elevation layer to fetch tiles from");
  const o3 = r.fromGeometry(n3), i4 = { ...A, ...a4, returnSampleInfo: true }, l4 = e3.pop(), r3 = await v(l4, o3, i4), s3 = await x(e3, r3, i4);
  return s3.geometry = s3.geometry.export(), a4?.returnSampleInfo || delete s3.sampleInfo, s3;
}
async function v(e3, n3, a4) {
  if (!e3) throw new s(G, "Elevation queries require an elevation layer to fetch tiles from");
  if (!n3 || !(n3 instanceof r) && "point" !== n3.type && "multipoint" !== n3.type && "polyline" !== n3.type) throw new s("elevation-query:invalid-geometry", "Only point, polyline and multipoint geometries can be used to query elevation");
  const o3 = { ...A, ...a4 }, i4 = new l2(e3, n3.spatialReference, o3), l4 = o3.signal;
  return await e3.load({ signal: l4 }), await V(i4, n3, l4), await R(i4, l4), await L(i4, l4), k(i4), O(i4, l4);
}
async function g(e3, n3, a4) {
  if (e3 = Array.isArray(e3) ? e3 : [e3], 0 === (e3 = a4?.ignoreInvisibleLayers ? e3.filter((e4) => e4.visible) : e3.slice()).length) throw new s(G, "Elevation queries require at least one elevation layer to fetch tiles from");
  if (!n3 || "extent" !== n3.type) throw new s("elevation-query:invalid-extent", "Invalid or undefined extent");
  const o3 = { ...A, ...a4, returnSampleInfo: true }, i4 = T(e3[e3.length - 1], n3, o3);
  if (1 === e3.length) return i4;
  return I(e3, n3, await i4, o3);
}
async function T(e3, t3, n3, a4) {
  const o3 = n3.signal;
  await e3.load({ signal: o3 });
  const i4 = t3.spatialReference, s3 = e3.tileInfo.spatialReference;
  i4.equals(s3) || (await N([{ source: i4, dest: s3 }], { signal: o3 }), t3 = W(t3, s3));
  const c5 = new n2(e3, t3, n3, a4);
  await R(c5, o3), await L(c5, o3);
  const m2 = c5.elevationTiles, f3 = c5.layer.tileInfo, p4 = c5.parameters.noDataValue;
  return new p3({ noDataValue: p4, tiles: m2, tileInfo: f3 });
}
async function I(e3, t3, n3, a4) {
  if (e3.pop(), !e3.length) return n3;
  const o3 = n3.samplers.filter((e4) => !e4.tile.hasNoDataValues).map((e4) => o(e4.extent)), i4 = await T(e3[e3.length - 1], t3, a4, o3);
  if (0 === i4.samplers.length) return n3;
  const l4 = n3.samplers.concat(i4.samplers), r3 = a4.noDataValue;
  return I(e3, t3, new p3({ samplers: l4, noDataValue: r3 }), a4);
}
async function x(e3, t3, a4) {
  const o3 = t3.geometry.coordinates, i4 = t3.sampleInfo;
  n(i4);
  const l4 = new Array(), r3 = new Array();
  for (let n3 = 0; n3 < o3.length; n3++) {
    i4[n3].demResolution < 0 && e3.length && (l4.push(o3[n3]), r3.push(n3));
  }
  const s3 = e3.pop();
  if (null == s3 || 0 === l4.length) return t3;
  const c5 = t3.geometry.clone(l4), u = await v(s3, c5, a4), m2 = u.sampleInfo;
  if (!m2) throw new Error("no sampleInfo");
  return r3.forEach((e4, t4) => {
    o3[e4].z = u.geometry.coordinates[t4].z, i4[e4].demResolution = m2[t4].demResolution, i4[e4].source = m2[t4].source;
  }), x(e3, t3, a4);
}
async function R(e3, n3) {
  "geometry" === e3.type && S(e3);
  const a4 = e3.parameters.demResolution;
  if ("number" == typeof a4) F(e3, a4);
  else if ("finest-contiguous" === a4) await E2(e3, n3);
  else {
    if ("auto" !== a4) throw new s("elevation-query:invalid-dem-resolution", `Invalid dem resolution value '${a4}', expected a number, "finest-contiguous" or "auto"`);
    await q(e3, n3);
  }
}
async function E2(e3, t3) {
  const { tileInfo: n3, tilemapCache: a4 } = e3.layer, o3 = b(n3, a4, e3.parameters.minDemResolution);
  await D(e3, o3, t3);
}
async function D(e3, n3, i4) {
  const l4 = e3.layer;
  if (e3.selectTilesAtLOD(n3), n3 < 0) return;
  const r3 = l4.tilemapCache, s3 = e3.getTilesToFetch();
  try {
    if (r3 && !o2(r3)) await p(Promise.all(s3.map((e4) => r3.fetchAvailability(e4.level, e4.row, e4.col, { signal: i4 }))), i4);
    else if (await L(e3, i4), !e3.allElevationTilesFetched()) throw e3.clearElevationTiles(), new s("elevation-query:has-unavailable-tiles", "Some elevation tiles are unavailable");
  } catch (c5) {
    f(c5), await D(e3, n3 - 1, i4);
  }
}
async function q(t3, n3) {
  $(t3), U(t3);
  const i4 = t3.layer.tilemapCache;
  if (!i4 || o2(i4)) return j(t3, n3);
  const l4 = t3.getTilesToFetch(), r3 = {}, s3 = l4.map(async (t4) => {
    const a4 = new e(0, 0, 0), l5 = await _2(i4.fetchAvailabilityUpsample(t4.level, t4.row, t4.col, a4, { signal: n3 }));
    false !== l5.ok ? null != t4.id && (r3[t4.id] = a4) : f(l5.error);
  });
  await p(Promise.all(s3), n3), t3.remapTiles(r3);
}
async function j(e3, t3) {
  const n3 = e3.layer.tileInfo;
  await L(e3, t3);
  let a4 = false;
  e3.forEachTileToFetch((e4, t4) => {
    n3.upsampleTile(e4) ? a4 = true : t4();
  }), a4 && await j(e3, t3);
}
function b(e3, t3, n3 = 0) {
  const a4 = a2(e3, t3);
  let o3 = a4.length - 1;
  if (n3 > 0) {
    const t4 = n3 / ae(e3.spatialReference), l4 = a4.findIndex((e4) => e4.resolution < t4);
    0 === l4 ? o3 = 0 : l4 > 0 && (o3 = l4 - 1);
  }
  return o3;
}
var A = { maximumAutoTileRequests: 20, noDataValue: 0, returnSampleInfo: false, demResolution: "auto", minDemResolution: 0, signal: null };
async function V(e3, n3, a4) {
  let o3;
  const i4 = e3.layer.tileInfo.spatialReference;
  if (n3 instanceof r ? o3 = await n3.project(i4, a4) : (await N([{ source: n3.spatialReference, dest: i4 }], { signal: a4 }), o3 = W(n3, i4)), !o3) throw new s("elevation-query:spatial-reference-mismatch", `Cannot query elevation in '${n3.spatialReference.wkid}' on an elevation service in '${i4.wkid}'`);
  e3.geometry = r.fromGeometry(o3);
}
function S(e3) {
  if (null == e3.layer.fullExtent) return;
  const t3 = new t2(new e(-1, -1, -1));
  t3.sample = () => e3.parameters.noDataValue, e3.outsideExtentTile = t3;
  const n3 = e3.layer.fullExtent;
  e3.geometry.coordinates.forEach((e4) => {
    const a4 = e4.x, o3 = e4.y;
    (a4 < n3.xmin || a4 > n3.xmax || o3 < n3.ymin || o3 > n3.ymax) && (e4.elevationTile = t3);
  });
}
function C(e3, t3) {
  const { tileInfo: n3, tilemapCache: a4 } = e3.layer, o3 = t3 / ae(n3.spatialReference), l4 = a2(n3, a4);
  let r3 = l4[0], s3 = 0;
  for (let i4 = 1; i4 < l4.length; i4++) {
    const e4 = l4[i4];
    Math.abs(e4.resolution - o3) < Math.abs(r3.resolution - o3) && (r3 = e4, s3 = i4);
  }
  return s3;
}
function F(e3, t3) {
  const n3 = C(e3, t3);
  e3.selectTilesAtLOD(n3);
}
function $(e3) {
  const { tileInfo: t3, tilemapCache: n3 } = e3.layer, a4 = b(t3, n3, e3.parameters.minDemResolution);
  e3.selectTilesAtLOD(a4, e3.parameters.maximumAutoTileRequests);
}
async function L(e3, t3) {
  const n3 = e3.getTilesToFetch(), o3 = {}, i4 = e3.parameters.cache, l4 = e3.parameters.noDataValue, r3 = { noDataValue: l4, signal: t3 }, s3 = n3.map(async (t4) => {
    if (null == t4.id) return;
    const n4 = `${e3.layer.uid}:${t4.id}:${l4}`, a4 = i4?.get(n4), s4 = a4 ?? await e3.layer.fetchTile(t4.level, t4.row, t4.col, r3);
    i4?.put(n4, s4), o3[t4.id] = new t2(t4, s4);
  });
  await p(Promise.allSettled(s3), t3), e3.populateElevationTiles(o3);
}
function U(e3) {
  const t3 = e3.layer.tileInfo;
  let n3 = 0;
  const a4 = {}, o3 = (e4) => {
    null != e4.id && (e4.id in a4 ? a4[e4.id]++ : (a4[e4.id] = 1, n3++));
  }, i4 = (e4) => {
    if (null == e4.id) return;
    const t4 = a4[e4.id];
    1 === t4 ? (delete a4[e4.id], n3--) : a4[e4.id] = t4 - 1;
  };
  e3.forEachTileToFetch(o3, i4);
  let l4 = true;
  for (; l4 && (l4 = false, e3.forEachTileToFetch((a5) => {
    n3 <= e3.parameters.maximumAutoTileRequests || (i4(a5), t3.upsampleTile(a5) && (l4 = true), o3(a5));
  }, i4), l4); ) ;
}
function k(e3) {
  e3.geometry.coordinates.forEach((t3) => {
    const n3 = t3.elevationTile;
    let a4 = e3.parameters.noDataValue;
    if (n3) {
      const e4 = n3.sample(t3.x, t3.y);
      null == e4 ? t3.elevationTile = null : a4 = e4;
    }
    t3.z = a4;
  });
}
async function O(e3, t3) {
  const a4 = await e3.geometry.project(e3.outSpatialReference, t3);
  n(a4);
  const o3 = { geometry: a4.export(), noDataValue: e3.parameters.noDataValue };
  return e3.parameters.returnSampleInfo && (o3.sampleInfo = z2(e3)), e3.geometry.coordinates.forEach((e4) => {
    e4.tile = null, e4.elevationTile = null;
  }), o3;
}
function z2(e3) {
  const t3 = e3.layer.tileInfo, n3 = ae(t3.spatialReference);
  return e3.geometry.coordinates.map((a4) => {
    let o3 = -1;
    if (a4.elevationTile && a4.elevationTile !== e3.outsideExtentTile) {
      o3 = t3.lodAt(a4.elevationTile.key.level).resolution * n3;
    }
    return { demResolution: o3, source: -1 === o3 ? void 0 : e3.layer };
  });
}
var G = "elevation-query:invalid-layer";
export {
  G as InvalidLayerError,
  g as createSampler,
  A as defaultOptions,
  b as getFinestLodIndex,
  v as query,
  h as queryAll
};
//# sourceMappingURL=ElevationQuery-IMK5N772.js.map
