import {
  f
} from "./chunk-5T3MJDSR.js";
import {
  C,
  G,
  I,
  T,
  c,
  o as o2
} from "./chunk-NMQNUPE4.js";
import {
  t
} from "./chunk-6KIXN4DJ.js";
import {
  s as s2
} from "./chunk-WRA2WBYC.js";
import {
  o
} from "./chunk-XWE6BM2U.js";
import {
  r
} from "./chunk-SOIZOFSB.js";
import {
  n
} from "./chunk-XXLHAM2M.js";
import {
  b,
  m
} from "./chunk-5EI5H4QX.js";
import {
  a as a2,
  a2 as a3
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  a,
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/geometry/Geometry.js
var c2 = class extends n {
  constructor(...e2) {
    super(...e2), this.type = null, this.hasM = false, this.hasZ = false, this.spatialReference = f.WGS84;
  }
  get cache() {
    return this.commitProperty("spatialReference"), {};
  }
  get extent() {
    return null;
  }
  readSpatialReference(e2, r3) {
    if (e2 instanceof f) return e2;
    if (null != e2) {
      const t2 = new f();
      return t2.read(e2, r3), t2;
    }
    return e2;
  }
  clone() {
    return console.warn(".clone() is not implemented for " + this.declaredClass), null;
  }
  clearCache() {
    this.notifyChange("cache");
  }
  getCacheValue(e2) {
    return this.cache[e2];
  }
  setCacheValue(e2, r3) {
    this.cache[e2] = r3;
  }
};
__decorate([m()], c2.prototype, "type", void 0), __decorate([m({ readOnly: true })], c2.prototype, "cache", null), __decorate([m({ readOnly: true })], c2.prototype, "extent", null), __decorate([m({ type: Boolean, json: { write: { overridePolicy: (e2) => ({ enabled: e2 }) } } })], c2.prototype, "hasM", void 0), __decorate([m({ type: Boolean, json: { write: { overridePolicy: (e2) => ({ enabled: e2 }) } } })], c2.prototype, "hasZ", void 0), __decorate([m({ type: f, json: { write: true }, value: f.WGS84 })], c2.prototype, "spatialReference", void 0), __decorate([o("spatialReference")], c2.prototype, "readSpatialReference", null), c2 = __decorate([a3("esri.geometry.Geometry")], c2);

// node_modules/@arcgis/core/geometry/asserts.js
function o3(o5) {
  if (o5 && "object" == typeof o5 && "type" in o5 && "mesh" === o5.type) throw new s("internal:mesh", "Mesh geometries are not supported for this operation");
}
function r2(e2) {
  e2.forEach(o3);
}

// node_modules/@arcgis/core/geometry/support/webMercatorUtils.js
var l = 57.29577951308232;
var u = 0.017453292519943;
function f2(n2) {
  return n2 * l;
}
function p(n2) {
  return n2 * u;
}
function h(n2) {
  return Math.PI / 2 - 2 * Math.atan(Math.exp(-n2 / t.radius));
}
function m2(n2) {
  return null != n2.wkid || null != n2.wkt;
}
var x = [0, 0];
function g(n2, t2, e2, i3, r3) {
  const s3 = n2, a4 = r3;
  if (a4.spatialReference = e2, "x" in s3 && "x" in a4) [a4.x, a4.y] = t2(s3.x, s3.y, x, i3);
  else if ("xmin" in s3 && "xmin" in a4) [a4.xmin, a4.ymin] = t2(s3.xmin, s3.ymin, x, i3), [a4.xmax, a4.ymax] = t2(s3.xmax, s3.ymax, x, i3);
  else if ("paths" in s3 && "paths" in a4 || "rings" in s3 && "rings" in a4) {
    const n3 = "paths" in s3 ? s3.paths : s3.rings, e3 = [];
    let r4;
    for (let s4 = 0; s4 < n3.length; s4++) {
      const a5 = n3[s4];
      r4 = [], e3.push(r4);
      for (let n4 = 0; n4 < a5.length; n4++) r4.push(t2(a5[n4][0], a5[n4][1], [0, 0], i3)), a5[n4].length > 2 && r4[n4].push(a5[n4][2]), a5[n4].length > 3 && r4[n4].push(a5[n4][3]);
    }
    "paths" in a4 ? a4.paths = e3 : a4.rings = e3;
  } else if ("points" in s3 && "points" in a4) {
    const n3 = s3.points, e3 = [];
    for (let r4 = 0; r4 < n3.length; r4++) e3[r4] = t2(n3[r4][0], n3[r4][1], [0, 0], i3), n3[r4].length > 2 && e3[r4].push(n3[r4][2]), n3[r4].length > 3 && e3[r4].push(n3[r4][3]);
    a4.points = e3;
  }
  return r3;
}
function M(n2, t2) {
  const e2 = n2 && (m2(n2) ? n2 : n2.spatialReference), i3 = t2 && (m2(t2) ? t2 : t2.spatialReference);
  return !(n2 && "type" in n2 && "mesh" === n2.type || t2 && "type" in t2 && "mesh" === t2.type || !e2 || !i3) && (!!T(i3, e2) || (C(i3) && I(e2) || C(e2) && I(i3)));
}
function y(t2, i3) {
  if (null == t2) return null;
  const r3 = t2.spatialReference, l3 = i3 && (m2(i3) ? i3 : i3.spatialReference);
  return M(r3, l3) ? T(r3, l3) ? a(t2) : C(l3) ? g(t2, d, f.WebMercator, false, a(t2)) : I(l3) ? g(t2, R, f.WGS84, false, a(t2)) : null : null;
}
function d(n2, t2, e2 = [0, 0]) {
  t2 > 89.99999 ? t2 = 89.99999 : t2 < -89.99999 && (t2 = -89.99999);
  const r3 = p(t2);
  return e2[0] = p(n2) * t.radius, e2[1] = t.halfSemiMajorAxis * Math.log((1 + Math.sin(r3)) / (1 - Math.sin(r3))), e2;
}
function R(n2, t2, e2 = [0, 0], s3 = false) {
  if (n2 === o2[0]) e2[0] = -180;
  else if (n2 === o2[1]) e2[0] = 180;
  else {
    const t3 = f2(n2 / t.radius);
    e2[0] = s3 ? t3 : t3 - 360 * Math.floor((t3 + 180) / 360);
  }
  return e2[1] = f2(Math.PI / 2 - 2 * Math.atan(Math.exp(-t2 / t.radius))), e2;
}
function j(i3, r3 = false, s3 = a(i3)) {
  return o3(i3), o3(s3), g(i3, d, f.WebMercator, r3, s3);
}
function S(i3, r3 = false, s3 = a(i3)) {
  return o3(i3), o3(s3), g(i3, R, f.WGS84, r3, s3);
}

// node_modules/@arcgis/core/geometry/support/pointUtils.js
function e(n2, r3) {
  const t2 = n2.x - r3.x, e2 = n2.y - r3.y, u3 = null != n2.z && null != r3.z ? n2.z - r3.z : 0;
  return Math.sqrt(t2 * t2 + e2 * e2 + u3 * u3);
}
function u2(n2) {
  return i2(n2, o4)?.[0] ?? null;
}
function l2(n2) {
  return i2(n2, o4)?.[1] ?? null;
}
function i2({ x: e2, y: u3, spatialReference: l3 }, i3 = [0, 0]) {
  if (l3) {
    if (C(l3)) return R(e2, u3, i3);
    if (c(l3)) return i3[0] = e2, i3[1] = u3, i3;
  }
  return null;
}
var o4 = [0, 0];

// node_modules/@arcgis/core/geometry/Point.js
var g2;
var w = [0, 0];
function x2(t2) {
  return t2 && ("esri.geometry.SpatialReference" === t2.declaredClass || null != t2.wkid);
}
var _ = g2 = class extends c2 {
  static copy(t2, r3) {
    r3._set("x", t2._get("x")), r3._set("y", t2._get("y")), r3._set("z", t2._get("z")), r3._set("m", t2._get("m"));
    const s3 = t2._get("spatialReference");
    r3._set("spatialReference", b.isFrozen(s3) ? s3 : s3.clone());
  }
  constructor(...t2) {
    super(...t2), this.x = 0, this.y = 0, this.z = void 0, this.m = void 0, this.type = "point";
  }
  normalizeCtorArgs(t2, e2, s3, i3, o5) {
    let l3;
    if (Array.isArray(t2)) l3 = t2, o5 = e2, t2 = l3[0], e2 = l3[1], s3 = l3[2], i3 = l3[3];
    else if (t2 && "object" == typeof t2) {
      if (l3 = t2, t2 = null != l3.x ? l3.x : l3.longitude, e2 = null != l3.y ? l3.y : l3.latitude, s3 = l3.z, i3 = l3.m, (o5 = l3.spatialReference) && "esri.geometry.SpatialReference" !== o5.declaredClass && (o5 = new f(o5)), null != l3.longitude || null != l3.latitude) {
        if (null == l3.longitude) i.getLogger(this).warn(".longitude=", "Latitude was defined without longitude");
        else if (null == l3.latitude) i.getLogger(this).warn(".latitude=", "Longitude was defined without latitude");
        else if (!l3.declaredClass && o5?.isWebMercator) {
          const r3 = d(l3.longitude, l3.latitude, w);
          t2 = r3[0], e2 = r3[1];
        }
      }
    } else x2(s3) ? (o5 = s3, s3 = null) : x2(i3) && (o5 = i3, i3 = null);
    const a4 = { x: t2, y: e2 };
    return null == a4.x && null != a4.y ? i.getLogger(this).warn(".y=", "Y coordinate was defined without an X coordinate") : null == a4.y && null != a4.x && i.getLogger(this).warn(".x=", "X coordinate was defined without a Y coordinate"), null != o5 && (a4.spatialReference = o5), null != s3 && (a4.z = s3), null != i3 && (a4.m = i3), a4;
  }
  get cache() {
    return this.commitProperty("x"), this.commitProperty("y"), this.commitProperty("z"), this.commitProperty("m"), this.commitProperty("spatialReference"), {};
  }
  get hasM() {
    return void 0 !== this.m;
  }
  set hasM(t2) {
    t2 !== (void 0 !== this._get("m")) && (this._set("m", t2 ? 0 : void 0), this._set("hasM", t2));
  }
  get hasZ() {
    return void 0 !== this.z;
  }
  set hasZ(t2) {
    t2 !== (void 0 !== this._get("z")) && (this._set("z", t2 ? 0 : void 0), this._set("hasZ", t2));
  }
  get latitude() {
    return l2(this);
  }
  set latitude(t2) {
    const { spatialReference: e2, x: r3 } = this;
    null != t2 && e2 && (e2.isWebMercator ? this._set("y", d(r3, t2, w)[1]) : e2.isGeographic && this._set("y", t2), this._set("latitude", t2));
  }
  get longitude() {
    return u2(this);
  }
  set longitude(t2) {
    const { y: e2, spatialReference: r3 } = this;
    null != t2 && r3 && (r3.isWebMercator ? this._set("x", d(t2, e2, w)[0]) : r3.isGeographic && this._set("x", t2), this._set("longitude", t2));
  }
  writeX(t2, e2, r3) {
    e2[r3] = isNaN(t2) ? "NaN" : t2;
  }
  readX(t2) {
    return "string" == typeof t2 ? NaN : t2;
  }
  clone() {
    const t2 = new g2();
    return t2.x = this.x, t2.y = this.y, t2.z = this.z, t2.m = this.m, t2.spatialReference = this.spatialReference, t2;
  }
  copy(t2) {
    return g2.copy(t2, this), this;
  }
  equals(t2) {
    if (null == t2) return false;
    const { x: e2, y: r3, z: s3, m: i3, spatialReference: o5 } = this, { z: l3, m: a4 } = t2;
    let { x: n2, y: p2, spatialReference: u3 } = t2;
    if (!o5.equals(u3)) if (o5.isWebMercator && u3.isWGS84) [n2, p2] = d(n2, p2), u3 = o5;
    else {
      if (!o5.isWGS84 || !u3.isWebMercator) return false;
      [n2, p2] = R(n2, p2), u3 = o5;
    }
    return e2 === n2 && r3 === p2 && s3 === l3 && i3 === a4 && o5.wkid === u3.wkid;
  }
  offset(t2, e2, r3) {
    return this.x += t2, this.y += e2, null != r3 && (this.z = (this.z ?? 0) + r3), this;
  }
  normalize() {
    if (!this.spatialReference) return this;
    const t2 = G(this.spatialReference);
    if (!t2) return this;
    let e2 = this.x;
    const [r3, s3] = t2.valid, i3 = 2 * s3;
    let o5;
    return e2 > s3 ? (o5 = Math.ceil(Math.abs(e2 - s3) / i3), e2 -= o5 * i3) : e2 < r3 && (o5 = Math.ceil(Math.abs(e2 - r3) / i3), e2 += o5 * i3), this._set("x", e2), this;
  }
  distance(t2) {
    return e(this, t2);
  }
  toArray() {
    const t2 = this.hasZ, e2 = this.hasM;
    return t2 && e2 ? [this.x, this.y, this.z, this.m] : t2 ? [this.x, this.y, this.z] : e2 ? [this.x, this.y, this.m] : [this.x, this.y];
  }
  toJSON(t2) {
    return this.write({}, t2);
  }
};
__decorate([m({ readOnly: true })], _.prototype, "cache", null), __decorate([m({ type: Boolean, json: { read: false, write: { enabled: false, overridePolicy: null } } })], _.prototype, "hasM", null), __decorate([m({ type: Boolean, json: { read: false, write: { enabled: false, overridePolicy: null } } })], _.prototype, "hasZ", null), __decorate([m({ type: Number })], _.prototype, "latitude", null), __decorate([m({ type: Number })], _.prototype, "longitude", null), __decorate([m({ type: Number, json: { type: [Number, String], write: { isRequired: true, allowNull: true } } }), s2((t2) => isNaN(t2) ? t2 : a2(t2))], _.prototype, "x", void 0), __decorate([r("x")], _.prototype, "writeX", null), __decorate([o("x")], _.prototype, "readX", null), __decorate([m({ type: Number, json: { write: true } })], _.prototype, "y", void 0), __decorate([m({ type: Number, json: { write: { overridePolicy() {
  return { enabled: this.hasZ };
} } } })], _.prototype, "z", void 0), __decorate([m({ type: Number, json: { write: { overridePolicy() {
  return { enabled: this.hasM };
} } } })], _.prototype, "m", void 0), _ = g2 = __decorate([a3("esri.geometry.Point")], _), _.prototype.toJSON.isDefaultToJSON = true;

export {
  c2 as c,
  o3 as o,
  r2 as r,
  h,
  M,
  y,
  d,
  R,
  j,
  S,
  e,
  i2 as i,
  _
};
//# sourceMappingURL=chunk-AXZMNHTN.js.map
