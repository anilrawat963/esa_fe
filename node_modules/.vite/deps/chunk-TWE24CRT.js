import {
  a as a2,
  l
} from "./chunk-U5TTP5E5.js";
import {
  a,
  i as i4
} from "./chunk-VGXUPJSS.js";
import {
  Z
} from "./chunk-2HGIYEIL.js";
import {
  Nt,
  at,
  dt,
  lt,
  rt,
  wt,
  xt
} from "./chunk-XX3OKYJS.js";
import {
  n as n2,
  o,
  s
} from "./chunk-JGA5YJWL.js";
import {
  e as e2
} from "./chunk-GCI4MA3M.js";
import {
  i as i3,
  n
} from "./chunk-SJ2OBYX2.js";
import {
  i as i2,
  m,
  r
} from "./chunk-MDJNYPVI.js";
import {
  D
} from "./chunk-HWUOAPTX.js";
import {
  f
} from "./chunk-GD4FJL3C.js";
import {
  e,
  t
} from "./chunk-THQO67BJ.js";
import {
  i3 as i
} from "./chunk-QY7XKUIV.js";
import {
  has
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/views/2d/layers/features/support/StaticBitSet.js
var e3 = class _e {
  static fromBuffer(t3, r4) {
    return new _e(t3, r4);
  }
  static create(t3, r4 = 4294967295) {
    const s2 = new Uint32Array(Math.ceil(t3 / 32));
    return new _e(s2, r4);
  }
  constructor(t3, e4) {
    this._mask = 0, this._buf = t3, this._mask = e4;
  }
  _getIndex(t3) {
    return Math.floor(t3 / 32);
  }
  get usedMemory() {
    return i3(this._buf);
  }
  has(t3) {
    const e4 = this._mask & t3;
    return !!(this._buf[this._getIndex(e4)] & 1 << e4 % 32);
  }
  hasRange(t3, e4) {
    let r4 = t3, s2 = e4;
    for (; r4 % 32 && r4 !== s2; ) {
      if (this.has(r4)) return true;
      r4++;
    }
    for (; s2 % 32 && r4 !== s2; ) {
      if (this.has(r4)) return true;
      s2--;
    }
    if (r4 === s2) return false;
    for (let i5 = r4 / 32; i5 !== s2 / 32; i5++) {
      if (this._buf[i5]) return true;
    }
    return false;
  }
  set(t3) {
    const e4 = this._mask & t3, r4 = this._getIndex(e4), s2 = 1 << e4 % 32;
    this._buf[r4] |= s2;
  }
  setRange(t3, e4) {
    let r4 = t3, s2 = e4;
    for (; r4 % 32 && r4 !== s2; ) this.set(r4++);
    for (; s2 % 32 && r4 !== s2; ) this.set(s2--);
    if (r4 !== s2) for (let i5 = r4 / 32; i5 !== s2 / 32; i5++) this._buf[i5] = 4294967295;
  }
  unset(t3) {
    const e4 = this._mask & t3, r4 = this._getIndex(e4), s2 = 1 << e4 % 32;
    this._buf[r4] &= 4294967295 ^ s2;
  }
  resize(t3) {
    const e4 = this._buf, r4 = new Uint32Array(Math.ceil(t3 / 32));
    r4.set(e4), this._buf = r4;
  }
  or(t3) {
    for (let e4 = 0; e4 < this._buf.length; e4++) this._buf[e4] |= t3._buf[e4];
    return this;
  }
  and(t3) {
    for (let e4 = 0; e4 < this._buf.length; e4++) this._buf[e4] &= t3._buf[e4];
    return this;
  }
  xor(t3) {
    for (let e4 = 0; e4 < this._buf.length; e4++) this._buf[e4] ^= t3._buf[e4];
    return this;
  }
  ior(t3) {
    for (let e4 = 0; e4 < this._buf.length; e4++) this._buf[e4] |= ~t3._buf[e4];
    return this;
  }
  iand(t3) {
    for (let e4 = 0; e4 < this._buf.length; e4++) this._buf[e4] &= ~t3._buf[e4];
    return this;
  }
  ixor(t3) {
    for (let e4 = 0; e4 < this._buf.length; e4++) this._buf[e4] ^= ~t3._buf[e4];
    return this;
  }
  any() {
    for (let t3 = 0; t3 < this._buf.length; t3++) if (this._buf[t3]) return true;
    return false;
  }
  copy(t3) {
    for (let e4 = 0; e4 < this._buf.length; e4++) this._buf[e4] = t3._buf[e4];
    return this;
  }
  clone() {
    return new _e(this._buf.slice(), this._mask);
  }
  clear() {
    for (let t3 = 0; t3 < this._buf.length; t3++) this._buf[t3] = 0;
    return this;
  }
  forEachSet(t3) {
    for (let e4 = 0; e4 < this._buf.length; e4++) {
      let r4 = this._buf[e4], s2 = 32 * e4;
      if (r4) for (; r4; ) {
        1 & r4 && t3(s2), r4 >>>= 1, s2++;
      }
    }
  }
  countSet() {
    let t3 = 0;
    return this.forEachSet((e4) => {
      t3++;
    }), t3;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetCache.js
var a3 = class {
  constructor(t3) {
    this._valid = e3.create(t3), this._data = new Array(t3);
  }
  get usedMemory() {
    let s2 = this._valid.usedMemory;
    if (this._data.length > 0) {
      const a4 = "string" == typeof this._data[0] ? 64 : n;
      s2 += this._data.length * a4;
    }
    return s2;
  }
  has(t3) {
    return this._valid.has(t3);
  }
  set(t3, s2) {
    this._valid.set(t3), this._data[t3] = s2;
  }
  get(t3) {
    return this._data[t3];
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReader.js
var x = has("featurelayer-simplify-thresholds") ?? [0.5, 0.5, 0.5, 0.5];
var D2 = x[0];
var T = x[1];
var F = x[2];
var A = x[3];
var S = has("featurelayer-simplify-payload-size-factors") ?? [1, 2, 4];
var I = S[0];
var B = S[1];
var j = S[2];
var M = has("featurelayer-simplify-mobile-factor") ?? 2;
var G = has("esri-mobile");
var C = 4294967295;
function v(e4, t3, r4) {
  if (!(e4.length > t3)) for (; e4.length <= t3; ) e4.push(r4);
}
var O = class {
  constructor(e4) {
    this.metadata = e4, this.type = "FeatureSetReader", this._overrides = null, this._joined = [], this._objectIdToIndex = null, this._boundsBuffer = [], this._caches = /* @__PURE__ */ new Map(), this.arcadeDeclaredClass = "esri.arcade.Feature", this._contextTimeZone = null;
  }
  destroy() {
  }
  [Symbol.dispose]() {
    this.destroy();
  }
  getAreaSimplificationThreshold(e4, t3) {
    let r4 = 1;
    const s2 = G ? M : 1;
    t3 > 4e6 ? r4 = j * s2 : t3 > 1e6 ? r4 = B * s2 : t3 > 5e5 ? r4 = I * s2 : t3 > 1e5 && (r4 = s2);
    let i5 = 0;
    return e4 > 4e3 ? i5 = A * r4 : e4 > 2e3 ? i5 = F * r4 : e4 > 100 ? i5 = T : e4 > 15 && (i5 = D2), i5;
  }
  getBounds(e4) {
    v(this._boundsBuffer, 4 * this.getIndex() + 4, 0);
    const t3 = this.getBoundsXMin();
    if (t3 === C || !isFinite(t3)) return false;
    if (0 === this.getBoundsXMin()) {
      const t4 = this.readGeometryWorldSpace();
      if (t4?.isPoint && 0 === t4.coords[0] && 0 === t4.coords[1]) return D(e4, 0, 0, 0, 0), true;
      if (!t4) return this.setBoundsXMin(C), false;
      let r5 = 1 / 0, s3 = 1 / 0, i6 = -1 / 0, a5 = -1 / 0;
      return t4.forEachVertex((e5, t5) => {
        r5 = Math.min(r5, e5), s3 = Math.min(s3, t5), i6 = Math.max(i6, e5), a5 = Math.max(a5, t5);
      }), this.setBoundsXMin(r5), this.setBoundsYMin(s3), this.setBoundsXMax(i6), this.setBoundsYMax(a5), D(e4, r5, s3, i6, a5), true;
    }
    const r4 = this.getBoundsXMin(), s2 = this.getBoundsYMin(), i5 = this.getBoundsXMax(), a4 = this.getBoundsYMax();
    return D(e4, r4, s2, i5, a4), true;
  }
  getBoundsXMin() {
    return this._boundsBuffer[4 * this.getIndex()];
  }
  setBoundsXMin(e4) {
    this._boundsBuffer[4 * this.getIndex()] = e4;
  }
  getBoundsYMin() {
    return this._boundsBuffer[4 * this.getIndex() + 1];
  }
  setBoundsYMin(e4) {
    this._boundsBuffer[4 * this.getIndex() + 1] = e4;
  }
  getBoundsXMax() {
    return this._boundsBuffer[4 * this.getIndex() + 2];
  }
  setBoundsXMax(e4) {
    this._boundsBuffer[4 * this.getIndex() + 2] = e4;
  }
  getBoundsYMax() {
    return this._boundsBuffer[4 * this.getIndex() + 3];
  }
  setBoundsYMax(e4) {
    this._boundsBuffer[4 * this.getIndex() + 3] = e4;
  }
  readAttributeAsTimestamp(e4) {
    const t3 = this.readAttribute(e4);
    return "string" == typeof t3 ? new Date(t3).getTime() : "number" == typeof t3 || null == t3 ? t3 : null;
  }
  readAttribute(e4, t3 = false) {
    const r4 = this._readAttribute(e4, t3);
    if (void 0 !== r4) return r4;
    for (const s2 of this._joined) {
      s2.setIndex(this.getIndex());
      const r5 = s2._readAttribute(e4, t3);
      if (void 0 !== r5) return r5;
    }
  }
  readAttributes() {
    const e4 = this._readAttributes();
    for (const t3 of this._joined) {
      t3.setIndex(this.getIndex());
      const r4 = t3._readAttributes();
      for (const t4 of Object.keys(r4)) e4[t4] = r4[t4];
    }
    return e4;
  }
  joinAttributes(e4) {
    this._joined.push(e4);
  }
  registerOverrides(e4) {
    this._overrides = e4;
  }
  withoutOverrides() {
    const e4 = this.copy();
    return e4._overrides = null, e4;
  }
  readOptimizedFeatureWorldSpace() {
    const e4 = this.readGeometryWorldSpace(), t3 = this.readAttributes(), r4 = this.readCentroidWorldSpace();
    return new s(e4, t3, r4, this.getObjectId(), this.getDisplayId());
  }
  readLegacyFeatureForDisplay() {
    const e4 = this.readCentroidForDisplay();
    return { attributes: this.readAttributes(), geometry: this.readLegacyGeometryForDisplay(), centroid: (e4 && { x: e4.coords[0], y: e4.coords[1] }) ?? null };
  }
  readLegacyFeatureWorldSpace() {
    const e4 = this.readCentroidWorldSpace();
    return { attributes: this.readAttributes(), geometry: this._readLegacyGeometryWorldSpace(), centroid: (e4 && { x: e4.coords[0], y: e4.coords[1] }) ?? null };
  }
  readLegacyGeometryForDisplay() {
    const e4 = this.readGeometryForDisplay();
    return lt(e4, this.geometryType, false, false);
  }
  readXForDisplay() {
    return this._readX();
  }
  readYForDisplay() {
    return this._readY();
  }
  readXWorldSpace() {
    const e4 = this._readX(), t3 = this.getInTransform();
    return null == t3 ? e4 : e4 * t3.scale[0] + t3.translate[0];
  }
  readYWorldSpace() {
    const e4 = this._readY(), t3 = this.getInTransform();
    return null == t3 ? e4 : t3.translate[1] - e4 * t3.scale[1];
  }
  readGeometryForDisplay() {
    const e4 = this._readGeometryDeltaDecoded(true);
    if (!e4) {
      const e5 = this._createDeltaQuantizedGeometryFromServerCentroid();
      return e5 ? e5.deltaDecode() : null;
    }
    return e4;
  }
  readGeometryForDisplayTransformed(e4) {
    let t3 = this.readGeometryForDisplay();
    if (t3 && "esriGeometryPolyline" === this.metadata.geometryType && (t3 = dt(new e2(), t3, this.hasZ, this.hasM, this.metadata.geometryType, e4.scale[0])), t3 && (t3 = xt(t3, e4, this.metadata.geometryType, this.hasZ, this.hasM)), !t3) {
      const t4 = this.readCentroidForDisplay();
      if (!t4) return null;
      const r4 = i4(e4, t4.coords[0]), s2 = a(e4, t4.coords[1]);
      return this._createDeltaQuantizedExtrudedGeometry(r4, s2).deltaDecode();
    }
    return t3;
  }
  readGeometryWorldSpace() {
    let e4 = this._readGeometry();
    if (e4 || (e4 = this._createDeltaQuantizedGeometryFromServerCentroid()), !e4) return null;
    const t3 = e4.clone(), r4 = this.getInTransform();
    return null != r4 && wt(t3, t3, this.hasZ, this.hasM, r4), t3;
  }
  readCentroidForDisplay() {
    const e4 = this.readGeometryForDisplay();
    return e4 ? this._computeDisplayCentroid(e4) : this._readServerCentroid();
  }
  readCentroidWorldSpace() {
    const e4 = this.readGeometryForDisplay(), t3 = e4 ? this._computeDisplayCentroid(e4) : this._readServerCentroid();
    if (!t3) return null;
    const r4 = t3.clone(), s2 = this.getInTransform();
    return null != s2 && wt(r4, r4, this.hasZ, this.hasM, s2), r4;
  }
  setCache(e4) {
    let t3 = this._caches.get(e4);
    null == t3 && (t3 = new a3(this.getSize()), this._caches.set(e4, t3)), this._activeCache = t3;
  }
  setCachedValue(e4) {
    this._activeCache.set(this.getIndex(), e4);
  }
  hasCachedValue() {
    return this._activeCache.has(this.getIndex());
  }
  getCachedValue() {
    return this._activeCache.get(this.getIndex());
  }
  get underlyingMemory() {
    let e4 = 0;
    e4 += i3(this._boundsBuffer);
    for (const t3 of this._caches.values()) e4 += t3.usedMemory;
    return e4;
  }
  _readGeometryDeltaDecoded(e4) {
    const t3 = this._readGeometry(e4);
    return "esriGeometryPoint" !== this.geometryType && t3 && this.getInTransform() ? t3.deltaDecode() : t3;
  }
  get contextTimeZone() {
    return this._contextTimeZone;
  }
  set contextTimeZone(e4) {
    this._contextTimeZone = e4;
  }
  readArcadeFeature() {
    return this;
  }
  hasField(e4) {
    return this.fields.has(e4) || this._joined.some((t3) => t3.hasField(e4));
  }
  geometry() {
    const e4 = this.readGeometryWorldSpace(), t3 = lt(e4, this.geometryType, this.hasZ, this.hasM), r4 = f(t3);
    if (r4) {
      if (!this.metadata.outSpatialReference) throw new Error("InternalError: Expected spatial reference to be defined");
      r4.spatialReference = this.metadata.outSpatialReference;
    }
    return r4;
  }
  autocastArcadeDate(t3, r4) {
    return r4 && r4 instanceof Date ? this.isUnknownDateTimeField(t3) ? m.unknownDateJSToArcadeDate(r4) : m.dateJSAndZoneToArcadeDate(r4, this.contextTimeZone ?? e) : r4;
  }
  isUnknownDateTimeField(e4) {
    return this.metadata.fieldsIndex.getTimeZone(e4) === t;
  }
  field(t3) {
    let i5 = this.fields.get(t3);
    if (i5) switch (i5.type) {
      case "date-only":
      case "esriFieldTypeDateOnly":
        return i2.fromReader(this.readAttribute(t3, false));
      case "time-only":
      case "esriFieldTypeTimeOnly":
        return r.fromReader(this.readAttribute(t3, false));
      case "esriFieldTypeTimestampOffset":
      case "timestamp-offset":
        return m.fromReaderAsTimeStampOffset(this.readAttribute(t3, false));
      case "date":
      case "esriFieldTypeDate":
        return this.autocastArcadeDate(t3, this.readAttribute(t3, true));
      default:
        return this.readAttribute(t3, false);
    }
    for (const o2 of this._joined) if (o2.setIndex(this.getIndex()), i5 = o2.fields.get(t3), i5) switch (i5.type) {
      case "date-only":
      case "esriFieldTypeDateOnly":
        return i2.fromReader(o2._readAttribute(t3, false));
      case "time-only":
      case "esriFieldTypeTimeOnly":
        return r.fromReader(o2._readAttribute(t3, false));
      case "esriFieldTypeTimestampOffset":
      case "timestamp-offset":
        return m.fromReaderAsTimeStampOffset(o2._readAttribute(t3, false));
      case "date":
      case "esriFieldTypeDate":
        return this.autocastArcadeDate(t3, o2._readAttribute(t3, true));
      default:
        return this.readAttribute(t3, false);
    }
    throw new Error(`Field ${t3} does not exist`);
  }
  setField(e4, t3) {
    throw new Error("Unable to update feature attribute values, feature is readonly");
  }
  keys() {
    return this.fields.fields.map((e4) => e4.name);
  }
  isEmpty() {
    return this.fields.fields.length <= 0 && null == this.geometry();
  }
  castToText(e4 = false) {
    if (!e4) return JSON.stringify(this.readLegacyFeatureForDisplay());
    const t3 = this.readLegacyFeatureForDisplay();
    if (!t3) return JSON.stringify(null);
    const r4 = { geometry: t3.geometry, attributes: { ...t3.attributes } };
    for (const s2 in r4.attributes) {
      const e5 = r4.attributes[s2];
      e5 instanceof Date && (r4.attributes[s2] = e5.getTime());
    }
    return JSON.stringify(r4);
  }
  gdbVersion() {
    return null;
  }
  fullSchema() {
    return this.metadata.arcadeSchema;
  }
  castAsJson(e4 = null) {
    return { attributes: this._readAttributes(), geometry: true === e4?.keepGeometryType ? this.geometry() : this.geometry()?.toJSON() ?? null };
  }
  castAsJsonAsync(e4 = null, t3 = null) {
    return Promise.resolve(this.castAsJson(t3));
  }
  _getExists() {
    if (this._overrides) {
      const e4 = this.getObjectId();
      return !this._overrides.hasOverride(e4);
    }
    return true;
  }
  _computeDisplayCentroid(e4) {
    if (null == this.getInTransform()) return n2(new e2(), e4, this.hasM, this.hasZ);
    const t3 = a2.fromOptimized(e4, this.geometryType);
    t3.yFactor *= -1;
    const r4 = l(t3);
    return r4 ? (r4[1] *= -1, new e2([], r4)) : null;
  }
  copyInto(e4) {
    e4._joined = this._joined, e4._overrides = this._overrides, e4._objectIdToIndex = this._objectIdToIndex, e4._boundsBuffer = this._boundsBuffer, e4._activeCache = this._activeCache, e4._caches = this._caches, e4._contextTimeZone = this._contextTimeZone;
  }
  _readLegacyGeometryWorldSpace() {
    const e4 = this.readGeometryWorldSpace();
    return lt(e4, this.geometryType, false, false);
  }
  _createDeltaQuantizedGeometryFromServerCentroid() {
    const e4 = this._readServerCentroid();
    if (!e4) return null;
    const [t3, r4] = e4.coords;
    return this._createDeltaQuantizedExtrudedGeometry(t3, r4);
  }
  _createDeltaQuantizedExtrudedGeometry(e4, t3) {
    return "esriGeometryPolyline" === this.geometryType ? this._createDeltaQuantizedExtrudedLine(e4, t3) : this._createDeltaQuantizedExtrudedQuad(e4, t3);
  }
  _createDeltaQuantizedExtrudedQuad(e4, t3) {
    return new e2([5], [e4 - 1, t3, 1, -1, 1, 1, -1, 1, -1, -1]);
  }
  _createDeltaQuantizedExtrudedLine(e4, t3) {
    return new e2([2], [e4 - 1, t3 + 1, 1, -1]);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderJSON.js
var u = class _u extends O {
  static fromFeatures(t3, r4) {
    const { geometryType: s2 } = r4, n4 = rt([], t3, s2, false, false, r4.featureIdInfo);
    for (let e4 = 0; e4 < n4.length; e4++) n4[e4].displayId = t3[e4].displayId;
    return _u.fromOptimizedFeatures(n4, r4);
  }
  static fromFeatureSet(e4, r4) {
    const s2 = at(e4, r4.featureIdInfo);
    return _u.fromOptimizedFeatureSet(s2, r4);
  }
  static fromOptimizedFeatureSet(e4, t3) {
    const r4 = _u.fromOptimizedFeatures(e4.features, t3);
    return r4._exceededTransferLimit = e4.exceededTransferLimit, r4._transform = e4.transform, r4._fieldsIndex = new Z(e4.fields), r4;
  }
  static fromOptimizedFeatures(e4, t3, r4) {
    const s2 = new _u(e4, t3);
    return s2._fieldsIndex = t3.fieldsIndex, s2._transform = r4, s2;
  }
  static empty(e4) {
    return new _u([], e4);
  }
  constructor(e4, t3) {
    super(t3), this._exceededTransferLimit = false, this._featureIndex = -1, this._fieldsIndex = null, this._geometryType = t3.geometryType, this._features = e4;
  }
  get fields() {
    return this._fieldsIndex;
  }
  get geometryType() {
    return this._geometryType;
  }
  get hasFeatures() {
    return !!this._features.length;
  }
  get hasNext() {
    return this._featureIndex + 1 < this._features.length;
  }
  get exceededTransferLimit() {
    return this._exceededTransferLimit;
  }
  get hasZ() {
    return false;
  }
  get hasM() {
    return false;
  }
  get _current() {
    return this._features[this._featureIndex];
  }
  get usedMemory() {
    return this._current.usedMemory;
  }
  getSize() {
    return this._features.length;
  }
  getCursor() {
    return this.copy();
  }
  getInTransform() {
    return this._transform;
  }
  getAttributeHash() {
    let e4 = "";
    for (const t3 in this._current.attributes) e4 += this._current.attributes[t3];
    return e4;
  }
  getIndex() {
    return this._featureIndex;
  }
  setIndex(e4) {
    this._featureIndex = e4;
  }
  getObjectId() {
    return this._current?.objectId;
  }
  getDisplayId() {
    return this._current.displayId;
  }
  setDisplayId(e4) {
    this._current.displayId = e4;
  }
  copy() {
    const e4 = new _u(this._features, this.metadata);
    return this.copyInto(e4), e4;
  }
  next() {
    for (; ++this._featureIndex < this._features.length && !this._getExists(); ) ;
    return this._featureIndex < this._features.length;
  }
  readGeometryArea() {
    return o(this._current) ? Nt(this._current.geometry, 2) : 0;
  }
  _readX() {
    return o(this._current) ? this._current.geometry.coords[0] : 0;
  }
  _readY() {
    return o(this._current) ? this._current.geometry.coords[1] : 0;
  }
  _readGeometry() {
    return o(this._current) ? this._current.geometry ?? null : null;
  }
  _readServerCentroid() {
    return this._current.centroid;
  }
  _readAttribute(e4, t3) {
    if (!this._fieldsIndex) {
      const t4 = this._current.attributes[e4];
      if (void 0 !== t4) return t4;
      const r5 = e4.toLowerCase();
      for (const e5 in this._current.attributes) if (e5.toLowerCase() === r5) return this._current.attributes[e5];
      return;
    }
    const r4 = this._fieldsIndex.get(e4);
    if (!r4) return;
    const s2 = this._current.attributes[r4.name];
    return null == s2 ? s2 : t3 && this.fields.isDateField(e4) ? new Date(s2) : s2;
  }
  _readAttributes() {
    return this._current.attributes;
  }
  copyInto(e4) {
    super.copyInto(e4), e4._featureIndex = this._featureIndex, e4._transform = this._transform, e4._fieldsIndex = this._fieldsIndex;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/FeatureStoreQueryAdapter.js
var _r = class _r {
  getObjectId(t3) {
    return t3.getObjectId();
  }
  getAttributes(t3) {
    return t3.readAttributes();
  }
  getAttribute(t3, e4) {
    return t3.readAttribute(e4);
  }
  getAttributeAsTimestamp(t3, e4) {
    return t3.readAttributeAsTimestamp(e4);
  }
  cloneWithGeometry(r4, a4) {
    const i5 = r4.readAttributes(), s2 = new s(a4, i5, null, r4.getObjectId(), r4.getDisplayId()), d = u.fromOptimizedFeatures([s2], r4.metadata);
    return d.setIndex(0), d;
  }
  getGeometry(t3) {
    return t3.readGeometryWorldSpace();
  }
  getCentroid(t3, e4) {
    return t3.readCentroidForDisplay();
  }
};
_r.Shared = new _r();
var r2 = _r;

// node_modules/@arcgis/core/views/2d/arcade/callExpressionWithCursor.js
function n3(n4, r4, t3) {
  if (null == n4) return null;
  const u2 = r4.readArcadeFeature();
  r4.contextTimeZone = t3.$view?.timeZone;
  try {
    return n4.evaluate(u2, t3);
  } catch (a4) {
    return i.getLogger("esri.views.2d.support.arcadeOnDemand").warn("Feature arcade evaluation failed:", a4), null;
  }
}
function r3(e4) {
  return null == e4 || e4 === 1 / 0 || e4 === -1 / 0 || "number" == typeof e4 && isNaN(e4);
}
function t2(e4, n4, t3, u2) {
  if (null == e4) return null != u2 ? u2 : null;
  const a4 = n4.readArcadeFeature();
  n4.contextTimeZone = t3.$view?.timeZone;
  const o2 = e4.evaluate(a4, t3);
  return r3(o2) ? null != u2 ? u2 : null : o2;
}

export {
  n3 as n,
  r3 as r,
  t2 as t,
  e3 as e,
  a3 as a,
  O,
  u,
  r2
};
//# sourceMappingURL=chunk-TWE24CRT.js.map
