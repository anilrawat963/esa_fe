import {
  a,
  c as c2,
  f2 as f
} from "./chunk-QYAMBIRP.js";
import {
  r
} from "./chunk-ZVTEFYZX.js";
import {
  A,
  E,
  I,
  P,
  _,
  c,
  g,
  j,
  o,
  p as p2,
  q,
  r as r2,
  s,
  u,
  v
} from "./chunk-VYMBX5H5.js";
import {
  p
} from "./chunk-XLOINTMG.js";
import {
  n,
  t as t2
} from "./chunk-75XOUSSS.js";
import {
  e as e2
} from "./chunk-3OVERDFX.js";
import {
  e
} from "./chunk-Q75WYS7K.js";
import {
  b,
  l
} from "./chunk-SMWUT52Z.js";
import {
  t
} from "./chunk-LZ2XTYP2.js";

// node_modules/@arcgis/core/core/ObjectStack.js
var s2 = class {
  constructor(t3) {
    this._allocator = t3, this._items = [], this._itemsPtr = 0, this._grow();
  }
  get() {
    return 0 === this._itemsPtr && t(() => this._reset()), this._itemsPtr === this._items.length && this._grow(), this._items[this._itemsPtr++];
  }
  _reset() {
    const t3 = Math.min(3 * Math.max(8, this._itemsPtr), this._itemsPtr + 3 * i);
    this._items.length = Math.min(t3, this._items.length), this._itemsPtr = 0;
  }
  _grow() {
    for (let t3 = 0; t3 < Math.max(8, Math.min(this._items.length, i)); t3++) this._items.push(this._allocator());
  }
};
var i = 1024;

// node_modules/@arcgis/core/geometry/support/ray.js
function b2(i2) {
  return i2 ? h2(t2(i2.origin), t2(i2.direction)) : h2(n(), n());
}
function h2(i2, r4) {
  return { origin: i2, direction: r4 };
}
function k(i2, r4) {
  const n3 = O.get();
  return n3.origin = i2, n3.direction = r4, n3;
}
function v2(i2, r4 = b2()) {
  return q2(i2.origin, i2.direction, r4);
}
function S(i2, r4, n3 = b2()) {
  return s(n3.origin, i2), c(n3.direction, r4, i2), n3;
}
function q2(i2, r4, n3 = b2()) {
  return s(n3.origin, i2), s(n3.direction, r4), n3;
}
function w(i2, r4) {
  const n3 = _(c2.get(), A(c2.get(), i2.direction), c(c2.get(), r4, i2.origin));
  return P(n3, n3);
}
function y(i2, r4, n3) {
  const t3 = P(i2.direction, c(n3, r4, i2.origin));
  return u(n3, i2.origin, g(n3, i2.direction, t3)), n3;
}
var O = new s2(() => b2());
var U = n();
var z = n();
var A2 = n();
var B = e2();

// node_modules/@arcgis/core/geometry/support/sphereUtils.js
function n2(n3, a2) {
  const c3 = r2(n3), r4 = l(n3[2] / c3), h3 = Math.atan2(n3[1] / c3, n3[0] / c3);
  return o(a2, c3, r4, h3), a2;
}

// node_modules/@arcgis/core/chunks/sphere.js
var S2 = P2();
function A3(t3, n3, r4, e3) {
  return new Array(t3, n3, r4, e3);
}
function P2() {
  return A3(0, 0, 0, 0);
}
function q3(t3, n3) {
  return A3(t3[0], t3[1], t3[2], n3);
}
function R2(t3) {
  return A3(t3[0], t3[1], t3[2], t3[3]);
}
function V(t3, n3, r4) {
  return F(t3, n3[0], n3[1], n3[2], r4);
}
function F(t3, n3, r4, e3, o2) {
  return t3[0] = n3, t3[1] = r4, t3[2] = e3, t3[3] = o2, t3;
}
function T(t3, n3) {
  return E2(t3, n3);
}
function E2(t3, n3) {
  return t3[0] === n3[0] && t3[1] === n3[1] && t3[2] === n3[2] && t3[3] === n3[3];
}
function O2(t3, n3) {
  return n3[0] = t3[0], n3[1] = t3[1], n3[2] = t3[2], n3[3] = t3[3], n3;
}
function _2(t3) {
  return A3(t3[0], t3[1], t3[2], t3[3]);
}
function k2(t3) {
  t3[0] = 0, t3[1] = 0, t3[2] = 0, t3[3] = 0;
}
function w2(t3, n3) {
  return t3[0] = 0, t3[1] = 0, t3[2] = 0, t3[3] = n3, t3;
}
function L(t3) {
  return t3[3];
}
function z2(t3, n3) {
  return o(n3, t3[0], t3[1], t3[2]);
}
function I2(t3) {
  return o(ht, t3[0], t3[1], t3[2]);
}
function N(t3, n3) {
  t3[0] = n3[0], t3[1] = n3[1], t3[2] = n3[2];
}
function U2(t3, n3) {
  t3[0] = n3[0], t3[1] = n3[1], t3[2] = n3[2];
}
function B2(t3, n3, r4, e3) {
  t3[0] = n3, t3[1] = r4, t3[2] = e3;
}
function D(t3, n3, r4) {
  N(t3, E(ht, n3, r4));
}
function G(t3, n3, r4, e3, o2) {
  t3[0] = n3, t3[1] = r4, t3[2] = e3, t3[3] = o2;
}
function H(t3) {
  return r(t3[0], t3[1], t3[2], t3[3]);
}
function J(t3, n3, r4) {
  return t3 !== r4 && (r4[0] = t3[0], r4[1] = t3[1], r4[2] = t3[2]), r4[3] = t3[3] + n3, r4;
}
function K(t3, n3, r4) {
  return t3 !== r4 && O2(t3, r4), r4;
}
function Q(t3, n3) {
  return n3;
}
function W(t3, n3, r4) {
  if (null == n3) return false;
  if (!Z(t3, n3, Y)) return false;
  let { t0: e3, t1: o2 } = Y;
  if ((e3 < 0 || o2 < e3 && o2 > 0) && (e3 = o2), e3 < 0) return false;
  if (r4) {
    const { origin: t4, direction: o3 } = n3;
    r4[0] = t4[0] + o3[0] * e3, r4[1] = t4[1] + o3[1] * e3, r4[2] = t4[2] + o3[2] * e3;
  }
  return true;
}
function X(t3, n3, r4) {
  const e3 = S(n3, r4);
  if (!Z(t3, e3, Y)) return [];
  const { origin: o2, direction: s4 } = e3, { t0: i2, t1: a2 } = Y, c3 = (n4) => {
    const r5 = n();
    return q(r5, o2, s4, n4), st(t3, r5, r5);
  };
  return Math.abs(i2 - a2) < e() ? [c3(i2)] : [c3(i2), c3(a2)];
}
var Y = { t0: 0, t1: 0 };
function Z(t3, n3, r4) {
  const { origin: e3, direction: o2 } = n3, s4 = $;
  s4[0] = e3[0] - t3[0], s4[1] = e3[1] - t3[1], s4[2] = e3[2] - t3[2];
  const i2 = o2[0] * o2[0] + o2[1] * o2[1] + o2[2] * o2[2];
  if (0 === i2) return false;
  const a2 = 2 * (o2[0] * s4[0] + o2[1] * s4[1] + o2[2] * s4[2]), c3 = a2 * a2 - 4 * i2 * (s4[0] * s4[0] + s4[1] * s4[1] + s4[2] * s4[2] - t3[3] * t3[3]);
  if (c3 < 0) return false;
  const u2 = Math.sqrt(c3);
  return r4.t0 = (-a2 - u2) / (2 * i2), r4.t1 = (-a2 + u2) / (2 * i2), true;
}
var $ = n();
function tt(t3, n3) {
  return W(t3, n3, null);
}
function nt(t3, n3, r4) {
  if (W(t3, n3, r4)) return r4;
  const e3 = rt(t3, n3, c2.get());
  return u(r4, n3.origin, g(c2.get(), n3.direction, p2(n3.origin, e3) / r2(n3.direction))), r4;
}
function rt(t3, r4, e3) {
  const s4 = c2.get(), a2 = f.get();
  _(s4, r4.origin, r4.direction);
  const f2 = L(t3);
  _(e3, s4, r4.origin), g(e3, e3, 1 / r2(e3) * f2);
  const m = at(t3, r4.origin), l2 = a(r4.origin, e3);
  return p(a2, l2 + m, s4), E(e3, e3, a2), e3;
}
function et(t3, n3, r4, e3) {
  const o2 = L(t3), s4 = o2 * o2, i2 = n3 + 0.5 * Math.PI, a2 = r4 * r4 + s4 - 2 * Math.cos(i2) * r4 * o2, c3 = Math.sqrt(a2), u2 = a2 - s4;
  if (u2 <= 0) return 0.5;
  const f2 = Math.sqrt(u2), m = Math.acos(f2 / c3) - Math.asin(o2 / (c3 / Math.sin(i2)));
  return Math.min(1, (m + 0.5 * e3) / e3);
}
function ot(t3, n3, r4) {
  return W(t3, n3, r4) ? r4 : (y(n3, I2(t3), r4), st(t3, r4, r4));
}
function st(t3, n3, r4) {
  const e3 = c(c2.get(), n3, I2(t3)), o2 = g(c2.get(), e3, t3[3] / r2(e3));
  return u(r4, o2, I2(t3));
}
function it(t3, n3) {
  const r4 = c(c2.get(), n3, I2(t3)), e3 = j(r4), o2 = t3[3] * t3[3];
  return Math.sqrt(Math.abs(e3 - o2));
}
function at(n3, r4) {
  const e3 = c(c2.get(), r4, I2(n3)), o2 = r2(e3), s4 = L(n3), i2 = s4 + Math.abs(s4 - o2);
  return b(s4 / i2);
}
var ct = n();
function ut(t3, n3, e3, o2) {
  const s4 = c(ct, n3, I2(t3));
  switch (e3) {
    case 0: {
      const t4 = n2(s4, ct)[2];
      return o(o2, -Math.sin(t4), Math.cos(t4), 0);
    }
    case 1: {
      const t4 = n2(s4, ct), n4 = t4[1], e4 = t4[2], i2 = Math.sin(n4);
      return o(o2, -i2 * Math.cos(e4), -i2 * Math.sin(e4), Math.cos(n4));
    }
    case 2:
      return A(o2, s4);
    default:
      return;
  }
}
function ft(t3, n3) {
  const r4 = c(dt, n3, I2(t3));
  return r2(r4) - t3[3];
}
function mt(t3, n3, r4, e3) {
  const o2 = ft(t3, n3), a2 = ut(t3, n3, 2, dt), c3 = g(dt, a2, r4 - o2);
  return u(e3, n3, c3);
}
function lt(t3, n3) {
  const r4 = v(I2(t3), n3), o2 = L(t3);
  return r4 <= o2 * o2;
}
function gt(t3, n3, r4 = P2()) {
  const e3 = p2(I2(t3), z2(n3, pt)), o2 = t3[3], s4 = n3[3];
  return e3 + s4 < o2 ? (O2(t3, r4), r4) : e3 + o2 < s4 ? (O2(n3, r4), r4) : (I(ht, I2(t3), z2(n3, pt), (e3 + s4 - o2) / (2 * e3)), V(r4, ht, (e3 + o2 + s4) / 2), r4);
}
var ht = n();
var pt = n();
var Mt = P2();
var dt = n();
var jt = Object.freeze(Object.defineProperty({ __proto__: null, NullSphere: S2, altitudeAt: ft, angleToSilhouette: at, axisAt: ut, cameraFrustumCoverage: et, clear: k2, clone: _2, closestPoint: ot, closestPointOnSilhouette: rt, containsPoint: lt, copy: O2, copyCenter: U2, create: P2, distanceToSilhouette: it, elevate: J, equals: E2, exactEquals: T, fromCenterAndRadius: q3, fromRadius: w2, fromValues: A3, fromVec4: R2, getCenter: z2, getCenterTemp: I2, getExtent: Q, getRadius: L, intersectLine: X, intersectRay: W, intersectRayClosestSilhouette: nt, intersectsRay: tt, projectPoint: st, set: F, setAltitudeAt: mt, setCenter: N, setCenterFromValues: B2, setExtent: K, setFromCenterAndRadius: V, setFromValues: G, setTransformedCenter: D, tmpSphere: Mt, toVec4: H, union: gt }, Symbol.toStringTag, { value: "Module" }));

export {
  s2 as s,
  b2 as b,
  k,
  v2 as v,
  S,
  q2 as q,
  w,
  S2,
  A3 as A,
  P2 as P,
  q3 as q2,
  R2 as R,
  V,
  T,
  O2 as O,
  w2,
  L,
  z2 as z,
  I2 as I,
  N,
  U2 as U,
  D,
  H,
  X,
  tt,
  et,
  st,
  lt,
  jt
};
//# sourceMappingURL=chunk-U6CJFTOF.js.map
