import {
  o3 as o
} from "./chunk-PZ5RULLK.js";
import {
  _ as _2
} from "./chunk-AXZMNHTN.js";
import {
  n
} from "./chunk-XXLHAM2M.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  _,
  a2
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  a
} from "./chunk-QY7XKUIV.js";
import {
  N
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/layers/support/DimensionalDefinition.js
var a3;
var p = a3 = class extends n {
  constructor(e) {
    super(e), this.variableName = null, this.dimensionName = null, this.values = [], this.isSlice = false;
  }
  clone() {
    return new a3({ variableName: this.variableName, dimensionName: this.dimensionName, values: a(this.values), isSlice: this.isSlice });
  }
};
__decorate([m({ type: String, json: { write: true } })], p.prototype, "variableName", void 0), __decorate([m({ type: String, json: { write: true } })], p.prototype, "dimensionName", void 0), __decorate([m({ type: _.array(_.oneOf([_.native(Number), _.array(_.native(Number))])), json: { write: true } })], p.prototype, "values", void 0), __decorate([m({ type: Boolean, json: { write: true } })], p.prototype, "isSlice", void 0), p = a3 = __decorate([a2("esri.layers.support.DimensionalDefinition")], p);

// node_modules/@arcgis/core/layers/support/rasterDatasets/multidimensionalUtils.js
function a4(e, n2, t) {
  const i = n2.shift();
  if (0 === t.length) {
    const e2 = [];
    t.push({ sliceId: -1, multidimensionalDefinition: e2 });
  }
  const s2 = t.length;
  for (let a5 = 0; a5 < s2; a5++) {
    const n3 = t.shift().multidimensionalDefinition;
    i.values?.forEach((a6) => {
      t.push({ sliceId: -1, multidimensionalDefinition: [...n3, { variableName: e, dimensionName: i.name, values: [a6] }] });
    });
  }
  n2.length && a4(e, n2, t);
}
function s(e, n2) {
  const t = [];
  let i = 0;
  return (n2 ? e.variables.filter((e2) => e2.name.toLowerCase() === n2.toLowerCase()) : [...e.variables].sort((e2, n3) => e2.name > n3.name ? 1 : -1)).forEach((e2) => {
    const n3 = [], s2 = [...e2.dimensions].sort((e3, n4) => e3.name > n4.name ? -1 : 1);
    a4(e2.name, s2, n3), n3.forEach((e3) => {
      t.push({ ...e3, sliceId: i++ });
    });
  }), t;
}
function r(e, n2, t) {
  let i = e;
  if (n2 && (n2 = [...n2].sort((e2, n3) => e2.dimensionName < n3.dimensionName ? -1 : 1)).forEach(({ dimensionName: e2, values: n3, isSlice: t2 }) => {
    n3.length && (i = i.filter((i2) => {
      const a5 = i2.multidimensionalDefinition.find((n4) => n4.dimensionName === e2);
      if (null == a5) return false;
      const s2 = a5.values[0];
      return "number" == typeof s2 ? "number" == typeof n3[0] ? n3.includes(s2) : n3.some((e3) => e3[0] <= s2 && e3[1] >= s2) : "number" == typeof n3[0] ? n3.some((e3) => s2[0] <= e3 && s2[1] >= e3) : t2 ? n3.some((e3) => e3[0] === s2[0] && e3[0] === s2[1]) : n3.some((e3) => e3[0] >= s2[0] && e3[0] <= s2[1] || e3[1] >= s2[0] && e3[1] <= s2[1] || e3[0] < s2[0] && e3[1] > s2[1]);
    }));
  }), i.length && null != t?.start && null != t.end) {
    const e2 = t.start.getTime(), n3 = t.end.getTime(), a5 = i[0].multidimensionalDefinition.findIndex((e3) => "StdTime" === e3.dimensionName);
    a5 > -1 && (i = i.filter((t2) => {
      const i2 = t2.multidimensionalDefinition[a5].values[0];
      return e2 <= i2 && n3 >= i2;
    }));
  }
  return i.map((e2) => e2.sliceId);
}
function l(e, n2) {
  return Array.isArray(e) ? n2[0] === n2[1] ? e[0] === n2[0] || e[1] === n2[0] : e[0] >= n2[0] && e[0] <= n2[1] && e[1] >= n2[0] && e[1] <= n2[1] : e >= n2[0] && e <= n2[1];
}
function u(e, n2) {
  return e[0] <= n2[0] && e[1] >= n2[0] || e[0] <= n2[1] && e[1] >= n2[1] || e[0] >= n2[0] && e[1] <= n2[1];
}
function o2(e) {
  return 1 === e.length ? [e[0], e[0]] : [e[0], e[e.length - 1]];
}
function m2(e, n2, t) {
  if (!n2?.subsetDefinitions?.length) return e;
  let i;
  if (t) {
    const { variables: a6 } = n2;
    if (a6.length && !a6.includes(t)) return null;
    const s3 = n2.subsetDefinitions.find((n3) => n3.dimensionName === e.name && n3.variableName === t);
    if (!s3?.values?.length) return e;
    i = o2(s3.values);
  } else {
    const t2 = n2.dimensions.find(({ name: n3 }) => n3 === e.name);
    i = t2?.extent;
  }
  const a5 = i;
  if (!a5?.length) return e;
  const s2 = e.values.filter((e2) => l(e2, a5));
  return { ...e, extent: [...a5], values: s2 };
}
function c(e, n2, t) {
  if (!n2?.subsetDefinitions?.length) return false;
  const { variables: i } = n2;
  if (i.length && e.some(({ variableName: e2 }) => e2 && !i.includes(e2))) return true;
  for (let a5 = 0; a5 < e.length; a5++) {
    const i2 = e[a5], s2 = n2.subsetDefinitions.find((e2) => ("" === i2.variableName || e2.variableName === i2.variableName) && e2.dimensionName === i2.dimensionName);
    if (s2?.values.length) {
      const e2 = o2(s2.values);
      if (!i2.isSlice && 2 === i2.values.length && !Array.isArray(i2.values[0]) && i2.values[0] !== i2.values[1] && t) {
        if (!u(i2.values, e2)) return true;
      } else if (i2.values.some((n3) => !l(n3, e2))) return true;
    }
  }
  return false;
}
function f(e, n2) {
  if (null == e) return { isOutside: false };
  const { geometry: t, timeExtent: i, multidimensionalDefinition: a5 } = n2;
  let s2 = null;
  if (null != i && (s2 = h(e, i), null == s2)) return { isOutside: true };
  const { areaOfInterest: r2 } = e;
  if (r2 && t) {
    const e2 = d(t);
    if (e2 && !r2.contains(e2)) return { isOutside: true };
  }
  return null != a5 && a5.length && c(a5, e, true) ? { isOutside: true } : { isOutside: false, intersection: { geometry: t, timeExtent: s2, multidimensionalDefinition: a5 } };
}
function d(e) {
  switch (e.type) {
    case "point":
      return e;
    case "extent":
      return e.center;
    case "polygon": {
      const i = o(e);
      return i ? _2.fromJSON(i) : null;
    }
  }
  return null;
}
function h(e, n2) {
  const t = e.dimensions.find(({ name: e2 }) => "StdTime" === e2);
  if (null == t || null == n2.start && null == n2.end) return n2;
  n2 = n2.clone();
  const { start: a5, end: s2 } = n2.toJSON(), r2 = a5 === s2 ? [a5] : null != a5 && null != s2 ? [a5, s2] : [a5 ?? s2];
  if (2 === r2.length && t?.extent.length && (r2[0] = Math.max(r2[0], t.extent[0]), r2[1] = Math.min(r2[1], t.extent[1] ?? t.extent[0]), r2[1] < r2[0])) return null;
  return c([new p({ variableName: "", dimensionName: "StdTime", isSlice: 1 === r2.length, values: r2 })], e, true) ? null : (n2.start = new Date(r2[0]), n2.end = new Date(r2[1] ?? r2[0]), n2);
}
function g(e) {
  const { rasterInfo: n2, multidimensionalSubset: t } = e, { multidimensionalInfo: i } = n2;
  if (null == i) return null;
  let a5 = e.multidimensionalDefinition?.length ? e.multidimensionalDefinition : b(n2, { multidimensionalSubset: t });
  if (!a5?.length) return null;
  if (a5.some((e2) => !e2.dimensionName)) {
    const { variableName: e2 } = a5[0], i2 = b(n2, { multidimensionalSubset: t, variableName: e2 });
    i2?.forEach((e3) => {
      const n3 = a5?.find(({ dimensionName: n4 }) => n4 === e3.dimensionName);
      n3?.values?.length && (e3.values = n3.values, e3.isSlice = n3.isSlice);
    }), a5 = i2;
  }
  const { timeExtent: s2 } = e;
  if (null != a5 && null != s2 && (null != s2.start || null != s2.end)) {
    a5 = a5.map((e3) => e3.clone());
    const e2 = i.variables.find(({ name: e3 }) => e3 === a5[0].variableName)?.dimensions?.find(({ name: e3 }) => "StdTime" === e3), n3 = a5.find(({ dimensionName: e3 }) => "StdTime" === e3);
    if (!e2 || !n3) return null;
    const { start: t2, end: r2 } = s2, l2 = null == t2 ? null : t2.getTime(), u2 = null == r2 ? null : r2.getTime(), o3 = l2 ?? u2, m3 = u2 ?? l2;
    if (null != e2.values) {
      const t3 = e2.values.filter((e3) => {
        if (Array.isArray(e3)) {
          if (o3 === m3) return e3[0] <= o3 && e3[1] >= o3;
          const n4 = e3[0] <= o3 && e3[1] > o3 || e3[0] < m3 && e3[1] >= m3, t4 = e3[0] >= o3 && e3[1] <= m3 || e3[0] < o3 && e3[1] > m3;
          return n4 || t4;
        }
        return o3 === m3 ? e3 === o3 : e3 >= o3 && e3 <= m3;
      });
      if (t3.length) {
        const e3 = t3.sort((e4, n4) => {
          const t4 = Array.isArray(e4) ? e4[0] : e4, i2 = Array.isArray(e4) ? e4[1] : e4, a6 = Array.isArray(n4) ? n4[0] : n4, s3 = Array.isArray(n4) ? n4[1] : n4;
          if (o3 === m3) return t4 - a6;
          return Math.abs(i2 - m3) - Math.abs(s3 - m3);
        })[0];
        n3.values = [e3];
      } else a5 = null;
    } else if (e2.hasRegularIntervals && e2.extent) {
      const [t3, i2] = e2.extent;
      o3 > i2 || m3 < t3 ? a5 = null : n3.values = o3 === m3 ? [o3] : [Math.max(t3, o3), Math.min(i2, m3)];
    }
  }
  return null != a5 && c(a5, t) ? null : a5;
}
function v(e, n2 = {}) {
  const { multidimensionalInfo: t, keyProperties: i } = e;
  if (null == t) return null;
  const { variableName: a5, multidimensionalSubset: s2, multidimensionalDefinition: r2 } = n2, l2 = null != r2 ? r2[0]?.variableName : null, u2 = a5 || l2 || i?.DefaultVariable;
  let { variables: o3 } = t;
  s2?.variables?.length && (o3 = o3.filter(({ name: e2 }) => s2.variables.includes(e2)));
  return u2 ? o3.find(({ name: e2 }) => e2 === u2) ?? o3[0] : o3[0];
}
function b(e, n2 = {}) {
  const t = v(e, n2);
  if (!t) return null;
  const a5 = [], { dimensions: s2, name: r2 } = t;
  if (0 === s2.length) return [new p({ variableName: r2, dimensionName: "", values: [], isSlice: true })];
  for (let l2 = 0; l2 < s2.length; l2++) {
    const e2 = m2(s2[l2], n2.multidimensionalSubset, r2);
    if (!e2) return null;
    const { values: t2, extent: u2 } = e2;
    let o3 = t2?.[0] ?? u2?.[0];
    "stdz" === e2.name.toLowerCase() && !e2.hasRanges && u2 && Math.abs(u2[1]) <= Math.abs(u2[0]) && (o3 = t2?.length ? t2[t2.length - 1] : u2[1]), a5.push(new p({ variableName: r2, dimensionName: e2.name, values: [o3], isSlice: !n2.useRangeForRangedDimensionInfo || !!e2.hasRanges }));
  }
  return a5;
}
function y(e) {
  return !!e?.length && e.some((e2) => {
    if (null == e2.values) return true;
    const n2 = e2.values.length;
    return 0 === n2 || n2 > 1 || !e2.isSlice && Array.isArray(e2.values[0]);
  });
}
function D(n2, t) {
  if (null == t || null == n2) return null;
  let i = t.variables.map((e) => ({ ...e }));
  return n2?.variables?.length && (i = i.filter(({ name: e }) => n2.variables.includes(e)), i.forEach((t2) => {
    t2.dimensions = t2.dimensions.map((e) => m2(e, n2, t2.name)).filter(N);
  })), i;
}
function N2(e, n2) {
  const { values: t } = n2;
  if (t?.length) {
    const n3 = Array.isArray(t[0]), i2 = Array.isArray(e);
    return n3 !== i2 ? -1 : n3 && i2 ? t.findIndex((n4) => n4[0] === e[0] && n4[1] === e[1]) : t.indexOf(e);
  }
  const { extent: i } = n2;
  if (Array.isArray(e) || !i || e < i[0] || e > i[1]) return -1;
  const a5 = n2.interval || 1;
  if ("ISO8601" !== n2.unit) return Math.round((e - i[0]) / a5);
  const s2 = i[0];
  let r2 = -1;
  switch (n2.intervalUnit?.toLowerCase() || "days") {
    case "seconds":
      r2 = Math.round((e - s2) / 1e3 / a5);
      break;
    case "minutes":
      r2 = Math.round((e - s2) / 6e4 / a5);
      break;
    case "hours":
      r2 = Math.round((e - s2) / 36e5 / a5);
      break;
    case "days":
      r2 = Math.round((e - s2) / 864e5 / a5);
      break;
    case "months":
      {
        const n3 = new Date(e).getUTCFullYear() - new Date(s2).getUTCFullYear(), t2 = new Date(s2).getUTCMonth(), i2 = new Date(e).getUTCMonth();
        r2 = 0 === n3 ? i2 - t2 : i2 + 11 - t2 + 12 * (n3 - 1);
      }
      break;
    case "years":
      r2 = Math.round((new Date(e).getUTCFullYear() - new Date(s2).getUTCFullYear()) / a5);
      break;
    case "decades":
      r2 = Math.round((new Date(e).getUTCFullYear() - new Date(s2).getUTCFullYear()) / 10 / a5);
  }
  return r2;
}
function T(e) {
  let n2 = e.values?.length;
  if (n2) return n2;
  const { extent: t, unit: i } = e, a5 = e.interval || 1, s2 = t ? t[1] - t[0] : 0;
  if ("ISO8601" !== i) return Math.round(s2 / a5);
  switch (e.intervalUnit?.toLowerCase() ?? "seconds") {
    case "seconds":
      n2 = Math.round(s2 / 1e3 / a5);
      break;
    case "minutes":
      n2 = Math.round(s2 / 6e4 / a5);
      break;
    case "hours":
      n2 = Math.round(s2 / 36e5 / a5);
      break;
    case "days":
      n2 = Math.round(s2 / 864e5 / a5);
      break;
    case "months":
      if (t) {
        const e2 = new Date(t[1]).getUTCFullYear() - new Date(t[0]).getUTCFullYear(), i2 = new Date(t[0]).getUTCMonth(), a6 = new Date(t[1]).getUTCMonth();
        n2 = 0 === e2 ? a6 - i2 + 1 : a6 + 11 - i2 + 12 * (e2 - 1) + 1;
      } else n2 = 0;
      break;
    case "years":
      n2 = t ? Math.round((new Date(t[1]).getUTCFullYear() - new Date(t[0]).getUTCFullYear()) / a5) : 0;
      break;
    case "decades":
      n2 = t ? Math.round((new Date(t[1]).getUTCFullYear() - new Date(t[0]).getUTCFullYear()) / 10 / a5) : 0;
      break;
    default:
      n2 = 0;
  }
  return n2;
}
function w(e) {
  if (2 !== e.extent?.length || !e.interval) return [];
  const { extent: [n2, t], interval: i } = e;
  if ("ISO8601" === e.unit) {
    const a6 = e.intervalUnit?.toLowerCase() ?? "days";
    return ["decades", "years", "months", "days", "hours", "minutes", "seconds"].includes(a6) ? M(n2, t, i, a6) : [];
  }
  const a5 = Math.round((t - n2) / i);
  return Array.from({ length: a5 }, (e2, s2) => s2 === a5 - 1 ? t : n2 + s2 * i);
}
function M(e, n2, t, i) {
  const a5 = [];
  let s2 = e;
  const r2 = new Date(e);
  for (; s2 <= n2; ) switch (a5.push(s2), i) {
    case "decades":
      r2.setUTCFullYear(r2.getUTCFullYear() + 10 * t), s2 = r2.getTime();
      break;
    case "years":
      r2.setUTCFullYear(r2.getUTCFullYear() + t), s2 = r2.getTime();
      break;
    case "months":
      r2.setUTCMonth(r2.getUTCMonth() + t), s2 = r2.getTime();
      break;
    case "days":
      s2 += 864e5 * t;
      break;
    case "hours":
      s2 += 36e5 * t;
      break;
    case "minutes":
      s2 += 6e4 * t;
      break;
    case "seconds":
      s2 += 1e3 * t;
  }
  return 1 === a5.length ? a5[1] = n2 : a5[a5.length - 1] = n2, a5;
}
function C(e, n2) {
  let t = 0;
  const i = e[0].variableName, a5 = [...n2.variables].sort((e2, n3) => e2.name > n3.name ? 1 : -1);
  for (let s2 = 0; s2 < a5.length; s2++) {
    const n3 = a5[s2], r2 = [...n3.dimensions].sort((e2, n4) => e2.name > n4.name ? -1 : 1);
    if (n3.name !== i) {
      t += r2.map((e2) => T(e2)).reduce((e2, n4) => e2 * n4);
      continue;
    }
    const l2 = r2.map((e2) => T(e2)), u2 = r2.length;
    for (let i2 = 0; i2 < u2; i2++) {
      const n4 = e.find((e2) => e2.dimensionName === r2[i2].name);
      if (null == n4) return null;
      const a6 = N2(n4.values[0], r2[i2]);
      if (-1 === a6) return null;
      l2.shift(), t += i2 === u2 - 1 ? a6 : a6 * l2.reduce((e2, n5) => e2 * n5);
    }
    break;
  }
  return t;
}
function U(e) {
  return Math.round(24 * (e - 25569) * 3600 * 1e3);
}

export {
  p,
  s,
  r,
  c,
  f,
  g,
  v,
  b,
  y,
  D,
  w,
  C,
  U
};
//# sourceMappingURL=chunk-BTNEC6LS.js.map
