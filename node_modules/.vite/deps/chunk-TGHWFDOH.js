import {
  e as e4,
  n as n3,
  r as r2,
  t as t2
} from "./chunk-KBVQCWWY.js";
import {
  v as v2
} from "./chunk-GVMCGYZ6.js";
import {
  e as e3
} from "./chunk-JHV6OBEB.js";
import {
  C,
  I,
  J,
  L,
  M,
  O,
  S,
  T,
  V,
  g as g2,
  j,
  o as o2,
  v,
  w,
  y
} from "./chunk-NDFIZYZY.js";
import {
  r
} from "./chunk-7HTU7ZUX.js";
import {
  R,
  _ as _2
} from "./chunk-QNVJVDYZ.js";
import {
  e as e2,
  t
} from "./chunk-K2OZ6WVC.js";
import {
  b,
  c,
  f,
  g,
  i as i2
} from "./chunk-XLOINTMG.js";
import {
  n as n2
} from "./chunk-234CIOHE.js";
import {
  _,
  nt,
  ot,
  tt
} from "./chunk-V2H77UEV.js";
import {
  e
} from "./chunk-4DGC7CBY.js";
import {
  A
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i,
  o,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  n
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/views/3d/glTF/LoaderResult.js
function e5(e7 = {}) {
  return { color: [1, 1, 1], opacity: 1, alphaMode: "OPAQUE", alphaCutoff: 0.5, doubleSided: false, castShadows: true, receiveShadows: true, receiveAmbientOcclusion: true, colorTexture: null, normalTexture: null, occlusionTexture: null, emissiveTexture: null, metallicRoughnessTexture: null, colorTextureTransform: null, normalTextureTransform: null, occlusionTextureTransform: null, emissiveTextureTransform: null, metallicRoughnessTextureTransform: null, emissiveFactor: [0, 0, 0], metallicFactor: 1, roughnessFactor: 1, colorMixMode: "multiply", ...e7 };
}
function l(e7, l4 = {}) {
  return { data: e7, parameters: { wrap: { s: 10497, t: 10497, ...l4.wrap }, noUnpackFlip: true, mipmap: false, ...l4 } };
}

// node_modules/@arcgis/core/chunks/scalar.js
function e6(e7, t7) {
  const o4 = e7.count;
  t7 || (t7 = new e7.TypedArrayConstructor(o4));
  for (let r6 = 0; r6 < o4; r6++) t7[r6] = e7.get(r6);
  return t7;
}
var t3 = Object.freeze(Object.defineProperty({ __proto__: null, makeDense: e6 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/libs/dracoMeshDecoder/dracoMeshDecoder.js
var r3;
function t4() {
  return r3 ??= (async () => {
    const { default: r6 } = await import("./draco_mesh_decoder-2K7O5ZZN.js");
    return await r6({ locateFile: (r7) => n2(`esri/libs/dracoMeshDecoder/${r7}`) });
  })(), r3;
}

// node_modules/@arcgis/core/views/3d/glTF/internal/BinaryStreamReader.js
var t5 = class {
  constructor(t7) {
    this._data = t7, this._offset4 = 0, this._dataUint32 = new Uint32Array(this._data, 0, Math.floor(this._data.byteLength / 4));
  }
  readUint32() {
    const t7 = this._offset4;
    return this._offset4 += 1, this._dataUint32[t7];
  }
  readUint8Array(t7) {
    const s3 = 4 * this._offset4;
    return this._offset4 += t7 / 4, new Uint8Array(this._data, s3, t7);
  }
  remainingBytes() {
    return this._data.byteLength - 4 * this._offset4;
  }
};

// node_modules/@arcgis/core/views/3d/glTF/internal/fillDefaults.js
var o3 = { baseColorFactor: [1, 1, 1, 1], metallicFactor: 1, roughnessFactor: 1 };
var r4 = { pbrMetallicRoughness: o3, emissiveFactor: [0, 0, 0], alphaMode: "OPAQUE", alphaCutoff: 0.5, doubleSided: false };
var t6 = { ESRI_externalColorMixMode: "tint", ESRI_receiveShadows: true, ESRI_receiveAmbientOcclusion: true };
var a = (e7 = {}) => {
  const a2 = { ...o3, ...e7.pbrMetallicRoughness }, i4 = l2({ ...t6, ...e7.extras });
  return { ...r4, ...e7, pbrMetallicRoughness: a2, extras: i4 };
};
function l2(o4) {
  switch (o4.ESRI_externalColorMixMode) {
    case "multiply":
    case "tint":
    case "ignore":
    case "replace":
      break;
    default:
      n(o4.ESRI_externalColorMixMode), o4.ESRI_externalColorMixMode = "tint";
  }
  return o4;
}
var i3 = { magFilter: 9729, minFilter: 9987, wrapS: 10497, wrapT: 10497 };
var s2 = (e7) => ({ ...i3, ...e7 });

// node_modules/@arcgis/core/views/3d/glTF/internal/pathUtils.js
function r5(r6) {
  let e7, t7;
  return r6.replace(/^(.*\/)?([^/]*)$/, (r7, a2, i4) => (e7 = a2 || "", t7 = i4 || "", "")), { dirPart: e7, filePart: t7 };
}

// node_modules/@arcgis/core/views/3d/glTF/internal/Resource.js
var k = { MAGIC: 1179937895, CHUNK_TYPE_JSON: 1313821514, CHUNK_TYPE_BIN: 5130562 };
var Y = class _Y {
  constructor(t7, r6, o4, n5) {
    if (this._context = t7, this.uri = r6, this.json = o4, this._glbBuffer = n5, this._bufferLoaders = /* @__PURE__ */ new Map(), this._textureLoaders = /* @__PURE__ */ new Map(), this._dracoBuffersSize = 0, this._textureCache = /* @__PURE__ */ new Map(), this._materialCache = /* @__PURE__ */ new Map(), this._nodeParentMap = /* @__PURE__ */ new Map(), this._nodeTransformCache = /* @__PURE__ */ new Map(), this._supportedExtensions = ["KHR_texture_basisu", "KHR_texture_transform", "KHR_draco_mesh_compression"], this._baseUri = r5(this.uri).dirPart, this._checkVersionSupported(), this._checkRequiredExtensionsSupported(), null == o4.scenes) throw new s("gltf-loader-unsupported-feature", "Scenes must be defined.");
    if (null == o4.meshes) throw new s("gltf-loader-unsupported-feature", "Meshes must be defined");
    if (null == o4.nodes) throw new s("gltf-loader-unsupported-feature", "Nodes must be defined.");
    this._computeNodeParents();
  }
  static async load(t7, r6, o4) {
    if (tt(r6)) {
      const e7 = ot(r6);
      if (e7 && "model/gltf-binary" !== e7.mediaType) try {
        const o6 = JSON.parse(e7.isBase64 ? atob(e7.data) : e7.data);
        return new _Y(t7, r6, o6);
      } catch {
      }
      const o5 = nt(r6);
      if (_Y._isGLBData(o5)) return this._fromGLBData(t7, r6, o5);
    }
    if (te.test(r6) || "gltf" === o4?.expectedType) {
      const e7 = await t7.loadJSON(r6, o4);
      return new _Y(t7, r6, e7);
    }
    const n5 = await t7.loadBinary(r6, o4);
    if (_Y._isGLBData(n5)) return this._fromGLBData(t7, r6, n5);
    if (re.test(r6) || "glb" === o4?.expectedType) throw new s("gltf-loader-invalid-glb", "This is not a valid glb file.");
    const u2 = await t7.loadJSON(r6, o4);
    return new _Y(t7, r6, u2);
  }
  static _isGLBData(e7) {
    if (null == e7) return false;
    const t7 = new t5(e7);
    return t7.remainingBytes() >= 4 && t7.readUint32() === k.MAGIC;
  }
  static async _fromGLBData(e7, t7, r6) {
    const o4 = await _Y._parseGLBData(r6);
    return new _Y(e7, t7, o4.json, o4.binaryData);
  }
  static async _parseGLBData(r6) {
    const o4 = new t5(r6);
    if (o4.remainingBytes() < 12) throw new s("gltf-loader-error", "glb binary data is insufficiently large.");
    const n5 = o4.readUint32(), s3 = o4.readUint32(), a2 = o4.readUint32();
    if (n5 !== k.MAGIC) throw new s("gltf-loader-error", "Magic first 4 bytes do not fit to expected glb value.");
    if (r6.byteLength < a2) throw new s("gltf-loader-error", "glb binary data is smaller than header specifies.");
    if (2 !== s3) throw new s("gltf-loader-unsupported-feature", "An unsupported glb container version was detected. Only version 2 is supported.");
    let i4, u2, f2 = 0;
    for (; o4.remainingBytes() >= 8; ) {
      const r7 = o4.readUint32(), n6 = o4.readUint32();
      if (0 === f2) {
        if (n6 !== k.CHUNK_TYPE_JSON) throw new s("gltf-loader-error", "First glb chunk must be JSON.");
        if (r7 < 0) throw new s("gltf-loader-error", "No JSON data found.");
        i4 = await n3(o4.readUint8Array(r7));
      } else if (1 === f2) {
        if (n6 !== k.CHUNK_TYPE_BIN) throw new s("gltf-loader-unsupported-feature", "Second glb chunk expected to be BIN.");
        u2 = o4.readUint8Array(r7);
      } else i.getLogger("esri.views.3d.glTF").warn("[Unsupported Feature] More than 2 glb chunks detected. Skipping.");
      f2 += 1;
    }
    if (!i4) throw new s("gltf-loader-error", "No glb JSON chunk detected.");
    return { json: i4, binaryData: u2 };
  }
  async getBuffer(t7, r6) {
    const o4 = this.json.buffers[t7];
    if (null == o4.uri) {
      if (null == this._glbBuffer) throw new s("gltf-loader-error", "glb buffer not present");
      return this._glbBuffer;
    }
    const n5 = await this._getBufferLoader(t7, r6);
    if (n5.byteLength !== o4.byteLength) throw new s("gltf-loader-error", "Buffer byte lengths should match.");
    return n5;
  }
  async _getBufferLoader(e7, t7) {
    const r6 = this._bufferLoaders.get(e7);
    if (r6) return r6;
    const o4 = this.json.buffers[e7].uri, n5 = this._context.loadBinary(this._resolveUri(o4), t7).then((e8) => new Uint8Array(e8));
    return this._bufferLoaders.set(e7, n5), n5;
  }
  _validateAccessor(t7) {
    if (!this.json.accessors) throw new s("gltf-loader-unsupported-feature", "Accessors missing.");
    const r6 = this.json.accessors[t7];
    if (r6.type in ["MAT2", "MAT3", "MAT4"]) throw new s("gltf-loader-unsupported-feature", `AttributeType ${r6.type} is not supported`);
    return r6;
  }
  _getComponentInfo(e7, t7) {
    const r6 = $[e7.type], o4 = t7?.componentType || e7.componentType, n5 = W[o4];
    return { componentType: o4, componentCount: r6, componentByteSize: n5, denseByteStride: r6 * n5 };
  }
  getDracoAccessor(e7, t7) {
    const r6 = this._validateAccessor(e7), o4 = t7.accessorInfos.get(e7), { componentType: n5, componentCount: s3, componentByteSize: a2, denseByteStride: i4 } = this._getComponentInfo(r6, o4);
    return { raw: t7.data.buffer, byteStride: i4, byteOffset: t7.data.byteOffset + (o4?.byteOffset || 0), entryCount: o4?.count ?? r6.count, isDenselyPacked: true, componentCount: s3, componentByteSize: a2, componentType: n5, min: r6.min, max: r6.max, normalized: !!r6.normalized };
  }
  async getAccessor(t7, r6) {
    const o4 = this._validateAccessor(t7);
    if (null == o4?.bufferView) throw new s("gltf-loader-unsupported-feature", "Some accessor does not specify a bufferView.");
    const { componentCount: n5, componentByteSize: s3, denseByteStride: a2 } = this._getComponentInfo(o4), i4 = this.json.bufferViews[o4.bufferView], u2 = await this.getBuffer(i4.buffer, r6), f2 = i4.byteStride || a2;
    return { raw: u2.buffer, byteStride: f2, byteOffset: u2.byteOffset + (i4.byteOffset || 0) + (o4.byteOffset || 0), entryCount: o4.count, isDenselyPacked: f2 === a2, componentCount: n5, componentByteSize: s3, componentType: o4.componentType, min: o4.min, max: o4.max, normalized: !!o4.normalized };
  }
  async getIndexData(e7, t7, r6) {
    if (null == e7.indices) return;
    const o4 = e7.indices, n5 = r6 ? this.getDracoAccessor(o4, r6) : await this.getAccessor(o4, t7);
    if (n5.isDenselyPacked) switch (n5.componentType) {
      case R.UNSIGNED_BYTE:
        return new Uint8Array(n5.raw, n5.byteOffset, n5.entryCount);
      case R.UNSIGNED_SHORT:
        return new Uint16Array(n5.raw, n5.byteOffset, n5.entryCount);
      case R.UNSIGNED_INT:
        return new Uint32Array(n5.raw, n5.byteOffset, n5.entryCount);
    }
    else switch (n5.componentType) {
      case R.UNSIGNED_BYTE:
        return e6(Z(I, n5));
      case R.UNSIGNED_SHORT:
        return e6(Z(w, n5));
      case R.UNSIGNED_INT:
        return e6(Z(v, n5));
    }
  }
  async getPositionData(t7, r6, n5) {
    if (null == t7.attributes.POSITION) throw new s("gltf-loader-unsupported-feature", "No POSITION vertex data found.");
    const s3 = t7.attributes.POSITION, a2 = n5 ? this.getDracoAccessor(s3, n5) : await this.getAccessor(s3, r6);
    if (a2.componentType !== R.FLOAT) throw new s("gltf-loader-unsupported-feature", "Expected type FLOAT for POSITION vertex attribute, but found " + o(R, a2.componentType));
    if (3 !== a2.componentCount) throw new s("gltf-loader-unsupported-feature", "POSITION vertex attribute must have 3 components, but found " + a2.componentCount.toFixed());
    return Z(o2, a2);
  }
  async getNormalData(t7, r6, n5) {
    if (null == t7.attributes.NORMAL) throw new s("gltf-loader-error", "No NORMAL vertex data found.");
    const s3 = t7.attributes.NORMAL, a2 = n5 ? this.getDracoAccessor(s3, n5) : await this.getAccessor(s3, r6);
    if (a2.componentType !== R.FLOAT) throw new s("gltf-loader-unsupported-feature", "Expected type FLOAT for NORMAL vertex attribute, but found " + o(R, a2.componentType));
    if (3 !== a2.componentCount) throw new s("gltf-loader-unsupported-feature", "NORMAL vertex attribute must have 3 components, but found " + a2.componentCount.toFixed());
    return Z(o2, a2);
  }
  async getTangentData(t7, r6, n5) {
    if (null == t7.attributes.TANGENT) throw new s("gltf-loader-error", "No TANGENT vertex data found.");
    const s3 = t7.attributes.TANGENT, a2 = n5 ? this.getDracoAccessor(s3, n5) : await this.getAccessor(s3, r6);
    if (a2.componentType !== R.FLOAT) throw new s("gltf-loader-unsupported-feature", "Expected type FLOAT for TANGENT vertex attribute, but found " + o(R, a2.componentType));
    if (4 !== a2.componentCount) throw new s("gltf-loader-unsupported-feature", "TANGENT vertex attribute must have 4 components, but found " + a2.componentCount.toFixed());
    return Z(T, a2);
  }
  async getTextureCoordinates(t7, r6, o4) {
    if (null == t7.attributes.TEXCOORD_0) throw new s("gltf-loader-error", "No TEXCOORD_0 vertex data found.");
    const n5 = t7.attributes.TEXCOORD_0, s3 = o4 ? this.getDracoAccessor(n5, o4) : await this.getAccessor(n5, r6);
    if (2 !== s3.componentCount) throw new s("gltf-loader-unsupported-feature", "TEXCOORD_0 vertex attribute must have 2 components, but found " + s3.componentCount.toFixed());
    if (s3.componentType === R.FLOAT) return Z(y, s3);
    if (!s3.normalized) throw new s("gltf-loader-unsupported-feature", "Integer component types are only supported for a normalized accessor for TEXCOORD_0.");
    return Q(s3);
  }
  async getVertexColors(t7, r6, n5) {
    if (null == t7.attributes.COLOR_0) throw new s("gltf-loader-error", "No COLOR_0 vertex data found.");
    const s3 = t7.attributes.COLOR_0, a2 = n5 ? this.getDracoAccessor(s3, n5) : await this.getAccessor(s3, r6);
    if (4 !== a2.componentCount && 3 !== a2.componentCount) throw new s("gltf-loader-unsupported-feature", "COLOR_0 attribute must have 3 or 4 components, but found " + a2.componentCount.toFixed());
    if (4 === a2.componentCount) {
      if (a2.componentType === R.FLOAT) return Z(T, a2);
      if (a2.componentType === R.UNSIGNED_BYTE) return Z(g2, a2);
      if (a2.componentType === R.UNSIGNED_SHORT) return Z(M, a2);
    } else if (3 === a2.componentCount) {
      if (a2.componentType === R.FLOAT) return Z(o2, a2);
      if (a2.componentType === R.UNSIGNED_BYTE) return Z(O, a2);
      if (a2.componentType === R.UNSIGNED_SHORT) return Z(V, a2);
    }
    throw new s("gltf-loader-unsupported-feature", "Unsupported component type for COLOR_0 attribute: " + o(R, a2.componentType));
  }
  hasPositions(e7) {
    return void 0 !== e7.attributes.POSITION;
  }
  hasNormals(e7) {
    return void 0 !== e7.attributes.NORMAL;
  }
  hasVertexColors(e7) {
    return void 0 !== e7.attributes.COLOR_0;
  }
  hasTextureCoordinates(e7) {
    return void 0 !== e7.attributes.TEXCOORD_0;
  }
  hasTangents(e7) {
    return void 0 !== e7.attributes.TANGENT;
  }
  async getMaterial(e7, t7, r6) {
    let o4 = e7.material ? this._materialCache.get(e7.material) : void 0;
    if (!o4) {
      const n5 = null != e7.material ? a(this.json.materials[e7.material]) : a(), s3 = n5.pbrMetallicRoughness, a2 = this.hasVertexColors(e7), i4 = this.getTexture(s3.baseColorTexture, t7), u2 = this.getTexture(n5.normalTexture, t7), f2 = r6 ? this.getTexture(n5.occlusionTexture, t7) : void 0, c3 = r6 ? this.getTexture(n5.emissiveTexture, t7) : void 0, d2 = r6 ? this.getTexture(s3.metallicRoughnessTexture, t7) : void 0, l4 = null != e7.material ? e7.material : -1;
      o4 = { alphaMode: n5.alphaMode, alphaCutoff: n5.alphaCutoff, color: s3.baseColorFactor, doubleSided: !!n5.doubleSided, colorTexture: await i4, normalTexture: await u2, name: n5.name, id: l4, occlusionTexture: await f2, emissiveTexture: await c3, emissiveFactor: n5.emissiveFactor, metallicFactor: s3.metallicFactor, roughnessFactor: s3.roughnessFactor, metallicRoughnessTexture: await d2, hasVertexColors: a2, ESRI_externalColorMixMode: n5.extras.ESRI_externalColorMixMode, colorTextureTransform: s3?.baseColorTexture?.extensions?.KHR_texture_transform, normalTextureTransform: n5.normalTexture?.extensions?.KHR_texture_transform, occlusionTextureTransform: n5.occlusionTexture?.extensions?.KHR_texture_transform, emissiveTextureTransform: n5.emissiveTexture?.extensions?.KHR_texture_transform, metallicRoughnessTextureTransform: s3?.metallicRoughnessTexture?.extensions?.KHR_texture_transform, receiveAmbientOcclusion: n5.extras.ESRI_receiveAmbientOcclusion, receiveShadows: n5.extras.ESRI_receiveShadows };
    }
    return o4;
  }
  async decode(t7, r6) {
    const o4 = t7.extensions?.KHR_draco_mesh_compression;
    if (!o4) return;
    if (null == t7.indices) throw new s("gltf-loader-error", "Found Draco compressed primitive without indices.");
    const n5 = this.json.bufferViews[o4.bufferView], s3 = await this.getBuffer(n5.buffer, r6), a2 = (await t4()).decode(new Uint8Array(s3.buffer, s3.byteOffset + (n5.byteOffset || 0), n5.byteLength));
    this._bufferLoaders.delete(n5.buffer);
    const i4 = /* @__PURE__ */ new Map([[t7.indices, a2.indices], [t7.attributes.POSITION, a2.positions]]);
    return t7.attributes.TEXCOORD_0 && i4.set(t7.attributes.TEXCOORD_0, a2.uvs), t7.attributes.NORMAL && i4.set(t7.attributes.NORMAL, a2.normals), t7.attributes.COLOR_0 && i4.set(t7.attributes.COLOR_0, a2.colors), t7.attributes.TANGENT && i4.set(t7.attributes.TANGENT, a2.tangents), this._dracoBuffersSize += a2.buffer.byteLength, { data: a2.buffer, accessorInfos: i4 };
  }
  async getTexture(t7, o4) {
    if (!t7) return;
    if (0 !== (t7.texCoord || 0)) throw new s("gltf-loader-unsupported-feature", "Only TEXCOORD with index 0 is supported.");
    const n5 = t7.index, s3 = this.json.textures[n5], a2 = s2(null != s3.sampler ? this.json.samplers[s3.sampler] : {}), i4 = ee(s3), u2 = this.json.images[i4], f2 = await this._loadTextureImageData(n5, s3, o4);
    return e(this._textureCache, n5, () => {
      const t8 = (e7) => 33071 === e7 || 33648 === e7 || 10497 === e7, r6 = (t9) => {
        throw new s("gltf-loader-error", `Unexpected TextureSampler WrapMode: ${t9}`);
      };
      return { data: f2, wrapS: t8(a2.wrapS) ? a2.wrapS : r6(a2.wrapS), wrapT: t8(a2.wrapT) ? a2.wrapT : r6(a2.wrapT), minFilter: a2.minFilter, name: u2.name, id: n5 };
    });
  }
  getNodeTransform(e7) {
    if (void 0 === e7) return X;
    let t7 = this._nodeTransformCache.get(e7);
    if (!t7) {
      const r6 = this.getNodeTransform(this._getNodeParent(e7)), o4 = this.json.nodes[e7];
      o4.matrix ? t7 = c(e2(), r6, o4.matrix) : o4.translation || o4.rotation || o4.scale ? (t7 = t(r6), o4.translation && i2(t7, t7, o4.translation), o4.rotation && (J2[3] = v2(J2, o4.rotation), b(t7, t7, J2[3], J2)), o4.scale && f(t7, t7, o4.scale)) : t7 = t(r6), this._nodeTransformCache.set(e7, t7);
    }
    return t7;
  }
  _resolveUri(e7) {
    return _(e7, this._baseUri);
  }
  _getNodeParent(e7) {
    return this._nodeParentMap.get(e7);
  }
  _checkVersionSupported() {
    const e7 = r.parse(this.json.asset.version, "glTF");
    q.validate(e7);
  }
  _checkRequiredExtensionsSupported() {
    const t7 = this.json;
    if (t7.extensionsRequired) {
      if (!t7.extensionsRequired.every((e7) => this._supportedExtensions.includes(e7))) throw new s("gltf-loader-unsupported-feature", "gltf loader was not able to load unsupported feature. Required extensions: " + t7.extensionsRequired.join(", "));
    }
  }
  _computeNodeParents() {
    this.json.nodes.forEach((e7, t7) => {
      e7.children && e7.children.forEach((e8) => {
        this._nodeParentMap.set(e8, t7);
      });
    });
  }
  async _loadTextureImageData(e7, t7, r6) {
    const o4 = this._textureLoaders.get(e7);
    if (o4) return o4;
    const n5 = this._createTextureLoader(t7, r6);
    return this._textureLoaders.set(e7, n5), n5;
  }
  async _createTextureLoader(t7, r6) {
    const o4 = ee(t7), n5 = this.json.images[o4];
    if (n5.uri) {
      if (n5.uri.endsWith(".ktx2")) {
        const e7 = await this._context.loadBinary(this._resolveUri(n5.uri), r6);
        return new e4(new Uint8Array(e7));
      }
      return this._context.loadImage(this._resolveUri(n5.uri), r6);
    }
    if (null == n5.bufferView) throw new s("gltf-loader-unsupported-feature", "Image bufferView must be defined.");
    if (null == n5.mimeType) throw new s("gltf-loader-unsupported-feature", "Image mimeType must be defined.");
    const s3 = this.json.bufferViews[n5.bufferView], a2 = await this.getBuffer(s3.buffer, r6);
    if (null != s3.byteStride) throw new s("gltf-loader-unsupported-feature", "byteStride not supported for image buffer");
    const i4 = a2.byteOffset + (s3.byteOffset || 0);
    return r2(new Uint8Array(a2.buffer, i4, s3.byteLength), n5.mimeType);
  }
  async getLoadedBuffersSize() {
    if (this._glbBuffer) return this._glbBuffer.byteLength;
    const e7 = await A(Array.from(this._bufferLoaders.values())), t7 = await A(Array.from(this._textureLoaders.values()));
    return e7.reduce((e8, t8) => e8 + (t8?.byteLength ?? 0), 0) + this._dracoBuffersSize + t7.reduce((e8, t8) => e8 + (t8 ? t2(t8) ? t8.data.byteLength : t8.width * t8.height * 4 : 0), 0);
  }
};
var X = g(e2(), Math.PI / 2);
var q = new r(2, 0, "glTF");
var J2 = e3();
var $ = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 };
var W = { [R.BYTE]: 1, [R.UNSIGNED_BYTE]: 1, [R.SHORT]: 2, [R.UNSIGNED_SHORT]: 2, [R.HALF_FLOAT]: 2, [R.FLOAT]: 4, [R.INT]: 4, [R.UNSIGNED_INT]: 4 };
function Q(e7) {
  switch (e7.componentType) {
    case R.BYTE:
      return new C(e7.raw, e7.byteOffset, e7.byteStride, e7.byteOffset + e7.byteStride * e7.entryCount);
    case R.UNSIGNED_BYTE:
      return new j(e7.raw, e7.byteOffset, e7.byteStride, e7.byteOffset + e7.byteStride * e7.entryCount);
    case R.SHORT:
      return new J(e7.raw, e7.byteOffset, e7.byteStride, e7.byteOffset + e7.byteStride * e7.entryCount);
    case R.UNSIGNED_SHORT:
      return new L(e7.raw, e7.byteOffset, e7.byteStride, e7.byteOffset + e7.byteStride * e7.entryCount);
    case R.UNSIGNED_INT:
      return new S(e7.raw, e7.byteOffset, e7.byteStride, e7.byteOffset + e7.byteStride * e7.entryCount);
    case R.FLOAT:
      return new y(e7.raw, e7.byteOffset, e7.byteStride, e7.byteOffset + e7.byteStride * e7.entryCount);
  }
}
function Z(e7, t7) {
  return new e7(t7.raw, t7.byteOffset, t7.byteStride, t7.byteOffset + t7.byteStride * (t7.entryCount - 1) + t7.componentByteSize * t7.componentCount);
}
function ee(t7) {
  if (null != t7.extensions?.KHR_texture_basisu) return t7.extensions.KHR_texture_basisu.source;
  if (null !== t7.source) return t7.source;
  throw new s("gltf-loader-unsupported-feature", "Source is expected to be defined for a texture. It can also be omitted in favour of an KHR_texture_basisu extension tag.");
}
var te = /\.gltf$/i;
var re = /\.glb$/i;

// node_modules/@arcgis/core/views/3d/glTF/loader.js
var n4 = 0;
async function l3(r6, s3, l4 = {}, m2 = true) {
  const T3 = await Y.load(r6, s3, l4), p = "gltf_" + n4++, f2 = { lods: [], materials: /* @__PURE__ */ new Map(), textures: /* @__PURE__ */ new Map(), meta: u(T3) }, x = !(!T3.json.asset.extras || "symbolResource" !== T3.json.asset.extras.ESRI_type), g3 = T3.json.asset.extras?.ESRI_webstyleSymbol?.webstyle, h = /* @__PURE__ */ new Map();
  let w2 = false;
  await c2(T3, async (r7, s4, a2, n5) => {
    const u2 = h.get(a2) ?? 0;
    h.set(a2, u2 + 1);
    const c3 = void 0 !== r7.mode ? r7.mode : _2.TRIANGLES, x2 = c3 === _2.TRIANGLES || c3 === _2.TRIANGLE_STRIP || c3 === _2.TRIANGLE_FAN ? c3 : null;
    if (null == x2) return void i.getLogger("esri.views.3d.glTF").warn("[Unsupported Feature] Unsupported primitive mode (" + o(_2, c3) + "). Skipping primitive.");
    if (!T3.hasPositions(r7)) return void i.getLogger("esri.views.3d.glTF").warn("Skipping primitive without POSITION vertex attribute.");
    const g4 = await T3.decode(r7, l4);
    w2 ||= !!g4;
    const v4 = T3.getPositionData(r7, l4, g4), S2 = T3.getMaterial(r7, l4, m2), R2 = T3.hasNormals(r7) ? T3.getNormalData(r7, l4, g4) : null, _3 = T3.hasTangents(r7) ? T3.getTangentData(r7, l4, g4) : null, F = T3.hasTextureCoordinates(r7) ? T3.getTextureCoordinates(r7, l4, g4) : null, y2 = T3.hasVertexColors(r7) ? T3.getVertexColors(r7, l4, g4) : null, E = T3.getIndexData(r7, l4, g4), I2 = { name: n5, transform: t(s4), attributes: { position: await v4, normal: R2 ? await R2 : null, texCoord0: F ? await F : null, color: y2 ? await y2 : null, tangent: _3 ? await _3 : null }, indices: await E, primitiveType: x2, material: d(f2, await S2, p) };
    let M2 = null;
    null != f2.meta?.ESRI_lod && "screenSpaceRadius" === f2.meta.ESRI_lod.metric && (M2 = f2.meta.ESRI_lod.thresholds[a2]), f2.lods[a2] = f2.lods[a2] || { parts: [], name: n5, lodThreshold: M2 }, f2.lods[a2].parts[u2] = I2;
  });
  for (const e7 of f2.lods) e7.parts = e7.parts.filter((e8) => !!e8);
  const v3 = await T3.getLoadedBuffersSize();
  return { model: f2, meta: { isEsriSymbolResource: x, uri: T3.uri, ESRI_webstyle: g3, isDracoDecompressed: w2 }, customMeta: {}, usedMemory: v3 };
}
function u(e7) {
  const o4 = e7.json;
  let t7 = null;
  return o4.nodes.forEach((e8) => {
    const o5 = e8.extras;
    null != o5 && (o5.ESRI_proxyEllipsoid || o5.ESRI_lod) && (t7 = o5);
  }), t7;
}
async function c2(o4, t7) {
  const r6 = o4.json, s3 = r6.scenes[r6.scene || 0].nodes, a2 = s3.length > 1, i4 = [];
  for (const e7 of s3) {
    const o5 = r6.nodes[e7];
    if (i4.push(n5(e7, 0)), m(o5) && !a2) {
      o5.extensions.MSFT_lod.ids.forEach((e8, o6) => n5(e8, o6 + 1));
    }
  }
  async function n5(s4, a3) {
    const l4 = r6.nodes[s4], u2 = o4.getNodeTransform(s4);
    if (null != l4.weights && i.getLogger("esri.views.3d.glTF").warn("[Unsupported Feature] Morph targets are not supported."), null != l4.mesh) {
      const e7 = r6.meshes[l4.mesh];
      for (const o5 of e7.primitives) i4.push(t7(o5, u2, a3, e7.name));
    }
    for (const e7 of l4.children || []) i4.push(n5(e7, a3));
  }
  await Promise.all(i4);
}
function m(e7) {
  return e7.extensions?.MSFT_lod && Array.isArray(e7.extensions.MSFT_lod.ids);
}
function d(e7, o4, t7) {
  const a2 = (o5) => {
    const r6 = `${t7}_tex_${o5 && o5.id}${o5?.name ? "_" + o5.name : ""}`;
    if (o5 && !e7.textures.has(r6)) {
      const t8 = l(o5.data, { wrap: { s: o5.wrapS, t: o5.wrapT }, mipmap: T2.has(o5.minFilter), noUnpackFlip: true });
      e7.textures.set(r6, t8);
    }
    return r6;
  }, i4 = `${t7}_mat_${o4.id}_${o4.name}`;
  if (!e7.materials.has(i4)) {
    const t8 = e5({ color: [o4.color[0], o4.color[1], o4.color[2]], opacity: o4.color[3], alphaMode: o4.alphaMode, alphaCutoff: o4.alphaCutoff, doubleSided: o4.doubleSided, colorMixMode: o4.ESRI_externalColorMixMode, colorTexture: o4.colorTexture ? a2(o4.colorTexture) : void 0, normalTexture: o4.normalTexture ? a2(o4.normalTexture) : void 0, occlusionTexture: o4.occlusionTexture ? a2(o4.occlusionTexture) : void 0, emissiveTexture: o4.emissiveTexture ? a2(o4.emissiveTexture) : void 0, metallicRoughnessTexture: o4.metallicRoughnessTexture ? a2(o4.metallicRoughnessTexture) : void 0, emissiveFactor: [o4.emissiveFactor[0], o4.emissiveFactor[1], o4.emissiveFactor[2]], colorTextureTransform: o4.colorTextureTransform, normalTextureTransform: o4.normalTextureTransform, occlusionTextureTransform: o4.occlusionTextureTransform, emissiveTextureTransform: o4.emissiveTextureTransform, metallicRoughnessTextureTransform: o4.metallicRoughnessTextureTransform, metallicFactor: o4.metallicFactor, roughnessFactor: o4.roughnessFactor, receiveShadows: o4.receiveShadows, receiveAmbientOcclusion: o4.receiveAmbientOcclusion });
    e7.materials.set(i4, t8);
  }
  return i4;
}
var T2 = /* @__PURE__ */ new Set([9987, 9985]);

export {
  l3 as l
};
//# sourceMappingURL=chunk-TGHWFDOH.js.map
