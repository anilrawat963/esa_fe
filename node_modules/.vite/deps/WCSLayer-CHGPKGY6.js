import {
  o as o3
} from "./chunk-LAJ2QATM.js";
import {
  X,
  X2,
  c,
  e,
  i as i3,
  l as l6,
  n,
  r,
  t as t2
} from "./chunk-GWWDVBTJ.js";
import "./chunk-ECIORIM4.js";
import {
  i2
} from "./chunk-ETHRUKGL.js";
import {
  U,
  p as p3,
  w
} from "./chunk-BTNEC6LS.js";
import "./chunk-BTFBYI67.js";
import "./chunk-D3G5WIRR.js";
import "./chunk-Q3JOE7TC.js";
import "./chunk-BJUALH6B.js";
import {
  o as o2,
  p as p2
} from "./chunk-EQUB4K44.js";
import "./chunk-NEYJ2XGC.js";
import "./chunk-L2YWECQ7.js";
import "./chunk-5RPEIJ7N.js";
import {
  L as L2,
  m as m3
} from "./chunk-TNGDEFWZ.js";
import {
  I
} from "./chunk-NQDCX3PB.js";
import "./chunk-QW7RJMQR.js";
import "./chunk-CJAJ4FML.js";
import {
  l as l4
} from "./chunk-JSH3APTG.js";
import "./chunk-WQT2KLDB.js";
import {
  d as d2
} from "./chunk-UVDECGZC.js";
import {
  o,
  s as s2
} from "./chunk-VKFTCFFM.js";
import {
  s as s3
} from "./chunk-ZETARPSI.js";
import {
  f as f2
} from "./chunk-TCDV4P3G.js";
import {
  b2 as b,
  d as d3,
  l as l5
} from "./chunk-CZOYDK6P.js";
import "./chunk-TMUM75KQ.js";
import "./chunk-RXH2WNPA.js";
import "./chunk-TWU3GKHX.js";
import "./chunk-BGIBV6LL.js";
import "./chunk-UQXJMFRI.js";
import "./chunk-DY7N5RAZ.js";
import {
  j
} from "./chunk-6TCXGIIN.js";
import {
  l as l2
} from "./chunk-NP2TBOXH.js";
import "./chunk-FHCV4NTV.js";
import "./chunk-HCTBVF3W.js";
import "./chunk-XTEXJOLG.js";
import "./chunk-YE4E5JCT.js";
import "./chunk-SXZO7ULH.js";
import "./chunk-H34D76ZQ.js";
import "./chunk-QTRET3PG.js";
import "./chunk-FMOL5XMB.js";
import "./chunk-VNSHGTPN.js";
import "./chunk-OEBAFVQK.js";
import "./chunk-EK7HOTRR.js";
import "./chunk-IXFJYDA2.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import "./chunk-233ALXRM.js";
import "./chunk-IRBX64M6.js";
import "./chunk-EKZRA6TO.js";
import "./chunk-M5SP6ZBM.js";
import "./chunk-ZCI5A4FF.js";
import "./chunk-2D47RURG.js";
import "./chunk-YP3WVJP3.js";
import "./chunk-M24KZOVI.js";
import "./chunk-6VL5D5UP.js";
import "./chunk-6QHY54HZ.js";
import "./chunk-GXJJY3ND.js";
import "./chunk-5ONGWFJ3.js";
import "./chunk-PLNHHGHL.js";
import "./chunk-4WTOIJXV.js";
import "./chunk-BBYMM7CM.js";
import "./chunk-EM7Y2JZC.js";
import {
  m as m2
} from "./chunk-QZQPB5XR.js";
import "./chunk-AQFRVV3U.js";
import {
  p
} from "./chunk-PEL3D3ZN.js";
import "./chunk-Q5KWD3VQ.js";
import "./chunk-BUQC3CLV.js";
import {
  t
} from "./chunk-W5S3VUFT.js";
import "./chunk-7YH7T6CS.js";
import "./chunk-3T4IXPP4.js";
import "./chunk-XTZAIV4X.js";
import "./chunk-63LDVRFI.js";
import "./chunk-C3FRY5U4.js";
import {
  q
} from "./chunk-JNJX34GB.js";
import "./chunk-3STJRSDT.js";
import "./chunk-67Q6KVC6.js";
import "./chunk-23NJHA5Q.js";
import "./chunk-4LA6K4VI.js";
import "./chunk-KEZCWFAR.js";
import "./chunk-JZUJ34RR.js";
import "./chunk-PMGS7UDU.js";
import "./chunk-3GHCGAH2.js";
import "./chunk-HWUOAPTX.js";
import "./chunk-QHCKOBU7.js";
import "./chunk-K2OZ6WVC.js";
import "./chunk-MC6NAKKX.js";
import "./chunk-TF6255HN.js";
import "./chunk-GD4FJL3C.js";
import "./chunk-C5OQVQZF.js";
import "./chunk-F7DKSAOI.js";
import "./chunk-4SOQWNPG.js";
import "./chunk-LTULADK2.js";
import "./chunk-35ST7YRB.js";
import "./chunk-EDA5QFHZ.js";
import "./chunk-CNYNCKEV.js";
import "./chunk-XL5QPCXN.js";
import "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-W75DBJD7.js";
import "./chunk-6KDQMJAI.js";
import "./chunk-UDHS2MGH.js";
import "./chunk-ENINOZUZ.js";
import {
  b as b2
} from "./chunk-P6IKJIMO.js";
import "./chunk-MHV23XAQ.js";
import "./chunk-V2X4OKYI.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import "./chunk-MA3QDRC3.js";
import "./chunk-W6J7XCPU.js";
import "./chunk-ONXWBTTM.js";
import {
  l as l3
} from "./chunk-T7F6Q6JJ.js";
import "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-7P2ANHQ3.js";
import "./chunk-XCKT47LJ.js";
import "./chunk-3FUHCAX3.js";
import {
  P
} from "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import {
  z
} from "./chunk-H74Q4SYB.js";
import {
  l
} from "./chunk-2OFHDVO5.js";
import "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-5UPBUJPC.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-CCQFL76O.js";
import "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import "./chunk-7H3U4IJR.js";
import "./chunk-SMWUT52Z.js";
import "./chunk-AXZMNHTN.js";
import "./chunk-5T3MJDSR.js";
import "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import {
  H2 as H
} from "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import {
  L,
  d,
  f2 as f
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/graphic/isWCSGraphicOrigin.js
var i4 = Symbol("isWCSGraphicOrigin");

// node_modules/@arcgis/core/graphic/WCSGraphicOrigin.js
var e2;
var s4 = class extends s2 {
  get [(e2 = i4, o)]() {
    return this.layer;
  }
  constructor(r3) {
    super(), this[e2] = true, this.type = "wcs", this.layer = r3;
  }
  get id() {
    return this.layer.id;
  }
};

// node_modules/@arcgis/core/layers/support/rasterDatasets/wcsCapabilitiesParser.js
function l7(e4) {
  return e4.endsWith("?") ? e4.slice(0, -1) : e4;
}
function u(e4) {
  return e4.filter(({ coverageSubType: e5 }) => null == e5 || "" === e5 || /^rectified(grid|dataset)/i.test(e5));
}
function p4(e4) {
  const i6 = t2(e4, "Service/name"), s5 = e(e4, "Capability"), c2 = e(s5, "GetCapabilities/Get/OnlineResource")?.getAttribute("xlink:href") ?? "", p5 = e(s5, "DescribeCoverage/Get/OnlineResource")?.getAttribute("xlink:href") ?? "", m5 = e(s5, "GetCoverage/Get/OnlineResource")?.getAttribute("xlink:href") ?? "", g4 = { getCapabilities: l7(c2), describeCoverage: l7(p5), getCoverage: l7(m5) }, v4 = n(e4, "CoverageOfferingBrief"), d6 = [];
  for (let r3 = 0; r3 < v4.length; r3++) {
    const e5 = v4[r3], i7 = t2(e5, "name"), s6 = n(e5, "pos"), c3 = r(s6[0]), l8 = r(s6[1]), u2 = new z({ xmin: c3[0], ymin: c3[1], xmax: l8[0], ymax: l8[1], spatialReference: { wkid: 4326 } });
    d6.push({ id: i7, lonLatEnvelope: u2 });
  }
  return { name: i6, onlineResources: g4, coverages: d6, gridCoverages: u(d6), supportedVersions: ["1.0.0"], version: "1.0.0" };
}
function m4(e4) {
  const r3 = {};
  for (let i6 = 0; i6 < e4.childNodes.length; i6++) {
    const n4 = e4.childNodes[i6];
    if (1 !== n4.nodeType) continue;
    const s5 = c(n4).toLowerCase();
    switch (s5) {
      case "title":
      case "abstract":
        r3[s5] = t2(n4);
        break;
      case "identifier":
        r3.id = t2(n4);
        break;
      case "wgs84boundingbox":
        {
          const e5 = r(n4, "LowerCorner"), o4 = r(n4, "UpperCorner");
          r3.lonLatEnvelope = new z({ xmin: e5[0], ymin: e5[1], xmax: o4[0], ymax: o4[1], spatialReference: { wkid: 4326 } });
        }
        break;
      case "coveragesummary":
        r3.coverageSummaries = r3.coverageSummaries || [], r3.coverageSummaries.push(m4(n4));
    }
  }
  return r3;
}
function g(e4, t4) {
  if (e4.coverageSummaries) for (let r3 = 0; r3 < e4.coverageSummaries.length; r3++) e4.coverageSummaries[r3].abstract = e4.coverageSummaries[r3].abstract || e4.abstract, e4.coverageSummaries[r3].lonLatEnvelope = e4.coverageSummaries[r3].lonLatEnvelope || e4.lonLatEnvelope, e4.coverageSummaries[r3].title = e4.coverageSummaries[r3].title || e4.title, g(e4.coverageSummaries[r3], t4);
  null != e4.id && t4.push(e4);
}
function v(e4) {
  const t4 = e(e4.querySelector("Operation[name=GetCapabilities]"), "Get")?.getAttribute("xlink:href") || "", o4 = e(e4.querySelector("Operation[name=DescribeCoverage]"), "Get")?.getAttribute("xlink:href") || "", i6 = e(e4.querySelector("Operation[name=GetCoverage]"), "Get")?.getAttribute("xlink:href") || "";
  return { getCapabilities: l7(t4), describeCoverage: l7(o4), getCoverage: l7(i6) };
}
function d4(e4) {
  const t4 = t2(e4, "ServiceIdentification/Title"), n4 = l6(e4, "ServiceIdentification/ServiceTypeVersion"), a2 = v(e(e4, "OperationsMetadata")), c2 = [], l8 = e(e4, "Contents");
  for (let r3 = 0; r3 < l8.childNodes.length; r3++) {
    const e5 = l8.childNodes[r3];
    1 === e5.nodeType && (i3(e5, "CoverageSummary") && g(m4(e5), c2));
  }
  const p5 = l6(l8, "SupportedFormat");
  return { name: t4, onlineResources: a2, coverages: c2, gridCoverages: u(c2), supportedVersions: n4, supportedFormats: p5, version: "1.1.0" };
}
function f3(e4) {
  const s5 = e(e4, "ServiceIdentification"), c2 = t2(s5, "Title"), l8 = l6(s5, "ServiceTypeVersion"), p5 = l6(s5, "Profile"), m5 = v(e(e4, "OperationsMetadata")), g4 = n(e4, "Contents/CoverageSummary"), d6 = [];
  for (let i6 = 0; i6 < g4.length; i6++) {
    const e5 = g4[i6], n4 = t2(e5, "CoverageId"), s6 = e(e5, "WGS84BoundingBox");
    let c3;
    if (s6) {
      const e6 = r(s6, "LowerCorner"), r3 = r(s6, "UpperCorner");
      c3 = new z({ xmin: e6[0], ymin: e6[1], xmax: r3[0], ymax: r3[1], spatialReference: { wkid: 4326 } });
    }
    const l9 = t2(e5, "CoverageSubtype") || "RectifiedGridCoverage";
    d6.push({ id: n4, lonLatEnvelope: c3, coverageSubType: l9 });
  }
  const f5 = e(e4, "ServiceMetadata");
  return { name: c2, supportedVersions: l8, supportedFormats: l6(f5, "formatSupported"), supportedInterpolations: l6(f5, "interpolationSupported").concat(l6(f5, "InterpolationSupported")), onlineResources: m5, profiles: p5, coverages: d6, gridCoverages: u(d6), version: "2.0.1" };
}
function S(e4) {
  let t4 = null;
  if ("string" == typeof e4) {
    t4 = new DOMParser().parseFromString(e4, "text/xml");
  } else t4 = e4;
  const r3 = t4.documentElement.getAttribute("version"), o4 = r3?.slice(0, 3);
  return null != o4 && o4 < "2.1";
}
function b3(t4, r3 = null) {
  let o4 = null;
  if ("string" == typeof t4) {
    o4 = new DOMParser().parseFromString(t4, "text/xml");
  } else o4 = t4;
  let i6 = o4.documentElement.getAttribute("version");
  "1.0" === i6 ? i6 = "1.0.0" : "1.1" === i6 && (i6 = "1.1.0");
  const n4 = i6 || r3 || "1.0.0", a2 = n4.slice(0, 3);
  let s5;
  if ("2.0" === a2) s5 = f3(o4);
  else if ("1.1" === a2) s5 = d4(o4);
  else {
    if ("1.0" !== a2) throw new s("wcsraster:parsecapabilities", "the capabilities version is not supported");
    s5 = p4(o4);
  }
  return s5.version = n4, s5;
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/wcsCoverageParser.js
function d5(e4) {
  e4.variables.forEach((e5) => e5.dimensions.forEach((e6) => e6.values ??= w(e6)));
}
function f4(e4) {
  return { requestResponseCRSs: l6(e4, "requestResponseCRSs").map((e5) => e5.split(":")[1]), nativeCRSs: l6(e4, "nativeCRSs").map((e5) => e5.split(":")[1]) };
}
function g2(e4, t4) {
  const n4 = l6(e4, "1.0.0" === t4 ? "interpolationMethod" : "InterpolationMethod"), i6 = "1.0.0" === t4 ? e4.getAttribute("default") : t2(e4, "InterpolationMethods/Default");
  return null != i6 ? [i6].concat(n4.filter((e5) => e5.toLowerCase() !== i6.toLowerCase())) : n4;
}
function h(e4) {
  return null == e4 ? ["nearest"] : e4.map((e5) => {
    const t4 = e5.toLowerCase();
    return t4.includes("nearest") ? "nearest" : t4.includes("linear") ? "bilinear" : t4.includes("cubic") ? "cubic" : null;
  }).filter((e5) => !!e5);
}
function b4(t4) {
  const n4 = n(t4, "pos"), i6 = r(n4[0]), s5 = r(n4[1]);
  return new z({ xmin: i6[0], ymin: i6[1], xmax: s5[0], ymax: s5[1], spatialReference: { wkid: 4326 } });
}
function x(e4, t4) {
  const n4 = l6(e4, t4);
  return n4?.length && "" !== n4[0] && !isNaN(Number(n4[0])) ? n4.map((e5) => Number(e5)) : null;
}
function v2(e4) {
  const t4 = r(e4, "MinimumValue"), n4 = r(e4, "MaximumValue");
  return t4.length && n4.length ? t4.map((e5, t5) => ({ min: e5, max: n4[t5], avg: -1, stddev: -1 })) : null;
}
function D(e4) {
  return null == e4 ? null : e4.every((t4) => t4 === e4[0]) ? e4[0] : e4;
}
function y(e4) {
  const t4 = [], n4 = n(e4, "RangeSet");
  let i6 = [];
  for (let s5 = 0; s5 < n4.length; s5++) {
    const e5 = t2(n4[s5], "name"), a2 = t2(n4[s5], "label"), l8 = [], m5 = x(n4[s5], "nullValues/singleValue"), p5 = n(n4[s5], "AxisDescription");
    for (let t5 = 0; t5 < p5.length; t5++) {
      const e6 = t2(p5[t5], "name"), n5 = t2(p5[t5], "label"), s6 = l6(p5[t5], "singleValue");
      if (0 === s6.length) {
        const e7 = t2(p5[t5], "min"), n6 = t2(p5[t5], "max"), i7 = Number(t2(p5[t5], "res")) || 1;
        if (null !== e7 && null !== n6) for (let t6 = parseInt(e7, 10); t6 <= parseInt(n6, 10); t6 += i7) s6.push(t6.toString());
      }
      "band" === e6.toLowerCase() && (i6 = s6), l8.push({ name: e6, label: n5, values: s6 });
    }
    t4.push({ name: e5, label: a2, nullValues: m5, axis: l8 });
  }
  return { rangeSet: t4, bandNames: i6 };
}
function w2(e4 = null) {
  if (!e4) return { resolution: null, units: null };
  let t4 = e4.toUpperCase();
  const n4 = ["Y", "M", "D"], i6 = ["H", "M", "S"], s5 = ["Years", "Months", "Days", "Hours", "Minutes", "Seconds"];
  let a2, o4, l8;
  return t4.includes("PT") ? (t4 = t4.slice(2), l8 = i6.findIndex((e5) => t4.includes(e5)), a2 = s5[3 + l8], o4 = parseFloat(t4.slice(0, -1))) : (t4 = t4.slice(1), l8 = n4.findIndex((e5) => t4.includes(e5)), l8 > -1 && (a2 = s5[l8]), o4 = parseFloat(t4.slice(0, -1))), { resolution: o4, units: a2 };
}
function S2(e4) {
  const t4 = n(e4, "timeposition");
  if (t4.length > 0) {
    const e5 = [];
    for (let n5 = 0; n5 < t4.length; n5++) e5.push(new Date(t2(t4[n5])));
    return { begin: e5[0], end: e5[e5.length - 1], values: e5 };
  }
  const n4 = e(e4, "timePeriod") || e(e4, "TimePeriod");
  if (n4) {
    return { begin: new Date(t2(n4, "beginPosition") || t2(n4, "BeginPosition")), end: new Date(t2(n4, "endPosition") || t2(n4, "EndPosition")), ...w2(t2(n4, "timeResolution") || t2(n4, "TimeResolution")) };
  }
  return null;
}
function I2(t4) {
  const n4 = e(t4, "spatialDomain"), i6 = e(n4, "Envelope") || e(n4, "EnvelopeWithTimePeriod"), s5 = i6.getAttribute("srsName").split(":"), a2 = s5[s5.length - 1], l8 = n(i6, "pos"), u2 = r(l8[0]), m5 = r(l8[1]), d6 = parseInt(a2, 10), f5 = isNaN(d6) ? null : { wkid: d6 }, g4 = new z({ xmin: u2[0], ymin: u2[1], xmax: m5[0], ymax: m5[1], spatialReference: f5 }), h2 = e(n4, "RectifiedGrid"), b6 = t2(h2, "low").split(" "), x3 = t2(h2, "high").split(" "), v4 = parseInt(x3[0], 10) - parseInt(b6[0], 10) + 1, D2 = parseInt(x3[1], 10) - parseInt(b6[1], 10) + 1, y3 = r(n4, "origin/pos"), w4 = n(n4, "offsetVector"), I4 = { envelope: g4, columns: v4, rows: D2, offset: { x: parseFloat(t2(w4[0]).split(" ")[0]), y: parseFloat(t2(w4[1]).split(" ")[1]) }, origin: { x: y3[0], y: y3[1] } }, L5 = e(t4, "temporalDomain") || e(t4, "TemporalDomain");
  return { spatialDomain: I4, temporalDomain: L5 ? S2(L5) : null };
}
function L3(e4) {
  const t4 = { version: "1.0" };
  let n4, s5 = [];
  for (let i6 = 0; i6 < e4.childNodes.length; i6++) {
    const a3 = e4.childNodes[i6];
    if (1 === a3.nodeType) if (i3(a3, "description")) t4.description = t2(a3);
    else if (i3(a3, "name")) t4.name = t2(a3);
    else if (i3(a3, "label")) t4.label = t2(a3);
    else if (i3(a3, "supportedFormats")) t4.supportedFormats = l6(a3, "formats");
    else if (i3(a3, "supportedCRSs")) t4.supportedCRSs = f4(a3);
    else if (i3(a3, "supportedInterpolations")) t4.supportedInterpolations = g2(a3, "1.0.0");
    else if (i3(a3, "lonLatEnvelope")) t4.lonLatEnvelope = b4(a3);
    else if (i3(a3, "rangeSet")) {
      const e5 = y(a3);
      t4.rangeSet = e5.rangeSet, s5 = e5.bandNames;
      const i7 = e5.rangeSet[0].nullValues;
      i7?.length && (n4 = D(i7));
    } else i3(a3, "domainSet") && (t4.domainSet = I2(a3));
  }
  const a2 = h(t4.supportedInterpolations), { name: o4, description: m5, label: p5, lonLatEnvelope: c2, supportedFormats: d6 } = t4, { spatialDomain: x3 } = t4.domainSet, v4 = { x: Math.abs(x3.offset.x), y: Math.abs(x3.offset.y) }, w4 = C(t4.domainSet), S3 = new m3({ width: x3.columns, height: x3.rows, pixelSize: v4, pixelType: "unknown", extent: x3.envelope, spatialReference: x3.envelope.spatialReference, bandCount: s5.length || 1, noDataValue: n4, multidimensionalInfo: w4 });
  return { id: o4, title: t4.name, description: m5 || p5, lonLatEnvelope: c2, rasterInfo: S3, bandNames: s5, supportedFormats: d6, supportedInterpolations: a2, coverageDescription: t4, version: "1.0.0", useEPSGAxis: false };
}
function C(e4) {
  if (!e4.temporalDomain) return null;
  const { begin: t4, end: n4, values: i6, units: s5, resolution: a2 } = e4.temporalDomain, o4 = { variables: [{ name: "default", description: "", dimensions: [{ name: "StdTime", description: "", unit: "ISO8601", values: i6?.map((e5) => e5.getTime()), hasRegularIntervals: !i6, interval: a2, intervalUnit: s5, extent: [t4.getTime(), n4.getTime()] }] }] };
  return d5(o4), o4;
}
function T(e4, t4) {
  const n4 = [], i6 = n(e4, "Field");
  let s5, a2 = [];
  for (let l8 = 0; l8 < i6.length; l8++) {
    const e5 = t2(i6[l8], "Identifier"), m5 = t2(i6[l8], "Description"), c2 = t2(i6[l8], "Definition"), d6 = t2(i6[l8], "Abstract"), f5 = t2(i6[l8], "Title"), h2 = x(i6[l8], "NullValue"), b6 = e(i6[l8], "AllowedValues"), D2 = b6 ? v2(b6) : null, y3 = g2(i6[l8], "1.1.0"), w4 = [], S3 = n(i6[l8], "Axis");
    for (let n5 = 0; n5 < S3.length; n5++) {
      const e6 = S3[n5].getAttribute("identifier"), i7 = t2(S3[n5], "UOM"), o4 = t2(S3[n5], "DataType"), l9 = l6(S3[n5], "Key");
      t4 && !e6.toLowerCase().includes("band") || (a2 = l9, s5 = h2), w4.push({ identifier: e6, uom: i7, dataType: o4, values: l9, bandNoDataValues: s5 });
    }
    n4.push({ identifier: e5, description: m5, definition: c2, abstract: d6, title: f5, supportedInterpolations: y3, axis: w4, nullValues: h2, statistics: D2 });
  }
  return { rangeSet: n4, bandNames: a2, bandNoDataValues: s5, statistics: n4[0].statistics };
}
function R(e4, t4) {
  if (!t4.temporalDomain) return null;
  const n4 = e4.filter((e5) => !e5.identifier.toLowerCase().includes("field_1") && !e5.axis.some((e6) => e6.identifier.includes("band"))), i6 = [];
  if (n4.length && n4.forEach((e5) => {
    const t5 = e5.axis.map((e6) => {
      const t6 = e6.values.map((t7) => {
        if ("ISO8601" === e6.uom) {
          return (t7 = t7.trim()).toLowerCase().includes("z") ? new Date(t7).getTime() : (/* @__PURE__ */ new Date(t7 + "Z")).getTime();
        }
        return parseFloat(t7.trim());
      }), n5 = [Math.min.apply(null, t6), Math.max.apply(null, t6)];
      return { name: e6.identifier.trim(), description: "", field: e6.identifier.trim(), unit: e6.uom ? e6.uom.trim() : "", hasRegularIntervals: false, values: t6, extent: n5 };
    });
    i6.push({ name: e5.identifier.trim(), description: e5.description?.trim() ?? "", unit: "", dimensions: t5, statistics: e5.statistics });
  }), t4.temporalDomain) {
    const { begin: e5, end: n5, values: s5, units: a2, resolution: o4 } = t4.temporalDomain;
    i6.some((e6) => e6.dimensions.some((e7) => "stdtime" === e7.name.toLowerCase())) || i6.forEach((t5) => {
      t5.dimensions.push({ name: "StdTime", description: "", unit: "ISO8601", values: s5?.map((e6) => e6.getTime()), hasRegularIntervals: !s5, interval: o4, intervalUnit: a2, extent: [e5.getTime(), n5.getTime()] });
    });
  }
  if (i6.length) {
    const e5 = { variables: i6 };
    return d5(e5), e5;
  }
  return null;
}
function M(t4) {
  const i6 = e(t4, "SpatialDomain"), s5 = e(i6, "GridCRS"), a2 = t2(s5, "GridBaseCRS"), l8 = t2(s5, "GridOrigin"), u2 = l8?.split(" ").map((e4) => parseFloat(e4)) ?? [0, 0], m5 = r(s5, "GridOffsets"), d6 = n(i6, "BoundingBox");
  let f5, g4, h2, b6;
  for (let n4 = 0; n4 < d6.length; n4++) {
    const t5 = d6[n4].getAttribute("crs")?.toLowerCase();
    if (null != t5) {
      if (t5.includes("imagecrs")) {
        const e4 = r(d6[n4], "LowerCorner"), t6 = r(d6[n4], "UpperCorner");
        f5 = t6[0] - e4[0] + 1, g4 = t6[1] - e4[1] + 1;
      } else if (t5.indexOf("epsg") > 0) {
        const i7 = t5.split(":");
        h2 = parseInt(i7[i7.length - 1], 10);
        const s6 = r(d6[n4], "LowerCorner"), a3 = r(d6[n4], "UpperCorner");
        b6 = new z({ xmin: s6[0], ymin: s6[1], xmax: a3[0], ymax: a3[1], spatialReference: { wkid: h2 } });
      }
    }
  }
  const x3 = f5 > g4, v4 = b6.xmax - b6.xmin > b6.ymax - b6.ymin;
  let D2 = false;
  o3(h2) && (x3 === v4 ? D2 = false : (D2 = true, b6 = new z({ xmin: b6.ymin, ymin: b6.xmin, xmax: b6.ymax, ymax: b6.xmax, spatialReference: { wkid: h2 } })));
  const y3 = { columns: f5, rows: g4, origin: { x: u2[0], y: u2[1] }, offset: { x: m5[0], y: m5[m5.length - 1] }, gridBaseCRS: a2, envelope: b6, useEPSGAxis: D2 }, w4 = e(t4, "temporalDomain") || e(t4, "TemporalDomain");
  return { spatialDomain: y3, temporalDomain: w4 ? S2(w4) : null };
}
function N(e4, t4) {
  const n4 = [], s5 = [], a2 = { supportedFormats: n4, supportedCRSs: s5, version: "1.1" };
  let o4, l8, u2 = [];
  for (let i6 = 0; i6 < e4.childNodes.length; i6++) {
    const t5 = e4.childNodes[i6];
    if (1 !== t5.nodeType) continue;
    const p6 = c(t5).toLowerCase();
    switch (p6) {
      case "title":
      case "abstract":
      case "identifier":
        a2[p6] = t2(t5);
        break;
      case "supportedformat":
        {
          const e5 = t2(t5);
          n4.includes(e5) || n4.push(e5);
        }
        break;
      case "supportedcrs":
        {
          const e5 = t2(t5);
          s5.includes(e5) || s5.push(e5);
        }
        break;
      case "range":
        {
          const e5 = T(t5, !!a2.domain?.temporalDomain);
          a2.range = e5.rangeSet, u2 = e5.bandNames;
          const { bandNoDataValues: n5 } = e5;
          n5?.length && (o4 = D(n5)), l8 = e5.statistics;
        }
        break;
      case "domain":
        a2.domain = M(t5);
    }
  }
  const p5 = h(a2.range[0].supportedInterpolations), { identifier: c2, abstract: d6, title: f5, domain: g4, range: b6 } = a2, x3 = { x: Math.abs(g4.spatialDomain.offset.x), y: Math.abs(g4.spatialDomain.offset.y) }, v4 = R(b6, g4);
  v4 && (o4 = b6[0].nullValues, 1 === o4?.length && (o4 = o4[0]));
  const y3 = new m3({ width: g4.spatialDomain.columns, height: g4.spatialDomain.rows, pixelSize: x3, pixelType: "unknown", extent: g4.spatialDomain.envelope, spatialReference: g4.spatialDomain.envelope.spatialReference, bandCount: u2.length || 1, noDataValue: o4, statistics: l8, multidimensionalInfo: v4 });
  return { id: c2, title: a2.title, description: d6 || f5, bandNames: u2, rasterInfo: y3, supportedFormats: n4, supportedInterpolations: p5, coverageDescription: a2, version: t4, useEPSGAxis: g4.spatialDomain.useEPSGAxis };
}
function P2(t4) {
  const n4 = e(t4, "Envelope") || e(t4, "EnvelopeWithTimePeriod"), i6 = n4.getAttribute("srsName"), s5 = i6.slice(i6.lastIndexOf("/") + 1), a2 = n4.getAttribute("axisLabels").split(" ").map((e4) => e4.trim()).filter((e4) => "" !== e4.trim()), o4 = r(n4, "lowerCorner"), u2 = r(n4, "upperCorner"), m5 = !["y", "lat", "latitude", "north", "nor", "n", "b"].includes(a2[0].toLowerCase());
  let d6;
  const f5 = parseInt(s5, 10), g4 = isNaN(f5) ? null : { wkid: f5 };
  d6 = new z(m5 ? { xmin: o4[0], ymin: o4[1], xmax: u2[0], ymax: u2[1], spatialReference: g4 } : { xmin: o4[1], ymin: o4[0], xmax: u2[1], ymax: u2[0], spatialReference: g4 });
  const h2 = { mins: o4, maxs: u2 }, b6 = n4.getAttribute("uomLabels").trim().split(" ");
  let x3, v4;
  if (i3(n4, "EnvelopeWithTimePeriod")) {
    x3 = new Date(t2(t4, "beginPosition") || t2(t4, "BeginPosition")), v4 = new Date(t2(t4, "endPosition") || t2(t4, "EndPosition"));
    const e4 = b6?.findIndex((e5) => "oledatetime" === e5?.toLowerCase());
    e4 > -1 && (b6[e4] = "ISO8601");
  }
  return { envelope: d6, axisLabels: a2, uomLabels: b6.length ? b6 : null, envelopeAllDims: h2, beginPosition: x3, endPosition: v4, isEastFirst: m5 };
}
function E(e4, t4) {
  const n4 = [], i6 = n(e4, "DataRecord"), s5 = [];
  let a2, l8 = [];
  for (let u2 = 0; u2 < i6.length; u2++) {
    const e5 = n(i6[u2], "field"), m5 = [];
    for (let n5 = 0; n5 < e5.length; n5++) {
      const i7 = e5[n5].getAttribute("name"), o4 = t2(e5[n5], "description") || "", u3 = e(e5[n5], "uom")?.getAttribute("code") || "", d6 = r(e5[n5], "interval"), f5 = x(e5[n5], "nilValue")?.[0];
      t4 && !i7.toLowerCase().includes("band") || (s5.push(i7), d6?.length && (a2 = a2 || [], a2.push({ min: d6[0], max: d6[1], avg: -1, stddev: -1 })), l8.push(f5)), m5.push({ name: i7, description: o4, uom: u3, allowedValues: d6, nilValue: f5 });
    }
    n4.push(m5);
  }
  return l8.some((e5) => null != e5) || (l8 = null), { rangeType: n4, bandNames: s5, bandStats: a2, bandNoDataValues: l8 };
}
function V(e4) {
  let t4 = 1, n4 = "";
  const i6 = 0.01;
  return Math.abs(e4 - 1 / 24) < 1 / 24 * i6 ? n4 = "Hours" : Math.abs(e4 - 1) < 1 * i6 ? n4 = "Days" : e4 < 1 ? (t4 = Math.round(24 * e4), n4 = "Hours") : e4 > 28 - i6 && e4 < 31 + i6 || Math.round(e4 / 30) < 12 ? n4 = "Months" : e4 > 365 - i6 && e4 < 366 + i6 && (n4 = "Years"), { interval: t4, intervalUnit: n4 };
}
function A(e4, t4, n4) {
  if (n4.axisLabels.length <= 2) return null;
  const i6 = [];
  for (let s5 = 0; s5 < e4.length; s5++) {
    const t5 = e4[s5];
    for (let e5 = 0; e5 < t5.length; e5++) t5[e5].name.toLowerCase().includes("band") || i6.push(t5[e5]);
  }
  const a2 = [];
  if (i6.length) {
    const e5 = [];
    for (let i7 = 2; i7 < n4.axisLabels.length; i7++) {
      const a3 = t4.uomLabels?.[i7]?.trim() ?? "", o4 = n4.axisLabels[i7].toLowerCase().includes("time") || "iso8601" === a3.toLowerCase() || "oledatetime" === a3.toLowerCase();
      let l8, r3;
      if (o4) {
        const e6 = V(n4.offset[i7]);
        l8 = e6.interval, r3 = e6.intervalUnit;
      } else l8 = n4.offset[i7], r3 = a3;
      const u2 = [];
      o4 ? (u2.push(U(t4.envelopeAllDims.mins[i7])), u2.push(U(t4.envelopeAllDims.maxs[i7]))) : (u2.push(t4.envelopeAllDims.mins[i7]), u2.push(t4.envelopeAllDims.maxs[i7])), e5.push({ name: n4.axisLabels[i7].trim(), description: n4.axisLabels[i7].trim(), unit: o4 ? "ISO8601" : a3, hasRegularIntervals: true, extent: u2, interval: l8, intervalUnit: r3 });
    }
    if (i6.forEach((t5) => {
      const { allowedValues: n5 } = t5, i7 = 2 === n5?.length ? [{ min: n5[0], max: n5[1], avg: -1, stddev: -1 }] : null;
      a2.push({ name: t5.name.trim(), description: t5.description?.trim() ?? "", unit: t5.uom.trim(), statistics: i7, dimensions: [...e5] });
    }), a2.length) {
      const e6 = { variables: a2 };
      return d5(e6), e6;
    }
  }
  return null;
}
function F(e4, t4) {
  const n4 = e(e4, "RectifiedGrid"), i6 = r(n4, "low"), s5 = r(n4, "high"), a2 = [];
  for (let o4 = 0; o4 < i6.length; o4++) a2.push(s5[o4] - i6[o4] + 1);
  const l8 = t2(n4, "axisLabels").split(" "), u2 = r(n4, "origin/pos"), m5 = n(n4, "offsetVector"), d6 = [];
  for (let o4 = 0; o4 < m5.length; o4++) {
    const e5 = r(m5[o4]), t5 = e5.findIndex((e6) => 0 !== e6);
    d6[t5] = e5[t5];
  }
  const f5 = ["y", "lat", "latitude", "north", "nor", "n", "b"];
  let g4 = false;
  if (t4?.length && l8?.length) {
    g4 = [...t4].sort((e5, t5) => e5 < t5 ? -1 : 1).join(",") === [...l8].sort((e5, t5) => e5 < t5 ? -1 : 1).join(",");
  }
  const h2 = g4 ? l8 : t4;
  let b6, x3, v4;
  return f5.includes(h2[0].toLowerCase()) ? (b6 = a2[1], x3 = a2[0], v4 = { y: Math.abs(d6[0]), x: Math.abs(d6[1]) }) : (b6 = a2[0], x3 = a2[1], v4 = { x: Math.abs(d6[0]), y: Math.abs(d6[1]) }), { columns: b6, rows: x3, origin: u2, offset: d6, resolution: v4, gridSamples: a2, axisLabels: l8, hasSameAxisLabelsAsBoundedBy: g4 };
}
function O(e4) {
  const n4 = e(e4, "EarthObservation");
  if (!n4) return null;
  const i6 = e(n4, "phenomenonTime"), s5 = i6 ? S2(i6) : null, a2 = e(n4, "phenomenonTime"), o4 = a2 ? S2(a2) : null, l8 = t2(n4, "featureOfInterest/Footprint/multiExtentOf/MultiSurface/surfaceMembers/Polygon/exterior/LinearRing/posList");
  let u2 = null;
  if (l8) {
    const e5 = l8.split(" ").map((e6) => e6.trim()).filter((e6) => null != e6 && "" !== e6).map(Number);
    if (e5.length) {
      const n5 = [];
      for (let t4 = 0; t4 < e5.length / 2; t4 += 2) n5.push(e5[t4], e5[t4 + 1]);
      u2 = new P({ rings: [[n5]] });
    }
  }
  return { observation: { phenomenonTime: s5, resultTime: o4, footprint: u2, identifier: t2(e4, "metaDataProperty/EarthObservationMetaData/identifier"), acquisitionType: t2(e4, "metaDataProperty/EarthObservationMetaData/acquisitionType"), status: t2(e4, "metaDataProperty/EarthObservationMetaData/status") } };
}
function B(e4) {
  const t4 = { version: "2.0" };
  let n4, s5, a2 = [];
  for (let i6 = 0; i6 < e4.childNodes.length; i6++) {
    const o5 = e4.childNodes[i6];
    if (1 === o5.nodeType) {
      if (i3(o5, "coverageId")) t4.coverageId = t2(o5);
      else if (i3(o5, "ServiceParameters")) t4.serviceParameters = { supportedFormats: l6(o5, "nativeFormat") };
      else if (i3(o5, "boundedBy")) t4.boundedBy = P2(o5);
      else if (i3(o5, "rangeType")) {
        const e5 = E(o5, t4.boundedBy?.axisLabels.length > 2 || t4.domainSet?.axisLabels.length > 2);
        t4.rangeType = e5.rangeType, a2 = e5.bandNames, n4 = e5.bandStats;
        const { bandNoDataValues: i7 } = e5;
        i7?.length && (s5 = D(i7));
      } else if (i3(o5, "domainSet")) t4.domainSet = F(o5, t4.boundedBy?.axisLabels);
      else if (i3(o5, "metadata")) {
        const e5 = e(o5, "EOMetadata");
        t4.eoMetadata = e5 ? O(e5) : null;
      }
    }
  }
  const { coverageId: o4, boundedBy: m5, domainSet: c2, rangeType: d6, serviceParameters: f5 } = t4, g4 = A(d6, m5, c2);
  !n4 && g4 && (n4 = g4?.variables[0].statistics), null != g4 && (s5 = d6[0][0].nilValue);
  return { id: o4, title: o4, description: o4, bandNames: a2, rasterInfo: new m3({ width: c2.columns, height: c2.rows, pixelSize: c2.resolution, pixelType: "unknown", extent: m5.envelope, spatialReference: m5.envelope.spatialReference, bandCount: a2.length || 1, statistics: n4, noDataValue: s5, multidimensionalInfo: g4 }), supportedFormats: f5.supportedFormats, coverageDescription: t4, version: "2.0.1", useEPSGAxis: false };
}
function k(e4, t4) {
  let n4 = null;
  if ("string" == typeof e4) {
    n4 = new DOMParser().parseFromString(e4, "text/xml");
  } else n4 = e4;
  if ("1.0.0" === t4) {
    return n(n4, "CoverageOffering").map((e5) => L3(e5));
  }
  const i6 = n(n4, "CoverageDescription");
  return "1.1.0" === t4 || "1.1.1" === t4 || "1.1.2" === t4 ? i6.map((e5) => N(e5, t4)) : i6.map((e5) => B(e5));
}

// node_modules/@arcgis/core/layers/ogc/wcsUtils.js
async function i5(a2, i6) {
  const { version: n4, customParameters: c2, signal: p5 } = i6 ?? {}, l8 = n4?.startsWith("1.0") ? "version" : "acceptVersions", m5 = { service: "WCS", request: "GetCapabilities", [l8]: n4, ...c2 };
  try {
    let { data: r3 } = await H(a2, { query: m5, responseType: "xml", signal: p5 });
    return i6?.version || S(r3) || (m5[l8] = "2.0.1", { data: r3 } = await H(a2, { query: m5, responseType: "xml", signal: p5 })), b3(r3);
  } catch (u2) {
    if (!d(u2)) throw new s("wcslayer:open", "wcs capabilities is not valid or supported");
    throw u2;
  }
}
async function n2(t4, o4) {
  const { coverageIds: i6, version: n4, customParameters: c2, signal: p5 } = o4, l8 = n4.slice(0, 3), m5 = "1.0" === l8 ? "coverage" : "1.1" === l8 ? "identifiers" : "coverageId", u2 = { service: "WCS", request: "DescribeCoverage", version: n4, [m5]: i6.join(","), ...c2 };
  try {
    const { data: r3 } = await H(t4, { query: u2, responseType: "xml", signal: p5 });
    return k(r3, n4);
  } catch (v4) {
    if (!d(v4)) throw new s("wcslayer:open", "wcs coverage description is not valid or supported");
    throw v4;
  }
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/multipartParser.js
function t3(t4) {
  const r3 = e3(t4);
  return r3 ? { isMultipart: true, data: r3.boundary ? n3(t4.data, r3, 0) : null } : { isMultipart: false, data: null };
}
function n3(t4, n4, e4 = 0) {
  const o4 = "--" + n4.boundary, i6 = [];
  for (let r3 = 0; r3 < o4.length; r3++) i6.push(o4.charCodeAt(r3));
  const a2 = [], s5 = "\n--" + n4.boundary + "--";
  for (let r3 = 0; r3 < s5.length; r3++) a2.push(s5.charCodeAt(r3));
  const l8 = [10], c2 = [13, 10], f5 = [], u2 = i6.length, h2 = new Uint8Array(t4, e4), g4 = h2.length - u2;
  let p5 = 0, d6 = 0;
  for (let b6 = 0; b6 < g4; b6++) {
    for (d6 = 0; d6 < u2 && h2[b6 + d6] === i6[d6]; d6++) ;
    if (d6 !== u2) continue;
    let t5 = false;
    if (p5) {
      const e5 = r2(h2.subarray(p5, b6), n4);
      f5.push(e5), t5 = !!e5.isValidImage;
    }
    if (b6 += u2 - 1, h2[b6 + 1] === l8[0] ? b6 += 1 : h2[b6 + 1] === c2[0] && h2[b6 + 2] === c2[1] && (b6 += 2), p5 = b6 + 1, t5) break;
  }
  const y3 = a2.length;
  for (let b6 = h2.length - y3 - 10; b6 < h2.length - y3; b6++) {
    for (d6 = 0; d6 < y3 && h2[b6 + d6] === a2[d6]; d6++) ;
    if (d6 === y3) {
      f5.push(r2(h2.subarray(p5, b6), n4));
      break;
    }
  }
  return f5;
}
function e3(t4) {
  const n4 = t4.getHeader?.("Content-Type")?.split(";");
  if (!n4) return null;
  if (!(n4[0].trim() ?? "").startsWith("multipart/")) return null;
  const e4 = { boundary: "", start: "", type: "" };
  for (let r3 = 1; r3 < n4.length; r3++) {
    const t5 = n4[r3].indexOf("=");
    if (t5 > 0) {
      const o4 = n4[r3].slice(0, t5).trim(), i6 = n4[r3].slice(t5 + 1).trim();
      e4[o4] = i6.startsWith('"') ? i6.slice(1, -1) : i6;
    }
  }
  return e4;
}
function r2(t4, n4) {
  const e4 = String.fromCharCode.apply(null, t4.subarray(0, Math.min(300, t4.length))).split("\n"), r3 = Math.min(e4.length, 7), o4 = { contentDisposition: "inline" };
  let i6 = 0;
  for (let a2 = 0; a2 < r3; a2++) if (e4[a2].length < 4) i6 = i6 + e4[a2].length + 1;
  else if ("content" === e4[a2].slice(0, 7).toLowerCase()) {
    i6 = i6 + e4[a2].length + 1;
    const t5 = e4[a2].indexOf(":");
    if (-1 === t5) continue;
    const n5 = e4[a2].slice(0, t5).trim(), r4 = e4[a2].slice(t5 + 1).trim();
    switch (n5.toLowerCase()) {
      case "content-type":
        o4.contentType = r4;
        break;
      case "content-description":
        o4.contentDescription = r4;
        break;
      case "content-transfer-encoding":
        o4.contentTransferEncoding = r4;
        break;
      case "content-id":
        o4.contentID = r4;
        break;
      case "content-disposition":
        o4.contentDisposition = r4;
        break;
      case "content-location":
        o4.contentLocation = r4;
    }
  } else {
    if (o4.contentDisposition.toLowerCase().includes("inline") && e4[a2].length >= 4 && o4.contentType?.toLowerCase().includes("image")) {
      let n5 = true, e5 = t4.subarray(i6, t4.length);
      if (o4.contentType.toLowerCase().indexOf("tif") > 0) {
        if ("base64" === o4.contentTransferEncoding) {
          let t5 = "";
          const n6 = e5;
          for (let e6 = 0; e6 < n6.length; e6 += 65535) {
            const r5 = n6.subarray(e6, e6 + 65535 > n6.length - 1 ? n6.length - 1 : e6 + 65535);
            t5 += String.fromCharCode.apply(null, r5);
          }
          const r4 = atob(t5);
          e5 = new Uint8Array(r4.length);
          for (let o5 = 0; o5 < e5.length; o5++) e5[o5] = r4.charCodeAt(o5);
        }
        n5 = 73 === e5[0] && 73 === e5[1] || 77 === e5[0] && 77 === e5[1];
      }
      if (n5) {
        let n6 = e5.buffer;
        "base64" !== o4.contentTransferEncoding && (n6 = new ArrayBuffer(t4.length - i6), e5 = new Uint8Array(n6), e5.set(t4.subarray(i6, t4.length))), o4.contentData = n6, o4.isValidImage = true;
      }
      break;
    }
    if (("" === n4.start || o4.contentID === n4.start) && o4.contentType) {
      if (o4.contentType.includes("text") || o4.contentType.includes("xml")) {
        o4.contentData = String.fromCharCode.apply(null, t4.subarray(i6, t4.length));
        break;
      }
      o4.contentData = t4.subarray(i6, t4.length);
    }
  }
  return o4;
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/WCSRaster.js
var g3 = ["nearest neighbor", "bilinear", "bicubic"];
var w3 = ["nearest", "linear", "cubic"];
var v3 = "response is not a supported multipart/related mediaType with inline tiff,  switching to compatibility mode";
var y2 = "response is not a supported multipart mediaType with inline tiff";
var x2 = "response is base64 encoded which may impact layer display performance";
var I3 = "server returns an exception";
var C2 = /* @__PURE__ */ new Set(["1.0.0", "1.1.0", "1.1.1", "1.1.2", "2.0.1"]);
var b5 = class extends X {
  constructor() {
    super(...arguments), this.datasetFormat = "WCSServer", this.tileType = "Raster";
  }
  get rasterId() {
    return `${this.url}-${this.coverageId}-${this.version}`;
  }
  async fetchRawTile(e4, i6, n4, s5 = {}) {
    if (this.isBlockOutside(e4, i6, n4)) return null;
    const { nativePixelSize: o4, spatialReference: r3 } = this.rasterInfo, a2 = 2 ** e4, l8 = o4.x * a2, c2 = o4.y * a2, { blockWidth: d6, blockHeight: f5 } = this.getBlockWidthHeight(e4), { origin: p5 } = this.rasterInfo.storageInfo.tileInfo, u2 = this.getTileExtent({ x: l8, y: c2 }, i6, n4, p5, r3, [d6, f5]), h2 = this.rasterInfo.extent, g4 = u2.xmax > h2.xmax, w4 = u2.ymin < h2.ymin, v4 = g4 || w4;
    let y3 = u2, x3 = d6, I4 = f5;
    if (v4 && (y3 = u2.clone().intersection(h2), null != y3 && (g4 && (x3 = Math.floor((y3.xmax - y3.xmin) / l8), y3.xmax = y3.xmin + l8 * x3), w4 && (I4 = Math.floor((y3.ymax - y3.ymin) / c2), y3.ymin = y3.ymax - c2 * I4))), null == y3 || x3 <= 1 || I4 <= 1) return null;
    const C4 = await this._getCoverage(y3, x3, I4, a2, s5);
    if (!C4) return null;
    const { coverageDescription: b6 } = this.coverageInfo, { noDataValue: $2, multidimensionalInfo: S3 } = this.rasterInfo, { multidimensionalDefinition: j2 } = s5;
    let T3;
    if (null != S3 && null != j2 && j2.length) {
      const e5 = j2[0].variableName;
      if ("2.0" === b6.version) {
        const t4 = b6.rangeType[0].find((t5) => t5.name === e5);
        T3 = t4?.nilValue;
      } else if ("1.1" === b6.version) {
        const t4 = b6.range.find((t5) => t5.identifier === e5);
        T3 = t4?.nullValues;
      }
    }
    const L5 = T3 ?? $2, P3 = await this.decodePixelBlock(C4, { width: x3, height: I4, planes: null, pixelType: null, tiffNoDataValue: Array.isArray(L5) ? L5[0] : L5, matchAllNoData: true });
    if (null == P3) return null;
    if (P3 && (P3.width !== x3 || P3.height !== I4)) throw new s("wcsraster-fetch", `the response has unexpected dimension width: ${P3.width}, height: {pixelBlock.height}`);
    return v4 ? I(P3, { x: 0, y: 0 }, { width: f5, height: f5 }) : P3;
  }
  async _open(e4) {
    const { customFetchParameters: i6 } = this.ioConfig, n4 = e4?.signal, s5 = await i5(this.url, { version: i6?.version ?? this.version, customParameters: i6, signal: n4 });
    if (this.capabilities = s5, !this.version) {
      let e5 = s5.version.slice(0, 3);
      "2.0" === e5 || "1.1" === e5 || "1.0" === e5 ? this.version = s5.version : (e5 = s5.supportedVersions.find((e6) => "2.0.1" === e6) || s5.supportedVersions.find((e6) => e6.startsWith("2.0")) || s5.supportedVersions.find((e6) => e6.startsWith("1.1")) || s5.supportedVersions.find((e6) => e6.startsWith("1.0")) || "1.0.0", this.version = e5);
    }
    const { version: o4 } = this;
    if (!C2.has(o4)) throw new s("wcsraster-open", `unsupported WCS version ${o4}`);
    const { gridCoverages: r3 } = s5;
    if (!r3.length) throw new s("wcsraster-open", "cannot find rectified grid coverages");
    this.coverageId ??= r3[0].id;
    const { coverageId: c2 } = this, d6 = r3.find((e5) => e5.id === c2);
    if (null == d6) throw new s("wcsraster-open", `the coverageId ${c2} does not exist in capabilities`);
    const f5 = await n2(this.url, { coverageIds: [c2], version: o4, customParameters: i6, signal: n4 });
    if (this.coverageInfo = f5[0], o4.startsWith("2.0")) {
      const { coverageInfo: e5 } = this;
      e5.lonLatEnvelope = d6.lonLatEnvelope, e5.supportedInterpolations = h(s5.supportedInterpolations), this._patchDimensionValues201(c2, n4);
    }
    this.datasetName = this.coverageInfo.title;
    const { rasterInfo: p5 } = this.coverageInfo;
    if (this.createRemoteDatasetStorageInfo(p5, 512, 512), this._set("rasterInfo", p5), null == p5.spatialReference) throw new s("wcsraster-open", `coverage without spatial reference is not supported: ${c2}`);
    const { pixelType: h2, bandCount: m5 } = await this._getPixelTypeAndBandCount(n4);
    p5.pixelType = h2, 1 === p5.bandCount && m5 > 1 && (p5.bandCount = m5), this.updateTileInfo();
  }
  async _patchDimensionValues201(e4, t4) {
    const { coverageInfo: i6 } = this, n4 = i6.rasterInfo.multidimensionalInfo?.variables, s5 = C2.has("1.1.2") ? "1.1.2" : C2.has("1.1.1") ? "1.1.1" : C2.has("1.1.0") ? "1.1.0" : null, { customFetchParameters: o4 } = this.ioConfig;
    if (n4 && s5) try {
      const i7 = this.url.includes("/ImageServer/"), r3 = e4.length > 8 && e4.startsWith("Coverage") && i7 ? e4.slice(8) : e4, a2 = await n2(this.url, { coverageIds: [r3 ?? e4], version: s5, customParameters: o4, signal: t4 }).catch(() => {
        if (r3) return n2(this.url, { coverageIds: [e4], version: s5, customParameters: o4, signal: t4 });
      }), c2 = a2?.[0].rasterInfo.multidimensionalInfo?.variables;
      if (c2) for (const e5 of n4) {
        const t5 = c2.find(({ name: t6 }) => t6 === e5.name);
        if (t5?.dimensions?.length) for (let n5 = e5.dimensions.length - 1; n5 >= 0; n5--) {
          const s6 = e5.dimensions[n5], o5 = t5.dimensions.find(({ name: e6 }) => e6 === s6.name);
          o5 ? o5.values && o5.extent?.join(",") === s6.extent?.join(",") && (e5.dimensions[n5] = { ...s6, values: o5.values }) : i7 && e5.dimensions.splice(n5, 1);
        }
      }
    } catch {
    }
  }
  async _getPixelTypeAndBandCount(e4) {
    const { pixelSize: n4, extent: s5, multidimensionalInfo: r3 } = this.rasterInfo, a2 = s5.center, l8 = new z({ xmin: a2.x - n4.x, xmax: a2.x + n4.x, ymin: a2.y - n4.y, ymax: a2.y + n4.y, spatialReference: s5.spatialReference });
    let d6 = [];
    if (null != r3) {
      const e5 = r3.variables[0];
      d6 = [], e5.dimensions.forEach((t4) => {
        d6.push(new p3({ variableName: e5.name, dimensionName: t4.name, values: t4.hasRegularIntervals ? t4.extent?.[0] : t4.values?.[0], isSlice: true }));
      });
    }
    const { coverageDescription: f5 } = this.coverageInfo, p5 = { interpolation: "nearest", multidimensionalDefinition: d6, signal: e4 }, { version: u2 } = f5, { ioConfig: h2 } = this, m5 = "2.0" === u2 && null == h2.allowAnyMediaType || "1.1" === u2 && null == h2.use2GridOffsets;
    let g4;
    try {
      g4 = await this._getCoverage(l8, 2, 2, 1, p5, true);
    } catch (y3) {
      if (!m5) throw y3;
      if ("1.1" === u2) {
        if (!y3.details?.isResolutionMismatch) throw y3;
        h2.use2GridOffsets = true;
      }
    }
    if (!g4 && m5 && ("2.0" === u2 && (h2.allowAnyMediaType = true), g4 = await this._getCoverage(l8, 2, 2, 1, p5), g4 && i.getLogger(this).warn("wcsraster:getcoverage", v3)), !g4) throw new s("wcsraster-open", "unable to determine pixel type");
    const w4 = await this.decodePixelBlock(g4, { width: 2, height: 2, planes: null, pixelType: null });
    if (null == w4) throw new s("wcsraster-open", "unable to determine pixel type");
    return { pixelType: w4.pixelType, bandCount: w4.getPlaneCount() ?? 0 };
  }
  async _getCoverage(e4, n4, s5, o4, r3, a2 = false) {
    const { coverageDescription: l8 } = this.coverageInfo, { version: c2 } = l8, d6 = "2.0" === c2 ? this._getCoverage201Parameters(e4, n4, s5, o4, r3, l8) : "1.1" === c2 ? this._getCoverage110Parameters(e4, n4, s5, r3, l8) : this._getCoverage100Parameters(e4, n4, s5, r3), f5 = "2.0" === c2 ? await this.request(this._constructWCS201Url(d6), { signal: r3.signal, responseType: "array-buffer" }) : await this.request(this.url, { query: d6, signal: r3.signal, responseType: "array-buffer" });
    if ("1.0" === c2) return f5.data;
    if ("2.0" === c2 && false !== this.ioConfig.allowAnyMediaType) {
      if ("tiff" === L2(f5.data)) return a2 && (this.ioConfig.allowAnyMediaType = true, i.getLogger(this).warn("wcsraster:getcoverage", v3)), f5.data;
    }
    const u2 = t3(f5);
    if (u2.isMultipart && u2.data) {
      const e5 = u2.data.find((e6) => e6.isValidImage);
      return a2 && "base64" === e5?.contentTransferEncoding && i.getLogger(this).warn("wcsraster:getcoverage", x2), e5?.contentData;
    }
    const m5 = new Uint8Array(f5.data, 0, Math.min(f5.data.byteLength, 2e3)), g4 = String.fromCharCode.apply(null, m5).toLowerCase().includes("exception"), w4 = g4 && String.fromCharCode.apply(null, m5).includes("A non-zero RESX/RESY or WIDTH/HEIGHT is required but neither was provided");
    if (g4) throw new s("wcsraster:getcoverage", I3, { isResolutionMismatch: w4 });
    throw new s("wcsraster:getcoverage", y2);
  }
  _getInterpolationIndex(e4) {
    return e4 && this.coverageInfo.supportedInterpolations?.includes(e4) ? "nearest" === e4 ? 0 : "bilinear" === e4 ? 1 : "cubic" === e4 ? 2 : 0 : 0;
  }
  _getCoverage100Parameters(e4, t4, i6, n4) {
    const s5 = `${e4.xmin},${e4.ymin},${e4.xmax},${e4.ymax}`, o4 = e4.spatialReference.wkid, r3 = (this.coverageInfo.supportedFormats || []).find((e5) => e5.toLowerCase().includes("tiff")) || "GEOTIFF", { bandIds: a2, interpolation: l8 } = n4, c2 = this._getInterpolationIndex(l8), d6 = a2 ? a2.map((e5) => this.coverageInfo.bandNames[e5]) : null, f5 = g3[c2], { multidimensionalDefinition: p5 } = n4;
    let u2;
    if (null != p5 && null != this.rasterInfo.multidimensionalInfo) {
      const e5 = p5.find((e6) => "StdTime" === e6.dimensionName);
      let t5 = e5?.values;
      t5 && t5.length > 0 && (Array.isArray(t5[0]) && (t5 = t5[0]), u2 = t5.map((e6) => $(e6)).join(","));
    }
    return { service: "WCS", request: "GetCoverage", version: this.version, coverage: this.coverageId, format: r3, crs: `EPSG:${o4}`, bbox: s5, width: t4, height: i6, time: u2, interpolation: f5, band: d6?.join(",") };
  }
  _getCoverage110Parameters(e4, t4, i6, n4, s5) {
    const { multidimensionalDefinition: o4, bandIds: a2, interpolation: l8 } = n4, c2 = e4.spatialReference.wkid, d6 = `urn:ogc:def:crs:EPSG::${c2}`, f5 = (this.coverageInfo.supportedFormats || []).find((e5) => e5.toLowerCase().includes("tiff")) || "image/tiff", p5 = this._getInterpolationIndex(l8), u2 = w3[p5], h2 = null == l8 || 0 === this.coverageInfo.supportedInterpolations?.indexOf(l8), m5 = s5.domain.spatialDomain, g4 = m5.origin.x <= m5.envelope.xmin && m5.origin.y <= m5.envelope.ymin, v4 = e4.width / t4, y3 = e4.height / i6 * (g4 ? 1 : -1), x3 = g4 ? [e4.xmin, e4.ymin] : [e4.xmin, e4.ymax], I4 = m5.useEPSGAxis && o3(c2), C4 = I4 ? `${x3[1]},${x3[0]}` : `${x3[0]},${x3[1]}`, b6 = this.ioConfig.use2GridOffsets, S3 = I4 ? b6 ? `${y3},${v4}` : `${y3},0,0,${v4}` : b6 ? `${v4},${y3}` : `${v4},0,0,${y3}`, j2 = v4 / 2, T3 = e4.xmin + j2, L5 = e4.xmax - j2, P3 = Math.abs(y3) / 2, R2 = e4.ymin + P3, D2 = e4.ymax - P3, _ = I4 ? `${R2},${T3},${D2},${L5},${d6}` : `${T3},${R2},${L5},${D2},${d6}`, A2 = s5.range.find((e5) => e5.axis.some((e6) => e6.identifier.toLowerCase().includes("band")));
    let E2, W = A2 && u2 && a2 ? h2 ? `${A2.identifier}[${A2.axis[0].identifier}[${a2.join(",")}]]` : `${A2.identifier}:${u2}[${A2.axis[0].identifier}[${a2.join(",")}]]` : null;
    if (null != o4 && o4.length) for (let r3 = 0; r3 < o4.length; r3++) {
      let e5 = o4[r3].values;
      const t5 = o4[r3].dimensionName?.toLowerCase(), i7 = o4[r3].variableName?.toLowerCase(), n5 = s5.range.find((e6) => e6.identifier.toLowerCase() === i7);
      if (e5.length > 0) {
        if (Array.isArray(e5[0]) && (e5 = e5[0]), "stdtime" === t5) E2 = e5.map((e6) => $(e6)).join(",");
        else if (n5) {
          const i8 = n5.axis.find((e6) => e6.identifier.toLowerCase() === t5);
          i8 && (W = h2 ? n5.identifier + "[" + i8.identifier + "[" + e5.join(",") + "]]" : n5.identifier + ":" + u2 + "[" + i8.identifier + "[" + e5.join(",") + "]]");
        }
      }
      r3 === o4.length - 1 && n5 && !W && (W = h2 ? n5.identifier : n5.identifier + ":" + u2);
    }
    return { service: "WCS", request: "GetCoverage", version: this.version, identifier: this.coverageId, format: f5, crs: `EPSG:${c2}`, boundingbox: _, gridCS: "urn:ogc:def:cs:OGC:0.0:Grid2dSquareCS", gridType: "urn:ogc:def:method:WCS:1.1:2dGridIn2dCrs", gridOrigin: C4, gridOffsets: S3, gridBaseCRS: d6, timeSequence: E2, rangeSubset: W };
  }
  _getCoverage201Parameters(e4, t4, i6, n4, s5, o4) {
    const { multidimensionalDefinition: r3, interpolation: a2 } = s5, l8 = this._getInterpolationIndex(a2);
    let c2 = null;
    const { supportedInterpolations: d6 } = this.capabilities;
    if (d6?.length) switch (l8) {
      case 0:
        c2 = d6.find((e5) => e5.toLowerCase().includes("nearest"));
        break;
      case 1:
        c2 = d6.find((e5) => e5.toLowerCase().includes("linear"));
        break;
      case 2:
        c2 = d6.find((e5) => e5.toLowerCase().includes("cubic") || e5.toLowerCase().includes("quadratic"));
    }
    const f5 = (this.coverageInfo.supportedFormats || []).find((e5) => e5.toLowerCase().includes("tiff")) || "image/tiff", { bandNames: p5 } = this.coverageInfo, { boundedBy: u2, domainSet: h2, rangeType: m5 } = o4, g4 = u2.isEastFirst ? 0 : 1, w4 = 1 - g4, { axisLabels: v4 } = u2, y3 = v4[g4], x3 = v4[w4], I4 = `http://www.opengis.net/def/crs/EPSG/0/${e4.spatialReference.wkid}`, C4 = I4, b6 = [];
    b6.push(`${y3}(${e4.xmin},${e4.xmax})`), b6.push(`${x3}(${e4.ymin},${e4.ymax})`);
    const S3 = [];
    if (v4.length > 2) for (let D2 = 2; D2 < v4.length; D2++) {
      const e5 = h2.origin[D2];
      if (v4[D2].toLowerCase().includes("time")) {
        let t5 = e5.toString();
        u2.uomLabels?.[D2].toLowerCase().includes("ole") && (S3.push(v4[D2]), t5 = $(e5, true)), b6.push(v4[D2] + ",http://www.opengis.net(" + t5 + ")");
      } else b6.push(v4[D2] + ",http://www.opengis.net(" + e5 + ")");
    }
    let j2 = null;
    if (null != r3 && r3.length) {
      const e5 = [];
      m5.forEach((t6) => t6.forEach((t7) => e5.push(t7.name)));
      const t5 = [];
      for (let i7 = 0; i7 < r3.length; i7++) {
        const n5 = v4.find((e6) => e6 === r3[i7].dimensionName), s6 = e5.find((e6) => e6 === r3[i7].variableName);
        if (t5.includes(s6) || t5.push(s6), n5) {
          let e6 = r3[i7].values;
          if (e6.length > 0) {
            Array.isArray(e6[0]) && (e6 = e6[0]);
            let t6 = "";
            t6 = n5.toLowerCase().includes("time") ? e6.map((e7) => $(e7)).join(",") : e6.join(",");
            const i8 = b6.findIndex((e7) => e7.startsWith(n5 + ",http://www.opengis.net"));
            -1 === i8 && b6.push(n5 + ",http://www.opengis.net(" + t6 + ")"), -1 === i8 || b6[i8].includes("(" + t6 + ")") || b6.splice(i8, 1, n5 + ",http://www.opengis.net(" + t6 + ")");
          }
        }
      }
      t5.length && (j2 = t5.join(","));
    } else if (p5?.length >= 2) {
      j2 = (s5.bandIds ? s5.bandIds.map((e5) => p5[e5]) : p5).join(",");
    }
    const T3 = b6.join("&subset="), L5 = !o4.domainSet.hasSameAxisLabelsAsBoundedBy && false !== this.ioConfig.allowScaleFactor, P3 = L5 ? null : `${y3}(${t4}),${x3}(${i6})`, R2 = L5 ? 1 / n4 : null;
    return { service: "WCS", request: "GetCoverage", version: this.version, coverageId: this.coverageId, rangesubset: j2, interpolation: c2, scaleSize: P3, scaleFactor: R2, subset: T3, format: f5, mediaType: this.ioConfig.allowAnyMediaType ? null : "multipart/related", outputcrs: I4, subsettingcrs: C4 };
  }
  _constructWCS201Url(e4) {
    const t4 = { ...this.ioConfig.customFetchParameters, ...e4 }, i6 = [];
    Object.keys(t4).forEach((e5) => {
      const n4 = t4[e5];
      null != n4 && ("subset" === e5 ? "string" == typeof n4 && n4.split("&subset=").forEach((e6) => {
        e6 && i6.push(`subset=${encodeURIComponent(e6)}`);
      }) : i6.push(`${e5}=${encodeURIComponent(n4)}`));
    });
    return `${encodeURI(this.url)}?${i6.join("&")}`;
  }
};
function $(e4, t4 = false) {
  return (t4 ? new Date(U(e4)) : new Date(e4)).toISOString();
}
__decorate([m({ type: String, json: { write: true } })], b5.prototype, "datasetFormat", void 0), __decorate([m({ readOnly: true })], b5.prototype, "tileType", void 0), __decorate([m({ type: String, json: { write: true } })], b5.prototype, "version", void 0), __decorate([m({ type: String, json: { write: true } })], b5.prototype, "coverageId", void 0), __decorate([m({ readOnly: true })], b5.prototype, "rasterId", null), b5 = __decorate([a("esri.layers.support.rasterDatasets.WCSRaster")], b5);

// node_modules/@arcgis/core/layers/WCSLayer.js
var C3 = /* @__PURE__ */ new Set(["milliseconds", "seconds", "minutes", "hours", "days", "weeks", "months", "years", "decades", "centuries"]);
var T2 = class extends p(t(b(j(s3(X2(i2(l4(f2(l2(l3(b2))))))))))) {
  constructor(...e4) {
    super(...e4), this.coverageId = null, this.version = null, this.isReference = null, this.graphicOrigin = new s4(this), this.legendEnabled = true, this.noData = 0, this.operationalLayerType = "WCS", this.type = "wcs", this.popupEnabled = true, this.popupTemplate = null, this.fields = null, this._debouncedSaveOperations = L(async (e5, r3, t4) => {
      const { save: o4, saveAs: s5 } = await import("./imageryUtils-K5KFGZOF.js");
      switch (e5) {
        case 0:
          return o4(this, r3);
        case 1:
          return s5(this, t4, r3);
      }
    });
  }
  normalizeCtorArgs(e4, r3) {
    return "string" == typeof e4 ? { url: e4, ...r3 } : e4;
  }
  load(e4) {
    const r3 = null != e4 ? e4.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["WCS"] }, e4).catch(f).then(() => this._openRaster(r3))), Promise.resolve(this);
  }
  get renderer() {
    return super.renderer;
  }
  set renderer(e4) {
    super.renderer = e4;
  }
  get coverageInfo() {
    return this.raster.coverageInfo;
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  get rasterFields() {
    const e4 = [o2("Pixel Value")], r3 = this.raster?.rasterInfo ?? this.serviceRasterInfo, t4 = r3?.multidimensionalInfo;
    if (t4) {
      const r4 = p2(t4);
      e4.push(...r4);
    }
    return e4;
  }
  createPopupTemplate(e4) {
    return d2({ fields: this.rasterFields, title: this.title }, e4);
  }
  async save(e4) {
    return this._debouncedSaveOperations(0, e4);
  }
  async saveAs(e4, r3) {
    return this._debouncedSaveOperations(1, r3, e4);
  }
  async _openRaster(e4) {
    const r3 = new b5({ url: this.url, version: this.version, coverageId: this.coverageId, ioConfig: { sampling: "closest", ...this.ioConfig, customFetchParameters: this.customParameters } });
    if (await r3.open({ signal: e4 }), !r3.rasterInfo) throw r3.destroy(), new s("wcs-layer:load", "cannot load resources on " + this.url);
    const { rasterInfo: t4 } = r3;
    null == t4.noDataValue && (t4.noDataValue = this.noData), this._set("serviceRasterInfo", t4), this._set("spatialReference", t4.spatialReference), null == this.title && this.setAtOrigin("title", r3.datasetName, "service"), null == this.coverageId && this.setAtOrigin("coverageId", r3.coverageInfo.id, "service"), null == this.version && r3.version && this.setAtOrigin("version", r3.version, "service"), this.setAtOrigin("tileInfo", r3.rasterInfo.storageInfo.tileInfo, "service");
    const { multidimensionalInfo: s5 } = t4;
    if (null != s5) {
      const e5 = s5.variables[0].dimensions.find(({ name: e6 }) => "StdTime" === e6);
      if (e5) {
        let r4 = e5.extent?.[0] ?? e5.values[0];
        Array.isArray(r4) && (r4 = r4[0]);
        let t5 = e5.extent?.[1] ?? e5.values[e5.values.length - 1];
        Array.isArray(t5) && (t5 = t5[1]);
        const o4 = C3.has(e5.intervalUnit?.toLowerCase()) ? e5.intervalUnit?.toLowerCase() : null;
        this.set("timeInfo", { startField: "StdTime", fullTimeExtent: { start: r4, end: t5 }, timeZone: null, interval: o4 ? { value: e5.interval, unit: o4 } : null });
      }
    }
    this.raster = r3, this._configDefaultSettings(), this.addHandles(l(() => this.customParameters, (e5) => this.raster.ioConfig.customFetchParameters = e5));
  }
};
__decorate([m({ type: String, nonNullable: true, json: { name: "wcsInfo.coverageId", write: { isRequired: true, ignoreOrigin: true } } })], T2.prototype, "coverageId", void 0), __decorate([m()], T2.prototype, "coverageInfo", null), __decorate([m({ type: ["1.0.0", "1.1.0", "1.1.1", "1.1.2", "2.0.1"], nonNullable: true, json: { name: "wcsInfo.version", write: { isRequired: true, ignoreOrigin: true } } })], T2.prototype, "version", void 0), __decorate([m({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], T2.prototype, "isReference", void 0), __decorate([m({ json: { read: true, write: true } })], T2.prototype, "blendMode", void 0), __decorate([m({ readOnly: true, clonable: false })], T2.prototype, "graphicOrigin", void 0), __decorate([m(d3)], T2.prototype, "legendEnabled", void 0), __decorate([m({ type: ["show", "hide"] })], T2.prototype, "listMode", void 0), __decorate([m()], T2.prototype, "noData", void 0), __decorate([m({ type: ["WCS"] })], T2.prototype, "operationalLayerType", void 0), __decorate([m()], T2.prototype, "raster", void 0), __decorate([m({ readOnly: true })], T2.prototype, "type", void 0), __decorate([m(l5)], T2.prototype, "popupEnabled", void 0), __decorate([m({ type: q, json: { name: "popupInfo", write: true } })], T2.prototype, "popupTemplate", void 0), __decorate([m({ readOnly: true })], T2.prototype, "defaultPopupTemplate", null), __decorate([m({ readOnly: true, type: [m2] })], T2.prototype, "fields", void 0), __decorate([m({ readOnly: true, type: [m2] })], T2.prototype, "rasterFields", null), T2 = __decorate([a("esri.layers.WCSLayer")], T2);
var L4 = T2;
export {
  L4 as default
};
//# sourceMappingURL=WCSLayer-CHGPKGY6.js.map
