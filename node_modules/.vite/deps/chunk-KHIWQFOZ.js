import {
  S
} from "./chunk-2QMXQ3D5.js";
import {
  s as s3
} from "./chunk-ZUQ2O3KU.js";
import {
  i as i3
} from "./chunk-OC3OQ2CI.js";
import {
  H as H2
} from "./chunk-KY5OS6CK.js";
import {
  v
} from "./chunk-DGQSLK46.js";
import {
  d
} from "./chunk-EOQ2S5UA.js";
import {
  A,
  I
} from "./chunk-RBTPLPVM.js";
import {
  c,
  i as i4,
  o as o2,
  t as t2
} from "./chunk-Y3FKYMXQ.js";
import {
  h
} from "./chunk-S5K4XWUR.js";
import {
  t
} from "./chunk-BZLHV37L.js";
import {
  i as i2
} from "./chunk-V6V3WWJF.js";
import {
  u as u2
} from "./chunk-DUZAVZR4.js";
import {
  b
} from "./chunk-647DAMHU.js";
import {
  _
} from "./chunk-C3FRY5U4.js";
import {
  f as f3
} from "./chunk-GD4FJL3C.js";
import {
  J,
  K,
  Q
} from "./chunk-2LC2762W.js";
import {
  r
} from "./chunk-QF7FRVN6.js";
import {
  m as m2
} from "./chunk-MHV23XAQ.js";
import {
  u
} from "./chunk-XCKT47LJ.js";
import {
  z
} from "./chunk-H74Q4SYB.js";
import {
  l
} from "./chunk-2OFHDVO5.js";
import {
  f as f2
} from "./chunk-5T3MJDSR.js";
import {
  T as T2,
  ce
} from "./chunk-NMQNUPE4.js";
import {
  Dt,
  H2 as H,
  V,
  g2 as g
} from "./chunk-V2H77UEV.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  o
} from "./chunk-65HD3WXL.js";
import {
  L as L2,
  T,
  f2 as f
} from "./chunk-GNMPGHLQ.js";
import {
  e,
  i3 as i,
  s,
  s2
} from "./chunk-QY7XKUIV.js";
import {
  L,
  N,
  has
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/layers/graphics/applyEditsUtils.js
async function m3(e2, t3, r2) {
  const { geometry: s4 } = t3, i5 = { ...t3.attributes };
  if (null != r2 && "mesh" === s4?.type) {
    const { transformFieldRoles: t4 } = r2, { origin: c2, spatialReference: p, vertexSpace: m4 } = s4, f5 = s4.transform ?? new d(), g3 = "local" === m4.type, b3 = e2.spatialReference, y2 = b3.isGeographic, R2 = T2(b3, p), h3 = K(p, b3) && J(p, b3);
    if (!(g3 && y2 && h3 || !g3 && !y2 && R2)) return null;
    const I3 = Q(c2, p, b3);
    if (null == I3) return null;
    if (i5[t4.originX] = I3.x, i5[t4.originY] = I3.y, i5[t4.originZ] = I3.z ?? 0, null != f5) {
      const { translation: e3, scale: r3, rotation: s5 } = f5, o3 = g3 ? 1 : ce(p) / ce(b3);
      i5[t4.translationX] = e3[0] * o3, i5[t4.translationY] = e3[2] * o3, i5[t4.translationZ] = -e3[1] * o3, i5[t4.scaleX] = r3[0], i5[t4.scaleY] = r3[2], i5[t4.scaleZ] = r3[1], i5[t4.rotationX] = s5[0], i5[t4.rotationY] = s5[2], i5[t4.rotationZ] = -s5[1], i5[t4.rotationDeg] = s5[3];
    }
    return { attributes: i5 };
  }
  return null == s4 ? { attributes: i5 } : "mesh" === s4.type || "extent" === s4.type ? null : { geometry: s4.toJSON(), attributes: i5 };
}
async function f4(e2, t3) {
  const r2 = await Promise.all((t3.addAttachments ?? []).map((t4) => g2(e2, t4))), a2 = await Promise.all((t3.updateAttachments ?? []).map((t4) => g2(e2, t4))), s4 = t3.deleteAttachments ?? [];
  return r2.length || a2.length || s4.length ? { adds: r2, updates: a2, deletes: [...s4] } : null;
}
async function g2(e2, t3) {
  const { feature: r2, attachment: a2 } = t3, { globalId: o3, name: n, contentType: l2, data: i5, uploadId: u3 } = a2, d2 = { globalId: o3 };
  if (r2 && ("attributes" in r2 ? d2.parentGlobalId = r2.attributes?.[e2.globalIdField] : r2.globalId && (d2.parentGlobalId = r2.globalId)), u3) d2.uploadId = u3;
  else if (i5) {
    const e3 = await Dt(i5);
    e3 && (d2.contentType = e3.mediaType, d2.data = e3.data), i5 instanceof File && (d2.name = i5.name);
  }
  return n && (d2.name = n), l2 && (d2.contentType = l2), d2;
}
function b2(e2, t3, r2) {
  if (!t3 || 0 === t3.length) return [];
  if (r2 && I(t3)) return t3.map((e3) => e3.globalId);
  if (A(t3)) return t3.map((e3) => e3.objectId);
  const a2 = r2 ? e2.globalIdField : e2.objectIdField;
  return a2 ? t3.map((e3) => e3.getAttribute(a2)) : [];
}
function y(e2) {
  const t3 = e2?.assetMaps;
  if (t3) {
    for (const e3 of t3.addResults) e3.success || i.getLogger("esri.layers.graphics.sources.support.sourceUtils").error(`Failed to map asset to feature with globalId ${e3.globalId}.`);
    for (const e3 of t3.updateResults) e3.success || i.getLogger("esri.layers.graphics.sources.support.sourceUtils").error(`Failed to map asset to feature with globalId ${e3.globalId}.`);
  }
  const a2 = e2?.attachments, s4 = { addFeatureResults: e2?.addResults?.map(R) ?? [], updateFeatureResults: e2?.updateResults?.map(R) ?? [], deleteFeatureResults: e2?.deleteResults?.map(R) ?? [], addAttachmentResults: a2?.addResults ? a2.addResults.map(R) : [], updateAttachmentResults: a2?.updateResults ? a2.updateResults.map(R) : [], deleteAttachmentResults: a2?.deleteResults ? a2.deleteResults.map(R) : [] };
  return e2?.editMoment && (s4.editMoment = e2.editMoment), s4;
}
function R(e2) {
  const r2 = true === e2.success ? null : e2.error || { code: void 0, description: "Feature edit failed" };
  return { objectId: e2.objectId, globalId: e2.globalId, error: r2 ? new s2("feature-layer-source:edit-failure", r2.description, { code: r2.code }) : null };
}
function h2(t3, r2) {
  return new _({ attributes: t3.attributes, geometry: f3({ ...t3.geometry, spatialReference: r2 }) });
}
function I2(e2, t3) {
  return { adds: e2?.adds?.map((e3) => h2(e3, t3)) || [], updates: e2?.updates?.map((e3) => ({ original: h2(e3[0], t3), current: h2(e3[1], t3) })) || [], deletes: e2?.deletes?.map((e3) => h2(e3, t3)) || [], spatialReference: t3 };
}
function j(e2) {
  const t3 = e2.details.raw, r2 = +t3.code, a2 = +t3.extendedCode;
  return 500 === r2 && (-2147217144 === a2 || -2147467261 === a2);
}

// node_modules/@arcgis/core/layers/graphics/sources/FeatureLayerSource.js
var V2 = new o({ originalAndCurrentFeatures: "original-and-current-features", none: "none" });
var $ = new o({ Started: "published", Publishing: "publishing", Stopped: "unavailable" });
var G = class extends u {
  constructor(e2) {
    super(e2), this.type = "feature-layer", this.supportedSourceTypes = /* @__PURE__ */ new Set(["Feature Layer", "Oriented Imagery Layer", "Table", "Catalog Layer"]), this.refresh = L2(async () => {
      await this.load();
      const e3 = this.sourceJSON.editingInfo?.lastEditDate;
      if (null == e3) return { dataChanged: true, updates: {} };
      try {
        await this._fetchService(null);
      } catch {
        return { dataChanged: true, updates: {} };
      }
      const t3 = e3 !== this.sourceJSON.editingInfo?.lastEditDate;
      return { dataChanged: t3, updates: t3 ? { editingInfo: this.sourceJSON.editingInfo, extent: this.sourceJSON.extent } : null };
    }), this._ongoingAssetUploads = /* @__PURE__ */ new Map();
  }
  load(e2) {
    const t3 = this.layer.sourceJSON, r2 = this._fetchService(t3, { ...e2 }).then(() => this.layer.setUserPrivileges(this.sourceJSON.serviceItemId, e2)).then(() => this._ensureLatestMetadata(e2));
    return this.addResolvingPromise(r2), Promise.resolve(this);
  }
  initialize() {
    this.addHandles([l(() => {
      const e2 = this.layer;
      return e2 && "lastEditsEventDate" in e2 ? e2.lastEditsEventDate : null;
    }, (e2) => this._handleLastEditsEventChange(e2))]);
  }
  destroy() {
    this._removeEditInterceptor();
  }
  get queryTask() {
    const { capabilities: e2, parsedUrl: t3, gdbVersion: r2, spatialReference: s4, fieldsIndex: a2, uniqueIdFields: i5 } = this.layer, n = "infoFor3D" in this.layer ? this.layer.infoFor3D : null, o3 = "dynamicDataSource" in this.layer ? this.layer.dynamicDataSource : null, u3 = has("featurelayer-pbf") && e2?.query.supportsFormatPBF && null == n;
    return new S({ dynamicDataSource: o3, fieldsIndex: a2, gdbVersion: r2, infoFor3D: n, pbfSupported: u3, queryAttachmentsSupported: e2?.operations?.supportsQueryAttachments ?? false, sourceSpatialReference: s4, uniqueIdFields: i5, url: t3.path });
  }
  async addAttachment(e2, t3) {
    await this.load();
    const { layer: s4 } = this;
    await H2(s4, "editing");
    const a2 = e2.attributes[s4.objectIdField], i5 = s4.parsedUrl.path + "/" + a2 + "/addAttachment", n = this._getLayerRequestOptions(), o3 = this._getFormDataForAttachment(t3, n.query);
    try {
      const e3 = await H(i5, { body: o3 });
      return R(e3.data.addAttachmentResult);
    } catch (u3) {
      throw this._createAttachmentErrorResult(a2, u3);
    }
  }
  async updateAttachment(e2, t3, s4) {
    await this.load();
    const { layer: a2 } = this;
    await H2(a2, "editing");
    const i5 = e2.attributes[a2.objectIdField], n = a2.parsedUrl.path + "/" + i5 + "/updateAttachment", o3 = this._getLayerRequestOptions({ query: { attachmentId: t3 } }), u3 = this._getFormDataForAttachment(s4, o3.query);
    try {
      const e3 = await H(n, { body: u3 });
      return R(e3.data.updateAttachmentResult);
    } catch (l2) {
      throw this._createAttachmentErrorResult(i5, l2);
    }
  }
  async applyEdits(e2, t3) {
    await this.load();
    const { layer: a2 } = this;
    await H2(a2, "editing");
    const n = "infoFor3D" in a2 ? a2.infoFor3D : null, o3 = null != n, u3 = o3 || (t3?.globalIdUsed ?? false), l2 = o3 ? await this._uploadMeshesAndGetAssetMapEditsJSON(e2) : null, c2 = e2.addFeatures?.map((e3) => m3(this.layer, e3, n)) ?? [], d2 = (await Promise.all(c2)).filter(N), p = e2.updateFeatures?.map((e3) => m3(this.layer, e3, n)) ?? [], y2 = (await Promise.all(p)).filter(N), h3 = b2(this.layer, e2.deleteFeatures, u3);
    i3(d2, y2, a2.spatialReference);
    const m4 = await f4(this.layer, e2), f5 = a2.capabilities.editing.supportsAsyncApplyEdits && o3, g3 = t3?.gdbVersion || a2.gdbVersion, q = { gdbVersion: g3, rollbackOnFailure: t3?.rollbackOnFailureEnabled, useGlobalIds: u3, returnEditMoment: t3?.returnEditMoment, usePreviousEditMoment: t3?.usePreviousEditMoment, async: f5 };
    await i4(this.layer.url, g3, true);
    const w = c(this.layer.url, g3 || null);
    if (await o2(a2.url, g3, a2.historicMoment)) throw new s2("feature-layer-source:historic-version", "Editing a historic version is not allowed");
    t3?.returnServiceEditsOption ? (q.edits = JSON.stringify([{ id: a2.layerId, adds: d2.length ? d2 : null, updates: y2.length ? y2 : null, deletes: h3.length ? h3 : null, attachments: m4, assetMaps: l2 }]), q.returnServiceEditsOption = V2.toJSON(t3?.returnServiceEditsOption), q.returnServiceEditsInSourceSR = t3?.returnServiceEditsInSourceSR) : (q.adds = d2.length ? JSON.stringify(d2) : null, q.updates = y2.length ? JSON.stringify(y2) : null, q.deletes = h3.length ? u3 ? JSON.stringify(h3) : h3.join(",") : null, q.attachments = m4 && JSON.stringify(m4), q.assetMaps = null != l2 ? JSON.stringify(l2) : void 0);
    const S2 = this._getLayerRequestOptions({ method: "post", query: q });
    w && (S2.authMode = "immediate", S2.query.returnEditMoment = true, S2.query.sessionId = t2);
    const E = t3?.returnServiceEditsOption ? a2.url : a2.parsedUrl.path;
    let O;
    try {
      O = f5 ? await this._asyncApplyEdits(E + "/applyEdits", S2) : await H(E + "/applyEdits", S2);
    } catch (_2) {
      if (!j(_2)) throw _2;
      S2.authMode = "immediate", O = f5 ? await this._asyncApplyEdits(E + "/applyEdits", S2) : await H(E + "/applyEdits", S2);
    }
    return this._createEditsResult(O);
  }
  async deleteAttachments(e2, t3) {
    await this.load();
    const { layer: s4 } = this;
    await H2(s4, "editing");
    const a2 = e2.attributes[s4.objectIdField], i5 = s4.parsedUrl.path + "/" + a2 + "/deleteAttachments";
    try {
      return (await H(i5, this._getLayerRequestOptions({ query: { attachmentIds: t3.join(",") }, method: "post" }))).data.deleteAttachmentResults.map(R);
    } catch (n) {
      throw this._createAttachmentErrorResult(a2, n);
    }
  }
  fetchRecomputedExtents(e2 = {}) {
    const t3 = e2.signal;
    return this.load({ signal: t3 }).then(async () => {
      const t4 = this._getLayerRequestOptions({ ...e2, query: { returnUpdates: true } }), { layerId: s4, url: a2 } = this.layer, { data: i5 } = await H(`${a2}/${s4}`, t4), { id: n, extent: o3, fullExtent: u3, timeExtent: l2 } = i5, c2 = o3 || u3;
      return { id: n, fullExtent: c2 && z.fromJSON(c2), timeExtent: l2 && m2.fromJSON({ start: l2[0], end: l2[1] }) };
    });
  }
  async queryAttachments(e2, t3 = {}) {
    await this.load();
    const r2 = this._getLayerRequestOptions(t3);
    return this.queryTask.executeAttachmentQuery(e2, r2);
  }
  async queryFeatures(e2, t3) {
    await this.load();
    const r2 = await this.queryTask.execute(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
    if (e2.outStatistics?.length && r2.features.length) {
      const t4 = /* @__PURE__ */ new Map();
      if (r2.features.forEach((r3) => {
        const s4 = r3.attributes;
        e2.outStatistics?.forEach(({ outStatisticFieldName: e3 }) => {
          if (e3) {
            const r4 = e3.toLowerCase();
            r4 && r4 in s4 && e3 !== r4 && (s4[e3] = s4[r4], delete s4[r4], t4.set(r4, e3));
          }
        });
      }), null != r2.fields) for (const e3 of r2.fields) {
        const r3 = t4.get(e3.name.toLowerCase());
        null != r3 && (e3.name = r3);
      }
    }
    return r2;
  }
  async queryFeaturesJSON(e2, t3) {
    return await this.load(), this.queryTask.executeJSON(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryObjectIds(e2, t3) {
    return await this.load(), this.queryTask.executeForIds(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryFeatureCount(e2, t3) {
    return await this.load(), this.queryTask.executeForCount(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryExtent(e2, t3) {
    return await this.load(), this.queryTask.executeForExtent(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryRelatedFeatures(e2, t3) {
    return await this.load(), this.queryTask.executeRelationshipQuery(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryRelatedFeaturesCount(e2, t3) {
    return await this.load(), this.queryTask.executeRelationshipQueryForCount(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryPivot(e2, t3) {
    return await this.load(), this.queryTask.executePivotQuery(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryTopFeatures(e2, t3) {
    return await this.load(), this.queryTask.executeTopFeaturesQuery(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryAttributeBins(e2, t3) {
    return await this.load(), this.queryTask.executeAttributeBinsQuery(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryTopObjectIds(e2, t3) {
    return await this.load(), this.queryTask.executeForTopIds(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryTopExtents(e2, t3) {
    return await this.load(), this.queryTask.executeForTopExtents(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async queryTopCount(e2, t3) {
    return await this.load(), this.queryTask.executeForTopCount(e2, { ...t3, query: this._createRequestQueryOptions(t3) });
  }
  async fetchPublishingStatus() {
    if (!g(this.layer.url)) return "unavailable";
    const e2 = V(this.layer.url, "status"), t3 = await H(e2, { query: { f: "json" } });
    return $.fromJSON(t3.data.status);
  }
  async uploadAssets(e2, t3) {
    const { uploadAssets: r2 } = await import("./uploadAssets-EZQDKJG7.js");
    return r2(e2, { layer: this.layer, ongoingUploads: this._ongoingAssetUploads }, t3);
  }
  _handleLastEditsEventChange(e2) {
    const t3 = this.layer;
    if (null == e2 || !("capabilities" in t3) || !("effectiveCapabilities" in t3)) return;
    if (!(!t3.capabilities?.operations?.supportsEditing && t3.effectiveCapabilities?.operations?.supportsEditing)) return;
    const r2 = t3.url;
    if (null == r2) return;
    "layerId" in t3 && V(r2, t3.layerId.toString());
    this._getOrCreateEditInterceptor(r2).before = (t4) => {
      const r3 = t4.requestOptions.method ?? "auto";
      if ("auto" === r3 || "head" === r3) {
        const r4 = t4.requestOptions.query ?? {};
        r4._ts = e2.getTime(), t4.requestOptions.query = r4;
      }
    };
  }
  _getOrCreateEditInterceptor(e2) {
    return null == this._editInterceptor && (this._editInterceptor = { urls: e2 }, s.request.internalInterceptors.push(this._editInterceptor)), this._editInterceptor;
  }
  _removeEditInterceptor() {
    null != this._editInterceptor && (L(s.request.internalInterceptors, this._editInterceptor), this._editInterceptor = null);
  }
  async _asyncApplyEdits(e2, t3) {
    const s4 = (await H(e2, t3)).data.statusUrl;
    for (; ; ) {
      const e3 = (await H(s4, { query: { f: "json" }, responseType: "json" })).data;
      switch (e3.status) {
        case "Completed":
          return H(e3.resultUrl, { query: { f: "json" }, responseType: "json" });
        case "CompletedWithErrors":
          throw new s2("async-applyEdits-failed", "asynchronous applyEdits call failed.");
        case "Failed ImportChanges":
        case "InProgress":
        case "Pending":
        case "ExportAttachments":
        case "ExportChanges":
        case "ExportingData":
        case "ExportingSnapshot":
        case "ImportAttachments":
        case "ProvisioningReplica":
        case "UnRegisteringReplica":
          break;
        default:
          throw new s2("async-applyEdits-failed", "asynchronous applyEdits call failed (undefined response status)");
      }
      await T(H3);
    }
  }
  _createRequestQueryOptions(e2) {
    const t3 = { ...this.layer.customParameters, token: this.layer.apiKey, ...e2?.query };
    return this.layer.datesInUnknownTimezone && (t3.timeReferenceUnknownClient = true), t3;
  }
  async _fetchService(e2, t3) {
    if (!e2) {
      const s5 = {};
      has("featurelayer-advanced-symbols") && (s5.returnAdvancedSymbols = true), t3?.cacheBust && (s5._ts = Date.now());
      const { data: a2 } = await H(this.layer.parsedUrl.path, this._getLayerRequestOptions({ query: s5, signal: t3?.signal }));
      e2 = a2;
    }
    this.layer.applyPreferredHost(e2), this.sourceJSON = await this._patchServiceJSON(e2, t3?.signal);
    const s4 = e2.type;
    if (!this.supportedSourceTypes.has(s4)) throw new s2("feature-layer-source:unsupported-type", `Source type "${s4}" is not supported`);
  }
  async _patchServiceJSON(e2, t3) {
    if ("Table" !== e2.type && e2.geometryType && !e2?.drawingInfo?.renderer && !e2.defaultSymbol) {
      const t4 = u2(e2.geometryType).renderer;
      e("drawingInfo.renderer", t4, e2);
    }
    if ("esriGeometryMultiPatch" === e2.geometryType && e2.infoFor3D && (e2.geometryType = "mesh"), null == e2.extent) try {
      const { data: s4 } = await H(this.layer.url, this._getLayerRequestOptions({ signal: t3 }));
      s4.spatialReference && (e2.extent = { xmin: 0, ymin: 0, xmax: 0, ymax: 0, spatialReference: s4.spatialReference });
    } catch (s4) {
      f(s4);
    }
    return e2;
  }
  async _ensureLatestMetadata(e2) {
    if (this.layer.userHasUpdateItemPrivileges && this.sourceJSON.cacheMaxAge > 0) return this._fetchService(null, { ...e2, cacheBust: true });
  }
  async _uploadMeshesAndGetAssetMapEditsJSON(e2) {
    const { addAssetFeatures: t3 } = e2;
    if (!t3?.length) return null;
    if (await this._areAllAssetsAlreadyMapped(t3)) return null;
    const r2 = e2.addFeatures.filter((e3) => e3.geometry);
    if (t3.length !== r2.length + e2.updateFeatures.length) throw new s2("feature-layer-source:unsupported-mesh-edits", "Mixing attribute only edits with mesh geometry edits is not currently supported");
    const s4 = new Array(), a2 = /* @__PURE__ */ new Map();
    for (const i5 of t3) {
      const { geometry: e3 } = i5, { vertexSpace: t4 } = e3;
      if (t(t4)) s4.push(e3);
      else {
        const t5 = e3.origin, { convertMeshVertexSpace: r3 } = await import("./convertMeshVertexSpace-PO4S3XFW.js"), n = await r3(e3, new i2({ origin: [t5.x, t5.y, t5.z ?? 0] }));
        a2.set(n, e3), i5.geometry = n, s4.push(n);
      }
    }
    await this.uploadAssets(s4);
    for (const [i5, n] of a2) n.addExternalSources(i5.metadata.externalSources.items);
    return { adds: this._getAssetMapEditsJSON(t3), updates: [], deletes: [] };
  }
  _getAssetMapEditsJSON(e2) {
    const t3 = new Array(), r2 = this.layer.globalIdField, s4 = this.layer.parsedUrl;
    for (const a2 of e2) {
      const e3 = a2.geometry, { metadata: i5 } = e3, n = i5.getExternalSourcesOnService(s4), o3 = a2.getAttribute(r2);
      if (0 === n.length) {
        i.getLogger(this).error(`Skipping feature ${o3}. The mesh it is associated with has not been uploaded to the service and cannot be mapped to it.`);
        continue;
      }
      const { source: l2 } = n.find(v) ?? n[0];
      for (const r3 of l2.assets) 1 === r3.parts.length ? t3.push({ globalId: r(), parentGlobalId: o3, assetName: r3.assetName, assetHash: r3.parts[0].partHash, flags: [] }) : i.getLogger(this).error(`Skipping asset ${r3.assetName}. It does not have exactly one part, so we cannot map it to a feature.`);
    }
    return t3;
  }
  _createEditsResult(e2) {
    const t3 = e2.data, { layerId: r2 } = this.layer, s4 = [];
    let a2 = null;
    if (Array.isArray(t3)) for (const n of t3) s4.push({ id: n.id, editedFeatures: n.editedFeatures }), n.id === r2 && (a2 = { addResults: n.addResults ?? [], updateResults: n.updateResults ?? [], deleteResults: n.deleteResults ?? [], attachments: n.attachments, editMoment: n.editMoment });
    else a2 = t3;
    const i5 = y(a2);
    if (s4.length > 0) {
      i5.editedFeatureResults = [];
      for (const e3 of s4) {
        const { editedFeatures: t4 } = e3, r3 = t4?.spatialReference ? new f2(t4.spatialReference) : null;
        i5.editedFeatureResults.push({ layerId: e3.id, editedFeatures: I2(t4, r3) });
      }
    }
    return i5;
  }
  _createAttachmentErrorResult(e2, t3) {
    const r2 = t3.details.messages?.[0] || t3.message, s4 = t3.details.httpStatus || t3.details.messageCode;
    return { objectId: e2, globalId: null, error: new s2("feature-layer-source:attachment-failure", r2, { code: s4 }) };
  }
  _getFormDataForAttachment(e2, t3) {
    const r2 = e2 instanceof FormData ? e2 : e2 && e2.elements ? new FormData(e2) : null;
    if (r2) for (const s4 in t3) {
      const e3 = t3[s4];
      null != e3 && (r2.set ? r2.set(s4, e3) : r2.append(s4, e3));
    }
    return r2;
  }
  _getLayerRequestOptions(e2 = {}) {
    const { layer: t3, layer: { parsedUrl: r2, gdbVersion: s4 } } = this;
    return { ...e2, query: { gdbVersion: s4, layer: "dynamicDataSource" in t3 && t3.dynamicDataSource ? JSON.stringify({ source: t3.dynamicDataSource }) : void 0, ...r2.query, f: "json", ...this._createRequestQueryOptions(e2) }, responseType: "json" };
  }
  async _areAllAssetsAlreadyMapped(e2) {
    const { layer: t3 } = this, { globalIdField: r2, parsedUrl: a2 } = t3, i5 = "infoFor3D" in t3 ? t3.infoFor3D : null;
    if (null == i5 || null == r2) return false;
    const n = h(i5);
    if (null == n) return false;
    const o3 = V(a2.path, `../${n.id}`), u3 = new Array();
    for (const s4 of e2) {
      if (!(s4.geometry.metadata.getExternalSourcesOnService(a2).length > 0)) return false;
      u3.push(s4);
    }
    const l2 = u3.map((e3) => e3.getAttribute(r2)).filter(N);
    if (0 === l2.length) return false;
    const { assetMapFieldRoles: { parentGlobalId: c2, assetHash: d2 } } = i5, p = new b({ where: `${c2} IN (${l2.map((e3) => `'${e3}'`)})`, outFields: [d2, c2], returnGeometry: false }), y2 = await s3(o3, p), { features: m4 } = y2;
    return 0 !== m4.length && !u3.some((e3) => {
      const t4 = e3.getAttribute(r2);
      if (!t4) return true;
      const { metadata: s4 } = e3.geometry, i6 = m4.filter((e4) => e4.getAttribute(c2) === t4);
      if (0 === i6.length) return true;
      const n2 = i6.map((e4) => e4.getAttribute(d2));
      return s4.getExternalSourcesOnService(a2).flatMap(({ source: e4 }) => e4.assets.flatMap((e5) => e5.parts.map((e6) => e6.partHash))).some((e4) => n2.every((t5) => e4 !== t5));
    });
  }
};
__decorate([m()], G.prototype, "type", void 0), __decorate([m({ constructOnly: true })], G.prototype, "layer", void 0), __decorate([m({ constructOnly: true })], G.prototype, "supportedSourceTypes", void 0), __decorate([m({ readOnly: true })], G.prototype, "queryTask", null), G = __decorate([a("esri.layers.graphics.sources.FeatureLayerSource")], G);
var H3 = 1e3;

export {
  G
};
//# sourceMappingURL=chunk-KHIWQFOZ.js.map
