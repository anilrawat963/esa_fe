import {
  p as p2
} from "./chunk-F7RQDGE7.js";
import {
  i as i5
} from "./chunk-GG4AQJJO.js";
import {
  t as t3
} from "./chunk-OGWYK5MD.js";
import {
  a as a2,
  l as l5
} from "./chunk-U5TTP5E5.js";
import {
  C
} from "./chunk-QENBEP2X.js";
import {
  t as t4
} from "./chunk-VZQ643XD.js";
import {
  h,
  i as i3,
  r
} from "./chunk-SMJWJAIA.js";
import {
  A,
  B,
  F,
  G,
  I as I2,
  L,
  N as N2,
  P as P2,
  T,
  U,
  V,
  ee,
  g as g2,
  p,
  v,
  w
} from "./chunk-YE4E5JCT.js";
import {
  o as o2
} from "./chunk-SXZO7ULH.js";
import {
  u as u3
} from "./chunk-VNSHGTPN.js";
import {
  e as e5,
  n as n2
} from "./chunk-B5A4L35M.js";
import {
  M,
  e as e4,
  i as i4,
  s as s5
} from "./chunk-52SEOH5H.js";
import {
  n as n3
} from "./chunk-UYMV6HXW.js";
import {
  It,
  Jt,
  W,
  X,
  ft,
  l as l4,
  q
} from "./chunk-JE2NJSBU.js";
import {
  l as l3,
  m,
  s as s3,
  u as u2,
  y as y2
} from "./chunk-GD4FJL3C.js";
import {
  l as l6
} from "./chunk-LTULADK2.js";
import {
  s as s4
} from "./chunk-35ST7YRB.js";
import {
  I,
  N,
  P,
  f4 as f3,
  l3 as l2,
  n3 as n,
  t2,
  x2 as x
} from "./chunk-PZ5RULLK.js";
import {
  c
} from "./chunk-OPJX4KXH.js";
import {
  K,
  e as e2,
  f as f2,
  g,
  i as i2,
  j,
  l,
  y
} from "./chunk-FPMLKIDB.js";
import {
  S,
  o
} from "./chunk-AZXJIEZ6.js";
import {
  e as e3,
  u
} from "./chunk-CSMCPN64.js";
import {
  s as s2
} from "./chunk-SMWUT52Z.js";
import {
  f
} from "./chunk-5T3MJDSR.js";
import {
  e
} from "./chunk-ZIE53VIV.js";
import {
  a,
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  has,
  t
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/symbols/cim/effects/EffectAddControlPoints.js
var _e = class _e {
  static local() {
    return null === _e.instance && (_e.instance = new _e()), _e.instance;
  }
  execute(e17, s17) {
    return new t5(e17, s17);
  }
};
_e.instance = null;
var e6 = _e;
var t5 = class {
  constructor(e17, t16) {
    this._inputGeometries = e17, this._angleTolerance = void 0 !== t16.angleTolerance ? t16.angleTolerance : 120, this._maxCosAngle = Math.cos((1 - Math.abs(this._angleTolerance) / 180) * Math.PI);
  }
  next() {
    let e17 = this._inputGeometries.next();
    if (!e17) return null;
    for (; e17; ) {
      if ("esriGeometryPolygon" === e17.geometryType) this._isClosed = true;
      else if ("esriGeometryPolyline" === e17.geometryType) this._isClosed = false;
      else {
        if ("esriGeometryEnvelope" !== e17.geometryType) {
          e17 = this._inputGeometries.next();
          continue;
        }
        if (this._maxCosAngle) return e17;
        this._isClosed = true;
      }
      for (; e17.nextPath(); ) this._processPath(e17);
      return e17.reset(), e17;
    }
    return null;
  }
  _processPath(e17) {
    if (e17.nextPoint()) {
      const t16 = e17.x, s17 = e17.y;
      let n23 = t16, i18 = s17, o9 = e17.pathSize, l12 = 0, r13 = 0, a11 = 0, h8 = 0, c5 = 0, _4 = 0;
      this._isClosed && ++o9;
      for (let u9 = 1; e17.nextPoint() || u9 < o9; ++u9) {
        let x3, m5;
        this._isClosed && u9 === o9 - 1 ? (x3 = t16, m5 = s17) : (x3 = e17.x, m5 = e17.y);
        const y6 = x3 - n23, g5 = m5 - i18, C2 = Math.sqrt(y6 * y6 + g5 * g5);
        if (u9 > 1 && C2 > 0 && a11 > 0) {
          (l12 * y6 + r13 * g5) / C2 / a11 <= this._maxCosAngle && e17.setControlPointAt(u9 - 1);
        }
        1 === u9 && (h8 = y6, c5 = g5, _4 = C2), C2 > 0 && (n23 = x3, i18 = m5, l12 = y6, r13 = g5, a11 = C2);
      }
      if (this._isClosed && a11 > 0 && _4 > 0) {
        (l12 * h8 + r13 * c5) / _4 / a11 <= this._maxCosAngle && e17.setControlPointAt(0);
      }
    }
  }
};

// node_modules/@arcgis/core/symbols/cim/CIMPlacements.js
var t6 = class {
  constructor() {
    this.setIdentity();
  }
  getAngle() {
    return (null == this.rz || 0 === this.rz && 1 !== this.rzCos && 0 !== this.rzSin) && (this.rz = Math.atan2(this.rzSin, this.rzCos)), this.rz;
  }
  setIdentity() {
    this.tx = 0, this.ty = 0, this.tz = 0, this.s = 1, this.rx = 0, this.ry = 0, this.rz = 0, this.rzCos = 1, this.rzSin = 0;
  }
  setTranslate(t16, s17) {
    this.tx = t16, this.ty = s17;
  }
  setTranslateZ(t16) {
    this.tz = t16;
  }
  setRotateCS(t16, s17) {
    this.rz = void 0, this.rzCos = t16, this.rzSin = s17;
  }
  setRotate(t16) {
    this.rz = t16, this.rzCos = void 0, this.rzSin = void 0;
  }
  setRotateY(t16) {
    this.ry = t16;
  }
  setScale(t16) {
    this.s = t16;
  }
  setMeasure(t16) {
    this.m = t16;
  }
};

// node_modules/@arcgis/core/symbols/cim/CIMCursor.js
function e7(t16, e17) {
  t16[4] = e17;
}
var i6 = class {
  constructor(e17, i18 = true, r13 = true, s17 = 0) {
    this.isClosed = false, this.geometryCursor = null, this.geometryCursor = !i18 && "esriGeometryPolygon" === e17.geometryType || !r13 && "esriGeometryPolyline" === e17.geometryType ? null : e17, this.geomUnitsPerPoint = s17, this.iterateMultiPath = false, this.iteratePath = false, this.internalPlacement = new t6();
  }
  next() {
    if (!this.geometryCursor) return null;
    const t16 = this.processMultiPath(this.geometryCursor);
    return this.iterateMultiPath && t16 || (this.geometryCursor = null), t16;
  }
  processMultiPath(t16) {
    for (; this.iteratePath || t16.pathIndex < t16.totalSize - 1; ) {
      this.iteratePath || t16.nextPath(), this.iterateMultiPath = true;
      const e17 = this.processPath(t16);
      if (e17) return e17;
    }
    return this.iterateMultiPath = false, null;
  }
};
var r2 = class {
  constructor(t16, e17, i18, r13 = 0) {
    this.isClosed = false, this.inputGeometries = t16, this.acceptPolygon = e17, this.acceptPolyline = i18, this.geomUnitsPerPoint = r13, this.iteratePath = false, this.multiPathCursor = null;
  }
  next() {
    for (; ; ) {
      if (!this.multiPathCursor) {
        let t16 = this.inputGeometries.next();
        for (; t16 && (this.isClosed = this.acceptPolygon && "esriGeometryPolygon" === t16.geometryType || "esriGeometryEnvelope" === t16.geometryType, this.multiPathCursor = t16, !this.multiPathCursor); ) t16 = this.inputGeometries.next();
        if (!this.multiPathCursor) return null;
      }
      for (; this.iteratePath || this.multiPathCursor.nextPath(); ) {
        this.multiPathCursor.seekPathStart();
        const t16 = this.processPath(this.multiPathCursor);
        if (t16) return t16;
      }
      this.multiPathCursor = null;
    }
  }
};

// node_modules/@arcgis/core/symbols/cim/CurveHelper.js
var e8 = 0.03;
var n4 = class {
  constructor(t16 = 0, e17 = false) {
  }
  isEmpty(t16) {
    if (!t16.nextPoint()) return true;
    let e17, n23, s17, r13;
    for (e17 = t16.x, n23 = t16.y; t16.nextPoint(); e17 = n23, n23 = r13) if (s17 = t16.x, r13 = t16.y, s17 !== e17 || r13 !== n23) return t16.seekPathStart(), false;
    return t16.seekPathStart(), true;
  }
  normalize(t16) {
    const e17 = Math.sqrt(t16[0] * t16[0] + t16[1] * t16[1]);
    0 !== e17 && (t16[0] /= e17, t16[1] /= e17);
  }
  getLength(t16, e17, n23, s17) {
    const r13 = n23 - t16, o9 = s17 - e17;
    return Math.sqrt(r13 * r13 + o9 * o9);
  }
  getSegLength(t16) {
    const [[e17, n23], [s17, r13]] = t16;
    return this.getLength(e17, n23, s17, r13);
  }
  getCoord2D(t16, e17, n23, s17, r13) {
    return [t16 + (n23 - t16) * r13, e17 + (s17 - e17) * r13];
  }
  getSegCoord2D(t16, e17) {
    const [[n23, s17], [r13, o9]] = t16;
    return this.getCoord2D(n23, s17, r13, o9, e17);
  }
  getAngle(t16, e17, n23, s17, r13) {
    const o9 = n23 - t16, i18 = s17 - e17;
    return Math.atan2(i18, o9);
  }
  getAngleCS(t16, e17, n23, s17, r13, o9) {
    null == t16 && (t16 = [0, 0]);
    const i18 = s17 - e17, h8 = r13 - n23, u9 = Math.sqrt(i18 * i18 + h8 * h8);
    return 0 !== u9 ? (t16[0] = i18 / u9, t16[1] = h8 / u9, t16) : (t16[0] = 1, t16[1] = 0, t16);
  }
  getSegAngleCS(t16, e17, n23) {
    const [[s17, r13], [o9, i18]] = e17;
    return this.getAngleCS(t16, s17, r13, o9, i18, n23);
  }
  cut(t16, e17, n23, s17, r13, o9) {
    return [r13 <= 0 ? [t16, e17] : this.getCoord2D(t16, e17, n23, s17, r13), o9 >= 1 ? [n23, s17] : this.getCoord2D(t16, e17, n23, s17, o9)];
  }
  getSubCurve(e17, n23, s17) {
    const r13 = a2.createEmptyOptimizedCIM("esriGeometryPolyline");
    return this.appendSubCurve(r13, e17, n23, s17) ? r13 : null;
  }
  appendSubCurve(t16, e17, n23, s17) {
    t16.startPath(), e17.seekPathStart();
    let r13 = 0, o9 = true;
    if (!e17.nextPoint()) return false;
    let i18 = e17.x, h8 = e17.y;
    for (; e17.nextPoint(); ) {
      const u9 = this.getLength(i18, h8, e17.x, e17.y);
      if (0 !== u9) {
        if (o9) {
          if (r13 + u9 > n23) {
            const l12 = (n23 - r13) / u9;
            let c5 = 1, a11 = false;
            r13 + u9 >= s17 && (c5 = (s17 - r13) / u9, a11 = true);
            const f6 = this.cut(i18, h8, e17.x, e17.y, l12, c5);
            if (f6 && t16.pushPoints(f6), a11) break;
            o9 = false;
          }
        } else {
          if (r13 + u9 > s17) {
            const n24 = this.cut(i18, h8, e17.x, e17.y, 0, (s17 - r13) / u9);
            n24 && t16.pushPoint(n24[1]);
            break;
          }
          t16.pushXY(e17.x, e17.y);
        }
        r13 += u9, i18 = e17.x, h8 = e17.y;
      } else i18 = e17.x, h8 = e17.y;
    }
    return true;
  }
  getCIMPointAlong(t16, e17) {
    if (!t16.nextPoint()) return null;
    let n23, s17, r13, o9, i18 = 0;
    for (n23 = t16.x, s17 = t16.y; t16.nextPoint(); n23 = r13, s17 = o9) {
      r13 = t16.x, o9 = t16.y;
      const h8 = this.getLength(n23, s17, r13, o9);
      if (0 !== h8) {
        if (i18 + h8 > e17) {
          const t17 = (e17 - i18) / h8;
          return this.getCoord2D(n23, s17, r13, o9, t17);
        }
        i18 += h8;
      }
    }
    return null;
  }
  offset(t16, e17, n23, s17, r13) {
    if (!t16 || t16.length < 2) return null;
    let o9 = 0, i18 = t16[o9++], h8 = o9;
    for (; o9 < t16.length; ) {
      const e18 = t16[o9];
      e18[0] === i18[0] && e18[1] === i18[1] || (o9 !== h8 && (t16[h8] = t16[o9]), i18 = t16[h8++]), o9++;
    }
    const u9 = t16[0][0] === t16[h8 - 1][0] && t16[0][1] === t16[h8 - 1][1];
    if (u9 && --h8, h8 < (u9 ? 3 : 2)) return null;
    const l12 = [];
    i18 = u9 ? t16[h8 - 1] : null;
    let c5 = t16[0];
    for (let a11 = 0; a11 < h8; a11++) {
      const r14 = a11 === h8 - 1 ? u9 ? t16[0] : null : t16[a11 + 1];
      if (i18) if (r14) {
        const t17 = [r14[0] - c5[0], r14[1] - c5[1]];
        this.normalize(t17);
        const o10 = [c5[0] - i18[0], c5[1] - i18[1]];
        this.normalize(o10);
        const h9 = o10[0] * t17[1] - o10[1] * t17[0], u10 = o10[0] * t17[0] + o10[1] * t17[1];
        if (0 === h9 && 1 === u10) {
          c5 = r14;
          continue;
        }
        if (h9 >= 0 == e17 <= 0) {
          if (u10 < 1) {
            const n24 = [t17[0] - o10[0], t17[1] - o10[1]];
            this.normalize(n24);
            const r15 = Math.sqrt((1 + u10) / 2);
            if (r15 > 1 / s17) {
              const t18 = -Math.abs(e17) / r15;
              l12.push([c5[0] - n24[0] * t18, c5[1] - n24[1] * t18]);
            }
          }
        } else switch (n23) {
          case "Mitered": {
            const n24 = Math.sqrt((1 + u10) / 2);
            if (n24 > 0 && 1 / n24 < s17) {
              const s18 = [t17[0] - o10[0], t17[1] - o10[1]];
              this.normalize(s18);
              const r15 = Math.abs(e17) / n24;
              l12.push([c5[0] - s18[0] * r15, c5[1] - s18[1] * r15]);
              break;
            }
          }
          case "Bevelled":
            l12.push([c5[0] + o10[1] * e17, c5[1] - o10[0] * e17]), l12.push([c5[0] + t17[1] * e17, c5[1] - t17[0] * e17]);
            break;
          case "Rounded":
            if (u10 < 1) {
              l12.push([c5[0] + o10[1] * e17, c5[1] - o10[0] * e17]);
              const n24 = Math.floor(2.5 * (1 - u10));
              if (n24 > 0) {
                const s18 = 1 / n24;
                let r15 = s18;
                for (let i19 = 1; i19 < n24; i19++, r15 += s18) {
                  const n25 = [o10[1] * (1 - r15) + t17[1] * r15, -o10[0] * (1 - r15) - t17[0] * r15];
                  this.normalize(n25), l12.push([c5[0] + n25[0] * e17, c5[1] + n25[1] * e17]);
                }
              }
              l12.push([c5[0] + t17[1] * e17, c5[1] - t17[0] * e17]);
            }
            break;
          default:
            if (h9 < 0) l12.push([c5[0] + (o10[1] + o10[0]) * e17, c5[1] + (o10[1] - o10[0]) * e17]), l12.push([c5[0] + (t17[1] - t17[0]) * e17, c5[1] - (t17[0] + t17[1]) * e17]);
            else {
              const n24 = Math.sqrt((1 + Math.abs(u10)) / 2), s18 = [t17[0] - o10[0], t17[1] - o10[1]];
              this.normalize(s18);
              const r15 = e17 / n24;
              l12.push([c5[0] - s18[0] * r15, c5[1] - s18[1] * r15]);
            }
        }
      } else {
        const t17 = [c5[0] - i18[0], c5[1] - i18[1]];
        this.normalize(t17), l12.push([c5[0] + t17[1] * e17, c5[1] - t17[0] * e17]);
      }
      else {
        const t17 = [r14[0] - c5[0], r14[1] - c5[1]];
        this.normalize(t17), l12.push([c5[0] + t17[1] * e17, c5[1] - t17[0] * e17]);
      }
      i18 = c5, c5 = r14;
    }
    return l12.length < (u9 ? 3 : 2) ? null : (u9 && l12.push([l12[0][0], l12[0][1]]), l12);
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectArrow.js
var s6 = 1.7320508075688772;
var i7 = 5;
var c2 = "OpenEnded";
var _u = class _u {
  static local() {
    return null === _u.instance && (_u.instance = new _u()), _u.instance;
  }
  execute(t16, e17, r13) {
    return new h2(t16, e17, r13);
  }
};
_u.instance = null;
var u4 = _u;
var h2 = class extends r2 {
  constructor(t16, e17, r13) {
    super(t16, false, true), this._curveHelper = new n4(), this._width = (void 0 !== e17.width ? e17.width : i7) * r13, this._arrowType = void 0 !== e17.geometricEffectArrowType ? e17.geometricEffectArrowType : void 0 !== e17.arrowType ? e17.arrowType : c2, this._offsetFlattenError = e8 * r13;
  }
  processPath(e17) {
    const r13 = a2.createEmptyOptimizedCIM(e17.geometryType);
    switch (this._arrowType) {
      case "OpenEnded":
      default:
        this._constructSimpleArrow(r13, e17, true);
        break;
      case "Block":
        this._constructSimpleArrow(r13, e17, false);
        break;
      case "Crossed":
        this._constructCrossedArrow(r13, e17);
    }
    return r13;
  }
  _constructSimpleArrow(t16, r13, n23) {
    const o9 = r13.pathLength();
    let s17 = this._width;
    o9 < 2 * s17 && (s17 = o9 / 2);
    const i18 = this._curveHelper.getSubCurve(r13, 0, o9 - s17);
    if (!i18 || !i18.nextPath()) return;
    i18.seekPathStart();
    const c5 = s17 / 2;
    if (this._curveHelper.isEmpty(i18)) return;
    const u9 = n(i18), h8 = this._constructOffset(u9, -c5);
    if (!h8) return;
    const P3 = this._constructOffset(u9, c5);
    if (!P3) return;
    const l12 = this._constructArrowBasePoint(h8, -c5 / 2);
    if (!l12) return;
    const p6 = this._constructArrowBasePoint(P3, c5 / 2);
    if (!p6) return;
    r13.seekInPath(r13.pathSize - 1);
    const a11 = [r13.x, r13.y];
    t16.pushPath(P3), t16.nextPath(), t16.nextPoint(), t16.setControlPoint(), t16.pushPoint(p6), t16.nextPoint(), t16.setControlPoint(), t16.pushPoint(a11), t16.nextPoint(), t16.setControlPoint(), t16.pushPoint(l12), t16.nextPoint(), t16.setControlPoint(), t16.pushPoints(h8.reverse()), t16.setControlPoint(), n23 || (t16.setControlPointAt(0), t16.setControlPointAt(t16.pathSize - 1), t16.pushPoint(P3[0])), t16.reset();
  }
  _constructCrossedArrow(t16, r13) {
    const n23 = r13.pathLength();
    let o9 = this._width;
    n23 < o9 * (1 + s6 + 1) && (o9 = n23 / (1 + s6 + 1)), r13.seekPathStart();
    const i18 = this._curveHelper.getSubCurve(r13, 0, n23 - o9 * (1 + s6));
    if (!i18) return;
    i18.nextPath();
    const c5 = o9 / 2;
    if (this._curveHelper.isEmpty(i18)) return;
    const u9 = n(i18), h8 = this._constructOffset(u9, c5);
    if (!h8) return;
    const P3 = this._constructOffset(u9, -c5);
    if (!P3) return;
    const l12 = this._curveHelper.getSubCurve(r13, 0, n23 - o9);
    if (!l12) return;
    if (l12.nextPath(), this._curveHelper.isEmpty(l12)) return;
    const p6 = n(l12), a11 = this._constructOffset(p6, c5);
    if (!a11) return;
    const f6 = this._constructOffset(p6, -c5);
    if (!f6) return;
    const _4 = a11[a11.length - 1], C2 = this._constructArrowBasePoint(a11, c5 / 2);
    if (!C2) return;
    const w3 = f6[f6.length - 1], m5 = this._constructArrowBasePoint(f6, -c5 / 2);
    if (!m5) return;
    r13.seekInPath(r13.pathSize - 1);
    const x3 = [r13.x, r13.y];
    t16.pushPath(h8), t16.nextPath(), t16.nextPoint(), t16.setControlPoint(), t16.pushPoint(w3), t16.nextPoint(), t16.setControlPoint(), t16.pushPoint(m5), t16.nextPoint(), t16.setControlPoint(), t16.pushPoint(x3), t16.nextPoint(), t16.setControlPoint(), t16.pushPoint(C2), t16.nextPoint(), t16.setControlPoint(), t16.pushPoint(_4), t16.nextPoint(), t16.setControlPoint(), t16.pushPoints(P3.reverse()), t16.nextPoint(), t16.setControlPoint(), t16.reset();
  }
  _constructOffset(t16, e17) {
    return this._curveHelper.offset(t16, e17, "Rounded", 4, this._offsetFlattenError);
  }
  _constructArrowBasePoint(t16, e17) {
    if (!t16 || t16.length < 2) return null;
    const r13 = t16[t16.length - 2], n23 = t16[t16.length - 1], o9 = [n23[0] - r13[0], n23[1] - r13[1]];
    return this._curveHelper.normalize(o9), [n23[0] + o9[1] * e17, n23[1] - o9[0] * e17];
  }
};

// node_modules/@arcgis/core/symbols/cim/CIMEffects.js
var o3 = P2(() => import("./bufferOperator-UFF5ALBC.js"));
var s7 = P2(() => import("./convexHullOperator-HB42RM4J.js"));
var m2 = P2(() => import("./lengthOperator-LWICUXSQ.js"));
var i8 = P2(() => import("./generalizeOperator-QXJ3DWBQ.js"));
var n5 = P2(() => import("./graphicBufferOperator-5H2BYB5B.js"));
var p3 = P2(() => import("./offsetOperator-I55SY5U4.js"));
var f4 = P2(() => import("./simplifyOperator-WZNYGTQH.js"));
var c3 = 512;
var a3;
function l7(e17) {
  switch (e17.type) {
    case "CIMGeometricEffectDonut":
    case "CIMGeometricEffectBuffer":
      return o3.getImportPromise();
    case "CIMGeometricEffectEnclosingPolygon":
      return s7.getImportPromise();
    case "CIMGeometricEffectOffset":
      return Promise.all([p3.getImportPromise(), n5.getImportPromise()]);
    case "CIMGeometricEffectTaperedPolygon":
      return Promise.all([f4.getImportPromise(), m2.getImportPromise(), i8.getImportPromise()]);
    default:
      return Promise.resolve();
  }
}
var g3 = class {
  constructor(e17) {
    this._geometry = e17;
  }
  next() {
    const e17 = this._geometry;
    return this._geometry = null, e17;
  }
};
function y3(t16, o9, s17) {
  if (!t16) return null;
  a3 || (a3 = new h(0, 0, 0, 1));
  const m5 = s17 ? -1 : 1, i18 = "esriGeometryPolygon" === t16.geometryType, n23 = i18 ? 3 : 2, p6 = i18 ? 3 : 2;
  let f6, l12;
  for (a3.reset(n23), a3.setPixelMargin(o9 + 1), a3.setExtent(c3); t16.nextPath(); ) if (!(t16.pathSize < p6)) {
    for (t16.nextPoint(), f6 = t16.x, l12 = m5 * t16.y, a3.moveTo(f6, l12); t16.nextPoint(); ) f6 = t16.x, l12 = m5 * t16.y, a3.lineTo(f6, l12);
    i18 && a3.close();
  }
  const g5 = a3.result(false);
  if (g5) {
    const r13 = a2.createEmptyOptimizedCIM(t16.geometryType);
    for (const e17 of g5) {
      r13.startPath();
      for (const t17 of e17) r13.pushXY(t17.x, m5 * t17.y);
    }
    return r13.reset(), r13;
  }
  return null;
}

// node_modules/@arcgis/core/symbols/cim/effects/EffectBuffer.js
var _m = class _m {
  static local() {
    return null === _m.instance && (_m.instance = new _m()), _m.instance;
  }
  execute(e17, t16, i18, s17, r13, n23) {
    return new l8(e17, t16, i18, s17, r13, n23);
  }
};
_m.instance = null;
var m3 = _m;
var l8 = class {
  constructor(e17, t16, i18, s17, r13, m5) {
    this._preventClipping = m5, this._inputGeometries = e17, this._tileKey = s17, this._curveHelper = new n4(), this._size = (void 0 !== t16.size ? t16.size : 1) * i18, this._maxInflateSize = r13 * i18, this._offsetFlattenError = e8 * i18;
  }
  next() {
    let n23;
    for (; n23 = this._inputGeometries.next(); ) {
      if (0 === this._size) return n23;
      if ("esriGeometryEnvelope" === n23.geometryType) {
        if (this._size > 0) {
          const i18 = a2.createEmptyOptimizedCIM(n23.geometryType), s17 = t2(n23)[0], r13 = this._curveHelper.offset(s17, this._size, "Rounded", 4, this._offsetFlattenError);
          if (r13) return i18.pushPath(r13), i18;
        } else if (this._size < 0) {
          const t16 = n23.asJSON();
          if (Math.min(t16.xmax - t16.xmin, t16.ymax - t16.ymin) + 2 * this._size > 0) return a2.fromJSONCIM({ xmin: t16.xmin - this._size, xmax: t16.xmax + this._size, ymin: t16.ymin - this._size, ymax: t16.ymax + this._size });
        }
      }
      const o9 = !this._preventClipping && this._tileKey ? y3(n23, this._maxInflateSize, true) : n23;
      if (!o9) continue;
      const m5 = o3.module, l12 = { ...o9.asJSON(), spatialReference: { wkid: f.WebMercator.wkid } }, a11 = m5.execute(l12, this._size);
      return a11 ? a2.fromJSONCIM(a11) : null;
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectControlMeasureLine.js
var _e2 = class _e2 {
  static local() {
    return null === _e2.instance && (_e2.instance = new _e2()), _e2.instance;
  }
  execute(s17, t16, i18) {
    return new r3(s17, t16, i18);
  }
};
_e2.instance = null;
var e9 = _e2;
var r3 = class {
  constructor(s17, t16, i18) {
    this._defaultPointSize = 20, this._inputGeometries = s17, this._geomUnitsPerPoint = i18, this._rule = t16.rule ?? "FullGeometry", this._defaultSize = this._defaultPointSize * i18;
  }
  next() {
    let i18;
    for (; i18 = this._inputGeometries.next(); ) {
      const h8 = this._processGeom(t2(i18));
      if (h8?.length) return a2.fromJSONCIM({ paths: h8 });
    }
    return null;
  }
  _clone(s17) {
    return [s17[0], s17[1]];
  }
  _mid(s17, t16) {
    return [(s17[0] + t16[0]) / 2, (s17[1] + t16[1]) / 2];
  }
  _mix(s17, t16, i18, h8) {
    return [s17[0] * t16 + i18[0] * h8, s17[1] * t16 + i18[1] * h8];
  }
  _add(s17, t16) {
    return [s17[0] + t16[0], s17[1] + t16[1]];
  }
  _add2(s17, t16, i18) {
    return [s17[0] + t16, s17[1] + i18];
  }
  _sub(s17, t16) {
    return [s17[0] - t16[0], s17[1] - t16[1]];
  }
  _dist(s17, t16) {
    return Math.sqrt((s17[0] - t16[0]) * (s17[0] - t16[0]) + (s17[1] - t16[1]) * (s17[1] - t16[1]));
  }
  _norm(s17) {
    return Math.sqrt(s17[0] * s17[0] + s17[1] * s17[1]);
  }
  _normalize(s17, t16 = 1) {
    const i18 = t16 / this._norm(s17);
    s17[0] *= i18, s17[1] *= i18;
  }
  _leftPerpendicular(s17) {
    const t16 = -s17[1], i18 = s17[0];
    s17[0] = t16, s17[1] = i18;
  }
  _leftPerp(s17) {
    return [-s17[1], s17[0]];
  }
  _rightPerpendicular(s17) {
    const t16 = s17[1], i18 = -s17[0];
    s17[0] = t16, s17[1] = i18;
  }
  _rightPerp(s17) {
    return [s17[1], -s17[0]];
  }
  _dotProduct(s17, t16) {
    return s17[0] * t16[0] + s17[1] * t16[1];
  }
  _crossProduct(s17, t16) {
    return s17[0] * t16[1] - s17[1] * t16[0];
  }
  _rotateDirect(s17, t16, i18) {
    const h8 = s17[0] * t16 - s17[1] * i18, e17 = s17[0] * i18 + s17[1] * t16;
    s17[0] = h8, s17[1] = e17;
  }
  _makeCtrlPt(s17) {
    const t16 = [s17[0], s17[1]];
    return e7(t16, 1), t16;
  }
  _addAngledTicks(s17, t16, i18, h8) {
    const e17 = this._sub(i18, t16);
    this._normalize(e17);
    const r13 = this._crossProduct(e17, this._sub(h8, t16));
    let _4;
    _4 = r13 > 0 ? this._rightPerp(e17) : this._leftPerp(e17);
    const c5 = Math.abs(r13) / 2, u9 = [];
    u9.push([t16[0] + (_4[0] - e17[0]) * c5, t16[1] + (_4[1] - e17[1]) * c5]), u9.push(t16), u9.push(i18), u9.push([i18[0] + (_4[0] + e17[0]) * c5, i18[1] + (_4[1] + e17[1]) * c5]), s17.push(u9);
  }
  _addBezier2(s17, t16, i18, h8, e17) {
    if (0 === e17--) return void s17.push(h8);
    const r13 = this._mid(t16, i18), _4 = this._mid(i18, h8), c5 = this._mid(r13, _4);
    this._addBezier2(s17, t16, r13, c5, e17), this._addBezier2(s17, c5, _4, h8, e17);
  }
  _addBezier3(s17, t16, i18, h8, e17, r13) {
    if (0 === r13--) return void s17.push(e17);
    const _4 = this._mid(t16, i18), c5 = this._mid(i18, h8), u9 = this._mid(h8, e17), o9 = this._mid(_4, c5), a11 = this._mid(c5, u9), n23 = this._mid(o9, a11);
    this._addBezier3(s17, t16, _4, o9, n23, r13), this._addBezier3(s17, n23, a11, u9, e17, r13);
  }
  _add90DegArc(s17, t16, i18, h8, e17) {
    const r13 = e17 ?? this._crossProduct(this._sub(i18, t16), this._sub(h8, t16)) > 0, _4 = this._mid(t16, i18), c5 = this._sub(_4, t16);
    r13 ? this._leftPerpendicular(c5) : this._rightPerpendicular(c5), _4[0] += c5[0], _4[1] += c5[1], this._addBezier3(s17, t16, this._mix(t16, 0.33333, _4, 0.66667), this._mix(i18, 0.33333, _4, 0.66667), i18, 4);
  }
  _addArrow(s17, t16, i18) {
    const h8 = t16[0], e17 = t16[1], r13 = t16[t16.length - 1], _4 = this._sub(h8, e17), c5 = this._norm(_4);
    this._normalize(_4);
    const u9 = Math.abs(this._crossProduct(_4, this._sub(r13, e17)));
    let o9 = this._dotProduct(_4, this._sub(r13, e17));
    o9 < 0.05 * c5 ? o9 = 0.05 * c5 : o9 > 0.95 * c5 && (o9 = 0.95 * c5);
    const a11 = 0.5 * u9, n23 = this._leftPerp(_4), p6 = [e17[0] + _4[0] * o9, e17[1] + _4[1] * o9], d = t16.length - 1, l12 = [];
    l12.push(i18 ? [-n23[0], -n23[1]] : n23);
    let b2 = [-_4[0], -_4[1]];
    for (let P3 = 1; P3 < d - 1; P3++) {
      const s18 = this._sub(t16[P3 + 1], t16[P3]);
      this._normalize(s18);
      const i19 = this._dotProduct(s18, b2), h9 = this._crossProduct(s18, b2), e18 = Math.sqrt((1 + i19) / 2), r14 = this._sub(s18, b2);
      this._normalize(r14), r14[0] /= e18, r14[1] /= e18, l12.push(h9 < 0 ? [-r14[0], -r14[1]] : r14), b2 = s18;
    }
    l12.push(this._rightPerp(b2));
    for (let P3 = l12.length - 1; P3 > 0; P3--) s17.push([t16[P3][0] + l12[P3][0] * a11, t16[P3][1] + l12[P3][1] * a11]);
    s17.push([p6[0] + l12[0][0] * a11, p6[1] + l12[0][1] * a11]), s17.push([p6[0] + l12[0][0] * u9, p6[1] + l12[0][1] * u9]), s17.push(h8), s17.push([p6[0] - l12[0][0] * u9, p6[1] - l12[0][1] * u9]), s17.push([p6[0] - l12[0][0] * a11, p6[1] - l12[0][1] * a11]);
    for (let P3 = 1; P3 < l12.length; P3++) s17.push([t16[P3][0] - l12[P3][0] * a11, t16[P3][1] - l12[P3][1] * a11]);
  }
  _addDash(s17, t16, i18) {
    const h8 = this._norm(i18) / 7;
    this._normalize(i18);
    let e17 = [];
    for (let r13 = 0; r13 <= 7; r13++) e17.push([t16[0] + i18[0] * r13 * h8, t16[1] + i18[1] * r13 * h8]), 1 & r13 && (s17.push(e17), e17 = []);
  }
  _cp2(s17, t16, i18) {
    return s17.length >= 2 ? s17[1] : this._add2(s17[0], t16 * this._defaultSize, i18 * this._defaultSize);
  }
  _cp3(s17, t16, i18, h8) {
    if (s17.length >= 3) return s17[2];
    const e17 = this._mix(s17[0], 1 - i18, t16, i18), r13 = this._sub(t16, s17[0]);
    return this._normalize(r13), this._rightPerpendicular(r13), [e17[0] + r13[0] * h8 * this._defaultSize, e17[1] + r13[1] * h8 * this._defaultSize];
  }
  _arrowPath(s17) {
    if (s17.length > 2) return s17;
    const t16 = s17[0], i18 = this._cp2(s17, -4, 0), h8 = this._sub(t16, i18);
    this._normalize(h8);
    const e17 = this._rightPerp(h8);
    return [t16, i18, [t16[0] + (e17[0] - h8[0]) * this._defaultSize, t16[1] + (e17[1] - h8[1]) * this._defaultSize]];
  }
  _arrowLastSeg(s17) {
    const t16 = s17[0], i18 = this._cp2(s17, -4, 0);
    let h8;
    if (s17.length >= 3) h8 = s17[s17.length - 1];
    else {
      const s18 = this._sub(t16, i18);
      this._normalize(s18);
      const e17 = this._rightPerp(s18);
      h8 = [t16[0] + (e17[0] - s18[0]) * this._defaultSize, t16[1] + (e17[1] - s18[1]) * this._defaultSize];
    }
    return [i18, h8];
  }
  _processGeom(s17) {
    if (!s17) return null;
    const t16 = [];
    for (const e17 of s17) {
      const s18 = e17.length > 1 && c(e17) < this._defaultSize;
      if (!e17 || 0 === e17.length || s18) continue;
      const r13 = e17.length;
      let _4 = e17[0];
      switch (this._rule) {
        case "PerpendicularFromFirstSegment": {
          const s19 = this._cp2(e17, 0, -1), i18 = this._cp3(e17, s19, 0.5, 4), h8 = [];
          h8.push(i18), h8.push(this._mid(_4, s19)), t16.push(h8);
          break;
        }
        case "ReversedFirstSegment": {
          const s19 = this._cp2(e17, 0, -1);
          t16.push([s19, _4]);
          break;
        }
        case "PerpendicularToSecondSegment": {
          if (e17.length < 3) return [];
          const s19 = this._cp2(e17, -4, 1), i18 = this._cp3(e17, s19, 0.882353, -1.94), h8 = [];
          h8.push(this._mid(s19, i18)), h8.push(_4), t16.push(h8);
          break;
        }
        case "SecondSegmentWithTicks": {
          if (e17.length < 3) return [];
          const s19 = this._cp2(e17, -4, 1), i18 = this._cp3(e17, s19, 0.882353, -1.94), h8 = this._sub(i18, s19);
          let r14;
          r14 = this._crossProduct(h8, this._sub(_4, s19)) > 0 ? this._rightPerp(h8) : this._leftPerp(h8);
          const c5 = [];
          c5.push([s19[0] + (r14[0] - h8[0]) / 3, s19[1] + (r14[1] - h8[1]) / 3]), c5.push(s19), c5.push(i18), c5.push([i18[0] + (r14[0] + h8[0]) / 3, i18[1] + (r14[1] + h8[1]) / 3]), t16.push(c5);
          break;
        }
        case "DoublePerpendicular": {
          const s19 = this._cp2(e17, 0, -1), i18 = this._cp3(e17, s19, 0.5, 3), h8 = this._mid(_4, s19), r14 = this._sub(h8, i18);
          this._normalize(r14);
          const c5 = this._crossProduct(r14, this._sub(_4, i18));
          this._leftPerpendicular(r14);
          const u9 = [];
          u9.push(_4), u9.push([i18[0] + r14[0] * c5, i18[1] + r14[1] * c5]), t16.push(u9);
          const o9 = [];
          o9.push([i18[0] - r14[0] * c5, i18[1] - r14[1] * c5]), o9.push(s19), t16.push(o9);
          break;
        }
        case "OppositeToFirstSegment": {
          const s19 = this._cp2(e17, 0, -1), i18 = this._cp3(e17, s19, 0.5, 3), h8 = this._mid(_4, s19), r14 = this._sub(h8, i18);
          this._normalize(r14);
          const c5 = this._crossProduct(r14, this._sub(_4, i18));
          this._leftPerpendicular(r14);
          const u9 = [];
          u9.push([i18[0] + r14[0] * c5, i18[1] + r14[1] * c5]), u9.push([i18[0] - r14[0] * c5, i18[1] - r14[1] * c5]), t16.push(u9);
          break;
        }
        case "TriplePerpendicular": {
          const s19 = this._cp2(e17, 0, -1), i18 = this._cp3(e17, s19, 0.5, 4), h8 = this._mid(_4, s19), r14 = this._sub(h8, i18);
          this._normalize(r14);
          const c5 = this._crossProduct(r14, this._sub(_4, i18));
          this._leftPerpendicular(r14);
          const u9 = [];
          u9.push([i18[0] + r14[0] * c5 * 0.8, i18[1] + r14[1] * c5 * 0.8]), u9.push([h8[0] + 0.8 * (_4[0] - h8[0]), h8[1] + 0.8 * (_4[1] - h8[1])]), t16.push(u9), t16.push([i18, h8]);
          const o9 = [];
          o9.push([i18[0] - r14[0] * c5 * 0.8, i18[1] - r14[1] * c5 * 0.8]), o9.push([h8[0] + 0.8 * (s19[0] - h8[0]), h8[1] + 0.8 * (s19[1] - h8[1])]), t16.push(o9);
          break;
        }
        case "HalfCircleFirstSegment": {
          const s19 = this._cp2(e17, 0, -1), i18 = this._cp3(e17, s19, 0.5, 4), h8 = this._mid(_4, s19);
          let r14 = this._sub(s19, _4);
          const c5 = Math.cos(Math.PI / 18), u9 = Math.sin(Math.PI / 18), o9 = Math.sqrt((1 + c5) / 2), a11 = Math.sqrt((1 - c5) / 2), n23 = [];
          let p6;
          this._crossProduct(r14, this._sub(i18, _4)) > 0 ? (n23.push(_4), r14 = this._sub(_4, h8), p6 = s19) : (n23.push(s19), r14 = this._sub(s19, h8), p6 = _4), this._rotateDirect(r14, o9, a11), r14[0] /= o9, r14[1] /= o9;
          for (let t17 = 1; t17 <= 18; t17++) n23.push(this._add(h8, r14)), this._rotateDirect(r14, c5, u9);
          n23.push(p6), t16.push(n23);
          break;
        }
        case "HalfCircleSecondSegment": {
          const s19 = this._cp2(e17, 0, -1), i18 = this._cp3(e17, s19, 1, -1);
          let h8 = this._sub(_4, s19);
          this._normalize(h8);
          const r14 = this._crossProduct(h8, this._sub(i18, s19)) / 2;
          this._leftPerpendicular(h8);
          const c5 = [s19[0] + h8[0] * r14, s19[1] + h8[1] * r14];
          h8 = this._sub(s19, c5);
          const u9 = Math.cos(Math.PI / 18);
          let o9 = Math.sin(Math.PI / 18);
          r14 > 0 && (o9 = -o9);
          const a11 = [s19];
          for (let t17 = 1; t17 <= 18; t17++) this._rotateDirect(h8, u9, o9), a11.push(this._add(c5, h8));
          t16.push(a11);
          break;
        }
        case "HalfCircleExtended": {
          const s19 = this._cp2(e17, 0, -2), i18 = this._cp3(e17, s19, 1, -1);
          let h8;
          if (r13 >= 4) h8 = e17[3];
          else {
            const t17 = this._sub(_4, s19);
            h8 = this._add(i18, t17);
          }
          const c5 = this._dist(s19, i18) / 2 / 0.75, u9 = this._sub(s19, _4);
          this._normalize(u9, c5);
          const o9 = this._sub(i18, h8);
          this._normalize(o9, c5);
          const a11 = [h8, i18];
          t16.push(a11);
          const n23 = [this._clone(i18)];
          this._addBezier3(n23, i18, this._add(i18, o9), this._add(s19, u9), s19, 4), n23.push(_4), t16.push(n23);
          break;
        }
        case "OpenCircle": {
          const s19 = this._cp2(e17, -2, 0), i18 = this._sub(s19, _4), h8 = Math.cos(Math.PI / 18), r14 = -Math.sin(Math.PI / 18), c5 = [s19];
          for (let t17 = 1; t17 <= 33; t17++) this._rotateDirect(i18, h8, r14), c5.push(this._add(_4, i18));
          t16.push(c5);
          break;
        }
        case "CoverageEdgesWithTicks": {
          const s19 = this._cp2(e17, 0, -1);
          let i18, h8;
          if (r13 >= 3) i18 = e17[2];
          else {
            const t17 = this._sub(s19, _4), h9 = this._leftPerp(t17);
            i18 = [_4[0] + h9[0] - 0.25 * t17[0], _4[1] + h9[1] - 0.25 * t17[1]];
          }
          if (r13 >= 4) h8 = e17[3];
          else {
            const t17 = this._mid(_4, s19), e18 = this._sub(_4, s19);
            this._normalize(e18), this._leftPerpendicular(e18);
            const r14 = this._crossProduct(e18, this._sub(i18, t17));
            this._rightPerpendicular(e18), h8 = [i18[0] + e18[0] * r14 * 2, i18[1] + e18[1] * r14 * 2];
          }
          const c5 = this._sub(s19, _4);
          let u9, o9;
          u9 = this._crossProduct(c5, this._sub(i18, _4)) > 0 ? this._rightPerp(c5) : this._leftPerp(c5), o9 = [], o9.push(i18), o9.push(_4), o9.push([_4[0] + (u9[0] - c5[0]) / 3, _4[1] + (u9[1] - c5[1]) / 3]), t16.push(o9), u9 = this._crossProduct(c5, this._sub(h8, s19)) > 0 ? this._rightPerp(c5) : this._leftPerp(c5), o9 = [], o9.push([s19[0] + (u9[0] + c5[0]) / 3, s19[1] + (u9[1] + c5[1]) / 3]), o9.push(s19), o9.push(h8), t16.push(o9);
          break;
        }
        case "GapExtentWithDoubleTicks": {
          const s19 = this._cp2(e17, 0, 2), i18 = this._cp3(e17, s19, 0, 1);
          let h8;
          if (r13 >= 4) h8 = e17[3];
          else {
            const t17 = this._sub(s19, _4);
            h8 = this._add(i18, t17);
          }
          this._addAngledTicks(t16, _4, s19, this._mid(i18, h8)), this._addAngledTicks(t16, i18, h8, this._mid(_4, s19));
          break;
        }
        case "GapExtentMidline": {
          const s19 = this._cp2(e17, 2, 0), i18 = this._cp3(e17, s19, 0, 1);
          let h8;
          if (r13 >= 4) h8 = e17[3];
          else {
            const t17 = this._sub(s19, _4);
            h8 = this._add(i18, t17);
          }
          const c5 = [];
          c5.push(this._mid(_4, i18)), c5.push(this._mid(s19, h8)), t16.push(c5);
          break;
        }
        case "Chevron": {
          const s19 = this._cp2(e17, -1, -1);
          let i18;
          if (r13 >= 3) i18 = e17[2];
          else {
            const t17 = this._sub(s19, _4);
            this._leftPerpendicular(t17), i18 = this._add(_4, t17);
          }
          t16.push([s19, this._makeCtrlPt(_4), i18]);
          break;
        }
        case "PerpendicularWithArc": {
          const s19 = this._cp2(e17, 0, -2), i18 = this._cp3(e17, s19, 0.5, -1), h8 = this._sub(s19, _4), c5 = this._norm(h8);
          h8[0] /= c5, h8[1] /= c5;
          const u9 = this._crossProduct(h8, this._sub(i18, _4));
          let o9 = this._dotProduct(h8, this._sub(i18, _4));
          o9 < 0.05 * c5 ? o9 = 0.05 * c5 : o9 > 0.95 * c5 && (o9 = 0.95 * c5);
          const a11 = [_4[0] + h8[0] * o9, _4[1] + h8[1] * o9];
          let n23 = this._leftPerp(h8), p6 = [];
          if (p6.push([a11[0] - n23[0] * u9, a11[1] - n23[1] * u9]), p6.push([a11[0] + n23[0] * u9, a11[1] + n23[1] * u9]), t16.push(p6), r13 >= 4) {
            const s20 = e17[3];
            let i19 = this._dotProduct(h8, this._sub(s20, _4));
            i19 < 0.1 * c5 ? i19 = 0.1 * c5 : i19 > 0.9 * c5 && (i19 = 0.9 * c5);
            const r14 = [_4[0] + h8[0] * i19, _4[1] + h8[1] * i19], u10 = this._crossProduct(h8, this._sub(s20, _4)), o10 = [];
            o10.push([r14[0] - n23[0] * u10, r14[1] - n23[1] * u10]), o10.push([r14[0] + n23[0] * u10, r14[1] + n23[1] * u10]), t16.push(o10);
          }
          const d = [s19[0] + n23[0] * u9, s19[1] + n23[1] * u9];
          n23 = this._sub(s19, d);
          const l12 = Math.cos(Math.PI / 18);
          let b2 = Math.sin(Math.PI / 18);
          u9 < 0 && (b2 = -b2), p6 = [_4, s19];
          for (let t17 = 1; t17 <= 9; t17++) this._rotateDirect(n23, l12, b2), p6.push(this._add(d, n23));
          t16.push(p6);
          break;
        }
        case "ClosedHalfCircle": {
          const s19 = this._cp2(e17, 2, 0), i18 = this._mid(_4, s19), h8 = this._sub(s19, i18), r14 = Math.cos(Math.PI / 18), c5 = Math.sin(Math.PI / 18), u9 = [_4, s19];
          for (let t17 = 1; t17 <= 18; t17++) this._rotateDirect(h8, r14, c5), u9.push(this._add(i18, h8));
          t16.push(u9);
          break;
        }
        case "TripleParallelExtended": {
          const s19 = this._cp2(e17, 0, -2), i18 = this._cp3(e17, s19, 1, -2), r14 = this._mid(_4, s19), c5 = this._sub(i18, s19);
          this._normalize(c5);
          const u9 = Math.abs(this._crossProduct(c5, this._sub(r14, s19))) / 2, o9 = this._dist(s19, i18), a11 = [s19, _4];
          a11.push([_4[0] + c5[0] * o9 * 0.5, _4[1] + c5[1] * o9 * 0.5]), t16.push(a11);
          const n23 = [];
          n23.push([r14[0] - c5[0] * u9, r14[1] - c5[1] * u9]), n23.push([r14[0] + c5[0] * o9 * 0.375, r14[1] + c5[1] * o9 * 0.375]), e7(n23[n23.length - 1], 1), n23.push([r14[0] + c5[0] * o9 * 0.75, r14[1] + c5[1] * o9 * 0.75]), t16.push(n23);
          const p6 = [s19, i18];
          t16.push(p6);
          break;
        }
        case "ParallelWithTicks": {
          const s19 = this._cp2(e17, 3, 0), i18 = this._cp3(e17, s19, 0.5, -1), h8 = this._sub(i18, s19);
          this._normalize(h8);
          const r14 = this._crossProduct(h8, this._sub(i18, _4));
          this._leftPerpendicular(h8), this._addAngledTicks(t16, _4, s19, i18), this._addAngledTicks(t16, this._mix(_4, 1, h8, r14), this._mix(s19, 1, h8, r14), this._mid(_4, s19));
          break;
        }
        case "Parallel": {
          const s19 = this._cp2(e17, 3, 0), i18 = this._cp3(e17, s19, 0.5, -1), h8 = this._sub(s19, _4);
          this._normalize(h8);
          const r14 = this._leftPerp(h8), c5 = this._crossProduct(h8, this._sub(i18, _4));
          let u9 = [_4, s19];
          t16.push(u9), u9 = [], u9.push([_4[0] + r14[0] * c5, _4[1] + r14[1] * c5]), u9.push([s19[0] + r14[0] * c5, s19[1] + r14[1] * c5]), t16.push(u9);
          break;
        }
        case "PerpendicularToFirstSegment": {
          const s19 = this._cp2(e17, 3, 0), i18 = this._cp3(e17, s19, 0.5, -1), h8 = this._mid(_4, s19), r14 = this._sub(s19, _4);
          this._normalize(r14);
          const c5 = this._crossProduct(r14, this._sub(i18, _4));
          this._leftPerpendicular(r14);
          const u9 = [];
          u9.push([h8[0] - r14[0] * c5 * 0.25, h8[1] - r14[1] * c5 * 0.25]), u9.push([h8[0] + r14[0] * c5 * 1.25, h8[1] + r14[1] * c5 * 1.25]), t16.push(u9);
          break;
        }
        case "ParallelOffset": {
          const s19 = this._cp2(e17, 3, 0), i18 = this._cp3(e17, s19, 0.5, -1), h8 = this._sub(s19, _4);
          this._normalize(h8);
          const r14 = this._crossProduct(h8, this._sub(i18, _4));
          this._leftPerpendicular(h8);
          const c5 = [];
          c5.push([_4[0] - h8[0] * r14, _4[1] - h8[1] * r14]), c5.push([s19[0] - h8[0] * r14, s19[1] - h8[1] * r14]), t16.push(c5);
          const u9 = [];
          u9.push([_4[0] + h8[0] * r14, _4[1] + h8[1] * r14]), u9.push([s19[0] + h8[0] * r14, s19[1] + h8[1] * r14]), t16.push(u9);
          break;
        }
        case "OffsetOpposite": {
          const s19 = this._cp2(e17, 3, 0), i18 = this._cp3(e17, s19, 0.5, -1), h8 = this._sub(s19, _4);
          this._normalize(h8);
          const r14 = this._crossProduct(h8, this._sub(i18, _4));
          this._leftPerpendicular(h8);
          const c5 = [];
          c5.push([_4[0] - h8[0] * r14, _4[1] - h8[1] * r14]), c5.push([s19[0] - h8[0] * r14, s19[1] - h8[1] * r14]), t16.push(c5);
          break;
        }
        case "OffsetSame": {
          const s19 = this._cp2(e17, 3, 0), i18 = this._cp3(e17, s19, 0.5, -1), h8 = this._sub(s19, _4);
          this._normalize(h8);
          const r14 = this._crossProduct(h8, this._sub(i18, _4));
          this._leftPerpendicular(h8);
          const c5 = [];
          c5.push([_4[0] + h8[0] * r14, _4[1] + h8[1] * r14]), c5.push([s19[0] + h8[0] * r14, s19[1] + h8[1] * r14]), t16.push(c5);
          break;
        }
        case "CircleWithArc": {
          let s19 = this._cp2(e17, 3, 0);
          const i18 = this._cp3(e17, s19, 0.5, -1);
          let c5, u9;
          if (r13 >= 4) c5 = e17[3], u9 = this._crossProduct(this._sub(c5, s19), this._sub(i18, s19)) > 0;
          else {
            c5 = s19, u9 = this._crossProduct(this._sub(c5, _4), this._sub(i18, _4)) > 0;
            const t17 = 24 * this._geomUnitsPerPoint, h8 = this._sub(c5, _4);
            this._normalize(h8, t17);
            const e18 = Math.sqrt(2) / 2;
            this._rotateDirect(h8, e18, u9 ? e18 : -e18), s19 = this._add(_4, h8);
          }
          const o9 = this._sub(s19, _4), a11 = Math.cos(Math.PI / 18), n23 = Math.sin(Math.PI / 18), p6 = [s19];
          for (let t17 = 1; t17 <= 36; t17++) this._rotateDirect(o9, a11, n23), p6.push(this._add(_4, o9));
          this._add90DegArc(p6, s19, c5, i18, u9), e7(p6[p6.length - 8], 1), t16.push(p6);
          break;
        }
        case "DoubleJog": {
          let s19, i18 = this._cp2(e17, -3, 1), h8 = this._cp3(e17, i18, -1, -0.5);
          if (r13 >= 4) s19 = e17[3];
          else {
            const t17 = _4;
            _4 = i18, s19 = h8;
            const e18 = this._dist(_4, t17), r14 = this._dist(s19, t17);
            let c6 = 30 * this._geomUnitsPerPoint;
            0.5 * e18 < c6 && (c6 = 0.5 * e18), 0.5 * r14 < c6 && (c6 = 0.5 * r14), i18 = this._mix(_4, c6 / e18, t17, (e18 - c6) / e18), h8 = this._mix(s19, c6 / r14, t17, (r14 - c6) / r14);
          }
          const c5 = this._mid(_4, i18), u9 = this._mid(s19, h8), o9 = this._dist(_4, i18), a11 = this._dist(h8, s19);
          let n23 = Math.min(o9, a11) / 8;
          n23 = Math.min(n23, 24 * this._geomUnitsPerPoint);
          const p6 = Math.cos(Math.PI / 4);
          let d = this._sub(_4, i18);
          this._normalize(d, n23), this._crossProduct(d, this._sub(s19, i18)) > 0 ? this._rotateDirect(d, p6, -p6) : this._rotateDirect(d, p6, p6);
          let l12 = [];
          l12.push(i18), l12.push(this._add(c5, d)), l12.push(this._sub(c5, d)), l12.push(_4), t16.push(l12), d = this._sub(s19, h8), this._normalize(d, n23), this._crossProduct(d, this._sub(_4, h8)) < 0 ? this._rotateDirect(d, p6, p6) : this._rotateDirect(d, p6, -p6), l12 = [], l12.push(h8), l12.push(this._add(u9, d)), l12.push(this._sub(u9, d)), l12.push(s19), t16.push(l12);
          break;
        }
        case "PerpendicularOffset": {
          const s19 = this._cp2(e17, -4, 1), i18 = this._cp3(e17, s19, 0.882353, -1.94), h8 = this._sub(i18, s19);
          this._crossProduct(h8, this._sub(_4, s19)) > 0 ? this._rightPerpendicular(h8) : this._leftPerpendicular(h8);
          const r14 = [h8[0] / 8, h8[1] / 8], c5 = this._sub(this._mid(s19, i18), r14);
          t16.push([c5, _4]);
          break;
        }
        case "LineExcludingLastSegment": {
          const s19 = this._arrowPath(e17), i18 = [];
          let h8 = s19.length - 2;
          for (; h8--; ) i18.push(s19[h8]);
          t16.push(i18);
          break;
        }
        case "MultivertexArrow": {
          const s19 = this._arrowPath(e17), i18 = [];
          this._addArrow(i18, s19, false), t16.push(i18);
          break;
        }
        case "CrossedArrow": {
          const s19 = this._arrowPath(e17), i18 = [];
          this._addArrow(i18, s19, true), t16.push(i18);
          break;
        }
        case "ChevronArrow": {
          const [s19, i18] = this._arrowLastSeg(e17), h8 = 10 * this._geomUnitsPerPoint, r14 = this._sub(_4, s19), c5 = this._norm(r14);
          this._normalize(r14);
          const u9 = this._crossProduct(r14, this._sub(i18, s19));
          let o9 = this._dotProduct(r14, this._sub(i18, s19));
          o9 < 0.05 * c5 ? o9 = 0.05 * c5 : o9 > 0.95 * c5 - h8 && (o9 = 0.95 * c5 - h8);
          const a11 = [s19[0] + r14[0] * o9, s19[1] + r14[1] * o9], n23 = this._leftPerp(r14), p6 = [];
          p6.push([a11[0] + n23[0] * u9 + r14[0] * h8, a11[1] + n23[1] * u9 + r14[1] * h8]), p6.push(_4), p6.push([a11[0] - n23[0] * u9 + r14[0] * h8, a11[1] - n23[1] * u9 + r14[1] * h8]), t16.push(p6);
          break;
        }
        case "ChevronArrowOffset": {
          const [s19, i18] = this._arrowLastSeg(e17), h8 = this._sub(_4, s19), r14 = this._norm(h8);
          this._normalize(h8);
          const c5 = this._crossProduct(h8, this._sub(i18, s19));
          let u9 = this._dotProduct(h8, this._sub(i18, s19));
          u9 < 0.05 * r14 ? u9 = 0.05 * r14 : u9 > 0.95 * r14 && (u9 = 0.95 * r14);
          const o9 = [s19[0] + h8[0] * u9, s19[1] + h8[1] * u9];
          this._leftPerpendicular(h8);
          const a11 = [];
          a11.push([o9[0] + h8[0] * c5 * 0.5, o9[1] + h8[1] * c5 * 0.5]), a11.push(this._mid(o9, _4)), a11.push([o9[0] - h8[0] * c5 * 0.5, o9[1] - h8[1] * c5 * 0.5]), t16.push(a11);
          break;
        }
        case "PartialFirstSegment": {
          const [s19, i18] = this._arrowLastSeg(e17), h8 = this._sub(_4, s19), r14 = this._norm(h8);
          this._normalize(h8);
          let c5 = this._dotProduct(h8, this._sub(i18, s19));
          c5 < 0.05 * r14 ? c5 = 0.05 * r14 : c5 > 0.95 * r14 && (c5 = 0.95 * r14);
          const u9 = [s19[0] + h8[0] * c5, s19[1] + h8[1] * c5];
          t16.push([s19, u9]);
          break;
        }
        case "Arch": {
          const s19 = this._cp2(e17, 0, -1), i18 = this._cp3(e17, s19, 0.5, 1), h8 = this._sub(_4, s19), r14 = this._mix(i18, 1, h8, 0.55), c5 = this._mix(i18, 1, h8, -0.55), u9 = [_4];
          this._addBezier2(u9, _4, r14, i18, 4), this._addBezier2(u9, i18, c5, s19, 4), t16.push(u9);
          break;
        }
        case "CurvedParallelTicks": {
          const s19 = this._cp2(e17, -4, 1), i18 = this._cp3(e17, s19, 0.882353, -1.94), h8 = this._sub(i18, s19);
          this._crossProduct(h8, this._sub(_4, s19)) > 0 ? this._rightPerpendicular(h8) : this._leftPerpendicular(h8);
          const r14 = [h8[0] / 8, h8[1] / 8], c5 = this._sub(this._mid(s19, i18), r14), u9 = this._sub(this._mix(s19, 0.75, i18, 0.25), r14), o9 = this._sub(this._mix(s19, 0.25, i18, 0.75), r14), a11 = [s19];
          this._addBezier2(a11, s19, u9, c5, 3), this._addBezier2(a11, c5, o9, i18, 3), t16.push(a11);
          for (let e18 = 0; e18 < 8; e18++) {
            const s20 = a11[2 * e18 + 1], i19 = [this._clone(s20)];
            i19.push(this._add(s20, [h8[0] / 4, h8[1] / 4])), t16.push(i19);
          }
          break;
        }
        case "Arc90Degrees": {
          const s19 = this._cp2(e17, 0, -1), i18 = this._cp3(e17, s19, 0.5, 1), h8 = [s19];
          this._add90DegArc(h8, s19, _4, i18), t16.push(h8);
          break;
        }
        case "TipWithPerpendicularAndTicks": {
          const [s19, i18] = this._arrowLastSeg(e17), h8 = 10 * this._geomUnitsPerPoint, r14 = this._sub(_4, s19), c5 = this._norm(r14);
          this._normalize(r14);
          let u9 = this._crossProduct(r14, this._sub(i18, s19)), o9 = this._dotProduct(r14, this._sub(i18, s19));
          o9 < 0.05 * c5 ? o9 = 0.05 * c5 : o9 > 0.95 * c5 - h8 && (o9 = 0.95 * c5 - h8);
          const a11 = this._leftPerp(r14), n23 = [_4[0] - r14[0] * h8, _4[1] - r14[1] * h8], p6 = 0.5 * Math.max(c5 - o9 - h8, h8);
          u9 = Math.abs(u9);
          const d = [];
          d.push([n23[0] + a11[0] * (u9 + p6) - r14[0] * p6, n23[1] + a11[1] * (u9 + p6) - r14[1] * p6]), d.push([n23[0] + a11[0] * u9, n23[1] + a11[1] * u9]), d.push([n23[0] - a11[0] * u9, n23[1] - a11[1] * u9]), d.push([n23[0] - a11[0] * (u9 + p6) - r14[0] * p6, n23[1] - a11[1] * (u9 + p6) - r14[1] * p6]), t16.push(d), t16.push([n23, _4]);
          break;
        }
        case "ConcentricCircles": {
          const s19 = this._cp2(e17, 1, 0), i18 = this._cp3(e17, s19, 2, 0), c5 = Math.cos(Math.PI / 18), u9 = Math.sin(Math.PI / 18);
          let o9 = this._dist(s19, _4), a11 = [o9, 0], n23 = [];
          for (let t17 = 0; t17 <= 36; t17++) n23.push(this._add(_4, a11)), this._rotateDirect(a11, c5, u9);
          if (t16.push(n23), r13 >= 4) {
            n23 = [];
            const s20 = e17[3];
            o9 = this._dist(s20, _4), a11 = [o9, 0];
            for (let t17 = 0; t17 <= 36; t17++) n23.push(this._add(_4, a11)), 0 === t17 && (n23.push(this._add(_4, a11)), e7(n23[1], 1)), this._rotateDirect(a11, c5, u9);
            t16.push(n23);
          }
          n23 = [], o9 = this._dist(i18, _4), a11 = [o9, 0];
          for (let t17 = 0; t17 <= 36; t17++) n23.push(this._add(_4, a11)), this._rotateDirect(a11, c5, u9);
          t16.push(n23);
          break;
        }
        case "DoubleJogArrow": {
          _4 = this._arrowPath(e17)[0];
          const [s19, i18] = this._arrowLastSeg(e17), h8 = this._sub(_4, s19), r14 = this._norm(h8);
          this._normalize(h8);
          const c5 = Math.abs(this._crossProduct(h8, this._sub(i18, _4)));
          let u9 = Math.abs(this._dotProduct(h8, this._sub(i18, _4)));
          u9 < 0.05 * r14 ? u9 = 0.05 * r14 : u9 > 0.95 * r14 && (u9 = 0.95 * r14);
          const o9 = Math.max(c5, u9), a11 = this._leftPerp(h8);
          let n23 = [];
          const p6 = [_4[0] - h8[0] * u9 * 0.5 + a11[0] * c5 * 0.5, _4[1] - h8[1] * u9 * 0.5 + a11[1] * c5 * 0.5];
          n23.push([p6[0], p6[1]]), p6[0] += h8[0] * o9 * 0.5 + a11[0] * o9 * 0.4, p6[1] += h8[1] * o9 * 0.5 + a11[1] * o9 * 0.4, n23.push([p6[0], p6[1]]), p6[0] -= a11[0] * o9 * 0.25, p6[1] -= a11[1] * o9 * 0.25, n23.push([p6[0], p6[1]]), p6[0] += h8[0] * o9 * 0.5 + a11[0] * o9 * 0.4, p6[1] += h8[1] * o9 * 0.5 + a11[1] * o9 * 0.4, n23.push([p6[0], p6[1]]), t16.push(n23), n23 = [], p6[0] = _4[0] - h8[0] * u9 * 0.5 - a11[0] * c5 * 0.5, p6[1] = _4[1] - h8[1] * u9 * 0.5 - a11[1] * c5 * 0.5, n23.push([p6[0], p6[1]]), p6[0] += h8[0] * o9 * 0.5 - a11[0] * o9 * 0.4, p6[1] += h8[1] * o9 * 0.5 - a11[1] * o9 * 0.4, n23.push([p6[0], p6[1]]), p6[0] += a11[0] * o9 * 0.25, p6[1] += a11[1] * o9 * 0.25, n23.push([p6[0], p6[1]]), p6[0] += h8[0] * o9 * 0.5 - a11[0] * o9 * 0.4, p6[1] += h8[1] * o9 * 0.5 - a11[1] * o9 * 0.4, n23.push([p6[0], p6[1]]), t16.push(n23);
          break;
        }
        case "LinkedChevrons": {
          const s19 = this._cp2(e17, -5, 0), i18 = this._cp3(e17, s19, -0.2, 1), h8 = this._sub(_4, s19);
          this._normalize(h8);
          const r14 = this._leftPerp(h8), c5 = Math.abs(this._crossProduct(h8, this._sub(i18, s19)));
          t16.push([s19, _4]);
          const u9 = [];
          u9.push([_4[0] - h8[0] * c5 + r14[0] * c5, _4[1] - h8[1] * c5 + r14[1] * c5]), u9.push(_4), u9.push([_4[0] - h8[0] * c5 - r14[0] * c5, _4[1] - h8[1] * c5 - r14[1] * c5]), t16.push(u9), this._addDash(t16, s19, [-h8[0] * c5 + r14[0] * c5, -h8[1] * c5 + r14[1] * c5]), this._addDash(t16, s19, [-h8[0] * c5 - r14[0] * c5, -h8[1] * c5 - r14[1] * c5]);
          break;
        }
        case "SegmentThenHalfCircle": {
          const s19 = this._cp2(e17, 2, 0), i18 = this._cp3(e17, s19, 1.5, 0);
          let h8;
          h8 = r13 >= 4 ? e17[3] : this._cp3(e17, s19, 1.25, -0.5);
          const c5 = this._sub(s19, _4);
          this._normalize(c5);
          const u9 = 0.5 * this._dist(s19, i18), o9 = this._crossProduct(c5, this._sub(h8, _4)) > 0, a11 = Math.cos(Math.PI / 18);
          let n23 = Math.sin(Math.PI / 18);
          o9 && (n23 = -n23);
          const p6 = [_4, s19];
          c5[0] *= u9, c5[1] *= u9;
          const d = this._add(s19, c5);
          c5[0] = -c5[0], c5[1] = -c5[1];
          for (let t17 = 1; t17 <= 18; t17++) this._rotateDirect(c5, a11, n23), p6.push(this._add(d, c5));
          t16.push(p6);
          break;
        }
        case "LineWithStraightTicks": {
          const s19 = this._cp2(e17, -2, 1), i18 = this._cp3(e17, s19, -1, -0.5), h8 = this._sub(i18, s19);
          this._normalize(h8);
          const r14 = this._dotProduct(h8, this._sub(s19, _4)), c5 = this._dotProduct(h8, this._sub(i18, _4));
          let u9 = [_4];
          u9.push([_4[0] + h8[0] * r14, _4[1] + h8[1] * r14]), u9.push(s19), t16.push(u9), u9 = [_4], u9.push([_4[0] + h8[0] * c5, _4[1] + h8[1] * c5]), u9.push(i18), t16.push(u9);
          break;
        }
        case "DoubleCurve": {
          const s19 = this._cp2(e17, -5, -1), i18 = this._cp3(e17, s19, 2, 0), r14 = Math.atan2(1, 5), c5 = Math.cos(r14), u9 = Math.sin(r14), o9 = this._sub(s19, _4), a11 = this._dist(_4, s19);
          this._normalize(o9), this._rotateDirect(o9, c5, -u9);
          const n23 = [_4];
          n23.push([_4[0] + o9[0] * a11 * 0.5, _4[1] + o9[1] * a11 * 0.5]), e7(n23[1], 1), n23.push([_4[0] + o9[0] * a11 * 0.8, _4[1] + o9[1] * a11 * 0.8]), this._addBezier2(n23, n23[2], [_4[0] + o9[0] * a11, _4[1] + o9[1] * a11], s19, 3);
          const p6 = this._sub(i18, s19), d = this._dist(s19, i18);
          this._normalize(p6), this._rotateDirect(p6, c5, -u9), this._addBezier2(n23, s19, [i18[0] - p6[0] * d, i18[1] - p6[1] * d], [i18[0] - p6[0] * d * 0.8, i18[1] - p6[1] * d * 0.8], 3), n23.push(i18), t16.push(n23);
          break;
        }
        case "ParallelWithTicksByWidth": {
          const s19 = this._cp2(e17, 0, -1), i18 = this._cp3(e17, s19, 0.5, 3), h8 = this._sub(s19, _4);
          this._normalize(h8);
          const r14 = this._crossProduct(h8, this._sub(i18, _4));
          this._leftPerpendicular(h8), r14 > 0 ? (this._addAngledTicks(t16, _4, [_4[0] + h8[0] * r14, _4[1] + h8[1] * r14], s19), this._addAngledTicks(t16, s19, [s19[0] + h8[0] * r14, s19[1] + h8[1] * r14], _4)) : (this._addAngledTicks(t16, [_4[0] + h8[0] * r14, _4[1] + h8[1] * r14], _4, s19), this._addAngledTicks(t16, [s19[0] + h8[0] * r14, s19[1] + h8[1] * r14], _4, s19));
          break;
        }
        case "EnclosingRoundedRectangle": {
          const s19 = this._cp2(e17, 3, -2), t17 = [Math.min(_4[0], s19[0]), Math.max(_4[1], s19[1])], i18 = [Math.max(_4[0], s19[0]), Math.min(_4[1], s19[1])], h8 = i18[0] - t17[0], r14 = t17[1] - i18[1], c5 = Math.min(h8, r14) / 10, u9 = [];
          u9.push([t17[0] + c5 + 0.75 * (h8 - 2 * c5), t17[1]]), u9.push([i18[0] - c5, t17[1]]), this._add90DegArc(u9, [i18[0] - c5, t17[1]], [i18[0], t17[1] - c5], [i18[0], t17[1]]), u9.push([i18[0], i18[1] + c5]), this._add90DegArc(u9, [i18[0], i18[1] + c5], [i18[0] - c5, i18[1]], i18), u9.push([t17[0] + c5, i18[1]]), this._add90DegArc(u9, [t17[0] + c5, i18[1]], [t17[0], i18[1] + c5], [t17[0], i18[1]]), u9.push([t17[0], t17[1] - c5]), this._add90DegArc(u9, [t17[0], t17[1] - c5], [t17[0] + c5, t17[1]], t17), u9.push([t17[0] + c5 + 0.75 * (h8 - 2 * c5), t17[1]]);
          break;
        }
        default:
          t16.push(e17);
      }
    }
    return t16;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectCut.js
var _r = class _r {
  static local() {
    return null === _r.instance && (_r.instance = new _r()), _r.instance;
  }
  execute(e17, t16, i18) {
    return new u5(e17, t16, i18);
  }
};
_r.instance = null;
var r4 = _r;
var u5 = class extends r2 {
  constructor(e17, t16, r13) {
    super(e17, true, true), this._curveHelper = new n4(), this._beginCut = (void 0 !== t16.beginCut ? t16.beginCut : 1) * r13, this._endCut = (void 0 !== t16.endCut ? t16.endCut : 1) * r13, this._middleCut = (void 0 !== t16.middleCut ? t16.middleCut : 0) * r13, this._invert = void 0 !== t16.invert && t16.invert, this._beginCut < 0 && (this._beginCut = 0), this._endCut < 0 && (this._endCut = 0), this._middleCut < 0 && (this._middleCut = 0);
  }
  processPath(t16) {
    const { _beginCut: i18, _endCut: r13, _middleCut: u9 } = this, s17 = t16.pathLength(), n23 = a2.createEmptyOptimizedCIM("esriGeometryPolyline");
    if (this._invert) {
      if (0 !== i18 || 0 !== r13 || 0 !== u9) if (i18 + r13 + u9 >= s17) for (n23.startPath(); t16.nextPoint(); ) n23.pushXY(t16.x, t16.y);
      else this._curveHelper.appendSubCurve(n23, t16, 0, i18), this._curveHelper.appendSubCurve(n23, t16, 0.5 * (s17 - u9), 0.5 * (s17 + u9)), this._curveHelper.appendSubCurve(n23, t16, s17 - r13, r13);
    } else if (0 === i18 && 0 === r13 && 0 === u9) for (n23.startPath(); t16.nextPoint(); ) n23.pushXY(t16.x, t16.y);
    else i18 + r13 + u9 < s17 && (0 === u9 ? this._curveHelper.appendSubCurve(n23, t16, i18, s17 - r13) : (this._curveHelper.appendSubCurve(n23, t16, i18, 0.5 * (s17 - u9)), this._curveHelper.appendSubCurve(n23, t16, 0.5 * (s17 + u9), s17 - r13)));
    return 0 === n23.totalSize ? null : n23;
  }
};

// node_modules/@arcgis/core/symbols/cim/GeometryWalker.js
var i9 = 1e-7;
var n6 = class {
  constructor() {
    this._values = [], this.extPtGap = 0, this.ctrlPtGap = 0, this._length = 0, this._currentValue = 0;
  }
  isEmpty() {
    return 0 === this._values.length;
  }
  size() {
    return this._values.length;
  }
  init(t16, e17, s17 = true) {
    if (this._setEmpty(), !t16 || 0 === t16.length) return false;
    for (let n23 = 0; n23 < t16.length; n23++) {
      let e18 = Math.abs(t16[n23]);
      s17 && e18 < i9 && (e18 = i9), this._values.push(e18), this._length += e18;
    }
    return e17 && 1 & t16.length && (this._length *= 2), 0 !== this._length && (this.ctrlPtGap = this.extPtGap = 0, this._currentValue = -1, true);
  }
  scale(t16) {
    const e17 = this._values ? this._values.length : 0;
    for (let s17 = 0; s17 < e17; ++s17) this._values[s17] *= t16;
    this._length *= t16, this.extPtGap *= t16, this.ctrlPtGap *= t16;
  }
  addValue(t16) {
    this._length += t16, this._values.push(t16);
  }
  firstValue() {
    return this._values[0];
  }
  lastValue() {
    return this._values[this._values.length - 1];
  }
  nextValue() {
    return this._currentValue++, this._currentValue === this._values.length && (this._currentValue = 0), this._values[this._currentValue];
  }
  reset() {
    this._currentValue = -1;
  }
  length() {
    return this._length;
  }
  _setEmpty() {
    this.extPtGap = this.ctrlPtGap = this._length = 0, this._currentValue = -1, this._values.length = 0;
  }
};
var h3 = class {
  constructor() {
    this.pt = null, this.ca = 0, this.sa = 0;
  }
};
var r5 = class {
  constructor() {
    this.reset();
  }
  reset() {
    this.segment = null, this.segmentLength = 0, this.abscissa = 0, this.isPathEnd = false, this.isPartEnd = false;
  }
  isValid() {
    return null !== this.segment;
  }
  copyTo(t16) {
    t16.segment = this.segment, t16.segmentLength = this.segmentLength, t16.abscissa = this.abscissa, t16.isPathEnd = this.isPathEnd, t16.isPartEnd = this.isPartEnd;
  }
};
var a4 = class extends n4 {
  constructor(t16 = 0, e17 = false) {
    super(t16, e17), this._tempPos = new r5(), this._tempPt = [0, 0], this._tolerance = e8, this._currentPosition = new r5();
  }
  updateTolerance(t16) {
    this._tolerance = e8 * t16;
  }
  init(t16, e17, s17 = true) {
    return s17 ? (this._patternLength = e17.length(), this._partExtPtGap = e17.extPtGap, this._partCtrlPtGap = e17.ctrlPtGap) : (this._patternLength = 0, this._partExtPtGap = 0, this._partCtrlPtGap = 0), this._currentPosition.reset(), this._partSegCount = 0, this._pathCursor = t16, this._seg = -1, this._setPosAtNextPart();
  }
  curPositionIsValid() {
    return this._currentPosition.isValid();
  }
  nextPosition(t16, e17 = 0) {
    const s17 = new r5();
    return !!this._nextPosition(t16, s17, null, e17) && (s17.copyTo(this._currentPosition), true);
  }
  curPointAndAngle(t16) {
    t16.pt = this._getPoint(this._currentPosition);
    const [e17, s17] = this._getAngleCS(this._tempPt, this._currentPosition);
    t16.ca = e17, t16.sa = s17;
  }
  nextPointAndAngle(t16, e17, s17 = 0) {
    const i18 = this._tempPos;
    if (!this._nextPosition(t16, i18, null, s17)) return false;
    i18.copyTo(this._currentPosition), e17.pt = this._getPoint(i18);
    const [n23, h8] = this._getAngleCS(this._tempPt, i18);
    return e17.ca = n23, e17.sa = h8, true;
  }
  nextCurve(e17) {
    if (0 === e17) return null;
    const s17 = a2.createEmptyOptimizedCIM("esriGeometryPolyline");
    s17.startPath(), s17.nextPath();
    const i18 = new r5();
    return this._nextPosition(e17, i18, s17, 1) ? (i18.copyTo(this._currentPosition), s17) : null;
  }
  isPathEnd() {
    return this._currentPosition.isPathEnd;
  }
  getPathEnd() {
    return this._currentPosition.segment[1];
  }
  getPt(t16) {
    return this._pathCursor.seekInPath(t16), [this._pathCursor.x, this._pathCursor.y];
  }
  getSeg(t16) {
    return [this.getPt(t16), this.getPt(t16 + 1)];
  }
  _nextPosition(t16, e17, s17, i18) {
    if (this._currentPosition.isPathEnd) return false;
    let n23 = this._currentPosition.abscissa;
    for (this._currentPosition.segmentLength > 0 && (n23 /= this._currentPosition.segmentLength), this._currentPosition.copyTo(e17); e17.abscissa + t16 * this._partLengthRatio > e17.segmentLength + this._tolerance; ) {
      if (s17) {
        if (0 === s17.pathSize) if (0 === n23) {
          const t18 = e17.segment[0];
          s17.pushXY(t18[0], t18[1]);
        } else s17.pushPoint(this.getSegCoord2D(e17.segment, n23));
        const t17 = e17.segment[1];
        s17.pushXY(t17[0], t17[1]);
      }
      if (n23 = 0, t16 -= (e17.segmentLength - e17.abscissa) / this._partLengthRatio, this._partSegCount) e17.segment = this._nextSegment(), e17.segmentLength = this.getSegLength(e17.segment), e17.abscissa = 0, this._partSegCount--;
      else {
        if (!this._setPosAtNextPart()) return 0 !== i18 && (e17.segmentLength = this.getSegLength(e17.segment), e17.isPartEnd = true, 1 === i18 ? (e17.abscissa = e17.segmentLength, e17.isPathEnd = true) : e17.abscissa = e17.segmentLength + t16, true);
        this._currentPosition.copyTo(e17);
      }
    }
    if (e17.abscissa += t16 * this._partLengthRatio, s17) {
      0 === s17.pathSize && (0 === n23 ? s17.pushPoint(e17.segment[0]) : s17.pushPoint(this.getSegCoord2D(e17.segment, n23)));
      const t17 = e17.abscissa / e17.segmentLength;
      1 === t17 ? s17.pushPoint(e17.segment[1]) : s17.pushPoint(this.getSegCoord2D(e17.segment, t17));
    }
    return this._partSegCount || Math.abs(e17.abscissa - e17.segmentLength) < this._tolerance && (e17.isPathEnd = this._partIsLast, e17.isPartEnd = true), true;
  }
  _getPoint(t16) {
    const e17 = t16.segmentLength <= 0 ? 0 : t16.abscissa / t16.segmentLength;
    return this.getSegCoord2D(this._currentPosition.segment, e17);
  }
  _getAngleCS(t16, e17) {
    const s17 = e17.segmentLength <= 0 ? 0 : e17.abscissa / e17.segmentLength;
    return this.getSegAngleCS(t16, this._currentPosition.segment, s17);
  }
  _setPosAtNextPart() {
    for (; this._partSegCount; ) this._hasNextSegment() && this._nextSegment(), this._partSegCount--;
    if (!this._hasNextSegment()) return false;
    for (this._partLength = 0, this._partIsLast = true, this._partSegCount = 0; this._hasNextSegment(); ) if (this._partLength += this.getSegLength(this._nextSegment()), this._partSegCount++, this._pathCursor.getControlPointAt(this._getEndPointIndex())) {
      this._partIsLast = !this._hasNextSegment();
      break;
    }
    let t16 = this._partSegCount;
    for (; t16; ) this._previousSegment(), --t16;
    this._currentPosition.segment = this._nextSegment(), this._currentPosition.segmentLength = this.getSegLength(this._currentPosition.segment), this._currentPosition.abscissa = 0, this._currentPosition.isPathEnd = this._currentPosition.isPartEnd = false, --this._partSegCount;
    const e17 = this._getStartPointIndex();
    this._ctrlPtBegin = this._pathCursor.getControlPointAt(e17);
    let s17 = e17 + this._partSegCount + 1;
    if (s17 >= this._pathCursor.pathSize && (s17 = 0), this._ctrlPtEnd = this._pathCursor.getControlPointAt(s17), this._patternLength > 0) {
      const t17 = this._ctrlPtBegin ? this._partCtrlPtGap : this._partExtPtGap, e18 = this._ctrlPtEnd ? this._partCtrlPtGap : this._partExtPtGap;
      let s18 = Math.round((this._partLength - (t17 + e18)) / this._patternLength);
      s18 <= 0 && (s18 = t17 + e18 > 0 ? 0 : 1), this._partLengthRatio = this._partLength / (t17 + e18 + s18 * this._patternLength), this._partLengthRatio < 0.01 && (this._partLengthRatio = 1);
    } else this._partLengthRatio = 1;
    return true;
  }
  _hasNextSegment() {
    return this._seg < this._pathCursor.pathSize - 2;
  }
  _previousSegment() {
    return this.getSeg(--this._seg);
  }
  _nextSegment() {
    return this.getSeg(++this._seg);
  }
  _getStartPointIndex() {
    return this._seg;
  }
  _getEndPointIndex() {
    return this._seg + 1;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectDashes.js
var _n = class _n {
  static local() {
    return null === _n.instance && (_n.instance = new _n()), _n.instance;
  }
  execute(t16, e17, s17) {
    return new h4(t16, e17, s17);
  }
};
_n.instance = null;
var n7 = _n;
var h4 = class extends r2 {
  constructor(t16, e17, s17) {
    super(t16, true, true), this._firstCurve = null, this._walker = new a4(), this._walker.updateTolerance(s17), this._endings = e17.lineDashEnding, this._customDashPos = -(e17.offsetAlongLine ?? 0) * s17, this._offsetAtEnd = (e17.customEndingOffset ?? 0) * s17;
    let n23 = B(e17).dashTemplate;
    null == n23 && (n23 = []), n23.length % 2 && (n23 = [...n23, ...n23]), this._pattern = new n6(), this._pattern.init(n23, true), this._pattern.scale(s17);
  }
  processPath(s17) {
    if (0 === this._pattern.length()) {
      this.iteratePath = false;
      const i19 = n(s17);
      return a2.fromJSONCIM({ paths: [i19] });
    }
    if (!this.iteratePath) {
      let i19 = true;
      switch (this._endings) {
        case "HalfPattern":
        case "HalfGap":
        default:
          this._pattern.extPtGap = 0;
          break;
        case "FullPattern":
          this.isClosed || (this._pattern.extPtGap = 0.5 * this._pattern.firstValue());
          break;
        case "FullGap":
          this.isClosed || (this._pattern.extPtGap = 0.5 * this._pattern.lastValue());
          break;
        case "NoConstraint":
          this.isClosed || (i19 = false);
          break;
        case "Custom":
          this.isClosed || (this._pattern.extPtGap = 0.5 * this._offsetAtEnd);
      }
      const r14 = s17.pathLength();
      if (this._pattern.isEmpty() || r14 < 0.1 * this._pattern.length()) {
        const i20 = n(s17);
        return a2.fromJSONCIM({ paths: [i20] });
      }
      if (!this._walker.init(s17, this._pattern, i19)) {
        const i20 = n(s17);
        return a2.fromJSONCIM({ paths: [i20] });
      }
    }
    let i18;
    if (this.iteratePath) i18 = this._pattern.nextValue();
    else {
      let t16;
      switch (this._endings) {
        case "HalfPattern":
        default:
          t16 = 0.5 * this._pattern.firstValue();
          break;
        case "HalfGap":
          t16 = 0.5 * -this._pattern.lastValue();
          break;
        case "FullGap":
          t16 = -this._pattern.lastValue();
          break;
        case "FullPattern":
          t16 = 0;
          break;
        case "NoConstraint":
        case "Custom":
          t16 = -this._customDashPos;
      }
      let e17 = t16 / this._pattern.length();
      e17 -= Math.floor(e17), t16 = e17 * this._pattern.length(), this._pattern.reset(), i18 = this._pattern.nextValue();
      let s18 = false;
      for (; t16 >= i18; ) t16 -= i18, i18 = this._pattern.nextValue(), s18 = !s18;
      i18 -= t16, s18 ? (this._walker.nextPosition(i18), i18 = this._pattern.nextValue()) : this.isClosed && (this._firstCurve = this._walker.nextCurve(i18), i18 = this._pattern.nextValue(), this._walker.nextPosition(i18), i18 = this._pattern.nextValue());
    }
    let r13 = this._walker.nextCurve(i18);
    if (r13) if (this._walker.isPathEnd()) {
      if (this.iteratePath = false, this._firstCurve) {
        for (this._firstCurve.nextPath(); this._firstCurve.nextPoint(); ) r13.pushXY(this._firstCurve.x, this._firstCurve.y);
        this._firstCurve = null;
      }
    } else i18 = this._pattern.nextValue(), !this._walker.nextPosition(i18) || this._walker.isPathEnd() ? (this.iteratePath = false, this._firstCurve && (r13.pushCursor(this._firstCurve), this._firstCurve = null)) : this.iteratePath = true;
    else this.iteratePath = false, r13 = this._firstCurve, this._firstCurve = null;
    return r13?.reset(), r13;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectDonut.js
var _s = class _s {
  static local() {
    return null === _s.instance && (_s.instance = new _s()), _s.instance;
  }
  execute(t16, i18, e17, n23, s17, h8) {
    return new r6(t16, i18, e17, n23, s17, h8);
  }
};
_s.instance = null;
var s8 = _s;
var r6 = class {
  constructor(t16, i18, e17, n23, s17, r13) {
    this._preventClipping = r13, this._inputGeometries = t16, this._tileKey = n23, this._maxInflateSize = s17 * e17, this._width = (void 0 !== i18.width ? i18.width : 2) * e17, i18.method, this._option = i18.option;
  }
  next() {
    let s17;
    for (; s17 = this._inputGeometries.next(); ) {
      if ("esriGeometryEnvelope" === s17.geometryType && this._width > 0) {
        const i18 = s17.asJSON();
        return Math.min(i18.xmax - i18.xmin, i18.ymax - i18.ymin) - 2 * this._width < 0 ? s17 : a2.fromJSONCIM({ paths: [[[i18.xmin + this._width, i18.ymin + this._width], [i18.xmax - this._width, i18.ymin + this._width], [i18.xmax - this._width, i18.ymax - this._width], [i18.xmin + this._width, i18.ymax - this._width], [i18.xmin + this._width, i18.ymin + this._width]], [[i18.xmin, i18.ymin], [i18.xmin, i18.ymax], [i18.xmax, i18.ymax], [i18.xmax, i18.ymin], [i18.xmin, i18.ymin]]] });
      }
      if ("esriGeometryPolygon" === s17.geometryType) {
        if (0 === this._width) return s17.clone();
        const t16 = o3.module, r13 = !this._preventClipping && this._tileKey ? y3(s17, this._maxInflateSize, true) : s17.clone();
        if (!r13) continue;
        const h8 = { ...r13.asJSON(), spatialReference: { wkid: f.WebMercator.wkid } }, o9 = t16.execute(h8, -this._width);
        if (o9) {
          for (const i18 of o9.rings) if (i18) {
            r13.startPath();
            for (const t17 of i18.reverse()) r13.pushXY(t17[0], r13.yFactor * t17[1]);
          }
        }
        return r13;
      }
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectEnclosingPolygon.js
var _o = class _o {
  static local() {
    return null === _o.instance && (_o.instance = new _o()), _o.instance;
  }
  execute(e17, t16) {
    return new s9(e17, t16);
  }
};
_o.instance = null;
var o4 = _o;
var s9 = class {
  constructor(e17, t16) {
    this._inputGeometries = e17, this._medhod = t16.method;
  }
  next() {
    let e17 = this._inputGeometries.next();
    const t16 = this._medhod;
    for (; null != e17; ) {
      if (e17.totalSize > 0) switch (t16) {
        case "RectangularBox":
          return i10(e17);
        case "ConvexHull":
          return this._constructConvexHull(e17);
        default:
          return u6(e17);
      }
      e17 = this._inputGeometries.next();
    }
    return null;
  }
  _constructConvexHull(r13) {
    switch (r13.geometryType) {
      case "esriGeometryPolyline":
      case "esriGeometryPolygon": {
        const o9 = s7.module, s17 = { ...r13.asJSON(), spatialReference: { wkid: f.WebMercator.wkid } }, i18 = o9.execute(s17);
        return i18 ? a2.fromJSONCIM(i18) : null;
      }
      case "esriGeometryEnvelope":
        return r13;
      default:
        return null;
    }
  }
};
function i10(t16) {
  const n23 = x(t16), o9 = { xmin: n23[0], ymin: n23[1], xmax: n23[2], ymax: n23[3] };
  return a2.fromJSONCIM(o9);
}
function u6(t16) {
  switch (t16.geometryType) {
    case "esriGeometryPolyline": {
      const r13 = [];
      for (; t16.nextPath(); ) l9(t16, r13);
      return a2.fromJSONCIM({ rings: r13 });
    }
    case "esriGeometryPolygon":
    case "esriGeometryEnvelope":
      return t16;
    default:
      return null;
  }
}
function l9(e17, t16) {
  if (e17.seekPathStart(), !e17.nextPoint()) return;
  const r13 = e17.x, n23 = e17.y, o9 = [[r13, n23]];
  for (t16.push(o9); e17.nextPoint(); ) o9.push([e17.x, e17.y]);
  o9.push([r13, n23]);
}

// node_modules/@arcgis/core/symbols/cim/effects/EffectJog.js
var _e3 = class _e3 {
  static local() {
    return null === _e3.instance && (_e3.instance = new _e3()), _e3.instance;
  }
  execute(t16, i18, s17) {
    return new n8(t16, i18, s17);
  }
};
_e3.instance = null;
var e10 = _e3;
var n8 = class extends r2 {
  constructor(t16, i18, e17) {
    super(t16, false, true), this._curveHelper = new n4(), this._length = (void 0 !== i18.length ? i18.length : 20) * e17, this._angle = void 0 !== i18.angle ? i18.angle : 225, this._position = void 0 !== i18.position ? i18.position : 50, this._length < 0 && (this._length = -this._length), this._position < 20 && (this._position = 20), this._position > 80 && (this._position = 80), this._mirror = false;
  }
  processPath(i18) {
    const s17 = a2.createEmptyOptimizedCIM("esriGeometryPolyline");
    if (this._curveHelper.isEmpty(i18)) return null;
    i18.seekInPath(0);
    const e17 = i18.x, n23 = i18.y;
    i18.seekInPath(i18.pathSize - 1);
    const o9 = i18.x, r13 = i18.y, h8 = [o9 - e17, r13 - n23];
    this._curveHelper.normalize(h8);
    const l12 = e17 + (o9 - e17) * this._position / 100, a11 = n23 + (r13 - n23) * this._position / 100, _4 = Math.cos((90 - this._angle) / 180 * Math.PI);
    let p6 = Math.sin((90 - this._angle) / 180 * Math.PI);
    this._mirror && (p6 = -p6), this._mirror = !this._mirror;
    const c5 = [l12 - this._length / 2 * _4, a11 - this._length / 2 * p6], m5 = [l12 + this._length / 2 * _4, a11 + this._length / 2 * p6];
    return s17.pushPath([[e17, n23], c5, m5, [o9, r13]]), s17;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectMove.js
var _t = class _t {
  static local() {
    return null === _t.instance && (_t.instance = new _t()), _t.instance;
  }
  execute(t16, s17, n23) {
    return new e11(t16, s17, n23);
  }
};
_t.instance = null;
var t7 = _t;
var e11 = class {
  constructor(t16, e17, s17) {
    this._inputGeometries = t16, this._offsetX = void 0 !== e17.offsetX ? e17.offsetX * s17 : 0, this._offsetY = void 0 !== e17.offsetY ? e17.offsetY * s17 : 0;
  }
  next() {
    let t16 = this._inputGeometries.next();
    for (; t16; ) {
      if (t16.totalSize > 0) return this._move(t16.clone(), this._offsetX, this._offsetY);
      t16 = this._inputGeometries.next();
    }
    return null;
  }
  _move(t16, e17, s17) {
    for (; t16.nextPath(); ) for (; t16.nextPoint(); ) t16.x = t16.x + e17, t16.y = t16.y + s17;
    return t16.reset(), t16;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectOffset.js
var a5 = 10;
var _l = class _l {
  static local() {
    return null === _l.instance && (_l.instance = new _l()), _l.instance;
  }
  execute(e17, t16, r13, s17, i18, o9) {
    return new h5(e17, t16, r13, s17, i18, o9);
  }
};
_l.instance = null;
var l10 = _l;
var h5 = class {
  constructor(e17, t16, r13, s17, i18, o9) {
    this._preventClipping = o9, this._inputGeometries = e17, this._tileKey = s17, this._curveHelper = new n4(), this._offset = (t16.offset ?? 1) * r13, this._method = t16.method, this._maxInflateSize = Math.max(Math.abs(i18 * r13), a5), this._option = t16.option, this._offsetFlattenError = e8 * r13;
  }
  next() {
    let f6;
    for (; f6 = this._inputGeometries.next(); ) {
      if (0 === this._offset) return f6.clone();
      if ("esriGeometryEnvelope" === f6.geometryType) {
        if ("Rounded" === this._method && this._offset > 0) {
          const r14 = n(f6), s17 = this._curveHelper.offset(r14, -this._offset, this._method, 4, this._offsetFlattenError);
          if (s17) {
            const t16 = a2.createEmptyOptimizedCIM(f6.geometryType);
            return t16.pushPath(s17), t16;
          }
          return null;
        }
        const r13 = f6.asJSON();
        if (m(r13) && Math.min(r13.xmax - r13.xmin, r13.ymax - r13.ymin) + 2 * this._offset > 0) return a2.fromJSONCIM({ xmin: r13.xmin - this._offset, xmax: r13.xmax + this._offset, ymin: r13.ymin - this._offset, ymax: r13.ymax + this._offset });
      }
      const m5 = !this._preventClipping && this._tileKey ? y3(f6, this._maxInflateSize, true) : f6.clone();
      if (!m5) continue;
      const a11 = p3.module, l12 = n5.module, h8 = { ...m5.asJSON(), spatialReference: { wkid: f.WebMercator.wkid } };
      let c5, p6 = u7(this._method);
      return "esriGeometryPolygon" === f6.geometryType && this._offset > 0 ? ("square" === p6 && (p6 = "bevel"), c5 = l12.executeMany([h8], [this._offset], p6, "round")[0]) : c5 = a11.execute(h8, -this._offset, { joins: p6, flattenError: this._offsetFlattenError, miterLimit: 4 }), c5 ? a2.fromJSONCIM(c5) : null;
    }
    return null;
  }
};
function u7(e17) {
  switch (e17) {
    case "Rounded":
      return "round";
    case "Bevelled":
      return "bevel";
    case "Mitered":
      return "miter";
    case "Square":
      return "square";
  }
}

// node_modules/@arcgis/core/symbols/cim/effects/EffectRadial.js
var _n2 = class _n2 {
  static local() {
    return null === _n2.instance && (_n2.instance = new _n2()), _n2.instance;
  }
  execute(t16, e17, i18) {
    return new r7(t16, e17, i18);
  }
};
_n2.instance = null;
var n9 = _n2;
var r7 = class {
  constructor(t16, e17, n23) {
    this._inputGeometries = t16, this._length = (void 0 !== e17.length ? e17.length : o2.CIMGeometricEffectRadial.length) * n23, this._angle = void 0 !== e17.angle ? e17.angle * Math.PI / 180 : o2.CIMGeometricEffectRadial.angle, this._lx = Math.cos(this._angle) * this._length, this._ly = Math.sin(this._angle) * this._length;
  }
  next() {
    let i18 = this._inputGeometries.next();
    for (; i18; ) {
      if ("esriGeometryPoint" === i18.geometryType || "esriGeometryMultipoint" === i18.geometryType) {
        const e17 = a2.createEmptyOptimizedCIM("esriGeometryPolyline");
        return i18.nextPath() && i18.nextPoint() && e17.pushPath([[i18.x, i18.y], [i18.x + this._lx, i18.y + this._ly]]), e17;
      }
      if ("esriGeometryPolygon" === i18.geometryType) {
        const n23 = I(i18);
        if (!n23) return null;
        const r13 = a2.createEmptyOptimizedCIM("esriGeometryPolyline");
        return r13.pushPath([[n23[0], n23[1]], [n23[0] + this._lx, n23[1] + this._ly]]), r13;
      }
      i18 = this._inputGeometries.next();
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectReverse.js
var _e4 = class _e4 {
  static local() {
    return null === _e4.instance && (_e4.instance = new _e4()), _e4.instance;
  }
  execute(e17, n23, r13) {
    return new t8(e17, n23, r13);
  }
};
_e4.instance = null;
var e12 = _e4;
var t8 = class {
  constructor(e17, t16, n23) {
    this._inputGeometries = e17, this._reverse = void 0 === t16.reverse || t16.reverse;
  }
  next() {
    let e17 = this._inputGeometries.next();
    for (; e17; ) {
      if (!this._reverse) return e17;
      if ("esriGeometryPolyline" === e17.geometryType) return n10(e17.clone());
      e17 = this._inputGeometries.next();
    }
    return null;
  }
};
function n10(e17) {
  for (; e17.nextPath(); ) for (let t16 = 0; t16 < e17.pathSize / 2; t16++) {
    e17.seekInPath(t16);
    const n23 = e17.x, r13 = e17.y;
    e17.seekInPath(e17.pathSize - t16 - 1);
    const s17 = e17.x, i18 = e17.y;
    e17.x = n23, e17.y = r13, e17.seekInPath(t16), e17.x = s17, e17.y = i18;
  }
  return e17.reset(), e17;
}

// node_modules/@arcgis/core/symbols/cim/effects/EffectRotate.js
var _e5 = class _e5 {
  static local() {
    return null === _e5.instance && (_e5.instance = new _e5()), _e5.instance;
  }
  execute(t16, e17, r13) {
    return new n11(t16, e17, r13);
  }
};
_e5.instance = null;
var e13 = _e5;
var n11 = class {
  constructor(t16, e17, n23) {
    this._inputGeometries = t16, this._rotateAngle = void 0 !== e17.angle ? e17.angle * Math.PI / 180 : 0;
  }
  next() {
    let e17 = this._inputGeometries.next();
    for (; e17; ) {
      if (0 === this._rotateAngle || "esriGeometryPoint" === e17.geometryType) return e17;
      if (e17.totalSize > 0) {
        const n23 = x(e17), r13 = (n23[2] + n23[0]) / 2, s17 = (n23[3] + n23[1]) / 2;
        return e17.reset(), this._rotate(e17.clone(), r13, s17);
      }
      e17 = this._inputGeometries.next();
    }
    return null;
  }
  _rotate(t16, e17, n23) {
    const r13 = Math.cos(this._rotateAngle), s17 = Math.sin(this._rotateAngle);
    for (; t16.nextPath(); ) for (; t16.nextPoint(); ) {
      const o9 = t16.x - e17, i18 = t16.y - n23;
      t16.x = e17 + o9 * r13 - i18 * s17, t16.y = n23 + o9 * s17 + i18 * r13;
    }
    return t16.reset(), t16;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectScale.js
var _e6 = class _e6 {
  static local() {
    return null === _e6.instance && (_e6.instance = new _e6()), _e6.instance;
  }
  execute(t16, e17, s17) {
    return new r8(t16, e17, s17);
  }
};
_e6.instance = null;
var e14 = _e6;
var r8 = class {
  constructor(t16, e17, r13) {
    this._inputGeometries = t16, this._xFactor = void 0 !== e17.xScaleFactor ? e17.xScaleFactor : 1.15, this._yFactor = void 0 !== e17.yScaleFactor ? e17.yScaleFactor : 1.15;
  }
  next() {
    const e17 = this._inputGeometries.next();
    if (e17) {
      if (1 === this._xFactor && 1 === this._yFactor) return e17;
      if ("esriGeometryPoint" === e17.geometryType) return e17;
      if (e17.totalSize > 0) {
        const r13 = x(e17), s17 = (r13[2] + r13[0]) / 2, o9 = (r13[3] + r13[1]) / 2;
        return e17.reset(), this._scaleCursor(e17.clone(), s17, o9);
      }
    }
    return null;
  }
  _scaleCursor(t16, e17, r13) {
    for (; t16.nextPath(); ) for (; t16.nextPoint(); ) t16.x = e17 + (t16.x - e17) * this._xFactor, t16.y = r13 + (t16.y - r13) * this._yFactor;
    return t16.reset(), t16;
  }
};

// node_modules/@arcgis/core/geometry/support/PolylineBuilder.js
var t9 = class {
  constructor() {
    this._polyline = [];
  }
  beginPath(t16) {
    this._polyline.push([t16]);
  }
  lineTo(t16) {
    if (0 === this._polyline.length) throw new Error("No path started. Call beginPath first.");
    this._polyline[this._polyline.length - 1].push(t16);
  }
  getPointCount() {
    return this._polyline.reduce((t16, e17) => t16 + e17.length, 0);
  }
  addSegment(t16, e17, l12) {
    l12 && this.beginPath(t16), this.lineTo(e17);
  }
  getXY(t16) {
    let e17 = 0;
    for (const l12 of this._polyline) {
      if (t16 < e17 + l12.length) return l12[t16 - e17];
      e17 += l12.length;
    }
    return null;
  }
  getGeometry() {
    return this._polyline;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectSuppress.js
var _r2 = class _r2 {
  static local() {
    return null === _r2.instance && (_r2.instance = new _r2()), _r2.instance;
  }
  execute(t16, e17, n23) {
    return new s10(t16, e17, n23);
  }
};
_r2.instance = null;
var r9 = _r2;
var s10 = class extends r2 {
  constructor(t16, e17, n23) {
    super(t16, false, true), this._suppress = void 0 !== e17.suppress && e17.suppress, this._invert = void 0 !== e17.invert && e17.invert;
  }
  processPath(n23) {
    if (n23.totalSize <= 0) return null;
    if (!this._suppress) {
      const e17 = a2.createEmptyOptimizedCIM("esriGeometryPolygon", false, false, n23.yFactor);
      for (n23.seekPathEnd(); n23.nextPoint(); ) e17.pushXY(n23.x, n23.y);
      return e17;
    }
    const r13 = [], s17 = new Array(n23.pathSize);
    let o9 = 0;
    for (n23.seekPathStart(); n23.nextPoint(); ) s17[o9++] = n23.getControlPoint(), r13.push([n23.x, n23.y]);
    let i18 = true, l12 = true, h8 = false, p6 = !this._invert;
    o9 = 0;
    const u9 = new t9();
    let c5 = r13[0];
    for (; o9 < r13.length; ) {
      const t16 = r13[o9 + 1], e17 = s17[o9], n24 = s17[o9 + 1];
      o9++, l12 && (p6 = e17 || n24 ? this._invert : !this._invert, l12 = false), p6 ? (u9.addSegment(c5, t16, i18), i18 = false) : h8 = true, c5 = t16, n24 && (p6 ? (p6 = false, i18 = true) : p6 = true);
    }
    const a11 = u9.getGeometry();
    if (0 === a11.length) return null;
    if (!h8 && r13[0][0] === r13[r13.length - 1][0] && r13[0][1] === r13[r13.length - 1][1]) {
      const e17 = a11[a11.length - 1];
      return e17[0][0] === e17[e17.length - 1][0] && e17[0][1] === e17[e17.length - 1][1] || e17.push([e17[0][0], e17[0][1]]), a2.fromJSONCIM({ paths: a11 });
    }
    const g5 = a11[a11.length - 1];
    return u9.getPointCount() > 1 && "esriGeometryPolygon" === n23.geometryType && g5[0][0] === g5[g5.length - 1][0] && g5[0][1] === g5[g5.length - 1][1] && a11.length > 1 && (a11[a11.length - 1].push(...a11[0]), a11.splice(0, 1)), a2.fromJSONCIM({ paths: a11 });
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectTaperedPolygon.js
var p4 = () => i.getLogger("esri.symbols.cim.effects.EffectTaperedPolygon");
var _y = class _y {
  static local() {
    return null === _y.instance && (_y.instance = new _y()), _y.instance;
  }
  execute(e17, t16, s17) {
    return new f5(e17, t16, s17);
  }
};
_y.instance = null;
var y4 = _y;
var f5 = class extends r2 {
  constructor(e17, t16, s17) {
    super(e17, false, true), this._slopeS = 0, this._slopeC = 1, this._lastTangent1 = new i3(NaN, NaN), this._lastWidth = 0, this._geomUnitsPerPoint = s17, this._halfFromWidth = Math.abs(void 0 !== t16.fromWidth ? t16.fromWidth : 0) * s17 * 0.5, this._halfToWidth = Math.abs(void 0 !== t16.toWidth ? t16.toWidth : 1) * s17 * 0.5, this._originalLength = (void 0 !== t16.length ? t16.length : 0) * s17, this._length = 0;
  }
  processPath(t16) {
    if (t16.totalSize <= 0) return null;
    if (this._halfFromWidth <= 0 && this._halfToWidth <= 0) {
      const e17 = a2.createEmptyOptimizedCIM("esriGeometryPolygon", false, false, t16.yFactor);
      for (t16.seekPathEnd(); t16.prevPoint(); ) e17.pushXY(t16.x, t16.y);
      for (t16.seekPathStart(); t16.nextPoint(); ) e17.pushXY(t16.x, t16.y);
      return e17;
    }
    const n23 = t16.getCurrentPath().asJSON(), h8 = i8.module.execute(n23, 0.25 * this._geomUnitsPerPoint, { removeDegenerateParts: true }), y6 = null == h8 ? null : y2(h8) ? h8.rings : s3(h8) ? h8.paths : null;
    if (!y6) return p4().error(new s("mapview-bad-resource", "Unable to process geometry")), null;
    const f6 = m2.module.execute(h8);
    if ((0 === this._originalLength || this._originalLength > f6) && f6 > 0) {
      this._length = f6;
      const e17 = (this._halfToWidth - this._halfFromWidth) / this._length;
      if (Math.abs(e17) < 1) {
        const t17 = e17 * e17;
        this._slopeC = Math.sqrt(1 / (1 + t17)), this._slopeS = Math.sqrt(t17 / (1 + t17)), e17 < 0 && (this._slopeS = -this._slopeS);
      } else this._slopeC = this._slopeS = 0.7071;
    } else this._length = this._originalLength, this._slopeC = 1, this._slopeS = 0;
    const m5 = [];
    for (const e17 of y6) {
      const t17 = new t9(), s17 = new t9();
      let o9 = 0;
      this._setFromOffset(e17.slice(0, 2), t17, s17);
      for (let r13 = 0, n24 = 3; n24 <= e17.length; ++r13, ++n24) o9 = this._setOffset(e17.slice(r13, n24), o9, t17, s17);
      this._setToOffset(e17.slice(-2), o9, t17, s17);
      const [i18] = t17.getGeometry(), [l12] = s17.getGeometry();
      m5.push([...i18, ...l12.reverse()]);
    }
    const x3 = { rings: m5, spatialReference: { wkid: f.WebMercator.wkid } }, d = f4.module.execute(x3);
    return a2.fromJSONCIM(d);
  }
  _setFromOffset([[e17, t16], [s17, o9]], i18, l12) {
    const r13 = this._halfFromWidth, h8 = new i3(s17 - e17, o9 - t16).normalize().scale(r13);
    i18.beginPath([e17 - h8.y, t16 + h8.x]), l12.beginPath([e17 + h8.y, t16 - h8.x]);
  }
  _setToOffset([[e17, t16], [s17, o9]], i18, l12, r13) {
    let h8;
    h8 = (i18 += Math.sqrt((s17 - e17) ** 2 + (o9 - t16) ** 2)) >= this._length ? this._halfToWidth : this._halfFromWidth + (this._halfToWidth - this._halfFromWidth) * i18 / this._length;
    const a11 = new i3(s17 - e17, o9 - t16).normalize().scale(h8);
    l12.lineTo([s17 - a11.y, o9 + a11.x]), r13.lineTo([s17 + a11.y, o9 - a11.x]);
  }
  _setOffset([[t16, s17], [o9, i18], [l12, r13]], h8, a11, c5) {
    const _4 = Math.sqrt((o9 - t16) ** 2 + (i18 - s17) ** 2);
    let y6;
    y6 = h8 + _4 >= this._length ? this._halfToWidth : this._halfFromWidth + (this._halfToWidth - this._halfFromWidth) * (h8 + _4) / this._length, h8 += _4;
    const f6 = new i3(o9, i18), m5 = new i3(o9 - t16, i18 - s17).normalize(), x3 = new i3(l12 - o9, r13 - i18).normalize(), d = i3.sub(x3, m5), g5 = a11.getPointCount(), u9 = c5.getPointCount();
    m5.leftPerpendicular(), x3.leftPerpendicular();
    const T4 = m5.x * x3.x + m5.y * x3.y;
    if (T4 > 0.99) {
      const e17 = i3.add(m5, x3).scale(y6 / 2), t17 = e17.clone().rotate(this._slopeC, this._slopeS);
      a11.lineTo([f6.x + t17.x, f6.y + t17.y]);
      const s18 = e17.rotateReverse(this._slopeC, this._slopeS);
      c5.lineTo([f6.x - s18.x, f6.y - s18.y]);
    } else {
      const o10 = m5.x * x3.y - m5.y * x3.x;
      if (d.scale(1 / o10), o10 < 0) {
        d.scale(-y6).rotateReverse(this._slopeC, this._slopeS);
        const t17 = c5.getXY(u9 - 1);
        t17 || p4().error(new s("mapview-bad-resource", "Unable to process geometry, index out of scope"));
        const s18 = i3.add(f6, d).sub(i3.fromArray(t17));
        if (m5.x * s18.y - m5.y * s18.x > 0) {
          const e17 = m5.clone().scale(-y6).rotateReverse(this._slopeC, this._slopeS), t18 = x3.clone().scale(-y6).rotateReverse(this._slopeC, this._slopeS);
          c5.lineTo([f6.x + e17.x, f6.y + e17.y]), c5.lineTo([f6.x, f6.y]), c5.lineTo([f6.x + t18.x, f6.y + t18.y]);
        } else c5.lineTo([f6.x + d.x, f6.y + d.y]);
      } else {
        d.scale(y6).rotate(this._slopeC, this._slopeS);
        const t17 = a11.getXY(g5 - 1);
        t17 || p4().error(new s("mapview-bad-resource", "Unable to process geometry, index out of scope"));
        const s18 = i3.add(f6, d).sub(i3.fromArray(t17));
        if (m5.x * s18.y - m5.y * s18.x > 0) {
          const e17 = m5.clone().scale(y6).rotate(this._slopeC, this._slopeS), t18 = x3.clone().scale(y6).rotate(this._slopeC, this._slopeS);
          a11.lineTo([f6.x + e17.x, f6.y + e17.y]), a11.lineTo([f6.x, f6.y]), a11.lineTo([f6.x + t18.x, f6.y + t18.y]);
        } else a11.lineTo([f6.x + d.x, f6.y + d.y]);
      }
      const i19 = Math.acos(T4);
      let l13 = 1;
      if (y6 > 0.25) {
        const e17 = 2 * Math.acos(1 - 0.25 / y6);
        e17 < i19 && (l13 = Math.round(i19 / e17));
      }
      const r14 = Math.cos(i19 / l13), h9 = Math.sin(i19 / l13), _5 = m5.clone();
      if (o10 < 0) {
        _5.rotate(this._slopeC, this._slopeS);
        const o11 = a11.getXY(g5 - 1);
        o11 || p4().error(new s("mapview-bad-resource", "Unable to process geometry, index out of scope"));
        const i20 = i3.add(f6, _5.clone().scale(this._lastWidth)), l14 = i3.sub(i20, i3.fromArray(o11)), r15 = m5.x * l14.y - m5.y * l14.x;
        if (!isNaN(this._lastTangent1.x) && !isNaN(this._lastTangent1.y) && r15 > 0) {
          const e17 = new i3(t16, s17), o12 = this._lastTangent1.clone().scale(this._lastWidth);
          o12.rotate(this._slopeC, this._slopeS);
          const i21 = m5.clone().scale(this._lastWidth);
          i21.rotate(this._slopeC, this._slopeS), a11.lineTo([e17.x + o12.x, e17.y + o12.y]), a11.lineTo([e17.x, e17.y]), a11.lineTo([e17.x + i21.x, e17.y + i21.y]);
        }
      } else {
        _5.scale(-1).rotateReverse(this._slopeC, this._slopeS);
        const o11 = c5.getXY(u9 - 1);
        o11 || p4().error(new s("mapview-bad-resource", "Unable to process geometry, index out of scope"));
        const i20 = i3.add(f6, _5.clone().scale(this._lastWidth)), l14 = i3.sub(i20, i3.fromArray(o11)), r15 = m5.x * l14.y - m5.y * l14.x;
        if (!isNaN(this._lastTangent1.x) && !isNaN(this._lastTangent1.y) && r15 > 0) {
          const e17 = new i3(t16, s17), o12 = this._lastTangent1.clone().scale(-this._lastWidth);
          o12.rotateReverse(this._slopeC, this._slopeS);
          const i21 = m5.clone().scale(-this._lastWidth);
          i21.rotateReverse(this._slopeC, this._slopeS), c5.lineTo([e17.x + o12.x, e17.y + o12.y]), c5.lineTo([e17.x, e17.y]), c5.lineTo([e17.x + i21.x, e17.y + i21.y]);
        }
      }
      _5.scale(y6);
      for (let e17 = 0; e17 <= l13; e17++) o10 < 0 ? (a11.lineTo([f6.x + _5.x, f6.y + _5.y]), _5.rotateReverse(r14, h9)) : (c5.lineTo([f6.x + _5.x, f6.y + _5.y]), _5.rotate(r14, h9));
    }
    return this._lastTangent1.setCoords(m5.x, m5.y), this._lastWidth = y6, h8;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectWave.js
var _h = class _h {
  static local() {
    return null === _h.instance && (_h.instance = new _h()), _h.instance;
  }
  execute(t16, e17, i18) {
    return new n12(t16, e17, i18);
  }
};
_h.instance = null;
var h6 = _h;
var n12 = class {
  constructor(t16, s17, h8) {
    this._inputGeometries = t16, this._height = (void 0 !== s17.amplitude ? s17.amplitude : 2) * h8, this._period = (void 0 !== s17.period ? s17.period : 3) * h8, this._style = s17.waveform, this._height <= 0 && (this._height = Math.abs(this._height)), this._period <= 0 && (this._period = Math.abs(this._period)), this._pattern = new n6(), this._pattern.addValue(this._period), this._pattern.addValue(this._period), this._walker = new a4(), this._walker.updateTolerance(h8);
  }
  next() {
    let t16 = this._inputGeometries.next();
    for (; t16; ) {
      if (0 === this._height || 0 === this._period) return t16;
      const e17 = this._processGeom(t16);
      if (e17) return e17;
      t16 = this._inputGeometries.next();
    }
    return null;
  }
  _processGeom(e17) {
    const i18 = a2.createEmptyOptimizedCIM(e17.geometryType);
    for (; e17.nextPath(); ) {
      i18.startPath();
      const t16 = e17.pathLength();
      if (this._walker.init(e17, this._pattern)) switch (this._style) {
        case "Sinus":
        default:
          this._constructCurve(i18, t16, false);
          break;
        case "Square":
          this._constructSquare(i18, t16);
          break;
        case "Triangle":
          this._constructTriangle(i18, t16);
          break;
        case "Random":
          this._constructCurve(i18, t16, true);
      }
      else for (; e17.nextPoint(); ) i18.pushXY(e17.x, e17.y);
    }
    return i18;
  }
  _constructCurve(t16, e17, i18) {
    let h8 = Math.round(e17 / this._period);
    0 === h8 && (h8 = 1);
    const n23 = h8 * 16 + 1, r13 = e17 / h8, a11 = this._period / 16, o9 = 1 / n23, p6 = 2 * Math.PI * e17 / r13, _4 = 2 * Math.PI * Math.random(), c5 = 2 * Math.PI * Math.random(), l12 = 2 * Math.PI * Math.random(), u9 = 0.75 - Math.random() / 2, d = 0.75 - Math.random() / 2, g5 = new h3();
    this._walker.curPointAndAngle(g5), t16.pushPoint(g5.pt);
    let w3 = 0;
    for (; ; ) {
      if (!this._walker.nextPointAndAngle(a11, g5)) {
        t16.pushPoint(this._walker.getPathEnd());
        break;
      }
      {
        const e18 = w3;
        let s17;
        if (w3 += o9, i18) {
          const t17 = this._height / 2 * (1 + 0.3 * Math.sin(u9 * p6 * e18 + _4));
          s17 = t17 * Math.sin(p6 * e18 + c5), s17 += t17 * Math.sin(d * p6 * e18 + l12), s17 /= 2;
        } else s17 = 0.5 * this._height * Math.sin(0.5 * p6 * e18);
        t16.pushXY(g5.pt[0] - s17 * g5.sa, g5.pt[1] + s17 * g5.ca);
      }
    }
  }
  _constructSquare(t16, e17) {
    Math.round(e17 / this._period);
    let i18 = true;
    for (; ; ) {
      let e18 = false;
      if (this._walker.curPositionIsValid()) {
        const h8 = new h3();
        this._walker.curPointAndAngle(h8);
        const n23 = new h3();
        if (this._walker.nextPointAndAngle(this._period, n23)) {
          const r13 = new h3();
          this._walker.nextPointAndAngle(this._period, r13) && (i18 ? (t16.pushPoint(h8.pt), i18 = false) : t16.pushPoint(h8.pt), t16.pushXY(h8.pt[0] - this._height / 2 * h8.sa, h8.pt[1] + this._height / 2 * h8.ca), t16.pushXY(n23.pt[0] - this._height / 2 * n23.sa, n23.pt[1] + this._height / 2 * n23.ca), t16.pushXY(n23.pt[0] + this._height / 2 * n23.sa, n23.pt[1] - this._height / 2 * n23.ca), t16.pushXY(r13.pt[0] + this._height / 2 * r13.sa, r13.pt[1] - this._height / 2 * r13.ca), e18 = true);
        }
      }
      if (!e18) {
        t16.pushPoint(this._walker.getPathEnd());
        break;
      }
    }
  }
  _constructTriangle(t16, e17) {
    Math.round(e17 / this._period);
    let i18 = true;
    for (; ; ) {
      let e18 = false;
      if (this._walker.curPositionIsValid()) {
        const h8 = new h3();
        this._walker.curPointAndAngle(h8);
        const n23 = new h3();
        if (this._walker.nextPointAndAngle(this._period / 2, n23)) {
          const r13 = new h3();
          this._walker.nextPointAndAngle(this._period, r13) && (this._walker.nextPosition(this._period / 2) && (i18 ? (t16.pushPoint(h8.pt), i18 = false) : t16.pushPoint(h8.pt), t16.pushXY(n23.pt[0] - this._height / 2 * n23.sa, n23.pt[1] + this._height / 2 * n23.ca), t16.pushXY(r13.pt[0] + this._height / 2 * r13.sa, r13.pt[1] - this._height / 2 * r13.ca)), e18 = true);
        }
      }
      if (!e18) {
        t16.pushPoint(this._walker.getPathEnd());
        break;
      }
    }
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementAlongLineSameSize.js
var _n3 = class _n3 {
  static local() {
    return null === _n3.instance && (_n3.instance = new _n3()), _n3.instance;
  }
  execute(t16, e17, s17) {
    return new a6(t16, e17, s17);
  }
};
_n3.instance = null;
var n13 = _n3;
var a6 = class extends i6 {
  constructor(t16, i18, n23) {
    super(t16), this._geometryWalker = new a4(), this._geometryWalker.updateTolerance(n23), this._angleToLine = i18.angleToLine ?? true, this._offset = (i18.offset ? i18.offset : 0) * n23, this._originalEndings = i18.endings, this._offsetAtEnd = (i18.customEndingOffset ? i18.customEndingOffset : 0) * n23, this._position = -(i18.offsetAlongLine ? i18.offsetAlongLine : 0) * n23, this._pattern = new n6(), this._pattern.init(i18.placementTemplate, false), this._pattern.scale(n23), this._endings = this._originalEndings;
  }
  processPath(t16) {
    if (this._pattern.isEmpty()) return null;
    let e17;
    if (this.iteratePath) e17 = this._pattern.nextValue();
    else {
      "WithFullGap" === this._originalEndings && this.isClosed ? this._endings = "WithMarkers" : this._endings = this._originalEndings, this._pattern.extPtGap = 0;
      let s18, i18 = true;
      switch (this._endings) {
        case "NoConstraint":
          s18 = -this._position, s18 = this._adjustPosition(s18), i18 = false;
          break;
        case "WithHalfGap":
        default:
          s18 = -this._pattern.lastValue() / 2;
          break;
        case "WithFullGap":
          s18 = -this._pattern.lastValue(), this._pattern.extPtGap = this._pattern.lastValue();
          break;
        case "WithMarkers":
          s18 = 0;
          break;
        case "Custom":
          s18 = -this._position, s18 = this._adjustPosition(s18), this._pattern.extPtGap = 0.5 * this._offsetAtEnd;
      }
      if (!this._geometryWalker.init(t16, this._pattern, i18)) return null;
      this._pattern.reset();
      let n23 = 0;
      for (; s18 > n23; ) s18 -= n23, n23 = this._pattern.nextValue();
      n23 -= s18, e17 = n23, this.iteratePath = true;
    }
    const s17 = new h3();
    return this._geometryWalker.nextPointAndAngle(e17, s17) ? "WithFullGap" === this._endings && this._geometryWalker.isPathEnd() ? (this.iteratePath = false, null) : "WithMarkers" === this._endings && this._geometryWalker.isPathEnd() && (this.iteratePath = false, this.isClosed) ? null : (this.internalPlacement.setTranslate(s17.pt[0] - this._offset * s17.sa, s17.pt[1] + this._offset * s17.ca), this._angleToLine && this.internalPlacement.setRotateCS(s17.ca, s17.sa), this.internalPlacement) : (this.iteratePath = false, null);
  }
  _adjustPosition(t16) {
    let e17 = t16 / this._pattern.length();
    return e17 -= Math.floor(e17), e17 * this._pattern.length();
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementAtExtremities.js
var _s2 = class _s2 {
  static local() {
    return null === _s2.instance && (_s2.instance = new _s2()), _s2.instance;
  }
  execute(t16, e17, s17) {
    return new i11(t16, e17, s17);
  }
};
_s2.instance = null;
var s11 = _s2;
var i11 = class extends i6 {
  constructor(t16, s17, i18) {
    super(t16, false, true), this._curveHelper = new n4(), this._placePerPart = s17.placePerPart ?? false, this._angleToLine = void 0 === s17.angleToLine || s17.angleToLine, this._offset = void 0 !== s17.offset ? s17.offset * i18 : 0, this._type = s17.extremityPlacement, this._position = void 0 !== s17.offsetAlongLine ? s17.offsetAlongLine * i18 : 0, this._beginProcessed = false;
  }
  processMultiPath(t16) {
    return this._placePerPart ? super.processMultiPath(t16) : this.processPath(t16);
  }
  processPath(t16) {
    let e17;
    switch (this._type) {
      case "Both":
      default:
        this._beginProcessed ? (e17 = this._atExtremities(t16, this._position, false), this._beginProcessed = false, this.iterateMultiPath = false, this.iteratePath = false) : (e17 = this._atExtremities(t16, this._position, true), this._beginProcessed = true, this.iterateMultiPath = true, this.iteratePath = true);
        break;
      case "JustBegin":
        e17 = this._atExtremities(t16, this._position, true);
        break;
      case "JustEnd":
        e17 = this._atExtremities(t16, this._position, false);
      case "None":
    }
    return e17;
  }
  _atExtremities(t16, e17, s17) {
    if (this._placePerPart || (s17 ? t16.seekPath(0) : t16.seekPath(t16.totalSize - 1)), s17 || t16.seekPathEnd(), s17 ? t16.nextPoint() : t16.prevPoint()) {
      let i18 = 0, [n23, r13] = [0, 0], [a11, o9] = [t16.x, t16.y];
      const h8 = [0, 0];
      for (; s17 ? t16.nextPoint() : t16.prevPoint(); ) {
        n23 = a11, r13 = o9, a11 = t16.x, o9 = t16.y;
        const s18 = this._curveHelper.getLength(n23, r13, a11, o9);
        if (i18 + s18 > e17) {
          const t17 = (e17 - i18) / s18, [l12, c5] = this._curveHelper.getAngleCS(h8, n23, r13, a11, o9, t17), P3 = this._curveHelper.getCoord2D(n23, r13, a11, o9, t17);
          return this.internalPlacement.setTranslate(P3[0] - this._offset * c5, P3[1] + this._offset * l12), this._angleToLine && this.internalPlacement.setRotateCS(-l12, -c5), this.internalPlacement;
        }
        i18 += s18;
      }
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementAtRatioPositions.js
var _n4 = class _n4 {
  static local() {
    return null === _n4.instance && (_n4.instance = new _n4()), _n4.instance;
  }
  execute(t16, i18, s17) {
    return new a7(t16, i18, s17);
  }
};
_n4.instance = null;
var n14 = _n4;
var a7 = class extends i6 {
  constructor(t16, e17, n23) {
    super(t16), this._walker = new a4(), this._walker.updateTolerance(n23), this._angleToLine = void 0 === e17.angleToLine || e17.angleToLine, this._offset = void 0 !== e17.offset ? e17.offset * n23 : 0, this._beginGap = void 0 !== e17.beginPosition ? e17.beginPosition * n23 : 0, this._endGap = void 0 !== e17.endPosition ? e17.endPosition * n23 : 0, this._flipFirst = void 0 === e17.flipFirst || e17.flipFirst, this._pattern = new n6(), this._pattern.init(e17.positionArray, false, false), this._subPathLen = 0, this._posCount = this._pattern.size(), this._isFirst = true, this._prevPos = 0;
  }
  processPath(t16) {
    if (this._pattern.isEmpty()) return null;
    let i18;
    if (this.iteratePath) {
      const t17 = this._pattern.nextValue() * this._subPathLen, s18 = this._beginGap + t17;
      i18 = s18 - this._prevPos, this._prevPos = s18;
    } else {
      if (this._posCount = this._pattern.size(), this._isFirst = true, this._prevPos = 0, this._subPathLen = t16.pathLength() - this._beginGap - this._endGap, this._subPathLen < 0) return this.iteratePath = false, null;
      if (!this._walker.init(t16, this._pattern, false)) return null;
      this._pattern.reset();
      const s18 = this._pattern.nextValue() * this._subPathLen, e17 = this._beginGap + s18;
      i18 = e17 - this._prevPos, this._prevPos = e17, this.iteratePath = true;
    }
    const s17 = new h3();
    if (!this._walker.nextPointAndAngle(i18, s17, 1)) return this.iteratePath = false, null;
    this.internalPlacement.setTranslate(s17.pt[0] - this._offset * s17.sa, s17.pt[1] + this._offset * s17.ca);
    const n23 = this._isFirst && this._flipFirst;
    let a11, h8;
    return this._angleToLine ? (a11 = s17.ca, h8 = s17.sa) : (a11 = 1, h8 = 0), n23 && (a11 = -a11, h8 = -h8), this.internalPlacement.setRotateCS(a11, h8), this._isFirst = false, this._posCount--, 0 === this._posCount && (this.iteratePath = false), this.internalPlacement;
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementInsidePolygon.js
var i12 = 512;
var e15 = 10;
var h7 = 24;
var n15 = 1e-6;
var __ = class __ {
  static local() {
    return null === __.instance && (__.instance = new __()), __.instance;
  }
  execute(t16, s17, i18, e17) {
    return new r10(t16, s17, i18, e17);
  }
};
__.instance = null;
var _ = __;
var r10 = class _r3 {
  constructor(e17, h8, n23, _4) {
    if (this._xMin = 0, this._xMax = 0, this._yMin = 0, this._yMax = 0, this._currentX = 0, this._currentY = 0, this._accelerationMap = null, this._testInsidePolygon = false, this._verticalSubdivision = true, this._stepX = Math.abs(h8.stepX ?? 16) * n23, this._stepY = Math.abs(h8.stepY ?? 16) * n23, this._stepX = Math.round(128 * this._stepX) / 128, this._stepY = Math.round(128 * this._stepY) / 128, 0 !== this._stepX && 0 !== this._stepY) {
      if (this._gridType = h8.gridType ?? "Fixed", "Random" === this._gridType) {
        const s17 = h8.seed ?? 13, i18 = 1;
        this._randomLCG = new t(s17 * i18), this._randomness = (h8.randomness ?? 100) / 100, this._gridAngle = 0, this._shiftOddRows = false, this._cosAngle = 1, this._sinAngle = 0, this._offsetX = 0, this._offsetY = 0, this._buildRandomValues();
      } else {
        if (this._randomness = 0, this._gridAngle = h8.gridAngle ?? 0, this._shiftOddRows = h8.shiftOddRows ?? false, this._offsetX = (h8.offsetX ?? 0) * n23, this._offsetY = (h8.offsetY ?? 0) * n23, this._cosAngle = Math.cos(this._gridAngle / 180 * Math.PI), this._sinAngle = -Math.sin(this._gridAngle / 180 * Math.PI), this._stepX) if (this._offsetX < 0) for (; this._offsetX < -0.5 * this._stepX; ) this._offsetX += this._stepX;
        else for (; this._offsetX >= 0.5 * this._stepX; ) this._offsetX -= this._stepX;
        if (this._stepY) if (this._offsetY < 0) for (; this._offsetY < -0.5 * this._stepY; ) this._offsetY += this._stepY;
        else for (; this._offsetY >= 0.5 * this._stepY; ) this._offsetY -= this._stepY;
      }
      if (this._graphicOriginX = 0, this._graphicOriginY = 0, null != _4) {
        const [t16, s17, e18, h9] = _4.split("/"), n24 = parseFloat(t16), r13 = parseFloat(s17), a11 = parseFloat(e18), o9 = parseFloat(h9);
        this._graphicOriginX = -(o9 * 2 ** n24 + a11) * i12, this._graphicOriginY = r13 * i12, this._testInsidePolygon = true;
      }
      this._internalPlacement = new t6(), this._calculateMinMax(e17), this._geometryCursor = e17;
    }
  }
  next() {
    return this._geometryCursor ? this._nextInside() : null;
  }
  _buildRandomValues() {
    if (!_r3._randValues) {
      _r3._randValues = [];
      for (let t16 = 0; t16 < h7; t16++) for (let s17 = 0; s17 < h7; s17++) _r3._randValues.push(this._randomLCG.getFloat()), _r3._randValues.push(this._randomLCG.getFloat());
    }
  }
  _calculateMinMax(t16) {
    let s17, e17, h8, n23, _4, r13, a11, o9, l12, f6, c5, u9, p6, M3;
    this._xMin = 0, this._xMax = 0, this._yMin = 0, this._yMax = 0, a11 = o9 = p6 = c5 = Number.MAX_VALUE, l12 = f6 = M3 = u9 = -Number.MAX_VALUE;
    const g5 = 1 !== this._cosAngle;
    for (t16.reset(); t16.nextPath(); ) for (; t16.nextPoint(); ) r13 = t16.x, _4 = t16.y, s17 = r13 - this._graphicOriginX - this._offsetX, e17 = _4 - this._graphicOriginY - this._offsetY, g5 ? (h8 = this._cosAngle * s17 - this._sinAngle * e17, n23 = this._sinAngle * s17 + this._cosAngle * e17) : (h8 = s17, n23 = e17), a11 = Math.min(a11, h8), l12 = Math.max(l12, h8), o9 = Math.min(o9, n23), f6 = Math.max(f6, n23), c5 = Math.min(c5, _4), u9 = Math.max(u9, _4), p6 = Math.min(p6, r13), M3 = Math.max(M3, r13);
    c5 = c5 !== Number.MAX_VALUE ? c5 : -i12 - this._stepY, u9 = u9 !== -Number.MAX_VALUE ? u9 : this._stepY, p6 = p6 !== Number.MAX_VALUE ? p6 : -this._stepX, M3 = M3 !== -Number.MAX_VALUE ? M3 : i12 + this._stepX;
    const d = u9 - c5, X3 = M3 - p6;
    if (this._verticalSubdivision = d >= X3, this._polygonMin = this._verticalSubdivision ? c5 : p6, this._testInsidePolygon) {
      let t17 = 0 - this._graphicOriginX - this._offsetX - this._stepX, s18 = i12 - this._graphicOriginX - this._offsetX + this._stepX, e18 = -i12 - this._graphicOriginY - this._offsetY - this._stepY, h9 = 0 - this._graphicOriginY - this._offsetY + this._stepY;
      if (g5) {
        const i18 = [[t17, e18], [t17, h9], [s18, e18], [s18, h9]];
        t17 = e18 = Number.MAX_VALUE, s18 = h9 = -Number.MAX_VALUE;
        for (const n24 of i18) {
          const i19 = this._cosAngle * n24[0] - this._sinAngle * n24[1], _5 = this._sinAngle * n24[0] + this._cosAngle * n24[1];
          t17 = Math.min(t17, i19), s18 = Math.max(s18, i19), e18 = Math.min(e18, _5), h9 = Math.max(h9, _5);
        }
      }
      a11 = a11 !== Number.MAX_VALUE ? Math.max(a11, t17) : t17, o9 = o9 !== Number.MAX_VALUE ? Math.max(o9, e18) : e18, l12 = l12 !== -Number.MAX_VALUE ? Math.min(l12, s18) : s18, f6 = f6 !== -Number.MAX_VALUE ? Math.min(f6, h9) : h9;
    }
    this._xMin = Math.round(a11 / this._stepX), this._xMax = Math.round(l12 / this._stepX), this._yMin = Math.round(o9 / this._stepY), this._yMax = Math.round(f6 / this._stepY), this._currentX = this._xMax + 1, this._currentY = this._yMin - 1, this._buildAccelerationMap(t16, p6, M3, c5, u9);
  }
  _buildAccelerationMap(t16, s17, h8, n23, _4) {
    t16.reset();
    const r13 = /* @__PURE__ */ new Map(), a11 = this._verticalSubdivision, l12 = a11 ? _4 - n23 : h8 - s17;
    let f6 = Math.ceil(l12 / e15);
    if (f6 <= 1) return;
    const c5 = Math.floor(l12 / f6);
    let u9, p6, M3, g5, d, X3, m5, x3, A4, Y2, y6;
    for (f6++, this._delta = c5, a11 ? (A4 = -i12 - 2 * this._stepY, Y2 = 2 * this._stepY, y6 = n23) : (A4 = -2 * this._stepX, Y2 = i12 + 2 * this._stepX, y6 = s17); t16.nextPath(); ) if (!(t16.pathSize < 2) && t16.nextPoint()) for (u9 = t16.x, p6 = t16.y; t16.nextPoint(); u9 = M3, p6 = g5) {
      if (M3 = t16.x, g5 = t16.y, a11) {
        if (p6 === g5 || p6 < A4 && g5 < A4 || p6 > Y2 && g5 > Y2) continue;
        d = Math.min(p6, g5), X3 = Math.max(p6, g5);
      } else {
        if (u9 === M3 || u9 < A4 && M3 < A4 || u9 > Y2 && M3 > Y2) continue;
        d = Math.min(u9, M3), X3 = Math.max(u9, M3);
      }
      for (; d < X3; ) m5 = Math.floor((d - y6) / c5), o5(m5, u9, p6, M3, g5, r13), d += c5;
      x3 = Math.floor((X3 - y6) / c5), x3 > m5 && o5(x3, u9, p6, M3, g5, r13);
    }
    this._accelerationMap = r13;
  }
  _nextInside() {
    for (; ; ) {
      if (this._currentX > this._xMax) {
        if (this._currentY++, this._currentY > this._yMax) return null;
        this._currentX = this._xMin, this._shiftOddRows && this._currentY % 2 && this._currentX--;
      }
      let t16 = this._currentX * this._stepX + this._offsetX;
      this._shiftOddRows && this._currentY % 2 && (t16 += 0.5 * this._stepX);
      const s17 = this._currentY * this._stepY + this._offsetY;
      let i18, e17;
      if (this._currentX++, "Random" === this._gridType) {
        const n23 = (this._currentX % h7 + h7) % h7, _4 = (this._currentY % h7 + h7) % h7;
        i18 = this._graphicOriginX + t16 + this._stepX * this._randomness * (0.5 - _r3._randValues[_4 * h7 + n23]) * 2 / 3, e17 = this._graphicOriginY + s17 + this._stepY * this._randomness * (0.5 - _r3._randValues[_4 * h7 + n23 + 1]) * 2 / 3;
      } else i18 = this._graphicOriginX + this._cosAngle * t16 + this._sinAngle * s17, e17 = this._graphicOriginY - this._sinAngle * t16 + this._cosAngle * s17;
      if (!this._testInsidePolygon || this._isInsidePolygon(i18, e17, this._geometryCursor)) return this._internalPlacement.setTranslate(i18, e17), this._internalPlacement;
    }
  }
  _isInsidePolygon(t16, s17, i18) {
    if (null == this._accelerationMap) return a8(t16, s17, i18);
    t16 += n15, s17 += n15;
    const e17 = this._verticalSubdivision, h8 = e17 ? s17 : t16, _4 = Math.floor((h8 - this._polygonMin) / this._delta), r13 = this._accelerationMap.get(_4);
    if (!r13) return false;
    let o9, l12, f6, c5 = 0;
    for (const n23 of r13) {
      if (o9 = n23[0], l12 = n23[1], e17) {
        if (o9[1] > s17 == l12[1] > s17) continue;
        f6 = (l12[0] - o9[0]) * (s17 - o9[1]) - (l12[1] - o9[1]) * (t16 - o9[0]);
      } else {
        if (o9[0] > t16 == l12[0] > t16) continue;
        f6 = (l12[1] - o9[1]) * (t16 - o9[0]) - (l12[0] - o9[0]) * (s17 - o9[1]);
      }
      f6 > 0 ? c5++ : c5--;
    }
    return 0 !== c5;
  }
};
function a8(t16, s17, i18) {
  let e17, h8, _4, r13, a11 = 0;
  for (t16 += n15, s17 += n15, i18.reset(); i18.nextPath(); ) if (i18.nextPoint()) for (e17 = i18.x, h8 = i18.y; i18.nextPoint(); e17 = _4, h8 = r13) {
    if (_4 = i18.x, r13 = i18.y, h8 > s17 == r13 > s17) continue;
    (_4 - e17) * (s17 - h8) - (r13 - h8) * (t16 - e17) > 0 ? a11++ : a11--;
  }
  return 0 !== a11;
}
function o5(t16, s17, i18, e17, h8, n23) {
  let _4 = n23.get(t16);
  _4 || (_4 = [], n23.set(t16, _4)), _4.push([[s17, i18], [e17, h8]]);
}

// node_modules/@arcgis/core/symbols/cim/placements/PlacementOnLine.js
var n16 = 1e-3;
var _i = class _i {
  static local() {
    return null === _i.instance && (_i.instance = new _i()), _i.instance;
  }
  execute(t16, e17, n23) {
    return new s12(t16, e17, n23);
  }
};
_i.instance = null;
var i13 = _i;
var s12 = class extends i6 {
  constructor(t16, i18, s17) {
    super(t16), this._curveHelper = new n4(), this._angleToLine = void 0 === i18.angleToLine || i18.angleToLine, this._offset = void 0 !== i18.offset ? i18.offset * s17 : 0, this._relativeTo = i18.relativeTo, this._position = void 0 !== i18.startPointOffset ? i18.startPointOffset * s17 : 0, this._epsilon = n16 * s17;
  }
  processPath(t16) {
    const e17 = this._position;
    if ("SegmentMidpoint" === this._relativeTo) {
      if (this.iteratePath || (this.iteratePath = true), t16.nextPoint()) {
        let [e18, n24] = [t16.x, t16.y], [i18, s17] = [0, 0];
        const r13 = [0, 0];
        for (; t16.nextPoint(); ) {
          i18 = t16.x, s17 = t16.y;
          const o9 = this._curveHelper.getLength(e18, n24, i18, s17);
          if (o9 < this._epsilon) {
            e18 = i18, n24 = s17;
            continue;
          }
          const a11 = 0.5 + this._position / o9, [l12, h8] = this._curveHelper.getAngleCS(r13, e18, n24, i18, s17, a11), c5 = this._curveHelper.getCoord2D(e18, n24, i18, s17, a11);
          return this.internalPlacement.setTranslate(c5[0] - this._offset * h8, c5[1] + this._offset * l12), this._angleToLine && this.internalPlacement.setRotateCS(l12, h8), this.internalPlacement;
        }
      }
      return this.iteratePath = false, null;
    }
    const n23 = "LineEnd" === this._relativeTo;
    return this.onLine(t16, e17, n23);
  }
  onLine(t16, e17, n23) {
    let i18, s17 = false;
    switch (this._relativeTo) {
      case "LineMiddle":
      default:
        t16.seekPathStart(), i18 = t16.pathLength() / 2 + e17;
        break;
      case "LineBeginning":
        i18 = e17;
        break;
      case "LineEnd":
        i18 = e17, s17 = true;
    }
    n23 ? t16.seekPathEnd() : t16.seekPathStart();
    let r13 = 0;
    if (n23 ? t16.prevPoint() : t16.nextPoint()) {
      let [e18, o9] = [t16.x, t16.y], [a11, l12] = [0, 0];
      const h8 = [0, 0];
      for (; n23 ? t16.prevPoint() : t16.nextPoint(); ) {
        a11 = t16.x, l12 = t16.y;
        const n24 = this._curveHelper.getLength(e18, o9, a11, l12);
        if (r13 + n24 > i18) {
          const t17 = (i18 - r13) / n24, [c5, f6] = this._curveHelper.getAngleCS(h8, e18, o9, a11, l12, t17), u9 = this._curveHelper.getCoord2D(e18, o9, a11, l12, t17), _4 = s17 ? -this._offset : this._offset;
          return this.internalPlacement.setTranslate(u9[0] - _4 * f6, u9[1] + _4 * c5), this._angleToLine && (s17 ? this.internalPlacement.setRotateCS(-c5, -f6) : this.internalPlacement.setRotateCS(c5, f6)), this.internalPlacement;
        }
        e18 = a11, o9 = l12, r13 += n24;
      }
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementOnVertices.js
var s13 = 1e-15;
var _i2 = class _i2 {
  static local() {
    return null === _i2.instance && (_i2.instance = new _i2()), _i2.instance;
  }
  execute(t16, e17, s17) {
    return new n17(t16, e17, s17);
  }
};
_i2.instance = null;
var i14 = _i2;
var n17 = class extends i6 {
  constructor(t16, s17, i18) {
    super(t16), this._curveHelper = new n4(), this._angleToLine = void 0 === s17.angleToLine || s17.angleToLine, this._offset = void 0 !== s17.offset ? s17.offset * i18 : 0, this._endPoints = void 0 === s17.placeOnEndPoints || s17.placeOnEndPoints, this._controlPoints = void 0 === s17.placeOnControlPoints || s17.placeOnControlPoints, this._regularVertices = void 0 === s17.placeOnRegularVertices || s17.placeOnRegularVertices, this._tags = [], this._tagIterator = 0;
  }
  processPath(t16) {
    if (this.iteratePath || (this._preparePath(t16), this.iteratePath = true), this._tagIterator >= this._tags.length) return this._tags.length = 0, this._tagIterator = 0, this.iteratePath = false, null;
    const e17 = this._tags[this._tagIterator];
    this._angleToLine && this.internalPlacement.setRotate(e17[2]);
    let s17 = e17[0], i18 = e17[1];
    if (0 !== this._offset) {
      const t17 = Math.cos(e17[2]), n23 = Math.sin(e17[2]);
      s17 -= this._offset * n23, i18 += this._offset * t17;
    }
    return this.internalPlacement.setTranslate(s17, i18), this._tagIterator++, this.internalPlacement;
  }
  _preparePath(t16) {
    this._tags.length = 0, this._tagIterator = 0, t16.seekPathStart();
    const e17 = t16.isClosed();
    let s17 = 0, i18 = false, n23 = 0, a11 = 0;
    if (t16.seekPathStart(), t16.nextPoint()) {
      let r13 = t16.x, h8 = t16.y, l12 = t16.getControlPoint(), _4 = true, c5 = t16.nextPoint();
      for (; c5; ) {
        const g5 = t16.x, P3 = t16.y, u9 = t16.getControlPoint();
        (this._angleToLine || 0 !== this._offset) && (n23 = this._curveHelper.getAngle(r13, h8, g5, P3, 0)), _4 ? (_4 = false, e17 ? (s17 = n23, i18 = l12) : (this._endPoints || this._controlPoints && l12) && this._tags.push([r13, h8, n23])) : l12 ? this._controlPoints && this._tags.push([r13, h8, o6(a11, n23)]) : this._regularVertices && this._tags.push([r13, h8, o6(a11, n23)]), (this._angleToLine || 0 !== this._offset) && (a11 = this._curveHelper.getAngle(r13, h8, g5, P3, 1)), c5 = t16.nextPoint(), c5 || (e17 ? u9 || i18 ? this._controlPoints && this._tags.push([g5, P3, o6(a11, s17)]) : this._regularVertices && this._tags.push([g5, P3, o6(a11, s17)]) : (this._endPoints || this._controlPoints && u9) && this._tags.push([g5, P3, a11])), r13 = g5, h8 = P3, l12 = u9;
      }
    }
    this._tagIterator = 0;
  }
};
function o6(t16, e17) {
  const i18 = Math.PI;
  for (; Math.abs(e17 - t16) > i18 + 2 * s13; ) e17 - t16 > i18 ? e17 -= 2 * i18 : e17 += 2 * i18;
  return (t16 + e17) / 2;
}

// node_modules/@arcgis/core/symbols/cim/placements/PlacementPolygonCenter.js
var _n5 = class _n5 {
  static local() {
    return null === _n5.instance && (_n5.instance = new _n5()), _n5.instance;
  }
  execute(t16, e17, s17) {
    return new o7(t16, e17, s17);
  }
};
_n5.instance = null;
var n18 = _n5;
var o7 = class {
  constructor(t16, e17, s17) {
    this._geometryCursor = t16, this._offsetX = void 0 !== e17.offsetX ? e17.offsetX * s17 : 0, this._offsetY = void 0 !== e17.offsetY ? e17.offsetY * s17 : 0, this._method = void 0 !== e17.method ? e17.method : "OnPolygon", this._placementPerPart = void 0 !== e17.placePerPart && e17.placePerPart, this._internalPlacement = new t6();
  }
  next() {
    const t16 = this._geometryCursor;
    if (!t16) return null;
    if (!this._placementPerPart) return this._geometryCursor = null, this._polygonCenter(t16);
    for (; t16.nextPath(); ) if (!(t16.getCurrentRingArea() < 0)) return this._polygonCenter(t16.getCurrentPath());
    return this._geometryCursor = null, null;
  }
  _polygonCenter(r13) {
    let n23 = false;
    switch (this._method) {
      case "CenterOfMass":
        {
          const t16 = N(r13);
          t16 && (this._internalPlacement.setTranslate(t16[0] + this._offsetX, t16[1] + this._offsetY), n23 = true);
        }
        break;
      case "BoundingBoxCenter":
        {
          const e17 = x(r13);
          e17 && (this._internalPlacement.setTranslate((e17[2] + e17[0]) / 2 + this._offsetX, (e17[3] + e17[1]) / 2 + this._offsetY), n23 = true);
        }
        break;
      default: {
        const t16 = l5(r13);
        null !== t16 && (this._internalPlacement.setTranslate(t16[0] + this._offsetX, t16[1] + this._offsetY), n23 = true);
      }
    }
    return n23 ? this._internalPlacement : null;
  }
};

// node_modules/@arcgis/core/symbols/cim/CIMImageColorSubstitutionHelper.js
var t10 = class {
  applyColorSubstitution(t16, a11) {
    if (!a11) return t16;
    this._rasterizationCanvas || (this._rasterizationCanvas = document.createElement("canvas"));
    const { width: e17, height: n23 } = t16, o9 = this._rasterizationCanvas, r13 = o9.getContext("2d", { willReadFrequently: true });
    t16 !== o9 && (o9.width = e17, o9.height = n23, r13.drawImage(t16, 0, 0, e17, n23));
    const i18 = r13.getImageData(0, 0, e17, n23).data;
    if (a11) {
      for (const l12 of a11) if (l12 && l12.oldColor && 4 === l12.oldColor.length && l12.newColor && 4 === l12.newColor.length) {
        const [t17, a12, e18, n24] = l12.oldColor, [o10, r14, s18, h8] = l12.newColor;
        if (t17 === o10 && a12 === r14 && e18 === s18 && n24 === h8) continue;
        for (let l13 = 0; l13 < i18.length; l13 += 4) t17 === i18[l13] && a12 === i18[l13 + 1] && e18 === i18[l13 + 2] && n24 === i18[l13 + 3] && (i18[l13] = o10, i18[l13 + 1] = r14, i18[l13 + 2] = s18, i18[l13 + 3] = h8);
      }
    }
    const s17 = new ImageData(i18, e17, n23);
    return r13.putImageData(s17, 0, 0), o9;
  }
  tintImageData(t16, a11) {
    if (!a11 || a11.length < 4) return t16;
    this._rasterizationCanvas || (this._rasterizationCanvas = document.createElement("canvas"));
    const { width: e17, height: n23 } = t16, o9 = this._rasterizationCanvas, r13 = o9.getContext("2d", { willReadFrequently: true });
    t16 !== o9 && (o9.width = e17, o9.height = n23, r13.drawImage(t16, 0, 0, e17, n23));
    const i18 = r13.getImageData(0, 0, e17, n23), s17 = new Uint8Array(i18.data), l12 = [a11[0] / 255, a11[1] / 255, a11[2] / 255, a11[3] / 255];
    for (let g5 = 0; g5 < s17.length; g5 += 4) s17[g5] *= l12[0], s17[g5 + 1] *= l12[1], s17[g5 + 2] *= l12[2], s17[g5 + 3] *= l12[3];
    const h8 = new ImageData(new Uint8ClampedArray(s17.buffer), e17, n23);
    return r13.putImageData(h8, 0, 0), o9;
  }
};

// node_modules/@arcgis/core/symbols/cim/CIMOperators.js
function R(P3) {
  if (!P3) return null;
  switch (P3.type) {
    case "CIMGeometricEffectAddControlPoints":
      return e6.local();
    case "CIMGeometricEffectArrow":
      return u4.local();
    case "CIMGeometricEffectBuffer":
      return m3.local();
    case "CIMGeometricEffectControlMeasureLine":
      return e9.local();
    case "CIMGeometricEffectCut":
      return r4.local();
    case "CIMGeometricEffectDashes":
      return n7.local();
    case "CIMGeometricEffectDonut":
      return s8.local();
    case "CIMGeometricEffectJog":
      return e10.local();
    case "CIMGeometricEffectMove":
      return t7.local();
    case "CIMGeometricEffectOffset":
      return l10.local();
    case "CIMGeometricEffectRadial":
      return n9.local();
    case "CIMGeometricEffectReverse":
      return e12.local();
    case "CIMGeometricEffectRotate":
      return e13.local();
    case "CIMGeometricEffectScale":
      return e14.local();
    case "CIMGeometricEffectSuppress":
      return r9.local();
    case "CIMGeometricEffectTaperedPolygon":
      return y4.local();
    case "CIMGeometricEffectWave":
      return h6.local();
    case "CIMGeometricEffectEnclosingPolygon":
      return o4.local();
  }
  return null;
}
function S2(e17) {
  if (!e17) return null;
  switch (e17.type) {
    case "CIMMarkerPlacementAlongLineSameSize":
      return n13.local();
    case "CIMMarkerPlacementAtExtremities":
      return s11.local();
    case "CIMMarkerPlacementAtRatioPositions":
      return n14.local();
    case "CIMMarkerPlacementInsidePolygon":
      return _.local();
    case "CIMMarkerPlacementOnLine":
      return i13.local();
    case "CIMMarkerPlacementOnVertices":
      return i14.local();
    case "CIMMarkerPlacementPolygonCenter":
      return n18.local();
  }
  return null;
}

// node_modules/@arcgis/core/symbols/cim/imageUtils.js
function t11(t16) {
  const e17 = t16.getFrame(0);
  if (e17 instanceof HTMLImageElement || e17 instanceof HTMLCanvasElement) return e17;
  const n23 = document.createElement("canvas");
  n23.width = t16.width, n23.height = t16.height;
  const a11 = n23.getContext("2d");
  return e17 instanceof ImageData ? a11.putImageData(e17, 0, 0) : a11.drawImage(e17, 0, 0), n23;
}

// node_modules/@arcgis/core/symbols/cim/mathUtils.js
function t12(t16, n23 = 0) {
  if (0 === n23) return t16;
  const r13 = Math.cos(n23), o9 = Math.sin(n23), [c5, e17] = t16;
  return [c5 * r13 + e17 * -o9, c5 * o9 + e17 * r13];
}

// node_modules/@arcgis/core/symbols/cim/Rect.js
var t13 = class _t3 {
  constructor(t16 = 0, h8 = 0, i18 = 0, s17 = 0) {
    this.x = t16, this.y = h8, this.width = i18, this.height = s17;
  }
  static fromExtent(h8) {
    return new _t3(h8.xmin, -h8.ymax, h8.xmax - h8.xmin, h8.ymax - h8.ymin);
  }
  get isEmpty() {
    return this.width <= 0 || this.height <= 0;
  }
  union(t16) {
    this.x = Math.min(this.x, t16.x), this.y = Math.min(this.y, t16.y), this.width = Math.max(this.width, t16.width), this.height = Math.max(this.height, t16.height);
  }
};

// node_modules/@arcgis/core/symbols/cim/TextRasterizer.js
function i15(e17) {
  return `rgb(${e17.slice(0, 3).toString()})`;
}
function n19(e17) {
  return `rgba(${e17.slice(0, 3).toString()},${e17[3]})`;
}
var s14 = class {
  constructor(e17) {
    e17 && (this._textRasterizationCanvas = e17);
  }
  rasterizeText(e17, s17) {
    this._textRasterizationCanvas || (this._textRasterizationCanvas = document.createElement("canvas"));
    const a11 = this._textRasterizationCanvas, h8 = a11.getContext("2d", { willReadFrequently: true });
    r11(h8, s17), this._parameters = s17, this._textLines = e17.split(/\r?\n/), this._lineHeight = this._computeLineHeight();
    const { decoration: l12, weight: d } = s17.font;
    this._lineThroughWidthOffset = l12 && "line-through" === l12 ? 0.1 * this._lineHeight : 0;
    const c5 = null != s17.backgroundColor || null != s17.borderLine, _4 = c5 ? s4 : 0, u9 = this._computeTextWidth(h8, s17) + 2 * _4, g5 = this._lineHeight * this._textLines.length + 2 * _4;
    if (a11.width = u9 + 2 * this._lineThroughWidthOffset, a11.height = g5, 0 === a11.width || 0 === a11.height) return a11.width = a11.height = 1, { size: [0, 0], image: new Uint32Array(0), sdf: false, simplePattern: false, anchorX: 0, anchorY: 0, canvas: a11 };
    this._renderedLineHeight = Math.round(this._lineHeight), this._renderedOutlineSize = (s17.outline.size || 0) * s17.pixelRatio, this._renderedHaloSize = (s17.halo.size || 0) * s17.pixelRatio, this._renderedWidth = u9, this._renderedHeight = g5, this._lineThroughWidthOffset *= s17.pixelRatio;
    const f6 = (s17.outline && s17.outline.color) ?? [0, 0, 0, 0], m5 = s17.color ?? [0, 0, 0, 0], p6 = s17.halo && s17.halo.color ? s17.halo.color : [0, 0, 0, 0];
    this._fillStyle = n19(m5), this._outlineStyle = n19(f6), this._haloStyle = i15(p6);
    const x3 = this._renderedLineHeight, z3 = this._renderedOutlineSize, b2 = this._renderedHaloSize;
    h8.save(), h8.clearRect(0, 0, a11.width, a11.height), r11(h8, s17);
    const w3 = _4 * s17.pixelRatio, v4 = o8(h8.textAlign, this._renderedWidth - 2 * w3, this._renderedHaloSize + this._renderedOutlineSize) + w3, S3 = b2 + z3 + w3, y6 = b2 > 0;
    let R4 = this._lineThroughWidthOffset, C2 = 0;
    if (c5) {
      h8.save();
      const e18 = s17.backgroundColor ?? [0, 0, 0, 0], t16 = s17.borderLine?.color ?? [0, 0, 0, 0], i18 = 2 * (s17.borderLine?.size ?? 0);
      h8.fillStyle = n19(e18), h8.strokeStyle = n19(t16), h8.lineWidth = i18, h8.fillRect(0, 0, a11.width, a11.height), h8.strokeRect(0, 0, a11.width, a11.height), h8.restore();
    }
    y6 && this._renderHalo(h8, v4, S3, R4, C2, s17), z3 > 0 && this._renderOutline(h8, v4, S3, R4, C2, s17), C2 += S3, R4 += v4;
    for (const t16 of this._textLines) y6 ? (h8.globalCompositeOperation = "destination-out", h8.fillStyle = "rgb(0, 0, 0)", h8.fillText(t16, R4, C2), h8.globalCompositeOperation = "source-over", h8.fillStyle = this._fillStyle, h8.fillText(t16, R4, C2)) : (h8.fillStyle = this._fillStyle, h8.fillText(t16, R4, C2)), l12 && "none" !== l12 && this._renderDecoration(h8, R4, C2, l12, d), C2 += x3;
    h8.restore();
    const H2 = this._renderedWidth + 2 * this._lineThroughWidthOffset, W3 = this._renderedHeight, T4 = h8.getImageData(0, 0, H2, W3), k = new Uint8Array(T4.data);
    if (s17.premultiplyColors) {
      let e18;
      for (let t16 = 0; t16 < k.length; t16 += 4) e18 = k[t16 + 3] / 255, k[t16] = k[t16] * e18, k[t16 + 1] = k[t16 + 1] * e18, k[t16 + 2] = k[t16 + 2] * e18;
    }
    let L4, O2;
    switch (s17.horizontalAlignment) {
      case "left":
        L4 = -0.5;
        break;
      case "right":
        L4 = 0.5;
        break;
      default:
        L4 = 0;
    }
    switch (s17.verticalAlignment) {
      case "bottom":
        O2 = -0.5;
        break;
      case "top":
        O2 = 0.5;
        break;
      case "baseline":
        O2 = -1 / 6;
        break;
      default:
        O2 = 0;
    }
    return { size: [H2, W3], image: new Uint32Array(k.buffer), sdf: false, simplePattern: false, anchorX: L4, anchorY: O2, canvas: a11 };
  }
  _renderHalo(e17, t16, i18, n23, s17, o9) {
    const a11 = this._renderedWidth, h8 = this._renderedHeight;
    this._outlineRasterizationCanvas || (this._outlineRasterizationCanvas = document.createElement("canvas")), this._outlineRasterizationCanvas.width = a11, this._outlineRasterizationCanvas.height = h8;
    const l12 = this._outlineRasterizationCanvas, d = l12.getContext("2d");
    d.clearRect(0, 0, a11, h8), r11(d, o9);
    const { decoration: c5, weight: _4 } = o9.font;
    d.fillStyle = this._haloStyle, d.strokeStyle = this._haloStyle, d.lineJoin = "round", this._renderOutlineNative(d, t16, i18, c5, _4, this._renderedHaloSize + this._renderedOutlineSize), e17.globalAlpha = this._parameters.halo.color[3], e17.drawImage(l12, 0, 0, a11, h8, n23, s17, a11, h8), e17.globalAlpha = 1;
  }
  _renderOutline(e17, t16, i18, n23, s17, o9) {
    const a11 = this._renderedWidth, h8 = this._renderedHeight;
    this._outlineRasterizationCanvas || (this._outlineRasterizationCanvas = document.createElement("canvas")), this._outlineRasterizationCanvas.width = a11, this._outlineRasterizationCanvas.height = h8;
    const l12 = this._outlineRasterizationCanvas, d = l12.getContext("2d");
    d.clearRect(0, 0, a11, h8), r11(d, o9);
    const { decoration: c5, weight: _4 } = o9.font;
    d.fillStyle = this._outlineStyle, d.strokeStyle = this._outlineStyle, d.lineJoin = "round", this._renderOutlineNative(d, t16, i18, c5, _4, this._renderedOutlineSize), e17.globalAlpha = this._parameters.outline.color[3], e17.drawImage(l12, 0, 0, a11, h8, n23, s17, a11, h8), e17.globalAlpha = 1;
  }
  _renderOutlineNative(e17, t16, i18, n23, s17, r13) {
    const o9 = this._renderedLineHeight;
    for (const a11 of this._textLines) {
      const h8 = 2 * r13, l12 = 5, d = 0.1;
      for (let r14 = 0; r14 < l12; r14++) {
        const o10 = (1 - (l12 - 1) * d + r14 * d) * h8;
        e17.lineWidth = o10, e17.strokeText(a11, t16, i18), n23 && "none" !== n23 && this._renderDecoration(e17, t16, i18, n23, s17, o10);
      }
      i18 += o9;
    }
  }
  computeTextSize(e17, t16) {
    this._textRasterizationCanvas || (this._textRasterizationCanvas = document.createElement("canvas"));
    const i18 = this._textRasterizationCanvas, n23 = i18.getContext("2d");
    r11(n23, t16), this._parameters = t16, this._textLines = e17.split(/\r?\n/), this._lineHeight = this._computeLineHeight();
    const s17 = this._computeTextWidth(n23, t16), o9 = this._lineHeight * this._textLines.length;
    return i18.width = s17, i18.height = o9, [s17 * t16.pixelRatio, o9 * t16.pixelRatio];
  }
  _computeTextWidth(t16, i18) {
    let n23 = 0;
    for (const e17 of this._textLines) n23 = Math.max(n23, t16.measureText(e17).width);
    const s17 = i18.font;
    return ("italic" === s17.style || "oblique" === s17.style || "string" == typeof s17.weight && ("bold" === s17.weight || "bolder" === s17.weight) || "number" == typeof s17.weight && s17.weight > 600) && (n23 += 0.3 * t16.measureText("w").width), n23 += 2 * u(this._parameters.halo.size), Math.round(n23);
  }
  _computeLineHeightBase() {
    return 1.275 * this._parameters.size;
  }
  _computeLineHeight() {
    let t16 = this._computeLineHeightBase();
    const i18 = this._parameters.font.decoration;
    return i18 && "underline" === i18 && (t16 *= 1.3), Math.round(t16 + 2 * u(this._parameters.halo.size));
  }
  _renderDecoration(e17, t16, i18, n23, s17, r13) {
    let o9 = 0.9 * this._lineHeight;
    const a11 = "bold" === s17 ? 0.06 : "bolder" === s17 ? 0.09 : 0.04;
    switch (e17.textAlign) {
      case "center":
        t16 -= this._renderedWidth / 2;
        break;
      case "right":
        t16 -= this._renderedWidth;
    }
    const h8 = e17.textBaseline;
    if ("underline" === n23) switch (o9 = 0.9 * this._computeLineHeightBase(), h8) {
      case "top":
        i18 += o9;
        break;
      case "middle":
        i18 += o9 / 2;
    }
    else if ("line-through" === n23) switch (h8) {
      case "top":
        i18 += o9 / 1.5;
        break;
      case "middle":
        i18 += o9 / 3;
    }
    const l12 = r13 ? 1.5 * r13 : Math.ceil(o9 * a11);
    e17.save(), e17.beginPath(), e17.strokeStyle = e17.fillStyle, e17.lineWidth = l12, e17.moveTo(t16 - this._lineThroughWidthOffset, i18), e17.lineTo(t16 + this._renderedWidth + 2 * this._lineThroughWidthOffset, i18), e17.stroke(), e17.restore();
  }
};
function r11(t16, i18) {
  const n23 = Math.max(i18.size, 0.5), s17 = i18.font, r13 = `${s17.style} ${s17.weight} ${u(n23).toFixed(1)}px ${s17.family}, sans-serif`;
  let o9;
  switch (t16.font = r13, t16.textBaseline = "top", i18.horizontalAlignment) {
    case "left":
    default:
      o9 = "left";
      break;
    case "right":
      o9 = "right";
      break;
    case "center":
      o9 = "center";
  }
  t16.textAlign = o9;
}
function o8(e17, t16, i18) {
  return "center" === e17 ? 0.5 * t16 : "right" === e17 ? t16 - i18 : i18;
}

// node_modules/@arcgis/core/views/2d/engine/svgUtils.js
function t14(t16) {
  return document.createElementNS("http://www.w3.org/2000/svg", t16);
}
function e16() {
  const e17 = t14("svg");
  return e17.setAttribute("style", "position: absolute;"), e17.setAttribute("width", "0"), e17.setAttribute("height", "0"), e17.setAttribute("aria-hidden", "true"), e17.setAttribute("role", "presentation"), document.body.appendChild(e17), e17;
}
function n20(t16) {
  return null != t16 && document.body.removeChild(t16), null;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/alignmentUtils.js
var t15 = () => i.getLogger("esri.views.2d.engine.webgl.alignmentUtils");
function r12(e17) {
  if (!e17) return 0;
  switch (e17) {
    case "Left":
    case "left":
      return -1;
    case "Right":
    case "right":
      return 1;
    case "Justify":
      return t15().warnOnce("Horizontal alignment 'justify' is not implemented. Falling back to 'center'."), 0;
    case "Center":
    case "center":
      return 0;
  }
}
function n21(e17) {
  if (!e17) return 0;
  switch (e17) {
    case "Top":
    case "top":
      return 1;
    case "Center":
    case "middle":
      return 0;
    case "Baseline":
    case "baseline":
      return 2;
    case "Bottom":
    case "bottom":
      return -1;
  }
}
function a9(e17) {
  switch (e17) {
    case "above-left":
    case "esriServerPointLabelPlacementAboveLeft":
      return ["right", "bottom"];
    case "above-center":
    case "above-along":
    case "esriServerPointLabelPlacementAboveCenter":
    case "esriServerLinePlacementAboveAlong":
      return ["center", "bottom"];
    case "above-right":
    case "esriServerPointLabelPlacementAboveRight":
      return ["left", "bottom"];
    case "center-left":
    case "esriServerPointLabelPlacementCenterLeft":
      return ["right", "middle"];
    case "center-center":
    case "center-along":
    case "esriServerPointLabelPlacementCenterCenter":
    case "esriServerLinePlacementCenterAlong":
    case "always-horizontal":
    case "esriServerPolygonPlacementAlwaysHorizontal":
      return ["center", "middle"];
    case "center-right":
    case "esriServerPointLabelPlacementCenterRight":
      return ["left", "middle"];
    case "below-left":
    case "esriServerPointLabelPlacementBelowLeft":
      return ["right", "top"];
    case "below-center":
    case "below-along":
    case "esriServerPointLabelPlacementBelowCenter":
    case "esriServerLinePlacementBelowAlong":
      return ["center", "top"];
    case "below-right":
    case "esriServerPointLabelPlacementBelowRight":
      return ["left", "top"];
    default:
      return console.debug(`Found invalid placement type ${e17}`), ["center", "middle"];
  }
}
function c4(e17) {
  switch (e17) {
    case 1:
    case "right":
      return -1;
    case 0:
    case "center":
      return 0;
    case -1:
    case "left":
      return 1;
    default:
      return console.debug(`Found invalid horizontal alignment ${e17}`), 0;
  }
}
function s15(e17) {
  switch (e17) {
    case 1:
    case "top":
      return 1;
    case 0:
    case "middle":
      return 0;
    case -1:
    case 2:
    case "baseline":
    case "bottom":
      return -1;
    default:
      return console.debug(`Found invalid vertical alignment ${e17}`), 0;
  }
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/shapingUtils.js
var g4 = 22;
var _2 = 4;
var l11 = g4 + _2;
var u8 = g4 - 6;
var x2 = 3;
var p5 = Math.PI / 180;
var b = 8;
var y5 = 1.5;
var w2 = class {
  constructor(t16, s17, i18, e17) {
    this._rotationT = n2(), this._xBounds = 0, this._yBounds = 0, this.minZoom = 0, this.maxZoom = 255, this._bounds = null;
    const h8 = i18.rect, n23 = new Float32Array(8);
    t16 *= e17, s17 *= e17;
    const r13 = i18.code ? h8.width * e17 : i18.metrics.width, a11 = i18.code ? h8.height * e17 : i18.metrics.height;
    this.width = r13, this.height = a11, n23[0] = t16, n23[1] = s17, n23[2] = t16 + r13, n23[3] = s17, n23[4] = t16, n23[5] = s17 + a11, n23[6] = t16 + r13, n23[7] = s17 + a11, this._data = n23, this._setTextureCoords(h8), this._scale = e17, this._mosaic = i18, this.x = t16, this.y = s17, this.maxOffset = Math.max(t16 + r13, s17 + a11);
  }
  get mosaic() {
    return this._mosaic;
  }
  set angle(s17) {
    this._angle = s17, M(this._rotationT, -s17), this._setOffsets();
  }
  get angle() {
    return this._angle;
  }
  get xTopLeft() {
    return this._data[0];
  }
  get yTopLeft() {
    return this._data[1];
  }
  get xBottomRight() {
    return this._data[6];
  }
  get yBottomRight() {
    return this._data[7];
  }
  get texcoords() {
    return this._texcoords;
  }
  get textureBinding() {
    return this._mosaic.textureBinding;
  }
  get offsets() {
    return this._offsets || this._setOffsets(), this._offsets;
  }
  get char() {
    return String.fromCharCode(this._mosaic.code);
  }
  get code() {
    return this._mosaic.code;
  }
  get bounds() {
    if (!this._bounds) {
      const { height: t16, width: i18 } = this._mosaic.metrics, e17 = i18 * this._scale, n23 = Math.abs(t16) * this._scale, r13 = new Float32Array(8);
      r13[0] = this.x, r13[1] = this.y, r13[2] = this.x + e17, r13[3] = this.y, r13[4] = this.x, r13[5] = this.y + n23, r13[6] = this.x + e17, r13[7] = this.y + n23;
      const a11 = e4(n2(), this._rotationT, this._transform);
      e5(r13, r13, a11);
      let f6 = 1 / 0, c5 = 1 / 0, m5 = -1 / 0, g5 = -1 / 0;
      for (let s17 = 0; s17 < 4; s17++) {
        const t17 = r13[2 * s17], i19 = r13[2 * s17 + 1];
        f6 = Math.min(f6, t17), c5 = Math.min(c5, i19), m5 = Math.max(m5, t17), g5 = Math.max(g5, i19);
      }
      const _4 = m5 - f6, l12 = g5 - c5, u9 = f6 + _4 / 2, x3 = c5 + l12 / 2;
      this._bounds = new i5(u9, x3, _4, l12);
    }
    return this._bounds;
  }
  setTransform(t16) {
    this._transform = t16, this._offsets = null;
  }
  _setOffsets() {
    this._offsets || (this._offsets = { topLeft: [0, 0], topRight: [0, 0], bottomLeft: [0, 0], bottomRight: [0, 0] });
    const t16 = e4(n2(), this._rotationT, this._transform);
    this._offsets.topLeft[0] = this._data[0], this._offsets.topLeft[1] = this._data[1], this._offsets.topRight[0] = this._data[2], this._offsets.topRight[1] = this._data[3], this._offsets.bottomLeft[0] = this._data[4], this._offsets.bottomLeft[1] = this._data[5], this._offsets.bottomRight[0] = this._data[6], this._offsets.bottomRight[1] = this._data[7], S(this._offsets.topLeft, this._offsets.topLeft, t16), S(this._offsets.topRight, this._offsets.topRight, t16), S(this._offsets.bottomLeft, this._offsets.bottomLeft, t16), S(this._offsets.bottomRight, this._offsets.bottomRight, t16);
  }
  _setTextureCoords({ x: t16, y: s17, width: i18, height: e17 }) {
    this._texcoords = { topLeft: [t16, s17], topRight: [t16 + i18, s17], bottomLeft: [t16, s17 + e17], bottomRight: [t16 + i18, s17 + e17] };
  }
};
var L2 = (t16, s17) => ({ code: 0, page: 0, sdf: true, rect: new t4(0, 0, 11, 8), textureBinding: s17, metrics: { advance: 0, height: 4, width: t16, left: 0, top: 0 } });
function M2(t16, s17) {
  return t16.forEach((t17) => S(t17, t17, s17)), { topLeft: t16[0], topRight: t16[1], bottomLeft: t16[2], bottomRight: t16[3] };
}
var R2 = class {
  constructor(t16, s17, i18) {
    this._rotation = 0, this._decorate(t16, s17, i18), this.glyphs = t16, this.bounds = this._createBounds(t16), this.isMultiline = s17.length > 1, this._hasRotation = 0 !== i18.angle, this._transform = this._createGlyphTransform(this.bounds, i18), this._borderLineSizePx = i18.borderLineSizePx, (i18.borderLineSizePx || i18.hasBackground) && ([this.bounds, this.textBox] = this.shapeBackground(this._transform));
    for (const e17 of t16) e17.setTransform(this._transform);
  }
  setRotation(i18) {
    if (0 === i18 && 0 === this._rotation) return;
    this._rotation = i18;
    const e17 = this._transform, h8 = M(n2(), i18);
    e4(e17, h8, e17);
    for (const t16 of this.glyphs) t16.setTransform(this._transform);
  }
  _decorate(t16, s17, i18) {
    if (!i18.decoration || "none" === i18.decoration || !t16.length) return;
    const e17 = i18.scale, o9 = "underline" === i18.decoration ? l11 : u8, h8 = t16[0].textureBinding;
    for (const n23 of s17) {
      const s18 = n23.startX * e17, i19 = n23.startY * e17, r13 = (n23.width + n23.glyphWidthEnd) * e17;
      t16.push(new w2(s18, i19 + o9 * e17, L2(r13, h8), 1));
    }
  }
  shapeBackground(t16) {
    const s17 = this._borderLineSizePx || 0, i18 = (y5 + s17) / 2, e17 = this._borderLineSizePx ? i18 : 0, { xmin: o9, ymin: h8, xmax: n23, ymax: r13, x: a11, y: f6, width: c5, height: m5 } = this.bounds, g5 = [o9 - b, h8 - b], _4 = [n23 + b, h8 - b], l12 = [o9 - b, r13 + b], u9 = [n23 + b, r13 + b], x3 = M2([[g5[0] - i18, g5[1] - i18], [_4[0] + i18, _4[1] - i18], [g5[0] + e17, g5[1] + e17], [_4[0] - e17, _4[1] + e17]], t16), p6 = M2([[l12[0] + e17, l12[1] - e17], [u9[0] - e17, u9[1] - e17], [l12[0] - i18, l12[1] + i18], [u9[0] + i18, u9[1] + i18]], t16), w3 = M2([[g5[0] - i18, g5[1] - i18], [g5[0] + e17, g5[1] + e17], [l12[0] - i18, l12[1] + i18], [l12[0] + e17, l12[1] - e17]], t16), L4 = M2([[_4[0] - e17, _4[1] + e17], [_4[0] + i18, _4[1] - i18], [u9[0] - e17, u9[1] - e17], [u9[0] + i18, u9[1] + i18]], t16), R4 = { main: M2([g5, _4, l12, u9], t16), top: x3, bot: p6, left: w3, right: L4 };
    return [new i5(a11, f6, c5 + 2 * i18, m5 + 2 * i18), R4];
  }
  get boundsT() {
    const t16 = this.bounds, s17 = o(n3(), t16.x, t16.y);
    if (S(s17, s17, this._transform), this._hasRotation) {
      const i18 = Math.max(t16.width, t16.height);
      return new i5(s17[0], s17[1], i18, i18);
    }
    return new i5(s17[0], s17[1], t16.width, t16.height);
  }
  _createBounds(t16) {
    let s17 = 1 / 0, i18 = 1 / 0, e17 = 0, o9 = 0;
    for (const r13 of t16) s17 = Math.min(s17, r13.xTopLeft), i18 = Math.min(i18, r13.yTopLeft), e17 = Math.max(e17, r13.xBottomRight), o9 = Math.max(o9, r13.yBottomRight);
    const h8 = e17 - s17, n23 = o9 - i18;
    return new i5(s17 + h8 / 2, i18 + n23 / 2, h8, n23);
  }
  _createGlyphTransform(t16, s17) {
    const h8 = p5 * s17.angle, n23 = n2(), f6 = n3();
    return i4(n23, n23, o(f6, s17.xOffset, -s17.yOffset)), s17.useCIMAngleBehavior ? s5(n23, n23, h8) : (i4(n23, n23, o(f6, t16.x, t16.y)), s5(n23, n23, h8), i4(n23, n23, o(f6, -t16.x, -t16.y))), n23;
  }
};
var B2 = class {
  constructor(t16, s17, i18, e17, o9, h8) {
    this.glyphWidthEnd = 0, this.startX = 0, this.startY = 0, this.start = Math.max(0, Math.min(s17, i18)), this.end = Math.max(0, Math.max(s17, i18)), this.end < t16.length && (this.glyphWidthEnd = t16[this.end].metrics.width), this.width = e17, this.yMin = o9, this.yMax = h8;
  }
};
var T2 = (t16) => 10 === t16;
var v2 = (t16) => 32 === t16;
function j2(t16, s17, i18) {
  const e17 = new Array(), o9 = 1 / i18.scale, h8 = i18.maxLineWidth * o9, n23 = s17 ? t16.length - 1 : 0, r13 = s17 ? -1 : t16.length, a11 = s17 ? -1 : 1;
  let f6 = n23, c5 = 0, m5 = 0, d = f6, g5 = d, _4 = 0, l12 = 1 / 0, u9 = 0;
  for (; f6 !== r13; ) {
    const { code: s18, metrics: i19 } = t16[f6], o10 = Math.abs(i19.top);
    if (T2(s18) || v2(s18) || (l12 = Math.min(l12, o10), u9 = Math.max(u9, o10 + i19.height)), T2(s18)) f6 !== n23 && (e17.push(new B2(t16, d, f6 - a11, c5, l12 === 1 / 0 ? 0 : l12, u9)), l12 = 1 / 0, u9 = 0), c5 = 0, d = f6 + a11, g5 = f6 + a11, m5 = 0;
    else if (v2(s18)) g5 = f6 + a11, m5 = 0, _4 = i19.advance, c5 += i19.advance;
    else if (c5 > h8) {
      if (g5 !== d) {
        const s19 = g5 - 2 * a11;
        c5 -= _4, e17.push(new B2(t16, d, s19, c5 - m5, l12, u9)), l12 = 1 / 0, u9 = 0, d = g5, c5 = m5;
      } else e17.push(new B2(t16, d, f6 - a11, c5, l12, u9)), l12 = 1 / 0, u9 = 0, d = f6, g5 = f6, c5 = 0;
      c5 += i19.advance, m5 += i19.advance;
    } else c5 += i19.advance, m5 += i19.advance;
    f6 += a11;
  }
  const x3 = new B2(t16, d, f6 - a11, c5, l12, u9);
  return x3.start >= 0 && x3.end < t16.length && e17.push(x3), e17;
}
function A2(t16, s17) {
  let i18 = 0;
  for (let h8 = 0; h8 < t16.length; h8++) {
    const { width: s18 } = t16[h8];
    i18 = Math.max(s18, i18);
  }
  const e17 = "underline" === s17.decoration ? _2 : 0, o9 = t16[0].yMin;
  return { x: 0, y: o9, height: t16[t16.length - 1].yMax + s17.lineHeight * (t16.length - 1) + e17 - o9, width: i18 };
}
function z(t16, s17) {
  const i18 = s17.scale, e17 = new Array(), { glyphs: o9, isRightToLeft: h8 } = t16, n23 = j2(o9, h8, s17), r13 = n23.length ? A2(n23, s17) : { y: 0, height: 0 }, a11 = r12(s17.horizontalAlignment), m5 = n21(s17.verticalAlignment), d = 2 === m5 ? 1 : 0, _4 = d ? 0 : m5 - 1, l12 = (1 - d) * -r13.y + _4 * (r13.height / 2) + (d ? 1 : 0) * -g4;
  for (let f6 = 0; f6 < n23.length; f6++) {
    const { start: h9, end: r14, width: c5 } = n23[f6];
    let m6 = -1 * (a11 + 1) * (c5 / 2) - x2;
    const d2 = (t16.isRightToLeft ? n23.length - 1 - f6 : f6) * s17.lineHeight + l12 - x2;
    n23[f6].startX = m6, n23[f6].startY = d2;
    for (let t17 = h9; t17 <= r14; t17++) {
      const s18 = o9[t17];
      if (T2(s18.code)) continue;
      const h10 = new w2(m6 + s18.metrics.left, d2 - s18.metrics.top, s18, i18);
      m6 += s18.metrics.advance, e17.push(h10);
    }
  }
  return new R2(e17, n23, s17);
}

// node_modules/@arcgis/core/views/2d/layers/graphics/graphicsUtils.js
var i16 = 50;
function m4(n23) {
  if (!n23) return null;
  const { xmin: e17, ymin: t16, xmax: o9, ymax: i18, spatialReference: m5 } = n23;
  return new P({ rings: [[[e17, t16], [e17, i18], [o9, i18], [o9, t16], [e17, t16]]], spatialReference: m5 });
}
function s16(r13) {
  return e3(Math.round(u(r13)));
}
function a10(e17) {
  const r13 = e3(It), i18 = e3(Jt);
  return Math.max(r13, Math.min(e17 || i18, i18));
}

// node_modules/@arcgis/core/symbols/cim/CIMSymbolDrawHelper.js
var st = Math.PI / 180;
var ot = 0.5;
var nt = () => i.getLogger("esri.symbols.cim.CIMSymbolDrawHelper");
var at = class _at {
  constructor(t16) {
    this._t = t16;
  }
  static createIdentity() {
    return new _at([1, 0, 0, 0, 1, 0]);
  }
  clone() {
    const t16 = this._t;
    return new _at(t16.slice());
  }
  transform(t16) {
    const e17 = this._t;
    return [e17[0] * t16[0] + e17[1] * t16[1] + e17[2], e17[3] * t16[0] + e17[4] * t16[1] + e17[5]];
  }
  static createScale(t16, e17) {
    return new _at([t16, 0, 0, 0, e17, 0]);
  }
  scale(t16, e17) {
    const r13 = this._t;
    return r13[0] *= t16, r13[1] *= t16, r13[2] *= t16, r13[3] *= e17, r13[4] *= e17, r13[5] *= e17, this;
  }
  scaleRatio() {
    return Math.sqrt(this._t[0] * this._t[0] + this._t[1] * this._t[1]);
  }
  static createTranslate(t16, e17) {
    return new _at([0, 0, t16, 0, 0, e17]);
  }
  translate(t16, e17) {
    const r13 = this._t;
    return r13[2] += t16, r13[5] += e17, this;
  }
  static createRotate(t16) {
    const e17 = Math.cos(t16), r13 = Math.sin(t16);
    return new _at([e17, -r13, 0, r13, e17, 0]);
  }
  rotate(t16) {
    return _at.multiply(this, _at.createRotate(t16), this);
  }
  angle() {
    const t16 = this._t[0], e17 = this._t[3], r13 = Math.sqrt(t16 * t16 + e17 * e17);
    return [t16 / r13, e17 / r13];
  }
  static multiply(t16, e17, r13) {
    const i18 = t16._t, s17 = e17._t, o9 = i18[0] * s17[0] + i18[3] * s17[1], n23 = i18[1] * s17[0] + i18[4] * s17[1], a11 = i18[2] * s17[0] + i18[5] * s17[1] + s17[2], l12 = i18[0] * s17[3] + i18[3] * s17[4], h8 = i18[1] * s17[3] + i18[4] * s17[4], c5 = i18[2] * s17[3] + i18[5] * s17[4] + s17[5], m5 = r13._t;
    return m5[0] = o9, m5[1] = n23, m5[2] = a11, m5[3] = l12, m5[4] = h8, m5[5] = c5, r13;
  }
  invert() {
    const t16 = this._t;
    let e17 = t16[0] * t16[4] - t16[1] * t16[3];
    if (0 === e17) return new _at([0, 0, 0, 0, 0, 0]);
    e17 = 1 / e17;
    const r13 = (t16[1] * t16[5] - t16[2] * t16[4]) * e17, i18 = (t16[2] * t16[3] - t16[0] * t16[5]) * e17, s17 = t16[4] * e17, o9 = -t16[1] * e17, n23 = -t16[3] * e17, a11 = t16[0] * e17;
    return new _at([s17, o9, r13, n23, a11, i18]);
  }
};
var lt = class {
  constructor(t16, e17) {
    this._resourceManager = t16, this._transfos = [], this._sizeTransfos = [], this._geomUnitsPerPoint = 1, this._placementPool = new e(() => new t6(), void 0, void 0, 100), this._earlyReturn = false, this._mapRotation = 0, this._transfos.push(e17 || at.createIdentity()), this._sizeTransfos.push(e17 ? e17.scaleRatio() : 1);
  }
  setTransform(t16, e17) {
    this._transfos = [t16 || at.createIdentity()], this._sizeTransfos = [e17 || (t16 ? t16.scaleRatio() : 1)];
  }
  setGeomUnitsPerPoint(t16) {
    this._geomUnitsPerPoint = t16;
  }
  transformPt(t16) {
    return this._transfos[this._transfos.length - 1].transform(t16);
  }
  transformSize(t16) {
    return t16 * this._sizeTransfos[this._sizeTransfos.length - 1];
  }
  reverseTransformPt(t16) {
    return this._transfos[this._transfos.length - 1].invert().transform(t16);
  }
  reverseTransformSize(t16) {
    return t16 / this._sizeTransfos[this._sizeTransfos.length - 1];
  }
  reverseTransformScalar(t16) {
    return t16 / this._transfos[this._transfos.length - 1].scaleRatio();
  }
  getTransformAngle() {
    return this._transfos[this._transfos.length - 1].angle();
  }
  geomUnitsPerPoint() {
    return this.isEmbedded() ? 1 : this._geomUnitsPerPoint;
  }
  prevGeomUnitsPerPoint() {
    return this._transfos.length > 2 ? 1 : this._geomUnitsPerPoint;
  }
  isEmbedded() {
    return this._transfos.length > 1;
  }
  back() {
    return this._transfos[this._transfos.length - 1];
  }
  push(t16, e17) {
    const r13 = e17 ? t16.scaleRatio() : 1;
    at.multiply(t16, this.back(), t16), this._transfos.push(t16), this._sizeTransfos.push(this._sizeTransfos[this._sizeTransfos.length - 1] * r13);
  }
  pop() {
    this._transfos.splice(-1, 1), this._sizeTransfos.splice(-1, 1);
  }
  drawSymbol(t16, e17, r13) {
    if (t16) switch (t16.type) {
      case "CIMPointSymbol":
      case "CIMLineSymbol":
      case "CIMPolygonSymbol":
        this.drawMultiLayerSymbol(t16, e17);
        break;
      case "CIMTextSymbol":
        this.drawTextSymbol(t16, e17, r13);
    }
  }
  drawMultiLayerSymbol(t16, e17) {
    if (!t16 || !e17) return;
    const r13 = t16.symbolLayers;
    if (!r13) return;
    const i18 = t16.effects;
    if (i18 && i18.length > 0) {
      const t17 = this.executeEffects(i18, e17);
      if (t17) {
        let e18 = t17.next();
        for (; e18; ) this.drawSymbolLayers(r13, e18.asJSON()), e18 = t17.next();
      }
    } else this.drawSymbolLayers(r13, e17);
  }
  executeEffects(t16, e17) {
    let r13 = new g3(a2.fromJSONCIM(e17));
    for (const i18 of t16) {
      const t17 = R(i18);
      t17 && (r13 = t17.execute(r13, i18, this.geomUnitsPerPoint(), null));
    }
    return r13;
  }
  drawSymbolLayers(t16, e17) {
    let r13 = t16.length;
    for (; r13--; ) {
      const i18 = t16[r13];
      if (!i18 || false === i18.enable) continue;
      const s17 = i18.effects;
      if (s17 && s17.length > 0) {
        const t17 = this.executeEffects(s17, e17);
        if (t17) {
          let e18 = null;
          for (; (e18 = t17.next()) && (this.drawSymbolLayer(i18, e18.asJSON()), !this._earlyReturn); ) ;
        }
      } else this.drawSymbolLayer(i18, e17);
      if (this._earlyReturn) return;
    }
  }
  drawSymbolLayer(t16, e17) {
    switch (t16.type) {
      case "CIMSolidFill":
        this.drawSolidFill(e17, t16.color, t16.path);
        break;
      case "CIMHatchFill":
        this.drawHatchFill(e17, t16);
        break;
      case "CIMPictureFill":
        this.drawPictureFill(e17, t16);
        break;
      case "CIMGradientFill":
        this.drawGradientFill(e17, t16);
        break;
      case "CIMSolidStroke":
        this.drawSolidStroke(e17, t16.color, t16.width, t16.capStyle, t16.joinStyle, t16.miterLimit, t16.path);
        break;
      case "CIMPictureStroke":
        this.drawPictureStroke(e17, t16);
        break;
      case "CIMGradientStroke":
        this.drawGradientStroke(e17, t16);
        break;
      case "CIMCharacterMarker":
      case "CIMPictureMarker":
      case "CIMVectorMarker":
        this.drawMarkerLayer(t16, e17);
    }
  }
  drawHatchFill(t16, e17) {
    const r13 = ft2(e17, t16, this.geomUnitsPerPoint());
    r13 && (this.pushClipPath(t16), this.drawMultiLayerSymbol(e17.lineSymbol, r13), this.popClipPath());
  }
  drawPictureFill(t16, e17) {
  }
  drawGradientFill(t16, e17) {
  }
  drawPictureStroke(t16, e17) {
  }
  drawGradientStroke(t16, e17) {
  }
  drawMarkerLayer(t16, e17) {
    const r13 = t16.markerPlacement;
    if (r13) {
      const i18 = S2(r13);
      if (i18) {
        const s17 = "CIMMarkerPlacementInsidePolygon" === r13.type || "CIMMarkerPlacementPolygonCenter" === r13.type && r13.clipAtBoundary;
        s17 && this.pushClipPath(e17);
        const o9 = i18.execute(a2.fromJSONCIM(e17), r13, this.geomUnitsPerPoint(), null);
        if (o9) {
          let e18 = null;
          for (; (e18 = o9.next()) && (this.drawMarker(t16, e18), !this._earlyReturn); ) ;
        }
        s17 && this.popClipPath();
      }
    } else {
      const r14 = this._placementPool.acquire();
      if (l3(e17)) r14.tx = e17.x, r14.ty = e17.y, this.drawMarker(t16, r14);
      else if (y2(e17)) {
        const i18 = l2(e17);
        i18 && ([r14.tx, r14.ty] = i18, this.drawMarker(t16, r14));
      } else if (s3(e17)) {
        for (const i18 of e17.paths) for (const e18 of i18) if (r14.tx = e18[0], r14.ty = e18[1], this.drawMarker(t16, r14), this._earlyReturn) break;
      } else for (const i18 of e17.points) if (r14.tx = i18[0], r14.ty = i18[1], this.drawMarker(t16, r14), this._earlyReturn) break;
      this._placementPool.release(r14);
    }
  }
  drawMarker(t16, e17) {
    switch (t16.type) {
      case "CIMCharacterMarker":
      case "CIMPictureMarker":
        this.drawPictureMarker(t16, e17);
        break;
      case "CIMVectorMarker":
        this.drawVectorMarker(t16, e17);
    }
  }
  drawPictureMarker(t16, e17) {
    if (!t16) return;
    const r13 = this._resourceManager.getResource(t16.url), i18 = I2(t16.size, o2.CIMPictureMarker.size);
    if (null == r13 || i18 <= 0) return;
    const s17 = r13.width, o9 = r13.height;
    if (!s17 || !o9) return;
    const n23 = s17 / o9, a11 = I2(t16.scaleX, 1), l12 = at.createIdentity(), h8 = t16.anchorPoint;
    if (h8) {
      let e18 = h8.x, r14 = h8.y;
      "Absolute" !== t16.anchorPointUnits && (e18 *= i18 * n23 * a11, r14 *= i18), l12.translate(-e18, -r14);
    }
    let c5 = I2(t16.rotation);
    t16.rotateClockwise && (c5 = -c5), this._mapRotation && (c5 += this._mapRotation), c5 && l12.rotate(c5 * st);
    let m5 = I2(t16.offsetX), f6 = I2(t16.offsetY);
    if (m5 || f6) {
      if (this._mapRotation) {
        const t17 = st * this._mapRotation, e18 = Math.cos(t17), r14 = Math.sin(t17), i19 = m5 * r14 + f6 * e18;
        m5 = m5 * e18 - f6 * r14, f6 = i19;
      }
      l12.translate(m5, f6);
    }
    const u9 = this.geomUnitsPerPoint();
    1 !== u9 && l12.scale(u9, u9);
    const d = e17.getAngle();
    d && l12.rotate(d), l12.translate(e17.tx, e17.ty), this.push(l12, false), this.drawImage(t16, i18), this.pop();
  }
  drawVectorMarker(t16, e17) {
    if (!t16) return;
    const r13 = t16.markerGraphics;
    if (!r13) return;
    const i18 = I2(t16.size, o2.CIMVectorMarker.size), s17 = t16.frame, o9 = s17 ? s17.ymax - s17.ymin : 0, n23 = i18 && o9 ? i18 / o9 : 1, a11 = at.createIdentity();
    s17 && a11.translate(0.5 * -(s17.xmax + s17.xmin), 0.5 * -(s17.ymax + s17.ymin));
    const l12 = t16.anchorPoint;
    if (l12) {
      let e18 = l12.x, r14 = l12.y;
      "Absolute" !== t16.anchorPointUnits ? s17 && (e18 *= s17.xmax - s17.xmin, r14 *= s17.ymax - s17.ymin) : (e18 /= n23, r14 /= n23), a11.translate(-e18, -r14);
    }
    1 !== n23 && a11.scale(n23, n23);
    let h8 = I2(t16.rotation);
    t16.rotateClockwise && (h8 = -h8), this._mapRotation && (h8 += this._mapRotation), h8 && a11.rotate(h8 * st);
    let c5 = I2(t16.offsetX), m5 = I2(t16.offsetY);
    if (c5 || m5) {
      if (this._mapRotation) {
        const t17 = st * this._mapRotation, e18 = Math.cos(t17), r14 = Math.sin(t17), i19 = c5 * r14 + m5 * e18;
        c5 = c5 * e18 - m5 * r14, m5 = i19;
      }
      a11.translate(c5, m5);
    }
    const f6 = this.geomUnitsPerPoint();
    1 !== f6 && a11.scale(f6, f6);
    const u9 = e17.getAngle();
    u9 && a11.rotate(u9), a11.translate(e17.tx, e17.ty), this.push(a11, t16.scaleSymbolsProportionally);
    for (const d of r13) {
      d?.symbol && d.geometry || nt().error("Invalid marker graphic", d);
      let t17 = d.textString;
      if ("number" == typeof t17 && (t17 = t17.toString()), this.drawSymbol(d.symbol, d.geometry, t17), this._earlyReturn) break;
    }
    this.pop();
  }
  drawTextSymbol(t16, e17, r13) {
    if (!t16) return;
    if (!l3(e17)) return;
    if (I2(t16.height, o2.CIMTextSymbol.height) <= 0) return;
    const i18 = at.createIdentity();
    let s17 = I2(t16.angle);
    s17 = -s17, s17 && i18.rotate(s17 * st);
    const o9 = I2(t16.offsetX), n23 = I2(t16.offsetY);
    (o9 || n23) && i18.translate(o9, n23);
    const a11 = this.geomUnitsPerPoint();
    1 !== a11 && i18.scale(a11, a11), i18.translate(e17.x, e17.y), this.push(i18, false), this.drawText(t16, r13), this.pop();
  }
};
var ht = class extends lt {
  constructor(t16, e17) {
    super(t16, e17), this.reset();
  }
  reset() {
    this._xmin = this._ymin = 1 / 0, this._xmax = this._ymax = -1 / 0, this._clipCount = 0;
  }
  envelope() {
    return new t13(this._xmin, this._ymin, this._xmax - this._xmin, this._ymax - this._ymin);
  }
  bounds() {
    return e2(this._xmin, this._ymin, this._xmax, this._ymax);
  }
  drawSolidFill(t16) {
    if (t16 && !(this._clipCount > 0)) if (y2(t16)) this._processPath(t16.rings, 0);
    else if (s3(t16)) this._processPath(t16.paths, 0);
    else if (m(t16)) {
      const e17 = pt(t16);
      e17 && this._processPath(e17.rings, 0);
    } else console.error("drawSolidFill Unexpected geometry type!");
  }
  drawSolidStroke(t16, e17, r13) {
    if (!t16 || this._clipCount > 0 || null == r13 || r13 <= 0) return;
    const i18 = Math.max(0.5 * this.transformSize(I2(r13, o2.CIMSolidStroke.width)), 0.5 * ot);
    if (y2(t16)) this._processPath(t16.rings, i18);
    else if (s3(t16)) this._processPath(t16.paths, i18);
    else if (m(t16)) {
      const e18 = pt(t16);
      e18 && this._processPath(e18.rings, i18);
    } else console.error("drawSolidStroke unexpected geometry type!");
  }
  drawMarkerLayer(t16, e17) {
    y2(e17) && t16.markerPlacement && ("CIMMarkerPlacementInsidePolygon" === t16.markerPlacement.type || "CIMMarkerPlacementPolygonCenter" === t16.markerPlacement.type && t16.markerPlacement.clipAtBoundary) ? this._processPath(e17.rings, 0) : super.drawMarkerLayer(t16, e17);
  }
  drawHatchFill(t16, e17) {
    this.drawSolidFill(t16);
  }
  drawPictureFill(t16, e17) {
    this.drawSolidFill(t16);
  }
  drawGradientFill(t16, e17) {
    this.drawSolidFill(t16);
  }
  drawPictureStroke(t16, e17) {
    this.drawSolidStroke(t16, null, e17.width);
  }
  drawGradientStroke(t16, e17) {
    this.drawSolidStroke(t16, null, e17.width);
  }
  pushClipPath(t16) {
    this.drawSolidFill(t16), this._clipCount++;
  }
  popClipPath() {
    this._clipCount--;
  }
  drawImage(t16, e17) {
    const { url: r13 } = t16, i18 = I2(t16.scaleX, 1);
    let s17 = i18 * e17, o9 = e17;
    const n23 = this._resourceManager.getResource(r13);
    if (null != n23) {
      const t17 = n23.height / n23.width;
      s17 = i18 * (e17 ? t17 > 1 ? e17 : e17 / t17 : n23.width), o9 = e17 ? t17 > 1 ? e17 * t17 : e17 : n23.height;
    }
    this._merge(this.transformPt([-s17 / 2, -o9 / 2]), 0), this._merge(this.transformPt([-s17 / 2, o9 / 2]), 0), this._merge(this.transformPt([s17 / 2, -o9 / 2]), 0), this._merge(this.transformPt([s17 / 2, o9 / 2]), 0);
  }
  drawText(t16, e17) {
    if (!e17 || 0 === e17.length) return;
    this._textRasterizer || (this._textRasterizer = new s14());
    const r13 = yt(t16);
    let [i18, s17] = this._textRasterizer.computeTextSize(e17, r13);
    i18 = e3(i18), s17 = e3(s17);
    const n23 = this.transformSize(1) * this.reverseTransformScalar(1);
    i18 *= n23, s17 *= n23;
    let a11 = 0;
    switch (t16.horizontalAlignment) {
      case "Left":
        a11 = i18 / 2;
        break;
      case "Right":
        a11 = -i18 / 2;
    }
    let l12 = 0;
    switch (t16.verticalAlignment) {
      case "Bottom":
        l12 = s17 / 2;
        break;
      case "Top":
        l12 = -s17 / 2;
        break;
      case "Baseline":
        l12 = s17 / 6;
    }
    this._merge(this.transformPt([-i18 / 2 + a11, -s17 / 2 + l12]), 0), this._merge(this.transformPt([-i18 / 2 + a11, s17 / 2 + l12]), 0), this._merge(this.transformPt([i18 / 2 + a11, -s17 / 2 + l12]), 0), this._merge(this.transformPt([i18 / 2 + a11, s17 / 2 + l12]), 0);
  }
  _processPath(t16, e17) {
    if (t16) for (const r13 of t16) {
      const t17 = r13 ? r13.length : 0;
      if (t17 > 1) {
        this._merge(this.transformPt(r13[0]), e17);
        for (let i18 = 1; i18 < t17; i18++) this._merge(this.transformPt(r13[i18]), e17);
      }
    }
  }
  _merge(t16, e17) {
    t16[0] - e17 < this._xmin && (this._xmin = t16[0] - e17), t16[0] + e17 > this._xmax && (this._xmax = t16[0] + e17), t16[1] - e17 < this._ymin && (this._ymin = t16[1] - e17), t16[1] + e17 > this._ymax && (this._ymax = t16[1] + e17);
  }
};
var ct = class extends lt {
  constructor() {
    super(...arguments), this._searchPoint = [0, 0], this._searchDistPoint = 0, this._textInfo = null, this._svg = null, this._path = null, this._canvas = null;
  }
  destroy() {
    this._svg = n20(this._svg), this._path = null, this._canvas = null;
  }
  hitTest(t16, e17, r13, i18, s17, a11) {
    const l12 = a11 * u(1);
    this.setTransform(), this.setGeomUnitsPerPoint(l12), this._searchPoint = [(t16[0] + t16[2]) / 2, (t16[1] + t16[3]) / 2], this._searchDistPoint = (t16[2] - t16[0]) / 2 / l12, this._textInfo = i18;
    const h8 = e17 && ("CIMPointSymbol" === e17.type && "Map" !== e17.angleAlignment || "CIMTextSymbol" === e17.type);
    if (this._mapRotation = h8 ? s17 : 0, !has("esri-mobile")) {
      const t17 = e3(W * window.devicePixelRatio), r14 = e3(X);
      !(("CIMLineSymbol" === e17?.type || "CIMPolygonSymbol" === e17?.type) && e17.symbolLayers?.some(p)) && "CIMMeshSymbol" !== e17?.type && (U(e17) ?? 0) < r14 && (this._searchDistPoint = t17);
    }
    return this._earlyReturn = false, this.drawSymbol(e17, r13), this._earlyReturn;
  }
  executeEffects(t16, e17) {
    return "CIMGeometricEffectDashes" === t16.at(-1)?.type && (t16 = t16.slice(0, -1)), super.executeEffects(t16, e17);
  }
  drawSolidFill(t16, e17, r13) {
    null != r13 ? this._hittestSvgPath(t16, r13, true) : this._hitTestFill(t16);
  }
  drawHatchFill(t16, e17) {
    this._hitTestFill(t16);
  }
  drawPictureFill(t16, e17) {
    this._hitTestFill(t16);
  }
  drawGradientFill(t16, e17) {
    this._hitTestFill(t16);
  }
  drawSolidStroke(t16, e17, r13, i18, s17, o9, n23) {
    null != n23 ? this._hittestSvgPath(t16, n23, false, r13) : this._hitTestStroke(t16, r13);
  }
  drawPictureStroke(t16, e17) {
    this._hitTestStroke(t16, e17.width);
  }
  drawGradientStroke(t16, e17) {
    this._hitTestStroke(t16, e17.width);
  }
  drawMarkerLayer(t16, e17) {
    t16.markerPlacement && ("CIMMarkerPlacementInsidePolygon" === t16.markerPlacement.type || "CIMMarkerPlacementPolygonCenter" === t16.markerPlacement.type && t16.markerPlacement.clipAtBoundary) ? this._hitTestFill(e17) : super.drawMarkerLayer(t16, e17);
  }
  pushClipPath(t16) {
  }
  popClipPath() {
  }
  drawImage(t16, e17) {
    const { url: r13 } = t16, i18 = I2(t16.scaleX, 1), s17 = this._resourceManager.getResource(r13);
    if (null == s17 || 0 === s17.height || 0 === e17) return;
    const o9 = e17 * this.geomUnitsPerPoint(), n23 = o9 * i18 * (s17.width / s17.height), a11 = this.reverseTransformPt(this._searchPoint), l12 = this._searchDistPoint;
    Math.abs(a11[0]) < n23 / 2 + l12 && Math.abs(a11[1]) < o9 / 2 + l12 && (this._earlyReturn = true);
  }
  drawText(t16, e17) {
    const r13 = this._textInfo;
    if (!r13) return;
    const i18 = r13.get(t16);
    if (!i18) return;
    if (!i18.glyphMosaicItems.glyphs.length) return;
    const s17 = s16(I2(t16.height, o2.CIMTextSymbol.height)), { lineGapType: o9, lineGap: n23 } = t16, a11 = o9 ? _t2(o9, I2(n23), s17) : 0, l12 = "CIMBackgroundCallout" === t16.callout?.type, h8 = z(i18.glyphMosaicItems, { scale: s17 / q, angle: 0, xOffset: 0, yOffset: 0, horizontalAlignment: t16.horizontalAlignment, verticalAlignment: t16.verticalAlignment, maxLineWidth: a10(t16.lineWidth), lineHeight: l4 * Math.max(0.25, Math.min(a11 || 1, 4)), decoration: t16.font.decoration || "none", useCIMAngleBehavior: true, hasBackground: l12 }), c5 = this.reverseTransformPt(this._searchPoint), m5 = c5[0], f6 = c5[1];
    for (const u9 of h8.glyphs) if (m5 > u9.xTopLeft && m5 < u9.xBottomRight && f6 > -u9.yBottomRight && f6 < -u9.yTopLeft) {
      this._earlyReturn = true;
      break;
    }
  }
  _hitTestFill(t16) {
    let e17 = null;
    if (m(t16)) {
      const r14 = t16;
      e17 = [[[r14.xmin, r14.ymin], [r14.xmin, r14.ymax], [r14.xmax, r14.ymax], [r14.xmax, r14.ymin], [r14.xmin, r14.ymin]]];
    } else if (y2(t16)) e17 = t16.rings;
    else {
      if (!s3(t16)) return;
      e17 = t16.paths;
    }
    const r13 = this.reverseTransformPt(this._searchPoint);
    if (ut(r13, e17) && (this._earlyReturn = true), !this._earlyReturn) {
      dt(r13, e17, this.reverseTransformScalar(this._searchDistPoint) * this.prevGeomUnitsPerPoint()) && (this._earlyReturn = true);
    }
  }
  _getSvgPath() {
    return null != this._svg && null != this._path || (this._svg ??= e16(), this._path ??= t14("path"), this._svg.appendChild(this._path)), this._path;
  }
  _getCanvasContext(t16, e17) {
    return this._canvas ??= document.createElement("canvas"), this._canvas.width = t16, this._canvas.height = e17, this._canvas.getContext("2d", { willReadFrequently: true });
  }
  _hittestSvgPath(t16, e17, r13, i18 = 0) {
    const s17 = this.reverseTransformScalar(this._searchDistPoint) * this.prevGeomUnitsPerPoint(), o9 = this.reverseTransformPt(this._searchPoint), n23 = i2();
    f3(n23, t16);
    const a11 = { x: n23[0], y: n23[1], width: n23[2] - n23[0], height: n23[3] - n23[1] }, h8 = this._getSvgPath();
    h8.setAttribute("d", e17);
    const c5 = h8.getBBox();
    let m5 = Math.max(c5.width / a11.width, c5.height / a11.height), f6 = 1;
    const u9 = 2 * s17 * m5;
    u9 < 1 && (f6 = 2 / u9, m5 *= f6, c5.x *= f6, c5.y *= f6, c5.width *= f6, c5.height *= f6);
    const d = 1 + i18 * m5 / 2, g5 = this._getCanvasContext(c5.width + 2 * d, c5.height + 2 * d);
    g5.setTransform(f6, 0, 0, f6, -c5.x + d, -c5.y + d);
    const _4 = new Path2D(e17);
    r13 ? g5.fill(_4) : (g5.lineWidth = i18 * (m5 / f6), g5.stroke(_4));
    const y6 = (a11.width * m5 - c5.width) / 2, P3 = (a11.height * m5 - c5.height) / 2, S3 = Math.floor((o9[0] - a11.x - s17) * m5 - y6 + d), w3 = Math.floor((a11.height - (o9[1] - a11.y) - s17) * m5 + P3 + d), x3 = Math.ceil(2 * s17 * m5), M3 = Math.ceil(2 * s17 * m5), b2 = g5.getImageData(S3, w3, x3, M3).data;
    for (let l12 = 3; l12 < b2.length; l12 += 4) if (b2[l12] > 127.5) return void (this._earlyReturn = true);
  }
  _hitTestStroke(t16, e17) {
    let r13 = null;
    if (m(t16)) {
      const e18 = t16;
      r13 = [[[e18.xmin, e18.ymin], [e18.xmin, e18.ymax], [e18.xmax, e18.ymax], [e18.xmax, e18.ymin], [e18.xmin, e18.ymin]]];
    } else if (y2(t16)) r13 = t16.rings;
    else {
      if (!s3(t16)) return;
      r13 = t16.paths;
    }
    dt(this.reverseTransformPt(this._searchPoint), r13, I2(e17, o2.CIMSolidStroke.width) * this.geomUnitsPerPoint() / 2 + this.reverseTransformScalar(this._searchDistPoint) * this.prevGeomUnitsPerPoint()) && (this._earlyReturn = true);
  }
};
var mt = class extends lt {
  constructor(t16, e17, r13, i18) {
    super(e17, r13), this._applyAdditionalRenderProps = i18, this._colorSubstitutionHelper = new t10(), this._ctx = t16;
  }
  drawSolidFill(t16, e17) {
    if (!t16) return;
    if (y2(t16)) this._buildPath(t16.rings, true);
    else if (s3(t16)) this._buildPath(t16.paths, true);
    else if (m(t16)) this._buildPath(pt(t16).rings, true);
    else {
      if (!u2(t16)) return;
      console.log("CanvasDrawHelper.drawSolidFill - No implementation!");
    }
    const r13 = this._ctx;
    r13.fillStyle = "string" == typeof e17 ? e17 : "rgba(" + Math.round(e17[0]) + "," + Math.round(e17[1]) + "," + Math.round(e17[2]) + "," + (e17[3] ?? 255) / 255 + ")", r13.fill("evenodd");
  }
  drawSolidStroke(t16, e17, r13, i18, s17, o9) {
    if (!t16 || !e17 || 0 === r13) return;
    if (y2(t16)) this._buildPath(t16.rings, true);
    else if (s3(t16)) this._buildPath(t16.paths, false);
    else {
      if (!m(t16)) return void console.log("CanvasDrawHelper.drawSolidStroke isn't implemented!");
      this._buildPath(pt(t16).rings, true);
    }
    const n23 = this._ctx;
    n23.strokeStyle = "string" == typeof e17 ? e17 : "rgba(" + Math.round(e17[0]) + "," + Math.round(e17[1]) + "," + Math.round(e17[2]) + "," + (e17[3] ?? 255) / 255 + ")", n23.lineWidth = Math.max(this.transformSize(r13), ot), this._setCapStyle(i18), this._setJoinStyle(s17), n23.miterLimit = o9, n23.stroke();
  }
  pushClipPath(t16) {
    if (this._ctx.save(), y2(t16)) this._buildPath(t16.rings, true);
    else if (s3(t16)) this._buildPath(t16.paths, true);
    else {
      if (!m(t16)) return;
      this._buildPath(pt(t16).rings, true);
    }
    this._ctx.clip("evenodd");
  }
  popClipPath() {
    this._ctx.restore();
  }
  drawImage(t16, e17) {
    const { colorSubstitutions: r13, url: i18, tintColor: s17 } = t16, o9 = I2(t16.scaleX, 1), n23 = this._resourceManager.getResource(i18);
    if (null == n23) return;
    let a11 = e17 * (n23.width / n23.height), l12 = e17;
    e17 || (a11 = n23.width, l12 = n23.height);
    const h8 = G(i18) || "src" in n23 && G(n23.src);
    let c5 = "getFrame" in n23 ? t11(n23) : n23;
    r13 && (c5 = this._colorSubstitutionHelper.applyColorSubstitution(c5, r13)), this._applyAdditionalRenderProps && !h8 && s17 && (c5 = this._colorSubstitutionHelper.tintImageData(c5, s17));
    const m5 = this.transformPt([0, 0]), [f6, u9] = this.getTransformAngle(), d = this.transformSize(1), g5 = this._ctx;
    g5.save(), g5.setTransform({ m11: o9 * d * f6, m12: o9 * d * u9, m21: -d * u9, m22: d * f6, m41: m5[0], m42: m5[1] }), g5.drawImage(c5, -a11 / 2, -l12 / 2, a11, l12), g5.restore();
  }
  drawText(t16, e17) {
    if (!e17 || 0 === e17.length) return;
    this._textRasterizer || (this._textRasterizer = new s14());
    const r13 = yt(t16, this.transformSize(e3(1))), i18 = this._textRasterizer.rasterizeText(e17, r13);
    if (!i18) return;
    const { size: s17, anchorX: n23, anchorY: a11, canvas: l12 } = i18, h8 = s17[0] * (n23 + 0.5), c5 = s17[1] * (a11 - 0.5), m5 = this._ctx, f6 = this.transformPt([0, 0]), [u9, d] = this.getTransformAngle(), g5 = 1;
    m5.save(), m5.setTransform({ m11: g5 * u9, m12: g5 * d, m21: -g5 * d, m22: g5 * u9, m41: f6[0] - g5 * h8, m42: f6[1] + g5 * c5 }), m5.drawImage(l12, 0, 0), m5.restore();
  }
  drawPictureFill(t16, e17) {
    if (!t16) return;
    let { colorSubstitutions: r13, height: i18, offsetX: s17, offsetY: o9, rotation: n23, scaleX: a11, tintColor: l12, url: h8 } = e17;
    const c5 = this._resourceManager.getResource(h8);
    if (null == c5) return;
    if (y2(t16)) this._buildPath(t16.rings, true);
    else if (s3(t16)) this._buildPath(t16.paths, true);
    else if (m(t16)) this._buildPath(pt(t16).rings, true);
    else {
      if (!u2(t16)) return;
      console.log("CanvasDrawHelper.drawPictureFill - No implementation!");
    }
    const m5 = this._ctx, f6 = G(h8) || "src" in c5 && G(c5.src);
    let u9, d = "getFrame" in c5 ? t11(c5) : c5;
    if (r13 && (d = this._colorSubstitutionHelper.applyColorSubstitution(d, r13)), this._applyAdditionalRenderProps) {
      f6 || l12 && (d = this._colorSubstitutionHelper.tintImageData(d, l12)), u9 = m5.createPattern(d, "repeat");
      const t17 = this.transformSize(1);
      n23 || (n23 = 0), s17 ? s17 *= t17 : s17 = 0, o9 ? o9 *= t17 : o9 = 0, i18 && (i18 *= t17);
      const e18 = i18 ? i18 / c5.height : 1, r14 = a11 && i18 ? a11 * i18 / c5.width : 1;
      if (0 !== n23 || 1 !== e18 || 1 !== r14 || 0 !== s17 || 0 !== o9) {
        const t18 = new DOMMatrix();
        t18.rotateSelf(0, 0, -n23).translateSelf(s17, o9).scaleSelf(r14, e18, 1), u9.setTransform(t18);
      }
    } else u9 = m5.createPattern(d, "repeat");
    m5.save(), m5.fillStyle = u9, m5.fill("evenodd"), m5.restore();
  }
  drawPictureStroke(t16, r13) {
    if (!t16) return;
    let { colorSubstitutions: i18, capStyle: s17, joinStyle: o9, miterLimit: a11, tintColor: l12, url: h8, width: c5 } = r13;
    const m5 = this._resourceManager.getResource(h8);
    if (null == m5) return;
    let f6;
    if (y2(t16)) f6 = t16.rings;
    else if (s3(t16)) f6 = t16.paths;
    else {
      if (!m(t16)) return u2(t16) ? void console.log("CanvasDrawHelper.drawPictureStroke - No implementation!") : void 0;
      f6 = pt(t16).rings;
    }
    c5 || (c5 = m5.width);
    const u9 = G(h8) || "src" in m5 && G(m5.src);
    let d = "getFrame" in m5 ? t11(m5) : m5;
    i18 && (d = this._colorSubstitutionHelper.applyColorSubstitution(d, i18)), this._applyAdditionalRenderProps && (u9 || l12 && (d = this._colorSubstitutionHelper.tintImageData(d, l12)));
    const g5 = Math.max(this.transformSize(u(c5)), 0.5), p6 = g5 / d.width, _4 = this._ctx, x3 = _4.createPattern(d, "repeat-y");
    let M3, b2;
    _4.save(), this._setCapStyle(s17), this._setJoinStyle(o9), void 0 !== a11 && (_4.miterLimit = a11), _4.lineWidth = g5;
    for (let n23 of f6) if (n23 = a(n23), St(n23), n23 && !(n23.length <= 1)) {
      M3 = this.transformPt(n23[0]);
      for (let t17 = 1; t17 < n23.length; t17++) {
        b2 = this.transformPt(n23[t17]);
        const e17 = gt(M3, b2), r14 = new DOMMatrix();
        r14.translateSelf(0, M3[1] - g5 / 2).scaleSelf(p6, p6, 1).rotateSelf(0, 0, 90 - e17), x3.setTransform(r14), _4.strokeStyle = x3, _4.beginPath(), _4.moveTo(M3[0], M3[1]), _4.lineTo(b2[0], b2[1]), _4.stroke(), M3 = b2;
      }
    }
    _4.restore();
  }
  drawGradientFill(t16, e17) {
    if (!t16) return;
    let r13;
    if (y2(t16)) r13 = t16.rings;
    else if (s3(t16)) r13 = t16.paths;
    else {
      if (!m(t16)) return void nt().error("Unable to draw gradient fill");
      r13 = pt(t16).rings;
    }
    this._buildPath(r13, true);
    const { angle: s17, gradientMethod: o9, gradientSize: a11, gradientSizeUnits: l12 } = e17, h8 = o2.CIMGradientFill, p6 = e17.gradientType ?? h8.gradientType, _4 = -s2(s17 ?? 0), w3 = K();
    for (const i18 of r13) {
      const t17 = i18 ? i18.length : 0;
      if (t17 > 1) for (let e18 = 0; e18 < t17; e18++) {
        let t18 = this.transformPt(i18[e18]);
        "Linear" !== o9 && "Rectangular" !== o9 || (t18 = t12(t18, -_4)), f2(w3, t18);
      }
    }
    const [x3, M3, b2, k] = w3, C2 = this._ctx;
    switch (C2.save(), o9) {
      case "Buffered":
        nt().error(`Gradient method "${o9}" currently unsupported.`);
        break;
      case "Linear": {
        const t17 = (M3 + k) / 2, r14 = "Absolute" === l12 ? this.transformSize(u(a11)) : ee(a11, h8.gradientSize) * (b2 - x3), [i18, s18] = "Discrete" === p6 ? [b2, b2 - r14] : [x3 + r14, x3], o10 = t12([i18, t17], _4), c5 = t12([s18, t17], _4), m5 = C2.createLinearGradient(o10[0], o10[1], c5[0], c5[1]);
        p2(m5, e17), C2.fillStyle = m5, C2.fill("evenodd");
        break;
      }
      case "Circular": {
        const t17 = g(w3), r14 = j(w3) / 2, i18 = "Absolute" === l12 ? this.transformSize(u(a11)) : ee(a11, h8.gradientSize) * r14, [s18, o10] = "Discrete" === p6 ? [r14, r14 - i18] : [i18, 0], c5 = C2.createRadialGradient(t17[0], t17[1], s18, t17[0], t17[1], o10);
        p2(c5, e17), C2.fillStyle = c5, C2.fill("evenodd");
        break;
      }
      case "Rectangular": {
        const r14 = g(w3), i18 = r14[0], s18 = r14[1], o10 = t12(r14, _4), c5 = (r15, i19, s19, n23, a12, l13, h9, c6) => {
          C2.save(), this.pushClipPath(t16);
          const m6 = t12([a12, l13], _4), f6 = t12([h9, c6], _4);
          C2.beginPath(), C2.moveTo(o10[0], o10[1]), C2.lineTo(m6[0], m6[1]), C2.lineTo(f6[0], f6[1]), C2.lineTo(o10[0], o10[1]), C2.clip();
          const u9 = t12([r15, i19], _4), d = t12([s19, n23], _4), g6 = C2.createLinearGradient(u9[0], u9[1], d[0], d[1]);
          p2(g6, e17), C2.fillStyle = g6, C2.fill("evenodd"), C2.restore();
        };
        let m5 = "Absolute" === l12 ? this.transformSize(u(a11)) : ee(a11, h8.gradientSize) * (l(w3) / 2), [g5, y6] = "Discrete" === p6 ? [b2, b2 - m5] : [i18 + m5, i18];
        c5(g5, s18, y6, s18, b2, M3, b2, k), [g5, y6] = "Discrete" === p6 ? [x3, x3 + m5] : [i18 - m5, i18], c5(g5, s18, y6, s18, x3, k, x3, M3), m5 = "Absolute" === l12 ? this.transformSize(u(a11)) : ee(a11, h8.gradientSize) * (y(w3) / 2);
        let [P3, S3] = "Discrete" === p6 ? [k, k - m5] : [s18 + m5, s18];
        c5(i18, P3, i18, S3, b2, k, x3, k), [P3, S3] = "Discrete" === p6 ? [M3, M3 + m5] : [s18 - m5, s18], c5(i18, P3, i18, S3, x3, M3, b2, M3);
        break;
      }
    }
    C2.restore();
  }
  drawGradientStroke(t16, r13) {
    const { capStyle: i18, gradientMethod: s17, gradientSize: o9, gradientSizeUnits: a11, joinStyle: l12, miterLimit: h8, width: c5 } = r13;
    if (!t16 || 0 === c5) return;
    let m5;
    if (y2(t16)) m5 = t16.rings;
    else if (s3(t16)) m5 = t16.paths;
    else {
      if (!m(t16)) return void nt().error("Unable to draw gradient stroke");
      m5 = pt(t16).rings;
    }
    const f6 = r13.gradientType ?? o2.CIMGradientStroke.gradientType, u9 = Math.max(this.transformSize(u(c5)), 0.5), d = this._ctx;
    let g5, p6;
    d.save(), this._setCapStyle(i18), this._setJoinStyle(l12), void 0 !== h8 && (d.miterLimit = h8), d.lineWidth = u9;
    for (let _4 of m5) {
      if (_4 = a(_4), St(_4), !_4 || _4.length <= 1) continue;
      let t17 = 0;
      g5 = this.transformPt(_4[0]);
      for (let e17 = 1; e17 < _4.length; e17++) {
        p6 = this.transformPt(_4[e17]);
        const r14 = p6[0] - g5[0], i20 = p6[1] - g5[1];
        t17 += Math.sqrt(r14 * r14 + i20 * i20), g5 = p6;
      }
      const i19 = "Absolute" === a11 ? this.transformSize(u(o9)) : ee(o9, o2.CIMGradientStroke.gradientSize) * ("AcrossLine" === s17 ? u9 : t17);
      let l13 = 0;
      g5 = this.transformPt(_4[0]);
      for (let e17 = 1; e17 < _4.length; e17++) {
        p6 = this.transformPt(_4[e17]);
        const o10 = p6[0] - g5[0], n23 = p6[1] - g5[1], a12 = Math.sqrt(o10 * o10 + n23 * n23);
        let h9, c6, m6, y6;
        switch (s17) {
          case "AcrossLine": {
            const [t18, e18] = t12([o10 / a12, n23 / a12], -Math.PI / 2), r14 = u9 / 2, s18 = "Discrete" === f6 ? r14 : i19 - r14;
            h9 = (g5[0] + p6[0]) / 2 + t18 * s18, c6 = (g5[1] + p6[1]) / 2 + e18 * s18, m6 = h9 - t18 * i19, y6 = c6 - e18 * i19;
            break;
          }
          case "AlongLine": {
            const e18 = o10 / a12, r14 = n23 / a12;
            "Discrete" === f6 ? (h9 = g5[0] - e18 * l13, c6 = g5[1] - r14 * l13, m6 = h9 + e18 * i19, y6 = c6 + r14 * i19) : (m6 = g5[0] + e18 * (t17 - l13), y6 = g5[1] + r14 * (t17 - l13), h9 = m6 - e18 * i19, c6 = y6 - r14 * i19);
            break;
          }
          default:
            return nt().error("Unrecognized gradient method:", s17), void d.restore();
        }
        const P3 = d.createLinearGradient(h9, c6, m6, y6);
        p2(P3, r13), d.strokeStyle = P3, d.beginPath(), d.moveTo(g5[0], g5[1]), d.lineTo(p6[0], p6[1]), d.stroke(), l13 += a12, g5 = p6;
      }
    }
    d.restore();
  }
  _buildPath(t16, e17) {
    const r13 = this._ctx;
    if (r13.beginPath(), t16) for (const i18 of t16) {
      const t17 = i18 ? i18.length : 0;
      if (t17 > 1) {
        let s17 = this.transformPt(i18[0]);
        r13.moveTo(s17[0], s17[1]);
        for (let e18 = 1; e18 < t17; e18++) s17 = this.transformPt(i18[e18]), r13.lineTo(s17[0], s17[1]);
        e17 && r13.closePath();
      }
    }
  }
  _setCapStyle(t16) {
    switch (t16) {
      case "Butt":
        this._ctx.lineCap = "butt";
        break;
      case "Round":
        this._ctx.lineCap = "round";
        break;
      case "Square":
        this._ctx.lineCap = "square";
    }
  }
  _setJoinStyle(t16) {
    switch (t16) {
      case "Bevel":
        this._ctx.lineJoin = "bevel";
        break;
      case "Round":
        this._ctx.lineJoin = "round";
        break;
      case "Miter":
        this._ctx.lineJoin = "miter";
    }
  }
};
function ft2(t16, e17, r13) {
  let i18 = I2(t16.separation, o2.CIMHatchFill.separation) * r13, s17 = I2(t16.rotation);
  if (0 === i18) return null;
  i18 < 0 && (i18 = -i18);
  let o9 = 0;
  const n23 = 0.5 * i18;
  for (; o9 > n23; ) o9 -= i18;
  for (; o9 < -n23; ) o9 += i18;
  const a11 = i2();
  f3(a11, e17), a11[0] -= n23, a11[1] -= n23, a11[2] += n23, a11[3] += n23;
  const h8 = [[a11[0], a11[1]], [a11[0], a11[3]], [a11[2], a11[3]], [a11[2], a11[1]]];
  for (; s17 > 180; ) s17 -= 180;
  for (; s17 < 0; ) s17 += 180;
  const c5 = Math.cos(s17 * st), m5 = Math.sin(s17 * st), f6 = -i18 * m5, u9 = i18 * c5;
  let d, g5, _4, y6;
  o9 = I2(t16.offsetX) * r13 * m5 - I2(t16.offsetY) * r13 * c5, d = _4 = Number.MAX_VALUE, g5 = y6 = -Number.MAX_VALUE;
  for (const l12 of h8) {
    const t17 = l12[0], e18 = l12[1], r14 = c5 * t17 + m5 * e18, i19 = -m5 * t17 + c5 * e18;
    d = Math.min(d, r14), _4 = Math.min(_4, i19), g5 = Math.max(g5, r14), y6 = Math.max(y6, i19);
  }
  _4 = Math.floor(_4 / i18) * i18;
  let P3 = c5 * d - m5 * _4 - f6 * o9 / i18, S3 = m5 * d + c5 * _4 - u9 * o9 / i18, w3 = c5 * g5 - m5 * _4 - f6 * o9 / i18, x3 = m5 * g5 + c5 * _4 - u9 * o9 / i18;
  const M3 = 1 + Math.round((y6 - _4) / i18), b2 = [];
  for (let l12 = 0; l12 < M3; l12++) P3 += f6, S3 += u9, w3 += f6, x3 += u9, b2.push([[P3, S3], [w3, x3]]);
  return { paths: b2 };
}
function ut(t16, e17) {
  let r13 = 0;
  for (const i18 of e17) {
    const e18 = i18.length;
    for (let s17 = 1; s17 < e18; s17++) {
      const e19 = i18[s17 - 1], o9 = i18[s17];
      if (e19[1] > t16[1] == o9[1] > t16[1]) continue;
      (o9[0] - e19[0]) * (t16[1] - e19[1]) - (o9[1] - e19[1]) * (t16[0] - e19[0]) > 0 ? r13++ : r13--;
    }
  }
  return 0 !== r13;
}
function dt(t16, e17, r13) {
  for (const i18 of e17) {
    const e18 = i18.length;
    for (let s17 = 1; s17 < e18; s17++) {
      const e19 = i18[s17 - 1], o9 = i18[s17];
      let n23 = (o9[0] - e19[0]) * (o9[0] - e19[0]) + (o9[1] - e19[1]) * (o9[1] - e19[1]);
      if (0 === n23) continue;
      n23 = Math.sqrt(n23);
      const a11 = ((o9[0] - e19[0]) * (t16[1] - e19[1]) - (o9[1] - e19[1]) * (t16[0] - e19[0])) / n23;
      if (Math.abs(a11) < r13) {
        const i19 = ((o9[0] - e19[0]) * (t16[0] - e19[0]) + (o9[1] - e19[1]) * (t16[1] - e19[1])) / n23;
        if (i19 > -r13 && i19 < n23 + r13) return true;
      }
    }
  }
  return false;
}
function gt(t16, e17) {
  const r13 = e17[0] - t16[0], i18 = e17[1] - t16[1];
  return 180 / Math.PI * Math.atan2(i18, r13);
}
var pt = (t16) => t16 ? { spatialReference: t16.spatialReference, rings: [[[t16.xmin, t16.ymin], [t16.xmin, t16.ymax], [t16.xmax, t16.ymax], [t16.xmax, t16.ymin], [t16.xmin, t16.ymin]]] } : null;
var _t2 = (t16, e17, r13) => {
  switch (t16) {
    case "ExtraLeading":
      return 1 + e17 / r13;
    case "Multiple":
      return e17;
    case "Exact":
      return e17 / r13;
  }
};
function yt(e17, r13 = 1) {
  const i18 = A(e17), s17 = L(e17.fontStyleName), o9 = e17.fontFamilyName ?? t3, { weight: n23, style: a11 } = s17, l12 = r13 * (e17.height || 5), h8 = F(e17.horizontalAlignment), c5 = V(e17.verticalAlignment), m5 = T(e17), f6 = T(e17.haloSymbol), u9 = null != f6 ? r13 * (e17.haloSize ?? 0) : 0, d = N2(e17.symbol), g5 = r13 * (v(e17.symbol) || 0), p6 = "CIMBackgroundCallout" === e17.callout?.type ? e17.callout.backgroundSymbol : null, _4 = T(p6), y6 = v(p6), P3 = N2(p6);
  return { color: m5, size: l12, horizontalAlignment: h8, verticalAlignment: c5, font: { family: o9, style: g2(a11), weight: w(n23), decoration: i18 }, outline: { size: g5 || 0, color: d }, halo: { size: u9 || 0, color: f6, style: a11 }, backgroundColor: _4, borderLine: null != y6 && null != P3 ? { size: y6, color: P3 } : null, pixelRatio: 1, premultiplyColors: true };
}
var Pt = 1e-4;
function St(t16) {
  let e17, r13, i18, s17, o9, n23 = t16[0], a11 = 1;
  for (; a11 < t16.length; ) e17 = t16[a11][0] - n23[0], r13 = t16[a11][1] - n23[1], s17 = 0 !== e17 ? r13 / e17 : Math.PI / 2, void 0 !== i18 && Math.abs(s17 - i18) <= Pt ? (t16.splice(a11 - 1, 1), n23 = o9) : (o9 = n23, n23 = t16[a11], a11++), i18 = s17;
}

// node_modules/@arcgis/core/core/BidiText.js
var n22 = new C();
function i17(r13) {
  if (null == r13) return ["", false];
  if (!n22.hasBidiChar(r13)) return [r13, false];
  let i18;
  return i18 = "rtl" === n22.checkContextual(r13) ? "IDNNN" : "ICNNN", [n22.bidiTransform(r13, i18, "VLYSN"), true];
}

// node_modules/@arcgis/core/symbols/cim/CIMSymbolHelper.js
var L3 = Math.PI;
var F2 = L3 / 2;
var z2 = Math.PI / 180;
var D = 96 / 72;
var G2 = 1.4142135623730951;
var T3 = 2;
var E = 4;
var v3 = () => i.getLogger("esri.symbols.cim.CIMSymbolHelper");
function A3(e17) {
  let t16;
  switch (e17.type) {
    case "cim":
      return e17.data;
    case "web-style":
      return e17;
    case "simple-marker": {
      const r13 = Y.fromSimpleMarker(e17);
      if (!r13) throw new Error("InternalError: Cannot convert symbol to CIM");
      t16 = r13;
      break;
    }
    case "picture-marker":
      t16 = Y.fromPictureMarker(e17);
      break;
    case "simple-line":
      t16 = Y.fromSimpleLineSymbol(e17);
      break;
    case "simple-fill":
      t16 = Y.fromSimpleFillSymbol(e17);
      break;
    case "picture-fill":
      t16 = Y.fromPictureFillSymbol(e17);
      break;
    case "text":
      t16 = Y.fromTextSymbol(e17);
  }
  return { type: "CIMSymbolReference", symbol: t16 };
}
function R3(e17, t16, r13) {
  switch (t16.type) {
    case "CIMSymbolReference":
      return R3(e17, t16.symbol, r13);
    case "CIMPointSymbol":
      null == r13 && (r13 = { x: 0, y: 0 }), e17.drawSymbol(t16, r13);
      break;
    case "CIMLineSymbol":
      null == r13 && (r13 = { paths: [[[0, 0], [10, 0]]] }), e17.drawSymbol(t16, r13);
      break;
    case "CIMPolygonSymbol":
      null == r13 && (r13 = { rings: [[[0, 0], [0, 10], [10, 10], [10, 0], [0, 0]]] }), e17.drawSymbol(t16, r13);
      break;
    case "CIMTextSymbol": {
      const r14 = { x: 0, y: 0 };
      e17.drawSymbol(t16, r14);
      break;
    }
    case "CIMVectorMarker": {
      const r14 = new t6();
      e17.drawMarker(t16, r14);
      break;
    }
  }
  return e17.envelope();
}
function j3(e17) {
  if (!e17) return 0;
  switch (e17.type) {
    case "CIMMarkerPlacementAlongLineSameSize":
    case "CIMMarkerPlacementAlongLineRandomSize":
    case "CIMMarkerPlacementAtExtremities":
    case "CIMMarkerPlacementAtMeasuredUnits":
    case "CIMMarkerPlacementAtRatioPositions":
    case "CIMMarkerPlacementOnLine":
    case "CIMMarkerPlacementOnVertices":
      return Math.abs(e17.offset);
    default:
      return 0;
  }
}
function B3(e17) {
  if (!e17) return 0;
  switch (e17.type) {
    case "CIMGeometricEffectArrow":
      return Math.abs(0.5 * e17.width);
    case "CIMGeometricEffectBuffer":
      return Math.abs(e17.size);
    case "CIMGeometricEffectControlMeasureLine":
      return 500;
    case "CIMGeometricEffectExtension":
    case "CIMGeometricEffectRadial":
      return Math.abs(e17.length);
    case "CIMGeometricEffectJog":
      return Math.abs(0.5 * e17.length);
    case "CIMGeometricEffectMove":
      return Math.max(Math.abs(I2(e17.offsetX)), Math.abs(I2(e17.offsetY)));
    case "CIMGeometricEffectOffset":
    case "CIMGeometricEffectOffsetTangent":
      return Math.abs(e17.offset);
    case "CIMGeometricEffectRegularPolygon":
      return Math.abs(e17.radius);
    case "CIMGeometricEffectRotate":
    case "CIMGeometricEffectScale":
    default:
      return 0;
    case "CIMGeometricEffectTaperedPolygon":
      return 0.5 * Math.max(Math.abs(e17.fromWidth), Math.abs(e17.toWidth));
    case "CIMGeometricEffectWave":
      return Math.abs(e17.amplitude);
    case "CIMGeometricEffectDonut":
      return Math.abs(e17.width);
  }
}
function X2(e17) {
  if (!e17) return 0;
  let t16 = 0;
  for (const r13 of e17) t16 += B3(r13);
  return t16;
}
var V2 = class {
  static getSymbolInflateSize(e17, t16, r13, o9, a11) {
    return e17 || (e17 = [0, 0, 0, 0]), t16 ? this._getInflateSize(e17, t16, r13, o9, a11) : e17;
  }
  static safeSize(e17) {
    const t16 = Math.max(Math.abs(e17[0]), Math.abs(e17[2])), r13 = Math.max(Math.abs(e17[1]), Math.abs(e17[3]));
    return Math.sqrt(t16 * t16 + r13 * r13);
  }
  static _vectorMarkerBounds(e17, t16, r13, o9) {
    let a11 = true;
    const i18 = i2();
    if (t16?.markerGraphics) for (const s17 of t16.markerGraphics) {
      const t17 = [0, 0, 0, 0];
      s17.geometry && (f3(i18, s17.geometry), t17[0] = 0, t17[1] = 0, t17[2] = 0, t17[3] = 0, this.getSymbolInflateSize(t17, s17.symbol, r13, 0, o9), i18[0] += t17[0], i18[1] += t17[1], i18[2] += t17[2], i18[3] += t17[3], a11 ? (e17[0] = i18[0], e17[1] = i18[1], e17[2] = i18[2], e17[3] = i18[3], a11 = false) : (e17[0] = Math.min(e17[0], i18[0]), e17[1] = Math.min(e17[1], i18[1]), e17[2] = Math.max(e17[2], i18[2]), e17[3] = Math.max(e17[3], i18[3])));
    }
    return e17;
  }
  static _getInflateSize(e17, t16, r13, o9, a11) {
    if (Q(t16)) {
      const s17 = this._getLayersInflateSize(e17, t16.symbolLayers, r13, o9, a11), i18 = X2(t16.effects);
      return i18 > 0 && (s17[0] -= i18, s17[1] -= i18, s17[2] += i18, s17[3] += i18), s17;
    }
    return this._getTextInflatedSize(e17, t16, a11);
  }
  static _getLayersInflateSize(e17, t16, r13, o9, a11) {
    let n23 = true;
    if (!t16) return e17;
    for (const l12 of t16) {
      if (!l12) continue;
      let t17 = [0, 0, 0, 0];
      switch (l12.type) {
        case "CIMSolidFill":
        case "CIMPictureFill":
        case "CIMHatchFill":
        case "CIMGradientFill":
          break;
        case "CIMSolidStroke":
        case "CIMPictureStroke":
        case "CIMGradientStroke": {
          const e18 = l12;
          let r14 = e18.width;
          null != r14 && ("Square" === e18.capStyle || "Miter" === e18.joinStyle ? r14 /= G2 : r14 /= 2, t17[0] = -r14, t17[1] = -r14, t17[2] = r14, t17[3] = r14);
          break;
        }
        case "CIMCharacterMarker":
        case "CIMVectorMarker":
        case "CIMPictureMarker": {
          const e18 = l12;
          if ("CIMVectorMarker" === l12.type) {
            const e19 = l12;
            if (t17 = this._vectorMarkerBounds(t17, e19, r13, a11), e19.frame) {
              const r14 = (e19.frame.xmin + e19.frame.xmax) / 2, o10 = (e19.frame.ymin + e19.frame.ymax) / 2;
              if (t17[0] -= r14, t17[1] -= o10, t17[2] -= r14, t17[3] -= o10, null != e19.size) {
                const r15 = e19.size / (e19.frame.ymax - e19.frame.ymin);
                t17[0] *= r15, t17[1] *= r15, t17[2] *= r15, t17[3] *= r15;
              }
            }
          } else if ("CIMPictureMarker" === l12.type) {
            const o10 = l12, a12 = r13.getResource(o10.url);
            let s17 = 1;
            if (null != a12 && a12.height && (s17 = a12.width / a12.height), null != e18.size) {
              const r14 = e18.size / 2, a13 = e18.size * s17 * o10.scaleX / 2;
              t17 = [-a13, -r14, a13, r14];
            }
          } else if (null != e18.size) {
            const r14 = e18.size / 2;
            t17 = [-r14, -r14, r14, r14];
          }
          if (e18.anchorPoint) {
            let r14, o10;
            "Absolute" === e18.anchorPointUnits ? (r14 = e18.anchorPoint.x, o10 = e18.anchorPoint.y) : (r14 = e18.anchorPoint.x * (t17[2] - t17[0]), o10 = e18.anchorPoint.y * (t17[3] - t17[1]));
            const a12 = 1.25 * Math.sqrt(r14 * r14 + o10 * o10);
            t17[0] -= a12, t17[1] -= a12, t17[2] += a12, t17[3] += a12;
          }
          let n24 = I2(e18.rotation);
          if (e18.rotateClockwise && (n24 = -n24), o9 && (n24 -= o9), n24) {
            const e19 = z2 * n24, r14 = Math.cos(e19), o10 = Math.sin(e19), a12 = i2([r, r, -r, -r]);
            f2(a12, [t17[0] * r14 - t17[1] * o10, t17[0] * o10 + t17[1] * r14]), f2(a12, [t17[0] * r14 - t17[3] * o10, t17[0] * o10 + t17[3] * r14]), f2(a12, [t17[2] * r14 - t17[1] * o10, t17[2] * o10 + t17[1] * r14]), f2(a12, [t17[2] * r14 - t17[3] * o10, t17[2] * o10 + t17[3] * r14]), t17 = a12;
          }
          let c6 = I2(e18.offsetX), m5 = I2(e18.offsetY);
          if (o9) {
            const e19 = z2 * o9, t18 = Math.cos(e19), r14 = Math.sin(e19), a12 = c6 * r14 + m5 * t18;
            c6 = c6 * t18 - m5 * r14, m5 = a12;
          }
          t17[0] += c6, t17[1] += m5, t17[2] += c6, t17[3] += m5;
          const f6 = j3(e18.markerPlacement);
          f6 > 0 && (t17[0] -= f6, t17[1] -= f6, t17[2] += f6, t17[3] += f6);
          break;
        }
      }
      const c5 = X2(l12.effects);
      c5 > 0 && (t17[0] -= c5, t17[1] -= c5, t17[2] += c5, t17[3] += c5), n23 ? (e17[0] = t17[0], e17[1] = t17[1], e17[2] = t17[2], e17[3] = t17[3], n23 = false) : (e17[0] = Math.min(e17[0], t17[0]), e17[1] = Math.min(e17[1], t17[1]), e17[2] = Math.max(e17[2], t17[2]), e17[3] = Math.max(e17[3], t17[3]));
    }
    return e17;
  }
  static _getTextInflatedSize(e17, t16, r13) {
    const o9 = s16(t16.height ?? o2.CIMTextSymbol.height);
    if (e17[0] = -o9 / 2, e17[1] = -o9 / 2, e17[2] = o9 / 2, e17[3] = o9 / 2, !r13) return e17;
    const a11 = r13.get(t16);
    if (!a11) return e17;
    if (!a11.glyphMosaicItems.glyphs.length) return e17;
    const { lineGapType: s17, lineGap: i18 } = t16, n23 = s17 ? _t2(s17, i18 ?? 0, o9) : 0, l12 = "CIMBackgroundCallout" === t16.callout?.type, c5 = z(a11.glyphMosaicItems, { scale: o9 / q, angle: I2(t16.angle), xOffset: I2(t16.offsetX), yOffset: I2(t16.offsetY), horizontalAlignment: t16.horizontalAlignment, verticalAlignment: t16.verticalAlignment, maxLineWidth: a10(t16.lineWidth), lineHeight: l4 * Math.max(0.25, Math.min(n23 || 1, 4)), decoration: t16.font.decoration || "none", useCIMAngleBehavior: true, hasBackground: l12 }).boundsT, m5 = Math.sqrt(c5.width * c5.width + c5.height * c5.height);
    return e17[0] -= c5.x + m5, e17[1] -= c5.y - m5, e17[2] += c5.x + m5, e17[3] += -c5.y + m5, e17;
  }
};
var Y = class _Y {
  static getEnvelope(e17, t16, r13) {
    if (!e17) return null;
    const o9 = new ht(r13);
    if (Array.isArray(e17)) {
      let r14;
      for (const a11 of e17) r14 ? r14.union(R3(o9, a11, t16)) : r14 = R3(o9, a11, t16);
      return r14;
    }
    return R3(o9, e17, t16);
  }
  static getTextureInfo(e17, t16, r13, o9, a11) {
    const s17 = o9 ?? this.getEnvelope(e17, null, t16);
    if (!s17) return [0, 0, 0, 0, 1];
    const i18 = Math.max(s17.width, s17.height) * D;
    let n23 = null != a11 ? Math.max(a11 / i18, 1) : 1;
    n23 *= D, s17.x *= n23, s17.y *= n23, s17.width *= n23, s17.height *= n23, s17.width = Math.max(Math.ceil(s17.x + s17.width) - Math.floor(s17.x), 1) - 1, s17.height = Math.max(Math.ceil(s17.y + s17.height) - Math.floor(s17.y), 1) - 1;
    let l12 = s17.x + 0.5 * s17.width, c5 = s17.y + 0.5 * s17.height;
    return l12 += s17.x - Math.floor(s17.x), c5 += s17.y - Math.floor(s17.y), o9 || (s17.width += r13, s17.height += r13, l12 += r13 / 2, c5 += r13 / 2), [s17.width, s17.height, l12, c5, n23];
  }
  static getTextureAnchor(e17, t16, r13) {
    const [o9, a11, s17, i18, n23] = this.getTextureInfo(e17, t16, T3, null, r13);
    return [-s17 / o9, -i18 / a11, a11 / n23 * D];
  }
  static rasterize(e17, t16, r13, o9, a11 = true, s17) {
    const [i18, n23, l12, c5, f6] = this.getTextureInfo(t16, o9, T3, r13, s17);
    e17.width = i18, e17.height = n23;
    const u9 = e17.getContext("2d", { willReadFrequently: true }), M3 = at.createScale(f6, -f6);
    M3.translate(0.5 * i18 - l12, 0.5 * n23 + c5);
    const p6 = new mt(u9, o9, M3);
    switch (t16.type) {
      case "CIMPointSymbol": {
        const e18 = { type: "point", x: 0, y: 0 };
        p6.drawSymbol(t16, e18);
        break;
      }
      case "CIMVectorMarker": {
        const e18 = new t6();
        p6.drawMarker(t16, e18);
        break;
      }
    }
    const S3 = u9.getImageData(0, 0, e17.width, e17.height), d = new Uint8Array(S3.data);
    if (a11) {
      let e18;
      for (let t17 = 0; t17 < d.length; t17 += 4) e18 = d[t17 + 3] / 255, d[t17] = d[t17] * e18, d[t17 + 1] = d[t17 + 1] * e18, d[t17 + 2] = d[t17 + 2] * e18;
    }
    return [d, e17.width, e17.height, -l12 / i18, -c5 / n23];
  }
  static fromTextSymbol(e17) {
    const { text: t16 } = e17;
    return { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMVectorMarker", enable: true, anchorPointUnits: "Relative", dominantSizeAxis3D: "Y", size: 10, billboardMode3D: "FaceNearPlane", frame: { xmin: -5, ymin: -5, xmax: 5, ymax: 5 }, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: { x: 0, y: 0 }, symbol: _Y.createCIMTextSymbolfromTextSymbol(e17), textString: t16 }], scaleSymbolsProportionally: true, respectFrame: true }], scaleX: 1, angleAlignment: "Display" };
  }
  static fromPictureFillSymbol(e17) {
    const { height: t16, outline: r13, width: o9, xoffset: a11, xscale: s17, yoffset: i18, yscale: n23 } = e17, l12 = [], c5 = { type: "CIMPolygonSymbol", symbolLayers: l12 };
    if (r13) {
      const e18 = te(r13);
      e18 && l12.push(e18);
    }
    let m5 = e17.url;
    "esriPFS" === e17.type && e17.imageData && (m5 = e17.imageData);
    const f6 = "angle" in e17 ? e17.angle ?? 0 : 0, y6 = (o9 ?? 0) * (s17 || 1), h8 = (t16 ?? 0) * (n23 || 1);
    return l12.push({ type: "CIMPictureFill", invertBackfaceTexture: false, scaleX: 1, textureFilter: "Picture", tintColor: null, url: m5, height: h8, width: y6, offsetX: I2(a11), offsetY: I2(i18), rotation: I2(-f6), colorSubstitutions: null }), c5;
  }
  static fromSimpleFillSymbol(e17) {
    const { color: r13, style: o9, outline: s17 } = e17, i18 = [], n23 = { type: "CIMPolygonSymbol", symbolLayers: i18 };
    if (s17) {
      const e18 = te(s17);
      e18 && i18.push(e18);
    }
    if (o9 && "solid" !== o9 && "none" !== o9 && "esriSFSSolid" !== o9 && "esriSFSNull" !== o9) {
      const e18 = { type: "CIMLineSymbol", symbolLayers: [{ type: "CIMSolidStroke", color: U2(r13), capStyle: "Butt", joinStyle: "Miter", width: 0.75 }] };
      let s18 = 0;
      const n24 = e3(ee2(o9) ? 8 : 10);
      switch (o9) {
        case "vertical":
        case "esriSFSVertical":
          s18 = 90;
          break;
        case "forward-diagonal":
        case "esriSFSForwardDiagonal":
        case "diagonal-cross":
        case "esriSFSDiagonalCross":
          s18 = -45;
          break;
        case "backward-diagonal":
        case "esriSFSBackwardDiagonal":
          s18 = 45;
          break;
        case "cross":
        case "esriSFSCross":
          s18 = 0;
      }
      i18.push({ type: "CIMHatchFill", lineSymbol: e18, offsetX: 0, offsetY: 0, rotation: s18, separation: n24 }), "cross" === o9 || "esriSFSCross" === o9 ? i18.push({ type: "CIMHatchFill", lineSymbol: a(e18), offsetX: 0, offsetY: 0, rotation: 90, separation: n24 }) : "diagonal-cross" !== o9 && "esriSFSDiagonalCross" !== o9 || i18.push({ type: "CIMHatchFill", lineSymbol: a(e18), offsetX: 0, offsetY: 0, rotation: 45, separation: n24 });
    } else !o9 || "solid" !== o9 && "esriSFSSolid" !== o9 || i18.push({ type: "CIMSolidFill", enable: true, color: U2(r13) });
    return n23;
  }
  static fromSimpleLineSymbol(e17) {
    const { cap: t16, color: r13, join: o9, marker: a11, miterLimit: s17, style: i18, width: n23 } = e17;
    let l12 = null;
    "solid" !== i18 && "none" !== i18 && "esriSLSSolid" !== i18 && "esriSLSNull" !== i18 && (l12 = [{ type: "CIMGeometricEffectDashes", dashTemplate: K2(i18, t16), lineDashEnding: "NoConstraint", scaleDash: true, offsetAlongLine: null }]);
    const c5 = [];
    if (a11) {
      let e18;
      switch (a11.placement) {
        case "begin-end":
          e18 = "Both";
          break;
        case "begin":
          e18 = "JustBegin";
          break;
        case "end":
          e18 = "JustEnd";
          break;
        default:
          e18 = "None";
      }
      const t17 = _Y.fromSimpleMarker(a11, n23, r13).symbolLayers[0];
      t17.markerPlacement = { type: "CIMMarkerPlacementAtExtremities", placePerPart: false, angleToLine: true, offset: 0, extremityPlacement: e18, offsetAlongLine: 0 }, c5.push(t17);
    }
    return c5.push({ type: "CIMSolidStroke", color: "none" !== i18 && "esriSLSNull" !== i18 ? U2(r13) : [0, 0, 0, 0], capStyle: _3(t16), joinStyle: q2(o9), miterLimit: s17, width: n23, effects: l12 }), { type: "CIMLineSymbol", symbolLayers: c5 };
  }
  static fromPictureMarker(e17) {
    const { angle: t16, height: r13, width: o9, xoffset: a11, yoffset: s17 } = e17;
    let i18 = e17.url;
    return "esriPMS" === e17.type && e17.imageData && (i18 = e17.imageData), { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMPictureMarker", invertBackfaceTexture: false, scaleX: 1, textureFilter: "Picture", tintColor: null, url: i18, size: r13, width: o9, offsetX: I2(a11), offsetY: I2(s17), rotation: I2(-t16) }] };
  }
  static createCIMTextSymbolfromTextSymbol(t16) {
    const { angle: r13, color: o9, font: a11, haloColor: s17, haloSize: i18, horizontalAlignment: n23, kerning: l12, lineWidth: c5, text: m5, verticalAlignment: f6, xoffset: y6, yoffset: h8, backgroundColor: u9, borderLineColor: M3, borderLineSize: S3 } = t16;
    let d, b2, g5, C2, x3, I3;
    a11 && (d = a11.family, b2 = a11.style, g5 = a11.weight, C2 = a11.size, x3 = a11.decoration);
    let k = false;
    if (m5) {
      k = i17(m5)[1];
    }
    return (u9 || S3) && (I3 = { type: "CIMBackgroundCallout", margin: null, backgroundSymbol: { type: "CIMPolygonSymbol", symbolLayers: [{ type: "CIMSolidFill", color: U2(u9) }, { type: "CIMSolidStroke", color: U2(M3), width: S3 }] }, accentBarSymbol: null, gap: null, leaderLineSymbol: null, lineStyle: null }), { type: "CIMTextSymbol", angle: r13, blockProgression: 2, depth3D: 1, extrapolateBaselines: true, fontEffects: 0, fontEncoding: 1, fontFamilyName: d || "Arial", fontStyleName: W2(b2, g5), fontType: 0, haloSize: i18, height: C2, hinting: 1, horizontalAlignment: H(n23 ?? "center"), kerning: l12, letterWidth: 100, ligatures: true, lineGapType: "Multiple", lineWidth: c5, offsetX: I2(y6), offsetY: I2(h8), strikethrough: "line-through" === x3, underline: "underline" === x3, symbol: { type: "CIMPolygonSymbol", symbolLayers: [{ type: "CIMSolidFill", enable: true, color: U2(o9) }] }, haloSymbol: { type: "CIMPolygonSymbol", symbolLayers: [{ type: "CIMSolidFill", enable: true, color: U2(s17) }] }, shadowColor: [0, 0, 0, 255], shadowOffsetX: 1, shadowOffsetY: 1, textCase: "Normal", textDirection: k ? 1 : 0, verticalAlignment: O(f6 ?? "baseline"), verticalGlyphOrientation: 0, wordSpacing: 100, billboardMode3D: 2, callout: I3 };
  }
  static createPictureMarkerRasterizationParam(e17) {
    const { angle: t16, height: r13, width: o9, xoffset: a11, yoffset: s17 } = e17, i18 = e17.url ?? e17.source?.url ?? e17.source?.imageData;
    return i18 ? { type: "sprite-rasterization-param", overrides: [], resource: { type: "CIMPictureMarker", invertBackfaceTexture: false, scaleX: 1, textureFilter: "Picture", tintColor: null, url: i18, size: r13, width: o9, offsetX: I2(a11), offsetY: I2(s17), rotation: I2(-t16) } } : null;
  }
  static createPictureFillRasterizationParam(e17) {
    const { width: t16, height: r13, xoffset: o9, yoffset: a11, url: s17 } = e17;
    return s17 ? { type: "sprite-rasterization-param", overrides: [], resource: { type: "CIMPictureFill", scaleX: 1, textureFilter: "Picture", tintColor: null, url: s17, width: t16, height: r13, offsetX: I2(o9), offsetY: I2(a11), rotation: 0 } } : null;
  }
  static fromSimpleMarker(e17, t16, r13) {
    const { style: o9 } = e17, a11 = e17.color ?? r13;
    if ("path" === o9 || "esriSMSPath" === o9) {
      const t17 = [];
      if ("outline" in e17 && e17.outline) {
        const r15 = e17.outline;
        t17.push({ type: "CIMSolidStroke", enable: true, width: r15.width, color: U2(r15.color), path: e17.path });
      }
      t17.push({ type: "CIMSolidFill", enable: true, color: U2(a11), path: e17.path });
      const [r14, o10] = Z("square");
      return { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMVectorMarker", enable: true, rotation: -I2(e17.angle), size: I2(e17.size || 6), offsetX: I2(e17.xoffset), offsetY: I2(e17.yoffset), scaleSymbolsProportionally: false, frame: r14, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: o10, symbol: { type: "CIMPolygonSymbol", symbolLayers: t17 } }] }] };
    }
    const s17 = [];
    let i18, n23, l12 = e17.size;
    if ("outline" in e17 && e17.outline && "none" !== e17.outline.style && "esriSLSNull" !== e17.outline.style) {
      const t17 = e17.outline, r14 = "solid" !== t17.style && "esriSLSSolid" !== t17.style;
      [i18, n23] = r14 ? Z(o9, e17.size) : Z(o9);
      const a12 = t17.width ?? u3.width;
      if (r14) {
        const t18 = a12 / e17.size, r15 = (i18.xmax - i18.xmin) * t18 / 2, o10 = (i18.ymax - i18.ymin) * t18 / 2;
        i18.xmin -= r15, i18.xmax += r15, i18.ymin -= o10, i18.ymax += o10, l12 && (l12 += a12);
      }
      const c6 = "cross" !== e17.style && "x" !== e17.style || "dot" === e17?.outline.style || "short-dot" === e17?.outline.style ? "HalfGap" : "FullPattern", m5 = r14 ? [{ type: "CIMGeometricEffectAddControlPoints" }, { type: "CIMGeometricEffectDashes", dashTemplate: K2(t17.style, null).map((e18) => t17.width && t17.width > 0 ? e18 * t17.width : e18), lineDashEnding: c6, controlPointEnding: "FullPattern" }] : void 0;
      s17.push({ type: "CIMSolidStroke", capStyle: r14 ? "Round" : "Butt", enable: true, width: a12, color: U2(t17.color), effects: m5 });
    } else !t16 || "line-marker" !== e17.type || "cross" !== e17.style && "x" !== e17.style ? [i18, n23] = Z(o9) : ([i18, n23] = Z(o9), s17.push({ type: "CIMSolidStroke", enable: true, width: t16, color: U2(a11) }));
    s17.push({ type: "CIMSolidFill", enable: true, color: U2(a11) });
    const c5 = { type: "CIMPolygonSymbol", symbolLayers: s17 };
    return { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMVectorMarker", enable: true, rotation: I2(-e17.angle), size: I2(l12 || 6 * t16), offsetX: I2(e17.xoffset), offsetY: I2(e17.yoffset), scaleSymbolsProportionally: false, frame: i18, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: n23, symbol: c5 }] }] };
  }
  static fromCIMHatchFill(e17, r13) {
    const o9 = r13 * (e17.separation ?? o2.CIMHatchFill.separation), a11 = o9 / 2, s17 = a(e17.lineSymbol);
    s17.symbolLayers?.forEach((e18) => {
      switch (e18.type) {
        case "CIMSolidStroke":
          null != e18.width && (e18.width *= r13), e18.effects?.forEach((e19) => {
            if ("CIMGeometricEffectDashes" === e19.type) {
              const t16 = e19.dashTemplate;
              e19.dashTemplate = t16?.map((e20) => e20 * r13);
            }
          });
          break;
        case "CIMVectorMarker": {
          null != e18.size && (e18.size *= r13);
          const t16 = e18.markerPlacement;
          null != t16 && "placementTemplate" in t16 && (t16.placementTemplate = t16.placementTemplate.map((e19) => e19 * r13));
          break;
        }
      }
    });
    let i18 = this._getLineSymbolPeriod(s17) || E;
    for (; i18 < E; ) i18 *= 2;
    const n23 = i18 / 2;
    return { type: "CIMVectorMarker", frame: { xmin: -n23, xmax: n23, ymin: -a11, ymax: a11 }, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: { paths: [[[-n23, 0], [n23, 0]]] }, symbol: s17 }], size: o9 };
  }
  static fetchResources(e17, t16, r13, o9 = null) {
    if (!e17 || !t16) return r13;
    switch (e17.type) {
      case "CIMMeshSymbol":
      case "CIMPointSymbol":
      case "CIMLineSymbol":
      case "CIMPolygonSymbol":
        for (const t17 of e17.effects || []) r13.push(l7(t17));
    }
    return N3(e17, (e18) => {
      for (const t17 of e18.effects || []) r13.push(l7(t17));
      "url" in e18 && e18.url && r13.push(t16.fetchResource(e18.url, { signal: o9 }));
    }), r13;
  }
  static fetchFonts(e17, t16, r13) {
    if (e17 && t16) {
      if ("symbolLayers" in e17 && e17.symbolLayers) {
        for (const o9 of e17.symbolLayers) if ("CIMVectorMarker" === o9.type && o9.markerGraphics) for (const e18 of o9.markerGraphics) e18?.symbol && _Y.fetchFonts(e18.symbol, t16, r13);
      } else if ("CIMTextSymbol" === e17.type) {
        const { fontFamilyName: o9, fontStyleName: a11 } = e17;
        if (!o9 || "calcitewebcoreicons" === o9.toLowerCase()) return;
        const { style: s17, weight: i18 } = L(a11), n23 = A(e17), c5 = new l6({ family: o9, style: s17, weight: i18, decoration: n23 });
        r13.push(t16.loadFont(c5).catch(() => {
          v3().error(`Unsupported font ${o9} in CIM symbol`);
        }));
      }
    }
  }
  static _getLineSymbolPeriod(e17) {
    if (e17) {
      const t16 = this._getEffectsRepeat(e17.effects);
      if (t16) return t16;
      if (e17.symbolLayers) {
        for (const r13 of e17.symbolLayers) if (r13) {
          const e18 = this._getEffectsRepeat(r13.effects);
          if (e18) return e18;
          switch (r13.type) {
            case "CIMCharacterMarker":
            case "CIMPictureMarker":
            case "CIMVectorMarker":
            case "CIMObjectMarker3D":
            case "CIMglTFMarker3D": {
              const e19 = this._getPlacementRepeat(r13.markerPlacement);
              if (e19) return e19;
            }
          }
        }
      }
    }
    return 0;
  }
  static _getEffectsRepeat(e17) {
    if (e17) {
      for (const t16 of e17) if (t16) switch (t16.type) {
        case "CIMGeometricEffectDashes": {
          const e18 = t16.dashTemplate;
          if (e18 && e18.length) {
            let t17 = 0;
            for (const r13 of e18) t17 += r13;
            return 1 & e18.length && (t17 *= 2), t17;
          }
          break;
        }
        case "CIMGeometricEffectWave":
          return t16.period;
        default:
          v3().error(`unsupported geometric effect type ${t16.type}`);
      }
    }
    return 0;
  }
  static _getPlacementRepeat(e17) {
    if (e17) switch (e17.type) {
      case "CIMMarkerPlacementAlongLineSameSize":
      case "CIMMarkerPlacementAlongLineRandomSize":
      case "CIMMarkerPlacementAlongLineVariableSize": {
        const t16 = e17.placementTemplate;
        if (t16 && t16.length) {
          let e18 = 0;
          for (const r13 of t16) e18 += +r13;
          return 1 & t16.length && (e18 *= 2), e18;
        }
        break;
      }
    }
    return 0;
  }
  static fromCIMInsidePolygon(e17) {
    const t16 = e17.markerPlacement, r13 = { ...e17 };
    r13.markerPlacement = null, r13.anchorPoint = null;
    const s17 = Math.abs(t16.stepX), i18 = Math.abs(t16.stepY), n23 = (t16.randomness ?? 100) / 100;
    let l12, c5, m5, f6;
    if ("Random" === t16.gridType) {
      const e18 = e3(ft), r14 = Math.max(Math.floor(e18 / s17), 1), y6 = Math.max(Math.floor(e18 / i18), 1);
      l12 = r14 * s17 / 2, c5 = y6 * i18 / 2, m5 = 2 * c5;
      const h8 = new t(t16.seed), u9 = n23 * s17 / 1.5, M3 = n23 * i18 / 1.5;
      f6 = [];
      for (let t17 = 0; t17 < r14; t17++) for (let e19 = 0; e19 < y6; e19++) {
        const r15 = t17 * s17 - l12 + u9 * (0.5 - h8.getFloat()), o9 = e19 * i18 - c5 + M3 * (0.5 - h8.getFloat());
        f6.push({ x: r15, y: o9 }), 0 === t17 && f6.push({ x: r15 + 2 * l12, y: o9 }), 0 === e19 && f6.push({ x: r15, y: o9 + 2 * c5 });
      }
    } else true === t16.shiftOddRows ? (l12 = s17 / 2, c5 = i18, m5 = 2 * i18, f6 = [{ x: -l12, y: 0 }, { x: l12, y: 0 }, { x: 0, y: c5 }, { x: 0, y: -c5 }]) : (l12 = s17 / 2, c5 = i18 / 2, m5 = i18, f6 = [{ x: -s17, y: 0 }, { x: 0, y: -i18 }, { x: -s17, y: -i18 }, { x: 0, y: 0 }, { x: s17, y: 0 }, { x: 0, y: i18 }, { x: s17, y: i18 }, { x: -s17, y: i18 }, { x: s17, y: -i18 }]);
    return { type: "CIMVectorMarker", frame: { xmin: -l12, xmax: l12, ymin: -c5, ymax: c5 }, markerGraphics: f6.map((e18) => ({ type: "CIMMarkerGraphic", geometry: e18, symbol: { type: "CIMPointSymbol", symbolLayers: [r13] } })), size: m5 };
  }
};
function N3(e17, t16) {
  if (e17) switch (e17.type) {
    case "CIMPointSymbol":
    case "CIMLineSymbol":
    case "CIMPolygonSymbol": {
      const r13 = e17.symbolLayers;
      if (!r13) return;
      for (const e18 of r13) if (t16(e18), "CIMVectorMarker" === e18.type) {
        const r14 = e18.markerGraphics;
        if (!r14) continue;
        for (const e19 of r14) if (e19) {
          const r15 = e19.symbol;
          r15 && N3(r15, t16);
        }
      }
      break;
    }
  }
}
var _3 = (e17) => {
  if (!e17) return "Butt";
  switch (e17) {
    case "butt":
      return "Butt";
    case "square":
      return "Square";
    case "round":
      return "Round";
  }
};
var q2 = (e17) => {
  if (!e17) return "Miter";
  switch (e17) {
    case "miter":
      return "Miter";
    case "round":
      return "Round";
    case "bevel":
      return "Bevel";
  }
};
var H = (e17) => {
  if (null == e17) return "Center";
  switch (e17) {
    case "left":
      return "Left";
    case "right":
      return "Right";
    case "center":
      return "Center";
  }
};
var O = (e17) => {
  if (null == e17) return "Center";
  switch (e17) {
    case "baseline":
      return "Baseline";
    case "top":
      return "Top";
    case "middle":
      return "Center";
    case "bottom":
      return "Bottom";
  }
};
var U2 = (e17) => {
  if (!e17) return [0, 0, 0, 0];
  const { r: t16, g: r13, b: o9, a: a11 } = e17;
  return [t16, r13, o9, 255 * a11];
};
var W2 = (e17, t16) => {
  const r13 = $(t16), o9 = J(e17);
  return r13 && o9 ? `${r13}-${o9}` : `${r13}${o9}`;
};
var $ = (e17) => {
  if (!e17) return "";
  switch (e17.toLowerCase()) {
    case "bold":
    case "bolder":
      return "bold";
  }
  return "";
};
var J = (e17) => {
  if (!e17) return "";
  switch (e17.toLowerCase()) {
    case "italic":
    case "oblique":
      return "italic";
  }
  return "";
};
var K2 = (e17, t16) => {
  const r13 = has("safari") ? 1e-3 : 0, o9 = "butt" === t16;
  switch (e17) {
    case "dash":
    case "esriSLSDash":
      return o9 ? [4, 3] : [3, 4];
    case "dash-dot":
    case "esriSLSDashDot":
      return o9 ? [4, 3, 1, 3] : [3, 4, r13, 4];
    case "dot":
    case "esriSLSDot":
      return o9 ? [1, 3] : [r13, 4];
    case "long-dash":
    case "esriSLSLongDash":
      return o9 ? [8, 3] : [7, 4];
    case "long-dash-dot":
    case "esriSLSLongDashDot":
      return o9 ? [8, 3, 1, 3] : [7, 4, r13, 4];
    case "long-dash-dot-dot":
    case "esriSLSDashDotDot":
      return o9 ? [8, 3, 1, 3, 1, 3] : [7, 4, r13, 4, r13, 4];
    case "short-dash":
    case "esriSLSShortDash":
      return o9 ? [4, 1] : [3, 2];
    case "short-dash-dot":
    case "esriSLSShortDashDot":
      return o9 ? [4, 1, 1, 1] : [3, 2, r13, 2];
    case "short-dash-dot-dot":
    case "esriSLSShortDashDotDot":
      return o9 ? [4, 1, 1, 1, 1, 1] : [3, 2, r13, 2, r13, 2];
    case "short-dot":
    case "esriSLSShortDot":
      return o9 ? [1, 1] : [r13, 2];
    case "solid":
    case "esriSLSSolid":
    case "none":
      return v3().error("Unexpected: style does not require rasterization"), [0, 0];
    default:
      return v3().error(`Tried to rasterize SLS, but found an unexpected style: ${e17}!`), [0, 0];
  }
};
function Q(e17) {
  return void 0 !== e17.symbolLayers;
}
var Z = (e17, t16 = 100) => {
  const r13 = t16 / 2;
  let o9, a11;
  const s17 = e17;
  if ("circle" === s17 || "esriSMSCircle" === s17) {
    const e18 = 0.25;
    let t17 = Math.acos(1 - e18 / r13), s18 = Math.ceil(L3 / t17 / 4);
    0 === s18 && (s18 = 1), t17 = F2 / s18, s18 *= 4;
    const i18 = [];
    i18.push([r13, 0]);
    for (let o10 = 1; o10 < s18; o10++) i18.push([r13 * Math.cos(o10 * t17), -r13 * Math.sin(o10 * t17)]);
    i18.push([r13, 0]), o9 = { rings: [i18] }, a11 = { xmin: -r13, ymin: -r13, xmax: r13, ymax: r13 };
  } else if ("cross" === s17 || "esriSMSCross" === s17) {
    const e18 = 0;
    o9 = { paths: [[[e18, r13], [e18, -r13]], [[r13, e18], [-r13, e18]]] }, a11 = { xmin: -r13, ymin: -r13, xmax: r13, ymax: r13 };
  } else if ("diamond" === s17 || "esriSMSDiamond" === s17) o9 = { rings: [[[-r13, 0], [0, r13], [r13, 0], [0, -r13], [-r13, 0]]] }, a11 = { xmin: -r13, ymin: -r13, xmax: r13, ymax: r13 };
  else if ("square" === s17 || "esriSMSSquare" === s17) o9 = { rings: [[[-r13, -r13], [-r13, r13], [r13, r13], [r13, -r13], [-r13, -r13]]] }, a11 = { xmin: -r13, ymin: -r13, xmax: r13, ymax: r13 };
  else if ("x" === s17 || "esriSMSX" === s17) o9 = { paths: [[[r13, r13], [-r13, -r13]], [[r13, -r13], [-r13, r13]]] }, a11 = { xmin: -r13, ymin: -r13, xmax: r13, ymax: r13 };
  else if ("triangle" === s17 || "esriSMSTriangle" === s17) {
    const e18 = t16 * 0.5773502691896257, r14 = -e18, s18 = 2 / 3 * t16, i18 = s18 - t16;
    o9 = { rings: [[[r14, i18], [0, s18], [e18, i18], [r14, i18]]] }, a11 = { xmin: r14, ymin: i18, xmax: e18, ymax: s18 };
  } else "arrow" === s17 && (o9 = { rings: [[[-50, 50], [50, 0], [-50, -50], [-33, -20], [-33, 20], [-50, 50]]] }, a11 = { xmin: -r13, ymin: -r13, xmax: r13, ymax: r13 });
  return [a11, o9];
};
var ee2 = (e17) => "vertical" === e17 || "horizontal" === e17 || "cross" === e17 || "esriSFSCross" === e17 || "esriSFSVertical" === e17 || "esriSFSHorizontal" === e17;
function te(e17) {
  if (!e17) return null;
  let t16 = null;
  const { cap: r13, color: o9, join: a11, miterLimit: s17, style: i18, width: n23 } = e17;
  return "solid" !== i18 && "none" !== i18 && "esriSLSSolid" !== i18 && "esriSLSNull" !== i18 && (t16 = [{ type: "CIMGeometricEffectDashes", dashTemplate: K2(i18, r13), lineDashEnding: "NoConstraint", scaleDash: true, offsetAlongLine: null }]), { type: "CIMSolidStroke", color: "esriSLSNull" !== i18 && "none" !== i18 ? U2(o9) : [0, 0, 0, 0], capStyle: _3(r13), joinStyle: q2(a11), miterLimit: s17, width: n23, effects: t16 };
}

export {
  l7 as l,
  g3 as g,
  y3 as y,
  R,
  S2 as S,
  i17 as i,
  t13 as t,
  t14 as t2,
  e16 as e,
  n20 as n,
  a9 as a,
  c4 as c,
  s15 as s,
  z,
  i16 as i2,
  m4 as m,
  at,
  ct,
  mt,
  A3 as A,
  X2 as X,
  V2 as V,
  Y,
  N3 as N,
  K2 as K
};
//# sourceMappingURL=chunk-DRHU543D.js.map
