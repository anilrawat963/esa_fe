import {
  q,
  t as t2
} from "./chunk-JNJX34GB.js";
import {
  x
} from "./chunk-23NJHA5Q.js";
import {
  l as l2
} from "./chunk-PMGS7UDU.js";
import {
  i as i2
} from "./chunk-3GHCGAH2.js";
import {
  f as f2
} from "./chunk-GD4FJL3C.js";
import {
  l
} from "./chunk-T7F6Q6JJ.js";
import {
  f
} from "./chunk-2OFHDVO5.js";
import {
  t
} from "./chunk-V2H77UEV.js";
import {
  n
} from "./chunk-XXLHAM2M.js";
import {
  e4 as e,
  m,
  p
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  i3 as i
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/graphic/getIdFieldsProvider.js
var n2 = Symbol("idFieldsProviderSymbol");
function o(o2) {
  return !!o2 && n2 in o2;
}
function i3(i4) {
  return o(i4) ? i4[n2] : void 0;
}

// node_modules/@arcgis/core/Graphic.js
var b;
function d(t3) {
  if (!t3) return null;
  const e2 = {};
  for (const r in t3) {
    const i4 = f2(t3[r]);
    i4 && (e2[r] = i4);
  }
  return 0 !== Object.keys(e2).length ? e2 : null;
}
function v(t3) {
  if (null == t3) return null;
  const e2 = {};
  for (const r in t3) {
    const i4 = t3[r];
    i4 && (e2[r] = i4.toJSON());
  }
  return 0 !== Object.keys(e2).length ? e2 : null;
}
var _a;
var _ = (_a = class extends l(n) {
  constructor(t3) {
    super(t3), this.isAggregate = false, this.layer = null, this.origin = null, this.sourceLayer = null, this._version = 0, Object.defineProperty(this, "uid", { value: e(), configurable: true }), Object.defineProperty(this, "_lastMeshTransform", { value: {}, configurable: true, writable: true, enumerable: false }), arguments.length > 1 && p(i.getLogger(this), "Graphic", { version: "4.30" });
  }
  initialize() {
    this._watchMeshGeometryChanges();
  }
  set aggregateGeometries(t3) {
    const e2 = this._get("aggregateGeometries");
    JSON.stringify(e2) !== JSON.stringify(t3) && this._set("aggregateGeometries", t3);
  }
  set attributes(t3) {
    const e2 = this._get("attributes");
    e2 !== t3 && (this._set("attributes", t3), this._notifyLayer("attributes", e2, t3));
  }
  set geometry(t3) {
    const e2 = this._get("geometry");
    e2 !== t3 && (this._set("geometry", t3), "mesh" !== t3?.type && this._notifyLayer("geometry", e2, t3));
  }
  set popupTemplate(t3) {
    const e2 = this._get("popupTemplate");
    e2 !== t3 && (this._set("popupTemplate", t3), this._notifyLayer("popupTemplate", e2, t3));
  }
  set symbol(t3) {
    const e2 = this._get("symbol");
    e2 !== t3 && (this._set("symbol", t3), this._notifyLayer("symbol", e2, t3));
  }
  get version() {
    return this._version;
  }
  set visible(t3) {
    const e2 = this._get("visible");
    e2 !== t3 && (this._set("visible", t3), this._notifyLayer("visible", e2, t3));
  }
  cloneShallow() {
    return new b({ aggregateGeometries: this.aggregateGeometries, attributes: this.attributes, geometry: this.geometry, isAggregate: this.isAggregate, layer: this.layer, popupTemplate: this.popupTemplate, sourceLayer: this.sourceLayer, symbol: this.symbol, visible: this.visible, origin: this.origin });
  }
  getEffectivePopupTemplate(t3 = false) {
    if (this.popupTemplate) return this.popupTemplate;
    const e2 = t2(this.origin);
    if (e2) return e2.popupTemplate ?? (t3 ? e2.defaultPopupTemplate : null) ?? null;
    const r = this.origin && "layer" in this.origin ? this.origin.layer : null;
    for (const i4 of [r, this.sourceLayer, this.layer]) if (i4 && "object" == typeof i4) {
      if ("popupTemplate" in i4 && i4.popupTemplate) return i4.popupTemplate;
      if (t3 && "defaultPopupTemplate" in i4 && null != i4.defaultPopupTemplate) return i4.defaultPopupTemplate;
    }
    return null;
  }
  getAttribute(t3) {
    return this.attributes?.[t3];
  }
  setAttribute(t3, e2) {
    if (this.attributes) {
      const r = this.getAttribute(t3);
      this.attributes[t3] = e2, this._notifyLayer("attributes", r, e2, t3);
    } else this.attributes = { [t3]: e2 };
  }
  getObjectId() {
    const t3 = i3(this.origin);
    if (t3) return i2(this, t3);
    const e2 = this.sourceLayer ?? this.layer;
    return e2 ? i2(this, e2) : null;
  }
  getGlobalId() {
    const t3 = i3(this.origin);
    if (t3?.globalIdField) return this.getAttribute(t3.globalIdField);
    const e2 = this.sourceLayer ?? this.layer;
    return e2 && "globalIdField" in e2 && e2.globalIdField ? this.getAttribute(e2.globalIdField) : null;
  }
  toJSON() {
    return { aggregateGeometries: v(this.aggregateGeometries), geometry: null != this.geometry ? this.geometry.toJSON() : null, symbol: null != this.symbol ? this.symbol.toJSON() : null, attributes: t(this.attributes) ? this.attributes.toJSON() : { ...this.attributes }, popupTemplate: this.popupTemplate?.toJSON() ?? null };
  }
  notifyMeshTransformChanged(t3 = {}) {
    const { geometry: e2 } = this;
    if ("mesh" === e2?.type) {
      const r = { origin: e2.origin, transform: e2.transform };
      this._notifyLayer("origin-transform", r, r, t3.action);
    }
  }
  _notifyLayer(t3, e2, r, i4) {
    if (this._version++, !this.layer || !("graphicChanged" in this.layer)) return;
    const s = { graphic: this, property: t3, oldValue: e2, newValue: r };
    "origin-transform" === t3 && (s.action = i4), "attributes" === t3 && (s.attributeName = i4), this.layer.graphicChanged(s);
  }
  _watchMeshGeometryChanges() {
    this.addHandles([f(() => "mesh" === this.geometry?.type && this.geometry.vertexSpace.origin ? { localMatrix: this.geometry.transform?.localMatrix, origin: this.geometry.vertexSpace.origin } : void 0, ({ localMatrix: t3, origin: e2 }) => {
      this._lastMeshTransform.localMatrix === t3 && this._lastMeshTransform.origin === e2 || (this._lastMeshTransform.localMatrix = t3, this._lastMeshTransform.origin = e2, this.notifyMeshTransformChanged());
    }), f(() => "mesh" === this.geometry?.type ? { vertexAttributes: this.geometry.vertexAttributes } : void 0, () => {
      const t3 = this.geometry;
      "mesh" === t3?.type && t3.vertexSpace.origin ? (this._lastMeshTransform.localMatrix = t3.transform?.localMatrix, this._lastMeshTransform.origin = t3.vertexSpace.origin) : (this._lastMeshTransform.localMatrix = void 0, this._lastMeshTransform.origin = void 0), this._notifyLayer("geometry", this.geometry, this.geometry);
    }, { equals: (t3, e2) => t3 === e2, sync: true })]);
  }
}, b = _a, _a);
__decorate([m({ value: null, json: { read: d } })], _.prototype, "aggregateGeometries", null), __decorate([m({ value: null })], _.prototype, "attributes", null), __decorate([m({ value: null, types: l2, json: { read: f2 } })], _.prototype, "geometry", null), __decorate([m({ type: Boolean })], _.prototype, "isAggregate", void 0), __decorate([m({ clonable: false })], _.prototype, "layer", void 0), __decorate([m({ clonable: "reference" })], _.prototype, "origin", void 0), __decorate([m({ type: q, value: null })], _.prototype, "popupTemplate", null), __decorate([m({ clonable: "reference" })], _.prototype, "sourceLayer", void 0), __decorate([m({ value: null, types: x })], _.prototype, "symbol", null), __decorate([m({ clonable: false, json: { read: false, write: false } })], _.prototype, "_version", void 0), __decorate([m({ type: Boolean, value: true })], _.prototype, "visible", null), _ = b = __decorate([a("esri.Graphic")], _);

export {
  n2 as n,
  _
};
//# sourceMappingURL=chunk-C3FRY5U4.js.map
