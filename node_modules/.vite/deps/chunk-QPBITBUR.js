import {
  p as p2,
  s as s3
} from "./chunk-PJJUVY7C.js";
import {
  o as o3
} from "./chunk-7VJQTJLO.js";
import {
  A
} from "./chunk-EVZ7KLPS.js";
import {
  s as s2
} from "./chunk-VKFTCFFM.js";
import {
  l as l4,
  p as p3
} from "./chunk-CZOYDK6P.js";
import {
  m as m2
} from "./chunk-RS755KXS.js";
import {
  te
} from "./chunk-KY5OS6CK.js";
import {
  p
} from "./chunk-UOYGMZIS.js";
import {
  V,
  b,
  l as l3
} from "./chunk-TWU3GKHX.js";
import {
  a as a4
} from "./chunk-7YH7T6CS.js";
import {
  n2,
  q
} from "./chunk-JNJX34GB.js";
import {
  g3 as g
} from "./chunk-23NJHA5Q.js";
import {
  u
} from "./chunk-F7DKSAOI.js";
import {
  x
} from "./chunk-JW6DU3OK.js";
import {
  l as l2
} from "./chunk-T7F6Q6JJ.js";
import {
  U,
  l
} from "./chunk-2OFHDVO5.js";
import {
  o as o2
} from "./chunk-CSMCPN64.js";
import {
  r as r2
} from "./chunk-7H3U4IJR.js";
import {
  o
} from "./chunk-XWE6BM2U.js";
import {
  r
} from "./chunk-SOIZOFSB.js";
import {
  n
} from "./chunk-XXLHAM2M.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a as a2,
  a2 as a3
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  a,
  e,
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  has
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/graphic/AggregateGraphicOrigin.js
var r3 = class extends s2 {
  constructor(e2) {
    super(), this.type = "aggregate", this.featureReductionProvider = e2;
  }
  get id() {
    return this.featureReductionProvider.id;
  }
  get [n2]() {
    const e2 = this.featureReductionProvider.featureReduction;
    return e2 && "popupTemplate" in e2 ? e2 : null;
  }
};

// node_modules/@arcgis/core/layers/support/ExpressionInfo.js
var p4 = class extends l2(n) {
  constructor(r4) {
    super(r4), this.expression = null, this.title = null, this.returnType = null;
  }
};
__decorate([m({ type: String, json: { write: true } })], p4.prototype, "expression", void 0), __decorate([m({ type: String, json: { write: true } })], p4.prototype, "title", void 0), __decorate([m({ type: String, json: { write: true } })], p4.prototype, "returnType", void 0), p4 = __decorate([a3("esri.layers.support.ExpressionInfo")], p4);

// node_modules/@arcgis/core/layers/support/AggregateField.js
var p5;
var _a;
var n3 = (_a = class extends n {
  constructor(t) {
    super(t), this.isAutoGenerated = false, this.name = null, this.alias = null, this.onStatisticField = null, this.onStatisticExpression = null, this.statisticType = null;
  }
  clone() {
    return new p5({ name: this.name, alias: this.alias, isAutoGenerated: this.isAutoGenerated, onStatisticExpression: a(this.onStatisticExpression), onStatisticField: this.onStatisticField, statisticType: this.statisticType });
  }
}, p5 = _a, _a);
__decorate([m({ type: Boolean, json: { write: true } })], n3.prototype, "isAutoGenerated", void 0), __decorate([m({ type: String, json: { write: true } })], n3.prototype, "name", void 0), __decorate([m({ type: String, json: { write: true } })], n3.prototype, "alias", void 0), __decorate([m({ type: String, json: { write: true } })], n3.prototype, "onStatisticField", void 0), __decorate([m({ type: p4, json: { write: true } })], n3.prototype, "onStatisticExpression", void 0), __decorate([m({ type: String, json: { write: true } })], n3.prototype, "statisticType", void 0), n3 = p5 = __decorate([a3("esri.layers.support.AggregateField")], n3);

// node_modules/@arcgis/core/layers/support/FeatureReductionBinning.js
var j;
var v = j = class extends s3 {
  constructor(e2) {
    super(e2), this.type = "binning", this.binType = "geohash", this.fixedBinLevel = null, this.labelingInfo = null, this.labelsVisible = true, this.maxScale = 0, this.popupEnabled = true, this.popupTemplate = null, this.size = o2("12px"), this.fields = [], this.renderer = null;
  }
  writeFields(e2, r4, o4) {
    const i2 = e2.filter((e3) => "avg_angle" !== e3.statisticType).map((e3) => e3.toJSON());
    e(o4, i2, r4);
  }
  readRenderer(e2, r4, o4) {
    const t = r4.drawingInfo?.renderer;
    return t ? o3(t, r4, o4) ?? void 0 : te(r4, o4);
  }
  clone() {
    return new j({ fields: a(this.fields), fixedBinLevel: this.fixedBinLevel, labelingInfo: a(this.labelingInfo), labelsVisible: this.labelsVisible, maxScale: this.maxScale, popupEnabled: this.popupEnabled, popupTemplate: a(this.popupTemplate), renderer: a(this.renderer), binType: a(this.binType), size: this.size });
  }
};
__decorate([r2({ binning: "binning" })], v.prototype, "type", void 0), __decorate([r2({ geohash: "geohash", square: "square" }), m({ type: ["geohash", "square"] })], v.prototype, "binType", void 0), __decorate([m({ type: Number, json: { write: true } })], v.prototype, "fixedBinLevel", void 0), __decorate([m({ type: [A], json: { read: { source: "drawingInfo.labelingInfo" }, write: { target: "drawingInfo.labelingInfo" } } })], v.prototype, "labelingInfo", void 0), __decorate([m(p3)], v.prototype, "labelsVisible", void 0), __decorate([m({ type: Number, json: { default: 0, name: "visibilityInfo.maxScale" } })], v.prototype, "maxScale", void 0), __decorate([m(l4)], v.prototype, "popupEnabled", void 0), __decorate([m({ type: q, json: { name: "popupInfo", write: true } })], v.prototype, "popupTemplate", void 0), __decorate([m({ cast: (e2) => "auto" === e2 ? e2 : a2(o2(e2)) })], v.prototype, "size", void 0), __decorate([m({ type: [n3], json: { write: true } })], v.prototype, "fields", void 0), __decorate([r("fields")], v.prototype, "writeFields", null), __decorate([m({ types: m2, json: { write: { target: "drawingInfo.renderer" } } })], v.prototype, "renderer", void 0), __decorate([o("renderer", ["drawingInfo.renderer"])], v.prototype, "readRenderer", null), v = j = __decorate([a3("esri.layers.support.FeatureReductionBinning")], v);

// node_modules/@arcgis/core/layers/support/FeatureReductionCluster.js
var S;
function w(e2) {
  return "simple" === e2.type && !e2.visualVariables?.length;
}
var I = S = class extends n {
  constructor(e2) {
    super(e2), this.type = "cluster", this.clusterRadius = o2("80px"), this.clusterMinSize = o2("12px"), this.clusterMaxSize = o2("50px"), this.maxScale = 0, this.popupEnabled = true, this.popupTemplate = null, this.renderer = null, this.symbol = null, this.labelingInfo = null, this.labelsVisible = true, this.fields = [];
  }
  readRenderer(e2, r4, t) {
    const o4 = r4.drawingInfo?.renderer;
    return o4?.authoringInfo?.isAutoGenerated ? null : o4 ? w(o4) ? null : o3(o4, r4, t) ?? void 0 : te(r4, t);
  }
  readSymbol(e2, r4, t) {
    const o4 = r4.drawingInfo?.renderer;
    if (o4?.authoringInfo?.isAutoGenerated) return null;
    if (o4 && w(o4)) {
      const e3 = o3(o4, r4, t);
      return e3?.symbol;
    }
    return null;
  }
  writeSymbol(e2, r4, t, o4) {
    const s4 = this.renderer?.authoringInfo?.isAutoGenerated;
    if (!this.renderer || s4) {
      const t2 = new p({ symbol: e2 });
      r4.drawingInfo = { renderer: t2.write({}, o4) };
    }
  }
  writeFields(e2, r4, t) {
    const o4 = e2.filter((e3) => "avg_angle" !== e3.statisticType).map((e3) => e3.toJSON());
    e(t, o4, r4);
  }
  readFields(e2, r4, t) {
    return e2.filter((e3) => !e3.isAutoGenerated).map((e3) => n3.fromJSON(e3));
  }
  clone() {
    return new S({ clusterRadius: this.clusterRadius, clusterMinSize: this.clusterMinSize, clusterMaxSize: this.clusterMaxSize, labelingInfo: a(this.labelingInfo), labelsVisible: this.labelsVisible, fields: a(this.fields), maxScale: this.maxScale, renderer: a(this.renderer), symbol: a(this.symbol), popupEnabled: this.popupEnabled, popupTemplate: a(this.popupTemplate) });
  }
};
__decorate([m({ type: ["cluster"], readOnly: true, json: { write: true } })], I.prototype, "type", void 0), __decorate([m({ cast: (e2) => "auto" === e2 ? e2 : a2(o2(e2)), json: { write: true } })], I.prototype, "clusterRadius", void 0), __decorate([m({ type: Number, cast: o2, json: { write: true } })], I.prototype, "clusterMinSize", void 0), __decorate([m({ type: Number, cast: o2, json: { write: true } })], I.prototype, "clusterMaxSize", void 0), __decorate([m({ type: Number, json: { default: 0, name: "visibilityInfo.maxScale" } })], I.prototype, "maxScale", void 0), __decorate([m(l4)], I.prototype, "popupEnabled", void 0), __decorate([m({ type: q, json: { read: { source: "popupInfo" }, write: { target: "popupInfo" } } })], I.prototype, "popupTemplate", void 0), __decorate([m({ types: m2, json: { write: { target: "drawingInfo.renderer" } } })], I.prototype, "renderer", void 0), __decorate([o("renderer", ["drawingInfo.renderer"])], I.prototype, "readRenderer", null), __decorate([m({ types: g })], I.prototype, "symbol", void 0), __decorate([o("symbol", ["drawingInfo.renderer"])], I.prototype, "readSymbol", null), __decorate([r("symbol")], I.prototype, "writeSymbol", null), __decorate([m({ type: [A], json: { read: { source: "drawingInfo.labelingInfo" }, write: { target: "drawingInfo.labelingInfo" } } })], I.prototype, "labelingInfo", void 0), __decorate([m(p3)], I.prototype, "labelsVisible", void 0), __decorate([m({ type: [n3], json: { write: true } })], I.prototype, "fields", void 0), __decorate([r("fields")], I.prototype, "writeFields", null), __decorate([o("fields")], I.prototype, "readFields", null), I = S = __decorate([a3("esri.layers.support.FeatureReductionCluster")], I);

// node_modules/@arcgis/core/layers/support/featureReductionUtils.js
var n4 = { key: "type", base: s3, typeMap: { cluster: I, binning: v } };
var a5 = { types: { key: "type", base: s3, typeMap: { selection: p2, cluster: I, binning: v } }, json: { name: "layerDefinition.featureReduction", write: { allowNull: true }, origins: { "web-map": { types: n4 }, "portal-item": { types: n4 }, "web-scene": { types: { key: "type", base: s3, typeMap: { selection: p2 } }, name: "layerDefinition.featureReduction", write: { allowNull: true, layerContainerTypes: a4 } } } } };

// node_modules/@arcgis/core/views/2d/layers/support/clusterUtils.js
var l5 = () => i.getLogger("esri.views.2d.layers.support.clusterUtils");
has.add("esri-cluster-arcade-enabled", true);
var u2 = has("esri-cluster-arcade-enabled");
var p6 = /* @__PURE__ */ new Set(["simple-line", "simple-fill", "picture-fill"]);
function d(e2, r4) {
  let s4 = r4.clone();
  if (!m3(s4)) return s4;
  if (r4.symbols.some((e3) => p6.has(e3.type)) && (s4 = new p({ symbol: new u() })), s4.authoringInfo || (s4.authoringInfo = new b()), s4.authoringInfo.isAutoGenerated = true, "visualVariables" in s4) {
    const r5 = (s4.visualVariables || []).filter((e3) => "$view.scale" !== e3.valueExpression);
    r5.forEach((r6) => {
      "rotation" === r6.type ? r6.field ? r6.field = v2(e2, r6.field, "avg_angle", "number") : r6.valueExpression && (r6.field = c(e2, r6.valueExpression, "avg_angle", "number"), r6.valueExpression = null) : r6.normalizationField ? (r6.field = v2(e2, r6.field, "avg_norm", "number", r6.normalizationField), r6.normalizationField = null) : r6.field ? r6.field = v2(e2, r6.field, "avg", "number") : r6.valueExpression && (r6.field = c(e2, r6.valueExpression, "avg", "number"), r6.valueExpression = null);
    }), s4.visualVariables = r5;
  }
  switch (s4.type) {
    case "simple":
      break;
    case "pie-chart":
      for (const r5 of s4.attributes) r5.field ? r5.field = v2(e2, r5.field, "sum", "number") : r5.valueExpression && (r5.field = c(e2, r5.valueExpression, "sum", "number"), r5.valueExpression = null);
      break;
    case "unique-value":
      s4.field ? s4.field = v2(e2, s4.field, "mode", "string") : s4.valueExpression && (s4.field = c(e2, s4.valueExpression, "mode", "string"), s4.valueExpression = null);
      break;
    case "class-breaks":
      s4.normalizationField ? (s4.field = v2(e2, s4.field, "avg_norm", "number", s4.normalizationField), s4.normalizationField = null) : s4.field ? s4.field = v2(e2, s4.field, "avg", "number") : s4.valueExpression && (s4.field = c(e2, s4.valueExpression, "avg", "number"), s4.valueExpression = null);
  }
  return s4;
}
var m3 = (r4) => {
  const s4 = (s5) => l5().error(new s("Unsupported-renderer", s5, { renderer: r4 }));
  if (!r4) return false;
  switch (r4.type) {
    case "unique-value":
      if (r4.field2 || r4.field3) return s4("FeatureReductionCluster does not support multi-field UniqueValueRenderers"), false;
      break;
    case "class-breaks":
      if (r4.normalizationField) {
        const e2 = r4.normalizationType;
        if ("field" !== e2) return s4(`FeatureReductionCluster does not support a normalizationType of ${e2}`), false;
      }
      break;
    case "simple":
    case "pie-chart":
      break;
    default:
      return s4(`FeatureReductionCluster does not support renderers of type ${r4.type}`), false;
  }
  if (!u2) {
    if ("valueExpression" in r4 && r4.valueExpression) return s4("FeatureReductionCluster does not currently support renderer.valueExpression. Support will be added in a future release"), false;
    if (("visualVariables" in r4 && r4.visualVariables || []).some((e2) => !(!("valueExpression" in e2) || !e2.valueExpression))) return s4("FeatureReductionCluster does not currently support visualVariables with a valueExpression. Support will be added in a future release"), false;
  }
  return true;
};
function f(e2, r4, i2) {
  switch (e2) {
    case "sum":
      return `cluster_sum_${r4}`;
    case "avg":
    case "avg_angle":
      return `cluster_avg_${r4}`;
    case "mode":
      return `cluster_type_${r4}`;
    case "avg_norm": {
      const e3 = i2, n5 = "field", t = r4.toLowerCase() + ",norm:" + n5 + "," + e3.toLowerCase();
      return "cluster_avg_" + x(t);
    }
  }
}
function c(e2, r4, t, a6) {
  const o4 = x(r4), l6 = "mode" === t ? `cluster_type_${o4}` : "sum" === t ? `cluster_sum_${o4}` : `cluster_avg_${o4}`;
  return e2.some((e3) => e3.name === l6) || e2.push(new n3({ name: l6, isAutoGenerated: true, onStatisticExpression: new p4({ expression: r4, returnType: a6 }), statisticType: t })), l6;
}
function v2(e2, r4, s4, t, a6) {
  if ("cluster_count" === r4 || e2.some((e3) => e3.name === r4)) return r4;
  const o4 = f(s4, r4, a6);
  return e2.some((e3) => e3.name === o4) || ("avg_norm" === s4 ? e2.push(new n3({ name: o4, isAutoGenerated: true, onStatisticExpression: new p4({ expression: `$feature.${r4} / $feature.${a6}`, returnType: t }), statisticType: "avg" })) : e2.push(new n3({ name: o4, isAutoGenerated: true, onStatisticField: r4, statisticType: s4 }))), o4;
}

// node_modules/@arcgis/core/layers/mixins/FeatureReductionLayer.js
var f2 = (f3) => {
  const p7 = f3;
  let m4 = class extends p7 {
    constructor(...e2) {
      super(...e2), this.aggregateGraphicOrigin = new r3(this), this.addHandles(l(() => this.renderer, () => {
        if (this.featureReduction) {
          const e3 = this._normalizeFeatureReduction(this.featureReduction);
          this._set("featureReduction", e3);
        }
      }, U));
    }
    set featureReduction(e2) {
      const r4 = this._normalizeFeatureReduction(e2);
      this._set("featureReduction", r4);
    }
    set renderer(e2) {
    }
    _withClusterVariable(e2, r4, t) {
      const i2 = e2.clone();
      if ("visualVariables" in i2) {
        i2.visualVariables || (i2.visualVariables = []);
        i2.visualVariables.some((e3) => "size" === e3.type) || i2.visualVariables.push(new V({ field: "cluster_count", stops: [new l3({ value: 1 }), new l3({ useMinValue: true, size: r4 }), new l3({ useMaxValue: true, size: t })] }));
      }
      return i2;
    }
    _normalizeFeatureReduction(e2) {
      if ("cluster" !== e2?.type) return e2;
      const r4 = e2.clone(), t = [new n3({ name: "cluster_count", alias: "cluster_count", isAutoGenerated: true, statisticType: "count" })], i2 = (r4.fields ?? []).filter((e3) => !e3.isAutoGenerated), s4 = e2.renderer && !e2.renderer.authoringInfo?.isAutoGenerated, { clusterMinSize: a6, clusterMaxSize: n5 } = r4;
      if (s4) {
        r4.fields = [...t, ...i2];
        const e3 = this._withClusterVariable(r4.renderer, a6, n5);
        return r4.effectiveFeatureRenderer = e3, r4.effectiveClusterRenderer = e3, r4;
      }
      if (e2.symbol) {
        if (r4.fields = [...t, ...i2], r4.renderer = null, !this.renderer) return r4.effectiveFeatureRenderer = null, r4.effectiveClusterRenderer = null, r4;
        const s5 = d(t, this.renderer), o4 = this._withClusterVariable(s5, a6, n5), l7 = "visualVariables" in o4 && o4.visualVariables ? o4.visualVariables : [], c3 = new p({ symbol: e2.symbol, visualVariables: l7 });
        return r4.fields = [...t, ...i2], r4.effectiveFeatureRenderer = o4, r4.effectiveClusterRenderer = c3, r4;
      }
      if (!this.renderer) return e2;
      const l6 = d(t, this.renderer);
      r4.fields = [...t, ...i2], r4.renderer = l6;
      const c2 = this._withClusterVariable(l6, a6, n5);
      return r4.effectiveFeatureRenderer = c2, r4.effectiveClusterRenderer = c2, r4;
    }
  };
  return __decorate([m({ readOnly: true, clonable: false })], m4.prototype, "aggregateGraphicOrigin", void 0), __decorate([m(a5)], m4.prototype, "featureReduction", null), m4 = __decorate([a3("esri.layers.mixins.FeatureReductionLayer")], m4), m4;
};

export {
  n3 as n,
  a5 as a,
  f2 as f
};
//# sourceMappingURL=chunk-QPBITBUR.js.map
