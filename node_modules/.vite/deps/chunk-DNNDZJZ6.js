import {
  o
} from "./chunk-HETHJJO6.js";
import {
  n as n3
} from "./chunk-CHC4AAHW.js";
import {
  i
} from "./chunk-CT7HOWYG.js";
import {
  e as e3
} from "./chunk-BZBDEPRV.js";
import {
  p
} from "./chunk-MXP2VO3L.js";
import {
  d,
  f,
  p as p2
} from "./chunk-OWSUTT7E.js";
import {
  e as e2
} from "./chunk-COMSADUT.js";
import {
  e
} from "./chunk-IT62DCG6.js";
import {
  r
} from "./chunk-EGPAQBOO.js";
import {
  s
} from "./chunk-WJ3E33GQ.js";
import {
  r as r2
} from "./chunk-YOYO2XMY.js";
import {
  n as n2,
  t
} from "./chunk-CFXCM2NO.js";
import {
  n
} from "./chunk-ZVTEFYZX.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/ScreenSizeScaling.glsl.js
function n4(n5, c) {
  if (!c.screenSizeEnabled) return;
  const t2 = n5.vertex;
  d(t2, c), t2.uniforms.add(new r("perScreenPixelRatio", (e4) => e4.camera.perScreenPixelRatio), new r2("screenSizeScale", (e4) => e4.screenSizeScale)).code.add(t`float computeRenderPixelSizeAt( vec3 pWorld ){
vec3 viewForward = - vec3(view[0][2], view[1][2], view[2][2]);
float viewDirectionDistance = abs(dot(viewForward, pWorld - cameraPosition));
return viewDirectionDistance * perScreenPixelRatio;
}
vec3 screenSizeScaling(vec3 position, vec3 anchor){
return position * screenSizeScale * computeRenderPixelSizeAt(anchor) + anchor;
}`);
}

// node_modules/@arcgis/core/chunks/ShadedColorMaterial.glsl.js
function w(e4) {
  const w2 = new s();
  w2.include(o), w2.include(n4, e4), w2.fragment.include(p, e4), w2.include(n3, e4), w2.include(i, e4);
  const { vertex: u2, fragment: b2 } = w2;
  return b2.include(e3), f(u2, e4), b2.uniforms.add(new e2("uColor", (e5) => e5.color)), w2.attributes.add("position", "vec3"), w2.varyings.add("vWorldPosition", "vec3"), e4.screenSizeEnabled && w2.attributes.add("offset", "vec3"), e4.shadingEnabled && (p2(u2), w2.attributes.add("normal", "vec3"), w2.varyings.add("vViewNormal", "vec3"), b2.uniforms.add(new e("shadingDirection", (e5) => e5.shadingDirection)), b2.uniforms.add(new e2("shadedColor", (e5) => f2(e5.shadingTint, e5.color)))), u2.main.add(t`
    vWorldPosition = ${e4.screenSizeEnabled ? t`screenSizeScaling(offset, position)` : t`position`};
    ${n2(e4.shadingEnabled, t`vec3 worldNormal = normal;
           vViewNormal = (viewNormal * vec4(worldNormal, 1)).xyz;`)}
    forwardViewPosDepth((view * vec4(vWorldPosition, 1.0)).xyz);
    gl_Position = transformPosition(proj, view, vWorldPosition);
  `), b2.main.add(t`
      discardBySlice(vWorldPosition);
      discardByTerrainDepth();
      ${e4.shadingEnabled ? t`vec3 viewNormalNorm = normalize(vViewNormal);
             float shadingFactor = 1.0 - clamp(-dot(viewNormalNorm, shadingDirection), 0.0, 1.0);
             vec4 finalColor = mix(uColor, shadedColor, shadingFactor);` : t`vec4 finalColor = uColor;`}
      outputColorHighlightOID(finalColor, vWorldPosition, finalColor.rgb);`), w2;
}
function f2(e4, o2) {
  const r3 = 1 - e4[3], i2 = e4[3] + o2[3] * r3;
  return 0 === i2 ? (u[3] = i2, u) : (u[0] = (e4[0] * e4[3] + o2[0] * o2[3] * r3) / i2, u[1] = (e4[1] * e4[3] + o2[1] * o2[3] * r3) / i2, u[2] = (e4[2] * e4[3] + o2[2] * o2[3] * r3) / i2, u[3] = o2[3], u);
}
var u = n();
var b = Object.freeze(Object.defineProperty({ __proto__: null, build: w }, Symbol.toStringTag, { value: "Module" }));

export {
  w,
  b
};
//# sourceMappingURL=chunk-DNNDZJZ6.js.map
