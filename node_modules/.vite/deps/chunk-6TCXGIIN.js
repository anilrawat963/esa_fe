import {
  f as f2
} from "./chunk-H34D76ZQ.js";
import {
  N
} from "./chunk-CNYNCKEV.js";
import {
  _
} from "./chunk-XL5QPCXN.js";
import {
  k
} from "./chunk-W75DBJD7.js";
import {
  M,
  u as u2
} from "./chunk-7P2ANHQ3.js";
import {
  D,
  H2 as H,
  K,
  T,
  s2 as s4
} from "./chunk-V2H77UEV.js";
import {
  o
} from "./chunk-XWE6BM2U.js";
import {
  r
} from "./chunk-SOIZOFSB.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  d,
  f2 as f,
  s as s3,
  u2 as u
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i,
  s,
  s2
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/layers/mixins/PortalLayer.js
var j = (j2) => {
  const _2 = j2;
  let b = class extends _2 {
    constructor() {
      super(...arguments), this.resourceReferences = { portalItem: null, paths: [] }, this.userHasEditingPrivileges = true, this.userHasFullEditingPrivileges = false, this.userHasUpdateItemPrivileges = false;
    }
    destroy() {
      this.portalItem = u(this.portalItem), this.resourceReferences.portalItem = null, this.resourceReferences.paths.length = 0;
    }
    set portalItem(e) {
      e !== this._get("portalItem") && (this.removeOrigin("portal-item"), this._set("portalItem", e));
    }
    readPortalItem(e, t, r2) {
      if (t.itemId) return new k({ id: t.itemId, portal: r2?.portal });
    }
    writePortalItem(e, t) {
      e?.id && (t.itemId = e.id);
    }
    async loadFromPortal(e, t) {
      if (this.portalItem?.id) try {
        const { load: r2 } = await import("./layersLoader-2PJERWO5.js");
        return s3(t), await r2({ instance: this, supportedTypes: e.supportedTypes, validateItem: e.validateItem, supportsData: e.supportsData, layerModuleTypeMap: e.layerModuleTypeMap, populateGroupLayer: e.populateGroupLayer }, t);
      } catch (r2) {
        throw d(r2) || i.getLogger(this).warn(`Failed to load layer (${this.title}, ${this.id}) portal item (${this.portalItem.id})
  ${r2}`), r2;
      }
    }
    async finishLoadEditablePortalLayer(e) {
      this._set("userHasEditingPrivileges", await this._fetchUserHasEditingPrivileges(e).catch((e2) => (f(e2), true)));
    }
    async setUserPrivileges(e, r2) {
      if (!s.userPrivilegesApplied) return this.finishLoadEditablePortalLayer(r2);
      if (this.url) try {
        const { features: { edit: t, fullEdit: s5 }, content: { updateItem: i2 } } = await this._fetchUserPrivileges(e, r2);
        this._set("userHasEditingPrivileges", t), this._set("userHasFullEditingPrivileges", s5), this._set("userHasUpdateItemPrivileges", i2);
      } catch (s5) {
        f(s5);
      }
    }
    async _fetchUserPrivileges(e, t) {
      let s5 = this.portalItem;
      if (!e || !s5 || !s5.loaded || s5.sourceUrl) return this._fetchFallbackUserPrivileges(t);
      const i2 = !s4?.findCredential(this.url), o2 = e === s5.id;
      if (o2 && s5.portal.user) return this._getUserPrivileges(s5, i2);
      let a2, l;
      if (o2) a2 = s5.portal.url;
      else try {
        a2 = await N(this.url, t);
      } catch (m2) {
        f(m2);
      }
      if (!a2 || !T(a2, s5.portal.url)) return this._fetchFallbackUserPrivileges(t);
      try {
        const e2 = null != t ? t.signal : null;
        l = await s4?.getCredential(`${a2}/sharing`, { prompt: false, signal: e2 });
      } catch (m2) {
        f(m2);
      }
      const n = true, p = false, d2 = false;
      if (!l) return { features: { edit: n, fullEdit: p }, content: { updateItem: d2 } };
      try {
        if (o2 ? await s5.reload() : (s5 = new k({ id: e, portal: { url: a2 } }), await s5.load(t)), s5.portal.user) return this._getUserPrivileges(s5, i2);
      } catch (m2) {
        f(m2);
      }
      return { features: { edit: n, fullEdit: p }, content: { updateItem: d2 } };
    }
    _getUserPrivileges(e, t) {
      const r2 = f2(e);
      return t && (r2.features.edit = true), r2;
    }
    async _fetchFallbackUserPrivileges(e) {
      let t = true;
      try {
        t = await this._fetchUserHasEditingPrivileges(e);
      } catch (r2) {
        f(r2);
      }
      return { features: { edit: t, fullEdit: false }, content: { updateItem: false } };
    }
    async _fetchUserHasEditingPrivileges(e) {
      const t = this.url ? s4?.findCredential(this.url) : null;
      if (!t) return true;
      const s5 = E.credential === t ? E.user : await this._fetchEditingUser(e);
      return E.credential = t, E.user = s5, null == s5?.privileges || s5.privileges.includes("features:user:edit");
    }
    async _fetchEditingUser(e) {
      const t = this.portalItem?.portal?.user;
      if (t) return t;
      const o2 = s4?.findServerInfo(this.url ?? "");
      if (!o2?.owningSystemUrl) return null;
      const a2 = `${o2.owningSystemUrl}/sharing/rest`, l = M.getDefault();
      if (l && l.loaded && K(l.restUrl) === K(a2)) return l.user;
      const n = `${a2}/community/self`, p = null != e ? e.signal : null, u3 = await _(H(n, { authMode: "no-prompt", query: { f: "json" }, signal: p }));
      return u3.ok ? u2.fromJSON(u3.value.data) : null;
    }
    read(e, t) {
      t && (t.layer = this), super.read(e, t);
    }
    write(e, t) {
      const r2 = t?.portal, s5 = this.portalItem?.id && (this.portalItem.portal || M.getDefault());
      return r2 && s5 && !D(s5.restUrl, r2.restUrl) ? (t.messages && t.messages.push(new s2("layer:cross-portal", `The layer '${this.title} (${this.id})' cannot be persisted because it refers to an item on a different portal than the one being saved to. To save, set layer.portalItem to null or save to the same portal as the item associated with the layer`, { layer: this })), null) : super.write(e, { ...t, layer: this });
    }
  };
  return __decorate([m({ type: k })], b.prototype, "portalItem", null), __decorate([o("web-document", "portalItem", ["itemId"])], b.prototype, "readPortalItem", null), __decorate([r("web-document", "portalItem", { itemId: { type: String } })], b.prototype, "writePortalItem", null), __decorate([m({ clonable: false })], b.prototype, "resourceReferences", void 0), __decorate([m({ type: Boolean, readOnly: true })], b.prototype, "userHasEditingPrivileges", void 0), __decorate([m({ type: Boolean, readOnly: true })], b.prototype, "userHasFullEditingPrivileges", void 0), __decorate([m({ type: Boolean, readOnly: true })], b.prototype, "userHasUpdateItemPrivileges", void 0), b = __decorate([a("esri.layers.mixins.PortalLayer")], b), b;
};
var E = { credential: null, user: null };

export {
  j
};
//# sourceMappingURL=chunk-6TCXGIIN.js.map
