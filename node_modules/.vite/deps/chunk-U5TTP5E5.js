import {
  e
} from "./chunk-GCI4MA3M.js";
import {
  l,
  m,
  s as s3,
  u,
  y
} from "./chunk-GD4FJL3C.js";
import {
  g2 as g,
  s2,
  t2 as t,
  x2 as x
} from "./chunk-PZ5RULLK.js";
import {
  s
} from "./chunk-OPJX4KXH.js";
import {
  i
} from "./chunk-FPMLKIDB.js";
import {
  G
} from "./chunk-H74Q4SYB.js";
import {
  a
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/geometry/GeometryCursor.js
var a2 = class {
  static fromOptimized(t3, e2, s4 = false, i2 = false, h2 = 1) {
    return new p().initialize(t3, e2, s4, i2, h2);
  }
  static fromJSON(t3, e2 = false, s4 = false) {
    const [i2, h2] = u2(t3);
    return new c().initialize(i2, h2, e2, s4, 1);
  }
  static fromOptimizedCIM(t3, e2, s4 = false, i2 = false, h2 = 1) {
    return new y2().initialize(t3, e2, s4, i2, h2);
  }
  static fromJSONCIM(t3, e2 = false, s4 = false, i2 = 1) {
    const [h2, r] = u2(t3);
    return new m2().initialize(h2, r, e2, s4, i2);
  }
  static fromFeatureSetReader(t3) {
    const e2 = t3.readGeometryForDisplay(), s4 = t3.geometryType;
    return e2 && s4 ? this.fromOptimized(e2, s4) : null;
  }
  static fromFeatureSetReaderCIM(t3) {
    const e2 = t3.readGeometryForDisplay(), s4 = t3.geometryType;
    return e2 && s4 ? this.fromOptimizedCIM(e2, s4) : null;
  }
  static createEmptyOptimized(t3, e2 = false, s4 = false, i2 = 1) {
    return new p().initialize(new e(), t3, e2, s4, i2);
  }
  static createEmptyJSON(t3, e2 = false, s4 = false) {
    return new c().initialize([], t3, e2, s4, 1);
  }
  static createEmptyOptimizedCIM(t3, e2 = false, s4 = false, i2 = 1) {
    return new y2().initialize(new e(), t3, e2, s4, i2);
  }
  static createEmptyJSONCIM(t3, e2 = false, s4 = false, i2 = 1) {
    return new m2().initialize([], t3, e2, s4, i2);
  }
  asJSON() {
    const t3 = t(this);
    return "esriGeometryEnvelope" === this.geometryType ? { xmin: t3[0][0][0], ymin: t3[0][0][1], xmax: t3[0][2][0], ymax: t3[0][2][1] } : "esriGeometryMultipoint" === this.geometryType ? { points: t3.flat() } : "esriGeometryPoint" === this.geometryType ? { x: t3[0][0][0], y: t3[0][0][1] } : "esriGeometryPolygon" === this.geometryType ? { rings: t3 } : { paths: t3 };
  }
  getCurrentRingArea() {
    if (this.pathSize < 3) return 0;
    let t3, e2, s4 = 0;
    if (this.seekPathStart(), !this.nextPoint()) return 0;
    t3 = this.x, e2 = this.y;
    const i2 = t3, h2 = e2;
    for (; this.nextPoint(); ) s4 += (t3 - this.x) * (e2 + this.y), t3 = this.x, e2 = this.y;
    return s4 += (t3 - i2) * (e2 + h2), -0.5 * s4;
  }
  invertY() {
    this.yFactor *= -1;
  }
};
var p = class _p extends a2 {
  constructor() {
    super(...arguments), this._end = -1;
  }
  initialize(t3, e2, s4, i2, h2) {
    return this.hasZ = s4, this.hasM = i2, this.geometryType = e2, this._stride = 2 + Number(s4) + Number(i2), this._geometry = t3, this._pathIndex = -1, this._pathOffset = 0, this._pointOffset = -this._stride, this._end = -1, this.yFactor = h2, this;
  }
  reset() {
    this.initialize(this._geometry, this.geometryType, this.hasZ, this.hasM, this.yFactor);
  }
  seekPath(t3) {
    if (t3 >= 0 && t3 < this.totalSize) {
      if (this._pathIndex < t3) for (; this._pathIndex < t3 && this.nextPath(); ) ;
      else if (this._pathIndex > t3) for (; this._pathIndex > t3 && this.prevPath(); ) ;
      return true;
    }
    return false;
  }
  seekPathStart() {
    this._pointOffset = this._pathOffset - this._stride;
  }
  seekPathEnd() {
    this._pointOffset = this._end;
  }
  seekInPath(t3) {
    const e2 = this._pathOffset + t3 * this._stride;
    return e2 >= 0 && e2 < this._end && (this._pointOffset = e2, true);
  }
  nextPoint() {
    return (this._pointOffset += this._stride) < this._end;
  }
  prevPoint() {
    return (this._pointOffset -= this._stride) >= this._pathOffset;
  }
  nextPath() {
    return !(this.pathIndex >= this.totalSize - 1) && (this._pathIndex >= 0 && (this._pathOffset += this._stride * this.pathSize), this._pathIndex++, this._pointOffset = this._pathOffset - this._stride, this._end = this._pointOffset + this._stride + this._stride * this.pathSize, true);
  }
  prevPath() {
    return !(this.pathIndex <= 0) && (this._pathIndex--, this._end = this._pathOffset, this._pathOffset -= this._stride * this.pathSize, this._pointOffset = this._pathOffset - this._stride, true);
  }
  getCurrentPath() {
    const t3 = this._end, e2 = this._geometry.coords, s4 = this._pathOffset;
    return new _p().initialize(new e([this.pathSize], e2.slice(s4, t3)), this.geometryType, this.hasZ, this.hasM, this.yFactor);
  }
  pathLength() {
    const t3 = this._end, e2 = this._stride, s4 = this._geometry.coords;
    let i2 = 0;
    for (let h2 = this._pathOffset + e2; h2 < t3; h2 += e2) {
      const t4 = s4[h2 - e2], r = s4[h2 - e2 + 1], n = s4[h2] - t4, o = s4[h2 + 1] - r;
      i2 += Math.sqrt(n * n + o * o);
    }
    return i2;
  }
  startPath() {
    this._geometry.lengths.push(0);
  }
  pushPath(t3) {
    this.startPath(), this.pushPoints(t3);
  }
  pushPoint(t3) {
    for (let e2 = 0; e2 < this._stride; ++e2) this._geometry.coords.push(t3[e2]);
    this._geometry.lengths[this.totalSize - 1]++;
  }
  pushXY(t3, e2) {
    this._geometry.coords.push(t3, e2), this._geometry.lengths[this.totalSize - 1]++;
  }
  pushPoints(t3) {
    for (const e2 of t3) for (let t4 = 0; t4 < this._stride; ++t4) this._geometry.coords.push(e2[t4]);
    this._geometry.lengths[this.totalSize - 1] += t3.length;
  }
  pushCursor(t3) {
    const e2 = t3.asOptimized();
    this._geometry.coords.push(...e2.coords), this._geometry.lengths.push(...e2.lengths);
  }
  asOptimized() {
    const t3 = this._geometry.clone();
    if (1 !== this.yFactor) for (let e2 = 1; e2 < t3.coords.length; e2 += this._stride) t3.coords[e2] *= this.yFactor;
    return "esriGeometryPoint" === this.geometryType && (t3.lengths.length = 0), t3;
  }
  isClosed() {
    const t3 = this._geometry.coords, e2 = this._pathOffset, s4 = this._end - this._stride;
    for (let i2 = 0; i2 < this._stride; i2++) if (t3[e2 + i2] !== t3[s4 + i2]) return false;
    return true;
  }
  clone() {
    return new _p().initialize(this._geometry.clone(), this.geometryType, this.hasZ, this.hasM, this.yFactor);
  }
  get totalPoints() {
    return this._geometry.isPoint ? 1 : this._geometry.lengths.reduce((t3, e2) => t3 + e2);
  }
  get pathSize() {
    const { lengths: t3 } = this._geometry;
    return this._geometry.isPoint ? 1 : this._pathIndex < 0 || this._pathIndex > t3.length - 1 ? 0 : t3[this._pathIndex];
  }
  get totalSize() {
    return this._geometry.isPoint ? 1 : this._geometry.lengths.length;
  }
  get x() {
    return this._geometry.coords[this._pointOffset];
  }
  set x(t3) {
    this._geometry.coords[this._pointOffset] = t3;
  }
  get y() {
    return this.yFactor * this._geometry.coords[this._pointOffset + 1];
  }
  set y(t3) {
    this._geometry.coords[this._pointOffset + 1] = this.yFactor * t3;
  }
  get z() {
    return this._geometry.coords[this._pointOffset + 2];
  }
  set z(t3) {
    this._geometry.coords[this._pointOffset + 2] = t3;
  }
  get m() {
    const t3 = this.hasZ ? 3 : 2;
    return this._geometry.coords[this._pointOffset + t3];
  }
  set m(t3) {
    this._geometry.coords[this._pointOffset + 3] = t3;
  }
  get pathIndex() {
    return this._pathIndex;
  }
  get _coordIndex() {
    return this._pointOffset / this._stride;
  }
};
function _(t3) {
  const e2 = [t3.x, t3.y];
  return t3.z && e2.push(t3.z), t3.m && e2.push(t3.m), e2;
}
function u2(t3) {
  return y(t3) ? [t3.rings, "esriGeometryPolygon"] : s3(t3) ? [t3.paths, "esriGeometryPolyline"] : u(t3) ? [[t3.points], "esriGeometryMultipoint"] : m(t3) ? [[[[t3.xmin, t3.ymin], [t3.xmin, t3.ymax], [t3.xmax, t3.ymax], [t3.xmax, t3.ymin], [t3.xmin, t3.ymin]]], "esriGeometryEnvelope"] : l(t3) ? [[[_(t3)]], "esriGeometryPoint"] : [[], "esriGeometryPolyline"];
}
var c = class _c extends a2 {
  initialize(t3, e2, s4, i2, h2) {
    return this._paths = t3, this.geometryType = e2, this.hasZ = s4, this.hasM = i2, this._pathIndex = this._pointIndex = -1, this.yFactor = h2, this._mIndex = this.hasZ ? 3 : 2, this;
  }
  reset() {
    this._pathIndex = this._pointIndex = -1;
  }
  seekPath(t3) {
    return this._pathIndex = t3, this._pointIndex = -1, t3 >= 0 && t3 < this.totalSize && (this._currentPath = this._paths[t3], true);
  }
  seekPathStart() {
    this._pointIndex = -1;
  }
  seekPathEnd() {
    this._pointIndex = this._currentPath.length;
  }
  seekInPath(t3) {
    return t3 >= 0 && t3 < this._currentPath.length && (this._pointIndex = t3, this._currentPoint = this._currentPath[this._pointIndex], true);
  }
  nextPoint() {
    return this._currentPoint = this._currentPath[++this._pointIndex], this._pointIndex < this._currentPath.length;
  }
  prevPoint() {
    return this._currentPoint = this._currentPath[--this._pointIndex], this._pointIndex >= 0;
  }
  nextPath() {
    return this._pointIndex = -1, this._currentPath = this._paths[++this._pathIndex], this._pathIndex < this.totalSize;
  }
  prevPath() {
    return this.pathIndex > 0 && (this._pointIndex = -1, this._pathIndex--, this._currentPath = this._paths[this._pathIndex], true);
  }
  pathLength() {
    const t3 = this._currentPath.length, e2 = this._currentPath;
    let s4 = 0;
    for (let i2 = 1; i2 < t3; i2++) {
      const t4 = e2[i2 - 1], h2 = e2[i2], r = t4[0], n = t4[1], o = h2[0] - r, a3 = h2[1] - n;
      s4 += Math.sqrt(o * o + a3 * a3);
    }
    return s4;
  }
  startPath() {
    this._paths.push([]);
  }
  getCurrentPath() {
    return new _c().initialize([this._currentPath], this.geometryType, this.hasZ, this.hasM, this.yFactor);
  }
  pushPath(t3) {
    this._paths.push(t3);
  }
  pushPoint(t3) {
    this._paths[this.totalSize - 1].push(t3);
  }
  pushXY(t3, e2) {
    this._paths[this.totalSize - 1].push([t3, e2]);
  }
  pushPoints(t3) {
    this._paths[this.totalSize - 1].push(...t3);
  }
  pushCursor(t3) {
    const s4 = t(t3);
    for (const e2 of s4) this.pushPath(e2);
  }
  asOptimized() {
    const t3 = new e();
    if ("esriGeometryPoint" === this.geometryType) t3.coords.push(...this._paths[0][0]), t3.lengths.length = 0;
    else for (const e2 of this._paths) {
      for (const s4 of e2) t3.coords.push(s4[0]), t3.coords.push(s4[1] * this.yFactor), this.hasZ && t3.coords.push(s4[2]), this.hasM && t3.coords.push(s4[this._mIndex]);
      t3.lengths.push(e2.length);
    }
    return t3;
  }
  isClosed() {
    const t3 = this._currentPath[0], e2 = this._currentPath[this._currentPath.length - 1];
    for (let s4 = 0; s4 < t3.length; s4++) if (t3[s4] !== e2[s4]) return false;
    return true;
  }
  clone() {
    return new _c().initialize(a(this._paths), this.geometryType, this.hasZ, this.hasM, this.yFactor);
  }
  get totalPoints() {
    return this._paths.map((t3) => t3.length).reduce((t3, e2) => t3 + e2);
  }
  get pathSize() {
    return this._pathIndex < 0 || this._pathIndex > this.totalSize - 1 ? -1 : this._paths[this._pathIndex].length;
  }
  get totalSize() {
    return this._paths.length;
  }
  get x() {
    return this._currentPoint[0];
  }
  set x(t3) {
    this._currentPoint[0] = t3;
  }
  get y() {
    return this.yFactor * this._currentPoint[1];
  }
  set y(t3) {
    this._currentPoint[1] = this.yFactor * t3;
  }
  get z() {
    return this._currentPoint[2];
  }
  set z(t3) {
    this._currentPoint[2] = t3;
  }
  get m() {
    return this._currentPoint[this._mIndex];
  }
  set m(t3) {
    this._currentPoint[this._mIndex] = t3;
  }
  get pathIndex() {
    return this._pathIndex;
  }
};
var d = 4;
var l2 = 1;
var y2 = class _y extends p {
  initialize(t3, e2, s4, i2, h2) {
    return super.initialize(t3, e2, s4, i2, h2), this._controlPoints || (this._controlPoints = this._controlPoints = new Array(this.totalSize).fill(void 0).map((t4) => /* @__PURE__ */ new Set())), this;
  }
  startPath() {
    super.startPath(), this._controlPoints.push(/* @__PURE__ */ new Set());
  }
  clone() {
    const t3 = new _y().initialize(this._geometry.clone(), this.geometryType, this.hasZ, this.hasM, this.yFactor);
    return t3._controlPoints = this._controlPoints, t3;
  }
  setControlPoint() {
    this._controlPoints[this.pathIndex].add(this._coordIndex);
  }
  getControlPoint() {
    return this._controlPoints[this.pathIndex].has(this._coordIndex);
  }
  setControlPointAt(t3) {
    this._controlPoints[this.pathIndex].add(t3);
  }
  getControlPointAt(t3) {
    return this._controlPoints[this.pathIndex].has(t3);
  }
};
var m2 = class _m extends c {
  initialize(t3, e2, s4, i2, h2) {
    return super.initialize(t3, e2, s4, i2, h2);
  }
  clone() {
    return new _m().initialize(a(this._paths), this.geometryType, this.hasZ, this.hasM, this.yFactor);
  }
  setControlPoint() {
    this._paths[this.pathIndex][this._pointIndex][d] = l2;
  }
  getControlPoint() {
    return this._paths[this.pathIndex][this._pointIndex][d] === l2;
  }
  setControlPointAt(t3) {
    this._paths[this.pathIndex][t3][d] = l2;
  }
  getControlPointAt(t3) {
    return this._paths[this.pathIndex][t3][d] === l2;
  }
};

// node_modules/@arcgis/core/geometry/support/labelPoint.js
var N = 100 * 222045e-21;
function l3(t3) {
  if (0 === t3.totalSize) return null;
  const a3 = x(t3);
  if (!a3) return null;
  const o = 4 * (Math.abs(a3[0]) + Math.abs(a3[2]) + Math.abs(a3[1]) + Math.abs(a3[3]) + 1) * N;
  let s4 = 0, c2 = 0;
  t3.reset();
  for (let e2 = 0; t3.nextPath(); e2++) {
    const n = t3.getCurrentRingArea();
    n > c2 && (c2 = n, s4 = e2);
  }
  if (t3.seekPath(s4), 0 === t3.pathSize) return null;
  t3.seekPathStart();
  const l4 = g(t3);
  if (Math.abs(c2) <= 2 * o * o) return [(l4[0] + l4[2]) / 2, (l4[1] + l4[3]) / 2];
  t3.seekPathStart();
  const x3 = s2(t3, i());
  if (null === x3) return null;
  if (t3.totalPoints < 4) return x3;
  const m4 = [[NaN, NaN], [NaN, NaN], [NaN, NaN], [NaN, NaN]], d3 = [NaN, NaN, NaN, NaN], P2 = [NaN, NaN, NaN, NaN];
  let y4 = false, M2 = f2(x3, t3, true);
  0 === M2.distance && (y4 = true, m4[0][0] = x3[0], m4[0][1] = x3[1], M2 = f2(x3, t3, false)), d3[0] = M2.distance, P2[0] = 0;
  const b2 = [NaN, NaN];
  let S = false, k = 0.25, z = -1, g2 = NaN;
  do {
    if (g2 = NaN, m4[1] = h(t3, w(l4[0], l4[2], k), o, a3), isNaN(m4[1][0]) || isNaN(m4[1][1]) || (M2 = f2(m4[1], t3, false), g2 = M2.distance), !isNaN(g2) && g2 > o && u3(m4[1], t3)) S = true, d3[1] = g2, P2[1] = p2(m4[1], x3);
    else if (!isNaN(g2) && g2 > z && (z = g2, b2[0] = m4[1][0], b2[1] = m4[1][1]), k -= 0.01, k < 0.1) {
      if (!(z >= 0)) break;
      S = true, d3[1] = z, m4[1][0] = b2[0], m4[1][1] = b2[1], P2[1] = p2(m4[1], x3);
    }
  } while (!S);
  S = false, k = 0.5, z = -1;
  let q = 0.01, j = 1;
  do {
    if (g2 = NaN, m4[2] = h(t3, w(l4[0], l4[2], k), o, a3), isNaN(m4[2][0]) || isNaN(m4[2][1]) || (M2 = f2(m4[2], t3, false), g2 = M2.distance), !isNaN(g2) && g2 > o && u3(m4[2], t3)) S = true, d3[2] = g2, P2[2] = p2(m4[2], x3);
    else if (!isNaN(g2) && g2 > z) z = g2, b2[0] = m4[2][0], b2[1] = m4[2][1];
    else if (g2 > z && (z = g2, b2[0] = m4[2][0], b2[1] = m4[2][1]), k = 0.5 + q * j, q += 0.01, j *= -1, k < 0.3 || k > 0.7) {
      if (!(z >= 0)) break;
      S = true, d3[2] = z, m4[2][0] = b2[0], m4[2][1] = b2[1], P2[2] = p2(m4[2], x3);
    }
  } while (!S);
  S = false, k = 0.75, z = -1;
  do {
    if (g2 = NaN, m4[3] = h(t3, w(l4[0], l4[2], k), o, a3), isNaN(m4[3][0]) || isNaN(m4[3][1]) || (M2 = f2(m4[3], t3, false), g2 = M2.distance), !isNaN(g2) && g2 > o && u3(m4[3], t3)) S = true, d3[3] = g2, P2[3] = p2(m4[3], x3);
    else if (g2 > z && (z = g2, b2[0] = m4[3][0], b2[1] = m4[3][1]), k += 0.01, k > 0.9) {
      if (!(z >= 0)) break;
      S = true, d3[3] = z, m4[3][0] = b2[0], m4[3][1] = b2[1], P2[3] = p2(m4[3], x3);
    }
  } while (!S);
  const T = [0, 1, 2, 3], D = y4 ? 0 : 1;
  let R;
  for (let e2 = D; e2 < 4; e2++) for (let t4 = D; t4 < 3; t4++) {
    const e3 = P2[t4], n = P2[t4 + 1];
    C(e3, n) > 0 && (R = T[t4], T[t4] = T[t4 + 1], T[t4 + 1] = R, P2[t4] = n, P2[t4 + 1] = e3);
  }
  let B = D, Q = 0, U = 0;
  for (let e2 = D; e2 < 4; e2++) {
    switch (e2) {
      case 0:
        U = 2 * d3[T[e2]];
        break;
      case 1:
        U = 1.66666666 * d3[T[e2]];
        break;
      case 2:
        U = 1.33333333 * d3[T[e2]];
        break;
      case 3:
        U = d3[T[e2]];
    }
    U > Q && (Q = U, B = T[e2]);
  }
  return m4[B];
}
function u3(t3, e2) {
  let n, i2, r, a3, o = 0;
  for (e2.reset(); e2.nextPath() && e2.nextPoint(); ) for (n = e2.x, i2 = e2.y; e2.nextPoint(); n = r, i2 = a3) {
    if (r = e2.x, a3 = e2.y, i2 > t3[1] == a3 > t3[1]) continue;
    (r - n) * (t3[1] - i2) - (a3 - i2) * (t3[0] - n) > 0 ? o++ : o--;
  }
  return 0 !== o;
}
function f2(t3, e2, n) {
  if (n && u3(t3, e2)) return { coord: t3, distance: 0 };
  let i2 = 1 / 0, r = 0, a3 = 0, s4 = [0, 0], c2 = [0, 0];
  const N2 = [0, 0];
  for (e2.reset(); e2.nextPath() && e2.nextPoint(); ) if (!(e2.pathSize < 2)) for (s4[0] = e2.x, s4[1] = e2.y; e2.nextPoint(); s4 = c2) {
    c2 = [e2.x, e2.y], s(N2, t3, s4, c2);
    const n2 = p2(t3, N2);
    n2 < i2 && (i2 = n2, r = N2[0], a3 = N2[1]);
  }
  return { coord: [r, a3], distance: Math.sqrt(i2) };
}
function h(t3, n, i2, r) {
  const a3 = [n, 0];
  let o = 1 / 0, s4 = 1 / 0, N2 = false, l4 = false;
  const u4 = [[n, r[1] - 1], [n, r[3] + 1]], f3 = [0, 0], h2 = [0, 0], m4 = [0, 0], d3 = [[0, 0], [0, 0]], P2 = i();
  for (t3.reset(); t3.nextPath() && t3.nextPoint(); ) if (!(t3.pathSize < 2)) for (d3[0][0] = t3.x, d3[0][1] = t3.y; t3.nextPoint(); d3[0][0] = d3[1][0], d3[0][1] = d3[1][1]) {
    if (d3[1][0] = t3.x, d3[1][1] = t3.y, null === x2(P2, d3)) continue;
    if (h2[0] = u4[0][0], h2[1] = u4[0][1], m4[0] = u4[1][0], m4[1] = u4[1][1], 0 === M(P2, h2, m4)) continue;
    if (!G(u4[0], u4[1], d3[0], d3[1], f3)) continue;
    const e2 = f3[1];
    o > s4 ? e2 < o && (o = e2, N2 = true) : e2 < s4 && (s4 = e2, l4 = true);
  }
  return N2 && l4 ? a3[1] = (o + s4) / 2 : a3[0] = a3[1] = NaN, a3;
}
function x2(t3, n) {
  if (n.length < 2) return null;
  t3 || (t3 = i());
  const [i2, r] = n[0], [a3, o] = n[1];
  return t3[0] = Math.min(i2, a3), t3[1] = Math.min(r, o), t3[2] = Math.max(i2, a3), t3[3] = Math.max(r, o), t3;
}
var m3 = 1;
var d2 = 4;
var P = 3;
var y3 = 12;
function M(t3, e2, n) {
  let i2 = b(e2, t3), r = b(n, t3);
  const a3 = t3[0], o = t3[1], s4 = t3[2], c2 = t3[3];
  if (i2 & r) return 0;
  if (!(i2 | r)) return 4;
  const N2 = (i2 ? 1 : 0) | (r ? 2 : 0);
  do {
    const N3 = n[0] - e2[0], l4 = n[1] - e2[1];
    if (N3 > l4) i2 & P ? (i2 & m3 ? (e2[1] += l4 * (a3 - e2[0]) / N3, e2[0] = a3) : (e2[1] += l4 * (s4 - e2[0]) / N3, e2[0] = s4), i2 = b(e2, t3)) : r & P ? (r & m3 ? (n[1] += l4 * (a3 - n[0]) / N3, n[0] = a3) : (n[1] += l4 * (s4 - n[0]) / N3, n[0] = s4), r = b(n, t3)) : i2 ? (i2 & d2 ? (e2[0] += N3 * (o - e2[1]) / l4, e2[1] = o) : (e2[0] += N3 * (c2 - e2[1]) / l4, e2[1] = c2), i2 = b(e2, t3)) : (r & d2 ? (n[0] += N3 * (o - n[1]) / l4, n[1] = o) : (n[0] += N3 * (c2 - n[1]) / l4, n[1] = c2), r = b(n, t3));
    else if (i2 & y3 ? (i2 & d2 ? (e2[0] += N3 * (o - e2[1]) / l4, e2[1] = o) : (e2[0] += N3 * (c2 - e2[1]) / l4, e2[1] = c2), i2 = b(e2, t3)) : r & y3 ? (r & d2 ? (n[0] += N3 * (o - n[1]) / l4, n[1] = o) : (n[0] += N3 * (c2 - n[1]) / l4, n[1] = c2), r = b(n, t3)) : i2 ? (i2 & m3 ? (e2[1] += l4 * (a3 - e2[0]) / N3, e2[0] = a3) : (e2[1] += l4 * (s4 - e2[0]) / N3, e2[0] = s4), i2 = b(e2, t3)) : (r & m3 ? (n[1] += l4 * (a3 - n[0]) / N3, n[0] = a3) : (n[1] += l4 * (s4 - n[0]) / N3, n[0] = s4), r = b(n, t3)), i2 & r) return 0;
  } while (i2 | r);
  return N2;
}
function b(t3, e2) {
  return (t3[0] < e2[0] ? 1 : 0) | (t3[0] > e2[2] ? 1 : 0) << 1 | (t3[1] < e2[1] ? 1 : 0) << 2 | (t3[1] > e2[3] ? 1 : 0) << 3;
}
function w(t3, e2, n) {
  return t3 + (e2 - t3) * n;
}
function p2(t3, e2) {
  return (t3[0] - e2[0]) * (t3[0] - e2[0]) + (t3[1] - e2[1]) * (t3[1] - e2[1]);
}
function C(t3, e2) {
  if (t3 < e2) return -1;
  if (t3 > e2) return 1;
  if (t3 === e2) return 0;
  const n = isNaN(t3), i2 = isNaN(e2);
  return n < i2 ? -1 : n > i2 ? 1 : 0;
}

export {
  a2 as a,
  l3 as l
};
//# sourceMappingURL=chunk-U5TTP5E5.js.map
