import {
  m
} from "./chunk-ET5EDAFM.js";
import {
  G,
  H,
  J,
  L,
  W
} from "./chunk-2LC2762W.js";
import {
  p2 as p
} from "./chunk-V2H77UEV.js";
import {
  s as s2
} from "./chunk-GNMPGHLQ.js";
import {
  s2 as s
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/views/support/projectionUtils.js
var a;
var c = null;
async function l(e) {
  c || (c = import("./geometryServiceUtils-NXIZ2EEK.js").then((t) => a = t)), await c, s2(e);
}
async function s3(t, i, c3, p3) {
  if (!t) return null;
  const u2 = t.spatialReference;
  return G() || J(u2, i) ? W(t, i) : a ? a.projectGeometry(t, i, c3, p3) : (await Promise.race([l(p3), L(p3)]), s3(t, i, c3, p3));
}
async function p2(t, e) {
  try {
    return t?.spatialReference ? await H(t, e) : null;
  } catch {
    return null;
  }
}

// node_modules/@arcgis/core/geometry/support/heightModelInfoUtils.js
function a2(n, i, a3) {
  const o2 = c2(n), l3 = i, h2 = r(o2, l3, a3);
  if (o2) {
    const i2 = m.deriveUnitFromSR(o2, n.spatialReference).heightUnit;
    if (!a3 && i2 !== o2.heightUnit) {
      const t = new s("layerview:unmatched-height-unit", `The vertical units of the layer must match the horizontal units (${i2})`, { horizontalUnit: i2 });
      return new s("layerview:unsupported-height-model-info", "The vertical coordinate system of the layer is not supported", { heightModelInfo: o2, error: t });
    }
  }
  if (!s4(n) || 4 === h2) return new s("layerview:unsupported-height-model-info", "The vertical coordinate system of the layer is not supported", { heightModelInfo: o2 });
  switch (h2) {
    case 1: {
      const t = o2?.heightUnit || "unknown", n2 = l3?.heightUnit || "unknown", i2 = new s("layerview:incompatible-height-unit", `The vertical units of the layer (${t}) must match the vertical units of the scene (${n2})`, { layerUnit: t, sceneUnit: n2 });
      return new s("layerview:incompatible-height-model-info", "The vertical coordinate system of the layer is incompatible with the scene", { layerHeightModelInfo: o2, sceneHeightModelInfo: l3, error: i2 });
    }
    case 2: {
      const t = o2?.heightModel || "unknown", n2 = l3?.heightModel || "unknown", i2 = new s("layerview:incompatible-height-model", `The height model of the layer (${t}) must match the height model of the scene (${n2})`, { layerHeightModel: t, sceneHeightModel: n2 });
      return new s("layerview:incompatible-height-model-info", "The vertical coordinate system of the layer is incompatible with the scene", { layerHeightModelInfo: o2, sceneHeightModelInfo: l3, error: i2 });
    }
    case 3: {
      const t = o2?.vertCRS || "unknown", n2 = l3?.vertCRS || "unknown", i2 = new s("layerview:incompatible-vertical-datum", `The vertical datum of the layer (${t}) must match the vertical datum of the scene (${n2})`, { layerDatum: t, sceneDatum: n2 });
      return new s("layerview:incompatible-height-model-info", "The vertical coordinate system of the layer is incompatible with the scene", { layerHeightModelInfo: o2, sceneHeightModelInfo: l3, error: i2 });
    }
  }
  return null;
}
function r(e, t, n) {
  if (!o(e) || !o(t)) return 4;
  if (null == e || null == t) return 0;
  if (!n && e.heightUnit !== t.heightUnit) return 1;
  if (e.heightModel !== t.heightModel) return 2;
  switch (e.heightModel) {
    case "gravity-related-height":
      return 0;
    case "ellipsoidal":
      return e.vertCRS === t.vertCRS ? 0 : 3;
    default:
      return 4;
  }
}
function o(e) {
  return null == e || null != e.heightModel && null != e.heightUnit;
}
function s4(e) {
  return "heightModelInfo" in e && null != e.heightModelInfo || null != e.spatialReference || !u(e);
}
function c2(e) {
  if ("integrated-mesh-3dtiles" === e.type || "gaussian-splat" === e.type) return null;
  const i = e.url ? p(e.url) : void 0, a3 = e.spatialReference?.vcsWkid;
  return !(null == a3 && null != i && "ImageServer" === i.serverType) && l2(e) && e.heightModelInfo ? e.heightModelInfo : u(e) ? m.deriveUnitFromSR(f, e.spatialReference) : null;
}
function l2(e) {
  return "heightModelInfo" in e;
}
function h(e) {
  if ("unknown" === e.type || !("capabilities" in e)) return false;
  switch (e.type) {
    case "catalog":
    case "catalog-footprint":
    case "csv":
    case "feature":
    case "geojson":
    case "subtype-group":
    case "ogc-feature":
    case "oriented-imagery":
    case "wfs":
    case "knowledge-graph-sublayer":
      return true;
    default:
      return false;
  }
}
function u(e) {
  return h(e) ? !!(e.capabilities && e.capabilities.data && e.capabilities.data.supportsZ) : d(e);
}
function g(e) {
  return null != e.layers || d(e) || h(e) || l2(e);
}
function d(e) {
  switch (e.type) {
    case "building-scene":
    case "elevation":
    case "integrated-mesh":
    case "integrated-mesh-3dtiles":
    case "point-cloud":
    case "scene":
    case "voxel":
      return true;
    case "base-dynamic":
    case "base-elevation":
    case "base-tile":
    case "bing-maps":
    case "catalog":
    case "catalog-footprint":
    case "catalog-dynamic-group":
    case "csv":
    case "dimension":
    case "gaussian-splat":
    case "geojson":
    case "feature":
    case "subtype-group":
    case "geo-rss":
    case "graphics":
    case "group":
    case "imagery":
    case "imagery-tile":
    case "kml":
    case "knowledge-graph":
    case "link-chart":
    case "knowledge-graph-sublayer":
    case "line-of-sight":
    case "map-image":
    case "map-notes":
    case "media":
    case "ogc-feature":
    case "open-street-map":
    case "oriented-imagery":
    case "parquet":
    case "route":
    case "stream":
    case "tile":
    case "unknown":
    case "unsupported":
    case "vector-tile":
    case "video":
    case "viewshed":
    case "wcs":
    case "web-tile":
    case "wfs":
    case "wms":
    case "wmts":
    case null:
      return false;
  }
  return false;
}
var f = new m({ heightModel: "gravity-related-height" });

export {
  a2 as a,
  c2 as c,
  g,
  s3 as s,
  p2 as p
};
//# sourceMappingURL=chunk-AUJIAAW5.js.map
