import {
  M
} from "./chunk-7P2ANHQ3.js";
import {
  u
} from "./chunk-XCKT47LJ.js";
import {
  z
} from "./chunk-H74Q4SYB.js";
import {
  n
} from "./chunk-234CIOHE.js";
import {
  G,
  R,
  Y,
  _,
  tt
} from "./chunk-V2H77UEV.js";
import {
  s as s2
} from "./chunk-WRA2WBYC.js";
import {
  o
} from "./chunk-XWE6BM2U.js";
import {
  a as a3
} from "./chunk-XXLHAM2M.js";
import {
  b,
  m as m2
} from "./chunk-5EI5H4QX.js";
import {
  a2,
  m
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  a,
  i3 as i,
  l,
  s2 as s
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/portal/PortalItemResource.js
var c = class extends b {
  constructor(t) {
    super(t), this.portalItem = null;
  }
  normalizeCtorArgs(t) {
    return t?.portalItem && t.path ? { ...t, path: n2(t.path, t.portalItem) } : t;
  }
  set path(t) {
    null != t && Y(t) ? i.getLogger(this).error("portalitemresource:invalid-path", "A portal item resource path must be relative") : this._set("path", t);
  }
  _castPath(t) {
    return n2(t, this.portalItem);
  }
  get url() {
    return this.portalItem && this.path ? `${this.portalItem.itemUrl}/resources/${this.path}` : null;
  }
  get cdnUrl() {
    return this.portalItem && this.path ? `${this.portalItem.itemCdnUrl}/resources/${this.path}` : null;
  }
  get itemRelativeUrl() {
    return this.portalItem && this.path ? `./resources/${this.path}` : null;
  }
  fetch(t = "json", r) {
    const o2 = this.cdnUrl;
    if (null == o2) throw new s("portal-item-resource:fetch", "Portal item resource does not refer to a valid item or path");
    return this.portalItem.portal.request(o2, { responseType: t, query: { token: this.portalItem.apiKey, _ts: r?.cacheBust ? Date.now() : null }, signal: r?.signal });
  }
  async update(t, r) {
    const { addOrUpdateResources: e } = await import("./resourceUtils-E5UBQNCG.js");
    return await e(this.portalItem, [{ resource: this, content: t, compress: r?.compress, access: r?.access }], "update", r), this;
  }
  hasPath() {
    return null != this.path;
  }
};
function n2(t, r) {
  return null == t ? t : (t = t.replace(/^\/+/, ""), null != r && Y(t) && (t = G(t, r.itemUrl)), t?.replace(/^\/+/, "").replace(/^(\.\/)?resources\//, ""));
}
__decorate([m2()], c.prototype, "portalItem", void 0), __decorate([m2({ type: String, value: null })], c.prototype, "path", null), __decorate([s2("path")], c.prototype, "_castPath", null), __decorate([m2({ type: String, readOnly: true })], c.prototype, "url", null), __decorate([m2({ type: String, readOnly: true })], c.prototype, "cdnUrl", null), __decorate([m2({ type: String, readOnly: true })], c.prototype, "itemRelativeUrl", null), c = __decorate([a2("esri.portal.PortalItemResource")], c);

// node_modules/@arcgis/core/portal/PortalRating.js
var s3 = class extends b {
  constructor(r) {
    super(r), this.created = null, this.rating = null;
  }
};
__decorate([m2({ type: Date })], s3.prototype, "created", void 0), __decorate([m2()], s3.prototype, "rating", void 0), s3 = __decorate([a2("esri.portal.PortalRating")], s3);

// node_modules/@arcgis/core/portal/PortalItem.js
var v;
var f = /* @__PURE__ */ new Set(["3DTiles Service", "CSV", "Feature Collection", "Feature Service", "Feed", "GeoJson", "Group Layer", "Image Service", "KML", "Knowledge Graph Layer", "Map Service", "Media Layer", "Scene Service", "Stream Service", "Video Service", "Vector Tile Service", "WCS", "WFS", "WMS", "WMTS"]);
var b2 = /* @__PURE__ */ new Set(["KML", "GeoJson", "CSV"]);
var k = v = class extends a3(u) {
  static from(e) {
    return m(v, e);
  }
  constructor(e) {
    super(e), this.access = null, this.accessInformation = null, this.apiKey = null, this.applicationProxies = null, this.avgRating = null, this.categories = null, this.classification = null, this.created = null, this.culture = null, this.description = null, this.extent = null, this.groupCategories = null, this.id = null, this.isOrgItem = false, this.itemControl = null, this.licenseInfo = null, this.modified = null, this.name = null, this.numComments = null, this.numRatings = null, this.numViews = null, this.owner = null, this.ownerFolder = null, this.portal = null, this.screenshots = null, this.size = null, this.snippet = null, this.sourceJSON = null, this.sourceUrl = null, this.spatialReference = null, this.tags = null, this.title = null, this.type = null, this.typeKeywords = null, this.url = null;
  }
  destroy() {
    this.portal = null;
  }
  get displayName() {
    const e = this.type, t = this.typeKeywords || [];
    let i2 = e;
    return "Feature Service" === e || "Feature Collection" === e ? i2 = t.includes("Table") ? "Table" : t.includes("Route Layer") ? "Route Layer" : t.includes("Markup") ? "Markup" : "Feature Layer" : "Image Service" === e ? i2 = t.includes("Elevation 3D Layer") ? "Elevation Layer" : t.includes("Tiled Imagery") ? "Tiled Imagery Layer" : "Imagery Layer" : "Scene Service" === e ? i2 = "Scene Layer" : "Video Service" === e ? i2 = "Video Layer" : "Scene Package" === e ? i2 = "Scene Layer Package" : "Stream Service" === e ? i2 = "Feature Layer" : "Geoprocessing Service" === e ? i2 = t.includes("Web Tool") ? "Tool" : "Geoprocessing Service" : "Geoenrichment Service" === e ? i2 = "GeoEnrichment Service" : "Geocoding Service" === e ? i2 = "Locator" : "Microsoft Powerpoint" === e ? i2 = "Microsoft PowerPoint" : "GeoJson" === e ? i2 = "GeoJSON" : "Globe Service" === e ? i2 = "Globe Layer" : "Vector Tile Service" === e ? i2 = "Tile Layer" : "netCDF" === e ? i2 = "NetCDF" : "Map Service" === e ? i2 = t.includes("Spatiotemporal") || !t.includes("Hosted Service") && !t.includes("Tiled") || t.includes("Relational") ? "Map Image Layer" : "Tile Layer" : e?.toLowerCase().includes("add in") ? i2 = e.replaceAll(/(add in)/gi, "Add-In") : "datastore catalog service" === e ? i2 = "Big Data File Share" : "Compact Tile Package" === e ? i2 = "Tile Package (tpkx)" : "Raster function template" === e ? i2 = "Raster Function Template" : "OGCFeatureServer" === e ? i2 = "OGC Feature Layer" : "web mapping application" === e && t.includes("configurableApp") ? i2 = "Instant App" : "Insights Page" === e ? i2 = "Insights Report" : "Excalibur Imagery Project" === e ? i2 = "Excalibur Project" : "3DTiles Service" === e ? i2 = "3D tiles layer" : "3DTiles Package" === e && (i2 = "3D tiles package"), i2;
  }
  readExtent(e) {
    return e && e.length ? new z(e[0][0], e[0][1], e[1][0], e[1][1]) : null;
  }
  get iconUrl() {
    const e = this.type?.toLowerCase() || "", i2 = this.typeKeywords || [], r = "esri/images/portal/", o2 = "16";
    let s4, a4 = false, n3 = false, l2 = false, p = false, c2 = false, d = false, u2 = false, m3 = false;
    return e.indexOf("service") > 0 || "feature collection" === e || "kml" === e || "wms" === e || "wmts" === e || "wfs" === e ? (a4 = i2.includes("Hosted Service"), "feature service" === e || "feature collection" === e || "kml" === e || "wfs" === e ? (n3 = i2.includes("Table"), l2 = i2.includes("Route Layer"), p = i2.includes("Markup"), c2 = i2.includes("Spatiotemporal"), d = i2.includes("UtilityNetwork"), s4 = c2 && n3 ? "spatiotemporaltable" : n3 ? "table" : l2 ? "routelayer" : p ? "markup" : c2 ? "spatiotemporal" : d ? "utilitynetwork" : a4 ? "featureshosted" : "features") : "map service" === e || "wms" === e || "wmts" === e ? (c2 = i2.includes("Spatiotemporal"), u2 = i2.includes("Relational"), s4 = c2 || u2 ? "mapimages" : a4 || i2.includes("Tiled") || "wmts" === e ? "maptiles" : "mapimages") : s4 = "scene service" === e ? i2.includes("Line") ? "sceneweblayerline" : i2.includes("3DObject") ? "sceneweblayermultipatch" : i2.includes("Point") ? "sceneweblayerpoint" : i2.includes("IntegratedMesh") ? "sceneweblayermesh" : i2.includes("PointCloud") ? "sceneweblayerpointcloud" : i2.includes("Polygon") ? "sceneweblayerpolygon" : i2.includes("Building") ? "sceneweblayerbuilding" : i2.includes("Voxel") ? "sceneweblayervoxel" : "sceneweblayer" : "image service" === e ? i2.includes("Elevation 3D Layer") ? "elevationlayer" : i2.includes("Tiled Imagery") ? "tiledimagerylayer" : "imagery" : "stream service" === e ? "streamlayer" : "vector tile service" === e ? "vectortile" : "datastore catalog service" === e ? "datastorecollection" : "geocoding service" === e ? "geocodeservice" : "video service" === e ? i2.includes("Live Stream") ? "livestreamvideolayer" : "videolayer" : "geoprocessing service" === e ? i2.includes("Web Tool") ? "tool" : "layers" : "geodata service" === e ? "geodataservice" : "3dtiles service" === e ? i2.includes("3DObject") ? "3dobjecttileslayer" : i2.includes("IntegratedMesh") ? "integratedmeshtileslayer" : i2.includes("GaussianSplat") ? "gaussiansplatlayer" : "3dtileslayer" : "layers") : "web map" === e || "cityengine web scene" === e ? s4 = "maps" : "web scene" === e ? s4 = i2.includes("ViewingMode-Local") ? "webscenelocal" : "websceneglobal" : "web mapping application" === e && i2.includes("configurableApp") ? s4 = "instantapps" : "web mapping application" === e || "mobile application" === e || "application" === e || "operation view" === e || "desktop application" === e ? s4 = "apps" : "map document" === e || "map package" === e || "published map" === e || "scene document" === e || "globe document" === e || "basemap package" === e || "mobile basemap package" === e || "mobile map package" === e || "project package" === e || "project template" === e || "pro map" === e || "layout" === e || "layer" === e && i2.includes("ArcGIS Pro") || "explorer map" === e && i2.indexOf("Explorer Document") ? s4 = "mapsgray" : "service definition" === e || "shapefile" === e || "cad drawing" === e || "geojson" === e || "netcdf" === e || "administrative report" === e ? s4 = "datafiles" : "360 vr experience" === e ? s4 = "360vr" : "explorer add in" === e || "desktop add in" === e || "windows viewer add in" === e || "windows viewer configuration" === e ? s4 = "appsgray" : "arcgis pro add in" === e || "arcgis pro configuration" === e ? s4 = "addindesktop" : "pdf" === e ? s4 = "pdf" : "microsoft word" === e ? s4 = "word" : "microsoft excel" === e ? s4 = "excel" : "microsoft powerpoint" === e ? s4 = "ppt" : "rule package" === e || "file geodatabase" === e || "sqlite geodatabase" === e || "csv collection" === e || "kml collection" === e || "windows mobile package" === e || "map template" === e || "desktop application template" === e || "gml" === e || "arcpad package" === e || "code sample" === e || "document link" === e || "earth configuration" === e || "operations dashboard add in" === e || "rules package" === e || "workflow manager package" === e || "explorer map" === e && i2.includes("Explorer Mapping Application") || i2.includes("Document") ? s4 = "datafilesgray" : "network analysis service" === e || "geoprocessing service" === e || "geodata service" === e || "geometry service" === e || "geoprocessing package" === e || "locator package" === e || "geoprocessing sample" === e || "workflow manager service" === e ? s4 = "toolsgray" : "layer" === e || "layer package" === e || "explorer layer" === e ? s4 = "layersgray" : "analysis model" === e ? s4 = "analysismodel" : "scene package" === e ? s4 = "scenepackage" : "3dtiles package" === e ? s4 = "3dtileslayerpackage" : "3dtiles service" === e ? s4 = "3dtileslayer" : "mobile scene package" === e ? s4 = "mobilescenepackage" : "tile package" === e || "compact tile package" === e ? s4 = "tilepackage" : "task file" === e ? s4 = "taskfile" : "report template" === e ? s4 = "report-template" : "statistical data collection" === e ? s4 = "statisticaldatacollection" : "insights workbook" === e ? s4 = "workbook" : "insights model" === e ? s4 = "insightsmodel" : "insights page" === e ? s4 = "insightspage" : "insights theme" === e ? s4 = "insightstheme" : "hub initiative" === e ? s4 = "hubinitiative" : "hub page" === e ? s4 = "hubpage" : "hub site application" === e ? s4 = "hubsite" : "hub event" === e ? s4 = "hubevent" : "hub project" === e ? s4 = "hubproject" : "relational database connection" === e ? s4 = "relationaldatabaseconnection" : "big data file share" === e ? s4 = "datastorecollection" : "image collection" === e ? s4 = "imagecollection" : "desktop style" === e ? s4 = "desktopstyle" : "style" === e ? s4 = i2.includes("Dictionary") ? "dictionarystyle" : "style" : "dashboard" === e ? s4 = "dashboard" : "raster function template" === e ? s4 = "rasterprocessingtemplate" : "vector tile package" === e ? s4 = "vectortilepackage" : "ortho mapping project" === e ? s4 = "orthomappingproject" : "ortho mapping template" === e ? s4 = "orthomappingtemplate" : "solution" === e ? s4 = "solutions" : "geopackage" === e ? s4 = "geopackage" : "deep learning package" === e ? s4 = "deeplearningpackage" : "real time analytic" === e ? s4 = "realtimeanalytics" : "reality mapping project" === e ? s4 = "realitymappingproject" : "big data analytic" === e ? s4 = "bigdataanalytics" : "feed" === e ? s4 = "feed" : "excalibur imagery project" === e ? s4 = "excaliburimageryproject" : "notebook" === e ? s4 = "notebook" : "storymap" === e ? s4 = "storymap" : "survey123 add in" === e ? s4 = "survey123addin" : "mission" === e ? s4 = "mission" : "mission report" === e ? s4 = "missionreport" : "mission template" === e ? s4 = "missiontemplate" : "quickcapture project" === e ? s4 = "quickcaptureproject" : "pro report" === e ? s4 = "proreport" : "pro report template" === e ? s4 = "proreporttemplate" : "urban model" === e ? s4 = "urbanmodel" : "urban project" === e ? s4 = "urbanproject" : "web experience" === e ? s4 = "experiencebuilder" : "web experience template" === e ? s4 = "webexperiencetemplate" : "experience builder widget" === e ? s4 = "experiencebuilderwidget" : "experience builder widget package" === e ? s4 = "experiencebuilderwidgetpackage" : "workflow" === e ? s4 = "workflow" : "kernel gateway connection" === e ? s4 = "kernelgatewayconnection" : "insights script" === e ? s4 = "insightsscript" : "hub initiative template" === e ? s4 = "hubinitiativetemplate" : "storymap theme" === e ? s4 = "storymaptheme" : "knowledge graph" === e ? s4 = "knowledgegraph" : "knowledge graph layer" === e ? s4 = "knowledgegraphlayer" : "knowledge studio project" === e ? s4 = "knowledgestudio" : "native application" === e ? s4 = "nativeapp" : "native application installer" === e ? s4 = "nativeappinstaller" : "web link chart" === e ? s4 = "linkchart" : "knowledge graph web investigation" === e ? s4 = "investigation" : "ogcfeatureserver" === e ? s4 = "features" : "pro presentation" === e ? s4 = "propresentation" : "pro project" === e ? s4 = "proproject" : "insights workbook package" === e ? s4 = "insightsworkbookpackage" : "apache parquet" === e ? s4 = "apacheparquet" : "notebook code snippet library" === e ? s4 = "notebookcodesnippets" : "suitability model" === e ? s4 = "suitabilitymodel" : "esri classifier definition" === e ? s4 = "classifierdefinition" : "esri classification schema" === e ? s4 = "classificationschema" : "insights data engineering workbook" === e ? s4 = "dataengineeringworkbook" : "insights data engineering model" === e ? s4 = "dataengineeringmodel" : "deep learning studio project" === e ? s4 = "deeplearningproject" : "discussion" === e ? s4 = "discussion" : "allsource project" === e ? s4 = "allsourceproject" : "api key" === e ? s4 = "apikey" : "data pipeline" === e ? s4 = "datapipelines" : "group layer" === e ? (m3 = i2.includes("Map"), s4 = m3 ? "layergroup2d" : "layergroup") : s4 = "media layer" === e ? "onlinemedialayer" : "form" === e ? i2.includes("Survey123") ? "survey" : "datafilesgray" : "csv" === e ? "csv" : "image" === e ? "image" : "xr experience" === e ? "xrexperience" : "maps", s4 ? n(r + s4 + o2 + ".png") : null;
  }
  get isLayer() {
    return null != this.type && f.has(this.type);
  }
  get itemCdnUrl() {
    return R(this.itemUrl);
  }
  get itemPageUrl() {
    const e = this.portal?.itemPageUrl;
    return e && this.id ? `${e}?id=${this.id}` : null;
  }
  get itemUrl() {
    const e = this.portal?.restUrl;
    return e && this.id ? `${e}/content/items/${this.id}` : null;
  }
  get loaded() {
    return super.loaded;
  }
  get thumbnailUrl() {
    const e = this.itemUrl, t = this.thumbnail;
    return e && t ? this.portal?.normalizeUrl(`${e}/info/${t}?f=json`) ?? null : null;
  }
  get userItemUrl() {
    const e = this.portal?.restUrl;
    if (!e) return null;
    const t = this.owner || this.portal?.user?.id;
    if (!t) return null;
    return `${e}/content/users/${this.ownerFolder ? `${t}/${this.ownerFolder}` : t}/items/${this.id}`;
  }
  load(e) {
    const t = this.portal ?? (this.portal = M.getDefault()), i2 = t.load(e).then(() => this.sourceJSON ? this.sourceJSON : this.id && this.itemUrl ? t.request(this.itemUrl, { signal: null != e ? e.signal : null, query: { token: this.apiKey } }) : {}).then((e2) => {
      this.sourceJSON = e2, this.read(e2);
    });
    return this.addResolvingPromise(i2), Promise.resolve(this);
  }
  async addRating(e) {
    const t = { method: "post", query: {} }, i2 = e instanceof s3 ? e.rating : e;
    return null == i2 || isNaN(i2) || "number" != typeof e || (t.query.rating = i2), this.portal ? (await this.portal.request(this.itemUrl + "/addRating", t), new s3({ rating: i2, created: /* @__PURE__ */ new Date() })) : null;
  }
  clone() {
    const e = { access: this.access, accessInformation: this.accessInformation, applicationProxies: a(this.applicationProxies), avgRating: this.avgRating, categories: a(this.categories), classification: a(this.classification), created: a(this.created), culture: this.culture, description: this.description, extent: a(this.extent), groupCategories: a(this.groupCategories), id: this.id, itemControl: this.itemControl, licenseInfo: this.licenseInfo, modified: a(this.modified), name: this.name, numComments: this.numComments, numRatings: this.numRatings, numViews: this.numViews, owner: this.owner, ownerFolder: this.ownerFolder, portal: this.portal, screenshots: a(this.screenshots), size: this.size, snippet: this.snippet, sourceUrl: this.sourceUrl, spatialReference: this.spatialReference, tags: a(this.tags), thumbnail: this.thumbnail, title: this.title, type: this.type, typeKeywords: a(this.typeKeywords), url: this.url };
    this.loaded && (e.loadStatus = "loaded");
    const t = new v({ sourceJSON: this.sourceJSON }).set(e);
    return t._set("isOrgItem", this.isOrgItem), t;
  }
  createPostQuery() {
    const e = this.toJSON();
    for (const t of ["tags", "typeKeywords", "categories"]) e[t] = e[t]?.join(", ");
    for (const t of ["extent", "classification"]) {
      const i2 = e[t];
      i2 && (e[t] = JSON.stringify(i2));
    }
    return e;
  }
  async deleteRating() {
    await this.portal.request(this.itemUrl + "/deleteRating", { method: "post" });
  }
  fetchData(e = "json", t) {
    return this.portal.request(this.itemUrl + "/data", { responseType: e, ...t, query: { token: this.apiKey } });
  }
  async fetchRating(e) {
    const t = await this.portal.request(this.itemUrl + "/rating", { query: { token: this.apiKey }, ...e });
    return null != t.rating ? (t.created = new Date(t.created), new s3(t)) : null;
  }
  fetchRelatedItems(e, t) {
    return this.portal.requestToTypedArray(this.itemUrl + "/relatedItems", { query: { ...e, token: this.apiKey }, ...t }, v);
  }
  getThumbnailUrl(e) {
    let t = this.thumbnailUrl;
    return t && e && (t += `&w=${e}`), t;
  }
  reload() {
    return this.portal.request(this.itemUrl ?? "", { cacheBust: true, query: { token: this.apiKey } }).then((e) => (this.applicationProxies && !Object.hasOwn(e, "appProxies") && (this.applicationProxies = null), this.sourceJSON = e, this.read(e), this));
  }
  update(e) {
    return this.id ? this.load().then(() => this.portal.signIn()).then(() => {
      const t = e?.data, i2 = { method: "post" };
      i2.query = this.createPostQuery();
      for (const e2 in i2.query) null === i2.query[e2] && (i2.query[e2] = "");
      return i2.query.clearEmptyFields = true, null != t && ("string" == typeof t ? i2.query.text = t : "object" == typeof t && (i2.query.text = JSON.stringify(t))), this.portal.request(`${this.userItemUrl}/update`, i2).then(() => this.reload());
    }) : Promise.reject(new s("portal:item-does-not-exist", "The item does not exist yet and cannot be updated"));
  }
  async copy(e) {
    if (!this.id) throw new s("portal:item-does-not-exist", "The item does not exist yet");
    await this.load();
    const { portal: t, itemUrl: r } = this;
    await t.signIn();
    const { copyResources: o2, folder: s4, tags: a4, title: n3 } = e || {}, l2 = { method: "post", query: { copyPrivateResources: "all" === o2, folder: "string" == typeof s4 ? s4 : s4?.id, includeResources: !!o2, tags: a4?.join(","), title: n3 } }, { itemId: p } = await t.request(`${r}/copy`, l2);
    return new v({ id: p, portal: t });
  }
  updateThumbnail(e) {
    return this.id ? this.load().then(() => this.portal.signIn()).then(() => {
      const t = e.thumbnail, i2 = e.filename, r = { method: "post" };
      if ("string" == typeof t) tt(t) ? r.query = { data: t } : r.query = { url: _(t) }, null != i2 && (r.query.filename = i2);
      else {
        const e2 = new FormData();
        null != i2 ? e2.append("file", t, i2) : e2.append("file", t), r.body = e2;
      }
      return this.portal.request(`${this.userItemUrl}/updateThumbnail`, r).then(() => this.reload());
    }) : Promise.reject(new s("portal:item-does-not-exist", "The item does not exist yet and cannot be updated"));
  }
  async fetchResources(e = {}, t) {
    const { fetchResources: i2 } = await import("./resourceUtils-E5UBQNCG.js");
    return i2(this, e, t);
  }
  async addResource(e, t, i2) {
    const { addOrUpdateResources: r } = await import("./resourceUtils-E5UBQNCG.js");
    return e.portalItem = this, await r(this, [{ resource: e, content: t, compress: i2?.compress, access: i2?.access }], "add", i2), e;
  }
  async removeResource(e, t) {
    const { removeResource: r } = await import("./resourceUtils-E5UBQNCG.js");
    if (e.portalItem && e.portalItem.itemUrl !== this.itemUrl) throw new s("removeresource:portal-item-mismatch", "The portal item associated with the provided resource does not match the item");
    return r(this, e, t);
  }
  async removeAllResources(e) {
    const { removeAllResources: t } = await import("./resourceUtils-E5UBQNCG.js");
    return t(this, e);
  }
  resourceFromPath(e) {
    return new c({ portalItem: this, path: e });
  }
  toJSON() {
    const e = this.extent, t = { accessInformation: this.accessInformation, categories: a(this.categories), classification: a(this.classification), created: this.created?.getTime(), description: this.description, extent: e && [[e.xmin, e.ymin], [e.xmax, e.ymax]], id: this.id, isOrgItem: this.isOrgItem, licenseInfo: this.licenseInfo, modified: this.modified?.getTime(), name: this.name, owner: this.owner, ownerFolder: this.ownerFolder, snippet: this.snippet, sourceUrl: this.sourceUrl, spatialReference: this.spatialReference, tags: a(this.tags), thumbnail: this.thumbnail, title: this.title, type: this.type, typeKeywords: a(this.typeKeywords), url: this.url };
    return l(t);
  }
  static fromJSON(e) {
    if (!e) return null;
    if (e.declaredClass) throw new Error("JSON object is already hydrated");
    return new v({ sourceJSON: e });
  }
  _getPostQuery() {
    const e = this.toJSON();
    for (const t in e) "tags" === t && null !== e[t] && (e[t] = e[t].join(", ")), "typeKeywords" === t && null !== e[t] && (e[t] = e[t].join(", ")), "extent" === t && e[t] && (e[t] = JSON.stringify(e[t]));
    return e;
  }
};
__decorate([m2({ type: ["private", "shared", "org", "public"] })], k.prototype, "access", void 0), __decorate([m2()], k.prototype, "accessInformation", void 0), __decorate([m2({ type: String })], k.prototype, "apiKey", void 0), __decorate([m2({ json: { read: { source: "appProxies" } } })], k.prototype, "applicationProxies", void 0), __decorate([m2()], k.prototype, "avgRating", void 0), __decorate([m2()], k.prototype, "categories", void 0), __decorate([m2()], k.prototype, "classification", void 0), __decorate([m2({ type: Date })], k.prototype, "created", void 0), __decorate([m2()], k.prototype, "culture", void 0), __decorate([m2()], k.prototype, "description", void 0), __decorate([m2({ readOnly: true })], k.prototype, "displayName", null), __decorate([m2({ type: z })], k.prototype, "extent", void 0), __decorate([o("extent")], k.prototype, "readExtent", null), __decorate([m2()], k.prototype, "groupCategories", void 0), __decorate([m2({ readOnly: true })], k.prototype, "iconUrl", null), __decorate([m2()], k.prototype, "id", void 0), __decorate([m2({ readOnly: true })], k.prototype, "isLayer", null), __decorate([m2({ type: Boolean, readOnly: true })], k.prototype, "isOrgItem", void 0), __decorate([m2()], k.prototype, "itemControl", void 0), __decorate([m2({ readOnly: true })], k.prototype, "itemPageUrl", null), __decorate([m2({ readOnly: true })], k.prototype, "itemUrl", null), __decorate([m2()], k.prototype, "licenseInfo", void 0), __decorate([m2({ type: Date })], k.prototype, "modified", void 0), __decorate([m2()], k.prototype, "name", void 0), __decorate([m2()], k.prototype, "numComments", void 0), __decorate([m2()], k.prototype, "numRatings", void 0), __decorate([m2()], k.prototype, "numViews", void 0), __decorate([m2()], k.prototype, "owner", void 0), __decorate([m2()], k.prototype, "ownerFolder", void 0), __decorate([m2({ type: M })], k.prototype, "portal", void 0), __decorate([m2()], k.prototype, "screenshots", void 0), __decorate([m2()], k.prototype, "size", void 0), __decorate([m2()], k.prototype, "snippet", void 0), __decorate([m2()], k.prototype, "sourceJSON", void 0), __decorate([m2({ type: String })], k.prototype, "sourceUrl", void 0), __decorate([m2({ type: String })], k.prototype, "spatialReference", void 0), __decorate([m2()], k.prototype, "tags", void 0), __decorate([m2()], k.prototype, "thumbnail", void 0), __decorate([m2({ readOnly: true })], k.prototype, "thumbnailUrl", null), __decorate([m2()], k.prototype, "title", void 0), __decorate([m2()], k.prototype, "type", void 0), __decorate([m2()], k.prototype, "typeKeywords", void 0), __decorate([m2({ type: String, json: { read(e, t) {
  if (b2.has(t.type)) {
    const t2 = this.portal?.restUrl;
    e ||= t2 && this.id ? `${t2}/content/items/${this.id}/data` : null;
  }
  return e;
} } })], k.prototype, "url", void 0), __decorate([m2({ readOnly: true })], k.prototype, "userItemUrl", null), k = v = __decorate([a2("esri.portal.PortalItem")], k);

export {
  k
};
//# sourceMappingURL=chunk-W75DBJD7.js.map
