import {
  Ue,
  Ve
} from "./chunk-5IXGYDQ3.js";
import {
  Ou,
  Yu,
  cs,
  ee,
  re
} from "./chunk-RKVVFTIZ.js";
import {
  a,
  mi
} from "./chunk-ZNI54T6D.js";
import {
  m
} from "./chunk-3FUHCAX3.js";
import {
  P,
  y3 as y
} from "./chunk-PZ5RULLK.js";
import {
  z
} from "./chunk-H74Q4SYB.js";
import {
  _
} from "./chunk-AXZMNHTN.js";

// node_modules/@arcgis/core/geometry/operators/support/apiConverter.js
var p = "_gxVersion";
var g = 2;
var y2 = 1;
function C(e) {
  return Array.isArray(e) ? e[0].spatialReference : e.spatialReference;
}
function x(e) {
  switch (e.type) {
    case "point":
      return w(e);
    case "multipoint":
      return V(e);
    case "polyline":
      return P2(e);
    case "polygon":
      return v(e);
    case "extent":
      return M(e);
    default:
      throw new Error(`Unsupported geometry type: ${e.type}`);
  }
}
function M(e) {
  if (!e.getCacheValue(p)) {
    const t = new re();
    t.setCoords(e.xmin, e.ymin, e.xmax, e.ymax), e.hasM && t.setInterval(g, 0, e.mmin, e.mmax), e.hasZ && t.setInterval(y2, 0, e.zmin, e.zmax), e.setCacheValue(p, t);
  }
  return e.getCacheValue(p);
}
function V(e) {
  if (!e.getCacheValue(p)) {
    const t = new cs(), n = new ee(), a2 = e.points, o = e.hasM, i = e.hasZ, u = i ? 3 : 2;
    for (let e2 = 0, s = a2.length; e2 < s; e2++) {
      const s2 = a2[e2];
      n.setXYCoords(s2[0], s2[1]), i && n.setZ(s2[2] ?? 0), o && n.setM(s2[u] ?? NaN), t.add(n);
    }
    e.setCacheValue(p, t);
  }
  return e.getCacheValue(p);
}
function w(e) {
  if (!e.getCacheValue(p)) {
    const t = new ee();
    t.setXYCoords(e.x, e.y), e.hasM && t.setM(e.m), e.hasZ && t.setZ(e.z), e.setCacheValue(p, t);
  }
  return e.getCacheValue(p);
}
function v(e) {
  if (!e.getCacheValue(p)) {
    const { curveRings: t, hasM: n, hasZ: s, rings: r } = e, a2 = Ve({ curveRings: t, hasM: n, hasZ: s, rings: r });
    e.setCacheValue(p, a2);
  }
  return e.getCacheValue(p);
}
function P2(e) {
  if (!e.getCacheValue(p)) {
    const { curvePaths: t, hasM: n, hasZ: s, paths: r } = e, a2 = Ve({ curvePaths: t, hasM: n, hasZ: s, paths: r });
    e.setCacheValue(p, a2);
  }
  return e.getCacheValue(p);
}
function Z(e) {
  if (e.wkid) return Ou(e.wkid);
  const t = e.wkt2 || e.wkt;
  return t ? Yu(t) : null;
}
function j(e, n) {
  if (e) switch (e.getGeometryType()) {
    case a.enumPoint:
      return R(e, n);
    case a.enumEnvelope:
      return E(e, n);
    case a.enumMultiPoint:
      return k(e, n);
    case a.enumPolyline:
      return z2(e, n);
    case a.enumPolygon:
      return d(e, n);
  }
  return null;
}
function E(e, t) {
  if (e.isEmpty()) return null;
  const n = new z({ xmin: e.getXMin(), ymin: e.getYMin(), xmax: e.getXMax(), ymax: e.getYMax(), spatialReference: t }), s = e.getDescription();
  if (s.hasM()) {
    const t2 = e.queryInterval(g, 0);
    n.mmin = t2.vmin, n.mmax = t2.vmax;
  }
  if (s.hasZ()) {
    const t2 = e.queryInterval(y2, 0);
    n.zmin = t2.vmin, n.zmax = t2.vmax;
  }
  return n.setCacheValue(p, e), n;
}
function k(e, t) {
  if (e.isEmpty()) return null;
  const n = e.getDescription(), r = n.hasM(), a2 = n.hasZ(), o = [], i = new ee();
  for (let s = 0, u = e.getPointCount(); s < u; s++) {
    e.getPointByVal(s, i);
    const t2 = [i.getX(), i.getY()];
    a2 && t2.push(i.getZ()), r && t2.push(i.getM()), o.push(t2);
  }
  const c = new m({ hasM: r, hasZ: a2, points: o, spatialReference: t });
  return c.setCacheValue(p, e), c;
}
function R(t, n) {
  if (t instanceof mi) return new _({ x: t.x, y: t.y, spatialReference: n });
  if (t.isEmpty()) return null;
  const s = new _({ x: t.getX(), y: t.getY(), spatialReference: n }), r = t.getDescription();
  return r.hasM() && (s.m = t.getM()), r.hasZ() && (s.z = t.getZ()), s.setCacheValue(p, t), s;
}
function d(e, t) {
  if (e.isEmpty()) return null;
  const n = P.fromJSON({ spatialReference: t, ...Ue(e, null) });
  return n.setCacheValue(p, e), n;
}
function z2(e, t) {
  if (e.isEmpty()) return null;
  const n = y.fromJSON({ spatialReference: t, ...Ue(e, null) });
  return n.setCacheValue(p, e), n;
}

export {
  C,
  x,
  M,
  V,
  w,
  v,
  P2 as P,
  Z,
  j,
  E,
  k,
  R,
  d,
  z2 as z
};
//# sourceMappingURL=chunk-TCIOA3WX.js.map
