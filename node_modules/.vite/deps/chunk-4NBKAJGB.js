import {
  a
} from "./chunk-QVM6IWUX.js";
import {
  c,
  e,
  i,
  l as l2,
  n,
  s as s3,
  y
} from "./chunk-ZMVRYYR6.js";
import {
  s as s4
} from "./chunk-63RKYW5K.js";
import {
  l
} from "./chunk-65WW7L4T.js";
import {
  s as s2
} from "./chunk-H34D76ZQ.js";
import {
  Q,
  W,
  w
} from "./chunk-CNYNCKEV.js";
import {
  k
} from "./chunk-W75DBJD7.js";
import {
  s2 as s
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/portal/support/portalLayers.js
async function L(e2) {
  let { portalItem: a2 } = e2;
  !a2 || a2 instanceof k || (a2 = new k(a2));
  const r = await w2(a2);
  return new (0, r.constructor)({ portalItem: a2, ...r.properties });
}
async function w2(e2) {
  await e2.load();
  const a2 = new e();
  return N(await S(e2, a2));
}
async function S(a2, r) {
  switch (a2.type) {
    case "3DTiles Service":
      return a2.typeKeywords.includes("3DObject") ? F() : a2.typeKeywords.includes("GaussianSplat") ? b() : P();
    case "CSV":
      return K();
    case "Feature Collection":
      return M(a2);
    case "Feature Service":
      return h(a2, r);
    case "Feed":
      return J();
    case "GeoJson":
      return G();
    case "Group Layer":
      return k2();
    case "Image Service":
      return g(a2, r);
    case "KML":
      return V();
    case "Knowledge Graph Layer":
      return W2();
    case "Map Service":
      return v(a2, r);
    case "Media Layer":
      return $();
    case "Scene Service":
      return I(a2, r);
    case "Stream Service":
      return j();
    case "Video Service":
      return T(a2, r);
    case "Vector Tile Service":
      return C();
    case "WCS":
      return U();
    case "WFS":
      return D();
    case "WMS":
      return O();
    case "WMTS":
      return x();
    default:
      throw new s("portal:unknown-item-type", "Unknown item type '${type}'", { type: a2.type });
  }
}
async function N(e2) {
  const a2 = e2.className, r = a[a2];
  return { constructor: await r(), properties: e2.properties };
}
async function v(e2, a2) {
  return await A(e2, a2) ? { className: "TileLayer" } : { className: "MapImageLayer" };
}
async function h(e2, a2) {
  const r = await E(e2, a2);
  if ("object" == typeof r) {
    const { sourceJSON: e3, className: a3 } = r, t = { sourceJSON: e3 };
    return null != r.id && (t.layerId = r.id), { className: a3 || "FeatureLayer", properties: t };
  }
  return { className: "GroupLayer" };
}
async function I(e2, r) {
  const t = await E(e2, r, async () => {
    try {
      if (!e2.url) return [];
      const { serverUrl: t2 } = await s4(e2.url, { sceneLayerItem: e2 }), s5 = await r.fetchServiceMetadata(t2);
      return s5?.tables ?? [];
    } catch {
      return [];
    }
  });
  if ("object" == typeof t) {
    const a2 = {};
    let n2;
    if (null != t.id ? (a2.layerId = t.id, n2 = `${e2.url}/layers/${t.id}`) : n2 = e2.url, e2.typeKeywords?.length) {
      for (const r2 of Object.keys(w)) if (e2.typeKeywords.includes(r2)) return { className: w[r2] };
    }
    const c2 = await r.fetchServiceMetadata(n2, { customParameters: await r.fetchCustomParameters(e2, (e3) => s3(e3)?.customParameters) });
    return { className: w[c2?.layerType] || "SceneLayer", properties: a2 };
  }
  if (false === t) {
    const a2 = await r.fetchServiceMetadata(e2.url);
    if ("Voxel" === a2?.layerType) return { className: "VoxelLayer" };
  }
  return { className: "GroupLayer" };
}
async function M(e2) {
  await e2.load();
  const a2 = s2(e2, "Map Notes"), r = s2(e2, "Markup");
  if (a2 || r) return { className: "MapNotesLayer" };
  if (s2(e2, "Route Layer")) return { className: "RouteLayer" };
  const t = await e2.fetchData();
  return 1 === c(t) ? { className: "FeatureLayer" } : { className: "GroupLayer" };
}
async function g(e2, a2) {
  await e2.load();
  const r = e2.typeKeywords?.map((e3) => e3.toLowerCase()) ?? [];
  if (r.includes("elevation 3d layer")) return { className: "ElevationLayer" };
  if (r.includes("tiled imagery")) return { className: "ImageryTileLayer" };
  const t = await a2.fetchItemData(e2), s5 = t?.layerType;
  if ("ArcGISTiledImageServiceLayer" === s5) return { className: "ImageryTileLayer" };
  if ("ArcGISImageServiceLayer" === s5) return { className: "ImageryLayer" };
  const n2 = await a2.fetchServiceMetadata(e2.url, { customParameters: await a2.fetchCustomParameters(e2) }), c2 = n2.cacheType?.toLowerCase(), o = n2.capabilities?.toLowerCase().includes("tilesonly"), i2 = n2.tileInfo?.format?.toLowerCase() ?? "", u = null == c2 && ["jpg", "jpeg", "png", "png8", "png24", "png32", "mixed"].includes(i2);
  return "map" === c2 || u || o ? { className: "ImageryTileLayer" } : { className: "ImageryLayer" };
}
function j() {
  return { className: "StreamLayer" };
}
async function T(e2, a2) {
  return "object" == typeof await E(e2, a2) ? { className: "VideoLayer" } : { className: "GroupLayer" };
}
function C() {
  return { className: "VectorTileLayer" };
}
function G() {
  return { className: "GeoJSONLayer" };
}
function P() {
  return { className: "IntegratedMesh3DTilesLayer" };
}
function b() {
  return { className: "GaussianSplatLayer" };
}
function F() {
  return { className: "UnsupportedLayer" };
}
function K() {
  return { className: "CSVLayer" };
}
function V() {
  return { className: "KMLLayer" };
}
function W2() {
  return { className: "KnowledgeGraphLayer" };
}
function U() {
  return { className: "WCSLayer" };
}
function D() {
  return { className: "WFSLayer" };
}
function O() {
  return { className: "WMSLayer" };
}
function x() {
  return { className: "WMTSLayer" };
}
function J() {
  return { className: "StreamLayer" };
}
function k2() {
  return { className: "GroupLayer" };
}
function $() {
  return { className: "MediaLayer" };
}
async function A(e2, a2) {
  const { tileInfo: r } = await a2.fetchServiceMetadata(e2.url, { customParameters: await a2.fetchCustomParameters(e2) });
  return r;
}
async function E(e2, a2, t) {
  const { url: s5, type: o } = e2, i2 = "Feature Service" === o;
  if (!s5) return {};
  if (/\/\d+$/.test(s5)) {
    if (i2) {
      const t2 = await a2.fetchServiceMetadata(s5, { customParameters: await a2.fetchCustomParameters(e2, (e3) => s3(e3)?.customParameters) });
      return W(e2, Q()), { id: t2.id, className: l(t2.type), sourceJSON: t2 };
    }
    return {};
  }
  if ("Video Service" === o) {
    const e3 = await a2.fetchServiceMetadata(s5);
    return !((e3.layers?.length ?? 0) > 1) && {};
  }
  await e2.load();
  let d = await a2.fetchItemData(e2);
  if (i2) {
    const { data: r, preferredHost: t2 } = await l2(d, s5, a2);
    W(e2, t2);
    const c2 = R(r);
    if ("object" == typeof c2) {
      const e3 = n(r, c2.id);
      c2.className = i(e3?.layerType);
    }
    return c2;
  }
  "Scene Service" === o && (d = await y(e2, d, a2));
  if (c(d) > 0) return R(d);
  const L2 = await a2.fetchServiceMetadata(s5);
  return t && (L2.tables = await t()), R(L2);
}
function R(e2) {
  return 1 === c(e2) && { id: s3(e2)?.id };
}

export {
  L,
  S
};
//# sourceMappingURL=chunk-4NBKAJGB.js.map
