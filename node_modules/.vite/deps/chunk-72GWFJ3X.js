import {
  r as r5
} from "./chunk-4FWFNZMT.js";
import {
  e as e5
} from "./chunk-6GZZL5MR.js";
import {
  a,
  e as e7,
  f as f2,
  n2,
  p as p3,
  t2 as t3,
  v
} from "./chunk-T6CRNJ3D.js";
import {
  a as a2,
  f as f3
} from "./chunk-Z4KE5G4E.js";
import {
  i,
  o as o2
} from "./chunk-HETHJJO6.js";
import {
  n as n3
} from "./chunk-CHC4AAHW.js";
import {
  o
} from "./chunk-I4DSU5MJ.js";
import {
  d as d2
} from "./chunk-NDWECAKM.js";
import {
  e2 as e3,
  r as r2,
  r2 as r3,
  t2
} from "./chunk-F43BIMML.js";
import {
  i as i2
} from "./chunk-CT7HOWYG.js";
import {
  d as d3,
  e as e6
} from "./chunk-BZBDEPRV.js";
import {
  p
} from "./chunk-MXP2VO3L.js";
import {
  d,
  f,
  p as p2
} from "./chunk-OWSUTT7E.js";
import {
  e as e2
} from "./chunk-COMSADUT.js";
import {
  e
} from "./chunk-IT62DCG6.js";
import {
  e as e4
} from "./chunk-SZ5DGQ75.js";
import {
  s
} from "./chunk-WJ3E33GQ.js";
import {
  r as r4
} from "./chunk-YOYO2XMY.js";
import {
  n,
  t
} from "./chunk-CFXCM2NO.js";
import {
  r
} from "./chunk-WDTGOP77.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/PathVertexPosition.glsl.js
var p4 = 8;
function f4(e8, c) {
  const { attributes: f5, vertex: u2 } = e8;
  f5.add("position", "vec3"), f5.add("profileVertexAndNormal", "vec4"), f5.add("profileAuxData", "vec3"), f5.add("profileRight", "vec2"), f5.add("profileUp", "vec2"), u2.code.add(t`bool isCapVertex() {
return profileAuxData.z == 1.0;
}`), u2.uniforms.add(new e4("size", (e9) => e9.size));
  const { hasVVSize: d4, hasVVColor: m, hasVVOpacity: x } = c;
  d4 ? (f5.add("sizeFeatureAttribute", "float"), u2.uniforms.add(new e("vvSizeMinSize", (e9) => e9.vvSize.minSize), new e("vvSizeMaxSize", (e9) => e9.vvSize.maxSize), new e("vvSizeOffset", (e9) => e9.vvSize.offset), new e("vvSizeFactor", (e9) => e9.vvSize.factor), new e("vvSizeFallback", (e9) => e9.vvSize.fallback)), u2.code.add(t`vec2 getSize() {
float value = sizeFeatureAttribute;
if (isnan(value)) {
return vvSizeFallback.xz;
}
return size * clamp(vvSizeOffset + value * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).xz;
}`)) : u2.code.add(t`vec2 getSize(){
return size;
}`), x ? (f5.add("opacityFeatureAttribute", "float"), u2.constants.add("vvOpacityNumber", "int", p4), u2.uniforms.add(new r2("vvOpacityValues", (e9) => e9.vvOpacity.values, p4), new r2("vvOpacityOpacities", (e9) => e9.vvOpacity.opacityValues, p4), new r4("vvOpacityFallback", (e9) => e9.vvOpacity.fallback, { supportsNaN: true })), u2.code.add(t`
    vec4 applyOpacity(vec4 color) {
      // if we encounter NaN in the color it means the color is in the fallback case where the symbol color
      // is not defined and there is no valid color visual variable override. In this case just return a fully
      // transparent color
      if (isnan(color.r)) {
        return vec4(0);
      }

      float value = opacityFeatureAttribute;

      if (isnan(value)) {
        // If there is a color vv then it will already have taken care of applying the fallback
        return ${n(m, "color", "vec4(color.rgb, vvOpacityFallback)")};
      }

      if (value <= vvOpacityValues[0]) {
        return vec4(color.rgb, vvOpacityOpacities[0]);
      }

      for (int i = 1; i < vvOpacityNumber; ++i) {
        if (vvOpacityValues[i] >= value) {
          float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);
          return vec4(color.rgb, mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f));
        }
      }

      return vec4( color.rgb, vvOpacityOpacities[vvOpacityNumber - 1]);
    }
    `)) : u2.code.add(t`vec4 applyOpacity(vec4 color){
return color;
}`), m ? (f5.add("colorFeatureAttribute", "float"), u2.constants.add("vvColorNumber", "int", r3), u2.uniforms.add(new r2("vvColorValues", (e9) => e9.vvColor.values, r3), new e3("vvColorColors", (e9) => e9.vvColor.colors, r3), new e2("vvColorFallback", (e9) => e9.vvColor.fallback)), u2.code.add(t`vec4 getColor() {
float value = colorFeatureAttribute;
if (isnan(value)) {
return applyOpacity(vvColorFallback);
}
if (value <= vvColorValues[0]) {
return applyOpacity(vvColorColors[0]);
}
for (int i = 1; i < vvColorNumber; ++i) {
if (vvColorValues[i] >= value) {
float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);
return applyOpacity(mix(vvColorColors[i-1], vvColorColors[i], f));
}
}
return applyOpacity(vvColorColors[vvColorNumber - 1]);
}`)) : u2.code.add(t`vec4 getColor(){
return applyOpacity(vec4(1, 1, 1, 1));
}`), u2.code.add(t`vec3 decompressAxis(vec2 axis) {
float z = 1.0 - abs(axis.x) - abs(axis.y);
return normalize(vec3(axis + sign(axis) * min(z, 0.0), z));
}
vec3 calculateVPos() {
vec2 size = getSize();
vec3 origin = position;
vec3 right = decompressAxis(profileRight);
vec3 up = decompressAxis(profileUp);
vec2 profileVertex = profileVertexAndNormal.xy * size;`), u2.code.add(t`if(isCapVertex()) {
float positionOffsetAlongProfilePlaneNormal = profileAuxData.x * size[0];
vec3 forward = cross(up, right);
vec3 offset = right * profileVertex.x + up * profileVertex.y + forward * positionOffsetAlongProfilePlaneNormal;
return origin + offset;
}
vec2 rotationRight = vec2(profileAuxData.x, profileAuxData.y);
float maxDistance = length(rotationRight);`), u2.code.add(t`rotationRight = maxDistance > 0.0 ? normalize(rotationRight) : vec2(0, 0);
float rx = dot(profileVertex, rotationRight);
if (abs(rx) > maxDistance) {
vec2 rotationUp = vec2(-rotationRight.y, rotationRight.x);
float ry = dot(profileVertex, rotationUp);
profileVertex = rotationRight * maxDistance * sign(rx) + rotationUp * ry;
}
vec3 offset = right * profileVertex.x + up * profileVertex.y;
return origin + offset;
}`), u2.code.add(t`vec3 localNormal() {
vec3 right = decompressAxis(profileRight);
vec3 up = decompressAxis(profileUp);
vec3 normal = right * profileVertexAndNormal.z + up * profileVertexAndNormal.w;
if(isCapVertex()) {
vec3 forward = cross(up, right);
normal += forward * profileAuxData.y;
}
return normal;
}`);
}
var u = class extends t2 {
  constructor() {
    super(...arguments), this.size = r(1, 1);
  }
};

// node_modules/@arcgis/core/chunks/Path.glsl.js
function B(B2) {
  const I2 = new s(), { vertex: M, fragment: _, varyings: F } = I2;
  f(M, B2), F.add("vpos", "vec3", { invariant: true }), I2.include(f4, B2);
  const { output: V, spherical: x, pbrMode: z, snowCover: T } = B2;
  switch ((o(V) || 10 === V) && (I2.include(o2), I2.include(f3, B2), I2.include(d2, B2), I2.include(i2, B2), F.add("vnormal", "vec3"), F.add("vcolor", "vec4"), M.main.add(t`vpos = calculateVPos();
vnormal = normalize(localNormal());
forwardViewPosDepth((view * vec4(vpos, 1.0)).xyz);
gl_Position = transformPosition(proj, view, vpos);
forwardObjectAndLayerIdColor();
vcolor = getColor();
forwardLinearDepthToReadShadowMap();`)), V) {
    case 1:
    case 0:
      I2.include(n2, B2), I2.include(f2, B2), _.include(t3, B2), I2.include(e5, B2), _.include(p, B2), I2.include(n3, B2), d(_, B2), p3(_), v(_), _.uniforms.add(M.uniforms.get("localOrigin"), new e("ambient", (e8) => e8.ambient), new e("diffuse", (e8) => e8.diffuse), new r4("opacity", (e8) => e8.opacity)), _.include(e6), _.include(e7, B2), a2(_), _.main.add(t`
        discardBySlice(vpos);
        discardByTerrainDepth();

        shadingParams.viewDirection = normalize(vpos - cameraPosition);
        shadingParams.normalView = vnormal;
        vec3 normal = shadingNormal(shadingParams);
        float ssao = evaluateAmbientOcclusionInverse();

        vec3 posWorld = vpos + localOrigin;
        vec3 normalGround = ${x ? "normalize(posWorld);" : "vec3(0.0, 0.0, 1.0);"}

        vec3 albedo = vcolor.rgb * max(ambient, diffuse); // combine the old material parameters into a single one
        float combinedOpacity = vcolor.a * opacity;

        ${n(T, t`float snow = getSnow(normal, normalGround);
                 albedo = mix(albedo, vec3(1), snow);
                 ssao = mix(ssao, 1.0, snow);`)}

        float additionalAmbientScale = additionalDirectedAmbientLight(posWorld);
        vec3 additionalLight = ssao * mainLightIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;
        float shadow = readShadow(additionalAmbientScale, vpos);

        ${n(2 === z, `float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * mainLightIntensity[2];
           ${n(T, "mrr = applySnowToMRR(mrr, snow);")}`)}

        vec3 shadedColor = ${2 === z ? "evaluateSceneLightingPBR(normal, albedo, shadow, 1.0 - ssao, additionalLight, shadingParams.viewDirection, normalGround, mrr, additionalAmbientIrradiance);" : "evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight);"}
        vec4 finalColor = vec4(shadedColor, combinedOpacity);
        outputColorHighlightOID(finalColor, vpos, albedo ${n(T, ", snow")});`);
      break;
    case 2:
      I2.include(o2), M.main.add(t`vpos = calculateVPos();
gl_Position = transformPosition(proj, view, vpos);`), I2.fragment.include(p, B2), _.main.add(t`discardBySlice(vpos);`);
      break;
    case 4:
    case 5:
    case 6:
    case 7:
      I2.include(o2), i(I2), F.add("depth", "float"), M.main.add(t`vpos = calculateVPos();
gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);`), I2.fragment.include(p, B2), I2.include(a, B2), _.main.add(t`discardBySlice(vpos);
outputDepth(depth);`);
      break;
    case 10:
      I2.fragment.include(p, B2), _.main.add(t`discardBySlice(vpos);
outputObjectAndLayerIdColor();`);
      break;
    case 3:
      I2.include(o2), I2.include(r5, B2), p2(M), F.add("vnormal", "vec3"), M.main.add(t`vpos = calculateVPos();
vnormal = normalize((viewNormal * vec4(localNormal(), 1.0)).xyz);
gl_Position = transformPosition(proj, view, vpos);`), I2.fragment.include(p, B2), _.main.add(t`discardBySlice(vpos);
vec3 normal = normalize(vnormal);
if (gl_FrontFacing == false) normal = -normal;
fragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);`);
      break;
    case 9:
      I2.include(o2), I2.include(r5, B2), F.add("vnormal", "vec3"), M.main.add(t`vpos = calculateVPos();
gl_Position = transformPosition(proj, view, vpos);`), I2.fragment.include(p, B2), I2.include(d3, B2), _.main.add(t`discardBySlice(vpos);
calculateOcclusionAndOutputHighlight();`);
  }
  return I2;
}
var I = Object.freeze(Object.defineProperty({ __proto__: null, build: B }, Symbol.toStringTag, { value: "Module" }));

export {
  u,
  B,
  I
};
//# sourceMappingURL=chunk-72GWFJ3X.js.map
