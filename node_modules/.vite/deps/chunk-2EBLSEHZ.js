import {
  A as A2,
  M,
  v
} from "./chunk-JBTWCDRR.js";
import {
  s as s3,
  w
} from "./chunk-U6CJFTOF.js";
import {
  G,
  I,
  K as K2,
  L,
  N,
  O,
  R,
  d,
  j2,
  k,
  q2 as q,
  y
} from "./chunk-2JMKFI2D.js";
import {
  c as c2,
  f
} from "./chunk-QYAMBIRP.js";
import {
  A,
  E,
  H,
  K,
  P,
  c,
  g,
  j,
  o,
  p as p2,
  r as r2,
  s as s2,
  u
} from "./chunk-VYMBX5H5.js";
import {
  e as e2
} from "./chunk-K2OZ6WVC.js";
import {
  h,
  p,
  s
} from "./chunk-XLOINTMG.js";
import {
  n,
  r,
  t
} from "./chunk-75XOUSSS.js";
import {
  e
} from "./chunk-FPMLKIDB.js";
import {
  b
} from "./chunk-SMWUT52Z.js";
import {
  i3 as i
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/chunks/boundedPlane.js
var U = () => i.getLogger("esri.views.3d.support.geometryUtils.boundedPlane");
function z(t2 = Nt) {
  return { plane: j2(t2.plane), origin: t(t2.origin), basis1: t(t2.basis1), basis2: t(t2.basis2) };
}
function D(t2, s4, i2) {
  const n2 = St.get();
  return n2.origin = t2, n2.basis1 = s4, n2.basis2 = i2, n2.plane = d(0, 0, 0, 0), J(n2), n2;
}
function G2(t2, s4 = z()) {
  return H2(t2.origin, t2.basis1, t2.basis2, s4);
}
function W(t2, s4) {
  s2(s4.origin, t2.origin), s2(s4.basis1, t2.basis1), s2(s4.basis2, t2.basis2), y(s4.plane, t2.plane);
}
function H2(t2, s4, i2, n2 = z()) {
  return s2(n2.origin, t2), s2(n2.basis1, s4), s2(n2.basis2, i2), J(n2), vt(n2, "fromValues()"), n2;
}
function J(t2) {
  I(t2.basis2, t2.basis1, t2.origin, t2.plane);
}
function K3(t2, s4, i2) {
  t2 !== i2 && G2(t2, i2);
  const n2 = g(c2.get(), dt(t2), s4);
  return u(i2.origin, i2.origin, n2), i2.plane[3] -= s4, i2;
}
function Q(t2, s4, i2) {
  return Z(s4, i2), K3(i2, bt(t2, t2.origin), i2), i2;
}
function X(t2, s4) {
  const i2 = t2.basis1[0], n2 = t2.basis2[1], [r3, e3] = t2.origin;
  return e(r3 - i2, e3 - n2, r3 + i2, e3 + n2, s4);
}
function Z(t2, s4 = z()) {
  const i2 = (t2[2] - t2[0]) / 2, n2 = (t2[3] - t2[1]) / 2;
  return o(s4.origin, t2[0] + i2, t2[1] + n2, 0), o(s4.basis1, i2, 0, 0), o(s4.basis2, 0, n2, 0), q(0, 0, 1, 0, s4.plane), s4;
}
function $(t2, s4, i2) {
  return !!K2(t2.plane, s4, i2) && ht(t2, i2);
}
function tt(t2, s4, i2) {
  if ($(t2, s4, i2)) return i2;
  const n2 = st(t2, s4, c2.get());
  return u(i2, s4.origin, g(c2.get(), s4.direction, p2(s4.origin, n2) / r2(s4.direction))), i2;
}
function st(t2, i2, n2) {
  const r3 = wt.get();
  Pt(t2, i2, r3, wt.get());
  let e3 = Number.POSITIVE_INFINITY;
  for (const o2 of Tt) {
    const c3 = yt(t2, o2, xt.get()), u2 = c2.get();
    if (L(r3, c3, u2)) {
      const t3 = K(c2.get(), i2.origin, u2), r4 = Math.abs(b(P(i2.direction, t3)));
      r4 < e3 && (e3 = r4, s2(n2, u2));
    }
  }
  return e3 === Number.POSITIVE_INFINITY ? nt(t2, i2, n2) : n2;
}
function it(t2, s4) {
  return (s4 - t2) / s4;
}
function nt(t2, s4, i2) {
  if ($(t2, s4, i2)) return i2;
  const n2 = wt.get(), r3 = wt.get();
  Pt(t2, s4, n2, r3);
  let e3 = Number.POSITIVE_INFINITY;
  for (const o2 of Tt) {
    const c3 = yt(t2, o2, xt.get()), u2 = c2.get();
    if (N(n2, c3, u2)) {
      const t3 = w(s4, u2);
      if (!O(r3, u2)) continue;
      t3 < e3 && (e3 = t3, s2(i2, u2));
    }
  }
  return ot(t2, s4.origin) < e3 && rt(t2, s4.origin, i2), i2;
}
function rt(t2, s4, i2) {
  const n2 = R(t2.plane, s4, c2.get()), r3 = A2(It(t2, t2.basis1), n2, -1, 1, c2.get()), e3 = A2(It(t2, t2.basis2), n2, -1, 1, c2.get());
  return c(i2, u(c2.get(), r3, e3), t2.origin), i2;
}
function et(t2, s4, i2) {
  const { origin: n2, basis1: r3, basis2: e3 } = t2, o2 = c(c2.get(), s4, n2), a = f(r3, o2), c3 = f(e3, o2), u2 = f(dt(t2), o2);
  return o(i2, a, c3, u2);
}
function ot(t2, s4) {
  const i2 = et(t2, s4, c2.get()), { basis1: n2, basis2: r3 } = t2, e3 = r2(n2), o2 = r2(r3), a = Math.max(Math.abs(i2[0]) - e3, 0), c3 = Math.max(Math.abs(i2[1]) - o2, 0), u2 = i2[2];
  return a * a + c3 * c3 + u2 * u2;
}
function at(t2, s4) {
  return Math.sqrt(ot(t2, s4));
}
function ct(t2, s4) {
  let i2 = Number.NEGATIVE_INFINITY;
  for (const n2 of Tt) {
    const r3 = yt(t2, n2, xt.get()), e3 = M(r3, s4);
    e3 > i2 && (i2 = e3);
  }
  return Math.sqrt(i2);
}
function ut(t2, s4) {
  return O(t2.plane, s4) && ht(t2, s4);
}
function gt(t2, s4, i2, n2) {
  return jt(t2, i2, n2);
}
function bt(t2, s4) {
  const i2 = -t2.plane[3];
  return f(dt(t2), s4) - i2;
}
function ft(t2, s4, i2, n2) {
  const r3 = bt(t2, s4), e3 = g(Mt, dt(t2), i2 - r3);
  return u(n2, s4, e3), n2;
}
function pt(t2, s4) {
  return H(t2.basis1, s4.basis1) && H(t2.basis2, s4.basis2) && H(t2.origin, s4.origin);
}
function lt(t2, s4, i2) {
  return t2 !== i2 && G2(t2, i2), h(Vt, s4), s(Vt, Vt), E(i2.basis1, t2.basis1, Vt), E(i2.basis2, t2.basis2, Vt), E(k(i2.plane), k(t2.plane), Vt), E(i2.origin, t2.origin, s4), G(i2.plane, i2.plane, i2.origin), i2;
}
function mt(t2, s4, i2, n2) {
  return t2 !== n2 && G2(t2, n2), p(At, s4, i2), E(n2.basis1, t2.basis1, At), E(n2.basis2, t2.basis2, At), J(n2), n2;
}
function dt(t2) {
  return k(t2.plane);
}
function jt(t2, s4, i2) {
  switch (s4) {
    case 0:
      s2(i2, t2.basis1), A(i2, i2);
      break;
    case 1:
      s2(i2, t2.basis2), A(i2, i2);
      break;
    case 2:
      s2(i2, dt(t2));
  }
  return i2;
}
function ht(t2, s4) {
  const i2 = c(c2.get(), s4, t2.origin), n2 = j(t2.basis1), r3 = j(t2.basis2), e3 = P(t2.basis1, i2), o2 = P(t2.basis2, i2);
  return -e3 - n2 < 0 && e3 - n2 < 0 && -o2 - r3 < 0 && o2 - r3 < 0;
}
function It(t2, s4) {
  const i2 = xt.get();
  return s2(i2.origin, t2.origin), s2(i2.vector, s4), i2;
}
function yt(t2, s4, i2) {
  const { basis1: n2, basis2: r3, origin: e3 } = t2, o2 = g(c2.get(), n2, s4.origin[0]), a = g(c2.get(), r3, s4.origin[1]);
  u(i2.origin, o2, a), u(i2.origin, i2.origin, e3);
  const g2 = g(c2.get(), n2, s4.direction[0]), b2 = g(c2.get(), r3, s4.direction[1]);
  return g(i2.vector, u(g2, g2, b2), 2), i2;
}
function vt(t2, s4) {
  Math.abs(P(t2.basis1, t2.basis2) / (r2(t2.basis1) * r2(t2.basis2))) > 1e-6 && U().warn(s4, "Provided basis vectors are not perpendicular"), Math.abs(P(t2.basis1, dt(t2))) > 1e-6 && U().warn(s4, "Basis vectors and plane normal are not perpendicular"), Math.abs(-P(dt(t2), t2.origin) - t2.plane[3]) > 1e-6 && U().warn(s4, "Plane offset is not consistent with plane origin");
}
function Pt(t2, s4, i2, n2) {
  const r3 = dt(t2);
  I(r3, s4.direction, s4.origin, i2), I(k(i2), r3, s4.origin, n2);
}
var Nt = { plane: j2(), origin: r(0, 0, 0), basis1: r(1, 0, 0), basis2: r(0, 1, 0) };
var wt = new s3(j2);
var xt = new s3(v);
var Mt = n();
var St = new s3(() => z());
var Tt = [{ origin: [-1, -1], direction: [1, 0] }, { origin: [1, -1], direction: [0, 1] }, { origin: [1, 1], direction: [-1, 0] }, { origin: [-1, 1], direction: [0, -1] }];
var Vt = e2();
var At = e2();
var Et = Object.freeze(Object.defineProperty({ __proto__: null, altitudeAt: bt, axisAt: gt, cameraFrustumCoverage: it, closestPoint: nt, closestPointOnSilhouette: st, copy: G2, copyWithoutVerify: W, create: z, distance: at, distance2: ot, distanceToSilhouette: ct, elevate: K3, equals: pt, extrusionContainsPoint: ut, fromAABoundingRect: Z, fromValues: H2, getExtent: X, intersectRay: $, intersectRayClosestSilhouette: tt, normal: dt, projectPoint: rt, projectPointLocal: et, rotate: mt, setAltitudeAt: ft, setExtent: Q, transform: lt, up: Nt, updateUnboundedPlane: J, wrap: D }, Symbol.toStringTag, { value: "Module" }));

export {
  z,
  G2 as G,
  H2 as H,
  J,
  Z,
  at,
  Et
};
//# sourceMappingURL=chunk-2EBLSEHZ.js.map
