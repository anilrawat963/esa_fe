import {
  f as f2,
  i as i4,
  p2 as p,
  s as s2,
  y
} from "./chunk-ZOIMNPWT.js";
import {
  i3,
  n2 as n,
  t
} from "./chunk-IOYCE6EG.js";
import {
  r2
} from "./chunk-TWE24CRT.js";
import {
  i as i2
} from "./chunk-Y3GEZC7J.js";
import "./chunk-U5TTP5E5.js";
import {
  d,
  w
} from "./chunk-7EPCZHGM.js";
import "./chunk-JCMADXBT.js";
import "./chunk-5XLI5DPS.js";
import {
  u as u2
} from "./chunk-DUZAVZR4.js";
import "./chunk-EK7HOTRR.js";
import {
  E,
  W,
  Y
} from "./chunk-3VXANCFN.js";
import "./chunk-MBQEPUQX.js";
import "./chunk-ODQ5APZK.js";
import "./chunk-G5IXTUNN.js";
import "./chunk-ZNQKJRCD.js";
import "./chunk-BA6HYZ35.js";
import "./chunk-GCTH5LET.js";
import "./chunk-SJB744AD.js";
import "./chunk-WM2VG5F2.js";
import "./chunk-IXFJYDA2.js";
import "./chunk-TTLSEJNG.js";
import "./chunk-U73R3I4U.js";
import "./chunk-VGXUPJSS.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import {
  _
} from "./chunk-IRBX64M6.js";
import "./chunk-DLM5SBNY.js";
import "./chunk-EKZRA6TO.js";
import "./chunk-M5SP6ZBM.js";
import "./chunk-FAA2FDN5.js";
import {
  Z
} from "./chunk-2HGIYEIL.js";
import "./chunk-XX3OKYJS.js";
import "./chunk-OTCNIJ2H.js";
import "./chunk-JGA5YJWL.js";
import "./chunk-GCI4MA3M.js";
import "./chunk-SJ2OBYX2.js";
import "./chunk-MDJNYPVI.js";
import "./chunk-Z6VKIQV2.js";
import "./chunk-4PXNA4MD.js";
import "./chunk-E2RVV63B.js";
import "./chunk-AJGINJLG.js";
import "./chunk-JE2NJSBU.js";
import "./chunk-WDTGOP77.js";
import "./chunk-XDLV73DB.js";
import "./chunk-ARTU4L55.js";
import "./chunk-6VL5D5UP.js";
import "./chunk-6QHY54HZ.js";
import "./chunk-GXJJY3ND.js";
import "./chunk-5ONGWFJ3.js";
import "./chunk-PLNHHGHL.js";
import "./chunk-DFK6QMLO.js";
import "./chunk-4WTOIJXV.js";
import "./chunk-BBYMM7CM.js";
import "./chunk-EM7Y2JZC.js";
import {
  m
} from "./chunk-QZQPB5XR.js";
import "./chunk-AQFRVV3U.js";
import "./chunk-3GHCGAH2.js";
import {
  B,
  L,
  M,
  k,
  u,
  x
} from "./chunk-HWUOAPTX.js";
import "./chunk-QHCKOBU7.js";
import "./chunk-K2OZ6WVC.js";
import {
  S
} from "./chunk-MC6NAKKX.js";
import "./chunk-TF6255HN.js";
import "./chunk-GD4FJL3C.js";
import "./chunk-C5OQVQZF.js";
import "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-C5M24ACM.js";
import "./chunk-L4A2QJG4.js";
import "./chunk-ENINOZUZ.js";
import "./chunk-V2X4OKYI.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import "./chunk-T7F6Q6JJ.js";
import {
  O
} from "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-3FUHCAX3.js";
import "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import "./chunk-2OFHDVO5.js";
import "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import "./chunk-7H3U4IJR.js";
import "./chunk-SMWUT52Z.js";
import "./chunk-AXZMNHTN.js";
import {
  f
} from "./chunk-5T3MJDSR.js";
import "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import "./chunk-5EI5H4QX.js";
import "./chunk-ZIE53VIV.js";
import {
  __addDisposableResource,
  __disposeResources
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import "./chunk-GNMPGHLQ.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  has,
  r
} from "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/layers/support/parquetEncodingUtils.js
function t2(t3) {
  switch (t3.type) {
    case "wkb":
      return s2.fromJSON(t3);
    case "location":
      return i4.fromJSON(t3);
  }
}

// node_modules/@arcgis/core/layers/graphics/sources/support/ParquetSourceWorker.js
var A = new r2();
var E2 = 4;
var P = 8e3;
var B2 = "__OBJECTID";
var T = class {
  constructor() {
    this._fileInfos = /* @__PURE__ */ new Map(), this._queue = new _({ concurrency: E2, process: (e, t3) => this._executeQuery(e, t3) });
  }
  async load(r3) {
    const n2 = r3.spatialReference ? f.fromJSON(r3.spatialReference) : void 0;
    if (n2 && !n2.isWGS84 && !n2.isWebMercator) throw new s("parquet:unsupported-projection", "Only WGS84 and Web Mercator are supported");
    const c = await y({ urls: new O(r3.urls), fields: r3.fields?.map((e) => m.fromJSON(e)), encoding: r3.encoding ? t2(r3.encoding) : null, geometryType: r3.geometryType ? f2(r3.geometryType) : null, spatialReference: n2 }, { customParameters: r3.customParameters });
    let f3;
    if (c.geometryType && c.encoding) {
      if (!c.spatialReference) throw new s("parquet:unsupported", "SpatialReference must be defined");
      if (!c.spatialReference.isGeographic && !c.spatialReference.isWebMercator) throw new s("parquet:unsupported-projection", "Only WGS84 and Web Mercator are supported");
      c.spatialReference.isGeographic && !c.spatialReference.isWGS84 && (i.getLogger("parquet:unsupported-projection").warn("Found a geographic projection that is not WGS84. Handling as WGS84.", { spatialReference: c.spatialReference }), c.spatialReference = f.WGS84), f3 = { geometryType: p(c.geometryType), spatialReference: c.spatialReference.toJSON(), encoding: c.encoding.toJSON(), displayOptimization: c.displayOptimization };
    }
    this.setCustomParameters(r3.customParameters), this._geometryInfo = f3;
    const m2 = r3.urls;
    for (const e of m2) {
      const t3 = await d(e, { geometryInfo: f3, outSpatialReference: null, getCustomParameters: () => this._customParameters });
      this._fileInfos.set(e, { index: this._fileInfos.size, file: t3 });
    }
    this._capabilities = N(await this.getFileStatistics());
    const y2 = this._fileInfos.values().next().value?.file;
    if (!y2) return { layerDefinition: {}, capabilities: N(null) };
    const { fields: h } = c;
    if (null == h) throw new s("parquet-layer:missing-metadata", "Unable to create parquet source: cannot infer fields", h);
    h.push(new m({ name: B2, type: "oid", alias: B2 }));
    const I = { fields: h.map((e) => ({ ...e.toJSON(), column: y2.columnForFieldName(e.name) })), timeZoneByFieldName: null }, C = Z.fromJSON(I);
    this._fieldsIndex = C;
    const b = p(c.geometryType ?? "point");
    if (this._metadata = i2.createFeature({ fieldsIndex: I, geometryType: b, featureIdInfo: { type: "object-id", fieldName: "rowId" }, subtypes: null, subtypeField: null, types: null, typeIdField: null, globalIdField: null, spatialReference: c.spatialReference, outSpatialReference: null, timeInfo: null, timeReferenceUnknownClient: null, dateFieldsTimeZone: null }), this._queryEngineParams = { fieldsIndex: this._metadata.fieldsIndex, geometryType: f3?.geometryType ?? "esriGeometryPoint", featureIdInfo: { type: "object-id", fieldName: "rowId" }, hasM: false, hasZ: false, spatialReference: f3?.spatialReference ?? { wkid: 4326 }, aggregateAdapter: null, timeInfo: null, definitionExpression: null }, c.spatialReference && (this._fullExtent = k2(this._fileInfos.values(), c.spatialReference.toJSON())), null == this._fullExtent && "location" === c.encoding?.type) {
      const { latitudeFieldName: s3, longitudeFieldName: r4 } = c.encoding, o = this._fieldsIndex.get(s3)?.column, i5 = this._fieldsIndex.get(r4)?.column, n3 = k(u(), L);
      for (const a of this._fileInfos.values()) for (const s4 of a.file.rowGroups()) {
        const r5 = { stack: [], error: void 0, hasError: false };
        try {
          const t3 = __addDisposableResource(r5, s4.columnDescriptorForAttribute(o), false), a2 = __addDisposableResource(r5, s4.columnDescriptorForAttribute(i5), false), u3 = [a2.minValue(), t3.minValue(), a2.maxValue(), t3.maxValue()];
          x(n3, u3), s4.free();
        } catch (v) {
          r5.error = v, r5.hasError = true;
        } finally {
          __disposeResources(r5);
        }
      }
      this._fullExtent = { xmin: n3[0], ymin: n3[1], xmax: n3[3], ymax: n3[4], spatialReference: c.spatialReference?.toJSON() };
    }
    return { capabilities: this._capabilities, layerDefinition: { fields: c.fields?.map((e) => e.toJSON()), drawingInfo: u2(b), extent: this._fullExtent ?? void 0, geometryType: b, geometryEncoding: c.encoding?.toJSON(), displayOptimization: c.displayOptimization } };
  }
  destroy() {
    for (const e of this._fileInfos.values()) e.file.free();
    this._fileInfos.clear(), this._queue.destroy();
  }
  setCustomParameters(e) {
    this._customParameters = e;
  }
  getFileStatistics() {
    if (!this._fileInfos.size) return null;
    const e = Array.from(this._fileInfos.values()).reduce((e2, t3) => e2 + t3.file.byteLength(), 0);
    return { featureCount: this._getFeatureCount(), byteLength: e };
  }
  async updateFiles(e) {
    const t3 = new Set(e);
    for (const [s3, r3] of this._fileInfos.entries()) t3.has(s3) ? t3.delete(s3) : (r3.file.free(), this._fileInfos.delete(s3));
    for (const s3 of t3) {
      const e2 = await d(s3, { geometryInfo: this._geometryInfo, outSpatialReference: null, getCustomParameters: () => this._customParameters });
      this._fileInfos.set(s3, { index: this._fileInfos.size, file: e2 });
    }
  }
  async queryFeatures(e, t3) {
    this._validateQuery(e), z(e) || (e.resultRecordCount = e.resultRecordCount ? Math.min(e.resultRecordCount, 8e3) : 8e3, e.resultOffset = e.resultOffset ?? 0), (e.outStatistics || e.returnDistinctValues) && delete e.returnGeometry;
    return (await this._enqueueQuery(e, t3)).createQueryResponse();
  }
  async queryFeatureCount(e, t3) {
    if (this._validateQuery(e), !G(e)) return this._getFeatureCount();
    delete e.outFields, delete e.returnGeometry;
    return (await this._enqueueQuery(e, t3)).createQueryResponseForCount();
  }
  async queryObjectIds(e, t3) {
    if (this._validateQuery(e), !G(e)) return Array.from({ length: this._getFeatureCount() }, (e2, t4) => t4);
    e.resultRecordCount = e.resultRecordCount ? Math.min(e.resultRecordCount, 8e3) : 8e3, e.resultOffset = e.resultOffset ?? 0, delete e.returnGeometry, delete e.outFields;
    return (await this._enqueueQuery(e, t3)).items.map((e2) => e2.getObjectId());
  }
  async queryExtent(e, t3) {
    if (this._validateQuery(e), this._fullExtent && !G(e)) return { count: this._getFeatureCount(), extent: this._fullExtent };
    const s3 = r(this._metadata.spatialReference);
    e.returnGeometry = true, delete e.outFields;
    const o = k(u(), L), i5 = u(), n2 = await this._enqueueQuery(e, t3);
    let a = 0;
    for (const r3 of n2.items) r3.getBounds(i5) && (M(o, i5), a += 1);
    return { count: a, extent: Y(o, s3, e.outSR ? r(e.outSR) : s3, s3, false) };
  }
  _getFeatureCount() {
    return Array.from(this._fileInfos.values()).reduce((e, t3) => e + t3.file.numRows(), 0);
  }
  _validateQuery(e) {
    if (!this._capabilities.query.supportsStatistics && e.outStatistics) throw new s("parquet:unsupported", "Statistics queries are not supported", { query: e });
    if (!this._capabilities.query.supportsOrderBy && e.orderByFields?.length) throw new s("parquet:unsupported", "Queries using orderBy are not supported", { query: e });
    if (!this._capabilities.query.supportsDistinct && e.returnDistinctValues) throw new s("parquet:unsupported", "Queries using returnDistinctValues are not supported", { query: e });
  }
  async *_fetchChunks(e, t3) {
    for (const s3 of this._fileInfos.values()) {
      const r3 = s3.file.numRows(), o = Math.ceil(r3 / P);
      for (let i5 = 0; i5 < o; i5++) {
        const r4 = i5 * P, o2 = await s3.file.readChunk(r4, P, e.fields, e.returnGeometry, t3);
        for (const e2 of o2) {
          const t4 = new i3(this._metadata, this._fieldsIndex, e2, 0, s3.index), r5 = M2([new t(t4, null, 0, false)], this._queryEngineParams);
          yield r5;
        }
      }
    }
  }
  _enqueueQuery(e, t3) {
    return this._queue.push(e, t3);
  }
  async _executeQuery(e, t3) {
    const s3 = await this._getReadParams(e);
    if (e.objectIds?.length) for (const n2 of this._fileInfos.values()) {
      const r4 = [], o2 = M2((await n2.file.readChunksByRowId(new Uint32Array(e.objectIds), s3.fields, s3.returnGeometry, t3)).map((e2, t4) => new i3(this._metadata, this._fieldsIndex, e2, t4, n2.index)).map((e2, t4) => new t(e2, null, t4, false)), this._queryEngineParams), i6 = await o2.executeQueryForOpaqueFeatures(e, t3);
      for (const e2 of i6) r4.push(e2);
      return new E(r4, e, { fieldsIndex: this._fieldsIndex, geometryType: this._metadata.geometryType, spatialReference: this._queryEngineParams.spatialReference, objectIdField: "rowId", hasM: false, hasZ: false, featureAdapter: A });
    }
    let r3 = e.resultRecordCount ?? this._getFeatureCount(), o = e.resultOffset ?? 0;
    delete e.resultRecordCount, delete e.resultOffset;
    const i5 = [];
    for await (const n2 of this._fetchChunks(s3, t3)) {
      const s4 = await n2.executeQueryForOpaqueFeatures(e, t3);
      if (s4.length > o) {
        const t4 = s4.slice(o, Math.min(o + r3, s4.length));
        for (const e2 of t4) i5.push(e2);
        if (o = 0, r3 -= t4.length, 0 === r3) return new E(i5, e, { fieldsIndex: this._fieldsIndex, geometryType: this._metadata.geometryType, spatialReference: this._queryEngineParams.spatialReference, objectIdField: "rowId", hasM: false, hasZ: false, featureAdapter: A });
      } else o -= s4.length;
    }
    return new E(i5, e, { fieldsIndex: this._fieldsIndex, geometryType: this._metadata.geometryType, spatialReference: this._queryEngineParams.spatialReference, objectIdField: "rowId", hasM: false, hasZ: false, featureAdapter: A });
  }
  async _getReadParams(e) {
    const t3 = /* @__PURE__ */ new Set();
    if (e.where && await S(t3, this._fieldsIndex, e.where), e.outStatistics) for (const s3 of e.outStatistics) null != s3.onStatisticField && t3.add(s3.onStatisticField);
    if (e.outFields) for (const s3 of e.outFields) t3.add(s3);
    return { fields: this._getAttributeIds(Array.from(t3)), returnGeometry: !!e.returnGeometry || !!e.geometry };
  }
  _getAttributeIds(e) {
    if (null == e) return new Uint32Array();
    if (e.includes("*")) return new Uint32Array(this._fieldsIndex.fields.map((e2) => e2.column).filter((e2) => null != e2));
    const t3 = [];
    for (const s3 of e) {
      const e2 = this._fieldsIndex.get(s3);
      if (null == e2) throw new s("unknown-field", `Field ${s3} does not exist`);
      null == e2.column || t3.push(e2.column);
    }
    return new Uint32Array(t3);
  }
};
function G(e) {
  return Object.keys(e).some((e2) => D(e2));
}
function D(e) {
  switch (e) {
    case "resultOffset":
    case "resultRecordCount":
    case "aggregateIds":
    case "distance":
    case "gdbVersion":
    case "geometry":
    case "having":
    case "timeExtent":
    case "where":
    case "objectIds":
    case "historicMoment":
      return true;
    default:
      return false;
  }
}
function M2(e, t3) {
  const s3 = new n();
  for (const r3 of e) s3.insert(r3);
  return new W({ ...t3, featureStore: s3 });
}
function U(e) {
  switch (e.length) {
    case 4:
      return B(u(), e);
    case 6:
      return e;
    default:
      throw new s("parquet:protocol-violation", "Invalid Geoparquet file. BoundingBox size must be 4 or 6.", { bbox: e });
  }
}
function k2(e, t3) {
  const s3 = k(u(), L);
  for (const r3 of e) {
    const e2 = w(r3.file);
    if (!e2) return null;
    const t4 = e2.columns[e2.primary_column];
    if (!t4.bbox) return null;
    const o = U(t4.bbox);
    M(s3, o);
  }
  return { xmin: s3[0], ymin: s3[1], xmax: s3[3], ymax: s3[4], spatialReference: t3 };
}
function N(e) {
  const t3 = e?.featureCount;
  let s3 = false;
  return null != t3 && t3 < has("parquetlayer-full-query-feature-count") && (s3 = true), { analytics: { supportsCacheHint: false }, attachment: null, data: { isVersioned: false, isBranchVersioned: false, supportsAttachment: false, supportsM: false, supportsZ: false }, metadata: { supportsAdvancedFieldProperties: false }, operations: { supportsCalculate: false, supportsTruncate: false, supportsValidateSql: false, supportsAdd: false, supportsDelete: false, supportsEditing: false, supportsChangeTracking: false, supportsQuery: true, supportsQueryBins: false, supportsQueryPivot: false, supportsQueryAnalytics: false, supportsQueryAttachments: false, supportsQueryTopFeatures: false, supportsResizeAttachments: false, supportsSync: false, supportsUpdate: false, supportsExceedsLimitStatistics: false, supportsAsyncConvert3D: false }, query: { maxRecordCount: 8e3, maxRecordCountFactor: void 0, maxUniqueIDCount: void 0, standardMaxRecordCount: void 0, supportsCacheHint: false, supportsCentroid: true, supportsCentroidOnDegeneratedQuantizedGeometry: false, supportsCurrentUser: false, supportsDegeneratedQuantizedGeometry: false, supportsDisjointSpatialRelationship: false, supportsDistance: false, supportsDistinct: s3, supportsExtent: false, supportsFormatPBF: false, supportsGeometryProperties: false, supportsHavingClause: false, supportsHistoricMoment: false, supportsMaxRecordCountFactor: false, supportsOrderBy: s3, supportsPagination: true, supportsPaginationOnAggregatedQueries: false, supportsPercentileStatistics: false, supportsQuantization: true, supportsQuantizationEditMode: false, supportsQueryByAnonymous: false, supportsQueryByOthers: false, supportsQueryGeometry: false, supportsResultType: false, supportsReturnMesh: false, supportsStandardizedQueriesOnly: false, supportsTopFeaturesQuery: false, supportsStatistics: s3, supportsSpatialAggregationStatistics: false, supportedSpatialAggregationStatistics: { envelope: false, centroid: false, convexHull: false }, supportsDefaultSpatialReference: false, supportsFullTextSearch: false, supportsCompactGeometry: false, supportsSqlExpression: false, supportsTrueCurve: false, tileMaxRecordCount: void 0 }, queryAttributeBins: { supportsDate: false, supportsFixedInterval: false, supportsAutoInterval: false, supportsFixedBoundaries: false, supportsStackBy: false, supportsSplitBy: false, supportsSnapToData: false, supportsReturnFullIntervalBin: false, supportsFirstDayOfWeek: false, supportsNormalization: false }, queryRelated: { supportsCount: false, supportsOrderBy: false, supportsPagination: false, supportsCacheHint: false }, queryTopFeatures: { supportsCacheHint: false }, editing: { supportsDeleteByAnonymous: false, supportsDeleteByOthers: false, supportsGeometryUpdate: false, supportsGlobalId: false, supportsReturnServiceEditsInSourceSpatialReference: false, supportsRollbackOnFailure: false, supportsUpdateByAnonymous: false, supportsUpdateByOthers: false, supportsUploadWithItemId: false, supportsUpdateWithoutM: false, supportsAsyncApplyEdits: false, zDefault: void 0 } };
}
function z(e) {
  return !!(e.objectIds?.length || e.outStatistics || e.orderByFields?.length || e.returnDistinctValues);
}
export {
  T as default
};
//# sourceMappingURL=ParquetSourceWorker-G4WHZH22.js.map
