import {
  R,
  T as T2,
  U as U3,
  W as W2,
  b as b2,
  j as j3,
  k as k3,
  v as v2
} from "./chunk-QMZNFXS2.js";
import {
  I as I2,
  M as M2,
  Q,
  U as U5,
  V as V2,
  e as e4,
  g as g3,
  h as h3,
  j as j5,
  l as l6,
  o as o4,
  t as t5,
  t2 as t6,
  w as w4,
  w2 as w5,
  w3 as w6
} from "./chunk-K5ZF6G4K.js";
import {
  R as R4,
  y as y4
} from "./chunk-6AWERJZ7.js";
import {
  E as E2,
  H2 as H,
  J2,
  R as R3,
  V,
  r as r3
} from "./chunk-MLUR3X6U.js";
import {
  c as c5,
  l as l5
} from "./chunk-Y2GQGUGW.js";
import {
  R as R2,
  U as U4,
  j as j4,
  x as x3
} from "./chunk-VHCNEAMV.js";
import {
  v as v3
} from "./chunk-36YQJD5W.js";
import {
  Dt,
  Mt,
  Ut,
  Zt,
  de,
  dt,
  kt,
  me as me2
} from "./chunk-BQ6DEXWK.js";
import {
  f as f5,
  g as g2,
  h as h2
} from "./chunk-3SCRAN3E.js";
import {
  N as N2
} from "./chunk-NTNXXNRP.js";
import {
  t as t4
} from "./chunk-X4ZPIDID.js";
import {
  T,
  a as a5,
  c as c4,
  d as d2,
  q,
  v
} from "./chunk-IGRCAVBL.js";
import {
  E,
  I,
  U as U2,
  c as c3,
  i as i5,
  t as t3,
  x as x2,
  y as y3
} from "./chunk-GD72EK2J.js";
import {
  k as k2,
  x
} from "./chunk-6WSJV2UJ.js";
import {
  J,
  z
} from "./chunk-2EBLSEHZ.js";
import {
  n as n2
} from "./chunk-B3BLJNSM.js";
import {
  t as t2
} from "./chunk-ALKEERWI.js";
import {
  y as y2
} from "./chunk-FHCV4NTV.js";
import {
  t
} from "./chunk-QYAMBIRP.js";
import {
  a as a4,
  i as i4
} from "./chunk-NHFKDWOM.js";
import {
  c as c2
} from "./chunk-BZLHV37L.js";
import {
  c,
  g,
  o as o3,
  s,
  u as u3,
  w as w3
} from "./chunk-VYMBX5H5.js";
import {
  h
} from "./chunk-BPTFV5VM.js";
import {
  G,
  f as f4
} from "./chunk-XDLV73DB.js";
import {
  n as n3
} from "./chunk-36OXW4YN.js";
import {
  _ as _2
} from "./chunk-C3FRY5U4.js";
import {
  d
} from "./chunk-XL5QPCXN.js";
import {
  W
} from "./chunk-2LC2762W.js";
import {
  O
} from "./chunk-YDTPM7OQ.js";
import {
  a as a3,
  n,
  r as r2
} from "./chunk-75XOUSSS.js";
import {
  M,
  e as e3,
  f as f3,
  j as j2,
  k,
  l as l4,
  o as o2,
  u as u2
} from "./chunk-AZXJIEZ6.js";
import {
  U,
  j,
  l as l3,
  w as w2
} from "./chunk-2OFHDVO5.js";
import {
  i as i2,
  l as l2
} from "./chunk-TFJXG32O.js";
import {
  f as f2,
  i as i3
} from "./chunk-CSMCPN64.js";
import {
  r
} from "./chunk-SMWUT52Z.js";
import {
  _
} from "./chunk-AXZMNHTN.js";
import {
  f
} from "./chunk-5T3MJDSR.js";
import {
  ae,
  fe,
  me,
  ne
} from "./chunk-NMQNUPE4.js";
import {
  b,
  i3 as i,
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2,
  w
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  $,
  L,
  e,
  e2,
  l2 as l,
  o2 as o,
  u2 as u,
  y
} from "./chunk-GNMPGHLQ.js";
import {
  a
} from "./chunk-QY7XKUIV.js";
import {
  N
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/views/interactive/ManipulatorCollection.js
var a6 = class {
  constructor() {
    this._isToolEditable = true, this._manipulators = new O(), this._resourceContexts = { manipulator3D: {} }, this._attached = false;
  }
  set isToolEditable(t8) {
    this._isToolEditable = t8;
  }
  get length() {
    return this._manipulators.length;
  }
  add(t8, a8 = 0) {
    this.addMany([t8], a8);
  }
  addMany(t8, a8 = 0) {
    for (const i10 of t8) {
      const t9 = { manipulator: i10, visibilityPredicate: a8, attached: false };
      this._manipulators.add(t9), this._attached && this._updateManipulatorAttachment(t9);
    }
  }
  remove(t8) {
    for (let a8 = 0; a8 < this._manipulators.length; a8++) if (this._manipulators.at(a8).manipulator === t8) {
      const t9 = this._manipulators.splice(a8, 1)[0];
      this._detachManipulator(t9);
      break;
    }
  }
  removeAll() {
    this._manipulators.forEach((t8) => {
      this._detachManipulator(t8);
    }), this._manipulators.removeAll();
  }
  attach() {
    this._manipulators.forEach((t8) => {
      this._updateManipulatorAttachment(t8);
    }), this._attached = true;
  }
  detach() {
    this._manipulators.forEach((t8) => {
      this._detachManipulator(t8);
    }), this._attached = false;
  }
  destroy() {
    this.detach(), this._manipulators.forEach(({ manipulator: t8 }) => t8.destroy()), this._manipulators.destroy(), this._resourceContexts = null;
  }
  on(t8, a8) {
    return this._manipulators.on(t8, (t9) => {
      a8(t9);
    });
  }
  forEach(t8) {
    for (const a8 of this._manipulators.items) t8(a8);
  }
  some(t8) {
    return this._manipulators.items.some(t8);
  }
  toArray() {
    const t8 = [];
    return this.forEach((a8) => t8.push(a8.manipulator)), t8;
  }
  intersect(t8, a8) {
    let i10 = null, e8 = Number.MAX_VALUE;
    return this._manipulators.forEach(({ manipulator: s4, attached: r7 }) => {
      if (!r7 || !s4.interactive) return;
      const o6 = s4.intersectionDistance(t8, a8);
      null != o6 && o6 < e8 && (e8 = o6, i10 = s4);
    }), i10;
  }
  _updateManipulatorAttachment(t8) {
    this._isManipulatorItemVisible(t8) ? this._attachManipulator(t8) : this._detachManipulator(t8);
  }
  _attachManipulator(t8) {
    t8.attached || (t8.manipulator.attach && t8.manipulator.attach(this._resourceContexts), t8.attached = true);
  }
  _detachManipulator(t8) {
    if (!t8.attached) return;
    const a8 = t8.manipulator;
    a8.grabbing = false, a8.dragging = false, a8.hovering = false, a8.selected = false, a8.detach && a8.detach(this._resourceContexts), t8.attached = false;
  }
  _isManipulatorItemVisible(t8) {
    return 2 === t8.visibilityPredicate || (this._isToolEditable ? 0 === t8.visibilityPredicate : 1 === t8.visibilityPredicate);
  }
};

// node_modules/@arcgis/core/views/interactive/InteractiveToolBase.js
var r4 = class extends l2 {
  constructor(t8) {
    super(t8), this.manipulators = new a6(), this.automaticManipulatorSelection = true, this.hasGrabbedManipulators = false, this.hasHoveredManipulators = false, this.firstGrabbedManipulator = null, this.created = false, this.removeIncompleteOnCancel = true, this._editableFlags = /* @__PURE__ */ new Map([[1, true], [0, true]]), this._creationFinishedResolver = $();
  }
  get active() {
    return null != this.view && this.view.activeTool === this;
  }
  set visible(t8) {
    this._get("visible") !== t8 && (this._set("visible", t8), this._syncVisible());
  }
  get editable() {
    return this.getEditableFlag(0);
  }
  set editable(t8) {
    this.setEditableFlag(0, t8);
  }
  get updating() {
    return false;
  }
  get cursor() {
    return null;
  }
  get hasFocusedManipulators() {
    return this.hasGrabbedManipulators || this.hasHoveredManipulators;
  }
  destroy() {
    this.manipulators.destroy(), this._set("view", null);
  }
  onAdd() {
    this._syncVisible();
  }
  activate() {
    null != this.view && (this.view.focus(), this.onActivate());
  }
  deactivate() {
    this.onDeactivate();
  }
  cancel() {
    this.emit("cancel");
  }
  handleInputEvent(t8) {
    this.onInputEvent(t8);
  }
  handleInputEventAfter(t8) {
    this.onInputEventAfter(t8);
  }
  setEditableFlag(t8, e8) {
    this._editableFlags.set(t8, e8), this.manipulators.isToolEditable = this.internallyEditable, this._updateManipulatorAttachment(), 0 === t8 && this.notifyChange("editable"), this.onEditableChange(), this.onManipulatorSelectionChanged();
  }
  getEditableFlag(t8) {
    return this._editableFlags.get(t8) ?? false;
  }
  endDrag() {
    const t8 = this.view.inputManager.latestPointerInfo?.location;
    if (!t8) return;
    let e8 = false;
    this.manipulators.forEach(({ manipulator: i10 }) => {
      i10.dragging && (e8 = true, i10.events.emit("drag", { action: "end", start: t8, screenPoint: t8 }));
    }), e8 && (this.view.toolViewManager.activeTool = null);
  }
  whenCreated() {
    return this._creationFinishedResolver.promise;
  }
  onManipulatorSelectionChanged() {
  }
  onActivate() {
  }
  onDeactivate() {
  }
  onShow() {
  }
  onHide() {
  }
  onEditableChange() {
  }
  onInputEvent(t8) {
  }
  onInputEventAfter(t8) {
  }
  get internallyEditable() {
    return this.getEditableFlag(0) && this.getEditableFlag(1);
  }
  finishToolCreation() {
    this.created || this._creationFinishedResolver.resolve(this), this._set("created", true);
  }
  _syncVisible() {
    if (this.initialized) {
      if (this.visible) this._show();
      else if (this._hide(), this.active) return void (this.view.activeTool = null);
    }
  }
  _show() {
    this._updateManipulatorAttachment(), this.onShow();
  }
  _hide() {
    this._updateManipulatorAttachment(), this.onHide();
  }
  _updateManipulatorAttachment() {
    this.visible ? this.manipulators.attach() : this.manipulators.detach();
  }
};
__decorate([m({ constructOnly: true })], r4.prototype, "view", void 0), __decorate([m({ readOnly: true })], r4.prototype, "active", null), __decorate([m({ value: true })], r4.prototype, "visible", null), __decorate([m({ value: true })], r4.prototype, "editable", null), __decorate([m({ readOnly: true })], r4.prototype, "manipulators", void 0), __decorate([m({ readOnly: true })], r4.prototype, "updating", null), __decorate([m()], r4.prototype, "cursor", null), __decorate([m({ readOnly: true })], r4.prototype, "automaticManipulatorSelection", void 0), __decorate([m()], r4.prototype, "hasFocusedManipulators", null), __decorate([m()], r4.prototype, "hasGrabbedManipulators", void 0), __decorate([m()], r4.prototype, "hasHoveredManipulators", void 0), __decorate([m()], r4.prototype, "firstGrabbedManipulator", void 0), __decorate([m({ readOnly: true })], r4.prototype, "created", void 0), __decorate([m({ readOnly: true })], r4.prototype, "removeIncompleteOnCancel", void 0), r4 = __decorate([a2("esri.views.interactive.InteractiveToolBase")], r4);

// node_modules/@arcgis/core/undoredo/UndoRedoError.js
var r5 = { UndoRedoUpdating: "Cannot perform operation whilst undo redo is updating", UndoInvalidError: "There are no items to Undo", RedoInvalidError: "There are no items to Redo", ApplyInvalidError: "Cannot apply an item that is already applied" };
var o5 = class extends Error {
  constructor() {
    super(r5.UndoRedoUpdating), this.type = "undo-redo-updating-error";
  }
};
var e5 = class extends Error {
  constructor() {
    super(r5.UndoInvalidError), this.type = "undo-redo-undo-error";
  }
};
var d3 = class extends Error {
  constructor() {
    super(r5.RedoInvalidError), this.type = "undo-redo-redo-error";
  }
};

// node_modules/@arcgis/core/UndoRedo.js
var h4 = class extends b {
  constructor() {
    super(...arguments), this._stack = new O(), this._stackPosition = -1, this._updatingHandles = new h();
  }
  get updating() {
    return this._updatingHandles.updating;
  }
  get canUndo() {
    return this.hasUndo && !this.updating;
  }
  get hasUndo() {
    return this._stackPosition >= 0;
  }
  get canRedo() {
    return this.hasRedo && !this.updating;
  }
  get hasRedo() {
    return this._stackPosition < this._stack.length - 1;
  }
  _truncateForwardStack() {
    this._stack.splice(this._stackPosition + 1, this._stack.length - this._stackPosition).forEach((t8) => t8.destroy());
  }
  _drainStack() {
    this._stack.drain((t8) => t8.destroy()), this._stackPosition = -1;
  }
  async undo() {
    if (!this.hasUndo) throw new e5();
    if (this.updating) throw new o5();
    const t8 = this._stack.getItemAt(this._stackPosition);
    t8 && await this._updatingHandles.addPromise((async () => {
      await t8.executeUndoRedoOperation(1), --this._stackPosition, t8.canRedo || this._truncateForwardStack();
    })());
  }
  async redo() {
    if (!this.hasRedo) throw new d3();
    if (this.updating) throw new o5();
    const t8 = this._stack.getItemAt(this._stackPosition + 1);
    if (!t8) throw new d3();
    await this._updatingHandles.addPromise((async () => {
      await t8.executeUndoRedoOperation(2), ++this._stackPosition;
    })());
  }
  peekUndo() {
    if (this.canUndo) return this._stack.getItemAt(this._stackPosition);
  }
  peekRedo() {
    if (this.canRedo) return this._stack.getItemAt(this._stackPosition + 1);
  }
  async inject(t8) {
    if (this.updating) throw new o5();
    await this._updatingHandles.addPromise((async () => {
      0 === t8.status && await t8.executeUndoRedoOperation(0), t8.canUndo ? (this._stack.splice(this._stackPosition + 1, 0, t8), this._stackPosition++) : this._stackPosition > -1 && (this._stack.splice(0, this._stackPosition + 1).forEach((t9) => t9.destroy()), this._stackPosition = -1);
    })());
  }
  async add(t8) {
    if (this.updating) throw new o5();
    await this._updatingHandles.addPromise((async () => {
      0 === t8.status && await t8.executeUndoRedoOperation(0), this._stackPosition >= -1 && this._truncateForwardStack(), t8.canUndo ? (this._stack.push(t8), this._stackPosition = this._stack.length - 1) : this._drainStack();
    })());
  }
  async removeTagged(t8, s4 = false) {
    if (this.updating && !s4) return;
    await j(() => !this.updating);
    const a8 = new O();
    for (let i10 = 0; i10 < this._stack.length; i10++) {
      const s5 = this._stack.getItemAt(i10);
      s5 && (s5.tag === t8 ? (s5.destroy(), i10 === this._stackPosition && (this._stackPosition = a8.length - 1)) : a8.push(s5));
    }
    this._stack = a8, this._stackPosition > a8.length - 1 && (this._stackPosition = a8.length - 1);
  }
  async clear(t8 = false) {
    if (this.updating && !t8) throw new o5();
    await j(() => !this.updating), this._drainStack();
  }
};
__decorate([m()], h4.prototype, "_stack", void 0), __decorate([m()], h4.prototype, "_stackPosition", void 0), __decorate([m()], h4.prototype, "updating", null), __decorate([m({ readOnly: true })], h4.prototype, "canUndo", null), __decorate([m({ readOnly: true })], h4.prototype, "hasUndo", null), __decorate([m({ readOnly: true })], h4.prototype, "canRedo", null), __decorate([m({ readOnly: true })], h4.prototype, "hasRedo", null), h4 = __decorate([a2("esri.UndoRedo")], h4);

// node_modules/@arcgis/core/views/draw/support/CreateOperationGeometry.js
var l7 = class {
  constructor() {
    this.committedVertices = null, this.cursorVertex = null, this.full = null, this.outline = null, this.cursorEdge = null, this.circle = null, this.rectangle = null;
  }
};

// node_modules/@arcgis/core/views/draw/support/helpMessageUtils.js
function e6(e8, i10, a8) {
  if (null == e8) return "noTool";
  switch (e8) {
    case "point":
      return n4();
    case "multipoint":
      return "multipoint";
    case "polyline":
      return r6(i10, a8);
    case "polygon":
      return t7(i10, a8);
    case "rectangle":
    case "circle":
      return l8(i10, a8);
    default:
      return;
  }
}
function n4(e8) {
  return "point";
}
function r6(e8, n5) {
  const r7 = null != e8 && "polyline" === e8.type && e8.paths.length ? e8.paths[0].length : 0;
  return "freehand" === n5 ? r7 < 2 ? "freehandStart" : "freehandEnd" : r7 < 2 ? "polylineZeroVertices" : "polylineOneVertex";
}
function t7(e8, n5) {
  const r7 = null != e8 && "polygon" === e8.type && e8.rings.length ? e8.rings[0].length : 0;
  if (r7 < 3) switch (n5) {
    case "freehand":
      return "freehandStart";
    case "hybrid":
      return "polygonZeroVerticesHybrid";
    default:
      return "polygonZeroVertices";
  }
  else if (r7 < 4) return "freehand" === n5 ? "freehandEnd" : "polygonOneVertex";
  return "polygonTwoVertices";
}
function l8(e8, n5) {
  if ((null != e8 && "polygon" === e8.type && e8.rings.length ? e8.rings[0].length : 0) < 3) switch (n5) {
    case "freehand":
      return "freehandStart";
    case "click":
      return "shapeStartClick";
    default:
      return "shapeStartHybrid";
  }
  switch (n5) {
    case "freehand":
      return "freehandEnd";
    case "click":
      return "shapeEndClick";
    default:
      return "shapeEndHybrid";
  }
}

// node_modules/@arcgis/core/views/draw/support/helpMessageUtils3d.js
function s2(r7, s4) {
  const l11 = r7?.geometry;
  if (!r7 || "mesh" !== l11?.type || !s4) return;
  const { renderCoordsHelper: f8, elevationProvider: p5 } = s4, { camera: u5 } = s4.state, { extent: d6 } = l11, { center: x6, spatialReference: g6 } = d6, v7 = ae(g6), j8 = ne(g6), z6 = ae(f8.spatialReference), R7 = d6.width * v7, y7 = d6.height * j8, C3 = (d6.zmax ?? 0) * j8, U9 = C3 - (d6.zmin ?? 0) * j8, b5 = Math.max(R7, y7, U9) / z6, { x: w8, y: M6 } = x6, P4 = x6.z ?? 0;
  o3(h5, w8, M6, P4), f8.toRenderCoords(h5, g6, h5);
  const S5 = b5 / u5.computeScreenPixelSizeAt(h5);
  if (S5 > Math.min(u5.width, u5.height) / u5.pixelRatio * a7) return "meshTooClose";
  if (S5 < m2) return "meshTooFar";
  const T6 = c3(r7), { absoluteZ: k6 } = y3(w8, M6, C3, g6, s4, T6);
  return k6 < (p5.getElevation(w8, M6, P4, g6, "ground") ?? 0) * j8 + U9 * c6 ? "meshUnderground" : "mesh";
}
var m2 = 20;
var a7 = 1;
var c6 = 0.1;
var h5 = n();

// node_modules/@arcgis/core/views/interactive/sketch/constraintUtils.js
function b3(e8, n5, t8, r7, o6, i10) {
  let l11 = "geodesic", u5 = N2(t8);
  const s4 = f5();
  return h2(e8, n5, r7, s4), s4[2] = 0, u5 && n2(s4, t8, s4, u5) || (l11 = "euclidean", u5 = t8), { mode: l11, view: n5, elevationInfo: r7, hasZ: o6, directionMode: i10, spatialReference: e8.spatialReference, measurementSR: u5, origin: s4 };
}
function M3(n5, t8, o6) {
  if (null == t8 || null == n5) return;
  const i10 = me(o6.measurementSR);
  if (null == i10) return;
  const l11 = W3(n5, o6);
  if (null == l11) return;
  const u5 = v(t8, i10);
  return new kt(l11, u5);
}
function Z(e8, t8, r7, o6) {
  if (null == r7 || null == e8) return;
  const i10 = W3(e8, o6);
  if (null == i10) return;
  const l11 = R2(r7), u5 = 10, s4 = (e9) => {
    if (null == e9) return;
    const t9 = f5(), r8 = c4(e9, "degrees", "geographic");
    return U4(t9, i10, o6.measurementSR, u5, r8, o6.mode) ? new Dt(i10, t9) : void 0;
  }, c9 = () => {
    if (null != t8 && null != e8) return R2(j4(t8, e8));
  };
  switch (o6.directionMode) {
    case "absolute":
      return s4(l11);
    case "relative": {
      const e9 = c9();
      if (null == e9) return;
      return s4(e9 + l11);
    }
    case "relative-bilateral": {
      const e9 = c9();
      if (null == e9) return;
      return de([s4(e9 + l11), s4(e9 - l11)]);
    }
  }
}
function P(e8, n5) {
  const t8 = B(e8, n5);
  return null != t8 ? new Mt(t8) : void 0;
}
function T3(e8, n5, t8) {
  const { context: r7, longitude: o6, latitude: i10, direction: l11, distance: u5, elevation: s4 } = t8;
  if (null != o6 || null != i10 || null != u5 || null != s4 || null != l11) {
    if (null != o6 || null != i10) {
      const e9 = R2(o6), n6 = R2(i10), t9 = B(s4, r7);
      return new Zt(e9, n6, t9);
    }
    return V3(e8, n5, t8);
  }
}
function V3(n5, t8, { context: r7, direction: o6, distance: i10, elevation: l11 }) {
  if (null == t8) return P(l11, r7);
  const { view: u5, elevationInfo: s4, measurementSR: a8 } = r7, f8 = h2(t8, u5, s4);
  if (!a8 || !n2(f8, t8.spatialReference, D, a8)) return;
  const [m5, d6] = D, p5 = null != i10 ? v(i10, "meters") : void 0, g6 = R2(o6), R7 = B(l11, r7), y7 = (e8) => {
    const n6 = new Ut([m5, d6], a8, p5, R7, e8);
    return null == p5 || null == e8 || null == R7 && r7.hasZ ? n6 : new dt(n6.closestTo(f8));
  };
  if (null == g6) return y7(void 0);
  const x6 = () => {
    if (null != n5 && null != t8) return R2(j4(n5, t8));
  };
  switch (r7.directionMode) {
    case "absolute":
      return y7(g6);
    case "relative": {
      const e8 = x6();
      if (null == e8) return;
      return y7(e8 + g6);
    }
    case "relative-bilateral": {
      const e8 = x6();
      if (null == e8) return;
      return de([y7(e8 + g6), y7(e8 - g6)]);
    }
  }
}
function k4(e8) {
  return "geodesic" === e8.context.mode ? T3(null, null, e8) : z2(e8);
}
function q2(e8, n5, t8) {
  const { context: r7, x: o6, y: i10, distance: l11, direction: u5, elevation: s4 } = t8;
  return "geodesic" === r7.mode ? T3(n5, e8, t8) : null != o6 || null != i10 ? z2(t8) : G2([M3(e8, l11, r7), Z(e8, n5, u5, r7), P(s4, r7)]);
}
function z2({ x: e8, y: n5, elevation: t8, context: r7 }) {
  H2.x = e8?.value ?? 0, H2.y = n5?.value ?? 0, H2.spatialReference = r7.spatialReference;
  const o6 = W3(H2, r7, E3);
  return new Zt(null != e8 && null != o6 ? o6[0] : void 0, null != n5 && null != o6 ? o6[1] : void 0, B(t8, r7));
}
function G2(e8) {
  let n5;
  for (const t8 of e8) t8 && (n5 = n5?.intersect(t8) ?? t8);
  return n5;
}
function W3(e8, n5, t8 = f5()) {
  const { view: r7, elevationInfo: o6, measurementSR: l11, origin: u5, mode: s4 } = n5;
  if (h2(e8, r7, o6, t8), n2(t8, e8.spatialReference, t8, l11)) return "geodesic" !== s4 && c(t8, t8, u5), t8;
}
function A(e8, n5, t8, r7) {
  const { view: o6, measurementSR: i10, spatialReference: s4, origin: a8, mode: f8 } = t8;
  if ("geodesic" === f8 ? s(F, e8) : u3(F, e8, a8), n2(F, i10, F, s4)) return g2(F, o6, n5, t8, r7);
}
function B(e8, n5) {
  return C(e8, n5)?.value ?? void 0;
}
function C(n5, { view: r7, origin: i10, elevationInfo: l11, hasZ: u5, measurementSR: s4 }) {
  if (null == n5 || !u5) return;
  const c9 = fe(s4);
  if (null == c9) return;
  const [a8, f8] = i10, d6 = v(n5, c9), p5 = "3d" === r7?.type ? I(r7, a8, f8, d6, s4, l11) : d6;
  return null != p5 ? a5(p5, c9) : void 0;
}
var D = f5();
var E3 = f5();
var F = f5();
var H2 = t2(0, 0, 0, f.WGS84);

// node_modules/@arcgis/core/views/interactive/tooltip/infos/DrawCircleTooltipInfo.js
var s3 = class extends r3 {
  constructor(o6) {
    super(o6), this.type = "draw-circle", this.radius = null, this.xSize = null, this.ySize = null, this.area = T;
  }
  get allFields() {
    return [];
  }
};
__decorate([m()], s3.prototype, "type", void 0), __decorate([m()], s3.prototype, "radius", void 0), __decorate([m()], s3.prototype, "xSize", void 0), __decorate([m()], s3.prototype, "ySize", void 0), __decorate([m()], s3.prototype, "area", void 0), __decorate([m()], s3.prototype, "helpMessage", void 0), __decorate([m()], s3.prototype, "allFields", null), s3 = __decorate([a2("esri.views.interactive.tooltip.infos.DrawCircleTooltipInfo")], s3);

// node_modules/@arcgis/core/views/interactive/tooltip/infos/DrawMeshTooltipInfo.js
var p = class extends h3(r3) {
  constructor(o6) {
    super(o6), this.type = "draw-mesh", this.orientation = M2({ lockable: false }), this.scale = j5({ lockable: false });
  }
  get allFields() {
    return [this.longitude, this.latitude, this.x, this.y, this.elevation, this.orientation, this.scale];
  }
};
__decorate([m()], p.prototype, "helpMessage", void 0), __decorate([m()], p.prototype, "allFields", null), p = __decorate([a2("esri.views.interactive.tooltip.infos.DrawMeshTooltipInfo")], p);

// node_modules/@arcgis/core/views/interactive/tooltip/infos/DrawMultipointTooltipInfo.js
var i6 = class extends h3(r3) {
  constructor(o6) {
    super(o6), this.type = "draw-multipoint";
  }
  get allFields() {
    return [this.longitude, this.latitude, this.x, this.y, this.elevation];
  }
};
__decorate([m()], i6.prototype, "helpMessage", void 0), __decorate([m()], i6.prototype, "allFields", null), i6 = __decorate([a2("esri.views.interactive.tooltip.infos.DrawMultipointTooltipInfo")], i6);

// node_modules/@arcgis/core/views/interactive/tooltip/infos/DrawPointTooltipInfo.js
var i7 = class extends h3(r3) {
  constructor(o6) {
    super(o6), this.type = "draw-point";
  }
  get allFields() {
    return [this.longitude, this.latitude, this.x, this.y, this.elevation];
  }
};
__decorate([m()], i7.prototype, "helpMessage", void 0), __decorate([m()], i7.prototype, "allFields", null), i7 = __decorate([a2("esri.views.interactive.tooltip.infos.DrawPointTooltipInfo")], i7);

// node_modules/@arcgis/core/views/interactive/tooltip/infos/DrawPolygonTooltipInfo.js
var l9 = class extends h3(r3) {
  constructor(o6) {
    super(o6), this.type = "draw-polygon", this.direction = I2(), this.distance = w4(), this.area = Q(), this.xyMode = "direction-distance";
  }
  get allFields() {
    return [this.direction, this.distance, this.longitude, this.latitude, this.x, this.y, this.elevation, this.area];
  }
};
__decorate([m()], l9.prototype, "xyMode", void 0), __decorate([m()], l9.prototype, "helpMessage", void 0), __decorate([m()], l9.prototype, "allFields", null), l9 = __decorate([a2("esri.views.interactive.tooltip.infos.DrawPolygonTooltipInfo")], l9);

// node_modules/@arcgis/core/views/interactive/tooltip/infos/DrawPolylineTooltipInfo.js
var c7 = class extends h3(r3) {
  constructor(t8) {
    super(t8), this.type = "draw-polyline", this.direction = I2(), this.distance = w4(), this.totalLength = U5(), this.xyMode = "direction-distance";
  }
  get allFields() {
    return [this.direction, this.distance, this.longitude, this.latitude, this.x, this.y, this.elevation, this.totalLength];
  }
};
__decorate([m()], c7.prototype, "helpMessage", void 0), __decorate([m()], c7.prototype, "xyMode", void 0), __decorate([m()], c7.prototype, "allFields", null), c7 = __decorate([a2("esri.views.interactive.tooltip.infos.DrawPolylineTooltipInfo")], c7);

// node_modules/@arcgis/core/views/interactive/tooltip/infos/DrawRectangleTooltipInfo.js
var p2 = class extends r3 {
  constructor(o6) {
    super(o6), this.type = "draw-rectangle", this.xSize = d2, this.ySize = d2, this.area = T;
  }
  get allFields() {
    return [];
  }
};
__decorate([m()], p2.prototype, "type", void 0), __decorate([m()], p2.prototype, "xSize", void 0), __decorate([m()], p2.prototype, "ySize", void 0), __decorate([m()], p2.prototype, "area", void 0), __decorate([m()], p2.prototype, "helpMessage", void 0), __decorate([m()], p2.prototype, "allFields", null), p2 = __decorate([a2("esri.views.interactive.tooltip.infos.DrawRectangleTooltipInfo")], p2);

// node_modules/@arcgis/core/views/draw/support/tooltipUtils.js
function D2(e8, t8) {
  return { point: new i7({ sketchOptions: t8, viewType: e8 }), multipoint: new i6({ sketchOptions: t8, viewType: e8 }), polyline: new c7({ sketchOptions: t8, viewType: e8 }), polygon: new l9({ sketchOptions: t8, viewType: e8 }), mesh: new p({ sketchOptions: t8, viewType: e8 }), rectangle: new p2({ sketchOptions: t8 }), circle: new s3({ sketchOptions: t8 }) };
}
function T4(e8) {
  const { directionOptions: t8, geometryType: o6, sketchOptions: n5, tooltipInfos: i10 } = e8, r7 = (t9) => {
    const o7 = N3(e8).mode, n6 = i10[t9].elevation;
    "relative-to-ground" === o7 || "relative-to-scene" === o7 || "on-the-ground" === o7 ? n6.lock(W4(e8)) : n6.unlock();
  }, a8 = (e9) => {
    if (t8) {
      const o7 = i10[e9].direction;
      o7.committed = t8.angle, o7.unlockOnVertexPlacement = false, n5.values.directionMode = t8.mode;
    }
  };
  switch (o6) {
    case "polygon":
    case "polyline":
      r7(o6), a8(o6);
      break;
    case "point":
    case "mesh":
      r7(o6);
  }
}
function j6(e8, t8) {
  const { drawOperation: o6, view: n5 } = t8, i10 = b4(t8), r7 = N3(t8);
  if ("2d" === n5.type || !e8 || "absolute-height" !== r7.mode || 1 !== o6?.numCommittedVertices || !i10 || "draw-polyline" !== i10.type && "draw-polygon" !== i10.type || i10.elevation.locked) return;
  const [a8, c9, l11] = e8, s4 = K(a8, c9, l11, r7, t8);
  null != s4 && i10.elevation.lock(s4);
}
function U6(e8) {
  b4(e8)?.allFields.forEach((e9) => {
    e9.unlockOnVertexPlacement && e9.unlock();
  });
}
function b4({ geometryType: e8, graphic: t8, tooltipInfos: o6 }) {
  return t8?.geometry?.type !== P2[e8] ? "circle" === e8 || "rectangle" === e8 ? o6[e8] : null : o6[e8];
}
var P2 = { point: "point", multipoint: "multipoint", mesh: "mesh", polyline: "polyline", polygon: "polygon", circle: "polygon", rectangle: "polygon", freehandPolygon: "polygon", freehandPolyline: "polyline", text: "point" };
function I3(e8, t8) {
  switch (e8?.type) {
    case "draw-point":
      L2(e8, t8);
      break;
    case "draw-multipoint":
      V4(e8, t8);
      break;
    case "draw-polyline":
      z3(e8, t8);
      break;
    case "draw-polygon":
      A2(e8, t8);
      break;
    case "draw-rectangle":
      F2(e8, t8);
      break;
    case "draw-circle":
      H3(e8, t8);
      break;
    case "draw-mesh":
      G3(e8, t8);
  }
}
function L2(e8, t8) {
  const o6 = t8.graphic?.geometry;
  "point" === o6?.type && (S(e8, o6, t8), e8.helpMessage = e6("point", o6, t8.drawOperation.drawingMode));
}
function V4(e8, t8) {
  const o6 = t8.graphic?.geometry;
  "multipoint" === o6?.type && (S(e8, o6, t8), e8.helpMessage = e6("multipoint", o6, t8.drawOperation.drawingMode));
}
function G3(e8, t8) {
  const { graphic: o6, view: n5 } = t8, i10 = o6?.geometry;
  "3d" !== n5.type || i10 && "mesh" !== i10.type || (S(e8, i10?.origin, t8), i10 && V(e8, i10), e8.helpMessage = s2(o6, n5));
}
function S(e8, t8, o6) {
  const { drawOperation: n5, view: i10, sketchOptions: r7 } = o6, { cursorVertex: a8 } = n5;
  e8.sketchOptions = r7, e8.viewType = i10.type;
  const c9 = "multipoint" === t8?.type ? t8.getPoint(t8.points.length - 1) : t8;
  if (e8.setLocationFromPoint(c9, Q2(o6)), R5(e8.elevation, o6), !a8) return void (n5.constraints = void 0);
  const l11 = a8;
  n5.constraints = { context: $2(l11, o6), x: e8.x.committed, y: e8.y.committed, longitude: e8.longitude.committed, latitude: e8.latitude.committed, elevation: e8.elevation.committed, distance: null, direction: null };
}
function z3(e8, t8) {
  const { createOperationGeometry: n5, drawOperation: i10, automaticLengthMeasurementUtils: r7 } = t8, a8 = null != n5 ? n5.full : null;
  a8 && "polyline" !== a8.type || (Z2(e8, t8), e8.totalLength.actual = i10.lastVertex ? (a8 ? r7.autoLength2D(a8) : null) ?? d2 : null, e8.helpMessage = e6("polyline", a8, t8.drawOperation.drawingMode));
}
function A2(e8, o6) {
  const { createOperationGeometry: n5, drawOperation: i10 } = o6, r7 = null != n5 ? n5.full : null;
  r7 && "polygon" !== r7.type || (Z2(e8, o6), e8.area.actual = i10.lastVertex ? (r7 ? o6.automaticAreaMeasurementUtils.autoArea2D(r7) : null) ?? T : null, e8.helpMessage = e6("polygon", r7, o6.drawOperation.drawingMode));
}
var B2 = w(_);
function Z2(e8, t8) {
  const { drawOperation: n5, sketchOptions: r7, view: a8, automaticLengthMeasurementUtils: c9 } = t8, { cursorVertex: l11, lastVertex: s4, secondToLastVertex: p5 } = n5, u5 = r7.values.effectiveDirectionMode;
  e8.sketchOptions = r7, e8.viewType = a8.type;
  const m5 = s4 && l11 ? c9.autoDistanceBetweenPoints2D(B2(s4), B2(l11)) ?? d2 : null;
  if (e8.distance.actual = m5, e8.distance.readOnly = null == s4, e8.direction.actual = null, e8.direction.readOnly = true, s4 && l11 && ("absolute" === u5 || p5)) {
    const t9 = x3(p5, s4, l11, u5);
    e8.direction.actual = t9 ?? q, e8.direction.readOnly = false;
  }
  e8.setLocationFromPoint(l11, Q2(t8)), R5(e8.elevation, t8);
  const d6 = C2(s4, t8);
  e8.xyMode = d6, e8.direction.visible = "direction-distance" === d6, e8.distance.visible = "direction-distance" === d6, e8.effectiveX.visible = "coordinates" === d6, e8.effectiveY.visible = "coordinates" === d6;
  const f8 = l11 ?? s4;
  n5.constraints = f8 ? { context: $2(f8, t8), x: e8.x.committed, y: e8.y.committed, longitude: e8.longitude.committed, latitude: e8.latitude.committed, elevation: e8.elevation.committed, distance: e8.distance.committed, direction: e8.direction.committed } : void 0;
}
function C2(e8, { sketchOptions: t8 }) {
  const o6 = t8.tooltips.xyMode;
  return "auto" === o6 ? e8 ? "direction-distance" : "coordinates" : o6;
}
function F2(e8, t8) {
  e8.sketchOptions = t8.sketchOptions, e8.xSize = E4(t8), e8.ySize = X(t8), e8.area = q3(t8), e8.helpMessage = e6("rectangle", t8.graphic?.geometry, t8.drawOperation.drawingMode);
}
function H3(e8, t8) {
  const { forceUniformSize: o6, sketchOptions: n5 } = t8;
  e8.sketchOptions = n5, e8.radius = o6 ? Y(t8) : null, e8.xSize = o6 ? null : E4(t8), e8.ySize = o6 ? null : X(t8), e8.area = q3(t8), e8.helpMessage = e6("circle", t8.graphic?.geometry, t8.drawOperation.drawingMode);
}
function R5(e8, t8) {
  const { drawOperation: o6 } = t8, n5 = o6?.cursorVertex ?? o6?.lastVertex;
  e8.actual = y4(n5) ?? W4(t8), e8.visible = o6.hasZ, e8.readOnly = false, e8.showAsZ = true;
}
function q3(e8) {
  const o6 = e8.createOperationGeometry?.full;
  return "polygon" !== o6?.type ? T : e8.automaticAreaMeasurementUtils.autoArea2D(o6) ?? T;
}
function E4({ createOperationGeometry: e8, automaticLengthMeasurementUtils: t8 }) {
  const n5 = e8?.rectangle?.midpoints;
  return (null != n5 ? t8.autoDistanceBetweenPoints2D(n5.left, n5.right) : null) ?? d2;
}
function X({ createOperationGeometry: e8, automaticLengthMeasurementUtils: t8 }) {
  const n5 = e8?.rectangle?.midpoints;
  return (null != n5 ? t8.autoDistanceBetweenPoints2D(n5.top, n5.bottom) : null) ?? d2;
}
function Y({ createOperationGeometry: e8, automaticLengthMeasurementUtils: t8 }) {
  return (null != e8?.circle?.center && null != e8.circle.edge ? t8.autoDistanceBetweenPoints2D(e8.circle.center, e8.circle.edge) : null) ?? d2;
}
function J3(t8) {
  const { geometryType: o6, tooltipInfos: n5 } = t8;
  switch (o6) {
    case "point":
    case "multipoint":
    case "mesh":
    case "polyline":
    case "polygon": {
      const i10 = n5[o6].elevation.committed;
      if (!i10) return;
      return v(i10, "meters") / ne(Q2(t8));
    }
    default:
      return;
  }
}
function K(e8, t8, o6, n5, i10) {
  const { view: r7, drawOperation: a8 } = i10;
  if ("3d" !== r7.type || !a8) return;
  o6 ??= 0;
  const c9 = Q2(i10), l11 = N3(i10), p5 = I(r7, e8, t8, o6, c9, l11, n5);
  return R4(p5, c9) ?? W4(i10);
}
function N3(e8) {
  return e8.drawOperation.elevationInfo ?? U2;
}
function Q2(e8) {
  return e8.drawOperation.coordinateHelper.spatialReference;
}
function W4(e8) {
  const t8 = ne(Q2(e8));
  return a5(e8.defaultZ * t8, "meters");
}
function $2(e8, t8) {
  return b3(e8, t8.view, Q2(t8), N3(t8), t8.drawOperation.coordinateHelper.hasZ(), t8.sketchOptions.values.effectiveDirectionMode);
}

// node_modules/@arcgis/core/views/draw/DrawGraphicTool.js
var A3 = class extends r4 {
  constructor(t8) {
    super(t8), this._graphic = null, this._coordinateFormatterLoadTask = null, this._createOperationGeometry = null, this.defaultZ = 0, this.directionOptions = null, this.elevationLockOnVertexAddDisabled = false, this.geometryType = null, this.hasZ = true, this.geometryToPlace = null, this.snappingManager = null, this.snapToScene = false, this.sketchOptions = new l5();
  }
  initialize() {
    const { view: t8 } = this;
    this.internalGraphicsLayer = new n3({ listMode: "hide", internal: true, title: "DrawGraphicTool layer" }), this.view.map.layers.add(this.internalGraphicsLayer);
    const e8 = this.drawOperation = this.makeDrawOperation();
    this.tooltipInfos = D2(t8.type, this.sketchOptions);
    const o6 = R3(() => ({ view: t8, options: this.sketchOptions.tooltips }));
    this.tooltip = o6, T4(this._tooltipsContext), this._coordinateFormatterLoadTask = d(() => E2()), this.addHandles([e8.on("vertex-add", (t9) => this.onVertexAdd(t9)), e8.on("vertex-remove", (t9) => this.onVertexRemove(t9)), e8.on("vertex-update", (t9) => this.onVertexUpdate(t9)), e8.on("cursor-update", (t9) => this.onCursorUpdate(t9)), e8.on("cursor-remove", () => this._updateGraphic()), e8.on("complete", (t9) => this.onComplete(t9)), this._coordinateFormatterLoadTask, o6.on("paste", (t9) => J2(t9, this.activeTooltipInfo)), l3(() => this.cursor, (t9) => {
      e8.cursor = t9;
    }, w2), i(() => {
      const { activeTooltipInfo: t9, sketchOptions: e9 } = this;
      I3(t9, this._tooltipsContext), o6.info = e9.tooltips.effectiveEnabled ? t9 : null;
    }), i(() => {
      e8.constraintZ = J3(this._tooltipsContext);
    }, U)]), this.finishToolCreation(), e8.initializePointer();
  }
  destroy() {
    this.drawOperation = u(this.drawOperation), this.tooltip = u(this.tooltip), this._destroyAllVisualizations(), this.view.map.remove(this.internalGraphicsLayer), this.internalGraphicsLayer = u(this.internalGraphicsLayer), this._set("view", null);
  }
  get _drawSpatialReference() {
    return this.drawOperation.coordinateHelper.spatialReference;
  }
  get _tooltipsContext() {
    const { defaultZ: t8, directionOptions: e8, drawOperation: o6, forceUniformSize: r7, geometryType: i10, graphic: s4, sketchOptions: a8, tooltipInfos: n5, view: l11, automaticAreaMeasurementUtils: p5, automaticLengthMeasurementUtils: c9 } = this;
    return { createOperationGeometry: this._createOperationGeometry, defaultZ: t8, directionOptions: e8, drawOperation: o6, forceUniformSize: r7, geometryType: i10, graphic: s4, sketchOptions: a8, tooltipInfos: n5, view: l11, automaticAreaMeasurementUtils: p5, automaticLengthMeasurementUtils: c9 };
  }
  get canRedo() {
    return this.drawOperation.canRedo;
  }
  get canUndo() {
    return this.drawOperation.canUndo;
  }
  set centered(t8) {
    this._set("centered", t8), this._updateGraphic();
  }
  get cursor() {
    return this._get("cursor");
  }
  set cursor(t8) {
    this._set("cursor", t8);
  }
  set enabled(t8) {
    this.drawOperation.interactive = t8, this._set("enabled", t8);
  }
  set forceUniformSize(t8) {
    this._set("forceUniformSize", t8), this._updateGraphic();
  }
  get graphic() {
    return this._graphic;
  }
  set graphicSymbol(t8) {
    this._set("graphicSymbol", t8), null != this._graphic && (this._graphic.symbol = t8);
  }
  set mode(t8) {
    const e8 = this.drawOperation;
    e8 && (e8.drawingMode = t8), this._set("mode", t8);
  }
  get updating() {
    return this.drawOperation?.updating ?? false;
  }
  get undoRedo() {
    const { view: { type: t8, map: e8 } } = this;
    return "2d" === t8 && e8 && "undoRedo" in e8 && e8.undoRedo instanceof h4 ? e8.undoRedo : null;
  }
  set undoRedo(t8) {
    this._override("undoRedo", t8);
  }
  completeCreateOperation() {
    this.drawOperation.complete();
  }
  onInputEvent(t8) {
    this.destroyed || H(t8, this.tooltip) || this.drawOperation.onInputEvent(t8);
  }
  redo() {
    this.drawOperation.redo();
  }
  reset() {
  }
  undo() {
    this.drawOperation.undo(), 0 === this.drawOperation.numCommittedVertices && T4(this._tooltipsContext);
  }
  _destroyAllVisualizations() {
    this.removeHandles(I4.outline), this.removeHandles(I4.regularVertices), this.removeHandles(I4.activeVertex), this.removeHandles(I4.activeEdge), this.removeHandles(E5);
  }
  _createOrUpdateGraphic(t8) {
    if (null != this._graphic) return this.updateGraphicGeometry(t8), this._graphic;
    const o6 = new _2({ ...this.graphicProperties, symbol: this.graphicSymbol });
    return this._graphic = o6, this.updateGraphicGeometry(t8), this.internalGraphicsLayer.add(o6), this.addHandles(this.initializeGraphic(o6)), this.notifyChange("graphic"), this.addHandles(e(() => {
      this.internalGraphicsLayer.remove(o6), this._graphic === o6 && (this._graphic = null);
    }), E5), o6;
  }
  updateGraphicGeometry(t8) {
    this._graphic.geometry = t8;
  }
  _getCreateOperationGeometry(t8 = { operationComplete: false }) {
    if (null == this.drawOperation) return;
    const { coordinateHelper: e8, view: o6, visualizationCursorVertex: r7, lastVertex: i10, committedVertices: s4, geometryIncludingUncommittedVertices: a8, numCommittedVertices: n5 } = this.drawOperation;
    if (!(n5 > 0 || null != r7)) return;
    const l11 = t8.operationComplete ? s4 : a8, p5 = l11.length, c9 = null != r7 ? e8.pointToArray(r7) : null, d6 = this._drawSpatialReference, h9 = "3d" === o6.type && "global" === o6.viewingMode, G5 = new l7();
    G5.committedVertices = s4, G5.cursorVertex = c9;
    const { geometryType: x6 } = this;
    switch (x6) {
      case "point":
      case "mesh":
        G5.full = e8.arrayToPoint(l11[0]);
        break;
      case "multipoint":
        G5.full = p5 > 0 ? R(l11, d6) : null;
        break;
      case "polyline":
      case "polygon":
        p5 > 0 && (G5.full = "polygon" === x6 ? T2([l11], d6, h9, true) : j3([l11], d6, h9), G5.cursorEdge = null != c9 && i10 && !a4(r7, i10) ? j3([[c9, e8.pointToArray(i10)]], d6, h9) : null, G5.outline = p5 > 1 ? G5.full : null);
        break;
      case "circle":
      case "rectangle": {
        if (G5.committedVertices = G5.cursorVertex = null, !p5) break;
        const e9 = W2(o6, l11[0]), r8 = l11[0], i11 = e9.makeMapPoint(r8[0] + D3 * o6.resolution, r8[1]);
        "circle" === x6 ? 1 === p5 && t8.operationComplete ? G5.circle = k3([r8, i11], e9, true) : 2 === p5 && (this.forceUniformSize ? G5.circle = k3(l11, e9, this.centered) : G5.rectangle = v2(l11, e9, this.centered)) : 1 === p5 && t8.operationComplete ? G5.rectangle = b2([r8, i11], e9, true) : 2 === p5 && (G5.rectangle = this.forceUniformSize ? b2(l11, e9, this.centered) : U3(l11, e9, this.centered)), G5.full = null != G5.circle ? G5.circle.geometry : G5.rectangle?.geometry, G5.outline = "polygon" === G5.full?.type ? G5.full : null;
        break;
      }
      default:
        return null;
    }
    return G5;
  }
  initializeGraphic(t8) {
    return e();
  }
  onComplete(t8) {
    if (!this.drawOperation) return;
    this._updateGraphic();
    let e8 = null;
    if (this.drawOperation.isCompleted) {
      const t9 = this._getCreateOperationGeometry({ operationComplete: true });
      null != t9 && (e8 = this._createOrUpdateGraphic(t9.full));
    }
    this._createOperationGeometry = null, this.emit("complete", { graphic: e8, ...t8 });
  }
  onCursorUpdate(t8) {
    this._updateGraphic(), this.emit("cursor-update", t8);
  }
  onDeactivate() {
    const { drawOperation: t8 } = this;
    t8 && (t8.isCompleted || t8.cancel());
  }
  onOutlineChanged(t8) {
    return e();
  }
  onCursorEdgeChanged(t8) {
    return e();
  }
  onVertexAdd(t8) {
    U6(this._tooltipsContext), this._updateGraphic(), this.elevationLockOnVertexAddDisabled || j6(t8.vertices.at(0)?.coordinates, this._tooltipsContext), this.emit("vertex-add", t8);
  }
  onVertexRemove(t8) {
    U6(this._tooltipsContext), this._updateGraphic(), this.emit("vertex-remove", t8);
  }
  onVertexUpdate(t8) {
    this._updateGraphic(), this.emit("vertex-update", t8);
  }
  _updateGraphic() {
    const t8 = this._getCreateOperationGeometry();
    this._createOperationGeometry = t8, null != t8 ? (null != t8.cursorEdge ? this.addHandles(this.onCursorEdgeChanged(t8.cursorEdge), I4.activeEdge) : this.removeHandles(I4.activeEdge), null != t8.outline ? this.addHandles(this.onOutlineChanged(t8.outline), I4.outline) : this.removeHandles(I4.outline), null != t8.committedVertices ? this.addHandles(this.onRegularVerticesChanged(t8.committedVertices), I4.regularVertices) : this.removeHandles(I4.regularVertices), null != t8.cursorVertex ? this.addHandles(this.onActiveVertexChanged(t8.cursorVertex), I4.activeVertex) : this.removeHandles(I4.activeVertex), null != t8.full ? this._createOrUpdateGraphic(t8.full) : this.removeHandles(E5)) : this._destroyAllVisualizations();
  }
  get activeTooltipInfo() {
    return this._coordinateFormatterLoadTask?.finished ? b4(this._tooltipsContext) : null;
  }
};
__decorate([m()], A3.prototype, "_coordinateFormatterLoadTask", void 0), __decorate([m()], A3.prototype, "_createOperationGeometry", void 0), __decorate([m()], A3.prototype, "_tooltipsContext", null), __decorate([m({ value: true })], A3.prototype, "centered", null), __decorate([m()], A3.prototype, "cursor", null), __decorate([m({ nonNullable: true })], A3.prototype, "defaultZ", void 0), __decorate([m({ constructOnly: true })], A3.prototype, "directionOptions", void 0), __decorate([m()], A3.prototype, "drawOperation", void 0), __decorate([m()], A3.prototype, "elevationLockOnVertexAddDisabled", void 0), __decorate([m({ value: true })], A3.prototype, "enabled", null), __decorate([m({ value: true })], A3.prototype, "forceUniformSize", null), __decorate([m({ constructOnly: true })], A3.prototype, "geometryType", void 0), __decorate([m()], A3.prototype, "graphic", null), __decorate([m({ constructOnly: true })], A3.prototype, "graphicProperties", void 0), __decorate([m()], A3.prototype, "graphicSymbol", null), __decorate([m({ constructOnly: true })], A3.prototype, "hasZ", void 0), __decorate([m({ constructOnly: true })], A3.prototype, "geometryToPlace", void 0), __decorate([m()], A3.prototype, "mode", null), __decorate([m()], A3.prototype, "snappingManager", void 0), __decorate([m()], A3.prototype, "snapToScene", void 0), __decorate([m()], A3.prototype, "tooltip", void 0), __decorate([m()], A3.prototype, "tooltipInfos", void 0), __decorate([m({ constructOnly: true, type: l5 })], A3.prototype, "sketchOptions", void 0), __decorate([m()], A3.prototype, "updating", null), __decorate([m({ constructOnly: true, nonNullable: true })], A3.prototype, "view", void 0), __decorate([m({ constructOnly: true })], A3.prototype, "automaticAreaMeasurementUtils", void 0), __decorate([m({ constructOnly: true })], A3.prototype, "automaticLengthMeasurementUtils", void 0), __decorate([m({ constructOnly: true })], A3.prototype, "undoRedo", null), __decorate([m()], A3.prototype, "activeTooltipInfo", null), A3 = __decorate([a2("esri.views.draw.DrawGraphicTool")], A3);
var E5 = Symbol("create-operation-graphic");
var I4 = { outline: Symbol("outline-visual"), regularVertices: Symbol("regular-vertices-visual"), activeVertex: Symbol("active-vertex-visual"), activeEdge: Symbol("active-edge-visual") };
function M4(t8) {
  switch (t8) {
    case "point":
    case "polyline":
    case "polygon":
    case "multipoint":
      return t8;
    case "circle":
    case "rectangle":
      return "segment";
    case "mesh":
      return "point";
  }
}
var D3 = 48;

// node_modules/@arcgis/core/views/interactive/dragEventPipeline.js
function i8(t8, n5) {
  let e8 = null, r7 = null;
  return (a8) => {
    if ("cancel" === a8.action) return void (null != r7 && (r7.execute({ action: "cancel" }), e8 = null, r7 = null));
    const o6 = { action: a8.action, screenStart: a8.start, screenEnd: a8.screenPoint };
    "start" === a8.action && null == e8 && (e8 = new D4(), r7 = new D4(), n5(t8, e8, r7, a8.pointerType, o6)), null != e8 && e8.execute(o6), "end" === a8.action && null != e8 && (e8 = null, r7 = null);
  };
}
function p3(t8, n5) {
  return t8.events.on("drag", i8(t8, n5));
}
function m3(t8, n5) {
  const e8 = [t8.x, t8.y, t8.z ?? 0], r7 = n5, a8 = [Math.cos(r7), Math.sin(r7)], o6 = Math.sqrt(a8[0] * a8[0] + a8[1] * a8[1]);
  if (0 === o6) return null;
  a8[0] /= o6, a8[1] /= o6;
  const l11 = (t9) => {
    const n6 = (t9.x - e8[0]) * a8[0] + (t9.y - e8[1]) * a8[1];
    t9.x = e8[0] + n6 * a8[0], t9.y = e8[1] + n6 * a8[1];
  };
  return (t9) => (l11(t9.mapStart), l11(t9.mapEnd), { ...t9, axis: a8 });
}
function f6(t8) {
  let n5 = null;
  const e8 = j7();
  return (r7) => {
    if ("start" === r7.action && (n5 = y5(t8, r7.mapStart.spatialReference)), null == n5) return null;
    const a8 = e8(r7);
    if (!a8) return null;
    const { translationX: o6, translationY: l11, translationZ: c9 } = a8;
    return n5.move(o6, l11, c9, r7.action), a8;
  };
}
function d4(t8, n5) {
  return null == t8 ? null : t8.spatialReference.equals(n5) ? t8.clone() : W(t8, n5);
}
function y5(t8, n5) {
  const e8 = t8.operations;
  if (!e8) return null;
  const r7 = e8.data.geometry, l11 = k2(n5);
  if (r7.spatialReference.equals(l11)) return x4(t8, e8, () => {
  });
  if ("mesh" !== r7.type) {
    const n6 = d4(r7, l11);
    if (null == n6) return null;
    const o6 = r7.spatialReference, c9 = g3.fromGeometry(n6, e8.viewingMode);
    return x4(t8, c9, () => {
      const t9 = c9.data.geometry, n7 = W(t9, o6);
      e8.trySetGeometry(n7);
    });
  }
  if (c2(r7)) {
    const n6 = d4(r7.origin, l11);
    if (!n6) return null;
    const o6 = r7.spatialReference, c9 = g3.fromGeometry(n6, e8.viewingMode);
    return x4(t8, e8, () => {
      const t9 = W(c9.data.geometry, o6), n7 = t9.x - r7.origin.x, l12 = t9.y - r7.origin.y, s4 = (t9.z ?? 0) - (r7.origin.z ?? 0);
      e8.move(n7, l12, s4);
    });
  }
  return null;
}
function x4(t8, n5, e8) {
  let r7 = 0, a8 = 0, o6 = 0;
  return { move: (l11, c9, s4, u5) => {
    "start" === u5 && (r7 = 0, a8 = 0, o6 = 0);
    const i10 = l11 - r7, p5 = c9 - a8, m5 = s4 - o6;
    n5.move(i10, p5, m5), r7 += i10, a8 += p5, o6 += m5, e8(), "end" === u5 && t8.endInteraction?.();
  } };
}
function E6(t8, n5 = null, e8) {
  let r7 = null;
  const o6 = null == n5 || t8.spatialReference?.equals(n5) ? (t9) => t9 : (t9) => null != t9 ? W(t9, n5) : t9, l11 = { exclude: [], ...e8 };
  return (n6) => {
    if ("start" === n6.action && (r7 = o6(t8.toMap(n6.screenStart, l11))), null == r7) return null;
    const e9 = o6(t8.toMap(n6.screenEnd, l11));
    return null != e9 ? { ...n6, mapStart: r7, mapEnd: e9 } : null;
  };
}
function S2(n5) {
  const e8 = n5.map((t8) => f6(t8)).filter(N), r7 = j7();
  return (t8) => {
    const n6 = r7(t8);
    return e8.forEach((n7) => n7(t8)), n6;
  };
}
function g4(t8) {
  const n5 = t8.operations?.createResetState();
  return (t9) => (n5?.remove(), t9);
}
function v4(t8) {
  const n5 = t8.map((t9) => g4(t9)).filter((t9) => null != t9);
  return (t9) => (n5.forEach((n6) => n6(t9)), t9);
}
function z4() {
  let t8 = 0, n5 = 0, e8 = 0;
  return (r7) => {
    "start" === r7.action && (t8 = r7.mapStart.x, n5 = r7.mapStart.y, e8 = r7.mapStart.z ?? 0);
    const a8 = r7.mapEnd.x - t8, o6 = r7.mapEnd.y - n5, l11 = (r7.mapEnd.z ?? 0) - e8;
    return t8 = r7.mapEnd.x, n5 = r7.mapEnd.y, e8 = r7.mapEnd.z, { ...r7, mapDeltaX: a8, mapDeltaY: o6, mapDeltaZ: l11, mapDeltaSpatialReference: r7.mapStart.spatialReference };
  };
}
function j7() {
  let t8 = 0, n5 = 0, e8 = 0;
  return (r7) => {
    "start" === r7.action && (t8 = r7.mapStart.x, n5 = r7.mapStart.y, e8 = r7.mapStart.z ?? 0);
    const a8 = r7.mapEnd.x - t8, o6 = r7.mapEnd.y - n5, l11 = (r7.mapEnd.z ?? 0) - e8;
    return { ...r7, translationX: a8, translationY: o6, translationZ: l11 };
  };
}
function M5() {
  let t8 = 0, n5 = 0;
  return (e8) => {
    "start" === e8.action && (t8 = e8.screenStart.x, n5 = e8.screenStart.y);
    const r7 = e8.screenEnd.x - t8, a8 = e8.screenEnd.y - n5;
    return t8 = e8.screenEnd.x, n5 = e8.screenEnd.y, { ...e8, screenDeltaX: r7, screenDeltaY: a8 };
  };
}
function R6(t8, n5) {
  let a8 = null, o6 = 0, l11 = 0;
  return (c9) => {
    if ("start" === c9.action && (a8 = t8.toScreen?.(n5), null != a8 && (a8.x < 0 || a8.x > t8.width || a8.y < 0 || a8.y > t8.height ? a8 = null : (o6 = c9.screenStart.x - a8.x, l11 = c9.screenStart.y - a8.y))), null == a8) return null;
    const s4 = r(c9.screenEnd.x - o6, 0, t8.width), u5 = r(c9.screenEnd.y - l11, 0, t8.height), i10 = i3(s4, u5);
    return c9.screenStart = a8, c9.screenEnd = i10, c9;
  };
}
var w7 = () => {
};
var D4 = class _D {
  constructor() {
    this.execute = w7;
  }
  next(t8, n5 = new _D()) {
    return null != t8 && (this.execute = (e8) => {
      const r7 = t8(e8);
      null != r7 && n5.execute(r7);
    }), n5;
  }
};
function U7(t8, n5, e8 = []) {
  if ("2d" === t8.type) return (t9) => t9;
  let r7 = null;
  return (a8) => {
    "start" === a8.action && (r7 = t8.toMap(a8.screenStart, { exclude: e8 }), null != r7 && (r7.z = x2(r7, t8, n5)));
    const o6 = t8.toMap(a8.screenEnd, { exclude: e8 });
    null != o6 && (o6.z = x2(o6, t8, n5));
    const l11 = null != r7 && null != o6 ? { sceneStart: r7, sceneEnd: o6 } : null;
    return { ...a8, scenePoints: l11 };
  };
}
function G4(t8, n5, e8) {
  const r7 = n5.elevationProvider.getElevation(t8.x, t8.y, t8.z ?? 0, t8.spatialReference, "scene") ?? 0, a8 = x(t8);
  return a8.z = r7, a8.hasZ = true, a8.z = x2(a8, n5, e8), a8;
}
function q4(t8, n5) {
  if ("2d" === t8.type) return (t9) => t9;
  let e8 = null;
  return (r7) => {
    "start" === r7.action && (e8 = G4(r7.mapStart, t8, n5));
    const a8 = G4(r7.mapEnd, t8, n5), o6 = null != e8 && null != a8 ? { sceneStart: e8, sceneEnd: a8 } : null;
    return { ...r7, scenePoints: o6 };
  };
}

// node_modules/@arcgis/core/views/interactive/snapping/SnappingDragPipelineStep.js
function f7({ predicate: o6 = () => true, snappingManager: i10, snappingContext: a8, updatingHandles: u5, useZ: p5 = true }) {
  const c9 = new D4();
  if (null == i10) return { snappingStep: [y6, c9], cancelSnapping: y6 };
  let f8, Z4 = null, j8 = null, z6 = null;
  const T6 = () => {
    Z4 = e2(Z4), i10.doneSnapping(), j8?.frameTask.remove(), j8 = null, f8 = l(f8), z6 = null;
  }, k6 = d5(i10, p5, c9);
  let w8 = null, I5 = null, U9 = null;
  return { snappingStep: [(n5) => {
    if (!o6(n5)) return n5;
    const { action: e8 } = n5;
    if ("start" === e8) {
      const { info: e9 } = n5, t8 = m4(i10.view);
      if (j8 = g5(a8, n5, t8), j8.context.selfSnappingZ = null, !p5 && null != e9) {
        const n6 = S3(a8.coordinateHelper, e9.handle.part);
        null != n6 && (j8.context.selfSnappingZ = { value: n6, elevationInfo: a8.elevationInfo ?? U2 });
      }
    }
    if (null != j8) {
      const { context: o7, originalScenePos: a9, originalPos: l11 } = j8, { mapEnd: s4, mapStart: c10, scenePoints: d6 } = n5, m5 = x5(l11, v5(s4, c10)), g6 = v5(c10, l11), S5 = { ...n5, action: "update" }, y7 = j8.context, T7 = P3(a9, d6), C3 = i10.update({ point: m5, scenePoint: T7, context: o7 });
      if (U9 = C3, h6(s4, C3, g6, p5), w8 = m5, I5 = T7, "end" !== e8) {
        const { frameTask: n6 } = j8;
        null == Z4 && (Z4 = new AbortController()), z6 = (e9) => {
          u5.addPromise(y(k6({ frameTask: n6, event: S5, context: y7, point: m5, scenePoint: T7, delta: g6, getLastState: () => ({ point: w8, scenePoint: I5, updatePoint: e9.forceUpdate ? null : U9 }) }, Z4.signal)));
        }, z6({ forceUpdate: false }), null == f8 && (f8 = l3(() => i10.options.effectiveEnabled, () => z6?.({ forceUpdate: true })));
      }
    }
    return "end" === e8 && T6(), n5;
  }, c9], cancelSnapping: (n5) => (T6(), n5) };
}
function d5(n5, e8, t8) {
  return L(async ({ frameTask: o6, point: r7, scenePoint: a8, context: l11, event: s4, delta: u5, getLastState: p5 }, c9) => {
    const f8 = await o6.schedule(() => n5.snap({ point: r7, scenePoint: a8, context: l11, signal: c9 }), c9);
    if (f8.valid) {
      let a9 = await o6.schedule(() => f8.apply(), c9);
      const d6 = p5();
      null != d6.point && r7 !== d6.point && (a9 = n5.update({ point: d6.point, scenePoint: d6.scenePoint, context: l11 })), null != d6.updatePoint && a4(a9, d6.updatePoint) || (h6(s4.mapEnd, a9, u5, e8), t8.execute(s4));
    }
  });
}
function m4(n5) {
  return "3d" === n5.type ? n5.resourceController.scheduler.registerTask(f4.SNAPPING) : G;
}
function g5(n5, e8, t8) {
  return { context: new e4({ editGeometryOperations: n5.editGeometryOperations, elevationInfo: n5.elevationInfo, pointer: n5.pointer, vertexHandle: null != e8.info ? e8.info.handle : null, excludeFeature: n5.excludeFeature, feature: n5.feature, visualizer: n5.visualizer }), originalPos: null != e8.snapOrigin ? n5.coordinateHelper.vectorToDehydratedPoint(e8.snapOrigin) : e8.mapStart, originalScenePos: null != e8.scenePoints ? e8.scenePoints.sceneStart : null, frameTask: t8 };
}
function x5(n5, [e8, t8, o6]) {
  const r7 = x(n5);
  return r7.x += e8, r7.y += t8, r7.hasZ && (r7.z += o6), r7;
}
function P3(n5, e8) {
  return null == n5 || null == e8 ? null : x5(n5, v5(e8.sceneEnd, e8.sceneStart));
}
function v5(n5, e8) {
  const t8 = n5.hasZ && e8.hasZ ? n5.z - e8.z : 0;
  return [n5.x - e8.x, n5.y - e8.y, t8];
}
function h6(n5, e8, [t8, o6, r7], i10) {
  n5.x = e8.x + t8, n5.y = e8.y + o6, i10 && n5.hasZ && e8.hasZ && (n5.z = e8.z + r7);
}
function S3(n5, e8) {
  if (!n5.hasZ()) return null;
  const t8 = e8.vertices;
  let o6 = null;
  for (const r7 of t8) {
    const e9 = n5.getZ(r7.pos);
    if (null != o6 && null != e9 && Math.abs(e9 - o6) > 1e-6) return null;
    null == o6 && (o6 = e9);
  }
  return o6;
}
function y6(n5) {
  return n5;
}

// node_modules/@arcgis/core/views/draw/DrawingMode.js
var e7 = "click";

// node_modules/@arcgis/core/views/draw/LegacyDrawManipulator.js
var i9 = class extends b {
  constructor(o6) {
    super(o6), this.events = new i2(), this.interactive = true, this.selectable = false, this.cursor = null, this.grabbable = true;
  }
  intersectionDistance(o6, r7) {
    return 0;
  }
  attach() {
  }
  detach() {
  }
  onElevationChange() {
  }
  onViewChange() {
  }
};
__decorate([m()], i9.prototype, "interactive", void 0), __decorate([m()], i9.prototype, "selectable", void 0), __decorate([m()], i9.prototype, "cursor", void 0), __decorate([m()], i9.prototype, "grabbing", void 0), __decorate([m()], i9.prototype, "grabbable", void 0), __decorate([m()], i9.prototype, "consumesClicks", void 0), __decorate([m()], i9.prototype, "grabbableForEvent", void 0), __decorate([m()], i9.prototype, "dragging", void 0), __decorate([m()], i9.prototype, "hovering", void 0), __decorate([m()], i9.prototype, "selected", void 0), i9 = __decorate([a2("esri.views.draw.LegacyDrawManipulator")], i9);

// node_modules/@arcgis/core/views/interactive/snapping/SnappingOperation.js
var p4 = class extends b {
  constructor(t8) {
    super(t8), this.constrainResult = (t9) => t9, this._snapPoints = null, this._frameTask = null, this._abortController = null, this._stagedPoint = null, this._snap = L(async (t9, s4, o6, i10) => {
      const n5 = this._frameTask;
      if (null == n5) return;
      const r7 = await n5.schedule(() => s4.snap({ ...t9, context: o6, signal: i10 }), i10);
      r7.valid && await n5.schedule(() => {
        this.stagedPoint = r7.apply(), t9 !== this._snapPoints && null != this._snapPoints && (this.stagedPoint = s4.update({ ...this._snapPoints, context: o6 }));
      }, i10);
    });
  }
  get stagedPoint() {
    return this._stagedPoint;
  }
  set stagedPoint(t8) {
    this._stagedPoint = this.constrainResult(t8);
  }
  initialize() {
    const t8 = "3d" === this.view.type ? this.view?.resourceController?.scheduler : null;
    this._frameTask = null != t8 ? t8.registerTask(f4.SNAPPING) : G;
  }
  destroy() {
    this._abortController = e2(this._abortController), this._frameTask = l(this._frameTask);
  }
  update(t8, s4, o6) {
    this._snapPoints = t8;
    const { point: i10, scenePoint: n5 } = t8, r7 = s4.update({ point: i10, scenePoint: n5, context: o6 });
    return this.stagedPoint = r7, r7;
  }
  async snap(t8, s4, o6) {
    const { point: i10, scenePoint: n5 } = t8;
    return this.stagedPoint = s4.update({ point: i10, scenePoint: n5, context: o6 }), this._snapPoints = t8, null == this._abortController && (this._abortController = new AbortController()), this._snap(t8, s4, o6, this._abortController.signal);
  }
  async snapAgainNearPreviousMapPoint(t8, s4) {
    null != this._snapPoints && await this.snap(this._snapPoints, t8, s4);
  }
  abort() {
    this._abortController = e2(this._abortController), this._snapPoints = null;
  }
};
__decorate([m({ constructOnly: true })], p4.prototype, "view", void 0), __decorate([m()], p4.prototype, "stagedPoint", null), __decorate([m()], p4.prototype, "constrainResult", void 0), __decorate([m()], p4.prototype, "_stagedPoint", void 0), p4 = __decorate([a2("esri.views.interactive.snapping.SnappingOperation")], p4);

// node_modules/@arcgis/core/views/draw/DrawOperation.js
var k5 = "crosshair";
var Z3 = "progress";
var L3 = Symbol();
var U8 = Symbol();
var A4 = class extends l2 {
  constructor(t8) {
    super(t8), this._createOperationCompleted = false, this._hideDefaultCursor = false, this._pointerDownStates = new t4(), this._stagedScreenPoint = null, this._stagedPointerType = null, this._updatingHandles = new h(), this._stagedPointerId = null, this.constraintsEnabled = false, this.constraints = void 0, this._getPointConstraint = t3(k4), this._getPolylineOrPolygonConstraint = t3(q2), this.constraintZ = null, this.defaultZ = null, this.isDraped = true, this.labelOptions = new c5(), this.cursor = null, this.loading = false, this.snapToSceneEnabled = null, this.firstVertex = null, this.lastVertex = null, this.secondToLastVertex = null, null == t8.elevationInfo && (this.elevationInfo = i5(!!t8.hasZ));
  }
  initializePointer() {
    const t8 = this.view.inputManager?.latestPointerInfo;
    null != t8 && this._updatePointer(t8.location, t8.id, t8.type);
  }
  initialize() {
    const { geometryType: t8, view: e8 } = this, i10 = e8.spatialReference, r7 = "viewingMode" in e8.state ? e8.state.viewingMode : 2, s4 = "segment" === t8 || "multipoint" === t8 ? "polyline" : t8;
    this.coordinateHelper = w5(this.hasZ, this.hasM, i10), this._editGeometryOperations = new g3(new w6(s4, this.coordinateHelper), r7), this._snappingOperation = new p4({ view: e8 }), this.addHandles([l3(() => ({ stagedPoint: this._snappingOperation.stagedPoint, constraint: this._constraint }), ({ stagedPoint: t9, constraint: e9 }, i11) => {
      const { snappingOptions: n5 } = this;
      n5 && (n5.forceDisabled = null != e9 && me2(e9));
      if (null != i11 && t9 === i11.stagedPoint && e9 !== i11.constraint) return this._onKeyboardBasedChange();
      this._processCursor(t9 ?? this._screenToMap(this._stagedScreenPoint));
    }, { equals: (t9, e9) => t9.stagedPoint === e9.stagedPoint && o(t9.constraint, e9.constraint) }), l3(() => this.view.viewpoint, (t9, e9) => {
      t9 && e9 && y2(t9, e9) && this._onKeyboardBasedChange();
    })]), this._activePart = new V2(i10, r7), this._editGeometryOperations.data.parts.push(this._activePart);
    const a8 = this.segmentLabels;
    null != a8 && (a8.context = { view: e8, editGeometryOperations: this._editGeometryOperations, elevationInfo: this.elevationInfo, labelOptions: this.labelOptions, automaticLengthMeasurementUtils: this.automaticLengthMeasurementUtils }, this.addHandles(l3(() => this.labelOptions.enabled, (t9) => {
      a8.visible = t9;
    }, w2))), this.addHandles(this._editGeometryOperations.on(["vertex-add", "vertex-update", "vertex-remove"], (t9) => {
      const e9 = t9.vertices.map((t10) => ({ componentIndex: 0, vertexIndex: t10.index, coordinates: this.coordinateHelper.vectorToArray(t10.pos) })), i11 = e9.map((t10) => t10.coordinates), n5 = this.coordinateHelper.vectorToDehydratedPoint(this._activePart.getFirstVertex()?.pos) ?? null;
      a4(n5, this.firstVertex) || (this.firstVertex = n5);
      const r8 = this.coordinateHelper.vectorToDehydratedPoint(this._activePart.getLastVertex()?.pos) ?? null;
      a4(r8, this.lastVertex) || (this.lastVertex = r8);
      const s5 = this.coordinateHelper.vectorToDehydratedPoint(this._activePart.segments.at(-1)?.leftVertex?.pos) ?? null;
      switch (a4(s5, this.secondToLastVertex) || (this.secondToLastVertex = s5), this._processCursor(this.cursorVertex), t9.type) {
        case "vertex-add":
          this.emit(t9.type, { ...t9, added: i11, vertices: e9 });
          break;
        case "vertex-update":
          this.emit(t9.type, { ...t9, updated: i11, vertices: e9 });
          break;
        case "vertex-remove":
          this.emit(t9.type, { ...t9, removed: i11, vertices: e9 });
      }
    }));
    const l11 = this._manipulator = new i9({ consumesClicks: false, grabbableForEvent: (t9) => "click" !== this.drawingMode || "touch" === t9.pointerType && this._snappingEnabled && 1 === this._pointerDownStates.size });
    this.manipulators.add(l11), l11.grabbable = "point" !== t8 && "multipoint" !== t8, this.addHandles([l11.events.on("immediate-click", (t9) => this._onImmediateClick(t9)), l11.events.on("immediate-double-click", (t9) => this._onImmediateDoubleClick(t9)), l3(() => this.drawingMode, () => {
      this.removeHandles(L3), this.addHandles(this._createManipulatorDragPipeline(l11), L3);
    }, w2), l3(() => ({ effectiveCursor: this.effectiveCursor }), ({ effectiveCursor: t9 }) => {
      l11.cursor = t9;
    }, w2)]), v3(this, () => {
      const t9 = this.view.inputManager.latestPointerInfo?.type ?? "mouse", e9 = this._getSnappingContext(t9);
      if (null != this.snappingManager) {
        const t10 = this._snappingOperation.snapAgainNearPreviousMapPoint(this.snappingManager, e9);
        this._updatingHandles.addPromise(y(t10));
      }
    });
  }
  destroy() {
    u(this.segmentLabels), u(this._snappingOperation), this._editGeometryOperations = u(this._editGeometryOperations), this._updatingHandles.destroy();
  }
  get _isDragging() {
    const { _stagedPointerId: t8, _manipulator: e8 } = this;
    return null != t8 && this._pointerDownStates.has(t8) || e8.grabbing || !e8.interactive;
  }
  get _snappingEnabled() {
    return null != this.snappingManager && this.snappingManager.options.effectiveEnabled;
  }
  get _requiresScenePoint() {
    const t8 = this._updateAndGetEffectiveDrawSurface();
    return "3d" === this.view.type && this.drawSurface !== t8;
  }
  get canRedo() {
    return this._editGeometryOperations.canRedo;
  }
  get canUndo() {
    return this._editGeometryOperations.canUndo;
  }
  get committedVertices() {
    return this._activePart.vertices.map((t8) => this.coordinateHelper.vectorToArray(t8.pos));
  }
  get _constraint() {
    const { constraints: t8, constraintsEnabled: e8 } = this;
    if (t8 && e8) switch (this.geometryType) {
      case "point":
      case "multipoint":
        return this._getPointConstraint(t8);
      case "polygon":
      case "polyline":
        return this._getPolylineOrPolygonConstraint(this.lastVertex, this.secondToLastVertex, t8);
    }
  }
  set drawingMode(t8) {
    this._set("drawingMode", t8 ?? e7);
  }
  get effectiveCursor() {
    return this.loading ? Z3 : this._hideDefaultCursor ? null : this.cursor || k5;
  }
  get interactive() {
    return this._manipulator.interactive;
  }
  set interactive(t8) {
    this._manipulator.interactive = t8;
  }
  get isCompleted() {
    return this._createOperationCompleted;
  }
  get numCommittedVertices() {
    return this._activePart.vertices.length;
  }
  get snappingOptions() {
    return null != this.snappingManager ? this.snappingManager.options : null;
  }
  get cursorVertex() {
    return this._get("cursorVertex");
  }
  get visualizationCursorVertex() {
    return "mouse" === this._stagedPointerType ? this.cursorVertex : null;
  }
  get committableVertex() {
    const { cursorVertex: t8, lastVertex: e8, firstVertex: i10, geometryType: n5 } = this;
    return "polygon" === n5 && i4(t8, i10) || i4(t8, e8) ? null : t8;
  }
  get updating() {
    return this._updatingHandles.updating;
  }
  get geometryIncludingUncommittedVertices() {
    const { committedVertices: t8, committableVertex: e8, coordinateHelper: i10 } = this, n5 = t8.slice();
    return null != e8 && n5.push(i10.pointToArray(e8)), n5;
  }
  cancel() {
    this.complete({ aborted: true });
  }
  commitStagedVertex() {
    this._snappingOperation.abort();
    const { committableVertex: t8 } = this;
    null != t8 && this._editGeometryOperations.appendVertex(this.coordinateHelper.pointToVector(t8), this._activePart);
  }
  complete(t8) {
    const e8 = t8?.aborted || false;
    this._snappingOperation.abort(), this.snappingManager?.doneSnapping();
    const { geometryType: i10, numCommittedVertices: n5 } = this, r7 = "multipoint" === i10 && 0 === n5 || "polyline" === i10 && n5 < 2 || "polygon" === i10 && n5 < 3;
    "segment" !== i10 && "point" !== i10 || this.commitStagedVertex(), this._createOperationCompleted = !r7, (this.isCompleted || e8) && (this._stagedScreenPoint = null, this._stagedPointerId = null, this._stagedPointerType = null, this._processCursor(null), this.emit("complete", { vertices: this.committedVertices.map((t9, e9) => ({ componentIndex: 0, vertexIndex: e9, coordinates: t9 })), aborted: e8, type: "complete" }));
  }
  onInputEvent(t8) {
    switch (t8.type) {
      case "pointer-down":
        this._pointerDownStates.add(t8.pointerId);
        break;
      case "pointer-up":
        this._pointerDownStates.delete(t8.pointerId);
    }
    switch (t8.type) {
      case "pointer-move":
        return this._onPointerMove(t8);
      case "hold":
        return this._onHold(t8);
    }
  }
  redo() {
    this._editGeometryOperations.redo();
  }
  undo() {
    null != this.snappingManager && this.snappingManager.doneSnapping(), this._editGeometryOperations.undo();
  }
  _processCursor(t8) {
    const e8 = a(this.cursorVertex), n5 = a(t8), r7 = n5 && (this._updateAndGetEffectiveDrawSurface()?.constrainZ(n5) ?? n5), s4 = this._snapToClosingVertex(r7), o6 = this._applyConstraints(s4);
    i4(e8, o6) || (this._set("cursorVertex", o6), this.segmentLabels?.set("stagedVertex", null != o6 ? this.coordinateHelper.pointToVector(o6) : null), null == o6 || "mouse" !== this._stagedPointerType ? this.emit("cursor-remove") : this.emit("cursor-update", { updated: null, vertices: [{ componentIndex: 0, vertexIndex: this._activePart.vertices.length, coordinates: this.coordinateHelper.pointToArray(o6) }], operation: "apply", type: "vertex-update" }));
  }
  _snapToClosingVertex(t8) {
    if (null == t8 || this._isDragging || "polygon" !== this.geometryType || this.numCommittedVertices <= 2) return t8;
    const e8 = this._mapToScreen(t8);
    if (!e8) return t8;
    const i10 = this._activePart;
    return this._vertexWithinPointerDistance(i10.vertices[0].pos, e8) ? this.firstVertex : this._vertexWithinPointerDistance(i10.vertices.at(-1).pos, e8) ? this.lastVertex : t8;
  }
  _createManipulatorDragPipeline(t8) {
    switch (this.drawingMode) {
      case "click":
        return this._createManipulatorDragPipelineClick(t8);
      case "freehand":
        return this._createManipulatorDragPipelineFreehand(t8);
      case "hybrid":
        return this._createManipulatorDragPipelineHybrid(t8);
    }
  }
  _createManipulatorDragPipelineClick(t8) {
    return p3(t8, (t9, e8, i10, n5) => {
      const r7 = "touch" === n5 && this._snappingEnabled;
      if (this.isCompleted || !r7) return;
      const { snappingStep: s4, cancelSnapping: o6 } = f7({ predicate: () => r7, snappingManager: this.snappingManager, snappingContext: new e4({ editGeometryOperations: this._editGeometryOperations, elevationInfo: this.elevationInfo, feature: this.graphic, pointer: n5, visualizer: this.snappingVisualizer, drawConstraints: this.constraints }), updatingHandles: this._updatingHandles, useZ: !this._requiresScenePoint });
      i10 = i10.next((t10) => (r7 && null != this.snappingManager && this.snappingManager.doneSnapping(), t10)).next(o6), e8.next(this._screenToMapDragEventStep()).next((t10) => ("start" === t10.action && (this._processCursor(t10.mapStart), ("segment" === this.geometryType || r7 && !this.numCommittedVertices) && this.commitStagedVertex()), t10)).next(U7(this.view, this.elevationInfo)).next(...s4).next((t10) => (r7 && (this._processCursor(t10.mapEnd), "end" === t10.action && this.commitStagedVertex()), t10)).next((t10) => ("end" === t10.action && ("mouse" !== this._stagedPointerType && this._snappingOperation.abort(), "segment" !== this.geometryType && "point" !== this.geometryType || this.complete()), t10));
    });
  }
  _createManipulatorDragPipelineFreehand(t8) {
    return p3(t8, (t9, e8) => {
      this.isCompleted || e8.next(this._screenToMapDragEventStep()).next((t10) => ("start" === t10.action && (this._snappingOperation.abort(), null == this.committableVertex && this._processCursor(t10.mapStart), "segment" === this.geometryType && this.commitStagedVertex()), t10)).next((t10) => {
        switch (t10.action) {
          case "start":
          case "update":
            this._processCursor(t10.mapEnd), "polygon" !== this.geometryType && "polyline" !== this.geometryType || this.commitStagedVertex();
            break;
          case "end":
            this.complete();
        }
        return t10;
      });
    });
  }
  _createManipulatorDragPipelineHybrid(t8) {
    return p3(t8, (t9, e8) => {
      this.isCompleted || e8.next(this._screenToMapDragEventStep()).next((t10) => ("start" === t10.action && (this._snappingOperation.abort(), this.addHandles(this._editGeometryOperations.createUndoGroup(), U8), this._processCursor(t10.mapStart), this.commitStagedVertex()), t10)).next((t10) => {
        switch (t10.action) {
          case "start":
          case "update":
            this._processCursor(t10.mapEnd), "polygon" !== this.geometryType && "polyline" !== this.geometryType || this.commitStagedVertex();
            break;
          case "end":
            "mouse" !== this._stagedPointerType && this._snappingOperation.abort(), this.removeHandles(U8), "segment" !== this.geometryType && "point" !== this.geometryType || this.complete();
        }
        return t10;
      });
    });
  }
  get _drawAtFixedElevation() {
    const { constraintsEnabled: t8, constraintZ: e8, geometryType: i10, numCommittedVertices: n5 } = this;
    return t8 ? null != e8 || "segment" === i10 && n5 > 0 : ("segment" === i10 || "polygon" === i10) && n5 > 0;
  }
  _updateAndGetEffectiveDrawSurface() {
    const { constraintsEnabled: t8, coordinateHelper: e8, drawSurface: i10, elevationDrawSurface: n5, snapToSceneEnabled: r7 } = this;
    if (null == n5) return i10;
    if (!this.hasZ) return n5.defaultZ = null, n5;
    const s4 = this.elevationInfo?.mode;
    let o6 = this.defaultZ, a8 = t8 || "absolute-height" === s4;
    if (null != r7 && (a8 = r7), "on-the-ground" === s4 && (a8 = false), this._drawAtFixedElevation) {
      o6 = (t8 ? this.constraintZ : null) ?? e8.getZ(this._activePart.vertices[0].pos), a8 = false;
    }
    return a8 ? i10 : (n5.defaultZ = o6, n5);
  }
  _mapToScreen(t8) {
    return this._updateAndGetEffectiveDrawSurface()?.mapToScreen(t8);
  }
  _onHold(t8) {
    this._snappingOperation.abort(), "click" === this.drawingMode && "touch" === t8.pointerType && this._snappingEnabled && this._processCursor(t8.mapPoint), t8.stopPropagation();
  }
  _onImmediateClick(t8) {
    if (!("mouse" === t8.pointerType && 2 === t8.button || this._manipulator.dragging)) try {
      const { drawingMode: e8, geometryType: i10 } = this;
      this._stagedPointerType = t8.pointerType, this._stagedScreenPoint = t8.screenPoint;
      const n5 = this._screenToMap(t8.screenPoint);
      if (null == n5) return;
      if (null == n5 || "freehand" === e8 && "point" !== i10 && "multipoint" !== i10) return;
      if (this._snappingEnabled && null != this.cursorVertex || this._processCursor(n5), null == this.committableVertex) return void this.complete();
      this.commitStagedVertex(), "mouse" !== t8.pointerType && this._processCursor(null), ("freehand" === e8 && "multipoint" !== this.geometryType || "point" === i10 || "segment" === i10 && 2 === this.numCommittedVertices || "segment" === i10 && "hybrid" === e8 && 1 === this.numCommittedVertices) && this.complete();
    } finally {
      t8.stopPropagation();
    }
  }
  _onImmediateDoubleClick(t8) {
    this._manipulator.dragging || "point" === this.geometryType || (this.complete(), t8.stopPropagation());
  }
  _onPointerMove(t8) {
    const e8 = i3(t8.x, t8.y);
    this._updatePointer(e8, t8.pointerId, t8.pointerType) && t8.stopPropagation();
  }
  _updatePointer(t8, e8, i10) {
    return this._stagedScreenPoint = t8, this._stagedPointerType = i10, this._stagedPointerId = e8, this._isDragging ? (this._snappingOperation.abort(), false) : (this._processCursorMovementRelativeToSurface(t8, i10), true);
  }
  _onKeyboardBasedChange() {
    "mouse" === this._stagedPointerType && this._stagedScreenPoint && null != this._stagedPointerId && !this._isDragging ? this._processCursorMovementRelativeToSurface(this._stagedScreenPoint, this._stagedPointerType) : this._snappingOperation.abort();
  }
  _processCursorMovementRelativeToSurface(t8, e8) {
    const i10 = this._snappingOperation, n5 = this._screenToMap(t8), r7 = this._requiresScenePoint ? this.drawSurface?.screenToMap(t8) : null;
    if (null == n5) return this._hideDefaultCursor = true, this._processCursor(null), void i10.abort();
    this._hideDefaultCursor = false;
    const s4 = this.snappingManager;
    if (null == s4) return this._processCursor(n5), void i10.abort();
    const a8 = this._getSnappingContext(e8);
    this._updatingHandles.addPromise(y(i10.snap({ point: n5, scenePoint: r7 }, s4, a8)));
  }
  _applyConstraints(t8) {
    const { _constraint: e8, constraints: i10 } = this;
    if (!t8 || !i10 || !e8) return t8;
    const { context: n5 } = i10, r7 = W3(t8, n5), s4 = r7 ? e8.closestTo(r7) : void 0;
    if (!s4) return t8;
    const o6 = A(s4, t8, n5), a8 = "2d" === this.view.type || "absolute-height" !== n5.elevationInfo.mode;
    return null != o6 && a8 && null != this.constraintZ && this.hasZ && (o6.z = this.constraintZ), o6;
  }
  _screenToMap(t8) {
    return t8 ? this._updateAndGetEffectiveDrawSurface()?.screenToMap(t8) : null;
  }
  _screenToMapDragEventStep() {
    let t8 = null;
    return (e8) => {
      if ("start" === e8.action && (t8 = this._screenToMap(e8.screenStart)), null == t8) return null;
      const i10 = this._screenToMap(e8.screenEnd);
      return null != i10 ? { ...e8, mapStart: t8, mapEnd: i10 } : null;
    };
  }
  _vertexWithinPointerDistance(t8, e8) {
    const i10 = 25, n5 = this._mapToScreen(this.coordinateHelper.vectorToDehydratedPoint(t8));
    return null != n5 && z5(n5, e8, i10);
  }
  _getSnappingContext(t8) {
    const e8 = this._drawAtFixedElevation ? this.elevationDrawSurface?.defaultZ : null;
    return new e4({ editGeometryOperations: this._editGeometryOperations, elevationInfo: this.elevationInfo, pointer: t8, feature: this.graphic, visualizer: this.snappingVisualizer, selfSnappingZ: null != e8 ? { value: e8, elevationInfo: this.elevationInfo } : null, drawConstraints: this.constraints });
  }
};
function z5(t8, e8, i10) {
  const n5 = t8.x - e8.x, r7 = t8.y - e8.y;
  return n5 * n5 + r7 * r7 <= i10;
}
__decorate([m()], A4.prototype, "_hideDefaultCursor", void 0), __decorate([m()], A4.prototype, "_stagedPointerId", void 0), __decorate([m()], A4.prototype, "_isDragging", null), __decorate([m()], A4.prototype, "_snappingOperation", void 0), __decorate([m()], A4.prototype, "_snappingEnabled", null), __decorate([m({ constructOnly: true })], A4.prototype, "graphic", void 0), __decorate([m()], A4.prototype, "constraintsEnabled", void 0), __decorate([m()], A4.prototype, "constraints", void 0), __decorate([m()], A4.prototype, "_constraint", null), __decorate([m()], A4.prototype, "constraintZ", void 0), __decorate([m()], A4.prototype, "defaultZ", void 0), __decorate([m()], A4.prototype, "isDraped", void 0), __decorate([m({ constructOnly: true })], A4.prototype, "automaticLengthMeasurementUtils", void 0), __decorate([m({ value: e7 })], A4.prototype, "drawingMode", null), __decorate([m({ constructOnly: true })], A4.prototype, "elevationDrawSurface", void 0), __decorate([m({ constructOnly: true })], A4.prototype, "elevationInfo", void 0), __decorate([m({ constructOnly: true, type: c5 })], A4.prototype, "labelOptions", void 0), __decorate([m({ constructOnly: true })], A4.prototype, "geometryType", void 0), __decorate([m({ constructOnly: true })], A4.prototype, "hasM", void 0), __decorate([m({ constructOnly: true })], A4.prototype, "hasZ", void 0), __decorate([m()], A4.prototype, "cursor", void 0), __decorate([m()], A4.prototype, "effectiveCursor", null), __decorate([m()], A4.prototype, "loading", void 0), __decorate([m({ constructOnly: true })], A4.prototype, "manipulators", void 0), __decorate([m({ constructOnly: true })], A4.prototype, "drawSurface", void 0), __decorate([m({ constructOnly: true })], A4.prototype, "segmentLabels", void 0), __decorate([m({ constructOnly: true })], A4.prototype, "snappingManager", void 0), __decorate([m({ constructOnly: true })], A4.prototype, "snappingVisualizer", void 0), __decorate([m()], A4.prototype, "snapToSceneEnabled", void 0), __decorate([m({ readOnly: true })], A4.prototype, "cursorVertex", null), __decorate([m({ readOnly: true })], A4.prototype, "visualizationCursorVertex", null), __decorate([m()], A4.prototype, "committableVertex", null), __decorate([m()], A4.prototype, "firstVertex", void 0), __decorate([m()], A4.prototype, "lastVertex", void 0), __decorate([m()], A4.prototype, "secondToLastVertex", void 0), __decorate([m()], A4.prototype, "updating", null), __decorate([m({ constructOnly: true })], A4.prototype, "view", void 0), A4 = __decorate([a2("esri.views.draw.DrawOperation")], A4);

// node_modules/@arcgis/core/views/draw/drawSurfaces.js
var c8 = class {
  constructor(e8, t8, s4, r7 = null) {
    this._elevationInfo = e8, this.defaultZ = t8, this._view = s4, this._excludeGraphics = r7;
  }
  screenToMap(t8) {
    const { defaultZ: s4, _view: r7 } = this, n5 = r7.sceneIntersectionHelper.intersectElevationFromScreen(f2(t8.x, t8.y), this._elevationInfo, s4 ?? 0, this._excludeGraphics);
    return null == s4 && null != n5 && (n5.z = void 0), n5;
  }
  mapToScreen(e8) {
    const t8 = t2(e8.x, e8.y, E(this._view, e8, this._elevationInfo), e8.spatialReference);
    return this._view.toScreen(t8);
  }
  constrainZ(e8) {
    const { defaultZ: t8 } = this;
    return null != t8 && e8.z !== t8 && ((e8 = x(e8)).z = t8), e8;
  }
};
var l10 = class {
  constructor(e8, t8, s4 = []) {
    this.view = e8, this.elevationInfo = t8, this.exclude = s4;
  }
  screenToMap(e8) {
    const t8 = this.view.toMap(e8, { exclude: this.exclude, excludeLabels: true });
    return null != t8 && (t8.z = x2(t8, this.view, this.elevationInfo)), t8;
  }
  mapToScreen(e8) {
    let t8 = e8;
    return null != this.elevationInfo && (t8 = t2(e8.x, e8.y, E(this.view, e8, this.elevationInfo), e8.spatialReference)), this.view.toScreen(t8);
  }
  constrainZ(e8) {
    return e8;
  }
};
var h7 = class {
  constructor(e8, t8 = false, s4 = 0) {
    this.view = e8, this.hasZ = t8, this.defaultZ = s4, this.mapToScreen = (t9) => e8.toScreen(t9), this.screenToMap = t8 ? (t9) => {
      const r7 = e8.toMap(t9);
      return r7.z = s4, r7;
    } : (t9) => e8.toMap(t9);
  }
  constrainZ(e8) {
    const { defaultZ: t8 } = this;
    return this.hasZ && e8.z !== t8 && ((e8 = x(e8)).z = t8), e8;
  }
};
var _u = class _u {
  screenToMap(e8) {
    const { x: t8, y: r7 } = e8;
    return new _({ x: t8, y: r7, spatialReference: _u.spatialReference });
  }
  mapToScreen(e8) {
    return i3(e8.x, e8.y);
  }
  constrainZ(e8) {
    return e8;
  }
};
_u.spatialReference = new f();
var u4 = _u;

// node_modules/@arcgis/core/views/interactive/editGeometry/support/editPlaneUtils.js
function V5(o6, i10) {
  return E7(o6, i10, false);
}
function T5(o6, i10) {
  return E7(o6, i10, true);
}
function E7(o6, i10, r7) {
  if (o6 instanceof t5) {
    if (o6.operation instanceof t6) return h8(o6.operation, i10, r7), true;
    if (o6.operation instanceof o4) return v6(o6.operation, i10, r7), true;
    if (o6.operation instanceof l6) return F3(o6.operation, i10, r7), true;
  }
  return false;
}
function h8(o6, i10, r7 = false) {
  const t8 = r7 ? -1 : 1, s4 = r2(t8 * o6.dx, t8 * o6.dy, t8 * o6.dz);
  u3(i10.origin, i10.origin, s4), J(i10);
}
function v6(o6, i10, r7 = false) {
  const t8 = r7 ? -o6.angle : o6.angle;
  w3(i10.basis1, i10.basis1, a3, t8), w3(i10.basis2, i10.basis2, a3, t8), J(i10);
}
function F3(o6, i10, r7 = false) {
  const t8 = r7 ? 1 / o6.factor1 : o6.factor1, s4 = r7 ? 1 / o6.factor2 : o6.factor2;
  g(i10.basis1, i10.basis1, t8), g(i10.basis2, i10.basis2, s4), k(i10.origin, i10.origin, o6.origin, o6.axis1, t8), k(i10.origin, i10.origin, o6.origin, o6.axis2, s4), J(i10);
}
function S4(a8, m5, g6, p5, u5 = false) {
  p5 || (p5 = z());
  const l11 = o2(t.get(), a8[1], -a8[0]), j8 = o2(t.get(), Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY), d6 = o2(t.get(), Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY), x6 = t.get(), V6 = m5.allVerticesUnordered;
  V6.forEach(({ pos: s4 }) => {
    o2(x6, j2(a8, s4), j2(l11, s4)), f3(j8, j8, x6), M(d6, d6, x6);
  });
  const T6 = 1e-6, E8 = o2(t.get(), d6[0] - j8[0] < T6 ? g6 / 2 : 0, d6[1] - j8[1] < T6 ? g6 / 2 : 0);
  e3(j8, j8, E8), u2(d6, d6, E8);
  const h9 = u5 ? V6.reduce((o6, i10) => o6 + (i10.pos[2] ?? 0), 0) / V6.length : 0;
  return l4(p5.basis1, a8, (d6[0] - j8[0]) / 2), l4(p5.basis2, l11, (d6[1] - j8[1]) / 2), o3(p5.origin, j8[0] * a8[0] + j8[1] * l11[0], j8[0] * a8[1] + j8[1] * l11[1], h9), u3(p5.origin, p5.origin, p5.basis1), u3(p5.origin, p5.origin, p5.basis2), J(p5), p5;
}

export {
  r4 as r,
  A3 as A,
  M4 as M,
  p3 as p,
  m3 as m,
  f6 as f,
  E6 as E,
  S2 as S,
  g4 as g,
  v4 as v,
  z4 as z,
  M5 as M2,
  R6 as R,
  D4 as D,
  U7 as U,
  q4 as q,
  f7 as f2,
  A4 as A2,
  c8 as c,
  l10 as l,
  h7 as h,
  V5 as V,
  T5 as T,
  S4 as S2
};
//# sourceMappingURL=chunk-7YU4QEOZ.js.map
