import {
  n as n4
} from "./chunk-5XLI5DPS.js";
import {
  e as e2,
  n as n3
} from "./chunk-W2EKXSEY.js";
import {
  a,
  u
} from "./chunk-DUZAVZR4.js";
import "./chunk-EK7HOTRR.js";
import {
  f as f2
} from "./chunk-5DFXT3PU.js";
import "./chunk-CKE7BUXC.js";
import "./chunk-B5SL7XHP.js";
import {
  W
} from "./chunk-3VXANCFN.js";
import "./chunk-MBQEPUQX.js";
import "./chunk-ODQ5APZK.js";
import "./chunk-G5IXTUNN.js";
import "./chunk-ZNQKJRCD.js";
import {
  f as f3
} from "./chunk-BA6HYZ35.js";
import "./chunk-GCTH5LET.js";
import "./chunk-Q7VRQYAO.js";
import "./chunk-SJB744AD.js";
import "./chunk-WM2VG5F2.js";
import "./chunk-IXFJYDA2.js";
import "./chunk-TTLSEJNG.js";
import "./chunk-U73R3I4U.js";
import "./chunk-VGXUPJSS.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import "./chunk-DLM5SBNY.js";
import "./chunk-EKZRA6TO.js";
import "./chunk-M5SP6ZBM.js";
import "./chunk-FAA2FDN5.js";
import {
  c
} from "./chunk-ZHSPVODX.js";
import {
  Z
} from "./chunk-2HGIYEIL.js";
import "./chunk-XX3OKYJS.js";
import "./chunk-OTCNIJ2H.js";
import {
  s as s2
} from "./chunk-JGA5YJWL.js";
import {
  e
} from "./chunk-GCI4MA3M.js";
import "./chunk-SJ2OBYX2.js";
import "./chunk-MDJNYPVI.js";
import "./chunk-Z6VKIQV2.js";
import "./chunk-4PXNA4MD.js";
import "./chunk-XDLV73DB.js";
import "./chunk-ARTU4L55.js";
import "./chunk-6VL5D5UP.js";
import "./chunk-6QHY54HZ.js";
import "./chunk-GXJJY3ND.js";
import "./chunk-5ONGWFJ3.js";
import "./chunk-PLNHHGHL.js";
import "./chunk-DFK6QMLO.js";
import "./chunk-EM7Y2JZC.js";
import "./chunk-AQFRVV3U.js";
import "./chunk-3GHCGAH2.js";
import "./chunk-HWUOAPTX.js";
import "./chunk-QHCKOBU7.js";
import "./chunk-K2OZ6WVC.js";
import {
  c as c2,
  ee,
  ne
} from "./chunk-MC6NAKKX.js";
import "./chunk-TF6255HN.js";
import "./chunk-GD4FJL3C.js";
import {
  n as n2
} from "./chunk-C5OQVQZF.js";
import {
  d as d3
} from "./chunk-XL5QPCXN.js";
import {
  B
} from "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-C5M24ACM.js";
import "./chunk-L4A2QJG4.js";
import "./chunk-ENINOZUZ.js";
import "./chunk-V2X4OKYI.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import "./chunk-T7F6Q6JJ.js";
import "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-3FUHCAX3.js";
import "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import "./chunk-2OFHDVO5.js";
import "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import {
  n
} from "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import "./chunk-7H3U4IJR.js";
import "./chunk-SMWUT52Z.js";
import {
  d as d2
} from "./chunk-AXZMNHTN.js";
import {
  f
} from "./chunk-5T3MJDSR.js";
import {
  C,
  N,
  T
} from "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import {
  H2 as H,
  I,
  qt
} from "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import "./chunk-5EI5H4QX.js";
import "./chunk-ZIE53VIV.js";
import "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import {
  d
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/layers/graphics/sources/csv/csv.js
var o = /^\s*"([\S\s]*)"\s*$/;
var l = /""/g;
var s3 = "\n";
var u2 = [",", " ", ";", "|", "	"];
function* c3(e3, t, n5) {
  let r = 0;
  for (; r <= e3.length; ) {
    const i2 = e3.indexOf(t, r), o2 = e3.slice(r, i2 > -1 ? i2 : void 0);
    r += o2.length + t.length, n5 && !o2.trim() || (yield o2);
  }
}
function f4(e3) {
  const t = e3.includes("\r\n") ? "\r\n" : s3;
  return c3(e3, t, true);
}
function a2(e3, t) {
  return c3(e3, t, false);
}
function d4(e3, t, n5) {
  e3 = e3.trim(), t = t?.trim();
  const r = [], o2 = Array.from(/* @__PURE__ */ new Set([n5?.delimiter, ...u2])).filter((e4) => null != e4);
  for (const i2 of o2) {
    const n6 = g(e3, i2).length, o3 = g(t, i2).length ?? n6;
    n6 > 1 && r.push({ weight: Math.min(n6, o3), delimiter: i2 });
  }
  const l2 = r.sort(({ weight: e4 }, { weight: t2 }) => t2 - e4).map(({ delimiter: e4 }) => e4);
  for (const s4 of l2) {
    const t2 = m(e3, s4).names, r2 = n4(t2, n5?.longitudeField, n5?.latitudeField);
    if (r2.longitudeFieldName && r2.latitudeFieldName) return { delimiter: s4, locationInfo: r2 };
  }
  return { delimiter: l2[0], locationInfo: null };
}
function* p(e3, t, n5, r = () => /* @__PURE__ */ Object.create(null)) {
  const i2 = f4(e3);
  i2.next();
  let u3 = "", c4 = "", d5 = 0, p2 = r(), m2 = 0;
  e: for (const f5 of i2) {
    const e4 = a2(f5, n5);
    for (const i3 of e4) if (u3 += c4 + i3, c4 = "", d5 += h(i3), d5 % 2 == 0) {
      if (d5 > 0) {
        const e5 = o.exec(u3);
        if (!e5) {
          p2 = r(), m2 = 0, u3 = "", d5 = 0;
          continue e;
        }
        p2[t[m2]] = e5[1].replaceAll(l, '"'), m2++;
      } else p2[t[m2]] = u3, m2++;
      u3 = "", d5 = 0;
    } else c4 = n5;
    0 === d5 ? (yield p2, p2 = r(), m2 = 0) : c4 = s3;
  }
}
function m(e3, t) {
  const r = g(e3, t).filter((e4) => null != e4), i2 = r.map((e4) => c2(e4));
  for (let n5 = i2.length - 1; n5 >= 0; n5--) i2[n5] || (i2.splice(n5, 1), r.splice(n5, 1));
  return { names: i2, aliases: r };
}
function g(e3, t) {
  if (!e3?.length) return [];
  const n5 = [];
  let r = "", i2 = "", s4 = 0;
  const u3 = a2(e3, t);
  for (const c4 of u3) if (r += i2 + c4, i2 = "", s4 += h(c4), s4 % 2 == 0) {
    if (s4 > 0) {
      const e4 = o.exec(r);
      e4 && n5.push(e4[1].replaceAll(l, '"'));
    } else n5.push(r);
    r = "", s4 = 0;
  } else i2 = t;
  return n5;
}
function h(e3) {
  let t = 0, n5 = 0;
  for (n5 = e3.indexOf('"', n5); n5 >= 0; ) t++, n5 = e3.indexOf('"', n5 + 1);
  return t;
}
function N2(e3, t, n5, i2, o2) {
  const l2 = [], s4 = p(e3, n5, t), u3 = [];
  for (const r of s4) {
    if (10 === u3.length) break;
    u3.push(r);
  }
  for (let c4 = 0; c4 < n5.length; c4++) {
    const e4 = n5[c4], t2 = i2[c4];
    if (e4 === o2.longitudeFieldName || e4 === o2.latitudeFieldName) l2.push({ name: e4, type: "esriFieldTypeDouble", alias: t2 });
    else {
      let n6;
      switch (b(u3.map((t3) => t3[e4]))) {
        case "integer":
          n6 = "esriFieldTypeInteger";
          break;
        case "double":
          n6 = "esriFieldTypeDouble";
          break;
        case "date":
          n6 = "esriFieldTypeDate";
          break;
        default:
          n6 = "esriFieldTypeString";
      }
      l2.push({ name: e4, type: n6, alias: t2, length: ne(n6) });
    }
  }
  return l2;
}
function b(t) {
  if (!t.length) return "string";
  const n5 = /[^+\-.,0-9]/;
  return t.map((t2) => {
    if ("" !== t2) {
      if (!n5.test(t2)) {
        let e3 = x(t2);
        if (!isNaN(e3)) return /[.,]/.test(t2) || !Number.isInteger(e3) || e3 > 214783647 || e3 < -214783648 ? "double" : "integer";
        if (t2.includes("E")) {
          if (e3 = Number(t2), !Number.isNaN(e3)) return "double";
          if (t2.includes(",") && (t2 = t2.replace(",", "."), e3 = Number(t2), !Number.isNaN(e3))) return "double";
        }
      }
      return e2(t2) ? "date" : "string";
    }
  }).reduce((e3, t2) => void 0 === e3 ? t2 : void 0 === t2 ? e3 : e3 === t2 ? t2 : "string" === e3 || "string" === t2 ? "string" : "double" === e3 || "double" === t2 ? "double" : void 0);
}
var x = (function() {
  const e3 = c(), n5 = new RegExp("^" + e3.regexp + "$"), r = new RegExp("[" + e3.group + "\\s\\xa0]", "g"), i2 = e3.factor;
  return (t) => {
    const o2 = n5.exec(t);
    if (e3.factor = i2, !o2) return NaN;
    let l2 = o2[1];
    if (!o2[1]) {
      if (!o2[2]) return NaN;
      l2 = o2[2], e3.factor *= -1;
    }
    return l2 = l2.replace(r, "").replace(e3.decimal, "."), +l2 * e3.factor;
  };
})();
function y(e3) {
  return JSON.parse(JSON.stringify(e3));
}

// node_modules/@arcgis/core/layers/graphics/sources/support/CSVSourceWorker.js
var v = u("esriGeometryPoint");
var D = ["csv"];
var k = [0, 0];
var P = class {
  constructor(e3, t) {
    this.x = e3, this.y = t;
  }
};
var R = class {
  constructor() {
    this._queryEngine = null, this._snapshotFeatures = async (e3) => {
      const t = await this._fetch(e3);
      return this._createFeatures(t);
    };
  }
  destroy() {
    this._queryEngine?.destroy(), this._queryEngine = null;
  }
  async load(e3, t = {}) {
    this._loadOptions = e3;
    const [i2] = await Promise.all([this._fetch(t.signal), this._checkProjection(e3?.parsingOptions?.spatialReference)]), n5 = V(i2, e3);
    this._locationInfo = n5.locationInfo, this._delimiter = n5.delimiter, this._queryEngine = this._createQueryEngine(n5);
    const r = this._createFeatures(i2);
    this._queryEngine.featureStore.addMany(r);
    const { fullExtent: s4, timeExtent: o2 } = await this._queryEngine.fetchRecomputedExtents();
    if (n5.layerDefinition.extent = s4, o2) {
      const { start: e4, end: t2 } = o2;
      n5.layerDefinition.timeInfo.timeExtent = [e4, t2];
    }
    return n5;
  }
  async applyEdits() {
    throw new s("csv-layer:editing-not-supported", "applyEdits() is not supported on CSVLayer");
  }
  async queryFeatures(e3 = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQuery(e3, t.signal);
  }
  async queryFeatureCount(e3 = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForCount(e3, t.signal);
  }
  async queryObjectIds(e3 = {}, t = {}) {
    await this._waitSnapshotComplete();
    return (await this._queryEngine.executeQueryForIds(e3, t.signal)).filter(n2);
  }
  async queryExtent(e3 = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForExtent(e3, t.signal);
  }
  async querySnapping(e3, t = {}) {
    return await this._waitSnapshotComplete(), await this._queryEngine.executeQueryForSnapping(e3, t.signal);
  }
  async queryAttributeBins(e3, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeAttributeBinsQuery(e3, t.signal);
  }
  async refresh(e3) {
    this._loadOptions.customParameters = e3, this._snapshotTask?.abort(), this._snapshotTask = d3(this._snapshotFeatures), this._snapshotTask.promise.then((e4) => {
      this._queryEngine.featureStore.clear(), e4 && this._queryEngine.featureStore.addMany(e4);
    }, (e4) => {
      this._queryEngine.featureStore.clear(), d(e4) || i.getLogger("esri.layers.CSVLayer").error(new s("csv-layer:refresh", "An error occurred during refresh", { error: e4 }));
    }), await this._waitSnapshotComplete();
    const { fullExtent: i2, timeExtent: o2 } = await this._queryEngine.fetchRecomputedExtents();
    return { extent: i2, timeExtent: o2 };
  }
  async _waitSnapshotComplete() {
    if (this._snapshotTask && !this._snapshotTask.finished) {
      try {
        await this._snapshotTask.promise;
      } catch {
      }
      return this._waitSnapshotComplete();
    }
  }
  async _fetch(t) {
    const { url: i2, customParameters: r } = this._loadOptions;
    if (!i2) throw new s("csv-layer:invalid-source", "url not defined");
    const s4 = I(i2);
    return (await H(s4.path, { query: { ...s4.query, ...r }, responseType: "text", signal: t })).data;
  }
  _createQueryEngine(e3) {
    const { objectIdField: t, fields: i2, extent: n5, timeInfo: r } = e3.layerDefinition, s4 = new f2({ geometryType: "esriGeometryPoint", hasM: false, hasZ: false }), o2 = { type: "object-id", fieldName: t };
    return new W({ fieldsIndex: Z.fromLayerJSON({ fields: i2, dateFieldsTimeReference: { timeZoneIANA: n } }), geometryType: "esriGeometryPoint", hasM: false, hasZ: false, timeInfo: r, featureIdInfo: o2, spatialReference: n5.spatialReference || { wkid: 4326 }, featureStore: s4 });
  }
  _createFeatures(e3) {
    const { latitudeFieldName: t, longitudeFieldName: n5 } = this._locationInfo, { objectIdField: r, fieldsIndex: s4, spatialReference: o2 } = this._queryEngine;
    let a3 = [];
    const u3 = [], h2 = s4.fields.filter((e4) => e4.name !== r).map((e4) => e4.name);
    let g2 = 0;
    const I2 = {};
    for (const i2 of s4.fields) if ("esriFieldTypeOID" !== i2.type && "esriFieldTypeGlobalID" !== i2.type) {
      const e4 = ee(i2);
      void 0 !== e4 && (I2[i2.name] = e4);
    }
    const E = p(e3, h2, this._delimiter, a(I2, r));
    for (const l2 of E) {
      const e4 = this._parseCoordinateValue(l2[t]), o3 = this._parseCoordinateValue(l2[n5]);
      if (null != o3 && null != e4 && !isNaN(e4) && !isNaN(o3)) {
        l2[t] = e4, l2[n5] = o3;
        for (const e5 in l2) if (e5 !== t && e5 !== n5) if (s4.isDateField(e5)) l2[e5] = n3(l2[e5]);
        else if (s4.isNumericField(e5)) {
          const t2 = x(l2[e5]);
          isNaN(t2) ? l2[e5] = null : l2[e5] = t2;
        } else null != l2[e5] && (l2[e5] = y(l2[e5]));
        l2[r] = g2, g2++, a3.push(new P(o3, e4)), u3.push(l2);
      }
    }
    if (!T({ wkid: 4326 }, o2)) if (C(o2)) for (const i2 of a3) [i2.x, i2.y] = d2(i2.x, i2.y, k);
    else a3 = B(a3, f.WGS84, o2);
    const T2 = [];
    for (let i2 = 0; i2 < a3.length; i2++) {
      const { x: e4, y: t2 } = a3[i2], n6 = u3[i2];
      n6[r] = i2 + 1, T2.push(new s2(new e([], [e4, t2]), n6, null, n6[r]));
    }
    return T2;
  }
  _parseCoordinateValue(e3) {
    if (null == e3 || "" === e3) return null;
    let t = x(e3);
    return (isNaN(t) || Math.abs(t) > 181) && (t = parseFloat(e3)), t;
  }
  async _checkProjection(e3) {
    try {
      await f3(N, e3);
    } catch {
      throw new s("csv-layer:projection-not-supported", "Projection not supported");
    }
  }
};
function V(e3, t) {
  const i2 = t.parsingOptions || {}, r = { delimiter: i2.delimiter, layerDefinition: null, locationInfo: { latitudeFieldName: i2.latitudeField, longitudeFieldName: i2.longitudeField } }, s4 = r.layerDefinition = { name: qt(t.url, D) || "csv", dateFieldsTimeReference: { timeZoneIANA: n }, drawingInfo: v, geometryType: "esriGeometryPoint", objectIdField: null, fields: [], timeInfo: i2.timeInfo, extent: { xmin: Number.POSITIVE_INFINITY, ymin: Number.POSITIVE_INFINITY, xmax: Number.NEGATIVE_INFINITY, ymax: Number.NEGATIVE_INFINITY, spatialReference: i2.spatialReference || { wkid: 4326 } } }, o2 = f4(e3), l2 = o2.next().value?.trim(), c4 = o2.next().value?.trim();
  if (!l2) throw new s("csv-layer:empty-csv", "CSV is empty", { csv: e3 });
  const { delimiter: m2, locationInfo: d5 } = d4(l2, c4, i2);
  if (!m2) throw new s("csv-layer:invalid-delimiter", "Unable to detect the delimiter from CSV", { firstLine: l2, secondLine: c4, parsingOptions: i2 });
  if (!d5) throw new s("csv-layer:location-fields-not-found", "Unable to identify latitude and longitude fields from the CSV file", { firstLine: l2, secondLine: c4, parsingOptions: i2 });
  r.locationInfo = d5, r.delimiter = m2;
  const { names: u3, aliases: f5 } = m(l2, m2), p2 = N2(e3, r.delimiter, u3, f5, r.locationInfo);
  if (i2.fields?.length) {
    const e4 = new Z(i2.fields);
    for (const t2 of p2) {
      const i3 = e4.get(t2.name);
      i3 && Object.assign(t2, i3);
    }
  }
  if (!p2.some((e4) => "esriFieldTypeOID" === e4.type && (s4.objectIdField = e4.name, true))) {
    const e4 = { name: "__OBJECTID", alias: "__OBJECTID", type: "esriFieldTypeOID", editable: false, nullable: false };
    s4.objectIdField = e4.name, p2.unshift(e4);
  }
  s4.fields = p2;
  const y2 = new Z(s4.fields);
  if (r.locationInfo && (r.locationInfo.latitudeFieldName = y2.get(r.locationInfo.latitudeFieldName).name, r.locationInfo.longitudeFieldName = y2.get(r.locationInfo.longitudeFieldName).name), s4.timeInfo) {
    const e4 = s4.timeInfo;
    if (e4.startTimeField) {
      const t2 = y2.get(e4.startTimeField);
      t2 ? (e4.startTimeField = t2.name, t2.type = "esriFieldTypeDate") : e4.startTimeField = null;
    }
    if (e4.endTimeField) {
      const t2 = y2.get(e4.endTimeField);
      t2 ? (e4.endTimeField = t2.name, t2.type = "esriFieldTypeDate") : e4.endTimeField = null;
    }
    if (e4.trackIdField) {
      const t2 = y2.get(e4.trackIdField);
      e4.trackIdField = t2 ? t2.name : null;
    }
    e4.startTimeField || e4.endTimeField || (s4.timeInfo = null);
  }
  return r;
}
export {
  R as default
};
//# sourceMappingURL=CSVSourceWorker-LS2Z674D.js.map
