import {
  Je,
  Ke,
  ge,
  oe,
  p as p2,
  te,
  ve,
  z
} from "./chunk-AH42IBBP.js";
import {
  n,
  o
} from "./chunk-4PXNA4MD.js";
import {
  n as n2,
  o as o2
} from "./chunk-C5OQVQZF.js";
import {
  M as M2,
  P,
  b,
  c as c2,
  d,
  f,
  f3 as f2,
  g,
  h3 as h,
  i,
  l,
  n2 as n3,
  o as o3,
  o2 as o4,
  p2 as p,
  q,
  s as s2,
  t,
  u2 as u,
  u3 as u2,
  u4 as u3,
  x,
  y3 as y
} from "./chunk-PZ5RULLK.js";
import {
  M
} from "./chunk-SMWUT52Z.js";
import {
  _,
  c
} from "./chunk-AXZMNHTN.js";
import {
  ae
} from "./chunk-NMQNUPE4.js";
import {
  s2 as s
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/arcade/functions/centroid.js
function e(t2, n4, e2) {
  return Math.sqrt((t2[0] - n4[0]) ** 2 + (t2[1] - n4[1]) ** 2 + (void 0 !== t2[2] && void 0 !== n4[2] ? (t2[2] * e2 - n4[2] * e2) ** 2 : 0));
}
function r(t2, n4, e2) {
  return (t2[0] - n4[0]) ** 2 + (t2[1] - n4[1]) ** 2 + (void 0 !== t2[2] && void 0 !== n4[2] ? (t2[2] * e2 - n4[2] * e2) ** 2 : 0);
}
var o5 = [];
for (const w2 of [[9002, 56146130, 6131, 6132, 8050, 8051, 8228], [9003, 5702, 6358, 6359, 6360, 8052, 8053], [9095, 5754]]) {
  const t2 = w2[0];
  for (let n4 = 1; n4 < w2.length; n4++) o5[w2[n4]] = t2;
}
var s3 = [];
function i2(t2) {
  return t2.vcsWkid && void 0 !== o5[t2.vcsWkid] ? s3[o5[t2.vcsWkid]] : t2.latestVcsWkid && void 0 !== o5[t2.latestVcsWkid] ? s3[o5[t2.latestVcsWkid]] : 1;
}
function f3(t2, n4, e2) {
  const r2 = n4[0] - t2[0], o6 = n4[1] - t2[1];
  if (e2) {
    const t3 = n4[2] - n4[2];
    return Math.sqrt(r2 * r2 + o6 * o6 + t3 * t3);
  }
  return Math.sqrt(r2 * r2 + o6 * o6);
}
function h2(t2, n4, e2) {
  const r2 = n4[0] - t2[0], o6 = n4[1] - t2[1];
  if (e2) {
    const t3 = n4[2] - n4[2];
    return r2 * r2 + o6 * o6 + t3 * t3;
  }
  return r2 * r2 + o6 * o6;
}
function m(t2, n4) {
  return t2.x * n4.x + t2.y * n4.y;
}
function M3(t2, n4) {
  return t2.x * n4.y - n4.x * t2.y;
}
function p3(t2, n4, e2 = 0) {
  for (; t2 < e2; ) t2 += n4;
  const r2 = e2 + n4;
  for (; t2 >= r2; ) t2 -= n4;
  return t2;
}
function g2(t2, n4) {
  return Math.atan2(n4.y - t2.y, n4.x - t2.x);
}
function z2(t2, n4) {
  return p3(g2(t2, n4), 2 * Math.PI) * (180 / Math.PI);
}
function d2(t2, n4) {
  return p3(Math.PI / 2 - g2(t2, n4), 2 * Math.PI) * (180 / Math.PI);
}
function v(t2, n4, e2) {
  const r2 = { x: t2.x - n4.x, y: t2.y - n4.y }, o6 = { x: e2.x - n4.x, y: e2.y - n4.y };
  return Math.atan2(M3(r2, o6), m(r2, o6));
}
function P2(n4, e2, r2) {
  return M(p3(v(n4, e2, r2), 2 * Math.PI));
}
function Z(n4, e2, r2) {
  return M(p3(-1 * v(n4, e2, r2), 2 * Math.PI));
}
function I(t2, n4, e2) {
  return Math.max(n4, Math.min(e2, t2));
}
function R(t2, n4) {
  return t2[0] * n4[0] + t2[1] * n4[1] + t2[2] * n4[2];
}
function k(t2) {
  return t2[0] * t2[0] + t2[1] * t2[1] + t2[2] * t2[2];
}
function W(t2, n4, e2) {
  const r2 = [e2[0] - n4[0], e2[1] - n4[1], e2[2] - n4[2]], o6 = I(R(r2, [t2[0] - n4[0], t2[1] - n4[1], t2[2] - n4[2]]) / k(r2), 0, 1);
  return [n4[0] + (e2[0] - n4[0]) * o6, n4[1] + (e2[1] - n4[1]) * o6, n4[2] + (e2[2] - n4[2]) * o6];
}
function q2(t2, n4, e2) {
  let r2 = 0;
  const o6 = e2[0] - n4[0], s4 = e2[1] - n4[1], i3 = o6 * o6 + s4 * s4;
  if (0 === i3) r2 = 0.5;
  else {
    r2 = ((t2[0] - n4[0]) * o6 + (t2[1] - n4[1]) * s4) / i3, r2 < 0 ? r2 = 0 : r2 > 1 && (r2 = 1);
  }
  return r2 <= 0.5 ? [n4[0] + (e2[0] - n4[0]) * r2, n4[1] + (e2[1] - n4[1]) * r2] : [e2[0] - (e2[0] - n4[0]) * (1 - r2), e2[1] - (e2[1] - n4[1]) * (1 - r2)];
}
s3[9002] = 0.3048, s3[9003] = 0.3048006096012192, s3[9095] = 0.3048007491;

// node_modules/@arcgis/core/geometry/support/curves/closestPointOnCurve.js
function u4(u5, j2, U2) {
  if (i(j2)) return s2(u5, j2, U2);
  if (t(j2)) {
    const t2 = b(u5, j2, U2)[0];
    if (null == t2) throw new s("closestPointOnCurve:unexpected-error", "Failed to find close point on bezier curve");
    return t2;
  }
  if (u3(j2)) {
    const r2 = l(u5, j2);
    return u(r2, U2);
  }
  if (c2(j2)) {
    const r2 = h(u5, j2);
    return u(r2, U2);
  }
  const v4 = p(u5, j2);
  return q(v4, U2);
}

// node_modules/@arcgis/core/geometry/support/curves/curveLength.js
function f4(f5, n4, p4 = 1) {
  if (t(n4)) return d(f5, n4, p4);
  if (u3(n4)) {
    const r2 = l(f5, n4);
    return r2.isInvalid ? Math.sqrt(o3(f5, n4.c[0])) : f(r2);
  }
  if (c2(n4)) {
    const r2 = h(f5, n4);
    return r2.isInvalid ? Math.sqrt(o3(f5, n4.a[0])) : f(r2);
  }
  return g(f5, n4, p4);
}

// node_modules/@arcgis/core/geometry/support/curves/splitCurveAtPoint.js
var j = 1e-6;
function U(r2, n4, o6, s4) {
  const c3 = b(r2, n4, o6).filter(({ distance: t2 }) => t2 <= s4), e2 = [];
  let u5 = 0, f5 = n4;
  for (const { t: t2 } of c3) {
    const n5 = (t2 - u5) / (1 - u5);
    if (n5 < j || 1 - n5 < j) continue;
    const [o7, s5] = M2(r2, f5, t2);
    e2.push(o7), f5 = s5, u5 = t2;
  }
  return e2.push(f5), e2;
}
function v2(t2, i3, s4, e2) {
  const u5 = l(t2, i3);
  if (u5.isInvalid) return [o4(i3)];
  const { t: f5, distance: l2 } = u(u5, s4);
  return l2 <= e2 ? u2(u5, i3, f5) : [o4(i3)];
}
function A(t2, i3, n4, o6) {
  const s4 = h(t2, i3);
  if (s4.isInvalid) return [o4(i3)];
  const { t: e2, distance: u5 } = u(s4, n4);
  return u5 <= o6 ? n3(s4, i3, e2) : [o4(i3)];
}
function I2(t2, i3, r2, n4) {
  const o6 = p(t2, i3);
  if (o6.isInvalid) return [o4(i3)];
  const { t: s4, distance: e2 } = q(o6, r2);
  return e2 <= n4 ? x(o6, i3, s4) : [o4(i3)];
}
function h3(t2, i3, r2, n4) {
  return i(i3) ? [o4(i3)] : t(i3) ? U(t2, i3, r2, n4) : u3(i3) ? v2(t2, i3, r2, n4) : c2(i3) ? A(t2, i3, r2, n4) : I2(t2, i3, r2, n4);
}

// node_modules/@arcgis/core/arcade/functions/measures.js
function g3(e2) {
  return Math.sqrt(e2[0] * e2[0] + e2[1] * e2[1] + e2[2] * e2[2]);
}
function y2(e2) {
  const t2 = g3(e2);
  return [e2[0] / t2, e2[1] / t2, e2[2] / t2];
}
function R2(e2, t2, n4, r2) {
  const s4 = y2([t2[0] - e2[0], t2[1] - e2[1], t2[2] * r2 - e2[2] * r2]);
  return [e2[0] + s4[0] * n4, e2[1] + s4[1] * n4, e2[2] + s4[2] * n4];
}
function x2(e2, t2, n4, r2) {
  return e2 + (t2 - e2) / n4 * r2;
}
function Z2(e2, t2, n4) {
  let r2 = t2[0] - e2[0], s4 = t2[1] - e2[1];
  const a = Math.sqrt(r2 * r2 + s4 * s4);
  return r2 /= a, s4 /= a, r2 *= n4, s4 *= n4, [e2[0] + r2, e2[1] + s4];
}
function M4(t2, n4) {
  if (!t2) return null;
  switch (t2.type) {
    case "extent":
    case "multipoint":
    case "mesh":
    case "point":
      return null;
  }
  const r2 = "polygon" === t2.type ? t2.rings : t2.paths;
  let s4 = 1;
  if (t2.spatialReference.vcsWkid || t2.spatialReference.latestVcsWkid) {
    s4 = i2(t2.spatialReference) / ae(t2.spatialReference);
  }
  if (0 === r2.length) return null;
  if (0 === r2[0].length) return null;
  if (false === t2.hasM) return null;
  let a = -1, i3 = 0;
  const { hasM: l2, hasZ: u5 } = t2, f5 = u5 ? 3 : 2, p4 = 2;
  for (const e2 of r2) {
    if (a++, e2.length > 0 && e2[0][f5] === n4) return { partId: a, distanceAlong: i3, coordinate: new _({ hasZ: u5, hasM: l2, spatialReference: t2.spatialReference, x: e2[0][0], y: e2[0][1], ...u5 ? { z: e2[0][p4] } : {}, ...l2 ? { m: e2[0][f5] } : {} }), segmentId: 0 };
    let r3 = -1;
    for (let o6 = 1; o6 < e2.length; o6++) {
      const h4 = k2(e2[o6 - 1], e2[o6], u5, s4);
      r3++;
      const m2 = e2[o6][f5] - e2[o6 - 1][f5], d3 = e2[o6][f5];
      if (d3 === n4) return { partId: a, distanceAlong: h4 + i3, coordinate: new _({ hasZ: u5, hasM: l2, spatialReference: t2.spatialReference, x: e2[o6][0], y: e2[o6][1], ...u5 ? { z: e2[o6][p4] } : {}, ...l2 ? { m: e2[o6][f5] } : {} }), segmentId: r3 };
      if (d3 > n4 && n4 > e2[o6 - 1][f5]) {
        const d4 = (n4 - e2[o6 - 1][f5]) / m2 * h4;
        let g4 = u5 ? R2(e2[o6 - 1], e2[o6], d4, s4) : Z2(e2[o6 - 1], e2[o6], d4);
        g4 = [...g4, n4];
        const y3 = new _({ hasZ: u5, hasM: l2, spatialReference: t2.spatialReference, x: g4[0], y: g4[1], ...u5 ? { z: g4[p4] } : {}, ...l2 ? { m: g4[f5] } : {} });
        return { partId: a, distanceAlong: i3 + k2(e2[o6 - 1], [y3.x, y3.y, ...u5 ? [y3.z] : [], ...l2 ? [y3.m] : []], u5, s4), coordinate: y3, segmentId: r3 };
      }
      i3 += h4;
    }
  }
  return null;
}
function v3(t2, n4) {
  if (!t2) return null;
  switch (t2.type) {
    case "extent":
    case "multipoint":
    case "mesh":
    case "point":
      return null;
  }
  const r2 = "polygon" === t2.type ? t2.rings : t2.paths;
  if (n4 < 0) return null;
  let s4 = 1;
  if (t2.spatialReference.vcsWkid || t2.spatialReference.latestVcsWkid) {
    s4 = i2(t2.spatialReference) / ae(t2.spatialReference);
  }
  let a = 0;
  const { hasZ: i3, hasM: l2 } = t2, u5 = i3 ? 3 : 2, f5 = 2;
  let p4 = -1;
  if (0 === n4) return 0 === r2.length || 0 === r2[0].length ? null : { partId: 0, coordinate: new _({ hasZ: i3, hasM: l2, spatialReference: t2.spatialReference, x: r2[0][0][0], y: r2[0][0][1], ...i3 ? { z: r2[0][0][f5] } : {}, ...l2 ? { m: r2[0][0][u5] } : {} }), segmentId: 0 };
  for (const e2 of r2) {
    p4++;
    let r3 = -1;
    for (let o6 = 1; o6 < e2.length; o6++) {
      r3++;
      const h4 = k2(e2[o6 - 1], e2[o6], i3, s4), m2 = a + h4;
      if (m2 === n4) return { partId: p4, coordinate: new _({ hasZ: i3, hasM: l2, spatialReference: t2.spatialReference, x: e2[o6][0], y: e2[o6][1], ...i3 ? { z: e2[o6][f5] } : {}, ...l2 ? { m: e2[o6][u5] } : {} }), segmentId: r3 };
      if (m2 > n4) {
        let m3 = i3 ? R2(e2[o6 - 1], e2[o6], n4 - a, s4) : Z2(e2[o6 - 1], e2[o6], n4 - a);
        return m3 = [...m3, x2(e2[o6 - 1][u5], e2[o6][u5], h4, n4 - a)], { partId: p4, coordinate: new _({ hasZ: i3, hasM: l2, spatialReference: t2.spatialReference, x: m3[0], y: m3[1], ...i3 ? { z: m3[f5] } : {}, ...l2 ? { m: m3[u5] } : {} }), segmentId: r3 };
      }
      a = m2;
    }
  }
  return null;
}
function I3(r2, s4) {
  if (!r2) return null;
  if (!s4) return null;
  let a = 1;
  if (s4.spatialReference.vcsWkid || s4.spatialReference.latestVcsWkid) {
    a = i2(s4.spatialReference) / ae(s4.spatialReference);
  }
  let i3 = null, l2 = 0;
  return i3 = r2, l2 = r2.hasZ && s4.hasZ ? e([s4.x, s4.y, s4.z], [r2.x, r2.y, r2.z], a) : f3([s4.x, s4.y], [r2.x, r2.y], false), { coordinate: i3, distance: l2 };
}
function w(t2, n4) {
  if (!t2) return null;
  if (!n4) return null;
  let a = 1;
  if (n4.spatialReference.vcsWkid || n4.spatialReference.latestVcsWkid) {
    a = i2(n4.spatialReference) / ae(n4.spatialReference);
  }
  let i3 = null, l2 = 0, c3 = Number.MAX_VALUE, u5 = -1, f5 = -1;
  for (const e2 of t2.points || []) {
    f5++;
    const i4 = t2.hasZ && n4.hasZ ? r([e2[0], e2[1], e2[2]], [n4.x, n4.y, n4.z], a) : h2([e2[0], e2[1]], [n4.x, n4.y], false);
    i4 < c3 && (c3 = i4, u5 = f5);
  }
  return u5 < 0 ? null : (l2 = c3, i3 = t2.getPoint(u5), { coordinate: i3, distance: Math.sqrt(l2) });
}
function z3(t2, n4) {
  if (!t2) return null;
  if (!n4) return null;
  const r2 = "polygon" === t2.type ? t2.curveRings ?? t2.rings : t2.curvePaths ?? t2.paths;
  let s4 = 1;
  if (n4.spatialReference.vcsWkid || n4.spatialReference.latestVcsWkid) {
    s4 = i2(n4.spatialReference) / ae(n4.spatialReference);
  }
  let a = Number.MAX_VALUE, i3 = -1, l2 = -1, u5 = -1;
  const f5 = t2.hasZ && n4.hasZ;
  let p4 = null;
  const g4 = f5 ? [n4.x, n4.y, n4.z] : [n4.x, n4.y];
  for (const e2 of r2) {
    l2++;
    for (let t3 = 1; t3 < e2.length; t3++) {
      const n5 = P3(g4, e2[t3 - 1], e2[t3], f5, s4);
      n5.distance < a && (a = n5.distance, p4 = n5.closestPoint, u5 = l2, i3 = t3 - 1);
    }
  }
  if (i3 < 0 || !p4) return null;
  const y3 = t2.hasM && t2.hasZ ? 3 : 2, R4 = 2, Z3 = r2[u5][i3], M5 = f2(Z3), v4 = r2[u5][i3 + 1], I5 = f2(v4);
  let w2 = null, z5 = null, W3 = f5 ? p4[2] : null;
  const j2 = i(v4) ? p4 : h3(M5, v4, p4, 1e-3)[0];
  let A3 = k2(M5, j2, f5, s4);
  const V = k2(M5, v4, f5, s4);
  t2.hasM && (z5 = x2(M5[y3], I5[y3], V, A3)), !t2.hasZ || false !== n4.hasZ && i(j2) || (W3 = x2(M5[R4], I5[R4], V, A3), f2(j2)[R4] = W3, A3 = k2(M5, j2, true, s4)), w2 = new _({ hasZ: f5, hasM: t2.hasM, spatialReference: n4.spatialReference, x: p4[0], y: p4[1], ...t2.hasZ ? { z: W3 } : {}, ...t2.hasM ? { m: z5 } : {} });
  let L = 0;
  for (let e2 = 0; e2 <= u5; e2++) {
    const n5 = r2[e2], a2 = e2 === u5 ? i3 : n5.length - 1;
    for (let e3 = 1; e3 <= a2; e3++) L += k2(f2(n5[e3 - 1]), n5[e3], t2.hasZ, s4);
  }
  return L += A3, { partId: u5, segmentId: i3, coordinate: w2, distance: a, distanceAlong: L };
}
function P3(e2, r2, s4, o6, c3) {
  const u5 = f2(r2);
  if (i(s4)) {
    const r3 = o6 ? W(e2, u5, s4) : q2(e2, u5, s4);
    return { closestPoint: r3, distance: o6 ? e(r3, e2, c3) : f3(r3, e2, false) };
  }
  const p4 = u4(u5, s4, e2);
  if (!p4) throw new s("arcade:closestPointOnSegment", "The given point is not on the curve");
  return { closestPoint: p4.curvePoint, distance: p4.distance };
}
function k2(e2, r2, s4, a) {
  return i(r2) ? s4 ? e(e2, r2, a) : f3(e2, r2, false) : f4(e2, r2, 1e-3);
}
function W2(e2, t2) {
  if (!e2) return null;
  if (!t2) return null;
  if ("extent" === e2.type) {
    const t3 = e2;
    e2 = new P({ spatialReference: e2.spatialReference, rings: [[[t3.xmin, t3.ymin], [t3.xmin, t3.ymax], [t3.xmax, t3.ymax], [t3.xmax, t3.ymin], [t3.xmin, t3.ymin]]] });
  }
  switch (e2.type) {
    case "point":
      return I3(e2, t2) ?? null;
    case "multipoint":
      return w(e2, t2) ?? null;
    case "polygon":
    case "polyline":
      return z3(e2, t2) ?? null;
    default:
      return null;
  }
}

// node_modules/@arcgis/core/arcade/geometry/functions.js
function P4(e2, n4, o6) {
  if (oe(e2, 2, 2, n4, o6), e2[0] instanceof c && e2[1] instanceof c) ;
  else if (e2[0] instanceof c && null === e2[1]) ;
  else if (e2[1] instanceof c && null === e2[0]) ;
  else if (null !== e2[0] || null !== e2[1]) throw new n(n4, "InvalidParameter", o6);
}
function x3(e2) {
  if ("polygon" !== e2.type && "polyline" !== e2.type && "extent" !== e2.type) return 0;
  let n4 = 1;
  if (e2.spatialReference.vcsWkid || e2.spatialReference.latestVcsWkid) {
    n4 = i2(e2.spatialReference) / ae(e2.spatialReference);
  }
  let t2 = 0;
  if ("polyline" === e2.type) for (const r2 of e2.paths) for (let e3 = 1; e3 < r2.length; e3++) t2 += e(r2[e3], r2[e3 - 1], n4);
  else if ("polygon" === e2.type) for (const r2 of e2.rings) {
    for (let e3 = 1; e3 < r2.length; e3++) t2 += e(r2[e3], r2[e3 - 1], n4);
    (r2[0][0] !== r2[r2.length - 1][0] || r2[0][1] !== r2[r2.length - 1][1] || void 0 !== r2[0][2] && r2[0][2] !== r2[r2.length - 1][2]) && (t2 += e(r2[0], r2[r2.length - 1], n4));
  }
  else "extent" === e2.type && (t2 += 2 * e([e2.xmin, e2.ymin, 0], [e2.xmax, e2.ymin, 0], n4), t2 += 2 * e([e2.xmin, e2.ymin, 0], [e2.xmin, e2.ymax, 0], n4), t2 *= 2, t2 += 4 * Math.abs(z(e2.zmax, 0) * n4 - z(e2.zmin, 0) * n4));
  return t2;
}
var I4 = (n4, o6, i3) => {
  if (i3 = Je(i3), oe(i3, 2, 2, n4, o6), null === i3[0]) return null;
  let u5 = i3[0];
  if ((o2(i3[0]) || te(i3[0])) && (u5 = ve(i3[0], n4.spatialReference)), null === u5) return null;
  if (!(u5 instanceof c)) throw new n(n4, "InvalidParameter", o6);
  if (!(u5 instanceof y)) throw new n(n4, "InvalidParameter", o6);
  if (!n2(i3[1])) throw new n(n4, "InvalidParameter", o6);
  const c3 = M4(u5, i3[1]);
  return c3 ? p2.convertObjectToArcadeDictionary(c3, Ke(n4), false, true) : null;
};
var R3 = (n4, o6, i3) => {
  if (i3 = Je(i3), oe(i3, 2, 2, n4, o6), null === i3[0]) return null;
  let u5 = i3[0];
  if ((o2(i3[0]) || te(i3[0])) && (u5 = ve(i3[0], n4.spatialReference)), null === u5) return null;
  if (!(u5 instanceof c)) throw new n(n4, "InvalidParameter", o6);
  if (!(u5 instanceof y)) throw new n(n4, "InvalidParameter", o6);
  const c3 = i3[1];
  if (null === c3) return null;
  if (!(c3 instanceof _)) throw new n(n4, "InvalidParameter", o6);
  const m2 = W2(u5, c3);
  return m2 ? p2.convertObjectToArcadeDictionary(m2, Ke(n4), false, true) : null;
};
var b2 = (n4, o6, i3) => {
  if (i3 = Je(i3), oe(i3, 2, 2, n4, o6), null === i3[0]) return null;
  let u5 = i3[0];
  if ((o2(i3[0]) || te(i3[0])) && (u5 = ve(i3[0], n4.spatialReference)), null === u5) return null;
  if (!(u5 instanceof c)) throw new n(n4, "InvalidParameter", o6);
  if (!(u5 instanceof y)) throw new n(n4, "InvalidParameter", o6);
  if (!n2(i3[1])) throw new n(n4, "InvalidParameter", o6);
  const c3 = v3(u5, i3[1]);
  return c3 ? p2.convertObjectToArcadeDictionary(c3, Ke(n4), false, true) : null;
};
var k3 = new o(["geodesic", "great-elliptic", "loxodrome", "normal-section", "shape-preserving"]);
function D(e2) {
  return null == e2 ? "geodesic" : k3.get(ge(e2));
}
var A2 = new o(["geometric", "labelPoint"]);
function O(e2) {
  return null == e2 ? "geometric" : A2.get(ge(e2));
}
var T = new o(["round", "bevel", "miter", "square"]);
function z4(e2) {
  return null == e2 ? "round" : T.lookup(ge(e2)) ?? "round";
}

export {
  z2 as z,
  d2 as d,
  P2 as P,
  Z,
  P4 as P2,
  x3 as x,
  I4 as I,
  R3 as R,
  b2 as b,
  D,
  O,
  z4 as z2
};
//# sourceMappingURL=chunk-EC6KNOF4.js.map
