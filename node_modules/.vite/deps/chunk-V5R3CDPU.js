import {
  e as e6
} from "./chunk-6GZZL5MR.js";
import {
  c2 as c,
  d,
  f2,
  f3,
  i,
  i2 as i3,
  o as o2,
  p as p2,
  t as t3
} from "./chunk-YTJAN3CY.js";
import {
  e as e7,
  f as f4,
  n2 as n4,
  p as p3,
  t2 as t4,
  v
} from "./chunk-T6CRNJ3D.js";
import {
  a as a2,
  f as f5,
  n as n3,
  p as p4
} from "./chunk-Z4KE5G4E.js";
import {
  l
} from "./chunk-KEMYAF6M.js";
import {
  r as r3
} from "./chunk-7YJLACUB.js";
import {
  o as o3
} from "./chunk-HETHJJO6.js";
import {
  n as n5
} from "./chunk-CHC4AAHW.js";
import {
  d2 as d3,
  o,
  r3 as r5
} from "./chunk-I4DSU5MJ.js";
import {
  e as e5
} from "./chunk-MCWHCMX6.js";
import {
  n as n2
} from "./chunk-FCDWKXLA.js";
import {
  l as l2,
  r as r2,
  u
} from "./chunk-KTMKDXZP.js";
import {
  i as i2
} from "./chunk-CT7HOWYG.js";
import {
  o2 as o4,
  t as t2
} from "./chunk-BZBDEPRV.js";
import {
  p
} from "./chunk-MXP2VO3L.js";
import {
  d as d2,
  f
} from "./chunk-OWSUTT7E.js";
import {
  e as e2
} from "./chunk-COMSADUT.js";
import {
  e
} from "./chunk-IT62DCG6.js";
import {
  e as e4
} from "./chunk-SZ5DGQ75.js";
import {
  s
} from "./chunk-WJ3E33GQ.js";
import {
  r as r4
} from "./chunk-YOYO2XMY.js";
import {
  e as e3
} from "./chunk-SZTZNZQW.js";
import {
  n,
  t
} from "./chunk-CFXCM2NO.js";
import {
  a
} from "./chunk-WDTGOP77.js";
import {
  r
} from "./chunk-3OVERDFX.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ComputeNormalTexture.glsl.js
function d4(d6, l3) {
  const c2 = d6.fragment, { hasVertexTangents: i5, doubleSidedMode: x, hasNormalTexture: T, textureCoordinateType: u2, bindType: g, hasNormalTextureTransform: v2 } = l3;
  i5 ? (d6.attributes.add("tangent", "vec4"), d6.varyings.add("vTangent", "vec4"), 2 === x ? c2.code.add(t`mat3 computeTangentSpace(vec3 normal) {
float tangentHeadedness = gl_FrontFacing ? vTangent.w : -vTangent.w;
vec3 tangent = normalize(gl_FrontFacing ? vTangent.xyz : -vTangent.xyz);
vec3 bitangent = cross(normal, tangent) * tangentHeadedness;
return mat3(tangent, bitangent, normal);
}`) : c2.code.add(t`mat3 computeTangentSpace(vec3 normal) {
float tangentHeadedness = vTangent.w;
vec3 tangent = normalize(vTangent.xyz);
vec3 bitangent = cross(normal, tangent) * tangentHeadedness;
return mat3(tangent, bitangent, normal);
}`)) : c2.code.add(t`mat3 computeTangentSpace(vec3 normal, vec3 pos, vec2 st) {
vec3 Q1 = dFdx(pos);
vec3 Q2 = dFdy(pos);
vec2 stx = dFdx(st);
vec2 sty = dFdy(st);
float det = stx.t * sty.s - sty.t * stx.s;
vec3 T = stx.t * Q2 - sty.t * Q1;
T = T - normal * dot(normal, T);
T *= inversesqrt(max(dot(T,T), 1.e-10));
vec3 B = sign(det) * cross(normal, T);
return mat3(T, B, normal);
}`), T && 0 !== u2 && (d6.include(r5, l3), c2.uniforms.add(1 === g ? new e3("normalTexture", (e8) => e8.textureNormal) : new e5("normalTexture", (e8) => e8.textureNormal)), v2 && (c2.uniforms.add(new e4("scale", (e8) => e8.scale ?? a)), c2.uniforms.add(new t2("normalTextureTransformMatrix", (t6) => t6.normalTextureTransformMatrix ?? r))), c2.code.add(t`vec3 computeTextureNormal(mat3 tangentSpace, vec2 uv) {
vec3 rawNormal = textureLookup(normalTexture, uv).rgb * 2.0 - 1.0;`), v2 && c2.code.add(t`mat3 normalRotation = mat3(normalTextureTransformMatrix[0][0]/scale[0], normalTextureTransformMatrix[0][1]/scale[1], 0.0,
normalTextureTransformMatrix[1][0]/scale[0], normalTextureTransformMatrix[1][1]/scale[1], 0.0,
0.0, 0.0, 0.0 );
rawNormal.xy = (normalRotation * vec3(rawNormal.x, rawNormal.y, 1.0)).xy;`), c2.code.add(t`return tangentSpace * rawNormal;
}`));
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/TextureTransformUV.glsl.js
function a3(a4, s3) {
  s3.hasColorTextureTransform ? (a4.varyings.add("colorUV", "vec2"), a4.vertex.uniforms.add(new t2("colorTextureTransformMatrix", (e8) => e8.colorTextureTransformMatrix ?? r)).code.add(t`void forwardColorUV(){
colorUV = (colorTextureTransformMatrix * vec3(vuv0, 1.0)).xy;
}`)) : a4.vertex.code.add(t`void forwardColorUV(){}`);
}
function s2(a4, s3) {
  s3.hasNormalTextureTransform && 0 !== s3.textureCoordinateType ? (a4.varyings.add("normalUV", "vec2"), a4.vertex.uniforms.add(new t2("normalTextureTransformMatrix", (e8) => e8.normalTextureTransformMatrix ?? r)).code.add(t`void forwardNormalUV(){
normalUV = (normalTextureTransformMatrix * vec3(vuv0, 1.0)).xy;
}`)) : a4.vertex.code.add(t`void forwardNormalUV(){}`);
}
function i4(a4, s3) {
  s3.hasEmissionTextureTransform && 0 !== s3.textureCoordinateType ? (a4.varyings.add("emissiveUV", "vec2"), a4.vertex.uniforms.add(new t2("emissiveTextureTransformMatrix", (e8) => e8.emissiveTextureTransformMatrix ?? r)).code.add(t`void forwardEmissiveUV(){
emissiveUV = (emissiveTextureTransformMatrix * vec3(vuv0, 1.0)).xy;
}`)) : a4.vertex.code.add(t`void forwardEmissiveUV(){}`);
}
function d5(a4, s3) {
  s3.hasOcclusionTextureTransform && 0 !== s3.textureCoordinateType ? (a4.varyings.add("occlusionUV", "vec2"), a4.vertex.uniforms.add(new t2("occlusionTextureTransformMatrix", (e8) => e8.occlusionTextureTransformMatrix ?? r)).code.add(t`void forwardOcclusionUV(){
occlusionUV = (occlusionTextureTransformMatrix * vec3(vuv0, 1.0)).xy;
}`)) : a4.vertex.code.add(t`void forwardOcclusionUV(){}`);
}
function t5(a4, s3) {
  s3.hasMetallicRoughnessTextureTransform && 0 !== s3.textureCoordinateType ? (a4.varyings.add("metallicRoughnessUV", "vec2"), a4.vertex.uniforms.add(new t2("metallicRoughnessTextureTransformMatrix", (e8) => e8.metallicRoughnessTextureTransformMatrix ?? r)).code.add(t`void forwardMetallicRoughnessUV(){
metallicRoughnessUV = (metallicRoughnessTextureTransformMatrix * vec3(vuv0, 1.0)).xy;
}`)) : a4.vertex.code.add(t`void forwardMetallicRoughnessUV(){}`);
}

// node_modules/@arcgis/core/chunks/DefaultMaterial.glsl.js
function J(J2) {
  const K2 = new s(), { attributes: Q, vertex: X, fragment: Y, varyings: Z } = K2, { output: ee, normalType: re, offsetBackfaces: oe, spherical: ie, snowCover: ae, pbrMode: le, textureAlphaPremultiplied: se, instancedDoublePrecision: ne, hasVertexColors: te, hasVertexTangents: de, hasColorTexture: ce, hasNormalTexture: me, hasNormalTextureTransform: ge, hasColorTextureTransform: ue } = J2;
  if (f(X, J2), Q.add("position", "vec3"), Z.add("vpos", "vec3", { invariant: true }), K2.include(u, J2), K2.include(p2, J2), K2.include(n2, J2), K2.include(a3, J2), !o(ee)) return K2.include(f3, J2), K2;
  K2.include(s2, J2), K2.include(i4, J2), K2.include(d5, J2), K2.include(t5, J2), d2(X, J2), K2.include(o2, J2), K2.include(o3);
  const ve = 0 === re || 1 === re;
  return ve && oe && K2.include(c), K2.include(d4, J2), K2.include(d, J2), K2.include(t3, J2), Z.add("vPositionLocal", "vec3"), K2.include(d3, J2), K2.include(i, J2), K2.include(r3, J2), X.uniforms.add(new e2("externalColor", (e8) => e8.externalColor, { supportsNaN: true })), Z.add("vcolorExt", "vec4"), K2.include(i2, J2), X.include(r2), X.include(l2), K2.include(ne ? p4 : f5, J2), X.main.add(t`
    forwardNormalizedVertexColor();

    MaskedColor maskedColor =
      applySymbolColor(applyVVColor(applyInstanceColor(createMaskedFromNaNColor(externalColor))));

    vcolorExt = maskedColor.color;
    forwardColorMixMode(maskedColor.mask);

    vpos = getVertexInLocalOriginSpace();
    vPositionLocal = vpos - view[3].xyz;
    vpos = subtractOrigin(vpos);
    ${n(ve, "vNormalWorld = dpNormal(vvLocalNormal(normalModel()));")}
    vpos = addVerticalOffset(vpos, localOrigin);
    ${n(de, "vTangent = dpTransformVertexTangent(tangent);")}
    gl_Position = transformPosition(proj, view, vpos);
    ${n(ve && oe, "gl_Position = offsetBackfacingClipPosition(gl_Position, vpos, vNormalWorld, cameraPosition);")}

    forwardViewPosDepth((view * vec4(vpos, 1.0)).xyz);
    forwardTextureCoordinates();
    forwardColorUV();
    forwardNormalUV();
    forwardEmissiveUV();
    forwardOcclusionUV();
    forwardMetallicRoughnessUV();

    if (opacityMixMode != ${t.int(l.ignore)} && vcolorExt.a < ${t.float(o4)}) {
      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
    }
    forwardLinearDepthToReadShadowMap();
  `), K2.include(f4, J2), Y.include(t4, J2), K2.include(f2, J2), Y.include(p, J2), K2.include(n5, J2), d2(Y, J2), Y.uniforms.add(X.uniforms.get("localOrigin"), new e("ambient", (e8) => e8.ambient), new e("diffuse", (e8) => e8.diffuse), new r4("opacity", (e8) => e8.opacity), new r4("layerOpacity", (e8) => e8.layerOpacity)), ce && Y.uniforms.add(new e3("tex", (e8) => e8.texture)), K2.include(n4, J2), Y.include(n3, J2), Y.include(i3), K2.include(e6, J2), Y.include(e7, J2), p3(Y), v(Y), a2(Y), Y.main.add(t`
    discardBySlice(vpos);
    discardByTerrainDepth();
    ${ce ? t`
            vec4 texColor = texture(tex, ${ue ? "colorUV" : "vuv0"});
            ${n(se, "texColor.rgb /= texColor.a;")}
            discardOrAdjustAlpha(texColor);` : t`vec4 texColor = vec4(1.0);`}
    shadingParams.viewDirection = normalize(vpos - cameraPosition);
    ${2 === re ? t`vec3 normal = screenDerivativeNormal(vPositionLocal);` : t`shadingParams.normalView = vNormalWorld;
                vec3 normal = shadingNormal(shadingParams);`}
    applyPBRFactors();
    float ssao = evaluateAmbientOcclusionInverse() * getBakedOcclusion();

    vec3 posWorld = vpos + localOrigin;

    float additionalAmbientScale = additionalDirectedAmbientLight(posWorld);
    float shadow = readShadow(additionalAmbientScale, vpos);

    vec3 matColor = max(ambient, diffuse);
    vec3 albedo = mixExternalColor(${n(te, "vColor.rgb *")} matColor, texColor.rgb, vcolorExt.rgb, colorMixMode);
    float opacity_ = layerOpacity * mixExternalOpacity(${n(te, "vColor.a * ")} opacity, texColor.a, vcolorExt.a, opacityMixMode);

    ${me ? `mat3 tangentSpace = computeTangentSpace(${de ? "normal" : "normal, vpos, vuv0"});
            vec3 shadingNormal = computeTextureNormal(tangentSpace, ${ge ? "normalUV" : "vuv0"});` : "vec3 shadingNormal = normal;"}
    vec3 normalGround = ${ie ? "normalize(posWorld);" : "vec3(0.0, 0.0, 1.0);"}

    ${n(ae, t`
          float snow = getSnow(normal, normalGround);
          albedo = mix(albedo, vec3(1), snow);
          shadingNormal = mix(shadingNormal, normal, snow);
          ssao = mix(ssao, 1.0, snow);`)}

    vec3 additionalLight = ssao * mainLightIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;

    ${1 === le || 2 === le ? t`
            float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * mainLightIntensity[2];
            ${n(ae, "mrr = applySnowToMRR(mrr, snow);")}
            vec3 shadedColor = evaluateSceneLightingPBR(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight, shadingParams.viewDirection, normalGround, mrr, additionalAmbientIrradiance);` : t`vec3 shadedColor = evaluateSceneLighting(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight);`}
    vec4 finalColor = vec4(shadedColor, opacity_);
    outputColorHighlightOID(finalColor, vpos, albedo ${n(ae, ", snow")});
  `), K2;
}
var K = Object.freeze(Object.defineProperty({ __proto__: null, build: J }, Symbol.toStringTag, { value: "Module" }));

export {
  J,
  K
};
//# sourceMappingURL=chunk-V5R3CDPU.js.map
