import {
  o
} from "./chunk-A3JORY5L.js";
import {
  c
} from "./chunk-BZV32YR7.js";
import {
  a
} from "./chunk-W6L6ZQPE.js";
import {
  e
} from "./chunk-6GHQTYW5.js";
import {
  s
} from "./chunk-WJ3E33GQ.js";
import {
  r
} from "./chunk-YOYO2XMY.js";
import {
  e as e2
} from "./chunk-SZTZNZQW.js";
import {
  n,
  t
} from "./chunk-CFXCM2NO.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js
function t2(t3) {
  t3.code.add(t`const float MAX_RGBA_FLOAT =
255.0 / 256.0 +
255.0 / 256.0 / 256.0 +
255.0 / 256.0 / 256.0 / 256.0 +
255.0 / 256.0 / 256.0 / 256.0 / 256.0;
const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);
vec4 float2rgba(const float value) {
float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);
vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);
const float toU8AsFloat = 1.0 / 255.0;
return fixedPointU8 * toU8AsFloat;
}`), t3.code.add(t`const vec4 RGBA_TO_FLOAT_FACTORS = vec4(
255.0 / (256.0),
255.0 / (256.0 * 256.0),
255.0 / (256.0 * 256.0 * 256.0),
255.0 / (256.0 * 256.0 * 256.0 * 256.0)
);
float rgbaTofloat(vec4 rgba) {
return dot(rgba, RGBA_TO_FLOAT_FACTORS);
}`), t3.code.add(t`const vec4 uninterpolatedRGBAToFloatFactors = vec4(
1.0 / 256.0,
1.0 / 256.0 / 256.0,
1.0 / 256.0 / 256.0 / 256.0,
1.0 / 256.0 / 256.0 / 256.0 / 256.0
);
float uninterpolatedRGBAToFloat(vec4 rgba) {
return (dot(round(rgba * 255.0), uninterpolatedRGBAToFloatFactors) - 0.5) * 2.0;
}`), t3.code.add(t`const vec3 uninterpolatedRGBToFloatFactors = vec3(
1.0 / 256.0,
1.0 / 256.0 / 256.0,
1.0 / 256.0 / 256.0 / 256.0
);
float uninterpolatedRGBToFloat(vec3 rgb) {
return (dot(round(rgb * 255.0), uninterpolatedRGBToFloatFactors) - 0.5) * 2.0;
}`);
}

// node_modules/@arcgis/core/chunks/Compositing.glsl.js
var m = class extends c {
  constructor() {
    super(...arguments), this.opacity = 1;
  }
};
function g(l) {
  const m2 = new s(), { blitEmissiveMode: g2, blitMode: c3, hasOpacityFactor: f } = l;
  m2.include(o), m2.fragment.uniforms.add(new e2("tex", (e3) => e3.texture)), f && m2.fragment.uniforms.add(new r("opacity", (e3) => e3.opacity));
  const u = 3 === c3;
  u && (m2.fragment.uniforms.add(new e("nearFar", (e3) => e3.camera.nearFar)), m2.fragment.include(a), m2.fragment.include(t2));
  const p = 1 === g2;
  return p && (m2.outputs.add("fragColor", "vec4", 0), m2.outputs.add("fragEmission", "vec4", 1)), m2.fragment.main.add(t`
    ${u ? t`
          float normalizedLinearDepth = (-linearDepthFromTexture(tex, uv) - nearFar[0]) / (nearFar[1] - nearFar[0]);
          fragColor = float2rgba(normalizedLinearDepth);` : t`
          fragColor = texture(tex, uv) ${f ? "* opacity" : ""};`}
    ${n(p, "fragEmission = vec4(0.0, 0.0, 0.0, fragColor.a);")}`), m2;
}
var c2 = Object.freeze(Object.defineProperty({ __proto__: null, CompositingPassParameters: m, build: g }, Symbol.toStringTag, { value: "Module" }));

export {
  m,
  g,
  c2 as c
};
//# sourceMappingURL=chunk-PLLKRMGV.js.map
