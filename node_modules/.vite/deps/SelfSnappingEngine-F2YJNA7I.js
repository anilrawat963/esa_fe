import {
  h,
  h2
} from "./chunk-GGINWBRK.js";
import {
  r as r2,
  s as s3
} from "./chunk-IJG47UFZ.js";
import "./chunk-M6NE6PU7.js";
import {
  p as p3
} from "./chunk-Z3EPMK46.js";
import {
  U as U2,
  y as y2
} from "./chunk-VHCNEAMV.js";
import "./chunk-2XEDAAX5.js";
import {
  i
} from "./chunk-ZG2JXORT.js";
import "./chunk-OL6EYE44.js";
import {
  g,
  j as j2,
  k,
  y as y3
} from "./chunk-36YQJD5W.js";
import {
  Dt,
  O as O2
} from "./chunk-BQ6DEXWK.js";
import {
  a as a2,
  c as c3,
  d2,
  m as m3,
  p as p2,
  s as s2,
  y2 as y
} from "./chunk-3SCRAN3E.js";
import "./chunk-NTNXXNRP.js";
import {
  c as c2,
  v
} from "./chunk-IGRCAVBL.js";
import {
  U
} from "./chunk-GD72EK2J.js";
import "./chunk-B3BLJNSM.js";
import "./chunk-ALKEERWI.js";
import "./chunk-U6CJFTOF.js";
import "./chunk-2JMKFI2D.js";
import "./chunk-QYAMBIRP.js";
import "./chunk-JHV6OBEB.js";
import "./chunk-WHHIH5YU.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import "./chunk-4VQDBNTM.js";
import "./chunk-3BNOOWTA.js";
import "./chunk-AIJLLSRB.js";
import "./chunk-VX2NEBRT.js";
import "./chunk-7HTU7ZUX.js";
import {
  n as n2
} from "./chunk-WDTGOP77.js";
import {
  c,
  o,
  q
} from "./chunk-VYMBX5H5.js";
import "./chunk-647DAMHU.js";
import "./chunk-O6G3PPOK.js";
import "./chunk-ZKNZTIAS.js";
import "./chunk-OJMISN3F.js";
import "./chunk-EFV6H5NA.js";
import {
  r,
  s
} from "./chunk-5ONGWFJ3.js";
import "./chunk-BBYMM7CM.js";
import "./chunk-EM7Y2JZC.js";
import "./chunk-QZQPB5XR.js";
import "./chunk-AQFRVV3U.js";
import "./chunk-XTZAIV4X.js";
import "./chunk-63LDVRFI.js";
import "./chunk-PMGS7UDU.js";
import "./chunk-K2OZ6WVC.js";
import "./chunk-TF6255HN.js";
import "./chunk-GD4FJL3C.js";
import "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-MHV23XAQ.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import "./chunk-T7F6Q6JJ.js";
import {
  O
} from "./chunk-YDTPM7OQ.js";
import {
  n
} from "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-3FUHCAX3.js";
import "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import {
  _,
  b as b2,
  d,
  e,
  j,
  m as m2,
  p
} from "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import "./chunk-2OFHDVO5.js";
import "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-CCQFL76O.js";
import "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import "./chunk-7H3U4IJR.js";
import "./chunk-SMWUT52Z.js";
import "./chunk-AXZMNHTN.js";
import "./chunk-5T3MJDSR.js";
import {
  ae
} from "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import {
  b,
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import "./chunk-GNMPGHLQ.js";
import "./chunk-QY7XKUIV.js";
import "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/views/interactive/snapping/SnappingAlgorithm.js
var l = class {
  constructor(e2, t) {
    this.view = e2, this.options = t, this.squaredShortLineThreshold = p3.shortLineThreshold * p3.shortLineThreshold;
  }
  snap(e2, t) {
    return null != t.vertexHandle ? "vertex" !== t.vertexHandle.type ? [] : this.snapExistingVertex(e2, t) : this.snapNewVertex(e2, t);
  }
  edgeExceedsShortLineThreshold(e2, t) {
    return this.exceedsShortLineThreshold(m3(e2.leftVertex.pos, this.view, t), m3(e2.rightVertex.pos, this.view, t), t);
  }
  exceedsShortLineThreshold(e2, t, { spatialReference: s4 }) {
    return 0 === this.squaredShortLineThreshold || g(s3(t, s4, U, this.view), s3(e2, s4, U, this.view)) > this.squaredShortLineThreshold;
  }
  isVertical(r3, s4, { spatialReference: h4 }) {
    const n3 = ae(h4);
    return m2(s2(r3), s2(s4)) * n3 < p3.verticalLineThresholdMeters;
  }
  squaredProximityThreshold(e2) {
    return "touch" === e2 ? this._squaredTouchProximityThreshold : this._squaredMouseProximityThreshold;
  }
  get _squaredMouseProximityThreshold() {
    return this.options.distance * this.options.distance;
  }
  get _squaredTouchProximityThreshold() {
    const { distance: e2, touchSensitivityMultiplier: t } = this.options, r3 = e2 * t;
    return r3 * r3;
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/LineSnapper.js
var S = class extends l {
  constructor(e2, t, s4) {
    super(e2, t), this._geodesicLengthMeasurementUtils = s4;
  }
  snapNewVertex(e2, t) {
    const s4 = t.editGeometryOperations.data.parts[0], r3 = s4.segments.length, i2 = [];
    if (r3 < 1) return i2;
    const { spatialReference: n3 } = t, a3 = s3(e2, n3, U, this.view), { view: l2 } = this, p4 = s4.segments[r3 - 1];
    let d4 = p4;
    do {
      if (k(d4) && this.edgeExceedsShortLineThreshold(d4, t)) {
        const s5 = j2(d4, l2, t);
        this._processCandidateProposal(s5.left, s5.right, e2, a3, t, i2);
      }
      d4 = d4.leftVertex.leftSegment;
    } while (d4 && d4 !== p4);
    return i2;
  }
  snapExistingVertex(e2, t) {
    const s4 = [], r3 = t.vertexHandle, i2 = r3.part;
    if (i2.segments.length < 2) return s4;
    const { view: a3 } = this, { spatialReference: l2 } = t, p4 = s3(e2, l2, U, a3), d4 = r3.leftSegment, m5 = r3.rightSegment;
    k(d4) && k(m5) && this.edgeExceedsShortLineThreshold(d4, t) && this.edgeExceedsShortLineThreshold(m5, t) && this._processCandidateProposal(m3(d4.leftVertex.pos, a3, t), m3(m5.rightVertex.pos, a3, t), e2, p4, t, s4);
    const f2 = i2.segments[0];
    let u2 = f2;
    do {
      if (k(u2) && u2 !== r3.leftSegment && u2 !== r3.rightSegment && this.edgeExceedsShortLineThreshold(u2, t)) {
        const r4 = j2(u2, a3, t);
        this._processCandidateProposal(r4.left, r4.right, e2, p4, t, s4);
      }
      u2 = u2.rightVertex.rightSegment;
    } while (u2 && u2 !== f2);
    return s4;
  }
  _processCandidateProposal(e2, t, s4, r3, n3, p4) {
    const { spatialReference: h4, pointer: c4 } = n3, f2 = n();
    j3(f2, e2, t, s4, n3, this._geodesicLengthMeasurementUtils);
    const u2 = p2(c3(f2));
    g(r3, s3(u2, h4, U, this.view)) < this.squaredProximityThreshold(c4) && p4.push(new i({ lineStart: e2, lineEnd: t, targetPoint: u2, isDraped: "on-the-ground" === n3.elevationInfo?.mode }));
  }
};
function j3(e2, t, s4, r3, i2, o2) {
  v2(e2, t, s4, r3, i2, o2) || w(e2, r3, t, s4);
}
function v2(i2, o2, n3, a3, { spatialReference: l2 }, p4) {
  const h4 = y2(o2, n3, l2, l2);
  if (null == h4) return false;
  const c4 = y2(n3, a3, l2, l2);
  if (null == c4) return false;
  const d4 = p4.geodesicDistance(n3, a3, l2);
  if (null == d4) return false;
  const m5 = Math.abs(s.shortestSignedDiff(h4, c4)) > Math.PI / 2 ? r.normalize(h4 + Math.PI) : h4;
  return U2(i2, n3, l2, v(d4, "meters"), c2(m5, "radians", "geographic"), "geodesic"), i2[2] = a3[2], true;
}
function w(e2, t, s4, r3) {
  O2(t, { start: s4, end: r3, type: 1 }, e2), e2[2] = t[2];
}

// node_modules/@arcgis/core/views/interactive/snapping/ParallelLineSnapper.js
var d3 = class extends l {
  snapNewVertex(e2, t) {
    const s4 = t.editGeometryOperations.data.parts[0], n3 = s4.segments.length, o2 = s4.vertices.length, l2 = [];
    if (n3 < 2) return l2;
    const { view: a3 } = this, p4 = s3(e2, t.spatialReference, U, a3), g2 = s4.vertices[0], f2 = s4.vertices[o2 - 1], d4 = k(f2.leftSegment) ? m3(f2.pos, a3, t) : null, u2 = k(g2.rightSegment) ? m3(g2.pos, a3, t) : null, v4 = s4.segments[n3 - 1];
    let x = v4;
    do {
      if (k(x) && this.edgeExceedsShortLineThreshold(x, t)) {
        const r3 = j2(x, a3, t);
        d4 && this._checkEdgeForParallelLines(r3, d4, e2, p4, t, l2), u2 && this._checkEdgeForParallelLines(r3, u2, e2, p4, t, l2);
      }
      x = x.leftVertex.leftSegment;
    } while (x && x !== v4);
    return l2;
  }
  snapExistingVertex(e2, t) {
    const s4 = [], n3 = t.vertexHandle, o2 = n3.part;
    if (o2.segments.length < 3) return s4;
    const { view: l2 } = this, a3 = s3(e2, t.spatialReference, U, l2), p4 = n3.leftSegment, g2 = n3.rightSegment, f2 = o2.vertices[0], d4 = m3(f2.pos, l2, t), u2 = o2.vertices.length, v4 = o2.vertices[u2 - 1], x = m3(v4.pos, l2, t), L = o2.segments[0];
    let S2 = L;
    do {
      if (k(S2) && S2 !== p4 && S2 !== g2 && this.edgeExceedsShortLineThreshold(S2, t)) {
        const r3 = j2(S2, l2, t);
        k(p4) && this._checkEdgeForParallelLines(r3, m3(p4.leftVertex.pos, l2, t), e2, a3, t, s4), k(g2) && this._checkEdgeForParallelLines(r3, m3(g2.rightVertex.pos, l2, t), e2, a3, t, s4), n3 === f2 ? this._checkEdgeForParallelLines(r3, x, e2, a3, t, s4) : n3 === v4 && this._checkEdgeForParallelLines(r3, d4, e2, a3, t, s4);
      }
      S2 = S2.rightVertex.rightSegment;
    } while (S2 && S2 !== L);
    return s4;
  }
  _checkEdgeForParallelLines(t, i2, a3, c4, h4, d4) {
    const x = t.left, L = t.right;
    if (y(v3, s2(i2), s2(x), s2(L)), b2(v3, s2(i2)) < p3.parallelLineThreshold) return;
    y(v3, s2(a3), s2(x), s2(L), s2(i2));
    const { spatialReference: S2, pointer: P2 } = h4, j4 = p2(a2(v3[0], v3[1], a3[2]));
    if (g(c4, s3(j4, S2, U, this.view)) < this.squaredProximityThreshold(P2)) {
      if (this.isVertical(j4, i2, h4) || this.isVertical(x, L, h4)) return;
      if (u(t, d4)) return;
      d4.push(new h({ referenceLine: t, lineStart: i2, targetPoint: j4, isDraped: "on-the-ground" === h4.elevationInfo?.mode }));
    }
  }
};
function u(t, r3) {
  const i2 = t.left, n3 = t.right;
  for (const o2 of r3) if (y(v3, s2(n3), s2(o2.constraint.start), s2(o2.constraint.end), s2(i2)), b2(v3, s2(n3)) < p3.parallelLineThreshold) return o2.addReferenceLine(t), true;
  return false;
}
var v3 = n2();

// node_modules/@arcgis/core/views/interactive/snapping/RightAngleSnapper.js
var y4 = class extends l {
  constructor(e2, t, r3) {
    super(e2, t), this._geodesicLengthMeasurementUtils = r3;
  }
  snapNewVertex(e2, t) {
    const r3 = t.editGeometryOperations.data.parts[0], i2 = [];
    if (r3.vertices.length < 2) return i2;
    const { view: n3 } = this, s4 = s3(e2, t.spatialReference, U, n3), o2 = r3.vertices.at(-1);
    k(o2.leftSegment) && this._checkForSnappingCandidate(1, i2, o2.leftSegment, o2, o2.leftSegment.leftVertex, e2, s4, t);
    const a3 = r3.vertices[0];
    return k(a3.rightSegment) && this._checkForSnappingCandidate(2, i2, a3.rightSegment, a3, a3.rightSegment.rightVertex, e2, s4, t), i2;
  }
  snapExistingVertex(e2, t) {
    const r3 = [], i2 = t.vertexHandle;
    if (i2.part.vertices.length < 3) return r3;
    const { view: n3 } = this, s4 = s3(e2, t.spatialReference, U, n3), o2 = i2.leftSegment, a3 = i2.rightSegment;
    if (k(o2?.leftVertex.leftSegment)) {
      const i3 = o2.leftVertex.leftSegment;
      this._checkForSnappingCandidate(3, r3, i3, i3.rightVertex, i3.leftVertex, e2, s4, t);
    }
    if (k(a3) && k(a3.rightVertex.rightSegment)) {
      const i3 = a3.rightVertex.rightSegment;
      this._checkForSnappingCandidate(3, r3, i3, i3.leftVertex, i3.rightVertex, e2, s4, t);
    }
    return r3;
  }
  _checkForSnappingCandidate(e2, t, r3, i2, n3, s4, o2, a3) {
    if (!k(r3) || !this.edgeExceedsShortLineThreshold(r3, a3)) return;
    const c4 = this.view, p4 = m3(i2.pos, c4, a3), g2 = m3(n3.pos, c4, a3);
    F(P, g2, p4, s4, a3, this._geodesicLengthMeasurementUtils), this._checkForSnappingCandidateAlongProjectedRay(e2, t, g2, p4, P, s4, o2, a3);
  }
  _checkForSnappingCandidateAlongProjectedRay(e2, t, r3, a3, p4, g2, f2, j4) {
    const { spatialReference: v4, pointer: _2 } = j4, w2 = e(M, s2(g2), s2(a3)), y5 = j(p4, w2) / p(p4), F2 = d(M, s2(a3), p4, y5), R2 = p2(a2(F2[0], F2[1], g2[2]));
    if (g(f2, s3(R2, v4, U, this.view)) > this.squaredProximityThreshold(_2) || this.isVertical(R2, a3, j4) || this.isVertical(a3, r3, j4)) return;
    const U4 = q(n(), a3, p4, Math.sign(y5));
    t.push(new r2({ targetPoint: R2, constraint: new Dt(a3, c3(U4)), previousVertex: r3, otherVertex: a3, otherVertexType: 1, selfSnappingType: e2, isDraped: "on-the-ground" === j4.elevationInfo?.mode }));
  }
};
function F(e2, t, r3, i2, n3, s4) {
  R(e2, t, r3, i2, n3, s4) || U3(e2, t, r3);
}
function R(i2, n3, s4, o2, { spatialReference: a3 }, c4) {
  const g2 = y2(n3, s4, a3, a3);
  if (null == g2) return false;
  const l2 = y2(s4, o2, a3, a3);
  if (null == l2) return false;
  const m5 = Math.sign(r.shortestSignedDiff(g2, l2)) * Math.PI * 0.5, f2 = c2(g2 + m5, "radians", "geographic"), d4 = n(), u2 = c4.geodesicDistance(s4, o2, a3);
  return null != u2 && (U2(d4, s4, a3, v(u2, "meters"), f2, "geodesic"), c(i2, d4, s4), true);
}
function U3(e2, t, r3) {
  const n3 = e(M, s2(r3), s2(t));
  o(e2, n3[1], -n3[0], 0);
}
var M = n2();
var P = n();

// node_modules/@arcgis/core/views/interactive/snapping/RightAngleTriangleSnapper.js
var h3 = class extends l {
  snapNewVertex(e2, t) {
    const i2 = t.editGeometryOperations.data.parts[0], r3 = [], o2 = i2.vertices.length;
    if ("polygon" !== t.editGeometryOperations.data.type || o2 < 2) return r3;
    const { view: n3 } = this, p4 = i2.vertices[0], a3 = i2.vertices[o2 - 1];
    if (a3.leftSegment && "line" !== a3.leftSegment.type || a3.rightSegment && "line" !== a3.rightSegment.type) return r3;
    const l2 = m3(p4.pos, n3, t), m5 = m3(a3.pos, n3, t);
    return this._processCandidateProposal(l2, m5, e2, t, r3), r3;
  }
  snapExistingVertex(e2, t) {
    const i2 = [], r3 = t.vertexHandle, o2 = r3.part;
    if (o2.segments.length < 2) return i2;
    if ("polyline" === t.editGeometryOperations.data.type && (0 === r3.index || r3.index === o2.vertices.length - 1)) return i2;
    if ("line" !== r3.leftSegment?.type || "line" !== r3.rightSegment?.type) return i2;
    const { view: n3 } = this, p4 = m3(r3.leftSegment.leftVertex.pos, n3, t), a3 = m3(r3.rightSegment.rightVertex.pos, n3, t);
    return this._processCandidateProposal(p4, a3, e2, t, i2), i2;
  }
  _processCandidateProposal(i2, s4, a3, h4, c4) {
    if (!this.exceedsShortLineThreshold(i2, s4, h4)) return;
    const u2 = _(f, s2(i2), s2(s4), 0.5), v4 = 0.5 * m2(s2(i2), s2(s4)), x = d2(f, s2(a3), u2, v4), y5 = p2(a2(x[0], x[1], a3[2])), { spatialReference: S2, pointer: j4 } = h4, w2 = s3(a3, S2, U, this.view);
    if (g(w2, s3(y5, S2, U, this.view)) < this.squaredProximityThreshold(j4)) {
      if (this.isVertical(i2, y5, h4) || this.isVertical(y5, s4, h4)) return;
      c4.push(new h2({ targetPoint: y5, point1: i2, point2: s4, isDraped: "on-the-ground" === h4.elevationInfo?.mode }));
    }
  }
};
var f = n2();

// node_modules/@arcgis/core/views/interactive/snapping/SelfSnappingEngine.js
var m4 = class extends b {
  constructor(s4) {
    super(s4), this.updating = false, this._snappers = new O(), this._domain = 2;
  }
  initialize() {
    this._snappers.push(new d3(this.view, this.options), new S(this.view, this.options, this.geodesicLengthMeasurementUtils), new y4(this.view, this.options, this.geodesicLengthMeasurementUtils), new h3(this.view, this.options));
  }
  set options(s4) {
    this._set("options", s4);
    for (const t of this._snappers) t.options = s4;
  }
  async fetchCandidates(s4, t, o2) {
    if (!(t & this._domain && this.options.effectiveSelfEnabled)) return [];
    const e2 = [];
    for (const i2 of this._snappers.items) for (const t2 of i2.snap(s4, o2)) e2.push(t2);
    return y3(s4, e2), e2;
  }
};
__decorate([m({ readOnly: true })], m4.prototype, "updating", void 0), __decorate([m({ constructOnly: true })], m4.prototype, "view", void 0), __decorate([m({ constructOnly: true })], m4.prototype, "geodesicLengthMeasurementUtils", void 0), __decorate([m()], m4.prototype, "options", null), m4 = __decorate([a("esri.views.interactive.snapping.SelfSnappingEngine")], m4);
export {
  m4 as SelfSnappingEngine
};
//# sourceMappingURL=SelfSnappingEngine-F2YJNA7I.js.map
