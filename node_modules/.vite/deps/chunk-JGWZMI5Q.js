import {
  s as s3
} from "./chunk-RZOWZMPW.js";
import {
  s as s2
} from "./chunk-WJ3E33GQ.js";
import {
  A,
  h
} from "./chunk-U55FA2EK.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  r2 as r
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i,
  s2 as s,
  t
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/graph/ShaderGraphNode.js
function t2(t5) {
  return t5.split(" ").map((t6, e3) => e3 > 0 ? t6.charAt(0).toUpperCase() + t6.slice(1) : t6).join("");
}
function e(t5, e3) {
  const s6 = [];
  for (s6.push(e3); s6.length; ) {
    const e4 = s6.pop();
    if ("object" == typeof e4 && !t5.has(e4.uid)) {
      t5.add(e4.uid);
      for (const t6 of e4.children) s6.push(t6);
    }
  }
}
var _s = class _s {
  constructor() {
    this.uid = _s.NodeCount++, this._debugName = null, this._isMutable = false, this.isImplicit = false;
  }
  get isMutable() {
    return this._isMutable;
  }
  setMutable() {
    return this._isMutable = true, this;
  }
  setDebugName(e3) {
    return e3 = t2(e3), this._debugName = e3, this.isImplicit && this.children[0] instanceof _s && this.children[0].setDebugName(e3), this;
  }
  get debugInfo() {
    return { name: this._debugName ?? "" };
  }
  cloneInto(t5) {
    t5._debugName = this._debugName, t5._isMutable = this._isMutable, t5.isImplicit = this.isImplicit, t5.uid = this.uid;
  }
};
_s.NodeCount = 0;
var s4 = _s;
function i2(t5) {
  return "object" == typeof t5 ? t5.clone() : t5;
}
var r2 = class extends s4 {
  constructor() {
    super(...arguments), this.shaderType = "primitive-node";
  }
};
var n = class _n extends s4 {
  constructor(t5) {
    super(), this.child = t5, this.shaderType = "scope-node";
  }
  get children() {
    return [this.child];
  }
  clone() {
    const t5 = new _n(i2(this.child));
    return this.cloneInto(t5), t5;
  }
};
var c = class _c extends s4 {
  constructor(t5, e3, s6) {
    super(), this.property = t5, this.target = e3, this.returnType = s6, this.shaderType = "property-access-node";
  }
  get children() {
    const t5 = [this.target];
    return "string" != typeof this.property && t5.push(this.property), t5;
  }
  clone() {
    const t5 = new _c(this.property, i2(this.target), this.returnType);
    return this.cloneInto(t5), t5;
  }
};
var o = class _o extends s4 {
  constructor(t5, e3, s6, i3) {
    super(), this.x = t5, this.y = e3, this.target = s6, this.returnType = i3, this.shaderType = "property-access-2d-node";
  }
  get children() {
    return [this.target, this.x, this.y];
  }
  clone() {
    const t5 = new _o(this.x, this.y, i2(this.target), this.returnType);
    return this.cloneInto(t5), t5;
  }
};
var u = class _u extends s4 {
  constructor(t5, e3, s6) {
    super(), this.condition = t5, this.ifTrue = e3, this.ifFalse = s6, this.shaderType = "condition-node";
  }
  get children() {
    return [this.condition, this.ifTrue, this.ifFalse];
  }
  clone() {
    const t5 = i2(this.ifTrue), e3 = this.ifFalse ? i2(this.ifFalse) : null, s6 = new _u(this.condition, t5, e3);
    return this.cloneInto(s6), s6;
  }
};
var p = class _p extends s4 {
  constructor(t5, e3, s6, i3) {
    super(), this.captureList = t5, this.returnType = e3, this.generator = i3, this.shaderType = "block-node", s6 && (this.subgraph = new n(s6));
  }
  get children() {
    return Object.keys(this.captureList).map((t5) => this.captureList[t5]).concat(this.subgraph ?? []);
  }
  clone() {
    const t5 = {};
    for (const s6 in this.captureList) t5[s6] = i2(this.captureList[s6]);
    const e3 = new _p(t5, this.returnType, this.subgraph ? i2(this.subgraph.child) : this.subgraph, this.generator);
    return this.cloneInto(e3), e3;
  }
};
var a = class _a15 extends s4 {
  constructor(t5, e3, s6, i3, r5, n4 = false) {
    super(), this.token = t5, this._children = e3, this.isInfix = s6, this.isPropertyAccess = i3, this.returnType = r5, this.isTernary = n4, this.shaderType = "function-node";
  }
  get children() {
    return this._children;
  }
  clone() {
    const t5 = new _a15(this.token, this._children.map(i2), this.isInfix, this.isPropertyAccess, this.returnType, this.isTernary);
    return this.cloneInto(t5), t5;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/graph/glsl.js
var h2;
var l;
var a2;
var f;
var p2;
var d;
var y;
var w;
var m;
var v;
var b;
var g;
var x;
var I;
function D(t5) {
  switch (t5.type) {
    case "bool":
    case "bvec2":
    case "bvec3":
    case "bvec4":
      return J;
    case "float":
    case "vec2":
    case "vec3":
    case "vec4":
      return C;
    case "int":
    case "ivec2":
    case "ivec3":
    case "ivec4":
      return W;
    case "uint":
    case "uvec2":
    case "uvec3":
    case "uvec4":
      return G;
    default:
      throw new Error("Unable to handle type");
  }
}
function k(t5) {
  const e3 = [["float", "vec2", "vec3", "vec4"], ["int", "ivec2", "ivec3", "ivec4"], ["uint", "uvec2", "uvec3", "uvec4"], ["bool", "bvec2", "bvec3", "bvec4"]];
  for (const n4 of e3) if (n4.includes(t5)) return n4.map((t6) => ct[t6]);
  throw new Error("Unable to find type family");
}
function M(t5) {
  return new Proxy(t5, { get(e3, n4) {
    if ("constructor" === n4) return new Proxy(e3.constructor, { construct: (t6, e4, n5) => M(new t6(...e4)) });
    if (n4 in e3) return e3[n4];
    if ("string" == typeof n4) {
      const e4 = k(t5.type);
      return dt(t5, n4, e4[n4.length - 1]);
    }
  } });
}
function S(t5) {
  return new Proxy(t5, { construct: (t6, e3, n4) => M(new t6(...e3)) });
}
function R(t5) {
  return new Proxy(t5, { get(e3, n4) {
    if (n4 in e3) return e3[n4];
    if ("string" == typeof n4) {
      const e4 = parseInt(n4, 10);
      if (!isNaN(e4)) return dt(t5, `[${e4}]`, t5.elementType.constructor);
    }
  } });
}
function j(t5) {
  return new Proxy(t5, { construct: (t6, e3, n4) => R(new t6(...e3)) });
}
var P = class extends Error {
};
var _a;
var B = (_a = class extends r2 {
  constructor(t5, e3) {
    super(), this.elementType = t5, this.size = e3, this.children = [], this.type = "array";
  }
  clone() {
    const t5 = new h2(this.elementType, this.size);
    return super.cloneInto(t5), t5;
  }
  get(t5, e3) {
    const n4 = new W(t5), r5 = null != e3 ? new W(e3) : null;
    if (null != r5) {
      return yt(this, n4, r5, D(this.elementType.constructor));
    }
    return dt(this, n4, this.elementType.constructor);
  }
  last() {
    return this.get(this.size - 1);
  }
  first() {
    return this.get(0);
  }
  findIndex(t5, e3, n4) {
    return Et(this, t5, e3, n4);
  }
  glslFindIndex(t5, e3, n4) {
    return $t(this, t5, e3, n4);
  }
  static ofType(t5, e3) {
    const n4 = { construct: (n5, r5) => new h2(new t5(), e3) };
    return new Proxy(h2, n4);
  }
}, h2 = _a, _a.type = "array", _a);
B = h2 = __decorate([j], B);
var _q = class _q extends r2 {
  constructor(t5, e3, n4, r5 = false) {
    super(), this.elementType = t5, this.xSize = e3, this.ySize = n4, this.isRowMajor = r5, this.children = [], this.type = "array-2d";
  }
  clone() {
    const t5 = new _q(this.elementType, this.xSize, this.ySize, this.isRowMajor);
    return super.cloneInto(t5), t5;
  }
  get size() {
    return this.xSize * this.ySize;
  }
  get(t5, e3) {
    return this.isRowMajor ? this._getRowMajor(t5, e3) : this._getColumnMajor(t5, e3);
  }
  _getColumnMajor(t5, e3) {
    const n4 = new W(t5);
    return dt(this, new W(e3).add(n4.multiply(this.xSize)), this.elementType.constructor);
  }
  _getRowMajor(t5, e3) {
    const n4 = new W(t5), r5 = new W(e3);
    return dt(this, n4.add(r5.multiply(this.ySize)), this.elementType.constructor);
  }
  static ofType(t5, e3, n4, r5 = false) {
    return new Proxy(B, { construct: (i3, c2) => new _q(new t5(), e3, n4, r5) });
  }
};
_q.type = "array-2d";
var q = _q;
var _U = class _U extends r2 {
  constructor() {
    super(...arguments), this.type = "sampler2D", this.children = [];
  }
  clone() {
    const t5 = new _U();
    return t5.children = this.children.map(i2), super.cloneInto(t5), t5;
  }
};
_U.type = "sampler2D";
var U = _U;
var _C = class _C extends r2 {
  constructor(t5) {
    super(), this.type = "float", this.children = [t5];
  }
  clone() {
    const t5 = new _C(i2(this.children[0]));
    return super.cloneInto(t5), t5;
  }
  multiply(t5) {
    return Dt(this, "number" == typeof t5 ? O(t5, _C) : t5);
  }
  divide(t5) {
    return Ft(this, "number" == typeof t5 ? O(t5, _C) : t5);
  }
  add(t5) {
    return kt(this, "number" == typeof t5 ? O(t5, _C) : t5);
  }
  subtract(t5) {
    return Mt(this, "number" == typeof t5 ? O(t5, _C) : t5);
  }
};
_C.type = "float";
var C = _C;
var _a2;
var X = (_a2 = class extends r2 {
  constructor(t5, e3) {
    super(), this.type = "vec2", this.children = [t5, e3].filter((t6) => null != t6);
  }
  clone() {
    const t5 = new l(i2(this.children[0]), i2(this.children[1]));
    return super.cloneInto(t5), t5;
  }
  get 0() {
    return dt(this, "[0]", C);
  }
  get 1() {
    return dt(this, "[1]", C);
  }
  get 2() {
    throw new P();
  }
  get 3() {
    throw new P();
  }
  multiply(t5) {
    return Dt(this, "number" == typeof t5 ? O(t5, C) : t5);
  }
  divide(t5) {
    return Ft(this, "number" == typeof t5 ? O(t5, C) : t5);
  }
  add(t5) {
    return kt(this, "number" == typeof t5 ? O(t5, C) : t5);
  }
  subtract(t5) {
    return Mt(this, "number" == typeof t5 ? O(t5, C) : t5);
  }
}, l = _a2, _a2.type = "vec2", _a2);
X = l = __decorate([S], X);
var _a3;
var Y = (_a3 = class extends r2 {
  constructor(t5, e3, n4) {
    super(), this.type = "vec3", this.children = [t5, e3, n4].filter((t6) => null != t6);
  }
  get 0() {
    return dt(this, "[0]", C);
  }
  get 1() {
    return dt(this, "[1]", C);
  }
  get 2() {
    return dt(this, "[2]", C);
  }
  get 3() {
    throw new P();
  }
  clone() {
    const t5 = new a2(i2(this.children[0]), i2(this.children[1]), i2(this.children[2]));
    return super.cloneInto(t5), t5;
  }
  multiply(t5) {
    return Dt(this, "number" == typeof t5 ? O(t5, C) : t5);
  }
  divide(t5) {
    return Ft(this, "number" == typeof t5 ? O(t5, C) : t5);
  }
  add(t5) {
    return kt(this, "number" == typeof t5 ? O(t5, C) : t5);
  }
  subtract(t5) {
    return Mt(this, "number" == typeof t5 ? O(t5, C) : t5);
  }
}, a2 = _a3, _a3.type = "vec3", _a3);
Y = a2 = __decorate([S], Y);
var _a4;
var _ = (_a4 = class extends r2 {
  constructor(t5, e3, n4, r5) {
    super(), this.type = "vec4", this.children = [t5, e3, n4, r5].filter((t6) => null != t6);
  }
  clone() {
    const t5 = new f(i2(this.children[0]), i2(this.children[1]), i2(this.children[2]), i2(this.children[3]));
    return super.cloneInto(t5), t5;
  }
  get 0() {
    return dt(this, "[0]", C);
  }
  get 1() {
    return dt(this, "[1]", C);
  }
  get 2() {
    return dt(this, "[2]", C);
  }
  get 3() {
    return dt(this, "[3]", C);
  }
  multiply(t5) {
    return Dt(this, "number" == typeof t5 ? O(t5, C) : t5);
  }
  divide(t5) {
    return Ft(this, "number" == typeof t5 ? O(t5, C) : t5);
  }
  add(t5) {
    return kt(this, "number" == typeof t5 ? O(t5, C) : t5);
  }
  subtract(t5) {
    return Mt(this, "number" == typeof t5 ? O(t5, C) : t5);
  }
}, f = _a4, _a4.type = "vec4", _a4);
_ = f = __decorate([S], _);
var _a5;
var G = (_a5 = class extends r2 {
  constructor(t5) {
    super(), this.type = "uint", this.children = [t5];
  }
  clone() {
    const t5 = new p2(i2(this.children[0]));
    return super.cloneInto(t5), t5;
  }
  multiply(t5) {
    return Dt(this, O(t5, p2));
  }
  add(t5) {
    return kt(this, O(t5, p2));
  }
  subtract(t5) {
    return Mt(this, O(t5, p2));
  }
  divide(t5) {
    return Ft(this, O(t5, p2));
  }
}, p2 = _a5, _a5.type = "uint", _a5);
G = p2 = __decorate([S], G);
var _a6;
var H = (_a6 = class extends r2 {
  constructor(t5, e3) {
    super(), this.type = "uvec2", this.children = [t5, e3].filter((t6) => null != t6);
  }
  clone() {
    const t5 = new d(i2(this.children[0]), i2(this.children[1]));
    return super.cloneInto(t5), t5;
  }
  get 0() {
    return dt(this, "[0]", W);
  }
  get 1() {
    return dt(this, "[1]", W);
  }
  get 2() {
    throw new P();
  }
  get 3() {
    throw new P();
  }
  multiply(t5) {
    return Dt(this, "number" == typeof t5 ? O(t5, G) : t5);
  }
  divide(t5) {
    return Ft(this, "number" == typeof t5 ? O(t5, G) : t5);
  }
  add(t5) {
    return kt(this, "number" == typeof t5 ? O(t5, G) : t5);
  }
  subtract(t5) {
    return Mt(this, "number" == typeof t5 ? O(t5, G) : t5);
  }
}, d = _a6, _a6.type = "uvec2", _a6);
H = d = __decorate([S], H);
var _a7;
var A2 = (_a7 = class extends r2 {
  constructor(t5, e3, n4) {
    super(), this.type = "uvec3", this.children = [t5, e3, n4].filter((t6) => null != t6);
  }
  clone() {
    const t5 = new y(i2(this.children[0]), i2(this.children[1]), i2(this.children[2]));
    return super.cloneInto(t5), t5;
  }
  get 0() {
    return dt(this, "[0]", G);
  }
  get 1() {
    return dt(this, "[1]", G);
  }
  get 2() {
    return dt(this, "[2]", G);
  }
  get 3() {
    throw new P();
  }
  multiply(t5) {
    return Dt(this, "number" == typeof t5 ? O(t5, G) : t5);
  }
  divide(t5) {
    return Ft(this, "number" == typeof t5 ? O(t5, G) : t5);
  }
  add(t5) {
    return kt(this, "number" == typeof t5 ? O(t5, G) : t5);
  }
  subtract(t5) {
    return Mt(this, "number" == typeof t5 ? O(t5, G) : t5);
  }
}, y = _a7, _a7.type = "uvec3", _a7);
A2 = y = __decorate([S], A2);
var _a8;
var V = (_a8 = class extends r2 {
  constructor(t5, e3, n4, r5) {
    super(), this.type = "uvec4", this.children = [t5, e3, n4, r5].filter((t6) => null != t6);
  }
  clone() {
    const t5 = new w(i2(this.children[0]), i2(this.children[1]), i2(this.children[2]), i2(this.children[3]));
    return super.cloneInto(t5), t5;
  }
  get 0() {
    return dt(this, "[0]", G);
  }
  get 1() {
    return dt(this, "[1]", G);
  }
  get 2() {
    return dt(this, "[2]", G);
  }
  get 3() {
    return dt(this, "[3]", G);
  }
  multiply(t5) {
    return Dt(this, "number" == typeof t5 ? O(t5, G) : t5);
  }
  divide(t5) {
    return Ft(this, "number" == typeof t5 ? O(t5, G) : t5);
  }
  add(t5) {
    return kt(this, "number" == typeof t5 ? O(t5, G) : t5);
  }
  subtract(t5) {
    return Mt(this, "number" == typeof t5 ? O(t5, G) : t5);
  }
}, w = _a8, _a8.type = "uvec4", _a8);
V = w = __decorate([S], V);
var _J = class _J extends r2 {
  constructor(t5) {
    super(), this.type = "bool", this.children = [t5];
  }
  and(t5) {
    return Lt(this, t5);
  }
  or(t5) {
    return At(this, t5);
  }
  xor(t5) {
    return Jt(this, t5);
  }
  clone() {
    const t5 = new _J(i2(this.children[0]));
    return super.cloneInto(t5), t5;
  }
};
_J.type = "bool";
var J = _J;
var _a9;
var K = (_a9 = class extends r2 {
  constructor(t5, e3) {
    super(), this.type = "bvec2", this.children = [t5, e3].filter((t6) => null != t6);
  }
  all() {
    return te(this);
  }
  any() {
    return ee(this);
  }
  clone() {
    const t5 = new m(i2(this.children[0]), i2(this.children[1]));
    return super.cloneInto(t5), t5;
  }
}, m = _a9, _a9.type = "bvec2", _a9);
K = m = __decorate([S], K);
var _a10;
var L = (_a10 = class extends r2 {
  constructor(t5, e3, n4) {
    super(), this.type = "bvec3", this.children = [t5, e3, n4].filter((t6) => null != t6);
  }
  all() {
    return te(this);
  }
  any() {
    return ee(this);
  }
  clone() {
    const t5 = new v(i2(this.children[0]), i2(this.children[1]), i2(this.children[2]));
    return super.cloneInto(t5), t5;
  }
}, v = _a10, _a10.type = "bvec3", _a10);
function O(t5, e3) {
  if ("number" == typeof t5) {
    return new e3(t5);
  }
  return t5;
}
L = v = __decorate([S], L);
var _a11;
var Q = (_a11 = class extends r2 {
  constructor(t5, e3, n4, r5) {
    super(), this.type = "bvec4", this.children = [t5, e3, n4, r5].filter((t6) => null != t6);
  }
  all() {
    return te(this);
  }
  any() {
    return ee(this);
  }
  clone() {
    const t5 = new b(i2(this.children[0]), i2(this.children[1]), i2(this.children[2]), i2(this.children[3]));
    return super.cloneInto(t5), t5;
  }
}, b = _a11, _a11.type = "bvec4", _a11);
Q = b = __decorate([S], Q);
var _W = class _W extends r2 {
  constructor(t5) {
    super(), this.type = "int", this.children = [t5];
  }
  multiply(t5) {
    return Dt(this, O(t5, _W));
  }
  add(t5) {
    return kt(this, O(t5, _W));
  }
  subtract(t5) {
    return Mt(this, O(t5, _W));
  }
  divide(t5) {
    return Ft(this, O(t5, _W));
  }
  clone() {
    const t5 = new _W(i2(this.children[0]));
    return super.cloneInto(t5), t5;
  }
};
_W.type = "int";
var W = _W;
var _a12;
var Z = (_a12 = class extends r2 {
  constructor(t5, e3) {
    super(), this.type = "ivec2", this.children = [t5, e3].filter((t6) => null != t6);
  }
  clone() {
    const t5 = new g(i2(this.children[0]), i2(this.children[1]));
    return super.cloneInto(t5), t5;
  }
  get 0() {
    return dt(this, "[0]", W);
  }
  get 1() {
    return dt(this, "[1]", W);
  }
  get 2() {
    throw new P();
  }
  get 3() {
    throw new P();
  }
  multiply(t5) {
    return Dt(this, "number" == typeof t5 ? O(t5, W) : t5);
  }
  divide(t5) {
    return Ft(this, "number" == typeof t5 ? O(t5, W) : t5);
  }
  add(t5) {
    return kt(this, "number" == typeof t5 ? O(t5, W) : t5);
  }
  subtract(t5) {
    return Mt(this, "number" == typeof t5 ? O(t5, W) : t5);
  }
}, g = _a12, _a12.type = "ivec2", _a12);
Z = g = __decorate([S], Z);
var _a13;
var tt = (_a13 = class extends r2 {
  constructor(t5, e3, n4) {
    super(), this.type = "ivec3", this.children = [t5, e3, n4].filter((t6) => null != t6);
  }
  clone() {
    const t5 = new x(i2(this.children[0]), i2(this.children[1]), i2(this.children[2]));
    return super.cloneInto(t5), t5;
  }
  get 0() {
    return dt(this, "[0]", W);
  }
  get 1() {
    return dt(this, "[1]", W);
  }
  get 2() {
    return dt(this, "[2]", W);
  }
  get 3() {
    throw new P();
  }
  multiply(t5) {
    return Dt(this, "number" == typeof t5 ? O(t5, W) : t5);
  }
  divide(t5) {
    return Ft(this, "number" == typeof t5 ? O(t5, W) : t5);
  }
  add(t5) {
    return kt(this, "number" == typeof t5 ? O(t5, W) : t5);
  }
  subtract(t5) {
    return Mt(this, "number" == typeof t5 ? O(t5, W) : t5);
  }
}, x = _a13, _a13.type = "ivec3", _a13);
tt = x = __decorate([S], tt);
var _a14;
var et = (_a14 = class extends r2 {
  constructor(t5, e3, n4, r5) {
    super(), this.type = "ivec4", this.children = [t5, e3, n4, r5].filter((t6) => null != t6);
  }
  clone() {
    const t5 = new I(i2(this.children[0]), i2(this.children[1]), i2(this.children[2]), i2(this.children[3]));
    return super.cloneInto(t5), t5;
  }
  get 0() {
    return dt(this, "[0]", W);
  }
  get 1() {
    return dt(this, "[1]", W);
  }
  get 2() {
    return dt(this, "[2]", W);
  }
  get 3() {
    return dt(this, "[3]", W);
  }
  multiply(t5) {
    return Dt(this, "number" == typeof t5 ? O(t5, W) : t5);
  }
  divide(t5) {
    return Ft(this, "number" == typeof t5 ? O(t5, W) : t5);
  }
  add(t5) {
    return kt(this, "number" == typeof t5 ? O(t5, W) : t5);
  }
  subtract(t5) {
    return Mt(this, "number" == typeof t5 ? O(t5, W) : t5);
  }
}, I = _a14, _a14.type = "ivec4", _a14);
et = I = __decorate([S], et);
var _nt = class _nt extends r2 {
  constructor(t5, e3, n4, r5) {
    super(), this.type = "mat2", this.children = [t5, e3, n4, r5];
  }
  clone() {
    const t5 = new _nt(i2(this.children[0]), i2(this.children[1]), i2(this.children[2]), i2(this.children[3]));
    return super.cloneInto(t5), t5;
  }
  get(t5, e3) {
    return yt(this, new W(t5), new W(e3), C);
  }
  multiply(t5) {
    return Dt(this, t5);
  }
};
_nt.type = "mat2";
var nt = _nt;
var _rt = class _rt extends r2 {
  static identity() {
    return new _rt(1, 0, 0, 0, 1, 0, 0, 0, 1);
  }
  static fromRotation(t5) {
    const e3 = un(t5), n4 = oe(t5);
    return new _rt(n4, e3, 0, gt(e3), n4, 0, 0, 0, 1);
  }
  constructor(t5, e3, n4, r5, i3, c2, u2, s6, o3) {
    super(), this.type = "mat3", this.children = [t5, e3, n4, r5, i3, c2, u2, s6, o3];
  }
  add(t5) {
    return kt(this, t5);
  }
  multiply(t5) {
    return Dt(this, t5);
  }
  get(t5, e3) {
    return yt(this, new W(t5), new W(e3), C);
  }
  clone() {
    const t5 = new _rt(i2(this.children[0]), i2(this.children[1]), i2(this.children[2]), i2(this.children[3]), i2(this.children[4]), i2(this.children[5]), i2(this.children[6]), i2(this.children[7]), i2(this.children[8]));
    return super.cloneInto(t5), t5;
  }
};
_rt.type = "mat3";
var rt = _rt;
var _it = class _it extends r2 {
  static identity() {
    return new _it(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
  }
  constructor(t5, e3, n4, r5, i3, c2, u2, s6, o3, h4, l3, a5, f4, p3, d3, y3) {
    super(), this.type = "mat4", this.children = [t5, e3, n4, r5, i3, c2, u2, s6, o3, h4, l3, a5, f4, p3, d3, y3];
  }
  static fromColumns(t5, e3, n4, r5) {
    return new _it(t5.x, t5.y, t5.z, t5.w, e3.x, e3.y, e3.z, e3.w, n4.x, n4.y, n4.z, n4.w, r5.x, r5.y, r5.z, r5.w);
  }
  multiply(t5) {
    return Dt(this, t5);
  }
  get(t5, e3) {
    return yt(this, new W(t5), new W(e3), C);
  }
  clone() {
    const t5 = new _it(i2(this.children[0]), i2(this.children[1]), i2(this.children[2]), i2(this.children[3]), i2(this.children[4]), i2(this.children[5]), i2(this.children[6]), i2(this.children[7]), i2(this.children[8]), i2(this.children[9]), i2(this.children[10]), i2(this.children[11]), i2(this.children[12]), i2(this.children[13]), i2(this.children[14]), i2(this.children[15]));
    return super.cloneInto(t5), t5;
  }
};
_it.type = "mat4";
var it = _it;
var ct = { float: C, vec2: X, vec3: Y, vec4: _, int: W, ivec2: Z, ivec3: tt, ivec4: et, uint: G, uvec2: H, uvec3: A2, uvec4: V, bool: J, bvec2: K, bvec3: L, bvec4: Q };
var ut = (...t5) => new W(...t5);
var st = (...t5) => new C(...t5);
var ot = (...t5) => new X(...t5);
var ht = (...t5) => new Y(...t5);
var lt = (...t5) => new _(...t5);
var ft = (...t5) => new rt(...t5);
function dt(t5, e3, n4) {
  const r5 = new n4(new c(e3, t5, n4));
  return r5.isImplicit = true, r5;
}
function yt(t5, e3, n4, r5) {
  const i3 = new r5(new o(e3, n4, t5, r5));
  return i3.isImplicit = true, i3;
}
function wt(t5, e3, n4, r5 = null) {
  if (r5) {
    const i4 = new r5(), u2 = new r5(new a(t5, [e3, n4], true, false, i4));
    return u2.isImplicit = true, u2;
  }
  if ("float" === e3.type || "int" === e3.type) {
    const r6 = new n4.constructor(new a(t5, [e3, n4], true, false, n4.constructor));
    return r6.isImplicit = true, r6;
  }
  if (("mat2" === e3.type || "mat3" === e3.type || "mat4" === e3.type) && "float" !== n4.type) {
    const r6 = new n4.constructor(new a(t5, [e3, n4], true, false, n4.constructor));
    return r6.isImplicit = true, r6;
  }
  const i3 = new e3.constructor(new a(t5, [e3, n4], true, false, e3.constructor));
  return i3.isImplicit = true, i3;
}
function mt(t5, e3, n4 = e3.constructor) {
  const r5 = new n4(new a(t5, [e3], false, false, n4));
  return r5.isImplicit = true, r5;
}
function vt(t5, e3, n4, r5 = e3.constructor) {
  const i3 = new r5(new a(t5, [e3, n4], false, false, r5));
  return i3.isImplicit = true, i3;
}
function bt(t5, e3, n4, r5, i3 = e3.constructor) {
  const u2 = new i3(new a(t5, [e3, n4, r5], false, false, i3));
  return u2.isImplicit = true, u2;
}
function gt(t5) {
  return Dt(t5, st(-1));
}
function xt(t5, e3, n4, r5) {
  return new e3(new p(t5, e3, n4, r5));
}
function Et(t5, e3, n4 = 0, r5 = t5.size) {
  const i3 = new W(n4).setMutable().setDebugName("FindIndexIterator"), c2 = e3(t5.get(i3)).setDebugName("FindIndexPredicate"), u2 = xt({ iter: i3 }, W, c2, ({ out: t6, iter: e4, subgraph: n5 }) => `
${t6} = -1;

for (; ${e4} < ${r5}; ${e4}++) {

${n5.body}

  if (${n5.varName}) {
    ${t6} = ${e4};
    break;
  }

}
`).setDebugName("FindIndexBlock");
  return u2;
}
function $t(t5, e3, n4 = 0, r5 = t5.size) {
  const i3 = xt({ array: t5 }, W, null, ({ out: t6, array: i4 }) => `
${t6} = -1;
for (int i = ${n4}; i < ${r5}; i++) {
  bool condition;
  ${e3({ array: i4, i: "i", out: "condition" })}
  if (condition) {
    ${t6} = i;
    break;
  }
}
`).setDebugName("GlslFindIndexBlock");
  return i3;
}
function zt(t5, e3, n4) {
  const i3 = "function" == typeof e3 ? e3() : e3, c2 = "function" == typeof n4 ? n4() : n4, u2 = new i3.constructor(new u(t5, i3, c2));
  return u2.isImplicit = true, u2;
}
function Tt(...t5) {
  const e3 = t5.map(([t6, e4]) => "function" == typeof e4 ? [t6, e4()] : [t6, e4]), n4 = e3[0][1].constructor, r5 = e3.findIndex((t6) => true === t6[0]);
  if (-1 === r5) throw new Error("A cond must have a fallthrough case with `true`/; ");
  const i3 = e3.slice(0, r5), c2 = e3[r5][1], u2 = new n4(i3.reduceRight((t6, e4) => zt(e4[0], e4[1], t6), c2));
  return u2.isImplicit = true, u2;
}
function Dt(t5, e3) {
  return wt("*", t5, e3);
}
function Ft(t5, e3) {
  return wt("/", t5, e3);
}
function kt(t5, e3) {
  return wt("+", t5, e3);
}
function Mt(t5, e3) {
  return wt("-", t5, e3);
}
function St(t5, e3) {
  return wt("%", t5, e3);
}
function Rt(t5, e3) {
  return wt("<<", t5, e3);
}
function jt(t5, e3) {
  return wt(">>", t5, e3);
}
function Pt(t5, e3) {
  return wt("&", t5, e3);
}
function Bt(t5, e3) {
  return wt("|", t5, e3);
}
function qt(t5, e3) {
  return wt("^", t5, e3);
}
function Ut(t5) {
  return mt("~", t5);
}
function Ct(t5, e3) {
  return wt("==", t5, e3, J);
}
function Xt(t5, e3) {
  return wt("!=", t5, e3, J);
}
function Yt(t5, e3) {
  return wt("<", t5, e3, J);
}
function _t(t5, e3) {
  return wt("<=", t5, e3, J);
}
function Gt(t5, e3) {
  return wt(">", t5, e3, J);
}
function Ht(t5, e3) {
  return wt(">=", t5, e3, J);
}
function At(...t5) {
  return t5.length <= 1 ? t5[0] : t5.slice(1).reduce((t6, e3) => Vt(t6, e3), t5[0]);
}
function Vt(t5, e3) {
  return wt("||", t5, e3, J);
}
function Jt(...t5) {
  return t5.length <= 1 ? t5[0] : t5.slice(1).reduce((t6, e3) => Kt(t6, e3), t5[0]);
}
function Kt(t5, e3) {
  return wt("^^", t5, e3, J);
}
function Lt(...t5) {
  return t5.length <= 1 ? t5[0] : t5.slice(1).reduce((t6, e3) => Ot(t6, e3), t5[0]);
}
function Ot(t5, e3) {
  return wt("&&", t5, e3, J);
}
function Qt(t5) {
  return mt("abs", t5);
}
function Wt(t5) {
  return mt("acos", t5);
}
function Zt(t5) {
  return mt("acosh", t5);
}
function te(t5) {
  return mt("all", t5, J);
}
function ee(t5) {
  return mt("any", t5, J);
}
function ne(t5) {
  return mt("asin", t5);
}
function re(t5) {
  return mt("asinh", t5);
}
function ie(t5, e3) {
  return null == e3 ? mt("atan", t5) : vt("atan", t5, e3, t5.constructor);
}
function ce(t5) {
  return mt("atanh", t5);
}
function ue(t5) {
  return mt("ceil", t5);
}
function se(t5, e3, n4) {
  return bt("clamp", t5, e3, n4, t5.constructor);
}
function oe(t5) {
  return mt("cos", t5);
}
function he(t5) {
  return mt("cosh", t5);
}
function ye(t5, e3) {
  return vt("distance", t5, e3, C);
}
function we(t5, e3) {
  return vt("dot", t5, e3, C);
}
function ge(t5) {
  return mt("exp", t5);
}
function ze(t5) {
  return mt("floor", t5);
}
function Te(t5) {
  return mt("fract", t5);
}
function je(t5) {
  return mt("length", t5, C);
}
function qe(t5) {
  return mt("log", t5);
}
function Ue(t5) {
  return mt("log2", t5);
}
function Xe(t5, e3) {
  return vt("max", t5, e3);
}
function Ye(t5, e3) {
  return vt("min", t5, e3);
}
function _e(t5, e3, n4) {
  return bt("mix", t5, e3, n4);
}
function Ge(t5, e3) {
  return vt("mod", t5, e3);
}
function Ae(t5) {
  return mt("normalize", t5);
}
function Ve(t5) {
  return "bool" === t5.type ? mt("!", t5) : mt("not", t5);
}
function We(t5, e3) {
  return vt("pow", t5, e3);
}
function nn(t5) {
  return mt("round", t5);
}
function cn(t5) {
  return mt("sign", t5);
}
function un(t5) {
  return mt("sin", t5);
}
function sn(t5) {
  return mt("sinh", t5);
}
function on(t5, e3, n4) {
  return bt("smoothstep", t5, e3, n4);
}
function hn(t5) {
  return mt("sqrt", t5);
}
function ln(t5, e3) {
  return vt("step", t5, e3, e3.constructor);
}
function an(t5) {
  return mt("tan", t5);
}
function fn(t5) {
  return mt("tanh", t5);
}
function pn(t5, e3, n4) {
  return bt("texelFetch", t5, e3, n4, _);
}
function wn(t5, e3) {
  return vt("texture", t5, e3, _);
}
function jn(t5, e3) {
  const { initialValue: n4, xRange: r5, yRange: i3, callback: c2 } = e3, [u2, s6] = r5, [o3, h4] = i3, l3 = new W(0).setMutable().setDebugName("iterX"), a5 = new W(0).setMutable().setDebugName("iterY"), f4 = n4.setMutable().setDebugName("accumulator"), p3 = c2(f4, t5.get(l3, a5), l3, a5).setDebugName("callback"), d3 = xt({ iterX: l3, iterY: a5, accumulator: f4 }, n4.constructor, p3, ({ out: t6, iterX: e4, iterY: n5, accumulator: r6, subgraph: i4 }) => `
for (${n5} = ${o3}; ${n5} < ${h4}; ${n5}++) {
  for (${e4} = ${u2}; ${e4} < ${s6}; ${e4}++) {

  ${i4.body}

  ${r6} = ${i4.varName};
  }
}
${t6} = ${r6};
`).setDebugName("reduce2DBody");
  return d3;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/graph/GlslGraphWriter.js
var e2 = 5;
function t3(e3, t5, r5) {
  const i3 = t5.split("\n");
  for (const n4 of i3) if (n4.trim().length) {
    {
      let t6 = "";
      null != r5 && (t6 += `/*id:${r5 ?? "000"}*/   `), e3.body += t6.padEnd(14);
    }
    e3.body += " ".repeat(e3.indent) + n4 + "\n";
  }
}
var r3 = class {
  write(e3) {
    for (const t5 of e3.rootOutputNodes()) e3.shouldPruneOutputNode(t5) || (t5.variableName = this._write(e3, t5.node));
    return e3;
  }
  _createVarName(e3, t5) {
    let r5 = "";
    return "boolean" != typeof t5 && "number" != typeof t5 && t5.debugInfo.name && (r5 = `${t5.debugInfo.name}_`), `${r5}v${e3.varCount++}`;
  }
  _write(e3, t5, r5 = false) {
    if ("number" == typeof t5) return t5.toString();
    if ("boolean" == typeof t5) return t5.toString();
    let i3 = e3.getEmit(t5);
    if (i3) return i3;
    switch (t5.shaderType) {
      case "scope-node":
        i3 = this._writeScopeNode(e3, t5);
        break;
      case "primitive-node":
        i3 = this._writePrimitiveNode(e3, t5, r5);
        break;
      case "function-node":
        i3 = this._writeFunctionNode(e3, t5);
        break;
      case "property-access-node":
        i3 = this._writePropertyAccessNode(e3, t5);
        break;
      case "property-access-2d-node":
        i3 = this._writePropertyAccess2DNode(e3, t5);
        break;
      case "text-node":
        i3 = t5.text;
        break;
      case "block-node":
        i3 = this._writeBlockNode(e3, t5);
        break;
      case "condition-node":
        i3 = this._writeConditionNode(e3, t5);
    }
    return e3.setEmit(t5, i3), i3;
  }
  _writeScopeNode(e3, r5) {
    const i3 = new r5.child.constructor();
    i3.setDebugName(r5.debugInfo.name);
    const n4 = this._write(e3, i3, true);
    t3(e3, `{ /*ScopeStart: ${r5.uid} ${r5.debugInfo.name}*/`), e3.indent += 2;
    return t3(e3, `${n4} = ${this._write(e3, r5.child)};`), e3.indent -= 2, t3(e3, `} /*ScopeEnd: ${r5.uid} ${r5.debugInfo.name}*/`), n4;
  }
  _writeConditionNode(e3, r5) {
    const i3 = new r5.ifTrue.constructor(), n4 = this._write(e3, i3, true);
    t3(e3, `if (${this._write(e3, r5.condition)}) {`), e3.indent += 2;
    const o3 = e3.createSubgraphContext(), s6 = this._write(o3, r5.ifTrue);
    if (e3.body += o3.body, s6 && t3(e3, `${n4} = ${s6};`), e3.indent -= 2, t3(e3, "}"), r5.ifFalse) {
      t3(e3, "else {"), e3.indent += 2;
      const i4 = e3.createSubgraphContext(), o4 = this._write(i4, r5.ifFalse);
      e3.body += i4.body, o4 && t3(e3, `${n4} = ${o4};`), e3.indent -= 2, t3(e3, "}");
    }
    return n4;
  }
  _writeBlockNode(e3, r5) {
    const { captureList: i3, generator: n4, returnType: o3 } = r5, s6 = {};
    for (const t5 in i3) {
      if (!i3[t5]) continue;
      const r6 = this._write(e3, i3[t5]);
      s6[t5] = r6;
    }
    const d3 = new o3(), c2 = this._write(e3, d3, true);
    if (s6.out = c2, r5.subgraph) {
      const t5 = e3.createSubgraphContext(), i4 = this._write(t5, r5.subgraph.child), n5 = t5.body;
      s6.subgraph = { varName: i4, body: n5 };
    }
    const a5 = n4(s6);
    return t3(e3, "{\n"), e3.indent += 2, t3(e3, a5), e3.indent -= 2, t3(e3, "}\n"), c2;
  }
  _writePropertyAccessNode(e3, t5) {
    const r5 = this._write(e3, t5.target);
    if ("string" == typeof t5.property && t5.property.includes("[")) return `${r5}${t5.property}`;
    if ("string" != typeof t5.property) {
      return `${r5}[${this._write(e3, t5.property)}]`;
    }
    return `${r5}.${t5.property}`;
  }
  _writePropertyAccess2DNode(e3, t5) {
    return `${this._write(e3, t5.target)}[${this._write(e3, t5.x)}][${this._write(e3, t5.y)}]`;
  }
  _writeFunctionNode(r5, i3) {
    const n4 = i3.returnType.type;
    if (i3.isInfix) {
      const [o4, s7] = i3.children.map((e3) => this._write(r5, e3)), d3 = this._createVarName(r5, i3);
      return t3(r5, `${n4.padEnd(e2)} ${d3} = ${o4} ${i3.token} ${s7};`, i3.uid), d3;
    }
    const o3 = i3.children.map((e3) => this._write(r5, e3)).join(", "), s6 = this._createVarName(r5, i3);
    return t3(r5, `${n4.padEnd(e2)} ${s6} = ${i3.token}(${o3});`, i3.uid), s6;
  }
  _writePrimitiveNode(r5, i3, n4 = false) {
    const o3 = r5.getInput(i3);
    if (o3) return o3.isUsed = true, o3.variableName;
    const s6 = 1 === i3.children.length && i3.children[0]?.type === i3.type;
    if (!i3.isMutable && (i3.isImplicit || s6)) return this._write(r5, i3.children[0]);
    const d3 = this._createVarName(r5, i3);
    if (n4) return t3(r5, `${i3.type.padEnd(e2)} ${d3};`, i3.uid), d3;
    const c2 = !i3.debugInfo.name && !i3.isMutable;
    if (c2 && "float" === i3.type && "number" == typeof i3.children[0]) return Number.isInteger(i3.children[0]) ? i3.children[0].toFixed(1) : i3.children[0].toString();
    if (c2 && "int" === i3.type && "number" == typeof i3.children[0] && Number.isInteger(i3.children[0])) return i3.children[0].toString();
    const a5 = i3.children.map((e3) => this._write(r5, e3)).join(", ");
    return "array" === i3.type ? (t3(r5, `${i3.type.padEnd(e2)} ${d3} = [${a5}];`, i3.uid), d3) : c2 ? `${i3.type}(${a5})` : (t3(r5, `${i3.type.padEnd(e2)} ${d3} = ${i3.type}(${a5});`, i3.uid), d3);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/graph/ShaderGraphContext.js
var t4 = class _t2 {
  constructor(e3, t5, a5, n4 = []) {
    this.variableName = e3, this.variableInputType = t5, this.node = a5, this.qualifiers = n4, this.type = "shader-input", this.isUsed = false;
  }
  clone() {
    return new _t2(this.variableName, this.variableInputType, i2(this.node), [...this.qualifiers]);
  }
};
var a3 = class _a15 {
  constructor(e3, t5, a5, n4 = []) {
    this.outVariableName = e3, this.outVariableType = t5, this.node = a5, this.qualifiers = n4, this.type = "shader-output";
  }
  clone() {
    const t5 = new _a15(this.outVariableName, this.outVariableType, i2(this.node), [...this.qualifiers]);
    return t5.variableName = this.variableName, t5;
  }
};
var n2 = class _n {
  static createVertex(e3, d3, s6, i3, r5, u2) {
    const p3 = [];
    for (const a5 in e3) {
      const n4 = e3[a5], o3 = s6.get(a5);
      o3 ? p3.push(new t4(o3, "builtin", n4)) : p3.push(new t4("a_" + a5, "in", n4));
    }
    for (const a5 of i3) {
      const e4 = a5.uniformHydrated;
      p3.push(new t4(a5.uniformName, "uniform", e4));
    }
    const c2 = [];
    for (const t5 in d3) {
      const e4 = d3[t5];
      if ("glPosition" === t5) c2.push(new a3("gl_Position", "builtin", e4));
      else if ("glPointSize" === t5) c2.push(new a3("gl_PointSize", "builtin", e4));
      else {
        const n4 = o2(e4), d4 = [];
        n4 && d4.push(n4), c2.push(new a3("v_" + t5, "out", e4, d4));
      }
    }
    return new _n(p3, c2, r5, u2);
  }
  static createFragment(e3, o3, d3, s6, i3, r5) {
    const u2 = [], p3 = Array.from(i3.rootOutputNodes());
    for (const a5 in e3) {
      const n4 = e3[a5], o4 = d3.get(a5);
      if (o4) {
        u2.push(new t4(o4, "builtin", n4));
        continue;
      }
      const s7 = p3.find((e4) => e4.node === n4);
      s7 && u2.push(new t4(s7.outVariableName, "in", n4));
    }
    for (const a5 of s6) {
      const e4 = a5.uniformHydrated;
      u2.push(new t4(a5.uniformName, "uniform", e4));
    }
    const c2 = [];
    for (const t5 in o3) {
      const e4 = o3[t5], n4 = d3.get(t5);
      switch (t5) {
        case "discard":
          c2.push(new a3(null, "discard", e4));
          break;
        case "fragData0":
          c2.push(new a3("fragData0", "fragData0", e4));
          break;
        case "fragData1":
          c2.push(new a3("fragData1", "fragData1", e4));
          break;
        case "fragData2":
          c2.push(new a3("fragData2", "fragData2", e4));
          break;
        case "fragData3":
          c2.push(new a3("fragData3", "fragData3", e4));
          break;
        default:
          n4 ? c2.push(new a3(n4, "builtin", e4)) : c2.push(new a3(t5, "out", e4));
      }
    }
    return new _n(u2, c2, r5);
  }
  constructor(e3, t5, a5, n4) {
    this.type = "shader-graph-context", this.indent = 0, this.body = "", this.varCount = 0, this._inputShaderTypesByNodeUid = /* @__PURE__ */ new Map(), this._nodeEmitMap = /* @__PURE__ */ new Map();
    for (const o3 of e3) this._inputShaderTypesByNodeUid.set(o3.node.uid, o3);
    this._outputShaderTypes = t5, this._transformFeedbackBindings = a5, this._transformFeedbackNames = new Set(a5.map((e4) => "v_" + e4.propertyKey)), this._usedInFragmentShader = n4;
  }
  shouldPruneOutputNode(e3) {
    return !!this._usedInFragmentShader && ("builtin" !== e3.outVariableType && (!this._transformFeedbackNames.has(e3.outVariableName) && !this._usedInFragmentShader.has(e3.node.uid)));
  }
  setEmit(e3, t5) {
    this._nodeEmitMap.set(e3.uid, t5);
  }
  getEmit(e3) {
    return this._nodeEmitMap.get(e3.uid);
  }
  inputs() {
    return this._inputShaderTypesByNodeUid.values();
  }
  getInput(e3) {
    return this._inputShaderTypesByNodeUid.get(e3.uid);
  }
  *rootOutputNodes() {
    for (const e3 of this._outputShaderTypes) yield e3;
  }
  *nodes() {
    const e3 = [];
    for (const t5 of this._outputShaderTypes.values()) e3.push(t5.node);
    for (; e3.length; ) {
      const t5 = e3.pop();
      "number" != typeof t5 && "boolean" != typeof t5 && e3.push(...t5.children.filter(Boolean)), yield t5;
    }
  }
  *nodesOfTypeOrFunction() {
    for (const e3 of this.nodes()) "number" != typeof e3 && "boolean" != typeof e3 && (yield e3);
  }
  createSubgraphContext() {
    const e3 = this.clone();
    return e3.body = "", e3.indent = this.indent + 2, e3._nodeEmitMap = new Map(this._nodeEmitMap), e3;
  }
  clone() {
    const e3 = new _n([], this._outputShaderTypes, this._transformFeedbackBindings, this._usedInFragmentShader);
    return e3._inputShaderTypesByNodeUid = this._inputShaderTypesByNodeUid, e3.indent = this.indent, e3.body = this.body, e3.varCount = this.varCount, e3._nodeEmitMap = this._nodeEmitMap, e3;
  }
  insertVertexShader(e3) {
    e3.vertex.code.add(""), this._insertInputs(e3, "vertex"), e3.vertex.code.add(""), e3.vertex.code.add("// OUTPUTS: "), e3.vertex.code.add("// --------------------------------------------------------- ");
    for (const t5 of this.rootOutputNodes()) {
      const a5 = "builtin" === t5.outVariableType;
      if (!this.shouldPruneOutputNode(t5)) if (a5) e3.vertex.code.add(`// ${t5.outVariableType.padEnd(7)} ${t5.node.type.padEnd(9)} ${t5.outVariableName};`);
      else {
        const a6 = [...t5.qualifiers, t5.outVariableType].join(" ");
        e3.vertex.code.add(`${a6.padEnd(10)} ${t5.node.type.padEnd(9)} ${t5.outVariableName};`);
      }
    }
    e3.vertex.code.add(""), e3.vertex.code.add("void main() {"), e3.vertex.code.add("  " + this.body.split("\n").join("\n  "));
    for (const t5 of this.rootOutputNodes()) this.shouldPruneOutputNode(t5) || e3.vertex.code.add(`  ${t5.outVariableName} = ${t5.variableName};`);
    e3.vertex.code.add("}");
  }
  insertFragmentShader(e3) {
    this._insertInputs(e3, "fragment"), e3.fragment.code.add(""), e3.fragment.code.add("// OUTPUTS: "), e3.fragment.code.add("// --------------------------------------------------------- ");
    let t5 = 0;
    for (const a5 of this.rootOutputNodes()) {
      "builtin" === a5.outVariableType ? e3.fragment.code.add(`// ${a5.outVariableType.padEnd(7)} ${a5.node.type.padEnd(9)} ${a5.outVariableName};`) : e3.outputs.add(a5.outVariableName, a5.node.type, t5++);
    }
    e3.fragment.code.add(""), e3.fragment.code.add("void main() {"), e3.fragment.code.add("  " + this.body.split("\n").join("\n  "));
    for (const a5 of this.rootOutputNodes()) "discard" === a5.outVariableType ? (e3.fragment.code.add("  // TODO: Should ensure codegen for discard appears first in fragment shader"), e3.fragment.code.add(`  if (${a5.variableName}) {`), e3.fragment.code.add("    discard;"), e3.fragment.code.add("  }"), e3.fragment.code.add("  ")) : e3.fragment.code.add(`  ${a5.outVariableName} = ${a5.variableName};`);
    e3.fragment.code.add("}");
  }
  _insertInputs(e3, t5) {
    e3[t5].code.add("// INPUTS: "), e3[t5].code.add("// --------------------------------------------------------- ");
    for (const a5 of this.inputs()) if (a5.isUsed && "builtin" !== a5.variableInputType) if ("array" === a5.node.type) e3[t5].code.add(`${a5.variableInputType.padEnd(10)} ${a5.node.elementType.type.padEnd(9)} ${a5.variableName}[${a5.node.size}];`);
    else if ("array-2d" === a5.node.type) e3[t5].code.add(`${a5.variableInputType.padEnd(10)} ${a5.node.elementType.type.padEnd(9)} ${a5.variableName}[${a5.node.size}]; // Emulated 2D Array. Not supported by ES3.0`);
    else {
      const n4 = [...a5.qualifiers, a5.variableInputType].join(" ");
      e3[t5].code.add(` ${n4.padEnd(10)} ${a5.node.type.padEnd(9)} ${a5.variableName};`);
    }
  }
};
function o2(e3) {
  switch (e3.type) {
    case "float":
    case "vec2":
    case "vec3":
    case "vec4":
      return null;
    case "int":
    case "ivec2":
    case "ivec3":
    case "ivec4":
    case "uint":
    case "uvec2":
    case "uvec3":
    case "uvec4":
    case "bool":
    case "bvec2":
    case "bvec3":
    case "bvec4":
      return "flat";
    case "mat2":
    case "mat3":
    case "mat4":
    case "array":
    case "sampler2D":
    case "array-2d":
      throw new Error(`InternalError: ${e3.type} is not a valid output type`);
  }
}

// node_modules/@arcgis/core/views/2d/engine/webgl/textureUtils.js
function r4(r5, t5, a5) {
  const i3 = new h(t5.width, t5.height);
  return i3.dataType = t5.dataType, t5.depth && (i3.depth = t5.depth), t5.flipped && (i3.flipped = t5.flipped), t5.hasMipmap && (i3.hasMipmap = t5.hasMipmap), i3.internalFormat = t5.internalFormat, t5.isImmutable && (i3.isImmutable = t5.isImmutable), t5.isOpaque && (i3.isOpaque = t5.isOpaque), t5.maxAnisotropy && (i3.maxAnisotropy = t5.maxAnisotropy), i3.pixelFormat = t5.pixelFormat, t5.preMultiplyAlpha && (i3.preMultiplyAlpha = t5.preMultiplyAlpha), t5.samplingMode && (i3.samplingMode = t5.samplingMode), t5.target && (i3.target = t5.target), i3.uniform = t5.uniform, t5.unpackAlignment && (i3.unpackAlignment = t5.unpackAlignment), t5.wrapMode && (i3.wrapMode = t5.wrapMode), new A(r5, i3, a5);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/typed/TypedShaderProgram.js
var n3 = () => i.getLogger("esri.views.2d.engine.webgl.shaderGraph.typed.TypedShaderProgram");
function a4(e3, t5, o3) {
  const i3 = t5.length;
  if (i3 !== o3) {
    const s6 = new s("Invalid Uniform", `Invalid length, expected ${o3} but got ${i3}`, { uniformName: e3, values: t5 });
    n3().errorOnce(s6);
  }
}
var f2 = class {
  constructor(r5, e3, t5, o3, i3) {
    this.vertexShader = r5, this.fragmentShader = e3, this._locations = t5, this._uniformBindings = o3, this._transformFeedbackBindings = i3, this._vao = null, this._temporaryTextures = [];
  }
  destroy() {
    this._program = r(this._program), this.cleanupTemporaryTextures();
  }
  setUniforms(r5) {
    this._uniforms = r5;
  }
  cleanupTemporaryTextures() {
    for (const r5 of this._temporaryTextures) r5.dispose();
    this._temporaryTextures = [];
  }
  bind(r5) {
    const e3 = this._uniforms;
    if (!this._program) {
      const e4 = [];
      for (const r6 of this._transformFeedbackBindings ?? []) {
        const { index: t6, propertyKey: o3 } = r6;
        e4[t6] = `v_${o3}`;
      }
      this._program = new s3(r5, this.vertexShader, this.fragmentShader, this._locations, /* @__PURE__ */ new Map(), e4);
    }
    const t5 = this._program;
    r5.useProgram(t5);
    for (const i3 of this._uniformBindings) {
      const { shaderModulePath: n4, uniformName: f4, uniformType: m3, uniformArrayLength: c2 } = i3, u2 = t(n4, e3);
      if (null == u2) {
        if ("sampler2D" === m3) continue;
        throw new Error(`Failed to find uniform value for ${n4}`);
      }
      switch ("array" === m3 || "array-2d" === m3 ? i3.uniformArrayElementType : m3) {
        case "sampler2D": {
          const { unit: e4, texture: o3 } = u2;
          if (t5.setUniform1i(f4, e4), "type" in o3) r5.bindTexture(o3, e4);
          else {
            const t6 = r4(r5, o3.descriptor, o3.data);
            r5.bindTexture(t6, e4);
          }
          break;
        }
        case "int":
          if (!c2) {
            t5.setUniform1i(f4, u2);
            break;
          }
          a4(i3.uniformName, u2, c2), t5.setUniform1iv(f4, u2);
          break;
        case "float":
          if (!c2) {
            t5.setUniform1f(f4, u2);
            break;
          }
          a4(i3.uniformName, u2, c2), t5.setUniform1fv(f4, u2);
          break;
        case "vec2":
          if (!c2) {
            t5.setUniform2f(f4, u2[0], u2[1]);
            break;
          }
          a4(i3.uniformName, u2, c2), t5.setUniform2fv(f4, u2.flat());
          break;
        case "vec3":
          if (!c2) {
            t5.setUniform3f(f4, u2[0], u2[1], u2[2]);
            break;
          }
          a4(i3.uniformName, u2, c2), t5.setUniform3fv(f4, u2.flat());
          break;
        case "vec4":
          if (!c2) {
            t5.setUniform4f(f4, u2[0], u2[1], u2[2], u2[3]);
            break;
          }
          a4(i3.uniformName, u2, c2), t5.setUniform4fv(f4, u2.flat());
          break;
        case "mat3":
          t5.setUniformMatrix3fv(f4, u2);
          break;
        case "mat4":
          t5.setUniformMatrix4fv(f4, u2);
          break;
        default:
          throw new Error(`Unable to set uniform for type ${m3}`);
      }
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/GraphShaderModule.js
function y2(t5) {
  return new t5();
}
function d2(t5, e3, r5) {
  const o3 = t5.constructor[e3] ?? [];
  t5.constructor.hasOwnProperty(e3) || Object.defineProperty(t5.constructor, e3, { value: o3.slice() }), t5.constructor[e3].push(r5);
}
function f3(t5, e3) {
  return (r5, o3) => {
    d2(r5, "locations", { typeCtor: e3, propertyKey: o3, parameterIndex: null, index: t5 });
  };
}
var h3 = (t5) => (e3, r5) => {
  d2(e3, "builtins", { builtin: t5, propertyKey: r5 });
};
var l2 = (t5) => (e3, r5, o3) => {
  d2(e3, "inputs", { inputCtor: t5, propertyKey: r5, parameterIndex: o3 });
};
var m2 = (t5) => (e3, r5) => {
  d2(e3, "uniforms", { typeCtor: t5, propertyKey: r5 });
};
var g2 = (t5) => (e3, r5) => {
  d2(e3, "options", { typeCtor: t5, propertyKey: r5 });
};
var _2 = (t5, e3) => {
  d2(t5, "defines", { propertyKey: e3 });
};
var b2 = (t5, e3) => (r5, o3) => {
  r5.constructor.builtins.push({ builtin: t5, propertyKey: o3, typeCtor: e3 });
};
var _C2 = class _C2 {
};
_C2.builtins = [];
var C2 = _C2;
__decorate([b2("gl_VertexID", W)], C2.prototype, "glVertexID", void 0);
var x2 = class {
};
var _I = class _I {
};
_I.builtins = [];
var I2 = _I;
__decorate([b2("gl_FragCoord", _)], I2.prototype, "glFragCoord", void 0), __decorate([b2("gl_PointCoord", X)], I2.prototype, "glPointCoord", void 0);
var v2 = class {
};
__decorate([h3("gl_FragDepth")], v2.prototype, "glFragDepth", void 0);
var w2 = class {
  constructor() {
    this.type = "uniform-group";
  }
  get _uniforms() {
    return this.constructor.uniforms ?? [];
  }
};
var P2 = class {
  constructor() {
    this.logShader = false, this.computeAttributes = {};
  }
  get vertexInput() {
    const t5 = this._shaderModuleClass.inputs.findLast((t6) => "vertex" === t6.propertyKey && 0 === t6.parameterIndex);
    if (!t5) throw new Error("Unable to find vertex input parameter");
    return t5;
  }
  get computeInput() {
    return this._shaderModuleClass.inputs.findLast((t5) => "vertex" === t5.propertyKey && 1 === t5.parameterIndex);
  }
  get fragmentInput() {
    const t5 = this._shaderModuleClass.inputs.findLast((t6) => "fragment" === t6.propertyKey);
    if (!t5) throw new Error("Unable to find fragment input parameter");
    return t5;
  }
  get transformFeedbackBindings() {
    return this.fragmentInput.inputCtor.transformFeedbackBindings ?? [];
  }
  get locations() {
    return [...this.vertexInput.inputCtor.locations, ...this.computeInput?.inputCtor.locations ?? []];
  }
  get locationsMap() {
    const t5 = /* @__PURE__ */ new Map(), r5 = /* @__PURE__ */ new Set();
    for (const o3 of this.locations) r5.has(o3.index) ? i.getLogger("esri.views.2d.engine.webgl.shaderGraph.GraphShaderModule").warnOnce("mapview-rendering", `Unable to assigned attribute ${o3.propertyKey} to ${o3.index}. Index already in use`, { locationsMap: t5 }) : (t5.set(o3.propertyKey, o3.index), r5.add(o3.index));
    return t5;
  }
  get locationInfo() {
    if (!this._locationInfo) {
      const t5 = this.locationsMap, e3 = Array.from(t5.entries()).map(([t6, e4]) => `${t6}.${e4}`).join("."), r5 = this.computeAttributes;
      this._locationInfo = { stringHash: e3, locations: t5, computeAttributeMap: r5 };
    }
    return this._locationInfo;
  }
  get renamedLocationsMap() {
    const t5 = /* @__PURE__ */ new Map();
    for (const e3 of this.locations) t5.set("a_" + e3.propertyKey, e3.index);
    return t5;
  }
  get optionPropertyKeys() {
    if (!this._optionPropertyKeys) {
      const t5 = /* @__PURE__ */ new Set();
      for (const e3 of this._options) t5.add(e3.propertyKey);
      this._optionPropertyKeys = t5;
    }
    return this._optionPropertyKeys;
  }
  get _shaderModuleClass() {
    return this.constructor;
  }
  get _defines() {
    return this._shaderModuleClass.defines ?? [];
  }
  get _options() {
    return this._shaderModuleClass.options ?? [];
  }
  get _uniforms() {
    return this._shaderModuleClass.uniforms ?? [];
  }
  getProgram(t5, e3, r5, o3) {
    try {
      const { vertex: n4, fragment: s6, uniformBindings: i3 } = this._generateShaders(t5, e3, r5, o3);
      return new f2(n4, s6, this.renamedLocationsMap, i3, this.transformFeedbackBindings);
    } catch (n4) {
      return new f2("", "", this.renamedLocationsMap, [], this.transformFeedbackBindings);
    }
  }
  getDebugUniformClassInfo(t5) {
    const e3 = this._options.find((e4) => e4.propertyKey === t5);
    if (e3) return { type: "option", className: e3.typeCtor };
    const r5 = this._uniforms.find((e4) => e4.propertyKey === t5);
    if (!r5) throw new Error(`Unable to find uniform class type for property: ${t5}`);
    return { type: "required", className: r5.typeCtor };
  }
  getShaderKey(t5, e3, r5, o3) {
    const n4 = Object.keys(t5).map((e4) => `${e4}.${t5[e4]}`).join("."), s6 = Object.keys(r5).map((t6) => `${t6}.${r5[t6]}`).join("."), i3 = Object.keys(o3).map((t6) => `${t6}.${o3[t6]}`).join("."), p3 = Object.keys(e3).filter((t6) => this.optionPropertyKeys.has(t6) && e3[t6]).join(".");
    return `${this.type}.${n4}.${s6}.${i3}.${p3}`;
  }
  _generateShaders(t5, e3, r5, o3) {
    const n4 = [];
    this._setDefines(r5), this._setOptionalUniforms(n4, e3), this._setRequiredUniforms(n4);
    const s6 = this._hydrateVertexInput(o3), u2 = this._injectPackPrecisionFactor(s6, t5), c2 = this._hydrateComputeInput(), y3 = c2 && this._injectComputePackPrecisionFactor(c2, t5), d3 = this.vertex(u2, y3), f4 = this._hydrateFragmentInput(d3), h4 = this.fragment(f4), l3 = /* @__PURE__ */ new Set();
    for (const i3 in h4) {
      const t6 = h4[i3];
      e(l3, t6);
    }
    const m3 = this._getVertexInputBuiltins(), g3 = {};
    for (const [i3, p3] of Object.entries(s6)) g3[i3] = p3;
    if (null != c2) for (const [i3, p3] of Object.entries(c2)) g3[i3] = p3;
    const _3 = n2.createVertex(g3, d3, m3, n4, this.transformFeedbackBindings, l3);
    new r3().write(_3);
    const K2 = this._getFragmentInputBuiltins(h4);
    K2.set("glPointCoord", "gl_PointCoord"), K2.set("glFragCoord", "gl_FragCoord");
    const b3 = n2.createFragment(f4, h4, K2, n4, _3, this.transformFeedbackBindings);
    new r3().write(b3);
    const C3 = this._createShaderBuilder(_3, b3), x3 = C3.generate("vertex"), I3 = C3.generate("fragment");
    return this.logShader && (console.log(x3), console.log(I3)), { vertex: x3, fragment: I3, uniformBindings: n4 };
  }
  _setDefines(t5) {
    for (const e3 in t5) this[e3] = t5[e3];
  }
  _setOptionalUniforms(t5, e3) {
    for (const r5 of this._options) {
      e3[r5.propertyKey] ? this[r5.propertyKey] = this._hydrateUniformGroup(t5, r5) : this[r5.propertyKey] = null;
    }
  }
  _setRequiredUniforms(t5) {
    for (const e3 of this._uniforms) this[e3.propertyKey] = this._hydrateUniformGroup(t5, e3);
  }
  _hydrateUniformGroup(t5, e3) {
    const r5 = new (0, e3.typeCtor)();
    for (const o3 of r5._uniforms ?? []) {
      const n4 = y2(o3.typeCtor), s6 = `u_${e3.propertyKey}_${o3.propertyKey}`, i3 = n4.type, p3 = [e3.propertyKey, o3.propertyKey].join(".");
      if ("type" in o3.typeCtor && "array" === o3.typeCtor.type) {
        const e4 = n4;
        t5.push({ shaderModulePath: p3, uniformName: s6, uniformType: i3, uniformArrayLength: e4.size, uniformArrayElementType: e4.elementType.type, uniformHydrated: n4 });
      } else if ("type" in o3.typeCtor && "array-2d" === o3.typeCtor.type) {
        const e4 = n4;
        t5.push({ shaderModulePath: p3, uniformName: s6, uniformType: i3, uniformArrayLength: e4.size, uniformArrayElementType: e4.elementType.type, uniformHydrated: n4 });
      } else t5.push({ shaderModulePath: p3, uniformName: s6, uniformType: i3, uniformHydrated: n4 });
      r5[o3.propertyKey] = n4;
    }
    return r5;
  }
  _hydrateVertexInput(t5) {
    const e3 = this.vertexInput.inputCtor, r5 = e3.locations.reduce((e4, r6) => false === t5[r6.propertyKey] ? e4 : { ...e4, [r6.propertyKey]: y2(r6.typeCtor) }, {});
    for (const { propertyKey: o3, typeCtor: n4 } of e3.builtins) {
      const t6 = y2(n4);
      r5[o3] = t6;
    }
    return r5;
  }
  _hydrateComputeInput() {
    if (null == this.computeInput) return null;
    return this.computeInput.inputCtor.locations.reduce((t5, e3) => ({ ...t5, [e3.propertyKey]: y2(e3.typeCtor) }), {});
  }
  _injectPackPrecisionFactor(t5, e3) {
    const o3 = {};
    for (const n4 in t5) {
      const s6 = t5[n4], i3 = e3[n4];
      if (i3) {
        if ("float" !== s6.type && "vec2" !== s6.type && "vec3" !== s6.type && "vec4" !== s6.type) throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${s6.type}`);
        o3[n4] = s6.divide(new C(i3));
      } else o3[n4] = s6;
    }
    return o3;
  }
  _injectComputePackPrecisionFactor(t5, e3) {
    const o3 = {}, n4 = /* @__PURE__ */ new Map();
    for (const r5 in this.computeAttributes) for (const t6 of this.computeAttributes[r5] ?? []) n4.set(t6, r5);
    for (const s6 in t5) {
      const i3 = t5[s6], p3 = n4.get(s6);
      if (!p3) continue;
      const a5 = e3[p3];
      if (a5) {
        if ("float" !== i3.type && "vec2" !== i3.type && "vec3" !== i3.type && "vec4" !== i3.type) throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${i3.type}`);
        o3[s6] = i3.divide(new C(a5));
      } else o3[s6] = i3;
    }
    return o3;
  }
  _hydrateFragmentInput(t5) {
    const e3 = {};
    for (const r5 in t5) e3[r5] = t5[r5];
    for (const { propertyKey: r5, typeCtor: o3 } of I2.builtins) {
      const t6 = y2(o3);
      e3[r5] = t6;
    }
    return e3;
  }
  _getVertexInputBuiltins() {
    const t5 = this.vertexInput.inputCtor, e3 = /* @__PURE__ */ new Map();
    for (const { builtin: r5, propertyKey: o3 } of t5.builtins) e3.set(o3, r5);
    return e3;
  }
  _getFragmentInputBuiltins(t5) {
    const e3 = t5.constructor, r5 = /* @__PURE__ */ new Map();
    for (const o3 of e3.builtins ?? []) r5.set(o3.propertyKey, o3.builtin);
    return r5;
  }
  _createShaderBuilder(t5, e3) {
    const r5 = new s2();
    return this._insertDebugInfo(r5), t5.insertVertexShader(r5), e3.insertFragmentShader(r5), r5;
  }
  _insertDebugInfo(t5) {
    t5.vertex.code.add("// DEFINES: "), t5.vertex.code.add("// --------------------------------------------------------- ");
    for (const e3 of this._defines) this[e3.propertyKey] ? t5.vertex.code.add(`//   ${e3.propertyKey}: true`) : t5.vertex.code.add(`//   ${e3.propertyKey}: false`);
    t5.vertex.code.add(""), t5.vertex.code.add("// OPTIONS: "), t5.vertex.code.add("// --------------------------------------------------------- ");
    for (const e3 of this._options) this[e3.propertyKey] ? t5.vertex.code.add(`//   ${e3.propertyKey}: true`) : t5.vertex.code.add(`//   ${e3.propertyKey}: false`);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/Technique.js
var s5 = class {
  constructor() {
    this.drawPhase = 89;
  }
  startup() {
  }
  shutdown(s6) {
  }
};

export {
  s5 as s,
  B,
  q,
  U,
  C,
  X,
  Y,
  _,
  J,
  W,
  Z,
  nt,
  rt,
  it,
  ut,
  st,
  ot,
  ht,
  lt,
  ft,
  gt,
  xt,
  zt,
  Tt,
  Dt,
  St,
  Rt,
  jt,
  Pt,
  Bt,
  qt,
  Ut,
  Ct,
  Xt,
  Yt,
  _t,
  Gt,
  Ht,
  At,
  Jt,
  Lt,
  Qt,
  Wt,
  Zt,
  ne,
  re,
  ie,
  ce,
  ue,
  se,
  oe,
  he,
  ye,
  we,
  ge,
  ze,
  Te,
  je,
  qe,
  Ue,
  Xe,
  Ye,
  _e,
  Ge,
  Ae,
  Ve,
  We,
  nn,
  cn,
  un,
  sn,
  on,
  hn,
  ln,
  an,
  fn,
  pn,
  wn,
  jn,
  f2 as f,
  f3 as f2,
  l2 as l,
  m2 as m,
  g2 as g,
  _2,
  C2,
  x2 as x,
  I2 as I,
  v2 as v,
  w2 as w,
  P2 as P
};
//# sourceMappingURL=chunk-JGWZMI5Q.js.map
