import {
  c
} from "./chunk-SUOIQXQ3.js";
import {
  f2 as f,
  f3 as f2,
  i as i2,
  n,
  t,
  u4 as u,
  w,
  y
} from "./chunk-PZ5RULLK.js";
import {
  r
} from "./chunk-OPJX4KXH.js";
import {
  g,
  i
} from "./chunk-FPMLKIDB.js";
import {
  M
} from "./chunk-SMWUT52Z.js";
import {
  h
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/views/draw/support/drawUtils.js
function y2(t2, n2, r2, o) {
  if (null == o || t2.hasZ || (o = void 0), "point" === t2.type) return t2.x += n2, t2.y += r2, t2.hasZ && null != o && (t2.z += o), t2;
  if ("multipoint" === t2.type) {
    const e2 = t2.points;
    for (let t3 = 0; t3 < e2.length; t3++) e2[t3] = g2(e2[t3], n2, r2, o);
    return t2;
  }
  if ("extent" === t2.type) return t2.xmin += n2, t2.xmax += n2, t2.ymin += r2, t2.ymax += r2, null != o && (t2.zmin ??= 0, t2.zmin += o, t2.zmax ??= 0, t2.zmax += o), t2;
  const e = "polyline" === t2.type ? t2.curvePaths ?? t2.paths : t2.curveRings ?? t2.rings, i3 = n(t2);
  for (let s = 0; s < e.length; s++) {
    const t3 = e[s];
    for (let e2 = 0; e2 < t3.length; e2++) t3[e2] = v(t3[e2], n2, r2, o);
  }
  return "paths" in t2 ? i3 ? t2.curvePaths = e : t2.paths = e : i3 ? t2.curveRings = e : t2.rings = e, t2;
}
function x(t2, n2, r2, o, e) {
  const i3 = t2.clone();
  if (e) {
    const { resolution: t3 } = o;
    y2(i3, n2 * t3, -r2 * t3);
  } else {
    const { dxMap: t3, dyMap: e2 } = h2(n2, r2, o);
    y2(i3, t3, e2);
  }
  return i3;
}
function h2(t2, n2, r2) {
  const o = r2.state.inverseTransform;
  return { dxMap: o[0] * t2 + o[2] * n2, dyMap: o[1] * t2 + o[3] * n2 };
}
function g2(t2, n2, r2, o) {
  return z(t2, t2[0] + n2, t2[1] + r2, null != t2[2] && null != o ? t2[2] + o : void 0);
}
function v(t2, n2, r2, o) {
  const e = g2(f2(t2), n2, r2, o);
  if (i2(t2)) return e;
  if (t(t2)) {
    const [, o2, i4] = t2.b;
    return { b: [e, [o2[0] + n2, o2[1] + r2], [i4[0] + n2, i4[1] + r2]] };
  }
  if (u(t2)) {
    const [, o2] = t2.c;
    return { c: [e, [o2[0] + n2, o2[1] + r2]] };
  }
  const [, i3, ...s] = t2.a;
  return { a: [e, [i3[0] + n2, i3[1] + r2], ...s] };
}
function M2(n2, s, c2, a) {
  if ("point" === n2.type) {
    const { x: t2, y: r2 } = n2, o = a ? a[0] : t2, e = a ? a[1] : r2, i3 = n2.clone(), u2 = (t2 - o) * s + o, m2 = (r2 - e) * c2 + e;
    return i3.x = u2, i3.y = m2, i3;
  }
  if ("extent" === n2.type) {
    const { xmin: t2, xmax: r2, ymin: o, ymax: e } = n2, i3 = a ? a[0] : (t2 + r2) / 2, u2 = a ? a[1] : (e + o) / 2, m2 = n2.clone();
    if (m2.xmin = (t2 - i3) * s + i3, m2.ymax = (e - u2) * c2 + u2, m2.xmax = (r2 - i3) * s + i3, m2.ymin = (o - u2) * c2 + u2, m2.xmin > m2.xmax) {
      const t3 = m2.xmin, n3 = m2.xmax;
      m2.xmin = n3, m2.xmax = t3;
    }
    if (m2.ymin > m2.ymax) {
      const t3 = m2.ymin, n3 = m2.ymax;
      m2.ymin = n3, m2.ymax = t3;
    }
    return m2;
  }
  let m = null;
  if (!a) {
    m = r(n2);
    const t2 = i(), o = y(t2, m);
    if (!o) return n2.clone();
    const [s2, c3, u2, l2] = o;
    a = [(s2 + u2) / 2, (c3 + l2) / 2];
  }
  const [l, p] = a;
  if ("multipoint" === n2.type) {
    const t2 = n2.clone(), r2 = t2.points;
    for (let n3 = 0; n3 < r2.length; n3++) {
      const t3 = r2[n3], [o, e] = t3, i3 = (o - l) * s + l, u2 = (e - p) * c2 + p;
      r2[n3] = z(t3, i3, u2, void 0);
    }
    return t2.points = r2, t2;
  }
  const f3 = n2.clone();
  m ??= r(n2);
  const y3 = "polygon" === f3.type, x2 = y3 ? f3.curveRings ?? f3.rings : f3.curvePaths ?? f3.paths;
  if (!a) {
    const t2 = i(), n3 = y(t2, x2, false, false);
    if (!n3) return f3;
    a = g(n3);
  }
  for (const r2 of x2) {
    let n3 = null;
    const o = y3 && r2.length > 0 && h(f2(r2[0]), f2(r2.at(-1)));
    for (let t2 = 0; t2 < r2.length; t2++) {
      const o2 = r2[t2];
      r2[t2] = j(o2, s, c2, l, p, n3), n3 = o2;
    }
    o && (r2[0] = [...f2(r2.at(-1))]);
  }
  return f3;
}
function d(t2, n2, r2, o, e) {
  const [i3, s, ...c2] = t2;
  return [(i3 - o) * n2 + o, (s - e) * r2 + e, ...c2];
}
function j(t2, n2, r2, o, e, i3) {
  if (i2(t2)) return d(t2, n2, r2, o, e);
  if (t(t2)) {
    const [i4, s, c3] = t2.b.map((t3) => d(t3, n2, r2, o, e));
    return { b: [i4, s, c3] };
  }
  if (!i3) return t2;
  const c2 = f2(i3), y3 = u(t2) ? f(c2, t2) : t2, [x2, h3, g3, v2, M3, j2, U2] = y3.a, b2 = M3 ?? 0, z2 = j2 ?? Math.hypot(x2[0] - h3[0], x2[1] - h3[1]), R = U2 ?? 1, P = c(o, e, 1, 0, 0, 1, n2, r2);
  return w(c2, { a: [[...x2], [...h3], g3, v2, b2, z2, R] }, P);
}
function U(t2, n2, r2, o, e, i3) {
  const s = Math.sqrt((r2 - t2) * (r2 - t2) + (o - n2) * (o - n2));
  return Math.sqrt((e - t2) * (e - t2) + (i3 - n2) * (i3 - n2)) / s;
}
function b(t2, r2, o, e = false) {
  const i3 = Math.atan2(r2.y - o.y, r2.x - o.x) - Math.atan2(t2.y - o.y, t2.x - o.x), s = Math.atan2(Math.sin(i3), Math.cos(i3));
  return e ? s : M(s);
}
function z(t2, n2, r2, o) {
  const e = [n2, r2];
  return t2.length > 2 && e.push(null != o ? o : t2[2]), t2.length > 3 && e.push(t2[3]), e;
}

export {
  x,
  h2 as h,
  M2 as M,
  U,
  b
};
//# sourceMappingURL=chunk-H4PQ35LQ.js.map
