import {
  c,
  d2 as d,
  f3 as f,
  h,
  h3 as h2,
  i,
  l,
  n,
  o,
  p2 as p,
  r,
  r2,
  t,
  u,
  u4 as u2
} from "./chunk-PZ5RULLK.js";

// node_modules/@arcgis/core/geometry/support/curves/densifyCurvedGeometry.js
var v = { maxSegmentLength: 1 / 0, maxDeviation: 1 / 0, maxSegmentsPerCurve: 12e3, minSegmentsPerCurve: 1 };
var f2 = 1e-6;
var g = [0, 0];
function M(t2) {
  return { maxSegmentLength: t2.maxSegmentLength ?? v.maxSegmentLength, maxDeviation: t2.maxDeviation ?? v.maxDeviation, maxSegmentsPerCurve: t2.maxSegmentsPerCurve ?? v.maxSegmentsPerCurve, minSegmentsPerCurve: Math.max(t2.minSegmentsPerCurve ?? v.minSegmentsPerCurve, 1) };
}
var P = class {
  constructor(t2, s) {
    this.curveStart = t2, this.curveEnd = s, this.tStart = 0, this.tEnd = 0, this.tEndStack = [], this.arcEndStack = [];
  }
  get stackSize() {
    return this.tEndStack.length;
  }
  initialize(t2, s) {
    this.tStart = 0, this.arcStart = t2, this.tEndStack.push(1), this.arcEndStack.push(s);
  }
  splitAt(t2) {
    this.tEndStack.push(this.tEnd), this.arcEndStack.push(this.arcEnd), this.tEndStack.push(t2), this.arcEndStack.push(this.interpolate(t2));
  }
  splitInHalf() {
    return this.splitAt((this.tStart + this.tEnd) / 2);
  }
  pop() {
    this.tEnd = this.tEndStack.pop(), this.arcEnd = this.arcEndStack.pop();
  }
  next() {
    this.tStart = this.tEnd, this.arcStart = this.arcEnd;
  }
  densify(t2, { maxDeviation: s, maxSegmentLength: i2, maxSegmentsPerCurve: n2, minSegmentsPerCurve: e }) {
    const r3 = i2 * i2, a2 = s * s, h3 = 1 / n2, c2 = this.interpolate(0), o3 = this.interpolate(1);
    o(this.curveStart, c2) > f2 && t2.push(c2), this.initialize(c2, o3);
    const u3 = 1 / e;
    for (let p2 = e - 1; p2 > 0; p2--) {
      const t3 = p2 * u3;
      this.pop(), this.splitAt(t3);
    }
    for (; this.stackSize > 0; ) this.pop(), this.tStart === this.tEnd || this.tEnd - this.tStart < h3 || (0 === r3 || !isFinite(r3) || o(this.arcStart, this.arcEnd) < r3) && (0 === a2 || !isFinite(a2) || this.getDeviation2() < a2) ? (t2.push(this.arcEnd), this.next()) : this.splitInHalf();
    return o(this.curveEnd, o3) > f2 && t2.push([...this.curveEnd]), t2;
  }
};
var x = class extends P {
  constructor(t2, s) {
    const [i2, n2, e] = s.b;
    super(t2, i2), this._controlPointsStack = [], this._curveControlPoints = [n2, e], this._arcControlPoints = [n2, e], this._controlPointsStack.push(this._arcControlPoints);
  }
  splitAt(t2) {
    const { arcStart: s, arcEnd: i2, tStart: n2, tEnd: e } = this, [r3, a2] = this._arcControlPoints, h3 = (t2 - n2) / (e - n2), c2 = r([], s, r3, h3), o3 = r(g, r3, a2, h3), u3 = r([], a2, i2, h3), p2 = r([], c2, o3, h3), l2 = r([], o3, u3, h3), d2 = r([], p2, l2, h3);
    this.tEndStack.push(this.tEnd), this.arcEndStack.push(this.arcEnd), this._controlPointsStack.push([l2, u3]), this.tEndStack.push(t2), this.arcEndStack.push(d2), this._arcControlPoints[0] = c2, this._arcControlPoints[1] = p2, this._controlPointsStack.push(this._arcControlPoints);
  }
  pop() {
    super.pop(), this._arcControlPoints = this._controlPointsStack.pop();
  }
  interpolate(s) {
    const { curveStart: i2, curveEnd: n2 } = this, [e, r3] = this._curveControlPoints;
    return h(i2, e, r3, n2, s);
  }
  getDeviation2() {
    const { arcStart: t2, arcEnd: s } = this, [i2, n2] = this._arcControlPoints;
    return Math.max(u(i2, t2, s), u(n2, t2, s));
  }
};
var k = class extends P {
  constructor(t2, s) {
    const [i2] = s.a;
    super(t2, i2), this._derivedEllipse = p(t2, s);
  }
  pop() {
    super.pop(), this._tMid = (this.tStart + this.tEnd) / 2, this._arcMid = this.interpolate(this._tMid);
  }
  splitInHalf() {
    this.tEndStack.push(this.tEnd), this.arcEndStack.push(this.arcEnd), this.tEndStack.push(this._tMid), this.arcEndStack.push(this._arcMid);
  }
  interpolate(t2) {
    return d(this._derivedEllipse, t2);
  }
  getDeviation2() {
    return u(this._arcMid, this.arcStart, this.arcEnd);
  }
};
function C(t2, s, i2, { cx: n2, cy: e, radius: r3, thetaStart: a2, thetaEnd: h3, isInvalid: c2 }, { maxDeviation: o3, maxSegmentLength: u3, maxSegmentsPerCurve: p2, minSegmentsPerCurve: l2 }) {
  if (c2) return t2.push([...i2]), t2;
  const d2 = 2 * r3, m = [n2 + r3 * Math.cos(a2), e + r3 * Math.sin(a2)], S = [n2 + r3 * Math.cos(h3), e + r3 * Math.sin(h3)];
  o(s, m) > f2 && t2.push(m);
  const v2 = Math.abs(h3 - a2), g2 = u3 < d2 ? 2 * Math.asin(u3 / d2) : v2, M2 = o3 <= r3 ? 2 * Math.acos(1 - o3 / r3) : v2, P2 = Math.min(g2, M2), x2 = Math.min(p2, Math.max(l2, Math.ceil(Math.abs(v2 / P2)))), k2 = 1 / x2;
  for (let E = 1; E < x2; E++) {
    const s2 = E * k2, i3 = a2 * (1 - s2) + h3 * s2;
    t2.push([n2 + r3 * Math.cos(i3), e + r3 * Math.sin(i3)]);
  }
  return t2.push(S), o(i2, S) > f2 && t2.push([...i2]), t2;
}
function _(t2, s, i2, n2) {
  return new x(s, i2).densify(t2, n2);
}
function Z(t2, i2, n2, e) {
  const r3 = l(i2, n2), [a2] = n2.c;
  return C(t2, i2, a2, r3, e);
}
function A(t2, s, i2, n2) {
  const e = h2(s, i2), [r3] = i2.a;
  return C(t2, s, r3, e, n2);
}
function D(t2, s, i2, n2) {
  const [e, r3, a2, h3, c2, o3, u3] = i2.a;
  return 0 === o3 || 0 === u3 ? (t2.push([...e]), t2) : new k(s, i2).densify(t2, n2);
}
function R(t2, s, i2, n2) {
  return i(i2) ? (t2.push([...i2]), t2) : t(i2) ? _(t2, s, i2, n2) : u2(i2) ? Z(t2, s, i2, n2) : c(i2) ? A(t2, s, i2, n2) : D(t2, s, i2, n2);
}
function y(t2, s) {
  if (!n(t2)) return t2;
  const r3 = M(s), a2 = r2(t2), h3 = [];
  for (const i2 of a2) {
    const t3 = [];
    for (let s2 = 0; s2 < i2.length - 1; s2++) {
      const n2 = s2 + 1, a3 = [...f(i2[s2])];
      0 === s2 && t3.push(a3);
      R(t3, a3, i2[n2], r3);
    }
    h3.push(t3);
  }
  return "curvePaths" in t2 ? { ...void 0 !== t2.hasZ ? { hasZ: t2.hasZ } : {}, ...void 0 !== t2.hasM ? { hasM: t2.hasM } : {}, paths: h3, spatialReference: t2.spatialReference } : { ...void 0 !== t2.hasZ ? { hasZ: t2.hasZ } : {}, ...void 0 !== t2.hasM ? { hasM: t2.hasM } : {}, rings: h3, spatialReference: t2.spatialReference };
}

export {
  y
};
//# sourceMappingURL=chunk-MJIAJDWR.js.map
