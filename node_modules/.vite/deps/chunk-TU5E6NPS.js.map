{
  "version": 3,
  "sources": ["../../@arcgis/toolkit/dist/dom/index.js"],
  "sourcesContent": ["function slotChangeHasContent(event) {\n  return slotChangeHasAssignedElement(event) || slotChangeHasTextContent(event);\n}\nfunction slotChangeGetTextContent(event) {\n  return slotChangeGetAssignedNodes(event).filter((node) => node.nodeType === Node.TEXT_NODE).map((node) => node.textContent).join(\"\").trim();\n}\nfunction slotChangeHasTextContent(event) {\n  return slotChangeGetTextContent(event).length > 0;\n}\nfunction slotChangeHasAssignedNode(event) {\n  return slotChangeGetAssignedNodes(event).length > 0;\n}\nfunction slotChangeGetAssignedNodes(event) {\n  return event.currentTarget.assignedNodes({\n    flatten: true\n  });\n}\nfunction slotChangeHasAssignedElement(event) {\n  return slotChangeGetAssignedElements(event).length > 0;\n}\nfunction slotChangeGetAssignedElements(event, selector) {\n  return getSlotAssignedElements(event.target, selector);\n}\nfunction getSlotAssignedElements(slot, selector) {\n  const assignedElements = slot.assignedElements({\n    flatten: true\n  });\n  return selector ? assignedElements.filter((element) => element.matches(selector)) : assignedElements;\n}\nconst classes = (...classes2) => {\n  const effectiveClasses = [];\n  for (let i = 0; i < classes2.length; i++) {\n    const arg = classes2[i];\n    if (typeof arg === \"string\") {\n      effectiveClasses.push(arg);\n    } else if (Array.isArray(arg)) {\n      effectiveClasses.push.apply(effectiveClasses, arg);\n    } else if (typeof arg === \"object\") {\n      for (const prop in arg) {\n        if (arg[prop]) {\n          effectiveClasses.push(prop);\n        }\n      }\n    }\n  }\n  const className = effectiveClasses.join(\" \");\n  effectiveClasses.length = 0;\n  return className;\n};\nconst inTargetElement = (element, targetElement) => {\n  let currentElement = element;\n  while (currentElement) {\n    if (currentElement === targetElement) {\n      return true;\n    }\n    if (!currentElement.parentNode) {\n      return false;\n    }\n    if (currentElement.parentNode instanceof ShadowRoot) {\n      currentElement = currentElement.parentNode.host;\n    } else {\n      currentElement = currentElement.parentNode;\n    }\n  }\n  return false;\n};\nconst observeAncestorsMutation = (element, attributeFilter, callback) => {\n  const subscribe = observe(attributeFilter).subscribe;\n  return subscribe((mutations) => {\n    const matched = mutations.some((mutation) => inTargetElement(element, mutation.target));\n    if (matched) {\n      callback();\n    }\n  });\n};\nconst observers = {};\nconst observe = (attributeFilter) => {\n  const attributes = attributeFilter.join(\",\");\n  const previousObserver = observers[attributes];\n  if (previousObserver !== void 0) {\n    return previousObserver;\n  }\n  const subscribers = /* @__PURE__ */ new Set();\n  const mutationObserver = new MutationObserver((mutations) => subscribers.forEach((callback) => callback(mutations)));\n  if (globalThis.document) {\n    mutationObserver.observe(document.documentElement, {\n      attributes: true,\n      attributeFilter,\n      subtree: true\n    });\n  }\n  const observer = {\n    subscribe: (callback) => {\n      subscribers.add(callback);\n      return () => {\n        subscribers.delete(callback);\n        if (subscribers.size === 0) {\n          mutationObserver.disconnect();\n          observers[attributes] = void 0;\n        }\n      };\n    }\n  };\n  observers[attributes] = observer;\n  return observer;\n};\nconst getClosestElement = (base, selector) => {\n  let currentElement = base;\n  while (currentElement) {\n    const element = currentElement.closest?.(selector);\n    if (element) {\n      return element;\n    }\n    const rootElement = currentElement.getRootNode?.();\n    if (rootElement === globalThis.document) {\n      return;\n    }\n    currentElement = rootElement.host;\n  }\n  return;\n};\nfunction unsafeGetCalciteModeName(el) {\n  const closestElWithMode = getClosestElement(el, `.calcite-mode-dark, .calcite-mode-light, .calcite-mode-auto`);\n  return closestElWithMode?.classList.contains(\"calcite-mode-dark\") || closestElWithMode?.classList.contains(\"calcite-mode-auto\") && window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"dark\" : \"light\";\n}\nconst unsafeGetElementDirection = (el) => (\n  //#endregion unsafeGetElementDirection\n  getElementAttribute(el, \"dir\", \"ltr\")\n);\nconst getElementAttribute = (el, attributeName, fallbackValue) => {\n  const closest = getClosestElement(el, `[${attributeName}]`);\n  return closest?.getAttribute(attributeName) ?? fallbackValue;\n};\nconst focusElement = async (el) => {\n  if (el == null) {\n    return;\n  }\n  if (hasSetFocus(el)) {\n    await el.setFocus();\n  } else {\n    el.focus();\n  }\n};\nconst hasSetFocus = (ref) => typeof ref.setFocus === \"function\";\nconst setFocusOnElement = (ref, selector) => {\n  if (!ref?.shadowRoot) {\n    return;\n  }\n  if (ref.hasAttribute(\"hydrated\") || ref.hasAttribute(\"calcite-hydrated\")) {\n    setFocus(ref, selector);\n    return;\n  }\n  void Promise.resolve(ref.componentOnReady?.()).then(() => setFocus(ref, selector));\n};\nconst isElement = (ref) => ref.nodeType === Node.ELEMENT_NODE;\nconst setFocus = (ref, selector = \"\") => {\n  if (!isElement(ref)) {\n    return false;\n  }\n  if (ref.matches(selector)) {\n    if (hasSetFocus(ref)) {\n      setTimeout(() => void ref.setFocus(), 0);\n    }\n    return true;\n  }\n  for (const child of ref.children) {\n    if (setFocus(child, selector)) {\n      return true;\n    }\n  }\n  const shadowRoot = ref.shadowRoot;\n  if (shadowRoot) {\n    for (const child of shadowRoot.children) {\n      if (setFocus(child, selector)) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\nexport {\n  classes,\n  focusElement,\n  getClosestElement,\n  getElementAttribute,\n  getSlotAssignedElements,\n  observeAncestorsMutation,\n  setFocusOnElement,\n  slotChangeGetAssignedElements,\n  slotChangeGetAssignedNodes,\n  slotChangeGetTextContent,\n  slotChangeHasAssignedElement,\n  slotChangeHasAssignedNode,\n  slotChangeHasContent,\n  slotChangeHasTextContent,\n  unsafeGetCalciteModeName,\n  unsafeGetElementDirection\n};\n"],
  "mappings": ";AAiDA,IAAM,kBAAkB,CAAC,SAAS,kBAAkB;AAClD,MAAI,iBAAiB;AACrB,SAAO,gBAAgB;AACrB,QAAI,mBAAmB,eAAe;AACpC,aAAO;AAAA,IACT;AACA,QAAI,CAAC,eAAe,YAAY;AAC9B,aAAO;AAAA,IACT;AACA,QAAI,eAAe,sBAAsB,YAAY;AACnD,uBAAiB,eAAe,WAAW;AAAA,IAC7C,OAAO;AACL,uBAAiB,eAAe;AAAA,IAClC;AAAA,EACF;AACA,SAAO;AACT;AACA,IAAM,2BAA2B,CAAC,SAAS,iBAAiB,aAAa;AACvE,QAAM,YAAY,QAAQ,eAAe,EAAE;AAC3C,SAAO,UAAU,CAAC,cAAc;AAC9B,UAAM,UAAU,UAAU,KAAK,CAAC,aAAa,gBAAgB,SAAS,SAAS,MAAM,CAAC;AACtF,QAAI,SAAS;AACX,eAAS;AAAA,IACX;AAAA,EACF,CAAC;AACH;AACA,IAAM,YAAY,CAAC;AACnB,IAAM,UAAU,CAAC,oBAAoB;AACnC,QAAM,aAAa,gBAAgB,KAAK,GAAG;AAC3C,QAAM,mBAAmB,UAAU,UAAU;AAC7C,MAAI,qBAAqB,QAAQ;AAC/B,WAAO;AAAA,EACT;AACA,QAAM,cAA8B,oBAAI,IAAI;AAC5C,QAAM,mBAAmB,IAAI,iBAAiB,CAAC,cAAc,YAAY,QAAQ,CAAC,aAAa,SAAS,SAAS,CAAC,CAAC;AACnH,MAAI,WAAW,UAAU;AACvB,qBAAiB,QAAQ,SAAS,iBAAiB;AAAA,MACjD,YAAY;AAAA,MACZ;AAAA,MACA,SAAS;AAAA,IACX,CAAC;AAAA,EACH;AACA,QAAM,WAAW;AAAA,IACf,WAAW,CAAC,aAAa;AACvB,kBAAY,IAAI,QAAQ;AACxB,aAAO,MAAM;AACX,oBAAY,OAAO,QAAQ;AAC3B,YAAI,YAAY,SAAS,GAAG;AAC1B,2BAAiB,WAAW;AAC5B,oBAAU,UAAU,IAAI;AAAA,QAC1B;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,YAAU,UAAU,IAAI;AACxB,SAAO;AACT;AACA,IAAM,oBAAoB,CAAC,MAAM,aAAa;AAC5C,MAAI,iBAAiB;AACrB,SAAO,gBAAgB;AACrB,UAAM,UAAU,eAAe,UAAU,QAAQ;AACjD,QAAI,SAAS;AACX,aAAO;AAAA,IACT;AACA,UAAM,cAAc,eAAe,cAAc;AACjD,QAAI,gBAAgB,WAAW,UAAU;AACvC;AAAA,IACF;AACA,qBAAiB,YAAY;AAAA,EAC/B;AACA;AACF;AACA,SAAS,yBAAyB,IAAI;AACpC,QAAM,oBAAoB,kBAAkB,IAAI,6DAA6D;AAC7G,SAAO,mBAAmB,UAAU,SAAS,mBAAmB,KAAK,mBAAmB,UAAU,SAAS,mBAAmB,KAAK,OAAO,WAAW,8BAA8B,EAAE,UAAU,SAAS;AAC1M;AAKA,IAAM,sBAAsB,CAAC,IAAI,eAAe,kBAAkB;AAChE,QAAM,UAAU,kBAAkB,IAAI,IAAI,aAAa,GAAG;AAC1D,SAAO,SAAS,aAAa,aAAa,KAAK;AACjD;",
  "names": []
}
