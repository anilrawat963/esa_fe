import {
  e
} from "./chunk-MA55PIAQ.js";
import "./chunk-233ALXRM.js";
import {
  m as m2
} from "./chunk-3FUHCAX3.js";
import {
  P,
  y3 as y
} from "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import {
  z
} from "./chunk-H74Q4SYB.js";
import "./chunk-SMWUT52Z.js";
import {
  _,
  o
} from "./chunk-AXZMNHTN.js";
import {
  f
} from "./chunk-5T3MJDSR.js";
import "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import "./chunk-5EI5H4QX.js";
import {
  m
} from "./chunk-ZIE53VIV.js";
import "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import "./chunk-GNMPGHLQ.js";
import "./chunk-QY7XKUIV.js";
import "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/geometry/geometryAdapters/hydrated.js
var r = { convertToGEGeometry: s, exportPoint: a, exportPolygon: c, exportPolyline: h, exportMultipoint: m3, exportExtent: x };
function s(e2, n) {
  if (null == n) return null;
  let t = "cache" in n ? n.cache._geVersion : void 0;
  return null == t && (t = e2.convertJSONToGeometry(n), "cache" in n && (n.cache._geVersion = t)), t;
}
function a(e2, n, o3) {
  const i2 = e2.hasZ(n), r2 = e2.hasM(n), s3 = new _({ x: e2.getPointX(n), y: e2.getPointY(n), spatialReference: o3 });
  return i2 && (s3.z = e2.getPointZ(n)), r2 && (s3.m = e2.getPointM(n)), s3.cache._geVersion = n, s3;
}
function c(e2, n, t) {
  const i2 = new P({ rings: e2.exportPaths(n), hasZ: e2.hasZ(n), hasM: e2.hasM(n), spatialReference: t });
  return i2.cache._geVersion = n, i2;
}
function h(e2, n, t) {
  const o3 = new y({ paths: e2.exportPaths(n), hasZ: e2.hasZ(n), hasM: e2.hasM(n), spatialReference: t });
  return o3.cache._geVersion = n, o3;
}
function m3(e2, t, o3) {
  const i2 = new m2({ hasZ: e2.hasZ(t), hasM: e2.hasM(t), points: e2.exportPoints(t), spatialReference: o3 });
  return i2.cache._geVersion = t, i2;
}
function x(n, t, o3) {
  const i2 = n.hasZ(t), r2 = n.hasM(t), s3 = new z({ xmin: n.getXMin(t), ymin: n.getYMin(t), xmax: n.getXMax(t), ymax: n.getYMax(t), spatialReference: o3 });
  if (i2) {
    const e2 = n.getZExtent(t);
    s3.zmin = e2.vmin, s3.zmax = e2.vmax;
  }
  if (r2) {
    const e2 = n.getMExtent(t);
    s3.mmin = e2.vmin, s3.mmax = e2.vmax;
  }
  return s3.cache._geVersion = t, s3;
}

// node_modules/@arcgis/core/geometry/geometryEngine.js
function i(e2) {
  const r2 = Array.isArray(e2) ? e2[0].spatialReference : e2.spatialReference;
  return r2 ? m(f, r2) : f.WGS84;
}
function o2(n) {
  return e.extendedSpatialReferenceInfo(n);
}
function c2(n, t) {
  return o(n), e.clip(r, i(n), n, t);
}
function f2(n, t) {
  return o(n), e.cut(r, i(n), n, t);
}
function s2(n, t) {
  return o(n), o(t), e.contains(r, i(n), n, t);
}
function a2(n, t) {
  return o(n), o(t), e.crosses(r, i(n), n, t);
}
function l(n, t, o3) {
  return o(n), o(t), e.distance(r, i(n), n, t, o3);
}
function p(n, t) {
  return o(n), o(t), e.equals(r, i(n), n, t);
}
function m4(n, t) {
  return o(n), o(t), e.intersects(r, i(n), n, t);
}
function d(n, t) {
  return o(n), o(t), e.touches(r, i(n), n, t);
}
function g(n, t) {
  return o(n), o(t), e.within(r, i(n), n, t);
}
function h2(n, t) {
  return o(n), o(t), e.disjoint(r, i(n), n, t);
}
function w(n, t) {
  return o(n), o(t), e.overlaps(r, i(n), n, t);
}
function R(n, t, o3) {
  return o(n), o(t), e.relate(r, i(n), n, t, o3);
}
function x2(n) {
  return o(n), e.isSimple(r, i(n), n);
}
function y2(n) {
  return o(n), e.simplify(r, i(n), n);
}
function S(n, e2 = false) {
  return e.convexHull(r, i(n), n, e2);
}
function j(n, t) {
  return o(t), e.difference(r, i(n), n, t);
}
function A(n, t) {
  return o(t), e.symmetricDifference(r, i(n), n, t);
}
function D(n, t) {
  return o(t), e.intersect(r, i(n), n, t);
}
function T(n) {
  return e.union(r, i(n), n);
}
function E(n, e2, t, o3, c3, f3) {
  return e.offset(r, i(n), n, e2, t, o3, c3, f3);
}
function J(n, e2, t, o3 = false) {
  return e.buffer(r, i(n), n, e2, t, o3);
}
function L(n, e2, t, o3, c3, f3) {
  return e.geodesicBuffer(r, i(n), n, e2, t, o3, c3, f3);
}
function N(n, t, o3 = true) {
  return o(n), e.nearestCoordinate(r, i(n), n, t, o3);
}
function O(n, t) {
  return o(n), e.nearestVertex(r, i(n), n, t);
}
function V(n, t, o3, c3) {
  return o(n), e.nearestVertices(r, i(n), n, t, o3, c3);
}
function v(n) {
  return "xmin" in n ? "center" in n ? n.center : null : "x" in n ? n : "extent" in n ? n.extent?.center ?? null : null;
}
function z2(n, e2, t) {
  if (null == n) throw new M();
  const u = n.spatialReference;
  if (null == (t = t ?? v(n))) throw new M();
  const i2 = n.constructor.fromJSON(e.rotate(n, e2, t));
  return i2.spatialReference = u, i2;
}
function B(n, e2) {
  if (null == n) throw new M();
  const t = n.spatialReference;
  if (null == (e2 = e2 ?? v(n))) throw new M();
  const u = n.constructor.fromJSON(e.flipHorizontal(n, e2));
  return u.spatialReference = t, u;
}
function G(n, e2) {
  if (null == n) throw new M();
  const t = n.spatialReference;
  if (null == (e2 = e2 ?? v(n))) throw new M();
  const u = n.constructor.fromJSON(e.flipVertical(n, e2));
  return u.spatialReference = t, u;
}
function H(n, t, o3, c3) {
  return o(n), e.generalize(r, i(n), n, t, o3, c3);
}
function I(n, t, o3) {
  return o(n), e.densify(r, i(n), n, t, o3);
}
function b(n, t, o3, c3 = 0) {
  return o(n), e.geodesicDensify(r, i(n), n, t, o3, c3);
}
function k(n, t) {
  return o(n), e.planarArea(r, i(n), n, t);
}
function q(n, t) {
  return o(n), e.planarLength(r, i(n), n, t);
}
function C(n, t, o3) {
  return o(n), e.geodesicArea(r, i(n), n, t, o3);
}
function P2(n, t, o3) {
  return o(n), e.geodesicLength(r, i(n), n, t, o3);
}
function W(n, e2) {
  return e.intersectLinesToPoints(r, i(n), n, e2);
}
function F(n, e2) {
  e.changeDefaultSpatialReferenceTolerance(n, e2);
}
function K(n) {
  e.clearDefaultSpatialReferenceTolerance(n);
}
var M = class extends Error {
  constructor() {
    super("Illegal Argument Exception");
  }
};
export {
  J as buffer,
  F as changeDefaultSpatialReferenceTolerance,
  K as clearDefaultSpatialReferenceTolerance,
  c2 as clip,
  s2 as contains,
  S as convexHull,
  a2 as crosses,
  f2 as cut,
  I as densify,
  j as difference,
  h2 as disjoint,
  l as distance,
  p as equals,
  o2 as extendedSpatialReferenceInfo,
  B as flipHorizontal,
  G as flipVertical,
  H as generalize,
  C as geodesicArea,
  L as geodesicBuffer,
  b as geodesicDensify,
  P2 as geodesicLength,
  D as intersect,
  W as intersectLinesToPoints,
  m4 as intersects,
  x2 as isSimple,
  N as nearestCoordinate,
  O as nearestVertex,
  V as nearestVertices,
  E as offset,
  w as overlaps,
  k as planarArea,
  q as planarLength,
  R as relate,
  z2 as rotate,
  y2 as simplify,
  A as symmetricDifference,
  d as touches,
  T as union,
  g as within
};
//# sourceMappingURL=geometryEngine-2B2KU6X2.js.map
