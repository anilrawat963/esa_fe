import {
  r as r3,
  x
} from "./chunk-QHMSLY43.js";
import "./chunk-27W5ILTF.js";
import {
  b as b4,
  l as l3,
  n as n4,
  p,
  s as s8
} from "./chunk-2GRS3IMC.js";
import {
  e as e9,
  u as u8
} from "./chunk-X5BCRMNY.js";
import {
  t as t6
} from "./chunk-YYGF76T3.js";
import {
  n2 as n7
} from "./chunk-GVFNGMIY.js";
import "./chunk-RQGBRVDD.js";
import "./chunk-JPZOLUPV.js";
import "./chunk-DRHU543D.js";
import "./chunk-F7RQDGE7.js";
import "./chunk-GG4AQJJO.js";
import "./chunk-OGWYK5MD.js";
import {
  a as a3
} from "./chunk-4V63WUXV.js";
import {
  R
} from "./chunk-N2KDB6KT.js";
import {
  d as d3,
  i as i9,
  i2 as i10,
  i3 as i11,
  l as l4,
  n as n5,
  n2 as n6,
  r as r4,
  t as t5
} from "./chunk-IOYCE6EG.js";
import {
  O,
  a as a2,
  u as u7
} from "./chunk-TWE24CRT.js";
import {
  i as i8
} from "./chunk-Y3GEZC7J.js";
import "./chunk-U5TTP5E5.js";
import {
  d as d4
} from "./chunk-7EPCZHGM.js";
import {
  _ as _2,
  e as e4,
  i as i6,
  r as r2,
  t as t4
} from "./chunk-CXUJAI27.js";
import "./chunk-VR2ODL2Y.js";
import "./chunk-QENBEP2X.js";
import "./chunk-VZQ643XD.js";
import "./chunk-SMJWJAIA.js";
import "./chunk-WBYRWTBX.js";
import "./chunk-WFCLXKCE.js";
import {
  s as s7
} from "./chunk-WX3525ER.js";
import {
  y as y3
} from "./chunk-FHCV4NTV.js";
import {
  r as r5
} from "./chunk-CSVD3MCH.js";
import {
  u as u6
} from "./chunk-NH6FXYCM.js";
import "./chunk-YE4E5JCT.js";
import "./chunk-SXZO7ULH.js";
import "./chunk-JCMADXBT.js";
import "./chunk-VNSHGTPN.js";
import "./chunk-4X4BOGIG.js";
import {
  c as c2,
  y as y2
} from "./chunk-QNW4D2V2.js";
import "./chunk-XAI6T5FU.js";
import "./chunk-QNDHLVDC.js";
import "./chunk-ZT4KW2M5.js";
import {
  b as b3,
  h
} from "./chunk-FHQNDU7E.js";
import {
  n as n3
} from "./chunk-IOJ4QFRL.js";
import "./chunk-2W3LGFFY.js";
import "./chunk-5BM4D5UD.js";
import "./chunk-W2EKXSEY.js";
import "./chunk-DUZAVZR4.js";
import "./chunk-EK7HOTRR.js";
import {
  e as e6
} from "./chunk-B5SL7XHP.js";
import {
  W
} from "./chunk-3VXANCFN.js";
import "./chunk-MBQEPUQX.js";
import "./chunk-ODQ5APZK.js";
import "./chunk-G5IXTUNN.js";
import "./chunk-ZNQKJRCD.js";
import {
  f as f3,
  g
} from "./chunk-BA6HYZ35.js";
import "./chunk-GCTH5LET.js";
import "./chunk-SJB744AD.js";
import "./chunk-WM2VG5F2.js";
import "./chunk-IXFJYDA2.js";
import "./chunk-TTLSEJNG.js";
import "./chunk-U73R3I4U.js";
import {
  s as s6
} from "./chunk-VGXUPJSS.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import {
  i as i7,
  s as s5,
  u as u5
} from "./chunk-WBVY3SPP.js";
import {
  e as e5
} from "./chunk-PRKYHOVW.js";
import "./chunk-WJ5RYEGC.js";
import {
  _
} from "./chunk-IRBX64M6.js";
import "./chunk-DLM5SBNY.js";
import "./chunk-EKZRA6TO.js";
import "./chunk-M5SP6ZBM.js";
import "./chunk-FAA2FDN5.js";
import {
  Z
} from "./chunk-2HGIYEIL.js";
import {
  Mt,
  X,
  at,
  gt,
  lt,
  mt,
  st,
  tt,
  wt
} from "./chunk-XX3OKYJS.js";
import "./chunk-OTCNIJ2H.js";
import {
  s as s4
} from "./chunk-JGA5YJWL.js";
import {
  e as e3
} from "./chunk-GCI4MA3M.js";
import {
  i as i5,
  s as s3
} from "./chunk-SJ2OBYX2.js";
import "./chunk-MDJNYPVI.js";
import "./chunk-Z6VKIQV2.js";
import "./chunk-4PXNA4MD.js";
import {
  r as r6
} from "./chunk-FI2PYYCT.js";
import "./chunk-ZSZK67ZL.js";
import "./chunk-IPWH4LK2.js";
import {
  h as h2
} from "./chunk-7CDU3B2L.js";
import "./chunk-B5A4L35M.js";
import "./chunk-52SEOH5H.js";
import {
  e as e7
} from "./chunk-JUZ3H47H.js";
import "./chunk-UYMV6HXW.js";
import {
  e as e8
} from "./chunk-E2RVV63B.js";
import "./chunk-AJGINJLG.js";
import {
  o
} from "./chunk-JE2NJSBU.js";
import {
  c as c3,
  l as l2
} from "./chunk-2D47RURG.js";
import "./chunk-7HTU7ZUX.js";
import "./chunk-QNVJVDYZ.js";
import "./chunk-WDTGOP77.js";
import "./chunk-BPTFV5VM.js";
import {
  z
} from "./chunk-YP3WVJP3.js";
import "./chunk-M24KZOVI.js";
import {
  b as b2
} from "./chunk-647DAMHU.js";
import {
  m as m3
} from "./chunk-O6G3PPOK.js";
import "./chunk-ZKNZTIAS.js";
import "./chunk-OJMISN3F.js";
import "./chunk-EFV6H5NA.js";
import "./chunk-XDLV73DB.js";
import "./chunk-ARTU4L55.js";
import {
  L as L2
} from "./chunk-6VL5D5UP.js";
import "./chunk-6QHY54HZ.js";
import "./chunk-GXJJY3ND.js";
import "./chunk-5ONGWFJ3.js";
import "./chunk-PLNHHGHL.js";
import "./chunk-DFK6QMLO.js";
import "./chunk-4WTOIJXV.js";
import "./chunk-BBYMM7CM.js";
import "./chunk-EM7Y2JZC.js";
import "./chunk-QZQPB5XR.js";
import "./chunk-AQFRVV3U.js";
import "./chunk-JZUJ34RR.js";
import "./chunk-PMGS7UDU.js";
import "./chunk-3GHCGAH2.js";
import {
  u as u4
} from "./chunk-HWUOAPTX.js";
import "./chunk-QHCKOBU7.js";
import "./chunk-K2OZ6WVC.js";
import "./chunk-MC6NAKKX.js";
import "./chunk-TF6255HN.js";
import "./chunk-GD4FJL3C.js";
import "./chunk-C5OQVQZF.js";
import "./chunk-F7DKSAOI.js";
import "./chunk-4SOQWNPG.js";
import "./chunk-LTULADK2.js";
import "./chunk-35ST7YRB.js";
import "./chunk-EDA5QFHZ.js";
import "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-C5M24ACM.js";
import "./chunk-L4A2QJG4.js";
import "./chunk-UDHS2MGH.js";
import {
  n as n2
} from "./chunk-QF7FRVN6.js";
import "./chunk-ENINOZUZ.js";
import "./chunk-MHV23XAQ.js";
import "./chunk-V2X4OKYI.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import "./chunk-T7F6Q6JJ.js";
import "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-3FUHCAX3.js";
import {
  P
} from "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import {
  K,
  c,
  d as d2,
  e as e2,
  f as f2,
  v
} from "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import {
  l
} from "./chunk-2OFHDVO5.js";
import {
  i as i4
} from "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-CCQFL76O.js";
import {
  u as u3
} from "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import "./chunk-7H3U4IJR.js";
import {
  r
} from "./chunk-SMWUT52Z.js";
import "./chunk-AXZMNHTN.js";
import {
  f
} from "./chunk-5T3MJDSR.js";
import "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import {
  H2 as H
} from "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import {
  b,
  i2 as i3,
  m,
  u3 as u2
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import {
  t as t3
} from "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import {
  e
} from "./chunk-4DGC7CBY.js";
import {
  $,
  L,
  T,
  d,
  m2,
  n,
  s as s2,
  t as t2,
  u2 as u,
  w,
  y
} from "./chunk-GNMPGHLQ.js";
import {
  i,
  i3 as i2,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  N,
  has,
  t
} from "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/views/2d/layers/features/PipelineConnectionHandlers.js
var t7 = class {
  constructor(e15) {
    this._client = e15, this.layerView = this._client.createInvokeProxy(""), this.container = this._client.createInvokeProxy("container"), this._eventLog = this._client.createInvokeProxy("eventLog");
  }
  onEvent(t17) {
    l2(this._eventLog.onEvent(t17));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/MultiTileMeshData.js
var r7 = 1;
var i12 = 2;
var n8 = 4;
var h3 = 8;
var o2 = 16;
var c4 = 32;
var a4 = 64;
var l5 = 128;
function f4(e15) {
  switch (e15) {
    case r7:
    case h3:
    case c4:
      return -1;
    case i12:
    case a4:
      return 0;
    case n8:
    case o2:
    case l5:
      return 1;
  }
}
function u9(e15) {
  switch (e15) {
    case r7:
    case i12:
    case n8:
      return -1;
    case h3:
    case o2:
      return 0;
    case c4:
    case a4:
    case l5:
      return 1;
  }
}
var _3 = r7 | h3 | c4;
var d5 = n8 | o2 | l5;
var m4 = r7 | i12 | n8;
var p2 = c4 | a4 | l5;
var g2 = class {
  constructor(e15, t17, r10, i21, n12 = 0) {
    this.tileKey = e15, this._bufferingEnabled = t17, this._sizeHint = n12, this._meshes = { self: new n4(this.id, this._sizeHint), neighbors: new Array() }, this._currentRecordOverlaps = 0, this._currentEntityOverlaps = 0;
    const h7 = i21 ? 1 : 0;
    this._copyBufferedDataIntoSelf = r10 && this._bufferingEnabled && e15.level === h7;
  }
  get id() {
    return this.tileKey.id;
  }
  vertexStart() {
    return this._meshes.self.vertexStart() ?? 0;
  }
  vertexCount() {
    return this._meshes.self.vertexCount();
  }
  indexCount() {
    return this._meshes.self.indexCount();
  }
  indexEnsureSize(e15) {
    this._meshes.self.indexEnsureSize(e15);
  }
  entityStart(e15, t17 = e15) {
    this._currentEntityOverlaps = 0, this._meshes.self.entityStart(e15, t17);
  }
  entityRecordCount() {
    return this._meshes.self.entityRecordCount();
  }
  entityEnd() {
    if (this._meshes.self.entityEnd(), this._bufferingEnabled) {
      if (this._copyBufferedDataIntoSelf) return;
      for (let e15 = 0; e15 < 8; e15++) {
        const t17 = 1 << e15;
        !!(this._currentEntityOverlaps & t17) && this._meshes.neighbors[e15].entityEnd();
      }
    }
  }
  recordStart(e15, t17, s17) {
    this._currentRecordOverlaps = 0, this._meshes.self.recordStart(e15, t17, s17);
  }
  recordEnd(e15 = 0) {
    const t17 = this._meshes.self.recordEnd(this._currentRecordOverlaps);
    return t17 && 0 !== this._currentRecordOverlaps ? (this._copyIntoNeighbors(), this._currentEntityOverlaps |= this._currentRecordOverlaps, true) : t17;
  }
  recordBounds(e15, t17, s17, r10) {
    this._bufferingEnabled && this._addOverlap(e15, t17, s17, r10);
  }
  recordCount() {
    return this._meshes.self.recordCount();
  }
  metricStart(e15) {
    this._meshes.self.metricStart(e15);
  }
  metricBoxWrite(e15) {
    this._meshes.self.metricBoxWrite(e15);
  }
  metricEnd() {
    this._meshes.self.metricEnd();
  }
  vertexWrite(e15) {
    this._meshes.self.vertexWrite(e15);
  }
  vertexWriteF32(e15) {
    this._meshes.self.vertexWriteF32(e15);
  }
  vertexWriteRegion(e15) {
    this._meshes.self.vertexWriteRegion(e15);
  }
  indexWrite(e15) {
    this._meshes.self.indexWrite(e15);
  }
  serialize(t17) {
    const s17 = { message: [], transferList: [] }, r10 = this._meshes.self.serialize();
    return s17.message.push({ tileId: this.tileKey.id, ...r10.message }), s17.transferList.push(...r10.transferList), this._meshes.neighbors.forEach((r11, i21) => {
      const n12 = r11.serialize(), h7 = 1 << i21, o8 = f4(h7), c8 = u9(h7), a9 = new e7(this.tileKey).getNormalizedNeighbor(o8, c8, t17);
      s17.message.push({ tileId: a9.id, ...n12.message }), s17.transferList.push(...n12.transferList);
    }), s17;
  }
  _addOverlap(e15, s17, r10, i21) {
    const n12 = Math.min(o / 2, r10), h7 = Math.min(o / 2, i21), o8 = 255 ^ ((e15 < 0 + n12 ? d5 : e15 >= o - n12 ? _3 : d5 | _3) | (s17 < 0 + h7 ? p2 : s17 >= o - h7 ? m4 : p2 | m4));
    this._currentRecordOverlaps |= o8;
  }
  _copyIntoNeighbors() {
    for (let e15 = 0; e15 < 8; e15++) {
      const r10 = 1 << e15;
      if (!!(this._currentRecordOverlaps & r10)) {
        if (this._copyBufferedDataIntoSelf) {
          const e16 = -f4(r10) * o, s17 = -u9(r10) * o;
          if (0 !== s17) continue;
          this._meshes.self.copyLast(e16, s17);
          continue;
        }
        if (!this._meshes.neighbors[e15]) {
          const t17 = Math.floor(this._sizeHint / 16);
          this._meshes.neighbors[e15] = new n4(r10, t17);
        }
        const i21 = this._meshes.neighbors[e15], n12 = -f4(r10) * o, h7 = -u9(r10) * o;
        i21.copyLastFrom(this._meshes.self, n12, h7);
      }
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/factories/MeshFactory.js
var s9 = class {
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Matcher.js
var t8 = class _t {
  constructor() {
    this._defaultResult = null, this._backgroundFillResult = null;
  }
  static async from(e15, s17) {
    const l11 = new _t();
    return l11.setDefault(await e15.createMeshWriters(s17.meshes)), l11;
  }
  size() {
    return 1;
  }
  getDefault() {
    return this._defaultResult;
  }
  setDefault(t17) {
    this._defaultResult = t17;
  }
  getBackgroundFill() {
    return this._backgroundFillResult;
  }
  setBackgroundFill(t17) {
    this._backgroundFillResult = t17;
  }
  hasArcadeDependency(t17) {
    return this._defaultResult?.some((e15) => e15.hasArcadeDependency(t17)) ?? false;
  }
  match(t17, e15, s17) {
    const l11 = this.doMatch(t17, e15) || this.getDefault();
    if (l11 && l11.length > 0) {
      const t18 = this.getBackgroundFill();
      if (t18) return [...t18, ...l11];
    }
    return l11;
  }
  getSortKey(t17, e15) {
    return 0;
  }
  doMatch(t17, e15) {
    return null;
  }
  async fetchResources(t17, e15) {
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/DictionaryMatcher.js
var e10 = class _e extends t8 {
  static async fromDictionaryRenderer(r10, o8) {
    const n12 = await s7.from(o8.dictionaryInfo, o8.userConfig, o8.fieldMap);
    return new _e(r10, n12);
  }
  constructor(t17, r10) {
    super(), this._context = t17, this._evaluator = r10, this._controlStringToPromise = /* @__PURE__ */ new Map(), this._controlStringToGroup = /* @__PURE__ */ new Map();
  }
  async fetchResources(t17, r10) {
    const e15 = r10.getCursor(), o8 = /* @__PURE__ */ new Set();
    for (; e15.next(); ) {
      const t18 = this._evaluateControlString(e15);
      t18 && o8.add(t18);
    }
    const n12 = Array.from(o8.values()).map((r11) => this._ensureGroup(t17, r11));
    await Promise.all(n12);
  }
  match(t17, r10) {
    const e15 = this._evaluateControlString(t17);
    return e15 ? this._controlStringToGroup.get(e15) : null;
  }
  _evaluateControlString(t17) {
    const r10 = t17.readLegacyFeatureWorldSpace();
    return this._evaluator.evaluate(r10, 0, t17.fields, null);
  }
  _ensureGroup(t17, r10) {
    let e15 = this._controlStringToPromise.get(r10);
    return null == e15 && (e15 = this._fetchGroup(t17, r10), this._controlStringToPromise.set(r10, e15)), e15;
  }
  async _fetchGroup(t17, r10) {
    const e15 = await t17.fetchDictionaryResourceImmediate({ type: "dictionary-request", controlString: r10 });
    if (!e15) return;
    const o8 = await this._context.createMeshWriters(e15.meshes);
    this._controlStringToGroup.set(r10, o8);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/IntervalMatcher.js
var t9 = class _t extends t8 {
  constructor(e15, t17) {
    super(), this._intervals = [], this._isMaxInclusive = t17, this._field = e15;
  }
  static async fromIntervalSchema(e15, s17) {
    const r10 = await e15.storage.createComputedField(s17), a9 = new _t(r10, s17.isMaxInclusive);
    await Promise.all(s17.intervals.map(async (t17) => {
      const s18 = await e15.createMeshWriters(t17.meshes);
      a9.add(t17, s18);
    }));
    const i21 = await e15.createMeshWriters(s17.defaultSymbol);
    a9.setDefault(i21);
    const n12 = await e15.createMeshWriters(s17.backgroundFill);
    return a9.setBackgroundFill(n12), a9;
  }
  add(e15, t17) {
    this._intervals.push({ interval: e15, result: t17 }), this._intervals.sort((e16, t18) => e16.interval.min - t18.interval.min);
  }
  size() {
    return super.size() + this._intervals.length;
  }
  hasArcadeDependency(e15) {
    return this._field?.hasArcadeDependency(e15) || this._intervals.some((t17) => t17.result.some((t18) => t18.hasArcadeDependency(e15)));
  }
  doMatch(e15, t17) {
    const s17 = this._field?.read(e15, t17);
    if (null == s17 || isNaN(s17) || s17 === 1 / 0 || s17 === -1 / 0) return null;
    for (let r10 = 0; r10 < this._intervals.length; r10++) {
      const { interval: e16, result: t18 } = this._intervals[r10], a9 = s17 >= e16.min, i21 = this._isMaxInclusive ? s17 <= e16.max : s17 < e16.max;
      if (a9 && i21) return t18;
    }
    return null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/LabelMatcher.js
var s10 = class _s extends t8 {
  static async fromLabelSchema(e15, a9) {
    const r10 = a9.classes.map(async (s17) => {
      const a10 = await e15.createMeshWriters(s17.meshes);
      return { minScale: s17.minScale, maxScale: s17.maxScale, meshes: a10, expression: null, where: await e15.storage.createWhereClause(s17.where) };
    }), t17 = await Promise.all(r10);
    return new _s(t17);
  }
  constructor(e15) {
    super(), this._labels = e15;
  }
  match(e15, s17, a9) {
    if (!this._labels.length) return null;
    const r10 = this._getLabels(s17.$view.scale), t17 = [];
    for (const l11 of r10) l11.where && !l11.where(e15, a9) || t17.push(...l11.meshes);
    return t17;
  }
  hasArcadeDependency(e15) {
    return this._labels.some((s17) => s17.meshes.some((s18) => s18.hasArcadeDependency(e15)));
  }
  _getLabels(e15) {
    return this._labels.filter((s17) => this._validForTileScale(s17, e15));
  }
  _validForTileScale(e15, s17) {
    const a9 = s17 - s17 / 4, r10 = s17 + s17 / 2;
    return (!e15.minScale || e15.minScale >= a9) && (!e15.maxScale || e15.maxScale <= r10);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/MapMatcher.js
var t10 = class _t extends t8 {
  constructor(e15, t17) {
    super(), this._defaultSymbolSortKey = 0, this._nullResult = null, this._resultsMap = /* @__PURE__ */ new Map(), this._fields = [], this._fields = e15, this._separator = t17 || "";
  }
  static async fromMatcherSchema(e15, s17) {
    const l11 = s17.expression ? [e15.storage.createComputedField({ expression: s17.expression })] : [s17.field ? e15.storage.createComputedField({ field: s17.field }) : null, s17.field2 ? e15.storage.createComputedField({ field: s17.field2 }) : null, s17.field3 ? e15.storage.createComputedField({ field: s17.field3 }) : null], r10 = (await Promise.all(l11)).filter((e16) => !!e16), i21 = new _t(r10, s17.fieldDelimiter), a9 = await e15.createMeshWriters(s17.defaultSymbol);
    i21.setDefault(a9);
    const u12 = await e15.createMeshWriters(s17.backgroundFill);
    return i21.setBackgroundFill(u12), await Promise.all(s17.map.map(async (t17, s18) => {
      const l12 = await e15.createMeshWriters(t17.symbol);
      "<Null>" === t17.value ? i21.setNullResult(l12) : i21.add(t17.value, l12, s18 + 1);
    })), i21;
  }
  setNullResult(e15) {
    this._nullResult = e15;
  }
  getSortKey(e15, t17) {
    const s17 = this._getValueFromFields(e15, t17);
    if (null == s17 || "" === s17 || "<Null>" === s17) return 0;
    const l11 = this._resultsMap.get(s17.toString());
    return l11 ? l11.sortKey : this._defaultSymbolSortKey;
  }
  add(e15, t17, s17) {
    this._resultsMap.set(e15.toString(), { meshWriters: t17, sortKey: s17 }), this._defaultSymbolSortKey = Math.max(this._defaultSymbolSortKey, s17 + 1);
  }
  size() {
    return super.size() + this._resultsMap.size;
  }
  hasArcadeDependency(e15) {
    return this._fields.some((t17) => t17.hasArcadeDependency(e15)) || [...this._resultsMap.values()].some((t17) => t17.meshWriters.some((t18) => t18.hasArcadeDependency(e15))) || this._nullResult?.some((t17) => t17.hasArcadeDependency(e15)) || false;
  }
  doMatch(e15, t17) {
    const s17 = this._getValueFromFields(e15, t17);
    if (null !== this._nullResult && (null == s17 || "" === s17 || "<Null>" === s17)) return this._nullResult;
    if (null == s17) return null;
    const l11 = s17.toString();
    return this._resultsMap.get(l11)?.meshWriters;
  }
  _getValueFromFields(e15, t17) {
    const s17 = [];
    for (const l11 of this._fields) {
      const r10 = l11.read(e15, t17);
      null == r10 || "" === r10 ? s17.push("<Null>") : s17.push(r10);
    }
    return s17.join(this._separator);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/createMatcher.js
async function n9(e15, n12) {
  switch (n12.type) {
    case "simple":
    case "heatmap":
    case "dot-density":
    case "pie-chart":
      return t8.from(e15, n12);
    case "interval":
      return t9.fromIntervalSchema(e15, n12);
    case "dictionary":
      return e10.fromDictionaryRenderer(e15, n12);
    case "label":
      return s10.fromLabelSchema(e15, n12);
    case "map":
      return t10.fromMatcherSchema(e15, n12);
    case "subtype":
      return h4.fromSubtypes(e15, n12);
    case "cluster":
      return i13.fromClusterSchema(e15, n12);
    case "track":
      return o3.fromTrackSchema(e15, n12);
    default:
      throw new Error("Impl");
  }
}
var h4 = class _h extends t8 {
  constructor(e15, t17) {
    super(), this._subMatchers = e15, this._subtypeField = t17;
  }
  static async fromSubtypes(e15, t17) {
    const r10 = /* @__PURE__ */ new Map(), a9 = [];
    for (const s17 in t17.renderers) {
      const c8 = parseInt(s17, 10), h7 = n9(e15, t17.renderers[s17]).then((e16) => r10.set(c8, e16));
      a9.push(h7);
    }
    return await Promise.all(a9), new _h(r10, t17.subtypeField);
  }
  match(e15, t17, r10) {
    const a9 = e15.readAttribute(this._subtypeField), s17 = this._subMatchers.get(a9);
    return s17 ? s17.match(e15, t17, r10) : null;
  }
  hasArcadeDependency(e15) {
    for (const t17 of this._subMatchers.values()) if (t17.hasArcadeDependency(e15)) return true;
    return false;
  }
};
var i13 = class _i extends t8 {
  static async fromClusterSchema(e15, t17) {
    const [r10, a9] = await Promise.all([n9(e15, t17.feature), n9(e15, t17.cluster)]);
    return new _i(r10, a9);
  }
  constructor(e15, t17) {
    super(), this._featureMatcher = e15, this._clusterMatcher = t17;
  }
  match(e15, t17, r10) {
    return 1 === e15.readAttribute("cluster_count") ? this._featureMatcher.match(e15, t17, r10) : this._clusterMatcher.match(e15, t17, r10);
  }
  hasArcadeDependency(e15) {
    return this._featureMatcher.hasArcadeDependency(e15) || this._clusterMatcher.hasArcadeDependency(e15);
  }
};
var o3 = class _o extends t8 {
  static async fromTrackSchema(e15, t17) {
    const [r10, a9, s17] = await Promise.all([n9(e15, t17.previousObservation), n9(e15, t17.latestObservation), n9(e15, t17.trackLine)]);
    return new _o(r10, a9, s17);
  }
  constructor(e15, t17, r10) {
    super(), this._previousObservationMatcher = e15, this._latestObservationMatcher = t17, this._trackLineMatcher = r10;
  }
  match(t17, r10, a9) {
    switch (t17.readAttribute(r2)) {
      case 0:
        return this._trackLineMatcher.match(t17, r10, a9);
      case 1:
        return this._latestObservationMatcher.match(t17, r10, a9);
      case 2:
        return this._previousObservationMatcher.match(t17, r10, a9);
    }
    return null;
  }
  hasArcadeDependency(e15) {
    return this._trackLineMatcher.hasArcadeDependency(e15) || this._latestObservationMatcher.hasArcadeDependency(e15) || this._previousObservationMatcher.hasArcadeDependency(e15);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/factories/FeatureMeshFactory.js
var s11 = class _s extends s9 {
  static async create(e15, o8) {
    const r10 = await n9(e15, o8.symbology), c8 = o8.labels ? await n9(e15, o8.labels) : null;
    return new _s(r10, c8);
  }
  constructor(e15, t17) {
    super(), this._symbology = e15, this._labels = t17;
  }
  destroy() {
  }
  async enqueueMatcherRequests(e15, t17) {
    await Promise.all([this._symbology.fetchResources(e15, t17), this._labels?.fetchResources(e15, t17)]);
  }
  enqueueWriterRequests(e15, t17, s17, o8) {
    const r10 = this._symbology.match(t17, s17, o8);
    if (r10) {
      for (const o9 of r10) o9.enqueueRequest(e15, t17, s17);
      if (this._labels) {
        const r11 = this._labels.match(t17, s17, o8);
        if (!r11) return;
        for (const o9 of r11) o9.enqueueRequest(e15, t17, s17);
      }
    }
  }
  write(e15, t17, s17, o8, r10, c8) {
    const a9 = this._symbology.match(s17, o8, r10);
    if (!a9) return;
    for (const n12 of a9) n12.write(e15, t17, s17, o8, c8);
    if (e15.entityRecordCount() >= 1 && this._labels) {
      const n12 = this._labels.match(s17, o8, r10);
      if (!n12) return;
      for (const r11 of n12) r11.setReferences(a9), r11.write(e15, t17, s17, o8, c8);
    }
  }
  getSortKey(e15, t17) {
    return this._symbology.getSortKey(e15, t17);
  }
  hasArcadeDependency(e15) {
    return !(!this._symbology.hasArcadeDependency(e15) && !this._labels?.hasArcadeDependency(e15));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/MatcherContext.js
var s12 = class {
  constructor(s17, t17, r10, e15, i21) {
    this.storage = s17, this.proxy = t17, this.viewParams = r10, this.registry = e15, this.fieldsMap = i21;
  }
  async createMeshWriters(s17) {
    const t17 = s17.map((s18) => this.registry.createMeshWriter(this.storage, this.proxy, this.viewParams, s18, this.fieldsMap));
    return Promise.all(t17);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/ProcessorTileMessageQueue.js
var e11 = class {
  constructor(e15) {
    this._outstandingMessages = [], this._queue = new _({ concurrency: e15.concurrency, process: (s17) => e15.process(s17) });
  }
  async push(s17) {
    if (s17.end) return await Promise.all(this._outstandingMessages), await this._queue.push(s17), void (this._outstandingMessages = []);
    const e15 = this._queue.push(s17);
    return this._outstandingMessages.push(e15), e15;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/ComputedAggregateField.js
var s13 = class _s {
  static async create(i21, e15) {
    if ("count" === e15.statisticType) {
      const i22 = new r3(1);
      return new _s(e15.name, e15.alias, e15.type, e15.statisticType, i22);
    }
    const a9 = await i21.createComputedField({ expression: e15.onStatisticExpression?.expression, field: e15.onStatisticField });
    return new _s(e15.name, e15.alias, e15.type, e15.statisticType, a9);
  }
  constructor(t17, s17, i21, e15, a9) {
    this.name = t17, this.alias = s17, this.type = i21, this.statisticType = e15, this.computed = a9;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/AProcessorStrategy.js
var t11 = class {
  constructor(t17) {
    this.subscription = t17, this.handledChunks = /* @__PURE__ */ new Set();
  }
  destroy() {
  }
};
var e12 = class {
  constructor(t17, e15, s17) {
    this._source = t17, this._attributeStore = e15, this._sqlOptions = s17, this._sendStates = /* @__PURE__ */ new Map();
  }
  destroy() {
  }
  get enablePixelBuffering() {
    return true;
  }
  get isAggregate() {
    return false;
  }
  get usedMemory() {
    return 0;
  }
  onSubscribe(t17) {
    const e15 = this.createState(t17);
    this._sendStates.set(t17.key.id, e15), this.updateChunks();
  }
  onUnsubscribe(t17) {
    this._sendStates.get(t17.key.id)?.destroy(), this._sendStates.delete(t17.key.id);
  }
  get hasSubscribers() {
    return this._sendStates.size > 0;
  }
  requiresInvalidation() {
    return false;
  }
  invalidate() {
    const t17 = Array.from(this._sendStates.values());
    this._sendStates.clear();
    for (const e15 of t17) e15.destroy(), this.onSubscribe(e15.subscription);
  }
  invalidateAttributeData(t17) {
  }
  hasArcadeDependency(t17) {
    return false;
  }
  getFeatureObjectIdsForAggregate(t17) {
    throw new Error("InternalError: AggregateId lookup not supported");
  }
  getDisplayIds(t17) {
    return this.displayMap(t17, (t18) => t18, (t18) => t18);
  }
  getDisplayAndObjectIds(t17) {
    return this.displayMap(t17, (t18) => t18, (t18, e15, s17) => [t18, s17]);
  }
  afterUpdateChunks() {
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/AAggregateStrategy.js
var i14 = class extends e12 {
  constructor(r10, t17, s17, n12, i21) {
    super(r10, t17, i21), this.spatialReference = s17, this.aggregateFields = n12, this._arcadeDependencies = /* @__PURE__ */ new Set(), this.events = new i4(), this.featureAdapter = e6;
    for (const e15 of n12) u6(this._arcadeDependencies, e15.computed);
  }
  get aggregateQueryEngine() {
    return this._aggregateQueryEngine || (this._aggregateQueryEngine = new W({ featureStore: this, fieldsIndex: this._metadata.fieldsIndex, geometryType: this._metadata.geometryType, featureIdInfo: this._metadata.featureIdInfo, spatialReference: this.spatialReference })), this._aggregateQueryEngine;
  }
  get isAggregate() {
    return true;
  }
  removeChunks(e15) {
  }
  hasArcadeDependency(e15) {
    return this._arcadeDependencies.has(e15);
  }
  forEach(e15) {
    return this.forEachAggregateWorldSpace(e15);
  }
  forEachInBounds(e15, r10) {
  }
  forEachBounds(e15, a9) {
    const s17 = u4();
    for (const r10 of e15) {
      const e16 = Mt(s17, r10.geometry, false, false);
      e16 && a9(e16);
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureSourceMessage.js
var e13 = class {
  constructor(e15, i21, t17, s17, r10) {
    this.subscription = e15, this.reader = i21, this.clear = t17, this.end = s17, this.debugInfo = r10, this.type = "append";
  }
  get id() {
    return this.subscription.tile.id;
  }
  createMessage(e15, i21, t17) {
    return { type: "append", clear: this.clear, id: this.id, append: e15, end: this.end, debugInfo: this.debugInfo, subscriptionVesrion: this.subscription.version, version: i21, attributeEpoch: t17 };
  }
};
var i15 = class {
  constructor(e15, i21, t17, s17, r10) {
    this.subscription = e15, this.reader = i21, this.remove = t17, this.end = s17, this.debugInfo = r10, this.type = "update";
  }
  get id() {
    return this.subscription.tile.id;
  }
  createMessage(e15, i21, t17) {
    return { type: "update", id: this.id, modify: e15, debugInfo: this.debugInfo, remove: this.remove, version: i21, subscriptionVesrion: this.subscription.version, end: this.end, attributeEpoch: t17 };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/BinningStrategy.js
var g3 = class extends t11 {
  constructor(e15, t17) {
    super(e15), this.bins = /* @__PURE__ */ new Map(), this.featureCache = /* @__PURE__ */ new Map(), this.done = false, this._store = t17;
  }
  reset() {
    this.destroy(), this.done = false;
  }
  destroy() {
    const e15 = this.subscription.tile.key.level;
    for (const t17 of this.featureCache.keys()) this._store.releaseDisplayIdForObjectId(`${t17}.${e15}`);
    this.bins.clear(), this.featureCache.clear(), this.handledChunks.clear();
  }
  get tile() {
    return this.subscription.tile;
  }
  *featuresWorldSpace() {
    for (const e15 of this.featureCache.values()) {
      const t17 = e15.clone();
      t17.geometry && wt(t17.geometry, t17.geometry, false, false, this.subscription.tile.transform), yield t17;
    }
  }
};
var y4 = class _y extends i14 {
  static async create(t17, s17, a9, i21, n12) {
    const l11 = s17.metadata.outSpatialReference, d10 = new l3({ spatialReference: l11 }), c8 = await Promise.all(t17.fields.map(async (e15) => s13.create(d10, e15))), p4 = t17.featureFilter ? await p.create({ geometryType: s17.metadata.geometryType, hasM: false, hasZ: false, timeInfo: s17.metadata.timeInfo, fieldsIndex: s17.metadata.fieldsIndex, spatialReference: l11, filterJSON: t17.featureFilter }) : null;
    return "geohash" === t17.index.type && await f3(l11, f.WGS84), new _y(t17, p4, i21, c8, l11, s17, a9, n12);
  }
  constructor(e15, t17, s17, a9, r10, o8, n12, l11) {
    super(o8, n12, r10, a9, l11), this._schema = e15, this._featureFilter = t17, this._arcadeContextInfo = s17, this._metadata = i8.createFeature({ geometryType: "esriGeometryPolygon", featureIdInfo: { type: "object-id", fieldName: "aggregateId" }, fieldsIndex: new Z(e15.fields).toJSON(), globalIdField: null, spatialReference: o8.metadata.spatialReference, outSpatialReference: o8.metadata.outSpatialReference, subtypeField: null, subtypes: null, timeInfo: null, timeReferenceUnknownClient: null, dateFieldsTimeZone: null, typeIdField: null, types: null });
  }
  createState(e15) {
    return new g3(e15, this._attributeStore);
  }
  async *applyOverrideUpdate(e15) {
    for (const t17 of this._sendStates.values()) {
      t17.reset();
      const e16 = new e13(t17.subscription, u7.empty(this._source.metadata), true, false, {});
      yield e16;
    }
  }
  displayMap(e15, t17, s17) {
    const a9 = new Map(e15.map((e16) => [t17(e16), e16])), r10 = [];
    for (const i21 of this._sendStates.values()) for (const e16 of i21.featuresWorldSpace()) {
      const { objectId: t18, displayId: i22 } = e16, o8 = a9.get(t18);
      if (null != o8) {
        const e17 = s17(i22, o8, t18);
        r10.push(e17), a9.delete(t18);
      }
    }
    return r10;
  }
  getDisplayFeatures(e15) {
    const s17 = new Set(e15), a9 = /* @__PURE__ */ new Set(), r10 = [];
    for (const i21 of this._sendStates.values()) for (const e16 of i21.featuresWorldSpace()) s17.has(e16.displayId) && !a9.has(e16.objectId) && (e16.geometry && r10.push({ ...st(e16, this._metadata.geometryType, false, false), displayId: e16.displayId }), a9.add(e16.objectId));
    return { features: [], aggregates: r10, tracks: [] };
  }
  getFeatureObjectIdsForAggregate(e15) {
    for (const t17 of this._sendStates.values()) for (const s17 of t17.bins.values()) if (s17.id === e15) return Array.from(s17.containedObjectIds);
    return [];
  }
  async *updateChunks() {
    for (const e15 of this._sendStates.values()) yield* this._update(e15, this._source);
  }
  forEachAggregateWorldSpace(e15) {
    const t17 = /* @__PURE__ */ new Set();
    for (const s17 of this._sendStates.values()) for (const a9 of s17.featuresWorldSpace()) t17.has(a9.objectId) || (e15(a9), t17.add(a9.objectId));
  }
  _createIndexOptions(e15) {
    switch (this._schema.index.type) {
      case "geohash":
        return { type: "geohash", fields: this.aggregateFields, featureFilter: this._featureFilter, geohashLevel: this._schema.index.fixBinLevel, spatialReference: this.spatialReference, arcadeContextInfo: this._arcadeContextInfo, scale: e15.scale, sqlOptions: this._sqlOptions };
      case "grid": {
        const t17 = this._schema.index.fixedBinLevel, s17 = null != t17 ? e15.tileInfoView.getLODInfoAt(t17).scale : e15.scale;
        return { type: "grid", fields: this.aggregateFields, cellSize: this._schema.index.size, featureFilter: this._featureFilter, spatialReference: this.spatialReference, arcadeContextInfo: this._arcadeContextInfo, scale: s17, sqlOptions: this._sqlOptions };
      }
    }
  }
  async *_update(e15, t17) {
    const { handledChunks: s17, subscription: r10, bins: i21, featureCache: o8 } = e15, n12 = r10.tile;
    if (e15.done) return;
    for (const a9 of t17.chunks()) {
      if (s17.has(a9.chunkId)) continue;
      s17.add(a9.chunkId);
      const t18 = a9.queryInfo;
      if ("tileId" in t18) {
        const e16 = new e7(t18.tileId);
        if (e16.level !== n12.level || e16.world !== n12.key.world) continue;
      }
      a9.getAggregateIndex(this._createIndexOptions(e15.tile)).putBounded(i21, e15.tile.extent, e15.tile.resolution);
    }
    const l11 = [], d10 = r10.tile.transform, u12 = r10.tile.key.level;
    for (const c8 of i21.values()) {
      let e16 = o8.get(c8.id);
      if (e16) e16.attributes = c8.getAttributes();
      else {
        const t18 = c8.getGeometry(this.spatialReference, d10);
        e16 = new s4(t18, c8.getAttributes(), null, c8.id), t18 || (e16.centroid = c8.getGeometricCentroid(this.spatialReference, d10)), e16.displayId = this._attributeStore.createDisplayIdForObjectId(`${e16.objectId}.${u12}`), o8.set(c8.id, e16);
      }
      l11.push(e16);
    }
    this.events.emit("changed"), e15.done = !t17.updateTracking.updating;
    const f7 = u7.fromOptimizedFeatures(l11, this._metadata, d10), p4 = f7.getCursor(), g5 = e15.subscription.tile.createArcadeEvaluationOptions(this._arcadeContextInfo);
    for (; p4.next(); ) this._attributeStore.setAttributeData(p4.getDisplayId(), p4, g5, this._sqlOptions);
    const y9 = new i15(e15.subscription, f7, [], e15.done, {});
    yield y9;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/support/WithDisplayId.js
var s14 = class {
  constructor(s17, t17) {
    this.inner = s17, this.displayId = t17;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/ClusterStrategy.js
var m5 = 128;
var y5 = class extends t11 {
  constructor(e15) {
    super(e15), this.didSend = false, this.done = false;
  }
};
var S = class {
  constructor(e15, t17, s17, i21, r10) {
    this._level = e15, this._scale = t17, this._indexOptions = s17, this._clusterRadius = i21, this._store = r10, this._cells = /* @__PURE__ */ new Map(), this._handledChunks = /* @__PURE__ */ new Set(), this._statistics = /* @__PURE__ */ new Map(), this._clusters = /* @__PURE__ */ new Map();
  }
  destroy() {
    this._clearClusters();
  }
  _clearClusters() {
    for (const e15 of this._clusters.values()) this._store.releaseDisplayIdForObjectId(e15.inner.id);
    this._clusters.clear();
  }
  *aggregatesWorldSpace() {
    for (const e15 of this._clusters.values()) {
      const s17 = e15.inner.getCentroid(null), i21 = new s4(s17, e15.inner.getAttributes(), null, e15.inner.id, e15.displayId);
      yield i21;
    }
  }
  clusters() {
    return this._clusters.values();
  }
  updateChunks(e15, t17) {
    let s17 = false;
    for (const a9 of e15) {
      const e16 = a9.queryInfo;
      if ("tileId" in e16) {
        if (new e7(e16.tileId).level !== this._level) continue;
      }
      if (!this._handledChunks.has(a9.normalizedChunkId)) {
        this._handledChunks.add(a9.normalizedChunkId), s17 = true;
        a9.getAggregateIndex({ ...this._indexOptions, scale: this._scale }).put(this._cells);
      }
    }
    const i21 = { xMin: 1 / 0, yMin: 1 / 0, xMax: -1 / 0, yMax: -1 / 0 }, r10 = r4(this._indexOptions.spatialReference, this._scale), n12 = this._indexOptions.cellSize;
    for (const { subscription: a9 } of t17) {
      const e16 = a9.tile.bounds, t18 = Math.floor(e16[0] * r10 / n12), s18 = Math.floor(e16[1] * r10 / n12), l11 = Math.ceil(e16[2] * r10 / n12), o8 = Math.ceil(e16[3] * r10 / n12);
      i21.xMin = Math.min(i21.xMin, t18), i21.yMin = Math.min(i21.yMin, s18), i21.xMax = Math.max(i21.xMax, l11), i21.yMax = Math.max(i21.yMax, o8);
    }
    return null != this._lastCellBounds && i21.xMin === this._lastCellBounds.xMin && i21.yMin === this._lastCellBounds.yMin && i21.yMin === this._lastCellBounds.yMin && i21.yMax === this._lastCellBounds.yMax || (s17 = true, this._lastCellBounds = i21), s17 && this._clusterCells(i21), s17;
  }
  async updateStatistics(e15) {
    let t17 = false;
    for (const s17 of this._clusters.values()) s17.inner.count > 1 && (t17 = this._updateAggregateStatistics(this._statistics, s17.inner) || t17);
    if (t17) {
      const t18 = Array.from(this._statistics.entries()).map(([e16, t19]) => ({ fieldName: e16, minValue: t19.minValue, maxValue: t19.maxValue }));
      await e15.container.updateStatistics(this._level, t18);
    }
  }
  createAggregateFeatures(e15, i21) {
    const n12 = e15.subscription, a9 = [], l11 = n12.tile.transform;
    for (const o8 of this._clusters.values()) {
      let e16 = o8.inner.getCentroidX(l11);
      const i22 = o8.inner.getCentroidY(l11), d10 = n12.tile.lod, u12 = d10.wrap ? d10.worldSize[0] : null, c8 = 1 === o8.inner.count ? o8.inner.firstObjectId : o8.inner.id, h7 = o8.displayId;
      if (null != u12) if (1 === u12) {
        const n13 = new e3([], [e16, i22]), l12 = new s4(n13, o8.inner.getAttributes(), null, c8, h7);
        l12.geometry.coords[0] -= o, a9.push(l12);
        const d11 = new e3([], [e16, i22]), u13 = new s4(d11, o8.inner.getAttributes(), null, c8, h7);
        u13.geometry.coords[0] += o, a9.push(u13);
      } else e16 > o + o / 2 ? e16 -= u12 * o : e16 < -256 && (e16 += u12 * o);
      if (e16 < o + m5 && e16 >= -m5 && i22 < o + m5 && i22 >= -m5) {
        const r10 = new e3([], [e16, i22]), n13 = new s4(r10, o8.inner.getAttributes(), null, c8, h7);
        a9.push(n13);
      }
    }
    return u7.fromOptimizedFeatures(a9, i21, n12.tile.transform);
  }
  _clusterCells(e15) {
    let t17 = Array.from(this._cells.values());
    t17 = t17.sort((e16, t18) => t18.count - e16.count);
    const s17 = [];
    for (const a9 of this._clusters.values()) s17.push(a9.inner.id);
    this._clusters.clear();
    const i21 = this._clusterRadius * (1 / r4(this._indexOptions.spatialReference, this._scale)), r10 = 1 + this._clusterRadius / this._indexOptions.cellSize, n12 = /* @__PURE__ */ new Set();
    for (const l11 of t17) {
      if (n12.has(l11.id)) continue;
      if (l11.gridX < e15.xMin || l11.gridX > e15.xMax || l11.gridY < e15.yMin || l11.gridY > e15.yMax) continue;
      const t18 = this._store.createDisplayIdForObjectId(l11.id), s18 = new s14(l11.clone(), t18);
      n12.add(l11.id), this._clusters.set(l11.id, s18);
      const o8 = l11.centroidXWorld, d10 = l11.centroidYWorld;
      for (let e16 = l11.gridY - r10; e16 <= l11.gridY + r10; e16++) for (let t19 = l11.gridX - r10; t19 <= l11.gridX + r10; t19++) {
        if (e16 === l11.gridY && t19 === l11.gridX) continue;
        const r11 = this._cells.get(l4.createId(t19, e16));
        if (!r11 || n12.has(r11.id)) continue;
        const u12 = Math.abs(r11.centroidXWorld - o8), c8 = Math.abs(r11.centroidYWorld - d10);
        u12 < i21 && c8 < i21 && (s18.inner.merge(r11), n12.add(r11.id));
      }
    }
    for (const a9 of s17) this._store.releaseDisplayIdForObjectId(a9);
  }
  _updateAggregateStatistics(e15, t17) {
    let s17 = false;
    for (const i21 of t17.statistics.values()) {
      if ("esriFieldTypeString" === i21.field.type) continue;
      const t18 = i21.value, r10 = i21.field, n12 = e15.get(r10.name);
      if (n12) {
        const { minValue: e16, maxValue: i22 } = n12, r11 = Math.min(n12.minValue, t18), a9 = Math.max(n12.maxValue, t18);
        e16 === r11 && i22 === a9 || (n12.minValue = r11, n12.maxValue = a9, s17 = true);
        continue;
      }
      e15.set(r10.name, { minValue: t18, maxValue: t18 }), s17 = true;
    }
    return s17;
  }
};
var x2 = class _x extends i14 {
  static async create(e15, t17, s17, i21, r10, a9) {
    const l11 = s17.metadata.outSpatialReference, o8 = new l3({ spatialReference: l11 }), d10 = { type: "grid", fields: await Promise.all(t17.fields.map(async (e16) => s13.create(o8, e16))), spatialReference: l11, featureFilter: t17.featureFilter ? await p.create({ geometryType: s17.metadata.geometryType, hasM: false, hasZ: false, timeInfo: s17.metadata.timeInfo, fieldsIndex: s17.metadata.fieldsIndex, spatialReference: l11, filterJSON: t17.featureFilter }) : null, cellSize: t17.clusterRadius / 4, arcadeContextInfo: r10, sqlOptions: a9 };
    return new _x(e15, t17.clusterRadius, d10, t17.fields, s17, i21, a9);
  }
  constructor(e15, t17, s17, r10, n12, a9, l11) {
    super(n12, a9, s17.spatialReference, s17.fields, l11), this._connection = e15, this._clusterRadius = t17, this._indexOptions = s17, this._cellsPerScale = /* @__PURE__ */ new Map(), this._metadata = i8.createFeature({ geometryType: "esriGeometryPoint", featureIdInfo: { type: "object-id", fieldName: "aggregateId" }, fieldsIndex: new Z([...r10, ...this._source.metadata.fieldsIndex.fields, { name: "aggregateId", alias: "aggregateId", type: "esriFieldTypeOID" }]).toJSON(), globalIdField: null, spatialReference: n12.metadata.spatialReference, outSpatialReference: n12.metadata.outSpatialReference, subtypeField: null, subtypes: null, timeInfo: null, timeReferenceUnknownClient: null, dateFieldsTimeZone: null, typeIdField: null, types: null });
  }
  get enablePixelBuffering() {
    return false;
  }
  invalidate() {
    super.invalidate();
    for (const e15 of this._cellsPerScale.values()) e15.destroy();
    this._cellsPerScale.clear();
  }
  onSubscribe(e15) {
    super.onSubscribe(e15), this._requiredLevel = e15.tile.level, this._requiredScale = e15.tile.scale;
  }
  createState(e15) {
    return new y5(e15);
  }
  async *applyOverrideUpdate(e15) {
    for (const t17 of this._cellsPerScale.values()) t17.destroy();
    this._cellsPerScale.clear();
    for (const t17 of this._sendStates.values()) t17.done = false;
  }
  displayMap(e15, t17, s17) {
    const i21 = new Map(e15.map((e16) => [t17(e16), e16])), r10 = [], n12 = this._getClusterState(this._requiredLevel, this._requiredScale);
    for (const a9 of n12.clusters()) {
      const e16 = i21.get(a9.inner.id);
      if (null != e16) {
        const t18 = s17(a9.displayId, e16, a9.inner.id);
        r10.push(t18), i21.delete(a9.inner.id);
        continue;
      }
      if (1 === a9.inner.count) {
        const { firstObjectId: e17 } = a9.inner, t18 = e17 ? i21.get(e17) : null;
        if (null != t18) {
          const n13 = s17(a9.displayId, t18, e17);
          r10.push(n13), i21.delete(e17);
        }
      }
    }
    return r10;
  }
  getDisplayFeatures(t17) {
    const s17 = new Set(t17), i21 = /* @__PURE__ */ new Set(), r10 = [], n12 = [], a9 = this._getClusterState(this._requiredLevel, this._requiredScale);
    for (const l11 of a9.aggregatesWorldSpace()) if (s17.has(l11.displayId) && !i21.has(l11.displayId)) {
      const t18 = st(l11, this._metadata.geometryType, false, false);
      if (i21.add(l11.displayId), 1 === t18.attributes.cluster_count) {
        r10.push({ ...t18, displayId: l11.displayId });
        continue;
      }
      n12.push({ ...t18, displayId: l11.displayId });
    }
    return { features: r10, aggregates: n12, tracks: [] };
  }
  getFeatureObjectIdsForAggregate(e15) {
    const t17 = this._getClusterState(this._requiredLevel, this._requiredScale);
    for (const s17 of t17.clusters()) if (s17.inner.id === e15) return Array.from(s17.inner.containedObjectIds);
    return [];
  }
  async *updateChunks() {
    const e15 = this._source.chunks();
    if (!e15.length) return;
    const t17 = this._getClusterState(this._requiredLevel, this._requiredScale), s17 = Array.from(this._sendStates.values()).filter((e16) => e16.subscription.tile.level === this._requiredLevel);
    if (t17.updateChunks(e15, s17) || !this._source.updateTracking.updating) for (const n12 of s17) n12.subscription.tile.level === this._requiredLevel && (n12.didSend = false, n12.done = false);
    const i21 = Array.from(this._sendStates.values()).filter((e16) => e16.done).map((e16) => e16.subscription.tile.key), r10 = new Set(i21);
    for (const n12 of this._sendStates.values()) {
      if (this._source.updateTracking.updating) {
        if (i21.some((e16) => e16.containsChild(n12.subscription.tile.key))) continue;
        if (n12.subscription.tile.key.getChildKeys().every((e16) => r10.has(e16))) continue;
      }
      n12.didSend || n12.subscription.tile.level !== this._requiredLevel || (n12.didSend = true, yield* this._update(n12, t17, this._source));
    }
    await t17.updateStatistics(this._connection);
  }
  forEachAggregateWorldSpace(e15) {
    if (null == this._requiredLevel || null == this._requiredScale) return;
    const t17 = this._getClusterState(this._requiredLevel, this._requiredScale);
    for (const s17 of t17.aggregatesWorldSpace()) e15(s17);
  }
  _getClusterState(e15, t17) {
    if (null == e15 || null == t17) throw new Error("InternalError: Level and scale must be defined");
    let s17 = this._cellsPerScale.get(t17);
    return s17 || (s17 = new S(e15, t17, this._indexOptions, this._clusterRadius, this._attributeStore), this._cellsPerScale.set(t17, s17)), s17;
  }
  async *_update(e15, t17, s17) {
    if (e15.done) return;
    const i21 = t17.createAggregateFeatures(e15, this._metadata);
    this.events.emit("changed"), e15.done = !s17.updateTracking.updating;
    const r10 = i21.getCursor(), n12 = e15.subscription.tile.createArcadeEvaluationOptions(this._indexOptions.arcadeContextInfo);
    for (; r10.next(); ) this._attributeStore.setAttributeData(r10.getDisplayId(), r10, n12, this._sqlOptions);
    const a9 = new e13(e15.subscription, i21, true, e15.done, {});
    yield a9;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/FeatureUpdateStrategy.js
var d6 = class extends t11 {
};
var i16 = class extends e12 {
  constructor(e15, t17, s17, r10) {
    super(e15, t17, r10), this._arcadeContextInfo = s17, this.handledChunks = /* @__PURE__ */ new Set(), this.handledChunksForIdCreation = /* @__PURE__ */ new Set(), this.handledChunksForAttributeData = /* @__PURE__ */ new Set(), this._streamLayerDeferredObjectIdsToRemove = [];
  }
  destroy() {
    super.destroy();
    for (const e15 of this._source.chunks()) this._cleanupChunkIds(e15);
  }
  invalidateAttributeData(e15) {
    this.handledChunksForAttributeData.clear(), this._arcadeContextInfo = e15, null != this._evalOptions && (this._evalOptions = e8(this._evalOptions.$view.scale, e15));
  }
  onSubscribe(e15) {
    super.onSubscribe(e15), this._evalOptions = e15.tile.createArcadeEvaluationOptions(this._arcadeContextInfo);
  }
  createState(e15) {
    return new d6(e15);
  }
  get aggregateQueryEngine() {
    return null;
  }
  displayMap(e15, t17, s17) {
    const r10 = new Map(e15.map((e16) => [t17(e16), e16])), a9 = [];
    for (const o8 of this._source.chunks()) {
      const e16 = o8.reader.getCursor();
      for (; e16.next(); ) {
        const t18 = e16.getObjectId(), o9 = e16.getDisplayId(), n12 = r10.get(t18);
        if (null != n12) {
          const e17 = s17(o9, n12, t18);
          a9.push(e17), r10.delete(t18);
        }
      }
    }
    return a9;
  }
  getDisplayFeatures(e15) {
    const t17 = new Set(e15), s17 = /* @__PURE__ */ new Set(), r10 = [];
    for (const a9 of this._source.chunks()) {
      const e16 = a9.reader.getCursor();
      for (; e16.next(); ) {
        const a10 = e16.getObjectId(), o8 = e16.getDisplayId();
        t17.has(o8) && !s17.has(a10) && (r10.push({ ...e16.readLegacyFeatureWorldSpace(), displayId: o8 }), s17.add(a10));
      }
    }
    return { features: r10, aggregates: [], tracks: [] };
  }
  async *applyOverrideUpdate(e15) {
    const t17 = [];
    for (const s17 of e15.modified.values()) {
      const e16 = this._attributeStore.createDisplayIdForObjectId(s17.objectId);
      s17.displayId = e16, t17.push(e16);
    }
    const r10 = u7.fromOptimizedFeatures(Array.from(e15.modified.values()), this._source.metadata).getCursor();
    for (; r10.next(); ) this._attributeStore.setAttributeData(r10.getDisplayId(), r10, this._evalOptions, this._sqlOptions);
    const o8 = [];
    for (const s17 of e15.removed) {
      const e16 = this._attributeStore.getDisplayIdForObjectId(s17);
      null != e16 && o8.push(e16);
    }
    has("esri-2d-update-debug") && console.debug("FeatureUpdateStrategy.applyLocalEdit", { message: e15, modifiedDisplayIds: t17, removedDisplayIds: o8 });
    const d10 = n5.fromFeatures(Array.from(e15.modified.values()), this._source.metadata);
    this.handledChunks.add(d10.chunkId), this.handledChunksForAttributeData.add(d10.chunkId), this.handledChunksForIdCreation.add(d10.chunkId);
    for (const a9 of this._sendStates.values()) a9.handledChunks.add(d10.chunkId), yield new i15(a9.subscription, null, t17, false, d10.queryInfo);
    for (const a9 of this._sendStates.values()) {
      const e16 = d10.getTileReader(a9.subscription.tile);
      yield new i15(a9.subscription, e16, o8, false, d10.queryInfo);
    }
    for (const s17 of e15.removed) this._attributeStore.releaseDisplayIdForObjectId(s17);
  }
  async *updateChunks() {
    if (this._source.chunks().length) {
      this._updateAttributeData();
      for (const e15 of this._sendStates.values()) yield* this._update(e15);
    }
  }
  removeChunks(e15) {
    for (const t17 of e15) this.handledChunks.delete(t17.chunkId), this.handledChunksForAttributeData.delete(t17.chunkId), this._cleanupChunkIds(t17);
  }
  afterUpdateChunks() {
    for (const e15 of this._streamLayerDeferredObjectIdsToRemove) this._attributeStore.releaseDisplayIdForObjectId(e15);
    this._streamLayerDeferredObjectIdsToRemove = [];
  }
  _cleanupChunkIds(e15) {
    if (this.handledChunksForIdCreation.has(e15.chunkId)) {
      const t17 = e15.reader.getCursor();
      for (; t17.next(); ) {
        const e16 = t17.getObjectId();
        this._source.isStream ? this._streamLayerDeferredObjectIdsToRemove.push(e16) : this._attributeStore.releaseDisplayIdForObjectId(e16);
      }
      this.handledChunksForIdCreation.delete(e15.chunkId);
    }
  }
  _updateAttributeData() {
    for (const e15 of this._source.chunks()) {
      const { chunkId: t17, reader: s17 } = e15;
      if (!this.handledChunksForIdCreation.has(t17)) {
        this.handledChunksForIdCreation.add(t17);
        const e16 = s17.getCursor();
        for (; e16.next(); ) {
          const t18 = this._attributeStore.createDisplayIdForObjectId(e16.getObjectId());
          e16.setDisplayId(t18);
        }
      }
    }
    for (const e15 of this._source.chunks()) if (this._attributeStore.referencesScale() || !this.handledChunksForAttributeData.has(e15.chunkId)) {
      this.handledChunksForAttributeData.add(e15.chunkId);
      const t17 = e15.reader.getCursor();
      for (; t17.next(); ) {
        const e16 = t17.getDisplayId();
        this._attributeStore.setAttributeData(e16, t17, this._evalOptions, this._sqlOptions);
      }
    }
  }
  *_update(e15) {
    const { subscription: t17, handledChunks: s17 } = e15;
    for (const a9 of this._source.chunks()) {
      const { chunkId: o8 } = a9;
      if (s17.has(o8) || !this.handledChunksForIdCreation.has(o8) || !this.handledChunksForAttributeData.has(o8)) continue;
      s17.add(o8);
      const n12 = a9.getTileReader(t17.tile);
      n12 && (yield new e13(e15.subscription, n12, false, a9.end, a9.queryInfo));
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/TrackStrategy.js
var C;
var G = () => i2.getLogger("esri.views.2d.layers.features.processor.TrackStrategy");
var P2 = 32;
var W2 = class {
  constructor(t17, e15, s17, r10, i21) {
    this.chunkIndex = t17, this.featureIndex = e15, this.objectId = s17, this.displayId = r10, this.time = i21;
  }
};
var z2 = class {
  static getOid(t17) {
    return t4 + t17;
  }
  constructor(t17, e15, s17, r10, i21, a9, o8, n12) {
    this._schema = t17, this.trackId = e15, this.objectId = s17, this.displayId = r10, this._fields = i21, this._spatialReference = a9, this._metadata = o8, this._isStream = n12, this._maxDisplayDuration = this._schema.maxDisplayDuration > 0 ? this._schema.maxDisplayDuration : 1 / 0, this._maxDisplayObservationsPerTrack = this._schema.maxDisplayObservationsPerTrack >= 1 ? this._schema.maxDisplayObservationsPerTrack : 1 / 0, this._observationRecords = [], this._nextObservationRecords = [], this._trackLinePath = [], this._bounds = [], this._trackLineGeometry = new e3();
  }
  get _trackLineAttributes() {
    const t17 = { ...this._latestObservationFeature?.attributes, aggregateId: this.objectId, [r2]: 0 };
    if (null != this._statistics) for (const e15 of this._statistics.values()) t17[e15.field.name] = e15.value;
    return t17;
  }
  get _startTimeField() {
    return this._metadata.timeInfo?.startTimeField;
  }
  get length() {
    return this._observationRecords.length;
  }
  *observations() {
    yield* this._observationRecords;
  }
  *previousObservations() {
    for (let t17 = 0; t17 < this._observationRecords.length - 1; t17++) yield this._observationRecords[t17];
  }
  get latestObservationFeature() {
    return this._latestObservationFeature;
  }
  get latestObservationRecord() {
    return this._latestObservationRecord;
  }
  stageObservation(t17, e15) {
    this._nextObservationRecords.push(new W2(t17, e15.getIndex(), e15.getObjectId(), e15.getDisplayId(), null != this._startTimeField ? e15.readAttributeAsTimestamp(this._startTimeField) : null));
  }
  commitObservations(t17, e15, r10) {
    const i21 = new Set(this._nextObservationRecords.map((t18) => t18.objectId)), a9 = this._observationRecords.filter((t18) => !i21.has(t18.objectId)).map((t18) => t18.objectId);
    let o8, n12;
    switch (this._observationRecords = [], this._trackLinePath = [], this._isStream || null == this._startTimeField || this._nextObservationRecords.sort((t18, e16) => {
      const s17 = t18.time, r11 = e16.time;
      return null != s17 && null != r11 ? s17 - r11 : 0;
    }), this._schema.timeField) {
      case "startTimeField":
        o8 = this._metadata.timeInfo?.startTimeField;
        break;
      case "endTimeField":
        o8 = this._metadata.timeInfo?.endTimeField;
        break;
      case "timeReceived":
        o8 = this._isStream ? i6 : null;
    }
    n12 = this._isStream ? r10?.end ?? Date.now() : r10?.end ?? -1 / 0;
    const l11 = e15.map((t18) => t18.reader.getCursor());
    let c8;
    for (let d10 = this._nextObservationRecords.length - 1; d10 >= 0 && !(this._observationRecords.length >= this._maxDisplayObservationsPerTrack); d10--) {
      const t18 = this._nextObservationRecords[d10], e16 = l11[t18.chunkIndex];
      n(e16), e16.setIndex(t18.featureIndex);
      const r11 = null != o8 ? e16.readAttributeAsTimestamp(o8) : null;
      (null != r11 ? n12 - r11 : 0) >= this._maxDisplayDuration || (this._commitObservation(t18, e16), c8 ??= t18);
    }
    if (null != c8) {
      const { chunkIndex: e16, featureIndex: r11 } = c8, i22 = `${c8.objectId}.latest`, o9 = t17.createDisplayIdForObjectId(i22), n13 = l11[e16];
      n(n13), n13.setIndex(r11);
      const d10 = new s4(n13.readGeometryWorldSpace(), { ...n13.readAttributes(), [r2]: 1 }, null, i22, o9);
      this._latestObservationFeature && a9.push(this._latestObservationFeature.objectId), this._latestObservationFeature = d10, this._latestObservationRecord = c8;
    } else this._latestObservationFeature = null;
    return this._trackLineGeometry = q(this._trackLineGeometry, this._trackLinePath, this._spatialReference), this._bounds = N2(this._trackLineGeometry), this._nextObservationRecords = [], a9;
  }
  updateStatistics(t17, e15) {
    this._statistics = i9.create(this._fields);
    const r10 = t17.map((t18) => t18.reader.getCursor());
    for (const { chunkIndex: i21, featureIndex: a9 } of this._observationRecords) {
      const t18 = r10[i21];
      n(t18), t18.setIndex(a9), this._statistics.insert(t18, e15);
    }
  }
  overlapsTile(t17) {
    for (const e15 of this._bounds) if (v(e15, t17.bounds, P2)) return true;
    return false;
  }
  getLatestObservationFeatureForTile(t17) {
    if (null == this._latestObservationFeature) return null;
    const { objectId: e15, displayId: s17, geometry: r10, attributes: i21 } = this._latestObservationFeature, a9 = new e3();
    gt(a9, r10, false, false, this._metadata.geometryType, t17.subscription.tile.transform);
    const o8 = e2(1 / 0, 1 / 0, -1 / 0, -1 / 0);
    E(a9, (t18, e16) => f2(o8, [t18, e16]));
    if (!d2(o8, e2(0, 0, o, o))) return null;
    return new s4(a9, i21, null, e15, s17);
  }
  getTrackLineFeatureForTile(t17) {
    const e15 = new e3();
    gt(e15, this._trackLineGeometry, false, false, "esriGeometryPolyline", t17.subscription.tile.transform);
    return new s4(e15, this._trackLineAttributes, null, this.objectId, this.displayId);
  }
  getTrackLineOptimizedFeature() {
    return new s4(this._trackLineGeometry, this._trackLineAttributes, null, this.objectId, this.displayId);
  }
  getTrackLineDisplayFeature() {
    const { _trackLineGeometry: t17, _trackLineAttributes: e15, displayId: s17 } = this;
    return { geometry: lt(t17, "esriGeometryPolyline", false, false), attributes: e15, displayId: s17 };
  }
  _commitObservation(t17, e15) {
    const s17 = e15.readCentroidWorldSpace();
    let r10 = s17?.coords[0], i21 = s17?.coords[1];
    null == s17 && (r10 = e15.readXWorldSpace(), i21 = e15.readYWorldSpace()), null != r10 && null != i21 && (this._observationRecords.unshift(t17), this._trackLinePath.unshift([r10, i21]));
  }
};
var M = class extends t11 {
  constructor(t17) {
    super(t17), this.done = false;
  }
};
var U = class _U extends i14 {
  static async create(t17, e15, s17, a9, o8) {
    const n12 = e15.metadata.outSpatialReference, l11 = new l3({ spatialReference: n12 }), c8 = await Promise.all(t17.fields.map(async (t18) => s13.create(l11, t18))), d10 = t17.featureFilter ? await p.create({ geometryType: e15.metadata.geometryType, hasM: false, hasZ: false, timeInfo: e15.metadata.timeInfo, fieldsIndex: e15.metadata.fieldsIndex, spatialReference: n12, filterJSON: t17.featureFilter }) : null;
    return n12.isWrappable || s5() || await Promise.all([import("./apiConverter-KNKAZ5K2.js"), import("./jsonConverter-YI6UYGEY.js"), i7()]).then(([t18, e16, s18]) => {
      C = { fromGeometryToGXGeometry: e16.fromGeometryToGXGeometry, toGeometry: e16.toGeometry, fromSpatialReference: t18.fromSpatialReference };
    }), new _U(t17, e15, s17, n12, c8, d10, a9, o8);
  }
  constructor(t17, e15, s17, r10, i21, a9, o8, n12) {
    super(e15, s17, r10, i21, n12), this._schema = t17, this._featureFilter = a9, this._arcadeContextInfo = o8, this._tracks = /* @__PURE__ */ new Map(), this._handledChunks = /* @__PURE__ */ new Set(), this._metadata = e15.metadata.weakCloneWithAdditionalFields([{ name: r2, alias: "trackPart", type: "esriFieldTypeSmallInteger" }]), this._trackLineMetadata = i8.createFeature({ geometryType: "esriGeometryPolyline", featureIdInfo: { type: "object-id", fieldName: "aggregateId" }, fieldsIndex: { fields: [...this._source.metadata.fieldsIndex.fields, ...this.aggregateFields, { name: r2, alias: "trackPart", type: "esriFieldTypeSmallInteger" }, { name: "aggregateId", alias: "aggregateId", type: "esriFieldTypeOID" }], timeZoneByFieldName: null }, globalIdField: null, spatialReference: e15.metadata.spatialReference, outSpatialReference: e15.metadata.outSpatialReference, subtypeField: null, subtypes: null, timeInfo: e15.metadata.timeInfo, timeReferenceUnknownClient: null, dateFieldsTimeZone: null, typeIdField: null, types: null });
  }
  destroy() {
    super.destroy(), this._clear();
  }
  get _isStream() {
    return this._source.isStream;
  }
  get enablePixelBuffering() {
    return true;
  }
  get isAggregate() {
    return false;
  }
  requiresInvalidation() {
    return true;
  }
  invalidate() {
    super.invalidate(), this._clear();
  }
  createState(t17) {
    return new M(t17);
  }
  async *applyOverrideUpdate(t17) {
    G().error("Applying override to tracks is not supported");
  }
  displayMap(t17, e15, s17) {
    const r10 = new Map(t17.map((t18) => [e15(t18), t18])), i21 = [];
    for (const a9 of this._tracks.values()) {
      const t18 = r10.get(a9.objectId);
      if (null != t18) {
        const e17 = s17(a9.displayId, t18, a9.objectId);
        i21.push(e17), r10.delete(a9.objectId);
        continue;
      }
      const e16 = a9.latestObservationFeature;
      if (e16?.objectId) {
        const t19 = r10.get(e16.objectId);
        if (null != t19) {
          const a10 = s17(e16.displayId, t19, e16.objectId);
          i21.push(a10), r10.delete(e16.objectId);
          continue;
        }
      }
      for (const o8 of a9.observations()) {
        const t19 = r10.get(o8.objectId);
        if (null != t19) {
          const e17 = s17(o8.displayId, t19, o8.objectId);
          i21.push(e17), r10.delete(o8.objectId);
        }
      }
    }
    return i21;
  }
  getDisplayFeatures(t17) {
    const e15 = new Set(t17), s17 = [], r10 = [], i21 = this._source.chunks().map((t18) => t18.reader.getCursor());
    for (const a9 of this._tracks.values()) {
      if (e15.has(a9.displayId) && r10.push(a9.getTrackLineDisplayFeature()), null != a9.latestObservationFeature && e15.has(a9.latestObservationFeature.displayId)) {
        const { displayId: t18, chunkIndex: e16, featureIndex: r11 } = a9.latestObservationRecord, o8 = i21[e16];
        o8.setIndex(r11), s17.push({ displayId: t18, ...o8.readLegacyFeatureWorldSpace() });
      }
      for (const { displayId: t18, chunkIndex: r11, featureIndex: o8 } of a9.observations()) if (e15.has(t18)) {
        const e16 = i21[r11];
        e16.setIndex(o8), s17.push({ displayId: t18, ...e16.readLegacyFeatureWorldSpace() });
      }
    }
    return { features: s17, aggregates: [], tracks: r10 };
  }
  getFeatureObjectIdsForAggregate(t17) {
    for (const e15 of this._tracks.values()) if (e15.objectId === t17) return Array.from(e15.observations(), (t18) => t18.objectId);
    return [];
  }
  async *updateChunks() {
    0 === this._handledChunks.size && this._rebuildTracks();
    for (const t17 of this._sendStates.values()) yield* this._update(t17);
  }
  forEachAggregateWorldSpace(t17) {
    for (const e15 of this._tracks.values()) t17(e15.getTrackLineOptimizedFeature());
  }
  _clear() {
    for (const t17 of this._source.chunks()) if (this._handledChunks.has(t17.chunkId)) {
      const e15 = t17.reader.getCursor();
      for (; e15.next(); ) {
        const t18 = e15.getObjectId();
        this._attributeStore.releaseDisplayIdForObjectId(t18);
      }
    }
    this._handledChunks.clear();
    for (const t17 of this._tracks.values()) this._removeTrack(t17);
    this._tracks.clear();
  }
  _rebuildTracks() {
    const t17 = this._source.chunks();
    if (!t17.length) return;
    const e15 = this._metadata.timeInfo?.trackIdField;
    if (null == e15) return;
    const s17 = /* @__PURE__ */ new Set();
    for (let r10 = 0; r10 < t17.length; r10++) {
      const i21 = t17[r10];
      if (this._handledChunks.has(i21.chunkId)) continue;
      this._handledChunks.add(i21.chunkId);
      const a9 = i21.reader.getCursor();
      for (; a9.next(); ) {
        const t18 = a9.getObjectId();
        a9.setDisplayId(this._attributeStore.createDisplayIdForObjectId(t18));
        const i22 = a9.readAttribute(e15);
        if (null != i22 && null != t18 && (null === this._featureFilter || this._featureFilter.check(a9, this._sqlOptions))) {
          if (!this._tracks.has(i22)) {
            const t19 = z2.getOid(i22), e16 = this._attributeStore.createDisplayIdForObjectId(t19), s18 = new z2(this._schema, i22, t19, e16, this.aggregateFields, this.spatialReference, this._source.metadata, this._isStream);
            this._tracks.set(i22, s18);
          }
          this._tracks.get(i22).stageObservation(r10, a9), s17.add(i22);
        }
      }
    }
    for (const r10 of this._tracks.values()) if (s17.has(r10.trackId)) {
      const e16 = r10.commitObservations(this._attributeStore, t17, this._featureFilter?.timeExtent);
      for (const t18 of e16) this._attributeStore.releaseDisplayIdForObjectId(t18);
      r10.updateStatistics(t17, e8(1, this._arcadeContextInfo));
    } else this._removeTrack(r10);
  }
  _removeTrack(t17) {
    this._tracks.delete(t17.trackId), this._attributeStore.releaseDisplayIdForObjectId(t17.objectId), null != t17.latestObservationFeature && this._attributeStore.releaseDisplayIdForObjectId(t17.latestObservationFeature.objectId);
  }
  *_update(e15) {
    if (e15.done) return;
    e15.done = !this._source.updateTracking.updating;
    const s17 = [], r10 = [];
    for (const t17 of this._tracks.values()) if (t17.length > 0) {
      if (this._schema.showLatestObservation) {
        const r11 = t17.getLatestObservationFeatureForTile(e15);
        null != r11 && s17.push(r11);
      }
      this._schema.showTrackLine && t17.overlapsTile(e15.subscription.tile) && r10.push(t17.getTrackLineFeatureForTile(e15));
    }
    const i21 = u7.fromOptimizedFeatures(s17, this._metadata, e15.subscription.tile.transform), a9 = u7.fromOptimizedFeatures(r10, this._trackLineMetadata, e15.subscription.tile.transform);
    let o8 = [];
    if (this._schema.showPreviousObservations) {
      const s18 = this._source.chunks().map(() => []);
      for (const t17 of this._tracks.values()) for (const { chunkIndex: e16, featureIndex: r11 } of t17.previousObservations()) s18[e16].push(r11);
      o8 = this._source.chunks().map((t17, r11) => {
        const i22 = t17.getTileReader(e15.subscription.tile);
        if (null == i22) return null;
        const a10 = d3.from(i22, s18[r11]);
        return a10.setProcessorAttributes({ [r2]: 2 }), "esriGeometryPoint" !== a10.geometryType && null != a10.getInTransform() || a10.setTransformForDisplay(e15.subscription.tile.transform), a10;
      }).filter(N);
    }
    this.events.emit("changed");
    const n12 = e15.subscription.tile.createArcadeEvaluationOptions(this._arcadeContextInfo), l11 = a9.getCursor();
    for (; l11.next(); ) this._attributeStore.setAttributeData(l11.getDisplayId(), l11, n12, this._sqlOptions);
    for (const t17 of o8) {
      const e16 = t17.getCursor();
      for (; e16.next(); ) this._attributeStore.setAttributeData(e16.getDisplayId(), e16, n12, this._sqlOptions);
    }
    const c8 = i21.getCursor();
    for (; c8.next(); ) this._attributeStore.setAttributeData(c8.getDisplayId(), c8, n12, this._sqlOptions);
    yield new e13(e15.subscription, a9, false, false, {});
    for (const t17 of o8) yield new e13(e15.subscription, t17, false, false, {});
    yield new e13(e15.subscription, i21, false, e15.done, {});
  }
};
function q(t17, e15, s17) {
  if (e15.length < 2) return tt(t17, [e15], false, false);
  if (s17.isWrappable) {
    let r11 = false;
    for (let t18 = 1; t18 < e15.length; t18++) {
      const i22 = e15[t18][0], a9 = L2(i22, e15[t18 - 1][0], s17);
      i22 !== a9 && (e15[t18][0] = a9, r11 = true);
    }
    if (r11) {
      const r12 = a3({ paths: [e15], spatialReference: s17 });
      if (null != r12) return tt(t17, r12.paths, false, false);
    }
    return tt(t17, [e15], false, false);
  }
  const r10 = C.fromGeometryToGXGeometry({ hasM: false, hasZ: false, paths: [e15] }), i21 = C.fromSpatialReference(s17);
  if (null != i21) {
    const e16 = u5(r10, 1e6, i21, e5.geodesic);
    if (null != e16) {
      const s18 = C.toGeometry(e16, i21);
      if (null != s18 && "paths" in s18) return tt(t17, s18.paths, false, false);
    }
  }
  return tt(t17, [e15], false, false);
}
function E(t17, e15) {
  const s17 = 2, { coords: r10, lengths: i21 } = t17;
  if (!i21.length) return void e15(r10[0], r10[1]);
  let a9 = 0;
  for (let o8 = 0; o8 < i21.length; o8++) {
    const t18 = i21[o8];
    let n12 = 0, l11 = 0;
    for (let i22 = 0; i22 < t18; i22++) n12 += r10[s17 * (i22 + a9)], l11 += r10[s17 * (i22 + a9) + 1], e15(n12, l11);
    a9 += t18;
  }
}
function N2(t17) {
  const { lengths: e15, coords: s17 } = t17, r10 = 2;
  if (!e15.length) return [K()];
  const i21 = [];
  let a9 = 0;
  for (let o8 = 0; o8 < e15.length; o8++) {
    const t18 = e15[o8], n12 = K();
    i21.push(n12);
    for (let e16 = 0; e16 < t18; e16++) {
      const t19 = s17[r10 * (e16 + a9)], i22 = s17[r10 * (e16 + a9) + 1];
      f2(n12, [t19, i22]);
    }
    a9 += t18;
  }
  return i21;
}

// node_modules/@arcgis/core/views/2d/layers/features/Processor.js
var b5 = class {
  constructor(t17, e15) {
    this._connection = t17, this._source = e15, this._version = 1, this._registry = new x(), this._proxy = new s8({ fetch: (t18, e16) => this._connection.layerView.fetch(t18, e16), fetchDictionary: (t18, e16) => this._connection.layerView.fetchDictionary(t18, e16) }), this._attributeStore = new b4({ isLocal: false, update: (t18) => l2(this._connection.container.updateAttributeView(t18)) });
  }
  destroy() {
    this._proxy.destroy(), this._strategy?.destroy(), this._attributeStore.destroy();
  }
  get aggregateQueryEngine() {
    return this._strategy?.aggregateQueryEngine;
  }
  get usedMemory() {
    let t17 = 0;
    return t17 += this._attributeStore.usedMemory, this._strategy && (t17 += this._strategy.usedMemory), t17;
  }
  get version() {
    return this._version;
  }
  getDisplayFeatures(t17) {
    return this._strategy ? this._strategy.getDisplayFeatures(t17) : { features: [], aggregates: [], tracks: [] };
  }
  getDisplayIds(t17) {
    const e15 = {};
    return this._strategy ? (this._strategy.displayMap(t17, (t18) => t18, (t18, s17, r10) => {
      e15[r10] = t18;
    }), e15) : e15;
  }
  getFeatureObjectIdsForAggregate(t17) {
    return this._strategy ? this._strategy.getFeatureObjectIdsForAggregate(t17) : [];
  }
  onSubscribe(t17) {
    this._strategy?.onSubscribe(t17);
  }
  onUnsubscribe(t17) {
    this._strategy?.onUnsubscribe(t17);
  }
  requiresInvalidation() {
    return this._strategy?.requiresInvalidation() ?? false;
  }
  async update(t17, s17, r10, i21, o8) {
    const n12 = t17.processor, h7 = i(this._schema?.storage, n12.storage), u12 = i(this._schema?.mesh.properties, n12.mesh.properties), p4 = i(this._schema?.mesh.factory, n12.mesh.factory), y9 = i(this._schema?.mesh.strategy, n12.mesh.strategy), d10 = w2(this._schema?.expressionProperties, n12.expressionProperties), _7 = d10.some((t18) => this._attributeStore.hasArcadeDependency(t18)), l11 = d10.some((t18) => this._factory?.hasArcadeDependency(t18) ?? false), m10 = d10.some((t18) => this._strategy?.hasArcadeDependency(t18)) || this._strategy?.isAggregate && _7, b6 = l11 || m10, I2 = u12 || p4 || y9;
    if (!(h7 || I2 || (l11 || _7 || m10)) && !i21) return false;
    has("esri-2d-update-debug") && console.debug(`Version[${this._version}] SymbolProcessor.update`, { changes: y3(this._schema, n12), schema: n12 }), this._schema = n12;
    const j = new l3({ fields: this._source.metadata.fieldsIndex, spatialReference: this._source.metadata.outSpatialReference }), x4 = { currentUser: n12.mesh.properties.currentUser };
    if ((h7 || I2 || _7) && (await this._attributeStore.update(n12.storage, j, this._source.metadata, s17), this._strategy?.invalidateAttributeData(S2(n12))), !i21 && !I2 && !b6) return false;
    (y9 || u12 || b6) && await this._updateStrategy(n12.mesh.strategy, o8, S2(n12), x4), this._updateSortKey(j, "sortKey" in n12.mesh.properties ? n12.mesh.properties.sortKey : null);
    const v2 = "dictionary" === n12.mesh.factory.symbology.type ? n12.mesh.factory.symbology.fieldMap : null, M2 = new s12(j, this._proxy, r10, this._registry, v2);
    return (p4 || "dictionary" === n12.mesh.factory.symbology.type) && (this._factory = await s11.create(M2, n12.mesh.factory)), this._version = s17, true;
  }
  async applyOverrideUpdate(t17) {
    if (!this._strategy) return;
    const e15 = this._strategy.applyOverrideUpdate(t17);
    for await (const r10 of e15) try {
      await this._process(r10);
    } catch (s17) {
    }
  }
  async updateChunks() {
    await this._doUpdateChunks(), this._strategy?.afterUpdateChunks();
  }
  async removeChunks(t17) {
    this._strategy?.removeChunks(t17), this._attributeStore.incrementDisplayIdGeneration();
  }
  updateHighlight({ highlights: t17 }) {
    if (!this._strategy || !this._strategy.hasSubscribers) return void this._attributeStore.setHighlight(t17.map(({ objectId: t18, highlightFlags: e16 }) => ({ objectId: t18, highlightFlags: e16, displayId: -1 })), t17);
    const e15 = this._strategy.displayMap(t17, ({ objectId: t18 }) => t18, (t18, { highlightFlags: e16 }, s17) => ({ objectId: s17, displayId: t18, highlightFlags: e16 }));
    this._attributeStore.setHighlight(e15, t17);
  }
  invalidate() {
    this._strategy && this._strategy.invalidate();
  }
  async _doUpdateChunks() {
    if (!this._strategy) return;
    const t17 = this._strategy.updateChunks(), e15 = [], r10 = /* @__PURE__ */ new Map();
    for await (const a9 of t17) {
      let t18 = r10.get(a9.id);
      null == t18 && (t18 = new e11({ concurrency: 16, process: (t19) => this._process(t19) }), r10.set(a9.id, t18));
      const i21 = t18.push(a9).catch((t19) => m2(t19));
      e15.push(i21);
    }
    try {
      await Promise.all(e15);
    } catch (i21) {
    }
    has("esri-2d-update-debug") && console.log("SendUpdates"), this._attributeStore.sendUpdates(), has("esri-2d-update-debug") && console.log("SendUpdates.await");
  }
  async _updateStrategy(t17, e15, s17, r10) {
    switch (this._strategy?.destroy(), t17.type) {
      case "feature":
        this._strategy = new i16(this._source, this._attributeStore, s17, r10);
        break;
      case "binning":
        this._strategy = await y4.create(t17, this._source, this._attributeStore, s17, r10);
        break;
      case "cluster":
        this._strategy = await x2.create(this._connection, t17, this._source, this._attributeStore, s17, r10);
        break;
      case "track":
        this._strategy = await U.create(t17, this._source, this._attributeStore, s17, r10);
    }
    for (const i21 of e15) this._strategy.onSubscribe(i21);
  }
  async _updateSortKey(e15, s17) {
    if (this._sortInfo = u(this._sortInfo?.computed), null != s17) {
      const t17 = s17.byRenderer ? null : await e15.createComputedField(s17);
      this._sortInfo = { ...s17, computed: t17 };
    }
  }
  async _process(t17) {
    const e15 = t17.subscription;
    if (has("esri-2d-update-debug")) {
      const s18 = e15.tile;
      console.debug(`Version[${this._version}] Tile[${s18.key.id}, end=${t17.end}] Processor._process`);
    }
    const s17 = { currentUser: this._schema?.mesh.properties.currentUser };
    await this._fetchResources(t17, s17), s2(e15.signal);
    const i21 = await this._write(t17, e15.tile.createArcadeEvaluationOptions(S2(this._schema)), s17), a9 = e15.tile.tileInfoView.getLODInfoAt(e15.tile.key);
    s2(e15.signal);
    const { message: o8, transferList: n12 } = i21.serialize(a9), c8 = { objectIdMap: null, inner: t17.createMessage(o8, this._version, this._attributeStore.epoch) };
    if (this._schema?.mesh.properties.returnMeshObjectId) {
      c8.objectIdMap = {};
      const e16 = t17.reader?.getCursor();
      if (e16) for (; e16.next(); ) c8.objectIdMap[e16.getDisplayId()] = e16.getObjectId();
    }
    if (s2(e15.signal), await this._connection.container.onMessage(c8, { signal: e15.signal, transferList: n12 }), this._attributeStore.sendUpdates(), has("esri-2d-update-debug")) {
      const s18 = e15.tile;
      console.debug(`Version[${this._version}] Tile[${s18.key.id}, end=${t17.end}] Processor._process.await`);
    }
  }
  async _fetchResources(t17, e15) {
    await this._fetchMatcherResources(t17), await this._fetchWriterResources(t17, e15);
  }
  async _fetchMatcherResources(t17) {
    if (t17.reader) return this._factory.enqueueMatcherRequests(this._proxy, t17.reader);
  }
  async _fetchWriterResources(t17, e15) {
    if (!t17.reader) return;
    const s17 = t17.reader.getCursor(), r10 = t17.subscription.tile.createArcadeEvaluationOptions(S2(this._schema));
    for (; s17.next(); ) this._factory.enqueueWriterRequests(this._proxy, s17, r10, e15);
    await this._proxy.fetchEnqueuedResources();
  }
  async _write(t17, e15, s17) {
    const a9 = t17.subscription.tile, o8 = t17.reader?.getCursor(), c8 = o8?.getSize() ?? 0, h7 = a9.tileInfoView.tileInfo.isWrappable, u12 = a9.tileInfoView.tileInfo.spatialReference.isWGS84, g5 = new g2(a9.key, this._strategy.enablePixelBuffering, h7, u12, c8);
    if (!o8) return g5;
    const p4 = a9.createArcadeEvaluationOptions(S2(this._schema));
    let y9 = 0;
    for (; o8.next(); ) {
      ++y9 % 1e3 || (await T(0), s2(t17.subscription));
      const n12 = this._getSortKeyValue(o8, e15);
      g5.entityStart(o8.getDisplayId(), n12), this._factory.write(g5, this._proxy, o8, p4, s17, a9.level), g5.entityEnd();
    }
    return g5;
  }
  _getSortKeyValue(t17, e15) {
    if (!this._sortInfo) return 0;
    const { computed: s17, order: r10, byRenderer: i21 } = this._sortInfo, a9 = i21 ? this._factory.getSortKey(t17, e15) : s17?.read(t17, e15);
    return null == a9 || isNaN(a9) ? 0 : a9 * ("asc" === r10 ? -1 : 1);
  }
};
function w2(t17, e15) {
  const s17 = [];
  return t17?.timeExtent?.start === e15.timeExtent?.start && t17?.timeExtent?.end === e15.timeExtent?.end || s17.push("timeProperties"), s17;
}
function S2(t17) {
  const { timeZone: e15 } = t17?.mesh.properties ?? {}, { timeExtent: s17 } = t17?.expressionProperties ?? {};
  return { timeZone: e15, timeExtent: s17 };
}

// node_modules/@arcgis/core/views/2d/layers/features/FeatureStoreStatistics.js
var t12 = class _t {
  static from(e15) {
    let n12 = 0, r10 = 0, o8 = 0;
    return e15.forEach((t17) => {
      const e16 = t17._readGeometry();
      e16 && (r10 += e16.isPoint ? 1 : e16.lengths.reduce((t18, e17) => t18 + e17, 0), o8 += e16.isPoint ? 1 : e16.lengths.length, n12 += 1);
    }), new _t(n12, r10, o8);
  }
  constructor(t17, e15, n12) {
    this.featureCount = t17, this.vertexCount = e15, this.ringCount = n12;
  }
  toJSON() {
    return { featureCount: this.featureCount, ringCount: this.featureCount, vertexCount: this.featureCount };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/StreamMessenger.js
var o4 = 2500;
var a5 = class extends b {
  constructor(e15) {
    super(), this._connection = e15, this._enabledEventTypes = /* @__PURE__ */ new Set(), this._updateInfo = { websocket: 0, client: 0 }, this._lastTime = performance.now(), this._queuedCommands = [], this.addHandles([l(() => this._strategy?.connectionStatus ?? "disconnected", (e16) => {
      this._layerView.setProperty({ propertyName: "pipelineConnectionStatus", value: e16 });
    }, { initial: true }), l(() => this._strategy?.errorString || null, (e16) => this._layerView.setProperty({ propertyName: "pipelineErrorString", value: e16 }), { initial: true })]);
  }
  destroy() {
    this._strategy = null, this.removeAllHandles();
  }
  get _layerView() {
    return this._connection.layerView;
  }
  set strategy(e15) {
    null == this._strategy && this._resetUpdateInfo(performance.now());
    const t17 = "event-handles";
    this.removeHandles(t17), null != e15 && (this.addHandles([e15.events.on("data-received", (e16) => this._onFeature(e16)), e15.events.on("message-received", (e16) => this._onWebSocketMessage(e16)), e15.events.on("features-updated", (e16) => this._onUpdate(e16)), e15.events.on("tick", () => this._onTick())], t17), this._queuedCommands.forEach((t18) => t18(e15)), this._queuedCommands = []), this._strategy = e15;
  }
  updateCustomParameters(e15) {
    null != e15 && this._callOrEnqueue((t17) => t17.updateCustomParameters(e15));
  }
  sendMessageToSocket(e15) {
    this._callOrEnqueue((t17) => t17.sendMessageToSocket(e15));
  }
  sendMessageToClient(e15) {
    this._callOrEnqueue((t17) => t17.sendMessageToClient(e15));
  }
  enableEvent(e15, t17) {
    t17 ? this._enabledEventTypes.add(e15) : this._enabledEventTypes.delete(e15);
  }
  disconnect() {
    this._strategy?.disconnect();
  }
  connect() {
    this._strategy?.connect();
  }
  clear() {
    this._strategy?.clear();
  }
  _onWebSocketMessage(e15) {
    this._enabledEventTypes.has("message-received") && this._layerView.emitEvent({ name: "message-received", event: e15 });
  }
  _onFeature(e15) {
    this._updateInfo.websocket++, this._enabledEventTypes.has("data-received") && this._layerView.emitEvent({ name: "data-received", event: { attributes: e15.attributes, centroid: e15.centroid, geometry: e15.geometry } });
  }
  _onUpdate(e15) {
    this._updateInfo.client += e15;
  }
  _onTick() {
    const e15 = performance.now(), t17 = e15 - this._lastTime;
    if (t17 > o4) {
      const s17 = Math.round(this._updateInfo.client / (t17 / 1e3)), n12 = Math.round(this._updateInfo.websocket / (t17 / 1e3));
      this._resetUpdateInfo(e15), this._layerView.emitEvent({ name: "update-rate", event: { client: s17, websocket: n12 } });
    }
  }
  _resetUpdateInfo(e15) {
    this._lastTime = e15, this._updateInfo.client = 0, this._updateInfo.websocket = 0;
  }
  _callOrEnqueue(e15) {
    null != this._strategy ? e15(this._strategy) : this._queuedCommands.push(e15);
  }
};
__decorate([m()], a5.prototype, "_strategy", void 0), a5 = __decorate([a("esri.views.2d.layers.features.sources.StreamMessenger")], a5);

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/ALoadStrategy.js
var r8 = class {
  constructor() {
    this._requiresInvalidation = false;
  }
  get requiresInvalidation() {
    return this._requiresInvalidation;
  }
  requireInvalidation() {
    this._requiresInvalidation = true;
  }
};
var e14 = class {
  constructor(r10, e15, o8) {
    this._context = o8, this._controller = new AbortController(), this.metadata = i8.createFeature(r10), this._schema = e15;
  }
  destroy() {
    this._controller.abort(), this.store.destroy();
  }
  get store() {
    return this._context.store;
  }
  get _connection() {
    return this._context.connection;
  }
  get _options() {
    return { signal: this._controller.signal };
  }
  get _signal() {
    return this._controller.signal;
  }
  async applyOverride(t17) {
    this._onOverride(), await this.store.applyOverride(t17);
  }
  takeOverrideUpdate() {
    return this.store.takeOverrideUpdate();
  }
  unsafeSetQueryHistoricMoment(t17) {
    throw new Error("InternalError: LoadStrategy does not support query info");
  }
  async queryByObjectId(t17, r10) {
    throw new Error("InternalError: LoadStrategy does not support fetching");
  }
  prepareCacheUpdate(t17, r10) {
  }
  applyCacheUpdate() {
    return null;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/support/snapshotUtils.js
async function o5(e15, n12, o8, a9 = {}) {
  const s17 = (await Promise.allSettled(o8.map((r10) => t13(e15, n12, r10, a9)))).filter((r10) => "rejected" === r10.status).map((r10) => r10.reason);
  if (s17.length) throw new s("featurelayer-query", "Encountered errors when downloading data", { errors: s17 });
}
async function t13(r10, o8, t17, a9 = {}) {
  const s17 = `${r10.chunkPrefix ?? ""}${t17.num}`, u12 = await r10.fetch(t17.query, a9, { chunkId: s17 }), i21 = new t5(u12, t17.query.inner.toJSON(), t17.num, false);
  i21.chunkId = i21.normalizedChunkId = s17, s2(a9), o8.insert(i21);
}

// node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureCache.js
var o6 = 8e3;
var h5 = class {
  constructor(h7, a9, c8, n12) {
    this.store = h7, this.queryInfo = a9, this._options = c8, this._fetch = n12, this._nextBatch = /* @__PURE__ */ new Set(), this._fetchFeatures = L(async () => {
      if (0 === this._nextBatch.size || this._options.signal?.aborted) return;
      const r10 = Array.from(this._nextBatch);
      this._nextBatch.clear(), r10.length > o6 && i2.getLogger("esri.views.2d.layers.FeatureLayerView2D").warn(new s("highlight-too-many-features", `highlight is limited to ${o6} features on large layers configured with a display filter to avoid performance issues`));
      const h8 = this.queryInfo.objectIdsQueryPageSize, a10 = Math.ceil(o6 / h8), c9 = Math.min(a10, Math.ceil(r10.length / h8)), n13 = Array.from({ length: c9 }, (t17, e15) => {
        const s17 = e15 * h8, i21 = Math.min(s17 + h8, r10.length);
        return { num: e15, query: this.queryInfo.createObjectIdsQuery(r10.slice(s17, i21)) };
      });
      try {
        await o5({ chunkPrefix: "cache." + n2(), fetch: this._fetch }, this.store, n13, this._options);
      } catch (f7) {
      }
    });
  }
  prepareCacheUpdate(t17, e15) {
    if (e15) for (const r10 of e15) this._nextBatch.delete(r10);
    for (const r10 of t17) this._nextBatch.add(r10);
  }
  applyCacheUpdate() {
    return 0 === this._nextBatch.size || this._options.signal?.aborted ? null : this._fetchFeatures().catch(() => {
    });
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/constants.js
var o7 = 32;

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderPBFHeader.js
var n10 = 268435455;
var i17 = class {
  constructor() {
    this.hasFeatures = false, this.exceededTransferLimit = false, this.fieldCount = 0, this.featureCount = 0, this.idFieldIndices = [], this.vertexCount = 0, this.offsets = { attributes: new Array(), geometry: new Array() }, this.centroid = new Array();
  }
  get usedMemory() {
    let t17 = 0;
    return t17 += i5(this.idFieldIndices), t17 += i5(this.offsets.attributes), t17 += i5(this.offsets.geometry), t17 += i5(this.centroid), this.displayIds && (t17 += i5(this.displayIds)), this.groupIds && (t17 += i5(this.groupIds)), t17;
  }
};
function a6(e15, a9, c8, f7 = false) {
  const d10 = 9, u12 = 12, p4 = 13, g5 = 15, h7 = e15.asUnsafe(), l11 = h7.pos(), m10 = new i17();
  let y9 = 0, I2 = 0;
  const w3 = 1, b6 = 2, k = 4, x4 = 3;
  let A = null, L3 = false;
  const F = [];
  for (; h7.next(); ) switch (h7.tag()) {
    case u12:
      A = h7.processMessage(h);
      break;
    case d10:
      if (m10.exceededTransferLimit = h7.getBool(), m10.exceededTransferLimit) {
        m10.offsets.geometry = f7 ? new Float64Array(8e3) : new Int32Array(8e3), m10.centroid = f7 ? new Float64Array(16e3) : new Int32Array(16e3);
        for (let e16 = 0; e16 < m10.centroid.length; e16++) m10.centroid[e16] = n10;
      }
      break;
    case p4: {
      const e16 = h7.processMessage(b3);
      e16.index = y9++, F.push(e16);
      break;
    }
    case g5: {
      const e16 = h7.getLength(), t17 = h7.pos() + e16;
      if (!m10.exceededTransferLimit) {
        const e17 = m10.offsets.geometry, t18 = m10.centroid;
        e17.push(0), t18.push(n10), t18.push(n10);
      }
      !L3 && m10.exceededTransferLimit && (L3 = true, m10.offsets.attributes = f7 ? new Float64Array(8e3 * y9) : new Uint32Array(8e3 * y9));
      let s17 = I2 * y9;
      for (; h7.pos() < t17 && h7.next(); ) switch (h7.tag()) {
        case w3: {
          if (L3) m10.offsets.attributes[s17++] = h7.pos();
          else {
            m10.offsets.attributes.push(h7.pos());
          }
          const e17 = h7.getLength();
          h7.skipLen(e17);
          break;
        }
        case b6:
          if (a9) {
            const e17 = h7.getLength(), t18 = h7.pos() + e17;
            for (; h7.pos() < t18 && h7.next(); ) switch (h7.tag()) {
              case x4: {
                h7.getUInt32();
                const e18 = h7.getSInt64(), t19 = h7.getSInt64();
                m10.centroid[2 * I2] = e18, m10.centroid[2 * I2 + 1] = t19;
                break;
              }
              default:
                h7.skip();
            }
          } else {
            m10.offsets.geometry[I2] = h7.pos();
            const e17 = h7.getLength();
            m10.vertexCount += e17, h7.skipLen(e17);
          }
          break;
        case k: {
          const e17 = h7.getLength(), t18 = h7.pos() + e17;
          for (; h7.pos() < t18 && h7.next(); ) switch (h7.tag()) {
            case x4: {
              h7.getUInt32();
              const e18 = h7.getSInt64(), t19 = h7.getSInt64();
              m10.centroid[2 * I2] = e18, m10.centroid[2 * I2 + 1] = t19;
              break;
            }
            default:
              h7.skip();
          }
          break;
        }
        default:
          h7.skip();
      }
      I2++, m10.hasFeatures = true;
      break;
    }
    default:
      h7.skip();
  }
  m10.fields = new Z(F), m10.featureCount = I2, m10.fieldCount = y9;
  const C2 = e9(c8);
  return m10.idFieldIndices = Array.from(C2, (e16) => m10.fields.get(e16)?.index), m10.transform = A, m10.displayIds = new Uint32Array(m10.featureCount), m10.groupIds = new Uint16Array(m10.featureCount), h7.move(l11), m10;
}

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderPBF.js
var d7 = 268435455;
var u10 = 128;
var c5 = 128e3;
var l6 = { small: { delta: new Int32Array(u10), decoded: new Int32Array(u10) }, small64: { delta: new Float64Array(0), decoded: new Float64Array(0) }, large: { delta: new Int32Array(c5), decoded: new Int32Array(c5) }, large64: { delta: new Float64Array(0), decoded: new Float64Array(0) } };
function g4(e15, t17) {
  return t17 ? e15 <= l6.small64.delta.length ? l6.small64 : (e15 <= l6.large64.delta.length || (l6.large64.delta = new Float64Array(Math.round(1.25 * e15)), l6.large64.decoded = new Float64Array(Math.round(1.25 * e15))), l6.large64) : e15 <= l6.small.delta.length ? l6.small : (e15 <= l6.large.delta.length || (l6.large.delta = new Int32Array(Math.round(1.25 * e15)), l6.large.decoded = new Int32Array(Math.round(1.25 * e15))), l6.large);
}
function _4(r10) {
  try {
    const e15 = 2, t17 = new n3(new Uint8Array(r10), new DataView(r10));
    for (; t17.next(); ) {
      if (t17.tag() === e15) return f5(t17.getMessage());
      t17.skip();
    }
  } catch (s17) {
    const r11 = new s("query:parsing-pbf", "Error while parsing FeatureSet PBF payload", { error: s17 });
    i2.getLogger("esri.view.2d.layers.features.support.FeatureSetReaderPBF").error(r11);
  }
  return null;
}
function f5(e15) {
  const t17 = 1;
  for (; e15.next(); ) {
    if (e15.tag() === t17) return e15.getMessage();
    e15.skip();
  }
  return null;
}
function y6(e15) {
  const t17 = 1, r10 = 2, s17 = 3, n12 = 4, a9 = 5, i21 = 6, h7 = 7, o8 = 8, d10 = 9, u12 = e15.getLength(), c8 = e15.pos() + u12;
  for (; e15.pos() < c8 && e15.next(); ) switch (e15.tag()) {
    case t17:
      return e15.getString();
    case r10:
      return e15.getFloat();
    case s17:
      return e15.getDouble();
    case n12:
      return e15.getSInt32();
    case a9:
      return e15.getUInt32();
    case i21:
      return e15.getInt64();
    case h7:
      return e15.getUInt64();
    case o8:
      return e15.getSInt64();
    case d10:
      return e15.getBool();
    default:
      return e15.skip(), null;
  }
  return null;
}
function m6(e15, t17, r10, s17, n12) {
  if (!e15) return false;
  return 0 === t17 * n12 - s17 * r10 && t17 * s17 + r10 * n12 > 0;
}
var I = class _I extends O {
  static fromBuffer(e15, t17, r10 = false) {
    const s17 = t17.geometryType, n12 = _4(e15), a9 = a6(n12, "esriGeometryPoint" === s17, t17.featureIdInfo, r10);
    return new _I(n12, a9, t17, r10);
  }
  constructor(e15, t17, r10, s17) {
    super(r10), this._use64Bit = s17, this._hasNext = false, this._isPoints = false, this._featureIndex = -1, this._featureOffset = 0, this._cache = { area: 0, unquantGeometry: void 0, geometry: void 0 }, this._parseCaches = new Array(), this._geometryType = r10.geometryType, this._reader = e15, this._header = t17, this._hasNext = t17.hasFeatures, this._isPoints = "esriGeometryPoint" === r10.geometryType;
  }
  get _size() {
    return this._header.featureCount;
  }
  get fields() {
    return this._header.fields;
  }
  get geometryType() {
    return this._geometryType;
  }
  get hasZ() {
    return false;
  }
  get hasM() {
    return false;
  }
  get hasFeatures() {
    return this._header.hasFeatures;
  }
  get hasNext() {
    return this._hasNext;
  }
  get exceededTransferLimit() {
    return this._header.exceededTransferLimit;
  }
  getSize() {
    return this._size;
  }
  getInTransform() {
    return this._header.transform;
  }
  getCursor() {
    return this.copy();
  }
  getIndex() {
    return this._featureIndex;
  }
  setIndex(e15) {
    this._cache.area = 0, this._cache.unquantGeometry = void 0, this._cache.geometry = void 0, this._featureIndex = e15;
  }
  getAttributeHash() {
    let e15 = "";
    for (const t17 of this._header.fields.fields) e15 += this._readAttributeAtIndex(t17.index) + ".";
    return e15;
  }
  getObjectId() {
    if (1 === this._header.idFieldIndices.length) return this._readAttributeAtIndex(this._header.idFieldIndices[0]);
    const e15 = this._header.idFieldIndices.map((e16) => this._readAttributeAtIndex(e16));
    return JSON.stringify(e15);
  }
  getDisplayId() {
    return this._header.displayIds[this._featureIndex];
  }
  setDisplayId(e15) {
    this._header.displayIds[this._featureIndex] = e15;
  }
  readGeometryArea() {
    return this._cache.area || this._readGeometry(true), this._cache.area;
  }
  copy() {
    const e15 = this._reader.clone(), t17 = new _I(e15, this._header, this.metadata, this._use64Bit);
    return this.copyInto(t17), t17;
  }
  next() {
    for (this._cache.area = 0, this._cache.unquantGeometry = void 0, this._cache.geometry = void 0; ++this._featureIndex < this._size && !this._getExists(); ) ;
    return this._featureIndex < this._size;
  }
  get usedMemory() {
    return s3 + (this._cache.geometry?.usedMemory ?? 0);
  }
  get underlyingMemory() {
    return super.underlyingMemory + this._reader.usedMemory + this._header.usedMemory;
  }
  _readX() {
    return this._header.centroid[2 * this._featureIndex];
  }
  _readY() {
    return this._header.centroid[2 * this._featureIndex + 1];
  }
  _readServerCentroid() {
    const e15 = this._header.centroid[2 * this._featureIndex], t17 = this._header.centroid[2 * this._featureIndex + 1];
    return e15 === d7 ? null : new e3([], [e15, t17]);
  }
  _readGeometry(e15 = false) {
    if (void 0 === this._cache.geometry) {
      let r10 = null;
      if (this._isPoints) {
        if (this._header.centroid[2 * this._featureIndex] === d7) return null;
        const e16 = this._header.centroid[2 * this._featureIndex], t17 = this._header.centroid[2 * this._featureIndex + 1];
        r10 = new e3([], [e16, t17]);
      } else {
        const s17 = this._header.offsets.geometry[this._featureIndex], n12 = this._reader;
        if (0 === s17) return null;
        n12.move(s17);
        try {
          r10 = e15 ? this._parseGeometryForDisplay(n12) : this._parseGeometry(n12);
        } catch (t17) {
          return null;
        }
      }
      return 0 === r10?.coords.length && (r10 = null), this._cache.geometry = r10, r10;
    }
    return this._cache.geometry;
  }
  _readAttribute(e15, t17) {
    const r10 = this._header.fields.get(e15);
    if (null == r10) return;
    const s17 = this._readAttributeAtIndex(r10.index), n12 = this._header.fields.isDateField(r10.name);
    return t17 ? null == s17 ? s17 : n12 ? new Date(s17) : s17 : s17;
  }
  _readAttributes() {
    const e15 = {};
    for (const t17 of this._header.fields.fields) e15[t17.name] = this._readAttributeAtIndex(t17.index);
    return e15;
  }
  copyInto(e15) {
    super.copyInto(e15), e15._featureIndex = this._featureIndex, e15._featureOffset = this._featureOffset, e15._hasNext = this._hasNext, e15._parseCaches = this._parseCaches;
  }
  _readAttributeAtIndex(e15) {
    let t17 = this._parseCaches[e15];
    if (t17 || (t17 = new a2(this.getSize()), this._parseCaches[e15] = t17), t17.has(this._featureIndex)) return t17.get(this._featureIndex);
    const r10 = this._header.offsets.attributes[this._featureIndex * this._header.fieldCount + e15], s17 = this._reader;
    s17.move(r10);
    const n12 = y6(s17);
    return t17.set(this._featureIndex, n12), n12;
  }
  _readGeometryDeltaDecoded(e15 = false) {
    if (void 0 === this._cache.unquantGeometry) {
      const t17 = this._readGeometry(e15);
      if (!t17) return this._cache.unquantGeometry = void 0, null;
      if (!this.getInTransform()) return this._cache.unquantGeometry = t17, t17;
      const r10 = g4(t17.coords.length, this._use64Bit).decoded, s17 = t17.clone(r10), n12 = s17.coords;
      let a9 = 0;
      for (const e16 of s17.lengths) {
        for (let t18 = 1; t18 < e16; t18++) {
          const e17 = 2 * (a9 + t18), r11 = 2 * (a9 + t18 - 1);
          n12[e17] += n12[r11], n12[e17 + 1] += n12[r11 + 1];
        }
        a9 += e16;
      }
      return this._cache.unquantGeometry = s17, s17;
    }
    return this._cache.unquantGeometry;
  }
  _parseGeometry(e15) {
    const t17 = 2, r10 = 3, s17 = e15.asUnsafe(), n12 = s17.getLength(), i21 = s17.pos() + n12, h7 = [], o8 = [];
    for (; s17.pos() < i21 && s17.next(); ) switch (s17.tag()) {
      case t17: {
        const e16 = s17.getUInt32(), t18 = s17.pos() + e16;
        for (; s17.pos() < t18; ) o8.push(s17.getUInt32());
        break;
      }
      case r10: {
        const e16 = s17.getUInt32(), t18 = s17.pos() + e16;
        for (h7.push(s17.getSInt64()), h7.push(s17.getSInt64()), this.hasZ && s17.getSInt64(), this.hasM && s17.getSInt64(); s17.pos() < t18; ) h7.push(s17.getSInt64()), h7.push(s17.getSInt64()), this.hasZ && s17.getSInt64(), this.hasM && s17.getSInt64();
        break;
      }
      default:
        s17.skip();
    }
    return new e3(o8, h7);
  }
  _parseGeometryForDisplay(e15) {
    const t17 = 2, s17 = 3, n12 = e15.asUnsafe(), i21 = n12.getLength(), h7 = n12.pos() + i21, o8 = [], d10 = [];
    let u12 = 0, c8 = 0, l11 = null, _7 = 0;
    const f7 = "esriGeometryPolygon" === this.geometryType, y9 = "esriGeometryPolyline" === this.geometryType, I2 = f7 ? 3 : y9 ? 2 : 1, p4 = f7 || y9;
    for (; n12.pos() < h7 && n12.next(); ) switch (n12.tag()) {
      case t17: {
        const e16 = n12.getUInt32(), t18 = n12.pos() + e16;
        for (; n12.pos() < t18; ) {
          const e17 = n12.getUInt32();
          o8.push(e17), u12 += e17;
        }
        l11 = g4(2 * u12, this._use64Bit).delta;
        break;
      }
      case s17: {
        n12.getUInt32();
        const e16 = 2 + (this.hasZ ? 1 : 0) + (this.hasM ? 1 : 0);
        n(l11);
        for (const t18 of o8) {
          if (c8 + e16 * t18 > l11.length) {
            for (let e17 = 0; e17 < t18; e17++) n12.getSInt64(), n12.getSInt64(), this.hasZ && n12.getSInt64(), this.hasM && n12.getSInt64();
            continue;
          }
          let r10 = 0, s18 = n12.getSInt64(), a9 = n12.getSInt64();
          this.hasZ && n12.getSInt64(), this.hasM && n12.getSInt64(), l11[c8++] = s18, l11[c8++] = a9, r10 += 1;
          for (let e17 = 1; e17 < t18; e17++) {
            const e18 = n12.getSInt64(), t19 = n12.getSInt64(), i22 = s18 + e18, h8 = a9 + t19;
            _7 += -0.5 * (i22 - s18) * (h8 + a9), this.hasZ && n12.getSInt64(), this.hasM && n12.getSInt64(), 0 === e18 && 0 === t19 || m6(p4, l11[c8 - 2], l11[c8 - 1], e18, t19) ? (l11[c8 - 2] += e18, l11[c8 - 1] += t19) : (l11[c8++] = e18, l11[c8++] = t19, r10 += 1), s18 = i22, a9 = h8;
          }
          r10 >= I2 ? d10.push(r10) : c8 -= r10 * e16;
        }
        break;
      }
      default:
        n12.skip();
    }
    return this._cache.area = _7, d10.length ? new e3(d10, l11) : null != l11 ? this._createDeltaQuantizedExtrudedGeometry(l11[0], l11[1]) : null;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/support/queryAdapters.js
var c6 = class {
  constructor(t17, e15) {
    this.service = t17, this._metadata = e15;
  }
  destroy() {
  }
};
function m7(t17, e15, a9) {
  switch (t17.type) {
    case "memory":
      return new p3(t17, e15, a9);
    case "ogc":
      return new h6(t17, e15);
    case "feature-service":
      return t17.queryMetadata.supportsFormatPBF && has("featurelayer-pbf") ? new d8(t17, e15) : new f6(t17, e15);
  }
}
async function l7(e15) {
  const a9 = new c3();
  return await a9.open(e15, {}), a9;
}
var p3 = class extends c6 {
  constructor(t17, e15, a9) {
    super(t17, e15), this._ports = [], this._loaded = this._load(a9);
  }
  destroy() {
    this._loaded.finally(() => {
      this._client.close(), this._client = null;
      for (const t17 of this._ports) t17.close();
    }).catch(() => {
    });
  }
  async _load(t17) {
    this._ports = await t17.layerView.openMemoryPorts(), this._client = await l7(this._ports);
  }
  async executeQuery(t17, e15) {
    await this._loaded;
    const a9 = await this._client.invoke("queryFeatures", t17.toJSON(), e15);
    return u7.fromFeatureSet(a9, this._metadata);
  }
};
var d8 = class extends c6 {
  async executeQuery(t17, e15) {
    const { data: a9 } = await c2(this.service.source, t17, e15), r10 = !t17.quantizationParameters;
    return I.fromBuffer(a9, this._metadata, r10);
  }
};
var f6 = class extends c6 {
  async executeQuery(t17, s17) {
    const { source: i21, queryMetadata: u12 } = this.service;
    if (null != t17.quantizationParameters && !u12.supportsQuantization) {
      const u13 = t17.clone(), c9 = s6(u13.quantizationParameters);
      u13.quantizationParameters = null;
      const { data: m10 } = await y2(i21, u13, this._metadata.spatialReference, s17), l11 = at(m10, this._metadata.featureIdInfo);
      return mt(c9, l11), u7.fromOptimizedFeatureSet(l11, this._metadata);
    }
    const { data: c8 } = await y2(i21, t17, this._metadata.spatialReference, s17);
    return "esriGeometryPoint" === this._metadata.geometryType && (c8.features = c8.features?.filter((t18) => {
      if (null != t18.geometry) {
        const e15 = t18.geometry;
        return Number.isFinite(e15.x) && Number.isFinite(e15.y);
      }
      return true;
    })), u7.fromFeatureSet(c8, this._metadata);
  }
};
var h6 = class extends c6 {
  async executeQuery(t17, a9) {
    if (t17.quantizationParameters && !this.service.queryMetadata.supportsQuantization) {
      const i22 = t17.clone(), o8 = s6(i22.quantizationParameters);
      i22.quantizationParameters = null;
      const u12 = await R(this.service.source, t17, a9);
      return mt(o8, u12), u7.fromOptimizedFeatureSet(u12, this._metadata);
    }
    const i21 = await R(this.service.source, t17, a9);
    return u7.fromOptimizedFeatureSet(i21, this._metadata);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/AFeatureLoadStrategy.js
var l8 = class extends e14 {
  constructor(e15, t17, r10) {
    super(e15.metadata, t17, r10), this._service = e15, this._didApplyOverride = false, this._queue = new _({ concurrency: o7, process: async (e16) => {
      const t18 = { signal: e16.options?.signal, query: e16.query.customParameters, useRequestQueue: true };
      return this._adapter.executeQuery(e16.query.inner, t18);
    } }), this._queryInfo = u8.create(e15, { ...t17.full, ...t17.partial }, this.metadata), this._adapter = m7(e15, this.metadata, r10.connection), this._lastEditDate = e15.queryMetadata.lastEditDate;
  }
  destroy() {
    super.destroy(), this._adapter.destroy();
  }
  unsafeSetQueryHistoricMoment(e15) {
    this._queryInfo.updateHistoricMoment(e15);
  }
  async tryUpdate(e15, t17) {
    if (i(this.availableFields, t17.availableFields)) {
      if (this._didApplyOverride || await this._queryLastEditDateChanged()) return false;
      await this._updateFields(t17.availableFields);
    }
    return this._schema.partial = t17, true;
  }
  async queryByObjectId(e15, t17) {
    if (0 === e15.length) return u7.empty(this.metadata);
    const r10 = this._queryInfo.createQuery({ objectIds: e15 });
    return r10.inner.outFields = t17, this._fetch(r10, null, null);
  }
  get availableFields() {
    return this._schema.partial.availableFields;
  }
  get definitionExpression() {
    return this._schema.full.definitionExpression;
  }
  _onOverride() {
    this._didApplyOverride = true;
  }
  async _updateFields(e15) {
    this._queryInfo.updateFields(e15);
    const r10 = Array.from(this.store.chunks()).map(async (e16) => {
      const t17 = b2.fromJSON(e16.queryInfo.queryJSON);
      if (t17) try {
        return await this._tryUpdateFields(e16.reader, t17, { chunkId: e16.chunkId }), null;
      } catch (r11) {
        return r11;
      }
    }), s17 = (await Promise.all(r10)).filter((e16) => e16);
    if (s17.length) throw new s("featurelayer-query", "Encountered errors when downloading fields", { errors: s17 });
  }
  async _fetch(e15, t17, r10) {
    const s17 = await this._enqueue(e15, t17);
    return await this._tryUpdateFields(s17, e15.inner, r10), s17;
  }
  async _queryLastEditDateChanged() {
    if (null == this._lastEditDate) return false;
    if (!("source" in this._service)) return false;
    const t17 = this._service.source, r10 = { ...t17.query, f: "json" }, s17 = (await H(t17.path, { query: r10, responseType: "json" })).data.editingInfo.lastEditDate;
    return s17 !== this._lastEditDate && (this._lastEditDate = s17, true);
  }
  async _tryUpdateFields(e15, s17, i21) {
    const a9 = this._queryInfo.createPatchFieldsQuery(s17, e15, i21);
    if (!a9) return;
    const n12 = await this._enqueue(a9, this._options);
    n12.getSize() === e15.getSize() ? e15.joinAttributes(n12) : i2.getLogger("esri.views.2d.layers.features.sources.strategies.AFetchLoadStrategy").error(new s("featurelayer-query", `Failed to join features. Expected a count of ${e15.getSize()} features, but got ${n12.getSize()}`, { query: a9.inner.toJSON(), debugInfo: i21 }));
  }
  async _enqueue(e15, t17) {
    return this._connection.onEvent({ type: "fetchStart" }), this._queue.push({ query: e15, options: t17 }).finally(() => {
      this._connection.onEvent({ type: "fetchEnd", done: 0 === this._queue.length });
    });
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/AFeatureTileLoadStrategy.js
var s15 = class extends l8 {
  constructor(t17, s17, h7) {
    super(t17, s17, h7), this._chunksById = /* @__PURE__ */ new Map(), this._featureCache = new h5(this.store, this._queryInfo, this._options, this._fetch.bind(this));
  }
  prepareCacheUpdate(e15, t17) {
    return this._featureCache.prepareCacheUpdate(e15, t17);
  }
  applyCacheUpdate() {
    return this._featureCache.applyCacheUpdate();
  }
  unload(e15) {
    this._removeChunks(e15.tile);
  }
  _addChunk(e15) {
    const t17 = e15.tile.id;
    this._chunksById.has(t17) || this._chunksById.set(t17, []);
    const s17 = e15.size();
    (s17 || e15.first || e15.end) && (has("esri-2d-update-debug") && console.debug(`Chunk[${e15.chunkId}] ATileLoadStrategy.addChunk [count=${s17}]`), this._chunksById.get(t17).push(e15), this.store.insert(e15));
  }
  _removeChunks(e15) {
    const t17 = this._chunksById.get(e15.key.id) ?? [];
    for (const s17 of t17) has("esri-2d-update-debug") && console.debug(`Tile[${e15.key.id}] Chunk[${s17.chunkId}] ATileLoadStrategy.removeChunk`), this.store.remove(s17);
    this._chunksById.delete(e15.key.id);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/DrillDownTileSourceChunk.js
var i18 = class extends i10 {
  constructor(e15, i21, t17, r10, s17, h7) {
    super(), this._reader = e15, this._queryJSON = i21, this._tile = t17, this._sourceTile = r10, this._sourceTileDepth = s17, this._end = h7, this.chunkId = `${this._tile.key.id}.${this._sourceTile?.key.id}${this._end ? "e" : ""}`, this.normalizedChunkId = `${this._tile.key.normalizedId}.${this._sourceTile?.key.normalizedId}${this._end ? "e" : ""}`;
  }
  get queryInfo() {
    return { type: "drill-down-tile", chunkId: this.chunkId, tileId: this._tile.key.id, queryJSON: this._queryJSON, sourceTileDepth: this._sourceTileDepth, sourceTileId: this._sourceTile?.key.id, size: this.size(), end: this.end };
  }
  get first() {
    return 0 === this._sourceTileDepth;
  }
  get reader() {
    return this._reader;
  }
  get end() {
    return this._end;
  }
  get tile() {
    return this._tile;
  }
  get isTiled() {
    return true;
  }
  getTileReader(e15) {
    return this._tile.key.id === e15.key.id ? this.reader : null;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/FeatureDrillDownTileLoadStrategy.js
var a7 = has("featurelayer-query-max-depth");
var l9 = class {
  constructor(e15, o8) {
    this.subscription = e15, this._tileIdToResult = /* @__PURE__ */ new Map(), this._controller = new AbortController(), this._handles = t2([w(e15.signal, () => this._controller.abort()), w(o8, () => this._controller.abort())]);
  }
  destroy() {
    this._controller.abort(), this._handles.remove();
  }
  get(t17) {
    return this._tileIdToResult.get(t17);
  }
  set(t17, e15) {
    this._tileIdToResult.set(t17, e15);
  }
  get options() {
    return { signal: this._controller.signal };
  }
};
var n11 = class extends s15 {
  constructor() {
    super(...arguments), this._loadStates = /* @__PURE__ */ new Map();
  }
  destroy() {
    super.destroy();
    for (const t17 of this._loadStates.values()) t17.destroy();
    this._loadStates.clear();
  }
  get about() {
    return { willQueryAllFeatures: false, willQueryFullResolutionGeometry: false };
  }
  async load(t17) {
    this._loadStates.has(t17.key.id) || this._loadStates.set(t17.key.id, new l9(t17, this._options));
    const s17 = this._loadStates.get(t17.key.id);
    let o8;
    try {
      for await (const o9 of this._fetchChunkInfos(s17, t17.tile, 0)) {
        const { queryJSON: t18, reader: i21, sourceTile: a10, sourceTileDepth: l11, tile: n12 } = o9, h7 = new i18(i21, t18, n12, a10, l11, false);
        s2(s17.options), this._addChunk(h7);
      }
    } catch (n12) {
      o8 = n12;
    }
    s2(s17.options);
    const a9 = new i18(u7.empty(this.metadata), null, t17.tile, null, -1, true);
    if (this._addChunk(a9), o8) throw o8;
  }
  unload(t17) {
    super.unload(t17), this._loadStates.get(t17.key.id)?.destroy(), this._loadStates.delete(t17.key.id);
  }
  async *_fetchChunkInfos(t17, e15, s17) {
    let o8 = t17.get(e15.id);
    const r10 = !!o8;
    if (o8 || (o8 = await this._fetchChunkInfo(t17, e15, s17), t17.set(e15.id, o8)), o8.reader.exceededTransferLimit && s17 < has("featurelayer-query-max-depth")) for (const i21 of e15.createChildTiles()) yield* this._fetchChunkInfos(t17, i21, s17 + 1);
    else r10 || (yield o8);
  }
  async _fetchChunkInfo(t17, e15, s17) {
    const o8 = t17.subscription.tile.getQuantizationParameters(), r10 = this._queryInfo.createTileQuery(e15, { returnExceededLimitFeatures: s17 === a7, quantizationParameters: o8 });
    return { reader: await this._fetch(r10, t17.options, { chunkId: e15.id }), queryJSON: r10.inner.toJSON(), tile: t17.subscription.tile, sourceTile: e15, sourceTileDepth: s17 };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/PagedTileSourceChunk.js
var t14 = class extends i10 {
  constructor(e15, t17, i21, r10, s17) {
    super(), this._reader = e15, this._queryJSON = t17, this._tile = i21, this._page = r10, this._end = s17, this.chunkId = `${this._tile.key.id}.${this._page}${this.end ? "e" : ""}`, this.normalizedChunkId = `${this._tile.key.normalizedId}.${this._page}${this.end ? "e" : ""}`;
  }
  get queryInfo() {
    return { type: "paged-tile", chunkId: this.chunkId, tileId: this._tile.key.id, queryJSON: this._queryJSON, page: this._page, size: this.size(), end: this.end };
  }
  get reader() {
    return this._reader;
  }
  get first() {
    return 0 === this._page;
  }
  get end() {
    return this._end;
  }
  get page() {
    return this._page;
  }
  get tile() {
    return this._tile;
  }
  get isTiled() {
    return true;
  }
  getTileReader(e15) {
    return this._tile.key.id === e15.key.id ? this.reader : null;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/FeaturePagedTileLoadStrategy.js
var l10 = class {
  constructor(t17, o8) {
    this.subscription = t17, this._pages = /* @__PURE__ */ new Set(), this._controller = new AbortController(), this._done = false, this._handles = t2([w(t17.signal, () => this._controller.abort()), w(o8, () => this._controller.abort())]);
  }
  destroy() {
    this._controller.abort(), this._handles.remove();
  }
  get pageStart() {
    let e15 = -1;
    for (const t17 of this._pages.values()) e15 = Math.max(e15, t17);
    return e15 + 1;
  }
  get done() {
    return this._done;
  }
  get options() {
    return { signal: this._controller.signal };
  }
  add(e15, t17) {
    this._pages.add(e15), this._done = this._done || t17;
  }
};
var c7 = class extends s15 {
  constructor() {
    super(...arguments), this._loadStates = /* @__PURE__ */ new Map();
  }
  destroy() {
    super.destroy();
    for (const e15 of this._loadStates.values()) e15.destroy();
    this._loadStates.clear();
  }
  get about() {
    return { willQueryAllFeatures: false, willQueryFullResolutionGeometry: false };
  }
  async load(e15) {
    const o8 = e(this._loadStates, e15.key.id, () => new l10(e15, this._options));
    for await (const t17 of this._fetchPages(o8)) this._addChunk(t17);
  }
  unload(e15) {
    super.unload(e15), this._loadStates.get(e15.key.id)?.destroy(), this._loadStates.delete(e15.key.id);
  }
  async *_fetchPages(e15) {
    let t17;
    try {
      for await (const t18 of this._concurrentPageStream(e15)) s2(e15.options), 0 !== t18.size() && (yield t18);
    } catch (r10) {
      t17 = r10;
    }
    if (t17 && d(t17) || (yield new t14(u7.empty(this.metadata), null, e15.subscription.tile, -1, true)), t17) throw t17;
  }
  async *_concurrentPageStream(e15) {
    const t17 = has("featurelayer-query-tile-concurrency"), o8 = this._pageStreamAll(e15), s17 = [];
    let r10 = false, a9 = 1;
    for (; !r10; ) {
      const e16 = [];
      for (; !r10 && s17.length < a9; ) {
        const t18 = o8.next();
        if (!t18.value) {
          r10 = true;
          break;
        }
        const a10 = t18.value;
        a10.then((e17) => {
          e17.reader.exceededTransferLimit || (r10 = true);
        }).catch((e17) => {
          r10 = true;
        }).finally(() => {
          s17.splice(s17.indexOf(a10), 1);
        }), s17.push(a10), e16.push(a10);
      }
      for (const t18 of e16) yield t18;
      s17.length && await Promise.race(s17), a9 < t17 && (a9 += 1);
    }
  }
  *_pageStreamAll(e15) {
    const t17 = Math.ceil(has("featurelayer-query-tile-max-features") / this._queryInfo.pageSize);
    for (let o8 = 0; o8 < t17; o8++) yield this._downloadPage(o8, e15);
  }
  async _downloadPage(e15, t17) {
    s2(t17.options);
    const s17 = t17.subscription.tile, r10 = this._queryInfo.createPagedTileQuery(s17, e15), a9 = await this._fetch(r10, t17.options, { chunkId: `${s17.id}-${e15}` });
    return s2(t17.options), new t14(a9, r10.inner.toJSON(), s17, e15, false);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/FeatureSnapshotLoadStrategy.js
var i19 = class extends l8 {
  constructor(e15, t17, r10) {
    super(e15, t17, r10);
  }
  get about() {
    return { willQueryAllFeatures: true, willQueryFullResolutionGeometry: true };
  }
  load(e15) {
    return null == this._promise && (this._promise = this._download()), this._promise;
  }
  unload(e15) {
  }
  async _download() {
    const e15 = this._schema.snapshotInfo.initialTolerance, t17 = e15 ? new m3({ mode: "view", originPosition: "upper-left", tolerance: e15 }) : null;
    await this._downloadStreaming(t17), null != t17 && await this._downloadRefresh();
  }
  async _downloadStreaming(t17) {
    try {
      for await (const e15 of this._fetchPages(t17)) this.store.insert(e15);
    } catch (r10) {
      throw new s("featurelayer-query", "Encountered error when downloading data", { error: r10 });
    }
  }
  async _downloadRefresh() {
    try {
      const e15 = [];
      for await (const t17 of this._fetchPages(null)) e15.push(t17);
      this.store.clear();
      for (const t17 of e15) this.store.insert(t17);
      this.store.refresh();
    } catch (t17) {
      throw new s("featurelayer-query", "Encountered error when downloading data", { error: t17 });
    }
  }
  async *_fetchPages(e15) {
    let r10;
    try {
      for await (const t17 of this._concurrentPageStream(e15)) 0 !== t17.size() && (yield t17);
    } catch (o8) {
      r10 = o8;
    }
    if (r10 && d(r10) || (yield new t5(u7.empty(this.metadata), null, -1, true)), r10) throw r10;
  }
  async *_concurrentPageStream(e15) {
    const t17 = has("featurelayer-snapshot-concurrency"), r10 = this._pageStreamAll(e15), o8 = [];
    let a9 = false, s17 = 1;
    for (; !a9; ) {
      const e16 = [];
      for (; !a9 && o8.length < s17; ) {
        const t18 = r10.next();
        if (!t18.value) {
          a9 = true;
          break;
        }
        const s18 = t18.value;
        s18.then((e17) => {
          e17.reader.exceededTransferLimit || (a9 = true);
        }).catch((e17) => {
          a9 = true;
        }).finally(() => {
          o8.splice(o8.indexOf(s18), 1);
        }), o8.push(s18), e16.push(s18);
      }
      for (const t18 of e16) yield t18;
      o8.length && await Promise.race(o8), s17 < t17 && (s17 += 1);
    }
  }
  *_pageStreamAll(e15) {
    const t17 = Math.ceil(this._schema.snapshotInfo.maxFeatureCount / this._queryInfo.pageSize);
    for (let r10 = 0; r10 < t17; r10++) yield this._downloadPage(r10, e15);
  }
  async _downloadPage(e15, t17) {
    s2(this._options);
    const o8 = this._queryInfo.createPagedQuery(e15, t17), a9 = await this._fetch(o8, this._options, { chunkId: e15.toString() }), n12 = new t5(a9, o8.inner.toJSON(), e15, false);
    return s2(this._options), n12;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/ParquetSnapshotLoadStrategy.js
var u11 = class extends e14 {
  constructor(e15, s17, t17) {
    super(e15.metadata, s17, t17), this._service = e15, this._chunkId = 0, this._files = /* @__PURE__ */ new Map();
  }
  destroy() {
    super.destroy();
    for (const e15 of this._files.values()) e15.free();
    this._files.clear();
  }
  get about() {
    return { willQueryAllFeatures: true, willQueryFullResolutionGeometry: true };
  }
  get availableFields() {
    return this._schema.partial.availableFields;
  }
  get definitionExpression() {
    return this._schema.full.definitionExpression;
  }
  async tryUpdate(t17, i21) {
    if (i(this.availableFields, i21.availableFields) && await this._updateFields(i21.availableFields), i(this._schema.partial.urls, i21.urls)) {
      for (const e15 of i21.urls) this._files.has(e15) || await this._insert(e15);
      for (const s17 of this._files.keys()) if (!i21.urls.includes(s17)) throw new s("unsupported", "Removing parquet files is not supported", { previous: this._schema.partial.urls, next: i21.urls });
    }
    return this._schema.partial = i21, true;
  }
  async load(e15) {
    return null == this._promise && (this._promise = this._download()), this._promise;
  }
  unload(e15) {
  }
  _onOverride() {
  }
  async _updateFields(e15) {
    await this._promise;
    const s17 = new Set(e15), t17 = i3(s17, new Set(this.availableFields)), r10 = this._fieldsIndex;
    if (null == r10) return;
    const a9 = Array.from(t17).map((e16) => r10.get(e16)?.column);
    if (t17.size) for (const i21 of this._files.values()) await i21.ensureFields(new Uint32Array(a9));
  }
  async _insert(e15) {
    const s17 = await d4(e15, { geometryInfo: this._service.geometryInfo, outSpatialReference: this._service.outSpatialReference, getCustomParameters: () => this._schema.full.customParameters }), i21 = this._files.size;
    this._files.set(e15, s17), s2(this._options);
    const o8 = s17.fields().map((e16) => ({ name: e16.name, alias: e16.name, type: e16.type, column: s17.columnForFieldName(e16.name) })), { timeZoneByFieldName: n12 } = this._service.metadata.fieldsIndex, u12 = Z.fromJSON({ fields: o8, timeZoneByFieldName: n12 });
    this._fieldsIndex = u12;
    const h7 = new Uint32Array(Array.from(this.availableFields.values()).map((e16) => u12.get(e16)?.column).filter((e16) => null != e16));
    await s17.readAllChunks(h7, this._signal, (e16) => {
      if (this._signal.aborted) return;
      const s18 = this._chunkId++, t17 = new i11(this.metadata, u12, e16, s18, i21), r10 = new t5(t17, null, s18, false);
      this.store.insert(r10);
    });
  }
  async _download() {
    try {
      await Promise.all(this._schema.partial.urls.map((e16) => this._insert(e16)));
      const e15 = new t5(u7.empty(this.metadata), null, -1, true);
      this.store.insert(e15);
    } catch (e15) {
      throw console.error(e15), e15;
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/ParquetSourceChunk.js
var i20 = class extends i10 {
  constructor(e15, t17, r10, i21, s17) {
    super(), this._metadata = e15, this._reader = t17, this._tile = r10, this._page = i21, this._end = s17, this.chunkId = `${this._tile.key.id}.${this._page}${this.end ? "e" : ""}`, this.normalizedChunkId = `${this._tile.key.normalizedId}.${this._page}${this.end ? "e" : ""}`;
  }
  get reader() {
    return this._reader ?? u7.empty(this._metadata);
  }
  get first() {
    return 0 === this._page;
  }
  get end() {
    return this._end;
  }
  get tile() {
    return this._tile;
  }
  get queryInfo() {
    return { type: "parquet", chunkId: this.chunkId, queryJSON: null, page: this._page, size: this.size(), tileId: this._tile.id, end: this.end };
  }
  get isTiled() {
    return true;
  }
  getTileReader(e15) {
    if (this._tile.key.id === e15.key.id) {
      const r10 = [];
      for (let e16 = 0; e16 < this.reader.getSize(); e16++) r10.push(e16);
      const i21 = d3.from(this.reader, r10);
      return i21.setTransformForDisplay(e15.transform), i21;
    }
    return null;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/ParquetTileLoadStrategy.js
var y7 = class extends e14 {
  constructor(e15, t17, i21) {
    if (super(e15.metadata, t17, i21), this._files = [], !e15.geometryInfo.displayOptimization) throw new Error("InternalError: ParquetTileLoadStrategy only supports XZ-enabled parquet files");
    this._index = _5.create(t17.partial.urls, this.metadata, e15, new Set(t17.partial.availableFields), this.store, () => t17.full.customParameters);
  }
  destroy() {
    super.destroy();
    for (const e15 of this._files) e15.free();
  }
  get about() {
    return { willQueryAllFeatures: true, willQueryFullResolutionGeometry: true };
  }
  get availableFields() {
    return this._schema.partial.availableFields;
  }
  get definitionExpression() {
    return this._schema.full.definitionExpression;
  }
  async tryUpdate(t17, i21) {
    return i(this.availableFields, i21.availableFields) && await this._updateFields(i21.availableFields), this._schema.partial = i21, true;
  }
  async load(e15) {
    const t17 = await this._index;
    await t17.ensureLoaded(e15);
  }
  unload(e15) {
    this._index.then((t17) => t17.unload(e15.tile));
  }
  _onOverride() {
  }
  async _updateFields(e15) {
    return (await this._index).updateFields(e15);
  }
};
var _5 = class __ {
  static async create(e15, t17, i21, a9, s17, r10) {
    const n12 = await Promise.all(e15.map((e16) => d4(e16, { geometryInfo: i21.geometryInfo, outSpatialReference: i21.outSpatialReference, getCustomParameters: r10 })));
    if (1 !== n12.length) throw new Error("InternalError: experimental parquet XZ display optimization only supports a single file.");
    const [o8] = n12, l11 = o8.fields().map((e16) => ({ name: e16.name, alias: e16.name, type: e16.type, column: o8.columnForFieldName(e16.name) })), { timeZoneByFieldName: d10 } = i21.metadata.fieldsIndex, h7 = Z.fromJSON({ fields: l11, timeZoneByFieldName: d10 }), p4 = new Uint32Array(Array.from(a9.values()).map((e16) => h7.get(e16)?.column).filter((e16) => null != e16)), f7 = i21.geometryInfo.displayOptimization;
    if (!f7) throw new Error("InternalError: tiled parquet load requires display optimization");
    return new __(t17, await Promise.all(n12), h7, p4, s17, a9, f7);
  }
  constructor(e15, i21, a9, s17, r10, n12, o8) {
    this._metadata = e15, this._files = i21, this._fieldsIndex = a9, this._fieldIndices = s17, this._store = r10, this._availableFields = n12, this._displayOptimization = o8, this.fileIndex = 0, this._queue = new _({ concurrency: o7, process: (e16) => this._ensureLoaded(e16) }), this._tileIdToChunkId = /* @__PURE__ */ new Map();
  }
  get file() {
    return this._files[0];
  }
  async ensureLoaded(e15) {
    return this._queue.push(e15);
  }
  unload(e15) {
    const t17 = this._tileIdToChunkId.get(e15.id);
    if (null != t17) {
      for (const e16 of t17) this._store.removeById(e16);
      this._tileIdToChunkId.delete(e15.id);
    }
  }
  async _ensureLoaded(e15) {
    const t17 = this._metadata.outSpatialReference, i21 = e15.tile, { xmin: a9, ymin: s17, xmax: r10, ymax: n12 } = x3(i21.extent, t17);
    let o8 = 0;
    const l11 = { extent: i21.extent, extent_lat_lng: { xmin: a9, ymin: s17, xmax: r10, ymax: n12 }, tile_level: i21.level, attributes: this._fieldIndices };
    if ("z" === this._displayOptimization.mode ? await this.file.queryZChunks(l11.extent_lat_lng, this._fieldIndices, e15.signal, (t18) => {
      if (e15.signal.aborted) return;
      const a10 = new i11(this._metadata, this._fieldsIndex, t18, o8, this.fileIndex), s18 = new i20(this._metadata, a10, i21, o8++, false);
      this._insertChunk(i21, s18);
    }) : await this.file.queryXZChunks(l11, e15.signal, (t18) => {
      if (e15.signal.aborted) return;
      const a10 = new i11(this._metadata, this._fieldsIndex, t18, o8, this.fileIndex), s18 = new i20(this._metadata, a10, i21, o8++, false);
      this._insertChunk(i21, s18);
    }), e15.signal.aborted) return;
    const d10 = new i20(this._metadata, null, i21, o8++, true);
    this._insertChunk(i21, d10);
  }
  _insertChunk(e15, t17) {
    let i21 = this._tileIdToChunkId.get(e15.id);
    null == i21 && (i21 = [], this._tileIdToChunkId.set(e15.id, i21)), i21.push(t17.chunkId), this._store.insert(t17);
  }
  async updateFields(e15) {
    const t17 = new Set(e15), s17 = i3(t17, this._availableFields);
    if (this._availableFields = u2(s17, this._availableFields), s17.size) for (const i21 of this._files) {
      const e16 = Array.from(s17).map((e17) => this._fieldsIndex.get(e17)?.column);
      await i21.ensureFields(new Uint32Array(e16));
    }
  }
};
function x3(e15, t17) {
  const i21 = [e15.xmin, e15.ymin, e15.xmax, e15.ymax], a9 = P.fromExtent(c(i21, t17)), m10 = g(a9, t17, f.WGS84);
  if (!m10) return null;
  const u12 = X(new e3(), m10, false, false), h7 = u12.coords.filter((e16, t18) => !(t18 % 2)), p4 = u12.coords.filter((e16, t18) => t18 % 2);
  return { xmin: Math.min(...h7), ymin: Math.min(...p4), xmax: Math.max(...h7), ymax: Math.max(...p4) };
}

// node_modules/@arcgis/core/layers/graphics/data/StreamFeatureManager.js
var d9 = 1e3;
var a8 = class {
  constructor(t17, s17, r10, o8, d10 = 128) {
    if (this._trackIdToObservations = /* @__PURE__ */ new Map(), this._idCounter = 0, this._lastPurge = performance.now(), this._addOrUpdated = /* @__PURE__ */ new Map(), this._removed = [], this._maxAge = 0, this._timeInfo = r10, this._purgeOptions = o8, this.store = t17, "unique-id-composite" === s17.type) throw new s("stream-layer", "composite uniqueIds are not supported");
    this.idField = s17.fieldName, this.purgeInterval = d10, this._useGeneratedIds = this.idField === _2;
  }
  removeById(t17) {
    this._removed.push(t17);
  }
  removeByTrackId(t17) {
    const e15 = this._trackIdToObservations.get(t17);
    if (e15) for (const s17 of e15.entries) this._removed.push(s17);
  }
  add(e15) {
    if (this._useGeneratedIds) {
      const t17 = this._nextId();
      e15.attributes[this.idField] = t17, e15.objectId = t17;
    } else e15.objectId = e15.attributes[this.idField];
    const i21 = e15.objectId;
    if (this._addOrUpdated.set(i21, e15), this._maxAge = Math.max(this._maxAge, e15.attributes[this._timeInfo.startTimeField]), !this._timeInfo.trackIdField) return null == this._trackIdLessObservations && (this._trackIdLessObservations = new t6(1e5)), void this._trackIdLessObservations.enqueue(i21);
    const r10 = e15.attributes[this._timeInfo.trackIdField];
    if (!this._trackIdToObservations.has(r10)) {
      const e16 = null != this._purgeOptions?.maxObservations ? this._purgeOptions.maxObservations : d9, i22 = r(e16, 0, d9);
      this._trackIdToObservations.set(r10, new t6(i22));
    }
    const o8 = this._trackIdToObservations.get(r10), a9 = o8?.enqueue(i21);
    null != a9 && (this._addOrUpdated.has(a9) ? this._addOrUpdated.delete(a9) : this._removed.push(a9));
  }
  checkForUpdates() {
    const t17 = this._getToAdd(), e15 = this._getToRemove(), s17 = performance.now(), i21 = s17 - this._lastPurge, d10 = Date.now();
    i21 >= this.purgeInterval && (this._purge(s17), this._lastPurge = s17);
    const a9 = [];
    if (null != e15) for (const r10 of e15) {
      const t18 = this.store.removeById(r10);
      null != t18 && a9.push(t18);
    }
    const n12 = [];
    if (null != t17) {
      const i22 = new Set(e15 ?? []);
      for (const e16 of t17) i22.has(e16.objectId) || (e16.attributes[e4] = s17, e16.attributes[i6] = d10, this.store.add(e16), n12.push(e16));
    }
    return !(!n12.length && !a9?.length) && (this.store.update(n12, a9), true);
  }
  _getToAdd() {
    if (!this._addOrUpdated.size) return null;
    const t17 = new Array(this._addOrUpdated.size);
    let e15 = 0;
    return this._addOrUpdated.forEach((s17) => t17[e15++] = s17), this._addOrUpdated.clear(), t17;
  }
  _getToRemove() {
    const t17 = this._removed;
    return this._removed.length ? (this._removed = [], t17) : null;
  }
  _nextId() {
    const t17 = this._idCounter;
    return this._idCounter = (this._idCounter + 1) % 4294967294 + 1, t17;
  }
  _purge(t17) {
    const e15 = this._purgeOptions;
    null != e15 && (this._purgeSomeByDisplayCount(e15), this._purgeByAge(e15), this._purgeByAgeReceived(t17, e15), this._purgeTracks());
  }
  _purgeSomeByDisplayCount(t17) {
    if (!t17.displayCount) return;
    let e15 = this.store.size;
    if (e15 > t17.displayCount) {
      if (this._timeInfo.trackIdField) {
        for (const s17 of this._trackIdToObservations.values()) if (e15 > t17.displayCount && s17.size) {
          const t18 = s17.dequeue();
          this._removed.push(t18), e15--;
        }
      }
      if (null != this._trackIdLessObservations) {
        let s17 = e15 - t17.displayCount;
        for (; s17-- > 0; ) {
          const t18 = this._trackIdLessObservations.dequeue();
          null != t18 && this._removed.push(t18);
        }
      }
    }
  }
  _purgeByAge(t17) {
    const e15 = this._timeInfo?.startTimeField;
    if (!t17.age || !e15) return;
    const s17 = 60 * t17.age * 1e3, i21 = this._maxAge - s17;
    this.store.forEach((t18) => {
      t18.attributes[e15] < i21 && this._removed.push(t18.objectId);
    });
  }
  _purgeByAgeReceived(t17, e15) {
    if (!e15.ageReceived) return;
    const s17 = t17 - 60 * e15.ageReceived * 1e3;
    this.store.forEach((t18) => {
      t18.attributes[e4] < s17 && this._removed.push(t18.objectId);
    });
  }
  _purgeTracks() {
    this._trackIdToObservations.forEach((t17, e15) => {
      0 === t17.size && this._trackIdToObservations.delete(e15);
    });
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/StreamConnectionState.js
var s16 = class extends b {
  constructor(r10) {
    super(r10);
  }
  get connectionStatus() {
    return this.connection?.connectionStatus;
  }
  get errorString() {
    return this.connection?.errorString;
  }
};
__decorate([m()], s16.prototype, "connection", void 0), __decorate([m()], s16.prototype, "connectionStatus", null), __decorate([m()], s16.prototype, "errorString", null), s16 = __decorate([a("esri.views.2d.layers.features.sources.StreamConnectionState")], s16);

// node_modules/@arcgis/core/views/2d/layers/features/sources/StreamFeatureStore.js
var t15 = class {
  constructor(e15, t17) {
    this._metadata = e15, this._onUpdate = t17, this._objectIdToFeature = /* @__PURE__ */ new Map();
  }
  get size() {
    return this._objectIdToFeature.size;
  }
  get reader() {
    return u7.fromFeatures([...this._objectIdToFeature.values()], this._metadata);
  }
  add(e15) {
    this._objectIdToFeature.set(e15.objectId, e15);
  }
  forEach(e15) {
    this._objectIdToFeature.forEach(e15);
  }
  removeById(e15) {
    const t17 = this._objectIdToFeature.get(e15);
    return t17 ? (this._objectIdToFeature.delete(e15), t17) : null;
  }
  clear() {
    this._objectIdToFeature = /* @__PURE__ */ new Map();
  }
  update(e15, t17) {
    this._onUpdate(e15?.length ?? 0);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/StreamSourceChunk.js
var r9 = class extends i10 {
  constructor(e15) {
    super(), this._reader = e15, this.chunkId = "stream-chunk", this.normalizedChunkId = "stream-chunk";
  }
  get reader() {
    return this._reader;
  }
  get first() {
    return true;
  }
  get end() {
    return true;
  }
  get queryInfo() {
    return { type: "stream", chunkId: this.chunkId, size: this.size(), end: this.end };
  }
  get isTiled() {
    return false;
  }
  getTileReader(e15) {
    const r10 = this.queryFeaturesInBounds(e15.bounds);
    return r10.setTransformForDisplay(e15.transform), r10;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/StreamLoadStrategy.js
var m8 = class extends e14 {
  constructor(t17, s17, n12) {
    super(t17.metadata, s17, n12), this._service = t17, this._connectionState = new s16(), this._forceRefresh = false, this.events = new i4();
    const { timeInfo: c8 } = this.metadata, { purgeOptions: h7 } = s17.full;
    this._stagingStore = new t15(this.metadata.weakCloneWithAdditionalFields([{ name: i6, alias: "timeReceived", type: "esriFieldTypeDate" }]), (e15) => this.events.emit("features-updated", e15)), this._manager = new a8(this._stagingStore, this.metadata.featureIdInfo, c8, h7), this.connect();
  }
  destroy() {
    super.destroy(), this.disconnect();
  }
  get about() {
    return { willQueryAllFeatures: false, willQueryFullResolutionGeometry: false };
  }
  get connectionStatus() {
    return this._connectionState.connectionStatus;
  }
  get errorString() {
    return this._connectionState?.errorString;
  }
  get availableFields() {
    return this._schema.full.availableFields;
  }
  get definitionExpression() {
    return this._schema.full.definitionExpression;
  }
  async tryUpdate(e15, t17) {
    const s17 = null != this._chunk;
    if (t17.sourceRefreshVersion !== this._refreshVersion) {
      if (this._refreshVersion = t17.sourceRefreshVersion, !this._manager.checkForUpdates() && s17 && !this._forceRefresh) return this.events.emit("tick"), true;
      this._chunk && (this.store.remove(this._chunk), e15.requireInvalidation()), this._forceRefresh = false, this._chunk = new r9(this._stagingStore.reader), this.store.insert(this._chunk), this.events.emit("tick");
    }
    return this._schema.partial = t17, true;
  }
  async load(e15) {
  }
  unload(e15) {
  }
  disconnect() {
    this._streamConnection = u(this._streamConnection), this._connectionState.connection = null, this._handlesGroup?.remove();
  }
  connect() {
    if (null != this._streamConnection) return;
    const { geometryType: e15, spatialReference: s17 } = this.metadata, { maxReconnectionAttempts: i21, maxReconnectionInterval: r10, geometryDefinition: o8, definitionExpression: a9, customParameters: c8 } = this._schema.full;
    this._streamConnection = r5(this._service.source, s17, this._service.outSpatialReference, e15, a9, o8, i21, r10, c8), this._handlesGroup = t2([this._streamConnection.on("data-received", (e16) => this._onFeature(e16)), this._streamConnection.on("message-received", (e16) => this._onWebSocketMessage(e16))]), this._connectionState.connection = this._streamConnection;
  }
  clear() {
    this._manager.checkForUpdates(), this._stagingStore.clear(), this._forceRefresh = true;
  }
  updateCustomParameters(e15) {
    this._streamConnection?.updateCustomParameters(e15);
  }
  sendMessageToSocket(e15) {
    this._streamConnection?.sendMessageToSocket(e15);
  }
  sendMessageToClient(e15) {
    this._streamConnection?.sendMessageToClient(e15);
  }
  _onOverride() {
  }
  _onWebSocketMessage(e15) {
    if ("type" in e15) switch (e15.type) {
      case "delete":
        if (e15.objectIds) for (const t17 of e15.objectIds) this._manager.removeById(t17);
        if (e15.trackIds) for (const t17 of e15.trackIds) this._manager.removeByTrackId(t17);
        break;
      case "clear":
        this.clear();
    }
    this.events.emit("message-received", e15);
  }
  _onFeature(e15) {
    try {
      this._manager.add(e15), this.events.emit("data-received", e15);
    } catch (t17) {
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureSource.js
var _6 = class {
  constructor(e15, t17, r10, s17) {
    this._aggregateAdapter = e15, this._subscriptions = t17, this._connection = r10, this._cachedObjectIds = s17, this._updateTracking = new n7({ debugName: "FeatureSource" }), this.store = new n6();
  }
  destroy() {
    this._strategy?.destroy(), this._streamMessenger?.destroy(), this._updateTracking?.destroy(), this.store.destroy();
  }
  get metadata() {
    return this._strategy.metadata;
  }
  get streamMessenger() {
    return null == this._streamMessenger && this._initStreamMessenger(), this._streamMessenger;
  }
  get statistics() {
    return t12.from(this.store);
  }
  get updateTracking() {
    return this._updateTracking;
  }
  get usedMemory() {
    return this.store.usedMemory;
  }
  get queryEngine() {
    if (!this._queryEngine) {
      if (!this.store || !this._strategy) return null;
      this._queryEngine = new W({ featureStore: this.store, fieldsIndex: this.metadata.fieldsIndex, geometryType: this.metadata.geometryType, featureIdInfo: this.metadata.featureIdInfo, hasM: false, hasZ: false, spatialReference: this.metadata.outSpatialReference, aggregateAdapter: this._aggregateAdapter, timeInfo: this.metadata.timeInfo, definitionExpression: this._strategy?.definitionExpression, availableFields: this._strategy?.availableFields });
    }
    return this._queryEngine;
  }
  get isStream() {
    return "stream" === this._schema.type;
  }
  get hasQueryDisplayFilter() {
    if (!this._schema) return false;
    switch (this._schema.type) {
      case "feature":
        return null != this._schema.strategy.full.displayFilterInfo;
      case "parquet":
      case "stream":
        return false;
    }
  }
  chunks() {
    return Array.from(this.store.chunks());
  }
  prepareCacheUpdate(e15, t17) {
    const r10 = /* @__PURE__ */ new Set(), s17 = /* @__PURE__ */ new Set();
    for (const a9 of e15) this._cachedObjectIds.has(a9) || (this._cachedObjectIds.add(a9), r10.add(a9));
    for (const a9 of t17) this._cachedObjectIds.delete(a9), s17.add(a9);
    this.hasQueryDisplayFilter && this._strategy.prepareCacheUpdate(r10, s17);
  }
  async applyCacheUpdate() {
    this.hasQueryDisplayFilter && await this._updateTracking.addPromise(this._strategy.applyCacheUpdate());
  }
  cleanup() {
    return this.store.cleanup();
  }
  onSubscribe(e15) {
    if (this._connection.onEvent({ type: "subscribe", tile: e15.tile.id }), !this._strategy) return;
    const t17 = this._strategy.load(e15);
    t17.then(() => this._connection.onEvent({ type: "loaded", tile: e15.tile.id })).catch((t18) => this._connection.onEvent({ type: "error", tile: e15.tile.id, error: t18 })), this._updateTracking.addPromise(t17);
  }
  onResume(e15) {
    this._updateTracking.addPromise(y(this._strategy?.load(e15)));
  }
  onUnsubscribe(e15) {
    this._connection.onEvent({ type: "unsubscribe", tile: e15.tile.id }), this._strategy?.unload(e15);
  }
  async applyOverride(e15) {
    await this._strategy?.applyOverride(e15);
  }
  takeOverrideUpdate() {
    return this._strategy?.takeOverrideUpdate();
  }
  async update(r10, s17) {
    const a9 = this._schema;
    if (this._schema = r10, this._queryEngine = u(this._queryEngine), a9 && a9.type !== r10.type) throw new Error("InternalError: Reconfiguring source types is not supported.");
    const i21 = new r8();
    return !a9 || i(a9.service, r10.service) || a9.strategy.type !== r10.strategy.type || i(r10.strategy.full, a9.strategy.full) || !await this._strategy.tryUpdate(i21, r10.strategy.partial) ? (await this._updateStrategyType(this._schema.service, r10, s17), await this.store.update({ metadata: this.metadata, definitionExpression: this._schema.strategy.full.definitionExpression }), true) : i21.requiresInvalidation;
  }
  unsafeSetQueryHistoricMoment(e15) {
    "feature" === this._schema.type && (this._schema.strategy.full.historicMoment = e15, this._strategy.unsafeSetQueryHistoricMoment(new Date(e15)));
  }
  _initStreamMessenger() {
    null == this._streamMessenger && (this._streamMessenger = new a5(this._connection));
  }
  async normalizeOverrides(e15) {
    const t17 = { historicMoment: e15.historicMoment, commands: { updateWeak: e15.commands.updateWeak.map(s4.fromJSON), removeWeak: e15.commands.removeWeak, update: e15.commands.update.map(s4.fromJSON), remove: e15.commands.remove, release: e15.commands.release } }, r10 = e15.commands.updateByIdWeak, s17 = await this._queryOptimizedFeatures(r10);
    if (s17.length !== r10.length) {
      const e16 = new Set(s17.map((e17) => e17.objectId));
      for (const s18 of r10) e16.has(s18) || t17.commands.removeWeak.push(s18);
    }
    return t17.commands.updateWeak.push(...s17), t17;
  }
  async _queryOptimizedFeatures(e15) {
    if (0 === e15.length) return [];
    const t17 = [], r10 = (await this._strategy.queryByObjectId(e15, ["*"])).getCursor();
    for (; r10.next(); ) t17.push(r10.readOptimizedFeatureWorldSpace());
    return t17;
  }
  getObjectIdsFromGlobalIds(e15) {
    const t17 = this.metadata.globalIdField;
    if (null == t17) throw new Error("InternalError: Recieved an edit with globalIds, but not supported by the service");
    const r10 = this.store.mapObjectIdsFromGlobalIds(e15, t17).values();
    return Array.from(r10);
  }
  async _updateStrategyType(e15, t17, r10) {
    const a9 = this._createStrategy(e15, t17);
    this._connection.onEvent({ type: "updateStrategyStart", about: a9.about });
    const i21 = !!this._strategy;
    this.store.clear(), this._strategy?.destroy(), this._strategy = a9, has("esri-2d-update-debug") && console.debug(`Version[${r10}] FeatureSource.updateStrategy`, { strategy: a9 });
    const n12 = Array.from(this._subscriptions.values());
    if (!n12.length) return void this._connection.onEvent({ type: "updateStrategyEnd" });
    const o8 = Promise.all(n12.map((e16) => this._strategy.load(e16).then(() => this._connection.onEvent({ type: "loaded", tile: e16.tile.id })).catch((t18) => this._connection.onEvent({ type: "error", tile: e16.tile.id, error: t18 }))));
    this._updateTracking.addPromise(o8), this._strategy.prepareCacheUpdate(this._cachedObjectIds);
    try {
      i21 && await o8;
    } catch (c8) {
      m2(c8);
    }
    this._connection.onEvent({ type: "updateStrategyEnd" }), has("esri-2d-update-debug") && console.debug(`Version[${r10}] FeatureSource.updateStrategyEnd`, { strategy: a9 });
  }
  _createStrategy(e15, t17) {
    const r10 = { connection: this._connection, store: this.store };
    switch (t17.type) {
      case "feature":
        return this._createFeatureLoadStrategy(e15, t17.strategy, r10);
      case "parquet":
        return this._createParquetLoadStrategy(e15, t17.strategy, r10);
      case "stream":
        return this._createStreamLoadStrategy(e15, t17.strategy, r10);
    }
  }
  _createFeatureLoadStrategy(e15, t17, r10) {
    switch (t17.type) {
      case "drill-down":
        return new n11(e15, t17, r10);
      case "paged-tile":
        return new c7(e15, t17, r10);
      case "snapshot":
        return new i19(e15, t17, r10);
    }
  }
  _createParquetLoadStrategy(e15, t17, r10) {
    switch (t17.type) {
      case "xz":
        return new y7(e15, t17, r10);
      case "snapshot":
        return new u11(e15, t17, r10);
    }
  }
  _createStreamLoadStrategy(e15, t17, r10) {
    const s17 = new m8(e15, t17, r10);
    return this.streamMessenger.strategy = s17, s17;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureTileSubscription.js
var t16 = class {
  constructor(t17, r10) {
    this.tile = t17, this.version = r10, this._abortController = new AbortController();
  }
  get key() {
    return this.tile.key;
  }
  get signal() {
    return this._abortController.signal;
  }
  abort() {
    this._abortController.abort();
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/FeaturePipelineWorker.js
var m9 = class {
  constructor(e15) {
    this.inner = e15, this.resolver = $();
  }
};
var y8 = class {
  constructor() {
    this._aggregateAdapter = { getFeatureObjectIds: (e15) => this._processor.getFeatureObjectIdsForAggregate(e15) }, this._subscriptions = /* @__PURE__ */ new Map(), this._cachedObjectIds = /* @__PURE__ */ new Set(), this._updateRequested = false, this._didSourceRefresh = false, this._updateSubscriptionRequests = [], this._updateHighlightRequests = [];
  }
  destroy() {
    this._subscriptions.clear(), this._processor?.destroy(), this._source?.destroy(), this._handles?.remove(), this._updateOverridesRequest = null, this._tileInfoView = null;
  }
  onAttach(e15) {
    has("esri-2d-update-debug") && console.debug("Pipeline.onAttach");
    const s17 = this._connection, i21 = z.fromJSON(e15.tileInfoJSON);
    this._tileInfoView = new h2(i21), this._source = new _6(this._aggregateAdapter, this._subscriptions, s17, this._cachedObjectIds), this._processor = new b5(s17, this._source), this._handles = t2([this._source.store.events.on("changed", () => this._requestUpdate()), this._source.store.events.on("refresh", () => this._requestRefresh()), l(() => this._source.updateTracking.updating, () => {
      this._requestUpdate(), y(this._connection.layerView.setUpdating({ source: this._source.updateTracking.updating, pipeline: true }));
    })]);
  }
  onDetach() {
    has("esri-2d-update-debug") && console.debug("Pipeline.onDetach"), this.destroy();
  }
  set remoteClient(e15) {
    this._connection = new t7(e15);
  }
  get features() {
    const t17 = this._source?.queryEngine;
    if (!t17) throw new s("no-queryEngine", "No query engine defined");
    return t17;
  }
  get aggregates() {
    const t17 = this._processor?.aggregateQueryEngine;
    if (!t17) throw new s("no-queryEngine", "No aggregate query engine defined");
    return t17;
  }
  get processor() {
    return this._processor;
  }
  get streamMessenger() {
    return this._source.streamMessenger;
  }
  getUsedMemory() {
    return this._source.usedMemory + this._processor.usedMemory;
  }
  getDisplayFeatures(e15) {
    return this._processor.getDisplayFeatures(e15);
  }
  getDisplayIds(e15) {
    return this._processor.getDisplayIds(e15);
  }
  getObjectIdsFromGlobalIds(e15) {
    return this._source.getObjectIdsFromGlobalIds(e15);
  }
  async updateSchema(e15, t17) {
    return has("esri-2d-update-debug") && this._updateSchemaRequest && console.error("InternalError: Schema already updating"), this._updateSchemaRequest = new m9({ schema: e15, version: t17 }), this._requestUpdate(), this._updateSchemaRequest.resolver.promise;
  }
  updateSubscriptions(e15) {
    const t17 = new m9(e15);
    return this._updateSubscriptionRequests.push(t17), this._requestUpdate(), t17.resolver.promise;
  }
  updateHighlight(e15) {
    const t17 = new m9(e15);
    return this._updateHighlightRequests.push(t17), this._requestUpdate(), t17.resolver.promise;
  }
  async onOverride(t17) {
    if (null != this._updateOverridesRequest) throw new s("featurelayer", "InternalError - Already processing an edit");
    this._updateOverridesRequest = new m9(t17);
    const s17 = this._updateOverridesRequest.resolver.promise;
    return this._requestUpdate(), s17;
  }
  queryStatistics() {
    return this._source.statistics.toJSON();
  }
  async queryVisibleFeatures(e15, t17) {
    return this.features.executeQuery(e15, t17);
  }
  async queryHeatmapStatistics(e15) {
    const t17 = Math.round(u3(e15.radius));
    let s17 = Number.POSITIVE_INFINITY, i21 = Number.NEGATIVE_INFINITY;
    const r10 = "string" == typeof e15.fieldOffset, o8 = e15.fieldOffset ?? 0, n12 = Array.from(this._subscriptions.values()), u12 = this._source.chunks(), d10 = t17 ** 2, c8 = 3 / (Math.PI * d10), h7 = 2 * t17, l11 = Math.ceil(o / h7);
    for (const a9 of n12) {
      const t18 = a9.tile, n13 = new Float64Array(l11 * l11);
      for (const s18 of u12) {
        const i22 = s18.getTileReader(t18);
        if (!i22) continue;
        const u13 = i22.getCursor();
        for (; u13.next(); ) {
          let t19 = 1;
          if (null != e15.field) {
            const s20 = u13.readAttribute(e15.field);
            t19 = r10 ? -1 * +s20 : +s20 + o8;
          }
          const s19 = u13.readXForDisplay() / h7, i23 = u13.readYForDisplay() / h7, a10 = Math.floor(s19), p4 = Math.floor(i23);
          if (a10 < 0 || p4 < 0 || a10 >= l11 || p4 >= l11) continue;
          const g5 = ((0.5 + a10 - s19) * h7) ** 2 + ((0.5 + p4 - i23) * h7) ** 2;
          if (g5 > d10) continue;
          const _7 = t19 * (c8 * (1 - g5 / d10) ** 2);
          n13[p4 + a10 * l11] += _7;
        }
      }
      for (let e16 = 0; e16 < n13.length; e16++) s17 = Math.min(s17, n13[e16]), i21 = Math.max(i21, n13[e16]);
    }
    return { max: i21, min: s17 };
  }
  async getSampleFeatures(e15) {
    const t17 = this._source.chunks();
    if (t17.reduce((e16, t18) => e16 + t18.size(), 0) <= e15.minFeatureCount) {
      if (!this._source.updateTracking.updating) {
        const e16 = [];
        return this._source.store.forEachUnsafe((t18) => e16.push(t18.readLegacyFeatureWorldSpace())), e16;
      }
      return null;
    }
    const s17 = /* @__PURE__ */ new Set(), i21 = [], r10 = t17.map((e16) => e16.reader.getCursor()), o8 = new t(), u12 = 3 * e15.sampleSize;
    for (let n12 = 0; n12 < u12 && i21.length < e15.sampleSize; n12++) {
      const e16 = r10[o8.getIntRange(0, t17.length - 1)];
      if (0 === e16.getSize()) continue;
      const n13 = o8.getIntRange(0, e16.getSize() - 1);
      e16.setIndex(n13);
      const u13 = e16.getObjectId();
      s17.has(u13) || (s17.add(u13), i21.push(e16.readLegacyFeatureWorldSpace()));
    }
    return i21.length >= e15.sampleSize ? i21 : null;
  }
  _requestUpdate() {
    this._updateRequested || (this._updateRequested = true, t3(() => this._scheduleNextUpdate()));
  }
  _requestRefresh() {
    this._didSourceRefresh = true, this._requestUpdate();
  }
  _scheduleNextUpdate() {
    this._updateRequested && (this._ongoingUpdate || (this._ongoingUpdate = l2(this._doUpdate()).finally(() => {
      this._ongoingUpdate = null, this._scheduleNextUpdate();
    }), this._updateRequested = false));
  }
  _subscribe(e15) {
    const t17 = e15.tileId;
    if (this._subscriptions.has(t17)) return;
    has("esri-2d-update-debug") && console.debug(`Tile[${t17}] Pipeline.subscribe`);
    const s17 = new r6(this._tileInfoView, t17), i21 = new t16(s17, e15.version);
    this._subscriptions.set(t17, i21), this._source.onSubscribe(i21), this._processor.onSubscribe(i21);
  }
  _unsubscribe(e15) {
    const t17 = this._subscriptions.get(e15);
    t17 && (has("esri-2d-update-debug") && console.debug(`Tile[${e15}] Pipeline.unsubscribe`), t17.abort(), this._source.onUnsubscribe(t17), this._processor.onUnsubscribe(t17), this._subscriptions.delete(t17.key.id));
  }
  async _doUpdate() {
    if (has("esri-2d-update-debug") && console.debug("Pipeline._doUpdateStart"), await this._connection.layerView.setUpdating({ source: this._source.updateTracking.updating, pipeline: true }), this._updateSubscriptionRequests.length) {
      const e16 = this._updateSubscriptionRequests;
      this._updateSubscriptionRequests = [];
      for (const t18 of e16) this._doUpdateSubscriptions(t18.inner), t18.resolver.resolve();
    }
    if (this._updateHighlightRequests.length) {
      const e16 = this._updateHighlightRequests, t18 = /* @__PURE__ */ new Set(), s18 = /* @__PURE__ */ new Set();
      for (const i21 of e16) for (const { objectId: e17, highlightFlags: r11 } of i21.inner.highlights) r11 ? (t18.add(e17), s18.delete(e17)) : (s18.add(e17), t18.delete(e17));
      this._source.prepareCacheUpdate(t18, s18);
    }
    const e15 = this._updateSchemaRequest;
    this._updateSchemaRequest = null;
    let t17 = false;
    if (null != e15) {
      const { schema: s18, version: i21 } = e15.inner;
      t17 = await this._doUpdateSchema(s18, i21);
    }
    this._processor.requiresInvalidation() && (t17 = true), this._didSourceRefresh && (t17 = true, this._didSourceRefresh = false), t17 && (this._processor.invalidate(), await this._connection.container.updateRenderState(this._processor.version));
    const s17 = this._updateOverridesRequest;
    if (this._updateOverridesRequest = null, null != s17) {
      has("esri-2d-update-debug") && console.debug("Pipeline.applyOverride", s17.inner), null != s17.inner.historicMoment && this._source.unsafeSetQueryHistoricMoment(s17.inner.historicMoment);
      const e16 = await this._source.normalizeOverrides(s17.inner);
      await this._source.applyOverride(e16), has("esri-2d-update-debug") && console.debug("Pipeline.endOverride", s17.inner);
    }
    if (await this._source.applyCacheUpdate(), this._updateHighlightRequests.length) {
      const e16 = this._updateHighlightRequests;
      this._updateHighlightRequests = [];
      for (const t18 of e16) this._processor.updateHighlight(t18.inner), t18.resolver.resolve();
    }
    const r10 = this._source.cleanup();
    this._processor.removeChunks(r10);
    try {
      const e16 = this._source.takeOverrideUpdate();
      if (null != e16 && this._subscriptions.size) {
        has("esri-2d-update-debug") && console.debug("Pipeline.applyOverrideChangesStart"), await this._connection.container.lockForOverrides();
        try {
          await this._processor.applyOverrideUpdate(e16);
        } catch (o8) {
          has("esri-2d-update-debug") && console.debug("InternalError", o8);
        }
        await this._connection.container.unlockForOverrides(), has("esri-2d-update-debug") && console.debug("Pipeline.applyOverrideChangesEnd");
      }
      this._subscriptions.size && (has("esri-2d-update-debug") && console.debug("Pipeline.updateChunksStart"), await this._processor.updateChunks(), has("esri-2d-update-debug") && console.debug("Pipeline.updateChunksEnd"));
    } catch (o8) {
      m2(o8);
    }
    null != s17 && s17.resolver.resolve(), null != e15 && e15.resolver.resolve(), null == e15 && t17 && await this._connection.container.trySwapRenderState(), this._connection.onEvent({ type: "performance", usedMemory: this.getUsedMemory() }), this._updateRequested ? (has("esri-2d-update-debug") && console.debug("Pipeline._doUpdateEnd [updateRequested=true]"), await this._connection.layerView.setUpdating({ source: this._source.updateTracking.updating, pipeline: true })) : (has("esri-2d-update-debug") && console.debug("Pipeline._doUpdateEnd [updateRequested=false, After flush]"), await this._connection.layerView.setUpdating({ source: this._source.updateTracking.updating, pipeline: this._updateRequested }));
  }
  async _doUpdateSchema(e15, t17) {
    has("esri-2d-update-debug") && console.debug(`Version[${t17}] Pipeline.updateStart`, { schema: e15 });
    const s17 = { tileInfo: this._tileInfoView?.tileInfo }, i21 = await this._source.update(e15.source, t17), r10 = Array.from(this._subscriptions.values()), o8 = this._processor.update(e15, t17, s17, i21, r10);
    return has("esri-2d-update-debug") && console.debug(`Version[${t17}] Pipeline.updateEnd`), o8;
  }
  _doUpdateSubscriptions(e15) {
    has("esri-2d-update-debug") && console.debug("Pipeline.updateSubscriptions", e15);
    for (const t17 of e15.subscribe) this._subscribe(t17);
    for (const t17 of e15.unsubscribe) this._unsubscribe(t17);
  }
};
export {
  y8 as default
};
//# sourceMappingURL=FeaturePipelineWorker-LXLRTXAH.js.map
