import {
  i as i3,
  o as o4
} from "./chunk-UTZXKPS3.js";
import "./chunk-5XYRAKJX.js";
import "./chunk-Y2DYCFJT.js";
import "./chunk-HUA6ZZZG.js";
import "./chunk-TNKZDDMZ.js";
import "./chunk-OL6EYE44.js";
import {
  x
} from "./chunk-36YQJD5W.js";
import "./chunk-BQ6DEXWK.js";
import "./chunk-3SCRAN3E.js";
import "./chunk-NTNXXNRP.js";
import {
  r
} from "./chunk-VIDAPS4J.js";
import {
  P as P2,
  t as t2
} from "./chunk-GD72EK2J.js";
import {
  Z,
  at,
  z as z2
} from "./chunk-2EBLSEHZ.js";
import {
  o as o3
} from "./chunk-A2QKOXAQ.js";
import {
  t
} from "./chunk-ALKEERWI.js";
import "./chunk-JBTWCDRR.js";
import "./chunk-U6CJFTOF.js";
import "./chunk-2JMKFI2D.js";
import "./chunk-QYAMBIRP.js";
import "./chunk-JHV6OBEB.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import "./chunk-4VQDBNTM.js";
import "./chunk-3BNOOWTA.js";
import "./chunk-AIJLLSRB.js";
import "./chunk-VX2NEBRT.js";
import "./chunk-ZCI5A4FF.js";
import "./chunk-2D47RURG.js";
import "./chunk-7HTU7ZUX.js";
import "./chunk-WDTGOP77.js";
import {
  o as o2
} from "./chunk-VYMBX5H5.js";
import {
  h as h3
} from "./chunk-BPTFV5VM.js";
import {
  l as l2,
  z
} from "./chunk-YP3WVJP3.js";
import {
  e as e4
} from "./chunk-M24KZOVI.js";
import "./chunk-647DAMHU.js";
import "./chunk-O6G3PPOK.js";
import "./chunk-ZKNZTIAS.js";
import "./chunk-OJMISN3F.js";
import "./chunk-EFV6H5NA.js";
import {
  E
} from "./chunk-ARTU4L55.js";
import "./chunk-BBYMM7CM.js";
import "./chunk-EM7Y2JZC.js";
import "./chunk-QZQPB5XR.js";
import "./chunk-AQFRVV3U.js";
import "./chunk-XTZAIV4X.js";
import "./chunk-63LDVRFI.js";
import {
  _ as _2
} from "./chunk-C3FRY5U4.js";
import "./chunk-JNJX34GB.js";
import "./chunk-3STJRSDT.js";
import "./chunk-67Q6KVC6.js";
import {
  g as g2,
  i2,
  j2 as j,
  m as m3,
  u as u2
} from "./chunk-23NJHA5Q.js";
import "./chunk-4LA6K4VI.js";
import "./chunk-KEZCWFAR.js";
import {
  m as m2
} from "./chunk-JZUJ34RR.js";
import {
  y as y2
} from "./chunk-PMGS7UDU.js";
import "./chunk-3GHCGAH2.js";
import "./chunk-HWUOAPTX.js";
import "./chunk-QHCKOBU7.js";
import "./chunk-K2OZ6WVC.js";
import "./chunk-MC6NAKKX.js";
import {
  l as l3
} from "./chunk-TF6255HN.js";
import "./chunk-GD4FJL3C.js";
import "./chunk-C5OQVQZF.js";
import "./chunk-F7DKSAOI.js";
import "./chunk-4SOQWNPG.js";
import {
  g
} from "./chunk-LTULADK2.js";
import "./chunk-35ST7YRB.js";
import "./chunk-EDA5QFHZ.js";
import {
  d as d2
} from "./chunk-CNYNCKEV.js";
import {
  d
} from "./chunk-XL5QPCXN.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6KDQMJAI.js";
import "./chunk-UDHS2MGH.js";
import "./chunk-ENINOZUZ.js";
import "./chunk-P6IKJIMO.js";
import "./chunk-MHV23XAQ.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import "./chunk-MA3QDRC3.js";
import "./chunk-W6J7XCPU.js";
import "./chunk-ONXWBTTM.js";
import "./chunk-T7F6Q6JJ.js";
import {
  O
} from "./chunk-YDTPM7OQ.js";
import {
  n
} from "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-7P2ANHQ3.js";
import "./chunk-XCKT47LJ.js";
import "./chunk-3FUHCAX3.js";
import {
  P
} from "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import {
  c as c2,
  e as e3,
  i
} from "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import {
  U,
  a as a2,
  h as h2,
  l,
  w
} from "./chunk-2OFHDVO5.js";
import "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-5UPBUJPC.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import {
  u
} from "./chunk-CCQFL76O.js";
import "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import "./chunk-7H3U4IJR.js";
import {
  o
} from "./chunk-SMWUT52Z.js";
import {
  _
} from "./chunk-AXZMNHTN.js";
import "./chunk-5T3MJDSR.js";
import "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import {
  b,
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import {
  L,
  c,
  e,
  e2,
  s,
  y
} from "./chunk-GNMPGHLQ.js";
import "./chunk-QY7XKUIV.js";
import {
  N,
  h
} from "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/tileUtils.js
function a3(s2, o5) {
  return Z(o5.extent, c3), at(c3, o2(n2, s2.x, s2.y, 0));
}
var c3 = z2();
var n2 = n();

// node_modules/@arcgis/core/views/2d/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTiles2D.js
var p = class extends b {
  get tiles() {
    const e5 = this.tilesCoveringView, t3 = null != this.pointOfInterest ? this.pointOfInterest : this.view.center;
    return e5.sort((e6, i4) => a3(t3, e6) - a3(t3, i4)), e5;
  }
  _scaleEnabled() {
    return r(this.view.scale, this.layer.minScale || 0, this.layer.maxScale || 0);
  }
  get tilesCoveringView() {
    if (!this.view.ready || !this.view.featuresTilingScheme || !this.view.state || null == this.tileInfo) return [];
    if (!this._scaleEnabled) return [];
    const { spans: e5, lodInfo: t3 } = this.view.featuresTilingScheme.getTileCoverage(this.view.state, 0), { level: i4 } = t3, r2 = [];
    for (const { row: o5, colFrom: s2, colTo: n3 } of e5) for (let e6 = s2; e6 <= n3; e6++) {
      const s3 = t3.normalizeCol(e6), n4 = new e4(i4, o5, s3);
      this.tileInfo.updateTileInfo(n4), r2.push(n4);
    }
    return r2;
  }
  get tileInfo() {
    return this.view.featuresTilingScheme?.tileInfo ?? null;
  }
  get tileSize() {
    return null != this.tileInfo ? this.tileInfo.size[0] : 256;
  }
  constructor(e5) {
    super(e5), this.pointOfInterest = null, this.updating = false;
  }
  initialize() {
    this.addHandles(l(() => this.view?.state?.viewpoint, () => this.notifyChange("tilesCoveringView"), U));
  }
};
__decorate([m({ readOnly: true })], p.prototype, "tiles", null), __decorate([m({ readOnly: true })], p.prototype, "_scaleEnabled", null), __decorate([m({ readOnly: true })], p.prototype, "tilesCoveringView", null), __decorate([m({ readOnly: true })], p.prototype, "tileInfo", null), __decorate([m({ readOnly: true })], p.prototype, "tileSize", null), __decorate([m({ constructOnly: true })], p.prototype, "view", void 0), __decorate([m({ constructOnly: true })], p.prototype, "layer", void 0), __decorate([m()], p.prototype, "pointOfInterest", void 0), __decorate([m()], p.prototype, "updating", void 0), p = __decorate([a("esri.views.2d.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiles2D")], p);

// node_modules/@arcgis/core/views/3d/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTiles3D.js
var u3 = class extends b {
  get _sortedTilesCoveringView() {
    const e5 = (this.view.featureTiles?.tiles?.toArray() ?? []).map(a4), t3 = this._effectivePointOfInterest;
    return null != t3 && e5.sort((e6, r2) => a3(t3, e6) - a3(t3, r2)), e5;
  }
  get tileInfo() {
    return this.view.featureTiles?.tilingScheme?.toTileInfo() ?? null;
  }
  get tileSize() {
    return this.view.featureTiles?.tileSize ?? 256;
  }
  get _effectivePointOfInterest() {
    const e5 = this.pointOfInterest;
    return null != e5 ? e5 : this.view.pointsOfInterest?.focus.location;
  }
  get updating() {
    return !this.view.featureTiles;
  }
  constructor(e5) {
    super(e5), this.tiles = [], this.pointOfInterest = null;
  }
  initialize() {
    this.addHandles([this.view.enableFeatureTiles(), l(() => this._sortedTilesCoveringView, (e5) => this._set("tiles", e5), { initial: true, equals: (e5, t3) => h(e5, t3, (e6, t4) => e6.id === t4.id) })]);
  }
};
function a4({ lij: [e5, t3, r2], extent: i4 }) {
  return new e4(e5, t3, r2, i4 ?? i());
}
__decorate([m({ readOnly: true })], u3.prototype, "tiles", void 0), __decorate([m({ readOnly: true })], u3.prototype, "_sortedTilesCoveringView", null), __decorate([m({ readOnly: true })], u3.prototype, "tileInfo", null), __decorate([m({ readOnly: true })], u3.prototype, "tileSize", null), __decorate([m({ constructOnly: true })], u3.prototype, "view", void 0), __decorate([m()], u3.prototype, "pointOfInterest", void 0), __decorate([m()], u3.prototype, "_effectivePointOfInterest", null), __decorate([m()], u3.prototype, "updating", null), u3 = __decorate([a("esri.views.3d.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiles3D")], u3);

// node_modules/@arcgis/core/views/support/TileTreeDebugger.js
var u4 = [[0, 179, 255], [117, 62, 128], [0, 104, 255], [215, 189, 166], [32, 0, 193], [98, 162, 206], [102, 112, 129], [52, 125, 0], [142, 118, 246], [138, 83, 0], [92, 122, 255], [122, 55, 83], [0, 142, 255], [81, 40, 179], [0, 200, 244], [13, 24, 127], [0, 170, 147], [19, 58, 241], [22, 44, 35]];
var d3 = class extends b {
  constructor(e5) {
    super(e5), this.updating = false, this.enablePolygons = true, this.enableLabels = true, this._polygons = /* @__PURE__ */ new Map(), this._labels = /* @__PURE__ */ new Map(), this._symbols = u4.map((e6) => new m2({ color: [e6[0], e6[1], e6[2], 0.6], outline: { color: "black", width: 1 } })), this._enabled = true;
  }
  initialize() {
    this.update();
  }
  destroy() {
    this._enabled = false, this.clear();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e5) {
    this._enabled !== e5 && (this._enabled = e5, this.update());
  }
  update() {
    if (!this._enabled) return void this.clear();
    const e5 = (e6) => {
      if (null != e6.label) return e6.label;
      let o5 = e6.lij.toString();
      return null != e6.loadPriority && (o5 += ` (${e6.loadPriority})`), e6.measures && (o5 += `[${e6.measures.lodLevel}]`), o5;
    }, t3 = this.getTiles(), i4 = new Array(), n3 = new Set(this._labels.size > 0 ? this._labels.keys() : this._polygons.keys());
    t3.forEach((m5, u6) => {
      const d4 = m5.lij.toString();
      n3.delete(d4);
      const g4 = m5.measures?.lodLevel ?? m5.level, f = m5.geometry;
      if (this.enablePolygons && !this._polygons.has(d4)) {
        const e6 = m5.polygonSymbol ?? this._symbols[g4 % this._symbols.length], o5 = new _2({ geometry: f, symbol: e6 });
        this._polygons.set(d4, o5), i4.push(o5);
      }
      if (this.enableLabels) {
        const n4 = e5(m5), g5 = u6 / (t3.length - 1), w2 = o(0, 200, g5), _3 = o(20, 6, g5) / 0.75, j2 = null != m5.loadPriority && m5.loadPriority >= t3.length, v = new u([w2, j2 ? 0 : w2, j2 ? 0 : w2]), S = "3d" === this.view.type ? () => new j({ verticalOffset: new i2({ screenLength: 40 / 0.75 }), callout: new u2({ color: new u("white"), border: new m3({ color: new u("black") }) }), symbolLayers: new O([new g2({ text: n4, halo: { color: "white", size: 1 / 0.75 }, material: { color: v }, size: _3 })]) }) : () => new g({ text: n4, haloColor: "white", haloSize: 1 / 0.75, color: v, size: _3 }), L2 = this._labels.get(d4);
        if (L2) {
          const e6 = S();
          null != L2.symbol && JSON.stringify(e6) === JSON.stringify(L2.symbol) || (L2.symbol = e6);
        } else {
          const e6 = new _2({ geometry: f.extent.center, symbol: S() });
          this._labels.set(d4, e6), i4.push(e6);
        }
      }
    });
    const m4 = new Array();
    n3.forEach((e6) => {
      const o5 = this._polygons.get(e6);
      null != o5 && (m4.push(o5), this._polygons.delete(e6));
      const s2 = this._labels.get(e6);
      null != s2 && (m4.push(s2), this._labels.delete(e6));
    }), this.view.graphics.removeMany(m4), this.view.graphics.addMany(i4);
  }
  clear() {
    this.view.graphics.removeMany(Array.from(this._polygons.values())), this.view.graphics.removeMany(Array.from(this._labels.values())), this._polygons.clear(), this._labels.clear();
  }
};
__decorate([m({ constructOnly: true })], d3.prototype, "view", void 0), __decorate([m({ readOnly: true })], d3.prototype, "updating", void 0), __decorate([m()], d3.prototype, "enabled", null), d3 = __decorate([a("esri.views.support.TileTreeDebugger")], d3);

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/WorkerTileTreeDebugger.js
var l4 = class extends d3 {
  constructor(e5) {
    super(e5);
  }
  initialize() {
    const e5 = setInterval(() => this._fetchDebugInfo(), 2e3);
    this.addHandles(e(() => clearInterval(e5)));
  }
  getTiles() {
    if (!this._debugInfo) return [];
    const e5 = /* @__PURE__ */ new Map(), t3 = /* @__PURE__ */ new Map();
    this._debugInfo.storedTiles.forEach((t4) => e5.set(e4.fromJSON(t4.key).id, t4.featureCount)), this._debugInfo.pendingTiles.forEach((r3) => {
      e5.set(r3.key.id, r3.featureCount), t3.set(r3.key.id, r3.state);
    });
    const r2 = (r3) => {
      const o6 = t3.get(r3), s2 = e5.get(r3) ?? "?";
      return o6 ? `${o6}:${s2}
${r3}` : `store:${s2}
${r3}`;
    }, o5 = /* @__PURE__ */ new Map();
    return this._debugInfo.storedTiles.forEach((e6) => {
      const t4 = e4.fromJSON(e6.key);
      o5.set(t4.id, t4);
    }), this._debugInfo.pendingTiles.forEach((e6) => {
      o5.set(e6.key.id, e6.key);
    }), Array.from(o5.values()).map((e6) => ({ lij: [e6.level, e6.row, e6.col], level: e6.level, geometry: P.fromExtent(c2(e6.extent, this.view.spatialReference)), label: r2(e6.id) }));
  }
  _fetchDebugInfo() {
    this.handle.getDebugInfo(null).then((e5) => {
      this._debugInfo = e5, this.update();
    });
  }
};
__decorate([m({ constructOnly: true })], l4.prototype, "handle", void 0), l4 = __decorate([a("esri.views.interactive.snapping.featureSources.WorkerTileTreeDebugger")], l4);

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceSnappingSourceWorkerHandle.js
var u5 = class extends b {
  get updating() {
    return this._updatingHandles.updating || this._workerHandleUpdating;
  }
  constructor(e5) {
    super(e5), this._updatingHandles = new h3(), this._suspendController = null, this.schedule = null, this.hasZ = false, this.elevationAlignPointsInFeatures = async (e6) => {
      const t3 = [];
      for (const { points: o5 } of e6.pointsInFeatures) for (const { z: e7 } of o5) t3.push(e7);
      return { elevations: t3, drapedObjectIds: /* @__PURE__ */ new Set(), failedObjectIds: /* @__PURE__ */ new Set() };
    }, this.queryForSymbologySnapping = async () => ({ candidates: [], sourceCandidateIndices: [] }), this.availability = 0, this._workerHandleUpdating = true, this.updateOutFields = L(async (e6, t3) => {
      await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("updateOutFields", [...e6], t3)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, t3));
    });
  }
  destroy() {
    this._suspendController = e2(this._suspendController), this._workerHandle.destroy(), this._updatingHandles.destroy();
  }
  initialize() {
    this._workerHandle = new g3(this.schedule, { alignElevation: async (e5, { signal: t3 }) => ({ result: await this.elevationAlignPointsInFeatures(e5.query, t3) }), getSymbologyCandidates: async (e5, { signal: t3 }) => ({ result: await this.queryForSymbologySnapping(e5, t3) }) }), this.addHandles([this._workerHandle.on("notify-updating", ({ updating: e5 }) => this._workerHandleUpdating = e5), this._workerHandle.on("notify-availability", ({ availability: e5 }) => this._set("availability", e5))]);
  }
  async setup(e5, t3) {
    const o5 = c4(e5.layer);
    if (null == o5) return;
    const i4 = { configuration: h4(e5.configuration), serviceInfo: o5, spatialReference: e5.spatialReference.toJSON(), hasZ: this.hasZ, elevationInfo: e5.layer.elevationInfo?.toJSON() };
    await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("setup", i4, t3)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, t3));
  }
  async configure(e5, t3) {
    const o5 = h4(e5);
    await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("configure", o5, t3)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, t3));
  }
  async refresh(e5) {
    await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("refresh", {}, e5)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, e5));
  }
  async fetchCandidates(e5, t3) {
    const { point: o5, filter: i4, coordinateHelper: n3 } = e5, a6 = { ...e5, point: t(o5[0], o5[1], o5[2], n3.spatialReference.toJSON()), filter: i4?.toJSON() };
    return this._workerHandle.invoke(a6, t3);
  }
  async updateTiles(e5, t3) {
    const o5 = { tiles: e5.tiles.map((e6) => e6.toJSON()), tileInfo: null != e5.tileInfo ? e5.tileInfo.toJSON() : null, tileSize: e5.tileSize };
    await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("updateTiles", o5, t3)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, t3));
  }
  async handleEdits({ historicMoment: e5, addedFeatures: t3, deletedFeatures: i4, updatedFeatures: n3 }, a6) {
    const r2 = { historicMoment: e5, addedFeatures: t3?.map(({ objectId: e6 }) => e6).filter(N) ?? [], deletedFeatures: i4?.map(({ objectId: e6, globalId: t4 }) => ({ objectId: e6, globalId: t4 })) ?? [], updatedFeatures: n3?.map(({ objectId: e6 }) => e6).filter(N) ?? [] };
    await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("handleEdits", r2, a6)), this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating", {}, a6));
  }
  async setHistoricMoment(e5, t3) {
    await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("setHistoricMoment", { moment: e5 }, t3));
  }
  getDebugInfo(e5) {
    return this._workerHandle.invokeMethod("getDebugInfo", {}, e5);
  }
  async notifyElevationSourceChange() {
    await this._workerHandle.invokeMethod("notifyElevationSourceChange", {});
  }
  async notifySymbologyChange() {
    await this._workerHandle.invokeMethod("notifySymbologyChange", {});
  }
  async setSymbologySnappingSupported(e5) {
    await this._workerHandle.invokeMethod("setSymbologySnappingSupported", e5);
  }
  async setSuspended(e5) {
    this._suspendController?.abort(), this._suspendController = new AbortController(), await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("setSuspended", e5, this._suspendController.signal));
  }
};
function h4(e5) {
  return { filter: null != e5.filter ? e5.filter.toJSON() : null, customParameters: e5.customParameters, viewType: e5.viewType };
}
function c4(e5) {
  return "multipatch" === e5.geometryType || "mesh" === e5.geometryType ? null : { url: e5.parsedUrl?.path ?? "", fieldsIndex: e5.fieldsIndex.toJSON(), geometryType: y2.toJSON(e5.geometryType), capabilities: e5.capabilities, objectIdField: e5.objectIdField, globalIdField: e5.globalIdField, spatialReference: e5.spatialReference.toJSON(), timeInfo: e5.timeInfo?.toJSON() };
}
__decorate([m({ constructOnly: true })], u5.prototype, "schedule", void 0), __decorate([m({ constructOnly: true })], u5.prototype, "hasZ", void 0), __decorate([m({ constructOnly: true })], u5.prototype, "elevationAlignPointsInFeatures", void 0), __decorate([m({ constructOnly: true })], u5.prototype, "queryForSymbologySnapping", void 0), __decorate([m({ readOnly: true })], u5.prototype, "updating", null), __decorate([m({ readOnly: true })], u5.prototype, "availability", void 0), __decorate([m()], u5.prototype, "_workerHandleUpdating", void 0), u5 = __decorate([a("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceSnappingSourceWorkerHandle")], u5);
var g3 = class extends o3 {
  constructor(e5, t3) {
    super("FeatureServiceSnappingSourceWorker", "fetchCandidates", {}, e5, { strategy: "dedicated", client: t3 });
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTilesSimple.js
var a5 = class extends b {
  get tiles() {
    return [new e4(0, 0, 0, e3(-1e8, -1e8, 1e8, 1e8))];
  }
  get tileInfo() {
    return new z({ origin: new _({ x: -1e8, y: 1e8, spatialReference: this.layer.spatialReference }), size: [512, 512], lods: [new l2({ level: 0, scale: 1, resolution: 390625 })], spatialReference: this.layer.spatialReference });
  }
  get tileSize() {
    return this.tileInfo.size[0];
  }
  constructor(e5) {
    super(e5), this.pointOfInterest = null, this.updating = false;
  }
};
__decorate([m({ readOnly: true })], a5.prototype, "tiles", null), __decorate([m({ readOnly: true })], a5.prototype, "tileInfo", null), __decorate([m({ readOnly: true })], a5.prototype, "tileSize", null), __decorate([m({ constructOnly: true })], a5.prototype, "layer", void 0), __decorate([m()], a5.prototype, "pointOfInterest", void 0), __decorate([m()], a5.prototype, "updating", void 0), a5 = __decorate([a("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTilesSimple")], a5);

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/FeatureServiceSnappingSource.js
var O2 = class extends b {
  get _updateTilesParameters() {
    return { tiles: this._tilesOfInterest.tiles, tileInfo: this._tilesOfInterest.tileInfo, tileSize: this._tilesOfInterest.tileSize };
  }
  get _layerView() {
    return this.view?.allLayerViews.find((e5) => e5.layer === this._layer);
  }
  get _isSuspended() {
    if (d2(this._layer)) {
      if (!this.layerSource.sublayerSources.some((e5) => e5.enabled && e5.layer.visible)) return true;
    }
    return this._snappingComplexityExceeded || !!this.view && (false !== this._layerView?.suspended || !this.layerSource.enabled);
  }
  get _snappingComplexityExceeded() {
    return !(!this._layerView || !("snappingComplexityExceeded" in this._layerView)) && this._layerView.snappingComplexityExceeded;
  }
  get updating() {
    return this._workerHandle?.updating || this._updatingHandles.updating || this._tilesOfInterest.updating;
  }
  get _outFields() {
    const { view: e5, _layerView: t3, layerSource: i4 } = this, { layer: r2 } = i4, { fieldsIndex: s2, timeInfo: o5, floorInfo: a6, subtypeField: n3 } = r2, l5 = t3 && "filter" in t3 ? t3.filter : null, d4 = l5?.where && "1=1" !== l5.where ? this._getOrLoadWhereFields(l5.where, s2) : [];
    if (l5?.timeExtent && o5) {
      const { startField: e6, endField: t4 } = o5, i5 = s2.get(e6)?.name ?? e6, r3 = s2.get(t4)?.name ?? t4;
      i5 && d4.push(i5), r3 && d4.push(r3);
    }
    if (e5?.map && x(e5.map) && e5.map.utilityNetworks?.find((e6) => e6.isUtilityLayer(r2))) {
      const e6 = r2.fieldsIndex.get("assetGroup")?.name, t4 = r2.fieldsIndex.get("assetType")?.name;
      e6 && t4 && (d4.push(e6), d4.push(t4));
    }
    if (r2 && a6?.floorField && e5?.floors?.length) {
      const e6 = s2.get(a6.floorField)?.name ?? a6.floorField;
      e6 && d4.push(e6);
    }
    if (n3) {
      const e6 = s2.get(n3)?.name ?? n3;
      e6 && d4.push(e6);
    }
    return new Set(d4);
  }
  get configuration() {
    const { view: e5 } = this, { apiKey: t3, customParameters: i4 } = this._layer, r2 = null != e5 ? e5.type : "2d", s2 = this._layer.createQuery();
    return this._layerView && "effectiveDisplayFilter" in this._layerView && (s2.where = l3(s2.where, this._layerView.effectiveDisplayFilter?.where)), { filter: s2, customParameters: t3 ? { ...i4, token: t3 } : i4, viewType: r2 };
  }
  get availability() {
    return this._workerHandle?.availability ?? 0;
  }
  get _layer() {
    return this.layerSource.layer;
  }
  constructor(e5) {
    super(e5), this._updatingHandles = new h3(), this._workerHandle = null, this._debug = null, this._memoizedMakeGetGroundElevation = t2(i3);
  }
  initialize() {
    let e5;
    const t3 = this.view;
    if (null == t3 || t3.destroyed) this._tilesOfInterest = new a5({ layer: this._layer }), e5 = this._workerHandle = new u5();
    else switch (t3.type) {
      case "2d":
        this._tilesOfInterest = new p({ view: t3, layer: this._layer }), e5 = this._workerHandle = new u5();
        break;
      case "3d": {
        const { resourceController: i4 } = t3, r2 = this._layer;
        this._tilesOfInterest = new u3({ view: t3 }), e5 = this._workerHandle = new u5({ schedule: (e6) => i4.immediate.schedule(e6), hasZ: r2.hasZ && (r2.returnZ ?? true), elevationAlignPointsInFeatures: async (e6, i5) => {
          const s2 = await t3.whenLayerView(r2);
          return s(i5), s2.elevationAlignPointsInFeatures(e6, i5);
        }, queryForSymbologySnapping: async (e6, i5) => {
          const s2 = await t3.whenLayerView(r2);
          return s(i5), s2.queryForSymbologySnapping(e6, i5);
        } }), this._updatingHandles.add(() => r2.elevationInfo, () => y(e5.notifyElevationSourceChange()), h2), this._updatingHandles.add(() => this._layerView?.layer?.renderer, () => y(e5.notifySymbologyChange()), h2), this._updatingHandles.add(() => this._layerView?.symbologySnappingSupported ?? false, (t4) => y(e5.setSymbologySnappingSupported(t4)), h2), this.addHandles([t3.elevationProvider.on("elevation-change", ({ context: t4 }) => {
          const { elevationInfo: i5 } = r2;
          P2(t4, i5) && y(e5.notifyElevationSourceChange());
        }), a2(() => this._layerView?.layer, ["edits", "apply-edits", "graphic-update"], () => e5.notifySymbologyChange())]);
        break;
      }
    }
    this.addHandles([c(e5)]), y(e5.setup({ layer: this._layer, spatialReference: this.spatialReference, configuration: this.configuration }, null)), this._updatingHandles.add(() => this._updateTilesParameters, () => y(e5.updateTiles(this._updateTilesParameters, null)), h2), this.addHandles([l(() => this.configuration, (t4) => y(e5.configure(t4, null)), U), l(() => this._layer.historicMoment, (t4) => y(e5.setHistoricMoment(t4)), w), l(() => this._isSuspended, (t4) => y(e5.setSuspended(t4)), w)]), this._updatingHandles.add(() => this._outFields, (t4) => y(e5.updateOutFields(t4)), h2), null != t3 && this.addHandles(l(() => E.FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES, (i4) => {
      i4 && !this._debug ? (this._debug = new l4({ view: t3, handle: e5 }), this.addHandles(c(this._debug), "debug")) : !i4 && this._debug && this.removeHandles("debug");
    }, h2)), this.addHandles([this.layerSource.layer.on("edits", (t4) => y(e5.handleEdits(t4, null))), this.layerSource.layer.on("apply-edits", (e6) => this._updatingHandles.addPromise(e6.result))]);
  }
  destroy() {
    this._updatingHandles.destroy(), this._tilesOfInterest.destroy();
  }
  refresh() {
    this._workerHandle?.refresh(null);
  }
  async fetchCandidates(e5, t3) {
    if (this._isSuspended) return [];
    const { coordinateHelper: i4, point: r2 } = e5;
    this._tilesOfInterest.pointOfInterest = i4.arrayToPoint(r2);
    const s2 = this._memoizedMakeGetGroundElevation(this.view, i4.spatialReference);
    return (await this._workerHandle.fetchCandidates({ ...e5 }, t3)).candidates.map((e6) => o4(e6, s2));
  }
  getDebugInfo(e5) {
    return this._workerHandle.getDebugInfo(e5);
  }
  _getOrLoadWhereFields(e5, t3) {
    const { _whereModule: r2 } = this;
    if (!this._loadWhereModuleTask && !r2) {
      const e6 = d(async () => {
        const e7 = await import("./WhereClause-QUO5S732.js");
        return this._whereModule = e7.default, this._whereModule;
      });
      return this._loadWhereModuleTask = e6, this._updatingHandles.addPromise(e6.promise), [];
    }
    if (!r2) return [];
    try {
      return r2.create(e5, { fieldsIndex: t3 }).fieldNames;
    } catch (s2) {
      return [];
    }
  }
};
__decorate([m({ constructOnly: true })], O2.prototype, "spatialReference", void 0), __decorate([m({ constructOnly: true })], O2.prototype, "layerSource", void 0), __decorate([m({ constructOnly: true })], O2.prototype, "view", void 0), __decorate([m()], O2.prototype, "_tilesOfInterest", void 0), __decorate([m({ readOnly: true })], O2.prototype, "_updateTilesParameters", null), __decorate([m()], O2.prototype, "_layerView", null), __decorate([m()], O2.prototype, "_isSuspended", null), __decorate([m()], O2.prototype, "_snappingComplexityExceeded", null), __decorate([m({ readOnly: true })], O2.prototype, "updating", null), __decorate([m()], O2.prototype, "_outFields", null), __decorate([m({ readOnly: true })], O2.prototype, "configuration", null), __decorate([m({ readOnly: true })], O2.prototype, "availability", null), __decorate([m()], O2.prototype, "_loadWhereModuleTask", void 0), __decorate([m()], O2.prototype, "_whereModule", void 0), O2 = __decorate([a("esri.views.interactive.snapping.featureSources.FeatureServiceSnappingSource")], O2);
export {
  O2 as FeatureServiceSnappingSource
};
//# sourceMappingURL=FeatureServiceSnappingSource-IQMQ37QG.js.map
