import {
  L as L3,
  b as b3
} from "./chunk-BTFBYI67.js";
import "./chunk-D3G5WIRR.js";
import {
  k
} from "./chunk-Q3JOE7TC.js";
import {
  h
} from "./chunk-WQW6HIRX.js";
import {
  V
} from "./chunk-PUWBFCEG.js";
import {
  F
} from "./chunk-VVMIB6RA.js";
import "./chunk-A7O5R67Z.js";
import {
  a as a4
} from "./chunk-ZEI5DZXH.js";
import {
  s as s6
} from "./chunk-RGWH5UES.js";
import "./chunk-4KVWUPLK.js";
import "./chunk-NOLINR6O.js";
import "./chunk-HIGI45S6.js";
import {
  t as t2
} from "./chunk-JVMNF6GR.js";
import {
  o as o3
} from "./chunk-SL3GC7WV.js";
import {
  l as l6
} from "./chunk-CJZPTLIZ.js";
import "./chunk-2U5X5TIX.js";
import {
  a as a6
} from "./chunk-4FQUAV7M.js";
import {
  A as A2,
  l as l8
} from "./chunk-EVZ7KLPS.js";
import {
  l as l7
} from "./chunk-JSH3APTG.js";
import {
  u as u4
} from "./chunk-WQT2KLDB.js";
import {
  d
} from "./chunk-UVDECGZC.js";
import {
  o as o2,
  s as s4
} from "./chunk-VKFTCFFM.js";
import {
  s as s5
} from "./chunk-ZETARPSI.js";
import {
  f as f3
} from "./chunk-TCDV4P3G.js";
import {
  b2,
  c as c2,
  d as d2,
  j as j3,
  l as l9,
  p as p4,
  u as u5,
  v as v2
} from "./chunk-CZOYDK6P.js";
import {
  j
} from "./chunk-TMUM75KQ.js";
import {
  A,
  B,
  C,
  D,
  E,
  F as F3,
  H,
  L as L2,
  O as O2,
  P,
  Q,
  R,
  T,
  U as U2,
  Y,
  q as q2,
  v
} from "./chunk-KY5OS6CK.js";
import "./chunk-3U5UUY3S.js";
import {
  p as p3
} from "./chunk-UOYGMZIS.js";
import {
  $
} from "./chunk-RXH2WNPA.js";
import {
  a as a5
} from "./chunk-TWU3GKHX.js";
import "./chunk-BGIBV6LL.js";
import "./chunk-UQXJMFRI.js";
import "./chunk-DY7N5RAZ.js";
import {
  j as j2
} from "./chunk-6TCXGIIN.js";
import {
  l as l3
} from "./chunk-NP2TBOXH.js";
import "./chunk-WBYRWTBX.js";
import "./chunk-WFCLXKCE.js";
import "./chunk-FHCV4NTV.js";
import {
  S as S2
} from "./chunk-XTEXJOLG.js";
import "./chunk-YE4E5JCT.js";
import "./chunk-SXZO7ULH.js";
import "./chunk-H34D76ZQ.js";
import "./chunk-QTRET3PG.js";
import "./chunk-FMOL5XMB.js";
import {
  S,
  c,
  u as u3
} from "./chunk-VNSHGTPN.js";
import "./chunk-OEBAFVQK.js";
import "./chunk-76V6RN4F.js";
import {
  F as F2
} from "./chunk-Y3FKYMXQ.js";
import "./chunk-S5K4XWUR.js";
import "./chunk-EK7HOTRR.js";
import "./chunk-GCTH5LET.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import "./chunk-EKZRA6TO.js";
import "./chunk-M5SP6ZBM.js";
import "./chunk-2HGIYEIL.js";
import "./chunk-Z6VKIQV2.js";
import "./chunk-ET5EDAFM.js";
import {
  b
} from "./chunk-647DAMHU.js";
import "./chunk-O6G3PPOK.js";
import "./chunk-ZKNZTIAS.js";
import "./chunk-OJMISN3F.js";
import "./chunk-EFV6H5NA.js";
import "./chunk-QZQPB5XR.js";
import "./chunk-AQFRVV3U.js";
import "./chunk-OJBEN6CV.js";
import {
  p as p2
} from "./chunk-PEL3D3ZN.js";
import "./chunk-Q5KWD3VQ.js";
import "./chunk-BUQC3CLV.js";
import {
  t
} from "./chunk-W5S3VUFT.js";
import {
  a as a3
} from "./chunk-7YH7T6CS.js";
import "./chunk-3T4IXPP4.js";
import "./chunk-XTZAIV4X.js";
import "./chunk-63LDVRFI.js";
import {
  n as n2
} from "./chunk-C3FRY5U4.js";
import {
  n2 as n3,
  q
} from "./chunk-JNJX34GB.js";
import "./chunk-3STJRSDT.js";
import "./chunk-67Q6KVC6.js";
import "./chunk-23NJHA5Q.js";
import "./chunk-4LA6K4VI.js";
import "./chunk-KEZCWFAR.js";
import "./chunk-JZUJ34RR.js";
import "./chunk-PMGS7UDU.js";
import "./chunk-3GHCGAH2.js";
import "./chunk-HWUOAPTX.js";
import "./chunk-QHCKOBU7.js";
import "./chunk-K2OZ6WVC.js";
import {
  F as F4,
  y2 as y
} from "./chunk-MC6NAKKX.js";
import {
  l as l5
} from "./chunk-TF6255HN.js";
import "./chunk-GD4FJL3C.js";
import {
  n
} from "./chunk-C5OQVQZF.js";
import "./chunk-F7DKSAOI.js";
import "./chunk-4SOQWNPG.js";
import "./chunk-LTULADK2.js";
import "./chunk-35ST7YRB.js";
import "./chunk-EDA5QFHZ.js";
import {
  l as l2
} from "./chunk-RO646JIV.js";
import "./chunk-CNYNCKEV.js";
import "./chunk-XL5QPCXN.js";
import "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-W75DBJD7.js";
import "./chunk-QF7FRVN6.js";
import {
  b as b4
} from "./chunk-P6IKJIMO.js";
import "./chunk-MHV23XAQ.js";
import "./chunk-V2X4OKYI.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import "./chunk-MA3QDRC3.js";
import "./chunk-W6J7XCPU.js";
import {
  s as s3
} from "./chunk-ONXWBTTM.js";
import {
  l as l4
} from "./chunk-T7F6Q6JJ.js";
import {
  O
} from "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-7P2ANHQ3.js";
import {
  u as u2
} from "./chunk-XCKT47LJ.js";
import "./chunk-3FUHCAX3.js";
import "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import {
  U,
  l
} from "./chunk-2OFHDVO5.js";
import "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-5UPBUJPC.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-CCQFL76O.js";
import "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import "./chunk-7H3U4IJR.js";
import "./chunk-SMWUT52Z.js";
import "./chunk-AXZMNHTN.js";
import {
  f as f2
} from "./chunk-5T3MJDSR.js";
import "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import {
  w
} from "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import {
  o
} from "./chunk-XWE6BM2U.js";
import {
  r
} from "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2,
  s3 as s2
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import {
  e as e2
} from "./chunk-4DGC7CBY.js";
import {
  L,
  f2 as f,
  p,
  u2 as u
} from "./chunk-GNMPGHLQ.js";
import {
  a,
  e,
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/layers/support/subtypeGroupLayerUtils.js
var f4 = { key: "type", base: a5, errorContext: "renderer", typeMap: { simple: p3, "unique-value": $, "class-breaks": j } };
var i2 = s2({ types: f4 });
function c3(e3, r2) {
  const s7 = e3.drawingInfo?.renderer, o5 = s7 ? i2(s7, e3, r2) : null;
  if ("simple" !== o5?.type) return;
  return b3(o5.symbol, null) ? o5.symbol.clone() : null;
}
var u6 = ["#ed5151", "#149ece", "#a7c636", "#9e559c", "#fc921f", "#ffde3e", "#f789d8", "#b7814a", "#3caf99", "#6b6bd6", "#b54779", "#7f7f7f"];
function a7(r2, s7) {
  return S2(u6, r2, { offset: true, shuffle: true }).reverse().map((e3) => {
    const r3 = s7.clone();
    return "cim" === r3.type ? k(r3, e3) : L3(r3, e3), new p3({ symbol: r3 });
  });
}

// node_modules/@arcgis/core/graphic/isSubtypeGroupGraphicOrigin.js
var i3 = Symbol("isSubtypeGroupGraphicOriginSymbol");

// node_modules/@arcgis/core/graphic/SubtypeGroupGraphicOrigin.js
var o4;
var u7 = class extends s4 {
  get [(o4 = i3, n3)]() {
    return this.sublayer;
  }
  get [n2]() {
    return this.sublayer;
  }
  get [o2]() {
    return this.layer;
  }
  constructor(r2) {
    super(), this[o4] = true, this.type = "subtype-group", this.sublayer = r2;
  }
  get layer() {
    return this.sublayer.parent;
  }
  get id() {
    return `${this.layer.id}:__${this.sublayer.id}__`;
  }
};

// node_modules/@arcgis/core/layers/support/SubtypeSublayer.js
var M = s6();
var Q2 = 0;
function k2(e3, t3) {
  let r2 = e3.json.write;
  return "object" != typeof r2 && (r2 = e3.json.write = {}), r2.ignoreOrigin = true, t3?.spatialOnly && (r2.layerContainerTypes = a3), e3;
}
function B2(e3) {
  const t3 = { write: { ignoreOrigin: true } };
  return e3?.name && (t3.name = e3.name), "object" == typeof t3.write && (e3?.spatialOnly && (t3.write.layerContainerTypes = a3), e3?.target && (t3.write.target = e3.target)), t3;
}
function H2(e3) {
  return new p3({ symbol: J(e3) });
}
function J(e3) {
  switch (e3) {
    case "point":
    case "multipoint":
      return S.clone();
    case "polyline":
      return u3.clone();
    case "polygon":
    case "multipatch":
      return c.clone();
    default:
      return null;
  }
}
function W(e3, t3) {
  return !!t3 && ("unique-value" === e3?.type && null != e3.field && e3.field.toLowerCase() === t3.toLowerCase() && !e3.field2 && !e3.field3 && !e3.valueExpression);
}
function z(e3, t3) {
  return null == e3 ? null : t3.subtypes?.find((t4) => t4.code === e3);
}
function K(e3, t3) {
  let r2 = null;
  switch (t3.geometryType) {
    case "esriGeometryPoint":
    case "esriGeometryMultipoint":
      r2 = "point";
      break;
    case "esriGeometryPolyline":
      r2 = "line";
      break;
    case "esriGeometryPolygon":
    case "esriGeometryMultiPatch":
      r2 = "polygon";
      break;
    default:
      t3.type, r2 = null;
  }
  const i4 = {}, o5 = z(e3, t3);
  if (null != o5) {
    const { defaultValues: e4 } = o5;
    for (const t4 in e4) i4[t4] = e4[t4];
  }
  return i4[t3.subtypeField] = e3, new a6({ name: "New Feature", drawingTool: r2, prototype: { attributes: i4 } });
}
var X = class extends l3(l4(s3(u2))) {
  constructor(e3) {
    super(e3), this.attributeTableTemplate = null, this.charts = null, this.editingEnabled = true, this.fieldOverrides = null, this.fieldsIndex = null, this.formTemplate = null, this.graphicOrigin = new u7(this), this.id = `${Date.now().toString(16)}-subtype-sublayer-${Q2++}`, this.type = "subtype-sublayer", this.labelsVisible = true, this.labelingInfo = null, this.layerType = "ArcGISFeatureLayer", this.legendEnabled = true, this.listMode = "show", this.minScale = 0, this.maxScale = 0, this.opacity = 1, this.parent = null, this.popupEnabled = true, this.popupTemplate = null, this.subtypeCode = null, this.templates = null, this.title = null, this.visible = true;
  }
  load(e3) {
    return y(this.renderer, this.fieldsIndex), Promise.resolve(this);
  }
  get _titleCreator() {
    const e3 = this._get("_titleCreator");
    return u(e3), new h({ fieldsIndex: this.fieldsIndex, objectIdField: this.objectIdField, displayField: this.parent?.displayField ?? "", fields: this.fields, effectivePopupTemplate: this.popupTemplate ?? this.defaultPopupTemplate });
  }
  get capabilities() {
    return this.parent?.capabilities;
  }
  get effectiveCapabilities() {
    return this.parent?.effectiveCapabilities;
  }
  get effectiveEditingEnabled() {
    const { parent: e3 } = this;
    return e3 ? e3.effectiveEditingEnabled && this.editingEnabled : this.editingEnabled;
  }
  get elevationInfo() {
    return this.parent?.elevationInfo;
  }
  get featureTitleFields() {
    return [...this._titleCreator.requiredFields];
  }
  writeFieldOverrides(e3, t3, r2) {
    const { fields: i4, parent: o5 } = this;
    let l10;
    if (i4) {
      l10 = [];
      let e4 = 0;
      i4.forEach(({ name: t4, alias: r3, editable: i5, visible: n4 }) => {
        if (!n4) return;
        const s7 = o5?.fields?.find((e5) => e5.name === t4);
        if (!s7) return;
        const a8 = { name: t4 };
        let p5 = false;
        r3 !== s7.alias && (a8.alias = r3, p5 = true), i5 !== s7.editable && (a8.editable = i5, p5 = true), l10.push(a8), p5 && e4++;
      }), 0 === e4 && l10.length === i4.length && (l10 = null);
    } else l10 = a(e3);
    l10?.length && e(r2, l10, t3);
  }
  get fields() {
    const { parent: e3, fieldOverrides: t3, subtypeCode: r2 } = this, i4 = e3?.fields;
    if (!e3 || !i4?.length) return null;
    const { subtypes: o5, subtypeField: n4 } = e3, l10 = o5?.find((e4) => e4.code === r2), s7 = l10?.defaultValues, a8 = l10?.domains, p5 = [];
    for (const d3 of i4) {
      const e4 = d3.clone(), { name: i5 } = e4, o6 = t3?.find((e5) => e5.name === i5);
      if (e4.visible = !t3?.length || !!o6, o6) {
        const { alias: t4, editable: r3 } = o6;
        t4 && (e4.alias = t4), false === r3 && (e4.editable = false);
      }
      const l11 = s7?.[i5] ?? null;
      e4.defaultValue = i5 === n4 ? r2 : l11;
      const u8 = a8?.[i5] ?? null;
      e4.domain = i5 === n4 ? null : u8 ? "inherited" === u8.type ? e4.domain : u8.clone() : null, p5.push(e4);
    }
    return p5;
  }
  get floorInfo() {
    return this.parent?.floorInfo;
  }
  get isTable() {
    return !!this.parent?.isTable;
  }
  get geometryType() {
    return this.parent?.geometryType;
  }
  get globalIdField() {
    return this.parent ? this.parent.globalIdField : (i.getLogger(this).error(ee("globalIdField")), null);
  }
  get effectiveScaleRange() {
    const { minScale: e3, maxScale: t3 } = this;
    return { minScale: e3, maxScale: t3 };
  }
  get objectIdField() {
    return this.parent || i.getLogger(this).error(ee("objectIdField")), this.parent?.objectIdField;
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  get relationships() {
    return this.parent?.relationships;
  }
  set renderer(e3) {
    y(e3, this.fieldsIndex), this._override("renderer", e3);
  }
  get renderer() {
    if (this._isOverridden("renderer")) return this._get("renderer");
    const { parent: e3 } = this;
    return e3 && !e3.isTable && "mesh" !== e3.geometryType ? H2(e3.geometryType) : null;
  }
  readRendererFromService(e3, t3, r2) {
    if ("Table" === t3.type) return null;
    const i4 = t3.drawingInfo?.renderer, o5 = i2(i4, t3, r2);
    let n4;
    const { subtypeCode: l10 } = this;
    if (null != l10 && W(o5, t3.subtypeField)) {
      const e4 = o5.uniqueValueInfos?.find(({ value: e5 }) => (e5 = "number" == typeof e5 ? String(e5) : e5) === String(l10));
      e4 && (n4 = new p3({ symbol: e4.symbol }));
    } else "simple" !== o5?.type || o5.visualVariables?.length || (n4 = o5);
    return n4;
  }
  readRenderer(e3, t3, r2) {
    const i4 = t3?.layerDefinition?.drawingInfo?.renderer;
    if (i4) return i2(i4, t3, r2) || void 0;
  }
  get spatialReference() {
    return this.parent?.spatialReference ?? f2.WGS84;
  }
  get subtypeField() {
    return this.parent?.subtypeField;
  }
  readTemplatesFromService(e3, t3) {
    return [K(this.subtypeCode, t3)];
  }
  readTitleFromService(e3, t3) {
    const r2 = z(this.subtypeCode, t3);
    return null != r2 ? r2.name : null;
  }
  get url() {
    return this.parent?.url;
  }
  get userHasUpdateItemPrivileges() {
    return !!this.parent?.userHasUpdateItemPrivileges;
  }
  async addAttachment(e3, t3) {
    const { parent: r2 } = this;
    if (!r2) throw ee("addAttachment");
    if (e3.getAttribute(r2.subtypeField) !== this.subtypeCode) throw new s("subtype-sublayer:addAttachment", "The feature provided does not belong to this SubtypeSublayer");
    return r2.addAttachment(e3, t3);
  }
  async updateAttachment(e3, t3, r2) {
    const { parent: o5 } = this;
    if (!o5) throw ee("updateAttachment");
    if (e3.getAttribute(o5.subtypeField) !== this.subtypeCode) throw new s("subtype-sublayer:updateAttachment", "The feature provided does not belong to this SubtypeSublayer");
    return o5.updateAttachment(e3, t3, r2);
  }
  async deleteAttachments(e3, t3) {
    const { parent: r2 } = this;
    if (!r2) throw ee("deleteAttachments");
    if (e3.getAttribute(r2.subtypeField) !== this.subtypeCode) throw new s("subtype-sublayer:deleteAttachments", "The feature provided does not belong to this SubtypeSublayer");
    return r2.deleteAttachments(e3, t3);
  }
  async applyEdits(e3, t3) {
    if (!this.parent) throw ee("applyEdits");
    return this.parent.applyEdits(e3, t3);
  }
  createPopupTemplate(e3) {
    let t3 = this;
    const { parent: r2, fields: i4, title: o5 } = this;
    if (r2) {
      const { displayField: e4, editFieldsInfo: n4, objectIdField: l10 } = r2;
      t3 = { displayField: e4, editFieldsInfo: n4, fields: i4, objectIdField: l10, title: o5 };
    }
    return d(t3, e3);
  }
  createQuery() {
    if (!this.parent) throw ee("createQuery");
    const e3 = R(this.parent), t3 = `${this.parent.subtypeField}=${this.subtypeCode}`;
    return e3.where = l5(t3, this.parent.definitionExpression), e3;
  }
  getFeatureTitle(e3, t3) {
    return this._titleCreator.getTitle(this, e3, t3);
  }
  getFeatureTitles(e3, t3) {
    return this._titleCreator.getTitles(this, e3, t3);
  }
  getField(e3) {
    return this.fieldsIndex.get(e3);
  }
  getFieldDomain(e3, t3) {
    if (!t3?.excludeImpliedDomains && this.parent) {
      const t4 = U2(this.parent, e3);
      if (t4) return t4;
    }
    return this._getLayerDomain(e3);
  }
  async queryAttachments(e3, t3) {
    const r2 = await this.load();
    if (!r2.parent) throw ee("queryAttachments");
    const i4 = e3.clone();
    return i4.where = Z(i4.where, r2.parent.subtypeField, r2.subtypeCode), r2.parent.queryAttachments(e3, t3);
  }
  async queryFeatureCount(e3, t3) {
    const r2 = await this.load();
    if (!r2.parent) throw ee("queryFeatureCount");
    return r2.parent.queryFeatureCount(Y2(r2.parent, r2, e3), t3);
  }
  async queryFeatures(e3, t3) {
    const r2 = await this.load();
    if (!r2.parent) throw ee("queryFeatures");
    return r2.parent.queryFeatures(Y2(r2.parent, r2, e3), t3);
  }
  async queryObjectIds(e3, t3) {
    const r2 = await this.load();
    if (!r2.parent) throw ee("queryObjectIds");
    return r2.parent.queryObjectIds(Y2(r2.parent, r2, e3), t3);
  }
  async queryRelatedFeatures(e3, t3) {
    const r2 = await this.load();
    if (!r2.parent) throw ee("queryRelatedFeatures");
    return r2.parent.queryRelatedFeatures(e3, t3);
  }
  async queryRelatedFeaturesCount(e3, t3) {
    const r2 = await this.load();
    if (!r2.parent) throw ee("queryRelatedFeaturesCount");
    return r2.parent.queryRelatedFeaturesCount(e3, t3);
  }
  _getLayerDomain(e3) {
    const t3 = this.fieldsIndex.get(e3);
    return t3 ? t3.domain : null;
  }
};
__decorate([m({ clonable: false, readOnly: true })], X.prototype, "_titleCreator", null), __decorate([m({ type: c2, json: B2({ name: "attributeTableInfo" }) })], X.prototype, "attributeTableTemplate", void 0), __decorate([m({ readOnly: true, json: { read: false } })], X.prototype, "capabilities", null), __decorate([m({ readOnly: true, json: { read: false } })], X.prototype, "effectiveCapabilities", null), __decorate([m({ json: B2() })], X.prototype, "charts", void 0), __decorate([m({ type: Boolean, nonNullable: true, json: B2({ name: "enableEditing" }) })], X.prototype, "editingEnabled", void 0), __decorate([m({ type: Boolean, readOnly: true })], X.prototype, "effectiveEditingEnabled", null), __decorate([m({ readOnly: true, json: { read: false } })], X.prototype, "elevationInfo", null), __decorate([m({ clonable: false, readOnly: true })], X.prototype, "featureTitleFields", null), __decorate([m({ json: { name: "layerDefinition.fieldOverrides", origins: { service: { read: false } }, write: { ignoreOrigin: true, allowNull: true } } })], X.prototype, "fieldOverrides", void 0), __decorate([r("fieldOverrides")], X.prototype, "writeFieldOverrides", null), __decorate([m({ ...M.fields, readOnly: true, json: { read: false } })], X.prototype, "fields", null), __decorate([m(M.fieldsIndex)], X.prototype, "fieldsIndex", void 0), __decorate([m({ readOnly: true, json: { read: false } })], X.prototype, "floorInfo", null), __decorate([m({ type: F, json: B2({ name: "formInfo" }) })], X.prototype, "formTemplate", void 0), __decorate([m({ readOnly: true, clonable: false })], X.prototype, "graphicOrigin", void 0), __decorate([m({ type: String, clonable: false, json: { origins: { service: { read: false }, "portal-item": { read: false } }, write: { ignoreOrigin: true } } })], X.prototype, "id", void 0), __decorate([m({ readOnly: true, json: { read: false } })], X.prototype, "isTable", null), __decorate([m({ readOnly: true, json: { read: false } })], X.prototype, "geometryType", null), __decorate([m({ readOnly: true, json: { read: false } })], X.prototype, "globalIdField", null), __decorate([m({ readOnly: true, json: { read: false } })], X.prototype, "type", void 0), __decorate([m(k2(a(p4)))], X.prototype, "labelsVisible", void 0), __decorate([m({ type: [A2], json: { name: "layerDefinition.drawingInfo.labelingInfo", origins: { service: { read: false } }, read: { reader: l8 }, write: { ignoreOrigin: true, layerContainerTypes: a3 } } })], X.prototype, "labelingInfo", void 0), __decorate([m({ type: ["ArcGISFeatureLayer"], readOnly: true, json: { read: false, write: { ignoreOrigin: true, layerContainerTypes: a3 } } })], X.prototype, "layerType", void 0), __decorate([m(k2(a(d2)))], X.prototype, "legendEnabled", void 0), __decorate([m({ type: ["show", "hide"] })], X.prototype, "listMode", void 0), __decorate([m((() => {
  const e3 = a(j3);
  return e3.json.origins.service.read = false, k2(e3, { spatialOnly: true });
})())], X.prototype, "minScale", void 0), __decorate([m((() => {
  const e3 = a(v2);
  return e3.json.origins.service.read = false, k2(e3, { spatialOnly: true });
})())], X.prototype, "maxScale", void 0), __decorate([m({ readOnly: true })], X.prototype, "effectiveScaleRange", null), __decorate([m({ readOnly: true, json: { read: false } })], X.prototype, "objectIdField", null), __decorate([m({ type: Number, range: { min: 0, max: 1 }, nonNullable: true, json: B2({ spatialOnly: true }) })], X.prototype, "opacity", void 0), __decorate([m({ clonable: false })], X.prototype, "parent", void 0), __decorate([m(k2(a(l9)))], X.prototype, "popupEnabled", void 0), __decorate([m({ type: q, json: B2({ name: "popupInfo" }) })], X.prototype, "popupTemplate", void 0), __decorate([m({ readOnly: true })], X.prototype, "defaultPopupTemplate", null), __decorate([m({ readOnly: true, json: { read: false } })], X.prototype, "relationships", null), __decorate([m({ types: f4, json: B2({ target: "layerDefinition.drawingInfo.renderer", spatialOnly: true }) })], X.prototype, "renderer", null), __decorate([o("service", "renderer", ["drawingInfo.renderer", "subtypeField", "type"])], X.prototype, "readRendererFromService", null), __decorate([o("renderer", ["layerDefinition.drawingInfo.renderer"])], X.prototype, "readRenderer", null), __decorate([m({ readOnly: true, json: { read: false } })], X.prototype, "spatialReference", null), __decorate([m({ type: Number, json: { origins: { service: { read: false } }, write: { ignoreOrigin: true } } })], X.prototype, "subtypeCode", void 0), __decorate([m({ readOnly: true, json: { read: false } })], X.prototype, "subtypeField", null), __decorate([m({ type: [a6], json: B2({ name: "layerDefinition.templates" }) })], X.prototype, "templates", void 0), __decorate([o("service", "templates", ["geometryType", "subtypeField", "subtypes", "type"])], X.prototype, "readTemplatesFromService", null), __decorate([m({ type: String, json: B2() })], X.prototype, "title", void 0), __decorate([o("service", "title", ["subtypes"])], X.prototype, "readTitleFromService", null), __decorate([m({ readOnly: true, json: { read: false } })], X.prototype, "url", null), __decorate([m({ readOnly: true })], X.prototype, "userHasUpdateItemPrivileges", null), __decorate([m({ type: Boolean, nonNullable: true, json: B2({ name: "visibility", spatialOnly: true }) })], X.prototype, "visible", void 0), X = __decorate([a2("esri.layers.support.SubtypeSublayer")], X);
var Y2 = (e3, t3, r2) => {
  if (!r2) return t3.createQuery();
  const i4 = b.from(r2);
  return i4.where = Z(i4.where, e3.subtypeField, t3.subtypeCode), i4;
};
var Z = (e3, t3, r2) => {
  const i4 = new RegExp(`${t3}\\s*=\\s*\\d+`), o5 = `${t3}=${r2}`, n4 = e3 ?? "";
  return i4.test(n4) ? n4.replace(i4, o5) : l5(o5, n4);
};
var ee = (e3) => new s("subtype-sublayer:parent-missing", `This sublayer must have a parent SubtypeGroupLayer in order to use ${e3}`);

// node_modules/@arcgis/core/layers/SubtypeGroupLayer.js
var se = "SubtypeGroupLayer";
function ie(e3, t3) {
  return new s("layer:unsupported", `Layer (${e3.title}, ${e3.id}) of type '${e3.declaredClass}' ${t3}`, { layer: e3 });
}
function oe(e3, t3) {
  const r2 = [];
  for (const s7 of e3) {
    const e4 = new X();
    e4.read(s7, t3), r2.push(e4);
  }
  return r2;
}
var ae = s6();
function ne() {
  return { name: "layerType", read: { enabled: true }, write: { enabled: true, ignoreOrigin: true, isRequired: true } };
}
var ue = class extends V(a4(F2(p2(l7(t(f3(l6(b2(j2(l3(s5(o3(l4(b4)))))))))))))) {
  constructor(...e3) {
    super(...e3), this._sublayerLookup = /* @__PURE__ */ new Map(), this.fields = null, this.fieldsIndex = null, this.outFields = null, this.sublayers = new (O.ofType(X))(), this.useUniqueColorsForSublayers = true, this.supportedSourceTypes = /* @__PURE__ */ new Set(["Feature Layer", "Table"]), this.timeInfo = null, this.title = "Layer", this.type = "subtype-group", this._debouncedSaveOperations = L(async (e4, t3, r2) => {
      const { save: s7, saveAs: i4 } = await import("./featureLayerUtils-XSPSJ4JS.js");
      switch (e4) {
        case 0:
          return s7(this, t3);
        case 1:
          return i4(this, r2, t3);
      }
    }), this.addHandles(l(() => this.sublayers, (e4, t3) => this._handleSublayersChange(e4, t3), U));
  }
  destroy() {
    this.source?.destroy();
  }
  normalizeCtorArgs(e3, t3) {
    return "string" == typeof e3 ? { url: e3, ...t3 } : e3;
  }
  load(e3) {
    const t3 = null != e3 ? e3.signal : null, r2 = this.loadFromPortal({ supportedTypes: ["Feature Service"] }, e3).catch(f).then(async () => {
      if (!this.url) throw new s("subtype-grouplayer:missing-url-or-source", "SubtypeGroupLayer must be created with either a url or a portal item");
      if (null == this.layerId) throw new s("subtype-grouplayer:missing-layerid", "layerId is required for a SubtypeGroupLayer created with url");
      this._initLayerProperties(await this.createGraphicsSource(t3));
    }).then(() => H(this, "load", e3));
    return this.addResolvingPromise(r2), Promise.resolve(this);
  }
  get createQueryVersion() {
    return this.commitProperty("definitionExpression"), this.commitProperty("timeExtent"), this.commitProperty("timeOffset"), this.commitProperty("geometryType"), this.commitProperty("gdbVersion"), this.commitProperty("historicMoment"), this.commitProperty("returnZ"), this.commitProperty("capabilities"), this.commitProperty("returnM"), (this._get("createQueryVersion") ?? 0) + 1;
  }
  get editingEnabled() {
    return this.loaded && null != this.capabilities && this.capabilities.operations.supportsEditing && this.userHasEditingPrivileges;
  }
  get effectiveEditingEnabled() {
    return Y(this);
  }
  get operationalLayerType() {
    return this.isTable ? "SubtypeGroupTable" : "SubtypeGroupLayer";
  }
  set source(e3) {
    this._get("source") !== e3 && this._set("source", e3);
  }
  readTitleFromService(e3, { name: t3 }) {
    return this.url ? w(this.url, t3) : t3;
  }
  async addAttachment(e3, t3) {
    const r2 = await F3(this, e3, t3, se);
    return this.lastEditsEventDate = /* @__PURE__ */ new Date(), r2;
  }
  async updateAttachment(e3, t3, r2) {
    const s7 = await P(this, e3, t3, r2, se);
    return this.lastEditsEventDate = /* @__PURE__ */ new Date(), s7;
  }
  async applyEdits(e3, t3) {
    return q2(this, e3, t3);
  }
  async createGraphicsSource(e3) {
    const { default: t3 } = await p(import("./FeatureLayerSource-ALLV5SO3.js"), e3);
    return new t3({ layer: this, supportedSourceTypes: this.supportedSourceTypes }).load({ signal: e3 });
  }
  createQuery() {
    const e3 = R(this), t3 = this.sublayers.map((e4) => e4.subtypeCode);
    return e3.where = l5(`${this.subtypeField} IN (${t3.join(",")})`, this.definitionExpression), e3;
  }
  async deleteAttachments(e3, t3) {
    const r2 = await v(this, e3, t3, se);
    return this.lastEditsEventDate = /* @__PURE__ */ new Date(), r2;
  }
  async fetchRecomputedExtents(e3) {
    return O2(this, e3, se);
  }
  findSublayerForFeature(e3) {
    const t3 = this.fieldsIndex.get(this.subtypeField), r2 = e3.attributes[t3.name];
    return this.findSublayerForSubtypeCode(r2);
  }
  findSublayerForSubtypeCode(e3) {
    return this._sublayerLookup.get(e3);
  }
  getFieldDomain(e3, t3) {
    if (!t3?.excludeImpliedDomains) {
      const t4 = U2(this, e3);
      if (t4) return t4;
    }
    const r2 = Q(this, t3?.feature);
    if (r2) {
      const t4 = r2.domains?.[e3];
      return "inherited" === t4?.type ? this._getLayerDomain(e3) : t4;
    }
    return this._getLayerDomain(e3);
  }
  loadAll() {
    return l2(this, (e3) => {
      e3(this.sublayers);
    });
  }
  async queryAttachments(e3, t3) {
    return A(this, e3, t3, se);
  }
  async queryFeatures(e3, t3) {
    const r2 = await this.load(), s7 = b.from(e3) ?? r2.createQuery(), i4 = s7.outFields ?? [];
    i4.includes(this.subtypeField) || (i4.push(this.subtypeField), s7.outFields = i4);
    const o5 = await r2.source.queryFeatures(s7, t3);
    if (o5?.features) for (const a8 of o5.features) {
      const e4 = this.findSublayerForFeature(a8);
      a8.origin = e4?.graphicOrigin, a8.layer = a8.sourceLayer = this.findSublayerForFeature(a8);
    }
    return o5;
  }
  async queryObjectIds(e3, t3) {
    return (await L2(this, e3, t3, se)).filter(n);
  }
  async queryFeatureCount(e3, t3) {
    return E(this, e3, t3, se);
  }
  async queryExtent(e3, t3) {
    return D(this, e3, t3, se);
  }
  async queryRelatedFeatures(e3, t3) {
    return T(this, e3, t3, se);
  }
  async queryRelatedFeaturesCount(e3, t3) {
    return C(this, e3, t3, se);
  }
  async save(e3) {
    return this._debouncedSaveOperations(0, e3);
  }
  async saveAs(e3, t3) {
    return this._debouncedSaveOperations(1, t3, e3);
  }
  write(e3, t3) {
    const { origin: r2, layerContainerType: i4, messages: o5 } = t3;
    if (this.isTable) {
      if ("web-scene" === r2 || "web-map" === r2 && "tables" !== i4) return o5?.push(ie(this, "using a table source cannot be written to web scenes and web maps")), null;
    } else if (this.loaded && "web-map" === r2 && "tables" === i4) return o5?.push(ie(this, "using a non-table source cannot be written to tables in web maps")), null;
    return this.sublayers?.length ? super.write(e3, t3) : (o5?.push(new s("web-document-write:invalid-property", `Layer (${this.title}, ${this.id}) of type '${this.declaredClass}' has invalid value for 'sublayers' property. 'sublayers' collection should contain at least one sublayer`, { layer: this })), null);
  }
  serviceSupportsSpatialReference(e3) {
    return !!this.loaded && t2(this, e3);
  }
  async getFeatureTitle(e3, t3) {
    const r2 = this.findSublayerForFeature(e3);
    return r2 ? await r2.getFeatureTitle(e3, t3) : this._getFeatureTitleForUnknownSublayer(e3);
  }
  async getFeatureTitles(e3, t3) {
    const r2 = /* @__PURE__ */ new Map(), s7 = /* @__PURE__ */ new Map(), i4 = [s7];
    e3.forEach((e4) => {
      const t4 = this.findSublayerForFeature(e4);
      if (t4) e2(r2, t4, () => []).push(e4);
      else {
        const t5 = e4.getObjectId() ?? e4.attributes[this.objectIdField];
        s7.set(t5, this._getFeatureTitleForUnknownSublayer(e4));
      }
    });
    const a8 = await Promise.all(Array.from(r2).map(([e4, r3]) => e4.getFeatureTitles(r3, t3)));
    return a8.forEach((e4) => i4.push(e4)), new Map(i4.flatMap((e4) => [...e4]));
  }
  get featureTitleFields() {
    const e3 = /* @__PURE__ */ new Set();
    for (const t3 of this.sublayers) {
      const r2 = t3.featureTitleFields;
      for (const t4 of r2) e3.add(t4);
    }
    return [...e3];
  }
  _getLayerDomain(e3) {
    const t3 = this.fieldsIndex.get(e3);
    return t3 ? t3.domain : null;
  }
  _initLayerProperties(e3) {
    this._set("source", e3);
    const { sourceJSON: t3 } = e3;
    if (t3 && (this.sourceJSON = t3, this.read(t3, { origin: "service", url: this.parsedUrl })), !this.subtypes?.length) throw new s("subtype-grouplayer:missing-subtypes", "SubtypeGroupLayer must be created using a layer with subtypes");
    this._verifyFields(), F4(this.timeInfo, this.fieldsIndex);
  }
  async hasDataChanged() {
    return B(this);
  }
  _verifyFields() {
    const e3 = this.parsedUrl?.path ?? "undefined";
    this.objectIdField || console.log("SubtypeGroupLayer: 'objectIdField' property is not defined (url: " + e3 + ")"), this.isTable || -1 !== e3.search(/\/FeatureServer\//i) || this.fields?.some((e4) => "geometry" === e4.type) || console.log("SubtypeGroupLayer: unable to find field of type 'geometry' in the layer 'fields' list. If you are using a map service layer, features will not have geometry (url: " + e3 + ")");
  }
  _handleSublayersChange(e3, t3) {
    t3 && (t3.forEach((e4) => {
      e4.parent = null;
    }), this.removeHandles("sublayers-owner"), this._sublayerLookup.clear()), e3 && (e3.forEach((e4) => {
      e4.parent = this, this._sublayerLookup.set(e4.subtypeCode, e4);
    }), this.addHandles([e3.on("after-add", ({ item: e4 }) => {
      e4.parent = this, this._sublayerLookup.set(e4.subtypeCode, e4);
    }), e3.on("after-remove", ({ item: e4 }) => {
      e4.parent = null, this._sublayerLookup.delete(e4.subtypeCode);
    })], "sublayers-owner"));
  }
  _getFeatureTitleForUnknownSublayer(e3) {
    const { displayField: t3, fieldsIndex: r2, objectIdField: s7 } = this;
    if (t3 && r2.has(t3)) return e3.attributes[r2.get(t3).name] ?? "";
    const i4 = e3.getObjectId();
    return null != i4 ? i4.toString() : s7 && r2.has(s7) ? e3.attributes[r2.get(s7).name] ?? "" : "";
  }
};
__decorate([m({ readOnly: true })], ue.prototype, "createQueryVersion", null), __decorate([m({ readOnly: true })], ue.prototype, "editingEnabled", null), __decorate([m({ readOnly: true })], ue.prototype, "effectiveEditingEnabled", null), __decorate([m({ ...ae.fields, readOnly: true, json: { origins: { service: { read: true } }, read: false } })], ue.prototype, "fields", void 0), __decorate([m(ae.fieldsIndex)], ue.prototype, "fieldsIndex", void 0), __decorate([m(u5)], ue.prototype, "id", void 0), __decorate([m({ type: ["show", "hide", "hide-children"], json: { origins: { "portal-item": { read: false, write: false } } } })], ue.prototype, "listMode", void 0), __decorate([m({ type: ["SubtypeGroupLayer", "SubtypeGroupTable"], json: { ...ne(), origins: { "web-document": ne(), "portal-item": ne() } } })], ue.prototype, "operationalLayerType", null), __decorate([m(ae.outFields)], ue.prototype, "outFields", void 0), __decorate([m({ clonable: false })], ue.prototype, "source", null), __decorate([m({ type: O.ofType(X), json: { origins: { service: { read: { source: "subtypes", reader(e3, t3, s7) {
  let i4 = null;
  if (this.useUniqueColorsForSublayers) {
    const r2 = c3(t3, s7);
    i4 = r2 ? a7(e3.length, r2) : null;
  }
  const o5 = e3.map(({ code: e4 }, r2) => {
    const o6 = new X({ subtypeCode: e4 });
    o6.read(t3, s7);
    const a8 = i4?.[r2];
    return a8 && o6.read({ drawingInfo: { renderer: a8.toJSON() } }, s7), o6;
  });
  return new (O.ofType(X))(o5);
} } } }, read: { source: ["layers", "tables"], reader(e3, t3, s7) {
  let i4;
  return "SubtypeGroupLayer" === t3.layerType && t3.layers?.length ? i4 = oe(t3.layers, s7) : "SubtypeGroupTable" === t3.layerType && t3.tables?.length && (i4 = oe(t3.tables, s7)), new (O.ofType(X))(i4);
} }, write: { ignoreOrigin: true, writer(e3, t3, r2, s7) {
  const i4 = [];
  for (const o5 of e3) {
    const e4 = o5.write({}, s7);
    i4.push(e4);
  }
  this.isTable ? t3.tables = i4 : t3.layers = i4;
} } } })], ue.prototype, "sublayers", void 0), __decorate([m()], ue.prototype, "useUniqueColorsForSublayers", void 0), __decorate([m({ type: u4 })], ue.prototype, "timeInfo", void 0), __decorate([m({ json: { origins: { "portal-item": { write: { enabled: true, ignoreOrigin: true, writerEnsuresNonNull: true } } } } })], ue.prototype, "title", void 0), __decorate([o("service", "title", ["name"])], ue.prototype, "readTitleFromService", null), __decorate([m({ json: { read: false } })], ue.prototype, "type", void 0), __decorate([m({ clonable: false, readOnly: true })], ue.prototype, "featureTitleFields", null), ue = __decorate([a2("esri.layers.SubtypeGroupLayer")], ue);
var le = ue;
export {
  le as default
};
//# sourceMappingURL=SubtypeGroupLayer-P5FFNO7A.js.map
