import {
  e as e2,
  t as t3
} from "./chunk-MBQEPUQX.js";
import {
  I,
  a as a2,
  d as d3,
  h,
  l as l5,
  n as n3,
  w as w2,
  y as y2
} from "./chunk-ODQ5APZK.js";
import {
  t as t2
} from "./chunk-G5IXTUNN.js";
import {
  m as m3,
  m2 as m4,
  m3 as m5,
  n as n2,
  s as s4
} from "./chunk-ZNQKJRCD.js";
import {
  B as B2,
  M as M2,
  S as S2,
  f as f4,
  g as g2,
  h as h2,
  w,
  x
} from "./chunk-BA6HYZ35.js";
import {
  b as b2
} from "./chunk-SJB744AD.js";
import {
  $,
  B,
  C,
  E,
  G,
  L as L2,
  P,
  U,
  d as d2,
  f as f3,
  g,
  k as k2,
  m as m2,
  p as p2,
  v
} from "./chunk-WM2VG5F2.js";
import {
  s as s3
} from "./chunk-VGXUPJSS.js";
import {
  r as r2
} from "./chunk-DLM5SBNY.js";
import {
  Z
} from "./chunk-2HGIYEIL.js";
import {
  ut
} from "./chunk-XX3OKYJS.js";
import {
  G as G3
} from "./chunk-XDLV73DB.js";
import {
  P as P2
} from "./chunk-6VL5D5UP.js";
import {
  i as i2
} from "./chunk-AQFRVV3U.js";
import {
  L,
  M,
  k,
  u as u2
} from "./chunk-HWUOAPTX.js";
import {
  Fe,
  Ie,
  be,
  e2 as e3,
  we,
  xe
} from "./chunk-MC6NAKKX.js";
import {
  f as f2,
  m,
  y
} from "./chunk-GD4FJL3C.js";
import {
  G as G2
} from "./chunk-2LC2762W.js";
import {
  d3 as d,
  f4 as f,
  l2 as l3,
  l3 as l4,
  r3
} from "./chunk-PZ5RULLK.js";
import {
  e,
  i
} from "./chunk-FPMLKIDB.js";
import {
  n
} from "./chunk-THQO67BJ.js";
import {
  DateTime
} from "./chunk-4YDOPHTZ.js";
import {
  T,
  ae,
  p
} from "./chunk-NMQNUPE4.js";
import {
  t
} from "./chunk-V2H77UEV.js";
import {
  l2 as l,
  l3 as l2,
  s as s2,
  u2 as u
} from "./chunk-GNMPGHLQ.js";
import {
  a,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  S,
  b,
  r
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/layers/graphics/data/attributeSupport.js
var s5 = new r2(50, 500);
var t4 = "unsupported-query";
var n4 = " as ";
var o = /* @__PURE__ */ new Set(["esriFieldTypeOID", "esriFieldTypeSmallInteger", "esriFieldTypeBigInteger", "esriFieldTypeInteger", "esriFieldTypeSingle", "esriFieldTypeDouble", "esriFieldTypeLong"]);
var a3 = /* @__PURE__ */ new Set(["esriFieldTypeDate", "esriFieldTypeDateOnly", "esriFieldTypeTimeOnly", "esriFieldTypeTimestampOffset"]);
var l6 = /* @__PURE__ */ new Set(["esriFieldTypeString", "esriFieldTypeGUID", "esriFieldTypeGlobalID", ...o, ...a3]);
function d4(i3, r5, n5 = {}) {
  const o2 = c(r5, i3);
  if (!o2) {
    const n6 = s5.getError(r5, i3);
    throw new s(t4, "invalid SQL expression", { expression: r5, error: n6 });
  }
  const a4 = n5.expressionName || "expression";
  if (n5.validateStandardized && !o2.isStandardized) throw new s(t4, `${a4} is not standard`, { expression: r5 });
  if (n5.validateAggregate && !o2.isAggregate) throw new s(t4, `${a4} does not contain a valid aggregate function`, { expression: r5 });
  return o2.fieldNames;
}
function p3(e5, i3, r5, s7) {
  if (!r5) return true;
  const t6 = "where clause";
  return g3(e5, i3, d4(e5, r5, { validateStandardized: true, expressionName: t6 }), { expressionName: t6, query: s7 }), true;
}
function f5(i3, r5, s7, n5, o2) {
  if (!s7) return true;
  const a4 = "having clause", l7 = d4(i3, s7, { validateAggregate: true, expressionName: a4 });
  g3(i3, r5, l7, { expressionName: a4, query: o2 });
  const p5 = c(s7, i3), f7 = p5?.getExpressions().every((e5) => {
    const { aggregateType: r6, field: s8 } = e5, t6 = i3.get(s8)?.name;
    return n5.some((e6) => {
      const { onStatisticField: s9, statisticType: n6 } = e6, o3 = i3.get(s9)?.name;
      return o3 === t6 && n6.toLowerCase().trim() === r6;
    });
  });
  if (!f7) throw new s(t4, "expressions in having clause should also exist in outStatistics", { having: s7 });
  return true;
}
function c(e5, i3) {
  return e5 ? s5.get(e5, i3) : null;
}
function u3(e5) {
  return /\((.*?)\)/.test(e5) ? e5 : e5.split(n4)[0];
}
function y3(e5) {
  return e5.split(n4)[1];
}
function g3(i3, r5, s7, n5 = {}) {
  const o2 = /* @__PURE__ */ new Map();
  if (m6(o2, i3, r5, n5.allowedFieldTypes ?? l6, s7), o2.size) {
    const i4 = n5.expressionName ?? "expression";
    throw new s(t4, `${i4} contains invalid or missing fields`, { errors: Array.from(o2.values()), query: n5.query });
  }
}
function m6(e5, i3, r5, s7, t6) {
  const n5 = t6.includes("*") ? [...r5, ...t6.filter((e6) => "*" !== e6)] : t6;
  for (const a4 of n5) {
    if (i3.get(a4)) T2(e5, i3, r5, s7, a4);
    else try {
      const t7 = d4(i3, u3(a4), { validateStandardized: true });
      for (const n6 of t7) T2(e5, i3, r5, s7, n6);
    } catch (o2) {
      e5.set(a4, { type: "expression-error", expression: a4, error: o2 });
    }
  }
}
function T2(e5, i3, s7, t6, n5) {
  const o2 = i3.get(n5);
  o2 ? s7.has(o2.name) ? "all" !== t6 && false === t6?.has(o2.type) && e5.set(n5, { type: "invalid-type", fieldName: o2.name, fieldType: i2.fromJSON(o2.type), allowedFieldTypes: Array.from(t6, (e6) => i2.fromJSON(e6)) }) : e5.set(n5, { type: "missing-field", fieldName: o2.name }) : e5.set(n5, { type: "invalid-field", fieldName: n5 });
}

// node_modules/@arcgis/core/layers/graphics/data/AttributesBuilder.js
var c2 = class {
  constructor(s7, a4, l7) {
    this._fieldDataCache = /* @__PURE__ */ new Map(), this._returnDistinctMap = /* @__PURE__ */ new Map(), this.returnDistinctValues = s7.returnDistinctValues ?? false, this.fieldsIndex = l7, this.featureAdapter = a4;
    const r5 = s7.outFields;
    if (r5 && !r5.includes("*")) {
      this.outFields = r5;
      let s8 = 0;
      for (const a5 of r5) {
        const r6 = u3(a5), n5 = this.fieldsIndex.get(r6), u5 = n5 ? null : c(r6, l7), o2 = n5 ? n5.name : y3(a5) || "FIELD_EXP_" + s8++;
        this._fieldDataCache.set(a5, { alias: o2, clause: u5 });
      }
    }
  }
  countDistinctValues(t6) {
    return this.returnDistinctValues ? (t6.forEach((t7) => this.getAttributes(t7)), this._returnDistinctMap.size) : t6.length;
  }
  getAttributes(t6) {
    const e5 = this._processAttributesForOutFields(t6);
    return this._processAttributesForDistinctValues(e5);
  }
  getFieldValue(t6, i3, s7) {
    const a4 = s7 ? s7.name : i3;
    let l7 = null;
    return this._fieldDataCache.has(a4) ? l7 = this._fieldDataCache.get(a4)?.clause : s7 || (l7 = c(i3, this.fieldsIndex), this._fieldDataCache.set(a4, { alias: a4, clause: l7 })), s7 ? this.featureAdapter.getAttribute(t6, a4) : l7?.calculateValue(t6, this.featureAdapter);
  }
  getDataValues(t6, e5, i3 = true) {
    const s7 = e5.normalizationType, d6 = e5.normalizationTotal, c4 = this.fieldsIndex.get(e5.field), h4 = be(c4) || we(c4), f7 = xe(c4);
    return t6.map((t7) => {
      let a4 = e5.field && this.getFieldValue(t7, e5.field, this.fieldsIndex.get(e5.field));
      if (e5.field2 ? (a4 = `${m2(a4)}${e5.fieldDelimiter}${m2(this.getFieldValue(t7, e5.field2, this.fieldsIndex.get(e5.field2)))}`, e5.field3 && (a4 = `${a4}${e5.fieldDelimiter}${m2(this.getFieldValue(t7, e5.field3, this.fieldsIndex.get(e5.field3)))}`)) : "string" == typeof a4 && i3 && (h4 ? a4 = a4 ? new Date(a4).getTime() : null : f7 && (a4 = a4 ? b2(a4) : null)), s7 && Number.isFinite(a4)) {
        const i4 = "field" === s7 && e5.normalizationField ? this.getFieldValue(t7, e5.normalizationField, this.fieldsIndex.get(e5.normalizationField)) : null;
        a4 = B(a4, s7, i4, d6);
      }
      return a4;
    });
  }
  async getExpressionValues(t6, e5, i3, a4, l7) {
    const { arcadeUtils: r5 } = await e3(), n5 = r5.hasGeometryOperations(e5);
    n5 && await r5.enableGeometryOperations();
    const u5 = r5.createFunction(e5), o2 = r5.getViewInfo(i3), c4 = { fields: this.fieldsIndex.fields };
    return t6.map((t7) => {
      const e6 = { attributes: this.featureAdapter.getAttributes(t7), layer: c4, geometry: n5 ? { ...a2(a4.geometryType, a4.hasZ, a4.hasM, this.featureAdapter.getGeometry(t7)), spatialReference: i3?.spatialReference } : null }, d6 = r5.createExecContext(e6, o2, l7);
      return r5.executeFunction(u5, d6);
    });
  }
  validateItem(t6, i3) {
    return this._fieldDataCache.has(i3) || this._fieldDataCache.set(i3, { alias: i3, clause: c(i3, this.fieldsIndex) }), this._fieldDataCache.get(i3)?.clause?.testFeature(t6, this.featureAdapter) ?? false;
  }
  validateItems(t6, i3) {
    return this._fieldDataCache.has(i3) || this._fieldDataCache.set(i3, { alias: i3, clause: c(i3, this.fieldsIndex) }), this._fieldDataCache.get(i3)?.clause?.testSet(t6, this.featureAdapter) ?? false;
  }
  _processAttributesForOutFields(t6) {
    const e5 = this.outFields;
    if (!e5?.length) return this.featureAdapter.getAttributes(t6);
    const i3 = {};
    for (const s7 of e5) {
      const { alias: e6, clause: a4 } = this._fieldDataCache.get(s7);
      i3[e6] = a4 ? a4.calculateValue(t6, this.featureAdapter) : this.featureAdapter.getAttribute(t6, e6);
    }
    return i3;
  }
  _processAttributesForDistinctValues(t6) {
    if (null == t6 || !this.returnDistinctValues) return t6;
    const e5 = this.outFields, i3 = [];
    if (e5) for (const l7 of e5) {
      const { alias: e6 } = this._fieldDataCache.get(l7);
      i3.push(t6[e6]);
    }
    else for (const l7 in t6) i3.push(t6[l7]);
    const s7 = `${(e5 || ["*"]).join(",")}=${i3.join(",")}`;
    let a4 = this._returnDistinctMap.get(s7) || 0;
    return this._returnDistinctMap.set(s7, ++a4), a4 > 1 ? null : t6;
  }
};

// node_modules/@arcgis/core/layers/graphics/data/QueryEngineResult.js
var O = "bin";
var E2 = class {
  constructor(e5, t6, i3) {
    this.items = e5, this.query = t6, this.geometryType = i3.geometryType, this.hasM = i3.hasM, this.hasZ = i3.hasZ, this.fieldsIndex = i3.fieldsIndex, this.objectIdField = i3.objectIdField, this.spatialReference = i3.spatialReference, this.featureAdapter = i3.featureAdapter;
  }
  get size() {
    return this.items.length;
  }
  createQueryResponseForCount() {
    const e5 = new c2(this.query, this.featureAdapter, this.fieldsIndex);
    if (!this.query.outStatistics) return e5.countDistinctValues(this.items);
    const { groupByFieldsForStatistics: t6, having: i3, outStatistics: s7 } = this.query, a4 = t6?.length;
    if (!!!a4) return 1;
    const r5 = /* @__PURE__ */ new Map(), n5 = /* @__PURE__ */ new Map(), o2 = /* @__PURE__ */ new Set();
    for (const l7 of s7) {
      const { statisticType: s8 } = l7, a5 = "exceedslimit" !== s8 ? l7.onStatisticField : void 0;
      if (!n5.has(a5)) {
        const i4 = [];
        for (const s9 of t6) {
          const t7 = this._getAttributeValues(e5, s9, this.items, r5);
          i4.push(t7);
        }
        n5.set(a5, this._calculateUniqueValues(i4, this.items, e5.returnDistinctValues));
      }
      const u5 = n5.get(a5);
      for (const t7 in u5) {
        const { data: s9, items: a6 } = u5[t7], r6 = s9.join(",");
        i3 && !e5.validateItems(a6, i3) || o2.add(r6);
      }
    }
    return o2.size;
  }
  async createQueryResponse() {
    let e5;
    if (this.query.outStatistics) {
      e5 = this.query.outStatistics.some((e6) => "exceedslimit" === e6.statisticType) ? this._createExceedsLimitQueryResponse() : await this._createStatisticsQueryResponse(this.query, this.items);
    } else e5 = this._createFeatureQueryResponse(this.query);
    if (this.query.returnQueryGeometry) {
      const t6 = this.query.geometry;
      p(this.query.outSR) && !T(t6.spatialReference, this.query.outSR) ? e5.queryGeometry = h({ spatialReference: this.query.outSR, ...g2(t6, t6.spatialReference, this.query.outSR) }) : e5.queryGeometry = h({ spatialReference: this.query.outSR, ...t6 });
    }
    return e5;
  }
  createSnappingResponse(e5, t6, i3) {
    const s7 = this.featureAdapter, a4 = Q(this.hasZ, this.hasM), { point: r5, mode: n5 } = e5, o2 = "number" == typeof e5.distance ? e5.distance : e5.distance.x, l7 = "number" == typeof e5.distance ? e5.distance : e5.distance.y, u5 = { candidates: [] }, c4 = "esriGeometryPolygon" === this.geometryType, m8 = "esriGeometryPolyline" === this.geometryType || "esriGeometryPoint" === this.geometryType, d6 = this._getPointCreator(n5, t6, this.spatialReference, i3), h4 = new U2(null, 0), y5 = new U2(null, 0), g4 = { x: 0, y: 0, z: 0 };
    for (const x2 of this.items) {
      const t7 = s7.getGeometry(x2);
      if (null == t7) continue;
      const { coords: i4 } = t7, n6 = t7.isPoint ? J : t7.lengths;
      if (h4.coords = i4, y5.coords = i4, e5.returnEdge) {
        let e6 = 0;
        for (let t8 = 0; t8 < n6.length; t8++) {
          const i5 = n6[t8], m9 = e6;
          for (let t9 = 0; t9 < i5; t9++, e6 += a4) {
            if (!c4 && t9 === i5 - 1) continue;
            const n7 = h4;
            n7.coordsIndex = e6;
            const p5 = y5;
            p5.coordsIndex = t9 === i5 - 1 ? m9 : e6 + a4;
            const T3 = g4;
            if (!H(g4, r5, n7, p5)) continue;
            const F2 = (r5.x - T3.x) / o2, I2 = (r5.y - T3.y) / l7, _ = F2 * F2 + I2 * I2;
            _ <= 1 && u5.candidates.push(e2(s7.getObjectId(x2), d6(T3), Math.sqrt(_), d6(n7), d6(p5)));
          }
        }
      }
      if ("all" === e5.vertexMode) {
        let e6 = 0;
        for (let t8 = 0; t8 < n6.length; t8++) {
          const i5 = n6[t8], m9 = e6, f7 = y5;
          f7.coordsIndex = m9;
          for (let t9 = 0; t9 < i5; t9++, e6 += a4) {
            const a5 = h4;
            if (a5.coordsIndex = e6, c4 && t9 === i5 - 1 && a5.x === f7.x && a5.y === f7.y) continue;
            const n7 = (r5.x - a5.x) / o2, m10 = (r5.y - a5.y) / l7, y6 = n7 * n7 + m10 * m10;
            y6 <= 1 && u5.candidates.push(t3(s7.getObjectId(x2), d6(a5), Math.sqrt(y6)));
          }
        }
      } else if (m8 && "ends" === e5.vertexMode) {
        let e6 = 0;
        const t8 = [];
        for (let i5 = 0; i5 < n6.length; i5++) {
          t8.push(e6);
          const s8 = n6[i5];
          e6 += s8 * a4, !c4 && s8 > 1 && t8.push(e6 - a4);
        }
        for (const i5 of t8) {
          const e7 = h4;
          e7.coordsIndex = i5;
          const t9 = (r5.x - e7.x) / o2, a5 = (r5.y - e7.y) / l7, n7 = t9 * t9 + a5 * a5;
          n7 <= 1 && u5.candidates.push(t3(s7.getObjectId(x2), d6(e7), Math.sqrt(n7)));
        }
      }
    }
    return u5.candidates.sort((e6, t7) => e6.distance - t7.distance), u5;
  }
  _getPointCreator(e5, t6, i3, s7) {
    const a4 = null == s7 || T(i3, s7) ? (e6) => e6 : (e6) => g2(e6, i3, s7), { hasZ: r5 } = this, n5 = 0;
    return "3d" === e5 ? r5 && t6 ? ({ x: e6, y: t7, z: i4 }) => a4({ x: e6, y: t7, z: i4 }) : ({ x: e6, y: t7 }) => a4({ x: e6, y: t7, z: n5 }) : ({ x: e6, y: t7 }) => a4({ x: e6, y: t7 });
  }
  async createSummaryStatisticsResponse(e5) {
    const { field: t6, valueExpression: i3, normalizationField: s7, normalizationType: a4, normalizationTotal: r5, minValue: n5, maxValue: o2, scale: l7, timeZone: u5, outStatisticTypes: c4 } = e5, m8 = this.fieldsIndex.get(t6), d6 = Ie(m8) || be(m8) || we(m8), h4 = await this._getDataValues({ field: t6, valueExpression: i3, normalizationField: s7, normalizationType: a4, normalizationTotal: r5, scale: l7, timeZone: u5 }, this.items), f7 = d2({ normalizationType: a4, normalizationField: s7, minValue: n5, maxValue: o2 }), p5 = { value: 0.5, fieldType: m8?.type }, F2 = Fe(m8) ? f3({ values: h4, supportsNullCount: f7, percentileParams: p5, outStatisticTypes: c4 }) : p2({ values: h4, minValue: n5, maxValue: o2, useSampleStdDev: !a4, supportsNullCount: f7, percentileParams: p5, outStatisticTypes: c4 });
    return C(F2, c4, d6);
  }
  async createUniqueValuesResponse(e5) {
    const { field: t6, valueExpression: i3, domains: s7, returnAllCodedValues: a4, scale: r5, timeZone: n5 } = e5, o2 = await this._getDataValues({ field: t6, field2: e5.field2, field3: e5.field3, fieldDelimiter: e5.fieldDelimiter, valueExpression: i3, scale: r5, timeZone: n5 }, this.items, false), l7 = k2(o2);
    return $(l7, s7, a4, e5.fieldDelimiter);
  }
  async createClassBreaksResponse(e5) {
    const { field: t6, valueExpression: i3, normalizationField: s7, normalizationType: a4, normalizationTotal: r5, classificationMethod: n5, standardDeviationInterval: o2, minValue: l7, maxValue: u5, numClasses: c4, scale: m8, timeZone: d6 } = e5, h4 = await this._getDataValues({ field: t6, valueExpression: i3, normalizationField: s7, normalizationType: a4, normalizationTotal: r5, scale: m8, timeZone: d6 }, this.items), f7 = E(h4, { field: t6, normalizationField: s7, normalizationType: a4, normalizationTotal: r5, classificationMethod: n5, standardDeviationInterval: o2, minValue: l7, maxValue: u5, numClasses: c4 });
    return P(f7, n5);
  }
  async createHistogramResponse(e5) {
    const { field: t6, valueExpression: i3, normalizationField: s7, normalizationType: a4, normalizationTotal: r5, classificationMethod: n5, standardDeviationInterval: o2, minValue: l7, maxValue: u5, numBins: c4, scale: m8, timeZone: d6 } = e5, h4 = await this._getDataValues({ field: t6, valueExpression: i3, normalizationField: s7, normalizationType: a4, normalizationTotal: r5, scale: m8, timeZone: d6 }, this.items);
    return U(h4, { field: t6, normalizationField: s7, normalizationType: a4, normalizationTotal: r5, classificationMethod: n5, standardDeviationInterval: o2, minValue: l7, maxValue: u5, numBins: c4 });
  }
  _sortFeatures(e5, t6, i3) {
    if (e5.length > 1 && t6?.length) for (const s7 of t6.slice().reverse()) {
      const t7 = s7.split(" "), a4 = t7[0], r5 = this.fieldsIndex.get(a4), n5 = !!t7[1] && "desc" === t7[1].toLowerCase(), o2 = g(r5?.type, n5);
      e5.sort((e6, t8) => {
        const s8 = i3(e6, a4, r5), n6 = i3(t8, a4, r5);
        return o2(s8, n6);
      });
    }
  }
  _createFeatureQueryResponse(e5) {
    const { items: t6, geometryType: i3, hasM: s7, hasZ: a4, objectIdField: n5, spatialReference: o2 } = this, { outFields: l7, outSR: c4, quantizationParameters: m8, resultRecordCount: d6, resultOffset: h4, returnZ: f7, returnM: p5 } = e5, y5 = null != d6 && t6.length > (h4 || 0) + d6, g4 = l7 && (l7.includes("*") ? [...this.fieldsIndex.fields] : l7.map((e6) => this.fieldsIndex.get(e6)));
    return { exceededTransferLimit: y5, features: this._createFeatures(e5, t6), fields: g4, geometryType: i3, hasM: s7 && p5, hasZ: a4 && f7, objectIdFieldName: n5, spatialReference: h(c4 || o2), transform: m8 && s3(m8) || null };
  }
  _createFeatures(e5, t6) {
    const i3 = new c2(e5, this.featureAdapter, this.fieldsIndex), { hasM: s7, hasZ: a4 } = this, { orderByFields: n5, quantizationParameters: o2, returnGeometry: u5, returnCentroid: d6, maxAllowableOffset: h4, resultOffset: f7, resultRecordCount: p5, returnZ: y5 = false, returnM: g4 = false } = e5, x2 = a4 && y5, T3 = s7 && g4;
    let F2 = [], I2 = 0;
    const _ = [...t6];
    if (this._sortFeatures(_, n5, (e6, t7, s8) => i3.getFieldValue(e6, t7, s8)), this.geometryType && (u5 || d6)) {
      const e6 = s3(o2) ?? void 0, t7 = "esriGeometryPolygon" === this.geometryType || "esriGeometryPolyline" === this.geometryType;
      if (u5 && !d6) for (const s8 of _) {
        const a5 = this.featureAdapter.getGeometry(s8), r5 = this._addFeatureJSONMetadata(s8, { attributes: i3.getAttributes(s8), geometry: a2(this.geometryType, this.hasZ, this.hasM, a5, h4, e6, x2, T3) });
        t7 && a5 && !r5.geometry && (r5.centroid = y2(this, this.featureAdapter.getCentroid(s8, this), e6)), F2[I2++] = r5;
      }
      else if (!u5 && d6) for (const s8 of _) F2[I2++] = this._addFeatureJSONMetadata(s8, { attributes: i3.getAttributes(s8), centroid: y2(this, this.featureAdapter.getCentroid(s8, this), e6) });
      else for (const s8 of _) F2[I2++] = this._addFeatureJSONMetadata(s8, { attributes: i3.getAttributes(s8), centroid: y2(this, this.featureAdapter.getCentroid(s8, this), e6), geometry: a2(this.geometryType, this.hasZ, this.hasM, this.featureAdapter.getGeometry(s8), h4, e6, x2, T3) });
    } else for (const r5 of _) {
      const e6 = i3.getAttributes(r5);
      e6 && (F2[I2++] = this._addFeatureJSONMetadata(r5, { attributes: e6 }));
    }
    const S3 = f7 || 0;
    if (null != p5) {
      const e6 = S3 + p5;
      F2 = F2.slice(S3, Math.min(F2.length, e6));
    }
    return F2;
  }
  _addFeatureJSONMetadata(e5, t6) {
    const i3 = this.featureAdapter.getMetadata?.(e5);
    return void 0 !== i3 && (t6.metadata = i3), t6;
  }
  _createExceedsLimitQueryResponse() {
    let e5 = false, t6 = Number.POSITIVE_INFINITY, i3 = Number.POSITIVE_INFINITY, s7 = Number.POSITIVE_INFINITY;
    for (const a4 of this.query.outStatistics ?? []) if ("exceedslimit" === a4.statisticType) {
      t6 = null != a4.maxPointCount ? a4.maxPointCount : Number.POSITIVE_INFINITY, i3 = null != a4.maxRecordCount ? a4.maxRecordCount : Number.POSITIVE_INFINITY, s7 = null != a4.maxVertexCount ? a4.maxVertexCount : Number.POSITIVE_INFINITY;
      break;
    }
    if ("esriGeometryPoint" === this.geometryType) e5 = this.items.length > t6;
    else if (this.items.length > i3) e5 = true;
    else {
      const t7 = Q(this.hasZ, this.hasM), i4 = this.featureAdapter;
      e5 = this.items.reduce((e6, t8) => {
        const s8 = i4.getGeometry(t8);
        return e6 + (null != s8 && s8.coords.length || 0);
      }, 0) / t7 > s7;
    }
    return { fields: [{ name: "exceedslimit", type: "esriFieldTypeInteger", alias: "exceedslimit", sqlType: "sqlTypeInteger", domain: null, defaultValue: null }], features: [{ attributes: { exceedslimit: Number(e5) } }] };
  }
  async _createStatisticsQueryResponse(e5, t6, i3 = { attributes: {} }) {
    const s7 = [], a4 = /* @__PURE__ */ new Map(), r5 = /* @__PURE__ */ new Map(), n5 = /* @__PURE__ */ new Map(), o2 = /* @__PURE__ */ new Map(), u5 = new c2(e5, this.featureAdapter, this.fieldsIndex), c4 = e5.outStatistics, { groupByFieldsForStatistics: m8, having: d6, orderByFields: h4, resultRecordCount: f7 } = e5, p5 = m8?.length, y5 = !!p5, g4 = y5 ? m8[0] : null, x2 = y5 && !this.fieldsIndex.get(g4);
    for (const l7 of c4 ?? []) {
      const { outStatisticFieldName: e6, statisticType: c5 } = l7, h5 = l7, f8 = "exceedslimit" !== c5 ? l7.onStatisticField : void 0, F3 = "percentile_disc" === c5 || "percentile_cont" === c5, I2 = "EnvelopeAggregate" === c5 || "CentroidAggregate" === c5 || "ConvexHullAggregate" === c5, _ = y5 && 1 === p5 && (f8 === g4 || x2) && "count" === c5;
      if (y5) {
        if (!n5.has(f8)) {
          const e7 = [];
          for (const i5 of m8) {
            const s9 = this._getAttributeValues(u5, i5, t6, a4);
            e7.push(s9);
          }
          n5.set(f8, this._calculateUniqueValues(e7, t6, !I2 && u5.returnDistinctValues));
        }
        const i4 = n5.get(f8);
        if (!i4) continue;
        const s8 = Object.keys(i4);
        for (const r6 of s8) {
          const { count: s9, data: n6, items: l8, itemPositions: c6 } = i4[r6], p6 = n6.join(",");
          if (!d6 || u5.validateItems(l8, d6)) {
            const i5 = o2.get(p6) || { attributes: {} };
            if (I2) {
              i5.aggregateGeometries || (i5.aggregateGeometries = {});
              const { aggregateGeometries: e7, outStatisticFieldName: t7 } = await this._getAggregateGeometry(h5, l8);
              i5.aggregateGeometries[t7] = e7;
            } else {
              let r8 = null;
              if (_) r8 = s9;
              else {
                const e7 = this._getAttributeValues(u5, f8, t6, a4), i6 = c6.map((t7) => e7[t7]);
                r8 = F3 && "statisticParameters" in h5 ? this._getPercentileValue(h5, i6) : this._getStatisticValue(h5, i6, null, u5.returnDistinctValues);
              }
              i5.attributes[e6] = r8;
            }
            let r7 = 0;
            m8.forEach((e7, t7) => i5.attributes[this.fieldsIndex.get(e7) ? e7 : "EXPR_" + ++r7] = n6[t7]), o2.set(p6, i5);
          }
        }
      } else if (I2) {
        i3.aggregateGeometries || (i3.aggregateGeometries = {});
        const { aggregateGeometries: e7, outStatisticFieldName: s8 } = await this._getAggregateGeometry(h5, t6);
        i3.aggregateGeometries[s8] = e7;
      } else {
        const s8 = this._getAttributeValues(u5, f8, t6, a4);
        i3.attributes[e6] = F3 && "statisticParameters" in h5 ? this._getPercentileValue(h5, s8) : this._getStatisticValue(h5, s8, r5, u5.returnDistinctValues);
      }
      const S3 = "min" !== c5 && "max" !== c5 || !Fe(this.fieldsIndex.get(f8)) && !this._isAnyDateField(f8) ? null : this.fieldsIndex.get(f8)?.type;
      s7.push({ name: e6, alias: e6, type: S3 || "esriFieldTypeDouble" });
    }
    const F2 = y5 ? Array.from(o2.values()) : [i3];
    return this._sortFeatures(F2, h4, (e6, t7) => e6.attributes[t7]), f7 && (F2.length = Math.min(f7, F2.length)), { fields: s7, features: F2 };
  }
  _isAnyDateField(e5) {
    const t6 = this.fieldsIndex.get(e5);
    return Ie(t6) || be(t6) || we(t6) || xe(t6);
  }
  async _getAggregateGeometry(e5, r5) {
    const { convexHull: n5, union: o2 } = await import("./geometryEngineJSON-MGMVGJHX.js"), { statisticType: l7, outStatisticFieldName: u5 } = e5, { featureAdapter: m8, spatialReference: d6, geometryType: h4, hasZ: f7, hasM: p5 } = this, y5 = r5.map((e6) => a2(h4, f7, p5, m8.getGeometry(e6))), g4 = n5(d6, y5, true)[0], x2 = { aggregateGeometries: null, outStatisticFieldName: null };
    if ("EnvelopeAggregate" === l7) {
      const e6 = g4 ? d(g4) : l3(o2(d6, y5));
      x2.aggregateGeometries = { ...e6, spatialReference: d6 }, x2.outStatisticFieldName = u5 || "extent";
    } else if ("CentroidAggregate" === l7) {
      const e6 = g4 ? l4(g4) : r3(l3(o2(d6, y5)));
      x2.aggregateGeometries = { x: e6[0], y: e6[1], spatialReference: d6 }, x2.outStatisticFieldName = u5 || "centroid";
    } else "ConvexHullAggregate" === l7 && (x2.aggregateGeometries = g4, x2.outStatisticFieldName = u5 || "convexHull");
    return x2;
  }
  _getStatisticValue(e5, t6, i3, s7) {
    const { onStatisticField: a4, statisticType: r5 } = e5;
    let n5 = null;
    n5 = i3?.has(a4) ? i3.get(a4) : Fe(this.fieldsIndex.get(a4)) || this._isAnyDateField(a4) ? f3({ values: t6, returnDistinct: s7 }) : p2({ values: s7 ? [...new Set(t6)] : t6, minValue: null, maxValue: null, useSampleStdDev: true }), i3 && i3.set(a4, n5);
    return n5["var" === r5 ? "variance" : r5];
  }
  _getPercentileValue(e5, t6) {
    const { onStatisticField: i3, statisticParameters: s7, statisticType: a4 } = e5, { value: r5, orderBy: n5 } = s7, o2 = this.fieldsIndex.get(i3);
    return v(t6, { value: r5, orderBy: n5, fieldType: o2?.type, isDiscrete: "percentile_disc" === a4 });
  }
  _getAttributeValues(e5, t6, i3, s7) {
    if (s7.has(t6)) return s7.get(t6);
    const a4 = this.fieldsIndex.get(t6), r5 = i3.map((i4) => e5.getFieldValue(i4, t6, a4));
    return s7.set(t6, r5), r5;
  }
  _calculateUniqueValues(e5, t6, i3) {
    const s7 = {}, a4 = t6.length;
    for (let r5 = 0; r5 < a4; r5++) {
      const a5 = t6[r5], n5 = [];
      for (const t7 of e5) n5.push(t7[r5]);
      const o2 = n5.join(",");
      null == s7[o2] ? s7[o2] = { count: 1, data: n5, items: [a5], itemPositions: [r5] } : (i3 || s7[o2].count++, s7[o2].items.push(a5), s7[o2].itemPositions.push(r5));
    }
    return s7;
  }
  async _getDataValues(t6, i3, s7 = true) {
    const a4 = new c2(this.query, this.featureAdapter, this.fieldsIndex), { valueExpression: r5, scale: n5, timeZone: o2 } = t6;
    return r5 ? a4.getExpressionValues(i3, r5, { viewingMode: "map", scale: n5, spatialReference: this.query.outSR || this.spatialReference }, { geometryType: this.geometryType, hasZ: this.hasZ, hasM: this.hasM }, o2) : a4.getDataValues(i3, a(t6), s7);
  }
  _calculateHistogramBins(e5, t6, i3) {
    if (null == t6.min && null == t6.max) return [];
    const s7 = t6.intervals, a4 = t6.min ?? 0, r5 = t6.max ?? 0, n5 = s7.map(([e6, t7]) => ({ minValue: e6, maxValue: t7, count: 0, items: [] }));
    for (let o2 = 0; o2 < e5.length; o2++) {
      const t7 = e5[o2], l7 = i3[o2];
      if (null != t7 && t7 >= a4 && t7 <= r5) {
        const e6 = L2(s7, t7);
        e6 > -1 && (n5[e6].count++, n5[e6].items.push(l7));
      }
    }
    return n5;
  }
  async createQueryBinsResponse(e5) {
    const t6 = e5.bin?.splitBy;
    if (!t6) return this._createBinsResponse(e5);
    const { value: i3, outAlias: s7, valueType: a4 } = t6, r5 = [], n5 = [{ name: s7 ?? i3, alias: s7 ?? i3, type: a4 ?? "esriFieldTypeString" }, { name: O, alias: O, type: "esriFieldTypeInteger" }], o2 = new c2(e5, this.featureAdapter, this.fieldsIndex), u5 = /* @__PURE__ */ new Map(), c4 = [...this.items];
    this._sortFeatures(c4, [i3], (e6, t7, i4) => o2.getFieldValue(e6, t7, i4));
    const m8 = this._getAttributeValues(o2, i3, c4, u5), d6 = this._calculateUniqueValues([m8], c4, o2.returnDistinctValues);
    for (const l7 in d6) {
      const { items: t7 } = d6[l7], a5 = await this._createBinsResponse(e5, t7);
      if (r5.push(...a5.features.map((e6) => ({ ...e6, attributes: { ...e6.attributes, [s7 ?? i3]: l7 } }))), a5.fields) for (const e6 of a5.fields) n5.some((t8) => t8.name === e6.name) || n5.push(e6);
    }
    return { fields: n5, features: r5 };
  }
  async _createBinsResponse(e5, t6) {
    const i3 = e5.bin;
    switch (t6 = t6 ?? this.items, i3.type) {
      case "autoIntervalBin":
        return this._createAutoIntervalBinsResponse(m3.fromJSON(i3), e5, t6);
      case "dateBin":
        return this._createDateBinsResponse(m4.fromJSON(i3), e5, t6);
      case "fixedBoundariesBin":
        return this._createFixedBoundariesBinsResponse(n2.fromJSON(i3), e5, t6);
      case "fixedIntervalBin":
        return this._createFixedIntervalBinsResponse(m5.fromJSON(i3), e5, t6);
    }
  }
  async _createAutoIntervalBinsResponse(e5, t6, i3) {
    const { field: s7, normalizationField: a4, numBins: r5, normalizationType: n5, normalizationTotal: o2, start: l7, end: u5 } = e5, c4 = await this._getDataValues({ field: e5.field, normalizationField: e5.normalizationField, normalizationType: e5.normalizationType, normalizationTotal: e5.normalizationTotal, timeZone: t6.outTimeReference?.ianaTimeZone }, i3), m8 = G(c4, { field: s7, normalizationField: a4, normalizationType: n5, normalizationTotal: o2, numBins: r5, minValue: h2(l7, false), maxValue: h2(u5, false) }), d6 = this._calculateHistogramBins(c4, m8, i3);
    return this._createFeaturesFromHistogramBins(d6, t6);
  }
  async _createDateBinsResponse(e5, t6, i3) {
    const { field: s7, interval: a4, start: r5, end: n5, snapToData: o2, returnFullIntervalBin: l7 } = e5, u5 = a4.unit, c4 = await this._getDataValues({ field: e5.field, timeZone: t6.outTimeReference?.ianaTimeZone }, i3), m8 = xe(this.fieldsIndex.get(s7)), d6 = s4.toJSON(u5), f7 = c4.filter(Boolean).sort((e6, t7) => e6 - t7), p5 = null != r5 ? h2(r5, m8) : f7[0], y5 = null != n5 ? h2(n5, m8) : f7[f7.length - 1], g4 = [];
    if (null != p5 && null != y5) {
      const e6 = { zone: t6.outTimeReference?.ianaTimeZone ?? n }, i4 = DateTime.fromMillis(p5, e6), s8 = DateTime.fromMillis(y5, e6);
      if ("last" === o2) {
        let e7 = s8;
        for (; e7 > i4; ) {
          const t7 = e7.minus({ [d6]: a4.value });
          if (t7 < i4) {
            g4.unshift([l7 ? t7.toMillis() : i4.toMillis(), e7.toMillis()]);
            break;
          }
          g4.unshift([t7.toMillis(), e7.toMillis()]), e7 = t7;
        }
      } else {
        let e7 = "first" === o2 ? i4 : i4.startOf(d6);
        for (; e7 <= s8; ) {
          const t7 = e7.plus({ [d6]: a4.value });
          if (t7 > s8) {
            g4.push([e7.toMillis(), l7 ? t7.toMillis() : s8.toMillis()]);
            break;
          }
          g4.push([e7.toMillis(), t7.toMillis()]), e7 = t7;
        }
      }
    }
    const x2 = this._calculateHistogramBins(c4, { intervals: g4, min: p5, max: y5 }, i3);
    return this._createFeaturesFromHistogramBins(x2, t6);
  }
  async _createFixedBoundariesBinsResponse(e5, t6, i3) {
    const { field: s7 } = e5, a4 = await this._getDataValues({ field: s7, timeZone: t6.outTimeReference?.ianaTimeZone }, i3), r5 = xe(this.fieldsIndex.get(s7)), n5 = e5.boundaries.map((e6) => h2(e6, r5)).sort((e6, t7) => e6 - t7), o2 = [];
    for (let c4 = 0; c4 < n5.length - 1; c4++) o2.push([n5[c4], n5[c4 + 1]]);
    const l7 = { intervals: o2, min: n5.at(0), max: n5.at(-1) }, u5 = this._calculateHistogramBins(a4, l7, i3);
    return this._createFeaturesFromHistogramBins(u5, t6);
  }
  async _createFixedIntervalBinsResponse(e5, t6, i3) {
    const { field: s7, interval: a4, start: r5, end: n5 } = e5, o2 = await this._getDataValues({ field: e5.field, normalizationField: e5.normalizationField, normalizationType: e5.normalizationType, normalizationTotal: e5.normalizationTotal, timeZone: t6.outTimeReference?.ianaTimeZone }, i3), l7 = xe(this.fieldsIndex.get(s7)), u5 = G(o2, { field: s7, classificationMethod: "defined-interval", definedInterval: a4, minValue: h2(r5, l7), maxValue: h2(n5, l7) }, true), c4 = this._calculateHistogramBins(o2, u5, i3);
    return this._createFeaturesFromHistogramBins(c4, t6);
  }
  async _createFeaturesFromHistogramBins(e5, t6) {
    const { upperBoundaryAlias: i3, lowerBoundaryAlias: s7 } = t6, a4 = s7 || "lowerBoundary", r5 = i3 || "upperBoundary", n5 = [], o2 = [{ name: a4, alias: a4, type: "esriFieldTypeDouble" }, { name: r5, alias: r5, type: "esriFieldTypeDouble" }], l7 = t6.bin?.stackBy?.value, u5 = t6.bin?.stackBy?.outAlias;
    l7 && o2.push({ name: O, alias: O, type: "esriFieldTypeInteger" }, { name: u5 ?? l7, alias: u5 ?? l7, type: "esriFieldTypeString" });
    let c4 = 0;
    const m8 = "dateBin" === t6.bin.type, d6 = t6.outTimeReference?.ianaTimeZone;
    for (const h4 of e5) {
      const { minValue: e6, maxValue: i4, items: s8 } = h4, f7 = { attributes: {} };
      let p5;
      if (f7.attributes[a4] = m8 && d6 && null != e6 ? DateTime.fromMillis(e6, { zone: d6 }).toISO() : e6, f7.attributes[r5] = m8 && d6 && null != i4 ? DateTime.fromMillis(i4, { zone: d6 }).toISO() : i4, l7 ? (p5 = await this._createStatisticsQueryResponse({ ...t6, groupByFieldsForStatistics: [l7], orderByFields: [l7] }, s8), f7.attributes[O] = ++c4, "flat" === t6.bin.jsonStyle ? n5.push(...p5.features.map(({ attributes: { EXPR_1: e7, ...t7 }, ...i5 }) => ({ ...i5, attributes: u5 ?? e7 ? { ...t7, [u5 ?? e7]: e7, ...f7.attributes } : { ...t7, ...f7.attributes } }))) : (f7.stackedAttributes = p5.features.map(({ attributes: { EXPR_1: e7, ...t7 } }) => u5 ?? e7 ? { ...t7, [u5 ?? e7]: e7 } : t7), n5.push(f7))) : (t6.bin?.splitBy && (f7.attributes[O] = ++c4), p5 = await this._createStatisticsQueryResponse(t6, s8, f7), n5.push(f7)), p5.fields) for (const t7 of p5.fields) o2.some((e7) => e7.name === t7.name) || o2.push(t7);
    }
    return "desc" === t6.binOrder && n5.reverse(), { fields: o2, features: n5 };
  }
};
function H(e5, t6, i3, s7) {
  const a4 = s7.x - i3.x, r5 = s7.y - i3.y, n5 = t6.x - i3.x, o2 = t6.y - i3.y, l7 = a4 * a4 + r5 * r5;
  if (0 === l7) return false;
  const u5 = n5 * a4 + o2 * r5, c4 = Math.min(1, Math.max(0, u5 / l7));
  return e5.x = i3.x + a4 * c4, e5.y = i3.y + r5 * c4, true;
}
function Q(e5, t6) {
  return e5 ? t6 ? 4 : 3 : t6 ? 3 : 2;
}
var U2 = class {
  constructor(e5, t6) {
    this.coords = e5, this.coordsIndex = t6;
  }
  get x() {
    return this.coords[this.coordsIndex];
  }
  get y() {
    return this.coords[this.coordsIndex + 1];
  }
  get z() {
    return this.coords[this.coordsIndex + 2];
  }
};
var J = [1];

// node_modules/@arcgis/core/layers/graphics/data/QueryEngineCache.js
var t5 = 5;
var e4 = class {
  constructor() {
    this._storage = /* @__PURE__ */ new Map(), this._purgeInterval = t5, this._sweep = () => {
      if (this._timer = void 0, !this._storage) return;
      const t6 = 1e3 * this._purgeInterval, e5 = performance.now() - t6;
      for (const [s7, r5] of this._storage) {
        if (!(r5.time < e5)) return void (this._storage.size > 0 && (this._timer = setTimeout(this._sweep, t6)));
        this._storage.delete(s7);
      }
    };
  }
  destroy() {
    this._storage?.clear(), this._storage = null, clearTimeout(this._timer);
  }
  put(t6, e5) {
    this._storage?.set(t6, new r4(e5)), this._scheduleSweep();
  }
  get(t6) {
    const e5 = this._storage?.get(t6);
    if (e5) return this._storage?.delete(t6), e5.time = performance.now(), this._storage?.set(t6, e5), e5.items;
  }
  clear() {
    this._storage?.clear();
  }
  _scheduleSweep() {
    this._storage && (this._timer ??= setTimeout(this._sweep, 1e3 * this._purgeInterval));
  }
  get test() {
  }
};
var s6 = 0;
var r4 = class {
  constructor(t6) {
    this.items = t6, this.time = performance.now(), this.id = s6++;
  }
};

// node_modules/@arcgis/core/layers/graphics/data/queryValidationUtils.js
var u4 = "unsupported-query";
async function p4(t6, i3) {
  const s7 = t6.bin;
  if (!s7.onField && !s7.onExpression?.value || "autoIntervalBin" === s7.type && null == s7.parameters.numberOfBins || "dateBin" === s7.type && (null == s7.parameters.number || null == s7.parameters.unit) || "fixedBoundariesBin" === s7.type && null == s7.parameters.boundaries || "fixedIntervalBin" === s7.type && null == s7.parameters.interval) throw new s(u4, "Unsupported query options", { query: t6 });
  return d5(t6, i3);
}
async function d5(t6, { fieldsIndex: i3, geometryType: s7, spatialReference: r5, availableFields: o2 }) {
  if (null != t6.geometryPrecision || t6.multipatchOption && "xyFootprint" !== t6.multipatchOption || t6.pixelSize || t6.relationParam || t6.text) throw new s(u4, "Unsupported query options", { query: t6 });
  return c3(i3, o2, t6), m7(i3, o2, t6), Promise.all([w2(t6, s7, r5), f4(r5, t6.outSR)]).then(() => t6);
}
function c3(s7, r5, o2) {
  const { returnDistinctValues: n5, outStatistics: a4 } = o2, l7 = a4 ? a4.map((e5) => e5.outStatisticFieldName && e5.outStatisticFieldName.toLowerCase()).filter(Boolean) : [];
  if ("orderByFields" in o2 && o2.orderByFields && o2.orderByFields.length > 0) {
    const e5 = " asc", i3 = " desc", n6 = o2.orderByFields.map((t6) => {
      const s8 = t6.toLowerCase();
      return s8.includes(e5) ? s8.split(e5)[0] : s8.includes(i3) ? s8.split(i3)[0] : t6;
    }).filter((e6) => !l7.includes(e6));
    g3(s7, r5, n6, { expressionName: "orderByFields", query: o2 });
  }
  if ("outFields" in o2) {
    if (o2.outFields?.length) g3(s7, r5, o2.outFields, { expressionName: "outFields", query: o2, allowedFieldTypes: "all" });
    else if (n5) throw new s(u4, "outFields should be specified for returnDistinctValues", { query: o2 });
  }
  p3(s7, r5, o2.where, o2);
}
var f6 = /* @__PURE__ */ new Set([...o, ...a3]);
function m7(i3, r5, o2) {
  const { outStatistics: n5, groupByFieldsForStatistics: a4, having: l7 } = o2, p5 = a4?.length, d6 = n5?.length;
  if (l7) {
    if (!p5 || !d6) throw new s(u4, "outStatistics and groupByFieldsForStatistics should be specified with having", { query: o2 });
    f5(i3, r5, l7, n5, o2);
  }
  if (d6) {
    if (!h3(n5)) return;
    const s7 = n5.map((e5) => e5.onStatisticField).filter(Boolean);
    g3(i3, r5, s7, { expressionName: "onStatisticFields", query: o2 }), p5 && g3(i3, r5, a4, { expressionName: "groupByFieldsForStatistics", query: o2 });
    for (const a5 of n5) {
      const { onStatisticField: s8, statisticType: n6 } = a5;
      if (("percentile_disc" === n6 || "percentile_cont" === n6) && "statisticParameters" in a5) {
        const { statisticParameters: t6 } = a5;
        if (!t6) throw new s(u4, "statisticParameters should be set for percentile type", { definition: a5, query: o2 });
      } else i3.get(s8) && "count" !== n6 && "min" !== n6 && "max" !== n6 && g3(i3, r5, [s8], { expressionName: `outStatistics with '${n6}' statistic type`, allowedFieldTypes: f6, query: o2 });
    }
  }
}
async function y4(t6, i3, { fieldsIndex: s7, geometryType: r5, spatialReference: o2, availableFields: l7 }) {
  if (null != t6.geometryPrecision || t6.multipatchOption || t6.pixelSize || t6.relationParam || t6.text || t6.outStatistics || t6.groupByFieldsForStatistics || t6.having || t6.orderByFields) throw new s(u4, "Unsupported query options", { query: t6 });
  return c3(s7, l7, t6), Promise.all([F(s7, l7, i3, t6), w2(t6, r5, o2), f4(o2, t6.outSR)]).then(() => t6);
}
async function F(i3, s7, r5, o2) {
  let n5 = [];
  if (r5.valueExpression) {
    const { arcadeUtils: e5 } = await e3();
    n5 = e5.extractFieldNames(r5.valueExpression);
  }
  if (r5.field && n5.push(r5.field), r5.field2 && n5.push(r5.field2), r5.field3 && n5.push(r5.field3), r5.normalizationField && n5.push(r5.normalizationField), !n5.length && !r5.valueExpression) throw new s(u4, "field or valueExpression is required", { params: r5 });
  g3(i3, s7, n5, { expressionName: "statistics", query: o2 });
}
function h3(e5) {
  return null != e5 && e5.every((e6) => "exceedslimit" !== e6.statisticType);
}

// node_modules/@arcgis/core/layers/graphics/data/QueryEngine.js
var D = "unsupported-query";
var W = class {
  constructor(e5) {
    this._changeHandle = null, this.capabilities = { query: t2 }, this.geometryType = e5.geometryType, this.hasM = !!e5.hasM, this.hasZ = !!e5.hasZ, this.spatialReference = e5.spatialReference, this.definitionExpression = e5.definitionExpression, this.featureStore = e5.featureStore, this.aggregateAdapter = e5.aggregateAdapter, this._cache = e5.cache ?? new e4(), this.timeInfo = e5.timeInfo, this.featureIdInfo = e5.featureIdInfo, "object-id" === e5.featureIdInfo.type && (this.objectIdField = e5.featureIdInfo.fieldName), this._changeHandle = this.featureStore.events.on("changed", () => this._clearCache()), this.fieldsIndex = t(e5.fieldsIndex) ? e5.fieldsIndex : Z.fromJSON(e5.fieldsIndex), !e5.availableFields || 1 === e5.availableFields.length && "*" === e5.availableFields[0] ? this.availableFields = new Set(this.fieldsIndex.fields.map((e6) => e6.name)) : this.availableFields = new Set(e5.availableFields.map((e6) => this.fieldsIndex.get(e6)?.name).filter((e6) => null != e6)), e5.scheduler && e5.priority ? this._frameTask = e5.scheduler.registerTask(e5.priority) : this._frameTask = G3;
  }
  destroy() {
    this._changeHandle = l(this._changeHandle), this._frameTask = l(this._frameTask), this._clearCache(), u(this._cache);
  }
  get featureAdapter() {
    return this.featureStore.featureAdapter;
  }
  async executeQuery(e5, t6) {
    const i3 = l2(t6);
    return await this._frameTask.scheduleGenerator(() => this._executeQueryFeatureSet(e5), i3);
  }
  async executeQueryForCount(e5 = {}, t6) {
    const i3 = l2(t6);
    return await this._frameTask.scheduleGenerator(() => this._executeQueryForCount(e5), i3);
  }
  async executeQueryForExtent(e5, t6) {
    const i3 = l2(t6);
    return await this._frameTask.scheduleGenerator(() => this._executeQueryForExtent(e5), i3);
  }
  async executeQueryForIds(e5, t6) {
    return Array.from(await this.executeQueryForIdSet(e5, t6));
  }
  async executeQueryForIdSet(e5, t6) {
    const i3 = l2(t6);
    return await this._frameTask.scheduleGenerator(() => this._executeQueryForIdSet(e5), i3);
  }
  async executeQueryForLatestObservations(e5, t6) {
    const i3 = l2(t6);
    if (!this.timeInfo?.trackIdField) throw new s(D, "Missing timeInfo or timeInfo.trackIdField", { query: e5, timeInfo: this.timeInfo });
    return await this._frameTask.scheduleGenerator(() => this._executeQueryForLatestObservations(e5), i3);
  }
  async executeQueryForOpaqueFeatures(e5, t6) {
    const i3 = l2(t6);
    return (await this._frameTask.scheduleGenerator(() => this._executeQuery(e5, {}), i3)).items;
  }
  async executeAttributeBinsQuery(e5, t6) {
    const i3 = l2(t6);
    return e5 = a(e5), await this._frameTask.scheduleGenerator(() => this._executeAttributeBinsQuery(e5), i3);
  }
  async executeQueryForSummaryStatistics(e5 = {}, t6, i3) {
    const r5 = l2(i3);
    return await this._frameTask.scheduleGenerator(() => this._executeQueryForSummaryStatistics(e5, t6), r5);
  }
  async executeQueryForUniqueValues(e5 = {}, t6, i3) {
    const r5 = l2(i3);
    return await this._frameTask.scheduleGenerator(() => this._executeQueryForUniqueValues(e5, t6), r5);
  }
  async executeQueryForClassBreaks(e5 = {}, t6, i3) {
    const r5 = l2(i3);
    return await this._frameTask.scheduleGenerator(() => this._executeQueryForClassBreaks(e5, t6), r5);
  }
  async executeQueryForHistogram(e5 = {}, t6, i3) {
    const r5 = l2(i3);
    return await this._frameTask.scheduleGenerator(() => this._executeQueryForHistogram(e5, t6), r5);
  }
  async executeQueryForSnapping(e5, t6) {
    const i3 = l2(t6);
    return await this._frameTask.scheduleGenerator(() => this._executeQueryForSnapping(e5, i3), i3);
  }
  async fetchRecomputedExtents(e5) {
    const t6 = l2(e5);
    this._timeExtentPromise ||= n3(this.timeInfo, this.featureStore);
    const [i3, r5] = await Promise.all([this._getFullExtent(), this._timeExtentPromise]);
    return s2(t6), { fullExtent: i3, timeExtent: r5 };
  }
  _clearCache() {
    this._cache.clear(), this._allFeaturesPromise = null, this._timeExtentPromise = null, this._fullExtentPromise = null;
  }
  async *_executeQueryFeatureSet(e5) {
    try {
      const t6 = yield* this._executeQuery(e5, {});
      return yield, await t6.createQueryResponse();
    } catch (t6) {
      if (t6 !== S2) throw t6;
      return await new E2([], e5, this).createQueryResponse();
    }
  }
  async *_executeQueryForCount(e5) {
    try {
      const t6 = yield* this._executeQuery(e5, { returnGeometry: false, returnCentroid: false, outSR: null });
      return yield, t6.createQueryResponseForCount();
    } catch (t6) {
      if (t6 !== S2) throw t6;
      return 0;
    }
  }
  async *_executeQueryForExtent(e5) {
    const t6 = e5.outSR;
    try {
      const i3 = yield* this._executeQuery(e5, { returnGeometry: true, returnCentroid: false, outSR: null });
      yield;
      const r5 = i3.size;
      if (!r5) return { count: 0, extent: null };
      const s7 = await this._getBounds(i3.items, i3.spatialReference, t6 ?? this.spatialReference);
      return yield, { count: r5, extent: s7 };
    } catch (i3) {
      if (i3 === S2) return { count: 0, extent: null };
      throw i3;
    }
  }
  async *_executeQueryForIdSet(e5) {
    try {
      const t6 = yield* this._executeQuery(e5, { returnGeometry: true, returnCentroid: false, outSR: null });
      yield;
      const i3 = t6.items, r5 = /* @__PURE__ */ new Set();
      for (const e6 of i3) r5.add(t6.featureAdapter.getObjectId(e6));
      return r5;
    } catch (t6) {
      if (t6 === S2) return /* @__PURE__ */ new Set();
      throw t6;
    }
  }
  async *_executeQueryForLatestObservations(e5) {
    try {
      const t6 = yield* this._executeQuery(e5, {});
      return yield, this._filterLatest(t6), yield, await t6.createQueryResponse();
    } catch (t6) {
      if (t6 !== S2) throw t6;
      return await new E2([], e5, this).createQueryResponse();
    }
  }
  async *_executeAttributeBinsQuery(e5) {
    let t6;
    try {
      e5 = await x(e5, this.definitionExpression, this.spatialReference), yield, e5 = await p4(e5, { availableFields: this.availableFields, fieldsIndex: this.fieldsIndex, geometryType: this.geometryType, spatialReference: this.spatialReference }), yield;
      const i3 = yield* this._executeSceneFilterQuery(e5);
      yield, t6 = yield* this._executeGeometryQuery(e5, i3), yield, this._executeAggregateIdsQuery(t6), yield, this._executeObjectIdsQuery(t6), yield, this._executeTimeQuery(t6), yield, this._executeAttributesQuery(t6), yield;
    } catch (i3) {
      if (i3 !== S2) throw i3;
      t6 = new E2([], e5, this);
    }
    return await t6.createQueryBinsResponse(e5);
  }
  async *_executeQueryForSummaryStatistics(e5 = {}, t6) {
    const { field: i3, normalizationField: r5, valueExpression: s7 } = t6, a4 = yield* this._executeQueryForStatistics(e5, { field: i3, normalizationField: r5, valueExpression: s7 });
    return yield, await a4.createSummaryStatisticsResponse(t6);
  }
  async *_executeQueryForUniqueValues(e5 = {}, t6) {
    const { field: i3, field2: r5, field3: s7, valueExpression: a4 } = t6, n5 = yield* this._executeQueryForStatistics(e5, { field: i3, field2: r5, field3: s7, valueExpression: a4 });
    return yield, await n5.createUniqueValuesResponse(t6);
  }
  async *_executeQueryForClassBreaks(e5, t6) {
    const { field: i3, normalizationField: r5, valueExpression: s7 } = t6, a4 = yield* this._executeQueryForStatistics(e5, { field: i3, normalizationField: r5, valueExpression: s7 });
    return yield, await a4.createClassBreaksResponse(t6);
  }
  async *_executeQueryForHistogram(e5, t6) {
    const { field: i3, normalizationField: r5, valueExpression: s7 } = t6, a4 = yield* this._executeQueryForStatistics(e5, { field: i3, normalizationField: r5, valueExpression: s7 });
    return yield, await a4.createHistogramResponse(t6);
  }
  async *_executeQueryForSnapping(e5, t6) {
    const { point: i3, distance: r5, returnEdge: a4, vertexMode: n5 } = e5;
    if (!a4 && "none" === n5) return { candidates: [] };
    let l7 = a(e5.query);
    l7 = await B2(l7, this.definitionExpression, this.spatialReference), yield, l7 = await d5(l7, { availableFields: this.availableFields, fieldsIndex: this.fieldsIndex, geometryType: this.geometryType, spatialReference: this.spatialReference }), yield;
    const u5 = !T(i3.spatialReference, this.spatialReference);
    u5 && (await f4(i3.spatialReference, this.spatialReference), yield);
    const o2 = "number" == typeof r5 ? r5 : r5.x, c4 = "number" == typeof r5 ? r5 : r5.y, h4 = { xmin: i3.x - o2, xmax: i3.x + o2, ymin: i3.y - c4, ymax: i3.y + c4, spatialReference: i3.spatialReference }, y5 = u5 ? g2(h4, this.spatialReference) : h4;
    if (!y5) return { candidates: [] };
    const d6 = (await P2(f2(i3), null, { signal: t6 }))[0];
    yield;
    const m8 = (await P2(f2(y5), null, { signal: t6 }))[0];
    if (yield, null == d6 || null == m8) return { candidates: [] };
    const f7 = await this._searchFeatures(X(m8.toJSON()));
    yield;
    const p5 = new E2(f7, l7, this);
    this._executeObjectIdsQuery(p5), yield, this._executeTimeQuery(p5), yield, this._executeAttributesQuery(p5), yield, yield* this._executeGeometryQueryForSnapping(p5), yield;
    const x2 = d6.toJSON(), g4 = u5 ? g2(x2, this.spatialReference) : x2, F2 = u5 ? Math.max(y5.xmax - y5.xmin, y5.ymax - y5.ymin) / 2 : r5;
    return p5.createSnappingResponse({ ...e5, point: g4, distance: F2 }, l7.returnZ, i3.spatialReference);
  }
  async _getBounds(e5, t6, i3) {
    const r5 = k(u2(), L);
    return await this.featureStore.forEachBounds(e5, (e6) => M(r5, e6)), Y(r5, t6, i3, this.spatialReference, this.hasZ);
  }
  _getFullExtent() {
    return this._fullExtentPromise ||= "getFullExtent" in this.featureStore && this.featureStore.getFullExtent ? Promise.resolve(this.featureStore.getFullExtent(this.spatialReference)) : this._getAllFeatures().then((e5) => this._getBounds(e5, this.spatialReference, this.spatialReference)), this._fullExtentPromise;
  }
  async _getAllFeaturesQueryEngineResult(e5) {
    return new E2(await this._getAllFeatures(), e5, this);
  }
  async _getAllFeatures() {
    if (null == this._allFeaturesPromise) {
      const e6 = [];
      this._allFeaturesPromise = (async () => await this.featureStore.forEach((t7) => e6.push(t7)))().then(() => r(e6));
    }
    const e5 = this._allFeaturesPromise, t6 = await e5;
    return e5 === this._allFeaturesPromise ? t6.slice() : this._getAllFeatures();
  }
  async *_executeQuery(e5, t6) {
    e5 = a(e5), e5 = await w(e5, this.definitionExpression, this.spatialReference), yield, e5 = await d5(e5, { availableFields: this.availableFields, fieldsIndex: this.fieldsIndex, geometryType: this.geometryType, spatialReference: this.spatialReference }), yield, e5 = { ...e5, ...t6 };
    const i3 = yield* this._executeSceneFilterQuery(e5);
    yield;
    const r5 = yield* this._executeGeometryQuery(e5, i3);
    return yield, this._executeAggregateIdsQuery(r5), yield, this._executeObjectIdsQuery(r5), yield, this._executeTimeQuery(r5), yield, this._executeAttributesQuery(r5), r5;
  }
  async *_executeSceneFilterQuery(e5) {
    if (null == e5.sceneFilter) return null;
    const { outSR: t6, returnGeometry: i3, returnCentroid: r5 } = e5, s7 = this.featureStore.featureSpatialReference, a4 = e5.sceneFilter.geometry, n5 = null == s7 || T(s7, a4.spatialReference) ? a4 : g2(a4, s7);
    if (!n5) return null;
    const l7 = i3 || r5, u5 = p(t6) && !T(this.spatialReference, t6) && l7 ? async (e6) => this._project(e6, t6) : (e6) => e6;
    yield;
    const o2 = this.featureAdapter, c4 = await this._searchFeatures(X(n5));
    yield;
    if ("disjoint" === e5.sceneFilter.spatialRelationship) {
      if (!c4.length) return null;
      const t7 = /* @__PURE__ */ new Set();
      for (const e6 of c4) t7.add(o2.getObjectId(e6));
      const i4 = await this._getAllFeatures();
      yield;
      const r6 = await I("esriSpatialRelDisjoint", n5, this.geometryType, this.hasZ, this.hasM);
      yield;
      const s8 = (e6) => !t7.has(o2.getObjectId(e6)) || r6(o2.getGeometry(e6)), a5 = yield* this._runSpatialFilter(i4, s8);
      yield;
      const l8 = new E2(a5, e5, this);
      return await u5(l8);
    }
    if (!c4.length) return new E2([], e5, this);
    if (this._canExecuteSinglePass(n5, e5)) return await u5(new E2(c4, e5, this));
    const h4 = await I("esriSpatialRelContains", n5, this.geometryType, this.hasZ, this.hasM);
    yield;
    const y5 = yield* this._runSpatialFilter(c4, (e6) => h4(o2.getGeometry(e6)));
    return yield, await u5(new E2(y5, e5, this));
  }
  async *_executeGeometryQuery(i3, r5) {
    if (null != r5 && 0 === r5.items.length) return r5;
    const { geometry: s7, outSR: a4, returnGeometry: n5, returnCentroid: l7 } = i3, u5 = r5 ? null : this._getCacheKey(i3), o2 = u5 ? this._cache.get(u5) : null;
    if (o2) return new E2(o2, i3, this);
    const c4 = p(a4) && !T(this.spatialReference, a4), h4 = n5 || l7, y5 = async (e5) => (c4 && h4 && await this._project(e5, a4), u5 && this._cache.put(u5, e5.items), e5), d6 = this.featureStore.featureSpatialReference, m8 = !s7 || null == d6 || T(d6, s7.spatialReference) ? s7 : g2(s7, d6);
    if (!m8) return await y5(null != r5 ? r5 : await this._getAllFeaturesQueryEngineResult(i3));
    yield;
    const f7 = this.featureAdapter;
    let p5 = await this._searchFeatures(X(s7));
    yield;
    const x2 = i3.spatialRel ?? "esriSpatialRelIntersects";
    if ("esriSpatialRelDisjoint" === x2) {
      if (!p5.length) return await y5(null != r5 ? r5 : await this._getAllFeaturesQueryEngineResult(i3));
      const e5 = /* @__PURE__ */ new Set();
      for (const i4 of p5) e5.add(f7.getObjectId(i4));
      let t6;
      null != r5 ? t6 = r5.items : (yield, t6 = await this._getAllFeatures(), yield);
      const s8 = await I(x2, m8, this.geometryType, this.hasZ, this.hasM);
      yield;
      const a5 = (t7) => !e5.has(f7.getObjectId(t7)) || s8(f7.getGeometry(t7)), n6 = yield* this._runSpatialFilter(t6, a5);
      yield;
      const l8 = new E2(n6, i3, this);
      return await y5(l8);
    }
    if (null != r5) {
      const i4 = new b();
      p5 = p5.filter((t6) => S(r5.items, t6, r5.items.length, i4) >= 0);
    }
    if (!p5.length) {
      const e5 = new E2([], i3, this);
      return u5 && this._cache.put(u5, e5.items), e5;
    }
    if (this._canExecuteSinglePass(m8, i3)) return await y5(new E2(p5, i3, this));
    const g4 = await I(x2, m8, this.geometryType, this.hasZ, this.hasM);
    yield;
    const _ = yield* this._runSpatialFilter(p5, (e5) => g4(f7.getGeometry(e5)));
    return yield, await y5(new E2(_, i3, this));
  }
  _executeAggregateIdsQuery(e5) {
    if (0 === e5.items.length || !e5.query.aggregateIds?.length || null == this.aggregateAdapter) return;
    const t6 = /* @__PURE__ */ new Set();
    for (const r5 of e5.query.aggregateIds) {
      this.aggregateAdapter.getFeatureObjectIds(r5).forEach((e6) => t6.add(e6));
    }
    const i3 = this.featureAdapter.getObjectId;
    e5.items = e5.items.filter((e6) => t6.has(i3(e6)));
  }
  _executeObjectIdsQuery(e5) {
    if (0 === e5.items.length || !e5.query.objectIds?.length) return;
    const t6 = new Set(e5.query.objectIds), i3 = this.featureAdapter.getObjectId;
    e5.items = e5.items.filter((e6) => t6.has(i3(e6)));
  }
  _executeTimeQuery(e5) {
    if (0 === e5.items.length) return;
    const t6 = l5(this.timeInfo, e5.query.timeExtent, this.featureAdapter);
    null != t6 && (e5.items = e5.items.filter(t6));
  }
  _executeAttributesQuery(e5) {
    if (0 === e5.items.length) return;
    const t6 = c(e5.query.where, this.fieldsIndex);
    if (t6) {
      if (!t6.isStandardized) throw new TypeError("Where clause is not standardized");
      e5.items = e5.items.filter((e6) => t6.testFeature(e6, this.featureAdapter));
    }
  }
  async *_executeGeometryQueryForSnapping(e5) {
    const { query: t6 } = e5, { spatialRel: i3 } = t6;
    if (!e5?.items?.length || !t6.geometry || !i3) return;
    const r5 = await I(i3, t6.geometry, this.geometryType, this.hasZ, this.hasM);
    yield;
    const s7 = this.featureAdapter, a4 = (e6) => r5(s7.getGeometry(e6)), n5 = yield* this._runSpatialFilter(e5.items, a4);
    e5.items = n5;
  }
  *_runSpatialFilter(e5, t6) {
    if (!t6) return e5;
    if (null == this._frameTask) return e5.filter((e6) => t6(e6));
    let i3 = yield;
    const r5 = new Array();
    for (const s7 of e5) t6(s7) && r5.push(s7), i3.madeProgress(), i3.done && (i3 = yield);
    return r5;
  }
  _filterLatest(e5) {
    const { trackIdField: t6, startTimeField: i3, endTimeField: r5 } = this.timeInfo, s7 = r5 || i3, a4 = /* @__PURE__ */ new Map(), n5 = this.featureAdapter.getAttribute;
    for (const l7 of e5.items) {
      const e6 = n5(l7, t6), i4 = n5(l7, s7), r6 = a4.get(e6);
      (!r6 || i4 > n5(r6, s7)) && a4.set(e6, l7);
    }
    e5.items = Array.from(a4.values());
  }
  _getCacheKey(e5) {
    const { geometry: t6, spatialRel: i3, returnGeometry: r5, returnCentroid: s7, outSR: a4, resultType: n5, cacheHint: l7 } = e5;
    if ("tile" !== n5 && !l7) return null;
    const u5 = r5 || s7;
    return p(a4) && !T(this.spatialReference, a4) && u5 ? JSON.stringify([t6, i3, a4]) : JSON.stringify([t6, i3]);
  }
  _canExecuteSinglePass(e5, t6) {
    const { spatialRel: i3 } = t6;
    return d3(e5) && ("esriSpatialRelEnvelopeIntersects" === i3 || "esriGeometryPoint" === this.geometryType && ("esriSpatialRelIntersects" === i3 || "esriSpatialRelContains" === i3));
  }
  async _project(e5, t6) {
    if (!t6 || T(this.spatialReference, t6)) return e5;
    const r5 = this.featureAdapter, s7 = G2() ? await this._getFullExtent() : void 0, a4 = await M2(e5.items.map((e6) => a2(this.geometryType, this.hasZ, this.hasM, r5.getGeometry(e6))), this.spatialReference, t6, { areaOfInterestExtent: s7 });
    return e5.items = r(a4.map((t7, i3) => r5.cloneWithGeometry(e5.items[i3], ut(t7, this.hasZ, this.hasM)))), e5;
  }
  async _searchFeatures(e5) {
    const t6 = /* @__PURE__ */ new Set();
    await Promise.all(e5.map((e6) => this.featureStore.forEachInBounds(e6, (e7) => t6.add(e7))));
    const i3 = Array.from(t6.values());
    return t6.clear(), i3;
  }
  async *_executeQueryForStatistics(e5, t6) {
    e5 = a(e5);
    try {
      e5 = await w(e5, this.definitionExpression, this.spatialReference), yield, e5 = await y4(e5, t6, { availableFields: this.availableFields, fieldsIndex: this.fieldsIndex, geometryType: this.geometryType, spatialReference: this.spatialReference }), yield;
      const i3 = yield* this._executeSceneFilterQuery(e5);
      yield;
      const r5 = yield* this._executeGeometryQuery(e5, i3);
      return yield, this._executeAggregateIdsQuery(r5), yield, this._executeObjectIdsQuery(r5), yield, this._executeTimeQuery(r5), yield, this._executeAttributesQuery(r5), yield, r5;
    } catch (i3) {
      if (i3 !== S2) throw i3;
      return new E2([], e5, this);
    }
  }
  get test() {
  }
};
function X(e5) {
  if (d3(e5)) {
    if (m(e5)) return [e(Math.min(e5.xmin, e5.xmax), Math.min(e5.ymin, e5.ymax), Math.max(e5.xmin, e5.xmax), Math.max(e5.ymin, e5.ymax))];
    if (y(e5)) return e5.rings.map((e6) => e(Math.min(e6[0][0], e6[2][0]), Math.min(e6[0][1], e6[2][1]), Math.max(e6[0][0], e6[2][0]), Math.max(e6[0][1], e6[2][1])));
  }
  return [f(i(), e5)];
}
function Y(e5, t6, i3, r5, s7) {
  const a4 = { xmin: e5[0], ymin: e5[1], xmax: e5[3], ymax: e5[4], spatialReference: h(r5) };
  s7 && isFinite(e5[2]) && isFinite(e5[5]) && (a4.zmin = e5[2], a4.zmax = e5[5], a4.hasZ = true);
  const n5 = g2(a4, t6, i3);
  if (n5.spatialReference = h(i3), n5.xmax - n5.xmin === 0) {
    const e6 = ae(n5.spatialReference);
    n5.xmin -= e6, n5.xmax += e6;
  }
  if (n5.ymax - n5.ymin === 0) {
    const e6 = ae(n5.spatialReference);
    n5.ymin -= e6, n5.ymax += e6;
  }
  if (s7 && null != n5.zmin && null != n5.zmax && n5.zmax - n5.zmin === 0) {
    const e6 = ae(n5.spatialReference);
    n5.zmin -= e6, n5.zmax += e6;
  }
  return n5;
}

export {
  E2 as E,
  W,
  Y
};
//# sourceMappingURL=chunk-3VXANCFN.js.map
