import {
  e as e4,
  h as h3,
  l
} from "./chunk-OPJX4KXH.js";
import {
  e as e2,
  i as i3,
  r as r3,
  s,
  u
} from "./chunk-LTPHDYPK.js";
import {
  e as e3
} from "./chunk-3OVERDFX.js";
import {
  E,
  e,
  f as f3,
  h as h2,
  i as i2,
  m as m3
} from "./chunk-FPMLKIDB.js";
import {
  b,
  z as z2
} from "./chunk-AZXJIEZ6.js";
import {
  f as f2,
  p,
  z
} from "./chunk-H74Q4SYB.js";
import {
  A,
  m as m2,
  r as r2
} from "./chunk-SMWUT52Z.js";
import {
  _,
  c as c2,
  y
} from "./chunk-AXZMNHTN.js";
import {
  f
} from "./chunk-5T3MJDSR.js";
import {
  r
} from "./chunk-SOIZOFSB.js";
import {
  c,
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  a,
  i3 as i
} from "./chunk-QY7XKUIV.js";
import {
  h
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/geometry/support/curves/mathUtils.js
function r4(n5, t4, r8, o6) {
  return n5[0] = t4[0] * (1 - o6) + r8[0] * o6, n5[1] = t4[1] * (1 - o6) + r8[1] * o6, n5;
}
function o(n5, r8) {
  return b(n5, r8);
}
function u2(n5, t4, r8) {
  const u10 = o(t4, r8);
  if (0 === u10) return o(t4, n5);
  const i8 = (t4[0] - n5[0]) * (r8[1] - n5[1]) - (t4[1] - n5[1]) * (r8[0] - n5[0]);
  return i8 * i8 / u10;
}
function i4(n5, t4, r8, o6, u10) {
  const [i8, c10] = t4, [e10, m10] = r8, [a9, f12] = o6, [s7, x7] = u10, h12 = (i8 - e10) * (f12 - x7) - (c10 - m10) * (a9 - s7);
  if (0 === h12) return null;
  const l8 = (i8 * m10 - c10 * e10) * (a9 - s7) - (i8 - e10) * (a9 * x7 - f12 * s7), M2 = (i8 * m10 - c10 * e10) * (f12 - x7) - (c10 - m10) * (a9 * x7 - f12 * s7);
  return n5[0] = l8 / h12, n5[1] = M2 / h12, n5;
}
var c3 = 2 * Math.PI;
function e5(n5, t4) {
  const r8 = Math.atan2(n5, t4);
  return r8 < 0 ? r8 + c3 : r8;
}
function m4(n5) {
  return Math.abs(n5) % c3;
}
function a3(n5) {
  const t4 = m4(n5);
  return t4 < Math.PI ? t4 : c3 - t4;
}
function f4(n5, t4) {
  return { min: Math.min(n5, t4), max: Math.max(n5, t4) };
}
function s2(t4, r8, o6, u10) {
  if (m2(m4(t4 - r8), 0)) return o6 ? [t4, t4] : [t4, u10 ? t4 - c3 : t4 + c3];
  const [i8, e10] = u10 ? [t4 - c3, t4] : [t4, t4 + c3];
  return [t4, x({ min: i8, max: e10 }, r8)];
}
function x({ min: n5, max: t4 }, r8) {
  let o6;
  return o6 = t4 - r8, o6 >= c3 ? (o6 -= o6 % c3, r8 + o6) : (o6 = r8 - n5, o6 >= c3 ? (o6 -= o6 % c3, r8 - o6) : r8);
}
function h4(n5, t4) {
  const r8 = x(n5, t4);
  return r8 > n5.min && r8 < n5.max ? r8 : a3(r8 - n5.min) < a3(r8 - n5.max) ? n5.min : n5.max;
}
function l2(n5, t4, r8, o6 = 10) {
  return t4.map((t5) => {
    let u10 = t5;
    for (let i8 = 0; i8 < o6; i8++) {
      const [t6, o7, i9, c10, e10, m10] = r8(u10), a9 = n5[0] - t6, f12 = n5[1] - o7, s7 = -i9, x7 = -c10;
      u10 += -(2 * a9 * s7 + 2 * f12 * x7) / (2 * s7 * s7 + 2 * a9 * -e10 + 2 * x7 * x7 + 2 * f12 * -m10 || 1e-6);
    }
    return u10;
  });
}

// node_modules/@arcgis/core/geometry/support/curves/lineUtils.js
function s3(s7, i8, n5) {
  const [c10, e10] = s7, [m10, a9] = i8, [f12, h12] = n5, [l8, p5] = [m10 - c10, a9 - e10];
  let u10 = l8 * (f12 - c10) + p5 * (h12 - e10);
  u10 /= l8 ** 2 + p5 ** 2, u10 = r2(u10, 0, 1);
  const j3 = r4([0, 0], s7, i8, u10);
  return { t: u10, curvePoint: j3, distance: Math.sqrt(o(j3, n5)) };
}

// node_modules/@arcgis/core/geometry/support/curves/circleUtils.js
var c4 = class {
  constructor(t4, n5, i8, a9, r8, s7) {
    this.cx = t4, this.cy = n5, this.radius = i8, this.thetaStart = a9, this.thetaEnd = r8, this.isInvalid = s7;
  }
  get startPoint() {
    const { cx: t4, cy: n5, radius: i8, thetaStart: a9 } = this;
    return [t4 + i8 * Math.cos(a9), n5 + i8 * Math.sin(a9)];
  }
  get endPoint() {
    const { cx: t4, cy: n5, radius: i8, thetaEnd: a9 } = this;
    return [t4 + i8 * Math.cos(a9), n5 + i8 * Math.sin(a9)];
  }
};
function e6(t4, n5) {
  const { cx: i8, cy: a9, radius: r8 } = t4;
  return [i8 + r8 * Math.cos(n5), a9 + r8 * Math.sin(n5)];
}
function h5(t4, n5) {
  if (t4.isInvalid) return r4([0, 0], t4.startPoint, t4.endPoint, n5);
  const { thetaStart: i8, thetaEnd: a9 } = t4;
  return e6(t4, i8 * (1 - n5) + a9 * n5);
}
function u3(t4, s7) {
  if (t4.isInvalid) return s3(t4.startPoint, t4.endPoint, s7);
  const { cx: o6, cy: c10, thetaStart: h12, thetaEnd: u10 } = t4, [d6, f12] = s7, l8 = h4(f4(h12, u10), Math.atan2(f12 - c10, d6 - o6)), M2 = e6(t4, l8);
  return { t: (l8 - h12) / (u10 - h12), curvePoint: M2, distance: Math.sqrt(o(s7, M2)) };
}
function d(n5, a9) {
  if (a9.isInvalid) return f3(n5, a9.startPoint), f3(n5, a9.endPoint), n5;
  const { cx: r8, cy: s7, radius: c10, thetaStart: h12, thetaEnd: u10 } = a9;
  f3(n5, e6(a9, h12)), f3(n5, e6(a9, u10));
  const d6 = f4(h12, u10), f12 = Math.PI / 2;
  let l8 = 0;
  for (const i8 of [[r8 + c10, s7], [r8, s7 + c10], [r8 - c10, s7], [r8, s7 - c10]]) l8 = x(d6, l8), l8 > d6.min && l8 < d6.max && f3(n5, i8), l8 += f12;
  return n5;
}
function f5(t4) {
  if (t4.isInvalid) return 2 * t4.radius;
  const { radius: n5, thetaStart: i8, thetaEnd: a9 } = t4;
  return n5 * Math.abs(a9 - i8);
}

// node_modules/@arcgis/core/geometry/support/curves/circularArcUtils.js
var e7 = e3();
function m5(r8, c10, i8) {
  const [o6, s7] = r8, [m10, l8] = c10, [u10, f12] = i8;
  r3(e7, o6, m10, u10, s7, l8, f12, 1, 1, 1);
  const h12 = e2(e7), M2 = 4 * h12 / (o(r8, c10) + o(c10, i8) + o(i8, r8));
  if (!isFinite(M2) || Math.abs(M2) < 1e-8) return null;
  const p5 = o6 ** 2 + s7 ** 2, b4 = m10 ** 2 + l8 ** 2, j3 = u10 ** 2 + f12 ** 2;
  r3(e7, p5, b4, j3, s7, l8, f12, 1, 1, 1);
  const x7 = e2(e7);
  r3(e7, p5, b4, j3, o6, m10, u10, 1, 1, 1);
  return [x7 / h12 * 0.5, e2(e7) / h12 * -0.5];
}
function l3(t4, n5) {
  const [r8, i8] = n5.c, a9 = m5(t4, i8, r8), e10 = null == a9, l8 = a9 ?? r4([], t4, r8, 0.5), [u10, f12] = t4, [h12, M2] = i8, [p5, b4] = r8, [j3, x7] = l8, d6 = u10 - j3, g3 = f12 - x7, I3 = Math.sqrt(d6 * d6 + g3 * g3), P3 = e5(f12 - x7, u10 - j3), U = e5(M2 - x7, h12 - j3);
  let q3 = e5(b4 - x7, p5 - j3);
  return (U - P3) * (q3 - U) < 0 && (q3 += 2 * Math.sign(P3 - q3) * Math.PI), new c4(j3, x7, I3, P3, q3, e10);
}
function u4(t4, n5, r8) {
  const c10 = h5(t4, r8 / 2), o6 = h5(t4, r8), s7 = h5(t4, (r8 + 1) / 2);
  return [{ c: [o6, c10] }, { c: [[...n5.c[0]], s7] }];
}
function f6(t4, n5) {
  const [r8] = n5.c, { cx: c10, cy: i8, thetaStart: o6, thetaEnd: s7, radius: a9, isInvalid: e10 } = l3(t4, n5);
  return { a: [r8, [c10, i8], Math.abs(s7 - o6) < Math.PI ? 1 : 0, o6 > s7 ? 1 : 0, e10 ? o6 : 0, a9, e10 ? 0 : 1] };
}

// node_modules/@arcgis/core/geometry/support/curves/curveUtils.js
function n(n5) {
  return "curveRings" in n5 && !!n5.curveRings?.length || "curvePaths" in n5 && !!n5.curvePaths?.length;
}
function r5(n5) {
  return "curveRings" in n5 ? n5.curveRings : n5.curvePaths;
}
function t(n5) {
  return "b" in n5;
}
function u5(n5) {
  return "c" in n5;
}
function i5(n5) {
  return Array.isArray(n5);
}
function e8(n5) {
  return "a" in n5;
}
function c5(n5) {
  return "a" in n5 && 4 === n5.a.length;
}
function a4(n5) {
  return "a" in n5 && 7 === n5.a.length;
}
function f7(n5) {
  return i5(n5) ? n5 : t(n5) ? n5.b[0] : u5(n5) ? n5.c[0] : n5.a[0];
}
function o2(n5) {
  if (t(n5)) {
    const [r8, t4, u10] = n5.b;
    return { b: [[...r8], [...t4], [...u10]] };
  }
  if (u5(n5)) {
    const [r8, t4] = n5.c;
    return { c: [[...r8], [...t4]] };
  }
  if (i5(n5)) return [...n5];
  if (c5(n5)) {
    const [r8, t4, u10, i8] = n5.a;
    return { a: [[...r8], [...t4], u10, i8] };
  }
  if (a4(n5)) {
    const [r8, t4, u10, i8, e10, c10, a9] = n5.a;
    return { a: [[...r8], [...t4], u10, i8, e10, c10, a9] };
  }
  return n5;
}

// node_modules/@arcgis/core/geometry/support/curves/ellipticArc4Utils.js
function h6(r8, h12) {
  const [n5, c10, i8, e10] = h12.a, [m10, M2] = r8, [f12, l8] = n5, [p5, u10] = c10, j3 = m10 - p5, U = M2 - u10, b4 = Math.sqrt(j3 * j3 + U * U), q3 = f12 - p5, x7 = l8 - u10, I3 = Math.sqrt(q3 * q3 + x7 * x7), P3 = 0 === b4 || 0 === I3 || !A(b4, I3), d6 = b4, [w3, y6] = s2(e5(M2 - u10, m10 - p5), Math.atan2(l8 - u10, f12 - p5), i8, e10);
  return new c4(p5, u10, d6, w3, y6, P3);
}
function n2(t4, a9, o6) {
  const { cx: s7, cy: h12, thetaStart: n5, thetaEnd: c10 } = t4, [i8, e10, m10, M2] = a9.a, f12 = n5 * (1 - o6) + c10 * o6;
  return [{ a: [h5(t4, o6), [s7, h12], Math.abs(f12 - n5) < Math.PI ? 1 : 0, M2] }, { a: [[...i8], [s7, h12], Math.abs(c10 - f12) < Math.PI ? 1 : 0, M2] }];
}

// node_modules/@arcgis/core/geometry/support/curves/bezierCurveUtils.js
var i6 = [0, 0];
function a5(t4) {
  const n5 = 1 - t4, o6 = n5 * n5, r8 = t4 * t4;
  return [o6 * n5, 3 * t4 * o6, 3 * r8 * n5, r8 * t4];
}
function h7(t4, n5, o6, r8, s7) {
  const [c10, u10, e10, f12] = a5(s7);
  return [t4[0] * c10 + n5[0] * u10 + o6[0] * e10 + r8[0] * f12, t4[1] * c10 + n5[1] * u10 + o6[1] * e10 + r8[1] * f12];
}
function m6(t4, n5, o6, r8, s7) {
  const [c10, u10, e10, f12] = a5(s7);
  return t4 * c10 + n5 * u10 + o6 * e10 + r8 * f12;
}
function p2(t4, n5, o6) {
  const r8 = t4, [s7, c10, u10] = n5.b;
  return h7(r8, c10, u10, s7, o6);
}
function M(t4, n5, o6) {
  const r8 = t4, [s7, c10, u10] = n5.b, f12 = r4([0, 0], r8, c10, o6), a9 = r4(i6, c10, u10, o6), h12 = r4([0, 0], u10, s7, o6), m10 = r4([0, 0], f12, a9, o6), p5 = r4([0, 0], a9, h12, o6);
  return [{ b: [r4([], m10, p5, o6), f12, m10] }, { b: [[...s7], p5, h12] }];
}
function b2(o6, r8, s7) {
  const c10 = o6, [u10, e10, i8] = r8.b, a9 = l2(s7, [0.1, 0.5, 0.9], (t4) => {
    const n5 = 1 - t4, [o7, r9] = h7(c10, e10, i8, u10, t4);
    return [o7, r9, 3 * n5 * n5 * (e10[0] - c10[0]) + 6 * n5 * t4 * (i8[0] - e10[0]) + 3 * t4 * t4 * (u10[0] - i8[0]), 3 * n5 * n5 * (e10[1] - c10[1]) + 6 * n5 * t4 * (i8[1] - e10[1]) + 3 * t4 * t4 * (u10[1] - i8[1]), 6 * n5 * (i8[0] - 2 * e10[0] + c10[0]) + 6 * t4 * (u10[0] - 2 * i8[0] + e10[0]), 6 * n5 * (i8[1] - 2 * e10[1] + c10[1]) + 6 * t4 * (u10[1] - 2 * i8[1] + e10[1])];
  }).map((t4) => Math.min(1, Math.max(0, t4)));
  a9.push(0, 1);
  let m10 = 1 / 0;
  const p5 = a9.map((t4) => {
    const n5 = h7(c10, e10, i8, u10, t4), [o7, r9] = n5, f12 = s7[0] - o7, a10 = s7[1] - r9, p6 = Math.sqrt(f12 * f12 + a10 * a10);
    return m10 = Math.min(p6, m10), { t: t4, curvePoint: n5, distance: p6 };
  }), M2 = [];
  for (const f12 of p5) {
    const { t: o7, distance: r9 } = f12;
    A(r9, m10) && !M2.some(({ t: t4 }) => m2(t4, o7)) && M2.push(f12);
  }
  return M2;
}
function l4(t4, n5, u10) {
  const e10 = n5, [f12, i8, a9] = u10.b;
  if (f3(t4, e10), f3(t4, f12), E(t4, i8[0], i8[1]) && E(t4, a9[0], a9[1])) return t4;
  for (const o6 of q(e10[0], i8[0], a9[0], f12[0])) o6 > 0 && o6 < 1 && m3(t4, m6(e10[0], i8[0], a9[0], f12[0], o6));
  for (const o6 of q(e10[1], i8[1], a9[1], f12[1])) o6 > 0 && o6 < 1 && h2(t4, m6(e10[1], i8[1], a9[1], f12[1], o6));
  return t4;
}
function q(t4, n5, o6, r8) {
  const s7 = 3 * (3 * (n5 - o6) - t4 + r8), c10 = 6 * (t4 - 2 * n5 + o6), u10 = 3 * (n5 - t4);
  if (0 === s7) return 0 !== c10 ? [-u10 / c10] : [];
  const e10 = Math.sqrt(c10 * c10 - 4 * s7 * u10);
  return [(-c10 + e10) / (2 * s7), (-c10 - e10) / (2 * s7)];
}
function d2(t4, n5, o6) {
  const r8 = 16;
  let s7 = 0, c10 = [n5];
  for (let e10 = 0; e10 < r8; e10++) {
    let n6 = t4;
    const r9 = [];
    for (const t5 of c10) r9.push(...M(n6, t5, 0.5)), n6 = t5.b[0];
    c10 = r9, n6 = t4, s7 = 0;
    let e11 = 0;
    for (const t5 of c10) {
      const [o7, r10, c11] = t5.b, f12 = Math.sqrt(o(n6, o7));
      s7 += (f12 + (Math.sqrt(o(n6, r10)) + Math.sqrt(o(r10, c11)) + Math.sqrt(o(c11, o7)))) / 2, e11 += f12, n6 = o7;
    }
    if (s7 - e11 < o6) return s7;
  }
  return s7;
}

// node_modules/@arcgis/core/geometry/support/curves/ellipticArc7Utils.js
var b3 = class {
  constructor(t4, s7, n5, a9, r8, o6, i8, c10, h12) {
    this.cx = t4, this.cy = s7, this.a = n5, this.b = a9, this.cosR = r8, this.sinR = o6, this.u1 = i8, this.u2 = c10, this.isInvalid = h12;
  }
};
function p3(t4, s7) {
  const [n5, a9, r8, o6, i8, c10, h12] = s7.a, [u10, m10] = t4, [M2, l8] = n5, [p5, R2] = a9, d6 = c10 * h12, x7 = Math.cos(i8), q3 = Math.sin(i8), [I3, g3] = s2(e5(1 / d6 * (m10 - R2) * x7 - 1 / d6 * (u10 - p5) * q3, 1 / c10 * (m10 - R2) * q3 + 1 / c10 * (u10 - p5) * x7), Math.atan2(1 / d6 * (l8 - R2) * x7 - 1 / d6 * (M2 - p5) * q3, 1 / c10 * (l8 - R2) * q3 + 1 / c10 * (M2 - p5) * x7), r8, o6);
  return new b3(p5, R2, c10, d6, x7, q3, I3, g3, 0 === c10 || 0 === d6);
}
function R(t4, s7) {
  const { a: n5, b: a9, cosR: r8, sinR: o6, cx: i8, cy: c10 } = t4, h12 = Math.cos(s7), u10 = Math.sin(s7);
  return [n5 * h12 * r8 - a9 * u10 * o6 + i8, n5 * h12 * o6 + a9 * u10 * r8 + c10];
}
function d3(t4, s7) {
  const { u1: n5, u2: a9 } = t4;
  return R(t4, n5 * (1 - s7) + a9 * s7);
}
function x2(t4, s7, n5) {
  if (n5 < 0 || n5 > 1) return [];
  if (0 === n5 || 1 === n5) return [o2(s7)];
  const [a9, [r8, o6], i8, h12, u10, e10, f12] = s7.a, { u1: m10, u2: M2 } = t4, l8 = m10 * (1 - n5) + M2 * n5;
  return [{ a: [[...d3(t4, n5)], [r8, o6], Math.abs(l8 - m10) < Math.PI ? 1 : 0, h12, u10, e10, f12] }, { a: [[...a9], [r8, o6], Math.abs(M2 - l8) < Math.PI ? 1 : 0, h12, u10, e10, f12] }];
}
function q2(t4, s7) {
  const { a: n5, b: a9, cosR: r8, sinR: o6, u1: i8, u2: c10 } = t4, e10 = Math.PI / 6, f12 = l2(s7, [1 * e10, 2 * e10, 4 * e10, 5 * e10, 7 * e10, 8 * e10, 10 * e10, 11 * e10], (s8) => {
    const i9 = Math.cos(s8), c11 = Math.sin(s8), [h12, u10] = R(t4, s8);
    return [h12, u10, -n5 * r8 * c11 - a9 * o6 * i9, -n5 * o6 * c11 + a9 * r8 * i9, -n5 * r8 * i9 + a9 * o6 * c11, -n5 * o6 * i9 - a9 * r8 * c11];
  }), m10 = f4(i8, c10), M2 = new Set(f12.map((t5) => x(m10, t5)).filter((t5) => t5 > m10.min && t5 < m10.max));
  M2.add(i8), M2.add(c10);
  let b4, p5, d6 = 1 / 0;
  for (const h12 of M2) {
    const n6 = R(t4, h12), [a10, r9] = n6, o7 = s7[0] - a10, u10 = s7[1] - r9, e11 = o7 * o7 + u10 * u10;
    e11 < d6 && (b4 = (h12 - i8) / (c10 - i8), p5 = n6, d6 = e11);
  }
  return { t: b4, curvePoint: p5, distance: Math.sqrt(d6) };
}
function I(t4, s7, n5) {
  const a9 = p3(s7, n5), { a: r8, b: o6, u1: c10, u2: e10, cosR: f12, sinR: m10, isInvalid: M2 } = a9, l8 = n5.a[0];
  if (f3(t4, s7), f3(t4, l8), M2) return t4;
  const b4 = Math.atan2(-o6 * m10, r8 * f12), d6 = b4 + Math.PI, x7 = Math.atan2(o6 * f12, r8 * m10), q3 = x7 + Math.PI, I3 = f4(c10, e10);
  for (const u10 of [b4, d6, x7, q3].map((t5) => x(I3, t5))) u10 > I3.min && u10 < I3.max && f3(t4, R(a9, u10));
  return t4;
}
function g(t4, s7, n5) {
  const [a9, r8, o6, i8, c10, h12, u10] = s7.a, e10 = p3(t4, s7), { u1: f12, u2: l8, isInvalid: b4 } = e10, x7 = l8 - f12;
  if (b4) return Math.sqrt(o(t4, a9));
  const q3 = 14, I3 = [0, 0];
  let g3 = 0, j3 = [d3(e10, 0), d3(e10, 0.25), d3(e10, 0.5), d3(e10, 0.75), d3(e10, 1)];
  for (let p5 = 0; p5 < q3; p5++) {
    const t5 = j3.length - 1, s8 = x7 / (2 * t5), a10 = [];
    for (let n6 = 0; n6 < t5; n6++) a10.push(j3[n6]), a10.push(R(e10, f12 + (2 * n6 + 1) * s8));
    a10.push(j3[j3.length - 1]), j3 = a10, g3 = 0;
    let o7 = 0;
    for (let n6 = 1; n6 < j3.length; n6++) {
      const t6 = j3[n6 - 1], s9 = j3[n6];
      if (g3 += Math.sqrt(o(t6, s9)), n6 > 1) {
        const a11 = j3[n6 - 2], i9 = i4(I3, a11, t6, r8, s9);
        o7 += i9 ? Math.sqrt(o(t6, i9)) : Math.abs(s9[0] - t6[0]) + Math.abs(s9[1] - t6[1]);
      } else o7 += g3;
    }
    if (o7 - g3 < n5) return g3;
  }
  return g3;
}
var j = e3();
var v = e3();
var P = e3();
var y2 = e3();
function w(r8, i8, c10) {
  const [h12, u10, e10, M2, l8, b4, R2] = i8.a, d6 = p3(r8, i8), { cosR: x7, sinR: q3, a: I3, b: g3, cx: w3, cy: U } = d6, B = z2([0, 0], h12, c10), S = z2([0, 0], u10, c10), k = c10[0] * c10[4] < 0 ? 1 - M2 : M2;
  {
    const s7 = I3 * I3 * q3 * q3 + g3 * g3 * x7 * x7, n5 = 2 * (g3 * g3 - I3 * I3) * q3 * x7, a9 = I3 * I3 * x7 * x7 + g3 * g3 * q3 * q3, r9 = -2 * s7 * w3 - n5 * U, o6 = -n5 * w3 - 2 * a9 * U;
    r3(j, s7, n5 / 2, r9 / 2, n5 / 2, a9, o6 / 2, r9 / 2, o6 / 2, s7 * w3 * w3 + n5 * w3 * U + a9 * U * U - I3 * I3 * g3 * g3);
  }
  if (s(v, c10), null == v) {
    const t4 = z2([0, 0], r8, c10);
    return { a: [B, S, e10, M2, e5(B[1], B[0]), Math.sqrt(o(B, t4)) / 2, 0] };
  }
  u(P, v), i3(y2, i3(y2, P, j), v);
  {
    const t4 = y2[0], s7 = 2 * y2[1], n5 = y2[4], a9 = 2 * y2[2], r9 = 2 * y2[5], o6 = s7 * s7 - 4 * t4 * n5, i9 = 2 * (t4 * r9 * r9 + n5 * a9 * a9 - s7 * a9 * r9 + o6 * y2[8]), c11 = Math.sqrt((t4 - n5) ** 2 + s7 * s7), h13 = -Math.sqrt(i9 * (t4 + n5 + c11)) / o6, u11 = -Math.sqrt(i9 * (t4 + n5 - c11)) / o6;
    return { a: [B, S, e10, k, 0.5 * e5(-s7, n5 - t4), h13, u11 / h13] };
  }
}

// node_modules/@arcgis/core/geometry/support/curves/curveExtent.js
function n3(n5, p5, u10) {
  if (i5(u10)) return f3(n5, p5), f3(n5, u10), n5;
  if (t(u10)) return l4(n5, p5, u10);
  if (u5(u10)) {
    const r8 = l3(p5, u10);
    return d(n5, r8);
  }
  if (c5(u10)) {
    const r8 = h6(p5, u10);
    return d(n5, r8);
  }
  return I(n5, p5, u10);
}

// node_modules/@arcgis/core/geometry/support/boundsUtils.js
function o3(n5) {
  return void 0 !== n5.xmin && void 0 !== n5.ymin && void 0 !== n5.xmax && void 0 !== n5.ymax;
}
function u6(n5) {
  return void 0 !== n5.points;
}
function c6(n5) {
  return void 0 !== n5.x && void 0 !== n5.y;
}
function s4(n5) {
  return void 0 !== n5.paths;
}
function l5(n5) {
  return void 0 !== n5.rings;
}
function h8(n5) {
  function t4(t5, i8) {
    return null == t5 ? i8 : null == i8 ? t5 : n5(t5, i8);
  }
  return t4;
}
var m7 = h8(Math.min);
var a6 = h8(Math.max);
function f8(n5, t4) {
  return s4(t4) ? y3(n5, t4.curvePaths ?? t4.paths, false, false) ?? n5 : l5(t4) ? y3(n5, t4.curveRings ?? t4.rings, false, false) ?? n5 : u6(t4) ? p4(n5, t4.points, false, false, false, false) : o3(t4) ? d4(n5, t4) : (c6(t4) && (n5[0] = t4.x, n5[1] = t4.y, n5[2] = t4.x, n5[3] = t4.y), n5);
}
function x3(n5) {
  let i8, r8, e10, o6;
  for (n5.reset(), i8 = e10 = 1 / 0, r8 = o6 = -1 / 0; n5.nextPath(); ) {
    const t4 = g2(n5);
    i8 = Math.min(t4[0], i8), e10 = Math.min(t4[1], e10), r8 = Math.max(t4[2], r8), o6 = Math.max(t4[3], o6);
  }
  return i2([i8, e10, r8, o6]);
}
function g2(n5) {
  let i8, r8, e10, o6;
  for (i8 = e10 = 1 / 0, r8 = o6 = -1 / 0; n5.nextPoint(); ) i8 = Math.min(n5.x, i8), e10 = Math.min(n5.y, e10), r8 = Math.max(n5.x, r8), o6 = Math.max(n5.y, o6);
  return i2([i8, e10, r8, o6]);
}
function v2(n5, t4) {
  return s4(t4) ? y3(n5, t4.curvePaths ?? t4.paths, true, false) ?? n5 : l5(t4) ? y3(n5, t4.curveRings ?? t4.rings, true, false) ?? n5 : u6(t4) ? p4(n5, t4.points, true, false, true, false) : o3(t4) ? d4(n5, t4, true, false, true, false) : (c6(t4) && (n5[0] = t4.x, n5[1] = t4.y, n5[2] = t4.z, n5[3] = t4.x, n5[4] = t4.y, n5[5] = t4.z), n5);
}
function y3(t4, o6, u10, c10) {
  const s7 = u10 ? 3 : 2;
  if (!o6.length || !o6[0].length) return null;
  let l8, h12, f12, x7, [g3, v5] = f7(o6[0][0]), y6 = g3, d6 = v5;
  for (let p5 = 0; p5 < o6.length; p5++) {
    const t5 = o6[p5];
    for (let o7 = 0; o7 < t5.length; o7++) {
      const p6 = f7(t5[o7]), [M2, z3] = p6;
      if (g3 = m7(g3, M2), v5 = m7(v5, z3), y6 = a6(y6, M2), d6 = a6(d6, z3), u10 && p6.length > 2) {
        const n5 = p6[2];
        l8 = m7(l8, n5), h12 = a6(h12, n5);
      }
      if (c10 && p6.length > s7) {
        const n5 = p6[s7];
        f12 = m7(l8, n5), x7 = a6(h12, n5);
      }
      const P3 = t5[o7];
      if (i5(P3) || o7 < 1) continue;
      const j3 = f7(t5[o7 - 1]), R2 = e(g3, v5, y6, d6);
      [g3, v5, y6, d6] = n3(R2, j3, P3);
    }
  }
  return u10 ? c10 ? (t4[0] = g3, t4[1] = v5, t4[2] = l8, t4[3] = f12, t4[4] = y6, t4[5] = d6, t4[6] = h12, t4[7] = x7, t4.length = 8, t4) : (t4[0] = g3, t4[1] = v5, t4[2] = l8, t4[3] = y6, t4[4] = d6, t4[5] = h12, t4.length = 6, t4) : c10 ? (t4[0] = g3, t4[1] = v5, t4[2] = f12, t4[3] = y6, t4[4] = d6, t4[5] = x7, t4.length = 6, t4) : (t4[0] = g3, t4[1] = v5, t4[2] = y6, t4[3] = d6, t4.length = 4, t4);
}
function d4(n5, t4, i8, r8, e10, o6) {
  const u10 = t4.xmin, c10 = t4.xmax, s7 = t4.ymin, l8 = t4.ymax;
  let h12 = t4.zmin, m10 = t4.zmax, a9 = t4.mmin, f12 = t4.mmax;
  return e10 ? (h12 = h12 || 0, m10 = m10 || 0, o6 ? (a9 = a9 || 0, f12 = f12 || 0, n5[0] = u10, n5[1] = s7, n5[2] = h12, n5[3] = a9, n5[4] = c10, n5[5] = l8, n5[6] = m10, n5[7] = f12, n5) : (n5[0] = u10, n5[1] = s7, n5[2] = h12, n5[3] = c10, n5[4] = l8, n5[5] = m10, n5)) : o6 ? (a9 = a9 || 0, f12 = f12 || 0, n5[0] = u10, n5[1] = s7, n5[2] = a9, n5[3] = c10, n5[4] = l8, n5[5] = f12, n5) : (n5[0] = u10, n5[1] = s7, n5[2] = c10, n5[3] = l8, n5);
}
function p4(n5, t4, i8, r8, e10, o6) {
  const u10 = i8 ? 3 : 2, c10 = r8 && o6, s7 = i8 && e10;
  if (!t4.length || !t4[0].length) return null;
  let l8, h12, f12, x7, [g3, v5] = t4[0], [y6, d6] = t4[0];
  for (let p5 = 0; p5 < t4.length; p5++) {
    const n6 = t4[p5], [i9, r9] = n6;
    if (g3 = m7(g3, i9), v5 = m7(v5, r9), y6 = a6(y6, i9), d6 = a6(d6, r9), s7 && n6.length > 2) {
      const t5 = n6[2];
      l8 = m7(l8, t5), h12 = a6(h12, t5);
    }
    if (c10 && n6.length > u10) {
      const t5 = n6[u10];
      f12 = m7(l8, t5), x7 = a6(h12, t5);
    }
  }
  return e10 ? (l8 = l8 || 0, h12 = h12 || 0, o6 ? (f12 = f12 || 0, x7 = x7 || 0, n5[0] = g3, n5[1] = v5, n5[2] = l8, n5[3] = f12, n5[4] = y6, n5[5] = d6, n5[6] = h12, n5[7] = x7, n5) : (n5[0] = g3, n5[1] = v5, n5[2] = l8, n5[3] = y6, n5[4] = d6, n5[5] = h12, n5)) : o6 ? (f12 = f12 || 0, x7 = x7 || 0, n5[0] = g3, n5[1] = v5, n5[2] = f12, n5[3] = y6, n5[4] = d6, n5[5] = x7, n5) : (n5[0] = g3, n5[1] = v5, n5[2] = y6, n5[3] = d6, n5);
}

// node_modules/@arcgis/core/geometry/geometryCursorCollectUtils.js
function t2(t4) {
  const n5 = [];
  for (t4.reset(); t4.nextPath(); ) {
    const e10 = [];
    for (; t4.nextPoint(); ) e10.push([t4.x, t4.y]);
    n5.push(e10);
  }
  return t4.reset(), n5;
}
function n4(t4) {
  const n5 = [];
  for (; t4.nextPoint(); ) n5.push([t4.x, t4.y]);
  return t4.seekPathStart(), n5;
}

// node_modules/@arcgis/core/geometry/support/centroid.js
function r6(t4) {
  return t4 ? t4.hasZ ? [t4.xmax - t4.xmin / 2, t4.ymax - t4.ymin / 2, t4.zmax - t4.zmin / 2] : [t4.xmax - t4.xmin / 2, t4.ymax - t4.ymin / 2] : null;
}
function l6(t4) {
  return u7(t4.rings, t4.hasZ ?? false);
}
function o4(t4) {
  const n5 = l6(t4);
  if (!n5) return null;
  const { hasZ: e10, spatialReference: r8 } = t4, [o6, u10, i8] = n5;
  return isNaN(o6) || isNaN(u10) || e10 && isNaN(i8) ? null : { x: o6, y: u10, z: e10 ? i8 : void 0, spatialReference: r8 };
}
function u7(t4, n5) {
  if (!t4?.length) return null;
  const e10 = [], r8 = [], l8 = n5 ? [1 / 0, -1 / 0, 1 / 0, -1 / 0, 1 / 0, -1 / 0] : [1 / 0, -1 / 0, 1 / 0, -1 / 0];
  for (let o6 = 0, u10 = t4.length; o6 < u10; o6++) {
    const e11 = i7(t4[o6], n5, l8);
    e11 && r8.push(e11);
  }
  if (r8.sort((t5, e11) => {
    let r9 = t5[2] - e11[2];
    return 0 === r9 && n5 && (r9 = t5[4] - e11[4]), r9;
  }), r8.length && (e10[0] = r8[0][0], e10[1] = r8[0][1], n5 && (e10[2] = r8[0][3]), (e10[0] < l8[0] || e10[0] > l8[1] || e10[1] < l8[2] || e10[1] > l8[3] || n5 && (e10[2] < l8[4] || e10[2] > l8[5])) && (e10.length = 0)), !e10.length) {
    const r9 = t4[0] && t4[0].length ? h9(t4[0], n5) : null;
    if (!r9) return null;
    e10[0] = r9[0], e10[1] = r9[1], n5 && r9.length > 2 && (e10[2] = r9[2]);
  }
  return e10;
}
function i7(t4, n5, e10) {
  let r8 = 0, l8 = 0, o6 = 0, u10 = 0, i8 = 0;
  const s7 = t4.length ? t4[0][0] : 0, h12 = t4.length ? t4[0][1] : 0, I3 = t4.length && n5 ? t4[0][2] : 0;
  for (let f12 = 0; f12 < t4.length; f12++) {
    const c11 = t4[f12], N2 = t4[(f12 + 1) % t4.length], [a9, x7, g3] = c11, m10 = a9 - s7, P3 = x7 - h12, [T, y6, E2] = N2, p5 = T - s7, S = y6 - h12, z3 = m10 * S - p5 * P3;
    if (u10 += z3, r8 += (m10 + p5) * z3, l8 += (P3 + S) * z3, n5 && c11.length > 2 && N2.length > 2) {
      const t5 = g3 - I3, n6 = E2 - I3, e11 = m10 * n6 - p5 * t5;
      o6 += (t5 + n6) * e11, i8 += e11;
    }
    a9 < e10[0] && (e10[0] = a9), a9 > e10[1] && (e10[1] = a9), x7 < e10[2] && (e10[2] = x7), x7 > e10[3] && (e10[3] = x7), n5 && (g3 < e10[4] && (e10[4] = g3), g3 > e10[5] && (e10[5] = g3));
  }
  if (u10 > 0 && (u10 *= -1), i8 > 0 && (i8 *= -1), !u10) return null;
  u10 *= 0.5, i8 *= 0.5;
  const c10 = [r8 / (6 * u10) + s7, l8 / (6 * u10) + h12, u10];
  return n5 && (e10[4] === e10[5] || 0 === i8 ? (c10[3] = (e10[4] + e10[5]) / 2, c10[4] = 0) : (c10[3] = o6 / (6 * i8) + I3, c10[4] = i8)), c10;
}
function s5(t4, n5) {
  let e10 = 0, r8 = 0, l8 = 0;
  t4.nextPoint();
  const o6 = t4.pathSize ? t4.x : 0, u10 = t4.pathSize ? t4.y : 0;
  for (let i8 = 0; i8 < t4.pathSize; i8++) {
    t4.seekInPath(i8);
    const s7 = [t4.x, t4.y];
    t4.seekInPath((i8 + 1) % t4.pathSize);
    const h12 = [t4.x, t4.y], [I3, c10] = s7, f12 = I3 - o6, N2 = c10 - u10, [a9, x7] = h12, g3 = a9 - o6, m10 = x7 - u10, P3 = f12 * m10 - g3 * N2;
    l8 += P3, e10 += (f12 + g3) * P3, r8 += (N2 + m10) * P3, I3 < n5[0] && (n5[0] = I3), I3 > n5[1] && (n5[1] = I3), c10 < n5[2] && (n5[2] = c10), c10 > n5[3] && (n5[3] = c10);
  }
  if (l8 > 0 && (l8 *= -1), !l8) return null;
  l8 *= 0.5;
  return [e10 / (6 * l8) + o6, r8 / (6 * l8) + u10, l8];
}
function h9(t4, r8) {
  const l8 = r8 ? [0, 0, 0] : [0, 0], o6 = r8 ? [0, 0, 0] : [0, 0];
  let u10 = 0, i8 = 0, s7 = 0, h12 = 0;
  for (let I3 = 0, c10 = t4.length; I3 < c10 - 1; I3++) {
    const c11 = t4[I3], f12 = t4[I3 + 1];
    if (c11 && f12) {
      l8[0] = c11[0], l8[1] = c11[1], o6[0] = f12[0], o6[1] = f12[1], r8 && c11.length > 2 && f12.length > 2 && (l8[2] = c11[2], o6[2] = f12[2]);
      const t5 = e4(l8, o6);
      if (t5) {
        u10 += t5;
        const e10 = l(c11, f12);
        i8 += t5 * e10[0], s7 += t5 * e10[1], r8 && e10.length > 2 && (h12 += t5 * e10[2]);
      }
    }
  }
  return u10 > 0 ? r8 ? [i8 / u10, s7 / u10, h12 / u10] : [i8 / u10, s7 / u10] : t4.length ? t4[0] : null;
}
function I2(n5) {
  const { hasZ: e10, totalSize: r8 } = n5;
  if (0 === r8) return null;
  const l8 = [], o6 = [], u10 = e10 ? [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY] : [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];
  for (n5.reset(); n5.nextPath(); ) {
    const e11 = i7(n4(n5), n5.hasZ, u10);
    e11 && o6.push(e11);
  }
  if (o6.sort((t4, n6) => {
    let r9 = t4[2] - n6[2];
    return 0 === r9 && e10 && (r9 = t4[4] - n6[4]), r9;
  }), o6.length && (l8[0] = o6[0][0], l8[1] = o6[0][1], e10 && (l8[2] = o6[0][3]), (l8[0] < u10[0] || l8[0] > u10[1] || l8[1] < u10[2] || l8[1] > u10[3] || e10 && (l8[2] < u10[4] || l8[2] > u10[5])) && (l8.length = 0)), !l8.length) {
    n5.reset(), n5.nextPath();
    const t4 = n5.pathSize ? c7(n5) : null;
    if (!t4) return null;
    l8[0] = t4[0], l8[1] = t4[1], e10 && t4.length > 2 && (l8[2] = t4[2]);
  }
  return l8;
}
function c7(t4) {
  const { hasZ: r8 } = t4, l8 = r8 ? [0, 0, 0] : [0, 0], o6 = r8 ? [0, 0, 0] : [0, 0];
  let u10 = 0, i8 = 0, s7 = 0, h12 = 0;
  if (t4.nextPoint()) {
    let I3 = t4.x, c10 = t4.y, f12 = t4.z;
    for (; t4.nextPoint(); ) {
      const N2 = t4.x, a9 = t4.y, x7 = t4.z;
      l8[0] = I3, l8[1] = c10, o6[0] = N2, o6[1] = a9, r8 && (l8[2] = f12, o6[2] = x7);
      const g3 = e4(l8, o6);
      if (g3) {
        u10 += g3;
        const t5 = l(l8, o6);
        i8 += g3 * t5[0], s7 += g3 * t5[1], r8 && t5.length > 2 && (h12 += g3 * t5[2]);
      }
      I3 = N2, c10 = a9, f12 = x7;
    }
  }
  return u10 > 0 ? r8 ? [i8 / u10, s7 / u10, h12 / u10] : [i8 / u10, s7 / u10] : t4.pathSize ? (t4.seekPathStart(), t4.nextPoint(), [t4.x, t4.y]) : null;
}
var f9 = 1e-6;
function N(t4) {
  let n5 = 0;
  for (t4.reset(); t4.nextPath(); ) n5 += t4.getCurrentRingArea();
  if (n5 < f9) {
    const n6 = I2(t4);
    return n6 ? [n6[0], n6[1]] : null;
  }
  const e10 = [0, 0];
  if (t4.reset(), !t4.nextPath() || !t4.nextPoint()) return null;
  const r8 = [t4.x, t4.y];
  for (t4.reset(); t4.nextPath(); ) x4(e10, r8, t4);
  return e10[0] *= 1 / n5, e10[1] *= 1 / n5, e10[0] += r8[0], e10[1] += r8[1], e10;
}
var a7 = 1 / 3;
function x4(t4, n5, e10) {
  if (!t4 || !e10 || e10.pathSize < 3) return null;
  e10.nextPoint();
  const r8 = e10.x, l8 = e10.y;
  e10.nextPoint();
  let o6, u10 = e10.x - r8, i8 = e10.y - l8, s7 = 0, h12 = 0;
  for (; e10.nextPoint(); ) s7 = e10.x - r8, h12 = e10.y - l8, o6 = 0.5 * a7 * (s7 * i8 - h12 * u10), t4[0] += o6 * (u10 + s7), t4[1] += o6 * (i8 + h12), u10 = s7, i8 = h12;
  const I3 = e10.getCurrentRingArea(), c10 = [r8, l8];
  return c10[0] -= n5[0], c10[1] -= n5[1], c10[0] *= I3, c10[1] *= I3, t4[0] += c10[0], t4[1] += c10[1], t4;
}

// node_modules/@arcgis/core/geometry/support/extentUtils.js
function t3(n5) {
  return void 0 !== n5.xmin && void 0 !== n5.ymin && void 0 !== n5.xmax && void 0 !== n5.ymax;
}
function u8(n5) {
  return void 0 !== n5.points;
}
function r7(n5) {
  return void 0 !== n5.x && void 0 !== n5.y;
}
function m8(n5) {
  return void 0 !== n5.paths;
}
function o5(n5) {
  return void 0 !== n5.rings;
}
var x5 = [];
function a8(n5, i8, t4, u10) {
  return { xmin: n5, ymin: i8, xmax: t4, ymax: u10 };
}
function c8(n5, i8, t4, u10, r8, m10) {
  return { xmin: n5, ymin: i8, zmin: t4, xmax: u10, ymax: r8, zmax: m10 };
}
function s6(n5, i8, t4, u10, r8, m10) {
  return { xmin: n5, ymin: i8, mmin: t4, xmax: u10, ymax: r8, mmax: m10 };
}
function e9(n5, i8, t4, u10, r8, m10, o6, x7) {
  return { xmin: n5, ymin: i8, zmin: t4, mmin: u10, xmax: r8, ymax: m10, zmax: o6, mmax: x7 };
}
function f10(n5, i8 = false, t4 = false) {
  return i8 ? t4 ? e9(n5[0], n5[1], n5[2], n5[3], n5[4], n5[5], n5[6], n5[7]) : c8(n5[0], n5[1], n5[2], n5[3], n5[4], n5[5]) : t4 ? s6(n5[0], n5[1], n5[2], n5[3], n5[4], n5[5]) : a8(n5[0], n5[1], n5[2], n5[3]);
}
function l7(n5) {
  return n5 ? t3(n5) ? n5 : r7(n5) ? v3(n5) : o5(n5) ? d5(n5) : m8(n5) ? h10(n5) : u8(n5) ? y4(n5) : null : null;
}
function y4(n5) {
  const { hasZ: t4, hasM: u10, points: r8 } = n5, m10 = p4(x5, r8, t4 ?? false, u10 ?? false, t4 ?? false, u10 ?? false);
  return m10 ? f10(m10, t4, u10) : null;
}
function v3(n5) {
  const { x: i8, y: t4, z: u10, m: r8 } = n5, m10 = null != r8;
  return null != u10 ? m10 ? e9(i8, t4, u10, r8, i8, t4, u10, r8) : c8(i8, t4, u10, i8, t4, u10) : m10 ? s6(i8, t4, r8, i8, t4, r8) : a8(i8, t4, i8, t4);
}
function d5(i8) {
  const { hasZ: t4, hasM: u10, rings: r8, curveRings: m10 } = i8, o6 = y3(x5, m10 ?? r8, t4 ?? false, u10 ?? false);
  return o6 ? f10(o6, t4, u10) : null;
}
function h10(i8) {
  const { hasZ: t4, hasM: u10, paths: r8, curvePaths: m10 } = i8, o6 = y3(x5, m10 ?? r8, t4 ?? false, u10 ?? false);
  return o6 ? f10(o6, t4, u10) : null;
}

// node_modules/@arcgis/core/geometry/support/zmUtils.js
function h11(h12, a9, s7 = false) {
  let { hasM: t4, hasZ: e10 } = h12;
  Array.isArray(a9) ? 4 !== a9.length || t4 || e10 ? 3 === a9.length && s7 && !t4 ? (e10 = true, t4 = false) : 3 === a9.length && t4 && e10 && (t4 = false, e10 = false) : (t4 = true, e10 = true) : (e10 = !e10 && a9.hasZ && (!t4 || a9.hasM), t4 = !t4 && a9.hasM && (!e10 || a9.hasZ)), h12.hasZ = e10, h12.hasM = t4;
}

// node_modules/@arcgis/core/geometry/Polygon.js
var w2;
function v4(t4) {
  return !Array.isArray(t4[0]);
}
function x6(t4) {
  return "number" == typeof t4[0]?.[0];
}
function j2(t4) {
  if (!t4) return;
  let { rings: e10, hasM: r8, hasZ: s7, spatialReference: i8 } = t4;
  switch (e10 ??= [], x6(e10) && (e10 = [e10]), e10[0]?.[0]?.length) {
    case 4:
      s7 ??= true, r8 ??= true;
      break;
    case 3:
      s7 ??= true !== r8, r8 ??= !s7;
      break;
    default:
      s7 ??= false, r8 ??= false;
  }
  return i8 ??= f.WGS84, { ...t4, hasM: r8, hasZ: s7, rings: e10, spatialReference: i8 };
}
var P2 = w2 = class extends c2 {
  static fromExtent(t4) {
    const e10 = t4.clone().normalize(), { spatialReference: r8 } = t4;
    let s7 = false, i8 = false;
    for (const o6 of e10) o6.hasZ && (s7 = true), o6.hasM && (i8 = true);
    const n5 = { rings: e10.map((t5) => {
      const e11 = [[t5.xmin, t5.ymin], [t5.xmin, t5.ymax], [t5.xmax, t5.ymax], [t5.xmax, t5.ymin], [t5.xmin, t5.ymin]];
      if (s7 && t5.hasZ) {
        const r9 = t5.zmin + 0.5 * (t5.zmax - t5.zmin);
        for (let t6 = 0; t6 < e11.length; t6++) e11[t6].push(r9);
      }
      if (i8 && t5.hasM) {
        const r9 = t5.mmin + 0.5 * (t5.mmax - t5.mmin);
        for (let t6 = 0; t6 < e11.length; t6++) e11[t6].push(r9);
      }
      return e11;
    }), spatialReference: r8 };
    return s7 && (n5.hasZ = true), i8 && (n5.hasM = true), new w2(n5);
  }
  constructor(t4) {
    super(j2(t4)), this.curveRings = void 0, this.rings = [], this.type = "polygon";
  }
  get cache() {
    return this.commitProperty("curveRings"), this.commitProperty("hasM"), this.commitProperty("hasZ"), this.commitProperty("rings"), this.commitProperty("spatialReference"), {};
  }
  get centroid() {
    c(i.getLogger(this), "centroid", { replacement: "Please use centroidOperator.execute() instead.", version: "4.34", warnOnce: true });
    const t4 = o4(this);
    return t4 ? _.fromJSON(t4) : null;
  }
  writeCurveRings(t4, e10) {
    e10.curveRings = a(t4);
  }
  get extent() {
    const t4 = d5(this), { spatialReference: e10 } = this;
    return t4 ? new z({ ...t4, spatialReference: e10 }) : null;
  }
  get isSelfIntersecting() {
    return c(i.getLogger(this), "isSelfIntersecting", { replacement: "Please use simplifyOperator.isSimple() instead.", version: "4.33", warnOnce: true }), p(this.rings);
  }
  writeRings(t4, e10) {
    e10.rings = a(this.rings);
  }
  addRing(t4) {
    if (!t4) return;
    const e10 = this.rings, r8 = e10.length;
    if (v4(t4)) {
      const s7 = [];
      for (let e11 = 0, r9 = t4.length; e11 < r9; e11++) s7[e11] = t4[e11].toArray();
      e10[r8] = s7;
    } else e10[r8] = t4.slice();
    return this.notifyChange("rings"), this;
  }
  clone() {
    const t4 = new w2();
    return t4.spatialReference = this.spatialReference, t4.rings = a(this.rings), t4.curveRings = a(this.curveRings), t4.hasZ = this.hasZ, t4.hasM = this.hasM, t4;
  }
  equals(t4) {
    if (this === t4) return true;
    if (null == t4) return false;
    const r8 = this.spatialReference, s7 = t4.spatialReference;
    if (null != r8 != (null != s7)) return false;
    if (null != r8 && null != s7 && !r8.equals(s7)) return false;
    if (this.rings.length !== t4.rings.length) return false;
    const i8 = ([t5, e10, r9, s8], [i9, n5, o6, a9]) => t5 === i9 && e10 === n5 && (null == r9 && null == o6 || r9 === o6) && (null == s8 && null == a9 || s8 === a9);
    for (let n5 = 0; n5 < this.rings.length; n5++) {
      const r9 = this.rings[n5], s8 = t4.rings[n5];
      if (!h(r9, s8, i8)) return false;
    }
    return true;
  }
  contains(t4) {
    if (!t4) return false;
    const e10 = y(t4, this.spatialReference);
    return f2(this, null != e10 ? e10 : t4);
  }
  isClockwise(t4) {
    const e10 = v4(t4) ? t4.map((t5) => this.hasZ ? this.hasM ? [t5.x, t5.y, t5.z, t5.m] : [t5.x, t5.y, t5.z] : [t5.x, t5.y]) : t4;
    return h3(e10);
  }
  getPoint(t4, e10) {
    if (!this._validateInputs(t4, e10)) return null;
    const r8 = this.rings[t4][e10], s7 = this.hasZ, i8 = this.hasM;
    return s7 && !i8 ? new _(r8[0], r8[1], r8[2], void 0, this.spatialReference) : i8 && !s7 ? new _(r8[0], r8[1], void 0, r8[2], this.spatialReference) : s7 && i8 ? new _(r8[0], r8[1], r8[2], r8[3], this.spatialReference) : new _(r8[0], r8[1], this.spatialReference);
  }
  insertPoint(t4, e10, r8) {
    return this._validateInputs(t4, e10, true) ? (h11(this, r8), Array.isArray(r8) || (r8 = r8.toArray()), this.rings[t4].splice(e10, 0, r8), this.notifyChange("rings"), this) : this;
  }
  removePoint(t4, e10) {
    if (!this._validateInputs(t4, e10)) return null;
    const r8 = new _(this.rings[t4].splice(e10, 1)[0], this.spatialReference);
    return this.notifyChange("rings"), r8;
  }
  removeRing(t4) {
    if (!this._validateInputs(t4, null)) return null;
    const e10 = this.rings.splice(t4, 1)[0], r8 = this.spatialReference, s7 = e10.map((t5) => new _(t5, r8));
    return this.notifyChange("rings"), s7;
  }
  setPoint(t4, e10, r8) {
    return this._validateInputs(t4, e10) ? (h11(this, r8), Array.isArray(r8) || (r8 = r8.toArray()), this.rings[t4][e10] = r8, this.notifyChange("rings"), this) : this;
  }
  _validateInputs(t4, e10, r8 = false) {
    if (null == t4 || t4 < 0 || t4 >= this.rings.length) return false;
    if (null != e10) {
      const s7 = this.rings[t4];
      if (r8 && (e10 < 0 || e10 > s7.length)) return false;
      if (!r8 && (e10 < 0 || e10 >= s7.length)) return false;
    }
    return true;
  }
  toJSON(t4) {
    return this.write({}, t4);
  }
};
__decorate([m({ readOnly: true })], P2.prototype, "cache", null), __decorate([m({ readOnly: true })], P2.prototype, "centroid", null), __decorate([m({ json: { write: true, origins: { "portal-item": { write: false }, "web-map": { write: false }, "web-scene": { write: false } } } })], P2.prototype, "curveRings", void 0), __decorate([r("curveRings")], P2.prototype, "writeCurveRings", null), __decorate([m({ readOnly: true })], P2.prototype, "extent", null), __decorate([m({ readOnly: true })], P2.prototype, "isSelfIntersecting", null), __decorate([m({ type: [[[Number]]], json: { write: { isRequired: true } } })], P2.prototype, "rings", void 0), __decorate([r("rings")], P2.prototype, "writeRings", null), P2 = w2 = __decorate([a2("esri.geometry.Polygon")], P2), P2.prototype.toJSON.isDefaultToJSON = true;

// node_modules/@arcgis/core/geometry/Polyline.js
var c9;
function u9(t4) {
  return !Array.isArray(t4[0]);
}
function f11(t4) {
  return "number" == typeof t4[0]?.[0];
}
function m9(t4) {
  if (!t4) return;
  let { paths: e10, hasM: r8, hasZ: s7, spatialReference: i8 } = t4;
  switch (e10 ??= [], f11(e10) && (e10 = [e10]), e10[0]?.[0]?.length) {
    case 4:
      s7 ??= true, r8 ??= true;
      break;
    case 3:
      s7 ??= true !== r8, r8 ??= !s7;
      break;
    default:
      s7 ??= false, r8 ??= false;
  }
  return i8 ??= f.WGS84, { ...t4, hasM: r8, hasZ: s7, paths: e10, spatialReference: i8 };
}
var y5 = c9 = class extends c2 {
  constructor(t4) {
    super(m9(t4)), this.curvePaths = void 0, this.paths = [], this.type = "polyline";
  }
  get cache() {
    return this.commitProperty("curvePaths"), this.commitProperty("hasM"), this.commitProperty("hasZ"), this.commitProperty("paths"), this.commitProperty("spatialReference"), {};
  }
  writeCurvePaths(t4, r8) {
    r8.curvePaths = a(t4);
  }
  get extent() {
    const t4 = h10(this), { spatialReference: e10 } = this;
    return t4 ? new z({ ...t4, spatialReference: e10 }) : null;
  }
  writePaths(t4, r8) {
    r8.paths = a(this.paths);
  }
  addPath(t4) {
    if (!t4) return;
    const e10 = this.paths, r8 = e10.length;
    if (u9(t4)) {
      const s7 = [];
      for (let e11 = 0, r9 = t4.length; e11 < r9; e11++) s7[e11] = t4[e11].toArray();
      e10[r8] = s7;
    } else e10[r8] = t4.slice();
    return this.notifyChange("paths"), this;
  }
  clone() {
    const t4 = new c9();
    return t4.spatialReference = this.spatialReference, t4.paths = a(this.paths), t4.curvePaths = a(this.curvePaths), t4.hasZ = this.hasZ, t4.hasM = this.hasM, t4;
  }
  getPoint(t4, e10) {
    if (!this._validateInputs(t4, e10)) return null;
    const r8 = this.paths[t4][e10], s7 = this.hasZ, i8 = this.hasM;
    return s7 && !i8 ? new _(r8[0], r8[1], r8[2], void 0, this.spatialReference) : i8 && !s7 ? new _(r8[0], r8[1], void 0, r8[2], this.spatialReference) : s7 && i8 ? new _(r8[0], r8[1], r8[2], r8[3], this.spatialReference) : new _(r8[0], r8[1], this.spatialReference);
  }
  insertPoint(t4, e10, r8) {
    return this._validateInputs(t4, e10, true) ? (h11(this, r8), Array.isArray(r8) || (r8 = r8.toArray()), this.paths[t4].splice(e10, 0, r8), this.notifyChange("paths"), this) : this;
  }
  removePath(t4) {
    if (!this._validateInputs(t4, null)) return null;
    const e10 = this.paths.splice(t4, 1)[0], r8 = this.spatialReference, s7 = e10.map((t5) => new _(t5, r8));
    return this.notifyChange("paths"), s7;
  }
  removePoint(t4, e10) {
    if (!this._validateInputs(t4, e10)) return null;
    const r8 = new _(this.paths[t4].splice(e10, 1)[0], this.spatialReference);
    return this.notifyChange("paths"), r8;
  }
  setPoint(t4, e10, r8) {
    return this._validateInputs(t4, e10) ? (h11(this, r8), Array.isArray(r8) || (r8 = r8.toArray()), this.paths[t4][e10] = r8, this.notifyChange("paths"), this) : this;
  }
  _validateInputs(t4, e10, r8 = false) {
    if (null == t4 || t4 < 0 || t4 >= this.paths.length) return false;
    if (null != e10) {
      const s7 = this.paths[t4];
      if (r8 && (e10 < 0 || e10 > s7.length)) return false;
      if (!r8 && (e10 < 0 || e10 >= s7.length)) return false;
    }
    return true;
  }
  toJSON(t4) {
    return this.write({}, t4);
  }
};
__decorate([m({ readOnly: true })], y5.prototype, "cache", null), __decorate([m({ json: { write: true, origins: { "portal-item": { write: false }, "web-map": { write: false }, "web-scene": { write: false } } } })], y5.prototype, "curvePaths", void 0), __decorate([r("curvePaths")], y5.prototype, "writeCurvePaths", null), __decorate([m({ readOnly: true })], y5.prototype, "extent", null), __decorate([m({ type: [[[Number]]], json: { write: { isRequired: true } } })], y5.prototype, "paths", void 0), __decorate([r("paths")], y5.prototype, "writePaths", null), y5 = c9 = __decorate([a2("esri.geometry.Polyline")], y5), y5.prototype.toJSON.isDefaultToJSON = true;

export {
  r4 as r,
  o,
  u2 as u,
  e5 as e,
  h7 as h,
  p2 as p,
  M,
  b2 as b,
  d2 as d,
  s3 as s,
  h5 as h2,
  u3 as u2,
  f5 as f,
  l3 as l,
  u4 as u3,
  f6 as f2,
  n,
  r5 as r2,
  t,
  u5 as u4,
  i5 as i,
  e8 as e2,
  c5 as c,
  a4 as a,
  f7 as f3,
  o2,
  h6 as h3,
  n2,
  p3 as p2,
  d3 as d2,
  x2 as x,
  q2 as q,
  g,
  w,
  f8 as f4,
  x3 as x2,
  g2,
  v2 as v,
  y3 as y,
  l7 as l2,
  y4 as y2,
  d5 as d3,
  h11 as h4,
  t2,
  n4 as n3,
  r6 as r3,
  l6 as l3,
  o4 as o3,
  u7 as u5,
  s5 as s2,
  I2 as I,
  N,
  P2 as P,
  y5 as y3
};
//# sourceMappingURL=chunk-PZ5RULLK.js.map
