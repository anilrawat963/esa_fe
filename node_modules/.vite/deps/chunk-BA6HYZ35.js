import {
  P
} from "./chunk-6VL5D5UP.js";
import {
  f,
  m,
  s as s2,
  y
} from "./chunk-GD4FJL3C.js";
import {
  B,
  J,
  N as N3
} from "./chunk-2LC2762W.js";
import {
  l2 as l
} from "./chunk-PZ5RULLK.js";
import {
  M,
  R,
  d
} from "./chunk-AXZMNHTN.js";
import {
  C,
  N as N2,
  T,
  c,
  oe,
  p
} from "./chunk-NMQNUPE4.js";
import {
  o
} from "./chunk-65HD3WXL.js";
import {
  $
} from "./chunk-GNMPGHLQ.js";
import {
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  N
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/layers/graphics/data/projectionSupport.js
var l2 = [0, 0];
function p2(s3, t) {
  if (!t) return null;
  if ("x" in t) {
    const e = { x: 0, y: 0 };
    return [e.x, e.y] = s3(t.x, t.y, l2), null != t.z && (e.z = t.z), null != t.m && (e.m = t.m), e;
  }
  if ("xmin" in t) {
    const e = { xmin: 0, ymin: 0, xmax: 0, ymax: 0 };
    return [e.xmin, e.ymin] = s3(t.xmin, t.ymin, l2), [e.xmax, e.ymax] = s3(t.xmax, t.ymax, l2), t.hasZ && (e.zmin = t.zmin, e.zmax = t.zmax, e.hasZ = true), t.hasM && (e.mmin = t.mmin, e.mmax = t.mmax, e.hasM = true), e;
  }
  return "rings" in t ? { rings: c2(t.rings, s3), hasM: t.hasM, hasZ: t.hasZ } : "paths" in t ? { paths: c2(t.paths, s3), hasM: t.hasM, hasZ: t.hasZ } : "points" in t ? { points: h(t.points, s3), hasM: t.hasM, hasZ: t.hasZ } : null;
}
function c2(s3, t) {
  const e = [];
  for (const n of s3) e.push(h(n, t));
  return e;
}
function h(s3, t) {
  const e = [];
  for (const n of s3) {
    const s4 = t(n[0], n[1], [0, 0]);
    e.push(s4), n.length > 2 && s4.push(n[2]), n.length > 3 && s4.push(n[3]);
  }
  return e;
}
async function f2(t, n) {
  if (!t || !n) return;
  const r = Array.isArray(t) ? t.map((s3) => null != s3.geometry ? s3.geometry.spatialReference : null).filter(N) : [t];
  await N3(r.map((s3) => ({ source: s3, dest: n })));
}
var x = p2.bind(null, d);
var y2 = p2.bind(null, R);
function g(s3, t, e, m2) {
  if (!s3) return null;
  if (e || (e = t, t = s3.spatialReference), !p(t) || !p(e) || T(t, e)) return s3;
  if (M(t, e)) {
    const t2 = C(e) ? x(s3) : y2(s3);
    return t2.spatialReference = e, t2;
  }
  return B([s3], t, e, m2)[0];
}
var _ = class {
  constructor() {
    this._jobs = [], this._timer = null, this._process = this._process.bind(this);
  }
  async push(s3, e, n, r) {
    if (!s3?.length || !e || !n || T(e, n)) return s3;
    const o2 = { geometries: s3, inSpatialReference: e, outSpatialReference: n, options: r, resolve: $() };
    return this._jobs.push(o2), this._timer ??= setTimeout(this._process, 10), o2.resolve.promise;
  }
  _process() {
    this._timer = null;
    const s3 = this._jobs.shift();
    if (!s3) return;
    const { geometries: t, inSpatialReference: e, outSpatialReference: r, resolve: i, options: m2 } = s3;
    M(e, r) && null == m2?.extendedParams ? C(r) ? i(t.map(x)) : i(t.map(y2)) : i(B(t, e, r, m2)), this._jobs.length > 0 && (this._timer = setTimeout(this._process, 10));
  }
};
var j = new _();
function M2(s3, t, e, n) {
  return j.push(s3, t, e, n);
}

// node_modules/@arcgis/core/layers/graphics/data/queryUtils.js
var g2 = new o({ esriSRUnit_Meter: "meters", esriSRUnit_Kilometer: "kilometers", esriSRUnit_Foot: "feet", esriSRUnit_StatuteMile: "miles", esriSRUnit_NauticalMile: "nautical-miles", esriSRUnit_USNauticalMile: "us-nautical-miles" });
var S = Object.freeze({});
var R2 = "frequency";
async function x2(t, e, i) {
  const r = t.bin;
  return r.onField && (r.onField = r.onField.trim()), r.onExpression?.value && (r.onExpression.value = r.onExpression.value.trim()), r.splitBy && (r.splitBy.value && (r.splitBy.value = r.splitBy.value.trim()), r.splitBy.outAlias && (r.splitBy.outAlias = r.splitBy.outAlias.trim())), r.stackBy && (r.stackBy.value && (r.stackBy.value = r.stackBy.value.trim()), r.stackBy.outAlias && (r.stackBy.outAlias = r.stackBy.outAlias.trim())), "normalizationField" in r.parameters && r.parameters.normalizationField && (r.parameters.normalizationField = r.parameters.normalizationField.trim()), t.outStatistics?.length || (t.outStatistics = [{ statisticType: "count", onStatisticField: "1", outStatisticFieldName: R2 }]), w(t, e, i);
}
async function w(t, e, i) {
  const { outFields: r, orderByFields: n, groupByFieldsForStatistics: a, outStatistics: o2 } = t;
  if (r) for (let s3 = 0; s3 < r.length; s3++) r[s3] = r[s3].trim();
  if (n) for (let s3 = 0; s3 < n.length; s3++) n[s3] = n[s3].trim();
  if (a) for (let s3 = 0; s3 < a.length; s3++) a[s3] = a[s3].trim();
  if (o2) for (let s3 = 0; s3 < o2.length; s3++) o2[s3].onStatisticField && (o2[s3].onStatisticField = o2[s3].onStatisticField.trim());
  return t.geometry && !t.outSR && (t.outSR = t.geometry.spatialReference), B2(t, e, i);
}
async function B2(t, e, i) {
  if (!t) return null;
  let { where: r } = t;
  if (t.where = r = r?.trim(), (!r || /^1 *= *1$/.test(r) || e && e === r) && (t.where = null), !t.geometry) return t;
  let o2 = await v(t);
  if (t.distance = 0, t.units = null, "esriSpatialRelEnvelopeIntersects" === t.spatialRel) {
    const { spatialReference: e2 } = t.geometry;
    o2 = l(o2), o2.spatialReference = e2;
  }
  if (o2) {
    await f2(o2.spatialReference, i), o2 = j2(o2, i);
    const e2 = (await P(f(o2)))[0];
    if (null == e2) throw S;
    const r2 = "quantizationParameters" in t && t.quantizationParameters?.tolerance || "maxAllowableOffset" in t && t.maxAllowableOffset || 0, n = r2 && F(o2, i) ? { extendedParams: { densificationStep: 8 * r2 } } : void 0, s3 = e2.toJSON(), l3 = g(s3, s3.spatialReference, i, n);
    if (!l3) throw S;
    l3.spatialReference = i, t.geometry = l3;
  }
  return t;
}
function F(t, e) {
  if (!t) return false;
  const i = t.spatialReference;
  return (m(t) || y(t) || s2(t)) && !T(i, e) && !J(i, e);
}
function j2(t, e) {
  const i = t.spatialReference;
  return F(t, e) && m(t) ? { spatialReference: i, rings: [[[t.xmin, t.ymin], [t.xmin, t.ymax], [t.xmax, t.ymax], [t.xmax, t.ymin], [t.xmin, t.ymin]]] } : t;
}
async function v(e) {
  const { distance: r, units: n } = e, a = e.geometry;
  if (null == r || "vertexAttributes" in a) return a;
  const s3 = a.spatialReference, l3 = n ? g2.fromJSON(n) : oe(s3), m2 = s3 && (c(s3) || C(s3)) ? a : await f2(s3, N2).then(() => g(a, N2)), f3 = await import("./geodesicBufferOperator-DRPFS2PE.js");
  await f3.load();
  const S2 = f3.execute(m2, r || 1, { unit: l3 }) ?? void 0;
  if (!S2 || !y(S2) || 0 === S2.rings.length) throw new s("unsupported-query:invalid-parameters", "Invalid parameters for query by distance");
  return S2;
}
function h2(t, e) {
  return null == t ? null : "string" == typeof t ? e ? (/* @__PURE__ */ new Date(`1970-01-01T${t}Z`)).getTime() : new Date(t).getTime() : t instanceof Date ? t.getTime() : t;
}

export {
  f2 as f,
  g,
  M2 as M,
  g2,
  S,
  x2 as x,
  w,
  B2 as B,
  h2 as h
};
//# sourceMappingURL=chunk-BA6HYZ35.js.map
