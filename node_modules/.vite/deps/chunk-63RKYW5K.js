import {
  k
} from "./chunk-W75DBJD7.js";
import {
  M
} from "./chunk-7P2ANHQ3.js";
import {
  H2 as H,
  p2 as p,
  s2
} from "./chunk-V2H77UEV.js";
import {
  f2 as f
} from "./chunk-GNMPGHLQ.js";
import {
  s2 as s
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/layers/support/associatedFeatureServiceUtils.js
async function s3(e, r) {
  const n = p(e);
  if (!n) throw new s("invalid-url", "Invalid scene service url");
  const o = { ...r, sceneServerUrl: n.url.path, layerId: n.sublayer ?? void 0 };
  if (o.sceneLayerItem ??= await l(o), null == o.sceneLayerItem) return f2(o.sceneServerUrl.replace("/SceneServer", "/FeatureServer"), o);
  const i = await y(o);
  if (!i?.url) throw new s("related-service-not-found", "Could not find feature service through portal item relationship");
  o.featureServiceItem = i;
  const s4 = await f2(i.url, o);
  return s4.portalItem = i, s4;
}
async function l(e) {
  const r = (await c(e)).serviceItemId;
  if (!r) return null;
  const t = new k({ id: r, apiKey: e.apiKey }), a = await u(e);
  null != a && (t.portal = new M({ url: a }));
  try {
    return await t.load({ signal: e.signal });
  } catch (s4) {
    return f(s4), null;
  }
}
async function c(e) {
  if (e.rootDocument) return e.rootDocument;
  const t = { query: { f: "json", ...e.customParameters, token: e.apiKey }, responseType: "json", signal: e.signal };
  try {
    const n = await H(e.sceneServerUrl, t);
    e.rootDocument = n.data;
  } catch {
    e.rootDocument = {};
  }
  return e.rootDocument;
}
async function u(t) {
  const a = s2?.findServerInfo(t.sceneServerUrl);
  if (a?.owningSystemUrl) return a.owningSystemUrl;
  const o = t.sceneServerUrl.replace(/(.*\/rest)\/.*/i, "$1") + "/info";
  try {
    const e = (await H(o, { query: { f: "json" }, responseType: "json", signal: t.signal })).data.owningSystemUrl;
    if (e) return e;
  } catch (i) {
    f(i);
  }
  return null;
}
async function f2(e, n) {
  const o = p(e);
  if (!o) throw new s("invalid-feature-service-url", "Invalid feature service url");
  const i = o.url.path, s4 = n.layerId;
  if (null == s4) return { serverUrl: i };
  const l2 = c(n), u2 = n.featureServiceItem ? await n.featureServiceItem.fetchData("json") : null, f3 = (u2?.layers?.[0] || u2?.tables?.[0])?.customParameters, y2 = (e2) => {
    const t = { query: { f: "json", ...f3 }, responseType: "json", authMode: e2, signal: n.signal };
    return H(i, t);
  }, m = y2("anonymous").catch(() => y2("no-prompt")), [p2, d] = await Promise.all([m, l2]), v = d?.layers, w = p2.data && p2.data.layers;
  if (!Array.isArray(w)) throw new Error("expected layers array");
  if (Array.isArray(v)) for (let r = 0; r < Math.min(v.length, w.length); r++) {
    if (v[r].id === s4) return { serverUrl: i, layerId: w[r].id };
  }
  else if (null != s4 && s4 < w.length) return { serverUrl: i, layerId: w[s4].id };
  throw new Error("could not find matching associated sublayer");
}
async function y({ sceneLayerItem: e, signal: r }) {
  if (!e) return null;
  try {
    const t = (await e.fetchRelatedItems({ relationshipType: "Service2Service", direction: "reverse" }, { signal: r })).find((e2) => "Feature Service" === e2.type) || null;
    if (!t) return null;
    const n = new k({ portal: t.portal, id: t.id });
    return await n.load(), n;
  } catch (t) {
    return f(t), null;
  }
}

export {
  s3 as s
};
//# sourceMappingURL=chunk-63RKYW5K.js.map
