import {
  s as s3
} from "./chunk-BBYMM7CM.js";
import {
  a2,
  c,
  r2 as r
} from "./chunk-V2H77UEV.js";
import {
  $,
  C,
  a,
  d,
  e,
  l2 as l,
  o4 as o,
  s as s2,
  t,
  u3 as u,
  w
} from "./chunk-GNMPGHLQ.js";
import {
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  has
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/core/workers/utils.js
var r2 = "worker:port-closed";
var e2 = { HANDSHAKE: 0, OPEN: 1, OPENED: 2, RESPONSE: 3, INVOKE: 4, ABORT: 5, CLOSE: 6, OPEN_PORT: 7, ON: 8 };
var n = 0;
function s4() {
  return n++;
}
function i(t3) {
  return t3 && "object" == typeof t3 && ("result" in t3 || "transferList" in t3);
}
function o2(t3) {
  return t3 ? "string" == typeof t3 ? JSON.stringify({ name: "message", message: t3 }) : t3.toJSON ? JSON.stringify(t3) : JSON.stringify({ name: t3.name, message: t3.message, details: t3.details || { stack: t3.stack } }) : null;
}
function a3(t3, r4, n4, s5) {
  if (r4.type === e2.OPEN_PORT) return void t3.postMessage(r4, [r4.port]);
  if (r4.type !== e2.INVOKE && r4.type !== e2.RESPONSE) return void t3.postMessage(r4);
  let o3;
  i(n4) ? (o3 = u2(n4.transferList), r4.data = n4.result) : (o3 = u2(s5), r4.data = n4), o3 ? t3.postMessage(r4, o3) : t3.postMessage(r4);
}
function f(t3) {
  if (!t3) return null;
  const r4 = t3.data;
  return r4 ? "string" == typeof r4 ? JSON.parse(r4) : r4 : null;
}
function u2(t3) {
  if (!t3?.length) return null;
  if (has("esri-workers-arraybuffer-transfer")) return t3;
  const r4 = t3.filter((t4) => !c2(t4));
  return r4.length ? r4 : null;
}
function c2(t3) {
  return t3 instanceof ArrayBuffer || "ArrayBuffer" === t3?.constructor?.name;
}
async function l2(e4) {
  try {
    return await e4;
  } catch (n4) {
    const e5 = n4?.name === r2;
    if (!(d(n4) || e5)) throw n4;
    return;
  }
}

// node_modules/@arcgis/core/core/workers/InvokeHandler.js
function t2(t3, r4) {
  return new Proxy({}, { get: (e4, i3, s5) => (...e5) => {
    let s6, o3;
    const a4 = e5[e5.length - 1];
    n2(a4) && (s6 = a4.signal, o3 = a4.transferList, e5.pop());
    return t3.apply(r4 ? `${r4}.${i3.toString()}` : i3.toString(), e5, { transferList: o3, signal: s6 });
  } });
}
function n2(t3) {
  return "object" == typeof t3 && !Array.isArray(t3) && null != t3 && ("signal" in t3 || "transferList" in t3 || 0 === Object.keys(t3).length);
}

// node_modules/@arcgis/core/core/workers/registry.js
var r3 = { statsWorker: () => import("./statsWorker-YZXKI5KV.js"), geometryEngineWorker: () => import("./geometryEngineWorker-UYWVJTEV.js"), arcadeGeometryOperatorsWorker: () => import("./operatorsWorker-UGUDWAUO.js"), CSVSourceWorker: () => import("./CSVSourceWorker-LS2Z674D.js"), EdgeProcessingWorker: () => import("./EdgeProcessingWorker-7PNTZ2UB.js"), ElevationSamplerWorker: () => import("./ElevationSamplerWorker-CGII75XD.js"), FeatureServiceSnappingSourceWorker: () => import("./FeatureServiceSnappingSourceWorker-G57WEJNF.js"), GaussianSplatSortWorker: () => import("./GaussianSplatSortWorker-2QVNVZFH.js"), GeoJSONSourceWorker: () => import("./GeoJSONSourceWorker-W4KUERDK.js"), LercWorker: () => import("./LercWorker-45DCP7JO.js"), MemorySourceWorker: () => import("./MemorySourceWorker-RUBL7MHO.js"), PBFDecoderWorker: () => import("./PBFDecoderWorker-FCQSL7IY.js"), FeaturePipelineWorker: () => import("./FeaturePipelineWorker-LXLRTXAH.js"), PointCloudWorker: () => import("./PointCloudWorker-EX3WRYW4.js"), RasterWorker: () => import("./RasterWorker-GVSLGDFE.js"), SceneLayerSnappingSourceWorker: () => import("./SceneLayerSnappingSourceWorker-SJYMYFA2.js"), SceneLayerWorker: () => import("./SceneLayerWorker-NBMOIVVT.js"), WFSSourceWorker: () => import("./WFSSourceWorker-C3BPAGYH.js"), WorkerTileHandler: () => import("./WorkerTileHandler-GULSUWE6.js"), Lyr3DWorker: () => import("./Lyr3DWorker-SAEO57EK.js"), Feature3DPipelineWorker: () => import("./Feature3DPipelineWorker-RUK7VR4N.js"), TextureCompressionWorker: () => import("./TextureCompressionWorker-5TD5VUSW.js"), FlowWorker: () => import("./FlowWorker-75KJVABJ.js"), ParquetSourceWorker: () => import("./ParquetSourceWorker-G4WHZH22.js"), PanoramicMeshWorker: () => import("./PanoramicMeshWorker-QQ2X5C4N.js") };

// node_modules/@arcgis/core/core/workers/RemoteClient.js
var { CLOSE: M, ABORT: k, INVOKE: y, RESPONSE: j, OPEN_PORT: I, ON: J } = e2;
var w2 = 2;
var O = class {
  constructor(e4) {
    this._invoke = e4, this._timer = null, this._cancelledJobIds = /* @__PURE__ */ new Set(), this._invokeMessages = [], this._timer = null, this._process = this._process.bind(this);
  }
  push(e4) {
    e4.type === k ? this._cancelledJobIds.add(e4.jobId) : (this._invokeMessages.push(e4), null === this._timer && (this._timer = setTimeout(this._process, 0)));
  }
  clear() {
    this._invokeMessages.length = 0, this._cancelledJobIds.clear(), this._timer = null;
  }
  _process() {
    this._timer = null;
    for (const e4 of this._invokeMessages) this._cancelledJobIds.has(e4.jobId) || this._invoke(e4);
    this._cancelledJobIds.clear(), this._invokeMessages.length = 0;
  }
};
var _E = class _E {
  static connect(e4, s5) {
    const t3 = new MessageChannel();
    let o3;
    o3 = "function" == typeof e4 ? new e4() : "default" in e4 && "function" == typeof e4.default ? new e4.default() : e4;
    const i3 = new _E(t3.port1, { channel: t3, client: o3, schedule: s5 });
    return "object" == typeof o3 && "remoteClient" in o3 && (o3.remoteClient = i3), _E.clients.set(i3, o3), t3.port2;
  }
  static loadWorker(e4) {
    const s5 = r3[e4];
    return s5 ? s5() : Promise.resolve(null);
  }
  constructor(e4, s5, t3, o3) {
    this._port = e4, this._jobQueue = t3, this._lowPriorityJobQueue = o3, this._outJobs = /* @__PURE__ */ new Map(), this._inJobs = /* @__PURE__ */ new Map(), this._invokeQueue = new O((e5) => this._onInvokeMessage(e5)), this._client = s5.client, this._onMessage = this._onMessage.bind(this), this._channel = s5.channel, this._schedule = s5.schedule, this._port.addEventListener("message", this._onMessage), this._port.start();
  }
  close() {
    this._post({ type: M }), this._close();
  }
  isBusy() {
    return this._outJobs.size > 0;
  }
  invoke(e4, s5, t3) {
    return this.apply(e4, [s5], t3);
  }
  apply(e4, t3, o3) {
    const h = o3?.signal, a4 = o3?.transferList;
    if (!this._port) return Promise.reject(new s(r2, `Cannot call invoke('${e4}'), port is closed`, { methodName: e4, data: t3 }));
    const c4 = s4();
    return new Promise((s5, o4) => {
      if (a(h)) return this._processWork(), void o4(u());
      const p = w(h, () => {
        const e5 = this._outJobs.get(c4);
        e5 && (this._outJobs.delete(c4), this._processWork(), l(e5.abortHandle), this._post({ type: k, jobId: c4 }), o4(u()));
      }), _ = { resolve: s5, reject: o4, abortHandle: p, debugInfo: e4 };
      this._outJobs.set(c4, _), this._post({ type: y, jobId: c4, methodName: e4, abortable: null != h }, t3, a4);
    });
  }
  createInvokeProxy(e4) {
    return t2(this, e4);
  }
  on(e4, s5) {
    const t3 = new MessageChannel();
    function i3(e5) {
      s5(e5.data);
    }
    return this._port.postMessage({ type: J, eventType: e4, port: t3.port2 }, [t3.port2]), t3.port1.addEventListener("message", i3), t3.port1.start(), e(() => {
      t3.port1.postMessage({ type: M }), t3.port1.close(), t3.port1.removeEventListener("message", i3);
    });
  }
  jobAdded() {
    this._processWork();
  }
  openPort() {
    const e4 = new MessageChannel();
    return this._post({ type: I, port: e4.port2 }), e4.port1;
  }
  _processWork() {
    if (this._outJobs.size >= w2) return;
    const e4 = this._jobQueue?.pop() ?? this._lowPriorityJobQueue?.pop();
    if (!e4) return;
    const { methodName: s5, data: t3, invokeOptions: o3, resolver: i3 } = e4;
    this.apply(s5, t3, o3).then((e5) => i3.resolve(e5)).catch((e5) => i3.reject(e5));
  }
  _close() {
    this._channel && (this._channel = void 0), this._port.removeEventListener("message", this._onMessage), this._port.close(), this._outJobs.forEach((e4) => {
      l(e4.abortHandle), e4.reject(u(`Worker closing, aborting job calling '${e4.debugInfo}'`));
    }), this._inJobs.clear(), this._outJobs.clear(), this._invokeQueue.clear(), this._port = null, this._client = null, this._schedule = null, this._onMessage = null, this._channel = null, this._jobQueue = void 0, this._invokeQueue = void 0, this._lowPriorityJobQueue = void 0;
  }
  _onMessage(e4) {
    null != this._schedule ? this._schedule(() => this._processMessage(e4, true)) : this._processMessage(e4, false);
  }
  _processMessage(e4, s5) {
    const t3 = f(e4);
    if (t3) switch (t3.type) {
      case j:
        this._onResponseMessage(t3);
        break;
      case y:
        s5 ? this._onInvokeMessage(t3) : this._invokeQueue.push(t3);
        break;
      case k:
        this._onAbortMessage(t3);
        break;
      case M:
        this._onCloseMessage();
        break;
      case I:
        this._onOpenPortMessage(t3);
        break;
      case J:
        this._onOnMessage(t3);
    }
  }
  _onAbortMessage(e4) {
    const s5 = this._inJobs, t3 = e4.jobId, o3 = s5.get(t3);
    this._invokeQueue.push(e4), o3 && (o3.controller && o3.controller.abort(), s5.delete(t3));
  }
  _onCloseMessage() {
    const e4 = this._client;
    this._close(), e4 && "destroy" in e4 && _E.clients.get(this) === e4 && e4.destroy(), _E.clients.delete(this), e4?.remoteClient && (e4.remoteClient = null);
  }
  _onInvokeMessage(e4) {
    const { methodName: s5, jobId: t3, data: o3 = [], abortable: i3 } = e4, n4 = i3 ? new AbortController() : null, r4 = this._inJobs;
    let l3, c4 = this._client, p = c4[s5];
    try {
      if (!p && s5 && s5.includes(".")) {
        const e5 = s5.split(".");
        for (let s6 = 0; s6 < e5.length - 1; s6++) c4 = c4[e5[s6]], p = c4[e5[s6 + 1]];
      }
      if ("function" != typeof p) throw new TypeError(`${s5} is not a function`);
      o3.push({ client: this, signal: n4 ? n4.signal : null }), l3 = p.apply(c4, o3);
    } catch (_) {
      return void this._post({ type: j, jobId: t3, error: o2(_) });
    }
    C(l3) ? (r4.set(t3, { controller: n4, promise: l3 }), l3.then((e5) => {
      r4.has(t3) && (r4.delete(t3), this._post({ type: j, jobId: t3 }, e5));
    }, (e5) => {
      r4.has(t3) && (r4.delete(t3), d(e5) || this._post({ type: j, jobId: t3, error: o2(e5 || { message: `Error encountered at method ${s5}` }) }));
    })) : this._post({ type: j, jobId: t3 }, l3);
  }
  _onOpenPortMessage(e4) {
    new _E(e4.port, { client: this._client });
  }
  _onOnMessage(e4) {
    const { port: s5 } = e4, o3 = this._client.on(e4.eventType, (e5) => {
      s5.postMessage(e5);
    }), i3 = o(e4.port, "message", (e5) => {
      const t3 = f(e5);
      t3?.type === M && (i3.remove(), o3.remove(), s5.close());
    });
  }
  _onResponseMessage(e4) {
    const { jobId: t3, error: o3, data: n4 } = e4, r4 = this._outJobs;
    if (!r4.has(t3)) return;
    const l3 = r4.get(t3);
    r4.delete(t3), this._processWork(), l(l3.abortHandle), o3 ? l3.reject(s.fromJSON(JSON.parse(o3))) : l3.resolve(n4);
  }
  _post(e4, s5, t3) {
    return a3(this._port, e4, s5, t3);
  }
};
_E.kernelInfo = { buildDate: a2, fullVersion: r, revision: c };
_E.clients = /* @__PURE__ */ new Map();
var E = _E;

// node_modules/@arcgis/core/core/workers/connectionRegistry.js
var n3 = new FinalizationRegistry((n4) => {
  n4.close();
});
function e3(e4, i3) {
  n3.register(e4, i3, i3);
}
function i2(e4) {
  n3.unregister(e4);
}

// node_modules/@arcgis/core/core/workers/Connection.js
var c3 = class {
  constructor() {
    this._inUseClients = new Array(), this._clients = new Array(), this._clientPromises = new Array(), this._ongoingJobsQueue = new s3(), this._ongoingLowPriorityJobsQueue = new s3();
  }
  destroy() {
    this.close();
  }
  get closed() {
    return !this._clients?.length;
  }
  open(e4, s5) {
    return new Promise((i3, n4) => {
      let r4 = true;
      const l3 = (e5) => {
        s2(s5.signal), r4 && (r4 = false, e5());
      };
      this._clients.length = e4.length, this._clientPromises.length = e4.length, this._inUseClients.length = e4.length;
      for (let o3 = 0; o3 < e4.length; ++o3) {
        const r5 = e4[o3];
        C(r5) ? this._clientPromises[o3] = r5.then((e5) => (this._clients[o3] = new E(e5, s5, this._ongoingJobsQueue, this._ongoingLowPriorityJobsQueue), l3(i3), this._clients[o3]), () => (l3(n4), null)) : (this._clients[o3] = new E(r5, s5, this._ongoingJobsQueue, this._ongoingLowPriorityJobsQueue), this._clientPromises[o3] = Promise.resolve(this._clients[o3]), l3(i3));
      }
    });
  }
  broadcast(e4, t3, s5) {
    const i3 = new Array(this._clientPromises.length);
    for (let o3 = 0; o3 < this._clientPromises.length; ++o3) {
      const n4 = this._clientPromises[o3];
      i3[o3] = n4.then((i4) => i4?.invoke(e4, t3, s5));
    }
    return i3;
  }
  close() {
    let e4;
    for (; e4 = this._ongoingJobsQueue.pop(); ) e4.resolver.reject(u(`Worker closing, aborting job calling '${e4.methodName}'`));
    for (; e4 = this._ongoingLowPriorityJobsQueue.pop(); ) e4.resolver.reject(u(`Worker closing, aborting job calling '${e4.methodName}'`));
    for (const t3 of this._clientPromises) t3.then((e5) => e5?.close());
    this._clients.length = 0, this._clientPromises.length = 0, this._inUseClients.length = 0, i2(this);
  }
  invoke(e4, t3, s5) {
    return this.apply(e4, [t3], s5);
  }
  apply(e4, t3, s5) {
    const o3 = $();
    ("low" === s5?.priority ? this._ongoingLowPriorityJobsQueue : this._ongoingJobsQueue).push({ methodName: e4, data: t3, invokeOptions: s5, resolver: o3 });
    for (let i3 = 0; i3 < this._clientPromises.length; i3++) {
      const e5 = this._clients[i3];
      e5 ? e5.jobAdded() : this._clientPromises[i3].then((e6) => e6?.jobAdded());
    }
    return o3.promise;
  }
  createInvokeProxy(e4) {
    return t2(this, e4);
  }
  on(t3, s5) {
    return Promise.all(this._clientPromises).then(() => t(this._clients.map((e4) => e4.on(t3, s5))));
  }
  openPorts() {
    return new Promise((e4) => {
      const t3 = new Array(this._clientPromises.length);
      let s5 = t3.length;
      for (let i3 = 0; i3 < this._clientPromises.length; ++i3) {
        this._clientPromises[i3].then((o3) => {
          o3 && (t3[i3] = o3.openPort()), 0 === --s5 && e4(t3);
        });
      }
    });
  }
  get test() {
  }
};

export {
  e3 as e,
  e2,
  s4 as s,
  o2 as o,
  a3 as a,
  f,
  l2 as l,
  E,
  c3 as c
};
//# sourceMappingURL=chunk-2D47RURG.js.map
