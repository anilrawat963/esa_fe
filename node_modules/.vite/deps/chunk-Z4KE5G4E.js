import {
  t2
} from "./chunk-HETHJJO6.js";
import {
  t as t3
} from "./chunk-ECKVUXN3.js";
import {
  o as o2
} from "./chunk-I4DSU5MJ.js";
import {
  o as o3
} from "./chunk-BZBDEPRV.js";
import {
  e
} from "./chunk-66Y6I5GR.js";
import {
  e as e2
} from "./chunk-3PAAA3FK.js";
import {
  r
} from "./chunk-EGPAQBOO.js";
import {
  i
} from "./chunk-AJG2ZYEA.js";
import {
  n as n3,
  t
} from "./chunk-CFXCM2NO.js";
import {
  n as n2
} from "./chunk-ZVTEFYZX.js";
import {
  s
} from "./chunk-LPUPM55U.js";
import {
  o
} from "./chunk-VYMBX5H5.js";
import {
  n
} from "./chunk-75XOUSSS.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientLighting.glsl.js
function m(n6, e6) {
  const m2 = n6.fragment, a4 = void 0 !== e6.lightingSphericalHarmonicsOrder ? e6.lightingSphericalHarmonicsOrder : 2;
  0 === a4 ? (m2.uniforms.add(new e("lightingAmbientSH0", ({ lighting: n7 }) => o(r2, n7.sh.r[0], n7.sh.g[0], n7.sh.b[0]))), m2.code.add(t`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec3 ambientLight = 0.282095 * lightingAmbientSH0;
return ambientLight * (1.0 - ambientOcclusion);
}`)) : 1 === a4 ? (m2.uniforms.add(new e2("lightingAmbientSH_R", ({ lighting: i2 }) => s(l, i2.sh.r[0], i2.sh.r[1], i2.sh.r[2], i2.sh.r[3])), new e2("lightingAmbientSH_G", ({ lighting: i2 }) => s(l, i2.sh.g[0], i2.sh.g[1], i2.sh.g[2], i2.sh.g[3])), new e2("lightingAmbientSH_B", ({ lighting: i2 }) => s(l, i2.sh.b[0], i2.sh.b[1], i2.sh.b[2], i2.sh.b[3]))), m2.code.add(t`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec4 sh0 = vec4(
0.282095,
0.488603 * normal.x,
0.488603 * normal.z,
0.488603 * normal.y
);
vec3 ambientLight = vec3(
dot(lightingAmbientSH_R, sh0),
dot(lightingAmbientSH_G, sh0),
dot(lightingAmbientSH_B, sh0)
);
return ambientLight * (1.0 - ambientOcclusion);
}`)) : 2 === a4 && (m2.uniforms.add(new e("lightingAmbientSH0", ({ lighting: n7 }) => o(r2, n7.sh.r[0], n7.sh.g[0], n7.sh.b[0])), new e2("lightingAmbientSH_R1", ({ lighting: i2 }) => s(l, i2.sh.r[1], i2.sh.r[2], i2.sh.r[3], i2.sh.r[4])), new e2("lightingAmbientSH_G1", ({ lighting: i2 }) => s(l, i2.sh.g[1], i2.sh.g[2], i2.sh.g[3], i2.sh.g[4])), new e2("lightingAmbientSH_B1", ({ lighting: i2 }) => s(l, i2.sh.b[1], i2.sh.b[2], i2.sh.b[3], i2.sh.b[4])), new e2("lightingAmbientSH_R2", ({ lighting: i2 }) => s(l, i2.sh.r[5], i2.sh.r[6], i2.sh.r[7], i2.sh.r[8])), new e2("lightingAmbientSH_G2", ({ lighting: i2 }) => s(l, i2.sh.g[5], i2.sh.g[6], i2.sh.g[7], i2.sh.g[8])), new e2("lightingAmbientSH_B2", ({ lighting: i2 }) => s(l, i2.sh.b[5], i2.sh.b[6], i2.sh.b[7], i2.sh.b[8]))), m2.code.add(t`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec3 ambientLight = 0.282095 * lightingAmbientSH0;
vec4 sh1 = vec4(
0.488603 * normal.x,
0.488603 * normal.z,
0.488603 * normal.y,
1.092548 * normal.x * normal.y
);
vec4 sh2 = vec4(
1.092548 * normal.y * normal.z,
0.315392 * (3.0 * normal.z * normal.z - 1.0),
1.092548 * normal.x * normal.z,
0.546274 * (normal.x * normal.x - normal.y * normal.y)
);
ambientLight += vec3(
dot(lightingAmbientSH_R1, sh1),
dot(lightingAmbientSH_G1, sh1),
dot(lightingAmbientSH_B1, sh1)
);
ambientLight += vec3(
dot(lightingAmbientSH_R2, sh2),
dot(lightingAmbientSH_G2, sh2),
dot(lightingAmbientSH_B2, sh2)
);
return ambientLight * (1.0 - ambientOcclusion);
}`), 1 !== e6.pbrMode && 2 !== e6.pbrMode || m2.code.add(t`const vec3 skyTransmittance = vec3(0.9, 0.9, 1.0);
vec3 calculateAmbientRadiance(float ambientOcclusion)
{
vec3 ambientLight = 1.2 * (0.282095 * lightingAmbientSH0) - 0.2;
return ambientLight *= (1.0 - ambientOcclusion) * skyTransmittance;
}`));
}
var r2 = n();
var l = n2();

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js
function t4(n6) {
  n6.uniforms.add(new e("mainLightDirection", (i2) => i2.lighting.mainLight.direction));
}
function a(n6) {
  n6.uniforms.add(new e("mainLightIntensity", (i2) => i2.lighting.mainLight.intensity));
}
function o4(i2) {
  t4(i2.fragment), a(i2.fragment), i2.fragment.code.add(t`vec3 applyShading(vec3 shadingNormal, float shadow) {
float dotVal = clamp(dot(shadingNormal, mainLightDirection), 0.0, 1.0);
return mainLightIntensity * ((1.0 - shadow) * dotVal);
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/AnalyticalSkyModel.glsl.js
function t5(t6) {
  t6.code.add(t`vec3 evaluateDiffuseIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float NdotNG) {
return ((1.0 - NdotNG) * ambientGround + (1.0 + NdotNG) * ambientSky) * 0.5;
}`), t6.code.add(t`float integratedRadiance(float cosTheta2, float roughness) {
return (cosTheta2 - 1.0) / (cosTheta2 * (1.0 - roughness * roughness) - 1.0);
}`), t6.code.add(t`vec3 evaluateSpecularIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float RdotNG, float roughness) {
float cosTheta2 = 1.0 - RdotNG * RdotNG;
float intRadTheta = integratedRadiance(cosTheta2, roughness);
float ground = RdotNG < 0.0 ? 1.0 - intRadTheta : 1.0 + intRadTheta;
float sky = 2.0 - ground;
return (ground * ambientGround + sky * ambientSky) * 0.5;
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRendering.glsl.js
function n4(n6, a4) {
  n6.include(t3), 1 !== a4.pbrMode && 2 !== a4.pbrMode && 5 !== a4.pbrMode && 6 !== a4.pbrMode || (n6.code.add(t`float normalDistribution(float NdotH, float roughness)
{
float a = NdotH * roughness;
float b = roughness / (1.0 - NdotH * NdotH + a * a);
return b * b * INV_PI;
}`), n6.code.add(t`const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);
const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);
const vec2 c2 = vec2(-1.04, 1.04);
vec2 prefilteredDFGAnalytical(float roughness, float NdotV) {
vec4 r = roughness * c0 + c1;
float a004 = min(r.x * r.x, exp2(-9.28 * NdotV)) * r.x + r.y;
return c2 * a004 + r.zw;
}`)), 1 !== a4.pbrMode && 2 !== a4.pbrMode || (n6.include(t5), n6.code.add(t`struct PBRShadingInfo
{
float NdotV;
float LdotH;
float NdotNG;
float RdotNG;
float NdotAmbDir;
float NdotH_Horizon;
vec3 skyRadianceToSurface;
vec3 groundRadianceToSurface;
vec3 skyIrradianceToSurface;
vec3 groundIrradianceToSurface;
float averageAmbientRadiance;
float ssao;
vec3 albedoLinear;
vec3 f0;
vec3 f90;
vec3 diffuseColor;
float metalness;
float roughness;
};`), n6.code.add(t`vec3 evaluateEnvironmentIllumination(PBRShadingInfo inputs) {
vec3 indirectDiffuse = evaluateDiffuseIlluminationHemisphere(inputs.groundIrradianceToSurface, inputs.skyIrradianceToSurface, inputs.NdotNG);
vec3 indirectSpecular = evaluateSpecularIlluminationHemisphere(inputs.groundRadianceToSurface, inputs.skyRadianceToSurface, inputs.RdotNG, inputs.roughness);
vec3 diffuseComponent = inputs.diffuseColor * indirectDiffuse * INV_PI;
vec2 dfg = prefilteredDFGAnalytical(inputs.roughness, inputs.NdotV);
vec3 specularColor = inputs.f0 * dfg.x + inputs.f90 * dfg.y;
vec3 specularComponent = specularColor * indirectSpecular;
return (diffuseComponent + specularComponent);
}`));
}
function a2(e6, n6) {
  e6.include(t3), e6.code.add(t`
  struct PBRShadingWater {
      float NdotL;   // cos angle between normal and light direction
      float NdotV;   // cos angle between normal and view direction
      float NdotH;   // cos angle between normal and half vector
      float VdotH;   // cos angle between view direction and half vector
      float LdotH;   // cos angle between light direction and half vector
      float VdotN;   // cos angle between view direction and normal vector
  };

  float dtrExponent = ${n6.useCustomDTRExponentForWater ? "2.2" : "2.0"};
  `), e6.code.add(t`vec3 fresnelReflection(float angle, vec3 f0, float f90) {
return f0 + (f90 - f0) * pow(1.0 - angle, 5.0);
}`), e6.code.add(t`float normalDistributionWater(float NdotH, float roughness) {
float r2 = roughness * roughness;
float NdotH2 = NdotH * NdotH;
float denom = pow((NdotH2 * (r2 - 1.0) + 1.0), dtrExponent) * PI;
return r2 / denom;
}`), e6.code.add(t`float geometricOcclusionKelemen(float LoH) {
return 0.25 / (LoH * LoH);
}`), e6.code.add(t`vec3 brdfSpecularWater(in PBRShadingWater props, float roughness, vec3 F0, float F0Max) {
vec3  F = fresnelReflection(props.VdotH, F0, F0Max);
float dSun = normalDistributionWater(props.NdotH, roughness);
float V = geometricOcclusionKelemen(props.LdotH);
float diffusionSunHaze = mix(roughness + 0.045, roughness + 0.385, 1.0 - props.VdotH);
float strengthSunHaze  = 1.2;
float dSunHaze = normalDistributionWater(props.NdotH, diffusionSunHaze) * strengthSunHaze;
return ((dSun + dSunHaze) * V) * F;
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepthToReadShadowMap.glsl.js
function a3(a4, d2) {
  const i2 = o2(d2.output) && d2.receiveShadows;
  i2 && t2(a4, true), a4.vertex.code.add(t`
    void forwardLinearDepthToReadShadowMap() { ${n3(i2, "forwardLinearDepth(gl_Position.w);")} }
  `);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Matrix4sDrawUniform.js
var s2 = class extends i {
  constructor(r3, s4, t6, e6) {
    super(r3, "mat4", 2, (t7, o7, m2, c3) => t7.setUniformMatrices4fv(r3, s4(o7, m2, c3), e6), t6);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Matrix4sPassUniform.js
var s3 = class extends i {
  constructor(r3, s4, t6, e6) {
    super(r3, "mat4", 1, (t7, o7, m2) => t7.setUniformMatrices4fv(r3, s4(o7, m2), e6), t6);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/calculateUVZShadow.glsl.js
function c2(a4) {
  a4.fragment.uniforms.add(new s3("shadowMapMatrix", (a5, e6) => e6.shadowMap.getShadowMapMatrices(a5.origin), 4)), l2(a4);
}
function n5(a4) {
  a4.fragment.uniforms.add(new s2("shadowMapMatrix", (a5, e6) => e6.shadowMap.getShadowMapMatrices(a5.origin), 4)), l2(a4);
}
function l2(a4) {
  const { fragment: i2 } = a4;
  i2.uniforms.add(new e2("cascadeDistances", (a5) => a5.shadowMap.cascadeDistances), new o3("numCascades", (a5) => a5.shadowMap.numCascades)), i2.code.add(t`const vec3 invalidShadowmapUVZ = vec3(0.0, 0.0, -1.0);
vec3 lightSpacePosition(vec3 _vpos, mat4 mat) {
vec4 lv = mat * vec4(_vpos, 1.0);
lv.xy /= lv.w;
return 0.5 * lv.xyz + vec3(0.5);
}
vec2 cascadeCoordinates(int i, ivec2 textureSize, vec3 lvpos) {
float xScale = float(textureSize.y) / float(textureSize.x);
return vec2((float(i) + lvpos.x) * xScale, lvpos.y);
}
vec3 calculateUVZShadow(in vec3 _worldPos, in float _linearDepth, in ivec2 shadowMapSize) {
int i = _linearDepth < cascadeDistances[1] ? 0 : _linearDepth < cascadeDistances[2] ? 1 : _linearDepth < cascadeDistances[3] ? 2 : 3;
if (i >= numCascades) {
return invalidShadowmapUVZ;
}
mat4 shadowMatrix = i == 0 ? shadowMapMatrix[0] : i == 1 ? shadowMapMatrix[1] : i == 2 ? shadowMapMatrix[2] : shadowMapMatrix[3];
vec3 lvpos = lightSpacePosition(_worldPos, shadowMatrix);
if (lvpos.z >= 1.0 || lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) {
return invalidShadowmapUVZ;
}
vec2 uvShadow = cascadeCoordinates(i, shadowMapSize, lvpos);
return vec3(uvShadow, lvpos.z);
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ShadowmapFiltering.glsl.js
function e3(a4) {
  a4.fragment.code.add(t`float readShadowMapUVZ(vec3 uvzShadow, sampler2DShadow _shadowMap) {
return texture(_shadowMap, uvzShadow);
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Texture2DShadowBindUniform.js
var e4 = class extends i {
  constructor(r3, e6) {
    super(r3, "sampler2DShadow", 0, (o7, s4) => o7.bindTexture(r3, e6(s4)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js
function p(a4, o7) {
  o7.receiveShadows && a4.include(c2), u(a4, o7);
}
function f(a4, o7) {
  o7.receiveShadows && a4.include(n5), u(a4, o7);
}
function u(a4, e6) {
  a4.fragment.uniforms.add(new r("lightingGlobalFactor", (a5) => a5.lighting.globalFactor));
  const { receiveShadows: r3, spherical: t6 } = e6;
  a4.include(a3, e6), r3 && w(a4), a4.fragment.code.add(t`
    float readShadow(float additionalAmbientScale, vec3 vpos) {
      return ${r3 ? "max(lightingGlobalFactor * (1.0 - additionalAmbientScale), readShadowMap(vpos, linearDepth))" : n3(t6, "lightingGlobalFactor * (1.0 - additionalAmbientScale)", "0.0")};
    }
  `);
}
function w(a4) {
  a4.include(e3), a4.fragment.uniforms.add(new e4("shadowMap", ({ shadowMap: a5 }) => a5.depthTexture)).code.add(t`float readShadowMap(const in vec3 _worldPos, float _linearDepth) {
vec3 uvzShadow = calculateUVZShadow(_worldPos, _linearDepth, textureSize(shadowMap,0));
if (uvzShadow.z < 0.0) {
return 0.0;
}
return readShadowMapUVZ(uvzShadow, shadowMap);
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ScreenSpaceConstants.js
var e5 = 3e5;
var o5 = 5e5;

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/ToneMapping.glsl.js
function o6(o7) {
  o7.code.add(t`vec3 tonemapACES(vec3 x) {
return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);
}`);
}

export {
  e5 as e,
  o5 as o,
  m,
  t4 as t,
  a,
  o4 as o2,
  n4 as n,
  a2,
  o6 as o3,
  p,
  f
};
//# sourceMappingURL=chunk-Z4KE5G4E.js.map
