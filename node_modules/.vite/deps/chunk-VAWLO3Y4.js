import {
  o as o2
} from "./chunk-QCJFPBRP.js";
import {
  n as n3,
  p
} from "./chunk-RRK2YVM5.js";
import {
  n as n2
} from "./chunk-INJCHY4H.js";
import {
  e as e2
} from "./chunk-G7FTSXBC.js";
import {
  i as i2,
  u as u4
} from "./chunk-2U5X5TIX.js";
import {
  P
} from "./chunk-6VL5D5UP.js";
import {
  f as f3,
  s as s3,
  u
} from "./chunk-PLNHHGHL.js";
import {
  _
} from "./chunk-C3FRY5U4.js";
import {
  l as l2,
  m as m3
} from "./chunk-PMGS7UDU.js";
import {
  e2 as e3,
  w
} from "./chunk-MC6NAKKX.js";
import {
  l
} from "./chunk-TF6255HN.js";
import {
  f as f2,
  v
} from "./chunk-GD4FJL3C.js";
import {
  i
} from "./chunk-C5OQVQZF.js";
import {
  u as u3
} from "./chunk-F7DKSAOI.js";
import {
  m as m4
} from "./chunk-MHV23XAQ.js";
import {
  O
} from "./chunk-YDTPM7OQ.js";
import {
  z
} from "./chunk-H74Q4SYB.js";
import {
  a as a2
} from "./chunk-2OFHDVO5.js";
import {
  u as u2
} from "./chunk-CCQFL76O.js";
import {
  f
} from "./chunk-5T3MJDSR.js";
import {
  A,
  ae
} from "./chunk-NMQNUPE4.js";
import {
  H2 as H
} from "./chunk-V2H77UEV.js";
import {
  o
} from "./chunk-XWE6BM2U.js";
import {
  r
} from "./chunk-SOIZOFSB.js";
import {
  n
} from "./chunk-XXLHAM2M.js";
import {
  b,
  m as m2
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a,
  m
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  e
} from "./chunk-4DGC7CBY.js";
import {
  L,
  s as s2,
  y
} from "./chunk-GNMPGHLQ.js";
import {
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  N,
  has
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/views/layers/support/highlightUtils.js
function i3(i4) {
  if (!i4) return [];
  let e4 = i(i4) ? [i4] : O.isCollection(i4) ? i4.toArray() : Array.isArray(i4) ? i4 : [];
  return e4 = e4?.filter(N), 0 === (e4?.length ?? 0) ? [] : e4;
}

// node_modules/@arcgis/core/rest/operations/identify.js
function o3(e4, r2) {
  const { dpi: n4, gdbVersion: s4, geometry: o4, geometryPrecision: a5, height: m7, historicMoment: p3, layerOption: f5, mapExtent: y2, maxAllowableOffset: u7, returnFieldName: c2, returnGeometry: d2, returnUnformattedValues: g, returnZ: x, spatialReference: h, timeExtent: b2, tolerance: E, width: O2 } = e4.toJSON(), { dynamicLayers: S2, layerDefs: j, layerIds: N2 } = l3(e4), $ = null != r2?.geometry ? r2.geometry : null, I = { historicMoment: p3, geometryPrecision: a5, maxAllowableOffset: u7, returnFieldName: c2, returnGeometry: d2, returnUnformattedValues: g, returnZ: x, tolerance: E }, R2 = $?.toJSON() || o4;
  I.imageDisplay = `${O2},${m7},${n4}`, s4 && (I.gdbVersion = s4), R2 && (delete R2.spatialReference, I.geometry = JSON.stringify(R2), I.geometryType = v(R2));
  const U2 = h ?? R2?.spatialReference ?? y2?.spatialReference;
  if (U2 && (I.sr = A(U2)), I.time = b2 ? [b2.start, b2.end].join(",") : null, y2) {
    const { xmin: e5, ymin: t, xmax: r3, ymax: i4 } = y2;
    I.mapExtent = `${e5},${t},${r3},${i4}`;
  }
  return j && (I.layerDefs = j), S2 && !j && (I.dynamicLayers = S2), I.layers = "popup" === f5 ? "visible" : f5, N2 && !S2 && (I.layers += `:${N2.join(",")}`), I;
}
function l3(e4) {
  const { mapExtent: t, floors: i4, width: o4, sublayers: l4, layerIds: m7, layerOption: p3, gdbVersion: f5 } = e4, y2 = l4?.find((e5) => null != e5.layer)?.layer?.serviceSublayers, u7 = "popup" === p3, c2 = {}, d2 = i2({ extent: t, width: o4, spatialReference: t?.spatialReference }), g = [], x = (e5) => {
    const t2 = 0 === d2, r2 = 0 === e5.minScale || d2 <= e5.minScale, i5 = 0 === e5.maxScale || d2 >= e5.maxScale;
    if (e5.visible && (t2 || r2 && i5)) if (e5.sublayers) e5.sublayers.forEach(x);
    else {
      if (false === m7?.includes(e5.id) || u7 && (!e5.popupTemplate || !e5.popupEnabled)) return;
      g.unshift(e5);
    }
  };
  if (l4?.forEach(x), l4 && !g.length) c2.layerIds = [];
  else {
    const e5 = e2(g, y2, f5), t2 = g.map((e6) => {
      const t3 = n2(i4, e6);
      return e6.toExportImageJSON(t3);
    });
    if (e5) c2.dynamicLayers = JSON.stringify(t2);
    else {
      if (l4) {
        let e7 = g.map(({ id: e8 }) => e8);
        m7 && (e7 = e7.filter((e8) => m7.includes(e8))), c2.layerIds = e7;
      } else m7?.length && (c2.layerIds = m7);
      const e6 = a3(i4, g);
      if (null != e6 && e6.length) {
        const t3 = {};
        for (const r2 of e6) r2.definitionExpression && (t3[r2.id] = r2.definitionExpression);
        Object.keys(t3).length && (c2.layerDefs = JSON.stringify(t3));
      }
    }
  }
  return c2;
}
function a3(t, r2) {
  const i4 = !!t?.length, s4 = r2.filter((e4) => null != e4.definitionExpression || i4 && null != e4.floorInfo);
  return s4.length ? s4.map((r3) => {
    const i5 = n2(t, r3), s5 = l(i5, r3.definitionExpression);
    return { id: r3.id, definitionExpression: s5 ?? void 0 };
  }) : null;
}

// node_modules/@arcgis/core/rest/support/IdentifyParameters.js
var u5;
var d = u5 = class extends n {
  static from(t) {
    return m(u5, t);
  }
  constructor(t) {
    super(t), this.dpi = 96, this.floors = null, this.gdbVersion = null, this.geometry = null, this.geometryPrecision = null, this.height = 400, this.historicMoment = null, this.layerIds = null, this.layerOption = "top", this.mapExtent = null, this.maxAllowableOffset = null, this.returnFieldName = true, this.returnGeometry = false, this.returnM = false, this.returnUnformattedValues = true, this.returnZ = false, this.spatialReference = null, this.sublayers = null, this.timeExtent = null, this.tolerance = null, this.width = 400;
  }
  writeHistoricMoment(t, e4) {
    e4.historicMoment = t && t.getTime();
  }
};
__decorate([m2({ type: Number, json: { write: true } })], d.prototype, "dpi", void 0), __decorate([m2()], d.prototype, "floors", void 0), __decorate([m2({ type: String, json: { write: true } })], d.prototype, "gdbVersion", void 0), __decorate([m2({ types: l2, json: { read: f2, write: true } })], d.prototype, "geometry", void 0), __decorate([m2({ type: Number, json: { write: true } })], d.prototype, "geometryPrecision", void 0), __decorate([m2({ type: Number, json: { write: true } })], d.prototype, "height", void 0), __decorate([m2({ type: Date })], d.prototype, "historicMoment", void 0), __decorate([r("historicMoment")], d.prototype, "writeHistoricMoment", null), __decorate([m2({ type: [Number], json: { write: true } })], d.prototype, "layerIds", void 0), __decorate([m2({ type: ["top", "visible", "all", "popup"], json: { write: true } })], d.prototype, "layerOption", void 0), __decorate([m2({ type: z, json: { write: true } })], d.prototype, "mapExtent", void 0), __decorate([m2({ type: Number, json: { write: true } })], d.prototype, "maxAllowableOffset", void 0), __decorate([m2({ type: Boolean, json: { write: true } })], d.prototype, "returnFieldName", void 0), __decorate([m2({ type: Boolean, json: { write: true } })], d.prototype, "returnGeometry", void 0), __decorate([m2({ type: Boolean, json: { write: true } })], d.prototype, "returnM", void 0), __decorate([m2({ type: Boolean, json: { write: true } })], d.prototype, "returnUnformattedValues", void 0), __decorate([m2({ type: Boolean, json: { write: true } })], d.prototype, "returnZ", void 0), __decorate([m2({ type: f, json: { write: true } })], d.prototype, "spatialReference", void 0), __decorate([m2({ type: O })], d.prototype, "sublayers", void 0), __decorate([m2({ type: m4, json: { write: true } })], d.prototype, "timeExtent", void 0), __decorate([m2({ type: Number, json: { write: true } })], d.prototype, "tolerance", void 0), __decorate([m2({ type: Number, json: { write: true } })], d.prototype, "width", void 0), d = u5 = __decorate([a("esri.rest.support.IdentifyParameters")], d);
var c = d;

// node_modules/@arcgis/core/rest/support/IdentifyResult.js
var u6 = class extends n {
  constructor(r2) {
    super(r2), this.displayFieldName = null, this.feature = null, this.layerId = null, this.layerName = null;
  }
  readFeature(r2, e4) {
    return _.fromJSON({ attributes: { ...e4.attributes }, geometry: { ...e4.geometry } });
  }
  writeFeature(r2, t) {
    if (!r2) return;
    const { attributes: e4, geometry: o4 } = r2;
    e4 && (t.attributes = { ...e4 }), null != o4 && (t.geometry = o4.toJSON(), t.geometryType = m3.toJSON(o4.type));
  }
};
__decorate([m2({ type: String, json: { write: true } })], u6.prototype, "displayFieldName", void 0), __decorate([m2({ type: _ })], u6.prototype, "feature", void 0), __decorate([o("feature", ["attributes", "geometry"])], u6.prototype, "readFeature", null), __decorate([r("feature")], u6.prototype, "writeFeature", null), __decorate([m2({ type: Number, json: { write: true } })], u6.prototype, "layerId", void 0), __decorate([m2({ type: String, json: { write: true } })], u6.prototype, "layerName", void 0), u6 = __decorate([a("esri.rest.support.IdentifyResult")], u6);
var m5 = u6;

// node_modules/@arcgis/core/rest/identify.js
async function f4(u7, i4, f5) {
  const c2 = (i4 = a4(i4)).geometry ? [i4.geometry] : [], l4 = f3(u7);
  return l4.path += "/identify", P(c2).then((e4) => {
    const t = o3(i4, { geometry: e4?.[0] }), u8 = u({ ...l4.query, f: "json", ...t }), a5 = s3(u8, f5);
    return H(l4.path, a5).then(m6).then((r2) => p2(r2, i4.sublayers));
  });
}
function m6(r2) {
  const e4 = r2.data;
  return e4.results = e4.results || [], e4.exceededTransferLimit = Boolean(e4.exceededTransferLimit), e4.results = e4.results.map((r3) => m5.fromJSON(r3)), e4;
}
function a4(r2) {
  return r2 = c.from(r2);
}
function p2(r2, e4) {
  if (!e4?.length) return r2;
  const t = /* @__PURE__ */ new Map();
  function o4(r3) {
    t.set(r3.id, r3), r3.sublayers && r3.sublayers.forEach(o4);
  }
  e4.forEach(o4);
  for (const s4 of r2.results) s4.feature.sourceLayer = t.get(s4.layerId);
  return r2;
}

// node_modules/@arcgis/core/views/layers/support/MapServiceLayerViewHelper.js
var G = null;
function S(e4, t) {
  return "tile" === t.type || "map-image" === t.type;
}
var P2 = class extends b {
  constructor(e4) {
    super(e4), this._featuresResolutions = /* @__PURE__ */ new WeakMap(), this.highlightGraphics = null, this.highlightGraphicUpdated = null, this.updateHighlightedFeatures = L(async (e5) => {
      this.destroyed || await this.updatingHandles.addPromise(this._updateHighlightedFeaturesGeometries(e5).catch(() => {
      }));
    });
  }
  initialize() {
    const e4 = (e5) => {
      for (const t of e5) {
        const { sourceLayer: e6 } = t;
        null != e6 && "geometryType" in e6 && "point" === e6.geometryType && t.visible && (t.visible = false, this.highlightGraphicUpdated?.({ graphic: t, property: "visible", oldValue: true, newValue: false }));
      }
      this.updatingHandles.addPromise(this._updateHighlightedFeaturesSymbols(e5).catch(() => {
      })), y(this.updateHighlightedFeatures(this._highlightGeometriesResolution));
    };
    this.addHandles([a2(() => this.highlightGraphics, "change", (t) => e4(t.added), { onListenerAdd: (t) => e4(t) })]);
  }
  async fetchPopupFeaturesAtLocation(e4, t) {
    const { layerView: { layer: r2, view: { scale: i4 } } } = this;
    if (!e4) throw new s("fetchPopupFeatures:invalid-area", "Nothing to fetch without area", { layer: r2 });
    const o4 = U(r2.sublayers, i4, t);
    if (!o4.length) return [];
    const a5 = await R(r2, o4);
    if (!((r2.capabilities?.operations?.supportsIdentify ?? true) && r2.version >= 10.5) && !a5) throw new s("fetchPopupFeatures:not-supported", "query operation is disabled for this service", { layer: r2 });
    return a5 ? this._fetchPopupFeaturesUsingQueries(e4, o4, t) : this._fetchPopupFeaturesUsingIdentify(e4, o4, t);
  }
  clearHighlights() {
    this.highlightGraphics?.removeAll();
  }
  async _updateHighlightedFeaturesSymbols(e4) {
    for (const t of e4) this._updateSymbology(t);
  }
  _updateSymbology(e4) {
    if ("point" === e4.geometry?.type) return this._updatePointSymbology(e4);
  }
  _setGraphicSymbol(e4, t) {
    if (!t) return;
    const r2 = e4.symbol;
    e4.symbol = t, this.highlightGraphicUpdated?.({ graphic: e4, property: "symbol", oldValue: r2, newValue: t });
  }
  _updatePointSymbology(e4) {
    const r2 = e4.sourceLayer && "renderer" in e4.sourceLayer && e4.sourceLayer.renderer, { highlightGraphicUpdated: i4, highlightGraphics: s4, layerView: { view: o4 } } = this, a5 = (e5) => {
      e5.visible || (e5.visible = true, i4?.({ graphic: e5, property: "visible", oldValue: false, newValue: true }));
    };
    r2 && "getSymbolAsync" in r2 ? r2.getSymbolAsync(e4).then(async (i5) => {
      i5 ||= new u3();
      let l4 = null;
      const n4 = "visualVariables" in r2 ? r2.visualVariables?.find((e5) => "size" === e5.type) : void 0;
      n4 && (G || (G = (await import("./visualVariableUtils-EKNNTOCH.js")).getSize), l4 = G(n4, e4, { view: o4.type, scale: o4.scale, shape: "simple-marker" === i5.type ? i5.style : null })), l4 ||= "width" in i5 && "height" in i5 && null != i5.width && null != i5.height ? Math.max(i5.width, i5.height) : "size" in i5 ? i5.size : 16, s4?.includes(e4) && (this._setGraphicSymbol(e4, new u3({ style: "square", size: l4, color: new u2([255, 255, 255, 1 / 255]), xoffset: "xoffset" in i5 ? i5.xoffset : 0, yoffset: "yoffset" in i5 ? i5.yoffset : 0 })), a5(e4));
    }) : a5(e4);
  }
  get _updateContext() {
    const { layerView: { layer: e4 }, highlightGraphics: t, highlightGraphicUpdated: r2 } = this;
    return r2 && t?.length && e4.capabilities.operations.supportsQuery ? { highlightGraphicUpdated: r2, highlightGraphics: t } : null;
  }
  get highlightFeaturesActive() {
    return !!this._updateContext;
  }
  async _updateHighlightedFeaturesGeometries(e4) {
    this._highlightGeometriesResolution = e4;
    const t = this._updateContext;
    if (!t) return;
    const r2 = this._getTargetResolution(e4), i4 = /* @__PURE__ */ new Map(), { highlightGraphics: s4, highlightGraphicUpdated: a5 } = t;
    for (const c2 of s4) if (!this._featuresResolutions.has(c2) || this._featuresResolutions.get(c2) > r2) {
      const e5 = c2.sourceLayer;
      e(i4, e5, () => /* @__PURE__ */ new Map()).set(c2.getObjectId(), c2);
    }
    const { layerView: { view: l4 } } = this, n4 = Array.from(i4, ([e5, t2]) => {
      const i5 = e5.createQuery();
      return i5.objectIds = [...t2.keys()], i5.outFields = [e5.objectIdField], i5.returnGeometry = true, i5.maxAllowableOffset = r2, i5.outSpatialReference = l4.spatialReference, e5.queryFeatures(i5);
    }), p3 = await Promise.all(n4);
    if (!this.destroyed) for (const { features: o4 } of p3) for (const e5 of o4) {
      const t2 = e5.sourceLayer, o5 = i4.get(t2).get(e5.getObjectId());
      if (o5 && s4.includes(o5)) {
        const t3 = o5.geometry;
        o5.geometry = e5.geometry, a5({ graphic: o5, property: "geometry", oldValue: t3, newValue: o5.geometry }), this._featuresResolutions.set(o5, r2);
      }
    }
  }
  _getTargetResolution(e4) {
    const t = e4 * ae(this.layerView.view.spatialReference), r2 = t / 16;
    return r2 <= 10 ? 0 : e4 / t * r2;
  }
  async _fetchPopupFeaturesUsingIdentify(e4, t, r2) {
    const i4 = await this._createIdentifyParameters(e4, t, r2);
    if (null == i4) return [];
    const { results: s4 } = await f4(this.layerView.layer.parsedUrl, i4, r2);
    return s4.map((e5) => e5.feature);
  }
  async _createIdentifyParameters(e4, t, r2) {
    const { floors: i4, layer: s4, timeExtent: o4, view: { spatialReference: a5, scale: l4 } } = this.layerView;
    if (!t.length) return null;
    await Promise.all(t.map(({ sublayer: e5 }) => e5.load(r2).catch(() => {
    })));
    const n4 = Math.min(has("mapservice-popup-identify-max-tolerance"), s4.allSublayers.reduce((e5, t2) => t2.renderer ? o2({ renderer: t2.renderer, pointerType: r2?.pointerType }) : e5, 2)), p3 = this.createFetchPopupFeaturesQueryGeometry(e4, n4), c2 = u4(l4, a5), u7 = Math.round(p3.width / c2), h = new z({ xmin: p3.center.x - c2 * u7, ymin: p3.center.y - c2 * u7, xmax: p3.center.x + c2 * u7, ymax: p3.center.y + c2 * u7, spatialReference: p3.spatialReference });
    return new c({ floors: i4, gdbVersion: "gdbVersion" in s4 ? s4.gdbVersion : void 0, geometry: e4, height: u7, layerOption: "popup", mapExtent: h, returnGeometry: true, spatialReference: a5, sublayers: s4.sublayers, timeExtent: o4, tolerance: n4, width: u7 });
  }
  async _fetchPopupFeaturesUsingQueries(e4, t, r2) {
    const { layerView: { floors: s4, timeExtent: o4 } } = this, a5 = t.map(async ({ sublayer: t2, popupTemplate: i4 }) => {
      if (await t2.load(r2).catch(() => {
      }), t2.capabilities && !t2.capabilities.operations.supportsQuery) return [];
      const a6 = t2.createQuery(), n4 = o2({ renderer: t2.renderer, pointerType: r2?.pointerType }), p3 = this.createFetchPopupFeaturesQueryGeometry(e4, n4), u7 = /* @__PURE__ */ new Set(), [h] = await Promise.all([p(t2, i4), t2.renderer?.collectRequiredFields(u7, t2.fieldsIndex)]);
      s2(r2), w(u7, t2.fieldsIndex, h);
      const y2 = Array.from(u7).sort();
      a6.geometry = p3, a6.outFields = y2, a6.timeExtent = o4;
      const d2 = n2(s4, t2);
      if (a6.where = l(a6.where, d2), t2.capabilities?.query.supportsOrderBy && t2.orderBy?.[0]) {
        const e5 = t2.orderBy[0], r3 = !e5.valueExpression && e5.field, i5 = "ascending" === e5.order ? "asc" : "desc";
        r3 && (a6.orderByFields = [`${r3} ${i5}`]);
      }
      const m7 = this._getTargetResolution(p3.width / n4), w2 = await V(i4);
      s2(r2);
      const v2 = "point" === t2.geometryType || w2 && w2.arcadeUtils.hasGeometryOperations(i4);
      v2 || (a6.maxAllowableOffset = m7);
      let { features: x } = await t2.queryFeatures(a6, r2);
      const _2 = v2 ? 0 : m7;
      x = await A2(t2, x, r2);
      for (const e5 of x) this._featuresResolutions.set(e5, _2);
      return x;
    });
    return (await Promise.allSettled(a5)).reduce((e5, t2) => "fulfilled" === t2.status ? [...e5, ...t2.value] : e5, []).filter(N);
  }
};
function U(e4, t, r2) {
  const i4 = [];
  if (!e4) return i4;
  const s4 = (e5) => {
    const o4 = 0 === e5.minScale || t <= e5.minScale, a5 = 0 === e5.maxScale || t >= e5.maxScale;
    if (e5.visible && o4 && a5) {
      if (e5.sublayers) e5.sublayers.forEach(s4);
      else if (e5.popupEnabled) {
        const t2 = n3(e5, { ...r2, defaultPopupTemplateEnabled: false });
        null != t2 && i4.unshift({ sublayer: e5, popupTemplate: t2 });
      }
    }
  };
  return e4.map(s4), i4;
}
function V(e4) {
  return e4.expressionInfos?.length || Array.isArray(e4.content) && e4.content.some((e5) => "expression" === e5.type) ? e3() : Promise.resolve();
}
async function R(e4, t) {
  if (e4.capabilities?.operations?.supportsQuery) return true;
  try {
    return await Promise.any(t.map(({ sublayer: e5 }) => e5.load().then(() => e5.capabilities.operations.supportsQuery)));
  } catch {
    return false;
  }
}
async function A2(e4, t, r2) {
  const i4 = e4.renderer;
  return i4 && "defaultSymbol" in i4 && !i4.defaultSymbol && (t = i4.valueExpression ? await Promise.all(t.map((e5) => i4.getSymbolAsync(e5, r2).then((t2) => t2 ? e5 : null))).then((e5) => e5.filter((e6) => null != e6)) : t.filter((e5) => null != i4.getSymbol(e5))), t;
}
__decorate([m2({ constructOnly: true })], P2.prototype, "createFetchPopupFeaturesQueryGeometry", void 0), __decorate([m2({ constructOnly: true })], P2.prototype, "layerView", void 0), __decorate([m2({ constructOnly: true })], P2.prototype, "highlightGraphics", void 0), __decorate([m2({ constructOnly: true })], P2.prototype, "highlightGraphicUpdated", void 0), __decorate([m2({ constructOnly: true })], P2.prototype, "updatingHandles", void 0), __decorate([m2()], P2.prototype, "_updateContext", null), P2 = __decorate([a("esri.views.layers.support.MapServiceLayerViewHelper")], P2);

export {
  i3 as i,
  S,
  P2 as P
};
//# sourceMappingURL=chunk-VAWLO3Y4.js.map
