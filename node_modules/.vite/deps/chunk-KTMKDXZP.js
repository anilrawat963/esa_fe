import {
  e2 as e3,
  r,
  r2
} from "./chunk-F43BIMML.js";
import {
  t as t2
} from "./chunk-BZBDEPRV.js";
import {
  e as e2
} from "./chunk-COMSADUT.js";
import {
  e
} from "./chunk-IT62DCG6.js";
import {
  t
} from "./chunk-CFXCM2NO.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/MaskedColor.glsl.js
function r3(r4) {
  r4.code.add(t`struct MaskedColor {
vec4 color;
bvec4 mask;
};`);
}
function e4(e5) {
  e5.include(r3), e5.code.add(t`
    MaskedColor createMaskedFromUInt8NaNColor(vec4 color) {
      return MaskedColor(color * ${t.float(1 / 254)}, equal(color, vec4(255)));
    }
  `);
}
function c(e5) {
  e5.include(r3), e5.code.add(t`vec4 maskedColorSelectOrOne(MaskedColor color) {
return vec4(
color.mask.r ? 1.0 : color.color.r,
color.mask.g ? 1.0 : color.color.g,
color.mask.b ? 1.0 : color.color.b,
color.mask.a ? 1.0 : color.color.a
);
}
MaskedColor multiplyMaskedColors(MaskedColor color1, MaskedColor color2) {
vec4 masked1 = maskedColorSelectOrOne(color1);
vec4 masked2 = maskedColorSelectOrOne(color2);
return MaskedColor(masked1 * masked2, bvec4(ivec4(color1.mask) & ivec4(color2.mask)));
}`);
}
function l(e5) {
  e5.include(r3), e5.code.add(t`MaskedColor createMaskedFromNaNColor(vec4 color) {
return MaskedColor(color, isnan(color));
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/VisualVariables.glsl.js
function u(u2, c2) {
  const { vertex: m, attributes: d } = u2;
  c2.hasVVInstancing && (c2.hasVVSize || c2.hasVVColor) && d.add("instanceFeatureAttribute", "vec4"), c2.hasVVSize ? (m.uniforms.add(new e("vvSizeMinSize", (o) => o.vvSize.minSize)), m.uniforms.add(new e("vvSizeMaxSize", (o) => o.vvSize.maxSize)), m.uniforms.add(new e("vvSizeOffset", (o) => o.vvSize.offset)), m.uniforms.add(new e("vvSizeFactor", (o) => o.vvSize.factor)), m.uniforms.add(new e("vvSizeFallback", (o) => o.vvSize.fallback)), m.uniforms.add(new t2("vvSymbolRotationMatrix", (o) => o.vvSymbolRotationMatrix)), m.uniforms.add(new e("vvSymbolAnchor", (o) => o.vvSymbolAnchor)), m.code.add(t`vec3 vvScale(vec4 _featureAttribute) {
if (isnan(_featureAttribute.x)) {
return vvSizeFallback;
}
return clamp(vvSizeOffset + _featureAttribute.x * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize);
}
vec4 vvTransformPosition(vec3 position, vec4 _featureAttribute) {
return vec4(vvSymbolRotationMatrix * ( vvScale(_featureAttribute) * (position + vvSymbolAnchor)), 1.0);
}`), m.code.add(t`
      const float eps = 1.192092896e-07;
      vec4 vvTransformNormal(vec3 _normal, vec4 _featureAttribute) {
        vec3 scale = max(vvScale(_featureAttribute), eps);
        return vec4(vvSymbolRotationMatrix * _normal / scale, 1.0);
      }

      ${c2.hasVVInstancing ? t`
      vec4 vvLocalNormal(vec3 _normal) {
        return vvTransformNormal(_normal, instanceFeatureAttribute);
      }

      vec4 localPosition() {
        return vvTransformPosition(position, instanceFeatureAttribute);
      }` : ""}
    `)) : m.code.add(t`vec4 localPosition() { return vec4(position, 1.0); }
vec4 vvLocalNormal(vec3 _normal) { return vec4(_normal, 1.0); }`), u2.vertex.include(r3), c2.hasVVColor ? (m.constants.add("vvColorNumber", "int", r2), m.uniforms.add(new r("vvColorValues", (o) => o.vvColor.values, r2), new e3("vvColorColors", (o) => o.vvColor.colors, r2), new e2("vvColorFallback", (o) => o.vvColor.fallback, { supportsNaN: true })), c2.hasVVInstancing && (u2.vertex.include(c), u2.vertex.include(l)), m.code.add(t`
      vec4 interpolateVVColor(float value) {
        if (isnan(value)) {
          return vvColorFallback;
        }

        if (value <= vvColorValues[0]) {
          return vvColorColors[0];
        }

        for (int i = 1; i < vvColorNumber; ++i) {
          if (vvColorValues[i] >= value) {
            float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);
            return mix(vvColorColors[i-1], vvColorColors[i], f);
          }
        }
        return vvColorColors[vvColorNumber - 1];
      }

      vec4 vvGetColor(vec4 featureAttribute) {
        return interpolateVVColor(featureAttribute.y);
      }

      ${c2.hasVVInstancing ? t`
            vec4 vvColor() {
              return vvGetColor(instanceFeatureAttribute);
            }

            MaskedColor applyVVColor(MaskedColor color) {
              return multiplyMaskedColors(color, createMaskedFromNaNColor(vvColor()));
            }
            ` : t`
            vec4 vvColor() {
              return vec4(1.0);
            }

            MaskedColor applyVVColor(MaskedColor color) {
              return color;
            }
            `}
    `)) : m.code.add(t`vec4 vvColor() {
return vec4(1.0);
}
MaskedColor applyVVColor(MaskedColor color) {
return color;
}`);
}

export {
  r3 as r,
  e4 as e,
  c,
  l,
  u
};
//# sourceMappingURL=chunk-KTMKDXZP.js.map
