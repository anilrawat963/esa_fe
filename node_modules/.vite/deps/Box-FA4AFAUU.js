import {
  h as h3
} from "./chunk-IZEXWD52.js";
import {
  j,
  l as l4
} from "./chunk-CMAY55HR.js";
import {
  t as t2
} from "./chunk-F5JN6VXH.js";
import {
  e,
  s,
  s2
} from "./chunk-6DHLEI74.js";
import {
  i as i4
} from "./chunk-L7AHSCRH.js";
import {
  M,
  U,
  b,
  x
} from "./chunk-H4PQ35LQ.js";
import {
  R,
  c,
  i as i3,
  n as n2
} from "./chunk-MLUR3X6U.js";
import "./chunk-I7PJIK77.js";
import {
  l as l3
} from "./chunk-Y2GQGUGW.js";
import "./chunk-SUOIQXQ3.js";
import "./chunk-VHCNEAMV.js";
import "./chunk-NTNXXNRP.js";
import "./chunk-QCJFPBRP.js";
import "./chunk-V4S4W4OB.js";
import {
  d
} from "./chunk-IGRCAVBL.js";
import "./chunk-VIDAPS4J.js";
import "./chunk-GD72EK2J.js";
import "./chunk-B3BLJNSM.js";
import "./chunk-ALKEERWI.js";
import "./chunk-EOQ2S5UA.js";
import "./chunk-WBXDB33U.js";
import "./chunk-GVMCGYZ6.js";
import "./chunk-JHV6OBEB.js";
import "./chunk-VNSHGTPN.js";
import "./chunk-WHHIH5YU.js";
import "./chunk-BZLHV37L.js";
import "./chunk-V6V3WWJF.js";
import "./chunk-EK7HOTRR.js";
import "./chunk-LPUPM55U.js";
import "./chunk-E7PJOFGP.js";
import "./chunk-4VQDBNTM.js";
import "./chunk-3BNOOWTA.js";
import "./chunk-AIJLLSRB.js";
import "./chunk-T3SYSTKO.js";
import "./chunk-HOJHSMLY.js";
import "./chunk-WDTGOP77.js";
import "./chunk-VYMBX5H5.js";
import "./chunk-BPTFV5VM.js";
import "./chunk-5ONGWFJ3.js";
import "./chunk-BBYMM7CM.js";
import "./chunk-EM7Y2JZC.js";
import "./chunk-MUBG7EZN.js";
import "./chunk-TMVLBQMP.js";
import "./chunk-6IHS6RYH.js";
import "./chunk-OJBEN6CV.js";
import "./chunk-TU5E6NPS.js";
import "./chunk-RKNCTZBL.js";
import "./chunk-36OXW4YN.js";
import "./chunk-PEL3D3ZN.js";
import "./chunk-Q5KWD3VQ.js";
import "./chunk-BUQC3CLV.js";
import "./chunk-W5S3VUFT.js";
import "./chunk-7YH7T6CS.js";
import "./chunk-3T4IXPP4.js";
import "./chunk-XTZAIV4X.js";
import "./chunk-63LDVRFI.js";
import "./chunk-TJTOV6JD.js";
import {
  _ as _2
} from "./chunk-C3FRY5U4.js";
import "./chunk-JNJX34GB.js";
import "./chunk-3STJRSDT.js";
import "./chunk-67Q6KVC6.js";
import "./chunk-23NJHA5Q.js";
import "./chunk-4LA6K4VI.js";
import "./chunk-KEZCWFAR.js";
import {
  m as m4
} from "./chunk-JZUJ34RR.js";
import "./chunk-PMGS7UDU.js";
import "./chunk-3GHCGAH2.js";
import "./chunk-HWUOAPTX.js";
import "./chunk-QHCKOBU7.js";
import "./chunk-K2OZ6WVC.js";
import "./chunk-MC6NAKKX.js";
import "./chunk-TF6255HN.js";
import "./chunk-GD4FJL3C.js";
import "./chunk-C5OQVQZF.js";
import {
  u as u3
} from "./chunk-F7DKSAOI.js";
import {
  m as m3
} from "./chunk-4SOQWNPG.js";
import "./chunk-LTULADK2.js";
import "./chunk-35ST7YRB.js";
import "./chunk-EDA5QFHZ.js";
import "./chunk-6Z5KSPPF.js";
import "./chunk-CNYNCKEV.js";
import "./chunk-XL5QPCXN.js";
import "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-6KDQMJAI.js";
import "./chunk-UDHS2MGH.js";
import "./chunk-QF7FRVN6.js";
import "./chunk-ENINOZUZ.js";
import "./chunk-P6IKJIMO.js";
import "./chunk-MHV23XAQ.js";
import "./chunk-V2X4OKYI.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import "./chunk-MA3QDRC3.js";
import "./chunk-W6J7XCPU.js";
import "./chunk-ONXWBTTM.js";
import "./chunk-T7F6Q6JJ.js";
import "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-7P2ANHQ3.js";
import "./chunk-XCKT47LJ.js";
import {
  m as m2
} from "./chunk-3FUHCAX3.js";
import {
  P,
  f3 as f2,
  f4 as f3,
  i as i2,
  n,
  t,
  u4 as u2,
  y3 as y
} from "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import {
  g,
  i
} from "./chunk-FPMLKIDB.js";
import {
  I
} from "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import {
  f,
  h as h2,
  l as l2,
  w
} from "./chunk-2OFHDVO5.js";
import {
  l
} from "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-5UPBUJPC.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-CCQFL76O.js";
import "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import "./chunk-7H3U4IJR.js";
import "./chunk-SMWUT52Z.js";
import {
  _
} from "./chunk-AXZMNHTN.js";
import "./chunk-5T3MJDSR.js";
import "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import {
  u2 as u
} from "./chunk-GNMPGHLQ.js";
import "./chunk-QY7XKUIV.js";
import {
  h
} from "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/geometry/support/rotate.js
function m5(t3, e2, n3, s3) {
  const r = [];
  for (const o of t3) {
    const t4 = o.slice();
    r.push(t4);
    const a2 = e2 * (o[0] - s3.x) - n3 * (o[1] - s3.y) + s3.x, i5 = n3 * (o[0] - s3.x) + e2 * (o[1] - s3.y) + s3.y;
    t4[0] = a2, t4[1] = i5;
  }
  return r;
}
function x2(t3, n3, s3, r) {
  const o = [r.x, r.y];
  if (i2(t3)) {
    const n4 = [...t3];
    return I(n4, n4, o, s3);
  }
  return t(t3) ? i3(t3, o, s3) : u2(t3) ? n2(t3, o, s3) : n3 ? c(n3, t3, o, s3) : t3;
}
function y2(e2, n3, s3, r) {
  const o = [];
  for (const a2 of e2) {
    const e3 = [], c2 = r && a2.length > 0 && h(f2(a2[0]), f2(a2.at(-1)));
    for (let t3 = 0; t3 < a2.length; t3++) {
      const r2 = a2[t3], o2 = t3 > 0 ? f2(a2[t3 - 1]) : void 0;
      e3.push(x2(r2, o2, n3, s3));
    }
    c2 && (e3[0] = [...f2(e3.at(-1))]), o.push(e3);
  }
  return o;
}
function v({ spatialReference: t3, xmin: e2, ymin: n3, ymax: s3, xmax: o }) {
  return new P({ spatialReference: t3 ?? void 0, hasM: false, hasZ: false, rings: [[[e2, n3], [e2, s3], [o, s3], [o, n3], [e2, n3]]] });
}
function g2(t3, e2, i5) {
  const { hasM: c2, hasZ: p, spatialReference: u4, type: f4 } = t3, h4 = e2 * Math.PI / 180, l5 = Math.cos(h4), x3 = Math.sin(h4);
  switch (f4) {
    case "point":
      return i5 = i5 ?? t3, new _({ x: l5 * (t3.x - i5.x) - x3 * (t3.y - i5.y) + i5.x, y: x3 * (t3.x - i5.x) + l5 * (t3.y - i5.y) + i5.y, z: t3.z, m: t3.m, spatialReference: u4 });
    case "extent":
    case "polygon": {
      t3 = "extent" === f4 ? v(t3) : t3, i5 = i5 ?? t3.extent.center;
      const e3 = n(t3), n3 = y2(t3.curveRings ?? t3.rings, h4, i5, true);
      return new P({ spatialReference: u4, hasZ: t3.hasZ, hasM: t3.hasM, curveRings: e3 ? n3 : void 0, rings: e3 ? void 0 : n3 });
    }
    case "polyline": {
      i5 = i5 ?? t3.extent.center;
      const e3 = n(t3), n3 = y2(t3.curvePaths ?? t3.paths, h4, i5, false);
      return new y({ hasZ: p, hasM: c2, spatialReference: u4, curvePaths: e3 ? n3 : void 0, paths: e3 ? void 0 : n3 });
    }
    case "multipoint":
      return i5 ??= t3.extent.center, new m2({ hasM: c2, hasZ: p, points: m5(t3.points, l5, x3, i5), spatialReference: u4 });
  }
  return null;
}

// node_modules/@arcgis/core/views/draw/support/Box.js
var E = h3.transformGraphics;
var B = { centerIndicator: new u3({ style: "cross", size: E.center.size, color: E.center.color }), fill: { default: new m4({ color: E.fill.color, outline: { color: E.fill.outlineColor, join: "round", width: 1 } }), active: new m4({ color: E.fill.stagedColor, outline: { color: E.fill.outlineColor, join: "round", style: "dash", width: 1 } }) }, handles: { default: new u3({ style: "square", size: E.vertex.size, color: E.vertex.color, outline: { color: E.vertex.outlineColor, width: 1 } }), hover: new u3({ style: "square", size: E.vertex.hoverSize, color: E.vertex.hoverColor, outline: { color: E.vertex.hoverOutlineColor, width: 1 } }) }, rotator: { default: new u3({ style: "circle", size: E.vertex.size, color: E.vertex.color, outline: { color: E.vertex.outlineColor, width: 1 } }), hover: new u3({ style: "circle", size: E.vertex.hoverSize, color: E.vertex.hoverColor, outline: { color: E.vertex.hoverOutlineColor, width: 1 } }) }, rotatorLine: new m3({ color: E.line.color, width: 1 }) };
var z = Symbol();
var N = class extends l {
  constructor(t3) {
    super(t3), this._activeHandleGraphic = null, this._graphicAttributes = { esriSketchTool: "box" }, this._mover = null, this._centerGraphic = null, this._backgroundGraphic = null, this._vertexGraphics = [], this._rotateHandleGraphic = null, this._rotateGraphicOffset = 20, this._angleOfRotation = 0, this._rotateLineGraphic = null, this._startInfo = null, this._totalDx = 0, this._totalDy = 0, this._xScale = 1, this._yScale = 1, this.tooltip = null, this.type = "box", this.callbacks = { onMoveStart() {
    }, onMove() {
    }, onMoveStop() {
    }, onScaleStart() {
    }, onScale() {
    }, onScaleStop() {
    }, onRotateStart() {
    }, onRotate() {
    }, onRotateStop() {
    }, onGraphicClick() {
    } }, this.enableMovement = true, this.enableRotation = true, this.enableScaling = true, this.graphics = [], this.highlightName = null, this.highlightsEnabled = true, this.layer = null, this.preserveAspectRatio = false, this.showCenterGraphic = true, this.symbols = B, this.sketchOptions = new l3(), this.view = null, this._getBounds = (() => {
      const t4 = i();
      return (e2, i5) => {
        e2[0] = Number.POSITIVE_INFINITY, e2[1] = Number.POSITIVE_INFINITY, e2[2] = Number.NEGATIVE_INFINITY, e2[3] = Number.NEGATIVE_INFINITY;
        for (const s3 of i5) {
          if (!s3) continue;
          let i6, o, r, a2;
          if ("point" === s3.type) i6 = r = s3.x, o = a2 = s3.y;
          else if ("extent" === s3.type) [i6, o, r, a2] = [s3.xmin, s3.ymin, s3.xmax, s3.ymax];
          else {
            const e3 = f3(t4, s3);
            [i6, o, r, a2] = e3;
          }
          e2[0] = Math.min(i6, e2[0]), e2[1] = Math.min(o, e2[1]), e2[2] = Math.max(r, e2[2]), e2[3] = Math.max(a2, e2[3]);
        }
        return e2;
      };
    })();
  }
  initialize() {
    const t3 = this.view;
    this._highlightHelper = new l4({ view: t3 }), this._setup(), this.addHandles([f(() => t3?.ready, () => {
      const { layer: t4, view: e2 } = this;
      t2(e2, t4);
    }, { once: true, initial: true }), l2(() => this.preserveAspectRatio, () => {
      this._activeHandleGraphic && (this._scaleGraphic(this._activeHandleGraphic), this._updateGraphics(), this._updateTooltip(this._activeHandleGraphic));
    }), l2(() => t3?.scale, () => {
      this._updateRotateGraphic(), this._updateRotateLineGraphic();
    }), l2(() => this.graphics, () => this.refresh()), l2(() => this.layer, (t4, e2) => {
      e2 && this._resetGraphics(e2), this.refresh();
    }), l2(() => [this.highlightsEnabled, this.highlightName], () => {
      this._highlightHelper?.removeAll(), this._setUpHighlights();
    }), l2(() => this.sketchOptions.tooltips.effectiveEnabled, (e2) => {
      this.tooltip = e2 ? R(() => ({ view: t3, options: this.sketchOptions.tooltips })) : u(this.tooltip);
    }, w), l2(() => this.view.effectiveTheme.accentColor, () => this._updateSymbolsForTheme(), h2), this.on("move-start", (t4) => this.callbacks?.onMoveStart?.(t4)), this.on("move", (t4) => this.callbacks?.onMove?.(t4)), this.on("move-stop", (t4) => this.callbacks?.onMoveStop?.(t4)), this.on("rotate-start", (t4) => this.callbacks?.onRotateStart?.(t4)), this.on("rotate", (t4) => this.callbacks?.onRotate?.(t4)), this.on("rotate-stop", (t4) => this.callbacks?.onRotateStop?.(t4)), this.on("scale-start", (t4) => this.callbacks?.onScaleStart?.(t4)), this.on("scale", (t4) => this.callbacks?.onScale?.(t4)), this.on("scale-stop", (t4) => this.callbacks?.onScaleStop?.(t4))]);
  }
  destroy() {
    this._reset(), this.tooltip = u(this.tooltip);
  }
  get state() {
    const t3 = this.view?.ready ?? false, e2 = this.graphics.length && this.layer;
    return t3 && e2 ? "active" : t3 ? "ready" : "disabled";
  }
  isUIGraphic(t3) {
    return this._vertexGraphics.includes(t3) || t3 === this._backgroundGraphic || t3 === this._centerGraphic || t3 === this._rotateHandleGraphic || t3 === this._rotateLineGraphic;
  }
  move(t3, e2) {
    if (this._mover && this.graphics.length) {
      for (const i5 of this.graphics) {
        const s3 = i5.geometry, o = x(s3, t3, e2, this.view);
        i5.geometry = o;
      }
      this.refresh(), this.emit("move-stop", { graphics: this.graphics, mover: null, dx: t3, dy: e2, type: "move-stop" });
    }
  }
  scale(t3, e2) {
    if (!this._mover || !this.graphics.length) return;
    const i5 = this._getBoxBounds(i()), s3 = g(i5);
    for (const o of this.graphics) {
      const i6 = o.geometry, r = M(i6, t3, e2, s3);
      o.geometry = r;
    }
    this.refresh(), this.emit("scale-stop", { graphics: this.graphics, mover: null, xScale: t3, yScale: e2, type: "scale-stop" });
  }
  rotate(t3, e2) {
    if (this._mover && this.graphics.length) {
      if (!e2) {
        const t4 = this._vertexGraphics[1].geometry.x, i5 = this._vertexGraphics[3].geometry.y;
        e2 = new _(t4, i5, this.view.spatialReference);
      }
      for (const i5 of this.graphics) {
        const s3 = i5.geometry, o = g2(s3, t3, e2);
        i5.geometry = o;
      }
      this.refresh(), this.emit("rotate-stop", { graphics: this.graphics, mover: null, angle: t3, type: "rotate-stop" });
    }
  }
  refresh() {
    this._reset(), this._setup();
  }
  reset() {
    this.graphics = [];
  }
  _setup() {
    "active" === this.state && (this._setUpHighlights(), this._setupGraphics(), this._setupMover(), this._updateGraphics());
  }
  _reset() {
    this._highlightHelper?.removeAll(), this._resetGraphicStateVars(), this._resetGraphics(), this._updateTooltip(), this._mover?.destroy(), this._mover = null, this.removeHandles(z);
  }
  _resetGraphicStateVars() {
    this._startInfo = null, this._activeHandleGraphic = null, this._totalDx = 0, this._totalDy = 0, this._xScale = 1, this._yScale = 1, this._angleOfRotation = 0;
  }
  _resetGraphics(t3) {
    (t3 = t3 || this.layer) && (t3.removeMany(this._vertexGraphics), t3.remove(this._backgroundGraphic), t3.remove(this._centerGraphic), t3.remove(this._rotateHandleGraphic), t3.remove(this._rotateLineGraphic)), this._vertexGraphics.forEach((t4) => !t4.destroyed && t4.destroy()), !this._backgroundGraphic.destroyed && this._backgroundGraphic.destroy(), !this._centerGraphic.destroyed && this._centerGraphic.destroy(), !this._rotateHandleGraphic.destroyed && this._rotateHandleGraphic.destroy(), !this._rotateLineGraphic.destroyed && this._rotateLineGraphic.destroy(), this._vertexGraphics = [], this._backgroundGraphic = null, this._centerGraphic = null, this._rotateHandleGraphic = null, this._rotateLineGraphic = null;
  }
  _setupMover() {
    let t3 = [];
    this.enableScaling && (t3 = t3.concat(this._vertexGraphics)), this.enableRotation && t3.push(this._rotateHandleGraphic), this.enableMovement && (t3 = t3.concat(this.graphics, this._backgroundGraphic)), this.showCenterGraphic && t3.push(this._centerGraphic), this._mover = new j({ enableMoveAllGraphics: false, highlightsEnabled: false, indicatorsEnabled: false, view: this.view, graphics: t3, callbacks: { onGraphicClick: (t4) => this._onGraphicClickCallback(t4), onGraphicMoveStart: (t4) => this._onGraphicMoveStartCallback(t4), onGraphicMove: (t4) => this._onGraphicMoveCallback(t4), onGraphicMoveStop: (t4) => this._onGraphicMoveStopCallback(t4), onGraphicPointerOver: (t4) => this._onGraphicPointerOverCallback(t4), onGraphicPointerOut: (t4) => this._onGraphicPointerOutCallback(t4) } });
  }
  _setCursor(t3) {
    this.addHandles(this.view.acquireCursor(t3, "high"), z);
  }
  _getStartInfo(t3) {
    const [e2, i5, s3, o] = this._getBoxBounds(i()), r = Math.abs(s3 - e2), a2 = Math.abs(o - i5), h4 = (s3 + e2) / 2, c2 = (o + i5) / 2, { x: n3, y: l5 } = t3.geometry;
    return { width: r, height: a2, centerX: h4, centerY: c2, startX: n3, startY: l5, graphicInfos: this._getGraphicInfos(), box: this._backgroundGraphic.geometry, rotate: this._rotateHandleGraphic.geometry };
  }
  _getGraphicInfos() {
    return this.graphics.map((t3) => this._getGraphicInfo(t3));
  }
  _getGraphicInfo(t3) {
    const e2 = t3.geometry, [i5, s3, o, r] = this._getBounds(i(), [e2]);
    return { width: Math.abs(o - i5), height: Math.abs(r - s3), centerX: (o + i5) / 2, centerY: (r + s3) / 2, geometry: e2 };
  }
  _onGraphicClickCallback(t3) {
    t3.viewEvent.stopPropagation(), this.emit("graphic-click", t3), this.callbacks.onGraphicClick && this.callbacks.onGraphicClick(t3);
  }
  _onGraphicMoveStartCallback(t3) {
    const { _angleOfRotation: e2, _xScale: i5, _yScale: s3, _backgroundGraphic: o, _vertexGraphics: r, _rotateHandleGraphic: a2, symbols: h4, graphics: c2 } = this, { graphic: n3, dx: l5, dy: p, viewEvent: _3 } = t3;
    this._resetGraphicStateVars(), this._hideGraphicsBeforeUpdate(), o.symbol = h4.fill.active, this._startInfo = this._getStartInfo(n3), this._updateTooltip(n3, _3), n3 === a2 ? (this._setCursor("grabbing"), this.emit("rotate-start", { type: "rotate-start", mover: n3, graphics: c2, angle: e2 })) : r.includes(n3) ? (this._activeHandleGraphic = n3, this.emit("scale-start", { type: "scale-start", mover: n3, graphics: c2, xScale: i5, yScale: s3 })) : this.emit("move-start", { type: "move-start", graphics: c2, mover: n3, dx: l5, dy: p });
  }
  _onGraphicMoveCallback(t3) {
    const e2 = t3.graphic;
    if (!this._startInfo) return;
    const { _xScale: i5, _yScale: s3, _angleOfRotation: o, graphics: r } = this;
    if (this._vertexGraphics.includes(e2)) this._scaleGraphic(e2), this._updateTooltip(e2, t3.viewEvent), this.emit("scale", { type: "scale", graphics: r, mover: e2, xScale: i5, yScale: s3 });
    else if (e2 === this._rotateHandleGraphic) this._rotateGraphic(e2), this._updateTooltip(e2, t3.viewEvent), this.emit("rotate", { type: "rotate", graphics: r, mover: e2, angle: o });
    else {
      const { dx: i6, dy: s4 } = t3;
      this._totalDx += i6, this._totalDy += s4, this._moveGraphic(e2, i6, s4), this._updateTooltip(e2, t3.viewEvent), this.emit("move", { type: "move", graphics: r, mover: e2, dx: i6, dy: s4 });
    }
  }
  _onGraphicMoveStopCallback(t3) {
    const e2 = t3.graphic;
    if (!this._startInfo) return void this.refresh();
    const { _angleOfRotation: i5, _totalDx: s3, _totalDy: o, _xScale: r, _yScale: a2, _vertexGraphics: h4, _rotateHandleGraphic: c2, graphics: n3 } = this;
    this.refresh(), e2 === c2 ? (this._setCursor("pointer"), this.emit("rotate-stop", { type: "rotate-stop", graphics: n3, mover: e2, angle: i5 })) : h4.includes(e2) ? this.emit("scale-stop", { type: "scale-stop", mover: e2, graphics: n3, xScale: r, yScale: a2 }) : this.emit("move-stop", { type: "move-stop", graphics: n3, mover: e2, dx: s3, dy: o });
  }
  _onGraphicPointerOverCallback(t3) {
    const { _backgroundGraphic: e2, _vertexGraphics: i5, graphics: s3, _rotateHandleGraphic: o, symbols: r, view: a2 } = this, h4 = t3.graphic;
    if (this._hoveredGraphic = h4, h4 === o) return o.symbol = r.rotator.hover, this._setCursor("pointer"), void this._updateTooltip(h4);
    if (s3.includes(h4) || h4 === e2) return void this._setCursor("move");
    if (!i5.includes(h4)) return void this._setCursor("pointer");
    this._updateTooltip(h4), t3.graphic.symbol = r.handles.hover;
    const c2 = a2.rotation;
    let n3, l5 = t3.index;
    switch (l5 < 8 && (c2 >= 0 && c2 < 45 ? l5 %= 8 : l5 = c2 >= 45 && c2 < 90 ? (l5 + 1) % 8 : c2 >= 90 && c2 < 135 ? (l5 + 2) % 8 : c2 >= 135 && c2 < 180 ? (l5 + 3) % 8 : c2 >= 180 && c2 < 225 ? (l5 + 4) % 8 : c2 >= 225 && c2 < 270 ? (l5 + 5) % 8 : c2 >= 270 && c2 < 315 ? (l5 + 6) % 8 : (l5 + 7) % 8), l5) {
      case 0:
      case 4:
        n3 = "nwse-resize";
        break;
      case 1:
      case 5:
        n3 = "ns-resize";
        break;
      case 2:
      case 6:
        n3 = "nesw-resize";
        break;
      case 3:
      case 7:
        n3 = "ew-resize";
        break;
      default:
        n3 = "pointer";
    }
    this._setCursor(n3);
  }
  _onGraphicPointerOutCallback(t3) {
    const { _vertexGraphics: e2, _rotateHandleGraphic: i5, symbols: s3 } = this;
    this._hoveredGraphic = null, t3.graphic === i5 ? i5.symbol = s3.rotator.default : e2.includes(t3.graphic) && (t3.graphic.symbol = s3.handles.default), this.removeHandles(z), this._updateTooltip();
  }
  _scaleGraphic(t3) {
    const { _startInfo: e2, _vertexGraphics: i5, preserveAspectRatio: s3, view: o } = this, { centerX: r, centerY: a2, graphicInfos: h4, height: c2, startX: n3, startY: l5, width: _3 } = e2, { resolution: d2, transform: m6 } = o.state, g3 = i5.indexOf(t3);
    1 !== g3 && 5 !== g3 || this._updateX(t3, r), 3 !== g3 && 7 !== g3 || this._updateY(t3, a2);
    const { x: u4, y: y3 } = t3.geometry, v2 = m6[0] * u4 + m6[2] * y3 + m6[4], f4 = m6[1] * u4 + m6[3] * y3 + m6[5], G = h4?.map((t4) => t4.geometry) ?? [], S = G.every((t4) => "point" === t4.type);
    if ((0 === _3 || 0 === c2) && S) {
      const t4 = U2((u4 - n3) / d2), i6 = U2((l5 - y3) / d2);
      for (let e3 = 0; e3 < G.length; e3++) this.graphics[e3].geometry = x(G[e3], t4, i6, o, true);
      return this._centerGraphic.geometry = new _(u4, y3, o.spatialReference), void (this._backgroundGraphic.geometry = x(e2.box, t4, i6, o, true));
    }
    if (s3) {
      const t4 = U2(m6[0] * r + m6[2] * a2 + m6[4], 2), e3 = U2(m6[1] * r + m6[3] * a2 + m6[5], 2), i6 = U2(m6[0] * n3 + m6[2] * l5 + m6[4], 2), s4 = U2(m6[1] * n3 + m6[3] * l5 + m6[5], 2);
      let o2 = U(t4, e3, i6, s4, v2, f4);
      0 !== o2 && Math.abs(o2) !== 1 / 0 || (o2 = 1), this._xScale = this._yScale = o2;
      for (const h5 of G) {
        const t5 = G.indexOf(h5);
        this.graphics[t5].geometry = M(h5, this._xScale, this._yScale, [r, a2]);
      }
      this._updateBackgroundGraphic();
    } else {
      let t4 = u4 - n3, i6 = l5 - y3;
      if (1 === g3 || 5 === g3 ? t4 = 0 : 3 !== g3 && 7 !== g3 || (i6 = 0), 0 === t4 && 0 === i6) return;
      const s4 = r + t4 / 2, h5 = a2 + i6 / 2;
      let m7 = (_3 + (n3 > r ? t4 : -1 * t4)) / _3, v3 = (c2 + (l5 < a2 ? i6 : -1 * i6)) / c2;
      1 !== g3 && 5 !== g3 && 0 !== m7 && Math.abs(m7) !== 1 / 0 || (m7 = 1), 3 !== g3 && 7 !== g3 && 0 !== v3 && Math.abs(v3) !== 1 / 0 || (v3 = 1), this._xScale = m7, this._yScale = v3;
      const f5 = (s4 - r) / d2, w2 = (h5 - a2) / d2, S2 = M(e2.box, this._xScale, this._yScale);
      this._backgroundGraphic.geometry = x(S2, f5, w2, o, true);
      const { centerX: k, centerY: R2 } = this._getGraphicInfo(this._backgroundGraphic), C = (k - r) / d2, M2 = -1 * (R2 - a2) / d2;
      for (const e3 of G) {
        const t5 = G.indexOf(e3), i7 = M(e3, this._xScale, this._yScale, [r, a2]);
        this.graphics[t5].geometry = x(i7, C, M2, o, true);
      }
      this._centerGraphic.geometry = new _(k, R2, o.spatialReference);
    }
  }
  _rotateGraphic(t3) {
    const { centerX: e2, centerY: i5, startX: s3, startY: o, box: r, rotate: a2 } = this._startInfo, h4 = this.view.spatialReference, c2 = new _(s3, o, h4), n3 = new _(e2, i5, h4), l5 = t3.geometry;
    this._angleOfRotation = b(c2, l5, n3);
    const _3 = this._startInfo.graphicInfos?.map((t4) => t4.geometry) ?? [];
    for (const p of _3) {
      const t4 = _3.indexOf(p), e3 = g2(p, this._angleOfRotation, n3);
      this.graphics[t4].geometry = e3;
    }
    this._backgroundGraphic.geometry = g2(r, this._angleOfRotation, n3), this._rotateHandleGraphic.geometry = g2(a2, this._angleOfRotation, n3);
  }
  _moveGraphic(t3, e2, i5) {
    if (this.graphics.includes(t3)) {
      const s3 = this._backgroundGraphic.geometry;
      this._backgroundGraphic.geometry = x(s3, e2, i5, this.view);
      for (const o of this.graphics) o !== t3 && (o.geometry = x(o.geometry, e2, i5, this.view));
    } else if (t3 === this._centerGraphic) {
      const t4 = this._backgroundGraphic.geometry;
      this._backgroundGraphic.geometry = x(t4, e2, i5, this.view);
    }
    if (t3 === this._backgroundGraphic || t3 === this._centerGraphic) for (const s3 of this.graphics) s3.geometry = x(s3.geometry, e2, i5, this.view);
  }
  _setUpHighlights() {
    this.highlightsEnabled && this.graphics.length && this._highlightHelper?.add(this.graphics, this.highlightName);
  }
  _setupGraphics() {
    const { _graphicAttributes: t3, symbols: i5 } = this;
    this._centerGraphic = new _2({ symbol: i5.centerIndicator, attributes: t3 }), this.showCenterGraphic && this.layer.add(this._centerGraphic), this._backgroundGraphic = new _2({ symbol: i5.fill.default, attributes: t3 }), this.layer.add(this._backgroundGraphic), this._rotateLineGraphic = new _2({ symbol: i5.rotatorLine, attributes: t3 }), this._rotateHandleGraphic = new _2({ symbol: i5.rotator.default, attributes: t3 }), this.enableRotation && !this._hasExtentGraphic() && this.layer.addMany([this._rotateLineGraphic, this._rotateHandleGraphic]);
    for (let s3 = 0; s3 < 8; s3++) this._vertexGraphics.push(new _2({ symbol: i5.handles.default, attributes: t3 }));
    this.enableScaling && this.layer.addMany(this._vertexGraphics);
  }
  _updateSymbolsForTheme() {
    const t3 = this.view.effectiveTheme.accentColor;
    this.symbols = { ...this.symbols, fill: { active: this.symbols.fill.active?.clone().set("outline.color", t3), default: this.symbols.fill.default?.clone().set("outline.color", t3) }, handles: { ...this.symbols.handles, default: this.symbols.handles.default.clone().set("outline.color", t3) }, rotator: { ...this.symbols.rotator, default: this.symbols.rotator.default.clone().set("outline.color", t3) }, rotatorLine: this.symbols.rotatorLine.clone().set("color", t3) };
    for (const e2 of this._vertexGraphics) e2.symbol = e2 === this._hoveredGraphic ? this.symbols.handles.hover : this.symbols.handles.default;
    this._backgroundGraphic.symbol = this.symbols.fill.default, this._rotateHandleGraphic.symbol = this._rotateHandleGraphic === this._hoveredGraphic ? this.symbols.rotator.hover : this.symbols.rotator.default, this._rotateLineGraphic.symbol = this.symbols.rotatorLine;
  }
  _updateGraphics() {
    this._updateBackgroundGraphic(), this._updateHandleGraphics(), this._updateCenterGraphic(), this._updateRotateGraphic(), this._updateRotateLineGraphic();
  }
  _hideGraphicsBeforeUpdate() {
    this._centerGraphic.visible = false, this._rotateHandleGraphic.visible = false, this._rotateLineGraphic.visible = false, this._vertexGraphics.forEach((t3) => t3.visible = false);
  }
  _updateHandleGraphics() {
    const t3 = this._getCoordinates(true);
    this._vertexGraphics.forEach((e2, i5) => {
      const [s3, o] = t3[i5];
      this._updateXY(e2, s3, o);
    });
  }
  _updateBackgroundGraphic() {
    const t3 = this._getCoordinates().map(([t4, e2]) => [t4, e2]);
    this._backgroundGraphic.geometry = new P({ rings: [t3], spatialReference: this.view.spatialReference });
  }
  _updateCenterGraphic() {
    const [t3, e2, i5, s3] = this._getBoxBounds(i()), o = (i5 + t3) / 2, r = (s3 + e2) / 2;
    this._centerGraphic.geometry = new _(o, r, this.view.spatialReference);
  }
  _updateRotateGraphic() {
    if (!this._vertexGraphics.length) return;
    const { x: t3, y: e2 } = this._vertexGraphics[1].geometry, i5 = e2 + this.view.state.resolution * this._rotateGraphicOffset;
    this._rotateHandleGraphic.geometry = new _(t3, i5, this.view.spatialReference);
  }
  _updateRotateLineGraphic() {
    if (!this._vertexGraphics.length || !this._rotateHandleGraphic?.geometry) return;
    const t3 = this._vertexGraphics[1].geometry, e2 = this._rotateHandleGraphic.geometry;
    this._rotateLineGraphic.geometry = new y({ paths: [[[t3.x, t3.y], [e2.x, e2.y]]], spatialReference: this.view.spatialReference });
  }
  _updateXY(t3, e2, i5) {
    t3.geometry = new _(e2, i5, this.view.spatialReference);
  }
  _updateX(t3, e2) {
    const i5 = t3.geometry.y;
    t3.geometry = new _(e2, i5, this.view.spatialReference);
  }
  _updateY(t3, e2) {
    const i5 = t3.geometry.x;
    t3.geometry = new _(i5, e2, this.view.spatialReference);
  }
  _hasExtentGraphic() {
    return this.graphics.some((t3) => null != t3?.geometry && "extent" === t3.geometry.type);
  }
  _getBoxBounds(t3) {
    const e2 = this.graphics.map((t4) => t4.geometry);
    return this._getBounds(t3, e2);
  }
  _getCoordinates(t3) {
    const [e2, i5, s3, o] = this._getBoxBounds(i());
    if (t3) {
      const t4 = (e2 + s3) / 2, r = (o + i5) / 2;
      return [[e2, o], [t4, o], [s3, o], [s3, r], [s3, i5], [t4, i5], [e2, i5], [e2, r]];
    }
    return [[e2, o], [s3, o], [s3, i5], [e2, i5]];
  }
  _updateTooltip(t3, e2) {
    if (null == this.tooltip) return;
    if (!t3) return void this.tooltip.clear();
    const { _backgroundGraphic: i5, graphics: s3, _vertexGraphics: o, _rotateHandleGraphic: r } = this;
    t3 === r ? this._updateRotateTooltip() : o.includes(t3) ? this._updateScaleTooltip() : (s3.includes(t3) || t3 === i5) && this._updateMoveTooltip(e2);
  }
  _updateRotateTooltip() {
    null != this.tooltip && (this.tooltip.info = new s({ sketchOptions: this.sketchOptions, angle: -this._angleOfRotation }));
  }
  _updateScaleTooltip() {
    const { tooltip: t3, _xScale: e2, _yScale: i5, sketchOptions: s3, view: o, automaticLengthMeasurementUtils: r } = this;
    if (null == t3) return;
    const a2 = this._getCoordinates(), h4 = e({ topLeft: a2[0], topRight: a2[1], bottomRight: a2[2], bottomLeft: a2[3], spatialReference: o.spatialReference, automaticLengthMeasurementUtils: r });
    if (null == h4) return;
    const { xSize: c2, ySize: n3 } = h4, l5 = Math.abs(e2), p = Math.abs(i5);
    t3.info = new s2({ sketchOptions: s3, xScale: l5, yScale: p, xSize: c2, ySize: n3 });
  }
  _updateMoveTooltip(t3) {
    const { tooltip: e2, sketchOptions: i5, view: s3, automaticLengthMeasurementUtils: r } = this;
    if (null == e2) return;
    const a2 = new i4({ sketchOptions: i5 });
    if (t3) {
      const { x: e3, y: i6 } = t3.origin, h4 = s3.toMap(t3), c2 = s3.toMap({ x: e3, y: i6 }), n3 = r.autoDistanceBetweenPoints2D(c2, h4);
      a2.distance = null != n3 ? n3 : d;
    }
    e2.info = a2;
  }
};
function U2(t3, e2 = 2) {
  return Number.parseFloat(t3.toFixed(e2));
}
__decorate([m()], N.prototype, "tooltip", void 0), __decorate([m({ readOnly: true })], N.prototype, "type", void 0), __decorate([m()], N.prototype, "callbacks", void 0), __decorate([m()], N.prototype, "enableMovement", void 0), __decorate([m()], N.prototype, "enableRotation", void 0), __decorate([m()], N.prototype, "enableScaling", void 0), __decorate([m()], N.prototype, "graphics", void 0), __decorate([m()], N.prototype, "highlightName", void 0), __decorate([m()], N.prototype, "highlightsEnabled", void 0), __decorate([m()], N.prototype, "layer", void 0), __decorate([m()], N.prototype, "preserveAspectRatio", void 0), __decorate([m()], N.prototype, "showCenterGraphic", void 0), __decorate([m({ readOnly: true })], N.prototype, "state", null), __decorate([m()], N.prototype, "symbols", void 0), __decorate([m({ type: l3 })], N.prototype, "sketchOptions", void 0), __decorate([m({ constructOnly: true })], N.prototype, "view", void 0), __decorate([m({ constructOnly: true })], N.prototype, "automaticLengthMeasurementUtils", void 0), N = __decorate([a("esri.views.draw.support.Box")], N);
var Y = N;
export {
  Y as default
};
//# sourceMappingURL=Box-FA4AFAUU.js.map
