import {
  U,
  x
} from "./chunk-U73R3I4U.js";
import {
  c as c2
} from "./chunk-3STJRSDT.js";
import {
  e2 as e,
  ke,
  qe,
  xe
} from "./chunk-MC6NAKKX.js";
import {
  G,
  I
} from "./chunk-CNYNCKEV.js";
import {
  c,
  l,
  s
} from "./chunk-UDHS2MGH.js";
import {
  N,
  b
} from "./chunk-DDOCCRD4.js";
import {
  h
} from "./chunk-THQO67BJ.js";
import {
  i3 as i,
  r
} from "./chunk-QY7XKUIV.js";
import {
  has
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/widgets/Feature/support/featureUtils.js
var I2 = "esri.widgets.Feature.support.featureUtils";
var b2 = () => i.getLogger(I2);
var h2 = /href=(""|'')/gi;
var F = /(\{([^{\r\n]+)\})/g;
var w = /'/g;
var T = /^\s*expression\//i;
var N2 = /(\n)/gi;
var j = /[\u00A0-\u9999<>&]/gim;
var C = /href\s*=\s*(?:"([^"]+)"|'([^']+)')/gi;
var Z = /^(?:mailto:|tel:)/;
var v = "relationships/";
var L = N("short-date-short-time");
function x2(e2) {
  if (null != e2) return (e2.sourceLayer || e2.layer) ?? void 0;
}
async function q({ type: e2, value: t, event: n }) {
  try {
    return "function" == typeof t ? t(n) : await t;
  } catch (r2) {
    return void b2().error("error", `An error occurred when calling the "${e2}" function`, { error: r2, graphic: n.graphic, value: t });
  }
}
function A(e2 = "") {
  if (e2) return !Z.test(e2.trim().toLowerCase());
}
function U2(e2) {
  return !!e2 && T.test(e2);
}
function E(e2, t) {
  if (!t || !U2(t) || !e2) return;
  const n = t.replace(T, "").toLowerCase();
  return e2.find(({ name: e3 }) => e3.toLowerCase() === n);
}
function M({ fieldInfo: e2, graphic: t }) {
  return !(!e2?.fieldName || U2(e2.fieldName) || he(e2.fieldName) || t?.isAggregate || t?.popupTemplate);
}
function k({ expressionInfos: e2, fieldInfo: t, graphic: n, isContentFieldInfos: r2, layer: i2 }) {
  if (!t?.fieldName) return null;
  const o = E(e2, t.fieldName);
  if (o) return o.title || null;
  if (I(i2) && M({ fieldInfo: t, graphic: n })) {
    const e3 = i2.getFieldAlias(t.fieldName);
    return r2 ? t.label || e3 || t.fieldName : e3 || t.fieldName;
  }
  return t.label || t.fieldName;
}
function R({ fieldInfo: e2, isContentFieldInfos: t, layer: n }) {
  if (!e2?.fieldName) return null;
  if (I(n)) {
    const r2 = n.popupTemplate || n.fieldConfigurations ? n.getFieldConfiguration(e2.fieldName)?.fieldFormat : c2(e2, n.getField(e2.fieldName));
    return t && e2.fieldFormat || r2;
  }
  return null;
}
function $(e2, t) {
  const n = t.get(e2.toLowerCase());
  return `{${n?.fieldName || e2}}`;
}
function D(e2) {
  return e2.replaceAll(h2, "");
}
function z(e2, t) {
  const n = S(t, e2);
  return n ? n.name : e2;
}
function O(e2, t) {
  return e2 && e2.map((e3) => z(e3, t));
}
function S(e2, t) {
  return e2 && "function" == typeof e2.getField && t ? e2.getField(t) ?? null : null;
}
function G2(e2) {
  return `${e2}`.trim();
}
function Q({ attributes: e2, globalAttributes: t, layer: n, text: r2, expressionAttributes: i2, fieldInfoMap: o }) {
  return r2 ? P({ formattedAttributes: t, template: J(r2, { ...t, ...i2, ...e2 }, n), fieldInfoMap: o }) : "";
}
function P({ formattedAttributes: e2, template: n, fieldInfoMap: r2 }) {
  return G2(D(r(r(n, (e3) => $(e3, r2)), e2)));
}
function _(e2, t, n = false) {
  const r2 = t[e2];
  if ("string" == typeof r2) {
    const i2 = "%27", o = (n ? encodeURIComponent(r2) : r2).replaceAll(w, i2);
    t[e2] = o;
  }
}
function H(e2, t = false) {
  const n = { ...e2 };
  return Object.keys(n).forEach((e3) => _(e3, n, t)), n;
}
function W(e2, n, r2) {
  const i2 = (n = G2(n)) && !n.startsWith("{");
  return r(e2, H(r2, i2 || false));
}
function B(e2, t) {
  return e2.replaceAll(F, (e3, n, r2) => {
    const i2 = S(t, r2);
    return i2 ? `{${i2.name}}` : n;
  });
}
function J(e2, t, n) {
  const r2 = B(e2, n);
  return r2 ? r2.replaceAll(C, (e3, n2, r3) => W(e3, n2 || r3, t)) : r2;
}
function K(e2, t) {
  const n = "number" === t?.fieldFormat?.type || t?.format && null == t.format.dateFormat && (null != t.format.places || null != t.format.digitSeparator);
  if ("string" == typeof e2 && n) {
    const t2 = Number(e2);
    if (!isNaN(t2)) return t2;
  }
  return e2;
}
function V(e2) {
  return null != e2 && "object" == typeof e2 && "fieldsIndex" in e2 && "geometryType" in e2 && "getField" in e2 && "load" in e2 && "loaded" in e2 && "objectIdField" in e2 && "spatialReference" in e2 && "type" in e2 && ("feature" === e2.type || "scene" === e2.type || "subtype-group" === e2.type || "subtype-sublayer" === e2.type || "sublayer" === e2.type) && "when" in e2;
}
function X(e2) {
  return null != e2 && "object" == typeof e2 && "createQuery" in e2 && "queryFeatureCount" in e2 && "queryObjectIds" in e2 && "queryRelatedFeatures" in e2 && "queryRelatedFeaturesCount" in e2 && "relationships" in e2;
}
function Y(e2) {
  return V(e2) && X(e2);
}
function ee(e2) {
  return !(!(e2 && "object" == typeof e2 && "createQuery" in e2 && "getField" in e2 && "queryFeatureCount" in e2 && "queryFeatures" in e2 && "queryObjectIds" in e2 && "capabilities" in e2 && "fields" in e2 && "fieldsIndex" in e2 && "type" in e2) || "feature" !== e2.type && "subtype-group" !== e2.type && "subtype-sublayer" !== e2.type && "sublayer" !== e2.type || !("when" in e2)) && ("subtype-sublayer" === e2.type && "parent" in e2 && e2.parent && "object" == typeof e2.parent ? "globalIdField" in e2.parent : "globalIdField" in e2);
}
function te(e2) {
  return !!e2 && "object" == typeof e2 && "sourceLayer" in e2 && Y(e2.sourceLayer);
}
function ne(e2, t) {
  const { fieldInfos: n, fieldName: r2, graphic: l2, isContentFieldInfos: s2, layer: f, preventPlacesFormatting: c3, timeZone: y } = t, m = oe(n, r2), g = S(f, r2), I3 = I(f) && M({ fieldInfo: m, graphic: l2 }), b3 = I3 ? null : m?.format, h3 = I3 ? R({ fieldInfo: m, layer: f, isContentFieldInfos: s2 }) : null, F2 = "number" === h3?.type;
  if (m && !qe(r2)) {
    const t2 = g?.type, n2 = "date-time" === h3?.type, r3 = b3?.dateFormat;
    if ("date" === t2 || "date-only" === t2 || "time-only" === t2 || "timestamp-offset" === t2 || n2 || r3) return x(e2, { format: n2 ? void 0 : r3, fieldFormat: n2 ? h3 : void 0, fieldType: t2, timeZoneOptions: { layerTimeZone: f && "preferredTimeZone" in f ? f.preferredTimeZone : null, viewTimeZone: y, datesInUnknownTimezone: !(!f || !("datesInUnknownTimezone" in f)) && !!f.datesInUnknownTimezone } });
  }
  if ("string" == typeof e2 && qe(r2) && b3) return re(e2, b3);
  if ("string" == typeof (e2 = K(e2, { format: F2 ? void 0 : b3, fieldFormat: F2 ? h3 : void 0 })) || null == e2 || null == b3 && null == h3) return ce(e2);
  const w2 = F2 ? s(h3) : b3 ? l(b3) : void 0;
  return c(e2, c3 ? { ...w2, minimumFractionDigits: 0, maximumFractionDigits: 20 } : w2);
}
function re(e2, t) {
  return e2 = e2.trim(), /\d{2}-\d{2}/.test(e2) ? e2 : e2.includes(",") ? ie(e2, ",", ", ", t) : e2.includes(";") ? ie(e2, ";", "; ", t) : e2.includes(" ") ? ie(e2, " ", " ", t) : c(Number(e2), l(t));
}
function ie(e2, t, n, r2) {
  return e2.trim().split(t).map((e3) => c(Number(e3), l(r2))).join(n);
}
function oe(e2, t) {
  if (e2?.length && t) return e2.find((e3) => e3.fieldName?.toLowerCase() === t.toLowerCase());
}
function ae({ fieldName: e2, graphic: t, layer: n }) {
  if (he(e2)) return null;
  if (!n || "function" != typeof n.getFeatureType) return null;
  const { typeIdField: r2 } = n;
  if (!r2 || e2 !== r2) return null;
  const i2 = n.getFeatureType(t);
  return i2 ? i2.name : null;
}
function le({ fieldName: e2, value: t, graphic: n, layer: r2 }) {
  if (he(e2)) return null;
  if (!r2 || "function" != typeof r2.getFieldDomain) return null;
  const i2 = n && r2.getFieldDomain(e2, { feature: n, excludeImpliedDomains: has("esri-widget-legacy-field-domain-calculation") });
  return i2 && "coded-value" === i2.type ? i2.getName(t) : null;
}
function ue(e2, t, n, i2) {
  const { creatorField: o, creationDateField: a, editorField: l2, editDateField: u } = e2;
  if (!t) return;
  const s2 = h(i2 && "preferredTimeZone" in i2 ? i2.preferredTimeZone : null, !(!i2 || !("datesInUnknownTimezone" in i2)) && !!i2.datesInUnknownTimezone, n, L, "date"), f = { ...L, ...s2 }, d = t[u];
  if ("number" == typeof d) {
    const e3 = t[l2];
    return { type: "edit", date: b(d, f), user: e3 };
  }
  const c3 = t[a];
  if ("number" == typeof c3) {
    const e3 = t[o];
    return { type: "create", date: b(c3, f), user: e3 };
  }
  return null;
}
function se(e2, t) {
  const n = /* @__PURE__ */ new Map();
  if (!e2) return n;
  for (const r2 of e2) {
    if (!r2.fieldName) continue;
    const e3 = z(r2.fieldName, t);
    r2.fieldName = e3, n.set(e3.toLowerCase(), r2);
  }
  return n;
}
function fe(e2) {
  const t = [];
  if (!e2) return t;
  const { fieldInfos: n, content: r2 } = e2;
  return n && t.push(...n), r2 && Array.isArray(r2) ? (r2.forEach((e3) => {
    if ("fields" === e3.type) {
      const n2 = e3?.fieldInfos;
      n2 && t.push(...n2);
    }
  }), t) : t;
}
function de(e2) {
  return e2.replaceAll(j, (e3) => `&#${e3.charCodeAt(0)};`);
}
function ce(e2) {
  return "string" == typeof e2 ? e2.replaceAll(N2, '<br class="esri-text-new-line" />') : e2;
}
function pe(e2) {
  const { fieldInfoMap: t, fieldInfos: n, fieldName: r2, graphic: i2, isContentFieldInfos: o, layer: a, timeZone: l2, value: u } = e2;
  if (null == u) return "";
  const s2 = le({ fieldName: r2, value: u, graphic: i2, layer: a });
  if (s2) return s2;
  const d = ae({ fieldName: r2, graphic: i2, layer: a });
  if (d) return d;
  if (t.get(r2.toLowerCase())) return ne(u, { fieldInfos: n || Array.from(t.values()), fieldName: r2, graphic: i2, isContentFieldInfos: o, layer: a, timeZone: l2 });
  const c3 = a?.fieldsIndex?.get(r2);
  return c3 && (U(c3) || xe(c3)) ? x(u, { fieldType: c3.type, timeZoneOptions: { layerTimeZone: a && "preferredTimeZone" in a ? a.preferredTimeZone : null, viewTimeZone: l2, datesInUnknownTimezone: !(!a || !("datesInUnknownTimezone" in a)) && !!a.datesInUnknownTimezone } }) : ce(u);
}
function ye({ attributes: e2, fieldInfoMap: t, fieldInfos: n, graphic: r2, isContentFieldInfos: i2, layer: o, relatedInfos: a, timeZone: l2 }) {
  const u = {};
  return a?.forEach((e3) => Te({ attributes: u, relatedInfo: e3, fieldInfoMap: t, fieldInfos: n, layer: o, timeZone: l2 })), e2 && Object.keys(e2).forEach((a2) => {
    const s2 = e2[a2];
    u[a2] = pe({ fieldInfoMap: t, fieldInfos: n, fieldName: a2, graphic: r2, isContentFieldInfos: i2, layer: o, timeZone: l2, value: s2 });
  }), u;
}
async function me(e2, t) {
  const { layer: n, graphic: r2, outFields: i2, objectIds: o, returnGeometry: a, spatialReference: l2 } = e2, u = o[0];
  if ("number" != typeof u && "string" != typeof u) {
    const e3 = "Could not query required fields for the specified feature. The feature's ID is invalid.", t2 = { layer: n, graphic: r2, objectId: u, requiredFields: i2 };
    return b2().warn(e3, t2), null;
  }
  if (!G(n)?.operations?.supportsQuery) {
    const e3 = "The specified layer cannot be queried. The following fields will not be available.", t2 = { layer: n, graphic: r2, requiredFields: i2, returnGeometry: a };
    return b2().warn(e3, t2), null;
  }
  const s2 = n.createQuery();
  s2.objectIds = o, s2.outFields = i2?.length ? i2 : [n.objectIdField], s2.returnGeometry = !!a, s2.returnZ = !!a, s2.returnM = !!a, s2.outSpatialReference = l2;
  return (await n.queryFeatures(s2, t)).features[0];
}
async function ge(e2) {
  if (!e2.expressionInfos?.length) return false;
  const t = await e(), { arcadeUtils: { hasGeometryFunctions: n } } = t;
  return n(e2);
}
async function Ie(e2) {
  if (!e2.expressionInfos?.length) return false;
  const t = await e(), { arcadeUtils: { requiresTrack: n } } = t;
  return n(e2);
}
async function be({ graphic: e2, popupTemplate: t, layer: n, spatialReference: r2 }, i2) {
  if (!n || !t) return;
  if ("function" == typeof n.load && await n.load(i2), !e2.attributes) return;
  const o = n.objectIdField, a = e2.attributes[o];
  if (null == a) return;
  const l2 = [a], u = new Set(await t.getRequiredFields(n.fieldsIndex));
  null == n.timeInfo?.trackIdField || u.has(n.timeInfo.trackIdField) || await Ie(t) && u.add(n.timeInfo.trackIdField);
  const f = ke(e2, u), d = f ? [] : u.has(o) ? [...u] : [...u, o], c3 = t.returnGeometry || await ge(t);
  if (f && !c3) return;
  const p = await me({ layer: n, graphic: e2, outFields: d, objectIds: l2, returnGeometry: c3, spatialReference: r2 }, i2);
  p && (p.geometry && (e2.geometry = p.geometry), p.attributes && (e2.attributes = { ...e2.attributes, ...p.attributes }));
}
function he(e2 = "") {
  return !!e2 && e2.includes(v);
}
function Fe(e2) {
  return e2 ? `${v}${e2.layerId}/${e2.fieldName}` : "";
}
function we({ attributes: e2, graphic: t, relatedInfo: n, fieldInfos: r2, fieldInfoMap: i2, layer: o, timeZone: a }) {
  e2 && t && n && Object.keys(t.attributes).forEach((l2) => {
    const u = Fe({ layerId: n.relation.id.toString(), fieldName: l2 }), s2 = t.attributes[l2];
    e2[u] = pe({ fieldName: u, fieldInfos: r2, fieldInfoMap: i2, layer: o, value: s2, graphic: t, timeZone: a });
  });
}
function Te({ attributes: e2, relatedInfo: t, fieldInfoMap: n, fieldInfos: r2, layer: i2, timeZone: o }) {
  e2 && t && (t.relatedFeatures?.forEach((a) => we({ attributes: e2, graphic: a, relatedInfo: t, fieldInfoMap: n, fieldInfos: r2, layer: i2, timeZone: o })), t.relatedStatsFeatures?.forEach((a) => we({ attributes: e2, graphic: a, relatedInfo: t, fieldInfoMap: n, fieldInfos: r2, layer: i2, timeZone: o })));
}
var Ne = (e2) => {
  if (!e2) return false;
  const t = e2.toUpperCase();
  return t.includes("CURRENT_TIMESTAMP") || t.includes("CURRENT_DATE") || t.includes("CURRENT_TIME");
};
var je = ({ layer: e2, method: t, query: n, definitionExpression: r2 }) => {
  if (!e2.capabilities?.query?.supportsCacheHint || "attachments" === t) return;
  const i2 = null != n.where ? n.where : null, o = null != n.geometry ? n.geometry : null;
  Ne(r2) || Ne(i2) || "extent" === o?.type || "tile" === n.resultType || (n.cacheHint = true);
};
var Ce = ({ query: e2, layer: t, method: n }) => {
  je({ layer: t, method: n, query: e2, definitionExpression: `${t.definitionExpression} ${t.serviceDefinitionExpression ?? ""}` });
};
var Ze = ({ queryPayload: e2, layer: t, method: n }) => {
  je({ layer: t, method: n, query: e2, definitionExpression: `${t.definitionExpression} ${t.serviceDefinitionExpression ?? ""}` });
};
function ve(e2, t, n) {
  return e2 && t && n ? "sublayer" === t.type ? qe2({ layers: t.layer?.allSublayers, map: e2, relatedLayer: t, relationship: n }) || qe2({ layers: t.layer?.subtables, map: e2, relatedLayer: t, relationship: n }) : qe2({ layers: e2.allLayers, map: e2, relatedLayer: t, relationship: n }) || qe2({ layers: e2.allTables, map: e2, relatedLayer: t, relationship: n }) : null;
}
function Le(e2, t) {
  return e2 && "utilityNetworks" in e2 && t ? e2.utilityNetworks?.find((e3) => e3.isUtilityLayer(t)) : null;
}
function xe2(e2, t) {
  return e2?.allTables.find((e3) => "feature" === e3.type && e3.layerId === t.id && e3.url === t.layer?.url);
}
function qe2({ map: e2, relationship: t, relationship: { relatedTableId: n }, relatedLayer: r2, layers: i2 }) {
  if (!i2) return null;
  for (const o of i2) {
    if ("map-image" === o.type) {
      const n2 = qe2({ layers: o.sublayers, map: e2, relatedLayer: r2, relationship: t }) || qe2({ layers: o.subtables, map: e2, relatedLayer: r2, relationship: t });
      if (n2) return n2;
      continue;
    }
    if (!Y(o)) continue;
    if ("sublayer" === r2.type) {
      if (o !== r2 && o.id === n) return o.isTable ? xe2(e2, o) : o;
      continue;
    }
    const i3 = "scene" === r2.type && r2.associatedLayer ? r2.associatedLayer.url : r2.url;
    if (!i3) return null;
    if ("sublayer" !== o.type) {
      if (o !== r2 && o.url === i3 && o.layerId === n) return o;
    } else if (o !== r2 && o.layer?.url === i3 && o.id === n) return o.isTable ? xe2(e2, o) : o;
  }
  return null;
}

export {
  x2 as x,
  q,
  A,
  U2 as U,
  M,
  k,
  R,
  z,
  O,
  Q,
  P,
  B,
  V,
  X,
  Y,
  ee,
  te,
  ne,
  oe,
  ue,
  se,
  fe,
  de,
  ce,
  ye,
  me,
  be,
  he,
  Ce,
  Ze,
  ve,
  Le
};
//# sourceMappingURL=chunk-VJ5FUG6T.js.map
