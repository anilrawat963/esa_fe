import {
  Os,
  ee,
  m,
  pm,
  ur
} from "./chunk-RKVVFTIZ.js";
import {
  t
} from "./chunk-WJ5RYEGC.js";
import {
  P,
  Pt,
  a,
  f,
  h,
  j,
  kt,
  l,
  mi,
  z
} from "./chunk-ZNI54T6D.js";
import {
  __addDisposableResource,
  __disposeResources
} from "./chunk-SS5CLIUY.js";

// node_modules/@arcgis/core/chunks/OperatorGeneralize.js
var P2 = class {
  getOperatorType() {
    return 10204;
  }
  supportsCurves() {
    return true;
  }
  accelerateGeometry(t2, e, s) {
    return false;
  }
  canAccelerateGeometry(t2) {
    return false;
  }
  executeMany(t2, e, s, i) {
    return new y(t2, e, s, i);
  }
  execute(t2, e, s, r) {
    t2 || P("null param is not allowed.");
    return new y(null, e, s, r).generalize(t2);
  }
};
var y = class extends t {
  constructor(t2, e, s, i) {
    super(), this.m_pline = null, this.m_point = new ee(), this.m_stack = [], this.m_resultstack = [], this.m_callCount = 0, this.m_progressTracker = i, this.m_geoms = t2, this.m_maxDeviation = e, this.m_bRemoveDegenerateParts = s;
  }
  tock() {
    return true;
  }
  getRank() {
    return 1;
  }
  next() {
    const t2 = this.m_geoms.next();
    return null === t2 ? null : (j(t2), this.generalize(t2));
  }
  getGeometryID() {
    return this.m_geoms.getGeometryID();
  }
  generalize(s) {
    const i = s.getGeometryType();
    if (l(i)) return s;
    if (i === a.enumEnvelope) {
      const t2 = new ur({ vd: s.getDescription() });
      return t2.addEnvelope(s, false), this.generalize(t2);
    }
    if (f(i)) {
      const t2 = new Os({ vd: s.getDescription() });
      return t2.addSegment(s, true), this.generalize(t2);
    }
    if (h(i) || z(""), s.isEmpty() || this.m_maxDeviation <= 0) return s;
    const r = new m().execute(s, 0, 0.05 * this.m_maxDeviation, 0, this.m_progressTracker);
    s.hasNonLinearSegments() && (this.m_maxDeviation *= 0.95);
    const _ = r, p = s.createInstance();
    if (p.getGeometryType() === a.enumPolygon) {
      p.setFillRule(s.getFillRule());
    }
    this.m_xy = _.getAttributeStreamRef(0);
    {
      const s2 = { stack: [], error: void 0, hasError: false };
      try {
        const e = new pm();
        this.m_pline = e, __addDisposableResource(s2, kt(() => {
          this.m_pline = null;
        }, false), false);
        for (let t2 = 0, s3 = _.getPathCount(); t2 < s3; t2++) this.generalizePath(_.getImpl(), t2, p.getImpl());
      } catch (k) {
        s2.error = k, s2.hasError = true;
      } finally {
        __disposeResources(s2);
      }
    }
    return this.m_resultstack.length = 0, this.m_stack.length = 0, p;
  }
  generalizePath(t2, e, s) {
    if (t2.getPathSize(e) < 2) return;
    this.m_resultstack.length = 0, this.m_stack.length = 0;
    const i = t2.getPathStart(e), r = t2.getPathEnd(e) - 1, n = t2.isClosedPath(e), a2 = t2.isClosedPathInXYPlane(e);
    let h2 = 0, m2 = -1;
    this.m_stack.push(n ? i : r), this.m_stack.push(i);
    let l2 = false, o = false;
    for (!this.m_bRemoveDegenerateParts && a2 && (l2 = true, o = true); this.m_stack.length > 1; ) {
      const e2 = this.m_stack.at(-1);
      this.m_stack.pop();
      const s2 = this.m_stack.at(-1);
      let i2 = t2.getXY(e2);
      this.m_pline.setStartXY(i2), i2 = t2.getXY(s2), this.m_pline.setEndXY(i2);
      const n2 = [Number.NaN];
      let a3 = this.findGreatestDistance(e2, s2, r, n2);
      a3 >= 0 && (l2 ? l2 = false : (o && n2[0] > h2 && (h2 = n2[0], m2 = a3), n2[0] <= this.m_maxDeviation && (a3 = -1))), a3 >= 0 ? (this.m_stack.push(a3), this.m_stack.push(e2)) : this.m_resultstack.push(e2);
    }
    n || this.m_resultstack.push(this.m_stack[0]);
    const c = this.m_resultstack.length;
    if (c === t2.getPathSize(e) && c === this.m_stack.length) s.addPath(t2, e, true);
    else if (this.m_resultstack.length > 0) {
      if (this.m_bRemoveDegenerateParts && this.m_resultstack.length <= 2) {
        if (n || 1 === this.m_resultstack.length) return;
        if (mi.distance(t2.getXY(this.m_resultstack[0]), t2.getXY(this.m_resultstack[1])) <= this.m_maxDeviation) return;
      }
      if (o && m2 >= 0 && h2 <= this.m_maxDeviation) {
        const t3 = this.m_resultstack.at(-1) > m2;
        this.m_resultstack.push(m2), t3 && (this.m_resultstack[this.m_resultstack.length - 2] = Pt(this.m_resultstack[this.m_resultstack.length - 1], this.m_resultstack[this.m_resultstack.length - 1] = this.m_resultstack[this.m_resultstack.length - 2]));
      }
      for (let e2 = 0, i2 = this.m_resultstack.length; e2 < i2; e2++) t2.getPointByVal(this.m_resultstack[e2], this.m_point), 0 === e2 ? s.startPathPoint(this.m_point) : s.lineToPoint(this.m_point);
      if (n) {
        for (let t3 = this.m_resultstack.length; t3 < 3; t3++) s.lineToPoint(this.m_point);
        s.closePathWithLine();
      }
    }
  }
  findGreatestDistance(t2, e, s, i) {
    let r = e - 1;
    e <= t2 && (r = s);
    let n = -1, a2 = 0;
    const h2 = new mi();
    for (let m2 = t2 + 1; m2 <= r; m2++) {
      this.m_xy.queryPoint2D(2 * m2, h2);
      const t3 = h2.x, e2 = h2.y, s2 = this.m_pline.getClosestCoordinate(h2, false);
      h2.assign(this.m_pline.getCoord2D(s2)), h2.x -= t3, h2.y -= e2;
      const i2 = h2.length();
      i2 > a2 && (n = m2, a2 = i2), this.m_callCount++;
    }
    return i[0] = a2, n;
  }
};

export {
  P2 as P
};
//# sourceMappingURL=chunk-MXO776UN.js.map
