import {
  c2 as c,
  u
} from "./chunk-CJAJ4FML.js";
import {
  q
} from "./chunk-SMWUT52Z.js";
import {
  o
} from "./chunk-65HD3WXL.js";

// node_modules/@arcgis/core/layers/support/rasterFunctions/pixelUtils.js
var l = 9;
var i = "PixelID";
function o2(t) {
  return null != t && t.pixels?.length > 0;
}
function r(t) {
  if (!t?.length || t.some((t2) => !o2(t2))) return null;
  if (1 === t.length) return t[0]?.clone() ?? null;
  const n = t, { width: l3, height: i3, pixelType: s2 } = n[0];
  if (n.some((t2) => t2.width !== l3 || t2.height !== i3)) return null;
  const r3 = n.map(({ mask: t2 }) => t2).filter((t2) => null != t2);
  let a3 = null;
  r3.length && (a3 = new Uint8Array(l3 * i3), a3.set(r3[0]), r3.length > 1 && y(r3.slice(1), a3));
  const h3 = [];
  n.forEach(({ pixels: t2 }) => h3.push(...t2));
  const f3 = n.map(({ statistics: t2 }) => t2).filter((t2) => t2?.length), c4 = [];
  return f3.forEach((t2) => c4.push(...t2)), new c({ pixelType: s2, width: l3, height: i3, mask: a3, pixels: h3, statistics: c4.length ? c4 : null });
}
function a(t) {
  if (!t) return;
  const e = t.colormap;
  if (!e || 0 === e.length) return;
  const n = e.sort((t2, e2) => t2[0] - e2[0]), l3 = n[0][0] < 0 ? n[0][0] : 0, i3 = Math.max(256, n[n.length - 1][0] - l3 + 1), o4 = new Uint8Array(4 * i3), s2 = [], r3 = 5 === n[0].length;
  if (i3 > 65536) return n.forEach((t2) => {
    s2[t2[0] - l3] = r3 ? t2.slice(1) : t2.slice(1).concat([255]);
  }), { indexed2DColormap: s2, offset: l3, alphaSpecified: r3 };
  if (t.fillUnspecified) {
    let t2 = n[0];
    for (let e2 = t2[0] - l3, s3 = 0; e2 < i3; e2++) o4[4 * e2] = t2[1], o4[4 * e2 + 1] = t2[2], o4[4 * e2 + 2] = t2[3], o4[4 * e2 + 3] = r3 ? t2[4] : 255, e2 === t2[0] - l3 && (t2 = s3 === n.length - 1 ? t2 : n[++s3]);
  } else for (let a3 = 0; a3 < n.length; a3++) {
    const t2 = n[a3], e2 = 4 * (t2[0] - l3);
    o4[e2] = t2[1], o4[e2 + 1] = t2[2], o4[e2 + 2] = t2[3], o4[e2 + 3] = r3 ? t2[4] : 255;
  }
  return { indexedColormap: o4, offset: l3, alphaSpecified: r3 };
}
function h(t, e) {
  if (!o2(t)) return t;
  if (!e || !e.indexedColormap && !e.indexed2DColormap) return t;
  const n = t.clone(), l3 = n.pixels;
  let i3 = n.mask;
  const s2 = n.width * n.height;
  if (1 !== l3.length) return t;
  const { indexedColormap: r3, indexed2DColormap: a3, offset: h3, alphaSpecified: f3 } = e, c4 = l3[0], u4 = new Uint8Array(c4.length), p3 = new Uint8Array(c4.length), x3 = new Uint8Array(c4.length);
  let m3, d3 = 0;
  if (r3) {
    const t2 = r3.length - 1;
    if (null != i3) for (let e2 = 0; e2 < s2; e2++) i3[e2] && (d3 = 4 * (c4[e2] - h3), d3 < h3 || d3 > t2 ? i3[e2] = 0 : (u4[e2] = r3[d3], p3[e2] = r3[d3 + 1], x3[e2] = r3[d3 + 2], i3[e2] = r3[d3 + 3]));
    else {
      i3 = new Uint8Array(s2);
      for (let e2 = 0; e2 < s2; e2++) d3 = 4 * (c4[e2] - h3), d3 < h3 || d3 > t2 ? i3[e2] = 0 : (u4[e2] = r3[d3], p3[e2] = r3[d3 + 1], x3[e2] = r3[d3 + 2], i3[e2] = r3[d3 + 3]);
      n.mask = i3;
    }
  } else if (a3) if (null != i3) for (let o4 = 0; o4 < s2; o4++) i3[o4] && (m3 = a3[c4[o4]], u4[o4] = m3[0], p3[o4] = m3[1], x3[o4] = m3[2], i3[o4] = m3[3]);
  else {
    i3 = new Uint8Array(s2);
    for (let t2 = 0; t2 < s2; t2++) m3 = a3[c4[t2]], u4[t2] = m3[0], p3[t2] = m3[1], x3[t2] = m3[2], i3[t2] = m3[3];
    n.mask = i3;
  }
  return n.pixels = [u4, p3, x3], n.statistics = null, n.pixelType = "u8", n.maskIsAlpha = f3, n;
}
function f(t, n) {
  if (!o2(t)) return null;
  const { pixels: l3, mask: i3 } = t, s2 = l3.length;
  let r3 = n.lut;
  const { offset: a3 } = n;
  r3 && 1 === r3[0].length && (r3 = l3.map(() => r3));
  const h3 = [], f3 = n.outputPixelType || "u8";
  for (let e = 0; e < s2; e++) {
    const t2 = c2(l3[e], i3, r3[e], a3 || 0, f3);
    h3.push(t2);
  }
  const u4 = new c({ width: t.width, height: t.height, pixels: h3, mask: i3, pixelType: f3 });
  return u4.updateStatistics(), u4;
}
function c2(t, n, l3, i3, o4) {
  const s2 = t.length, r3 = c.createEmptyBand(o4, s2);
  if (n) for (let e = 0; e < s2; e++) n[e] && (r3[e] = l3[t[e] - i3]);
  else for (let e = 0; e < s2; e++) r3[e] = l3[t[e] - i3];
  return r3;
}
function u2(t, e, n) {
  if (!o2(t)) return;
  const { width: l3, height: i3, pixels: s2, mask: r3 } = t, a3 = l3 * i3, h3 = new Uint8Array(a3);
  for (let o4 = 1; o4 <= n.length; o4++) {
    const { bandId: t2, ranges: e2 } = n[o4 - 1], l4 = s2[t2];
    if (!l4) continue;
    const i4 = 1 === e2.length, [f4, c5] = e2[0];
    for (let n2 = 0; n2 < a3; n2++) if (!r3 || r3[n2]) {
      const t3 = l4[n2];
      if (i4) t3 >= f4 && t3 <= c5 && (h3[n2] = o4);
      else for (let l5 = 0; l5 < e2.length; l5++) {
        const [i5, s3] = e2[l5];
        if (t3 >= i5 && t3 <= s3) {
          h3[n2] = o4;
          break;
        }
      }
    }
  }
  const { pixels: f3 } = e;
  1 === f3.length && (f3[1] = f3[0].slice(), f3[2] = f3[0].slice());
  const c4 = n.map((t2) => t2.color);
  if (e.mask) {
    const t2 = e.mask;
    for (let e2 = 0; e2 < a3; e2++) if (t2[e2]) {
      t2[e2] = 255;
      const n2 = h3[e2];
      if (n2) {
        const l4 = c4[n2 - 1];
        f3[0][e2] = l4[0], f3[1][e2] = l4[1], f3[2][e2] = l4[2], t2[e2] = l4[3];
      }
    }
  } else {
    const t2 = new Uint8Array(a3).fill(255);
    for (let e2 = 0; e2 < a3; e2++) {
      const n2 = h3[e2];
      if (n2) {
        const l4 = c4[n2 - 1];
        f3[0][e2] = l4[0], f3[1][e2] = l4[1], f3[2][e2] = l4[2], t2[e2] = l4[3];
      }
    }
    e.mask = t2;
  }
  e.maskIsAlpha = true;
}
function p(t, e) {
  if (!o2(t)) return null;
  const n = t.clone(), { pixels: l3 } = n, i3 = n.width * n.height, s2 = e.length, r3 = Math.floor(s2 / 2), a3 = e[Math.floor(r3)], h3 = l3[0], f3 = new Uint8Array(i3), c4 = new Uint8Array(i3), u4 = new Uint8Array(i3);
  let p3 = n.mask;
  const x3 = 4 === e[0].mappedColor.length;
  p3 || (p3 = new Uint8Array(i3), p3.fill(x3 ? 255 : 1), n.mask = p3);
  for (let o4 = 0; o4 < i3; o4++) if (p3[o4]) {
    const t2 = h3[o4];
    let n2 = false, l4 = r3, i4 = a3, x4 = 0, m3 = s2 - 1;
    for (; m3 - x4 > 1; ) {
      if (t2 === i4.value) {
        n2 = true;
        break;
      }
      t2 > i4.value ? x4 = l4 : m3 = l4, l4 = Math.floor((x4 + m3) / 2), i4 = e[Math.floor(l4)];
    }
    n2 || (t2 === e[x4].value ? (i4 = e[x4], n2 = true) : t2 === e[m3].value ? (i4 = e[m3], n2 = true) : t2 < e[x4].value ? n2 = false : t2 > e[x4].value && (t2 < e[m3].value ? (i4 = e[x4], n2 = true) : m3 === s2 - 1 ? n2 = false : (i4 = e[m3], n2 = true))), n2 ? (f3[o4] = i4.mappedColor[0], c4[o4] = i4.mappedColor[1], u4[o4] = i4.mappedColor[2], p3[o4] = i4.mappedColor[3]) : f3[o4] = c4[o4] = u4[o4] = p3[o4] = 0;
  }
  return n.pixels = [f3, c4, u4], n.mask = p3, n.pixelType = "u8", n.maskIsAlpha = x3, n;
}
function x(e, n, i3 = false) {
  const o4 = 1e-5, s2 = new Float32Array(3 * l), r3 = n.length;
  for (let a3 = 0; a3 < l; a3++) s2[3 * a3] = e[2 * a3] ?? q - 1, s2[3 * a3 + 1] = e[2 * a3 + 1] ?? q, s2[3 * a3 + 2] = n[a3] ?? 0, a3 < r3 && (a3 > 0 && (s2[3 * a3] -= o4), e[2 * a3 + 1] !== e[2 * a3] && (a3 < r3 - 1 || !i3) && (s2[3 * a3 + 1] -= o4));
  return s2;
}
function m(t, l3) {
  if (!o2(t)) return null;
  const { width: i3, height: s2 } = t, { inputRanges: r3, outputValues: a3, outputPixelType: h3, noDataRanges: f3, allowUnmatched: c4, replacementValue: u4, isLastInputRangeInclusive: p3 } = l3, x3 = t.pixels[0], m3 = c.createEmptyBand(h3, x3.length), d3 = t.mask, g3 = new Uint8Array(i3 * s2);
  d3 ? g3.set(d3) : g3.fill(255);
  const y3 = t.pixelType.startsWith("f") ? 1e-6 : 0, w3 = r3.map((t2) => t2 - y3);
  w3[0] = r3[0], w3[w3.length - 1] = r3[r3.length - 1] + (p3 ? 1e-6 : 0);
  const k3 = r3.length / 2, [M3, A3] = u(h3);
  for (let e = 0; e < s2; e++) for (let t2 = 0; t2 < i3; t2++) {
    const n = e * i3 + t2;
    if (g3[n]) {
      const t3 = x3[n];
      let e2 = false;
      for (let l4 = k3 - 1; l4 >= 0; l4--) if (t3 === r3[2 * l4] || t3 > w3[2 * l4] && t3 < w3[2 * l4 + 1]) {
        m3[n] = a3[l4], e2 = true;
        break;
      }
      e2 || (c4 ? m3[n] = t3 > A3 ? A3 : t3 < M3 ? M3 : u4 ?? t3 : g3[n] = 0);
    }
  }
  const U3 = f3?.length;
  if (U3) for (let e = 0; e < s2; e++) for (let t2 = 0; t2 < i3; t2++) {
    const n = e * i3 + t2;
    if (!d3 || d3[n]) {
      const t3 = x3[n];
      for (let e2 = 0; e2 < U3; e2 += 2) if (t3 >= f3[e2] && t3 <= f3[e2 + 1]) {
        m3[n] = 0, g3[n] = 0;
        break;
      }
    }
  }
  return new c({ width: i3, height: s2, pixelType: h3, pixels: [m3], mask: g3 });
}
function d(t, e, n, l3) {
  const i3 = null != n && n.length >= 2 ? new Set(n) : null, o4 = 1 === n?.length ? n[0] : null, s2 = !!e?.length;
  for (let r3 = 0; r3 < t.length; r3++) if (l3[r3]) {
    const n2 = t[r3];
    if (s2) {
      let t2 = false;
      for (let l4 = 0; l4 < e.length; l4 += 2) if (n2 >= e[l4] && n2 <= e[l4 + 1]) {
        t2 = true;
        break;
      }
      t2 || (l3[r3] = 0);
    }
    l3[r3] && (n2 === o4 || i3?.has(n2)) && (l3[r3] = 0);
  }
}
function g(t, e) {
  const n = t[0].length;
  for (let l3 = 0; l3 < n; l3++) if (e[l3]) {
    let n2 = false;
    for (let e2 = 0; e2 < t.length; e2++) if (t[e2][l3]) {
      n2 = true;
      break;
    }
    n2 || (e[l3] = 0);
  }
}
function y(t, e) {
  const n = t[0].length;
  for (let l3 = 0; l3 < n; l3++) if (e[l3]) {
    let n2 = false;
    for (let e2 = 0; e2 < t.length; e2++) if (0 === t[e2][l3]) {
      n2 = true;
      break;
    }
    n2 && (e[l3] = 0);
  }
}
function w(t, n) {
  if (!o2(t)) return null;
  const { width: l3, height: i3, pixels: s2 } = t, r3 = l3 * i3, a3 = new Uint8Array(r3);
  t.mask ? a3.set(t.mask) : a3.fill(255);
  const h3 = s2.length, { includedRanges: f3, noDataValues: u4, outputPixelType: p3, matchAll: x3, lookups: m3 } = n;
  if (m3) {
    const t2 = [];
    for (let e = 0; e < h3; e++) {
      const n2 = m3[e], l4 = c2(s2[e], a3, n2.lut, n2.offset || 0, "u8");
      t2.push(l4);
    }
    1 === t2.length ? a3.set(t2[0]) : x3 ? g(t2, a3) : y(t2, a3);
  } else if (x3) {
    const t2 = [];
    for (let e = 0; e < h3; e++) {
      const n2 = new Uint8Array(r3);
      n2.set(a3), d(s2[e], f3?.slice(2 * e, 2 * e + 2), u4?.[e], n2), t2.push(n2);
    }
    1 === t2.length ? a3.set(t2[0]) : g(t2, a3);
  } else for (let e = 0; e < h3; e++) d(s2[e], f3?.slice(2 * e, 2 * e + 2), u4?.[e], a3);
  return new c({ width: l3, height: i3, pixelType: p3, pixels: s2, mask: a3 });
}
function k(t) {
  const { srcPixelType: l3, inputRanges: i3, outputValues: o4, allowUnmatched: s2, noDataRanges: r3, isLastInputRangeInclusive: a3, outputPixelType: h3 } = t;
  if ("u8" !== l3 && "s8" !== l3 && "u16" !== l3 && "s16" !== l3) return null;
  const f3 = l3.includes("16") ? 65536 : 256, c4 = l3.includes("s") ? -f3 / 2 : 0, u4 = c.createEmptyBand(h3, f3), p3 = new Uint8Array(f3);
  s2 && p3.fill(255);
  const [x3, m3] = u(h3);
  if (i3?.length && o4?.length) {
    const t2 = 1e-6, e = i3.map((e2) => e2 - t2);
    e[0] = i3[0], a3 && (e[e.length - 1] = i3[i3.length - 1]);
    for (let n = 0; n < e.length; n++) {
      const t3 = o4[n] > m3 ? m3 : o4[n] < x3 ? x3 : o4[n], l4 = Math.ceil(e[2 * n] - c4), s3 = i3[2 * n + 1] === i3[2 * n] ? l4 : Math.floor(e[2 * n + 1] - c4);
      for (let e2 = l4; e2 <= s3; e2++) u4[e2] = t3, p3[e2] = 255;
    }
  }
  if (r3?.length) for (let e = 0; e < r3.length; e++) {
    const t2 = Math.ceil(r3[2 * e] - c4), n = Math.floor(r3[2 * e + 1] - c4);
    for (let e2 = t2; e2 <= n; e2++) p3[e2] = 0;
  }
  return { lut: u4, offset: c4, mask: p3 };
}
function M(t, e, n) {
  if ("u8" !== t && "s8" !== t && "u16" !== t && "s16" !== t) return null;
  const l3 = t.includes("16") ? 65536 : 256, i3 = t.includes("s") ? -l3 / 2 : 0, o4 = new Uint8Array(l3);
  if (e) for (let s2 = 0; s2 < e.length; s2++) {
    const t2 = Math.ceil(e[2 * s2] - i3), n2 = Math.floor(e[2 * s2 + 1] - i3);
    for (let e2 = t2; e2 <= n2; e2++) o4[e2] = 255;
  }
  else o4.fill(255);
  if (n) for (let s2 = 0; s2 < n.length; s2++) o4[n[s2] - i3] = 0;
  return { lut: o4, offset: i3 };
}
function A(t, e, n, l3, i3, o4, s2, r3) {
  return { xmin: i3 <= n * t ? 0 : i3 < n * t + t ? i3 - n * t : t, ymin: o4 <= l3 * e ? 0 : o4 < l3 * e + e ? o4 - l3 * e : e, xmax: i3 + s2 <= n * t ? 0 : i3 + s2 < n * t + t ? i3 + s2 - n * t : t, ymax: o4 + r3 <= l3 * e ? 0 : o4 + r3 < l3 * e + e ? o4 + r3 - l3 * e : e };
}
function U(t, e) {
  if (!t || 0 === t.length) return null;
  const n = t.find((t2) => t2.pixelBlock);
  if (null == n?.pixelBlock) return null;
  const l3 = (n.extent.xmax - n.extent.xmin) / n.pixelBlock.width, i3 = (n.extent.ymax - n.extent.ymin) / n.pixelBlock.height, o4 = 0.01 * Math.min(l3, i3), s2 = t.sort((t2, e2) => Math.abs(t2.extent.ymax - e2.extent.ymax) > o4 ? e2.extent.ymax - t2.extent.ymax : Math.abs(t2.extent.xmin - e2.extent.xmin) > o4 ? t2.extent.xmin - e2.extent.xmin : 0), r3 = Math.min.apply(null, s2.map((t2) => t2.extent.xmin)), a3 = Math.min.apply(null, s2.map((t2) => t2.extent.ymin)), h3 = Math.max.apply(null, s2.map((t2) => t2.extent.xmax)), f3 = Math.max.apply(null, s2.map((t2) => t2.extent.ymax)), c4 = { x: Math.round((e.xmin - r3) / l3), y: Math.round((f3 - e.ymax) / i3) }, u4 = { width: Math.round((h3 - r3) / l3), height: Math.round((f3 - a3) / i3) }, p3 = { width: Math.round((e.xmax - e.xmin) / l3), height: Math.round((e.ymax - e.ymin) / i3) };
  if (Math.round(u4.width / n.pixelBlock.width) * Math.round(u4.height / n.pixelBlock.height) !== s2.length || c4.x < 0 || c4.y < 0 || u4.width < p3.width || u4.height < p3.height) return null;
  return { extent: e, pixelBlock: T(s2.map((t2) => t2.pixelBlock), u4, { clipOffset: c4, clipSize: p3 }) };
}
function b(t, e, n, l3, i3, o4) {
  const { width: s2, height: r3 } = n.block, { x: a3, y: h3 } = n.offset, { width: f3, height: c4 } = n.mosaic, u4 = A(s2, r3, l3, i3, a3, h3, f3, c4);
  let p3 = 0, x3 = 0;
  if (o4) {
    const t2 = o4.hasGCSSShiftTransform ? 360 : o4.halfWorldWidth ?? 0, e2 = s2 * o4.resolutionX, n2 = o4.startX + l3 * e2;
    n2 < t2 && n2 + e2 > t2 ? x3 = o4.rightPadding : n2 >= t2 && (p3 = o4.leftMargin - o4.rightPadding, x3 = 0);
  }
  if (u4.xmax -= x3, "number" != typeof e) for (let m3 = u4.ymin; m3 < u4.ymax; m3++) {
    const n2 = (i3 * r3 + m3 - h3) * f3 + (l3 * s2 - a3) + p3, o5 = m3 * s2;
    for (let l4 = u4.xmin; l4 < u4.xmax; l4++) t[n2 + l4] = e[o5 + l4];
  }
  else for (let m3 = u4.ymin; m3 < u4.ymax; m3++) {
    const n2 = (i3 * r3 + m3 - h3) * f3 + (l3 * s2 - a3) + p3;
    for (let l4 = u4.xmin; l4 < u4.xmax; l4++) t[n2 + l4] = e;
  }
}
function T(t, n, l3 = {}) {
  const { clipOffset: i3, clipSize: s2, alignmentInfo: r3, blockWidths: a3 } = l3;
  if (a3) return S(t, n, { blockWidths: a3 });
  const h3 = t.find((t2) => o2(t2));
  if (null == h3) return null;
  const f3 = s2 ? s2.width : n.width, c4 = s2 ? s2.height : n.height, u4 = h3.width, p3 = h3.height, x3 = n.width / u4, m3 = n.height / p3, d3 = { offset: i3 || { x: 0, y: 0 }, mosaic: s2 || n, block: { width: u4, height: p3 } }, g3 = h3.pixelType, y3 = c.getPixelArrayConstructor(g3), w3 = h3.pixels.length, k3 = [];
  let M3, A3;
  for (let e = 0; e < w3; e++) {
    A3 = new y3(f3 * c4);
    for (let n2 = 0; n2 < m3; n2++) for (let l4 = 0; l4 < x3; l4++) {
      const i4 = t[n2 * x3 + l4];
      o2(i4) && (M3 = i4.pixels[e], b(A3, M3, d3, l4, n2, r3));
    }
    k3.push(A3);
  }
  const U3 = t.some((t2) => null == t2 || null != t2.mask && t2.mask.length > 0), T2 = t.some((t2) => t2?.bandMasks && t2.bandMasks.length > 1), v3 = U3 ? new Uint8Array(f3 * c4) : void 0, B2 = T2 ? [] : void 0;
  if (v3) {
    for (let e = 0; e < m3; e++) for (let n2 = 0; n2 < x3; n2++) {
      const l4 = t[e * x3 + n2], i4 = null != l4 ? l4.mask : null;
      b(v3, null != i4 ? i4 : l4 ? 255 : 0, d3, n2, e, r3);
    }
    if (B2) for (let e = 0; e < w3; e++) {
      const n2 = new Uint8Array(f3 * c4);
      for (let l4 = 0; l4 < m3; l4++) for (let i4 = 0; i4 < x3; i4++) {
        const o4 = t[l4 * x3 + i4], s3 = o4?.bandMasks?.[e] ?? o4?.mask;
        b(n2, null != s3 ? s3 : o4 ? 255 : 0, d3, i4, l4, r3);
      }
      B2.push(n2);
    }
  }
  const C2 = new c({ width: f3, height: c4, pixels: k3, pixelType: g3, bandMasks: B2, mask: v3 });
  return C2.updateStatistics(), C2;
}
function S(t, n, l3) {
  const i3 = t.find((t2) => null != t2);
  if (null == i3) return null;
  const s2 = t.some((t2) => null == t2 || !!t2.mask), { width: r3, height: a3 } = n, h3 = s2 ? new Uint8Array(r3 * a3) : null, { blockWidths: f3 } = l3, c4 = [], u4 = i3.getPlaneCount(), p3 = c.getPixelArrayConstructor(i3.pixelType);
  if (s2) for (let e = 0, y3 = 0; e < t.length; y3 += f3[e], e++) {
    const n2 = t[e];
    if (!o2(n2)) continue;
    const l4 = n2.mask;
    for (let t2 = 0; t2 < a3; t2++) for (let i4 = 0; i4 < f3[e]; i4++) h3[t2 * r3 + i4 + y3] = null == l4 ? 255 : l4[t2 * n2.width + i4];
  }
  const x3 = t.some((t2) => t2?.bandMasks && t2.bandMasks.length > 1), m3 = x3 ? [] : void 0, d3 = r3 * a3;
  for (let e = 0; e < u4; e++) {
    const n2 = new p3(d3), l4 = x3 ? new Uint8Array(d3) : void 0;
    for (let i4 = 0, s3 = 0; i4 < t.length; s3 += f3[i4], i4++) {
      const h4 = t[i4];
      if (!o2(h4)) continue;
      const c5 = h4.pixels[e];
      if (null != c5) {
        for (let t2 = 0; t2 < a3; t2++) for (let e2 = 0; e2 < f3[i4]; e2++) n2[t2 * r3 + e2 + s3] = c5[t2 * h4.width + e2];
        if (l4) {
          const t2 = h4.bandMasks?.[e] ?? h4.mask;
          for (let e2 = 0; e2 < a3; e2++) for (let n3 = 0; n3 < f3[i4]; n3++) l4[e2 * r3 + n3 + s3] = t2 ? t2[e2 * h4.width + n3] : 255;
        }
      }
    }
    c4.push(n2), m3 && l4 && m3.push(l4);
  }
  const g3 = new c({ width: r3, height: a3, mask: h3, bandMasks: m3, pixels: c4, pixelType: i3.pixelType });
  return g3.updateStatistics(), g3;
}
function v(t, e, n) {
  if (!o2(t)) return null;
  const { width: l3, height: i3 } = t, s2 = e.x, r3 = e.y, a3 = n.width + s2, h3 = n.height + r3;
  if (s2 < 0 || r3 < 0 || a3 > l3 || h3 > i3) return t;
  if (0 === s2 && 0 === r3 && a3 === l3 && h3 === i3) return t;
  t.mask || (t.mask = new Uint8Array(l3 * i3));
  const f3 = t.mask;
  for (let o4 = 0; o4 < i3; o4++) {
    const t2 = o4 * l3;
    for (let e2 = 0; e2 < l3; e2++) f3[t2 + e2] = o4 < r3 || o4 >= h3 || e2 < s2 || e2 >= a3 ? 0 : 1;
  }
  return t.updateStatistics(), t;
}
function B(t) {
  if (!o2(t)) return null;
  const e = t.clone(), { width: n, height: l3, pixels: i3 } = t, s2 = i3[0], r3 = e.pixels[0], a3 = t.mask;
  for (let o4 = 2; o4 < l3 - 1; o4++) {
    const t2 = /* @__PURE__ */ new Map();
    for (let l4 = o4 - 2; l4 < o4 + 2; l4++) for (let e3 = 0; e3 < 4; e3++) {
      const i4 = l4 * n + e3;
      R(t2, s2[i4], a3 ? a3[i4] : 1);
    }
    r3[o4 * n] = C(t2), r3[o4 * n + 1] = r3[o4 * n + 2] = r3[o4 * n];
    let e2 = 3;
    for (; e2 < n - 1; e2++) {
      let l4 = (o4 - 2) * n + e2 + 1;
      R(t2, s2[l4], a3 ? a3[l4] : 1), l4 = (o4 - 1) * n + e2 + 1, R(t2, s2[l4], a3 ? a3[l4] : 1), l4 = o4 * n + e2 + 1, R(t2, s2[l4], a3 ? a3[l4] : 1), l4 = (o4 + 1) * n + e2 + 1, R(t2, s2[l4], a3 ? a3[l4] : 1), l4 = (o4 - 2) * n + e2 - 3, P(t2, s2[l4], a3 ? a3[l4] : 1), l4 = (o4 - 1) * n + e2 - 3, P(t2, s2[l4], a3 ? a3[l4] : 1), l4 = o4 * n + e2 - 3, P(t2, s2[l4], a3 ? a3[l4] : 1), l4 = (o4 + 1) * n + e2 - 3, P(t2, s2[l4], a3 ? a3[l4] : 1), r3[o4 * n + e2] = C(t2);
    }
    r3[o4 * n + e2 + 1] = r3[o4 * n + e2];
  }
  for (let o4 = 0; o4 < n; o4++) r3[o4] = r3[n + o4] = r3[2 * n + o4], r3[(l3 - 1) * n + o4] = r3[(l3 - 2) * n + o4];
  return e.updateStatistics(), e;
}
function C(t) {
  if (0 === t.size) return 0;
  let e = 0, n = -1, l3 = 0;
  const i3 = t.keys();
  let o4 = i3.next();
  for (; !o4.done; ) l3 = t.get(o4.value), l3 > e && (n = o4.value, e = l3), o4 = i3.next();
  return n;
}
function P(t, e, n) {
  if (0 === n) return;
  const l3 = t.get(e);
  1 === l3 ? t.delete(e) : t.set(e, l3 - 1);
}
function R(t, e, n) {
  0 !== n && t.set(e, t.has(e) ? t.get(e) + 1 : 1);
}
function I(t, n, l3) {
  let { x: i3, y: s2 } = n;
  const { width: r3, height: a3 } = l3;
  if (0 === i3 && 0 === s2 && a3 === t.height && r3 === t.width) return t;
  const { width: h3, height: f3 } = t, c4 = Math.max(0, s2), u4 = Math.max(0, i3), p3 = Math.min(i3 + r3, h3), x3 = Math.min(s2 + a3, f3);
  if (p3 < 0 || x3 < 0 || !o2(t)) return null;
  i3 = Math.max(0, -i3), s2 = Math.max(0, -s2);
  const { pixels: m3 } = t, d3 = r3 * a3, g3 = m3.length, y3 = [];
  for (let o4 = 0; o4 < g3; o4++) {
    const n2 = m3[o4], l4 = c.createEmptyBand(t.pixelType, d3);
    for (let t2 = c4; t2 < x3; t2++) {
      const e = t2 * h3;
      let o5 = (t2 + s2 - c4) * r3 + i3;
      for (let t3 = u4; t3 < p3; t3++) l4[o5++] = n2[e + t3];
    }
    y3.push(l4);
  }
  const w3 = new Uint8Array(d3), k3 = t.mask;
  for (let e = c4; e < x3; e++) {
    const t2 = e * h3;
    let n2 = (e + s2 - c4) * r3 + i3;
    for (let e2 = u4; e2 < p3; e2++) w3[n2++] = k3 ? k3[t2 + e2] : 1;
  }
  const M3 = new c({ width: l3.width, height: l3.height, pixelType: t.pixelType, pixels: y3, mask: w3 });
  return M3.updateStatistics(), M3;
}
function _(t, n = true) {
  if (!o2(t)) return null;
  const { pixels: l3, width: i3, height: s2, mask: r3, pixelType: a3 } = t, h3 = [], f3 = Math.round(i3 / 2), c4 = Math.round(s2 / 2), u4 = s2 - 1, p3 = i3 - 1;
  for (let o4 = 0; o4 < l3.length; o4++) {
    const t2 = l3[o4], r4 = c.createEmptyBand(a3, f3 * c4);
    let x4 = 0;
    for (let e = 0; e < s2; e += 2) for (let l4 = 0; l4 < i3; l4 += 2) {
      const o5 = t2[e * i3 + l4];
      if (n) {
        const n2 = l4 === p3 ? o5 : t2[e * i3 + l4 + 1], s3 = e === u4 ? o5 : t2[e * i3 + l4 + i3], a4 = l4 === p3 ? s3 : e === u4 ? n2 : t2[e * i3 + l4 + i3 + 1];
        r4[x4++] = (o5 + n2 + s3 + a4) / 4;
      } else r4[x4++] = o5;
    }
    h3.push(r4);
  }
  let x3 = null;
  if (null != r3) {
    x3 = new Uint8Array(f3 * c4);
    let t2 = 0;
    for (let e = 0; e < s2; e += 2) for (let l4 = 0; l4 < i3; l4 += 2) {
      const o4 = r3[e * i3 + l4];
      if (n) {
        const n2 = l4 === p3 ? o4 : r3[e * i3 + l4 + 1], s3 = e === u4 ? o4 : r3[e * i3 + l4 + i3], a4 = l4 === p3 ? s3 : e === u4 ? n2 : r3[e * i3 + l4 + i3 + 1];
        x3[t2++] = o4 * n2 * s3 * a4 ? 1 : 0;
      } else x3[t2++] = o4;
    }
  }
  return new c({ width: f3, height: c4, pixelType: a3, pixels: h3, mask: x3 });
}
function W(t, e, n = 0, l3 = true) {
  if (!o2(t)) return null;
  const { width: i3, height: s2 } = e;
  let { width: r3, height: a3 } = t;
  const h3 = /* @__PURE__ */ new Map(), f3 = { x: 0, y: 0 }, c4 = 1 + n;
  let u4 = t;
  for (let o4 = 0; o4 < c4; o4++) {
    const t2 = Math.ceil(r3 / i3), n2 = Math.ceil(a3 / s2);
    for (let l4 = 0; l4 < n2; l4++) {
      f3.y = l4 * s2;
      for (let n3 = 0; n3 < t2; n3++) {
        f3.x = n3 * i3;
        const t3 = I(u4, f3, e);
        h3.set(`${o4}/${l4}/${n3}`, t3);
      }
    }
    o4 < c4 - 1 && (u4 = _(u4, l3)), r3 = Math.round(r3 / 2), a3 = Math.round(a3 / 2);
  }
  return h3;
}
function E(t) {
  const { pixelBlock: e, tileSize: n, level: l3, row: i3, col: s2, useBilinear: r3 } = t;
  if (!o2(e)) return null;
  const { width: a3, height: h3 } = n, f3 = 2 ** l3, c4 = f3 * a3, u4 = f3 * h3;
  let p3 = I(e, { y: i3 * u4, x: s2 * c4 }, { width: c4, height: u4 });
  if (!p3) return null;
  for (let o4 = l3; o4 > 0; o4--) p3 = _(p3, r3);
  return p3;
}
function F(t, e, n, l3, i3 = 0) {
  const { width: o4, height: s2 } = t, { width: r3, height: a3 } = e, h3 = l3.cols, f3 = l3.rows, c4 = Math.ceil(r3 / h3 - 0.1 / h3), u4 = Math.ceil(a3 / f3 - 0.1 / f3);
  let p3, x3, m3, d3, g3, y3, w3;
  const k3 = c4 * h3, M3 = k3 * u4 * f3, A3 = new Float32Array(M3), U3 = new Float32Array(M3), b3 = new Uint32Array(M3), T2 = new Uint32Array(M3);
  let S3, v3, B2 = 0;
  for (let C2 = 0; C2 < u4; C2++) for (let t2 = 0; t2 < c4; t2++) {
    p3 = 12 * (C2 * c4 + t2), x3 = n[p3], m3 = n[p3 + 1], d3 = n[p3 + 2], g3 = n[p3 + 3], y3 = n[p3 + 4], w3 = n[p3 + 5];
    for (let e2 = 0; e2 < f3; e2++) {
      B2 = (C2 * f3 + e2) * k3 + t2 * h3, v3 = (e2 + 0.5) / f3;
      for (let t3 = 0; t3 < e2; t3++) S3 = (t3 + 0.5) / h3, A3[B2 + t3] = (x3 * S3 + m3 * v3 + d3) * o4 + i3, U3[B2 + t3] = (g3 * S3 + y3 * v3 + w3) * s2 + i3, b3[B2 + t3] = Math.floor(A3[B2 + t3]), T2[B2 + t3] = Math.floor(U3[B2 + t3]);
    }
    p3 += 6, x3 = n[p3], m3 = n[p3 + 1], d3 = n[p3 + 2], g3 = n[p3 + 3], y3 = n[p3 + 4], w3 = n[p3 + 5];
    for (let e2 = 0; e2 < f3; e2++) {
      B2 = (C2 * f3 + e2) * k3 + t2 * h3, v3 = (e2 + 0.5) / f3;
      for (let t3 = e2; t3 < h3; t3++) S3 = (t3 + 0.5) / h3, A3[B2 + t3] = (x3 * S3 + m3 * v3 + d3) * o4 + i3, U3[B2 + t3] = (g3 * S3 + y3 * v3 + w3) * s2 + i3, b3[B2 + t3] = Math.floor(A3[B2 + t3]), T2[B2 + t3] = Math.floor(U3[B2 + t3]);
    }
  }
  return { offsets_x: A3, offsets_y: U3, offsets_xi: b3, offsets_yi: T2, gridWidth: k3 };
}
function D(t, e) {
  const { coefficients: n, spacing: l3 } = e, { offsets_x: i3, offsets_y: o4, gridWidth: s2 } = F(t, t, n, { rows: l3[0], cols: l3[1] }), { width: r3, height: a3 } = t, h3 = new Float32Array(r3 * a3), f3 = 180 / Math.PI;
  for (let c4 = 0; c4 < a3; c4++) for (let t2 = 0; t2 < r3; t2++) {
    const e2 = c4 * s2 + t2, n2 = 0 === c4 ? e2 : e2 - s2, l4 = c4 === a3 - 1 ? e2 : e2 + s2, u4 = i3[n2] - i3[l4], p3 = o4[l4] - o4[n2];
    if (isNaN(u4) || isNaN(p3)) h3[c4 * r3 + t2] = 90;
    else {
      let e3 = Math.atan2(p3, u4) * f3;
      e3 = (360 + e3) % 360, h3[c4 * r3 + t2] = e3;
    }
  }
  return h3;
}
function N(t, n, l3, i3, s2 = "nearest") {
  if (!o2(t)) return null;
  "majority" === s2 && (t = B(t));
  const { pixels: r3, mask: a3, bandMasks: h3, pixelType: f3 } = t, c4 = t.width, u4 = t.height, p3 = c.getPixelArrayConstructor(f3), x3 = r3.length, { width: m3, height: d3 } = n;
  let g3 = false;
  for (let e = 0; e < l3.length; e += 3) -1 === l3[e] && -1 === l3[e + 1] && -1 === l3[e + 2] && (g3 = true);
  const { offsets_x: y3, offsets_y: w3, offsets_xi: k3, offsets_yi: M3, gridWidth: A3 } = F({ width: c4, height: u4 }, n, l3, i3, "majority" === s2 ? 0.5 : 0);
  let U3;
  const b3 = (t2, e, n2, l4) => {
    const i4 = t2 instanceof Float32Array || t2 instanceof Float64Array ? 0 : 0.5;
    for (let o4 = 0; o4 < d3; o4++) {
      U3 = o4 * A3;
      for (let s3 = 0; s3 < m3; s3++) {
        if (y3[U3] < 0 || w3[U3] < 0) t2[o4 * m3 + s3] = 0;
        else if (l4) t2[o4 * m3 + s3] = e[k3[U3] + M3[U3] * c4];
        else {
          const l5 = Math.floor(y3[U3]), r4 = Math.floor(w3[U3]), a4 = Math.ceil(y3[U3]), h4 = Math.ceil(w3[U3]), f4 = y3[U3] - l5, u5 = w3[U3] - r4;
          if (!n2 || n2[l5 + r4 * c4] && n2[a4 + r4 * c4] && n2[l5 + h4 * c4] && n2[a4 + h4 * c4]) {
            const n3 = (1 - f4) * e[l5 + r4 * c4] + f4 * e[a4 + r4 * c4], p4 = (1 - f4) * e[l5 + h4 * c4] + f4 * e[a4 + h4 * c4];
            t2[o4 * m3 + s3] = (1 - u5) * n3 + u5 * p4 + i4;
          } else t2[o4 * m3 + s3] = e[k3[U3] + M3[U3] * c4];
        }
        U3++;
      }
    }
  }, T2 = [];
  let S3;
  const v3 = h3?.length === x3, C2 = [];
  for (let e = 0; e < x3; e++) {
    if (v3) {
      const t2 = new Uint8Array(m3 * d3);
      b3(t2, h3[e], h3[e], true), C2.push(t2);
    }
    S3 = new p3(m3 * d3), b3(S3, r3[e], v3 ? h3[e] : a3, "nearest" === s2 || "majority" === s2), T2.push(S3);
  }
  const P3 = new c({ width: m3, height: d3, pixelType: f3, pixels: T2, bandMasks: v3 ? C2 : void 0 });
  if (null != a3) P3.mask = new Uint8Array(m3 * d3), b3(P3.mask, a3, a3, true);
  else if (g3) {
    P3.mask = new Uint8Array(m3 * d3);
    for (let t2 = 0; t2 < m3 * d3; t2++) P3.mask[t2] = y3[t2] < 0 || w3[t2] < 0 ? 0 : 1;
  }
  return P3.updateStatistics(), P3;
}
function j(t) {
  const { pixelBlock: e, extent: n, fieldNames: l3, skipFactor: o4, skipSpatialReference: s2 = false, pixelIdOffset: r3 = 0 } = t, a3 = [], { width: h3, height: f3, pixels: c4, mask: u4 } = e, p3 = t.imageRowSize ?? h3, x3 = n.width / h3, m3 = n.height / f3, d3 = c4.length, g3 = Math.floor(o4 / 2), { xmin: y3, ymax: w3 } = n, k3 = s2 ? void 0 : n.spatialReference.toJSON();
  for (let M3 = g3; M3 < f3; M3 += o4) for (let t2 = g3; t2 < h3; t2 += o4) {
    const e2 = M3 * h3 + t2;
    if (!u4 || u4[e2]) {
      const n2 = { x: y3 + (t2 + 0.5) * x3, y: w3 - (M3 + 0.5) * m3, spatialReference: k3 }, o5 = { [i]: r3 + M3 * p3 + t2 };
      for (let t3 = 0; t3 < d3; t3++) o5[l3[t3 + 1]] = c4[t3][e2];
      a3.push({ geometry: n2, attributes: o5 });
    }
  }
  return a3;
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/vectorFieldUtils.js
var r2 = /* @__PURE__ */ new Map();
r2.set("meter-per-second", 1), r2.set("kilometer-per-hour", 0.277778), r2.set("knots", 0.514444), r2.set("feet-per-second", 0.3048), r2.set("mile-per-hour", 0.44704);
var o3 = 180 / Math.PI;
var i2 = 5;
var s = new o({ esriMetersPerSecond: "meter-per-second", esriKilometersPerHour: "kilometer-per-hour", esriKnots: "knots", esriFeetPerSecond: "feet-per-second", esriMilesPerHour: "mile-per-hour" });
function a2(t, e) {
  return r2.get(t) / r2.get(e) || 1;
}
function h2(t) {
  return (450 - t) % 360;
}
function l2(t, e = "geographic") {
  const [n, r3] = t, i3 = Math.sqrt(n * n + r3 * r3);
  let s2 = Math.atan2(r3, n) * o3;
  return s2 = (360 + s2) % 360, "geographic" === e && (s2 = h2(s2)), [i3, s2];
}
function c3(t, e = "geographic") {
  let n = t[1];
  "geographic" === e && (n = h2(n)), n %= 360;
  const r3 = t[0];
  return [r3 * Math.cos(n / o3), r3 * Math.sin(n / o3)];
}
function u3(t, e, r3, o4 = "geographic") {
  if (!o2(t) || null == r3) return t;
  const i3 = "vector-magdir" === e ? t.clone() : f2(t, e), s2 = i3.pixels[1];
  for (let n = 0; n < s2.length; n++) s2[n] = "geographic" === o4 ? (s2[n] + r3[n] + 270) % 360 : (s2[n] + 360 - r3[n]) % 360;
  return "vector-magdir" === e ? i3 : f2(i3, "vector-magdir");
}
function f2(t, r3, o4 = "geographic", i3 = 1) {
  if (!o2(t)) return t;
  const { pixels: s2, width: a3, height: h3 } = t, u4 = a3 * h3, f3 = s2[0], p3 = s2[1], m3 = t.pixelType.startsWith("f") ? t.pixelType : "f32", d3 = c.createEmptyBand(m3, u4), g3 = c.createEmptyBand(m3, u4);
  let x3 = 0;
  for (let e = 0; e < h3; e++) for (let t2 = 0; t2 < a3; t2++) "vector-uv" === r3 ? ([d3[x3], g3[x3]] = l2([f3[x3], p3[x3]], o4), d3[x3] *= i3) : ([d3[x3], g3[x3]] = c3([f3[x3], p3[x3]], o4), d3[x3] *= i3, g3[x3] *= i3), x3++;
  const M3 = new c({ pixelType: m3, width: t.width, height: t.height, mask: t.mask, validPixelCount: t.validPixelCount, maskIsAlpha: t.maskIsAlpha, pixels: [d3, g3] });
  return M3.updateStatistics(), M3;
}
function p2(t, e, r3 = 1) {
  if (1 === r3 || !o2(t)) return t;
  const o4 = t.clone(), { pixels: i3, width: s2, height: a3 } = o4, h3 = i3[0], l3 = i3[1];
  let c4 = 0;
  for (let n = 0; n < a3; n++) for (let t2 = 0; t2 < s2; t2++) "vector-uv" === e ? (h3[c4] *= r3, l3[c4] *= r3) : h3[c4] *= r3, c4++;
  return o4.updateStatistics(), o4;
}
function m2(t, e, n, r3, o4) {
  if (null == o4 || !o4.spatialReference.equals(t.spatialReference)) return { extent: t, width: Math.round(e / r3), height: Math.round(n / r3), resolution: t.width / e };
  const i3 = o4.xmin, s2 = o4.ymax, a3 = (t.xmax - t.xmin) / e * r3, h3 = (t.ymax - t.ymin) / n * r3, l3 = (a3 + h3) / 2;
  return t.xmin = i3 + Math.floor((t.xmin - i3) / a3) * a3, t.xmax = i3 + Math.ceil((t.xmax - i3) / a3) * a3, t.ymin = s2 + Math.floor((t.ymin - s2) / h3) * h3, t.ymax = s2 + Math.ceil((t.ymax - s2) / h3) * h3, { extent: t, width: Math.round(t.width / a3), height: Math.round(t.height / h3), resolution: l3 };
}
var d2 = g2(0, 0, 0);
function g2(t = 0, e = 0, n = Math.PI, r3 = true) {
  r3 && (n = (2 * Math.PI - n) % (2 * Math.PI));
  const o4 = r3 ? -1 : 1, i3 = 13 * o4, s2 = -7 * o4, a3 = -2 * o4, h3 = -16 * o4, l3 = 21.75, [c4, u4] = M2(0, e + i3, n, l3), [f3, p3] = M2(t - 5.5, e + s2, n, l3), [m3, d3] = M2(t + 5.5, e + s2, n, l3), [g3, x3] = M2(t - 1.5, e + a3, n, l3), [k3, w3] = M2(t + 1.5, e + a3, n, l3), [y3, P3] = M2(t - 1.5, e + h3, n, l3), [b3, v3] = M2(t + 1.5, e + h3, n, l3);
  return [c4, u4, f3, p3, g3, x3, k3, w3, m3, d3, y3, P3, b3, v3];
}
function x2(t = 0, e = Math.PI, n = true) {
  n && (e = (2 * Math.PI - e) % (2 * Math.PI));
  const r3 = 10, o4 = n ? -1 : 1, s2 = 5 * o4, a3 = 20 * o4, h3 = 25 * o4, l3 = 45, c4 = 0, u4 = 0, f3 = 2, p3 = 0, m3 = f3 * o4, d3 = n ? 1 : -1, g3 = r3 / 2 * d3;
  let [x3, k3] = [c4 + g3, u4 - a3], [w3, y3] = [x3 + f3 * d3, k3], [P3, b3] = [w3 - p3 * d3, y3 + m3], [v3, I3] = [c4 - g3, u4 - h3], [A3, _3] = [v3 + p3 * d3, I3 - m3], U3 = Math.ceil(t / i2), S3 = Math.floor(U3 / 10);
  U3 -= 8 * S3;
  const D2 = [], F2 = [];
  for (let i3 = 0; i3 < U3 / 2; i3++, S3--) {
    S3 <= 0 && U3 % 2 == 1 && i3 === (U3 - 1) / 2 && (v3 = c4, A3 = v3 + p3 * d3, I3 = (I3 + k3) / 2, _3 = I3 - m3);
    const [t2, n2] = M2(v3, I3, e, l3);
    if (S3 > 0) {
      const [r4, o5] = M2(w3, I3, e, l3), [i4, s3] = M2(x3, k3, e, l3);
      D2.push(r4), D2.push(o5), D2.push(t2), D2.push(n2), D2.push(i4), D2.push(s3);
    } else {
      const [r4, o5] = M2(w3, y3, e, l3), [i4, s3] = M2(P3, b3, e, l3), [a4, h4] = M2(A3, _3, e, l3);
      F2.push(t2), F2.push(n2), F2.push(a4), F2.push(h4), F2.push(i4), F2.push(s3), F2.push(r4), F2.push(o5);
    }
    I3 += s2, k3 += s2, y3 += s2, b3 += s2, _3 += s2;
  }
  const [N2, j2] = M2(c4 + g3, u4 + a3, e, l3), J = (r3 / 2 + f3) * d3, [O, q2] = M2(c4 + J, u4 + a3, e, l3), [B2, E2] = M2(c4 + g3, u4 - h3, e, l3), [T2, C2] = M2(c4 + J, u4 - h3, e, l3);
  return { pennants: D2, barbs: F2, shaft: [N2, j2, O, q2, B2, E2, T2, C2] };
}
function M2(t, e, n, r3 = 1) {
  const o4 = Math.sqrt(t * t + e * e) / r3, i3 = (2 * Math.PI + Math.atan2(e, t)) % (2 * Math.PI);
  return [o4, (2 * Math.PI + i3 - n) % (2 * Math.PI)];
}
var k2 = [0, 1, 3, 6, 10, 16, 21, 27, 33, 40, 47, 55, 63];
var w2 = [0, 0.5, 1, 1.5, 2];
var y2 = [0, 0.25, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4];
function P2(t, e, n, r3) {
  const o4 = a2(r3 || "knots", n);
  let i3;
  for (i3 = 1; i3 < e.length; i3++) if (i3 === e.length - 1) {
    if (t < e[i3] * o4) break;
  } else if (t <= e[i3] * o4) break;
  return Math.min(i3 - 1, e.length - 2);
}
function b2(t, e, n, r3, o4) {
  let i3 = 0;
  switch (e) {
    case "beaufort_kn":
      i3 = P2(t, k2, "knots", n);
      break;
    case "beaufort_km":
      i3 = P2(t, k2, "kilometer-per-hour", n);
      break;
    case "beaufort_ft":
      i3 = P2(t, k2, "feet-per-second", n);
      break;
    case "beaufort_m":
      i3 = P2(t, k2, "meter-per-second", n);
      break;
    case "classified_arrow":
      i3 = P2(t, o4 ?? [], r3, n);
      break;
    case "ocean_current_m":
      i3 = P2(t, w2, "meter-per-second", n);
      break;
    case "ocean_current_kn":
      i3 = P2(t, y2, "knots", n);
  }
  return i3;
}
function v2(t, e) {
  const { style: n, inputUnit: r3, outputUnit: o4, breakValues: i3 } = e, a3 = s.fromJSON(r3), h3 = s.fromJSON(o4), l3 = 7 * 6, c4 = 15;
  let u4 = 0, f3 = 0;
  const { width: p3, height: m3, mask: x3 } = t, M3 = t.pixels[0], k3 = t.pixels[1], w3 = null != x3 ? x3.filter((t2) => t2 > 0).length : p3 * m3, y3 = new Float32Array(w3 * l3), P3 = new Uint32Array(c4 * w3), v3 = e.invertDirection ? g2(0, 0, 0, false) : d2;
  for (let s2 = 0; s2 < m3; s2++) for (let t2 = 0; t2 < p3; t2++) {
    const e2 = s2 * p3 + t2;
    if (!x3 || x3[s2 * p3 + t2]) {
      const r4 = (k3[e2] + 360) % 360 / 180 * Math.PI, o5 = b2(M3[e2], n, a3, h3, i3);
      for (let n2 = 0; n2 < v3.length; n2 += 2) y3[u4++] = (t2 + 0.5) / p3, y3[u4++] = (s2 + 0.5) / m3, y3[u4++] = v3[n2], y3[u4++] = v3[n2 + 1] + r4, y3[u4++] = o5, y3[u4++] = M3[e2];
      const c5 = 7 * (u4 / l3 - 1);
      P3[f3++] = c5, P3[f3++] = c5 + 1, P3[f3++] = c5 + 2, P3[f3++] = c5 + 0, P3[f3++] = c5 + 4, P3[f3++] = c5 + 3, P3[f3++] = c5 + 0, P3[f3++] = c5 + 2, P3[f3++] = c5 + 3, P3[f3++] = c5 + 2, P3[f3++] = c5 + 5, P3[f3++] = c5 + 3, P3[f3++] = c5 + 5, P3[f3++] = c5 + 6, P3[f3++] = c5 + 3;
    }
  }
  return { vertexData: y3, indexData: P3 };
}
var I2 = [];
function A2(t, e) {
  if (0 === I2.length) for (let i3 = 0; i3 < 30; i3++) I2.push(x2(5 * i3, 0, !e.invertDirection));
  const n = a2(s.fromJSON(e.inputUnit), "knots"), { width: r3, height: o4, mask: h3 } = t, l3 = t.pixels[0], c4 = t.pixels[1], u4 = 6, f3 = [], p3 = [];
  let m3 = 0, d3 = 0;
  for (let s2 = 0; s2 < o4; s2++) for (let t2 = 0; t2 < r3; t2++) {
    const e2 = s2 * r3 + t2, a3 = l3[e2] * n;
    if ((!h3 || h3[s2 * r3 + t2]) && a3 >= i2) {
      const n2 = (c4[e2] + 360) % 360 / 180 * Math.PI, { pennants: i3, barbs: h4, shaft: l4 } = I2[Math.min(Math.floor(a3 / 5), 29)];
      if (i3.length + h4.length === 0) continue;
      let g3 = f3.length / u4;
      const x3 = (t2 + 0.5) / r3, M3 = (s2 + 0.5) / o4;
      for (let t3 = 0; t3 < i3.length; t3 += 2) f3[m3++] = x3, f3[m3++] = M3, f3[m3++] = i3[t3], f3[m3++] = i3[t3 + 1] + n2, f3[m3++] = 0, f3[m3++] = a3;
      for (let t3 = 0; t3 < h4.length; t3 += 2) f3[m3++] = x3, f3[m3++] = M3, f3[m3++] = h4[t3], f3[m3++] = h4[t3 + 1] + n2, f3[m3++] = 0, f3[m3++] = a3;
      for (let t3 = 0; t3 < l4.length; t3 += 2) f3[m3++] = x3, f3[m3++] = M3, f3[m3++] = l4[t3], f3[m3++] = l4[t3 + 1] + n2, f3[m3++] = 0, f3[m3++] = a3;
      for (let t3 = 0; t3 < i3.length / 6; t3++) p3[d3++] = g3, p3[d3++] = g3 + 1, p3[d3++] = g3 + 2, g3 += 3;
      for (let t3 = 0; t3 < h4.length / 8; t3++) p3[d3++] = g3, p3[d3++] = g3 + 1, p3[d3++] = g3 + 2, p3[d3++] = g3 + 1, p3[d3++] = g3 + 2, p3[d3++] = g3 + 3, g3 += 4;
      p3[d3++] = g3 + 0, p3[d3++] = g3 + 1, p3[d3++] = g3 + 2, p3[d3++] = g3 + 1, p3[d3++] = g3 + 3, p3[d3++] = g3 + 2, g3 += 4;
    }
  }
  return { vertexData: new Float32Array(f3), indexData: new Uint32Array(p3) };
}
function _2(t, e) {
  const n = 4 * 6;
  let r3 = 0, o4 = 0;
  const { width: h3, height: l3, mask: c4 } = t, u4 = t.pixels[0], f3 = [], p3 = [], m3 = a2(s.fromJSON(e.inputUnit), "knots"), d3 = "wind_speed" === e.style ? i2 : Number.MAX_VALUE;
  for (let i3 = 0; i3 < l3; i3++) for (let t2 = 0; t2 < h3; t2++) {
    const e2 = u4[i3 * h3 + t2] * m3;
    if ((!c4 || c4[i3 * h3 + t2]) && e2 < d3) {
      for (let n2 = 0; n2 < 4; n2++) f3[r3++] = (t2 + 0.5) / h3, f3[r3++] = (i3 + 0.5) / l3, f3[r3++] = n2 < 2 ? -0.5 : 0.5, f3[r3++] = n2 % 2 == 0 ? -0.5 : 0.5, f3[r3++] = 0, f3[r3++] = e2;
      const s2 = 4 * (r3 / n - 1);
      p3[o4++] = s2, p3[o4++] = s2 + 1, p3[o4++] = s2 + 2, p3[o4++] = s2 + 1, p3[o4++] = s2 + 2, p3[o4++] = s2 + 3;
    }
  }
  return { vertexData: new Float32Array(f3), indexData: new Uint32Array(p3) };
}
function U2(t, e) {
  return "simple_scalar" === e.style ? _2(t, e) : "wind_speed" === e.style ? A2(t, e) : v2(t, e);
}
function S2(t, n, r3, o4 = [0, 0], i3 = 0.5) {
  const { width: s2, height: a3, mask: h3 } = t, [u4, f3] = t.pixels, [p3, m3] = o4, d3 = Math.round((s2 - p3) / r3), g3 = Math.round((a3 - m3) / r3), x3 = d3 * g3, M3 = new Float32Array(x3), k3 = new Float32Array(x3), w3 = new Uint8Array(x3), y3 = "vector-uv" === n;
  for (let e = 0; e < g3; e++) for (let t2 = 0; t2 < d3; t2++) {
    let n2 = 0;
    const o5 = e * d3 + t2, g4 = Math.max(0, e * r3 + m3), x4 = Math.max(0, t2 * r3 + p3), P4 = Math.min(a3, g4 + r3), b3 = Math.min(s2, x4 + r3);
    for (let t3 = g4; t3 < P4; t3++) for (let e2 = x4; e2 < b3; e2++) {
      const r4 = t3 * s2 + e2;
      if (!h3 || h3[r4]) {
        n2++;
        const t4 = y3 ? [u4[r4], f3[r4]] : [u4[r4], (360 + f3[r4]) % 360], [e3, i4] = y3 ? t4 : c3(t4);
        M3[o5] += e3, k3[o5] += i4;
      }
    }
    if (n2 >= (P4 - g4) * (b3 - x4) * (1 - i3)) {
      w3[o5] = 1;
      const [t3, e2] = l2([M3[o5] / n2, k3[o5] / n2]);
      M3[o5] = t3, k3[o5] = e2;
    } else w3[o5] = 0, M3[o5] = 0, k3[o5] = 0;
  }
  const P3 = new c({ width: d3, height: g3, pixels: [M3, k3], mask: w3 });
  return P3.updateStatistics(), P3;
}

export {
  l,
  o2 as o,
  r,
  a,
  h,
  f,
  c2 as c,
  u2 as u,
  p,
  x,
  m,
  w,
  k,
  M,
  U,
  T,
  v,
  I,
  W,
  E,
  D,
  N,
  j,
  s,
  a2,
  l2,
  u3 as u2,
  f2,
  p2,
  m2,
  _2 as _,
  U2,
  S2 as S
};
//# sourceMappingURL=chunk-NQDCX3PB.js.map
