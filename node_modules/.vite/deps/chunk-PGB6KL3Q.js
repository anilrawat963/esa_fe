import {
  e as e3
} from "./chunk-EKZRA6TO.js";
import {
  i
} from "./chunk-SJ2OBYX2.js";
import {
  e as e2
} from "./chunk-M24KZOVI.js";
import {
  h,
  l
} from "./chunk-2OFHDVO5.js";
import {
  A,
  H2 as H
} from "./chunk-V2H77UEV.js";
import {
  b,
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  M
} from "./chunk-R54Q5TGA.js";
import {
  r
} from "./chunk-A5XN2VFT.js";
import {
  a as a3,
  d,
  e,
  u3 as u,
  w
} from "./chunk-GNMPGHLQ.js";
import {
  a,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  y
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/geometry/support/UintArray.js
function n(n3, e4 = false) {
  return n3 <= y ? e4 ? new Array(n3).fill(0) : new Array(n3) : new Uint32Array(n3);
}

// node_modules/@arcgis/core/layers/support/Tilemap.js
var l2 = class _l {
  constructor(t) {
    s2(t);
    const { location: i2, data: l3 } = t;
    this.location = Object.freeze(a(i2));
    const r3 = this.location.width, n3 = this.location.height;
    let h2 = true, c = true;
    const m2 = Math.ceil(r3 * n3 / 32), f = n(m2);
    let w3 = 0;
    for (let e4 = 0; e4 < l3.length; e4++) {
      const t2 = e4 % 32;
      l3[e4] ? (c = false, f[w3] |= 1 << t2) : h2 = false, 31 === t2 && ++w3;
    }
    c ? (this._availability = "unavailable", this.byteSize = 40) : h2 ? (this._availability = "available", this.byteSize = 40) : (this._availability = f, this.byteSize = 40 + i(f));
  }
  getAvailability(t, i2) {
    if ("unavailable" === this._availability || "available" === this._availability) return this._availability;
    const e4 = (t - this.location.top) * this.location.width + (i2 - this.location.left), a4 = e4 % 32, o = e4 >> 5, l3 = this._availability;
    return o < 0 || o > l3.length ? "unknown" : l3[o] & 1 << a4 ? "available" : "unavailable";
  }
  static fromDefinition(e4, a4) {
    const o = e4.service.request || H, { row: r3, col: s3, width: h2, height: c } = e4, m2 = { query: { f: "json" } };
    return a4 = a4 ? { ...m2, ...a4 } : m2, o(n2(e4), a4).then((t) => t.data).catch((t) => {
      if (422 === t?.details?.httpStatus) return { location: { top: r3, left: s3, width: h2, height: c }, valid: true, data: new Array(h2 * c).fill(0) };
      throw t;
    }).then((t) => {
      if (t.location && (t.location.top !== r3 || t.location.left !== s3 || t.location.width !== h2 || t.location.height !== c)) throw new s("tilemap:location-mismatch", "Tilemap response for different location than requested", { response: t, definition: { top: r3, left: s3, width: h2, height: c } });
      return _l.fromJSON(t);
    });
  }
  static fromJSON(t) {
    return Object.freeze(new _l(t));
  }
};
function r2(t) {
  return `${t.level}/${t.row}/${t.col}/${t.width}/${t.height}`;
}
function n2(t) {
  let i2;
  if (t.service.tileServers?.length) {
    const e5 = t.service.tileServers;
    i2 = `${e5 && e5.length ? e5[t.row % e5.length] : t.service.url}/tilemap/${t.level}/${t.row}/${t.col}/${t.width}/${t.height}`;
  } else i2 = `${t.service.url}/tilemap/${t.level}/${t.row}/${t.col}/${t.width}/${t.height}`;
  const e4 = t.service.query;
  return e4 && (i2 = `${i2}?${e4}`), i2;
}
function s2(t) {
  if (!t?.location) throw new s("tilemap:missing-location", "Location missing from tilemap response");
  if (false === t.valid) throw new s("tilemap:invalid", "Tilemap response was marked as invalid");
  if (!t.data) throw new s("tilemap:missing-data", "Data missing from tilemap response");
  if (!Array.isArray(t.data)) throw new s("tilemap:data-mismatch", "Data must be an array of numbers");
  if (t.data.length !== t.location.width * t.location.height) throw new s("tilemap:data-mismatch", "Number of data items does not match width/height of tilemap");
}

// node_modules/@arcgis/core/layers/support/TilemapCache.js
var g;
function w2(e4, t, i2) {
  return new s("tile-map:tile-unavailable", "Tile is not available", { level: e4, row: t, col: i2 });
}
var _a;
var j = (_a = class extends b {
  constructor(e4) {
    super(e4), this._pendingTilemapRequests = {}, this.request = H, this.size = 32, this._prefetchingEnabled = true;
  }
  initialize() {
    this._tilemapCache = new e3(2097152), this.addHandles(l(() => {
      const { layer: e4 } = this;
      return [e4?.parsedUrl, e4?.tileServers, e4?.apiKey, e4?.customParameters];
    }, () => this._initializeTilemapDefinition(), h));
  }
  get effectiveMinLOD() {
    return this.minLOD ?? this.layer.tileInfo.lods[0].level;
  }
  get effectiveMaxLOD() {
    return this.maxLOD ?? this.layer.tileInfo.lods[this.layer.tileInfo.lods.length - 1].level;
  }
  getAvailability(e4, t, i2) {
    if (!this.layer.tileInfo.lodAt(e4) || e4 < this.effectiveMinLOD || e4 > this.effectiveMaxLOD) return "unavailable";
    const r3 = this._tilemapFromCache(e4, t, i2, this._tmpTilemapDefinition);
    return r3 ? r3.getAvailability(t, i2) : "unknown";
  }
  fetchAvailability(e4, t, i2, r3) {
    return !this.layer.tileInfo.lodAt(e4) || e4 < this.effectiveMinLOD || e4 > this.effectiveMaxLOD ? Promise.reject(w2(e4, t, i2)) : this._fetchTilemap(e4, t, i2, r3).catch((e5) => e5).then((r4) => {
      if (r4 instanceof l2) {
        const s3 = r4.getAvailability(t, i2);
        if ("unavailable" === s3) throw w2(e4, t, i2);
        return s3;
      }
      if (d(r4)) throw r4;
      return "unknown";
    });
  }
  fetchAvailabilityUpsample(e4, t, i2, r3, s3) {
    r3.level = e4, r3.row = t, r3.col = i2;
    const l3 = this.layer.tileInfo;
    l3.updateTileInfo(r3);
    const o = this.fetchAvailability(e4, t, i2, s3).catch((e5) => {
      if (d(e5)) throw e5;
      if (l3.upsampleTile(r3)) return this.fetchAvailabilityUpsample(r3.level, r3.row, r3.col, r3, s3);
      throw e5;
    });
    return this._fetchAvailabilityUpsamplePrefetch(e4, t, i2, s3, o), o;
  }
  async _fetchAvailabilityUpsamplePrefetch(e4, t, i2, r3, l3) {
    if (!this._prefetchingEnabled) return;
    const o = `prefetch-${e4}-${t}-${i2}`;
    if (this.hasHandles(o)) return;
    const a4 = new AbortController();
    l3.then(() => a4.abort(), () => a4.abort());
    let c = false;
    const h2 = e(() => {
      c || (c = true, a4.abort());
    });
    if (this.addHandles(h2, o), await M(10, a4.signal).catch(() => {
    }), c || (c = true, this.removeHandles(o)), a3(a4)) return;
    const p = new e2(e4, t, i2), m2 = { ...r3, signal: a4.signal }, u2 = this.layer.tileInfo;
    for (let s3 = 0; g._prefetches.length < g._maxPrefetch && u2.upsampleTile(p); ++s3) {
      const e5 = this.fetchAvailability(p.level, p.row, p.col, m2);
      g._prefetches.push(e5);
      const t2 = () => {
        g._prefetches.removeUnordered(e5);
      };
      e5.then(t2, t2);
    }
  }
  static cleanupTilemapCache() {
    this._prefetches.prune();
  }
  _fetchTilemap(e4, t, i2, s3) {
    if (!this.layer.tileInfo.lodAt(e4) || e4 < this.effectiveMinLOD || e4 > this.effectiveMaxLOD) return Promise.reject(new s("tilemap-cache:level-unavailable", `Level ${e4} is unavailable in the service`));
    const l3 = this._tmpTilemapDefinition, o = this._tilemapFromCache(e4, t, i2, l3);
    if (o) return Promise.resolve(o);
    const a4 = s3?.signal;
    return s3 = { ...s3, signal: null }, new Promise((e5, t2) => {
      w(a4, () => t2(u()));
      const i3 = r2(l3);
      let r3 = this._pendingTilemapRequests[i3];
      if (!r3) {
        r3 = l2.fromDefinition(l3, s3).then((e7) => (this._tilemapCache.put(i3, e7, e7.byteSize), e7));
        const e6 = () => {
          delete this._pendingTilemapRequests[i3];
        };
        this._pendingTilemapRequests[i3] = r3, r3.then(e6, e6);
      }
      r3.then(e5, t2);
    });
  }
  _initializeTilemapDefinition() {
    if (!this.layer.parsedUrl) return;
    const { parsedUrl: e4, apiKey: t, customParameters: i2 } = this.layer;
    this._tilemapCache.clear(), this._tmpTilemapDefinition = { service: { url: e4.path, query: A({ ...e4.query, ...i2, token: t ?? e4.query?.token }), tileServers: this.layer.tileServers, request: this.request }, width: this.size, height: this.size, level: 0, row: 0, col: 0 };
  }
  _tilemapFromCache(e4, t, i2, r3) {
    r3.level = e4, r3.row = t - t % this.size, r3.col = i2 - i2 % this.size;
    const s3 = r2(r3);
    return this._tilemapCache.get(s3);
  }
  get test() {
  }
}, g = _a, _a._maxPrefetch = 4, _a._prefetches = new r({ initialSize: g._maxPrefetch }), _a);
__decorate([m({ constructOnly: true })], j.prototype, "layer", void 0), __decorate([m({ constructOnly: true })], j.prototype, "minLOD", void 0), __decorate([m({ constructOnly: true })], j.prototype, "maxLOD", void 0), __decorate([m({ constructOnly: true })], j.prototype, "request", void 0), __decorate([m({ constructOnly: true })], j.prototype, "size", void 0), j = g = __decorate([a2("esri.layers.support.TilemapCache")], j);

export {
  j
};
//# sourceMappingURL=chunk-PGB6KL3Q.js.map
