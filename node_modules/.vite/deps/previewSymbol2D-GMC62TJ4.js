import {
  y as y2
} from "./chunk-MJIAJDWR.js";
import {
  h,
  t
} from "./chunk-WAYU35CW.js";
import {
  l
} from "./chunk-XBGTYNWI.js";
import {
  f,
  g,
  u as u3,
  y
} from "./chunk-D3G5WIRR.js";
import "./chunk-Q3JOE7TC.js";
import {
  c
} from "./chunk-OGWYK5MD.js";
import {
  E
} from "./chunk-XTEXJOLG.js";
import "./chunk-YE4E5JCT.js";
import "./chunk-SXZO7ULH.js";
import {
  U,
  k
} from "./chunk-VGXUPJSS.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import "./chunk-EKZRA6TO.js";
import "./chunk-M5SP6ZBM.js";
import "./chunk-B5A4L35M.js";
import "./chunk-52SEOH5H.js";
import "./chunk-6IHS6RYH.js";
import "./chunk-OJBEN6CV.js";
import "./chunk-TU5E6NPS.js";
import "./chunk-GD4FJL3C.js";
import {
  s as s2
} from "./chunk-35ST7YRB.js";
import "./chunk-3FUHCAX3.js";
import {
  n
} from "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import "./chunk-2OFHDVO5.js";
import {
  u as u2
} from "./chunk-CCQFL76O.js";
import {
  u
} from "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import "./chunk-SMWUT52Z.js";
import "./chunk-AXZMNHTN.js";
import "./chunk-5T3MJDSR.js";
import "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import "./chunk-5EI5H4QX.js";
import "./chunk-ZIE53VIV.js";
import "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import "./chunk-GNMPGHLQ.js";
import {
  s2 as s
} from "./chunk-QY7XKUIV.js";
import "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/symbols/support/previewSymbol2D.js
var y3 = "picture-fill";
var w = "picture-marker";
var x = "simple-fill";
var v = "simple-line";
var b = "simple-marker";
var M = "text";
var k2 = "Aa";
var z = 22;
var L = 120;
var S = 80;
var C = 50;
var j = 225;
var B = document.createElement("canvas");
function P(t2, e, o) {
  const { extent: i } = t2;
  if (!i) return "";
  const n2 = i.width || 1, h2 = i.height || 1;
  if ("polygon" === t2.type) {
    const l2 = t2.clone();
    n(l2) && (l2.rings = y2(l2, { minSegmentsPerCurve: 128 }).rings), U({ originPosition: "upperLeft", scale: [n2 / e, h2 / o], translate: [i.xmin, i.ymax] }, l2, l2);
    let c2 = "";
    for (let t3 = 0; t3 < l2.rings.length; t3++) {
      const e2 = l2.rings[t3];
      for (let t4 = 0; t4 < e2.length; t4++) {
        const o2 = e2[t4][0], i2 = e2[t4][1], n3 = 0 === t4 ? "M" : "l", a = t4 === e2.length - 1 ? " Z" : "";
        c2 += `${"" !== c2 ? " " : ""}${n3}${o2.toString()} ${i2.toString()}${a}`;
      }
    }
    return c2;
  }
  if ("polyline" === t2.type) {
    const a = t2.clone();
    n(a) && (a.paths = y2(a, { minSegmentsPerCurve: 128 }).paths), k({ originPosition: "upperLeft", scale: [n2 / e, h2 / o], translate: [i.xmin, i.ymax] }, a, a);
    let c2 = "";
    for (let t3 = 0; t3 < a.paths.length; t3++) {
      const e2 = a.paths[t3];
      for (let t4 = 0; t4 < e2.length; t4++) {
        const o2 = e2[t4][0], i2 = e2[t4][1];
        c2 += `${"" !== c2 ? " " : ""}${0 === t4 ? "M" : "l"}${o2.toString()} ${i2.toString()}`;
      }
    }
    return c2;
  }
  return "";
}
function $(t2, e) {
  const o = B.getContext("2d"), i = [];
  e && (e.weight && i.push(e.weight), e.size && i.push(e.size + "px"), e.family && i.push(e.family)), o.font = i.join(" ");
  const { width: n2, actualBoundingBoxLeft: a, actualBoundingBoxRight: l2, actualBoundingBoxAscent: s3, actualBoundingBoxDescent: r } = o.measureText(t2);
  return { width: Math.ceil(Math.max(n2, a + l2)), height: Math.ceil(s3 + r), x: Math.floor(a), y: Math.floor((s3 - r) / 2) };
}
function E2(t2) {
  const e = t2?.size;
  return { width: null != e && "object" == typeof e && "width" in e ? u(e.width) : null, height: null != e && "object" == typeof e && "height" in e ? u(e.height) : null };
}
async function U2(t2, e) {
  const o = e.fill, i = t2.color;
  if ("pattern" === o?.type && i && t2.type !== y3) {
    const t3 = await f(o.src, i.toCss(true));
    o.src = t3, e.fill = o;
  }
}
async function F(t2, e, o, n2) {
  if (!("font" in t2) || !t2.font || "text" !== e.shape.type) return;
  try {
    await c(t2.font);
  } catch {
  }
  const { width: a, height: l2 } = E2(n2);
  if (!/[\uE600-\uE6FF]/.test(e.shape.text)) {
    const { width: i, height: s3, x: r, y: h2 } = $(e.shape.text, { weight: e.font?.weight, size: e.font?.size, family: e.font?.family });
    o[0] = a ?? i, o[1] = l2 ?? s3, e.shape.x = r, e.shape.y = h2;
    let c2 = "angle" in t2 ? t2.angle : null;
    if (null != n2?.rotation && (c2 = (c2 ?? 0) + n2.rotation), c2) {
      const t3 = c2 * (Math.PI / 180), e2 = Math.abs(Math.sin(t3)), i2 = Math.abs(Math.cos(t3));
      o[1] = o[0] * e2 + o[1] * i2;
    }
  }
}
function A(t2, e, o, i, a) {
  if (null != t2.haloColor && null != t2.haloSize) {
    a.masking ??= o.map(() => []);
    const l2 = u(t2.haloSize);
    i[0] += l2, i[1] += l2, o.unshift([{ ...e, fill: null, stroke: { color: t2.haloColor, width: 2 * l2, join: "round", cap: "round" } }]), a.masking.unshift([{ shape: { type: "rect", x: 0, y: 0, width: i[0] + 2 * s2, height: i[1] + 2 * s2 }, fill: [255, 255, 255], stroke: null }, { ...e, fill: [0, 0, 0, 0], stroke: null }]);
  }
  null == t2.backgroundColor && null == t2.borderLineColor || (i[0] += 2 * s2, i[1] += 2 * s2, o.unshift([{ shape: { type: "rect", x: 0, y: 0, width: i[0], height: i[1] }, fill: t2.backgroundColor, stroke: { color: t2.borderLineColor, width: u(t2.borderLineSize) } }]), a.masking?.unshift([]));
}
function Z(t2, e) {
  return t2 > e ? "dark" : "light";
}
function D(t2, e) {
  const o = "number" == typeof e?.size ? e?.size : null, i = null != o ? u(o) : null, a = null != e?.maxSize ? u(e.maxSize) : null;
  let l2 = "angle" in t2 ? t2.angle : null;
  null != e?.rotation && (l2 = (l2 ?? 0) + e.rotation);
  const s3 = u3(t2);
  let r = y(t2);
  "dark" !== T(t2, 245) || e?.ignoreWhiteSymbols || (r = { width: 0.75, ...r, color: "#bdc3c7" });
  let u4 = null;
  const d = { shape: null, fill: s3, stroke: r, offset: [0, 0] };
  r?.width && (r.width = Math.min(r.width, S));
  const f2 = r?.width || 0;
  let g2 = null != e?.size && (null == e?.scale || e?.scale), j2 = 0, B2 = 0, U3 = false;
  switch (t2.type) {
    case b: {
      const o2 = t2.style, { width: s4, height: r2 } = E2(e);
      let h2 = s4 === r2 && null != s4 ? s4 : null != i ? i : Math.min(u(t2.size), a || L);
      if (true === e?.useMarkerSymbolSize && null !== s4 && null !== r2) {
        const e2 = Math.min(u(t2.size), a || L);
        h2 = e2 > s4 && e2 > r2 ? Math.min(s4, r2) : e2;
      }
      switch (j2 = h2, B2 = h2, o2) {
        case "circle":
          d.shape = { type: "circle", cx: 0, cy: 0, r: 0.5 * h2 }, g2 || (j2 += f2, B2 += f2);
          break;
        case "cross":
          d.shape = { type: "path", path: [{ command: "M", values: [0, 0.5 * B2] }, { command: "L", values: [j2, 0.5 * B2] }, { command: "M", values: [0.5 * j2, 0] }, { command: "L", values: [0.5 * j2, B2] }] };
          break;
        case "diamond":
          d.shape = { type: "path", path: [{ command: "M", values: [0, 0.5 * B2] }, { command: "L", values: [0.5 * j2, 0] }, { command: "L", values: [j2, 0.5 * B2] }, { command: "L", values: [0.5 * j2, B2] }, { command: "Z", values: [] }] }, g2 || (j2 += f2, B2 += f2);
          break;
        case "square":
          d.shape = { type: "path", path: [{ command: "M", values: [0, 0] }, { command: "L", values: [j2, 0] }, { command: "L", values: [j2, B2] }, { command: "L", values: [0, B2] }, { command: "Z", values: [] }] }, g2 || (j2 += f2, B2 += f2), l2 && (U3 = true);
          break;
        case "triangle":
          d.shape = { type: "path", path: [{ command: "M", values: [0.5 * j2, 0] }, { command: "L", values: [j2, B2] }, { command: "L", values: [0, B2] }, { command: "Z", values: [] }] }, g2 || (j2 += f2, B2 += f2), l2 && (U3 = true);
          break;
        case "x":
          d.shape = { type: "path", path: [{ command: "M", values: [0, 0] }, { command: "L", values: [j2, B2] }, { command: "M", values: [j2, 0] }, { command: "L", values: [0, B2] }] }, l2 && (U3 = true);
          break;
        case "path":
          d.shape = { type: "path", path: t2.path || "" }, g2 || (j2 += f2, B2 += f2), l2 && (U3 = true), g2 = true;
      }
      break;
    }
    case v: {
      const { width: t3, height: o2 } = E2(e), n2 = g(r).reduce((t4, e2) => t4 + e2, 0), a2 = n2 && Math.ceil(C / n2), l3 = o2 ?? i ?? f2, s4 = t3 ?? (n2 * a2 || C);
      if (g2 = true, "polyline" === e?.geometry?.type && e?.geometry?.extent) {
        j2 = s4, B2 = o2 ?? j2;
        const t4 = 1e3, i2 = 0.15 * t4;
        u4 = [j2, B2], B2 = u4[0] > u4[1] ? t4 * u4[1] / u4[0] : t4, j2 = u4[0] > u4[1] ? t4 : t4 * u4[0] / u4[1], r?.width && (r.width = r.width * t4 / (u4[1] > u4[0] ? u4[1] : u4[0]), r.width > i2 && (r.width = i2)), d.shape = { type: "path", path: P(e.geometry, j2, B2) };
      } else j2 = null != e?.maxSize ? Math.min(s4, e.maxSize) : s4, B2 = l3, r && (r.width = l3), d.shape = { type: "path", path: [{ command: "M", values: [l3 / 2, B2 / 2] }, { command: "L", values: [j2 - l3 / 2, B2 / 2] }] };
      break;
    }
    case y3:
    case x: {
      const t3 = "object" == typeof e?.symbolConfig && !!e?.symbolConfig?.isSquareFill, { width: o2, height: n2 } = E2(e);
      j2 = !t3 && o2 !== n2 || null == o2 ? null != i ? i : z : o2, B2 = !t3 && o2 !== n2 || null == n2 ? j2 : n2, g2 || (j2 += f2, B2 += f2), g2 = true, e?.geometry?.extent && "polygon" === e?.geometry?.type ? (u4 = [j2, B2], B2 = u4[0] > u4[1] ? 1e3 * u4[1] / u4[0] : 1e3, j2 = u4[0] > u4[1] ? 1e3 : 1e3 * u4[0] / u4[1], d.shape = { type: "path", path: P(e.geometry, j2, B2) }) : d.shape = t3 ? { type: "path", path: [{ command: "M", values: [0, 0] }, { command: "L", values: [j2, 0] }, { command: "L", values: [j2, B2] }, { command: "L", values: [0, B2] }, { command: "L", values: [0, 0] }, { command: "Z", values: [] }] } : t.fill[0];
      break;
    }
    case w: {
      const o2 = Math.min(u(t2.width), a || L), s4 = Math.min(u(t2.height), a || L), { width: r2, height: h2 } = E2(e), c2 = r2 === h2 && null != r2 ? r2 : null != i ? i : Math.max(o2, s4), m = t2.width / t2.height;
      j2 = m <= 1 ? Math.ceil(c2 * m) : c2, B2 = m <= 1 ? c2 : Math.ceil(c2 / m), d.shape = { type: "image", x: -Math.round(j2 / 2), y: -Math.round(B2 / 2), width: j2, height: B2, src: t2.url || "" }, l2 && (U3 = true);
      break;
    }
    case M: {
      const o2 = t2, l3 = e?.overrideText || o2.text || k2, s4 = o2.font, { width: r2, height: h2 } = E2(e), c2 = null != h2 ? h2 : null != i ? i : Math.min(u(s4.size), a || L), { width: m, height: u5 } = $(l3, { weight: s4.weight, size: c2, family: s4.family }), p = /[\uE600-\uE6FF]/.test(l3);
      j2 = r2 ?? (p ? c2 : m), B2 = p ? c2 : u5;
      let f3 = 0.5 * (p ? c2 : u5);
      p && (f3 += 5), d.shape = { type: "text", text: l3, x: o2.xoffset || 0, y: o2.yoffset || f3, align: "middle", alignBaseline: o2.verticalAlignment, decoration: s4 && s4.decoration, rotated: o2.rotated, kerning: o2.kerning }, d.font = s4 && { size: c2, style: s4.style, decoration: s4.decoration, weight: s4.weight, family: s4.family };
      break;
    }
  }
  return { shapeDescriptor: d, size: [j2, B2], outputSize: u4, renderOptions: { node: e?.node, scale: g2, opacity: e?.opacity, rotations: [l2], useRotationSize: U3, cssEffectFilter: e?.cssEffectFilter, ariaLabel: e?.ariaLabel, clipBloomEffect: e?.clipBloomEffect } };
}
async function q(t2, e) {
  const { shapeDescriptor: i, size: n2, renderOptions: a, outputSize: l2 } = D(t2, e);
  if (!i.shape) throw new s("symbolPreview: renderPreviewHTML2D", "symbol not supported.");
  await U2(t2, i), await F(t2, i, n2, e);
  const s3 = [[i]];
  if ("object" == typeof e?.symbolConfig && e?.symbolConfig?.applyColorModulation) {
    const t3 = 0.6 * n2[0];
    s3.unshift([{ ...i, offset: [-t3, 0], fill: h(i.fill, -0.3) }]), s3.push([{ ...i, offset: [t3, 0], fill: h(i.fill, 0.3) }]), n2[0] += 2 * t3, a.scale = false;
  }
  "text" === t2.type && A(t2, i, s3, n2, a);
  const r = l(s3, n2, a);
  if (l2 && r) {
    const t3 = "img" === r.nodeName.toLowerCase() ? r : r.firstChild;
    "svg" === t3.nodeName.toLowerCase() && t3.setAttribute("viewBox", `0 0 ${n2[0].toString()} ${n2[1].toString()}`), t3.setAttribute("width", l2[0].toString()), t3.setAttribute("height", l2[1].toString()), l2.length > 2 && (t3.style.setProperty("padding-left", l2[2]?.toString() + "px"), t3.style.setProperty("padding-right", l2[2]?.toString() + "px"), t3.style.setProperty("padding-top", l2[3]?.toString() + "px"), t3.style.setProperty("padding-bottom", l2[3]?.toString() + "px"), t3.style.setProperty("box-sizing", "border-box"));
  }
  return r;
}
function T(o, i = j) {
  const n2 = u3(o), a = y(o), l2 = !n2 || "type" in n2 ? null : new u2(n2), s3 = a?.color ? new u2(a?.color) : null, r = l2 ? Z(E(l2), i) : null, m = s3 ? Z(E(s3), i) : null;
  return m ? r ? r === m ? r : i >= j ? "light" : "dark" : m : r;
}
export {
  T as getContrastingBackgroundTheme,
  D as getRenderSymbolParameters,
  q as previewSymbol2D
};
//# sourceMappingURL=previewSymbol2D-GMC62TJ4.js.map
