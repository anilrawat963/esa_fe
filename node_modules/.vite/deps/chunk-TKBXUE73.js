import {
  N,
  W
} from "./chunk-2LC2762W.js";
import {
  m
} from "./chunk-3FUHCAX3.js";
import {
  y3 as y
} from "./chunk-PZ5RULLK.js";
import {
  _
} from "./chunk-AXZMNHTN.js";

// node_modules/@arcgis/core/layers/support/GeometryDescriptor.js
var r = class _r {
  constructor(e) {
    this.geometry = e, this.spatialReference = e.spatialReference;
  }
  export() {
    return this._exporter(this.coordinates, this.spatialReference);
  }
  clone(e) {
    const t = new _r(this.geometry);
    return t.spatialReference = this.spatialReference, t.coordinates = e ?? this.coordinates.map((e2) => e2.clone()), t._exporter = this._exporter, t;
  }
  async project(t, s) {
    if (this.spatialReference.equals(t)) return this.clone();
    await N([{ source: this.spatialReference, dest: t }], { signal: s });
    const r2 = new m({ spatialReference: this.spatialReference, points: this.coordinates.map((e) => [e.x, e.y]) }), i2 = W(r2, t);
    if (!i2) return null;
    const a = this.coordinates.map((e, t2) => {
      const s2 = e.clone(), n = i2.points[t2];
      return s2.x = n[0], s2.y = n[1], s2;
    }), c = this.clone(a);
    return c.spatialReference = t, c;
  }
  static fromGeometry(n) {
    const o = new _r(n);
    if (n instanceof _r) return o.coordinates = n.coordinates.map((e) => e.clone()), o._exporter = (e, t) => {
      const s = n.clone(e);
      return s.spatialReference = t, s;
    }, o;
    switch (n.type) {
      case "point": {
        const e = n, { hasZ: s, hasM: r2 } = e;
        return o.coordinates = s && r2 ? [new i(e.x, e.y, e.z, e.m)] : s ? [new i(e.x, e.y, e.z)] : r2 ? [new i(e.x, e.y, null, e.m)] : [new i(e.x, e.y)], o._exporter = (e2, s2) => n.hasM ? new _(e2[0].x, e2[0].y, e2[0].z, e2[0].m, s2) : new _(e2[0].x, e2[0].y, e2[0].z, s2), o;
      }
      case "multipoint": {
        const t = n, { hasZ: s, hasM: r2 } = t;
        return o.coordinates = s && r2 ? t.points.map((e) => new i(e[0], e[1], e[2], e[3])) : s ? t.points.map((e) => new i(e[0], e[1], e[2])) : r2 ? t.points.map((e) => new i(e[0], e[1], null, e[2])) : t.points.map((e) => new i(e[0], e[1])), o._exporter = (t2, s2) => n.hasM ? new m({ points: t2.map((e) => [e.x, e.y, e.z ?? 0, e.m ?? 0]), hasZ: true, hasM: true, spatialReference: s2 }) : new m({ points: t2.map((e) => [e.x, e.y, e.z ?? 0]), spatialReference: s2 }), o;
      }
      case "polyline": {
        const e = n, t = [], r2 = [], { hasZ: a, hasM: c } = n;
        let p = 0;
        for (const s of e.paths) if (r2.push([p, p + s.length]), p += s.length, a && c) for (const e2 of s) t.push(new i(e2[0], e2[1], e2[2], e2[3]));
        else if (a) for (const e2 of s) t.push(new i(e2[0], e2[1], e2[2]));
        else if (c) for (const e2 of s) t.push(new i(e2[0], e2[1], null, e2[2]));
        else for (const e2 of s) t.push(new i(e2[0], e2[1]));
        return o.coordinates = t, o._exporter = (e2, t2) => {
          const o2 = n.hasM ? e2.map((e3) => [e3.x, e3.y, e3.z ?? 0, e3.m ?? 0]) : e2.map((e3) => [e3.x, e3.y, e3.z ?? 0]), i2 = r2.map((e3) => o2.slice(e3[0], e3[1]));
          return new y({ paths: i2, hasM: n.hasM, hasZ: true, spatialReference: t2 });
        }, o;
      }
    }
  }
};
var i = class _i {
  constructor(e, t, s = null, n = null, o = null, r2 = null) {
    this.x = e, this.y = t, this.z = s, this.m = n, this.tile = o, this.elevationTile = r2;
  }
  clone() {
    return new _i(this.x, this.y, this.z, this.m);
  }
};

export {
  r
};
//# sourceMappingURL=chunk-TKBXUE73.js.map
