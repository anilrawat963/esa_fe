import {
  z
} from "./chunk-GD72EK2J.js";
import {
  o
} from "./chunk-A2QKOXAQ.js";
import {
  n
} from "./chunk-2BTHAF26.js";
import {
  o as o2,
  t
} from "./chunk-GQGQDZ2T.js";
import "./chunk-ZCI5A4FF.js";
import "./chunk-2D47RURG.js";
import {
  F as F2
} from "./chunk-XDLV73DB.js";
import "./chunk-ARTU4L55.js";
import "./chunk-BBYMM7CM.js";
import "./chunk-EM7Y2JZC.js";
import "./chunk-XTZAIV4X.js";
import "./chunk-63LDVRFI.js";
import "./chunk-6KDQMJAI.js";
import "./chunk-UDHS2MGH.js";
import "./chunk-ENINOZUZ.js";
import "./chunk-TH4EQWJJ.js";
import {
  l
} from "./chunk-2OFHDVO5.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import {
  c,
  r
} from "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import {
  H2 as H
} from "./chunk-V2H77UEV.js";
import {
  b,
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  F
} from "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import {
  C,
  d
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i
} from "./chunk-QY7XKUIV.js";
import "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/layers/Lyr3DWorkerHandle.js
var e = class extends o {
  constructor(r2) {
    super("Lyr3DWorker", "process", { process: (r3) => r3.inputs }, r2, { hasInitialize: true });
  }
  destroyWasm() {
    return this.broadcast({}, "destroyWasm");
  }
  addSpatialReferenceInfo(r2, e2, s, t2) {
    const o4 = { sr: r2, isGCS: e2, toMetersXY: s, toMetersZ: t2 };
    return this.broadcast(o4, "addSpatialReferenceInfo");
  }
};

// node_modules/@arcgis/core/views/3d/layers/support/makeScheduleFunction.js
function o3(o4) {
  return (t2) => {
    if (o4.destroyed) {
      const o5 = t2(F2);
      return C(o5) ? o5 : Promise.resolve(o5);
    }
    if (o4.immediate) return o4.immediate.schedule(t2);
    const i2 = "No immediate scheduler";
    throw console.error(i2), new Error(i2);
  };
}

// node_modules/@arcgis/core/layers/Lyr3DWasmPerSceneView.js
var w = 3857;
var b2 = 32662;
var p = 4326;
var f = 5773;
var M = 115700;
var L = class extends b {
  constructor(e2) {
    super(e2), this._lyr3DMainPromise = null, this._lyr3DMain = null, this._layers = /* @__PURE__ */ new Map(), this._viewSR = null, this._debugFlags = /* @__PURE__ */ new Set(), this._debugLevel = 0, this._wasmNotLoaded = "method requiring WASM was called when WASM isn't loaded", this._pulseTaskHandle = null, this._debugFlags.add(0), this._debugFlags.add(1), this._debugFlags.add(2);
  }
  _debugLog(e2, t2, i2, r2 = true) {
    if (this._debugFlags.has(e2) && this._debugLevel >= t2) {
      const e3 = r2 ? `[js] ${i2}` : `${i2}`;
      0 === t2 || 1 === t2 ? i.getLogger(this).error(e3) : 2 === t2 && i.getLogger(this).warn(e3), i.getLogger(this).info(e3);
    }
  }
  initialize() {
    this._debugLevel > 2 && (i.getLogger(this).level = "info"), this._debugLog(0, 3, "Lyr3DWasmPerSceneView.initialize()"), this.addHandles([l(() => this.view.state?.contentCamera, () => this._updateWasmCamera())]), this._pulseTaskHandle = F({ preRender: () => this._pulseTask() });
  }
  destroy() {
    this._debugLog(0, 3, "Lyr3DWasmPerSceneView.destroy()"), this._lyr3DMain && (this._layers.forEach((e3) => {
      e3.abortController.abort();
    }), this._lyr3DMain.uninitialize_lyr3d_wasm(), this._lyr3DMain = null);
    const e2 = this._workerHandle;
    e2 && e2.destroyWasm().then(() => {
      this._workerHandle?.destroy(), this._workerHandle = null;
    }), this._pulseTaskHandle?.remove(), this._pulseTaskHandle = null;
  }
  addLayerView(e2) {
    return this._lyr3DMain ? this._addLayerView(e2) : (this._debugLog(0, 1, "Lyr3DWasmPerSceneView.add3DTilesLayerView() called when WASM wasn't initialized"), { wasmLayerId: t });
  }
  removeLayerView(e2) {
    if (!this._lyr3DMain) return this._debugLog(0, 1, this._wasmNotLoaded), 0;
    this._doRemoveLayerView(e2);
    const t2 = this._layers.size;
    return 0 === t2 && (this._debugLog(0, 3, "Lyr3DWasmPerSceneView.remove3DTilesLayerView() no Lyr3D layers left after removing a layer, destroying"), this.destroy()), t2;
  }
  getValidLayerViewCount() {
    if (!this._lyr3DMain) return this._debugLog(0, 1, this._wasmNotLoaded), 0;
    let e2 = 0;
    return this._layers.forEach((t2) => {
      t2.layerView.wasmLayerId >= 0 && ++e2;
    }), e2;
  }
  setEnabled(e2, t2) {
    if (!this._lyr3DMain) return void this._debugLog(0, 1, this._wasmNotLoaded);
    const i2 = this._layers.get(e2.wasmLayerId);
    i2 && (this._lyr3DMain.set_enabled(e2.wasmLayerId, t2), i2.needMemoryUsageUpdate = true, i2.needFrame = true, i2.layerView.updatingFlagChanged());
  }
  setLayerOffset(e2, t2) {
    if (!this._lyr3DMain) return void this._debugLog(0, 1, this._wasmNotLoaded);
    this._layers.get(e2.wasmLayerId) && this._lyr3DMain.set_carto_offset_z(e2.wasmLayerId, t2);
  }
  getAttributionText() {
    if (!this._lyr3DMain) return this._debugLog(0, 1, this._wasmNotLoaded), [];
    return this._lyr3DMain.get_current_attribution_text().split("|");
  }
  onRenderableEvicted(e2, t2, i2) {
    if (!this._lyr3DMain) return void this._debugLog(0, 1, this._wasmNotLoaded);
    this._layers.get(e2.wasmLayerId) && this._lyr3DMain.on_renderable_evicted(e2.wasmLayerId, t2, i2);
  }
  setMeshModifications(e2, t2, i2) {
    if (!this._lyr3DMain) return void this._debugLog(0, 1, this._wasmNotLoaded);
    const s = this._layers.get(e2.wasmLayerId);
    if (s) {
      const r2 = this._lyr3DMain._malloc(8 * t2.length), a2 = new Float64Array(this._lyr3DMain.HEAPF64.buffer, r2, t2.length);
      for (let e3 = 0; e3 < t2.length; ++e3) a2[e3] = t2[e3];
      this._lyr3DMain.set_mesh_modification_polygons(e2.wasmLayerId, r2, t2.length, i2), this._lyr3DMain._free(r2), s.needFrame = true, s.layerView.updatingFlagChanged();
    }
  }
  isUpdating(e2) {
    if (!this._lyr3DMain && this._lyr3DMainPromise) return true;
    const t2 = this._layers.get(e2);
    return !!t2 && (t2.outstandingJobCount > 0 || t2.outstandingRenderableCount > 0 || t2.needFrame);
  }
  initializeWasm(e2, t2) {
    return this._lyr3DMain ? Promise.resolve() : this.view.renderSpatialReference ? (this._debugLog(0, 3, "Lyr3DWasmPerSceneView.initializeWasm()"), this._lyr3DMainPromise || (this._lyr3DMainPromise = n().then((i2) => {
      this._lyr3DMain = i2, this._lyr3DMainPromise = null;
      const s = this._lyr3DMain.addFunction(this._onNewJob.bind(this), "v"), r2 = this._lyr3DMain.addFunction(this._onNewRenderable.bind(this), "v"), a2 = this._lyr3DMain.addFunction(this._freeRenderables.bind(this), "viii"), n2 = this._lyr3DMain.addFunction(this._setRenderableVisibility.bind(this), "viiii"), o4 = this._lyr3DMain.addFunction(this._onWasmError.bind(this), "viiii");
      if (!this.view.renderSpatialReference) return void (this._lyr3DMain = null);
      this._viewSR = this.view.renderSpatialReference?.toJSON();
      const l2 = "global" === this.view.viewingMode ? 5 : 3;
      if (5 === l2) this._viewSR.wkid = this._viewSR.latestWkid = p, this._viewSR.vcsWkid = this._viewSR.latestVcsWkid = f;
      else if (this.view.renderSpatialReference?.isWebMercator) this._viewSR.wkid = this._viewSR.latestWkid = w, this._viewSR.vcsWkid = this._viewSR.latestVcsWkid = f;
      else if (this.view.renderSpatialReference?.wkid === b2) this._viewSR.wkid = this._viewSR.latestWkid = p, this._viewSR.vcsWkid = this._viewSR.latestVcsWkid = f;
      else if (!this._viewSR.latestVcsWkid && !this._viewSR.vcsWkid) {
        const e3 = this.view.heightModelInfo?.heightModel, t3 = !e3 || "gravity-related-height" === e3;
        this._viewSR.vcsWkid = this._viewSR.latestVcsWkid = t3 ? f : M;
      }
      return this._lyr3DMain.initialize_lyr3d_wasm(o4, s, r2, a2, n2, e2, t2, l2, this._cleanUpSR(this._makeSRWasmSerializable(this._viewSR)), Math.max(this._debugLevel, 0)) ? (this._workerHandle = new e(o3(this.view.resourceController)), this._workerHandle.promise ? this._workerHandle.promise : void 0) : (this._lyr3DMain = null, void this._debugLog(0, 0, "Lyr3d Main WASM failed to initialize", false));
    }).catch((e3) => {
      this._debugLog(0, 0, `Lyr3d WASM failed to download error = ${e3}`, false);
    })), this._lyr3DMainPromise) : Promise.reject();
  }
  _pulseTask() {
    if (this._lyr3DMain) {
      let e2 = 0, t2 = 0;
      this._layers.forEach((i3) => {
        e2 += i3.layerView.usedMemory, t2 += i3.layerView.cachedMemory;
      }), e2 /= 1048576, t2 /= 1048576;
      const i2 = this.view.resourceController.memoryController, s = i2.usedMemory * i2.maxMemory - e2;
      this._lyr3DMain.frame_pulse(i2.memoryFactor, e2, t2, s, i2.maxMemory), this._layers.forEach((e3) => {
        true === e3.needFrame && (e3.needFrame = false, e3.layerView.updatingFlagChanged());
      });
    }
  }
  _incrementJobCount(e2) {
    e2.outstandingJobCount += 1, 1 === e2.outstandingJobCount && e2.outstandingRenderableCount < 1 && e2.layerView.updatingFlagChanged();
  }
  _decrementJobCount(e2) {
    e2.outstandingJobCount -= 1, 0 === e2.outstandingJobCount && e2.outstandingRenderableCount < 1 && e2.layerView.updatingFlagChanged();
  }
  _incrementRenderableCount(e2) {
    e2.outstandingRenderableCount += 1, e2.outstandingJobCount < 1 && 1 === e2.outstandingRenderableCount && e2.layerView.updatingFlagChanged();
  }
  _decrementRenderableCount(e2) {
    e2.outstandingRenderableCount -= 1, e2.outstandingJobCount < 1 && 0 === e2.outstandingRenderableCount && e2.layerView.updatingFlagChanged();
  }
  _onJobFailed(e2, t2, i2) {
    t2.error.length && this._debugLog(1, 1, t2.error, false), this._lyr3DMain && this._lyr3DMain.on_job_failed(i2.jobId, i2.desc), this._decrementJobCount(e2);
  }
  _onJobSucceeded(e2, t2, i2) {
    if (this._lyr3DMain) {
      const e3 = t2.data.byteLength, s = this._lyr3DMain._malloc(e3);
      new Uint8Array(this._lyr3DMain.HEAPU8.buffer, s, e3).set(t2.data), this._lyr3DMain.on_job_completed(i2.jobId, t2.jobDescJson, s, e3), this._lyr3DMain._free(s);
    }
    this._decrementJobCount(e2);
  }
  _getRequestPromises(e2, i2, s, r2) {
    const a2 = [];
    for (const n2 of e2) {
      const e3 = new URL(n2);
      if ("integrated-mesh-3dtiles" === r2.type) {
        if (e3.origin === s.origin && e3.pathname === s.pathname) {
          if (r2.rootTileset) {
            a2.push(Promise.resolve(r2.rootTileset.slice()));
            continue;
          }
        } else r2.session && e3.searchParams.append("session", r2.session);
      }
      a2.push(H(e3.toString(), i2).then((e4) => e4.data));
    }
    return a2;
  }
  _getInitialPromise(e2, t2, i2, s, a2, n2, o4) {
    const l2 = this._getRequestPromises(e2.urls, t2, i2, s);
    return Promise.all(l2).then((e3) => (a2.inputs = e3, this._workerHandle.invoke(a2, n2))).then((e3) => e3).catch((t3) => {
      let i3 = 1;
      return d(t3) ? this._debugLog(1, 2, `job ${e2.jobId} was cancelled.`) : o4 && 400 === t3.details?.httpStatus ? (i3 = 3, this._debugLog(1, 2, "Session expired, trying to create new Session.")) : this._debugLog(1, 1, `job ${e2.jobId} failed with error ${t3}.`), { status: i3, error: "", jobDescJson: "", data: new Uint8Array(0), missingInputUrls: [], inputs: [] };
    });
  }
  async _onNewJob() {
    const e2 = this._lyr3DMain.get_next_job(), t2 = this._layers.get(e2.layerId);
    if (!t2) return;
    this._incrementJobCount(t2);
    const i2 = t2.abortController.signal, s = t2.layerView.layer, a2 = "integrated-mesh-3dtiles" === s.type ? s.key : null, n2 = "integrated-mesh-3dtiles" === s.type ? s.session : null, o4 = { responseType: "array-buffer", signal: i2, query: { ...t2.customParameters, token: t2.apiKey, key: a2 } }, l2 = { id: e2.jobId, inputs: [], jobDescJson: e2.desc.slice(), isMissingResourceCase: false }, d2 = new URL(s.url), h = (a3) => {
      if (1 === a3.status) this._onJobFailed(t2, a3, e2);
      else if (0 === a3.status) this._onJobSucceeded(t2, a3, e2);
      else if (2 === a3.status) {
        const n3 = this._getRequestPromises(a3.missingInputUrls, o4, d2, s);
        Promise.all(n3).then((e3) => {
          l2.jobDescJson = a3.jobDescJson, a3.originalInputs ? l2.inputs = a3.originalInputs : l2.inputs = [], l2.isMissingResourceCase = true;
          for (const t3 of e3) l2.inputs.push(t3);
          return this._workerHandle.invoke(l2, i2);
        }).then((i3) => {
          1 === i3.status ? this._onJobFailed(t2, i3, e2) : 0 === i3.status && this._onJobSucceeded(t2, i3, e2);
        }).catch((i3) => {
          this._decrementJobCount(t2), d(i3) ? this._debugLog(1, 2, `job ${e2.jobId} was cancelled.`) : this._debugLog(1, 1, `job ${e2.jobId} failed with error2 ${i3}.`), this._lyr3DMain && this._lyr3DMain.on_job_failed(e2.jobId, e2.desc);
        });
      }
    };
    try {
      const t3 = await this._getInitialPromise(e2, o4, d2, s, l2, i2, n2);
      if (3 === t3.status && "integrated-mesh-3dtiles" === s.type) {
        n2 === s.session && null !== s.session && await s.requestRootAndSession(i2);
        h(await this._getInitialPromise(e2, o4, d2, s, l2, i2, s.session));
      } else h(t3);
    } catch (_) {
      _ && this._debugLog(1, 1, _.toString(), false), this._lyr3DMain && this._lyr3DMain.on_job_failed(e2.jobId, e2.desc), this._decrementJobCount(t2);
    }
  }
  _onNewRenderable() {
    const e2 = this._lyr3DMain.get_next_renderable(), t2 = e2.meshData;
    if (t2.data && t2.data.byteLength > 0) {
      const e3 = t2.data.slice();
      t2.data = e3;
    }
    const i2 = this._layers.get(e2.layerId);
    i2 && (this._incrementRenderableCount(i2), i2.layerView.createRenderable(e2).then((t3) => {
      this._lyr3DMain && this._lyr3DMain.on_renderable_created(true, e2.layerId, e2.handle, t3.memUsageBytes), this._decrementRenderableCount(i2);
    }).catch((t3) => {
      d(t3) || this._debugLog(2, 1, `createRenderable failed with error ${t3}.`), this._lyr3DMain && this._lyr3DMain.on_renderable_created(false, e2.layerId, e2.handle, 0), this._decrementRenderableCount(i2);
    }));
  }
  _freeRenderables(e2, t2, i2) {
    if (i2 < 1) return;
    const s = this._layers.get(e2);
    if (!s) return;
    const r2 = s.layerView, a2 = [], n2 = new Uint32Array(this._lyr3DMain.HEAPU32.buffer, t2, i2);
    for (let o4 = 0; o4 < i2; ++o4) a2.push(n2[o4]);
    for (let o4 = 0; o4 < i2; ++o4) r2.freeRenderable(a2[o4]);
  }
  _setRenderableVisibility(e2, t2, i2, s) {
    if (s < 1) return;
    const r2 = this._layers.get(e2);
    if (!r2) return;
    const a2 = r2.layerView, n2 = [], o4 = [], l2 = new Uint32Array(this._lyr3DMain.HEAPU32.buffer, t2, s), d2 = new Uint8Array(this._lyr3DMain.HEAPU8.buffer, i2, s);
    for (let h = 0; h < s; ++h) n2.push(l2[h]), o4.push(1 === d2[h]);
    a2.setRenderableVisibility(n2, o4, s);
  }
  _onWasmError(e2, t2, i2, s) {
    this._lyr3DMain && this._debugLog(i2, s, this._lyr3DMain.UTF8ToString(e2, t2), false);
  }
  _doRemoveLayerView(e2) {
    const t2 = this._layers.get(e2.wasmLayerId);
    return !!t2 && (t2.abortController.abort(), this._lyr3DMain.remove_layer(e2.wasmLayerId), this._layers.delete(e2.wasmLayerId), true);
  }
  _isGaussianSplatLayerView(e2) {
    return "gaussian-splat" === e2.layer.type;
  }
  _isGaussianSplatLayer(e2) {
    return "gaussian-splat" === e2.type;
  }
  _addLayerView(e2) {
    const t2 = e2.layer;
    if (!t2.url || !t2.rootTilesetJSON) return { wasmLayerId: o2 };
    const i2 = "integrated-mesh-3dtiles" === t2.type ? 0 : 2, r2 = this._lyr3DMain.validate_root_tileset(JSON.stringify(t2.rootTilesetJSON), i2);
    if (0 !== r2.errorCode) return { wasmLayerId: o2, check: r2 };
    const a2 = this._lyr3DMain.get_next_layer_id(), n2 = new AbortController();
    this._layers.set(a2, { layerView: e2, abortController: n2, needMemoryUsageUpdate: false, outstandingJobCount: 0, outstandingRenderableCount: 0, customParameters: t2.customParameters, apiKey: t2.apiKey, needFrame: false });
    const o4 = z(t2.elevationInfo), l2 = (e3) => i.getLogger(this).error("add-spatial-reference-error", "Error when adding SR:", e3);
    let _ = false;
    if (this._isGaussianSplatLayerView(e2) && this._isGaussianSplatLayer(t2)) {
      let i3 = t2.spatialReference;
      if (e2.useEsriCrs && t2.esriCrsSpatialReference) {
        i3 = t2.esriCrsSpatialReference;
        const s = c(i3);
        let r3 = 1, a3 = 1;
        !s && i3.wkid && -1 !== i3.wkid && (r3 = r.values[r[i3.wkid]], a3 = e2.metersPerVCSUnit), this._workerHandle.addSpatialReferenceInfo(this._cleanUpSR(this._makeSRWasmSerializable(i3)), s, r3, a3).catch(l2);
      }
      _ = this._lyr3DMain.add_gaussian_splat_layer(t2.url, a2, o4);
    } else _ = this._lyr3DMain.add_3dtiles_layer(t2.url, a2, o4);
    return _ ? (this._updateWasmCamera(), { wasmLayerId: a2 }) : (this._layers.delete(a2), { wasmLayerId: o2 });
  }
  _updateWasmCamera() {
    const e2 = this.view.state?.contentCamera;
    if (!e2 || !this._lyr3DMain) return;
    const { eye: t2, center: i2, up: s, near: r2, far: a2, fovY: n2 } = e2, o4 = [e2.viewport[2], e2.viewport[3]], l2 = e2.width / e2.height;
    this._lyr3DMain.set_camera_parameters({ eye: t2, center: i2, up: s, near: r2, far: a2, fov: n2, aspectRatio: l2, viewport: o4 });
  }
  _makeSRWasmSerializable(e2) {
    return { wkid: e2?.wkid ?? -1, latestWkid: e2?.latestWkid ?? -1, vcsWkid: e2?.vcsWkid ?? -1, latestVcsWkid: e2?.latestVcsWkid ?? -1, wkt: e2?.wkt ?? "" };
  }
  _cleanUpSR(e2) {
    return -1 === e2?.wkid && e2.latestWkid && -1 !== e2.latestWkid ? e2.wkid = e2.latestWkid : -1 === e2?.latestWkid && e2.wkid && -1 !== e2.wkid && (e2.latestWkid = e2.wkid), -1 === e2?.vcsWkid && e2.latestVcsWkid && -1 !== e2.latestVcsWkid ? e2.vcsWkid = e2.latestVcsWkid : -1 === e2?.latestVcsWkid && e2.vcsWkid && -1 !== e2.vcsWkid && (e2.latestVcsWkid = e2.vcsWkid), e2;
  }
};
__decorate([m({ constructOnly: true })], L.prototype, "view", void 0), L = __decorate([a("esri.layers.Lyr3DWasmPerSceneView")], L);
var v = L;
export {
  v as default
};
//# sourceMappingURL=Lyr3DWasmPerSceneView-TF7RBK75.js.map
