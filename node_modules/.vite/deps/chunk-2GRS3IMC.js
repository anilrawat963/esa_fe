import {
  n,
  o2 as o,
  r2 as r
} from "./chunk-GVFNGMIY.js";
import {
  u as u3
} from "./chunk-RQGBRVDD.js";
import {
  e,
  i as i4,
  t
} from "./chunk-JPZOLUPV.js";
import {
  e as e2,
  n as n2,
  r as r2,
  r2 as r3,
  t as t2
} from "./chunk-TWE24CRT.js";
import {
  p
} from "./chunk-WFCLXKCE.js";
import {
  y as y2
} from "./chunk-FHCV4NTV.js";
import {
  h,
  u as u2
} from "./chunk-NH6FXYCM.js";
import {
  a,
  s as s2
} from "./chunk-YE4E5JCT.js";
import {
  I,
  l as l2
} from "./chunk-ODQ5APZK.js";
import {
  B
} from "./chunk-BA6HYZ35.js";
import {
  i as i3
} from "./chunk-SJ2OBYX2.js";
import {
  Ht,
  P
} from "./chunk-JE2NJSBU.js";
import {
  N as N2
} from "./chunk-QNVJVDYZ.js";
import {
  b as b2
} from "./chunk-647DAMHU.js";
import {
  D
} from "./chunk-HWUOAPTX.js";
import {
  Ie,
  ge,
  y
} from "./chunk-MC6NAKKX.js";
import {
  u
} from "./chunk-TF6255HN.js";
import {
  c
} from "./chunk-UDHS2MGH.js";
import {
  f4 as f
} from "./chunk-PZ5RULLK.js";
import {
  i as i2
} from "./chunk-FPMLKIDB.js";
import {
  N,
  b
} from "./chunk-DDOCCRD4.js";
import {
  i3 as i,
  l3 as l,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  has
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Writer.js
var t3 = 1.25;
var r4 = class {
  get length() {
    return this._pos;
  }
  constructor(t5, r11) {
    this._pos = 0;
    const e4 = r11 ? this._roundToNearest(r11, t5.BYTES_PER_ELEMENT) : 40;
    this._array = new ArrayBuffer(e4), this._buffer = new t5(this._array), this._ctor = t5, this._i16View = new Int16Array(this._array);
  }
  _roundToNearest(t5, r11) {
    const e4 = Math.round(t5);
    return 1 === r11 ? e4 : e4 + (r11 - e4 % r11);
  }
  _ensureSize(r11) {
    if (this._pos + r11 >= this._buffer.length) {
      const e4 = this._roundToNearest((this._array.byteLength + r11 * this._buffer.BYTES_PER_ELEMENT) * t3, this._buffer.BYTES_PER_ELEMENT), s7 = new ArrayBuffer(e4), i7 = new this._ctor(s7);
      i7.set(this._buffer, 0), this._array = s7, this._buffer = i7, this._i16View = new Int16Array(this._array);
    }
  }
  ensureSize(t5) {
    this._ensureSize(t5);
  }
  writeF32(t5) {
    this._ensureSize(1);
    const r11 = this._pos;
    return new Float32Array(this._array, 4 * this._pos, 1)[0] = t5, this._pos++, r11;
  }
  push(t5) {
    this._ensureSize(1);
    const r11 = this._pos;
    return this._buffer[this._pos++] = t5, r11;
  }
  writeFixed(t5) {
    this._buffer[this._pos++] = t5;
  }
  setValue(t5, r11) {
    this._buffer[t5] = r11;
  }
  i1616Add(t5, r11, e4) {
    this._i16View[2 * t5] += r11, this._i16View[2 * t5 + 1] += e4;
  }
  getValue(t5) {
    return this._buffer[t5];
  }
  getValueF32(t5) {
    return new Float32Array(this._array, 4 * t5, 1)[0];
  }
  incr(t5) {
    if (this._buffer.length < t5) throw new Error("Increment index overflows the target buffer");
    this._buffer[t5]++;
  }
  decr(t5) {
    this._buffer[t5]--;
  }
  writeRegion(t5) {
    this._ensureSize(t5.length);
    const r11 = this._pos;
    return this._buffer.set(t5, this._pos), this._pos += t5.length, r11;
  }
  writeManyFrom(t5, r11, e4) {
    this._ensureSize(e4 - r11);
    for (let s7 = r11; s7 !== e4; s7++) this.writeFixed(t5._buffer[s7]);
  }
  buffer() {
    const t5 = this._array.slice(0, 4 * this._pos);
    return this.destroy(), t5;
  }
  toArray() {
    return [...this._buffer];
  }
  seek(t5) {
    this._pos = t5;
  }
  destroy() {
    this._array = null, this._buffer = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/VertexDataWriter.js
var e3 = 6;
var i5 = 4;
var r5 = class {
  constructor(r11, s7, n6 = 0) {
    const c4 = e3 * n6 * Uint32Array.BYTES_PER_ELEMENT, h3 = i5 * n6 * s7.stride, u4 = s7.stride / 4, _3 = s7.attributes.find((t5) => "pos" === t5.name || "position" === t5.name);
    if (!_3) throw new Error("InternalError: Unable to find position attribute");
    this.layout = { ...s7, position: _3 }, this._indices = new r4(Uint32Array, c4), this._vertices = new r4(Uint32Array, h3), this._metrics = new r4(Uint32Array, 0), this._metricCountOffset = this._metrics.push(0), this._strideInt = u4, this._instanceId = r11;
  }
  serialize(t5) {
    const e4 = this._indices.buffer(), i7 = this._vertices.buffer(), r11 = this._metrics.length ? this._metrics.buffer() : null;
    return t5.push(e4, i7), { instanceId: this._instanceId, layout: this.layout, indices: e4, vertices: i7, metrics: r11 };
  }
  get strideInt() {
    return this._strideInt;
  }
  get vertexCount() {
    return this._vertices.length / this._strideInt;
  }
  get indexCount() {
    return this._indices.length;
  }
  get indexWriter() {
    return this._indices;
  }
  get vertexWriter() {
    return this._vertices;
  }
  get metricWriter() {
    return this._metrics;
  }
  vertexEnsureSize(t5) {
    this._vertices.ensureSize(t5);
  }
  indexEnsureSize(t5) {
    this._indices.ensureSize(t5);
  }
  writeIndex(t5) {
    this._indices.push(t5);
  }
  writeVertex(t5) {
    this._vertices.push(t5);
  }
  writeVertexRegion(t5) {
    this._vertices.writeRegion(t5);
  }
  writeVertexF32(t5) {
    this._vertices.writeF32(t5);
  }
  writeMetric(t5) {
    this._metrics.incr(this._metricCountOffset), t5.serialize(this._metrics);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/MeshData.js
var n3 = class {
  constructor(e4, r11 = 0) {
    this._id = e4, this._sizeHint = r11, this._entityRecordCountOffset = 0, this._entityCountOffset = 0, this._entityIdIndex = 0, this._entitySortKeyIndex = 0, this._didEntityStart = false, this._instanceIdToVertexData = /* @__PURE__ */ new Map(), this._recordIndexStart = 0, this._recordIndexCount = 0, this._recordVertexStart = 0, this._recordVertexCount = 0, this._current = { metric: null, writer: null, start: 0, sortKey: 0, instanceId: 0, layoutHash: 0, indexStart: 0, vertexStart: 0, textureKey: 0, metricBoxLenPointer: 0 }, this._entities = new r4(Uint32Array, this._sizeHint * e.byteSizeHint), this._entityCountOffset = this._entities.push(0);
  }
  get id() {
    return this._id;
  }
  serialize() {
    const t5 = new Array(), e4 = [], r11 = this._entities.buffer();
    for (const i7 of this._instanceIdToVertexData.values()) e4.push(i7.serialize(t5));
    return { message: { data: e4, entities: r11 }, transferList: t5 };
  }
  vertexStart() {
    return this._current.vertexStart ?? 0;
  }
  vertexCount() {
    return this._current.writer?.vertexCount ?? 0;
  }
  indexCount() {
    return this._current.writer?.indexCount ?? 0;
  }
  vertexEnsureSize(t5) {
    this._current.writer.vertexEnsureSize(t5);
  }
  indexEnsureSize(t5) {
    this._current.writer.indexEnsureSize(t5);
  }
  vertexWrite(t5) {
    this._current.writer.writeVertex(t5);
  }
  vertexWriteRegion(t5) {
    this._current.writer.writeVertexRegion(t5);
  }
  vertexWriteF32(t5) {
    this._current.writer.writeVertexF32(t5);
  }
  recordBounds(t5, e4, r11, i7) {
  }
  indexWrite(t5) {
    this._current.writer.writeIndex(t5);
  }
  metricStart(t5) {
    this._current.metric = t5, this._current.metric.recordStart = this.recordCount();
  }
  metricEnd() {
    const t5 = this._current.writer;
    this._current.metric && (this._current.metric.recordCount = this.recordCount() - this._current.metric.recordStart), this._current.metric?.bounds.length && this._current.metric?.recordCount ? (t5.writeMetric(this._current.metric), this._current.metric = null) : this._current.metric = null;
  }
  metricBoxWrite(t5) {
    this._current.metric.bounds.push(t5);
  }
  entityStart(t5, e4 = t5) {
    this._entityIdIndex = this._entities.push(t5), this._entitySortKeyIndex = this._entities.writeF32(e4), this._entityRecordCountOffset = this._entities.push(0), this._didEntityStart = true;
  }
  entityRecordCount() {
    return this._entities.getValue(this._entityRecordCountOffset);
  }
  entityEnd() {
    if (!this._didEntityStart) return;
    0 === this.entityRecordCount() ? this._entities.seek(this._entityIdIndex) : this._entities.incr(this._entityCountOffset), this._didEntityStart = false;
  }
  recordCount() {
    return this._entities.getValue(this._entityRecordCountOffset);
  }
  recordStart(t5, e4, r11 = 0) {
    this._current.writer = this._getVertexWriter(t5, e4), this._current.indexStart = this._current.writer.indexCount, this._current.vertexStart = this._current.writer.vertexCount, this._current.instanceId = t5, this._current.layoutHash = e4.hash, this._current.textureKey = r11;
  }
  recordEnd(t5 = 0) {
    const r11 = this._current.vertexStart, i7 = this._current.writer.vertexCount - r11;
    if (!i7) return false;
    const n6 = this._current.indexStart, s7 = this._current.writer.indexCount - n6;
    return this._recordIndexStart = n6, this._recordIndexCount = s7, this._recordVertexStart = r11, this._recordVertexCount = i7, this._entities.incr(this._entityRecordCountOffset), t.write(this._entities, this._current.instanceId, this._current.textureKey, n6, s7, r11, i7, t5), true;
  }
  copyLast(t5, r11) {
    const i7 = this._recordVertexStart + this._recordVertexCount;
    this._entities.incr(this._entityRecordCountOffset), t.write(this._entities, this._current.instanceId, this._current.textureKey, this._recordIndexStart + this._recordIndexCount, this._recordIndexCount, i7, this._recordVertexCount, 0);
    const n6 = this._current.writer.indexWriter, s7 = this._current.writer.vertexWriter, c4 = this._recordIndexStart + this._recordIndexCount, o3 = this._recordVertexCount;
    for (let e4 = this._recordIndexStart; e4 !== c4; e4++) {
      const t6 = n6.getValue(e4);
      n6.push(t6 + o3);
    }
    const u4 = this._current.writer.layout.stride / Uint32Array.BYTES_PER_ELEMENT, h3 = this._recordVertexStart * u4, _3 = (this._recordVertexStart + this._recordVertexCount) * u4;
    for (let e4 = h3; e4 !== _3; e4++) {
      const t6 = s7.getValue(e4);
      s7.push(t6);
    }
    const d3 = this._current.writer.layout.position, a4 = d3.packPrecisionFactor ?? 1, x2 = d3.offset / Uint32Array.BYTES_PER_ELEMENT, y4 = t5 * a4, S = r11 * a4;
    for (let e4 = i7 * u4; e4 <= s7.length; e4 += u4) s7.i1616Add(e4 + x2, y4, S);
  }
  copyLastFrom(t5, e4, r11) {
    const i7 = t5._entities.getValue(t5._entityIdIndex);
    if (i7 !== this._entities.getValue(this._entityIdIndex)) {
      const e5 = t5._entities.getValueF32(t5._entitySortKeyIndex);
      this.entityStart(i7, e5);
    }
    this.recordStart(t5._current.instanceId, t5._current.writer.layout, t5._current.textureKey);
    const n6 = this._current.writer.layout.stride / Uint32Array.BYTES_PER_ELEMENT, s7 = this._current.vertexStart, c4 = t5._current.vertexStart - s7, o3 = this._current.writer.indexWriter, u4 = this._current.writer.vertexWriter, h3 = t5._current.writer.indexWriter, _3 = t5._current.writer.vertexWriter;
    for (let l5 = t5._current.indexStart; l5 !== h3.length; l5++) {
      const t6 = h3.getValue(l5);
      o3.push(t6 - c4);
    }
    for (let l5 = t5._current.vertexStart * n6; l5 !== _3.length; l5++) {
      const t6 = _3.getValue(l5);
      u4.push(t6);
    }
    const d3 = this._current.writer.layout.position, a4 = d3.packPrecisionFactor ?? 1, x2 = d3.offset / Uint32Array.BYTES_PER_ELEMENT, y4 = e4 * a4, S = r11 * a4;
    for (let l5 = s7 * n6; l5 <= u4.length; l5 += n6) u4.i1616Add(l5 + x2, y4, S);
    this.recordEnd();
  }
  _getVertexWriter(t5, e4) {
    const i7 = this._instanceIdToVertexData;
    return i7.has(t5) || i7.set(t5, new r5(t5, e4, this._sizeHint)), i7.get(t5);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/urlUtils.js
function r6(r11) {
  return "url" in r11 && "urlHash" in r11 ? { ...r11, url: "" } : r11;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/mesh/AResourceProxy.js
var s3 = class {
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/factories/ResourceProxy.js
var s4 = class extends s3 {
  constructor(e4) {
    super(), this._fetcher = e4, this._controller = new AbortController(), this._pendingIds = /* @__PURE__ */ new Set(), this._pendingRequests = [], this._resourceIdToResource = /* @__PURE__ */ new Map();
  }
  destroy() {
    this._controller.abort();
  }
  get _abortOptions() {
    return { signal: this._controller.signal };
  }
  enqueueRequest(r11) {
    const s7 = r6(r11.resource), o3 = l(JSON.stringify(s7));
    return this._pendingIds.has(o3) || (this._pendingIds.add(o3), this._pendingRequests.push({ ...r11, resourceId: o3 })), o3;
  }
  async fetchEnqueuedResources() {
    const e4 = this._pendingRequests;
    if (this._pendingIds.clear(), this._pendingRequests = [], 0 === e4.length) return;
    const t5 = await this._fetcher.fetch(e4, this._abortOptions);
    for (let r11 = 0; r11 < t5.length; r11++) {
      const s7 = e4[r11].resourceId;
      this._resourceIdToResource.set(s7, t5[r11]);
    }
  }
  async fetchResourceImmediate(e4) {
    const t5 = await this._fetcher.fetch([e4]);
    if (1 !== t5.length) throw new Error("FeaturePipelineResourceProxy: failed to fetch resources");
    return t5[0];
  }
  async fetchDictionaryResourceImmediate(e4) {
    const t5 = await this._fetcher.fetchDictionary([e4]);
    if (1 !== t5.length) throw new Error("FeaturePipelineResourceProxy: failed to fetch dictionary resources");
    return t5[0];
  }
  getResource(e4) {
    return this._resourceIdToResource.get(e4);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/AComputedField.js
var s5 = class {
  destroy() {
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/CachedField.js
var r7 = class extends s5 {
  constructor(e4) {
    super(), this._field = e4;
  }
  resize(e4) {
    throw new Error("Method not implemented.");
  }
  read(e4, r11) {
    return e4.readAttribute(this._field);
  }
  readWithDefault(e4, r11) {
    return e4.readAttribute(this._field);
  }
  hasArcadeDependency(e4) {
    return false;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/ComputedExpression.js
function c2(e4, t5) {
  const r11 = 43758.5453 * Math.sin(12.9898 * e4 + 78.233 * t5);
  return r11 - Math.floor(r11);
}
var i6 = class _i extends s5 {
  static async create(r11, s7) {
    const a4 = await h(r11, s7.spatialReference), c4 = l(r11);
    return new _i(a4, c4);
  }
  constructor(e4, t5) {
    super(), this._compiled = e4, this._cacheKey = t5;
  }
  resize(e4) {
  }
  read(e4, t5) {
    return this.hasArcadeDependency("scale") || "system" !== t5.$view.timeZone ? n2(this._compiled, e4, t5) : this._readCached(e4, t5);
  }
  readWithDefault(e4, t5, r11) {
    return this.hasArcadeDependency("scale") || "system" !== t5.$view.timeZone ? t2(this._compiled, e4, t5, r11) : this._readWithDefaultCached(e4, t5, r11);
  }
  hasArcadeDependency(e4) {
    return this._compiled?.references(e4) ?? false;
  }
  _getCacheKey(e4) {
    if (!this._compiled?.references("timeProperties")) return this._cacheKey;
    const { currentStart: t5, currentEnd: r11 } = e4.$view.timeProperties;
    return this._cacheKey + c2(t5 ?? 1, r11 ?? 1);
  }
  _readCached(e4, t5) {
    if (e4.setCache(this._getCacheKey(t5)), e4.hasCachedValue()) return e4.getCachedValue();
    const s7 = n2(this._compiled, e4, t5);
    return e4.setCachedValue(s7), s7;
  }
  _readWithDefaultCached(e4, t5, r11) {
    if (e4.setCache(this._getCacheKey(t5)), e4.hasCachedValue()) return e4.getCachedValue();
    const a4 = t2(this._compiled, e4, t5, r11);
    return e4.setCachedValue(a4), a4;
  }
};

// node_modules/@arcgis/core/layers/support/labelFormatUtils.js
function h2(e4, r11) {
  if (null == e4) return "";
  const t5 = r11.domain;
  if (t5) {
    if ("codedValue" === t5.type || "coded-value" === t5.type) {
      const r12 = e4;
      for (const e5 of t5.codedValues) if (e5.code === r12) return e5.name;
    } else if ("range" === t5.type) {
      const { max: n6, min: o3 } = y(r11), a4 = +e4;
      if (null != o3 && null != n6 && o3 <= a4 && a4 <= n6) return t5.name;
    }
  }
  let u4 = e4;
  return Ie(r11) ? u4 = b(u4, N("short-date")) : ge(r11) && (u4 = c(+u4)), u4 || "";
}

// node_modules/@arcgis/core/views/2d/layers/features/support/ComputedLegacyLabelExpression.js
var a2 = class _a extends s5 {
  static async create(t5, s7) {
    const l5 = p(t5);
    return new _a((e4) => l5.replaceAll(/{[^}]*}/g, (t6) => {
      const s8 = t6.slice(1, -1), a4 = e4.metadata.fieldsIndex.get(s8);
      if (null == a4) return t6;
      const l6 = e4.readAttribute(s8);
      return null == l6 ? "" : h2(l6, a4);
    }));
  }
  constructor(r11) {
    super(), this._evaluator = r11;
  }
  resize(r11) {
  }
  read(r11, e4) {
    return this._evaluator(r11);
  }
  readWithDefault(r11, e4, s7) {
    const a4 = this._evaluator(r11);
    return r2(a4) ? s7 : a4;
  }
  hasArcadeDependency(r11) {
    return false;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/DictionaryTemplate.js
var r8 = class extends s5 {
  constructor(e4, s7) {
    super(), this._template = e4, this._parts = a(e4.template, s7);
  }
  resize(t5) {
  }
  read(t5, s7) {
    return s2(t5, this._parts, this._template.textCase);
  }
  readWithDefault(t5, s7, r11) {
    return s2(t5, this._parts, this._template.textCase);
  }
  hasArcadeDependency(t5) {
    return false;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/NormalizedField.js
var r9 = class extends s5 {
  constructor(e4, r11) {
    super(), this._field = e4, this._normalizationInfo = r11;
  }
  resize(e4) {
    throw new Error("Method not implemented.");
  }
  read(e4, r11) {
    return this._readNormalized(e4);
  }
  readWithDefault(e4, r11) {
    return this._readNormalized(e4);
  }
  hasArcadeDependency(e4) {
    return false;
  }
  _readNormalized(e4) {
    const r11 = e4.readAttribute(this._field);
    if (null == r11) return null;
    const { normalizationField: t5, normalizationTotal: i7, normalizationType: o3 } = this._normalizationInfo, a4 = e4.readAttribute(t5);
    switch (o3 ?? "esriNormalizeByField") {
      case "esriNormalizeByField":
        return a4 ? a4 ? r11 / a4 : void 0 : null;
      case "esriNormalizeByLog":
        return Math.log(r11) * Math.LOG10E;
      case "esriNormalizeByPercentOfTotal":
        return i7 ? r11 / i7 * 100 : null;
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/whereUtils.js
var n4 = () => i.getLogger("esri.views.2d.layers.FeatureLayerView2D");
var o2 = { getAttribute: (r11, e4) => r11.readAttribute(e4) };
async function a3(e4, a4) {
  try {
    const s7 = await u(e4, a4);
    return s7.isStandardized || n4().error(new s("sql-parse-error", "expression is not standardized", { where: e4 })), (t5, a5) => {
      const i7 = t5.readArcadeFeature();
      try {
        return s7.testFeatureCompiled(i7, o2, a5.currentUser);
      } catch (u4) {
        return n4().warn(new s("sql-runtime-error", "Encountered an error when evaluating where clause", { where: e4, error: u4 })), true;
      }
    };
  } catch (s7) {
    return n4().warn(new s("sql-runtime-error", "Encountered an error when evaluating where clause", { where: e4, error: s7 })), (r11) => true;
  }
}

// node_modules/@arcgis/core/views/2d/layers/features/support/ComputedAttributeStorage.js
var c3 = () => i.getLogger("esri.views.2d.layers.features.support.ComputedAttributeStorage");
var m = 4294967295;
function p2(t5, e4, s7) {
  if (!(t5.length > e4)) for (; t5.length <= e4; ) t5.push(s7);
}
var l3 = class {
  constructor(t5) {
    this._numerics = [], this._strings = [], this._allocatedSize = 256, this._bitsets = [], this._instanceIds = [], this._bounds = [], this._dirtyBitset = this.getBitset(this.createBitset()), this.compilationOptions = t5;
  }
  createBitset() {
    const t5 = this._bitsets.length;
    return this._bitsets.push(e2.create(this._allocatedSize, n)), t5 + 1;
  }
  createDictionaryTemplateField(t5, e4) {
    return new r8(t5, e4);
  }
  async createComputedField(e4, s7 = false) {
    if (e4.expression) try {
      if (!this.compilationOptions) throw new Error("InternalError: Compilation options not defined");
      if (s7) return await a2.create(e4.expression, this.compilationOptions);
      return await i6.create(e4.expression, this.compilationOptions);
    } catch (u4) {
      const s8 = new s("featurelayer", "Failed to compile arcade expression", { error: u4, expression: e4.expression });
      return c3().error(s8), null;
    }
    if (e4.normalizationType || e4.normalizationField) return new r9(e4.field, e4);
    if (e4.field) return new r7(e4.field);
    const i7 = new s("featurelayer", "Unable to create computed field. No expression or field found", { info: e4 });
    return c3().error(i7), null;
  }
  async createWhereClause(t5) {
    return t5 ? a3(t5, this.compilationOptions.fields) : null;
  }
  getBitset(t5) {
    return this._bitsets[t5 - 1];
  }
  getComputedNumeric(t5, e4) {
    return this.getComputedNumericAtIndex(t5 & n, 0);
  }
  setComputedNumeric(t5, e4, s7) {
    return this.setComputedNumericAtIndex(t5 & n, s7, 0);
  }
  getComputedString(t5, e4) {
    return this.getComputedStringAtIndex(t5 & n, 0);
  }
  setComputedString(t5, e4, s7) {
    return this.setComputedStringAtIndex(t5 & n, 0, s7);
  }
  getComputedNumericAtIndex(t5, e4) {
    const s7 = t5 & n;
    return this._ensureNumeric(e4, s7), this._numerics[e4][s7];
  }
  setComputedNumericAtIndex(t5, e4, s7) {
    const r11 = t5 & n;
    this._ensureNumeric(e4, r11), this._numerics[e4][r11] = s7;
  }
  getPackedChunkId(t5) {
    const e4 = t5 & n;
    return this._ensureInstanceId(e4), this._instanceIds[e4];
  }
  setPackedChunkId(t5, e4) {
    const s7 = t5 & n;
    this._ensureInstanceId(s7), this._instanceIds[s7] = e4;
  }
  getComputedStringAtIndex(t5, e4) {
    const s7 = t5 & n;
    return this._ensureString(e4, s7), this._strings[e4][s7];
  }
  setComputedStringAtIndex(t5, e4, s7) {
    const r11 = t5 & n;
    this._ensureString(e4, r11), this._strings[e4][r11] = s7;
  }
  getXMin(t5) {
    return this._bounds[4 * (t5 & n)];
  }
  getYMin(t5) {
    return this._bounds[4 * (t5 & n) + 1];
  }
  getXMax(t5) {
    return this._bounds[4 * (t5 & n) + 2];
  }
  getYMax(t5) {
    return this._bounds[4 * (t5 & n) + 3];
  }
  setBounds(t5, e4, s7 = false) {
    const r11 = t5 & n;
    if (!s7 && !this._dirtyBitset.has(t5)) return this._bounds[4 * r11] !== m;
    this._dirtyBitset.unset(t5);
    const n6 = e4.readGeometryWorldSpace();
    if (p2(this._bounds, 4 * r11 + 4, 0), !n6 || !n6.coords.length) return this._bounds[4 * r11] = m, this._bounds[4 * r11 + 1] = m, this._bounds[4 * r11 + 2] = m, this._bounds[4 * r11 + 3] = m, false;
    let o3 = 1 / 0, u4 = 1 / 0, d3 = -1 / 0, h3 = -1 / 0;
    return n6.forEachVertex((t6, e5) => {
      o3 = Math.min(o3, t6), u4 = Math.min(u4, e5), d3 = Math.max(d3, t6), h3 = Math.max(h3, e5);
    }), this._bounds[4 * r11] = o3, this._bounds[4 * r11 + 1] = u4, this._bounds[4 * r11 + 2] = d3, this._bounds[4 * r11 + 3] = h3, true;
  }
  getBounds(t5, e4) {
    const i7 = this.getXMin(e4), r11 = this.getYMin(e4), n6 = this.getXMax(e4), o3 = this.getYMax(e4);
    return D(t5, i7, r11, n6, o3), i7 !== m;
  }
  _ensureNumeric(t5, e4) {
    this._numerics[t5] || (this._numerics[t5] = []);
    p2(this._numerics[t5], e4, 0);
  }
  _ensureInstanceId(t5) {
    p2(this._instanceIds, t5, 0);
  }
  _ensureString(t5, e4) {
    this._strings[t5] || (this._strings[t5] = []);
    p2(this._strings[t5], e4, null);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/debug.js
var n5 = (n6, l5) => n6 && ((...n7) => l5.warn("DEBUG:", ...n7)) || (() => null);
var l4 = false;

// node_modules/@arcgis/core/views/2d/layers/features/support/DisplayIdGenerator.js
var _s = class _s {
  constructor(e4) {
    this.data = e4, this._referenceCount = 0;
  }
  increment() {
    this._referenceCount += 1;
  }
  decrement() {
    this._referenceCount -= 1;
  }
  empty() {
    return 0 === this._referenceCount;
  }
};
_s.estimatedMemory = 20;
var s6 = _s;
var r10 = class {
  constructor() {
    this._freeIdsGenerationA = [], this._freeIdsGenerationB = [], this._idCounter = 1, this._freeIds = this._freeIdsGenerationA, this._objectIdToDisplayId = /* @__PURE__ */ new Map();
  }
  get usedMemory() {
    let t5 = 0;
    return t5 += i3(this._freeIdsGenerationA), t5 += i3(this._freeIdsGenerationB), t5 += this._objectIdToDisplayId.size * (s6.estimatedMemory + 8), t5;
  }
  createIdForObjectId(e4) {
    let r11 = this._objectIdToDisplayId.get(e4);
    return r11 ? r11.increment() : (r11 = new s6(r(this._getFreeId(), false)), r11.increment(), this._objectIdToDisplayId.set(e4, r11)), r11.data;
  }
  releaseIdForObjectId(e4) {
    const t5 = this._objectIdToDisplayId.get(e4);
    t5 && (t5.decrement(), t5.empty() && (this._objectIdToDisplayId.delete(e4), this._freeIds.push(t5.data)));
  }
  getDisplayIdForObjectId(e4) {
    const t5 = this._objectIdToDisplayId.get(e4);
    return null != t5 ? t5.data : null;
  }
  releaseAll() {
    for (const e4 of this._objectIdToDisplayId.values()) this._freeIds.push(e4.data);
    this._objectIdToDisplayId.clear();
  }
  incrementGeneration() {
    this._freeIds = this._freeIds === this._freeIdsGenerationA ? this._freeIdsGenerationB : this._freeIdsGenerationA;
  }
  _getFreeId() {
    return this._freeIds.length ? this._freeIds.pop() : this._idCounter++;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureFilterEvaluator.js
var m2 = 1;
var d2 = 2;
var p3 = class _p {
  constructor(t5) {
    this._geometryBounds = i2(), this._idToVisibility = /* @__PURE__ */ new Map(), this._serviceInfo = t5;
  }
  static async create(t5) {
    const e4 = new _p(t5);
    return await e4.update(t5.filterJSON, t5.spatialReference), e4;
  }
  get hash() {
    return this._hash;
  }
  check(t5, e4) {
    return this._applyFilter(t5, e4);
  }
  invalidate() {
    this._idToVisibility.forEach((t5, e4) => {
      this._idToVisibility.set(e4, 0);
    });
  }
  setKnownIds(t5) {
    for (const e4 of t5) this._idToVisibility.set(e4, m2);
  }
  setTrue(t5) {
    const e4 = [], i7 = [], s7 = new Set(t5);
    return this._idToVisibility.forEach((t6, r11) => {
      const o3 = !!(this._idToVisibility.get(r11) & m2), a4 = s7.has(r11);
      !o3 && a4 ? e4.push(r11) : o3 && !a4 && i7.push(r11), this._idToVisibility.set(r11, a4 ? m2 | d2 : 0);
    }), { show: e4, hide: i7 };
  }
  createQuery() {
    const { geometry: t5, spatialRel: e4, where: i7, timeExtent: s7, objectIds: r11 } = this;
    return b2.fromJSON({ geometry: t5, spatialRel: e4, where: i7, timeExtent: s7, objectIds: r11 });
  }
  async update(t5, e4) {
    this._hash = JSON.stringify(t5);
    const i7 = await B(t5, null, e4);
    await Promise.all([this._setGeometryFilter(i7), this._setIdFilter(i7), this._setAttributeFilter(i7), this._setTimeFilter(i7)]);
  }
  async _setAttributeFilter(t5) {
    if (!t5?.where) return this._clause = null, void (this.where = null);
    this._clause = await a3(t5.where, this._serviceInfo.fieldsIndex), this.where = t5.where;
  }
  _setIdFilter(t5) {
    this._idsToShow = t5?.objectIds && new Set(t5.objectIds), this._idsToHide = t5?.hiddenIds && new Set(t5.hiddenIds), this.objectIds = t5?.objectIds;
  }
  async _setGeometryFilter(t5) {
    if (!t5?.geometry) return this._spatialQueryOperator = null, this.geometry = null, void (this.spatialRel = null);
    const e4 = t5.geometry, i7 = t5.spatialRel ?? "esriSpatialRelIntersects", r11 = await I(i7, e4, this._serviceInfo.geometryType, this._serviceInfo.hasZ, this._serviceInfo.hasM);
    f(this._geometryBounds, e4), this._spatialQueryOperator = r11, this.geometry = e4, this.spatialRel = i7;
  }
  _setTimeFilter(i7) {
    if (this.timeExtent = this._timeOperator = null, i7?.timeExtent) {
      if (!this._serviceInfo.timeInfo) {
        const s7 = new s("feature-layer-view:time-filter-not-available", "Unable to apply time filter, as layer doesn't have time metadata.", i7.timeExtent);
        return void i.getLogger("esri.views.2d.layers.features.controllers.FeatureFilter").error(s7);
      }
      this.timeExtent = i7.timeExtent, this._timeOperator = l2(this._serviceInfo.timeInfo, i7.timeExtent, r3.Shared);
    }
  }
  _applyFilter(t5, e4) {
    return this._filterByGeometry(t5) && this._filterById(t5) && this._filterByTime(t5) && this._filterByExpression(t5, e4);
  }
  _filterByExpression(t5, e4) {
    return !this.where || this._clause(t5, e4);
  }
  _filterById(t5) {
    return (!this._idsToHide?.size || !this._idsToHide.has(t5.getObjectId())) && (!this._idsToShow?.size || this._idsToShow.has(t5.getObjectId()));
  }
  _filterByGeometry(t5) {
    if (!this.geometry) return true;
    const e4 = t5.readGeometryWorldSpace();
    return !!e4 && this._spatialQueryOperator(e4);
  }
  _filterByTime(t5) {
    return null == this._timeOperator || this._timeOperator(t5);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/AttributeStore.js
function g(t5, e4) {
  if (!t5 || !e4) return t5;
  switch (e4) {
    case "radius":
    case "distance":
      return 2 * t5;
    case "diameter":
    case "width":
      return t5;
    case "area":
      return Math.sqrt(t5);
  }
  return t5;
}
var f2 = () => i.getLogger("esri.views.layers.2d.features.support.AttributeStore");
var _2 = n5(l4, f2());
var y3 = { sharedArrayBuffer: has("esri-shared-array-buffer"), atomics: has("esri-atomics") };
var m3 = class {
  constructor(t5, e4, i7) {
    this.size = 0, this.texelSize = 4, this.dirtyStart = 0, this.dirtyEnd = 0;
    const { pixelType: s7, layout: r11, textureOnly: a4 } = e4;
    this.textureOnly = a4 || false, this.pixelType = s7, this.layout = r11, this._resetRange(), this.size = t5, this.isLocal = i7, a4 || (this.data = this._initData(s7, t5));
  }
  get usedMemory() {
    return this.data?.byteLength ?? 0;
  }
  get buffer() {
    return this.data?.buffer;
  }
  unsetComponentAllTexels(t5, e4) {
    const i7 = this.data;
    for (let s7 = 0; s7 < this.size * this.size; s7++) i7[s7 * this.texelSize + t5] &= ~e4;
    this.dirtyStart = 0, this.dirtyEnd = this.size * this.size - 1;
  }
  setComponentAllTexels(t5, e4) {
    const i7 = this.data;
    for (let s7 = 0; s7 < this.size * this.size; s7++) i7[s7 * this.texelSize + t5] |= 255 & e4;
    this.dirtyStart = 0, this.dirtyEnd = this.size * this.size - 1;
  }
  setComponent(t5, e4, i7) {
    const s7 = this.data;
    for (const r11 of i7) s7[r11 * this.texelSize + t5] |= e4, this.dirtyStart = Math.min(this.dirtyStart, r11), this.dirtyEnd = Math.max(this.dirtyEnd, r11);
  }
  setComponentTexel(t5, e4, i7) {
    this.data[i7 * this.texelSize + t5] |= e4, this.dirtyStart = Math.min(this.dirtyStart, i7), this.dirtyEnd = Math.max(this.dirtyEnd, i7);
  }
  unsetComponentTexel(t5, e4, i7) {
    this.data[i7 * this.texelSize + t5] &= ~e4, this.dirtyStart = Math.min(this.dirtyStart, i7), this.dirtyEnd = Math.max(this.dirtyEnd, i7);
  }
  getData(t5, e4) {
    const i7 = o(t5);
    return this.data[i7 * this.texelSize + e4];
  }
  setData(t5, e4, i7) {
    const s7 = o(t5), r11 = 1 << e4;
    0 !== (this.layout & r11) ? null != this.data && (this.data[s7 * this.texelSize + e4] = i7, this.dirtyStart = Math.min(this.dirtyStart, s7), this.dirtyEnd = Math.max(this.dirtyEnd, s7)) : f2().error("mapview-attributes-store", "Tried to set a value for a texel's readonly component");
  }
  expand(t5) {
    if (this.size = t5, !this.textureOnly) {
      const e4 = this._initData(this.pixelType, t5), i7 = this.data;
      e4.set(i7), this.data = e4;
    }
  }
  toMessage() {
    const t5 = this.dirtyStart, e4 = this.dirtyEnd, i7 = this.texelSize;
    if (t5 > e4) return null;
    this._resetRange();
    const s7 = !this.isLocal, r11 = this.pixelType, a4 = this.layout, n6 = this.data;
    return { start: t5, end: e4, data: s7 && n6.slice(t5 * i7, (e4 + 1) * i7) || null, pixelType: r11, layout: a4 };
  }
  _initData(t5, e4) {
    const i7 = ArrayBuffer, s7 = i4(t5), r11 = new s7(new i7(e4 * e4 * 4 * s7.BYTES_PER_ELEMENT));
    for (let a4 = 0; a4 < r11.length; a4 += 4) r11[a4 + 1] = 255;
    return r11;
  }
  _resetRange() {
    this.dirtyStart = 2147483647, this.dirtyEnd = 0;
  }
};
var b3 = class {
  constructor(t5) {
    this._client = t5, this._filters = [], this._blocks = new Array(), this._attributeComputeInfo = null, this._abortController = new AbortController(), this._size = Ht, this._idsToHighlight = /* @__PURE__ */ new Map(), this._arcadeDependencies = /* @__PURE__ */ new Set(), this._initialized = false, this.version = 0, this._idGenerator = new r10(), this._epoch = 1;
  }
  destroy() {
    this._abortController.abort();
  }
  _initialize() {
    if (null != this._blockDescriptors) return;
    const t5 = N2.FLOAT;
    _2(`Creating AttributeStore ${y3.sharedArrayBuffer ? "with" : "without"} shared memory`), this._blockDescriptors = [{ pixelType: N2.UNSIGNED_BYTE, layout: 1 }, { pixelType: N2.UNSIGNED_BYTE, layout: 15, textureOnly: true }, { pixelType: N2.UNSIGNED_BYTE, layout: 15, textureOnly: true }, { pixelType: t5, layout: 15 }, { pixelType: t5, layout: 15 }, { pixelType: t5, layout: 15 }, { pixelType: t5, layout: 15 }, { pixelType: N2.FLOAT, layout: 15 }], this._blocks = this._blockDescriptors.map(() => null);
  }
  get usedMemory() {
    let t5 = 0;
    for (const e4 of this._blocks) e4 && (t5 += e4.usedMemory);
    return t5 += this._idGenerator.usedMemory, t5;
  }
  get hasHighlight() {
    return this._idsToHighlight.size > 0;
  }
  createDisplayIdForObjectId(t5) {
    return this._idGenerator.createIdForObjectId(t5);
  }
  releaseDisplayIdForObjectId(t5) {
    return this._idGenerator.releaseIdForObjectId(t5);
  }
  getDisplayIdForObjectId(t5) {
    return this._idGenerator.getDisplayIdForObjectId(t5);
  }
  incrementDisplayIdGeneration() {
    this._idGenerator.incrementGeneration();
  }
  hasArcadeDependency(t5) {
    return this._arcadeDependencies.has(t5);
  }
  releaseAllIds() {
    this._idGenerator.releaseAll();
  }
  async update(t5, e4, s7, r11 = 0) {
    const a4 = y2(this._schema, t5);
    if (this.version = r11, a4 && (has("esri-2d-update-debug") && console.debug(`Version[${r11}] AttributeStore.update`, { changed: a4 }), this._schema = t5, this._attributeComputeInfo = null, this._initialize(), null != t5)) if (s7 && (this._filters = await Promise.all(t5.filters.map((t6) => t6 ? p3.create({ geometryType: s7.geometryType, hasM: false, hasZ: false, timeInfo: s7.timeInfo, fieldsIndex: s7.fieldsIndex, spatialReference: s7.outSpatialReference, filterJSON: t6 }) : null))), "multi" !== t5.type) this._attributeComputeInfo = { type: "feature", map: /* @__PURE__ */ new Map() }, await Promise.all(t5.bindings.map(async (t6) => {
      const i7 = await this._bind(e4, t6);
      this._updateReferences(i7);
    }));
    else {
      this._attributeComputeInfo = { type: "multi", keyField: t5.keyField, map: /* @__PURE__ */ new Map() };
      for (const i7 in t5.bindings) {
        const s8 = t5.bindings[i7];
        await Promise.all(s8.map(async (t6) => {
          const s9 = await this._bind(e4, t6, parseInt(i7, 10));
          this._updateReferences(s9);
        }));
      }
    }
  }
  setHighlight(t5, e4) {
    let i7 = null;
    0 === t5.length && 0 === e4.length && (i7 = this._getBlock(0), i7.unsetComponentAllTexels(0, (1 << P) - 1));
    for (const { displayId: s7, highlightFlags: r11 } of t5) {
      if (null == s7 || -1 === s7) continue;
      i7 || (i7 = this._getBlock(0), i7.unsetComponentAllTexels(0, (1 << P) - 1));
      const t6 = o(s7);
      i7.setComponent(0, r11, [t6]);
    }
    this._idsToHighlight.clear();
    for (const { objectId: s7, highlightFlags: r11 } of t5) this._idsToHighlight.set(s7, r11);
    for (const { objectId: s7, highlightFlags: r11 } of e4) this._idsToHighlight.set(s7, r11);
  }
  setData(t5, e4, i7, s7) {
    const r11 = o(t5);
    this._ensureSizeForTexel(r11), this._getBlock(e4).setData(t5, i7, s7);
  }
  getData(t5, e4, i7) {
    return this._getBlock(e4).getData(t5, i7);
  }
  getHighlightFlags(t5) {
    return this._idsToHighlight.get(t5) || 0;
  }
  unsetAttributeData(t5) {
    const e4 = o(t5);
    this._getBlock(0).setData(e4, 0, 0);
  }
  referencesScale() {
    const t5 = this._attributeComputeInfo;
    if (!t5) return false;
    if ("multi" === t5.type) {
      for (const e4 of t5.map.values()) for (const { field: t6 } of e4.values()) if (t6?.hasArcadeDependency("scale")) return true;
    } else for (const { field: e4 } of t5.map.values()) if (e4?.hasArcadeDependency("scale")) return true;
    return false;
  }
  setAttributeData(t5, e4, i7, s7) {
    const r11 = o(t5);
    this._ensureSizeForTexel(r11), this._getBlock(0).setData(r11, 0, this.getFilterFlags(e4, s7));
    const a4 = this._attributeComputeInfo, o3 = 1, h3 = 4;
    let d3 = null;
    a4 && (d3 = "multi" === a4.type ? a4.map.get(e4.readAttribute(a4.keyField)) : a4.map, d3?.size && d3.forEach((t6, s8) => {
      const a5 = s8 * o3 % h3, n6 = Math.floor(s8 * o3 / h3), d4 = this._getBlock(n6 + 3);
      let c4 = t6.field?.read(e4, i7);
      t6.valueRepresentation && (c4 = g(c4, t6.valueRepresentation));
      (null === c4 || isNaN(c4) || c4 === 1 / 0 || c4 === -1 / 0) && (c4 = u3), d4.setData(r11, a5, c4);
    }));
  }
  get epoch() {
    return this._epoch;
  }
  sendUpdates() {
    const t5 = this._blocks.map((t6) => null != t6 ? t6.toMessage() : null), e4 = this._getInitArgs();
    has("esri-2d-log-updating") && console.log("AttributeStore: _doSendUpdate.start"), this._client.update({ initArgs: e4, blockData: t5, version: this.version, sendUpdateEpoch: this._epoch }), this._epoch += 1, has("esri-2d-log-updating") && console.log("AttributeStore: _doSendUpdate.end");
  }
  _ensureSizeForTexel(t5) {
    for (; t5 >= this._size * this._size; ) if (this._expand()) return;
  }
  async _bind(t5, e4, i7) {
    const s7 = await t5.createComputedField(e4), { valueRepresentation: r11 } = e4, a4 = this._attributeComputeInfo;
    if ("multi" === a4.type) {
      const t6 = a4.map.get(i7) ?? /* @__PURE__ */ new Map();
      t6.set(e4.binding, { field: s7, valueRepresentation: r11 }), a4.map.set(i7, t6);
    } else a4.map.set(e4.binding, { field: s7, valueRepresentation: r11 });
    return s7;
  }
  _getInitArgs() {
    return this._initialized ? null : (this._initialized = true, this._getBlock(1), this._getBlock(2), this._getBlock(7), { blockSize: this._size, blockDescriptors: this._blocks.map((t5) => null != t5 ? { textureOnly: t5.textureOnly, buffer: t5.buffer, pixelType: t5.pixelType } : null) });
  }
  _getBlock(t5) {
    const e4 = this._blocks[t5];
    if (null != e4) return e4;
    _2(`Initializing AttributeBlock at index ${t5}`);
    const i7 = new m3(this._size, this._blockDescriptors[t5], this._client.isLocal);
    return this._blocks[t5] = i7, this._initialized = false, i7;
  }
  _expand() {
    if (this._size < this._schema.capabilities.maxTextureSize) {
      const t5 = this._size <<= 1;
      _2("Expanding block size to", t5, this._blocks);
      for (const e4 of this._blocks) e4?.expand(t5);
      return this._initialized = false, this._size = t5, 0;
    }
    return f2().error(new s("mapview-limitations", "Maximum number of onscreen features exceeded.")), -1;
  }
  _updateReferences(t5) {
    u2(this._arcadeDependencies, t5);
  }
  isVisible(t5) {
    return !!(this._getBlock(0).getData(t5, 0) & 1 << P);
  }
  getFilterFlags(t5, e4) {
    let i7 = 0;
    for (let r11 = 0; r11 < this._filters.length; r11++) {
      const s8 = !!(1 << r11), a4 = this._filters[r11];
      i7 |= (!s8 || null == a4 || a4.check(t5, e4) ? 1 : 0) << r11;
    }
    let s7 = 0;
    if (this._idsToHighlight.size) {
      const e5 = t5.getObjectId();
      s7 = this.getHighlightFlags(e5);
    }
    return i7 << P | s7;
  }
};

export {
  n3 as n,
  r6 as r,
  s4 as s,
  s5 as s2,
  l3 as l,
  p3 as p,
  b3 as b
};
//# sourceMappingURL=chunk-2GRS3IMC.js.map
