import {
  r as r2
} from "./chunk-3U5UUY3S.js";
import {
  p as p2
} from "./chunk-UOYGMZIS.js";
import {
  $
} from "./chunk-RXH2WNPA.js";
import {
  u as u2
} from "./chunk-76V6RN4F.js";
import {
  n as n2
} from "./chunk-GCTH5LET.js";
import {
  b as b2
} from "./chunk-647DAMHU.js";
import {
  i,
  p
} from "./chunk-QZQPB5XR.js";
import {
  D as D2
} from "./chunk-23NJHA5Q.js";
import {
  Fe,
  ye
} from "./chunk-MC6NAKKX.js";
import {
  u
} from "./chunk-TF6255HN.js";
import {
  D,
  N
} from "./chunk-CNYNCKEV.js";
import {
  b
} from "./chunk-XL5QPCXN.js";
import {
  e
} from "./chunk-QF7FRVN6.js";
import {
  s2 as s3
} from "./chunk-V2H77UEV.js";
import {
  r
} from "./chunk-SOIZOFSB.js";
import {
  n
} from "./chunk-XXLHAM2M.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2,
  s3 as s2,
  w
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  o
} from "./chunk-65HD3WXL.js";
import {
  a,
  s2 as s
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/rest/support/AttachmentQuery.js
var a3;
var _a;
var p3 = (_a = class extends n {
  constructor(t) {
    super(t), this.attachmentTypes = null, this.attachmentsWhere = null, this.cacheHint = void 0, this.keywords = null, this.globalIds = null, this.name = null, this.num = null, this.objectIds = null, this.orderByFields = null, this.returnMetadata = false, this.size = null, this.start = null, this.where = null;
  }
  writeStart(t, e2) {
    e2.resultOffset = this.start, e2.resultRecordCount = this.num || 10;
  }
  clone() {
    return new a3(a({ attachmentTypes: this.attachmentTypes, attachmentsWhere: this.attachmentsWhere, cacheHint: this.cacheHint, keywords: this.keywords, where: this.where, globalIds: this.globalIds, name: this.name, num: this.num, objectIds: this.objectIds, orderByFields: this.orderByFields, returnMetadata: this.returnMetadata, size: this.size, start: this.start }));
  }
}, a3 = _a, _a);
__decorate([m({ type: [String], json: { write: true } })], p3.prototype, "attachmentTypes", void 0), __decorate([m({ type: String, json: { read: { source: "attachmentsDefinitionExpression" }, write: { target: "attachmentsDefinitionExpression" } } })], p3.prototype, "attachmentsWhere", void 0), __decorate([m({ type: Boolean, json: { write: true } })], p3.prototype, "cacheHint", void 0), __decorate([m({ type: [String], json: { write: true } })], p3.prototype, "keywords", void 0), __decorate([m({ type: [String], json: { write: true } })], p3.prototype, "globalIds", void 0), __decorate([m({ json: { write: true } })], p3.prototype, "name", void 0), __decorate([m({ type: Number, json: { read: { source: "resultRecordCount" } } })], p3.prototype, "num", void 0), __decorate([m({ type: [Number], json: { write: true } })], p3.prototype, "objectIds", void 0), __decorate([m({ type: [String], json: { write: true } })], p3.prototype, "orderByFields", void 0), __decorate([m({ type: Boolean, json: { default: false, write: true } })], p3.prototype, "returnMetadata", void 0), __decorate([m({ type: [Number], json: { write: true } })], p3.prototype, "size", void 0), __decorate([m({ type: Number, json: { read: { source: "resultOffset" } } })], p3.prototype, "start", void 0), __decorate([r("start"), r("num")], p3.prototype, "writeStart", null), __decorate([m({ type: String, json: { read: { source: "definitionExpression" }, write: { target: "definitionExpression" } } })], p3.prototype, "where", void 0), p3 = a3 = __decorate([a2("esri.rest.support.AttachmentQuery")], p3), p3.from = w(p3);

// node_modules/@arcgis/core/layers/support/featureLayerUtils.js
var j = new o({ esriGeometryPoint: "point", esriGeometryMultipoint: "multipoint", esriGeometryPolyline: "polyline", esriGeometryPolygon: "polygon", esriGeometryMultiPatch: "multipatch" });
async function F(e2, t, n3, o2) {
  const i2 = await $2(e2);
  if (await x(e2, t, o2), !i2.addAttachment) throw new s(o2, "Layer source does not support addAttachment capability");
  return i2.addAttachment(t, n3);
}
function x(e2, t, n3) {
  const { attributes: o2 } = t, { objectIdField: i2 } = e2;
  return e2.capabilities?.data?.supportsAttachment ? t ? o2 ? i2 && o2[i2] ? Promise.resolve() : Promise.reject(new s(n3, `feature is missing the identifying attribute ${i2}`)) : Promise.reject(new s(n3, "'attributes' are required on a feature to query attachments")) : Promise.reject(new s(n3, "A feature is required to add/delete/update attachments")) : Promise.reject(new s(n3, "this layer doesn't support attachments"));
}
async function P(e2, t, n3, o2, i2) {
  const s4 = await $2(e2);
  if (await x(e2, t, i2), !s4.updateAttachment) throw new s(i2, "Layer source does not support updateAttachment capability");
  return s4.updateAttachment(t, n3, o2);
}
async function q(e2, t, r3) {
  const { applyEdits: n3 } = await import("./editingSupport-AZ6EUTCP.js"), o2 = await e2.load();
  let i2 = r3;
  return "feature" === o2.type && o2.infoFor3D && null != t.deleteFeatures && null != o2.globalIdField && (i2 = { ...i2, globalIdToObjectId: await ne(o2, t.deleteFeatures, o2.globalIdField) }), n3(o2, o2.source, t, r3);
}
async function S(e2, t, r3) {
  const { uploadAssets: n3 } = await import("./editingSupport-AZ6EUTCP.js"), o2 = await e2.load();
  return n3(o2, o2.source, t, r3);
}
async function v(e2, t, n3, o2) {
  const i2 = await $2(e2);
  if (await x(e2, t, o2), !i2.deleteAttachments) throw new s(o2, "Layer source does not support deleteAttachments capability");
  return i2.deleteAttachments(t, n3);
}
async function O(e2, t, n3) {
  const o2 = (await e2.load({ signal: t?.signal })).source;
  if (!o2.fetchRecomputedExtents) throw new s(n3, "Layer source does not support fetchUpdates capability");
  return o2.fetchRecomputedExtents(t);
}
async function A(e2, t, n3, o2) {
  t = p3.from(t), await e2.load();
  const i2 = e2.source, s4 = e2.capabilities;
  if (!s4?.data?.supportsAttachment) throw new s(o2, "this layer doesn't support attachments");
  const { attachmentTypes: a4, objectIds: u3, globalIds: c, num: l, size: p4, start: d, where: f } = t;
  if (!s4?.operations?.supportsQueryAttachments) {
    if (a4?.length > 0 || c?.length > 0 || p4?.length > 0 || l || d || f) throw new s(o2, "when 'capabilities.operations.supportsQueryAttachments' is false, only objectIds is supported", t);
  }
  if (!(u3?.length || c?.length || f)) throw new s(o2, "'objectIds', 'globalIds', or 'where' are required to perform attachment query", t);
  if (!i2.queryAttachments) throw new s(o2, "Layer source does not support queryAttachments capability", t);
  return !s4?.attachment?.supportsOrderByFields && t.orderByFields?.length && ((t = t.clone()).orderByFields = null), i2.queryAttachments(t);
}
async function L(e2, t, n3, o2) {
  const i2 = await $2(e2);
  if (!i2.queryObjectIds) throw new s(o2, "Layer source does not support queryObjectIds capability");
  return i2.queryObjectIds(b2.from(t) ?? e2.createQuery(), n3);
}
async function E(e2, t, n3, o2) {
  const i2 = await $2(e2);
  if (!i2.queryFeatureCount) throw new s(o2, "Layer source does not support queryFeatureCount capability");
  return i2.queryFeatureCount(b2.from(t) ?? e2.createQuery(), n3);
}
async function D3(e2, t, n3, o2) {
  const i2 = await $2(e2);
  if (!i2.queryExtent) throw new s(o2, "Layer source does not support queryExtent capability");
  return i2.queryExtent(b2.from(t) ?? e2.createQuery(), n3);
}
async function T(e2, t, n3, o2) {
  const i2 = await $2(e2);
  if (!i2.queryRelatedFeatures) throw new s(o2, "Layer source does not support queryRelatedFeatures capability");
  return i2.queryRelatedFeatures(u2.from(t), n3);
}
async function C(e2, t, n3, o2) {
  const i2 = await $2(e2);
  if (!i2.queryRelatedFeaturesCount) throw new s(o2, "Layer source does not support queryRelatedFeaturesCount capability");
  return i2.queryRelatedFeaturesCount(u2.from(t), n3);
}
async function B(e2) {
  const t = e2.source;
  if (t?.refresh) try {
    const { dataChanged: r3, updates: n3 } = await t.refresh();
    if (null != n3 && (e2.sourceJSON = { ...e2.sourceJSON, ...n3 }, e2.read(n3, { origin: "service", url: e2.parsedUrl })), r3) return true;
  } catch {
  }
  if (e2.definitionExpression) try {
    return (await u(e2.definitionExpression, e2.fieldsIndex)).hasDateFunctions;
  } catch {
  }
  return false;
}
function R(e2) {
  const t = new b2();
  t.historicMoment = e2.historicMoment, t.gdbVersion = e2.gdbVersion, t.returnGeometry = true, t.outFields = ["*"], t.multipatchOption = "multipatch" === e2.geometryType ? "xyFootprint" : null;
  const r3 = e2.capabilities?.query;
  r3 && (t.compactGeometryEnabled = r3.supportsCompactGeometry, t.defaultSpatialReferenceEnabled = r3.supportsDefaultSpatialReference);
  const n3 = e2.capabilities?.data;
  n3?.supportsZ && null != e2.returnZ && (t.returnZ = e2.returnZ), n3?.supportsM && null != e2.returnM && (t.returnM = e2.returnM);
  const { timeOffset: o2, timeExtent: i2 } = e2;
  return t.timeExtent = null != o2 && null != i2 ? i2.offset(-o2.value, o2.unit) : i2 || null, t;
}
function M(e2) {
  const { globalIdField: t, fields: r3 } = e2;
  if (t) return t;
  if (r3) {
    for (const n3 of r3) if ("esriFieldTypeGlobalID" === n3.type) return n3.name;
  }
}
function k(e2) {
  const { objectIdField: t, fields: r3 } = e2;
  if (t) return t;
  if (r3) {
    for (const n3 of r3) if ("esriFieldTypeOID" === n3.type) return n3.name;
  }
}
function z(e2) {
  return e2.currentVersion ? e2.currentVersion : e2.hasOwnProperty("capabilities") || e2.hasOwnProperty("drawingInfo") || e2.hasOwnProperty("hasAttachments") || e2.hasOwnProperty("htmlPopupType") || e2.hasOwnProperty("relationships") || e2.hasOwnProperty("timeInfo") || e2.hasOwnProperty("typeIdField") || e2.hasOwnProperty("types") ? 10 : 9.3;
}
function N2(e2, t, r3, n3) {
  const o2 = r3?.feature, i2 = !!e2.subtypes?.length;
  if (i2 && !r3?.excludeImpliedDomains) {
    const r4 = U(e2, t);
    if (r4) return r4;
  }
  const s4 = i2 && Q(e2, o2);
  if (s4) {
    const e3 = s4?.domains?.[t];
    return "inherited" === e3?.type ? n3 : e3;
  }
  const a4 = oe(e2.types, e2.typeIdField, o2);
  if (a4) {
    const e3 = a4.domains && a4.domains[t];
    if (e3 && "inherited" !== e3?.type) return e3;
  }
  if (n3) return n3;
  if (!r3?.excludeImpliedDomains) {
    const r4 = V(e2, t);
    if (r4) return r4;
  }
  return null;
}
function Q(e2, t) {
  const { subtypes: r3, subtypeField: n3 } = e2;
  if (!t?.attributes || !r3?.length || !n3) return null;
  const o2 = t.attributes[n3];
  return null == o2 ? null : r3.find((e3) => e3.code === o2);
}
function U(e2, t) {
  const { fieldsIndex: r3, subtypeField: n3 } = e2, { name: o2, type: i2 } = r3.get(t) ?? {};
  if (!o2) return null;
  if ((n3 && r3.get(n3)?.name) === o2 && e2.subtypes?.length) {
    const t2 = e2.subtypes.map((e3) => new p({ code: G(e3.code, i2), name: e3.name }));
    if (t2?.length) return new i({ codedValues: t2 });
  }
  return null;
}
function V(e2, t) {
  const { fieldsIndex: r3 } = e2, { name: n3, type: o2 } = r3.get(t) ?? {};
  if (!n3) return null;
  if (("typeIdField" in e2 ? r3.get(e2.typeIdField)?.name : null) === n3 && "types" in e2 && e2.types?.length) {
    const t2 = e2.types.map((e3) => new p({ code: G(e3.id, o2), name: e3.name }));
    return new i({ codedValues: t2 });
  }
  return null;
}
function G(e2, t) {
  return t ? Fe({ type: t }) && "number" == typeof e2 ? `${e2}` : ye({ type: t }) && "string" == typeof e2 ? Number.parseInt(e2, 10) : e2 : e2;
}
async function $2(e2) {
  return (await e2.load()).source;
}
async function J(t, r3) {
  if (!s3) return;
  const n3 = s3.findCredential(t);
  if (n3) return n3.userId;
  let o2;
  try {
    const n4 = await N(t, r3);
    n4 && (o2 = await s3.checkSignInStatus(`${n4}/sharing`));
  } catch (i2) {
  }
  return o2 ? o2.userId : null;
}
async function Z(t, r3) {
  if (!s3) return;
  if (s3.findCredential(t)) return;
  let n3;
  try {
    const o2 = await N(t, r3);
    o2 && (n3 = await s3.checkSignInStatus(`${o2}/sharing`));
  } catch (o2) {
  }
  if (n3) try {
    const n4 = null != r3 ? r3.signal : null;
    await s3.getCredential(t, { signal: n4 });
  } catch (o2) {
  }
}
async function H(e2, t, r3) {
  const n3 = e2.parsedUrl?.path;
  n3 && e2.authenticationTriggerEvent === t && await Z(n3, r3);
}
async function W(e2) {
  const t = e2.parsedUrl?.path;
  t && _(e2) && await Z(t);
}
function _(e2) {
  return K(e2) && ("serviceDefinitionExpression" in e2 && X(e2.serviceDefinitionExpression) || "definitionExpression" in e2 && X(e2.definitionExpression));
}
function K(e2) {
  return !(!D(e2) || !e2.capabilities?.query.supportsCurrentUser);
}
function X(e2) {
  return !!e2?.toLowerCase().includes("current_user");
}
function Y(e2) {
  return !ie(e2) && (e2.userHasUpdateItemPrivileges || e2.editingEnabled);
}
var ee = s2({ types: D2 });
function te(e2, t) {
  if (e2.defaultSymbol) return e2.types?.length ? new $({ defaultSymbol: ee(e2.defaultSymbol, e2, t), field: e2.typeIdField, uniqueValueInfos: e2.types.map((e3) => ({ id: e3.id, symbol: ee(e3.symbol, e3, t) })) }) : new p2({ symbol: ee(e2.defaultSymbol, e2, t) });
}
function re(e2) {
  let t = e2.sourceJSON?.cacheMaxAge;
  if (!t) return false;
  const r3 = e2.editingInfo?.lastEditDate?.getTime();
  return null == r3 || (t *= 1e3, Date.now() - r3 < t);
}
async function ne(e2, r3, n3) {
  if (null == r3) return null;
  const o2 = [], { objectIdField: s4 } = e2;
  if (r3.forEach((e3) => {
    let t = null;
    if ("attributes" in e3) {
      const { attributes: r4 } = e3;
      t = { globalId: r4[n3], objectId: null != r4[s4] && -1 !== r4[s4] ? r4[s4] : null };
    } else t = { globalId: e3.globalId, objectId: null != e3.objectId && -1 !== e3.objectId ? e3.objectId : null };
    null != t.globalId && (null != t.objectId && -1 !== t.objectId || o2.push(t.globalId));
  }), 0 === o2.length) return null;
  const a4 = e2.createQuery();
  a4.where = o2.map((e3) => `${n3}='${e3}'`).join(" OR "), a4.returnGeometry = false, a4.outFields = [s4, n3], a4.cacheHint = false;
  const u3 = await b(r2(e2, a4));
  if (!u3.ok) return null;
  const l = /* @__PURE__ */ new Map(), p4 = u3.value.features;
  for (const t of p4) {
    const e3 = t.attributes[n3], r4 = t.attributes[s4];
    null != e3 && null != r4 && -1 !== r4 && l.set(e(e3), r4);
  }
  return l;
}
function oe(e2, t, r3) {
  if (!t || !r3 || !e2) return null;
  const n3 = r3.getAttribute(t);
  return null == n3 ? null : e2.find((e3) => {
    const { id: t2 } = e3;
    return null != t2 && t2.toString() === n3.toString();
  }) ?? null;
}
function ie(e2) {
  return e2.sourceJSON?.isMultiServicesView || se(e2);
}
function se(e2) {
  return !!e2.sourceJSON?.capabilities?.toLowerCase().split(",").map((e3) => e3.trim()).includes("map");
}
function ae(e2, t, n3) {
  const o2 = t?.queryAttributeBins;
  if (!t?.operations?.supportsQueryBins || !o2) throw new s(n3, "Layer source does not support binning");
  switch (e2.binParameters.type) {
    case "auto-interval":
      if (!o2.supportsAutoInterval) throw new s(n3, "Layer source does not support auto-interval binning");
      if (e2.binParameters.normalizationType && (!o2.supportsNormalization || !ue(e2.binParameters.normalizationType, o2.supportedNormalizationTypes))) throw new s(n3, "Layer source does not support normalization binning");
      break;
    case "date":
      if (!o2.supportsDate) throw new s(n3, "Layer source does not support date binning");
      if (e2.binParameters.snapToData && !o2.supportsSnapToData) throw new s(n3, "Layer source does not support snapToData binning");
      if (e2.binParameters.returnFullIntervalBin && !o2.supportsReturnFullIntervalBin) throw new s(n3, "Layer source does not support returnFullIntervalBin binning");
      break;
    case "fixed-boundaries":
      if (!o2.supportsFixedBoundaries) throw new s(n3, "Layer source does not support fixed-boundaries binning");
      break;
    case "fixed-interval":
      if (!o2.supportsFixedInterval) throw new s(n3, "Layer source does not support fixed-interval binning");
      if (e2.binParameters.normalizationType && (!o2.supportsNormalization || !ue(e2.binParameters.normalizationType, o2.supportedNormalizationTypes))) throw new s(n3, "Layer source does not support normalization binning");
  }
  if (e2.binParameters.stackBy && !o2.supportsStackBy) throw new s(n3, "Layer source does not support stackBy binning");
  if (e2.binParameters.splitBy && !o2.supportsSplitBy) throw new s(n3, "Layer source does not support splitBy binning");
  if (e2.binParameters.firstDayOfWeek && !o2.supportsFirstDayOfWeek) throw new s(n3, "Layer source does not support firstDayOfWeek binning");
  const i2 = o2?.supportedStatistics;
  if (e2.outStatistics && i2) {
    const t2 = /* @__PURE__ */ new Map([["count", "count"], ["sum", "sum"], ["min", "min"], ["max", "max"], ["avg", "avg"], ["stddev", "stddev"], ["var", "var"], ["percentile-continuous", "percentileContinuous"], ["percentile-discrete", "percentileDiscrete"], ["centroid-aggregate", "centroid"], ["convex-hull-aggregate", "convexHull"], ["envelope-aggregate", "envelope"]]);
    for (const { statisticType: o3 } of e2.outStatistics) {
      const e3 = t2.get(o3);
      if (e3 && !i2[e3]) throw new s(n3, `Layer source does not support ${o3} statistic type`);
    }
  }
}
function ue(e2, t) {
  return null != e2 && !!t?.[n2.toJSON(e2)];
}

export {
  p3 as p,
  j,
  F,
  P,
  q,
  S,
  v,
  O,
  A,
  L,
  E,
  D3 as D,
  T,
  C,
  B,
  R,
  M,
  k,
  z,
  N2 as N,
  Q,
  U,
  J,
  H,
  W,
  X,
  Y,
  te,
  re,
  ne,
  oe,
  ie,
  ae
};
//# sourceMappingURL=chunk-KY5OS6CK.js.map
