import {
  a as a5,
  b as b3,
  c,
  f as f5,
  m as m7
} from "./chunk-KWUYYGLN.js";
import {
  S,
  T,
  d as d2,
  h as h2,
  n as n3,
  o as o6
} from "./chunk-GB62XN32.js";
import {
  a as a4
} from "./chunk-XPO6OCCI.js";
import {
  D,
  M as M2,
  R,
  U,
  a as a3,
  b,
  f as f4,
  l as l4,
  m as m6,
  n as n2,
  o as o5,
  q as q2,
  r as r3,
  w
} from "./chunk-43UUQEW5.js";
import {
  t as t3
} from "./chunk-AO5WTXLR.js";
import {
  i as i2
} from "./chunk-WVAXXVEK.js";
import {
  o as o4
} from "./chunk-7VJQTJLO.js";
import {
  b2
} from "./chunk-CZOYDK6P.js";
import "./chunk-RS755KXS.js";
import "./chunk-TMUM75KQ.js";
import "./chunk-UOYGMZIS.js";
import "./chunk-RXH2WNPA.js";
import "./chunk-TWU3GKHX.js";
import "./chunk-BGIBV6LL.js";
import "./chunk-UQXJMFRI.js";
import "./chunk-DY7N5RAZ.js";
import {
  j
} from "./chunk-6TCXGIIN.js";
import {
  l
} from "./chunk-NP2TBOXH.js";
import "./chunk-WX3525ER.js";
import "./chunk-FHCV4NTV.js";
import {
  g
} from "./chunk-HCTBVF3W.js";
import "./chunk-NH6FXYCM.js";
import "./chunk-YE4E5JCT.js";
import "./chunk-SXZO7ULH.js";
import {
  E
} from "./chunk-H34D76ZQ.js";
import "./chunk-QTRET3PG.js";
import "./chunk-FMOL5XMB.js";
import "./chunk-VNSHGTPN.js";
import "./chunk-OEBAFVQK.js";
import "./chunk-EK7HOTRR.js";
import "./chunk-TTLSEJNG.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import "./chunk-EKZRA6TO.js";
import "./chunk-M5SP6ZBM.js";
import "./chunk-2HGIYEIL.js";
import "./chunk-MDJNYPVI.js";
import "./chunk-Z6VKIQV2.js";
import "./chunk-4PXNA4MD.js";
import "./chunk-7HTU7ZUX.js";
import {
  P
} from "./chunk-6VL5D5UP.js";
import "./chunk-6QHY54HZ.js";
import "./chunk-GXJJY3ND.js";
import "./chunk-5ONGWFJ3.js";
import {
  f as f3,
  s as s3
} from "./chunk-PLNHHGHL.js";
import "./chunk-QZQPB5XR.js";
import "./chunk-AQFRVV3U.js";
import {
  p
} from "./chunk-PEL3D3ZN.js";
import "./chunk-Q5KWD3VQ.js";
import "./chunk-BUQC3CLV.js";
import {
  t as t2
} from "./chunk-W5S3VUFT.js";
import "./chunk-7YH7T6CS.js";
import "./chunk-3T4IXPP4.js";
import "./chunk-XTZAIV4X.js";
import "./chunk-63LDVRFI.js";
import {
  _ as _2
} from "./chunk-C3FRY5U4.js";
import {
  q
} from "./chunk-JNJX34GB.js";
import "./chunk-3STJRSDT.js";
import "./chunk-67Q6KVC6.js";
import {
  C,
  M,
  h
} from "./chunk-23NJHA5Q.js";
import "./chunk-4LA6K4VI.js";
import "./chunk-KEZCWFAR.js";
import {
  m as m5
} from "./chunk-JZUJ34RR.js";
import {
  l as l3
} from "./chunk-PMGS7UDU.js";
import "./chunk-3GHCGAH2.js";
import "./chunk-HWUOAPTX.js";
import "./chunk-QHCKOBU7.js";
import "./chunk-K2OZ6WVC.js";
import "./chunk-MC6NAKKX.js";
import "./chunk-TF6255HN.js";
import {
  f as f2
} from "./chunk-GD4FJL3C.js";
import "./chunk-C5OQVQZF.js";
import {
  u
} from "./chunk-F7DKSAOI.js";
import {
  m as m4
} from "./chunk-4SOQWNPG.js";
import "./chunk-LTULADK2.js";
import "./chunk-35ST7YRB.js";
import "./chunk-EDA5QFHZ.js";
import "./chunk-NPYFNHY2.js";
import "./chunk-CNYNCKEV.js";
import "./chunk-XL5QPCXN.js";
import {
  N as N4,
  W
} from "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import {
  k
} from "./chunk-W75DBJD7.js";
import {
  b as b4
} from "./chunk-P6IKJIMO.js";
import "./chunk-MHV23XAQ.js";
import "./chunk-V2X4OKYI.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import "./chunk-MA3QDRC3.js";
import "./chunk-W6J7XCPU.js";
import "./chunk-ONXWBTTM.js";
import {
  l as l2
} from "./chunk-T7F6Q6JJ.js";
import {
  O
} from "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import {
  M as M3
} from "./chunk-7P2ANHQ3.js";
import "./chunk-XCKT47LJ.js";
import {
  m as m3
} from "./chunk-3FUHCAX3.js";
import {
  y3 as y2
} from "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import {
  z
} from "./chunk-H74Q4SYB.js";
import {
  a as a2
} from "./chunk-2OFHDVO5.js";
import "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-5UPBUJPC.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-CCQFL76O.js";
import "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import {
  r as r2
} from "./chunk-7H3U4IJR.js";
import "./chunk-SMWUT52Z.js";
import {
  _
} from "./chunk-AXZMNHTN.js";
import {
  f
} from "./chunk-5T3MJDSR.js";
import {
  N as N2,
  N2 as N3
} from "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import {
  H2 as H,
  I,
  jt,
  y2 as y
} from "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import {
  o as o3
} from "./chunk-XWE6BM2U.js";
import {
  r
} from "./chunk-SOIZOFSB.js";
import {
  n
} from "./chunk-XXLHAM2M.js";
import {
  m as m2,
  o
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a,
  m
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import {
  o as o2
} from "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import {
  d
} from "./chunk-GNMPGHLQ.js";
import {
  e,
  i3 as i,
  s,
  s2,
  t
} from "./chunk-QY7XKUIV.js";
import {
  N
} from "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/layers/support/RouteStopSymbols.js
var p2 = class extends n {
  constructor(o7) {
    super(o7), this.break = new u({ color: [255, 255, 255], size: 12, outline: { color: [0, 122, 194], width: 3 } }), this.first = new u({ color: [0, 255, 0], size: 20, outline: { color: [255, 255, 255], width: 4 } }), this.unlocated = new u({ color: [255, 0, 0], size: 12, outline: { color: [255, 255, 255], width: 3 } }), this.last = new u({ color: [255, 0, 0], size: 20, outline: { color: [255, 255, 255], width: 4 } }), this.middle = new u({ color: [51, 51, 51], size: 12, outline: { color: [0, 122, 194], width: 3 } }), this.waypoint = new u({ color: [255, 255, 255], size: 12, outline: { color: [0, 122, 194], width: 3 } });
  }
};
__decorate([m2({ types: M })], p2.prototype, "break", void 0), __decorate([m2({ types: M })], p2.prototype, "first", void 0), __decorate([m2({ types: M })], p2.prototype, "unlocated", void 0), __decorate([m2({ types: M })], p2.prototype, "last", void 0), __decorate([m2({ types: M })], p2.prototype, "middle", void 0), __decorate([m2({ types: M })], p2.prototype, "waypoint", void 0), p2 = __decorate([a("esri.layers.support.RouteStopSymbols")], p2);

// node_modules/@arcgis/core/layers/support/RouteSymbols.js
var c2 = class extends n {
  constructor(o7) {
    super(o7), this.directionLines = new m4({ color: [0, 122, 194], width: 6 }), this.directionPoints = new u({ color: [255, 255, 255], size: 6, outline: { color: [0, 122, 194], width: 2 } }), this.pointBarriers = new u({ style: "x", size: 10, outline: { color: [255, 0, 0], width: 3 } }), this.polygonBarriers = new m5({ color: [255, 170, 0, 0.6], outline: { width: 7.5, color: [255, 0, 0, 0.6] } }), this.polylineBarriers = new m4({ width: 7.5, color: [255, 85, 0, 0.7] }), this.routeInfo = new m4({ width: 8, color: [20, 89, 127] }), this.stops = new p2();
  }
};
__decorate([m2({ types: C })], c2.prototype, "directionLines", void 0), __decorate([m2({ types: M })], c2.prototype, "directionPoints", void 0), __decorate([m2({ types: M })], c2.prototype, "pointBarriers", void 0), __decorate([m2({ types: h })], c2.prototype, "polygonBarriers", void 0), __decorate([m2({ types: C })], c2.prototype, "polylineBarriers", void 0), __decorate([m2({ types: C })], c2.prototype, "routeInfo", void 0), __decorate([m2({ type: p2 })], c2.prototype, "stops", void 0), c2 = __decorate([a("esri.layers.support.RouteSymbols")], c2);

// node_modules/@arcgis/core/rest/support/NetworkAttribute.js
var m8 = class extends n {
  constructor(t4) {
    super(t4), this.dataType = null, this.name = null, this.parameterNames = null, this.restrictionUsageParameterName = null, this.timeNeutralAttributeName = null, this.trafficSupport = null, this.units = null, this.usageType = null;
  }
};
__decorate([m2({ type: String })], m8.prototype, "dataType", void 0), __decorate([r2(D, { ignoreUnknown: false })], m8.prototype, "name", void 0), __decorate([m2({ type: [String] })], m8.prototype, "parameterNames", void 0), __decorate([m2({ type: String })], m8.prototype, "restrictionUsageParameterName", void 0), __decorate([r2(U, { ignoreUnknown: false })], m8.prototype, "timeNeutralAttributeName", void 0), __decorate([m2({ type: String })], m8.prototype, "trafficSupport", void 0), __decorate([r2(n2)], m8.prototype, "units", void 0), __decorate([r2(b)], m8.prototype, "usageType", void 0), m8 = __decorate([a("esri.rest.support.NetworkAttribute")], m8);
var u2 = m8;

// node_modules/@arcgis/core/rest/support/NetworkDataset.js
var p3 = class extends n {
  constructor(t4) {
    super(t4), this.buildTime = null, this.name = null, this.networkAttributes = null, this.networkSources = null, this.state = null;
  }
};
__decorate([m2({ type: Number })], p3.prototype, "buildTime", void 0), __decorate([m2({ type: String })], p3.prototype, "name", void 0), __decorate([m2({ type: [u2] })], p3.prototype, "networkAttributes", void 0), __decorate([m2()], p3.prototype, "networkSources", void 0), __decorate([m2({ type: String })], p3.prototype, "state", void 0), p3 = __decorate([a("esri.rest.support.NetworkDataset")], p3);
var i3 = p3;

// node_modules/@arcgis/core/rest/support/NetworkServiceDescription.js
var c3 = class extends n {
  constructor(t4) {
    super(t4), this.accumulateAttributeNames = null, this.attributeParameterValues = null, this.currentVersion = null, this.defaultTravelMode = null, this.directionsLanguage = null, this.directionsLengthUnits = null, this.directionsSupportedLanguages = null, this.directionsTimeAttribute = null, this.hasZ = null, this.impedance = null, this.networkDataset = null, this.supportedTravelModes = null;
  }
  readAccumulateAttributes(t4) {
    return null == t4 ? null : t4.map((t5) => D.fromJSON(t5));
  }
  writeAccumulateAttributes(t4, e2, r4) {
    t4?.length && (e2[r4] = t4.map((t5) => D.toJSON(t5)));
  }
  get capabilities() {
    return { supportsNow: (this.currentVersion ?? 10) >= 10.81 };
  }
  readDefaultTravelMode(t4, e2) {
    const r4 = e2.supportedTravelModes?.find(({ id: t5 }) => t5 === e2.defaultTravelMode) ?? e2.supportedTravelModes?.find(({ itemId: t5 }) => t5 === e2.defaultTravelMode);
    return r4 ? b3.fromJSON(r4) : null;
  }
};
__decorate([m2()], c3.prototype, "accumulateAttributeNames", void 0), __decorate([o3("accumulateAttributeNames")], c3.prototype, "readAccumulateAttributes", null), __decorate([r("accumulateAttributeNames")], c3.prototype, "writeAccumulateAttributes", null), __decorate([m2()], c3.prototype, "attributeParameterValues", void 0), __decorate([m2()], c3.prototype, "capabilities", null), __decorate([m2()], c3.prototype, "currentVersion", void 0), __decorate([m2()], c3.prototype, "defaultTravelMode", void 0), __decorate([o3("defaultTravelMode", ["defaultTravelMode", "supportedTravelModes"])], c3.prototype, "readDefaultTravelMode", null), __decorate([m2()], c3.prototype, "directionsLanguage", void 0), __decorate([r2(a3)], c3.prototype, "directionsLengthUnits", void 0), __decorate([m2()], c3.prototype, "directionsSupportedLanguages", void 0), __decorate([r2(U, { ignoreUnknown: false })], c3.prototype, "directionsTimeAttribute", void 0), __decorate([m2()], c3.prototype, "hasZ", void 0), __decorate([r2(D, { ignoreUnknown: false })], c3.prototype, "impedance", void 0), __decorate([m2({ type: i3 })], c3.prototype, "networkDataset", void 0), __decorate([m2({ type: [b3] })], c3.prototype, "supportedTravelModes", void 0), c3 = __decorate([a("esri.rest.support.NetworkServiceDescription")], c3);

// node_modules/@arcgis/core/rest/networkService.js
var l5 = () => i.getLogger("esri.rest.networkService");
function u3(e2, r4, t4, o7) {
  o7[t4] = [r4.length, r4.length + e2.length], e2.forEach((e3) => {
    r4.push(e3.geometry);
  });
}
function f6(e2, r4) {
  for (let t4 = 0; t4 < r4.length; t4++) {
    const o7 = e2[r4[t4]];
    if (o7 && o7.length) for (const e3 of o7) e3.z = void 0;
  }
  l5().warnOnce("The remote Network Analysis service is powered by a network dataset which is not Z-aware.\nZ-coordinates of the input geometry are ignored.");
}
function c4(e2, r4) {
  for (let t4 = 0; t4 < r4.length; t4++) {
    const o7 = e2[r4[t4]];
    if (o7 && o7.length) {
      for (const e3 of o7) if (null != e3 && e3.hasZ) return true;
    }
  }
  return false;
}
async function d3(t4, o7, s5) {
  if (!t4) throw new s2("network-service:missing-url", "Url to Network service is missing");
  const n6 = s3({ f: "json", token: o7 }, s5), { data: l8 } = await H(t4, n6), u6 = l8.currentVersion >= 10.4 ? p4(t4, o7, s5) : v(t4, s5), { defaultTravelMode: f7, supportedTravelModes: c11 } = await u6;
  return l8.defaultTravelMode = f7, l8.supportedTravelModes = c11, c3.fromJSON(l8);
}
async function v(r4, t4) {
  const i6 = s3({ f: "json" }, t4), { data: l8 } = await H(r4.replace(/\/rest\/.*$/i, "/info"), i6);
  if (!l8?.owningSystemUrl) return { supportedTravelModes: [], defaultTravelMode: null };
  const { owningSystemUrl: u6 } = l8, f7 = jt(u6) + "/sharing/rest/portals/self", { data: c11 } = await H(f7, i6), d4 = t("helperServices.routingUtilities.url", c11);
  if (!d4) return { supportedTravelModes: [], defaultTravelMode: null };
  const v2 = f3(u6), p8 = /\/solve$/i.test(v2.path) ? "Route" : /\/solveclosestfacility$/i.test(v2.path) ? "ClosestFacility" : "ServiceAreas", m13 = s3({ f: "json", serviceName: p8 }, t4), h3 = jt(d4) + "/GetTravelModes/execute", g2 = await H(h3, m13), w2 = [];
  let T2 = null;
  if (g2?.data?.results?.length) {
    const e2 = g2.data.results;
    for (const r5 of e2) if ("supportedTravelModes" === r5.paramName) {
      if (r5.value?.features) {
        for (const { attributes: e3 } of r5.value.features) if (e3) {
          const r6 = JSON.parse(e3.TravelMode);
          w2.push(r6);
        }
      }
    } else "defaultTravelMode" === r5.paramName && (T2 = r5.value);
  }
  return { supportedTravelModes: w2, defaultTravelMode: T2 };
}
async function p4(t4, o7, n6) {
  try {
    const r4 = s3({ f: "json", token: o7 }, n6), i6 = jt(t4) + "/retrieveTravelModes", { data: { supportedTravelModes: l8, defaultTravelMode: u6 } } = await H(i6, r4);
    return { supportedTravelModes: l8, defaultTravelMode: u6 };
  } catch (i6) {
    throw new s2("network-service:retrieveTravelModes", "Could not get to the NAServer's retrieveTravelModes.", { error: i6 });
  }
}

// node_modules/@arcgis/core/rest/support/NAMessage.js
var p5 = new o2({ 0: "informative", 1: "process-definition", 2: "process-start", 3: "process-stop", 50: "warning", 100: "error", 101: "empty", 200: "abort" });
var c5 = class extends a4 {
  constructor(r4) {
    super(r4), this.type = null;
  }
};
__decorate([m2({ type: String, json: { read: p5.read, write: p5.write } })], c5.prototype, "type", void 0), c5 = __decorate([a("esri.rest.support.NAMessage")], c5);
var i4 = c5;

// node_modules/@arcgis/core/rest/support/DirectionsString.js
var c6 = class extends n {
  constructor(r4) {
    super(r4);
  }
};
__decorate([m2({ json: { read: { source: "string" } } })], c6.prototype, "text", void 0), __decorate([r2(q2, { name: "stringType" })], c6.prototype, "type", void 0), c6 = __decorate([a("esri.rest.support.DirectionsString")], c6);
var i5 = c6;

// node_modules/@arcgis/core/rest/support/DirectionsEvent.js
var a6 = class extends n {
  constructor(r4) {
    super(r4), this.arriveTime = null, this.arriveTimeOffset = null, this.geometry = null, this.strings = null;
  }
  readArriveTimeOffset(r4, e2) {
    return o6(e2.ETA, e2.arriveTimeUTC);
  }
  readGeometry(r4, e2) {
    return _.fromJSON(e2.point);
  }
};
__decorate([m2({ type: Date, json: { read: { source: "arriveTimeUTC" } } })], a6.prototype, "arriveTime", void 0), __decorate([m2()], a6.prototype, "arriveTimeOffset", void 0), __decorate([o3("arriveTimeOffset", ["arriveTimeUTC", "ETA"])], a6.prototype, "readArriveTimeOffset", null), __decorate([m2({ type: _ })], a6.prototype, "geometry", void 0), __decorate([o3("geometry", ["point"])], a6.prototype, "readGeometry", null), __decorate([m2({ type: [i5] })], a6.prototype, "strings", void 0), a6 = __decorate([a("esri.rest.support.DirectionsEvent")], a6);
var c7 = a6;

// node_modules/@arcgis/core/rest/support/DirectionsFeature.js
function a7(r4) {
  if (null == r4 || "" === r4) return null;
  let t4 = 0, e2 = 0, o7 = 0, s5 = 0;
  const p8 = [];
  let n6, i6, a8, c11, m13, l8, u6, y3, d4 = 0, f7 = 0, h3 = 0;
  if (m13 = r4.match(/((\+|-)[^+\-|]+|\|)/g), m13 || (m13 = []), 0 === parseInt(m13[d4], 32)) {
    d4 = 2;
    const r5 = parseInt(m13[d4], 32);
    d4++, l8 = parseInt(m13[d4], 32), d4++, 1 & r5 && (f7 = m13.indexOf("|") + 1, u6 = parseInt(m13[f7], 32), f7++), 2 & r5 && (h3 = m13.indexOf("|", f7) + 1, y3 = parseInt(m13[h3], 32), h3++);
  } else l8 = parseInt(m13[d4], 32), d4++;
  for (; d4 < m13.length && "|" !== m13[d4]; ) {
    n6 = parseInt(m13[d4], 32) + t4, d4++, t4 = n6, i6 = parseInt(m13[d4], 32) + e2, d4++, e2 = i6;
    const r5 = [n6 / l8, i6 / l8];
    f7 && (c11 = parseInt(m13[f7], 32) + o7, f7++, o7 = c11, r5.push(c11 / u6)), h3 && (a8 = parseInt(m13[h3], 32) + s5, h3++, s5 = a8, r5.push(a8 / y3)), p8.push(r5);
  }
  return { paths: [p8], hasZ: f7 > 0, hasM: h3 > 0 };
}
var c8 = class extends _2 {
  constructor(r4) {
    super(r4), this.events = null, this.geometry = null, this.strings = null;
  }
  set attributes(r4) {
    super.attributes = r4;
  }
  readGeometry(r4, t4) {
    const e2 = a7(t4.compressedGeometry);
    return null != e2 ? y2.fromJSON(e2) : null;
  }
};
__decorate([m2({ type: [c7] })], c8.prototype, "events", void 0), __decorate([m2({ type: y2 })], c8.prototype, "geometry", void 0), __decorate([o3("geometry", ["compressedGeometry"])], c8.prototype, "readGeometry", null), __decorate([m2({ type: [i5] })], c8.prototype, "strings", void 0), c8 = __decorate([a("esri.rest.support.DirectionsFeature")], c8);
var m9 = c8;

// node_modules/@arcgis/core/rest/support/DirectionsFeatureSet.js
function u4(e2, t4) {
  if (0 === e2.length) return new y2({ spatialReference: t4 });
  const r4 = [];
  for (const n6 of e2) for (const e3 of n6.paths) r4.push(...e3);
  const o7 = [];
  r4.forEach((e3, t5) => {
    0 !== t5 && e3[0] === r4[t5 - 1][0] && e3[1] === r4[t5 - 1][1] || o7.push(e3);
  });
  const { hasM: s5, hasZ: a8 } = e2[0];
  return new y2({ hasM: s5, hasZ: a8, paths: [o7], spatialReference: t4 });
}
var m10 = class extends g {
  constructor(e2) {
    super(e2), this.extent = null, this.features = [], this.geometryType = "polyline", this.routeId = null, this.routeName = null, this.totalDriveTime = null, this.totalLength = null, this.totalTime = null;
  }
  readFeatures(e2, t4) {
    if (!e2) return [];
    const r4 = t4.summary.envelope.spatialReference ?? t4.spatialReference, o7 = r4 && f.fromJSON(r4);
    return e2.map((e3) => {
      const t5 = m9.fromJSON(e3);
      if (null != t5.geometry && (t5.geometry.spatialReference = o7), null != t5.events) for (const r5 of t5.events) null != r5.geometry && (r5.geometry.spatialReference = o7);
      return t5;
    });
  }
  get mergedGeometry() {
    if (!this.features) return null;
    return u4(this.features.map(({ geometry: e2 }) => e2), this.extent.spatialReference);
  }
  get strings() {
    return this.features.flatMap(({ strings: e2 }) => e2).filter(N);
  }
};
__decorate([m2({ type: z, json: { read: { source: "summary.envelope" } } })], m10.prototype, "extent", void 0), __decorate([m2({ nonNullable: true })], m10.prototype, "features", void 0), __decorate([o3("features")], m10.prototype, "readFeatures", null), __decorate([m2()], m10.prototype, "geometryType", void 0), __decorate([m2({ readOnly: true })], m10.prototype, "mergedGeometry", null), __decorate([m2()], m10.prototype, "routeId", void 0), __decorate([m2()], m10.prototype, "routeName", void 0), __decorate([m2({ value: null, readOnly: true })], m10.prototype, "strings", null), __decorate([m2({ json: { read: { source: "summary.totalDriveTime" } } })], m10.prototype, "totalDriveTime", void 0), __decorate([m2({ json: { read: { source: "summary.totalLength" } } })], m10.prototype, "totalLength", void 0), __decorate([m2({ json: { read: { source: "summary.totalTime" } } })], m10.prototype, "totalTime", void 0), m10 = __decorate([a("esri.rest.support.DirectionsFeatureSet")], m10);
var c9 = m10;

// node_modules/@arcgis/core/rest/support/RouteResult.js
var n4 = class extends n {
  constructor(t4) {
    super(t4), this.directionLines = null, this.directionPoints = null, this.directions = null, this.route = null, this.routeName = null, this.stops = null, this.traversedEdges = null, this.traversedJunctions = null, this.traversedTurns = null;
  }
};
__decorate([m2({ type: g, json: { write: true } })], n4.prototype, "directionLines", void 0), __decorate([m2({ type: g, json: { write: true } })], n4.prototype, "directionPoints", void 0), __decorate([m2({ type: c9, json: { write: true } })], n4.prototype, "directions", void 0), __decorate([m2({ type: _2, json: { write: true } })], n4.prototype, "route", void 0), __decorate([m2({ type: String, json: { write: true } })], n4.prototype, "routeName", void 0), __decorate([m2({ type: [_2], json: { write: true } })], n4.prototype, "stops", void 0), __decorate([m2({ type: g, json: { write: true } })], n4.prototype, "traversedEdges", void 0), __decorate([m2({ type: g, json: { write: true } })], n4.prototype, "traversedJunctions", void 0), __decorate([m2({ type: g, json: { write: true } })], n4.prototype, "traversedTurns", void 0), n4 = __decorate([a("esri.rest.support.RouteResult")], n4);
var u5 = n4;

// node_modules/@arcgis/core/rest/support/RouteSolveResult.js
function n5(r4) {
  return r4 ? g.fromJSON(r4).features.filter(N) : [];
}
var m11 = class extends n {
  constructor(r4) {
    super(r4), this.checksum = null, this.messages = null, this.pointBarriers = null, this.polylineBarriers = null, this.polygonBarriers = null, this.routeResults = null;
  }
  readPointBarriers(r4, o7) {
    return n5(o7.barriers);
  }
  readPolylineBarriers(r4) {
    return n5(r4);
  }
  readPolygonBarriers(r4) {
    return n5(r4);
  }
};
__decorate([m2({ type: String })], m11.prototype, "checksum", void 0), __decorate([m2({ type: [i4] })], m11.prototype, "messages", void 0), __decorate([m2({ type: [_2] })], m11.prototype, "pointBarriers", void 0), __decorate([o3("pointBarriers", ["barriers"])], m11.prototype, "readPointBarriers", null), __decorate([m2({ type: [_2] })], m11.prototype, "polylineBarriers", void 0), __decorate([o3("polylineBarriers")], m11.prototype, "readPolylineBarriers", null), __decorate([m2({ type: [_2] })], m11.prototype, "polygonBarriers", void 0), __decorate([o3("polygonBarriers")], m11.prototype, "readPolygonBarriers", null), __decorate([m2({ type: [u5] })], m11.prototype, "routeResults", void 0), m11 = __decorate([a("esri.rest.support.RouteSolveResult")], m11);

// node_modules/@arcgis/core/rest/route.js
function p6(e2) {
  return e2 instanceof g;
}
async function l6(c11, f7, l8) {
  const y3 = [], d4 = [], h3 = {}, g2 = {}, R3 = f3(c11), { path: v2 } = R3;
  p6(f7.stops) && u3(f7.stops.features, d4, "stops.features", h3), p6(f7.pointBarriers) && u3(f7.pointBarriers.features, d4, "pointBarriers.features", h3), p6(f7.polylineBarriers) && u3(f7.polylineBarriers.features, d4, "polylineBarriers.features", h3), p6(f7.polygonBarriers) && u3(f7.polygonBarriers.features, d4, "polygonBarriers.features", h3);
  const B = await P(d4);
  for (const e2 in h3) {
    const r4 = h3[e2];
    y3.push(e2), g2[e2] = B.slice(r4[0], r4[1]);
  }
  if (c4(g2, y3)) {
    let e2 = null;
    try {
      e2 = await d3(v2, f7.apiKey, l8);
    } catch {
    }
    e2 && !e2.hasZ && f6(g2, y3);
  }
  for (const e2 in g2) g2[e2].forEach((t4, s5) => {
    o(f7, e2)[s5].geometry = t4;
  });
  const E2 = { ...l8, query: { ...R3.query, ...n3(f7), f: "json" } }, T2 = v2.endsWith("/solve") ? v2 : `${v2}/solve`, { data: b5 } = await H(T2, E2);
  return m12(b5);
}
function m12(e2) {
  const { barriers: r4, checksum: t4, directionLines: s5, directionPoints: o7, directions: a8, messages: u6, polygonBarriers: i6, polylineBarriers: n6, routes: c11, stops: p8, traversedEdges: l8, traversedJunctions: m13, traversedTurns: y3 } = e2, d4 = (e3) => {
    const r5 = g2.find((r6) => r6.routeName === e3);
    if (null != r5) return r5;
    const t5 = { routeId: g2.length + 1, routeName: e3 };
    return g2.push(t5), t5;
  }, h3 = (e3) => {
    const r5 = g2.find((r6) => r6.routeId === e3);
    if (null != r5) return r5;
    const t5 = { routeId: e3, routeName: null };
    return g2.push(t5), t5;
  }, g2 = [];
  c11?.features.forEach((e3, r5) => {
    e3.geometry.spatialReference = c11.spatialReference ?? void 0;
    const t5 = e3.attributes.Name, s6 = r5 + 1;
    g2.push({ routeId: s6, routeName: t5, route: e3 });
  }), a8?.forEach((e3) => {
    const { routeName: r5 } = e3;
    d4(r5).directions = e3;
  });
  const R3 = (p8?.features.every((e3) => null == e3.attributes.RouteName) ?? false) && g2.length > 0 ? g2[0].routeName : null;
  return p8?.features.forEach((e3) => {
    e3.geometry && (e3.geometry.spatialReference ??= p8.spatialReference ?? void 0);
    const r5 = R3 ?? e3.attributes.RouteName, t5 = d4(r5);
    t5.stops ??= [], t5.stops.push(e3);
  }), s5?.features.forEach((e3) => {
    const r5 = e3.attributes.RouteID, t5 = h3(r5), { geometryType: o8, spatialReference: a9 } = s5;
    t5.directionLines ??= { features: [], geometryType: o8, spatialReference: a9 }, t5.directionLines.features.push(e3);
  }), o7?.features.forEach((e3) => {
    const r5 = e3.attributes.RouteID, t5 = h3(r5), { geometryType: s6, spatialReference: a9 } = o7;
    t5.directionPoints ??= { features: [], geometryType: s6, spatialReference: a9 }, t5.directionPoints.features.push(e3);
  }), l8?.features.forEach((e3) => {
    const r5 = e3.attributes.RouteID, t5 = h3(r5), { geometryType: s6, spatialReference: o8 } = l8;
    t5.traversedEdges ??= { features: [], geometryType: s6, spatialReference: o8 }, t5.traversedEdges.features.push(e3);
  }), m13?.features.forEach((e3) => {
    const r5 = e3.attributes.RouteID, t5 = h3(r5), { geometryType: s6, spatialReference: o8 } = m13;
    t5.traversedJunctions ??= { features: [], geometryType: s6, spatialReference: o8 }, t5.traversedJunctions.features.push(e3);
  }), y3?.features.forEach((e3) => {
    const r5 = e3.attributes.RouteID, t5 = h3(r5);
    t5.traversedTurns ??= { features: [] }, t5.traversedTurns.features.push(e3);
  }), m11.fromJSON({ barriers: r4, checksum: t4, messages: u6, polygonBarriers: i6, polylineBarriers: n6, routeResults: g2 });
}

// node_modules/@arcgis/core/rest/support/DataLayer.js
var l7 = class extends l2(n) {
  constructor(o7) {
    super(o7), this.doNotLocateOnRestrictedElements = null, this.geometry = null, this.geometryType = null, this.name = null, this.spatialRelationship = null, this.type = "layer", this.where = null;
  }
};
__decorate([m2({ type: Boolean, json: { write: true } })], l7.prototype, "doNotLocateOnRestrictedElements", void 0), __decorate([m2({ types: l3, json: { read: f2, write: true } })], l7.prototype, "geometry", void 0), __decorate([r2(R)], l7.prototype, "geometryType", void 0), __decorate([m2({ type: String, json: { name: "layerName", write: true } })], l7.prototype, "name", void 0), __decorate([r2(M2, { name: "spatialRel" })], l7.prototype, "spatialRelationship", void 0), __decorate([m2({ type: String, json: { write: true } })], l7.prototype, "type", void 0), __decorate([m2({ type: String, json: { write: true } })], l7.prototype, "where", void 0), l7 = __decorate([a("esri.rest.support.DataLayer")], l7);

// node_modules/@arcgis/core/rest/support/NetworkFeatureSet.js
var s4;
var _a;
var c10 = (_a = class extends g {
  constructor(t4) {
    super(t4), this.doNotLocateOnRestrictedElements = null;
  }
  clone() {
    return new s4({ doNotLocateOnRestrictedElements: this.doNotLocateOnRestrictedElements, ...this.cloneProperties() });
  }
}, s4 = _a, _a);
__decorate([m2({ type: Boolean, json: { write: true } })], c10.prototype, "doNotLocateOnRestrictedElements", void 0), c10 = s4 = __decorate([a("esri.rest.support.NetworkFeatureSet")], c10);

// node_modules/@arcgis/core/rest/support/NetworkUrl.js
var p7 = class extends l2(n) {
  constructor(o7) {
    super(o7), this.doNotLocateOnRestrictedElements = null, this.url = null;
  }
};
__decorate([m2({ type: Boolean, json: { write: true } })], p7.prototype, "doNotLocateOnRestrictedElements", void 0), __decorate([m2({ type: String, json: { write: true } })], p7.prototype, "url", void 0), p7 = __decorate([a("esri.rest.support.NetworkUrl")], p7);

// node_modules/@arcgis/core/rest/support/RouteParameters.js
var N5;
var _a2;
var P2 = (_a2 = class extends l2(n) {
  constructor(t4) {
    super(t4), this.accumulateAttributes = null, this.apiKey = null, this.attributeParameterValues = null, this.checksum = null, this.directionsLanguage = null, this.directionsLengthUnits = null, this.directionsOutputType = null, this.directionsStyleName = null, this.directionsTimeAttribute = null, this.findBestSequence = null, this.geometryPrecision = null, this.geometryPrecisionM = null, this.geometryPrecisionZ = null, this.ignoreInvalidLocations = null, this.impedanceAttribute = null, this.outputGeometryPrecision = null, this.outputGeometryPrecisionUnits = null, this.outputLines = "true-shape", this.outSpatialReference = null, this.overrides = null, this.pointBarriers = null, this.polygonBarriers = null, this.polylineBarriers = null, this.preserveFirstStop = null, this.preserveLastStop = null, this.preserveObjectID = null, this.restrictionAttributes = null, this.restrictUTurns = null, this.returnBarriers = false, this.returnDirections = false, this.returnPolygonBarriers = false, this.returnPolylineBarriers = false, this.returnRoutes = true, this.returnStops = false, this.returnTraversedEdges = null, this.returnTraversedJunctions = null, this.returnTraversedTurns = null, this.returnZ = true, this.startTime = null, this.startTimeIsUTC = true, this.stops = null, this.timeWindowsAreUTC = null, this.travelMode = null, this.useHierarchy = null, this.useTimeWindows = null;
  }
  static from(t4) {
    return m(N5, t4);
  }
  readAccumulateAttributes(t4) {
    return null == t4 ? null : t4.map((t5) => D.fromJSON(t5));
  }
  writeAccumulateAttributes(t4, e2, r4) {
    t4?.length && (e2[r4] = t4.map((t5) => D.toJSON(t5)));
  }
  writePointBarriers(t4, e2, r4) {
    C2(t4, e2, r4);
  }
  writePolygonBarrier(t4, e2, r4) {
    C2(t4, e2, r4);
  }
  writePolylineBarrier(t4, e2, r4) {
    C2(t4, e2, r4);
  }
  readRestrictionAttributes(t4) {
    return null == t4 ? null : t4.map((t5) => w.fromJSON(t5));
  }
  writeRestrictionAttributes(t4, e2, r4) {
    t4?.length && (e2[r4] = t4.map((t5) => w.toJSON(t5)));
  }
  readStartTime(t4, e2) {
    const { startTime: r4 } = e2;
    return null == r4 ? null : "now" === r4 ? "now" : new Date(r4);
  }
  writeStartTime(t4, e2) {
    null != t4 && (e2.startTime = "now" === t4 ? "now" : t4.getTime());
  }
  readStops(t4, e2) {
    return U2(e2.stops);
  }
  writeStops(t4, e2, r4) {
    C2(t4, e2, r4);
  }
}, N5 = _a2, _a2);
function O2(t4) {
  return t4 && "type" in t4;
}
function J(t4) {
  return t4 && "features" in t4 && "doNotLocateOnRestrictedElements" in t4;
}
function L(t4) {
  return t4 && "url" in t4;
}
function R2(t4) {
  return t4 && "features" in t4;
}
function U2(t4) {
  return O2(t4) ? l7.fromJSON(t4) : L(t4) ? p7.fromJSON(t4) : J(t4) ? c10.fromJSON(t4) : R2(t4) ? g.fromJSON(t4) : null;
}
function C2(t4, e2, o7) {
  null != t4 && (e2[o7] = O.isCollection(t4) ? { features: t4.toArray().map((t5) => t5.toJSON()) } : t4.toJSON());
}
__decorate([m2({ type: [String], json: { name: "accumulateAttributeNames", write: true } })], P2.prototype, "accumulateAttributes", void 0), __decorate([o3("accumulateAttributes")], P2.prototype, "readAccumulateAttributes", null), __decorate([r("accumulateAttributes")], P2.prototype, "writeAccumulateAttributes", null), __decorate([m2(t3)], P2.prototype, "apiKey", void 0), __decorate([m2({ json: { write: true } })], P2.prototype, "attributeParameterValues", void 0), __decorate([m2({ type: String, json: { write: true } })], P2.prototype, "checksum", void 0), __decorate([m2({ type: String, json: { write: true } })], P2.prototype, "directionsLanguage", void 0), __decorate([r2(a3)], P2.prototype, "directionsLengthUnits", void 0), __decorate([r2(o5)], P2.prototype, "directionsOutputType", void 0), __decorate([r2(f4)], P2.prototype, "directionsStyleName", void 0), __decorate([r2(U, { name: "directionsTimeAttributeName", ignoreUnknown: false })], P2.prototype, "directionsTimeAttribute", void 0), __decorate([m2({ type: Boolean, json: { write: true } })], P2.prototype, "findBestSequence", void 0), __decorate([m2({ type: Number, json: { write: true } })], P2.prototype, "geometryPrecision", void 0), __decorate([m2({ type: Number, json: { write: true } })], P2.prototype, "geometryPrecisionM", void 0), __decorate([m2({ type: Number, json: { write: true } })], P2.prototype, "geometryPrecisionZ", void 0), __decorate([m2({ type: Boolean, json: { write: true } })], P2.prototype, "ignoreInvalidLocations", void 0), __decorate([r2(D, { name: "impedanceAttributeName", ignoreUnknown: false })], P2.prototype, "impedanceAttribute", void 0), __decorate([m2({ type: Number, json: { write: true } })], P2.prototype, "outputGeometryPrecision", void 0), __decorate([r2(r3)], P2.prototype, "outputGeometryPrecisionUnits", void 0), __decorate([r2(l4)], P2.prototype, "outputLines", void 0), __decorate([m2({ type: f, json: { name: "outSR", write: true } })], P2.prototype, "outSpatialReference", void 0), __decorate([m2({ json: { write: true } })], P2.prototype, "overrides", void 0), __decorate([m2({ json: { name: "barriers", write: true } })], P2.prototype, "pointBarriers", void 0), __decorate([r("pointBarriers")], P2.prototype, "writePointBarriers", null), __decorate([m2({ json: { write: true } })], P2.prototype, "polygonBarriers", void 0), __decorate([r("polygonBarriers")], P2.prototype, "writePolygonBarrier", null), __decorate([m2({ json: { write: true } })], P2.prototype, "polylineBarriers", void 0), __decorate([r("polylineBarriers")], P2.prototype, "writePolylineBarrier", null), __decorate([m2({ type: Boolean, json: { write: true } })], P2.prototype, "preserveFirstStop", void 0), __decorate([m2({ type: Boolean, json: { write: true } })], P2.prototype, "preserveLastStop", void 0), __decorate([m2({ type: Boolean, json: { write: true } })], P2.prototype, "preserveObjectID", void 0), __decorate([m2({ type: [String], json: { name: "restrictionAttributeNames", write: true } })], P2.prototype, "restrictionAttributes", void 0), __decorate([o3("restrictionAttributes")], P2.prototype, "readRestrictionAttributes", null), __decorate([r("restrictionAttributes")], P2.prototype, "writeRestrictionAttributes", null), __decorate([r2(m6)], P2.prototype, "restrictUTurns", void 0), __decorate([m2({ type: Boolean, json: { write: true } })], P2.prototype, "returnBarriers", void 0), __decorate([m2({ type: Boolean, json: { write: true } })], P2.prototype, "returnDirections", void 0), __decorate([m2({ type: Boolean, json: { write: true } })], P2.prototype, "returnPolygonBarriers", void 0), __decorate([m2({ type: Boolean, json: { write: true } })], P2.prototype, "returnPolylineBarriers", void 0), __decorate([m2({ type: Boolean, json: { write: true } })], P2.prototype, "returnRoutes", void 0), __decorate([m2({ type: Boolean, json: { write: true } })], P2.prototype, "returnStops", void 0), __decorate([m2({ type: Boolean, json: { write: true } })], P2.prototype, "returnTraversedEdges", void 0), __decorate([m2({ type: Boolean, json: { write: true } })], P2.prototype, "returnTraversedJunctions", void 0), __decorate([m2({ type: Boolean, json: { write: true } })], P2.prototype, "returnTraversedTurns", void 0), __decorate([m2({ type: Boolean, json: { write: true } })], P2.prototype, "returnZ", void 0), __decorate([m2({ json: { write: true } })], P2.prototype, "startTime", void 0), __decorate([o3("startTime")], P2.prototype, "readStartTime", null), __decorate([r("startTime")], P2.prototype, "writeStartTime", null), __decorate([m2({ type: Boolean, json: { write: true } })], P2.prototype, "startTimeIsUTC", void 0), __decorate([m2({ json: { write: true } })], P2.prototype, "stops", void 0), __decorate([o3("stops")], P2.prototype, "readStops", null), __decorate([r("stops")], P2.prototype, "writeStops", null), __decorate([m2({ type: Boolean, json: { write: true } })], P2.prototype, "timeWindowsAreUTC", void 0), __decorate([m2({ type: b3, json: { write: true } })], P2.prototype, "travelMode", void 0), __decorate([m2({ type: Boolean, json: { write: true } })], P2.prototype, "useHierarchy", void 0), __decorate([m2({ type: Boolean, json: { write: true } })], P2.prototype, "useTimeWindows", void 0), P2 = N5 = __decorate([a("esri.rest.support.RouteParameters")], P2);

// node_modules/@arcgis/core/layers/RouteLayer.js
function Y(e2) {
  if (!e2.length) return;
  const t4 = e2.toArray(), r4 = t4.map(({ objectId: e3 }) => e3).filter((e3) => null != e3);
  let o7 = Math.max(...r4, 0);
  for (const i6 of t4) null == i6.objectId && (i6.objectId = ++o7);
}
function Z(e2, t4) {
  return !!e2.length && e2.length === t4.length && z2(e2) && z2(t4);
}
function z2(e2) {
  return e2.every(({ objectId: e3 }) => null != e3);
}
function K(e2) {
  return e2.length ? e2 : null;
}
function X(e2) {
  switch (e2) {
    case "esriGeometryPoint":
      return { type: "esriSMS", style: "esriSMSCircle", size: 12, color: [0, 0, 0, 0], outline: X("esriGeometryPolyline") };
    case "esriGeometryPolyline":
      return { type: "esriSLS", style: "esriSLSSolid", width: 1, color: [0, 0, 0, 0] };
    case "esriGeometryPolygon":
      return { type: "esriSFS", style: "esriSFSNull", outline: X("esriGeometryPolyline") };
  }
}
function H2(e2) {
  return "layers" in e2;
}
function Q(e2) {
  return "esri.rest.support.FeatureSet" === e2.declaredClass;
}
function $(e2) {
  return "esri.rest.support.NetworkFeatureSet" === e2.declaredClass;
}
function ee(e2, t4) {
  for (const r4 of e2) {
    const e3 = t4.find((e4) => e4.objectId === r4.objectId);
    e3 && (e3.addedCost = r4.addedCost, e3.barrierType = r4.barrierType, e3.costs = r4.costs, e3.curbApproach = r4.curbApproach, e3.fullEdge = r4.fullEdge, e3.geometry = r4.geometry, e3.name = r4.name, e3.sideOfEdge = r4.sideOfEdge, e3.sourceId = r4.sourceId, e3.sourceOid = r4.sourceOid, e3.status = r4.status, e3.symbol = r4.symbol);
  }
}
function te(e2, t4) {
  for (const r4 of e2) {
    const e3 = t4.find((e4) => e4.objectId === r4.objectId);
    e3 && (e3.barrierType = r4.barrierType, e3.costs = r4.costs, e3.geometry = r4.geometry, e3.name = r4.name, e3.scaleFactor = r4.scaleFactor, e3.symbol = r4.symbol);
  }
}
function re(e2, t4) {
  for (const r4 of e2) {
    const e3 = t4.find((e4) => e4.objectId === r4.objectId);
    e3 && (e3.barrierType = r4.barrierType, e3.costs = r4.costs, e3.geometry = r4.geometry, e3.name = r4.name, e3.scaleFactor = r4.scaleFactor, e3.symbol = r4.symbol);
  }
}
function oe(e2, t4) {
  for (const r4 of e2) {
    const e3 = t4.find((e4) => e4.objectId === r4.objectId);
    e3 && (e3.arriveCurbApproach = r4.arriveCurbApproach, e3.arriveTime = r4.arriveTime, e3.arriveTimeOffset = r4.arriveTimeOffset, e3.cumulativeCosts = r4.cumulativeCosts, e3.cumulativeDistance = r4.cumulativeDistance, e3.cumulativeDuration = r4.cumulativeDuration, e3.curbApproach = r4.curbApproach, e3.departCurbApproach = r4.departCurbApproach, e3.departTime = r4.departTime, e3.departTimeOffset = r4.departTimeOffset, e3.distanceToNetworkInMeters = r4.distanceToNetworkInMeters, e3.geometry = r4.geometry, e3.lateDuration = r4.lateDuration, e3.name = r4.name, e3.navLatency = r4.navLatency, e3.posAlong = r4.posAlong, e3.routeName = r4.routeName, e3.serviceCosts = r4.serviceCosts, e3.serviceDistance = r4.serviceDistance, e3.serviceDuration = r4.serviceDuration, e3.sequence = r4.sequence, e3.sideOfEdge = r4.sideOfEdge, e3.snapX = r4.snapX, e3.snapY = r4.snapY, e3.snapZ = r4.snapZ, e3.sourceId = r4.sourceId, e3.sourceOid = r4.sourceOid, e3.status = r4.status, e3.symbol = r4.symbol, e3.timeWindowEnd = r4.timeWindowEnd, e3.timeWindowStart = r4.timeWindowStart, e3.violations = r4.violations, e3.waitDuration = r4.waitDuration, e3.wait = r4.wait);
  }
}
async function ie(e2) {
  const t4 = f.WGS84;
  return await N4(e2.spatialReference, t4), W(e2, t4);
}
function se(e2, t4) {
  switch (t4) {
    case "seconds":
      return e2 / 60;
    case "hours":
      return 60 * e2;
    case "days":
      return 60 * e2 * 24;
    default:
      return e2;
  }
}
function ne(e2, t4) {
  return "decimal-degrees" === t4 || "points" === t4 || "unknown" === t4 ? e2 : N3(e2, t4, "meters");
}
function ae(e2) {
  const { attributes: t4, geometry: r4, popupTemplate: o7, symbol: i6 } = e2.toGraphic().toJSON();
  return { attributes: t4, geometry: r4, popupInfo: o7, symbol: i6 };
}
var le = O.ofType(m7);
var ue = O.ofType(c);
var pe = O.ofType(T);
var ce = O.ofType(h2);
var me = O.ofType(d2);
var ye = O.ofType(S);
var fe = class extends p(t2(b2(j(l(b4))))) {
  constructor(e2) {
    super(e2), this._cachedServiceDescription = null, this._featureCollection = null, this._type = "Feature Collection", this.checksum = null, this.defaultSymbols = new c2(), this.directionLines = null, this.directionPoints = null, this.featureCollectionType = "route", this.legendEnabled = false, this.maxScale = 0, this.minScale = 0, this.pointBarriers = new pe(), this.polygonBarriers = new ce(), this.polylineBarriers = new me(), this.routeInfo = null, this.spatialReference = f.WGS84, this.stops = new ye(), this.type = "route";
    const t4 = () => {
      this._setStopSymbol(this.stops);
    };
    this.addHandles(a2(() => this.stops, "change", t4, { sync: true, onListenerAdd: t4 }));
  }
  writeFeatureCollectionWebmap(e2, t4, r4, o7) {
    const i6 = [this._writePolygonBarriers(), this._writePolylineBarriers(), this._writePointBarriers(), this._writeRouteInfo(), this._writeDirectionLines(), this._writeDirectionPoints(), this._writeStops()].filter((e3) => !!e3), s5 = i6.map((e3, t5) => t5), n6 = "web-map" === o7.origin ? "featureCollection.layers" : "layers";
    e(n6, i6, t4), t4.opacity = this.opacity, t4.visibility = this.visible, t4.visibleLayers = s5;
  }
  readDirectionLines(e2, t4) {
    return this._getNetworkFeatures(t4, "DirectionLines", (e3) => m7.fromGraphic(e3));
  }
  readDirectionPoints(e2, t4) {
    return this._getNetworkFeatures(t4, "DirectionPoints", (e3) => c.fromGraphic(e3));
  }
  get fullExtent() {
    const e2 = new z({ xmin: -180, ymin: -90, xmax: 180, ymax: 90, spatialReference: f.WGS84 });
    if (null != this.routeInfo?.geometry) return this.routeInfo.geometry.extent ?? e2;
    if (null == this.stops) return e2;
    const t4 = this.stops.filter((e3) => null != e3.geometry);
    if (t4.length < 2) return e2;
    const { spatialReference: r4 } = t4.at(0).geometry;
    if (null == r4) return e2;
    const o7 = t4.toArray().map((e3) => {
      const t5 = e3.geometry;
      return [t5.x, t5.y];
    });
    return new m3({ points: o7, spatialReference: r4 }).extent;
  }
  readMaxScale(e2, t4) {
    const r4 = H2(t4) ? t4.layers : t4.featureCollection?.layers, o7 = r4?.find((e3) => null != e3.layerDefinition.maxScale);
    return o7?.layerDefinition.maxScale ?? 0;
  }
  readMinScale(e2, t4) {
    const r4 = H2(t4) ? t4.layers : t4.featureCollection?.layers, o7 = r4?.find((e3) => null != e3.layerDefinition.minScale);
    return o7?.layerDefinition.minScale ?? 0;
  }
  readPointBarriers(e2, t4) {
    return this._getNetworkFeatures(t4, "Barriers", (e3) => T.fromGraphic(e3));
  }
  readPolygonBarriers(e2, t4) {
    return this._getNetworkFeatures(t4, "PolygonBarriers", (e3) => h2.fromGraphic(e3));
  }
  readPolylineBarriers(e2, t4) {
    return this._getNetworkFeatures(t4, "PolylineBarriers", (e3) => d2.fromGraphic(e3));
  }
  readRouteInfo(e2, t4) {
    return this._getNetworkFeatures(t4, "RouteInfo", (e3) => f5.fromGraphic(e3)).at(0) ?? null;
  }
  readSpatialReference(e2, t4) {
    const r4 = H2(t4) ? t4.layers : t4.featureCollection?.layers;
    if (!r4?.length) return f.WGS84;
    const { layerDefinition: o7, featureSet: i6 } = r4[0], s5 = i6.features[0], n6 = s5?.geometry?.spatialReference ?? i6.spatialReference ?? o7.spatialReference ?? o7.extent.spatialReference ?? N2;
    return f.fromJSON(n6);
  }
  readStops(e2, t4) {
    return this._getNetworkFeatures(t4, "Stops", (e3) => S.fromGraphic(e3), (e3) => this._setStopSymbol(e3));
  }
  get title() {
    return this.routeInfo?.name ?? "Route";
  }
  set title(e2) {
    this._overrideIfSome("title", e2);
  }
  get url() {
    return s.routeServiceUrl;
  }
  set url(e2) {
    null != e2 ? this._set("url", y(e2, i.getLogger(this))) : this._set("url", s.routeServiceUrl);
  }
  load(e2) {
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Feature Collection"] }, e2)), Promise.resolve(this);
  }
  removeAll() {
    this.removeResult(), this.pointBarriers.removeAll(), this.polygonBarriers.removeAll(), this.polylineBarriers.removeAll(), this.stops.removeAll();
  }
  removeResult() {
    null != this.directionLines && (this.directionLines.removeAll(), this._set("directionLines", null)), null != this.directionPoints && (this.directionPoints.removeAll(), this._set("directionPoints", null)), null != this.routeInfo && this._set("routeInfo", null);
  }
  async save() {
    await this.load();
    const { fullExtent: e2, portalItem: t4 } = this;
    if (!t4) throw new s2("routelayer:portal-item-not-set", "save() requires to the layer to have a portal item");
    if (!t4.id) throw new s2("routelayer:portal-item-not-saved", "Please use saveAs() first to save the routelayer");
    if ("Feature Collection" !== t4.type) throw new s2("routelayer:portal-item-wrong-type", 'Portal item needs to have type "Feature Collection"');
    if (!this.routeInfo) throw new s2("routelayer:route-unsolved", "save() requires a solved route");
    const { portal: r4 } = t4;
    await r4.signIn(), r4.user || await t4.reload();
    const { itemUrl: o7, itemControl: i6 } = t4;
    if ("admin" !== i6 && "update" !== i6) throw new s2("routelayer:insufficient-permissions", "To save this layer, you need to be the owner or an administrator of your organization");
    const n6 = { messages: [], origin: "portal-item", portal: r4, url: o7 ? I(o7) : void 0, writtenProperties: [] }, a8 = this.write(void 0, n6);
    return t4.extent = await ie(e2), t4.title = this.title, await t4.update({ data: a8 }), t4;
  }
  async saveAs(e2, t4 = {}) {
    if (await this.load(), null == this.routeInfo) throw new s2("routelayer:route-unsolved", "saveAs() requires a solved route");
    const r4 = k.from(e2).clone();
    r4.extent ??= await ie(this.fullExtent), r4.id = null, r4.portal ??= M3.getDefault(), r4.title ??= this.title, r4.type = "Feature Collection", r4.typeKeywords = ["Data", "Feature Collection", E.MULTI_LAYER, "Route Layer"];
    const { portal: o7 } = r4, i6 = { messages: [], origin: "portal-item", portal: o7, url: null, writtenProperties: [] };
    await o7.signIn();
    const n6 = t4?.folder, a8 = this.write(void 0, i6);
    return await o7.user.addItem({ item: r4, folder: n6, data: a8 }), this.portalItem = r4, i2(i6), i6.portalItem = r4, r4;
  }
  async solve(e2, t4) {
    Y(this.stops), Y(this.pointBarriers), Y(this.polylineBarriers), Y(this.polygonBarriers);
    const r4 = e2?.stops ?? this.stops, o7 = e2?.pointBarriers ?? K(this.pointBarriers), n6 = e2?.polylineBarriers ?? K(this.polylineBarriers), a8 = e2?.polygonBarriers ?? K(this.polygonBarriers);
    if (null == r4) throw new s2("routelayer:undefined-stops", "the route layer must have stops defined in the route parameters.");
    if ((Q(r4) || $(r4)) && r4.features.length < 2 || O.isCollection(r4) && r4.length < 2) throw new s2("routelayer:insufficent-stops", "the route layer must have two or more stops to solve a route.");
    if (O.isCollection(r4)) for (const i6 of r4) i6.routeName = null;
    const l8 = e2?.apiKey, { checksum: p8, url: c11 } = this, m13 = await this._getServiceDescription(c11, l8, t4), y3 = e2?.travelMode ?? m13.defaultTravelMode, f7 = e2?.accumulateAttributes ?? [];
    y3 && (f7.push(y3.distanceAttributeName), y3.timeAttributeName && f7.push(y3.timeAttributeName));
    const d4 = { accumulateAttributes: f7, checksum: p8, directionsOutputType: "featuresets", ignoreInvalidLocations: true, pointBarriers: o7, polylineBarriers: n6, polygonBarriers: a8, preserveObjectID: true, returnBarriers: !!o7, returnDirections: true, returnPolygonBarriers: !!a8, returnPolylineBarriers: !!n6, returnRoutes: true, returnStops: true, stops: r4 }, h3 = P2.from(e2 ?? {});
    let w2;
    h3.set(d4);
    try {
      w2 = await l6(c11, h3, t4);
    } catch (S2) {
      throw d(S2) ? S2 : new s2("routelayer:failed-route-request", "the routing request failed", { error: S2 });
    }
    const g2 = this._toRouteLayerSolution(w2);
    return this._isOverridden("title") || (this.title = g2.routeInfo.name ?? "Route"), this._populatePortalFields(g2, m13, h3), g2;
  }
  update(e2) {
    const { checksum: t4, directionLines: r4, directionPoints: o7, pointBarriers: i6, polygonBarriers: s5, polylineBarriers: n6, routeInfo: a8, stops: l8 } = e2;
    Z(l8, this.stops) ? oe(l8, this.stops) : this.set({ stops: l8 }), Z(i6, this.pointBarriers) ? ee(i6, this.pointBarriers) : this.set({ pointBarriers: i6 }), Z(n6, this.polylineBarriers) ? te(n6, this.polylineBarriers) : this.set({ polylineBarriers: n6 }), Z(s5, this.polygonBarriers) ? re(s5, this.polygonBarriers) : this.set({ polygonBarriers: s5 }), this.set({ checksum: t4 }), this._set("directionLines", r4), this._set("directionPoints", o7), this._set("routeInfo", a8), null != a8.geometry && (this.spatialReference = a8.geometry.spatialReference);
  }
  _getNetworkFeatures(e2, t4, s5, n6) {
    const a8 = H2(e2) ? e2.layers : e2.featureCollection?.layers, l8 = a8?.find((e3) => e3.layerDefinition.name === t4);
    if (null == l8) return new O();
    const { layerDefinition: u6, popupInfo: p8, featureSet: c11 } = l8, m13 = u6.drawingInfo.renderer, { features: y3 } = c11, f7 = c11.spatialReference ?? u6.spatialReference ?? u6.extent.spatialReference ?? N2, d4 = m13 && o4(m13), h3 = f.fromJSON(f7), w2 = y3.map((e3) => {
      const i6 = _2.fromJSON(e3);
      null != i6.geometry && null != e3.geometry && null == e3.geometry.spatialReference && (i6.geometry.spatialReference = h3);
      const n7 = s5(i6);
      return n7.symbol ??= d4?.getSymbol(i6) ?? this._getNetworkSymbol(t4), n7.popupTemplate ??= p8 && q.fromJSON(p8), n7;
    });
    return n6 && w2.some(({ symbol: e3 }) => !e3) && n6(w2), new O(w2);
  }
  _getNetworkSymbol(e2) {
    switch (e2) {
      case "Barriers":
        return this.defaultSymbols.pointBarriers;
      case "DirectionPoints":
        return this.defaultSymbols.directionPoints;
      case "DirectionLines":
        return this.defaultSymbols.directionLines;
      case "PolylineBarriers":
        return this.defaultSymbols.polylineBarriers;
      case "PolygonBarriers":
        return this.defaultSymbols.polygonBarriers;
      case "RouteInfo":
        return this.defaultSymbols.routeInfo;
      case "Stops":
        return null;
    }
  }
  async _getServiceDescription(e2, t4, r4) {
    if (null != this._cachedServiceDescription && this._cachedServiceDescription.url === e2) return this._cachedServiceDescription.serviceDescription;
    const o7 = await d3(e2, t4, r4);
    return this._cachedServiceDescription = { serviceDescription: o7, url: e2 }, o7;
  }
  _setStopSymbol(e2) {
    if (!e2 || !e2.length || !this.defaultSymbols.stops || e2.every(({ symbol: e3 }) => !!e3)) return;
    const { first: t4, last: r4, middle: o7, unlocated: i6, waypoint: s5, break: n6 } = this.defaultSymbols.stops, a8 = e2.map(({ sequence: e3 }) => e3).filter((e3) => null != e3), l8 = e2.length === a8.length;
    if (!this.routeInfo && !l8 || 1 === e2.length) return void e2.forEach((i7, s6) => {
      switch (s6) {
        case 0:
          i7.symbol = t4;
          break;
        case e2.length - 1:
          i7.symbol = r4;
          break;
        default:
          i7.symbol = o7;
      }
    });
    const u6 = Math.min(...a8), p8 = Math.max(...a8);
    for (const c11 of e2) c11.sequence !== u6 ? c11.sequence !== p8 ? this.routeInfo && "ok" !== c11.status && "not-located-on-closest" !== c11.status ? c11.symbol = i6 : "waypoint" !== c11.locationType ? "break" !== c11.locationType ? c11.symbol = o7 : c11.symbol = n6 : c11.symbol = s5 : c11.symbol = r4 : c11.symbol = t4;
  }
  _toRouteLayerSolution(e2) {
    const { checksum: t4, routeResults: r4 } = e2, o7 = r4[0].stops?.map((e3) => S.fromJSON(e3.toJSON()));
    this._setStopSymbol(o7);
    const i6 = new ye(o7), s5 = new ce(e2.polygonBarriers?.map((e3) => {
      const t5 = h2.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.polygonBarriers, t5;
    })), n6 = new me(e2.polylineBarriers?.map((e3) => {
      const t5 = d2.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.polylineBarriers, t5;
    })), a8 = new pe(e2.pointBarriers?.map((e3) => {
      const t5 = T.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.pointBarriers, t5;
    })), l8 = r4[0].route?.toJSON(), u6 = f5.fromJSON(l8);
    u6.symbol = this.defaultSymbols.routeInfo;
    const p8 = new ue(r4[0].directionPoints?.features.map((e3) => {
      const t5 = c.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.directionPoints, t5;
    }));
    return { checksum: t4, directionLines: new le(r4[0].directionLines?.features.map((e3) => {
      const t5 = m7.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.directionLines, t5;
    })), directionPoints: p8, pointBarriers: a8, polygonBarriers: s5, polylineBarriers: n6, routeInfo: u6, stops: i6 };
  }
  _writeDirectionLines() {
    return this._writeNetworkFeatures(this.directionLines, this.defaultSymbols.directionLines, "esriGeometryPolyline", m7.fields, "DirectionLines", "Direction Lines");
  }
  _writeDirectionPoints() {
    return this._writeNetworkFeatures(this.directionPoints, this.defaultSymbols.directionPoints, "esriGeometryPoint", c.fields, "DirectionPoints", "Direction Points");
  }
  _writeNetworkFeatures(e2, t4, r4, o7, i6, s5) {
    if (!e2?.length) return null;
    const n6 = this.spatialReference.toJSON(), { fullExtent: a8, maxScale: l8, minScale: u6 } = this;
    return { featureSet: { features: e2.toArray().map((e3) => ae(e3)), geometryType: r4, spatialReference: n6 }, layerDefinition: { capabilities: "Query,Update,Editing", drawingInfo: { renderer: { type: "simple", symbol: null != t4 ? t4.toJSON() : X(r4) } }, extent: a8.toJSON(), fields: o7, geometryType: r4, hasM: false, hasZ: false, maxScale: l8, minScale: u6, name: i6, objectIdField: "ObjectID", spatialReference: n6, title: s5, type: "Feature Layer", typeIdField: "" } };
  }
  _writePointBarriers() {
    return this._writeNetworkFeatures(this.pointBarriers, this.defaultSymbols.pointBarriers, "esriGeometryPoint", T.fields, "Barriers", "Point Barriers");
  }
  _writePolygonBarriers() {
    return this._writeNetworkFeatures(this.polygonBarriers, this.defaultSymbols.polygonBarriers, "esriGeometryPolygon", h2.fields, "PolygonBarriers", "Polygon Barriers");
  }
  _writePolylineBarriers() {
    return this._writeNetworkFeatures(this.polylineBarriers, this.defaultSymbols.polylineBarriers, "esriGeometryPolyline", d2.fields, "PolylineBarriers", "Line Barriers");
  }
  _writeRouteInfo() {
    return this._writeNetworkFeatures(null != this.routeInfo ? new O([this.routeInfo]) : null, this.defaultSymbols.routeInfo, "esriGeometryPolyline", f5.fields, "RouteInfo", "Route Details");
  }
  _writeStops() {
    const e2 = this._writeNetworkFeatures(this.stops, null, "esriGeometryPoint", S.fields, "Stops", "Stops");
    if (null == e2) return null;
    const { stops: t4 } = this.defaultSymbols, r4 = t4?.first?.toJSON(), o7 = t4?.middle?.toJSON(), i6 = t4?.last?.toJSON();
    return e2.layerDefinition.drawingInfo.renderer = { type: "uniqueValue", field1: "Sequence", defaultSymbol: o7, uniqueValueInfos: [{ value: "1", symbol: r4, label: "First Stop" }, { value: `${this.stops.length}`, symbol: i6, label: "Last Stop" }] }, e2;
  }
  _populatePortalFields(e2, t4, r4) {
    const o7 = t4.networkDataset?.networkAttributes, i6 = o7?.filter(({ usageType: e3 }) => "cost" === e3) ?? [], a8 = r4.travelMode ?? t4.defaultTravelMode;
    if (null == a8) return void i.getLogger(this).warn("route-layer:missing-travel-mode", "The routing service must have a default travel mode or one must be specified in the route parameter.");
    const { timeAttributeName: l8, distanceAttributeName: u6 } = a8, p8 = i6.find(({ name: e3 }) => e3 === l8), c11 = i6.find(({ name: e3 }) => e3 === u6), m13 = r4.travelMode?.impedanceAttributeName ?? r4.impedanceAttribute ?? t4.impedance, y3 = p8?.units, f7 = c11?.units;
    if (!y3 || !f7) throw new s2("routelayer:unknown-impedance-units", "the units of either the distance or time impedance are unknown");
    const d4 = r4.directionsLanguage ?? t4.directionsLanguage, h3 = r4.accumulateAttributes ?? t4.accumulateAttributeNames ?? [], w2 = new Set(i6.filter(({ name: e3 }) => e3 === l8 || e3 === u6 || e3 === m13 || null != e3 && h3.includes(e3)).map(({ name: e3 }) => e3)), g2 = (e3) => {
      for (const t5 in e3) w2.has(t5) || delete e3[t5];
    };
    for (const s5 of e2.pointBarriers) null != s5.costs && (s5.addedCost = s5.costs[m13] ?? 0, g2(s5.costs));
    for (const s5 of e2.polygonBarriers) null != s5.costs && (s5.scaleFactor = s5.costs[m13] ?? 1, g2(s5.costs));
    for (const s5 of e2.polylineBarriers) null != s5.costs && (s5.scaleFactor = s5.costs[m13] ?? 1, g2(s5.costs));
    const { routeInfo: S2 } = e2, { findBestSequence: b5, preserveFirstStop: v2, preserveLastStop: B, startTimeIsUTC: P3, timeWindowsAreUTC: I2 } = r4;
    S2.analysisSettings = new a5({ accumulateAttributes: h3, directionsLanguage: d4, findBestSequence: b5, preserveFirstStop: v2, preserveLastStop: B, startTimeIsUTC: P3, timeWindowsAreUTC: I2, travelMode: a8 }), S2.totalDuration = se(S2.totalCosts?.[l8] ?? 0, y3), S2.totalDistance = ne(S2.totalCosts?.[u6] ?? 0, f7), S2.totalLateDuration = se(S2.totalViolations?.[l8] ?? 0, y3), S2.totalWaitDuration = se(S2.totalWait?.[l8] ?? 0, y3), null != S2.totalCosts && g2(S2.totalCosts), null != S2.totalViolations && g2(S2.totalViolations), null != S2.totalWait && g2(S2.totalWait);
    for (const s5 of e2.stops) null != s5.serviceCosts && (s5.serviceDuration = se(s5.serviceCosts[l8] ?? 0, y3), s5.serviceDistance = ne(s5.serviceCosts[u6] ?? 0, f7), g2(s5.serviceCosts)), null != s5.cumulativeCosts && (s5.cumulativeDuration = se(s5.cumulativeCosts[l8] ?? 0, y3), s5.cumulativeDistance = ne(s5.cumulativeCosts[u6] ?? 0, f7), g2(s5.cumulativeCosts)), null != s5.violations && (s5.lateDuration = se(s5.violations[l8] ?? 0, y3), g2(s5.violations)), null != s5.wait && (s5.waitDuration = se(s5.wait[l8] ?? 0, y3), g2(s5.wait));
  }
};
__decorate([m2({ readOnly: true, json: { read: false, origins: { "portal-item": { write: { allowNull: true, ignoreOrigin: true } }, "web-map": { write: { overridePolicy() {
  return { allowNull: true, ignoreOrigin: null == this.portalItem };
} } } } } })], fe.prototype, "_featureCollection", void 0), __decorate([r(["web-map", "portal-item"], "_featureCollection")], fe.prototype, "writeFeatureCollectionWebmap", null), __decorate([m2({ readOnly: true, json: { read: false, origins: { "web-map": { write: { target: "type", overridePolicy() {
  return { ignoreOrigin: null != this.portalItem };
} } } } } })], fe.prototype, "_type", void 0), __decorate([m2({ type: String })], fe.prototype, "checksum", void 0), __decorate([m2({ nonNullable: true, type: c2 })], fe.prototype, "defaultSymbols", void 0), __decorate([m2({ readOnly: true })], fe.prototype, "directionLines", void 0), __decorate([o3(["web-map", "portal-item"], "directionLines", ["layers", "featureCollection.layers"])], fe.prototype, "readDirectionLines", null), __decorate([m2({ readOnly: true })], fe.prototype, "directionPoints", void 0), __decorate([o3(["web-map", "portal-item"], "directionPoints", ["layers", "featureCollection.layers"])], fe.prototype, "readDirectionPoints", null), __decorate([m2({ readOnly: true, json: { read: false, origins: { "web-map": { write: { ignoreOrigin: true } } } } })], fe.prototype, "featureCollectionType", void 0), __decorate([m2({ readOnly: true })], fe.prototype, "fullExtent", null), __decorate([m2({ json: { origins: { "web-map": { name: "featureCollection.showLegend" } }, write: true } })], fe.prototype, "legendEnabled", void 0), __decorate([m2({ type: ["show", "hide"] })], fe.prototype, "listMode", void 0), __decorate([m2({ type: Number, nonNullable: true, json: { write: false } })], fe.prototype, "maxScale", void 0), __decorate([o3(["web-map", "portal-item"], "maxScale", ["layers", "featureCollection.layers"])], fe.prototype, "readMaxScale", null), __decorate([m2({ type: Number, nonNullable: true, json: { write: false } })], fe.prototype, "minScale", void 0), __decorate([o3(["web-map", "portal-item"], "minScale", ["layers", "featureCollection.layers"])], fe.prototype, "readMinScale", null), __decorate([m2({ type: ["ArcGISFeatureLayer"], value: "ArcGISFeatureLayer" })], fe.prototype, "operationalLayerType", void 0), __decorate([m2({ nonNullable: true, type: O.ofType(T) })], fe.prototype, "pointBarriers", void 0), __decorate([o3(["web-map", "portal-item"], "pointBarriers", ["layers", "featureCollection.layers"])], fe.prototype, "readPointBarriers", null), __decorate([m2({ nonNullable: true, type: O.ofType(h2) })], fe.prototype, "polygonBarriers", void 0), __decorate([o3(["web-map", "portal-item"], "polygonBarriers", ["layers", "featureCollection.layers"])], fe.prototype, "readPolygonBarriers", null), __decorate([m2({ nonNullable: true, type: O.ofType(d2) })], fe.prototype, "polylineBarriers", void 0), __decorate([o3(["web-map", "portal-item"], "polylineBarriers", ["layers", "featureCollection.layers"])], fe.prototype, "readPolylineBarriers", null), __decorate([m2({ readOnly: true })], fe.prototype, "routeInfo", void 0), __decorate([o3(["web-map", "portal-item"], "routeInfo", ["layers", "featureCollection.layers"])], fe.prototype, "readRouteInfo", null), __decorate([m2({ type: f })], fe.prototype, "spatialReference", void 0), __decorate([o3(["web-map", "portal-item"], "spatialReference", ["layers", "featureCollection.layers"])], fe.prototype, "readSpatialReference", null), __decorate([m2({ nonNullable: true, type: O.ofType(S) })], fe.prototype, "stops", void 0), __decorate([o3(["web-map", "portal-item"], "stops", ["layers", "featureCollection.layers"])], fe.prototype, "readStops", null), __decorate([m2()], fe.prototype, "title", null), __decorate([m2({ readOnly: true, json: { read: false } })], fe.prototype, "type", void 0), __decorate([m2()], fe.prototype, "url", null), fe = __decorate([a("esri.layers.RouteLayer")], fe);
var de = fe;
export {
  de as default
};
//# sourceMappingURL=RouteLayer-G5ULCZBC.js.map
