import {
  h as h7
} from "./chunk-IZEXWD52.js";
import {
  j as j3,
  l as l6
} from "./chunk-CMAY55HR.js";
import {
  a as a3,
  t as t4
} from "./chunk-F5JN6VXH.js";
import {
  e as e7,
  i as i4,
  p as p4
} from "./chunk-V622TPWA.js";
import {
  i as i5
} from "./chunk-L7AHSCRH.js";
import {
  f as f6
} from "./chunk-B6U4OZGR.js";
import {
  h as h6,
  x as x3
} from "./chunk-H4PQ35LQ.js";
import {
  e as e6,
  g,
  w2
} from "./chunk-K5ZF6G4K.js";
import {
  y as y3
} from "./chunk-6AWERJZ7.js";
import {
  C2 as C,
  F2,
  H2 as H,
  R,
  r as r2
} from "./chunk-MLUR3X6U.js";
import "./chunk-I7PJIK77.js";
import {
  l as l5
} from "./chunk-Y2GQGUGW.js";
import "./chunk-SUOIQXQ3.js";
import "./chunk-TNKZDDMZ.js";
import "./chunk-Z3EPMK46.js";
import "./chunk-VHCNEAMV.js";
import "./chunk-2XEDAAX5.js";
import "./chunk-H6PLTW7B.js";
import "./chunk-3SCRAN3E.js";
import "./chunk-NTNXXNRP.js";
import "./chunk-QCJFPBRP.js";
import {
  F
} from "./chunk-MSFUE7MW.js";
import "./chunk-V4S4W4OB.js";
import {
  d as d3
} from "./chunk-IGRCAVBL.js";
import "./chunk-BHTGT37R.js";
import "./chunk-WAYU35CW.js";
import "./chunk-XBGTYNWI.js";
import "./chunk-BTFBYI67.js";
import "./chunk-D3G5WIRR.js";
import "./chunk-Q3JOE7TC.js";
import "./chunk-VIDAPS4J.js";
import "./chunk-GD72EK2J.js";
import "./chunk-B3BLJNSM.js";
import "./chunk-ALKEERWI.js";
import "./chunk-2JMKFI2D.js";
import "./chunk-QYAMBIRP.js";
import "./chunk-EOQ2S5UA.js";
import "./chunk-WBXDB33U.js";
import "./chunk-XTEXJOLG.js";
import "./chunk-YE4E5JCT.js";
import "./chunk-SXZO7ULH.js";
import "./chunk-GVMCGYZ6.js";
import "./chunk-JHV6OBEB.js";
import "./chunk-IR5QDMME.js";
import "./chunk-O5UBEIJA.js";
import "./chunk-FNMK6NUG.js";
import "./chunk-QTRET3PG.js";
import "./chunk-FMOL5XMB.js";
import "./chunk-VNSHGTPN.js";
import "./chunk-WHHIH5YU.js";
import "./chunk-5LMH6D7V.js";
import "./chunk-BZLHV37L.js";
import "./chunk-V6V3WWJF.js";
import "./chunk-EK7HOTRR.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import {
  j as j2,
  x as x2
} from "./chunk-TCIOA3WX.js";
import "./chunk-5IXGYDQ3.js";
import "./chunk-RKVVFTIZ.js";
import "./chunk-WJ5RYEGC.js";
import "./chunk-7TAAMEZT.js";
import "./chunk-4POFO7MP.js";
import "./chunk-257FD5T2.js";
import "./chunk-ZNI54T6D.js";
import "./chunk-EKZRA6TO.js";
import "./chunk-M5SP6ZBM.js";
import "./chunk-E7PJOFGP.js";
import {
  c as c2
} from "./chunk-4VQDBNTM.js";
import {
  f as f5
} from "./chunk-3BNOOWTA.js";
import "./chunk-AIJLLSRB.js";
import "./chunk-T3SYSTKO.js";
import "./chunk-HOJHSMLY.js";
import "./chunk-B5A4L35M.js";
import "./chunk-52SEOH5H.js";
import "./chunk-WDTGOP77.js";
import "./chunk-VYMBX5H5.js";
import {
  h as h5
} from "./chunk-BPTFV5VM.js";
import "./chunk-5ONGWFJ3.js";
import "./chunk-BBYMM7CM.js";
import "./chunk-EM7Y2JZC.js";
import "./chunk-MUBG7EZN.js";
import "./chunk-TMVLBQMP.js";
import "./chunk-6IHS6RYH.js";
import "./chunk-OJBEN6CV.js";
import "./chunk-TU5E6NPS.js";
import "./chunk-RKNCTZBL.js";
import {
  n as n4
} from "./chunk-36OXW4YN.js";
import "./chunk-PEL3D3ZN.js";
import "./chunk-Q5KWD3VQ.js";
import "./chunk-BUQC3CLV.js";
import "./chunk-W5S3VUFT.js";
import "./chunk-7YH7T6CS.js";
import "./chunk-3T4IXPP4.js";
import "./chunk-XTZAIV4X.js";
import "./chunk-63LDVRFI.js";
import "./chunk-TJTOV6JD.js";
import {
  _ as _2
} from "./chunk-C3FRY5U4.js";
import "./chunk-JNJX34GB.js";
import "./chunk-3STJRSDT.js";
import "./chunk-67Q6KVC6.js";
import "./chunk-23NJHA5Q.js";
import "./chunk-4LA6K4VI.js";
import "./chunk-KEZCWFAR.js";
import "./chunk-JZUJ34RR.js";
import {
  G,
  f as f4,
  s as s3,
  u as u4
} from "./chunk-PMGS7UDU.js";
import "./chunk-3GHCGAH2.js";
import "./chunk-HWUOAPTX.js";
import "./chunk-QHCKOBU7.js";
import "./chunk-K2OZ6WVC.js";
import "./chunk-MC6NAKKX.js";
import "./chunk-TF6255HN.js";
import "./chunk-GD4FJL3C.js";
import "./chunk-C5OQVQZF.js";
import {
  u as u5
} from "./chunk-F7DKSAOI.js";
import {
  m as m3
} from "./chunk-4SOQWNPG.js";
import "./chunk-LTULADK2.js";
import "./chunk-35ST7YRB.js";
import "./chunk-EDA5QFHZ.js";
import "./chunk-6Z5KSPPF.js";
import {
  m as m2,
  p
} from "./chunk-CNYNCKEV.js";
import {
  d
} from "./chunk-XL5QPCXN.js";
import "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-6KDQMJAI.js";
import "./chunk-UDHS2MGH.js";
import "./chunk-QF7FRVN6.js";
import "./chunk-ENINOZUZ.js";
import "./chunk-P6IKJIMO.js";
import "./chunk-MHV23XAQ.js";
import "./chunk-V2X4OKYI.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import "./chunk-MA3QDRC3.js";
import "./chunk-W6J7XCPU.js";
import "./chunk-ONXWBTTM.js";
import "./chunk-T7F6Q6JJ.js";
import {
  O
} from "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-7P2ANHQ3.js";
import "./chunk-XCKT47LJ.js";
import "./chunk-3FUHCAX3.js";
import {
  M,
  a as a2,
  c,
  d2,
  e as e4,
  e2 as e5,
  f2,
  f3,
  h2 as h3,
  h3 as h4,
  i as i3,
  l as l3,
  n as n2,
  n2 as n3,
  p as p2,
  p2 as p3,
  t as t3,
  u3 as u2,
  u4 as u3,
  x,
  y3 as y2
} from "./chunk-PZ5RULLK.js";
import {
  l as l4,
  r,
  y
} from "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import {
  P,
  U,
  f,
  h as h2,
  j,
  l as l2,
  w
} from "./chunk-2OFHDVO5.js";
import {
  l
} from "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-5UPBUJPC.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-CCQFL76O.js";
import {
  i as i2
} from "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import "./chunk-7H3U4IJR.js";
import "./chunk-SMWUT52Z.js";
import {
  _
} from "./chunk-AXZMNHTN.js";
import "./chunk-5T3MJDSR.js";
import "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import {
  b,
  m,
  t4 as t2
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import {
  e
} from "./chunk-4DGC7CBY.js";
import {
  e as e2,
  e2 as e3,
  n,
  s as s2,
  t,
  u2 as u
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  h
} from "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/views/draw/support/ConnectedReshapeManager.js
var _3 = () => i.getLogger("esri.views.draw.support.ConnectedReshapeManager");
var w3 = Symbol();
var G2 = class extends b {
  constructor(e8) {
    super(e8), this.activeOperationType = null, this.providerFactories = [], this.view = null, this._activeProviders = /* @__PURE__ */ new Set(), this._graphics = /* @__PURE__ */ new Map(), this._modifiedFeatures = /* @__PURE__ */ new Map(), this._modifiedGraphicsLayer = new n4({ listMode: "hide", internal: true, title: "Connected Reshape Modified Graphics (Internal)" }), this._pendingGraphicsLayer = new n4({ listMode: "hide", internal: true, title: "Connected Reshape Pending Graphics (Internal)" }), this._pendingFeatures = /* @__PURE__ */ new Map(), this._updatingHandles = new h5();
  }
  initialize() {
    this.view.map.addMany([this._modifiedGraphicsLayer, this._pendingGraphicsLayer]);
  }
  destroy() {
    this.view.destroyed || this.view.map.removeMany([this._modifiedGraphicsLayer, this._pendingGraphicsLayer]), this._modifiedGraphicsLayer.destroy(), this._pendingGraphicsLayer.destroy(), this._updatingHandles.destroy();
  }
  get updating() {
    return this._updatingHandles.updating || Array.from(this._activeProviders).some((e8) => e8.updating);
  }
  startFeatureMove(e8) {
    this.activeOperationType = 0, this._activeProviders.clear();
    for (const i7 of this.providerFactories) t2(this._activeProviders, i7.getFeatureReshapeProvider(e8));
  }
  startVertexMove(e8, i7) {
    this.activeOperationType = 1, this._activeProviders.clear();
    for (const t5 of this.providerFactories) t2(this._activeProviders, t5.getVertexReshapeProvider(e8, i7));
  }
  finish() {
    this.activeOperationType = null, this._activeProviders.clear();
    for (const [e8, i7] of this._pendingFeatures) {
      this._pendingFeatures.delete(e8), this._modifiedFeatures.set(e8, i7);
      const t5 = this._graphics.get(e8);
      t5 && (this._modifiedGraphicsLayer.add(t5), this._pendingGraphicsLayer.remove(t5));
    }
  }
  translate(e8, i7, t5 = 0) {
    if (null === this.activeOperationType) return;
    const r3 = P2(e8), s4 = P2(i7), a4 = P2(t5);
    for (const o of this._activeProviders) {
      const e9 = o.translate(r3, s4, a4);
      this._update(e9);
    }
  }
  async _initializeGraphic(e8, i7) {
    e8.symbol ??= await this._updatingHandles.addPromise(F(e8, { scale: this.view.scale, useSourceLayer: true })), this._pendingFeatures.has(i7.uniqueId) ? this._pendingGraphicsLayer.add(e8) : this._modifiedFeatures.has(i7.uniqueId) && this._modifiedGraphicsLayer.add(e8), this.addHandles(await L(i7.originalGraphic, e8, this.view), w3);
  }
  _update(e8) {
    for (const i7 of e8) {
      const e9 = this._modifiedFeatures.delete(i7.uniqueId);
      this._pendingFeatures.set(i7.uniqueId, i7);
      const t5 = e(this._graphics, i7.uniqueId, () => {
        const e10 = i7.graphic.cloneShallow();
        return this._initializeGraphic(e10, i7), e10;
      });
      t5.geometry = i7.graphic.geometry, e9 && (this._modifiedGraphicsLayer.remove(t5), this._pendingGraphicsLayer.add(t5));
    }
  }
  get test() {
    return { activeProviders: this._activeProviders, modifiedFeatures: this._modifiedFeatures, modifiedGraphicsLayer: this._modifiedGraphicsLayer, pendingFeatures: this._pendingFeatures, pendingGraphicsLayer: this._pendingGraphicsLayer };
  }
};
async function L(e8, i7, a4) {
  const o = e8.sourceLayer, d5 = e8.getObjectId();
  if (null == d5) return _3().error("editing:cannot-hide-graphic", "Unable to hide original graphic because it has no objectId."), e2();
  let c3 = null;
  function h9(e9) {
    c3?.abort(), c3 = d(async (i8) => {
      const t5 = await b2(a4, o);
      s2(i8), t5 && t5.setVisibility?.(d5, e9);
    });
  }
  return await F3(a4, i7), h9(false), t([j4(a4, i7, (e9) => h9(!e9)), e2(async () => {
    h9(true);
    const e9 = await b2(a4, o);
    await j(() => !e9?.updating);
  })]);
}
function j4(e8, i7, t5) {
  if ("3d" === e8.type) {
    const r3 = new e7({ graphic: i7 });
    return t([e8.trackGraphicState(r3), l2(() => r3.displaying, t5)]);
  }
  return l2(() => i7.visible, t5);
}
async function F3(e8, i7) {
  if ("3d" === e8.type) {
    const t5 = new e7({ graphic: i7 }), r3 = e8.trackGraphicState(t5);
    await j(() => t5.displaying || t5.error), r3.remove();
  } else await j(() => i7.visible);
}
async function b2(e8, i7) {
  const t5 = m2(i7) || p(i7) ? i7.parent : i7;
  return t5 ? e8.whenLayerView(t5) : null;
}
function P2(e8) {
  return isNaN(e8) ? 0 : e8;
}
__decorate([m()], G2.prototype, "activeOperationType", void 0), __decorate([m()], G2.prototype, "providerFactories", void 0), __decorate([m()], G2.prototype, "updating", null), __decorate([m({ constructOnly: true })], G2.prototype, "view", void 0), G2 = __decorate([a("esri.views.draw.support.ConnectedReshapeManager")], G2);

// node_modules/@arcgis/core/views/interactive/tooltip/infos/TranslateVertexTooltipInfo.js
var i6 = class extends r2 {
  constructor(t5) {
    super(t5), this.type = "translate-vertex", this.distance = d3, this.elevation = null, this.area = null, this.totalLength = null;
  }
  clear() {
    this.distance = d3, this.elevation = null, this.area = null, this.totalLength = null;
  }
};
__decorate([m()], i6.prototype, "type", void 0), __decorate([m()], i6.prototype, "distance", void 0), __decorate([m()], i6.prototype, "elevation", void 0), __decorate([m()], i6.prototype, "area", void 0), __decorate([m()], i6.prototype, "totalLength", void 0), i6 = __decorate([a("esri.views.interactive.tooltip.infos.TranslateVertexTooltipInfo")], i6);

// node_modules/@arcgis/core/views/draw/support/reshapeTooltipUtils.js
function v(t5) {
  const e8 = { sketchOptions: t5, viewType: "2d" };
  return { movePoint: new i4(e8), selectedVertex: new p4(e8), translateGraphic: new i5(e8), translateVertices: new i6(e8) };
}
function g2(e8, r3) {
  function a4() {
    const t5 = r3(), e9 = t5.sketchOptions.tooltips.effectiveEnabled ? t5.activeTooltipInfo : null;
    return { ...t5, activeTooltipInfo: e9 };
  }
  let s4 = false;
  function l7(t5) {
    s4 || (s4 = true, t5(), s4 = false);
  }
  return t([l2(() => {
    const t5 = a4();
    return { context: t5, geometry: t5.graphic?.geometry, vertexGeometry: t5.selectedVertex?.geometry };
  }, ({ context: t5 }) => {
    l7(() => {
      h8(t5), e8.info = t5.activeTooltipInfo;
    });
  }, w), l2(() => {
    const t5 = a4(), { activeTooltipInfo: e9 } = t5;
    if (e9 && "key" in e9) return { context: t5, key: e9.key };
  }, (t5, e9) => {
    t5 && e9 && t5.key !== e9.key && l7(() => j5(t5.context));
  }, U), C(e8, { onBeforePaste: () => {
    s4 = true;
  }, onAfterPaste: () => {
    j5(a4()), s4 = false;
  } })]);
}
function h8(t5) {
  const e8 = t5.activeTooltipInfo;
  if (e8) {
    switch (e8?.type) {
      case "move-point":
        return d4(e8, t5);
      case "selected-vertex":
        return x4(e8, t5);
    }
    e8.sketchOptions = t5.sketchOptions;
  }
}
function d4(t5, { graphic: e8 }) {
  T(t5, e8, e8?.geometry);
}
function x4(t5, { graphic: e8, selectedVertex: o, automaticAreaMeasurementUtils: n5, automaticLengthMeasurementUtils: i7 }) {
  T(t5, e8, o?.geometry);
  const r3 = e8?.geometry;
  if (!r3 || !n2(r3)) switch (r3?.type) {
    case "polygon":
      t5.geometryType = "polygon", t5.totalLength.visible = false, t5.area.actual = n5.autoArea2D(r3);
      break;
    case "polyline":
      t5.geometryType = "polyline", t5.totalLength.actual = i7.autoLength2D(r3), t5.area.visible = false;
      break;
    case "multipoint":
      t5.geometryType = "multipoint", t5.area.visible = false, t5.totalLength.visible = false;
  }
}
function T(t5, e8, o) {
  e8 && "point" === o?.type && (t5.setLocationFromPoint(o), t5.elevation.actual = y3(o), t5.elevation.visible = !!e8.geometry?.hasZ, t5.elevation.readOnly = false, t5.elevation.showAsZ = true);
}
function j5(t5) {
  function e8(e9, o2) {
    const n6 = o2?.geometry;
    if (!n6 || "point" !== n6.type) return;
    const { dx: i8, dy: r3, dz: s4 } = F2(e9, n6);
    if (0 === i8 && 0 === r3 && 0 === s4) return;
    const { x: c3, y: p5, z: m4, m: u6, spatialReference: f7 } = n6, y4 = new _({ x: c3 + i8, y: p5 + r3, z: null != m4 ? m4 + s4 : void 0, m: u6, spatialReference: f7 });
    t5.updateGeometry(o2, y4, n6, i8, r3);
  }
  const { activeTooltipInfo: o, graphic: n5, selectedVertex: i7 } = t5;
  switch (o?.type) {
    case "move-point":
      return e8(o, n5);
    case "selected-vertex":
      return e8(o, i7);
  }
}
function U2(t5, e8, o, n5) {
  t5.clear(), w4(t5, e8, n5, o);
}
function k(t5, e8, o, n5, i7) {
  if (t5.clear(), o && n2(o)) return;
  const { automaticAreaMeasurementUtils: r3, automaticLengthMeasurementUtils: a4 } = n5;
  "polygon" === o?.type ? t5.area = r3.autoArea2D(o) : "polyline" === o?.type && (t5.totalLength = a4.autoLength2D(o)), w4(t5, e8, i7, n5);
}
function w4(t5, o, n5, { automaticLengthMeasurementUtils: i7 }) {
  if (!n5) return;
  const { x: a4, y: s4 } = n5.origin, c3 = o.toMap(n5), l7 = o.toMap(i2(a4, s4)), p5 = i7.autoDistanceBetweenPoints2D(l7, c3);
  t5.distance = null != p5 ? p5 : d3;
}

// node_modules/@arcgis/core/views/draw/support/reshapeUtils.js
var R2 = { pathIndex: "pathIndex", pointIndex: "pointIndex", pointIndexStart: "pointIndexStart", pointIndexEnd: "pointIndexEnd", controlPointKind: "kind", relatedGraphicIndices: "relatedGraphicIndices", curveFromStraightEdgeFlag: "curveFromStraightEdgeFlag", tool: "esriSketchTool" };
var U3 = { bezier: { cp1: "bezier-cp-1", cp2: "bezier-cp-2", line1: "bezier-line-1", line2: "bezier-line-2" }, circle: { interior: "circle-interior" } };
var k2 = "box";
var E = h7.reshapeGraphics;
var T2 = { vertices: { default: new u5({ style: "circle", size: E.vertex.size, color: E.vertex.color, outline: { color: E.vertex.outlineColor, width: 1 } }), hover: new u5({ style: "circle", size: E.vertex.hoverSize, color: E.vertex.hoverColor, outline: { color: E.vertex.hoverOutlineColor, width: 1 } }), selected: new u5({ style: "circle", size: E.selected.size, color: E.selected.color, outline: { color: E.selected.outlineColor, width: 1 } }) }, controlPoints: { default: new u5({ style: "diamond", size: E.vertex.size, color: E.vertex.color, outline: { color: E.vertex.outlineColor, width: 1 } }), hover: new u5({ style: "diamond", size: E.vertex.hoverSize, color: E.vertex.hoverColor, outline: { color: E.vertex.hoverOutlineColor, width: 1 } }), selected: new u5({ style: "diamond", size: E.selected.size, color: E.selected.color, outline: { color: E.selected.outlineColor, width: 1 } }) }, midpoints: { default: new u5({ style: "circle", size: E.midpoint.size, color: E.midpoint.color, outline: { color: E.midpoint.outlineColor, width: 1 } }), hover: new u5({ style: "circle", size: E.midpoint.size, color: E.midpoint.color, outline: { color: E.midpoint.outlineColor, width: 1 } }) }, constructionLines: new m3({ style: "solid", width: 1, color: E.vertex.color }) };
function K(t5, o, r3) {
  const n5 = [];
  return t5?.forEach((t6, i7) => {
    t6.forEach((t7, s4) => {
      n5.push(new _2({ geometry: r3.arrayToPoint(f3(t7)), symbol: o?.vertices?.default, attributes: { [R2.tool]: k2, [R2.pathIndex]: i7, [R2.pointIndex]: s4 } }));
    });
  }), n5;
}
function F4(t5, o, r3) {
  const n5 = [];
  for (let i7 = 0; i7 < t5.length; i7++) {
    const s4 = t5[i7];
    if (!Z(t5, i7)) for (let t6 = 1; t6 < s4.length; t6++) {
      const l7 = s4[t6];
      if (i3(l7)) continue;
      const c3 = f3(s4[t6 - 1]), a4 = { [R2.tool]: k2, [R2.pathIndex]: i7, [R2.pointIndex]: t6 };
      if (t3(l7)) {
        const t7 = l7.b.slice(1);
        n5.push(...t7.map((t8, n6) => new _2({ geometry: r3.arrayToPoint(t8), symbol: o?.controlPoints?.default, attributes: { ...a4, [R2.controlPointKind]: 0 === n6 ? U3.bezier.cp1 : U3.bezier.cp2 } })));
      }
      const m4 = u3(l7), g3 = c(l7);
      if (m4 || g3) {
        const t7 = m4 ? l3(c3, l7) : h4(c3, l7), i8 = h3(t7, 0.25);
        n5.push(new _2({ geometry: r3.arrayToPoint(i8), symbol: o?.controlPoints?.default, attributes: { ...a4, [R2.controlPointKind]: U3.circle.interior } }));
      }
    }
  }
  return n5;
}
function G3(t5, o, n5) {
  const i7 = [], { spatialReference: s4 } = n5;
  for (let l7 = 0; l7 < t5.length; l7++) {
    const n6 = t5[l7];
    for (let t6 = 1; t6 < n6.length; t6++) {
      const c3 = n6[t6];
      if (!t3(c3)) continue;
      const [a4, p5, u6] = c3.b, m4 = f3(n6[t6 - 1]), f7 = { [R2.tool]: k2, [R2.pathIndex]: l7, [R2.pointIndex]: t6 };
      i7.push(new _2({ geometry: new y2({ paths: [[[m4[0], m4[1]], p5]], spatialReference: s4 }), symbol: o?.constructionLines, attributes: { ...f7, [R2.controlPointKind]: U3.bezier.line1 } }), new _2({ geometry: new y2({ paths: [[[a4[0], a4[1]], u6]], spatialReference: s4 }), symbol: o?.constructionLines, attributes: { ...f7, [R2.controlPointKind]: U3.bezier.line2 } }));
    }
  }
  return i7;
}
function L2(t5, o, r3, n5) {
  const i7 = [];
  for (let s4 = 0; s4 < t5.length; s4++) {
    const l7 = t5[s4], c3 = O2(t5, s4);
    for (let t6 = 0; t6 < l7.length; t6++) {
      const a4 = (t6 + 1) % l7.length;
      if ((!n5 || c3) && 0 === a4) continue;
      const p5 = M2(l7[t6], l7[a4], r3);
      i7.push(new _2({ geometry: p5, symbol: o.midpoints.default, attributes: { [R2.tool]: k2, [R2.pathIndex]: s4, [R2.pointIndexStart]: t6, [R2.pointIndexEnd]: a4 } }));
    }
  }
  return i7;
}
function M2(e8, t5, r3) {
  const i7 = f3(e8), s4 = f3(t5), { spatialReference: l7 } = r3, a4 = r3.arrayToVector(i7), m4 = r3.arrayToVector(s4), g3 = r3.toXYZ(a4), x5 = r3.toXYZ(m4), [w5, j6, P3] = l4(g3, x5), S = r3.hasM() ? 0 : void 0;
  if (i3(t5)) return new _({ x: w5, y: j6, z: P3, m: S, spatialReference: l7 });
  if (t3(t5)) {
    const [e9, r4] = p2(i7, t5, 0.5);
    return new _({ x: e9, y: r4, z: P3, m: S, spatialReference: l7 });
  }
  if (u3(t5)) {
    const e9 = l3(i7, t5), [r4, n5] = h3(e9, 0.5);
    return new _({ x: r4, y: n5, z: P3, m: S, spatialReference: l7 });
  }
  if (c(t5)) {
    const e9 = h4(i7, t5), [r4, n5] = h3(e9, 0.5);
    return new _({ x: r4, y: n5, z: P3, m: S, spatialReference: l7 });
  }
  const C2 = p3(i7, t5), [R3, U4] = d2(C2, 0.5);
  return new _({ x: R3, y: U4, z: P3, m: S, spatialReference: l7 });
}
function Z(e8, o) {
  const r3 = e8.at(o);
  return 2 === r3?.length && h(f3(r3[1]), f3(r3[0])) && c(r3[1]);
}
function A(e8, o) {
  const r3 = e8.at(o);
  return 2 === r3?.length && h(f3(r3[1]), f3(r3[0])) && a2(r3[1]);
}
function O2(e8, o) {
  const r3 = e8.at(o);
  return 2 === r3?.length && h(f3(r3[1]), f3(r3[0])) && e5(r3[1]);
}
function V(e8, t5) {
  if (u4(e8)) return void (e8.points = t5.flat());
  const o = t5.some((e9) => e9.some((e10) => !i3(e10)));
  f4(e8) ? o ? (e8.curveRings = t5, e8.rings = []) : (e8.rings = t5, e8.curveRings = void 0) : G(e8) && (o ? (e8.curvePaths = t5, e8.paths = []) : (e8.curvePaths = void 0, e8.paths = t5));
}
function X(e8, t5, o, r3) {
  const n5 = f3(t5);
  let i7 = [];
  switch (true) {
    case t3(t5):
      i7 = M(e8, t5, o);
      break;
    case u3(t5): {
      const r4 = l3(e8, t5);
      i7 = u2(r4, t5, o);
      break;
    }
    case c(t5): {
      const r4 = h4(e8, t5);
      i7 = n3(r4, t5, o);
      break;
    }
    default: {
      const r4 = p3(e8, t5);
      i7 = x(r4, t5, o);
      break;
    }
  }
  if (i7.length < 2) return i7;
  if (r3.hasZ()) {
    const t6 = e8.at(2) ?? 0, r4 = n5.at(2) ?? 0, s4 = t6 + (r4 - t6) * o;
    f3(i7[0])[2] = s4, f3(i7[1])[2] = r4;
  }
  if (r3.hasM()) {
    const e9 = r3.hasZ() ? 3 : 2;
    f3(i7[0])[e9] = 0, f3(i7[1])[e9] = n5.at(-1) ?? 0;
  }
  return i7;
}

// node_modules/@arcgis/core/views/draw/support/Reshape.js
var yt = Symbol();
var _t = class extends l {
  constructor(t5) {
    super(t5), this._updateHandlesOnExternalGeometryChange = null, this._activeOperationInfo = null, this._connectedReshapeManager = null, this._editGeometryOperations = null, this._mover = null, this._snappingContext = null, this._snappingGraphicsLayer = null, this._hoverGraphic = null, this._snappingTask = null, this._stagedVertex = null, this.tooltip = null, this.activeTooltipInfo = null, this.callbacks = { onReshapeStart() {
    }, onReshape() {
    }, onReshapeStop() {
    }, onMoveStart() {
    }, onMove() {
    }, onMoveStop() {
    }, onGraphicClick() {
    } }, this.connectedReshapeProviders = null, this.enableMidpoints = true, this.enableCurveOnMidpoint = false, this.enableMovement = true, this.enableVertices = true, this.graphic = null, this.highlightName = null, this.highlightsEnabled = true, this.layer = null, this.snappingManager = null, this.symbols = T2, this.sketchOptions = new l5(), this.type = "reshape", this.vertexGraphics = new O(), this.curveControlPointGraphics = new O(), this.constructionLineGraphics = new O(), this.midpointGraphics = new O(), this.selectedManipulators = new O(), this.view = null;
  }
  initialize() {
    const t5 = this.view;
    this._highlightHelper = new l6({ view: t5 }), this._setup(), this._updateHandlesOnExternalGeometryChange = P(() => this.graphic?.geometry, (t6) => {
      if (!t6) return;
      const e8 = new Set(this.selectedManipulators.map(wt));
      this._highlightHelper.removeAll(), this._setUpHighlights(), this._setupGraphics(), this._clearSelection(), this.vertexGraphics.filter((t7) => e8.has(wt(t7))).forEach((t7) => this._addToSelection(t7));
      const { enableMovement: i7, _mover: s4, graphic: o, midpointGraphics: r3, vertexGraphics: n5, curveControlPointGraphics: a4 } = this, h9 = n5.concat(r3, a4).items;
      i7 && h9.push(o), s4?.set("graphics", h9);
    }, U), this.tooltip = R(() => ({ view: t5, options: this.sketchOptions.tooltips })), this.tooltipInfos = v(this.sketchOptions), this.addHandles([f(() => t5?.ready, () => {
      const { layer: t6, view: e8 } = this;
      t4(e8, t6), this.addHandles(e8.on("key-down", (t7) => this._keyDownHandler(t7), f5.TOOL));
    }, { once: true, initial: true }), l2(() => this.graphic, () => this.refresh()), l2(() => this.layer, (t6, e8) => {
      e8 && (this._clearSelection(), this._resetGraphics(e8)), this.refresh();
    }), l2(() => [this.highlightsEnabled, this.highlightName], () => {
      this._highlightHelper?.removeAll(), this._setUpHighlights();
    }), l2(() => this.enableMidpoints, () => this.refresh()), g2(this.tooltip, () => this._tooltipsContext), l2(() => this.view.effectiveTheme.accentColor, () => this._updateSymbolsForTheme(), h2), this._updateHandlesOnExternalGeometryChange]), this._updateTooltip();
  }
  destroy() {
    this._reset(), this._mover?.destroy(), this._mover = null, this._connectedReshapeManager = u(this._connectedReshapeManager), this.tooltip = u(this.tooltip);
  }
  get _coordinateHelper() {
    return this._editGeometryOperations?.data.coordinateHelper ?? w2(!!this.graphic.geometry?.hasZ, !!this.graphic.geometry?.hasM, this.view.spatialReference);
  }
  get _selectedManipulator() {
    return 1 === this.selectedManipulators.length ? this.selectedManipulators.at(0) : void 0;
  }
  get _tooltipsContext() {
    const { automaticAreaMeasurementUtils: t5, automaticLengthMeasurementUtils: e8, sketchOptions: i7, activeTooltipInfo: s4, graphic: o } = this;
    return { sketchOptions: i7, activeTooltipInfo: s4, graphic: o, selectedVertex: this._selectedManipulator, automaticAreaMeasurementUtils: t5, automaticLengthMeasurementUtils: e8, updateGeometry: (t6, e9, i8, s5, o2) => {
      this._setUpGeometryHelper();
      const r3 = t6 === this.graphic;
      r3 ? this._emitMoveStartEvent(0, 0) : this._emitReshapeStartEvent(t6);
      const n5 = true;
      if (this._syncGeometryAfterVertexMove(t6, e9, s5, o2, n5), r3) {
        const { view: t7 } = this, s6 = t7.toScreen(i8), o3 = t7.toScreen(e9), r4 = (o3?.x ?? 0) - (s6?.x ?? 0), n6 = (o3?.y ?? 0) - (s6?.y ?? 0);
        this._emitMoveEvent(r4, n6), this._emitMoveStopEvent(r4, n6);
      } else this._emitReshapeEvent(t6), this._emitReshapeStopEvent(t6);
      this._editGeometryOperations = u(this._editGeometryOperations);
    } };
  }
  get state() {
    const t5 = this.view.ready, e8 = !(!this.graphic || !this.layer);
    return t5 && e8 ? "active" : t5 ? "ready" : "disabled";
  }
  isUIGraphic(t5) {
    return t5 === this.graphic || this._isMidpoint(t5) || this._isCurveControlPoint(t5) || this._isVertex(t5) || this._isConstructionLine(t5);
  }
  refresh() {
    this._reset(), this._setup();
  }
  reset() {
    this.graphic = null;
  }
  clearSelection() {
    this._clearSelection();
  }
  removeSelectedVertices() {
    const { selectedManipulators: t5 } = this;
    t5.length && this._removeVertices(t5);
  }
  _setup() {
    const { graphic: t5, layer: e8 } = this;
    if (!e8 || null == t5?.geometry) return;
    const i7 = t5.geometry;
    "mesh" !== i7.type && "extent" !== i7.type ? ("polygon" === i7.type && y(i7), this._setUpHighlights(), this._setupGraphics(), this._setupMover(), this._setupConnectedReshapeManager()) : this._logGeometryTypeError();
  }
  _setUpHighlights() {
    this.highlightsEnabled && this.graphic && this._highlightHelper?.add(this.graphic, this.highlightName);
  }
  _setUpGeometryHelper() {
    const t5 = this.graphic.geometry;
    null != t5 && "mesh" !== t5.type && "extent" !== t5.type ? this._editGeometryOperations ??= g.fromGeometry(t5, 2, { allowCurves: true }) : this._logGeometryTypeError();
  }
  _saveSnappingContextForHandle(t5, e8) {
    this._snappingGraphicsLayer = new n4({ listMode: "hide", internal: true, title: "Reshape snapping layer" }), this.view.map.layers.add(this._snappingGraphicsLayer);
    const i7 = this._editGeometryOperations;
    n(i7), this._snappingContext = new e6({ editGeometryOperations: i7, elevationInfo: { mode: "on-the-ground", offset: 0 }, pointer: e8.viewEvent?.pointerType || "mouse", excludeFeature: this.graphic, feature: this.graphic, visualizer: new f6(this._snappingGraphicsLayer), vertexHandle: this._getVertexFromEditGeometry(t5) });
  }
  _reset() {
    this._clearSelection(), this._highlightHelper?.removeAll(), this._updateTooltip(), this._resetGraphics(), this._resetSnappingStateVars(), this._activeOperationInfo = null, this._mover?.destroy(), this._mover = null, this.removeHandles(yt);
  }
  _resetSnappingStateVars() {
    null != this.snappingManager && this.snappingManager.doneSnapping(), null != this._snappingGraphicsLayer && (this.view?.map && this.view.map.layers.remove(this._snappingGraphicsLayer), this._snappingGraphicsLayer.destroy()), this._editGeometryOperations = u(this._editGeometryOperations), this._snappingTask = e3(this._snappingTask), this._snappingTask = null, this._snappingContext = null, this._stagedVertex = null;
  }
  _resetGraphics(t5) {
    this._removeMidpointGraphics(t5), this._removeVertexGraphics(t5), this._removeCurveGraphics(t5), this._updateTooltip();
  }
  _removeMidpointGraphics(t5 = this.layer) {
    const { midpointGraphics: e8 } = this;
    t5?.removeMany(e8.items), e8.drain(u);
  }
  _removeVertexGraphics(t5 = this.layer) {
    const { vertexGraphics: e8 } = this;
    t5?.removeMany(e8.items), e8.drain(u);
  }
  _removeCurveGraphics(t5 = this.layer) {
    const { curveControlPointGraphics: e8, constructionLineGraphics: i7 } = this;
    t5?.removeMany(e8.items), t5?.removeMany(i7.items), e8.drain(u), i7.drain(u);
  }
  _setupGraphics() {
    const t5 = this.graphic.geometry;
    if (null != t5 && ("polyline" === t5.type || "polygon" === t5.type || "multipoint" === t5.type)) {
      const e8 = gt(t5);
      this.enableMidpoints && "multipoint" !== t5.type && this._setUpMidpointGraphics(e8), this.enableVertices && (this._setUpVertexGraphics(e8), this._setupCurveGraphics(e8));
    }
  }
  _setUpMidpointGraphics(t5) {
    this._removeMidpointGraphics();
    const e8 = L2(t5, this.symbols, this._coordinateHelper, "polygon" === this.graphic.geometry?.type);
    this.midpointGraphics.addMany(e8), this.layer.addMany(e8);
  }
  _setUpVertexGraphics(t5) {
    this._removeVertexGraphics();
    const e8 = K(t5, this.symbols, this._coordinateHelper);
    this.vertexGraphics.addMany(e8), this._storeRelatedVertexIndices(), this.layer.addMany(e8);
  }
  _setupCurveGraphics(t5) {
    this._removeCurveGraphics();
    const e8 = F4(t5, this.symbols, this._coordinateHelper), i7 = G3(t5, this.symbols, this._coordinateHelper);
    this.curveControlPointGraphics.addMany(e8), this.constructionLineGraphics.addMany(i7), this.layer.addMany(i7), this.layer.addMany(e8);
  }
  _updateSymbolsForTheme() {
    const t5 = this.view.effectiveTheme.accentColor;
    this.symbols = { vertices: { ...this.symbols.vertices, default: this.symbols.vertices.default.clone().set("color", t5), hover: this.symbols.vertices.hover?.clone().set("color", t5) }, controlPoints: { ...this.symbols.controlPoints, default: this.symbols.controlPoints.default.clone().set("color", t5), hover: this.symbols.controlPoints.hover?.clone().set("color", t5) }, midpoints: { ...this.symbols.midpoints }, constructionLines: this.symbols.constructionLines.clone().set("color", t5) };
    for (const e8 of this.vertexGraphics) this._isSelected(e8) ? e8.symbol = this.symbols.vertices.selected : this._hoverGraphic === e8 ? e8.symbol = this.symbols.vertices.hover : e8.symbol = this.symbols.vertices.default;
    for (const e8 of this.curveControlPointGraphics) this._isSelected(e8) ? e8.symbol = this.symbols.controlPoints.selected : this._hoverGraphic === e8 ? e8.symbol = this.symbols.controlPoints.hover : e8.symbol = this.symbols.controlPoints.default;
    for (const e8 of this.constructionLineGraphics) e8.symbol = this.symbols.constructionLines;
  }
  _storeRelatedVertexIndices() {
    const t5 = this.vertexGraphics.items;
    if (!t5) return;
    const e8 = t5.map(({ geometry: t6 }) => ({ x: t6.x, y: t6.y }));
    for (let i7 = 0; i7 < e8.length; i7++) {
      const s4 = [];
      for (let t6 = 0; t6 < e8.length; t6++) {
        if (i7 === t6) continue;
        const o = e8[i7], r3 = e8[t6];
        o.x === r3.x && o.y === r3.y && s4.push(t6);
      }
      t5[i7].attributes[R2.relatedGraphicIndices] = s4;
    }
  }
  _setupMover() {
    const { enableMovement: t5, graphic: e8, midpointGraphics: i7, vertexGraphics: s4, view: o } = this, r3 = s4.concat(i7, this.curveControlPointGraphics).items;
    t5 && "multipoint" !== e8.geometry?.type && r3.push(e8), this._mover = new j3({ enableMoveAllGraphics: false, highlightsEnabled: false, indicatorsEnabled: false, graphics: r3, view: o, callbacks: { onGraphicClick: (t6) => this._onGraphicClickCallback(t6), onGraphicMoveStart: (t6) => this._onGraphicMoveStartCallback(t6), onGraphicMove: (t6) => this._onGraphicMoveCallback(t6), onGraphicMoveStop: (t6) => this._onGraphicMoveStopCallback(t6), onGraphicPointerOver: (t6) => this._onGraphicPointerOverCallback(t6), onGraphicPointerOut: (t6) => this._onGraphicPointerOutCallback(t6) } });
  }
  _setupConnectedReshapeManager() {
    const { connectedReshapeProviders: t5 } = this;
    null != t5 && 0 !== t5.length && (this._connectedReshapeManager = new G2({ providerFactories: t5, view: this.view }));
  }
  _onGraphicClickCallback(t5) {
    t5.viewEvent.stopPropagation();
    const e8 = t5.graphic, i7 = this._isCurveControlPoint(e8);
    if (e8 === this.graphic) this.clearSelection(), this.emit("graphic-click", t5), this.callbacks.onGraphicClick?.(t5);
    else if (this._isMidpoint(e8)) {
      if (2 === t5.viewEvent.button) return;
      const i8 = this.graphic.clone(), s4 = this._handleMidpointClickOrStartMove(t5);
      this.refresh(), s4.length && this._emitVertexAddEvent([e8], i8, s4);
    } else if (this._isVertex(e8) || i7) {
      if (t5.viewEvent.stopPropagation(), 2 === t5.viewEvent.button) return void (i7 || this._removeVertices(e8));
      t5.viewEvent.native.shiftKey || this._clearSelection(), this.selectedManipulators.includes(e8) ? this._removeFromSelection(e8, true) : this._addToSelection(e8);
    }
  }
  _setUpOperation(t5) {
    const { graphic: e8, dx: i7, dy: s4 } = t5, o = e8 === this.graphic;
    this._resetSnappingStateVars(), this._setUpGeometryHelper(), this._saveSnappingContextForHandle(e8, t5), this._activeOperationInfo = { target: this.graphic, mover: e8, operationType: o ? "move" : "reshape", totalDx: i7, totalDy: s4 };
  }
  _onGraphicMoveStartCallback(t5) {
    const { dx: e8, dy: i7, graphic: s4 } = t5, o = this._connectedReshapeManager, r3 = o ? Vt(this.graphic) : null;
    if (s4 === this.graphic) {
      const { geometry: n6 } = s4;
      return this._setUpOperation(t5), this._emitMoveStartEvent(e8, i7), r3 && o?.startFeatureMove([r3]), void (null != n6 && "point" === n6.type && this._onHandleMove(s4, e8, i7, t5, () => {
        this._updateTooltip(this.graphic, t5.viewEvent), this._emitMoveEvent(e8, i7);
      }));
    }
    const { selectedManipulators: n5 } = this;
    if (!n5.includes(s4)) {
      if (this._clearSelection(), this._isMidpoint(s4)) {
        const e9 = this.graphic.clone(), i8 = this._handleMidpointClickOrStartMove(t5);
        i8.length && (this._emitVertexAddEvent([s4], e9, i8), this._refreshGraphicIndicesAttributes(i8[0]));
      }
      this._addToSelection(s4);
    }
    if (this._setUpOperation(t5), r3) {
      const t6 = n5.filter((t7) => this._isVertex(t7));
      o?.startVertexMove(r3, It(t6));
    }
    this._emitReshapeStartEvent(s4), this._onHandleMove(s4, e8, i7, t5, () => {
      this._updateTooltip(s4, t5.viewEvent), this._emitReshapeEvent(s4);
    });
  }
  _onGraphicMoveCallback(t5) {
    const e8 = this._activeOperationInfo;
    if (!e8) return;
    const { dx: i7, dy: s4, graphic: o } = t5;
    e8.totalDx += i7, e8.totalDy += s4;
    const { operationType: r3 } = e8, { geometry: n5 } = o;
    if (null != n5) {
      if ("move" !== r3) this._onHandleMove(o, i7, s4, t5, () => {
        this._updateTooltip(o, t5.viewEvent), this._emitReshapeEvent(o);
      });
      else if ("point" === n5.type) this._onHandleMove(o, i7, s4, t5, () => {
        this._updateTooltip(this.graphic, t5.viewEvent), this._emitMoveEvent(i7, s4);
      });
      else if ("polyline" === n5.type || "polygon" === n5.type) {
        const e9 = gt(n5);
        this._updateVertexGraphicLocations(e9);
        const { dxMap: o2, dyMap: r4 } = h6(i7, s4, this.view);
        this._connectedReshapeManager?.translate(o2, r4, 0), this._updateTooltip(this.graphic, t5.viewEvent), this._emitMoveEvent(i7, s4);
      }
    }
  }
  _onGraphicMoveStopCallback(t5) {
    const e8 = this._activeOperationInfo;
    if (!e8) return;
    const { dx: i7, dy: s4, graphic: o } = t5, { operationType: r3 } = e8;
    e8.totalDx += i7, e8.totalDy += s4, this._onHandleMove(o, i7, s4, t5, () => "move" === r3 ? this._emitMoveStopEvent() : this._emitReshapeStopEvent(o)), this._isMidpoint(o) || o.getAttribute(R2.curveFromStraightEdgeFlag) ? this.refresh() : (this._updateTooltip(this._isVertex(o) ? o : null), this._resetSnappingStateVars(), this._connectedReshapeManager?.finish(), this._activeOperationInfo = null);
  }
  _updateVertexGraphicLocations(t5) {
    const { _coordinateHelper: e8 } = this;
    for (const i7 of this.vertexGraphics) {
      const { pathIndex: s4, pointIndex: o } = i7.attributes;
      i7.geometry = e8.arrayToPoint(f3(t5[s4][o]));
    }
    this._updateMidpointGraphicLocations(t5), this._updateCurveGraphicLocations(t5);
  }
  _updateMidpointGraphicLocations(t5) {
    const { _coordinateHelper: e8 } = this;
    for (const i7 of this.midpointGraphics) {
      const { pathIndex: s4, pointIndexStart: o, pointIndexEnd: r3 } = i7.attributes, n5 = t5[s4];
      i7.geometry = M2(n5[o], n5[r3], e8);
    }
  }
  _updateCurveGraphicLocations(t5) {
    const { spatialReference: e8 } = this._coordinateHelper, i7 = /* @__PURE__ */ new Map();
    for (const s4 of this.selectedManipulators) {
      const [t6, e9] = Et(s4);
      null != t6 && null != e9 && s4.getAttribute(R2.controlPointKind) && e(i7, t6, () => /* @__PURE__ */ new Set())?.add(e9);
    }
    for (const s4 of this.curveControlPointGraphics) {
      const [e9, o] = Et(s4);
      if (i7.get(e9)?.has(o)) continue;
      const r3 = t5[e9][o];
      if (u3(r3) || c(r3)) {
        const i8 = f3(t5[e9][o - 1]), n5 = u3(r3) ? l3(i8, r3) : h4(i8, r3), [a4, h9] = h3(n5, 0.25);
        s4.geometry = new _({ x: a4, y: h9, spatialReference: this._coordinateHelper.spatialReference });
      } else if (t3(r3)) {
        const t6 = s4.getAttribute(R2.controlPointKind), [e10, i8] = t6 === U3.bezier.cp1 ? r3.b[1] : r3.b[2];
        s4.geometry = new _({ x: e10, y: i8, spatialReference: this._coordinateHelper.spatialReference });
      }
    }
    for (const s4 of this.constructionLineGraphics) {
      const i8 = s4.getAttribute(R2.controlPointKind), [o, r3] = Et(s4), n5 = t5[o], a4 = f3(n5[r3 - 1]), h9 = f3(n5[r3]), p5 = t5[o][r3];
      i8 === U3.bezier.line1 ? s4.geometry = new y2({ paths: [[[a4[0], a4[1]], [...p5.b[1]]]], spatialReference: e8 }) : s4.geometry = new y2({ paths: [[[h9[0], h9[1]], [...p5.b[2]]]], spatialReference: e8 });
    }
  }
  _refreshGraphicIndicesAttributes(t5) {
    const { componentIndex: e8, vertexIndex: i7 } = t5, s4 = (t6) => {
      const [s5, o] = Et(t6);
      s5 === e8 && o >= i7 && t6.setAttribute(R2.pointIndex, o + 1);
    };
    this.vertexGraphics.forEach(s4), this.curveControlPointGraphics.forEach(s4), this.constructionLineGraphics.forEach(s4);
    for (const o of this.midpointGraphics) {
      if (o.getAttribute(R2.pathIndex) !== e8) continue;
      const t6 = o.getAttribute(R2.pointIndexStart);
      t6 >= i7 && (o.setAttribute(R2.pointIndexStart, t6 + 1), o.setAttribute(R2.pointIndexEnd, o.getAttribute(R2.pointIndexEnd) + 1));
    }
  }
  _getVertexFromEditGeometry(t5) {
    const [e8, i7] = Et(t5);
    return n(this._editGeometryOperations), this._editGeometryOperations.data.parts[e8].vertices[i7];
  }
  _onHandleMove(t5, e8, s4, o, r3) {
    e3(this._snappingTask);
    const n5 = this._snappingContext;
    if (!n5) return;
    const a4 = t5.geometry, h9 = "graphic-move-stop" === o.type;
    if (a4 && s3(a4)) if (null != this.snappingManager && this.selectedManipulators.length < 2 && !h9) {
      const o2 = this.snappingManager;
      this._stagedVertex = o2.update({ point: a4, context: n5 }), this._syncGeometryAfterVertexMove(t5, new _(this._stagedVertex), e8, s4, h9), r3(), this._snappingTask = d(async (i7) => {
        const p5 = await o2.snap({ point: a4, context: n5, signal: i7 });
        p5.valid && (this._stagedVertex = p5.apply(), this._syncGeometryAfterVertexMove(t5, new _(this._stagedVertex), e8, s4, h9), r3());
      });
    } else {
      const i7 = null != this._stagedVertex ? new _(this._stagedVertex) : a4;
      this._syncGeometryAfterVertexMove(t5, i7, e8, s4, h9), r3();
    }
    else r3();
  }
  _syncGeometryAfterVertexMove(t5, e8, i7, s4, o = false) {
    const r3 = this._editGeometryOperations?.data.geometry;
    if (!r3) return;
    const { _coordinateHelper: n5 } = this, a4 = n5.pointToVector(e8), h9 = this._getVertexFromEditGeometry(t5);
    if (h9) {
      const t6 = n5.getZ(a4), e9 = a4[0] - h9.pos[0], i8 = a4[1] - h9.pos[1], s5 = null != t6 ? t6 - h9.pos[2] : 0;
      "point" !== r3.type && "mesh" !== r3.type || this._editGeometryOperations?.moveVertices([h9], e9, i8, s5), this._connectedReshapeManager?.translate(e9, i8, s5);
    }
    if ("point" === r3.type) t5.geometry = e8;
    else if ("mesh" === r3.type) t5.geometry = r3.centerAt(e8);
    else {
      if (t5 !== this.graphic) {
        const o2 = n5.spatialReference, [a5, h10] = Et(t5);
        let p5 = ft(r3);
        const c3 = n5.pointToArray(e8);
        this._updateGeometryFromGraphic(t5, p5, a5, h10, c3, o2, "polygon" === r3.type), this._isVertex(t5) || this._isCurveControlPoint(t5) ? (p5 = this._moveRelatedCoordinates(p5, t5, c3), p5 = this._moveSelectedHandleCoordinates(p5, t5, i7, s4, "polygon" === r3.type), this._updateMidpointGraphicLocations(p5), this._updateCurveGraphicLocations(p5)) : this._isMidpoint(t5) && this._updateCurveGraphicLocations(p5), V(r3, p5);
      }
      this._updateGraphicGeometry(r3.clone()), this._editGeometryOperations = g.fromGeometry(r3, 2, { allowCurves: true }), o && (this._mover ? this._mover.updateGeometry(this._mover.graphics.indexOf(t5), e8) : t5.geometry = e8);
    }
  }
  _moveRelatedCoordinates(t5, e8, i7) {
    const { relatedGraphicIndices: s4 } = e8.attributes, o = this._coordinateHelper.spatialReference;
    if (!s4?.length) return t5;
    for (const r3 of s4) {
      const s5 = this.vertexGraphics.at(r3), [n5, a4] = Et(s5);
      St(t5, n5, a4, i7, o), s5.geometry = e8.geometry;
    }
    return t5;
  }
  _moveSelectedHandleCoordinates(t5, e8, i7, s4, o) {
    const r3 = this._coordinateHelper.spatialReference;
    for (const n5 of this.selectedManipulators) if (n5 !== e8) {
      const [e9, a4] = Et(n5), h9 = n5.getAttribute(R2.relatedGraphicIndices), p5 = x3(n5.geometry, i7, s4, this.view), c3 = r(p5);
      if (n5.geometry = p5, this._updateGeometryFromGraphic(n5, t5, e9, a4, c3, r3, o), h9?.length) for (const i8 of h9) {
        const e10 = this.vertexGraphics.at(i8), [s5, o2] = Et(e10);
        St(t5, s5, o2, c3, r3), e10.geometry = p5;
      }
    }
    return t5;
  }
  _updateGeometryFromGraphic(t5, e8, i7, s4, o, r3, n5) {
    const a4 = e8[i7].length - 1;
    this._isCurveControlPoint(t5) ? xt(e8, i7, s4, [o[0], o[1]], t5.getAttribute(R2.controlPointKind)) : (St(e8, i7, s4, o, r3), n5 && (0 === s4 ? St(e8, i7, a4, o, r3) : s4 === a4 && (e8[i7][0] = o)));
  }
  _onGraphicPointerOverCallback(t5) {
    const e8 = t5.graphic;
    this._hoverGraphic = e8;
    const i7 = this._isVertex(e8);
    i7 && !this._isSelected(e8) ? e8.symbol = this.symbols.vertices.hover : this._isCurveControlPoint(e8) && !this._isSelected(e8) && (e8.symbol = this.symbols.controlPoints.hover), this._updateTooltip(i7 ? e8 : null), this._updateHoverCursor(e8);
  }
  _onGraphicPointerOutCallback(t5) {
    const e8 = t5.graphic;
    this._hoverGraphic = null, this._isVertex(e8) && !this._isSelected(e8) && (e8.symbol = this.symbols.vertices.default), this._isCurveControlPoint(e8) && !this._isSelected(e8) && (e8.symbol = this.symbols.controlPoints.default), this.removeHandles(yt), this._updateTooltip();
  }
  _handleMidpointClickOrStartMove(t5) {
    const { graphic: e8 } = t5, i7 = this.graphic.geometry;
    if (null == i7 || "polygon" !== i7.type && "polyline" !== i7.type) return [];
    const s4 = i7.clone(), o = [], { [R2.pathIndex]: r3, [R2.pointIndexStart]: n5, [R2.pointIndexEnd]: a4 } = e8.attributes, h9 = r(e8.geometry), p5 = 0 === a4 ? n5 + 1 : a4;
    e8.attributes = { [R2.tool]: k2, [R2.pathIndex]: r3, [R2.pointIndex]: p5, [R2.relatedGraphicIndices]: [] };
    const c3 = ft(s4), l7 = c3[r3][a4];
    if (i3(l7)) {
      if (this.enableCurveOnMidpoint && t5.viewEvent.native.shiftKey) {
        const t6 = f3(c3[r3][p5]);
        c3[r3].splice(p5, 1, { c: [t6, [h9[0], h9[1]]] }), e8.setAttribute(R2.controlPointKind, U3.circle.interior), e8.setAttribute(R2.curveFromStraightEdgeFlag, true), this.midpointGraphics.remove(e8), this.curveControlPointGraphics.push(e8), V(s4, c3);
      } else c3[r3].splice(p5, 0, h9), o.push({ coordinates: c3[r3][p5], componentIndex: r3, vertexIndex: p5 });
    } else {
      const t6 = f3(c3[r3][n5]), e9 = X(t6, l7, 0.5, this._coordinateHelper);
      c3[r3].splice(a4, 1, ...e9), o.push({ coordinates: f3(c3[r3][p5]), componentIndex: r3, vertexIndex: p5 });
    }
    return this._updateGraphicGeometry(s4), o;
  }
  _addToSelection(t5) {
    const e8 = Ot(t5);
    for (const i7 of e8) this._isCurveControlPoint(i7) ? i7.symbol = this.symbols.controlPoints.selected : i7.symbol = this.symbols.vertices.selected, this.selectedManipulators.add(i7), this._updateTooltip(i7);
    this._emitSelectEvent(e8);
  }
  _removeFromSelection(t5, e8) {
    if (this._isVertex(t5)) {
      const { vertices: i7 } = this.symbols;
      t5.symbol = e8 ? i7.hover : i7.default;
    } else if (this._isCurveControlPoint(t5)) {
      const { controlPoints: i7 } = this.symbols;
      t5.symbol = e8 ? i7.hover : i7.default;
    }
    this.selectedManipulators.remove(t5), this._emitDeselectEvent([t5]), this._updateTooltip();
  }
  _clearSelection() {
    const t5 = this.selectedManipulators.toArray(), { controlPoints: e8, vertices: i7 } = this.symbols;
    if (t5.length > 0) {
      for (const s4 of t5) this._isVertex(s4) ? s4.symbol = i7.default : this._isCurveControlPoint(s4) && (s4.symbol = e8.default);
      this.selectedManipulators.removeAll(), this._emitDeselectEvent(t5), this._updateTooltip();
    }
  }
  _keyDownHandler(t5) {
    null == this._activeOperationInfo && H(t5, this.tooltip) || c2.delete.includes(t5.key) && !t5.repeat && this.selectedManipulators.length && this._removeVertices(this.selectedManipulators);
  }
  _removeVertices(t5) {
    const e8 = this.graphic.geometry, i7 = this.vertexGraphics.length;
    if (null == e8 || "polygon" !== e8.type && "polyline" !== e8.type && "multipoint" !== e8.type) return;
    if ("polygon" === e8.type && i7 < 4 || "multipoint" === e8.type && i7 < 2 || "polyline" === e8.type && i7 < 3) return;
    const s4 = this.graphic.clone(), o = e8.clone();
    let r3 = ft(o);
    const n5 = [], a4 = Ot(t5);
    for (const h9 of a4) {
      if (this._isCurveControlPoint(h9)) continue;
      const { x: t6, y: e9 } = h9.geometry;
      for (let i8 = 0; i8 < r3.length; i8++) {
        const s5 = r3[i8];
        for (let o2 = 0; o2 < s5.length; o2++) {
          const [a5, h10] = f3(s5[o2]);
          if (t6 === a5 && e9 === h10) {
            n5.push({ coordinates: f3(r3[i8][o2]), componentIndex: i8, vertexIndex: o2 }), r3[i8].splice(Number(o2), 1);
            const t7 = r3[i8][o2];
            t7 && !i3(t7) && (r3[i8][o2] = f3(t7));
          }
        }
      }
    }
    if ("polygon" === o.type) r3 = r3.filter((t6) => {
      if (t6.length < 2) return false;
      const [e9, i8] = f3(t6[0]), [s5, o2] = f3(t6[t6.length - 1]);
      return (2 !== t6.length || e9 !== s5 || i8 !== o2) && (e9 === s5 && i8 === o2 || t6.push(t6[0]), true);
    });
    else if ("polyline" === o.type) for (const h9 of r3) 1 === h9.length && r3.splice(r3.indexOf(h9), 1);
    V(o, r3), this._updateGraphicGeometry(o), this.refresh(), this._emitVertexRemoveEvent(a4, s4, n5);
  }
  _isVertex(t5) {
    return this.vertexGraphics.includes(t5);
  }
  _isCurveControlPoint(t5) {
    return this.curveControlPointGraphics.includes(t5);
  }
  _isConstructionLine(t5) {
    return this.constructionLineGraphics.includes(t5);
  }
  _isSelected(t5) {
    return (this._isVertex(t5) || this.curveControlPointGraphics.includes(t5)) && this.selectedManipulators.includes(t5);
  }
  _isMidpoint(t5) {
    return this.midpointGraphics.includes(t5);
  }
  _updateHoverCursor(t5) {
    const e8 = this._isMidpoint(t5) ? "copy" : "move";
    this.addHandles(this.view.acquireCursor(e8, "high"), yt);
  }
  _updateTooltip(t5, e8) {
    let i7 = null;
    const { graphic: s4, view: o, tooltipInfos: r3 } = this, n5 = s4?.geometry;
    "point" === n5?.type ? i7 = r3.movePoint : this._selectedManipulator ? i7 = r3.selectedVertex : t5 === this.graphic ? (i7 = r3.translateGraphic, U2(i7, o, this._tooltipsContext, e8)) : t5 && this.selectedManipulators.length > 1 && (i7 = r3.translateVertices, k(i7, o, n5, this._tooltipsContext, e8)), this.activeTooltipInfo = i7;
  }
  _updateGraphicGeometry(t5) {
    this._updateHandlesOnExternalGeometryChange?.pause(), this.graphic.geometry = t5, this._updateHandlesOnExternalGeometryChange?.resume();
  }
  _emitMoveStartEvent(t5, e8) {
    const i7 = { type: "move-start", mover: this.graphic, dx: t5, dy: e8 };
    this.emit("move-start", i7), this.callbacks.onMoveStart?.(i7);
  }
  _emitMoveEvent(t5, e8) {
    const i7 = { type: "move", mover: this.graphic, dx: t5, dy: e8 };
    this.emit("move", i7), this.callbacks.onMove?.(i7);
  }
  _emitMoveStopEvent(t5, e8) {
    if (null == t5 || null == e8) {
      const i8 = this._activeOperationInfo;
      if (!i8) return;
      t5 = i8.totalDx, e8 = i8.totalDy;
    }
    const i7 = { type: "move-stop", mover: this.graphic, dx: t5, dy: e8 };
    this.emit("move-stop", i7), this.callbacks.onMoveStop?.(i7);
  }
  _emitReshapeStartEvent(t5) {
    const e8 = { type: "reshape-start", graphic: this.graphic, mover: t5, selected: this.selectedManipulators.toArray() };
    this.emit("reshape-start", e8), this.callbacks.onReshapeStart?.(e8);
  }
  _emitReshapeEvent(t5) {
    const e8 = { type: "reshape", graphic: this.graphic, mover: t5, selected: this.selectedManipulators.toArray() };
    this.emit("reshape", e8), this.callbacks.onReshape?.(e8);
  }
  _emitReshapeStopEvent(t5) {
    const e8 = { type: "reshape-stop", graphic: this.graphic, mover: t5, selected: this.selectedManipulators.toArray() };
    this.emit("reshape-stop", e8), this.callbacks.onReshapeStop?.(e8);
  }
  _emitSelectEvent(t5) {
    const e8 = { type: "vertex-select", added: t5 };
    this.emit("select", e8), this.callbacks.onVertexSelect?.(e8);
  }
  _emitDeselectEvent(t5) {
    const e8 = { type: "vertex-deselect", removed: t5 };
    this.emit("deselect", e8), this.callbacks.onVertexDeselect?.(e8);
  }
  _emitVertexAddEvent(t5, e8, i7) {
    const s4 = { type: "vertex-add", added: t5, graphic: this.graphic, oldGraphic: e8, vertices: i7 };
    this.emit("vertex-add", s4), this.callbacks.onVertexAdd?.(s4);
  }
  _emitVertexRemoveEvent(t5, e8, i7) {
    const s4 = { type: "vertex-remove", removed: t5, graphic: this.graphic, oldGraphic: e8, vertices: i7 };
    this.emit("vertex-remove", s4), this.callbacks.onVertexRemove?.(s4);
  }
  _logGeometryTypeError() {
    i.getLogger(this).error(new s("reshape:invalid-geometry", "Reshape operation not supported for the provided graphic. The geometry type is not supported."));
  }
};
function gt(t5) {
  const e8 = ft(t5.clone());
  if ("polygon" === t5.type) for (const i7 of e8) {
    const t6 = i7[i7.length - 1];
    if (!i3(t6)) continue;
    const e9 = i7[0];
    e9[0] === t6[0] && e9[1] === t6[1] && i7.length > 2 && i7.pop();
  }
  return e8;
}
function ft(t5) {
  return "polygon" === t5.type ? t5.curveRings?.slice() ?? t5.rings.slice() : "polyline" === t5.type ? t5.curvePaths?.slice() ?? t5.paths.slice() : t5.points.map((t6) => [t6]);
}
function Gt(t5, e8, i7, s4) {
  const o = t5[e8][i7];
  if (u3(o)) o.c[1] = s4;
  else if (c(o)) {
    const o2 = f3(t5[e8][i7]);
    t5[e8][i7] = { c: [o2, s4] };
  }
}
function xt(t5, e8, i7, s4, o) {
  switch (o) {
    case U3.circle.interior:
      Gt(t5, e8, i7, s4);
      break;
    case U3.bezier.cp1:
      t5[e8][i7].b[1] = s4;
      break;
    case U3.bezier.cp2:
      t5[e8][i7].b[2] = s4;
  }
}
function Mt(t5, e8) {
  return t5 < 1e-8 * e8;
}
function bt(t5, { cx: e8, cy: i7, isInvalid: s4, thetaStart: o, thetaEnd: r3 }, n5, a4) {
  const [h9, p5] = t5, [c3, l7] = n5, d5 = c3 - h9, m4 = l7 - p5;
  e8 -= h9, i7 -= p5;
  const v2 = a4 ? o > r3 : o < r3, [u6, y4] = s4 ? [e8, i7] : v2 ? [-i7, e8] : [i7, -e8], [_4, g3] = [d5, m4], [f7, G4] = [u6, y4], x5 = _4 * G4 - g3 * f7, M3 = (d5 ** 2 + m4 ** 2) / 2;
  if (Mt(Math.abs(x5), M3)) return [(h9 + c3) / 2, (p5 + l7) / 2];
  const [b3, C2] = [G4 / x5 * M3, -f7 / x5 * M3], S = b3 ** 2 + C2 ** 2, [E2, w5] = [d5 / 2 - b3, m4 / 2 - C2];
  if (Mt(E2 ** 2 + w5 ** 2, S)) {
    const [t6, e9] = v2 ? [-C2, b3] : [C2, -b3];
    return [t6 + b3 + h9, e9 + C2 + p5];
  }
  const O3 = Math.sqrt((b3 ** 2 + C2 ** 2) / (E2 ** 2 + w5 ** 2)) * Math.sign(d5 * u6 + m4 * y4);
  return [E2 * O3 + b3 + h9, w5 * O3 + C2 + p5];
}
function Ct(t5, e8, i7) {
  const s4 = x2(new y2({ curvePaths: [[t5, e8]], spatialReference: i7 })), { curvePaths: o } = j2(s4, i7), r3 = o[0][1];
  return a2(r3) ? r3 : f2(t5, r3);
}
function St(t5, e8, i7, s4, o) {
  const r3 = t5[e8][i7], n5 = t5[e8].at(i7 + 1);
  if (Z(t5, e8)) {
    const i8 = t5[e8][1];
    return t5[e8][0] = [...s4], void (t5[e8][1] = { a: [[...s4], [...i8.a[1]], 0, 0] });
  }
  if (A(t5, e8)) {
    const i8 = t5[e8][1], [o2, r4] = i8.a[1], [n6, a5] = s4, h9 = Math.hypot(n6 - o2, a5 - r4), [p5, c3] = [n6 - o2, a5 - r4], l7 = e4(c3, p5);
    return t5[e8][0] = [...s4], void (t5[e8][1] = { a: [[...s4], [...i8.a[1]], 0, 0, l7, h9, i8.a[6]] });
  }
  const a4 = f3(r3);
  if (i3(r3)) r3.splice(0, r3.length, ...s4);
  else if (t3(r3)) r3.b[0].splice(0, r3.b[0].length, ...s4);
  else if (u3(r3) || c(r3)) {
    const o2 = f3(t5[e8][i7 - 1]), n6 = u3(r3) ? l3(o2, r3) : h4(o2, r3);
    t5[e8].splice(i7, 1, { c: [[...s4], bt(o2, n6, s4, true)] });
  } else if (a2(r3)) {
    r3.a[0].splice(0, r3.a[0].length, ...s4);
    const n6 = f3(t5[e8][i7 - 1]);
    r3.a = Ct(n6, r3, o).a;
  }
  if (n5 && !i3(n5) && !t3(r3)) {
    if (u3(n5) || c(n5)) {
      const o2 = f3(n5), r4 = u3(n5) ? l3(a4, n5) : h4(a4, n5);
      t5[e8].splice(i7 + 1, 1, { c: [o2, bt(o2, r4, s4, false)] });
    } else if (a2(n5)) {
      const t6 = f3(r3);
      n5.a = Ct(t6, n5, o).a;
    }
  }
}
function Et({ attributes: t5 }) {
  return [t5?.[R2.pathIndex] || 0, t5?.[R2.pointIndex] || 0];
}
function wt({ attributes: t5 }) {
  return `${t5?.[R2.pathIndex]}-${t5?.[R2.pointIndex]}`;
}
function Ot(t5) {
  return t5 instanceof _2 ? [t5] : [...t5];
}
function Vt(t5) {
  const e8 = t5.sourceLayer ?? t5.layer;
  return a3(e8) ? { graphic: t5, layer: e8 } : null;
}
function It(t5) {
  return t5.toArray().map(({ attributes: t6 }) => ({ pathIndex: t6[R2.pathIndex], vertexIndex: t6[R2.pointIndex] }));
}
__decorate([m()], _t.prototype, "_activeOperationInfo", void 0), __decorate([m()], _t.prototype, "_connectedReshapeManager", void 0), __decorate([m()], _t.prototype, "_coordinateHelper", null), __decorate([m()], _t.prototype, "_editGeometryOperations", void 0), __decorate([m()], _t.prototype, "tooltip", void 0), __decorate([m()], _t.prototype, "tooltipInfos", void 0), __decorate([m()], _t.prototype, "activeTooltipInfo", void 0), __decorate([m({ constructOnly: true })], _t.prototype, "automaticAreaMeasurementUtils", void 0), __decorate([m({ constructOnly: true })], _t.prototype, "automaticLengthMeasurementUtils", void 0), __decorate([m()], _t.prototype, "_selectedManipulator", null), __decorate([m()], _t.prototype, "_tooltipsContext", null), __decorate([m()], _t.prototype, "callbacks", void 0), __decorate([m()], _t.prototype, "connectedReshapeProviders", void 0), __decorate([m()], _t.prototype, "enableMidpoints", void 0), __decorate([m()], _t.prototype, "enableCurveOnMidpoint", void 0), __decorate([m()], _t.prototype, "enableMovement", void 0), __decorate([m()], _t.prototype, "enableVertices", void 0), __decorate([m()], _t.prototype, "graphic", void 0), __decorate([m()], _t.prototype, "highlightName", void 0), __decorate([m()], _t.prototype, "highlightsEnabled", void 0), __decorate([m()], _t.prototype, "layer", void 0), __decorate([m()], _t.prototype, "snappingManager", void 0), __decorate([m({ readOnly: true })], _t.prototype, "state", null), __decorate([m()], _t.prototype, "symbols", void 0), __decorate([m({ type: l5 })], _t.prototype, "sketchOptions", void 0), __decorate([m({ readOnly: true })], _t.prototype, "type", void 0), __decorate([m({ readOnly: true })], _t.prototype, "vertexGraphics", void 0), __decorate([m({ readOnly: true })], _t.prototype, "curveControlPointGraphics", void 0), __decorate([m({ readOnly: true })], _t.prototype, "constructionLineGraphics", void 0), __decorate([m({ readOnly: true })], _t.prototype, "midpointGraphics", void 0), __decorate([m({ readOnly: true })], _t.prototype, "selectedManipulators", void 0), __decorate([m()], _t.prototype, "view", void 0), _t = __decorate([a("esri.views.draw.support.Reshape")], _t);
var Pt = _t;
export {
  Pt as default
};
//# sourceMappingURL=Reshape-VWS3KVJE.js.map
