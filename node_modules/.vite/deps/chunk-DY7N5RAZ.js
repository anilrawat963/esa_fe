import {
  u
} from "./chunk-CCQFL76O.js";
import {
  r as r2
} from "./chunk-7H3U4IJR.js";
import {
  o
} from "./chunk-XWE6BM2U.js";
import {
  r
} from "./chunk-SOIZOFSB.js";
import {
  n
} from "./chunk-XXLHAM2M.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2,
  x
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  a
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/rest/support/ColorRamp.js
var e = class extends n {
  constructor(r3) {
    super(r3), this.type = null;
  }
};
__decorate([m({ readOnly: true, json: { read: false, write: true } })], e.prototype, "type", void 0), e = __decorate([a2("esri.rest.support.ColorRamp")], e);

// node_modules/@arcgis/core/rest/support/AlgorithmicColorRamp.js
var m2;
var a3 = m2 = class extends e {
  constructor(o2) {
    super(o2), this.algorithm = null, this.fromColor = null, this.toColor = null, this.type = "algorithmic";
  }
  clone() {
    return new m2({ fromColor: a(this.fromColor), toColor: a(this.toColor), algorithm: this.algorithm });
  }
};
__decorate([r2({ esriCIELabAlgorithm: "cie-lab", esriHSVAlgorithm: "hsv", esriLabLChAlgorithm: "lab-lch" })], a3.prototype, "algorithm", void 0), __decorate([m({ type: u, json: { type: [x], write: { isRequired: true } } })], a3.prototype, "fromColor", void 0), __decorate([m({ type: u, json: { type: [x], write: { isRequired: true } } })], a3.prototype, "toColor", void 0), __decorate([m({ type: ["algorithmic"], json: { write: { isRequired: true } } })], a3.prototype, "type", void 0), a3 = m2 = __decorate([a2("esri.rest.support.AlgorithmicColorRamp")], a3);

// node_modules/@arcgis/core/rest/support/MultipartColorRamp.js
var c;
var l = c = class extends e {
  constructor(o2) {
    super(o2), this.colorRamps = null, this.type = "multipart", this.weights = void 0;
  }
  writeColorRamps(o2, r3, t, s) {
    const e2 = o2?.map((o3) => o3.toJSON(s)), { weights: p2 } = this;
    if (e2 && p2?.length && e2.length === p2?.length) {
      const o3 = 100 / p2.reduce((o4, r5) => o4 + r5);
      let r4 = 0;
      e2.forEach((t2, s2) => {
        t2.start = r4, r4 += p2[s2] * o3, t2.stop = r4;
      });
    }
    r3.colorRamps = e2;
  }
  readWeights(o2, r3) {
    const t = r3.colorRamps?.map(({ start: o3, stop: r4 }) => null == o3 || null == r4 ? -1 : r4 - o3);
    if (!t?.some((o3) => o3 < 0)) return t;
  }
  clone() {
    return new c({ colorRamps: a(this.colorRamps) });
  }
};
__decorate([m({ type: [a3], json: { write: { isRequired: true } } })], l.prototype, "colorRamps", void 0), __decorate([r("colorRamps")], l.prototype, "writeColorRamps", null), __decorate([m({ type: ["multipart"], json: { write: { isRequired: true } } })], l.prototype, "type", void 0), __decorate([m({ type: [Number] })], l.prototype, "weights", void 0), __decorate([o("weights", ["colorRamps"])], l.prototype, "readWeights", null), l = c = __decorate([a2("esri.rest.support.MultipartColorRamp")], l);

// node_modules/@arcgis/core/rest/support/colorRamps.js
var m3 = { key: "type", base: e, typeMap: { algorithmic: a3, multipart: l } };
function p(o2) {
  return o2?.type ? "algorithmic" === o2.type ? a3.fromJSON(o2) : "multipart" === o2.type ? l.fromJSON(o2) : null : null;
}

export {
  l,
  m3 as m,
  p
};
//# sourceMappingURL=chunk-DY7N5RAZ.js.map
