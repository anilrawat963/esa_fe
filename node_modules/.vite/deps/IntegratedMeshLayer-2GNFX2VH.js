import {
  n
} from "./chunk-D2MXQDQ2.js";
import {
  a as a3,
  m as m3,
  p as p2,
  y
} from "./chunk-7XHCDINS.js";
import {
  _
} from "./chunk-K5O7EA6J.js";
import {
  R,
  j as j2,
  w
} from "./chunk-GD72EK2J.js";
import "./chunk-NFPLS75J.js";
import "./chunk-WVAXXVEK.js";
import "./chunk-NJSGYS3K.js";
import "./chunk-A7O5R67Z.js";
import {
  o as o2
} from "./chunk-SL3GC7WV.js";
import {
  l as l3
} from "./chunk-CJZPTLIZ.js";
import {
  s as s2
} from "./chunk-ZETARPSI.js";
import {
  b2 as b,
  m as m2
} from "./chunk-CZOYDK6P.js";
import {
  j
} from "./chunk-6TCXGIIN.js";
import {
  l
} from "./chunk-NP2TBOXH.js";
import "./chunk-HROH5C5D.js";
import "./chunk-H34D76ZQ.js";
import "./chunk-CBCHZD3F.js";
import "./chunk-ET5EDAFM.js";
import {
  t as t2
} from "./chunk-W5S3VUFT.js";
import "./chunk-7YH7T6CS.js";
import "./chunk-3T4IXPP4.js";
import "./chunk-XTZAIV4X.js";
import "./chunk-63LDVRFI.js";
import "./chunk-MC6NAKKX.js";
import "./chunk-TF6255HN.js";
import "./chunk-C5OQVQZF.js";
import {
  j as j3
} from "./chunk-U3X2LY5C.js";
import "./chunk-JRCD3NNE.js";
import "./chunk-NPYFNHY2.js";
import "./chunk-JW6DU3OK.js";
import {
  t
} from "./chunk-CNYNCKEV.js";
import "./chunk-XL5QPCXN.js";
import "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-W75DBJD7.js";
import "./chunk-QF7FRVN6.js";
import {
  b as b2
} from "./chunk-P6IKJIMO.js";
import "./chunk-MHV23XAQ.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-W6J7XCPU.js";
import "./chunk-ONXWBTTM.js";
import {
  l as l2
} from "./chunk-T7F6Q6JJ.js";
import "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-7P2ANHQ3.js";
import "./chunk-XCKT47LJ.js";
import "./chunk-3FUHCAX3.js";
import "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import {
  U,
  a as a2
} from "./chunk-2OFHDVO5.js";
import "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-5UPBUJPC.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-7H3U4IJR.js";
import "./chunk-SMWUT52Z.js";
import "./chunk-AXZMNHTN.js";
import "./chunk-5T3MJDSR.js";
import "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import {
  p
} from "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import {
  o
} from "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import {
  f2 as f
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/layers/IntegratedMeshLayer.js
var A = class extends _(l3(b(j(t2(l(s2(o2(l2(b2))))))))) {
  constructor(...e) {
    super(...e), this.geometryType = "mesh", this.operationalLayerType = "IntegratedMeshLayer", this.type = "integrated-mesh", this.nodePages = null, this.materialDefinitions = null, this.textureSetDefinitions = null, this.geometryDefinitions = null, this.serviceUpdateTimeStamp = null, this.profile = "mesh-pyramids", this.modifications = null, this.path = null, this.definitionExpression = null, this._canReplaceTerrain = false;
  }
  initialize() {
    this.addHandles(a2(() => this.modifications, "after-changes", () => this.modifications = this.modifications, U));
  }
  normalizeCtorArgs(e, t3) {
    return "string" == typeof e ? { url: e, ...t3 } : e;
  }
  readModifications(e, t3, r) {
    this._modificationsSource = { url: p(e, r), context: r };
  }
  set elevationInfo(e) {
    null != e && "absolute-height" !== e.mode || this._set("elevationInfo", e), this._validateElevationInfo(e);
  }
  async load(e) {
    return this.addResolvingPromise(this._doLoad(e)), this;
  }
  async _doLoad(e) {
    const t3 = e?.signal;
    try {
      await this.loadFromPortal({ supportedTypes: ["Scene Service"] }, e);
    } catch (r) {
      f(r);
    }
    if (await this._fetchService(t3), null != this._modificationsSource) {
      const t4 = await n.fromUrl(this._modificationsSource.url, this.spatialReference, e);
      this.setAtOrigin("modifications", t4, this._modificationsSource.context.origin), this._modificationsSource = null;
    }
    await this._fetchIndexAndUpdateExtent(this.nodePages, t3);
  }
  beforeSave() {
    if (null != this._modificationsSource) return this.load().then(() => {
    }, () => {
    });
  }
  async saveAs(e, t3) {
    return this._debouncedSaveOperations(1, { ...t3, getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "integrated-mesh" }, e);
  }
  async save() {
    const e = { getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "integrated-mesh" };
    return this._debouncedSaveOperations(0, e);
  }
  validateLayer(e) {
    if (e.layerType && "IntegratedMesh" !== e.layerType) throw new s("integrated-mesh-layer:layer-type-not-supported", "IntegratedMeshLayer does not support this layer type", { layerType: e.layerType });
    if (isNaN(this.version.major) || isNaN(this.version.minor)) throw new s("layer:service-version-not-supported", "Service version is not supported.", { serviceVersion: this.version.versionString, supportedVersions: "1.x" });
    if (this.version.major > 1) throw new s("layer:service-version-too-new", "Service version is too new.", { serviceVersion: this.version.versionString, supportedVersions: "1.x" });
  }
  _getTypeKeywords() {
    return ["IntegratedMeshLayer"];
  }
  _validateElevationInfo(e) {
    const t3 = "Integrated mesh layers";
    j2(i.getLogger(this), w(t3, "absolute-height", e)), j2(i.getLogger(this), R(t3, e));
  }
  get replacesTerrain() {
    return this._canReplaceTerrain && this._isUsedAsGroundLayer;
  }
  get _isUsedAsGroundLayer() {
    return t(this.parent);
  }
};
__decorate([m({ type: String, readOnly: true })], A.prototype, "geometryType", void 0), __decorate([m({ type: ["show", "hide"] })], A.prototype, "listMode", void 0), __decorate([m({ type: ["IntegratedMeshLayer"] })], A.prototype, "operationalLayerType", void 0), __decorate([m({ json: { read: false }, readOnly: true })], A.prototype, "type", void 0), __decorate([m({ type: p2, readOnly: true, clonable: false })], A.prototype, "nodePages", void 0), __decorate([m({ type: [a3], readOnly: true, clonable: false })], A.prototype, "materialDefinitions", void 0), __decorate([m({ type: [y], readOnly: true, clonable: false })], A.prototype, "textureSetDefinitions", void 0), __decorate([m({ type: [m3], readOnly: true, clonable: false })], A.prototype, "geometryDefinitions", void 0), __decorate([m({ readOnly: true })], A.prototype, "serviceUpdateTimeStamp", void 0), __decorate([m({ type: n, clonable: (e) => e?.clone() ?? e }), j3({ origins: ["web-scene", "portal-item"], type: "resource", prefix: "modifications" })], A.prototype, "modifications", void 0), __decorate([o(["web-scene", "portal-item"], "modifications")], A.prototype, "readModifications", null), __decorate([m(m2)], A.prototype, "elevationInfo", null), __decorate([m({ type: String, json: { origins: { "web-scene": { read: true, write: true }, "portal-item": { read: true, write: true } }, read: false } })], A.prototype, "path", void 0), __decorate([m()], A.prototype, "replacesTerrain", null), __decorate([m()], A.prototype, "_isUsedAsGroundLayer", null), __decorate([m()], A.prototype, "_canReplaceTerrain", void 0), A = __decorate([a("esri.layers.IntegratedMeshLayer")], A);
var P = A;
export {
  P as default
};
//# sourceMappingURL=IntegratedMeshLayer-2GNFX2VH.js.map
