import {
  e as e2
} from "./chunk-D7KJNSAT.js";
import {
  t
} from "./chunk-CFXCM2NO.js";
import {
  E,
  c,
  o,
  u
} from "./chunk-VYMBX5H5.js";
import {
  e
} from "./chunk-K2OZ6WVC.js";
import {
  i
} from "./chunk-XLOINTMG.js";
import {
  a,
  n
} from "./chunk-75XOUSSS.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js
function p(e4, s) {
  B(e4, s, new e2("slicePlaneOrigin", (e5, i2) => h(s, e5, i2)), new e2("slicePlaneBasis1", (e5, i2) => y(s, e5, i2, i2.slicePlane?.basis1)), new e2("slicePlaneBasis2", (e5, i2) => y(s, e5, i2, i2.slicePlane?.basis2)));
}
function m(e4, s) {
  v(e4, s, new e2("slicePlaneOrigin", (e5, i2) => h(s, e5, i2)), new e2("slicePlaneBasis1", (e5, i2) => y(s, e5, i2, i2.slicePlane?.basis1)), new e2("slicePlaneBasis2", (e5, i2) => y(s, e5, i2, i2.slicePlane?.basis2)));
}
var b = t`struct SliceFactors {
float front;
float side0;
float side1;
float side2;
float side3;
};
SliceFactors calculateSliceFactors(vec3 pos) {
vec3 rel = pos - slicePlaneOrigin;
vec3 slicePlaneNormal = -cross(slicePlaneBasis1, slicePlaneBasis2);
float slicePlaneW = -dot(slicePlaneNormal, slicePlaneOrigin);
float basis1Len2 = dot(slicePlaneBasis1, slicePlaneBasis1);
float basis2Len2 = dot(slicePlaneBasis2, slicePlaneBasis2);
float basis1Dot = dot(slicePlaneBasis1, rel);
float basis2Dot = dot(slicePlaneBasis2, rel);
return SliceFactors(
dot(slicePlaneNormal, pos) + slicePlaneW,
-basis1Dot - basis1Len2,
basis1Dot - basis1Len2,
-basis2Dot - basis2Len2,
basis2Dot - basis2Len2
);
}
bool sliceByFactors(SliceFactors factors) {
return factors.front < 0.0
&& factors.side0 < 0.0
&& factors.side1 < 0.0
&& factors.side2 < 0.0
&& factors.side3 < 0.0;
}
bool sliceEnabled() {
return dot(slicePlaneBasis1, slicePlaneBasis1) != 0.0;
}
bool sliceByPlane(vec3 pos) {
return sliceEnabled() && sliceByFactors(calculateSliceFactors(pos));
}
bool rejectBySlice(vec3 pos) {
return sliceByPlane(pos);
}`;
function v(e4, s, ...i2) {
  s.hasSlicePlane ? (e4.uniforms.add(...i2), e4.code.add(b)) : e4.code.add("bool rejectBySlice(vec3 pos) { return false; }");
}
function B(e4, s, ...i2) {
  v(e4, s, ...i2), s.hasSlicePlane ? e4.code.add("\n    void discardBySlice(vec3 pos) {\n      if (sliceByPlane(pos)) {\n        discard;\n      }\n    }\n\n    vec4 applySliceOutline(vec4 color, vec3 pos) {\n      SliceFactors factors = calculateSliceFactors(pos);\n\n      factors.front /= 2.0 * fwidth(factors.front);\n      factors.side0 /= 2.0 * fwidth(factors.side0);\n      factors.side1 /= 2.0 * fwidth(factors.side1);\n      factors.side2 /= 2.0 * fwidth(factors.side2);\n      factors.side3 /= 2.0 * fwidth(factors.side3);\n\n      // return after calling fwidth, to avoid aliasing caused by discontinuities in the input to fwidth\n      if (sliceByFactors(factors)) {\n        return color;\n      }\n\n      float outlineFactor = (1.0 - step(0.5, factors.front))\n        * (1.0 - step(0.5, factors.side0))\n        * (1.0 - step(0.5, factors.side1))\n        * (1.0 - step(0.5, factors.side2))\n        * (1.0 - step(0.5, factors.side3));\n\n      return mix(color, vec4(vec3(0.0), color.a), outlineFactor * 0.3);\n    }\n\n    vec4 applySlice(vec4 color, vec3 pos) {\n      return sliceEnabled() ? applySliceOutline(color, pos) : color;\n    }\n  ") : e4.code.add(t`void discardBySlice(vec3 pos) { }
vec4 applySlice(vec4 color, vec3 pos) { return color; }`);
}
function w(e4, s, i2) {
  return e4.instancedDoublePrecision ? o(F, i2.camera.viewInverseTransposeMatrix[3], i2.camera.viewInverseTransposeMatrix[7], i2.camera.viewInverseTransposeMatrix[11]) : s.slicePlaneLocalOrigin;
}
function S(e4, s) {
  return null != e4 ? c(j, s.origin, e4) : s.origin;
}
function g(s, i2, a2) {
  return s.hasSliceTranslatedView ? null != i2 ? i(O, a2.camera.viewMatrix, i2) : a2.camera.viewMatrix : null;
}
function h(e4, s, i2) {
  if (null == i2.slicePlane) return a;
  const l = w(e4, s, i2), c3 = S(l, i2.slicePlane), o2 = g(e4, l, i2);
  return null != o2 ? E(j, c3, o2) : c3;
}
function y(e4, s, c3, o2) {
  if (null == o2 || null == c3.slicePlane) return a;
  const r = w(e4, s, c3), t2 = S(r, c3.slicePlane), f = g(e4, r, c3);
  return null != f ? (u(x, o2, t2), E(j, t2, f), E(x, x, f), c(x, x, j)) : o2;
}
var F = n();
var j = n();
var x = n();
var O = e();

export {
  p,
  m
};
//# sourceMappingURL=chunk-MXP2VO3L.js.map
