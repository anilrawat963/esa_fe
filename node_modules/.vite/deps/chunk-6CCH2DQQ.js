import {
  n as n2,
  o
} from "./chunk-Y2QJFDQ5.js";
import {
  u
} from "./chunk-2W3LGFFY.js";
import {
  m
} from "./chunk-QZQPB5XR.js";
import {
  y
} from "./chunk-PMGS7UDU.js";
import {
  ne
} from "./chunk-MC6NAKKX.js";
import {
  N as N2,
  W
} from "./chunk-2LC2762W.js";
import {
  z
} from "./chunk-H74Q4SYB.js";
import {
  f
} from "./chunk-5T3MJDSR.js";
import {
  N,
  T
} from "./chunk-NMQNUPE4.js";
import {
  $t,
  F,
  H2 as H,
  d,
  mt
} from "./chunk-V2H77UEV.js";
import {
  n,
  t2 as t
} from "./chunk-5EI5H4QX.js";
import {
  s2 as s
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/layers/ogc/wfsUtils.js
var T2 = "xlink:href";
var S = "2.0.0";
var F2 = "__esri_wfs_id__";
var x = "wfs-layer:getWFSLayerTypeInfo-error";
var C = "wfs-layer:empty-service";
var E = "wfs-layer:feature-type-not-found";
var R = "wfs-layer:geojson-not-supported";
var k = "wfs-layer:kvp-encoding-not-supported";
var P = "wfs-layer:malformed-json";
var j = "wfs-layer:unknown-geometry-type";
var A = "wfs-layer:unknown-field-type";
var N3 = "wfs-layer:unsupported-spatial-reference";
var G = "wfs-layer:unsupported-wfs-version";
async function v(t2, r) {
  const n3 = U((await H(t2, { responseType: "text", query: { SERVICE: "WFS", REQUEST: "GetCapabilities", VERSION: S, ...r?.customParameters }, signal: r?.signal })).data);
  return D(t2, n3), n3;
}
function U(e) {
  const t2 = te(e);
  ne2(t2), ae(t2);
  const r = t2.firstElementChild, a = n(O(r));
  return { operations: M(r), get featureTypes() {
    return Array.from(a());
  }, readFeatureTypes: a };
}
var I = ["json", "application/json; subtype=geojson; charset=utf-8", "application/json; subtype=geojson", "application/json", "geojson", "application/geo+json"];
function L(e) {
  for (const t2 of I) {
    const r = e.findIndex((e2) => e2.toLowerCase() === t2);
    if (r >= 0) return e[r];
  }
  return null;
}
function M(e) {
  let r = true;
  const n3 = { GetCapabilities: { url: "" }, DescribeFeatureType: { url: "" }, GetFeature: { url: "", outputFormat: null, supportsPagination: false } }, a = [], o2 = [];
  if (o(e, { OperationsMetadata: { Parameter: (e2) => {
    if ("outputformat" === e2.getAttribute("name")?.toLowerCase()) return { AllowedValues: { Value: ({ textContent: e3 }) => {
      e3 && a.push(e3);
    } } };
  }, Operation: (e2) => {
    switch (e2.getAttribute("name")) {
      case "GetCapabilities":
        return { DCP: { HTTP: { Get: (e3) => {
          n3.GetCapabilities.url = e3.getAttribute(T2);
        } } } };
      case "DescribeFeatureType":
        return { DCP: { HTTP: { Get: (e3) => {
          n3.DescribeFeatureType.url = e3.getAttribute(T2);
        } } } };
      case "GetFeature":
        return { DCP: { HTTP: { Get: (e3) => {
          n3.GetFeature.url = e3.getAttribute(T2);
        } } }, Parameter: (e3) => {
          if ("outputformat" === e3.getAttribute("name")?.toLowerCase()) return { AllowedValues: { Value: ({ textContent: e4 }) => {
            e4 && o2.push(e4);
          } } };
        } };
    }
  }, Constraint: (e2) => {
    switch (e2.getAttribute("name")) {
      case "KVPEncoding":
        return { DefaultValue: (e3) => {
          r = "true" === e3.textContent.toLowerCase();
        } };
      case "ImplementsResultPaging":
        return { DefaultValue: (e3) => {
          n3.GetFeature.supportsPagination = "true" === e3.textContent.toLowerCase();
        } };
    }
  } } }), n3.GetFeature.outputFormat = L(o2) ?? L(a), !r) throw new s(k, "WFS service doesn't support key/value pair (KVP) encoding");
  if (null == n3.GetFeature.outputFormat) throw new s(R, "WFS service doesn't support GeoJSON output format");
  return n3;
}
function D(e, t2) {
  mt(e) && (F(e, t2.operations.DescribeFeatureType.url, true) && (t2.operations.DescribeFeatureType.url = $t(t2.operations.DescribeFeatureType.url)), F(e, t2.operations.GetFeature.url, true) && (t2.operations.GetFeature.url = $t(t2.operations.GetFeature.url)));
}
function V(e) {
  const t2 = parseInt(e.textContent?.match(/(?<wkid>\d+$)/i)?.groups?.wkid ?? "", 10);
  if (!Number.isNaN(t2)) return t2;
}
function O(e) {
  return n2(e, { FeatureTypeList: { FeatureType: (e2) => {
    const t2 = { typeName: "undefined:undefined", name: "", title: "", description: "", extent: null, namespacePrefix: "", namespaceUri: "", defaultSpatialReference: 4326, supportedSpatialReferences: [] }, r = /* @__PURE__ */ new Set();
    return o(e2, { Name: (e3) => {
      const { name: r2, prefix: n3 } = re(e3.textContent);
      t2.typeName = `${n3}:${r2}`, t2.name = r2, t2.namespacePrefix = n3, t2.namespaceUri = e3.lookupNamespaceURI(n3);
    }, Abstract: (e3) => {
      t2.description = e3.textContent;
    }, Title: (e3) => {
      t2.title = e3.textContent;
    }, WGS84BoundingBox: (e3) => {
      t2.extent = z.fromJSON($(e3));
    }, DefaultCRS: (e3) => {
      const n3 = V(e3);
      n3 && (t2.defaultSpatialReference = n3, r.add(n3));
    }, OtherCRS: (e3) => {
      const t3 = V(e3);
      t3 && r.add(t3);
    } }), t2.title || (t2.title = t2.name), r.add(4326), t2.supportedSpatialReferences.push(...r), t2;
  } } });
}
function $(e) {
  let t2, r, n3, a;
  for (const o2 of e.children) switch (o2.localName) {
    case "LowerCorner":
      [t2, r] = o2.textContent.split(" ").map((e2) => Number.parseFloat(e2));
      break;
    case "UpperCorner":
      [n3, a] = o2.textContent.split(" ").map((e2) => Number.parseFloat(e2));
  }
  return { xmin: t2, ymin: r, xmax: n3, ymax: a, spatialReference: N };
}
function Y(e, t2, n3) {
  return t(e, (e2) => n3 ? e2.name === t2 && e2.namespaceUri === n3 : e2.typeName === t2 || e2.name === t2);
}
async function W2(e, t2, r, n3 = {}) {
  const { featureType: a, extent: o2 } = await X(e, t2, r, n3), { spatialReference: s2 } = oe(e.operations.GetFeature.url, a, n3.spatialReference), { fields: i, geometryType: p, swapXY: u2, objectIdField: c, geometryField: m2 } = await q(e, a, s2, n3);
  return { url: e.operations.GetCapabilities.url, name: a.name, namespaceUri: a.namespaceUri, fields: i, geometryField: m2, geometryType: p, objectIdField: c, spatialReference: n3.spatialReference ?? new f({ wkid: a.defaultSpatialReference }), extent: o2, swapXY: u2, wfsCapabilities: e, customParameters: n3.customParameters };
}
async function X(e, r, n3, a = {}) {
  const o2 = e.readFeatureTypes(), s2 = r ? Y(o2, r, n3) : o2.next().value, { spatialReference: i = new f({ wkid: s2?.defaultSpatialReference }) } = a;
  if (null == s2) throw r ? new s(E, `The type '${r}' could not be found in the service`) : new s(C, "The service is empty");
  let m2 = s2.extent;
  if (m2 && !T(m2.spatialReference, i)) try {
    await N2(m2.spatialReference, i, void 0, a), m2 = W(m2, i);
  } catch {
    throw new s(N3, "Projection not supported");
  }
  return { extent: m2, spatialReference: i, featureType: s2 };
}
async function q(e, r, n3, a = {}) {
  const { typeName: o2 } = r, [s2, i] = await Promise.allSettled([J(e.operations.DescribeFeatureType.url, o2, a), _(e, o2, n3, a)]), p = (e2) => new s(x, `An error occurred while getting info about the feature type '${o2}'`, { error: e2 });
  if ("rejected" === s2.status) throw p(s2.reason);
  if ("rejected" === i.status) throw p(i.reason);
  const { fields: u2, errors: l } = s2.value ?? {}, c = s2.value?.geometryType || i.value?.geometryType, m2 = i.value?.swapXY ?? false;
  if (null == c) throw new s(j, `The geometry type could not be determined for type '${o2}`, { typeName: o2, geometryType: c, fields: u2, errors: l });
  return { ...z2(u2 ?? []), geometryType: c, swapXY: m2 };
}
function z2(e) {
  const t2 = e.find((e2) => "geometry" === e2.type);
  let r = e.find((e2) => "oid" === e2.type);
  return e = e.filter((e2) => "geometry" !== e2.type), r || (r = new m({ name: F2, type: "oid", alias: F2 }), e.unshift(r)), { geometryField: t2?.name ?? null, objectIdField: r.name, fields: e };
}
async function _(t2, r, n3, a = {}) {
  let o2, s2 = false;
  const [i, p] = await Promise.all([K(t2.operations.GetFeature.url, r, n3, t2.operations.GetFeature.outputFormat, { ...a, count: 1 }), H(t2.operations.GetFeature.url, { responseType: "text", query: Z(r, n3, void 0, { ...a, count: 1 }), signal: a?.signal })]), u2 = "FeatureCollection" === i.type && i.features[0]?.geometry;
  if (u2) {
    let e;
    switch (o2 = y.fromJSON(u(u2.type)), u2.type) {
      case "Point":
        e = u2.coordinates;
        break;
      case "LineString":
      case "MultiPoint":
        e = u2.coordinates[0];
        break;
      case "MultiLineString":
      case "Polygon":
        e = u2.coordinates[0][0];
        break;
      case "MultiPolygon":
        e = u2.coordinates[0][0][0];
    }
    const t3 = /<[^>]*pos[^>]*> *(-?\d+(?:\.\d+)?) (-?\d+(?:\.\d+)?)/.exec(p.data);
    if (t3) {
      const r2 = e[0].toFixed(3), n4 = e[1].toFixed(3), a2 = parseFloat(t3[1]).toFixed(3);
      r2 === parseFloat(t3[2]).toFixed(3) && n4 === a2 && (s2 = true);
    }
  }
  return { geometryType: o2, swapXY: s2 };
}
async function J(t2, r, n3) {
  return Q(r, (await H(t2, { responseType: "text", query: { SERVICE: "WFS", REQUEST: "DescribeFeatureType", VERSION: S, TYPENAME: r, TYPENAMES: r, ...n3?.customParameters }, signal: n3?.signal })).data);
}
function Q(e, n3) {
  const { name: a } = re(e), o2 = te(n3);
  ae(o2);
  const s2 = t(n2(o2.firstElementChild, { element: (e2) => e2 }), (e2) => e2.getAttribute("name") === a);
  if (null != s2) {
    const e2 = s2.getAttribute("type"), t2 = e2 ? t(n2(o2.firstElementChild, { complexType: (e3) => e3 }), (t3) => t3.getAttribute("name") === re(e2).name) : t(n2(s2, { complexType: (e3) => e3 }), () => true);
    if (t2) return B(t2);
  }
  throw new s(E, `Type '${e}' not found in document`, { document: new XMLSerializer().serializeToString(o2) });
}
var H2 = /* @__PURE__ */ new Set(["objectid", "fid"]);
function B(e) {
  const r = [], n3 = [];
  let a;
  const o2 = n2(e, { complexContent: { extension: { sequence: { element: (e2) => e2 } } } });
  for (const s2 of o2) {
    const o3 = s2.getAttribute("name");
    if (!o3) continue;
    let i, p;
    if (s2.hasAttribute("type") ? i = re(s2.getAttribute("type")).name : o(s2, { simpleType: { restriction: (e2) => (i = re(e2.getAttribute("base")).name, { maxLength: (e3) => {
      p = +e3.getAttribute("value");
    } }) } }), !i) continue;
    const u2 = "true" === s2.getAttribute("nillable");
    let l = false;
    switch (i.toLowerCase()) {
      case "integer":
      case "nonpositiveinteger":
      case "negativeinteger":
      case "long":
      case "int":
      case "short":
      case "byte":
      case "nonnegativeinteger":
      case "unsignedlong":
      case "unsignedint":
      case "unsignedshort":
      case "unsignedbyte":
      case "positiveinteger":
        n3.push(new m({ name: o3, alias: o3, type: "integer", nullable: u2, length: ne("integer") }));
        break;
      case "float":
      case "double":
      case "decimal":
        n3.push(new m({ name: o3, alias: o3, type: "double", nullable: u2, length: ne("double") }));
        break;
      case "boolean":
      case "string":
      case "gyearmonth":
      case "gyear":
      case "gmonthday":
      case "gday":
      case "gmonth":
      case "anyuri":
      case "qname":
      case "notation":
      case "normalizedstring":
      case "token":
      case "language":
      case "idrefs":
      case "entities":
      case "nmtoken":
      case "nmtokens":
      case "name":
      case "ncname":
      case "id":
      case "idref":
      case "entity":
      case "duration":
      case "time":
        n3.push(new m({ name: o3, alias: o3, type: "string", nullable: u2, length: p ?? ne("string") }));
        break;
      case "datetime":
      case "date":
        n3.push(new m({ name: o3, alias: o3, type: "date", nullable: u2, length: p ?? ne("date") }));
        break;
      case "pointpropertytype":
        a = "point", l = true;
        break;
      case "multipointpropertytype":
        a = "multipoint", l = true;
        break;
      case "curvepropertytype":
      case "multicurvepropertytype":
      case "multilinestringpropertytype":
        a = "polyline", l = true;
        break;
      case "surfacepropertytype":
      case "multisurfacepropertytype":
      case "multipolygonpropertytype":
        a = "polygon", l = true;
        break;
      case "geometrypropertytype":
      case "multigeometrypropertytype":
        l = true, r.push(new s(j, `geometry type '${i}' is not supported`, { type: new XMLSerializer().serializeToString(e) }));
        break;
      default:
        r.push(new s(A, `Unknown field type '${i}'`, { type: new XMLSerializer().serializeToString(e) }));
    }
    l && n3.push(new m({ name: o3, alias: o3, type: "geometry", nullable: u2 }));
  }
  for (const t2 of n3) if ("integer" === t2.type && !t2.nullable && H2.has(t2.name.toLowerCase())) {
    t2.type = "oid";
    break;
  }
  return { geometryType: a, fields: n3, errors: r };
}
async function K(r, n3, a, o2, s2) {
  let { data: i } = await H(r, { responseType: "text", query: Z(n3, a, o2, s2), signal: s2?.signal });
  i = i.replaceAll(/": +(-?\d+),(\d+)(,)?/g, '": $1.$2$3');
  try {
    return JSON.parse(i);
  } catch (p) {
    throw new s(P, "Error while parsing theÂ response", { response: i, error: p });
  }
}
function Z(e, t2, r, n3) {
  const a = "number" == typeof t2 ? t2 : t2.wkid;
  return { SERVICE: "WFS", REQUEST: "GetFeature", VERSION: S, TYPENAMES: e, OUTPUTFORMAT: r, SRSNAME: "EPSG:" + a, STARTINDEX: n3?.startIndex, COUNT: n3?.count, ...n3?.customParameters };
}
async function ee(t2, r, n3) {
  const a = await H(t2, { responseType: "text", query: { SERVICE: "WFS", REQUEST: "GetFeature", VERSION: S, TYPENAMES: r, RESULTTYPE: "hits", ...n3?.customParameters }, signal: n3?.signal }), o2 = /numberMatched=["'](?<numberMatched>\d+)["']/gi.exec(a.data);
  if (o2?.groups) return +o2.groups.numberMatched;
}
function te(e) {
  return new DOMParser().parseFromString(e.trim(), "text/xml");
}
function re(e) {
  const [t2, r] = e.split(":");
  return { prefix: r ? t2 : "", name: r ?? t2 };
}
function ne2(e) {
  const r = e.firstElementChild?.getAttribute("version");
  if (r && r !== S) throw new s(G, `Unsupported WFS version ${r}. Supported version: ${S}`);
}
function ae(e) {
  let r = "", n3 = "";
  if (o(e.firstElementChild, { Exception: (e2) => (r = e2.getAttribute("exceptionCode"), { ExceptionText: (e3) => {
    n3 = e3.textContent;
  } }) }), r) throw new s(`wfs-layer:${r}`, n3);
}
function oe(e, t2, r) {
  const n3 = { wkid: t2.defaultSpatialReference }, a = null != r?.wkid ? { wkid: r.wkid } : n3;
  return { spatialReference: a, getFeatureSpatialReference: d(e) || a.wkid && t2.supportedSpatialReferences.includes(a.wkid) ? { wkid: a.wkid } : { wkid: t2.defaultSpatialReference } };
}

export {
  F2 as F,
  v,
  Y,
  W2 as W,
  z2 as z,
  K,
  ee,
  oe
};
//# sourceMappingURL=chunk-6CCH2DQQ.js.map
