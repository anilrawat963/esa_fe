import {
  L
} from "./chunk-BTFBYI67.js";
import {
  k
} from "./chunk-Q3JOE7TC.js";
import {
  l
} from "./chunk-T7F6Q6JJ.js";
import {
  P,
  y3 as y
} from "./chunk-PZ5RULLK.js";
import {
  _
} from "./chunk-AXZMNHTN.js";
import {
  o
} from "./chunk-XWE6BM2U.js";
import {
  r
} from "./chunk-SOIZOFSB.js";
import {
  n
} from "./chunk-XXLHAM2M.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";

// node_modules/@arcgis/core/layers/support/TelemetryData.js
var m2 = class extends l(n) {
  constructor(o2) {
    super(o2), this.frameCenter = null, this.frameOutline = null, this.lineOfSight = null, this.sensorLocation = null, this.sensorTrail = null;
  }
};
__decorate([m({ type: _ })], m2.prototype, "frameCenter", void 0), __decorate([m({ type: P })], m2.prototype, "frameOutline", void 0), __decorate([m({ type: y })], m2.prototype, "lineOfSight", void 0), __decorate([m({ type: _ })], m2.prototype, "sensorLocation", void 0), __decorate([m({ type: y })], m2.prototype, "sensorTrail", void 0), m2 = __decorate([a("esri.layers.support.TelemetryData")], m2);

// node_modules/@arcgis/core/layers/support/TelemetryDisplay.js
var i = { type: Boolean, json: { write: true } };
var p = class extends l(n) {
  constructor(o2) {
    super(o2), this.frame = false, this.frameCenter = false, this.frameOutline = true, this.lineOfSight = true, this.sensorLocation = true, this.sensorTrail = true;
  }
};
__decorate([m(i)], p.prototype, "frame", void 0), __decorate([m(i)], p.prototype, "frameCenter", void 0), __decorate([m(i)], p.prototype, "frameOutline", void 0), __decorate([m(i)], p.prototype, "lineOfSight", void 0), __decorate([m(i)], p.prototype, "sensorLocation", void 0), __decorate([m(i)], p.prototype, "sensorTrail", void 0), p = __decorate([a("esri.layers.support.TelemetryDisplay")], p);

// node_modules/@arcgis/core/layers/support/VideoTimeExtent.js
var n2 = class extends l(n) {
  constructor(t) {
    super(t), this.duration = null, this.end = null, this.start = null, this.timezone = "UTC";
  }
  readEnd(t, r2) {
    return null != r2.end ? new Date(r2.end) : null;
  }
  writeEnd(t, r2) {
    r2.end = t ? t.getTime() : null;
  }
  readStart(t, r2) {
    return null != r2.start ? new Date(r2.start) : null;
  }
  writeStart(t, r2) {
    r2.start = t ? t.getTime() : null;
  }
};
__decorate([m({ type: Number, json: { write: { allowNull: true } } })], n2.prototype, "duration", void 0), __decorate([m({ type: Date, json: { write: { allowNull: true } } })], n2.prototype, "end", void 0), __decorate([o("end")], n2.prototype, "readEnd", null), __decorate([r("end")], n2.prototype, "writeEnd", null), __decorate([m({ type: Date, json: { write: { allowNull: true } } })], n2.prototype, "start", void 0), __decorate([o("start")], n2.prototype, "readStart", null), __decorate([r("start")], n2.prototype, "writeStart", null), __decorate([m({ type: String })], n2.prototype, "timezone", void 0), n2 = __decorate([a("esri.layers.support.VideoTimeExtent")], n2);
var a2 = n2;

// node_modules/@arcgis/core/layers/video/videoUtils.js
var u = "application/x-mpegURL";
var s = "video/mp4";
var l2 = "video/webm";
var d = { UASDatalinkLocalSet: 1e4, PrecisionTimeStamp: 10002, MissionId: 10003, PlatformTailNumber: 10004, PlatformHeadingAngle: 10005, PlatformPitchAngle: 10006, PlatformRollAngle: 10007, PlatformTrueAirspeed: 10008, PlatformIndicatedAirspeed: 10009, PlatformDesignation: 10010, ImageSourceSensor: 10011, ImageCoordinateSystem: 10012, SensorLatitude: 10013, SensorLongitude: 10014, SensorTrueAltitude: 10015, SensorHorizontalFOV: 10016, SensorVerticalFOV: 10017, SensorAzimuthAngle: 10018, SensorElevationAngle: 10019, SensorRollAngle: 10020, PlatformSlantRange: 10021, TargetWidth: 10022, FrameCenterLatitude: 10023, FrameCenterLongitude: 10024, FrameCenterElevation: 10025, OffsetCorner1Latitude: 10026, OffsetCorner1Longitude: 10027, OffsetCorner2Latitude: 10028, OffsetCorner2Longitude: 10029, OffsetCorner3Latitude: 10030, OffsetCorner3Longitude: 10031, OffsetCorner4Latitude: 10032, OffsetCorner4Longitude: 10033, TargetLocationLatitude: 10040, TargetLocationLongitude: 10041, TargetLocationElevation: 10042, TargetTrackGateWidth: 10043, TargetTrackGateHeight: 10044, TargetErrorEstimateHorizontal: 10045, TargetErrorEstimateLateral: 10046, GenericFlagData: 10047, PlatformGroundSpeed: 10056, PlatformGroundRange: 10057, PlatformRemainingFuel: 10058, PlatformCallSign: 10059, SensorFOVName: 10063, PlatformMagneticHeading: 10064, LDSVersionNumber: 10065, AlternatePlatformName: 10070, EventStartTimeUTC: 10072, VMTIDataSet: 10074, SensorEllipsoidHeight: 10075, OperationalMode: 10077, FrameCenterAboveEllipsoid: 10078, CornerLatitudePoint1: 10082, CornerLongitudePoint1: 10083, CornerLatitudePoint2: 10084, CornerLongitudePoint2: 10085, CornerLatitudePoint3: 10086, CornerLongitudePoint3: 10087, CornerLatitudePoint4: 10088, CornerLongitudePoint4: 10089, SARMotionImageryMetadata: 10095, SecurityClassification: 20001, SecurityClassifyingAuthority: 20002, SecurityClassifyingCountry: 20003, SecuritySCI: 20004, SecurityCaveats: 20005, SecurityReleaseInstructions: 20006, SecurityLDSVersion: 20022, EsriVideoWidth: 90001, EsriVideoHeight: 90002, EsriFrameCenterLatitude: 90050, EsriFrameCenterLongitude: 90051, EsriCornerLatitudePt1: 90052, EsriCornerLongitudePt1: 90053, EsriCornerLatitudePt2: 90054, EsriCornerLongitudePt2: 90055, EsriCornerLatitudePt3: 90056, EsriCornerLongitudePt3: 90057, EsriCornerLatitudePt4: 90058, EsriCornerLongitudePt4: 90059, EsriFrameOutline: 90060, EsriSensorPosition: 90061, EsriHorizonPixelPack: 90063, EsriGroundControlPoints: 90064 };
function f(e, t = 1e4) {
  if (!e || !e.length) return [];
  let r2 = [], n3 = [];
  for (let i2 = 0; i2 < e.length; i2++) {
    const t2 = e[i2], n4 = t2?.text ? JSON.parse(t2.text) : null;
    "EsriVideoServer" === n4?.source && (r2 = [...n4.data]);
  }
  const o2 = r2.find((e2) => e2.tagId === t);
  return Array.isArray(o2?.value) && (n3 = [...o2.value]), n3;
}
function g(e) {
  const { duration: t, end: r2, start: n3, timezone: i2 = "UTC" } = e || {};
  return "number" != typeof t ? null : new a2({ duration: t || null, end: "number" == typeof r2 ? new Date(r2) : null, start: "number" == typeof n3 ? new Date(n3) : null, timezone: i2 });
}
function m3(e, t) {
  const r2 = [...t], n3 = r2.findIndex((t2) => t2.equals(e));
  return n3 > -1 && r2.splice(n3), r2.push(e), r2;
}
function C(e) {
  if (!e?.size) return new m2();
  const t = b(e), r2 = P2(e), o2 = O(e), i2 = A(t, r2);
  return new m2({ frameCenter: r2, frameOutline: o2, lineOfSight: i2, sensorLocation: t });
}
function L2(e) {
  if (!e?.size) return null;
  return e.get(d.EsriGroundControlPoints)?.value ?? null ?? null;
}
function c(e) {
  return e?.size ? e.get(d.EsriHorizonPixelPack)?.value ?? null : null;
}
function P2(e) {
  return S(e) ?? y2(e);
}
function E(e) {
  if (!e) return u;
  const t = e.match(/\.(\w{3,4})(?:$|\?)/i);
  if (!t) return u;
  switch (t[1].toLowerCase()) {
    case "mp4":
      return s;
    case "webm":
      return l2;
    default:
      return u;
  }
}
function p2(e) {
  const t = e?.layers;
  return t?.length ? t.map((e2) => ({ layerId: e2.id, posterUrl: e2.poster, sourceType: e2.serviceType, title: e2.name, type: e2.type || "Video Layer" })) : [];
}
function v(e, t, r2) {
  if (!e) return null;
  const n3 = e.clone();
  switch (n3.type) {
    case "simple-fill":
      L(n3, r2), n3.outline.color = t;
      break;
    case "simple-line":
      L(n3, t);
      break;
    case "simple-marker":
      L(n3, t), n3?.outline?.color && (n3.outline.color = t);
      break;
    case "cim":
      k(n3, t);
  }
  return n3;
}
function h(e) {
  const { cameraAzimuth: t, platformHeading: r2, source: n3 = null, symbolOffset: o2 = 0 } = e || {};
  let i2 = 0;
  if (!n3) return i2;
  i2 = "platformHeading" === n3 ? r2 + o2 : r2 + t + o2;
  const a3 = i2 > 360 ? i2 - 360 : i2;
  return Math.round(Math.abs(a3));
}
function S(t) {
  return t && t.has(d.EsriFrameCenterLatitude) && t.has(d.EsriFrameCenterLongitude) ? new _({ x: t.get(d.EsriFrameCenterLongitude).value, y: t.get(d.EsriFrameCenterLatitude).value, z: t.get(d.FrameCenterAboveEllipsoid)?.value ?? t.get(d.FrameCenterElevation)?.value }) : null;
}
function y2(t) {
  return t && t.has(d.FrameCenterLatitude) && t.has(d.FrameCenterLongitude) ? new _({ x: t.get(d.FrameCenterLongitude)?.value, y: t.get(d.FrameCenterLatitude)?.value, z: t.get(d.FrameCenterElevation)?.value }) : null;
}
function O(e) {
  if (!e) return null;
  const r2 = e.get(d.EsriFrameOutline)?.value;
  return r2 ? P.fromJSON(r2.geometry) : F(e) ?? T(e);
}
function F(e) {
  if (!(e.has(d.EsriCornerLatitudePt1) && e.has(d.EsriCornerLongitudePt1) && e.has(d.EsriCornerLatitudePt2) && e.has(d.EsriCornerLongitudePt2) && e.has(d.EsriCornerLatitudePt3) && e.has(d.EsriCornerLongitudePt3) && e.has(d.EsriCornerLatitudePt4) && e.has(d.EsriCornerLongitudePt4))) return null;
  const r2 = [e.get(d.EsriCornerLongitudePt1)?.value, e.get(d.EsriCornerLatitudePt1)?.value], n3 = [e.get(d.EsriCornerLongitudePt2)?.value, e.get(d.EsriCornerLatitudePt2)?.value], o2 = [e.get(d.EsriCornerLongitudePt3)?.value, e.get(d.EsriCornerLatitudePt3)?.value], i2 = [e.get(d.EsriCornerLongitudePt4)?.value, e.get(d.EsriCornerLatitudePt4)?.value];
  return new P({ rings: [[r2, n3, o2, i2]] });
}
function T(e) {
  if (!(e.has(d.OffsetCorner1Latitude) && e.has(d.OffsetCorner1Longitude) && e.has(d.OffsetCorner2Latitude) && e.has(d.OffsetCorner2Longitude) && e.has(d.OffsetCorner3Latitude) && e.has(d.OffsetCorner3Longitude) && e.has(d.OffsetCorner4Latitude) && e.has(d.OffsetCorner4Longitude) && e.has(d.FrameCenterLatitude) && e.has(d.FrameCenterLongitude))) return null;
  const r2 = e.get(d.FrameCenterLatitude)?.value, n3 = e.get(d.FrameCenterLongitude)?.value, o2 = r2 + e.get(d.OffsetCorner1Latitude)?.value, i2 = n3 + e.get(d.OffsetCorner1Longitude)?.value, a3 = r2 + e.get(d.OffsetCorner2Latitude)?.value, u2 = n3 + e.get(d.OffsetCorner2Longitude)?.value, s2 = r2 + e.get(d.OffsetCorner3Latitude)?.value, l3 = n3 + e.get(d.OffsetCorner3Longitude)?.value, f2 = r2 + e.get(d.OffsetCorner4Latitude)?.value, g2 = n3 + e.get(d.OffsetCorner4Longitude)?.value;
  return new P({ rings: [[[i2, o2], [u2, a3], [l3, s2], [g2, f2]]] });
}
function A(e, t) {
  if (!e || !t) return null;
  const n3 = [e.x, e.y, e.z ?? 0], o2 = [t.x, t.y, t.z ?? 0];
  return new y({ paths: [[n3, o2]] });
}
function b(t) {
  if (!t?.size) return null;
  if (t.has(d.EsriSensorPosition)) {
    const r2 = t.get(d.EsriSensorPosition)?.value;
    if (r2) return _.fromJSON(r2.geometry);
  }
  return t.has(d.SensorLongitude) && t.has(d.SensorLatitude) ? new _({ x: t.get(d.SensorLongitude)?.value, y: t.get(d.SensorLatitude)?.value, z: t.get(d.SensorTrueAltitude)?.value }) : null;
}

export {
  m2 as m,
  p,
  a2 as a,
  d,
  f,
  g,
  m3 as m2,
  C,
  L2 as L,
  c,
  E,
  p2,
  v,
  h
};
//# sourceMappingURL=chunk-GHIN7ITM.js.map
