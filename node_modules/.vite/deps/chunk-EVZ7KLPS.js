import {
  E,
  _,
  f,
  g,
  u,
  x
} from "./chunk-WFCLXKCE.js";
import {
  p
} from "./chunk-FMOL5XMB.js";
import {
  a as a3
} from "./chunk-VNSHGTPN.js";
import {
  P,
  T
} from "./chunk-23NJHA5Q.js";
import {
  L
} from "./chunk-CNYNCKEV.js";
import {
  o as o3
} from "./chunk-CSMCPN64.js";
import {
  o as o2
} from "./chunk-XWE6BM2U.js";
import {
  r
} from "./chunk-SOIZOFSB.js";
import {
  n
} from "./chunk-XXLHAM2M.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  o
} from "./chunk-65HD3WXL.js";
import {
  a,
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/layers/support/LabelExpressionInfo.js
var l;
var _a;
var n2 = (_a = class extends n {
  constructor() {
    super(...arguments), this.expression = null, this.title = null, this.value = null;
  }
  readExpression(r2, e) {
    return e.value ? E(e.value) : r2;
  }
  writeExpression(r2, e, o4) {
    null != this.value && (r2 = E(this.value)), null != r2 && (e[o4] = r2);
  }
  clone() {
    return new l({ expression: this.expression, title: this.title, value: this.value });
  }
}, l = _a, _a);
__decorate([m({ type: String, json: { write: { writerEnsuresNonNull: true } } })], n2.prototype, "expression", void 0), __decorate([o2("expression", ["expression", "value"])], n2.prototype, "readExpression", null), __decorate([r("expression")], n2.prototype, "writeExpression", null), __decorate([m({ type: String, json: { write: true, origins: { "web-scene": { write: false } } } })], n2.prototype, "title", void 0), __decorate([m({ json: { read: false, write: false } })], n2.prototype, "value", void 0), n2 = l = __decorate([a2("esri.layers.support.LabelExpressionInfo")], n2);

// node_modules/@arcgis/core/layers/support/LabelClass.js
var S;
var L2 = new o({ esriServerPointLabelPlacementAboveCenter: "above-center", esriServerPointLabelPlacementAboveLeft: "above-left", esriServerPointLabelPlacementAboveRight: "above-right", esriServerPointLabelPlacementBelowCenter: "below-center", esriServerPointLabelPlacementBelowLeft: "below-left", esriServerPointLabelPlacementBelowRight: "below-right", esriServerPointLabelPlacementCenterCenter: "center-center", esriServerPointLabelPlacementCenterLeft: "center-left", esriServerPointLabelPlacementCenterRight: "center-right", esriServerLinePlacementAboveAfter: "above-after", esriServerLinePlacementAboveAlong: "above-along", esriServerLinePlacementAboveBefore: "above-before", esriServerLinePlacementAboveStart: "above-start", esriServerLinePlacementAboveEnd: "above-end", esriServerLinePlacementBelowAfter: "below-after", esriServerLinePlacementBelowAlong: "below-along", esriServerLinePlacementBelowBefore: "below-before", esriServerLinePlacementBelowStart: "below-start", esriServerLinePlacementBelowEnd: "below-end", esriServerLinePlacementCenterAfter: "center-after", esriServerLinePlacementCenterAlong: "center-along", esriServerLinePlacementCenterBefore: "center-before", esriServerLinePlacementCenterStart: "center-start", esriServerLinePlacementCenterEnd: "center-end", esriServerPolygonPlacementAlwaysHorizontal: "always-horizontal" }, { ignoreUnknown: true });
function P2(e, r2, t2) {
  return { enabled: !L(t2?.layer) };
}
function x2(e) {
  return !e || "service" !== e.origin && !("map-image" === e.layer?.type);
}
function g2(e) {
  return "map-image" === e?.type;
}
function E2(e) {
  return !!g2(e) && !!e.capabilities?.exportMap?.supportsArcadeExpressionForLabeling;
}
function j(e) {
  return x2(e) || E2(e?.layer);
}
var _a2;
var A = (_a2 = class extends n {
  static evaluateWhere(e, r2) {
    const t2 = (e2, r3, t3) => {
      switch (r3) {
        case "=":
          return e2 == t3;
        case "<>":
          return e2 != t3;
        case ">":
          return e2 > t3;
        case ">=":
          return e2 >= t3;
        case "<":
          return e2 < t3;
        case "<=":
          return e2 <= t3;
      }
      return false;
    };
    try {
      if (null == e) return true;
      const o4 = e.split(" ");
      if (3 === o4.length) return t2(r2[o4[0]], o4[1], o4[2]);
      if (7 === o4.length) {
        const e2 = t2(r2[o4[0]], o4[1], o4[2]), i3 = o4[3], l3 = t2(r2[o4[4]], o4[5], o4[6]);
        switch (i3) {
          case "AND":
            return e2 && l3;
          case "OR":
            return e2 || l3;
        }
      }
      return false;
    } catch (o4) {
    }
  }
  constructor(e) {
    super(e), this.type = "label", this.name = null, this.allowOverrun = false, this.deconflictionStrategy = "static", this.labelExpression = null, this.labelExpressionInfo = null, this.labelPlacement = null, this.labelPosition = "curved", this.maxScale = 0, this.minScale = 0, this.repeatLabel = true, this.repeatLabelDistance = null, this.symbol = a3, this.useCodedValues = void 0, this.where = null;
  }
  readLabelExpression(e, r2) {
    const t2 = r2.labelExpressionInfo;
    if (!t2 || !t2.value && !t2.expression) return e;
  }
  writeLabelExpression(e, r2, t2) {
    if (this.labelExpressionInfo) {
      if (null != this.labelExpressionInfo.value) e = u(this.labelExpressionInfo.value);
      else if (null != this.labelExpressionInfo.expression) {
        const r3 = _(this.labelExpressionInfo.expression);
        r3 && (e = "[" + r3 + "]");
      }
    }
    null != e && (r2[t2] = e);
  }
  writeLabelExpressionInfo(e, r2, t2, o4) {
    if (null == e && null != this.labelExpression && x2(o4)) e = new n2({ expression: this.getLabelExpressionArcade() });
    else if (!e) return;
    const i3 = e.toJSON(o4);
    i3.expression && (r2[t2] = i3);
  }
  writeMaxScale(e, r2) {
    (e || this.minScale) && (r2.maxScale = e);
  }
  writeMinScale(e, r2) {
    (e || this.maxScale) && (r2.minScale = e);
  }
  getLabelExpression() {
    return x(this);
  }
  getLabelExpressionArcade() {
    return f(this);
  }
  getLabelExpressionSingleField() {
    return g(this);
  }
  hash() {
    return JSON.stringify(this);
  }
  clone() {
    return new S({ allowOverrun: this.allowOverrun, deconflictionStrategy: this.deconflictionStrategy, labelExpression: this.labelExpression, labelExpressionInfo: a(this.labelExpressionInfo), labelPosition: this.labelPosition, labelPlacement: this.labelPlacement, maxScale: this.maxScale, minScale: this.minScale, name: this.name, repeatLabel: this.repeatLabel, repeatLabelDistance: this.repeatLabelDistance, symbol: a(this.symbol), where: this.where, useCodedValues: this.useCodedValues });
  }
}, S = _a2, _a2);
__decorate([m({ type: String, json: { write: true } })], A.prototype, "name", void 0), __decorate([m({ type: Boolean, json: { write: true, default: false, origins: { "web-scene": { write: false }, "portal-item": { default: false, write: { overridePolicy: P2 } } } } })], A.prototype, "allowOverrun", void 0), __decorate([m({ type: String, json: { write: true, default: "static", origins: { "web-scene": { write: false }, "portal-item": { default: "static", write: { overridePolicy: P2 } } } } })], A.prototype, "deconflictionStrategy", void 0), __decorate([m({ type: String, json: { write: { overridePolicy(e, r2, t2) {
  return this.labelExpressionInfo && "service" === t2?.origin && E2(t2.layer) ? { enabled: false } : { allowNull: true };
} } } })], A.prototype, "labelExpression", void 0), __decorate([o2("labelExpression")], A.prototype, "readLabelExpression", null), __decorate([r("labelExpression")], A.prototype, "writeLabelExpression", null), __decorate([m({ type: n2, json: { write: { overridePolicy: (e, r2, t2) => j(t2) ? { allowNull: true } : { enabled: false } } } })], A.prototype, "labelExpressionInfo", void 0), __decorate([r("labelExpressionInfo")], A.prototype, "writeLabelExpressionInfo", null), __decorate([m({ type: L2.apiValues, json: { type: L2.jsonValues, read: L2.read, write: L2.write } })], A.prototype, "labelPlacement", void 0), __decorate([m({ type: ["curved", "parallel"], json: { write: true, origins: { "web-map": { write: false }, "web-scene": { write: false }, "portal-item": { write: false } } } })], A.prototype, "labelPosition", void 0), __decorate([m({ type: Number })], A.prototype, "maxScale", void 0), __decorate([r("maxScale")], A.prototype, "writeMaxScale", null), __decorate([m({ type: Number })], A.prototype, "minScale", void 0), __decorate([r("minScale")], A.prototype, "writeMinScale", null), __decorate([m({ type: Boolean, json: { write: true, origins: { "web-scene": { write: false }, "portal-item": { write: { overridePolicy: P2 } } } } })], A.prototype, "repeatLabel", void 0), __decorate([m({ type: Number, cast: o3, json: { write: true, origins: { "web-scene": { write: false }, "portal-item": { write: { overridePolicy: P2 } } } } })], A.prototype, "repeatLabelDistance", void 0), __decorate([m({ types: P, json: { origins: { "web-scene": { types: T, write: p, default: null } }, write: p, default: null } })], A.prototype, "symbol", void 0), __decorate([m({ type: Boolean, json: { write: true } })], A.prototype, "useCodedValues", void 0), __decorate([m({ type: String, json: { write: true } })], A.prototype, "where", void 0), A = S = __decorate([a2("esri.layers.support.LabelClass")], A);

// node_modules/@arcgis/core/layers/support/labelingInfo.js
var t = () => i.getLogger("esri.layers.support.labelingInfo");
var n3 = /\[([^[\]]+)\]/gi;
function l2(e, o4, t2) {
  return e ? e.map((e2) => {
    const l3 = new A();
    if (l3.read(e2, t2), l3.labelExpression) {
      const e3 = o4.fields || o4.layerDefinition?.fields || this.fields;
      l3.labelExpression = l3.labelExpression.replaceAll(n3, (o5, r2) => `[${s2(r2, e3)}]`);
    }
    return l3;
  }) : null;
}
function s2(e, o4) {
  if (!o4) return e;
  const r2 = e.toLowerCase();
  for (let t2 = 0; t2 < o4.length; t2++) {
    const e2 = o4[t2].name;
    if (e2.toLowerCase() === r2) return e2;
  }
  return e;
}
var i2 = ["above-right", "above-center", "above-left", "center-center", "center-left", "center-right", "below-center", "below-left", "below-right"];
var a4 = { esriGeometryPoint: i2, esriGeometryMultiPatch: ["always-horizontal"], esriGeometryPolygon: ["always-horizontal"], esriGeometryPolyline: ["center-along", "above-along", "below-along"], esriGeometryMultipoint: i2, esriGeometryEnvelope: null };
function c(o4, r2) {
  const n4 = [];
  for (const l3 of o4) {
    const o5 = l3.labelPlacement, s3 = a4[r2];
    if (!l3.symbol) return t().warn("No ILabelClass symbol specified."), [];
    if (!s3) return t().error(new s("labeling:unsupported-geometry-type", `Unable to create labels for layer, geometry type '${r2}' is not supported`)), [];
    if (s3.includes(o5)) n4.push(l3);
    else {
      const e = s3[0];
      o5 && t().warn(`Found invalid label placement type ${o5} for ${r2}. Defaulting to ${e}`);
      const i3 = l3.clone();
      i3.labelPlacement = e, n4.push(i3);
    }
  }
  return n4;
}

export {
  n2 as n,
  A,
  l2 as l,
  c
};
//# sourceMappingURL=chunk-EVZ7KLPS.js.map
