import {
  d as d3,
  i as i9,
  v as v3
} from "./chunk-IJEEAMVP.js";
import {
  i as i10,
  o as o4,
  s as s3,
  u as u4
} from "./chunk-S5XQW4PV.js";
import {
  e as e5
} from "./chunk-2GCOQTG5.js";
import {
  i as i8
} from "./chunk-VEW6BMSK.js";
import {
  r as r6
} from "./chunk-ZS4Q4DJE.js";
import {
  n as n3
} from "./chunk-E77VVW2C.js";
import {
  E as E2,
  J as J2,
  g as g3
} from "./chunk-PG3227VO.js";
import {
  m as m4
} from "./chunk-2XM57LB5.js";
import {
  i as i7
} from "./chunk-UXLDVCDU.js";
import {
  At,
  B,
  Bt,
  C as C2,
  C2 as C3,
  Ct,
  Ge,
  Gt,
  Ht,
  I as I2,
  J,
  Jt,
  Lt,
  P as P2,
  Pt,
  Qt,
  Rt,
  Te,
  Tt,
  U as U3,
  Ue,
  Ut,
  W,
  We,
  Wt,
  X,
  Xe,
  Xt,
  Y,
  Ye,
  Yt,
  Z,
  Zt,
  _ as _3,
  _2 as _4,
  _e,
  _t,
  an,
  ce,
  cn,
  f2,
  fn,
  g as g2,
  ge,
  gt,
  he,
  hn,
  ie,
  jn,
  jt,
  l as l4,
  ln,
  m as m3,
  ne,
  oe,
  pn,
  q as q2,
  qe,
  qt,
  re,
  rt,
  s as s2,
  se,
  sn,
  st,
  ue as ue2,
  un,
  ut,
  v as v2,
  w,
  we,
  wn,
  xt,
  ze,
  zt
} from "./chunk-JGWZMI5Q.js";
import {
  r2 as r5
} from "./chunk-43423NKQ.js";
import {
  b as b3
} from "./chunk-T5PAMHK6.js";
import {
  d as d2
} from "./chunk-PZZ55S55.js";
import {
  e as e4
} from "./chunk-ALLCMCHO.js";
import {
  m as m2
} from "./chunk-NNZE65VM.js";
import "./chunk-RZOWZMPW.js";
import "./chunk-7LPDSYJP.js";
import {
  a as a3,
  g,
  i as i6,
  u as u3
} from "./chunk-ECIORIM4.js";
import {
  c as c2
} from "./chunk-BTNEC6LS.js";
import {
  t
} from "./chunk-BJUALH6B.js";
import "./chunk-XQWYTOXM.js";
import {
  V,
  a as a2,
  i as i5
} from "./chunk-EQUB4K44.js";
import {
  n as n2
} from "./chunk-RRK2YVM5.js";
import "./chunk-VIDAPS4J.js";
import "./chunk-FTN6U6TO.js";
import "./chunk-QTS3W27E.js";
import "./chunk-3RABUJDL.js";
import "./chunk-WJ3E33GQ.js";
import "./chunk-U3B7YMY7.js";
import "./chunk-F75XORHS.js";
import {
  h as h5
} from "./chunk-L2YWECQ7.js";
import {
  $,
  I,
  me,
  ue,
  v
} from "./chunk-5RPEIJ7N.js";
import {
  S,
  l as l3
} from "./chunk-NQDCX3PB.js";
import "./chunk-QW7RJMQR.js";
import {
  c2 as c,
  l2
} from "./chunk-CJAJ4FML.js";
import {
  H
} from "./chunk-RQGBRVDD.js";
import "./chunk-JPZOLUPV.js";
import "./chunk-GG4AQJJO.js";
import "./chunk-M5JMVUW2.js";
import "./chunk-ALR6N4CF.js";
import "./chunk-4X4BOGIG.js";
import "./chunk-XX3OKYJS.js";
import "./chunk-OTCNIJ2H.js";
import "./chunk-JGA5YJWL.js";
import "./chunk-GCI4MA3M.js";
import "./chunk-SJ2OBYX2.js";
import "./chunk-VX2NEBRT.js";
import "./chunk-IXRRTVLJ.js";
import "./chunk-EKM7KERW.js";
import {
  e as e3,
  o2 as o3
} from "./chunk-WKTI47FV.js";
import {
  e as e2
} from "./chunk-T3SYSTKO.js";
import {
  mt
} from "./chunk-6RE6OSTE.js";
import "./chunk-QSGJ3ECU.js";
import {
  t as t2
} from "./chunk-LQPKVYW2.js";
import {
  A,
  h as h6
} from "./chunk-U55FA2EK.js";
import "./chunk-GBN36VHC.js";
import {
  p,
  r as r3
} from "./chunk-ZSZK67ZL.js";
import "./chunk-IPWH4LK2.js";
import {
  h as h4
} from "./chunk-7CDU3B2L.js";
import "./chunk-B5A4L35M.js";
import "./chunk-52SEOH5H.js";
import "./chunk-JUZ3H47H.js";
import {
  r as r4
} from "./chunk-UYMV6HXW.js";
import {
  o as o2
} from "./chunk-JE2NJSBU.js";
import "./chunk-7HTU7ZUX.js";
import {
  C,
  D,
  E,
  N,
  P,
  U as U2
} from "./chunk-QNVJVDYZ.js";
import "./chunk-WDTGOP77.js";
import "./chunk-VYMBX5H5.js";
import {
  h as h3
} from "./chunk-BPTFV5VM.js";
import {
  z as z2
} from "./chunk-YP3WVJP3.js";
import "./chunk-M24KZOVI.js";
import {
  f
} from "./chunk-XDLV73DB.js";
import "./chunk-ARTU4L55.js";
import "./chunk-6VL5D5UP.js";
import "./chunk-6QHY54HZ.js";
import "./chunk-GXJJY3ND.js";
import "./chunk-5ONGWFJ3.js";
import "./chunk-PLNHHGHL.js";
import "./chunk-4WTOIJXV.js";
import "./chunk-BBYMM7CM.js";
import "./chunk-EM7Y2JZC.js";
import "./chunk-QZQPB5XR.js";
import "./chunk-AQFRVV3U.js";
import "./chunk-BUQC3CLV.js";
import {
  _ as _2
} from "./chunk-C3FRY5U4.js";
import "./chunk-JNJX34GB.js";
import "./chunk-3STJRSDT.js";
import "./chunk-67Q6KVC6.js";
import "./chunk-23NJHA5Q.js";
import "./chunk-4LA6K4VI.js";
import "./chunk-KEZCWFAR.js";
import "./chunk-JZUJ34RR.js";
import "./chunk-PMGS7UDU.js";
import "./chunk-3GHCGAH2.js";
import "./chunk-HWUOAPTX.js";
import "./chunk-QHCKOBU7.js";
import "./chunk-K2OZ6WVC.js";
import "./chunk-MC6NAKKX.js";
import "./chunk-TF6255HN.js";
import "./chunk-GD4FJL3C.js";
import "./chunk-C5OQVQZF.js";
import "./chunk-F7DKSAOI.js";
import "./chunk-4SOQWNPG.js";
import "./chunk-LTULADK2.js";
import "./chunk-35ST7YRB.js";
import "./chunk-EDA5QFHZ.js";
import "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-MHV23XAQ.js";
import "./chunk-V2X4OKYI.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import "./chunk-MA3QDRC3.js";
import "./chunk-W6J7XCPU.js";
import "./chunk-ONXWBTTM.js";
import "./chunk-T7F6Q6JJ.js";
import "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-7P2ANHQ3.js";
import "./chunk-XCKT47LJ.js";
import "./chunk-3FUHCAX3.js";
import "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import {
  M,
  b as b2,
  h as h2,
  i as i4,
  o,
  r as r2
} from "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import {
  i as i3
} from "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import {
  z
} from "./chunk-H74Q4SYB.js";
import {
  U,
  h,
  l
} from "./chunk-2OFHDVO5.js";
import "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-5UPBUJPC.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import {
  u as u2
} from "./chunk-CCQFL76O.js";
import "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import "./chunk-7H3U4IJR.js";
import {
  i as i2,
  q,
  u
} from "./chunk-SMWUT52Z.js";
import {
  _
} from "./chunk-AXZMNHTN.js";
import "./chunk-5T3MJDSR.js";
import "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import {
  b,
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate,
  __param
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import {
  L,
  d,
  e,
  n,
  r2 as r
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  has
} from "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/views/2d/engine/imagery/RasterBitmap.js
var x = { bandCount: 3, minOutput: 0, maxOutput: 1, minCutOff: [0, 0, 0], maxCutOff: [255, 255, 255], factor: [1 / 255, 1 / 255, 1 / 255], useGamma: false, gamma: [1, 1, 1], gammaCorrection: [1, 1, 1], colormap: null, colormapOffset: null, stretchType: "none", type: "stretch" };
var m5 = class extends e4 {
  constructor(t10 = null, e8 = null, s10 = null) {
    super(), this._textureInvalidated = true, this._colormapTextureInvalidated = true, this._rasterTexture = null, this._maskTexture = null, this._rasterTextureBandIds = null, this._transformGridTexture = null, this._colormapTexture = null, this._colormap = null, this._supportsBilinearTexture = true, this._processedTexture = null, this._highlightTexture = null, this.functionTextures = [], this.projected = false, this.stencilRef = 0, this.coordScale = [1, 1], this._processed = false, this._highlighted = false, this._symbolizerParameters = null, this.height = null, this.isRendereredSource = false, this.pixelRatio = 1, this.resolution = 0, this.rotation = 0, this._source = null, this._mask = null, this.rawPixelData = null, this._suspended = false, this._bandIds = null, this._interpolation = null, this._transformGrid = null, this.width = null, this.x = 0, this.y = 0, this.source = t10, this.transformGrid = e8, this.interpolation = s10;
  }
  destroy() {
    super.destroy(), this._disposeTextures();
  }
  get processedTexture() {
    return this._processedTexture;
  }
  set processedTexture(t10) {
    this._processedTexture !== t10 && (this._disposeTextures(true), this._processedTexture = t10);
  }
  get highlightTexture() {
    return this._highlightTexture;
  }
  set highlightTexture(t10) {
    this._highlightTexture !== t10 && (this._highlightTexture?.dispose(), this._highlightTexture = t10), null == t10 && (this._highlighted = false);
  }
  get rasterTexture() {
    return this._rasterTexture;
  }
  set rasterTexture(t10) {
    this._rasterTexture !== t10 && (this._rasterTexture?.dispose(), this._rasterTexture = t10), null == t10 && (this.projected = false);
  }
  get processed() {
    return this._processed;
  }
  set processed(e8) {
    this._processed = e8, e8 || (this.processedTexture = r(this.processedTexture), this.invalidateTexture());
  }
  get highlighted() {
    return this._highlighted;
  }
  get symbolizerParameters() {
    return this._symbolizerParameters || x;
  }
  set symbolizerParameters(t10) {
    this._symbolizerParameters !== t10 && (this._symbolizerParameters = t10, this._colormapTextureInvalidated = true);
  }
  get source() {
    return this._source;
  }
  set source(e8) {
    this._source !== e8 && (this._source = e8, this._rasterTexture && (this._rasterTexture = r(this._rasterTexture), this._rasterTextureBandIds = null), this.projected = false, this.invalidateTexture());
  }
  get mask() {
    return this._mask;
  }
  set mask(e8) {
    this._mask !== e8 && (this._mask = e8, this._maskTexture = r(this._maskTexture));
  }
  get suspended() {
    return this._suspended;
  }
  set suspended(t10) {
    this._suspended && !t10 && this.stage && (this.ready(), this.requestRender()), this._suspended = t10;
  }
  get bandIds() {
    return this._bandIds;
  }
  set bandIds(t10) {
    this._bandIds = t10, this._isBandIdsChanged(t10) && (this.projected = false, this.invalidateTexture());
  }
  get interpolation() {
    return this._interpolation || "nearest";
  }
  set interpolation(t10) {
    this._interpolation = t10, this._rasterTexture && this._rasterTexture.setSamplingMode("bilinear" === this._getTextureSamplingMethod(t10 || "nearest") ? 9729 : 9728);
  }
  get transformGrid() {
    return this._transformGrid;
  }
  set transformGrid(e8) {
    this._transformGrid !== e8 && (this._transformGrid = e8, this._transformGridTexture = r(this._transformGridTexture));
  }
  invalidateTexture() {
    this._textureInvalidated || (this._textureInvalidated = true, this.requestRender());
  }
  getRasterTextureSize(t10 = false) {
    const e8 = t10 || this.projected;
    return [e8 ? this.width : this.source?.width || this.width, e8 ? this.height : this.source?.height || this.height];
  }
  getRasterCellSize() {
    const t10 = this.rawPixelData?.srcPixelSize, { projected: e8, resolution: s10 } = this;
    return t10 && !e8 ? [t10.x, t10.y] : [s10, s10];
  }
  _createTransforms() {
    return { displayViewScreenMat3: e3() };
  }
  setTransform(t10) {
    const a10 = o(this.transforms.displayViewScreenMat3), [o6, n7] = t10.toScreenNoRotation([0, 0], [this.x, this.y]), l7 = this.resolution / this.pixelRatio / t10.resolution, d8 = l7 * this.width, _8 = l7 * this.height, x6 = Math.PI * this.rotation / 180;
    M(a10, a10, r4(o6, n7)), M(a10, a10, r4(d8 / 2, _8 / 2)), h2(a10, a10, -x6), M(a10, a10, r4(-d8 / 2, -_8 / 2)), b2(a10, a10, r4(d8, _8)), i4(this.transforms.displayViewScreenMat3, t10.displayViewMat3, a10);
  }
  getTextures({ forProcessing: t10 = false, useProcessedTexture: e8 = false } = {}) {
    const s10 = e8 ? this._processedTexture ?? this._rasterTexture : this._rasterTexture, r15 = [], i15 = [];
    return s10 ? (this._transformGridTexture && !this.projected && (i15.push(this._transformGridTexture), r15.push("u_transformGrid")), i15.push(s10), r15.push("u_image"), !this._colormapTexture || !e8 && t10 || (i15.push(this._colormapTexture), r15.push("u_colormap")), this._maskTexture && (i15.push(this._maskTexture), r15.push("u_mask")), { names: r15, textures: i15 }) : { names: r15, textures: i15 };
  }
  onAttach() {
    this.invalidateTexture();
  }
  onDetach() {
    this.invalidateTexture();
  }
  updateTexture({ context: t10 }) {
    if (!this.stage) return void this._disposeTextures();
    const e8 = this._isValidSource(this.source);
    e8 && this._colormapTextureInvalidated && (this._colormapTextureInvalidated = false, this._updateColormapTexture(t10)), this._textureInvalidated && (this._textureInvalidated = false, this._createOrDestroyRasterTexture(t10), this._rasterTexture && (e8 ? (this.transformGrid && !this._transformGridTexture && (this._transformGridTexture = i10(t10, this.transformGrid)), this._mask && !this._maskTexture && (this._maskTexture = s3(t10, this._mask, [this.width, this.height]))) : this._rasterTexture.setData(null)), this.suspended || (this.ready(), this.requestRender()));
  }
  updateProcessedTexture(t10 = true) {
    t10 && (this._highlighted = null != this.highlightTexture);
    const { functionTextures: e8 } = this;
    0 !== e8.length && (this.processedTexture = e8.shift(), e8.forEach((t11) => t11?.dispose()), e8.length = 0, this.processed = !!this.processedTexture);
  }
  _createOrDestroyRasterTexture(e8) {
    const s10 = this.source?.extractBands(this.bandIds);
    if (!this._isValidSource(s10)) return void (this._rasterTexture && (this._rasterTexture = r(this._rasterTexture), this._rasterTextureBandIds = null));
    const r15 = !this._isBandIdsChanged(this.bandIds);
    if (this._rasterTexture) {
      if (r15) return;
      this._rasterTexture = r(this._rasterTexture), this._rasterTextureBandIds = null;
    }
    this._supportsBilinearTexture = !!e8.capabilities.textureFloatLinear;
    const i15 = this._getTextureSamplingMethod(this.interpolation), h20 = this.isRendereredSource;
    this._rasterTexture = u4(e8, s10, i15, h20), this.projected = false, this._processed = false, this._rasterTextureBandIds = this.bandIds ? [...this.bandIds] : null;
  }
  _isBandIdsChanged(t10) {
    const e8 = this._rasterTextureBandIds;
    return !(null == e8 && null == t10 || e8 && t10 && e8.join("") === t10.join(""));
  }
  _isValidSource(t10) {
    return null != t10 && t10.pixels?.length > 0;
  }
  _getTextureSamplingMethod(t10) {
    const { type: e8 } = this.symbolizerParameters, s10 = "lut" === e8 && !this.symbolizerParameters.isClassBreaks || "hillshade" === e8 || "stretch" === e8 && 1 === this.symbolizerParameters.bandCount;
    return !this._supportsBilinearTexture || s10 || "bilinear" !== t10 && "cubic" !== t10 ? "nearest" : "bilinear";
  }
  _updateColormapTexture(e8) {
    const s10 = this._colormap, r15 = this.symbolizerParameters.colormap;
    return r15 ? s10 ? r15.length !== s10.length || r15.some((t10, e9) => t10 !== s10[e9]) ? (this._colormapTexture && (this._colormapTexture = r(this._colormapTexture)), this._colormapTexture = o4(e8, r15), void (this._colormap = r15)) : void 0 : (this._colormapTexture = o4(e8, r15), void (this._colormap = r15)) : (this._colormapTexture && (this._colormapTexture = r(this._colormapTexture)), void (this._colormap = null));
  }
  _disposeTextures(e8 = false) {
    e8 ? this.projected && (this._transformGridTexture = r(this._transformGridTexture)) : (this._rasterTexture = r(this._rasterTexture), this._colormapTexture = r(this._colormapTexture), this._transformGridTexture = r(this._transformGridTexture), this._maskTexture = r(this._maskTexture), this._rasterTextureBandIds = null, this._colormap = null, this._colormapTextureInvalidated = true), this._processedTexture = r(this._processedTexture), this._highlightTexture = r(this._highlightTexture);
  }
};

// node_modules/@arcgis/core/views/2d/engine/imagery/RasterTile.js
var i11 = class extends r5 {
  constructor(t10, e8, i15, a10, r15, l7, n7 = null) {
    super(t10, e8, i15, a10, r15, l7), this.bitmap = null, this.bitmap = new m5(n7, null, null), this.bitmap.coordScale = [r15, l7], this.bitmap.once("isReady", () => this.ready());
  }
  destroy() {
    super.destroy(), this.bitmap.destroy(), this.bitmap = null, this.stage = null;
  }
  set stencilRef(t10) {
    this.bitmap.stencilRef = t10;
  }
  get stencilRef() {
    return this.bitmap.stencilRef;
  }
  setTransform(t10) {
    super.setTransform(t10), this.bitmap.transforms.displayViewScreenMat3 = this.transforms.displayViewScreenMat3;
  }
  _createTransforms() {
    return { displayViewScreenMat3: e3(), tileMat3: e3() };
  }
  onAttach() {
    this.bitmap.stage = this.stage;
  }
  onDetach() {
    this.bitmap.stage = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/TextureStatisticsDiffShader.js
var w2 = class extends C3 {
};
__decorate([f2(0, X)], w2.prototype, "position", void 0);
var h7 = class extends I2 {
};
var b4 = class extends w {
};
__decorate([m3(U3)], b4.prototype, "inputTexture", void 0), __decorate([m3(U3)], b4.prototype, "sumTexture", void 0), __decorate([m3(U3)], b4.prototype, "numOfNoDataTexture", void 0), __decorate([m3(C2)], b4.prototype, "numTexels", void 0);
var j = class extends P2 {
  constructor() {
    super(...arguments), this.type = "TextureStatisticsDiffShader";
  }
  vertex(t10) {
    const e8 = t10.position;
    return { uv: e8, glPosition: new _3(g3(e8), 0, 1) };
  }
  fragment(t10) {
    const { inputTexture: e8, numOfNoDataTexture: o6, sumTexture: s10 } = this.config, i15 = new v2(), n7 = wn(e8, t10.uv), p6 = pn(s10, new Z(0, 0), new W(0)), u9 = pn(o6, new Z(0, 0), new W(0)).r, l7 = this.config.numTexels.subtract(u9), a10 = p6.divide(l7), y8 = ln(n7.a, new C2(0)), g12 = new C2(1).subtract(y8).multiply(n7.subtract(a10));
    return i15.fragColor = g12.multiply(g12), i15;
  }
};
__decorate([m3(b4)], j.prototype, "config", void 0), __decorate([__param(0, l4(w2))], j.prototype, "vertex", null), __decorate([__param(0, l4(h7))], j.prototype, "fragment", null);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/TextureStatisticsMinMaxSumShader.js
var b5 = class extends C3 {
};
__decorate([f2(0, X)], b5.prototype, "position", void 0);
var j2 = class extends I2 {
};
var S2 = class extends w {
};
__decorate([m3(U3)], S2.prototype, "minTexture", void 0), __decorate([m3(U3)], S2.prototype, "maxTexture", void 0), __decorate([m3(U3)], S2.prototype, "sumTexture", void 0), __decorate([m3(U3)], S2.prototype, "numOfNoDataTexture", void 0), __decorate([m3(W)], S2.prototype, "width", void 0), __decorate([m3(W)], S2.prototype, "height", void 0), __decorate([m3(W)], S2.prototype, "isFirstPass", void 0);
var F = class extends P2 {
  constructor() {
    super(...arguments), this.type = "TextureStatisticsMinMaxSumShader";
  }
  vertex(t10) {
    const e8 = t10.position;
    return { uv: e8, glPosition: new _3(g3(e8), 0, 1) };
  }
  fragment(t10) {
    const e8 = new v2(), { minTexture: n7, maxTexture: r15, sumTexture: a10, numOfNoDataTexture: i15 } = this.config, s10 = t10.glFragCoord.xy, d8 = new Z(s10.multiply(2)), u9 = new W(0), y8 = pn(n7, d8, u9), f10 = pn(n7, d8.add(new Z(-1, 0)), u9), x6 = pn(n7, d8.add(new Z(0, -1)), u9), g12 = pn(n7, d8.add(new Z(-1, -1)), u9), v7 = M2(M2(y8, M2(f10, new _3(H))), M2(x6, M2(g12, new _3(H)))), T4 = pn(r15, d8, u9), b9 = pn(r15, d8.add(new Z(-1, 0)), u9), j5 = pn(r15, d8.add(new Z(0, -1)), u9), S8 = pn(r15, d8.add(new Z(-1, -1)), u9), F3 = P3(P3(T4, P3(b9, new _3(-H))), P3(j5, P3(S8, new _3(-H)))), C7 = pn(a10, d8, u9), G2 = pn(a10, d8.add(new Z(-1, 0)), u9), k = pn(a10, d8.add(new Z(0, -1)), u9), q3 = pn(a10, d8.add(new Z(-1, -1)), u9), z5 = J2(N2(C7), N2(G2), N2(k), N2(q3)), A2 = pn(i15, d8, u9), B3 = pn(i15, d8.add(new Z(-1, 0)), u9), E4 = pn(i15, d8.add(new Z(0, -1)), u9), H2 = pn(i15, d8.add(new Z(-1, -1)), u9), I4 = new C2(this.config.isFirstPass), J3 = J2(O(A2, I4), O(B3, I4), O(E4, I4), O(H2, I4));
    return e8.fragData0 = v7, e8.fragData1 = F3, e8.fragData2 = z5, e8.fragData3 = J3, e8;
  }
};
function M2(t10, e8) {
  const n7 = ln(t10.a, new C2(0));
  return Ye(t10, e8).multiply(new C2(1).subtract(n7)).add(e8.multiply(n7));
}
function P3(t10, e8) {
  const n7 = ln(t10.a, new C2(0));
  return Xe(t10, e8).multiply(new C2(1).subtract(n7)).add(e8.multiply(n7));
}
function N2(t10) {
  const e8 = ln(t10.a, new C2(0)), n7 = new C2(1).subtract(e8);
  return t10.multiply(n7);
}
function O(t10, e8) {
  const n7 = ln(t10.a, new C2(0)), o6 = new C2(1).subtract(e8);
  return e8.multiply(n7).multiply(new _3(1)).add(o6.multiply(t10));
}
__decorate([m3(S2)], F.prototype, "config", void 0), __decorate([__param(0, l4(b5))], F.prototype, "vertex", null), __decorate([__param(0, l4(j2))], F.prototype, "fragment", null);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/TextureStatisticsStdDevShader.js
var y = class extends C3 {
};
__decorate([f2(0, X)], y.prototype, "position", void 0);
var h8 = class extends I2 {
};
var D2 = class extends w {
};
__decorate([m3(U3)], D2.prototype, "minTexture", void 0), __decorate([m3(U3)], D2.prototype, "maxTexture", void 0), __decorate([m3(U3)], D2.prototype, "sumTexture", void 0), __decorate([m3(U3)], D2.prototype, "numOfNoDataTexture", void 0), __decorate([m3(U3)], D2.prototype, "diffSqTexture", void 0), __decorate([m3(C2)], D2.prototype, "numTexels", void 0);
var S3 = class extends P2 {
  constructor() {
    super(...arguments), this.type = "TextureStatisticsStdDevShader";
  }
  vertex(t10) {
    const e8 = t10.position;
    return { uv: e8, glPosition: new _3(g3(e8), 0, 1) };
  }
  fragment(t10) {
    const e8 = new v2(), { minTexture: o6, maxTexture: i15, numOfNoDataTexture: s10, sumTexture: a10, diffSqTexture: p6 } = this.config, n7 = t10.glFragCoord.xy, u9 = new Z(n7), d8 = new W(0), g12 = pn(o6, u9, d8), v7 = pn(i15, u9, d8), c10 = pn(a10, u9, d8), T4 = pn(s10, u9, d8).r, y8 = pn(p6, u9, d8), h20 = this.config.numTexels.subtract(T4), D4 = c10.divide(h20), S8 = y8.divide(h20), w7 = hn(S8);
    return e8.fragData0 = g12, e8.fragData1 = v7, e8.fragData2 = D4, e8.fragData3 = w7, e8;
  }
};
__decorate([m3(D2)], S3.prototype, "config", void 0), __decorate([__param(0, l4(y))], S3.prototype, "vertex", null), __decorate([__param(0, l4(h8))], S3.prototype, "fragment", null);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/TextureStatisticsSumOfSquaredDiffShader.js
var y2 = class extends C3 {
};
__decorate([f2(0, X)], y2.prototype, "position", void 0);
var h9 = class extends I2 {
};
var v4 = class extends w {
};
__decorate([m3(U3)], v4.prototype, "sumTexture", void 0), __decorate([m3(W)], v4.prototype, "width", void 0), __decorate([m3(W)], v4.prototype, "height", void 0);
var D3 = class extends P2 {
  constructor() {
    super(...arguments), this.type = "TextureStatisticsSumOfSquaredDiffShader";
  }
  vertex(t10) {
    const e8 = t10.position;
    return { uv: e8, glPosition: new _3(g3(e8), 0, 1) };
  }
  fragment(t10) {
    const e8 = new v2(), { sumTexture: o6 } = this.config, s10 = t10.glFragCoord.xy, a10 = new Z(s10.multiply(2)), n7 = new W(0), i15 = pn(o6, a10, n7), p6 = pn(o6, a10.add(new Z(-1, 0)), n7), d8 = pn(o6, a10.add(new Z(0, -1)), n7), m12 = pn(o6, a10.add(new Z(-1, -1)), n7), c10 = J2(i15, p6, d8, m12);
    return e8.fragData0 = c10, e8.fragData1 = new _3(0), e8.fragData2 = new _3(0), e8.fragData3 = new _3(0), e8;
  }
};
__decorate([m3(v4)], D3.prototype, "config", void 0), __decorate([__param(0, l4(y2))], D3.prototype, "vertex", null), __decorate([__param(0, l4(h9))], D3.prototype, "fragment", null);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/TextureStatisticsTechnique.js
var _5 = 1048576;
var F2 = class extends s2 {
  constructor() {
    super(...arguments), this.type = 32, this._width = 0, this._height = 0, this._framebuffers = null, this._minTexture = null, this._maxTexture = null, this._sumTexture = null, this._numOfNoDataTexture = null, this._resultsFramebuffer = null, this._startFramebuffer = null, this._diffFramebuffer = null, this._scaleFbo = null, this.shaders = { textureStatisticsMinMaxSum: new F(), textureStatisticsSum: new D3(), textureStatisticsDiff: new j(), textureStatisticsStdDev: new S3() };
  }
  dispose() {
    this.shaders.textureStatisticsMinMaxSum = null, this._framebuffers && (this._framebuffers.forEach((e8) => r(e8)), this._framebuffers = null), r(this._resultsFramebuffer), r(this._startFramebuffer), r(this._diffFramebuffer), r(this._scaleFbo), r(this._minTexture), r(this._maxTexture), r(this._sumTexture), r(this._numOfNoDataTexture);
  }
  get minValuesTexture() {
    return this._minTexture || null;
  }
  get maxValuesTexture() {
    return this._maxTexture || null;
  }
  get meanValuesTexture() {
    return this._resultsFramebuffer?.getColorTexture(U2) || null;
  }
  get stdDevValuesTexture() {
    return this._resultsFramebuffer?.getColorTexture(P) || null;
  }
  get statsFbo() {
    return this._resultsFramebuffer;
  }
  render(t10, r15) {
    const { context: u9, painter: o6 } = t10;
    let i15 = r15.fbo.width, a10 = r15.fbo.height, f10 = r15.fbo;
    const n7 = u9.gl, l7 = u9.getBoundFramebufferObject();
    if (i15 * a10 > _5 || !u(i15) || !u(a10)) {
      const t11 = i15 / a10;
      if (i15 * a10 > _5) {
        const e8 = Math.max(Math.floor(Math.sqrt(_5 / t11)), 1);
        i15 = Math.max(Math.floor(t11 * e8), 1), a10 = e8;
      }
      if (u(i15) || (i15 = S4(i15)), u(a10) || (a10 = S4(a10)), this._scaleFbo) this._scaleFbo.resize(i15, a10);
      else {
        const { dataType: e8, internalFormat: t12 } = r15.fbo.getColorTexture(D).descriptor, s10 = t12 ?? E.RGBA8;
        this._scaleFbo = w3(u9, i15, a10, e8, s10);
      }
      u9.bindFramebuffer(this._scaleFbo), u9.setViewport(0, 0, i15, a10), o6.blitTexture(u9, f10.getColorTexture(D), 9728), f10 = this._scaleFbo;
    }
    this._updateResources(t10, f10), o6.setPipelineState({ ...e5, color: { write: [true, true, true, true], blendMode: "none" } });
    const h20 = this._applyReductionPass(t10);
    n7.readBuffer(n7.COLOR_ATTACHMENT3), h20.copyToTexture(0, 0, 1, 1, 0, 0, this._numOfNoDataTexture), n7.readBuffer(n7.COLOR_ATTACHMENT2), h20.copyToTexture(0, 0, 1, 1, 0, 0, this._sumTexture), n7.readBuffer(n7.COLOR_ATTACHMENT1), h20.copyToTexture(0, 0, 1, 1, 0, 0, this._maxTexture), n7.readBuffer(n7.COLOR_ATTACHMENT0), h20.copyToTexture(0, 0, 1, 1, 0, 0, this._minTexture);
    const x6 = r15.fbo.getColorTexture(D);
    if (!x6) throw new Error("Start buffer color texture is not available, cannot compute diff.");
    this._computeDiff(t10, x6, this._sumTexture, this._numOfNoDataTexture, i15, a10);
    const T4 = this._applySecondReductionPass(t10, i15, a10).getColorTexture(D);
    this._computeSdtDev(t10, this._minTexture, this._maxTexture, this._sumTexture, this._numOfNoDataTexture, T4, i15, a10), u9.bindFramebuffer(l7), u9.setViewport(0, 0, r15.fbo.width, r15.fbo.height), u9.setDrawBuffers([D]), o6.setPipelineState(e5);
  }
  _applyReductionPass(e8) {
    const { context: t10, painter: r15 } = e8, s10 = this.shaders.textureStatisticsMinMaxSum, u9 = this._framebuffers;
    if (null === u9) throw new Error("Framebuffers are not initialized, cannot apply reduction pass.");
    t10.setDrawBuffers([D, C, U2]);
    const o6 = this._startFramebuffer;
    let i15 = o6.getColorTexture(D), a10 = o6.getColorTexture(C), f10 = o6.getColorTexture(U2), n7 = o6.getColorTexture(P);
    const c10 = u9;
    let T4 = 0;
    for (const d8 of c10) {
      t10.setViewport(0, 0, d8.width, d8.height), t10.bindFramebuffer(d8), t10.setClearColor(0, 0, 0, 0), t10.clear(16384);
      const e9 = { shader: s10, uniforms: { config: { minTexture: { texture: i15, unit: 1 }, maxTexture: { texture: a10, unit: 2 }, sumTexture: { texture: f10, unit: 3 }, numOfNoDataTexture: { texture: n7, unit: 4 }, width: d8.width, height: d8.height, isFirstPass: 0 === T4 ? 1 : 0 } }, defines: null, optionalAttributes: null, useComputeBuffer: false };
      r15.submitDrawMesh(t10, e9, r15.quadMesh), i15 = d8.getColorTexture(D), a10 = d8.getColorTexture(C), f10 = d8.getColorTexture(U2), n7 = d8.getColorTexture(P), T4++;
    }
    return u9.at(-1);
  }
  _applySecondReductionPass(e8, t10, r15) {
    const { context: s10, painter: u9 } = e8, o6 = this.shaders.textureStatisticsSum, i15 = this._framebuffers;
    if (null === i15 || null == this._diffFramebuffer) throw new Error("Framebuffers are not initialized, cannot apply reduction pass.");
    s10.setDrawBuffers([D]);
    let a10 = this._diffFramebuffer.getColorTexture(D);
    const f10 = i15;
    for (const n7 of f10) {
      s10.setViewport(0, 0, n7.width, n7.height), s10.bindFramebuffer(n7), s10.setClearColor(0, 0, 0, 0), s10.clear(16384);
      const e9 = { shader: o6, uniforms: { config: { sumTexture: { texture: a10, unit: 2 }, width: n7.width, height: n7.height } }, defines: null, optionalAttributes: null, useComputeBuffer: false };
      u9.submitDrawMesh(s10, e9, u9.quadMesh), a10 = n7.getColorTexture(D);
    }
    return i15.at(-1);
  }
  _updateResources(e8, t10) {
    const { context: r15 } = e8, s10 = t10.width, u9 = t10.height;
    if (null === this._startFramebuffer) {
      if (!t2().supportsColorBufferFloat) throw new Error("WebGL does not support color buffer float, cannot compute texture statistics.");
      const e9 = t10.getColorTexture(D);
      if (!e9) throw new Error("Input FBO does not have a color attachment 0, cannot compute texture statistics.");
      const o7 = e9.descriptor, { dataType: i15, internalFormat: a10 } = o7, f10 = w3(r15, s10, u9, i15, a10 ?? E.RGBA8, 4), d8 = f10.getColorTexture(D), p6 = f10.getColorTexture(C), b9 = f10.getColorTexture(U2), _8 = f10.getColorTexture(P);
      t10.copyToTexture(0, 0, s10, u9, 0, 0, d8), t10.copyToTexture(0, 0, s10, u9, 0, 0, p6), t10.copyToTexture(0, 0, s10, u9, 0, 0, b9), t10.copyToTexture(0, 0, s10, u9, 0, 0, _8), this._startFramebuffer = f10, this._diffFramebuffer = w3(r15, s10, u9, N.FLOAT, E.RGBA32F), this._resultsFramebuffer = w3(r15, 1, 1, N.FLOAT, E.RGBA32F, 4), this._minTexture = C4(r15, 1, 1, N.FLOAT, E.RGBA32F), this._maxTexture = C4(r15, 1, 1, N.FLOAT, E.RGBA32F), this._sumTexture = C4(r15, 1, 1, N.FLOAT, E.RGBA32F), this._numOfNoDataTexture = C4(r15, 1, 1, N.FLOAT, E.R32F);
    } else {
      const e9 = this._startFramebuffer;
      e9.resize(s10, u9);
      const r16 = e9.getColorTexture(D), o7 = e9.getColorTexture(C), i15 = e9.getColorTexture(U2), a10 = e9.getColorTexture(P);
      t10.copyToTexture(0, 0, s10, u9, 0, 0, r16), t10.copyToTexture(0, 0, s10, u9, 0, 0, o7), t10.copyToTexture(0, 0, s10, u9, 0, 0, i15), t10.copyToTexture(0, 0, s10, u9, 0, 0, a10), this._diffFramebuffer.resize(s10, u9);
    }
    if (this._width === s10 && this._height === u9 && null !== this._framebuffers) return;
    const o6 = (this._framebuffers || []).reverse();
    this._framebuffers = null, this._width = s10, this._height = u9, this._framebuffers = this._updateFramebuffers(r15, s10, u9, o6, 4);
  }
  _updateFramebuffers(e8, t10, s10, u9, o6 = 1) {
    const i15 = [];
    let a10 = t10, f10 = s10;
    for (; a10 > 1 || f10 > 1; ) {
      const t11 = Math.max(1, Math.floor(a10 / 2)), r15 = Math.max(1, Math.floor(f10 / 2)), s11 = g4(e8, t11, r15, u9, o6);
      i15.push(s11), a10 = t11, f10 = r15;
    }
    return i15.at(-1), u9.forEach((e9) => r(e9)), u9.length = 0, i15;
  }
  _computeDiff(e8, t10, r15, s10, u9, o6) {
    const { context: i15, painter: a10 } = e8;
    i15.bindFramebuffer(this._diffFramebuffer), i15.setDrawBuffers([D]), i15.setViewport(0, 0, u9, o6), i15.setClearColor(0, 0, 0, 0), i15.clear(16384);
    const f10 = { shader: this.shaders.textureStatisticsDiff, uniforms: { config: { inputTexture: { texture: t10, unit: 1 }, sumTexture: { texture: r15, unit: 2 }, numOfNoDataTexture: { texture: s10, unit: 3 }, numTexels: u9 * o6 } }, defines: null, optionalAttributes: null, useComputeBuffer: false };
    a10.submitDrawMesh(i15, f10, a10.quadMesh);
  }
  _computeSdtDev(e8, t10, r15, s10, u9, o6, i15, a10) {
    const { context: f10, painter: n7 } = e8;
    f10.bindFramebuffer(this._resultsFramebuffer), f10.setDrawBuffers([D, C, U2, P]), f10.setViewport(0, 0, 1, 1), f10.setClearColor(0, 0, 0, 0), f10.clear(16384);
    const c10 = { shader: this.shaders.textureStatisticsStdDev, uniforms: { config: { minTexture: { texture: t10, unit: 1 }, maxTexture: { texture: r15, unit: 2 }, sumTexture: { texture: s10, unit: 3 }, numOfNoDataTexture: { texture: u9, unit: 4 }, diffSqTexture: { texture: o6, unit: 5 }, numTexels: i15 * a10 } }, defines: null, optionalAttributes: null, useComputeBuffer: false };
    n7.submitDrawMesh(f10, c10, n7.quadMesh);
  }
};
function g4(e8, t10, r15, s10, u9 = 1) {
  let o6 = s10.pop();
  return void 0 !== o6 ? o6.resize(t10, r15) : o6 = w3(e8, t10, r15, N.FLOAT, E.RGBA32F, u9), o6;
}
function w3(e8, t10, r15, s10, u9, o6 = 1) {
  if (o6 < 1 || o6 > 4) throw new Error("Number of color attachments must be between 1 and 4.");
  const i15 = new m2(e8, C4(e8, t10, r15, s10, u9));
  for (let a10 = 1; a10 < o6; a10++) {
    const o7 = C4(e8, t10, r15, s10, u9);
    i15.attachColorTexture(o7, D + a10);
  }
  return i15;
}
function C4(e8, t10, r15, s10, u9) {
  const o6 = new h6(t10, r15);
  return o6.samplingMode = 9728, o6.wrapMode = 33071, o6.pixelFormat = 6408, o6.dataType = s10, o6.internalFormat = u9, new A(e8, o6);
}
function S4(e8) {
  const r15 = i2(e8), s10 = r15 / 2;
  return Math.abs(r15 - e8) < Math.abs(s10 - e8) ? r15 : s10;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/textureUtils.js
function i12(r15, n7) {
  const i15 = new h6(r15, n7);
  return i15.internalFormat = E.RGBA32F, i15.samplingMode = 9728, i15.dataType = N.FLOAT, i15.isImmutable = true, i15.wrapMode = 33071, i15;
}
function u5(e8, t10, r15) {
  const o6 = i12(t10, r15);
  return new A(e8, o6);
}
function s4(e8, t10, n7) {
  const o6 = i12(t10, n7);
  return new m2(e8, o6);
}
function a4(e8) {
  const { symbolizerParameters: t10 } = e8, { type: r15 } = t10, n7 = "lut" === r15 ? "nearest" : e8.interpolation, o6 = "bilinear" === n7 && ("lut" !== r15 && ("stretch" !== r15 || 1 === t10.bandCount));
  return { bilinear: o6, bicubic: "cubic" === n7, nearestOnEdge: o6 };
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/sampleBilinear.js
function m6(m12, p6, r15, u9) {
  const x6 = ze(p6.multiply(r15)), o6 = new Z(new W(x6.x), new W(x6.y)), s10 = new Z(o6.x.add(1), o6.y), f10 = new Z(o6.x, o6.y.add(1)), c10 = new Z(o6.x.add(1), o6.y.add(1)), g12 = pn(m12, o6, new W(0)), j5 = pn(m12, s10, new W(0)), h20 = pn(m12, f10, new W(0)), z5 = pn(m12, c10, new W(0)), b9 = Te(p6.multiply(r15)), k = _e(g12, j5, b9.x), q3 = _e(h20, z5, b9.x), v7 = _e(k, q3, b9.y);
  if (!u9) return v7;
  const A2 = new _3(g12.a, j5.a, h20.a, z5.a), B3 = A2.xy.multiply(A2.zw), C7 = ze(B3.x.multiply(B3.y).add(0.5)), D4 = v7.multiply(C7), E4 = E2(C7).multiply(wn(m12, p6));
  return D4.add(E4);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/projection.js
var v5 = class extends w {
};
function j3(e8, r15) {
  const t10 = wn(r15.transformTexture, e8);
  return new X(t10.r, t10.g);
}
function z3(e8, r15) {
  const { transformTexture: t10, targetImageSize: n7, transformSpacing: i15 } = r15, m12 = ze(e8.multiply(n7)), l7 = new X(4, 1), w7 = ze(m12.divide(i15)).multiply(l7), g12 = Te(m12.add(new X(0.5, 0.5)).divide(i15)), x6 = new Z(ut(w7.x), ut(w7.y)), y8 = new Y(g12, 1);
  return zt(_t(g12.x, g12.y), I3(t10, x6, y8), h10(t10, x6, y8));
}
function I3(e8, r15, t10) {
  const n7 = pn(e8, r15, new W(0)), i15 = new Z(r15.x.add(1), r15.y), m12 = pn(e8, i15, new W(0));
  return new X(we(n7.rgb, t10), we(m12.rgb, t10));
}
function h10(e8, r15, t10) {
  const n7 = new Z(r15.x.add(2), r15.y), i15 = pn(e8, n7, new W(0)), m12 = new Z(r15.x.add(3), r15.y), s10 = pn(e8, m12, new W(0));
  return new X(we(i15.rgb, t10), we(s10.rgb, t10));
}
function T(e8) {
  const r15 = ln(new X(-1e-5, -1e-5), e8).multiply(ln(e8, new X(1.00001, 1.00001))), t10 = E2(r15.x.multiply(r15.y));
  return new J(t10);
}
function G(e8, r15, t10 = false) {
  return r15 ? t10 ? j3(e8, r15) : z3(e8, r15) : e8;
}
function B2(e8, r15, t10) {
  const { bicubic: n7 = false, bilinear: o6 = false, nearestOnEdge: i15 = false } = t10 ?? {};
  return n7 || o6 ? n7 ? m4(r15.texture, e8, r15.srcImageSize) : m6(r15.texture, e8, r15.srcImageSize, i15) : wn(r15.texture, e8);
}
__decorate([m3(U3)], v5.prototype, "transformTexture", void 0), __decorate([m3(X)], v5.prototype, "targetImageSize", void 0), __decorate([m3(X)], v5.prototype, "transformSpacing", void 0), __decorate([m3(X)], v5.prototype, "transformGridSize", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/BaseRasterColorizerShader.js
var _6 = class extends C3 {
};
__decorate([f2(0, X)], _6.prototype, "position", void 0);
var w4 = class extends I2 {
};
var E3 = class extends w {
};
__decorate([m3(U3)], E3.prototype, "texture", void 0), __decorate([m3(rt)], E3.prototype, "dvsMat3", void 0), __decorate([m3(X)], E3.prototype, "coordScale", void 0), __decorate([m3(X)], E3.prototype, "srcImageSize", void 0), __decorate([m3(C2)], E3.prototype, "opacity", void 0);
var O2 = class extends w {
};
__decorate([m3(U3)], O2.prototype, "maskTexture", void 0);
var S5 = class extends w {
};
__decorate([m3(U3)], S5.prototype, "highlightTexture", void 0);
var T2 = class extends P2 {
  constructor() {
    super(...arguments), this.applyProjection = true, this.lookupProjection = false, this.bilinear = false, this.bicubic = false, this.nearestOnEdge = false, this.applyPixelMask = false, this.applyPixelHighlights = false;
  }
  vertex(t10) {
    const o6 = t10.position, { dvsMat3: i15, coordScale: e8 } = this.config, p6 = i15.multiply(new Y(o6.multiply(e8), 1));
    return { uv: o6, glPosition: new _3(p6, 1) };
  }
  fragment(t10) {
    const o6 = new v2(), i15 = G(t10.uv, this.applyProjection ? this.projectionConfig : void 0, this.lookupProjection);
    let p6 = this._colorize(i15, t10.uv);
    this.applyPixelHighlights && (p6 = this._highlightPixels(t10.uv, p6));
    const r15 = zt(T(i15), new _3(0), p6);
    let s10 = r15.a.multiply(this.config.opacity);
    if (this.applyPixelMask) {
      const o7 = this._getPixelMask(t10.uv);
      s10 = s10.multiply(o7);
    }
    return o6.fragColor = new _3(r15.rgb, 1).multiply(s10), o6;
  }
  _getPixel(t10) {
    const { config: o6, bicubic: i15, bilinear: e8, nearestOnEdge: p6 } = this;
    return B2(t10, o6, { bicubic: i15, bilinear: e8, nearestOnEdge: p6 });
  }
  _getPixelMask(t10) {
    const { maskTexture: o6 } = this.pixelMaskConfig, i15 = wn(o6, t10);
    return cn(i15.a);
  }
  _highlightPixels(t10, o6) {
    const { highlightTexture: i15 } = this.highlightConfig, e8 = wn(i15, t10), p6 = cn(e8.a);
    return _e(o6, e8, p6);
  }
};
__decorate([_4], T2.prototype, "applyProjection", void 0), __decorate([_4], T2.prototype, "lookupProjection", void 0), __decorate([_4], T2.prototype, "bilinear", void 0), __decorate([_4], T2.prototype, "bicubic", void 0), __decorate([_4], T2.prototype, "nearestOnEdge", void 0), __decorate([_4], T2.prototype, "applyPixelMask", void 0), __decorate([_4], T2.prototype, "applyPixelHighlights", void 0), __decorate([m3(E3)], T2.prototype, "config", void 0), __decorate([g2(v5)], T2.prototype, "projectionConfig", void 0), __decorate([g2(O2)], T2.prototype, "pixelMaskConfig", void 0), __decorate([g2(S5)], T2.prototype, "highlightConfig", void 0), __decorate([__param(0, l4(_6))], T2.prototype, "vertex", null), __decorate([__param(0, l4(w4))], T2.prototype, "fragment", null);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/lut.js
var n4 = class extends w {
};
function c3(o6, r15, t10, i15 = true) {
  const { colormapTexture: n7, colormapOffset: c10, colormapMaxIndex: s10 } = t10, u9 = o6.r.multiply(r15).subtract(c10), x6 = se(u9, new C2(0), s10), f10 = new X(x6.add(0.5).divide(s10.add(1)), 0), y8 = wn(n7, f10), v7 = new _3(y8.rgb, y8.a.multiply(o6.a));
  if (i15) return v7;
  const w7 = ln(new C2(0), u9).multiply(ln(u9, t10.colormapMaxIndex));
  return v7.multiply(w7);
}
__decorate([m3(U3)], n4.prototype, "colormapTexture", void 0), __decorate([m3(C2)], n4.prototype, "colormapOffset", void 0), __decorate([m3(C2)], n4.prototype, "colormapMaxIndex", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/RasterColorizerLUTShader.js
var p2 = class extends T2 {
  constructor() {
    super(...arguments), this.type = "RasterColorizerLUTShader";
  }
  _colorize(r15) {
    const o6 = this._getPixel(r15);
    return c3(o6, new C2(1), this.colormapConfig, false);
  }
};
__decorate([m3(n4)], p2.prototype, "colormapConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/colorConversion.js
function a5(r15) {
  const u9 = new _3(0, -1 / 3, 2 / 3, -1), i15 = zt(Yt(r15.y, r15.z), new _3(r15.zy, u9.wz), new _3(r15.yz, u9.xy)), a10 = zt(Yt(r15.x, i15.x), new _3(i15.xyw, r15.x), new _3(r15.x, i15.yzx)), c10 = a10.x.subtract(Ye(a10.w, a10.y)), l7 = new C2(1e-10), s10 = a10.w.subtract(a10.y), z5 = c10.multiply(6).add(l7), o6 = Qt(s10.divide(z5).add(a10.z)), p6 = a10.x.add(l7), m12 = Ye(c10.divide(p6), new C2(1));
  return new Y(o6, m12, a10.x);
}
function c4(n7) {
  const t10 = new _3(1, 2 / 3, 1 / 3, 3), w7 = Qt(Te(n7.xxx.add(t10.xyz)).multiply(6).subtract(t10.www)), e8 = se(w7.subtract(t10.xxx), new Y(0, 0, 0), new Y(1));
  return n7.z.multiply(_e(t10.xxx, e8, n7.y));
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/surface.js
var a6 = class extends w {
};
function y3(n7) {
  const t10 = Qt(n7), e8 = ln(t10, new X(1, 1)).multiply(t10), o6 = new C2(2).subtract(t10), r15 = ln(new C2(1), t10).multiply(o6);
  return e8.add(r15);
}
function m7(n7, t10, e8) {
  const l7 = new C2(1).divide(e8), p6 = wn(n7, y3(l7.multiply(new X(-1, -1)).add(t10))), w7 = wn(n7, y3(l7.multiply(new X(0, -1)).add(t10))), c10 = wn(n7, y3(l7.multiply(new X(1, -1)).add(t10))), u9 = wn(n7, y3(l7.multiply(new X(-1, 0)).add(t10))), a10 = wn(n7, y3(t10)), m12 = wn(n7, y3(l7.multiply(new X(1, 0)).add(t10))), f10 = wn(n7, y3(l7.multiply(new X(-1, 1)).add(t10))), Z3 = wn(n7, y3(l7.multiply(new X(0, 1)).add(t10))), x6 = wn(n7, y3(l7.multiply(new X(1, 1)).add(t10))), z5 = new _3(p6.a, w7.a, c10.a, u9.a), A2 = new _3(m12.a, f10.a, Z3.a, x6.a), g12 = z5.multiply(A2), h20 = g12.xy.multiply(g12.zw), v7 = h20.x.multiply(h20.y).multiply(a10.a), b9 = new B(new C2(0), 10);
  return b9[0] = p6.r, b9[1] = w7.r, b9[2] = c10.r, b9[3] = u9.r, b9[4] = a10.r, b9[5] = m12.r, b9[6] = f10.r, b9[7] = Z3.r, b9[8] = x6.r, b9[9] = v7, b9;
}
function f3(n7, t10) {
  const e8 = new _3(n7[5], n7[3], n7[7], n7[1]).multiply(2), i15 = new Y(n7[2], e8[0], n7[8]), o6 = new Y(n7[0], e8[1], n7[6]), d8 = we(i15.subtract(o6), new Y(1)), l7 = new Y(n7[6], e8[2], n7[8]), c10 = new Y(n7[0], e8[3], n7[2]), u9 = we(l7.subtract(c10), new Y(1));
  return new X(d8, u9).multiply(t10);
}
function Z2(n7, t10, e8) {
  const { factor: o6 } = t10, s10 = f3(n7, o6), d8 = hn(we(s10, s10).add(1)), c10 = n7[9], { sinZsinAs: u9, sinZcosAs: a10, cosZs: y8, weights: m12 } = t10;
  if (!e8) {
    const n8 = x2({ sinZsinA: u9[0], sinZcosA: a10[0], cosZ: y8[0], weights: new C2(1), dzxy: s10, dzd: d8 });
    return new _3(n8, n8, n8, c10);
  }
  const Z3 = x2({ sinZsinA: new Y(u9[0], u9[1], u9[2]), sinZcosA: new Y(a10[0], a10[1], a10[2]), cosZ: new Y(y8[0], y8[1], y8[2]), weights: new Y(m12[0], m12[1], m12[2]), dzxy: s10, dzd: d8 }), z5 = x2({ sinZsinA: new Y(u9[3], u9[4], u9[5]), sinZcosA: new Y(a10[3], a10[5], a10[5]), cosZ: new Y(y8[3], y8[4], y8[5]), weights: new Y(m12[3], m12[4], m12[5]), dzxy: s10, dzd: d8 }), A2 = we(Z3.add(z5), new Y(1));
  return new _3(A2, A2, A2, c10);
}
function x2(n7) {
  const t10 = n7.sinZsinA.multiply(n7.dzxy.y), e8 = n7.sinZcosA.multiply(n7.dzxy.x), o6 = t10.subtract(e8), s10 = n7.cosZ.add(o6).divide(n7.dzd);
  return s10.multiply(ln(new C2(0), s10)).multiply(n7.weights);
}
function z4(n7, t10) {
  const { pixelSizeFactor: e8 } = n7, i15 = [n7.factor[0] / t10[0], n7.factor[1] / t10[1]];
  if (e8 > 0) {
    const { zFactor: o6, pixelSizePower: s10, gcsFactor: r15 } = n7, d8 = t10[0] * r15, l7 = t10[1] * r15;
    i15[0] = (o6 + d8 ** s10 * e8) / (8 * d8), i15[1] = (o6 + l7 ** s10 * e8) / (8 * l7);
  }
  return i15;
}
__decorate([m3(B.ofType(C2, 6))], a6.prototype, "sinZcosAs", void 0), __decorate([m3(B.ofType(C2, 6))], a6.prototype, "sinZsinAs", void 0), __decorate([m3(B.ofType(C2, 6))], a6.prototype, "cosZs", void 0), __decorate([m3(B.ofType(C2, 6))], a6.prototype, "weights", void 0), __decorate([m3(C2)], a6.prototype, "minValue", void 0), __decorate([m3(C2)], a6.prototype, "maxValue", void 0), __decorate([m3(X)], a6.prototype, "factor", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/RasterColorizerShadedReliefShader.js
var g5 = class extends T2 {
  constructor() {
    super(...arguments), this.type = "RasterColorizerShadedReliefShader", this.applyColormap = false, this.isMultidirectional = false;
  }
  _colorize(o6) {
    const { texture: i15 } = this.config, r15 = m7(i15, o6, this.config.srcImageSize), t10 = Z2(r15, this.hillshadeConfig, this.isMultidirectional);
    if (!this.applyColormap) return new _3(t10.x, t10.x, t10.x, t10.a);
    const { minValue: p6, maxValue: d8 } = this.hillshadeConfig, u9 = this._getPixel(o6), g12 = d8.subtract(p6), x6 = u9.r.subtract(p6), y8 = se(x6.divide(g12), new C2(0), new C2(1)), C7 = c3(new _3(y8, y8, y8, 1), new C2(255), this.colormapConfig), w7 = a5(C7.xyz), j5 = c4(new Y(w7.xy, t10.x));
    return new _3(j5, C7.a.multiply(t10.a));
  }
};
__decorate([_4], g5.prototype, "applyColormap", void 0), __decorate([_4], g5.prototype, "isMultidirectional", void 0), __decorate([m3(a6)], g5.prototype, "hillshadeConfig", void 0), __decorate([g2(n4)], g5.prototype, "colormapConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/math.js
function w5(n7) {
  const t10 = cn(n7), e8 = n7.add(Qt(t10).subtract(1));
  return t10.multiply(t10).divide(e8);
}
function a7(n7) {
  return new _3(ze(n7.rgb.add(0.5)), n7.a);
}
function p3(n7, t10) {
  return ln(t10.x, n7).multiply(ln(n7, t10.y));
}
function d4(o6, u9) {
  let i15 = new Y(0, 0, 0);
  const s10 = new Y(o6);
  for (let r15 = 0; r15 < l3 / 3; r15++) {
    const n7 = 6 * r15, l7 = new Y(u9[n7], u9[n7 + 2], u9[n7 + 4]), o7 = new Y(u9[n7 + 1], u9[n7 + 3], u9[n7 + 5]);
    i15 = i15.add(ln(l7, s10).multiply(ln(s10, o7)));
  }
  return cn(we(i15, new Y(1, 1, 1)));
}
function f4(n7, o6, u9) {
  const i15 = new Y(n7);
  let w7 = new Y(0, 0, 0), a10 = new C2(0);
  for (let r15 = 0; r15 < u9 / 3; r15++) {
    const n8 = 9 * r15, l7 = new Y(o6[n8], o6[n8 + 3], o6[n8 + 6]), u10 = new Y(o6[n8 + 1], o6[n8 + 4], o6[n8 + 7]), s10 = ln(l7, i15).multiply(ln(i15, u10)), p6 = new Y(o6[n8 + 2], o6[n8 + 5], o6[n8 + 8]);
    a10 = _e(a10, p6.x, s10.x), a10 = _e(a10, p6.y, s10.y), a10 = _e(a10, p6.z, s10.z), w7 = w7.add(s10);
  }
  return { mapValue: a10, includeMask: cn(we(w7, new Y(1, 1, 1))) };
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/stretch.js
var b6 = class extends w {
};
__decorate([m3(C2)], b6.prototype, "minOutput", void 0), __decorate([m3(C2)], b6.prototype, "maxOutput", void 0), __decorate([m3(Y)], b6.prototype, "minCutOff", void 0), __decorate([m3(Y)], b6.prototype, "maxCutOff", void 0), __decorate([m3(Y)], b6.prototype, "factor", void 0), __decorate([m3(Y)], b6.prototype, "gamma", void 0), __decorate([m3(Y)], b6.prototype, "gammaCorrection", void 0);
var O3 = class extends w {
};
function g6(t10, r15) {
  const { minCutOff: o6, maxCutOff: e8, factor: i15, minOutput: u9 } = r15;
  return se(t10, o6, e8).subtract(o6).multiply(i15).add(u9);
}
function C5(t10, r15) {
  const { minCutOff: o6, maxCutOff: e8, minOutput: i15, maxOutput: u9, gamma: m12, gammaCorrection: p6 } = r15, a10 = se(t10, o6, e8).subtract(o6), v7 = e8.subtract(o6), y8 = a10.divide(v7), b9 = ln(new C2(1), m12), O4 = cn(m12.subtract(1)), g12 = u9.subtract(i15), C7 = new Y(1), T4 = We(C7.divide(g12), y8.multiply(p6)), w7 = E2(b9.multiply(O4).multiply(T4)), h20 = We(y8, C7.divide(m12)), j5 = w7.multiply(g12).multiply(h20).add(i15);
  return se(j5, i15, u9);
}
function T3(t10, r15, o6, i15 = 255) {
  const u9 = o6 ? C5(t10.rgb, r15).divide(i15) : g6(t10.rgb, r15);
  return new _3(u9, t10.a);
}
function w6(t10, r15, o6, d8, s10) {
  const f10 = new Z(0, 0), c10 = new W(0);
  let l7 = pn(o6.minTexture, f10, c10).rgb, v7 = pn(o6.maxTexture, f10, c10).rgb;
  if (s10) {
    const t11 = pn(o6.meanTexture, f10, c10).rgb, r16 = pn(o6.stddevTexture, f10, c10).rgb.multiply(o6.numberOfStandardDeviations);
    l7 = Xe(l7, t11.subtract(r16)), v7 = Ye(v7, t11.add(r16));
  }
  const x6 = v7.subtract(l7), b9 = new Y(w5(x6.x), w5(x6.y), w5(x6.z)), O4 = r15.maxOutput.subtract(r15.minOutput).multiply(b9), T4 = { ...r15, minCutOff: l7, maxCutOff: v7, factor: O4 }, w7 = d8 ? C5(t10.rgb, T4).divide(255) : g6(t10.rgb, T4);
  return new _3(w7, t10.a);
}
__decorate([m3(U3)], O3.prototype, "minTexture", void 0), __decorate([m3(U3)], O3.prototype, "maxTexture", void 0), __decorate([m3(U3)], O3.prototype, "meanTexture", void 0), __decorate([m3(U3)], O3.prototype, "stddevTexture", void 0), __decorate([m3(C2)], O3.prototype, "numberOfStandardDeviations", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/RasterColorizerStretchShader.js
var c5 = class extends T2 {
  constructor() {
    super(...arguments), this.type = "RasterColorizerStretchShader", this.isMultiband = true, this.applyColormap = false, this.useGamma = false, this.noOp = false, this.draStretchType = 0;
  }
  _colorize(t10) {
    const o6 = this._getPixel(t10);
    if (this.noOp) return o6;
    const { draStretchType: r15, stretchConfig: i15, useGamma: p6, statisticsConfig: h20 } = this;
    let n7 = 0 === r15 ? T3(o6, i15, p6) : w6(o6, i15, h20, p6, 2 === r15);
    if (this.isMultiband) return n7;
    if (n7 = new _3(n7.rrr, n7.a), this.applyColormap) {
      const t11 = this.useGamma ? 255 : 1;
      n7 = c3(n7, new C2(t11), this.colormapConfig);
    }
    return n7;
  }
};
__decorate([_4], c5.prototype, "isMultiband", void 0), __decorate([_4], c5.prototype, "applyColormap", void 0), __decorate([_4], c5.prototype, "useGamma", void 0), __decorate([_4], c5.prototype, "noOp", void 0), __decorate([_4], c5.prototype, "draStretchType", void 0), __decorate([m3(b6)], c5.prototype, "stretchConfig", void 0), __decorate([g2(n4)], c5.prototype, "colormapConfig", void 0), __decorate([g2(O3)], c5.prototype, "statisticsConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/RasterColorizerTechnique.js
var h11 = 160;
var p4 = /* @__PURE__ */ new Set(["f32", "f64", "u16", "s16", "u32", "s32"]);
var f5 = class extends s2 {
  constructor() {
    super(...arguments), this.name = "BrushRasterColorizer", this.type = 0, this.shaders = { lut: new p2(), stretch: new c5(), shadedRelief: new g5() }, this._mosaicFbo = null, this._statisticsTechnique = null, this._draTimer = 0;
  }
  shutdown(t10) {
    super.shutdown(t10), this._mosaicFbo = r(this._mosaicFbo), this._statisticsTechnique = r(this._statisticsTechnique);
  }
  render(t10, i15) {
    const s10 = i15.bitmaps.some(g7);
    s10 || (this._mosaicFbo = r(this._mosaicFbo), this._statisticsTechnique = r(this._statisticsTechnique));
    const o6 = s10 ? this._computeStatisticsTextures(t10, i15) : void 0;
    for (const e8 of i15.bitmaps) {
      if (!e8.source || e8.suspended) continue;
      t10.timeline.begin(this.name);
      const { painter: i16 } = t10;
      i16.setPipelineState({ depth: false, stencil: { test: { mask: 255, compare: 514, op: { fail: 7680, zFail: 7680, zPass: 7680 } }, write: false }, color: { write: [true, true, true, true], blendMode: "composite" } }), e8.updateTexture(t10), e8.updateProcessedTexture();
      const { type: s11 } = e8.symbolizerParameters, r15 = "stretch" === s11 ? this._getStretchOptions(e8, o6) : "lut" === s11 ? this._getLutOptions(e8) : this._getShadedReliefOptions(e8);
      "bilinear" !== e8.interpolation || t10.context.capabilities.textureFloatLinear || (r15.defines.bilinear = true), i16.submitDrawMesh(t10.context, r15, i16.quadMesh, e8), t10.timeline.end(this.name);
    }
  }
  _computeStatisticsTextures(e8, t10) {
    this._statisticsTechnique ??= new F2();
    const s10 = this._statisticsTechnique;
    let o6 = has("esri-2d-dra-delay");
    if (null == o6) {
      const e9 = t10.bitmaps.find(g7), { stretchType: i15, bandCount: s11 } = e9.symbolizerParameters, { pixelType: r15 } = e9.source;
      "minMax" === i15 && s11 >= 3 && p4.has(r15) && (o6 = h11);
    }
    if (o6) {
      const i15 = performance.now();
      (i15 - this._draTimer >= o6 || e8.stationary || !s10.minValuesTexture) && (this._mosaic(e8, t10), s10.render(e8, { fbo: this._mosaicFbo }), this._draTimer = i15);
    } else this._mosaic(e8, t10), s10.render(e8, { fbo: this._mosaicFbo });
    return { minTexture: s10.minValuesTexture, maxTexture: s10.maxValuesTexture, meanTexture: s10.meanValuesTexture, stddevTexture: s10.stdDevValuesTexture };
  }
  _mosaic(e8, t10) {
    const { context: i15, painter: s10 } = e8, o6 = i15.getBoundFramebufferObject();
    if (this._mosaicFbo) this._mosaicFbo.resize(o6.width, o6.height);
    else {
      const e9 = d5(i15, o6.width, o6.height);
      this._mosaicFbo = new m2(i15, e9);
    }
    i15.bindFramebuffer(this._mosaicFbo);
    const r15 = "RasterColorizerMosaic";
    for (const n7 of t10.bitmaps) {
      if (!g7(n7)) continue;
      e8.timeline.begin(r15), s10.setPipelineState({ depth: false, stencil: { test: { mask: 255, compare: 514, op: { fail: 7680, zFail: 7680, zPass: 7680 } }, write: false }, color: { write: [true, true, true, true], blendMode: "composite" } });
      const t11 = n7.interpolation;
      n7.interpolation = "nearest", n7.updateTexture(e8), n7.updateProcessedTexture();
      const i16 = this._getStretchOptions(n7);
      i16.defines.noOp = true, s10.submitDrawMesh(e8.context, i16, s10.quadMesh, n7), n7.interpolation = t11, e8.timeline.end(r15);
    }
    i15.bindFramebuffer(o6);
  }
  _getLutOptions(e8) {
    const { config: t10, projectionConfig: i15, colormapConfig: o6, pixelMaskConfig: r15, highlightConfig: n7, projectionDefines: a10 } = this._getCommonConfig(e8), u9 = a4(e8);
    return { shader: this.shaders.lut, uniforms: { projectionConfig: i15, config: t10, colormapConfig: o6, pixelMaskConfig: r15, highlightConfig: n7 }, defines: { ...a10, ...u9, applyPixelMask: !!r15, applyPixelHighlights: !!n7 }, optionalAttributes: null, useComputeBuffer: false };
  }
  _getStretchOptions(e8, t10) {
    const i15 = e8.symbolizerParameters, { config: o6, projectionConfig: r15, colormapConfig: n7, pixelMaskConfig: a10, highlightConfig: u9, projectionDefines: c10, textureUnit: m12 } = this._getCommonConfig(e8), l7 = a4(e8), h20 = t10 ? { minTexture: { texture: t10.minTexture, unit: m12 }, maxTexture: { texture: t10.maxTexture, unit: m12 + 1 }, meanTexture: { texture: t10.meanTexture, unit: m12 + 2 }, stddevTexture: { texture: t10.stddevTexture, unit: m12 + 3 }, numberOfStandardDeviations: i15.numberOfStandardDeviations || 2 } : void 0, p6 = t10 ? "standardDeviation" === i15.stretchType ? 2 : 1 : 0;
    return { shader: this.shaders.stretch, uniforms: { projectionConfig: r15, config: o6, stretchConfig: i15, colormapConfig: n7, pixelMaskConfig: a10, highlightConfig: u9, statisticsConfig: h20 }, defines: { ...c10, ...l7, isMultiband: i15.bandCount > 1, applyColormap: !!n7, useGamma: i15.useGamma, noOp: e8.isRendereredSource && !e8.processed, applyPixelMask: !!a10, applyPixelHighlights: !!u9, draStretchType: p6 }, optionalAttributes: null, useComputeBuffer: false };
  }
  _getShadedReliefOptions(e8) {
    const t10 = e8.symbolizerParameters, { config: i15, projectionConfig: o6, colormapConfig: r15, pixelMaskConfig: n7, highlightConfig: a10, projectionDefines: u9 } = this._getCommonConfig(e8), c10 = a4(e8);
    return { shader: this.shaders.shadedRelief, uniforms: { projectionConfig: o6, config: i15, hillshadeConfig: t10, colormapConfig: r15, pixelMaskConfig: n7, highlightConfig: a10 }, defines: { ...u9, ...c10, isMultidirectional: t10.hillshadeType > 0, applyColormap: !!r15, applyPixelMask: !!n7, applyPixelHighlights: !!a10 }, optionalAttributes: null, useComputeBuffer: false };
  }
  _getCommonConfig(e8) {
    const { coordScale: t10, computedOpacity: i15, transforms: s10 } = e8, { names: o6, textures: r15 } = e8.getTextures({ useProcessedTexture: e8.processed }), n7 = r15[o6.indexOf("u_image")], a10 = e8.getRasterTextureSize();
    let u9 = 0;
    const c10 = { texture: { texture: n7, unit: u9++ }, dvsMat3: s10.displayViewScreenMat3, coordScale: t10, srcImageSize: a10, opacity: i15 }, m12 = r15[o6.indexOf("u_transformGrid")], { transformGrid: l7 } = e8, h20 = !(!m12 || !l7), p6 = h20 ? { transformTexture: { texture: m12, unit: u9++ }, targetImageSize: [e8.width, e8.height], transformSpacing: l7.spacing, transformGridSize: l7.size } : void 0, f10 = r15[o6.indexOf("u_colormap")], { colormap: d8, colormapOffset: g12 } = e8.symbolizerParameters, x6 = f10 && d8 ? { colormapTexture: { texture: f10, unit: u9++ }, colormapOffset: g12 ?? 0, colormapMaxIndex: d8.length / 4 - 1 } : void 0, T4 = r15[o6.indexOf("u_mask")], b9 = T4 ? { maskTexture: { texture: T4, unit: u9++ } } : void 0, { highlightTexture: C7 } = e8;
    return { config: c10, projectionConfig: p6, colormapConfig: x6, pixelMaskConfig: b9, highlightConfig: C7 ? { highlightTexture: { texture: C7, unit: u9++ } } : void 0, projectionDefines: { applyProjection: h20, lookupProjection: h20 && 1 === l7.spacing[0] }, textureUnit: u9 };
  }
};
function d5(e8, t10, i15) {
  const s10 = new h6(t10, i15);
  return s10.internalFormat = E.RGBA32F, s10.samplingMode = 9728, s10.dataType = N.FLOAT, s10.wrapMode = 33071, new A(e8, s10);
}
function g7(e8) {
  return !e8.suspended && null != e8.source && !e8.isRendereredSource && "stretch" === e8.symbolizerParameters.type && !!e8.symbolizerParameters.dynamicRangeAdjustment;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/RasterRangeHighlightShader.js
var c6 = class extends w {
};
__decorate([m3(B.ofType(C2, 2 * l3))], c6.prototype, "ranges", void 0), __decorate([m3(rt)], c6.prototype, "bandSwap", void 0), __decorate([m3(_3)], c6.prototype, "color", void 0);
var f6 = class extends T2 {
  constructor() {
    super(...arguments), this.type = "RasterRangeHighlightShader", this.hasExistingHighlights = false;
  }
  _colorize(t10, i15) {
    const o6 = this._getPixel(t10), { ranges: r15, color: s10, bandSwap: a10 } = this.rangeHighlightConfig, l7 = a10.multiply(o6.rgb).x, n7 = d4(l7, r15).multiply(cn(o6.a)), m12 = _e(new _3(0), s10, n7);
    if (this.hasExistingHighlights) {
      const { highlightTexture: t11 } = this.highlightConfig, o7 = wn(t11, i15);
      return _e(o7, m12, n7);
    }
    return m12;
  }
};
__decorate([_4], f6.prototype, "hasExistingHighlights", void 0), __decorate([m3(c6)], f6.prototype, "rangeHighlightConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/RasterHighlightTechnique.js
var g8 = class extends s2 {
  constructor() {
    super(...arguments), this.name = "BrushRasterHighlight", this.type = 2, this.shaders = { range: new f6() };
  }
  shutdown(e8) {
    super.shutdown(e8), this._fbo?.dispose(), this._fbo = void 0;
  }
  render(t10, r15) {
    const { context: o6 } = t10;
    if (!this._fbo) {
      const i15 = u6(t10.context, o2, o2);
      this._fbo = new m2(o6, i15);
    }
    const s10 = o6.getBoundFramebufferObject(), a10 = o6.getViewport(), { pixelHighlightOptions: h20 } = t10;
    for (const n7 of r15.bitmaps) {
      if (!h20 || !n7.source || n7.highlighted || n7.suspended || n7.isRendereredSource) continue;
      const r16 = n7.bandIds?.length ? n7.bandIds.indexOf(h20.bandId) : 0;
      if (r16 < 0 || r16 > 2) continue;
      t10.timeline.begin(this.name);
      const { painter: s11 } = t10;
      s11.setPipelineState({ depth: false, stencil: { test: false, write: false }, color: { write: [true, true, true, true], blendMode: "custom", blendParameters: { srcRGB: 1, dstRGB: 0, srcAlpha: 1, dstAlpha: 0 } } }), n7.updateTexture(t10), n7.updateProcessedTexture(false);
      const { config: a11, projectionConfig: g12, highlightConfig: c10, projectionDefines: d8 } = this._getCommonConfig(n7), f10 = a4(n7);
      "bilinear" !== n7.interpolation || t10.context.capabilities.textureFloatLinear || (f10.bilinear = true);
      const p6 = new Float32Array(9);
      p6[3 * r16] = 1;
      const l7 = { ...h20, bandSwap: p6 }, m12 = { shader: this.shaders.range, uniforms: { projectionConfig: g12, config: a11, rangeHighlightConfig: l7, highlightConfig: c10 }, defines: { ...d8, ...f10, applyPixelMask: false, applyPixelHighlights: false, hasExistingHighlights: !!c10 }, optionalAttributes: null, useComputeBuffer: false };
      o6.bindFramebuffer(this._fbo), o6.setViewport(0, 0, o2, o2), s11.submitDrawMesh(t10.context, m12, s11.quadMesh);
      const x6 = u6(t10.context, o2, o2);
      this._fbo.copyToTexture(0, 0, o2, o2, 0, 0, x6), n7.highlightTexture = x6, t10.timeline.end(this.name);
    }
    o6.bindFramebuffer(s10), o6.setViewport(a10.x, a10.y, a10.width, a10.height);
  }
  _getCommonConfig(e8) {
    const { names: t10, textures: i15 } = e8.getTextures({ forProcessing: true, useProcessedTexture: e8.processed }), r15 = i15[t10.indexOf("u_image")], o6 = e8.getRasterTextureSize(), s10 = { texture: { texture: r15, unit: 0 }, dvsMat3: new Float32Array([2, 0, 0, 0, 2, 0, -1, -1, 0]), coordScale: [1, 1], srcImageSize: o6, opacity: 1 }, n7 = i15[t10.indexOf("u_transformGrid")], { transformGrid: a10 } = e8, h20 = !(!n7 || !a10), g12 = h20 ? { transformTexture: { texture: n7, unit: 1 }, targetImageSize: [e8.width, e8.height], transformSpacing: a10.spacing, transformGridSize: a10.size } : void 0, { highlightTexture: u9 } = e8;
    return { config: s10, projectionConfig: g12, highlightConfig: u9 ? { highlightTexture: { texture: u9, unit: 2 } } : void 0, projectionDefines: { applyProjection: h20, lookupProjection: h20 && 1 === a10.spacing[0] } };
  }
};
function u6(e8, t10, i15) {
  const r15 = new h6(t10, i15);
  return r15.internalFormat = E.RGBA8, r15.samplingMode = 9728, r15.dataType = N.UNSIGNED_BYTE, r15.isImmutable = true, r15.wrapMode = 33071, new A(e8, r15);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/BaseRasterProcessorTechnique.js
var i13 = class extends s2 {
  shutdown(e8) {
    super.shutdown(e8), this._fbo?.dispose(), this._fbo = void 0;
  }
  render(r15, i15) {
    const { rasterFunction: a10 } = r15;
    if (!a10) return;
    const { context: u9 } = r15, m12 = "indexedColormap" in a10.parameters ? o4(u9, a10.parameters.indexedColormap) : void 0, p6 = "Reproject" === a10.name, d8 = u9.getBoundFramebufferObject(), c10 = u9.getViewport();
    for (const o6 of i15.bitmaps) {
      const d9 = p6 ? !(o6.rasterTexture && o6.projected) : !o6.processed;
      if (!o6.source || !d9 || o6.suspended) continue;
      r15.timeline.begin(this.name);
      const { painter: c11 } = r15;
      c11.setPipelineState({ depth: false, stencil: { test: false, write: false }, color: { write: [true, true, true, true], blendMode: "custom", blendParameters: { srcRGB: 1, dstRGB: 0, srcAlpha: 1, dstAlpha: 0 } } }), p6 || (o6.processedTexture = r(o6.processedTexture)), o6.updateTexture(r15);
      const [l7, g12] = o6.getRasterTextureSize(p6), f10 = l7 === o2 && g12 === o2, h20 = f10 ? i15.processorFbo : s4(u9, l7, g12);
      u9.bindFramebuffer(h20), u9.setViewport(0, 0, h20.width, h20.height), this._process(r15, o6, m12);
      const x6 = u5(r15.context, l7, g12);
      if (h20.copyToTexture(0, 0, l7, g12, 0, 0, x6), p6) o6.rasterTexture = x6;
      else {
        const e8 = r15.hasBranches ? a10.id : 0;
        o6.functionTextures[e8]?.dispose(), o6.functionTextures[e8] = x6;
      }
      f10 || h20.dispose(), r15.timeline.end(this.name);
    }
    m12?.dispose(), u9.bindFramebuffer(d8), u9.setViewport(c10.x, c10.y, c10.width, c10.height);
  }
  _getCommonConfig(e8, t10) {
    const { rasterFunction: r15, hasBranches: n7 } = e8, { raster: s10, rasters: o6 } = r15.parameters, i15 = n7 ? s10?.id ?? o6?.find((e9) => "Constant" !== e9.name)?.id ?? -1 : 0, a10 = t10.functionTextures[i15] ?? t10.rasterTexture, u9 = "Reproject" === r15.name;
    return { texture: { texture: a10, unit: 0 }, srcImageSize: t10.getRasterTextureSize(u9) };
  }
  _getMultipleInputConfig(e8, t10) {
    return t10?.length ? 2 === t10.length ? { twoRasterConfig: this._getTwoInputConfig(t10, e8) } : 3 === t10.length ? { threeRasterConfig: this._getThreeInputConfig(t10, e8) } : {} : {};
  }
  _getConstantCount(e8) {
    return e8?.filter((e9) => "Constant" === e9.name).length ?? 0;
  }
  _getTextures(e8, t10) {
    return e8.filter((e9) => "Constant" !== e9.name).map((e9) => null != e9.id && "Identity" !== e9.name ? t10.functionTextures[e9.id] : t10.rasterTexture);
  }
  _getTwoInputConfig(e8, t10) {
    const r15 = this._getTextures(e8, t10), n7 = r15[1] ? { texture: r15[1], unit: 1 } : void 0, s10 = e8.findIndex((e9) => "Constant" === e9.name), o6 = 0 === s10 ? new Float32Array([0, 1, 0, 1, 0, 0, 0, 0, 0]) : new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 0]);
    return { image1: n7, image1Const: s10 > -1 ? e8[s10].parameters.value : 0, imageSwap: o6 };
  }
  _getThreeInputConfig(e8, t10) {
    const r15 = this._getTextures(e8, t10);
    let n7 = 0, s10 = 0, o6 = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    const i15 = r15[1] ? { texture: r15[1], unit: 1 } : void 0, a10 = r15[2] ? { texture: r15[2], unit: 2 } : void 0, u9 = [];
    if (e8.forEach((e9, t11) => "Constant" === e9.name && u9.push(t11)), 1 === u9.length) n7 = e8[u9[0]].parameters.value, o6 = 0 === u9[0] ? new Float32Array([0, 1, 0, 0, 0, 1, 1, 0, 0]) : 1 === u9[0] ? new Float32Array([1, 0, 0, 0, 0, 1, 0, 1, 0]) : new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    else if (2 === u9.length) {
      n7 = e8[u9[0]].parameters.value, s10 = e8[u9[1]].parameters.value;
      const t11 = e8.findIndex((e9) => "Constant" !== e9.name);
      o6 = 0 === t11 ? new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]) : 1 === t11 ? new Float32Array([0, 1, 0, 1, 0, 0, 0, 0, 1]) : new Float32Array([0, 0, 1, 1, 0, 0, 0, 1, 0]);
    }
    return { image1: i15, image2: a10, image1Const: n7, image2Const: s10, imageSwap: o6 };
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/BaseRasterProcessorShader.js
var x3 = class extends C3 {
};
__decorate([f2(0, X)], x3.prototype, "position", void 0);
var v6 = class extends I2 {
};
var y4 = class extends w {
};
__decorate([m3(U3)], y4.prototype, "texture", void 0), __decorate([m3(X)], y4.prototype, "srcImageSize", void 0);
var h12 = class extends P2 {
  vertex(o6) {
    return { uv: o6.position, glPosition: new _3(g3(o6.position), 0, 1) };
  }
  fragment(o6) {
    const t10 = new v2(), e8 = G(o6.uv), s10 = this._process(e8);
    return t10.fragColor = new _3(s10.rgb, 1).multiply(s10.a), t10;
  }
  _getPixel(o6) {
    return B2(o6, this.config);
  }
};
__decorate([m3(y4)], h12.prototype, "config", void 0), __decorate([__param(0, l4(x3))], h12.prototype, "vertex", null), __decorate([__param(0, l4(v6))], h12.prototype, "fragment", null);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/AspectShader.js
var h13 = class extends w {
};
__decorate([m3(X)], h13.prototype, "cellSize", void 0);
var g9 = class extends h12 {
  constructor() {
    super(...arguments), this.type = "AspectShader";
  }
  _process(e8) {
    const { texture: t10 } = this.config, i15 = m7(t10, e8, this.config.srcImageSize), f10 = new X(1).divide(this.aspectConfig.cellSize.multiply(8)), { x: h20, y: g12 } = f3(i15, f10), w7 = gt(g12), S8 = i15[9].multiply(cn(Qt(h20).add(Qt(w7)))), x6 = Qt(cn(h20)), j5 = new C2(3.14159265359), v7 = new C2(0), z5 = ln(v7, w7).multiply(0.5).multiply(j5).add(ln(w7, v7).multiply(1.5).multiply(j5)), C7 = Ge(new C2(2.5).multiply(j5).add(ie(w7, gt(h20))), new C2(2).multiply(j5)), b9 = _e(z5, C7, x6).multiply(180).divide(j5);
    return new _3(b9, b9, b9, S8);
  }
};
__decorate([m3(h13)], g9.prototype, "aspectConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/AspectTechnique.js
var t3 = class extends i13 {
  constructor() {
    super(...arguments), this.name = "RasterAspectProcessor", this.type = 3, this.shaders = { aspect: new g9() };
  }
  _process(s10, e8) {
    const t10 = { cellSize: e8.getRasterCellSize() }, r15 = this._getCommonConfig(s10, e8), o6 = { shader: this.shaders.aspect, uniforms: { config: r15, aspectConfig: t10 }, defines: {}, optionalAttributes: null, useComputeBuffer: false }, { painter: a10, context: i15 } = s10;
    a10.submitDrawMesh(i15, o6, a10.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/BandArithmeticShader.js
var b7 = class extends w {
};
__decorate([m3(rt)], b7.prototype, "bandIndexMat3", void 0);
var h14 = class extends w {
};
__decorate([m3(Y)], h14.prototype, "adjustments", void 0);
var x4 = class extends h12 {
  constructor() {
    super(...arguments), this.type = "BandArithmeticShader", this.isOutputRounded = false;
  }
  _process(t10) {
    const u9 = this._getPixel(t10), s10 = this.bandArithmeticConfig.bandIndexMat3.multiply(u9.rgb), r15 = this._processIndex(s10), l7 = new _3(r15, r15, r15, u9.a);
    return this.isOutputRounded ? a7(l7) : l7;
  }
  _processIndex(t10) {
    const { r: u9, g: s10 } = t10, r15 = this.adjustmentConfig?.adjustments;
    switch (this.indexType) {
      case "ndxi": {
        const t11 = u9.subtract(s10), r16 = u9.add(s10);
        return t11.multiply(w5(r16));
      }
      case "sr":
        return u9.multiply(w5(s10));
      case "ci":
        return u9.multiply(w5(s10)).subtract(1);
      case "savi": {
        const { x: t11 } = r15, l7 = u9.subtract(s10), i15 = u9.add(s10).add(t11);
        return l7.multiply(w5(i15)).multiply(t11.add(1));
      }
      case "tsavi": {
        const { x: t11, y: l7, z: i15 } = r15, a10 = i15.multiply(t11.multiply(t11).add(1)).subtract(l7.multiply(t11)), e8 = t11.multiply(u9.subtract(t11.multiply(s10)).subtract(l7)), d8 = l7.multiply(u9).add(s10).add(a10);
        return e8.multiply(w5(d8));
      }
      case "msavi": {
        const t11 = u9.multiply(2).add(1), r16 = t11.multiply(t11).subtract(u9.subtract(s10).multiply(8));
        return t11.subtract(hn(r16)).multiply(0.5);
      }
      case "gemi": {
        const t11 = u9.multiply(u9).subtract(s10.multiply(s10)).multiply(2).add(u9.multiply(1.5)).add(s10.multiply(0.5)), r16 = u9.add(s10).add(0.5), l7 = t11.multiply(w5(r16)), i15 = l7.multiply(E2(l7.multiply(0.25))), a10 = s10.subtract(0.125).multiply(w5(E2(s10)));
        return i15.subtract(a10);
      }
      case "pvi": {
        const { x: t11, y: l7 } = r15, i15 = hn(t11.multiply(t11).add(1));
        return u9.subtract(s10.multiply(t11)).subtract(l7).multiply(w5(i15));
      }
      case "vari": {
        const u10 = t10.g.subtract(t10.r), s11 = t10.g.add(t10.r).subtract(t10.b);
        return u10.multiply(w5(s11));
      }
      case "rtvicore":
        return u9.subtract(s10).multiply(100).subtract(u9.subtract(t10.b).multiply(10));
      case "bai": {
        const t11 = We(new C2(0.1).subtract(s10), new C2(2)), r16 = We(new C2(0.06).subtract(u9), new C2(2));
        return w5(t11.add(r16));
      }
      case "evi": {
        const r16 = t10.b, l7 = u9.add(s10.multiply(6)).subtract(r16.multiply(7.5)).add(1);
        return u9.subtract(s10).multiply(2.5).multiply(w5(l7));
      }
      case "wndwi": {
        const { r: u10, g: s11, b: l7 } = t10, i15 = r15.x, a10 = i15.multiply(s11), e8 = i15.multiply(l7), d8 = u10.add(a10).add(l7).subtract(e8);
        return u10.subtract(a10).subtract(l7).add(e8).multiply(w5(d8));
      }
      case "mtvi": {
        const r16 = t10.b, l7 = We(u9.multiply(2).add(1), new C2(2)), i15 = u9.multiply(6).subtract(hn(s10).multiply(5)), p6 = hn(l7.subtract(i15).subtract(0.5)), c10 = u9.subtract(r16).multiply(1.2), m12 = s10.subtract(r16).multiply(2.5);
        return c10.subtract(m12).multiply(1.5).multiply(w5(p6));
      }
      default:
        return u9;
    }
  }
};
__decorate([_4], x4.prototype, "indexType", void 0), __decorate([_4], x4.prototype, "isOutputRounded", void 0), __decorate([m3(b7)], x4.prototype, "bandArithmeticConfig", void 0), __decorate([g2(h14)], x4.prototype, "adjustmentConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/BandArithmeticTechnique.js
var s5 = class extends i13 {
  constructor() {
    super(...arguments), this.name = "RasterBandArithmeticProcessor", this.type = 4, this.shaders = { bandArithmetic: new x4() };
  }
  _process(e8, t10) {
    const s10 = e8.rasterFunction.parameters, r15 = { indexType: s10.indexType, isOutputRounded: s10.isOutputRounded }, n7 = { bandIndexMat3: s10.bandIndexMat3 }, i15 = s10.adjustments ? { adjustments: [...s10.adjustments] } : void 0, a10 = this._getCommonConfig(e8, t10), o6 = { shader: this.shaders.bandArithmetic, uniforms: { config: a10, bandArithmeticConfig: n7, adjustmentConfig: i15 }, defines: r15, optionalAttributes: null, useComputeBuffer: false }, { painter: d8, context: u9 } = e8;
    d8.submitDrawMesh(u9, o6, d8.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/ColormapToRGBShader.js
var m8 = class extends h12 {
  constructor() {
    super(...arguments), this.type = "ColormapToRGBShader";
  }
  _process(o6) {
    const r15 = this._getPixel(o6), p6 = c3(r15, new C2(1), this.colormapConfig, false);
    return new _3(p6.xyz.multiply(255), p6.a);
  }
};
__decorate([m3(n4)], m8.prototype, "colormapConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/ColormapToRGBTechnique.js
var r7 = class extends i13 {
  constructor() {
    super(...arguments), this.name = "RasterColormapToRGBProcessor", this.type = 5, this.shaders = { colormapToRGB: new m8() };
  }
  _process(o6, e8, r15) {
    const s10 = o6.rasterFunction.parameters, t10 = { colormapTexture: { texture: r15, unit: 1 }, colormapOffset: s10.offset, colormapMaxIndex: s10.indexedColormap.length / 4 - 1 }, a10 = this._getCommonConfig(o6, e8), n7 = { shader: this.shaders.colormapToRGB, uniforms: { config: a10, colormapConfig: t10 }, defines: {}, optionalAttributes: null, useComputeBuffer: false }, { painter: i15, context: m12 } = o6;
    i15.submitDrawMesh(m12, n7, i15.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/MultiRasterMixin.js
var u7 = class extends w {
};
__decorate([m3(U3)], u7.prototype, "image1", void 0), __decorate([m3(C2)], u7.prototype, "image1Const", void 0), __decorate([m3(rt)], u7.prototype, "imageSwap", void 0);
var l5 = class extends w {
};
__decorate([m3(U3)], l5.prototype, "image1", void 0), __decorate([m3(U3)], l5.prototype, "image2", void 0), __decorate([m3(C2)], l5.prototype, "image1Const", void 0), __decorate([m3(C2)], l5.prototype, "image2Const", void 0), __decorate([m3(rt)], l5.prototype, "imageSwap", void 0);
var m9 = (a10) => {
  const i15 = a10;
  class n7 extends i15 {
    constructor() {
      super(...arguments), this.constantCount = 0, this.imageCount = 1;
    }
    _getRasterValues(t10) {
      const { imageCount: o6 } = this;
      if (1 === o6) {
        const o7 = wn(this.config.texture, t10);
        return { a: o7.r, b: o7.g, c: o7.b, alpha: o7.a };
      }
      if (2 === o6) {
        const o7 = this._getTwoValues(t10);
        return { a: o7.a, b: o7.b, c: o7.b, alpha: o7.alpha };
      }
      return this._getThreeValues(t10);
    }
    _getTwoValues(t10) {
      const o6 = wn(this.config.texture, t10);
      if (1 === this.constantCount) {
        const { imageSwap: t11, image1Const: e9 } = this.twoRasterConfig, a12 = t11.multiply(new Y(o6.r, e9, 0));
        return { a: a12.x, b: a12.y, alpha: o6.a };
      }
      const { image1: e8 } = this.twoRasterConfig, a11 = wn(e8, t10);
      return { a: o6.r, b: a11.r, alpha: o6.a.multiply(a11.a) };
    }
    _getThreeValues(t10) {
      const o6 = wn(this.config.texture, t10), { imageSwap: e8, image1: a11, image2: i16, image1Const: n8, image2Const: p6 } = this.threeRasterConfig;
      if (2 === this.constantCount) {
        const t11 = e8.multiply(new Y(o6.r, n8, p6));
        return { a: t11.x, b: t11.y, c: t11.z, alpha: o6.a };
      }
      if (1 === this.constantCount) {
        const i17 = wn(a11, t10), p7 = e8.multiply(new Y(o6.r, i17.r, n8));
        return { a: p7.x, b: p7.y, c: p7.z, alpha: o6.a.multiply(i17.a) };
      }
      const g12 = wn(a11, t10), u9 = wn(i16, t10);
      return { a: o6.r, b: g12.r, c: u9.r, alpha: o6.a.multiply(g12.a).multiply(u9.a) };
    }
  }
  return __decorate([_4], n7.prototype, "constantCount", void 0), __decorate([_4], n7.prototype, "imageCount", void 0), __decorate([g2(u7)], n7.prototype, "twoRasterConfig", void 0), __decorate([g2(l5)], n7.prototype, "threeRasterConfig", void 0), n7;
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/CompositeBandShader.js
var t4 = class extends m9(h12) {
  constructor() {
    super(...arguments), this.type = "CompositeBandShader";
  }
  _process(r15) {
    const { a: e8, b: t10, c: o6, alpha: a10 } = this._getRasterValues(r15);
    return new _3(e8, t10, o6, a10);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/CompositeBandTechnique.js
var e6 = class extends i13 {
  constructor() {
    super(...arguments), this.name = "RasterCompositeBandProcessor", this.type = 6, this.shaders = { compositeBand: new t4() };
  }
  _process(s10, t10) {
    const { rasters: e8 } = s10.rasterFunction.parameters, o6 = { constantCount: this._getConstantCount(e8), imageCount: e8?.length ?? 1 }, r15 = this._getMultipleInputConfig(t10, e8), n7 = this._getCommonConfig(s10, t10), a10 = { shader: this.shaders.compositeBand, uniforms: { config: n7, ...r15 }, defines: o6, optionalAttributes: null, useComputeBuffer: false }, { painter: i15, context: p6 } = s10;
    i15.submitDrawMesh(p6, a10, i15.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/LocalShader.js
var ee = class extends w {
};
__decorate([m3(X)], ee.prototype, "domainRange", void 0);
var ae = class extends m9(h12) {
  constructor() {
    super(...arguments), this.type = "LocalShader", this.isOutputRounded = false;
  }
  _process(e8) {
    if ("conditional" === this.operationName) return this._conditional(e8);
    const { a: a10, b: s10, alpha: t10 } = this._getRasterValues(e8), { value: r15, alpha: n7 } = this._compute(a10, s10, t10);
    return this._processResult(r15, n7);
  }
  _processResult(e8, a10) {
    const s10 = p3(e8, this.domainRangeConfig.domainRange), t10 = new _3(e8, e8, e8, a10).multiply(s10);
    return this.isOutputRounded ? a7(t10) : t10;
  }
  _compute(e8, a10, s10) {
    const { operationName: t10 } = this;
    let r15;
    switch (t10) {
      case "plus":
        r15 = e8.add(a10);
        break;
      case "minus":
        r15 = e8.subtract(a10);
        break;
      case "times":
        r15 = e8.multiply(a10);
        break;
      case "divide":
      case "floatdivide":
        r15 = e8.multiply(w5(a10)), s10 = s10.multiply(st(Qt(cn(a10))));
        break;
      case "floordivide":
        r15 = ze(e8.multiply(w5(a10))), s10 = s10.multiply(st(Qt(cn(a10))));
        break;
      case "square":
        r15 = e8.multiply(e8);
        break;
      case "sqrt":
        r15 = hn(e8);
        break;
      case "power":
        r15 = We(e8, a10);
        break;
      case "ln":
        r15 = zt(Gt(e8, new C2(0)), qe(e8), new C2(0)), s10 = s10.multiply(this._isAboveZero(e8));
        break;
      case "log10":
        r15 = zt(Gt(e8, new C2(0)), Ue(e8).multiply(w5(Ue(new C2(10)))), new C2(0)), s10 = s10.multiply(this._isAboveZero(e8));
        break;
      case "log2":
        r15 = zt(Gt(e8, new C2(0)), Ue(e8), new C2(0)), s10 = s10.multiply(this._isAboveZero(e8));
        break;
      case "exp":
        r15 = ge(e8);
        break;
      case "exp10":
        r15 = We(new C2(10), e8);
        break;
      case "exp2":
        r15 = We(new C2(2), e8);
        break;
      case "rounddown":
        r15 = ze(e8);
        break;
      case "roundup":
        r15 = ue2(e8);
        break;
      case "int":
        r15 = cn(e8).multiply(ze(Qt(e8)));
        break;
      case "mod":
        r15 = Ge(e8, a10);
        break;
      case "negate":
        r15 = gt(e8);
        break;
      case "abs":
        r15 = Qt(e8);
        break;
      case "acos": {
        const a11 = this._isAbsBiggerThanOne(e8);
        r15 = zt(a11, new C2(0), Wt(e8)), s10 = zt(a11, new C2(0), s10);
        break;
      }
      case "acosh":
        r15 = Zt(e8);
        break;
      case "asin": {
        const a11 = this._isAbsBiggerThanOne(e8);
        r15 = zt(a11, new C2(0), ne(e8)), s10 = zt(a11, new C2(0), s10);
        break;
      }
      case "asinh":
        r15 = re(e8);
        break;
      case "atan":
        r15 = ie(e8);
        break;
      case "atanh": {
        const a11 = this._isAbsBiggerThanOne(e8);
        r15 = zt(a11, new C2(0), ce(e8)), s10 = zt(a11, new C2(0), s10);
        break;
      }
      case "atan2":
        r15 = ie(e8, a10);
        break;
      case "cos":
        r15 = oe(e8);
        break;
      case "cosh":
        r15 = he(e8);
        break;
      case "sin":
        r15 = un(e8);
        break;
      case "sinh":
        r15 = sn(e8);
        break;
      case "tan":
        r15 = an(e8);
        break;
      case "tanh":
        r15 = fn(e8);
        break;
      case "bitwiseand":
        r15 = new C2(Pt(new W(e8), new W(a10)));
        break;
      case "bitwiseor":
        r15 = new C2(Bt(new W(e8), new W(a10)));
        break;
      case "bitwiseleftshift":
        r15 = new C2(Rt(new W(e8), new W(a10)));
        break;
      case "bitwiserightshift":
        r15 = new C2(jt(new W(e8), new W(a10)));
        break;
      case "bitwisenot":
        r15 = new C2(Ut(new W(e8)));
        break;
      case "bitwisexor":
        r15 = new C2(qt(new W(e8), new W(a10)));
        break;
      case "booleanand":
        r15 = st(Lt(Xt(e8, new C2(0)), Xt(a10, new C2(0))));
        break;
      case "booleanor":
        r15 = st(At(Xt(e8, new C2(0)), Xt(a10, new C2(0))));
        break;
      case "booleannot":
        r15 = st(Ct(e8, new C2(0)));
        break;
      case "booleanxor":
        r15 = st(Jt(Xt(e8, new C2(0)), Xt(a10, new C2(0))));
        break;
      case "greaterthan":
        r15 = st(Gt(e8, a10));
        break;
      case "greaterthanequal":
        r15 = st(Ht(e8, a10));
        break;
      case "lessthan":
        r15 = st(Yt(e8, a10));
        break;
      case "lessthanequal":
        r15 = st(_t(e8, a10));
        break;
      case "equalto":
        r15 = st(Ct(e8, a10));
        break;
      case "notequal":
        r15 = st(Xt(e8, a10));
        break;
      case "isnull":
        r15 = st(Ct(s10, new C2(0))), s10 = new C2(1);
        break;
      case "setnull": {
        const t11 = st(Ct(e8, new C2(0)));
        r15 = t11.multiply(a10), s10 = s10.multiply(t11);
        break;
      }
      default:
        r15 = e8;
    }
    return { value: r15, alpha: s10 };
  }
  _conditional(e8) {
    const { a: a10, b: s10, c: t10, alpha: r15 } = this._getRasterValues(e8), n7 = new C2(Qt(cn(a10))), i15 = _e(t10, s10, n7);
    return this._processResult(i15, r15);
  }
  _isAboveZero(e8) {
    return st(Gt(e8, new C2(0)));
  }
  _isAbsBiggerThanOne(e8) {
    return Gt(Qt(e8), new C2(1));
  }
};
__decorate([_4], ae.prototype, "operationName", void 0), __decorate([_4], ae.prototype, "isOutputRounded", void 0), __decorate([m3(ee)], ae.prototype, "domainRangeConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/ComputeChangeShader.js
var h15 = class extends m9(h12) {
  constructor() {
    super(...arguments), this.type = "ComputeChangeShader", this.isOutputRounded = false;
  }
  _process(t10) {
    const { a: o6, b: e8, alpha: a10 } = this._getRasterValues(t10);
    let p6 = o6.subtract(e8);
    "relative-difference" === this.method && (p6 = p6.multiply(w5(Xe(Qt(o6), Qt(e8)))));
    const u9 = p3(p6, this.domainRangeConfig.domainRange), h20 = new _3(p6, p6, p6, a10).multiply(u9);
    return this.isOutputRounded ? a7(h20) : h20;
  }
};
__decorate([_4], h15.prototype, "method", void 0), __decorate([_4], h15.prototype, "isOutputRounded", void 0), __decorate([m3(ee)], h15.prototype, "domainRangeConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/ComputeChangeTechnique.js
var s6 = class extends i13 {
  constructor() {
    super(...arguments), this.name = "RasterComputeChangeProcessor", this.type = 7, this.shaders = { computeChange: new h15() };
  }
  _process(e8, t10) {
    const s10 = e8.rasterFunction.parameters, { rasters: o6 } = s10, n7 = { constantCount: this._getConstantCount(o6), imageCount: o6.length, method: s10.method, isOutputRounded: s10.isOutputRounded }, r15 = { domainRange: s10.domainRange }, { twoRasterConfig: a10 } = this._getMultipleInputConfig(t10, o6), i15 = this._getCommonConfig(e8, t10), u9 = { shader: this.shaders.computeChange, uniforms: { config: i15, domainRangeConfig: r15, twoRasterConfig: a10 }, defines: n7, optionalAttributes: null, useComputeBuffer: false }, { painter: h20, context: m12 } = e8;
    h20.submitDrawMesh(m12, u9, h20.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/ContrastBrightnessShader.js
var f7 = class extends w {
};
__decorate([m3(C2)], f7.prototype, "contrastOffset", void 0), __decorate([m3(C2)], f7.prototype, "brightnessOffset", void 0);
var h16 = class extends h12 {
  constructor() {
    super(...arguments), this.type = "ContrastBrightnessShader";
  }
  _process(t10) {
    const { rgb: s10, a: e8 } = this._getPixel(t10), { contrastOffset: l7, brightnessOffset: f10 } = this.contrastBrightnessConfig, h20 = new C2(255), c10 = new C2(128), u9 = s10.multiply(200), g12 = h20.multiply(100), y8 = h20.multiply(2).multiply(f10), w7 = u9.subtract(g12).add(y8), b9 = Tt([Ct(l7, new C2(-100)), new Y(c10)], [Ct(l7, new C2(100)), cn(w7).add(1).divide(2).multiply(h20)], [Gt(l7, new C2(0)), w7.divide(new C2(100).subtract(l7).multiply(2)).add(c10)], [true, w7.multiply(l7.add(100)).divide(2e4).add(c10)]);
    return a7(new _3(b9, e8));
  }
};
__decorate([m3(f7)], h16.prototype, "contrastBrightnessConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/ContrastBrightnessTechnique.js
var r8 = class extends i13 {
  constructor() {
    super(...arguments), this.name = "RasterContrastBrightnessProcessor", this.type = 8, this.shaders = { contrastBrightness: new h16() };
  }
  _process(s10, t10) {
    const r15 = this._getCommonConfig(s10, t10), e8 = s10.rasterFunction.parameters, o6 = { shader: this.shaders.contrastBrightness, uniforms: { config: r15, contrastBrightnessConfig: e8 }, defines: {}, optionalAttributes: null, useComputeBuffer: false }, { painter: n7, context: a10 } = s10;
    n7.submitDrawMesh(a10, o6, n7.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/ConvolutionShader.js
var u8 = class extends w {
};
__decorate([m3(q2.ofType(C2, 5, 5, true))], u8.prototype, "kernel", void 0), __decorate([m3(X)], u8.prototype, "clampRange", void 0);
var g10 = class extends h12 {
  constructor() {
    super(...arguments), this.type = "ConvolutionShader", this.rows = 3, this.cols = 3;
  }
  _process(o6) {
    const { rows: t10, cols: e8 } = this, r15 = new X(Math.floor(t10 / 2), Math.floor(e8 / 2)), { texture: c10, srcImageSize: m12 } = this.config, u9 = new C2(1).divide(m12), { kernel: g12 } = this.convolutionConfig, h20 = jn(g12, { initialValue: new _3(0, 0, 0, 1), xRange: [0, t10], yRange: [0, e8], callback: (t11, e9, n7, a10) => {
      const m13 = new X(new C2(n7), new C2(a10)).subtract(r15).multiply(u9), g13 = wn(c10, y3(o6.add(m13))), h21 = g13.rgb.multiply(e9).add(t11.rgb), f11 = g13.a.multiply(t11.a);
      return new _3(h21, f11);
    } }), { clampRange: f10 } = this.convolutionConfig;
    return new _3(se(h20.rgb, f10.x, f10.y), 1).multiply(h20.a);
  }
};
__decorate([_4], g10.prototype, "rows", void 0), __decorate([_4], g10.prototype, "cols", void 0), __decorate([m3(u8)], g10.prototype, "convolutionConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/ConvolutionTechnique.js
var s7 = class extends i13 {
  constructor() {
    super(...arguments), this.name = "RasterConvolutionProcessor", this.type = 9, this.shaders = { convolution: new g10() };
  }
  _process(e8, o6) {
    const s10 = e8.rasterFunction.parameters, r15 = { rows: s10.kernelRows, cols: s10.kernelCols }, n7 = { kernel: [...s10.kernel], clampRange: s10.clampRange }, t10 = this._getCommonConfig(e8, o6), i15 = { shader: this.shaders.convolution, uniforms: { config: t10, convolutionConfig: n7 }, defines: r15, optionalAttributes: null, useComputeBuffer: false }, { painter: a10, context: c10 } = e8;
    a10.submitDrawMesh(c10, i15, a10.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/CurvatureShader.js
var c7 = class extends w {
};
__decorate([m3(C2)], c7.prototype, "zlFactor", void 0);
var m10 = class extends h12 {
  constructor() {
    super(...arguments), this.type = "CurvatureShader";
  }
  _process(t10) {
    const { texture: r15 } = this.config, e8 = m7(r15, t10, this.config.srcImageSize), i15 = e8[3].add(e8[5]).multiply(0.5).subtract(e8[4]), d8 = e8[1].add(e8[7]).multiply(0.5).subtract(e8[4]), { zlFactor: l7 } = this.curvatureConfig, { curvatureType: c10 } = this;
    let m12;
    if ("standard" === c10) m12 = gt(l7).multiply(i15.add(d8));
    else {
      const t11 = e8[2].subtract(e8[0]).add(e8[6]).subtract(e8[8]).divide(4), r16 = e8[5].subtract(e8[3]).divide(2), u9 = e8[1].subtract(e8[7]).divide(2), p6 = r16.multiply(r16), n7 = u9.multiply(u9), y8 = r16.multiply(u9), f10 = l7.divide(p6.add(n7));
      m12 = "profile" === c10 ? we(new Y(i15, d8, t11), new Y(p6, n7, y8)).multiply(f10) : we(new Y(i15, d8, gt(t11)), new Y(n7, p6, y8)).multiply(gt(f10));
    }
    return new _3(m12, m12, m12, e8[9]);
  }
};
__decorate([_4], m10.prototype, "curvatureType", void 0), __decorate([m3(c7)], m10.prototype, "curvatureConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/CurvatureTechnique.js
var s8 = class extends i13 {
  constructor() {
    super(...arguments), this.name = "RasterCurvatureProcessor", this.type = 10, this.shaders = { curvature: new m10() };
  }
  _process(r15, e8) {
    const s10 = r15.rasterFunction.parameters, t10 = { curvatureType: s10.curvatureType }, a10 = e8.getRasterCellSize(), o6 = { zlFactor: 200 * s10.zFactor / a10[0] / a10[1] }, u9 = this._getCommonConfig(r15, e8), c10 = { shader: this.shaders.curvature, uniforms: { config: u9, curvatureConfig: o6 }, defines: t10, optionalAttributes: null, useComputeBuffer: false }, { painter: i15, context: n7 } = r15;
    i15.submitDrawMesh(n7, c10, i15.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/ExtractBandShader.js
var d6 = class extends w {
};
__decorate([m3(rt)], d6.prototype, "bandIndexMat3", void 0);
var n5 = class extends h12 {
  constructor() {
    super(...arguments), this.type = "ExtractBandShader";
  }
  _process(t10) {
    const r15 = this._getPixel(t10), e8 = this.extractBandConfig.bandIndexMat3.multiply(r15.rgb);
    return new _3(e8, r15.a);
  }
};
__decorate([m3(d6)], n5.prototype, "extractBandConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/ExtractBandTechnique.js
var t5 = class extends i13 {
  constructor() {
    super(...arguments), this.name = "RasterExtractBandProcessor", this.type = 11, this.shaders = { extractBand: new n5() };
  }
  _process(e8, s10) {
    const t10 = { bandIndexMat3: e8.rasterFunction.parameters.bandIndexMat3 }, r15 = this._getCommonConfig(e8, s10), a10 = { shader: this.shaders.extractBand, uniforms: { config: r15, extractBandConfig: t10 }, defines: {}, optionalAttributes: null, useComputeBuffer: false }, { painter: n7, context: o6 } = e8;
    n7.submitDrawMesh(o6, a10, n7.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/FocalStatisticsShader.js
var f8 = class extends w {
};
__decorate([m3(X)], f8.prototype, "clampRange", void 0);
var _7 = class extends h12 {
  constructor() {
    super(...arguments), this.type = "FocalStatisticsShader", this.rows = 3, this.cols = 3, this.fill = false;
  }
  _process(t10) {
    const e8 = this._process1(t10), r15 = ln(new C2(1), e8.a);
    if (!this.fill) return this._clamp(e8.rgb, r15);
    const a10 = this._getPixel(t10), i15 = _e(e8.rgb, a10.rgb, a10.a);
    return this._clamp(i15, r15);
  }
  _clamp(t10, e8) {
    const { clampRange: r15 } = this.focalStatisticsConfig;
    return new _3(se(t10, r15.x, r15.y), 1).multiply(e8);
  }
  _process1(t10) {
    const { texture: e8, srcImageSize: r15 } = this.config, { rows: a10, cols: s10 } = this, n7 = new X(Math.floor(a10 / 2), Math.floor(s10 / 2)), l7 = new C2(1).divide(r15), w7 = this._getPixel(t10), { statisticsType: b9 } = this, h20 = "min" === b9 || "max" === b9 ? new _3(w7.rgb, 0) : new _3(0, 0, 0, 0);
    switch (b9) {
      case "min":
        return this._stat(a10, s10, h20, (r16, a11, s11) => {
          const p6 = new X(new C2(a11), new C2(s11)).subtract(n7).multiply(l7), m12 = wn(e8, y3(t10.add(p6))), w8 = Ye(r16.rgb, m12.rgb);
          return new _3(w8, r16.a.add(m12.a));
        });
      case "max":
        return this._stat(a10, s10, h20, (r16, a11, s11) => {
          const p6 = new X(new C2(a11), new C2(s11)).subtract(n7).multiply(l7), d8 = wn(e8, y3(t10.add(p6))), w8 = Xe(r16.rgb, d8.rgb);
          return new _3(w8, r16.a.add(d8.a));
        });
      case "mean": {
        const r16 = this._stat(a10, s10, h20, (r17, a11, s11) => {
          const p7 = new X(new C2(a11), new C2(s11)).subtract(n7).multiply(l7), m12 = wn(e8, y3(t10.add(p7))), d8 = r17.rgb.add(m12.rgb.multiply(m12.a));
          return new _3(d8, r17.a.add(m12.a));
        }), p6 = r16.rgb.multiply(w5(r16.a));
        return new _3(p6, r16.a);
      }
      case "stddev": {
        const r16 = this._stat(a10, s10, h20, (r17, a11, s11) => {
          const p6 = new X(new C2(a11), new C2(s11)).subtract(n7).multiply(l7), m13 = wn(e8, y3(t10.add(p6))), d9 = r17.rgb.add(m13.rgb.multiply(m13.a));
          return new _3(d9, r17.a.add(m13.a));
        }), m12 = this._stat(a10, s10, h20, (r17, a11, s11) => {
          const p6 = new X(new C2(a11), new C2(s11)).subtract(n7).multiply(l7), m13 = wn(e8, y3(t10.add(p6))), d9 = r17.rgb.add(m13.a.multiply(m13.rgb).multiply(m13.rgb));
          return new _3(d9, r17.a.add(m13.a));
        }), d8 = w5(m12.a), w8 = hn(m12.subtract(r16.multiply(r16).multiply(d8)).multiply(d8));
        return new _3(w8.rgb, r16.a);
      }
      default:
        return w7;
    }
  }
  _stat(t10 = 3, e8 = 3, r15, a10) {
    const s10 = new W(0).setMutable().setDebugName("StatColIterator"), o6 = new W(0).setMutable().setDebugName("StatRowIterator"), n7 = r15.setMutable().setDebugName("StatAccumulator"), l7 = a10(n7, s10, o6).setDebugName("StatPredicate"), c10 = xt({ iterX: s10, iterY: o6, accumulator: n7 }, _3, l7, ({ out: r16, iterX: a11, iterY: s11, accumulator: o7, subgraph: n8 }) => `
  for (${s11} = 0; ${s11} < ${t10}; ${s11}++) {
    for (${a11} = 0; ${a11} < ${e8}; ${a11}++) {
  
    ${n8.body}
  
    ${o7} = ${n8.varName};
    }
  }
  ${r16} = ${o7};
  `).setDebugName("statBody");
    return c10;
  }
};
__decorate([_4], _7.prototype, "rows", void 0), __decorate([_4], _7.prototype, "cols", void 0), __decorate([_4], _7.prototype, "statisticsType", void 0), __decorate([_4], _7.prototype, "fill", void 0), __decorate([m3(f8)], _7.prototype, "focalStatisticsConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/FocalStatisticsTechnique.js
var e7 = class extends i13 {
  constructor() {
    super(...arguments), this.name = "RasterFocalStatisticsProcessor", this.type = 21, this.shaders = { focalStatistics: new _7() };
  }
  _process(s10, t10) {
    const e8 = s10.rasterFunction.parameters, a10 = { rows: e8.kernelRows, cols: e8.kernelCols, statisticsType: e8.statisticsType, fill: e8.fillNoDataOnly }, o6 = { clampRange: e8.clampRange }, r15 = this._getCommonConfig(s10, t10), i15 = { shader: this.shaders.focalStatistics, uniforms: { config: r15, focalStatisticsConfig: o6 }, defines: a10, optionalAttributes: null, useComputeBuffer: false }, { painter: c10, context: n7 } = s10;
    c10.submitDrawMesh(n7, i15, c10.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/GrayscaleShader.js
var p5 = class extends w {
};
__decorate([m3(Y)], p5.prototype, "weights", void 0);
var c8 = class extends h12 {
  constructor() {
    super(...arguments), this.type = "GrayscaleShader";
  }
  _process(r15) {
    const s10 = this._getPixel(r15), { weights: e8 } = this.grayscaleConfig, a10 = we(e8, s10.rgb);
    return new _3(a10, a10, a10, s10.a);
  }
};
__decorate([m3(p5)], c8.prototype, "grayscaleConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/GrayscaleTechnique.js
var r9 = class extends i13 {
  constructor() {
    super(...arguments), this.name = "RasterGrayscaleProcessor", this.type = 12, this.shaders = { grayscale: new c8() };
  }
  _process(s10, e8) {
    const r15 = { weights: s10.rasterFunction.parameters.weights }, t10 = this._getCommonConfig(s10, e8), a10 = { shader: this.shaders.grayscale, uniforms: { config: t10, grayscaleConfig: r15 }, defines: {}, optionalAttributes: null, useComputeBuffer: false }, { painter: o6, context: i15 } = s10;
    o6.submitDrawMesh(i15, a10, o6.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/HillshadeShader.js
var h17 = class extends h12 {
  constructor() {
    super(...arguments), this.type = "HillshadeShader", this.isMultidirectional = false;
  }
  _process(i15) {
    const { texture: r15 } = this.config, t10 = m7(r15, i15, this.config.srcImageSize), l7 = Z2(t10, this.hillshadeConfig, this.isMultidirectional);
    return new _3(l7.rgb.multiply(255), l7.a);
  }
};
__decorate([_4], h17.prototype, "isMultidirectional", void 0), __decorate([m3(a6)], h17.prototype, "hillshadeConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/HillshadeTechnique.js
var t6 = class extends i13 {
  constructor() {
    super(...arguments), this.name = "RasterHillshadeProcessor", this.type = 13, this.shaders = { hillshade: new h17() };
  }
  _process(e8, r15) {
    const t10 = e8.rasterFunction.parameters, a10 = { isMultidirectional: t10.hillshadeType > 0 }, i15 = r15.getRasterCellSize(), o6 = z4(t10, i15), h20 = { ...t10, factor: o6, minValue: 0, maxValue: 8e3 }, l7 = this._getCommonConfig(e8, r15), n7 = { shader: this.shaders.hillshade, uniforms: { config: l7, hillshadeConfig: h20 }, defines: a10, optionalAttributes: null, useComputeBuffer: false }, { painter: d8, context: u9 } = e8;
    d8.submitDrawMesh(u9, n7, d8.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/LocalTechnique.js
var t7 = class extends i13 {
  constructor() {
    super(...arguments), this.name = "RasterLocalProcessor", this.type = 14, this.shaders = { local: new ae() };
  }
  _process(e8, s10) {
    const t10 = e8.rasterFunction.parameters, o6 = { constantCount: this._getConstantCount(t10.rasters), imageCount: t10.imageCount, operationName: t10.operationName, isOutputRounded: t10.isOutputRounded }, a10 = { domainRange: t10.domainRange }, r15 = "conditional" === t10.operationName ? t10.rasters : t10.rasters?.slice(0, 2), n7 = this._getMultipleInputConfig(s10, r15), i15 = this._getCommonConfig(e8, s10), u9 = { shader: this.shaders.local, uniforms: { config: i15, domainRangeConfig: a10, ...n7 }, defines: o6, optionalAttributes: null, useComputeBuffer: false }, { painter: c10, context: m12 } = e8;
    c10.submitDrawMesh(m12, u9, c10.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/MaskShader.js
var c9 = class extends w {
};
__decorate([m3(B.ofType(C2, 6))], c9.prototype, "includedRanges", void 0), __decorate([m3(B.ofType(C2, l3))], c9.prototype, "noDataValues", void 0);
var y5 = class extends h12 {
  constructor() {
    super(...arguments), this.type = "MaskShader", this.isMultiband = true;
  }
  _process(t10) {
    const o6 = this._getPixel(t10), e8 = this._computeNoDataFactor(o6.r), s10 = this._computeRangeFactor(o6.rgb);
    let r15;
    if (this.isMultiband) {
      const t11 = this._computeNoDataFactor(o6.g), a10 = this._computeNoDataFactor(o6.b), l7 = new Y(e8, t11, a10).multiply(s10);
      r15 = l7.x.multiply(l7.y).multiply(l7.z);
    } else r15 = e8.multiply(s10.x);
    return o6.multiply(r15);
  }
  _computeNoDataFactor(t10) {
    const { noDataValues: e8 } = this.maskConfig;
    let s10 = new Y(1);
    for (let r15 = 0; r15 < l3 / 3; r15++) {
      const o6 = 3 * r15, p6 = new Y(e8[o6 + 0], e8[o6 + 1], e8[o6 + 2]), n7 = Qt(cn(p6.subtract(t10)));
      s10 = s10.multiply(n7);
    }
    return s10.x.multiply(s10.y).multiply(s10.z);
  }
  _computeRangeFactor(t10) {
    const { includedRanges: o6 } = this.maskConfig, e8 = new Y(o6[0], o6[2], o6[4]), s10 = new Y(o6[1], o6[3], o6[5]);
    return ln(e8, t10).multiply(ln(t10, s10));
  }
};
__decorate([_4], y5.prototype, "isMultiband", void 0), __decorate([m3(c9)], y5.prototype, "maskConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/MaskTechnique.js
var a8 = class extends i13 {
  constructor() {
    super(...arguments), this.name = "RasterMaskProcessor", this.type = 15, this.shaders = { mask: new y5() };
  }
  _process(s10, e8) {
    const a10 = s10.rasterFunction.parameters, r15 = { isMultiband: a10.bandCount > 1 }, t10 = { includedRanges: [...a10.includedRanges], noDataValues: [...a10.noDataValues] }, o6 = this._getCommonConfig(s10, e8), n7 = { shader: this.shaders.mask, uniforms: { config: o6, maskConfig: t10 }, defines: r15, optionalAttributes: null, useComputeBuffer: false }, { painter: i15, context: u9 } = s10;
    i15.submitDrawMesh(u9, n7, i15.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/NDVIShader.js
var n6 = class extends w {
};
__decorate([m3(rt)], n6.prototype, "bandIndexMat3", void 0);
var l6 = class extends h12 {
  constructor() {
    super(...arguments), this.type = "NDVIShader", this.scaled = true;
  }
  _process(t10) {
    const r15 = this._getPixel(t10), { r: s10, g: o6 } = this.ndviConfig.bandIndexMat3.multiply(r15.rgb), a10 = s10.subtract(o6), d8 = s10.add(o6), n7 = a10.multiply(w5(d8));
    if (!this.scaled) return new _3(n7, n7, n7, r15.a);
    const l7 = ze(n7.multiply(100).add(100.5));
    return new _3(l7, l7, l7, r15.a);
  }
};
__decorate([_4], l6.prototype, "scaled", void 0), __decorate([m3(n6)], l6.prototype, "ndviConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/NDVITechnique.js
var r10 = class extends i13 {
  constructor() {
    super(...arguments), this.name = "RasterNDVIProcessor", this.type = 16, this.shaders = { ndvi: new l6() };
  }
  _process(s10, e8) {
    const r15 = s10.rasterFunction.parameters, t10 = { scaled: r15.scaled }, o6 = { bandIndexMat3: r15.bandIndexMat3 }, n7 = this._getCommonConfig(s10, e8), a10 = { shader: this.shaders.ndvi, uniforms: { config: n7, ndviConfig: o6 }, defines: t10, optionalAttributes: null, useComputeBuffer: false }, { painter: i15, context: d8 } = s10;
    i15.submitDrawMesh(d8, a10, i15.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/RemapShader.js
var j4 = class extends w {
};
__decorate([m3(B.ofType(C2, 3 * l3))], j4.prototype, "rangeMaps", void 0), __decorate([m3(B.ofType(C2, 2 * l3))], j4.prototype, "noDataRanges", void 0), __decorate([m3(C2)], j4.prototype, "unmatchMask", void 0), __decorate([m3(C2)], j4.prototype, "replacementValue", void 0), __decorate([m3(X)], j4.prototype, "clampRange", void 0);
var x5 = class extends h12 {
  constructor() {
    super(...arguments), this.type = "RemapShader";
  }
  _process(t10) {
    const o6 = this._getPixel(t10), { rangeMaps: r15, unmatchMask: a10, clampRange: n7, replacementValue: l7 } = this.remapConfig, { mapValue: c10, includeMask: u9 } = f4(o6.r, r15, l3), d8 = this.replaceUnmatched ? l7 : a10.multiply(o6.r), h20 = _e(d8, c10, u9), y8 = se(h20, n7.x, n7.y), f10 = this._computeNoDataFactor(o6.rrr).multiply(Xe(a10, u9));
    return new _3(y8, y8, y8, o6.a).multiply(f10);
  }
  _computeNoDataFactor(t10) {
    const { noDataRanges: o6 } = this.remapConfig;
    let r15 = new Y(0, 0, 0);
    for (let a10 = 0; a10 < l3 / 3; a10++) {
      const e8 = 6 * a10, p6 = new Y(o6[e8], o6[e8 + 2], o6[e8 + 4]), s10 = new Y(o6[e8 + 1], o6[e8 + 3], o6[e8 + 5]);
      r15 = r15.add(ln(p6, t10).multiply(ln(t10, s10)));
    }
    return E2(cn(we(r15, new Y(1, 1, 1))));
  }
};
__decorate([m3(j4)], x5.prototype, "remapConfig", void 0), __decorate([_4], x5.prototype, "replaceUnmatched", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/RemapTechnique.js
var s9 = class extends i13 {
  constructor() {
    super(...arguments), this.name = "RasterRemapProcessor", this.type = 17, this.shaders = { remap: new x5() };
  }
  _process(e8, a10) {
    const s10 = e8.rasterFunction.parameters, r15 = { replaceUnmatched: s10.allowUnmatched && null != s10.replacementValue }, t10 = { rangeMaps: [...s10.rangeMaps], noDataRanges: [...s10.noDataRanges], unmatchMask: s10.allowUnmatched ? 1 : 0, replacementValue: s10.replacementValue ?? 0, clampRange: s10.clampRange }, n7 = this._getCommonConfig(e8, a10), o6 = { shader: this.shaders.remap, uniforms: { config: n7, remapConfig: t10 }, defines: r15, optionalAttributes: null, useComputeBuffer: false }, { painter: m12, context: p6 } = e8;
    m12.submitDrawMesh(p6, o6, m12.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/ReprojectShader.js
var r11 = class extends T2 {
  constructor() {
    super(...arguments), this.type = "ReprojectShader";
  }
  _colorize(e8) {
    return this._getPixel(e8);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/ReprojectTechnique.js
var r12 = class extends i13 {
  constructor() {
    super(...arguments), this.name = "RasterReprojectProcessor", this.type = 18, this.shaders = { reproject: new r11() };
  }
  _process(e8, t10) {
    const r15 = e8.rasterFunction.parameters, o6 = this._getInterpolationDefines(t10.interpolation, !!r15.requireNNEdge), { config: i15, projectionConfig: n7, projectionDefines: s10 } = this._getReprojectConfig(t10), a10 = { shader: this.shaders.reproject, uniforms: { config: i15, projectionConfig: n7 }, defines: { ...s10, ...o6, applyPixelMask: false, applyPixelHighlights: false }, optionalAttributes: null, useComputeBuffer: false }, { interpolation: c10 } = t10;
    t10.interpolation = "nearest";
    const { painter: p6, context: u9 } = e8;
    p6.submitDrawMesh(u9, a10, p6.quadMesh), t10.interpolation = c10, t10.projected = true;
  }
  _getReprojectConfig(e8) {
    const { source: t10 } = e8, { names: r15, textures: o6 } = e8.getTextures({ forProcessing: true }), i15 = { texture: { texture: o6[r15.indexOf("u_image")], unit: 0 }, dvsMat3: new Float32Array([2, 0, 0, 0, 2, 0, -1, -1, 0]), coordScale: [1, 1], srcImageSize: [t10.width, t10.height], opacity: 1 }, n7 = o6[r15.indexOf("u_transformGrid")], { transformGrid: s10 } = e8, a10 = !(!n7 || !s10);
    return { config: i15, projectionConfig: a10 ? { transformTexture: { texture: n7, unit: 1 }, targetImageSize: [e8.width, e8.height], transformSpacing: s10.spacing, transformGridSize: s10.size } : void 0, projectionDefines: { applyProjection: a10, lookupProjection: a10 && 1 === s10.spacing[0] } };
  }
  _getInterpolationDefines(e8, t10) {
    const r15 = "bilinear" === e8 && t10;
    return { bilinear: r15, bicubic: "cubic" === e8, nearestOnEdge: r15 };
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/ShadedReliefShader.js
var d7 = class extends h17 {
  constructor() {
    super(...arguments), this.type = "ShadedReliefShader";
  }
  _process(r15) {
    const o6 = super._process(r15), { minValue: m12, maxValue: n7 } = this.hillshadeConfig, d8 = this._getPixel(r15), h20 = n7.subtract(m12), u9 = d8.r.subtract(m12), c10 = se(u9.divide(h20), new C2(0), new C2(1)), f10 = c3(new _3(c10, c10, c10, 1), new C2(255), this.colormapConfig), x6 = a5(f10.xyz), g12 = c4(new Y(x6.xy, o6.x.divide(255))).multiply(255);
    return new _3(g12, f10.a.multiply(o6.a));
  }
};
__decorate([m3(n4)], d7.prototype, "colormapConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/ShadedReliefTechnique.js
var t8 = class extends i13 {
  constructor() {
    super(...arguments), this.name = "RasterShadedReliefProcessor", this.type = 19, this.shaders = { shadedRelief: new d7() };
  }
  _process(e8, r15, t10) {
    const o6 = e8.rasterFunction.parameters, a10 = { isMultidirectional: o6.hillshadeType > 0 }, i15 = r15.getRasterCellSize(), n7 = z4(o6, i15), d8 = { ...o6, factor: n7 }, h20 = { colormapTexture: { texture: t10, unit: 1 }, colormapOffset: o6.offset, colormapMaxIndex: o6.indexedColormap.length / 4 - 1 }, l7 = this._getCommonConfig(e8, r15), f10 = { shader: this.shaders.shadedRelief, uniforms: { config: l7, hillshadeConfig: d8, colormapConfig: h20 }, defines: a10, optionalAttributes: null, useComputeBuffer: false }, { painter: c10, context: m12 } = e8;
    c10.submitDrawMesh(m12, f10, c10.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/SlopeShader.js
var y6 = class extends w {
};
__decorate([m3(C2)], y6.prototype, "pixelSizePower", void 0), __decorate([m3(C2)], y6.prototype, "pixelSizeFactor", void 0), __decorate([m3(C2)], y6.prototype, "zFactor", void 0), __decorate([m3(X)], y6.prototype, "cellSize", void 0);
var h18 = class extends h12 {
  constructor() {
    super(...arguments), this.type = "SlopeShader", this.isOutputRounded = false, this.percentRise = false;
  }
  _process(e8) {
    const { cellSize: t10, pixelSizePower: o6, pixelSizeFactor: i15, zFactor: u9 } = this.slopeConfig, a10 = We(t10, new X(o6)).multiply(i15).add(u9).divide(t10.multiply(8)), { texture: y8 } = this.config, h20 = m7(y8, e8, this.config.srcImageSize), { x: f10, y: S8 } = f3(h20, a10), x6 = hn(f10.multiply(f10).add(S8.multiply(S8))), z5 = this.percentRise ? x6.multiply(100) : ie(x6).multiply(57.2957795), v7 = new _3(z5, z5, z5, h20[9]);
    return this.isOutputRounded ? a7(v7) : v7;
  }
};
__decorate([_4], h18.prototype, "isOutputRounded", void 0), __decorate([_4], h18.prototype, "percentRise", void 0), __decorate([m3(y6)], h18.prototype, "slopeConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/SlopeTechnique.js
var r13 = class extends i13 {
  constructor() {
    super(...arguments), this.name = "RasterSlopeProcessor", this.type = 20, this.shaders = { slope: new h18() };
  }
  _process(e8, s10) {
    const r15 = e8.rasterFunction.parameters, t10 = { isOutputRounded: r15.isOutputRounded, percentRise: "percent-rise" === r15.slopeType }, o6 = { cellSize: s10.getRasterCellSize(), pixelSizePower: "adjusted" === r15.slopeType ? r15.pixelSizePower : 0, pixelSizeFactor: "adjusted" === r15.slopeType ? r15.pixelSizeFactor : 0, zFactor: r15.zFactor }, i15 = this._getCommonConfig(e8, s10), p6 = { shader: this.shaders.slope, uniforms: { config: i15, slopeConfig: o6 }, defines: t10, optionalAttributes: null, useComputeBuffer: false }, { painter: a10, context: n7 } = e8;
    a10.submitDrawMesh(n7, p6, a10.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/raster/processor/StretchShader.js
var h19 = class extends h12 {
  constructor() {
    super(...arguments), this.type = "StretchShader", this.isMultiband = true, this.isOutputRounded = false, this.useGamma = false;
  }
  _process(t10) {
    const s10 = this._getPixel(t10);
    let r15 = T3(s10, this.stretchConfig, this.useGamma, 1);
    return this.isMultiband || (r15 = new _3(r15.rrr, r15.a)), this.isOutputRounded ? a7(r15) : r15;
  }
};
__decorate([_4], h19.prototype, "isMultiband", void 0), __decorate([_4], h19.prototype, "isOutputRounded", void 0), __decorate([_4], h19.prototype, "useGamma", void 0), __decorate([m3(b6)], h19.prototype, "stretchConfig", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/processor/StretchTechnique.js
var t9 = class extends i13 {
  constructor() {
    super(...arguments), this.name = "RasterStretchProcessor", this.type = 22, this.shaders = { stretch: new h19() };
  }
  _process(s10, e8) {
    const t10 = s10.rasterFunction.parameters, r15 = { isMultiband: t10.bandCount > 1, isOutputRounded: t10.isOutputRounded, useGamma: t10.useGamma }, o6 = this._getCommonConfig(s10, e8), a10 = { shader: this.shaders.stretch, uniforms: { config: o6, stretchConfig: t10 }, defines: r15, optionalAttributes: null, useComputeBuffer: false }, { painter: n7, context: i15 } = s10;
    n7.submitDrawMesh(i15, a10, n7.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/raster/RasterProcessorTechnique.js
var S6 = /* @__PURE__ */ new Map([["Aspect", t3], ["BandArithmetic", s5], ["ColormapToRGB", r7], ["CompositeBand", e6], ["ComputeChange", s6], ["ContrastBrightness", r8], ["Convolution", s7], ["Curvature", s8], ["ExtractBand", t5], ["Grayscale", r9], ["Hillshade", t6], ["Local", t7], ["Mask", a8], ["NDVI", r10], ["Remap", s9], ["Reproject", r12], ["ShadedRelief", t8], ["Slope", r13], ["Statistics", e7], ["Stretch", t9]]);
var g11 = class extends s2 {
  constructor() {
    super(...arguments), this.type = 1, this.shaders = {}, this._techniques = /* @__PURE__ */ new Map();
  }
  shutdown(e8) {
    super.shutdown(e8), this._fbo?.dispose(), this._fbo = void 0;
    for (const o6 of this._techniques.values()) o6.shutdown();
    this._techniques.clear();
  }
  render(o6, r15) {
    this._fbo ??= s4(o6.context, o2, o2);
    let { name: s10 } = o6.rasterFunction;
    if ("Arithmetic" === s10 && (s10 = "Local"), !this._techniques.has(s10)) {
      const e8 = S6.get(s10);
      if (!e8) return;
      this._techniques.set(s10, new e8());
    }
    this._techniques.get(s10).render(o6, { ...r15, processorFbo: this._fbo });
  }
};

// node_modules/@arcgis/core/views/2d/engine/imagery/RasterTileContainer.js
var o5 = class extends n3 {
  constructor() {
    super(...arguments), this.isCustomTilingScheme = false;
  }
  get pixelHighlights() {
    return this._pixelHighlights;
  }
  set pixelHighlights(e8) {
    this._pixelHighlights = e8, this.children.forEach(({ bitmap: e9 }) => e9.highlightTexture = null), this.requestRender();
  }
  createTile(e8) {
    const i15 = this._getTileBounds(e8), [s10, h20] = this.tileInfoView.tileInfo.size, r15 = this.tileInfoView.getTileResolution(e8.level);
    return new i11(e8, r15, i15[0], i15[3], s10, h20);
  }
  onAttach() {
    super.onAttach(), this._colorizerTechnique = new f5(), this._processorTechnique = new g11(), this._highlightTechnique = new g8();
  }
  onDetach() {
    super.onDetach(), this._colorizerTechnique?.shutdown(), this._colorizerTechnique = void 0, this._processorTechnique?.shutdown(), this._processorTechnique = void 0, this._highlightTechnique?.shutdown(), this._highlightTechnique = void 0;
  }
  doRender(e8) {
    if (!this.visible || 1 !== e8.drawPhase || !this._colorizerTechnique) return;
    const { rasterFunctionChain: i15 } = this;
    if (i15?.functions?.length) {
      if (!this._processorTechnique) return;
      const { functions: t11, hasBranches: s10 } = i15;
      for (const i16 of t11) {
        if ("Constant" === i16.name || "Identity" === i16.name) continue;
        e8.rasterFunction = i16, e8.hasBranches = s10, super.doRender(e8);
        const t12 = this.children.map((e9) => e9.bitmap);
        this._processorTechnique.render(e8, { bitmaps: t12 });
      }
    }
    if (this._pixelHighlights?.length && this._highlightTechnique) for (const s10 of this._pixelHighlights) {
      e8.pixelHighlightOptions = s10, super.doRender(e8);
      const i16 = this.children.map((e9) => e9.bitmap);
      this._highlightTechnique.render(e8, { bitmaps: i16 });
    }
    e8.rasterFunction = null, e8.pixelHighlightOptions = void 0, super.doRender(e8);
    const t10 = this.children.map((e9) => e9.bitmap);
    this._colorizerTechnique.render(e8, { bitmaps: t10 });
  }
  _getTileBounds(t10) {
    const s10 = this.tileInfoView.getTileBounds(i3(), t10);
    if (this.isCustomTilingScheme && t10.world) {
      const { tileInfo: e8 } = this.tileInfoView, h20 = mt(e8.spatialReference);
      if (h20) {
        const i15 = e8.lodAt(t10.level);
        if (!i15) return s10;
        const { resolution: r15 } = i15, n7 = r15 * e8.size[0];
        s10[0] = h20 * t10.world + e8.origin.x + t10.col * n7, s10[2] = s10[0] + n7;
      }
    }
    return s10;
  }
};

// node_modules/@arcgis/core/views/2d/layers/imagery/BaseImageryTileSubView2D.js
var C6 = [0, 0];
var S7 = class extends b {
  constructor() {
    super(...arguments), this._updatingHandles = new h3(), this._emptyTilePixelBlock = null, this._tileStrategy = null, this._tileInfoView = null, this._fetchQueue = null, this._blockCacheRegistryUrl = null, this._blockCacheRegistryId = null, this._srcResolutions = [], this.previousLOD = null, this._needBlockCacheUpdate = false, this._globalSymbolizerParams = null, this._symbolizerParams = null, this._abortController = null, this._isCustomTilingScheme = false, this._maxIndexedColormapSize = 0, this._rasterFunctionState = "na", this._globalUpdateRequested = false, this.attached = false, this.timeExtent = null, this.redrawOrRefetch = L(async (e8 = {}) => {
      const t10 = this._rasterFunctionState, i15 = e8.reprocess || "gpu" === t10 && !this.canUseWebGLForProcessing || "cpu" === t10 && this.canUseWebGLForProcessing;
      if (i15 && (await this._updatingHandles.addPromise(this.layer.updateRasterFunction()), this.updateRasterFunctionParameters()), !this.previousLOD || this.layerView.suspended) return;
      const s10 = this._rasterFunctionState, { type: r15 } = this;
      return e8.refetch || "raster" !== r15 && !!i15 || "cpu" === s10 || "cpu" === t10 ? this._updatingHandles.addPromise(this.doRefresh()) : this._updatingHandles.addPromise(this._redrawImage(e8.signal));
    });
  }
  destroy() {
    this._updatingHandles.destroy();
  }
  get canUseWebGLForProcessing() {
    return false;
  }
  get canUseLocalSymbolizerParams() {
    return (this.canUseWebGLForProcessing || "rasterVF" === this.type) && !this.layerView.hasTilingEffects;
  }
  get isCPUBasedDRA() {
    const { renderer: e8 } = this.layer;
    return "raster-stretch" === e8?.type && e8.dynamicRangeAdjustment && (!this.canUseWebGLForProcessing || !("min-max" === e8.stretchType || "standard-deviation" === e8.stretchType));
  }
  get useWebGLForProcessing() {
    return this._get("useWebGLForProcessing") ?? true;
  }
  set useWebGLForProcessing(e8) {
    this._set("useWebGLForProcessing", e8);
  }
  get useProgressiveUpdate() {
    return this._get("useProgressiveUpdate") ?? true;
  }
  set useProgressiveUpdate(e8) {
    if (this._tileStrategy && this.useProgressiveUpdate !== e8) {
      this._tileStrategy.destroy(), this.container.removeAllChildren();
      const t10 = this._getCacheSize(e8);
      this._tileStrategy = new r3({ cachePolicy: "purge", acquireTile: (e9) => this.acquireTile(e9), releaseTile: (e9) => this.releaseTile(e9), cacheSize: t10, tileInfoView: this._tileInfoView }), this._set("useProgressiveUpdate", e8), this.layerView.requestUpdate();
    }
  }
  update(e8) {
    this._fetchQueue.pause(), this._fetchQueue.state = e8.state, this._tileStrategy.update(e8), this._fetchQueue.resume();
    const { extent: t10, resolution: i15, scale: s10 } = e8.state, r15 = this._tileInfoView.getClosestInfoForScale(s10);
    if (this.layer.raster) {
      if (!this.useProgressiveUpdate || this._needBlockCacheUpdate) {
        const e9 = this._srcResolutions[r15.level], s11 = "toJSON" in t10 ? t10 : z.fromJSON(t10);
        g(this._blockCacheRegistryUrl, this._blockCacheRegistryId, s11, i15, e9, this.layer.raster.ioConfig.sampling);
      }
      this._needBlockCacheUpdate = false, this.previousLOD?.level !== r15.level && (this.previousLOD = r15, null != this._symbolizerParams && this.canUseLocalSymbolizerParams && this._updateSymbolizerParams(), this._tileStrategy.updateCacheSize(0));
    }
  }
  moveEnd() {
    !this.isCPUBasedDRA && this.useProgressiveUpdate || (this._abortController && this._abortController.abort(), this._abortController = new AbortController(), 0 === this._fetchQueue.length && this._redrawImage(this._abortController.signal).then(() => {
      this._globalUpdateRequested = false, this.layerView.requestUpdate();
    }));
    const e8 = this._getCacheSize(this.useProgressiveUpdate);
    this._tileStrategy.updateCacheSize(e8), this.layerView.requestUpdate();
  }
  get updating() {
    return this._globalUpdateRequested || this._updatingHandles?.updating;
  }
  attach() {
    const e8 = t2();
    this._maxIndexedColormapSize = 4 * (e8.maxTextureSize || 4096), this._initializeTileInfo(), this._tileInfoView = new h4(this.layerView.tileInfo, this.layerView.fullExtent);
    const t10 = this._computeFetchConcurrency();
    this._fetchQueue = new p({ tileInfoView: this._tileInfoView, concurrency: t10, process: (e9, t11) => this._fetchTile(e9, t11), priority: f.MAPVIEW_FETCH_QUEUE, scheduler: this.scheduler });
    const i15 = this._getCacheSize(this.useProgressiveUpdate);
    this._tileStrategy = new r3({ cachePolicy: "purge", acquireTile: (e9) => this.acquireTile(e9), releaseTile: (e9) => this.releaseTile(e9), cacheSize: i15, tileInfoView: this._tileInfoView }), this._updateBlockCacheRegistry();
  }
  detach() {
    this._tileStrategy.destroy(), this._fetchQueue.clear(), this.container.removeAllChildren(), this._fetchQueue = this._tileStrategy = this._tileInfoView = null, a3(this._blockCacheRegistryUrl, this._blockCacheRegistryId), this._blockCacheRegistryUrl = this._blockCacheRegistryId = null;
  }
  acquireTile(e8) {
    const t10 = this.container.createTile(e8);
    return this._updatingHandles.addPromise(this._enqueueTileFetch(t10)), this.layerView.requestUpdate(), this._needBlockCacheUpdate = true, this._globalUpdateRequested = this.isCPUBasedDRA || !this.useProgressiveUpdate, t10;
  }
  releaseTile(e8) {
    this._fetchQueue.abort(e8.key.id), this.container.removeChild(e8), e8.once("detach", () => {
      e8.destroy(), this.layerView.requestUpdate();
    }), this.layerView.requestUpdate();
  }
  createEmptyTilePixelBlock(e8 = null) {
    const t10 = null == e8 || e8.join(",") === this._tileInfoView.tileInfo.size.join(",");
    if (t10 && null != this._emptyTilePixelBlock) return this._emptyTilePixelBlock;
    e8 = e8 || this._tileInfoView.tileInfo.size;
    const [i15, s10] = e8, r15 = new c({ width: i15, height: s10, pixels: [new Uint8Array(i15 * s10)], mask: new Uint8Array(i15 * s10), pixelType: "u8" });
    return t10 && (this._emptyTilePixelBlock = r15), r15;
  }
  _getBandIds() {
    if (this.container && (!("rasterFunctionChain" in this.container) || !this.container.rasterFunctionChain)) return this.layer.bandIds;
    const { bandIds: e8, raster: t10 } = this.layer, i15 = "rasterFunction" in t10 ? t10.rasterFunction.rawInputBandIds : null;
    return e8?.length && i15?.length && 1 !== t10.rasterInfo.bandCount ? e8.map((e9) => i15[Math.min(e9, i15.length - 1)]) : "rasterFunction" in t10 ? i15 : e8;
  }
  updateRasterFunctionParameters() {
  }
  _fetchTile(e8, t10) {
    const i15 = this._getFetchOptions(e8.level, t10.signal);
    return this.fetchTile(e8, i15);
  }
  _getFetchOptions(e8, t10) {
    const { canUseWebGLForProcessing: i15 } = this, { layerView: s10 } = this, { tileInfo: r15 } = s10, a10 = !r15.isWrappable && null != $(s10.view.spatialReference), o6 = i15 && this.layer.raster.hasUniqueSourceStorageInfo, { layer: l7 } = this.layerView, n7 = l7.serviceRasterInfo?.storageInfo.isBsqTile ? l7.getRawDisplayBandIds() : void 0;
    return { allowPartialFill: true, datumTransformation: s10.datumTransformation, interpolation: i15 ? "nearest" : this.layer.interpolation, registryId: this._blockCacheRegistryId, requestRawData: o6, skipRasterFunction: "raster" === this.type && null != this.container.rasterFunctionChain, signal: t10, srcResolution: this._srcResolutions[e8], timeExtent: s10.timeExtent, tileInfo: r15, bandIds: n7, disableWrapAround: a10 };
  }
  _getCacheSize(e8) {
    return e8 ? 40 : 0;
  }
  _initializeTileInfo() {
    const { layerView: e8 } = this, t10 = e8.view.spatialReference;
    if (this._canUseLayerLODs()) {
      const { origin: i16, lods: s10 } = this.layer.tileInfo, r16 = s10.map(({ scale: e9 }) => e9), a11 = z2.create({ spatialReference: t10, size: o2, scales: r16, origin: i16 });
      return e8.set("tileInfo", a11), void (this._srcResolutions = s10.map(({ resolution: e9 }) => ({ x: e9, y: e9 })));
    }
    const { scales: i15, srcResolutions: r15, isCustomTilingScheme: a10 } = me(this.layer.serviceRasterInfo, t10, { tileSize: o2, alignGlobalDatasetWithAGOL: true, limitToSrcResolution: false }), o6 = z2.create({ spatialReference: t10, size: o2, scales: i15 }), l7 = 0 === o6.origin.x;
    n(e8.fullExtent);
    const { xmin: n7, ymax: h20 } = e8.fullExtent;
    (l7 || a10 && o6.origin.x > n7) && (o6.origin = new _({ x: n7, y: h20, spatialReference: t10 })), this._isCustomTilingScheme = a10, e8.set("tileInfo", o6), this._srcResolutions = r15 ?? [];
  }
  _canUseLayerLODs() {
    const { layer: e8, layerView: t10 } = this;
    if ("Map" !== e8.raster.tileType) return false;
    const { lods: i15 } = e8.tileInfo, s10 = t10.view.constraints?.effectiveLODs;
    return s10?.length === i15.length && s10.every(({ scale: e9 }, t11) => Math.abs(e9 - i15[t11].scale) < 1e-3);
  }
  _computeFetchConcurrency() {
    const { blockBoundary: e8 } = this.layer.serviceRasterInfo.storageInfo, t10 = e8[e8.length - 1];
    return (t10.maxCol - t10.minCol + 1) * (t10.maxRow - t10.minRow + 1) > 64 ? 2 : 10;
  }
  async _enqueueTileFetch(e8, t10) {
    if (!this._fetchQueue.has(e8.key.id)) {
      try {
        let t11 = e8.once("detach", () => t11 = void 0);
        const r15 = await this._fetchQueue.push(e8.key), o6 = this._getBandIds();
        let l7 = !this.useProgressiveUpdate || this.isCPUBasedDRA && !this._globalSymbolizerParams;
        if (this._globalUpdateRequested && !this.layerView.moving && 0 === this._fetchQueue.length) {
          l7 = false;
          try {
            await this._redrawImage(this._abortController?.signal);
          } catch (s10) {
            d(s10) && i.getLogger(this).error(s10);
          }
          this._globalUpdateRequested = false;
        }
        if (!t11) return;
        this.canUseLocalSymbolizerParams && null == this._symbolizerParams && this._updateSymbolizerParams();
        const n7 = this._tileInfoView.getTileCoords(C6, e8.key), h20 = this._tileInfoView.getTileResolution(e8.key);
        await this.updateTileSource(e8, { source: r15, symbolizerParams: this._symbolizerParams, globalSymbolizerParams: this._globalSymbolizerParams, suspended: l7, bandIds: o6, coords: n7, resolution: h20 }), t11 && (e8.once("attach", () => this.layerView.requestUpdate()), this.container.addChild(e8), t11.remove());
      } catch (s10) {
        d(s10) || i.getLogger(this).error(s10);
      }
      this.layerView.requestUpdate();
    }
  }
  async _redrawImage(e8) {
    if (!this.attached || 0 === this.container.children.length) return;
    if (await this.layer.updateRenderer(), this.isCPUBasedDRA ? await this._updateGlobalSymbolizerParams(e8) : (this.canUseLocalSymbolizerParams && this._updateSymbolizerParams(), this._globalSymbolizerParams = null), !this.attached || e8?.aborted) return;
    const t10 = this.container.children.map(async (t11) => this.updateTileSymbolizerParameters(t11, { local: this._symbolizerParams, global: this._globalSymbolizerParams }, e8));
    await Promise.allSettled(t10), this.attached && !e8?.aborted && this.container.requestRender();
  }
  async _updateGlobalSymbolizerParams(e8) {
    const t10 = this._getFetchOptions(this.previousLOD.level, e8), i15 = await this.layer.fetchPixels(this.layerView.view.extent, this.layerView.view.width, this.layerView.view.height, { ...t10, interpolation: "nearest", requestRawData: false, skipRasterFunction: false });
    if (!i15?.pixelBlock) return;
    const { resolution: s10 } = this.previousLOD, { isBsqTile: r15 } = this.layer.raster.rasterInfo.storageInfo, a10 = r15 ? null : this._getBandIds(), o6 = this.layer.symbolizer.generateWebGLParameters({ pixelBlock: i15.pixelBlock.extractBands(a10), isGCS: this.layerView.view.spatialReference.isGeographic, resolution: { x: s10, y: s10 }, bandIds: a10 });
    !this.canUseWebGLForProcessing && o6 && "stretch" === o6.type && this.layer.renderer && "raster-stretch" === this.layer.renderer.type && (o6.factor = o6.factor.map((e9) => 255 * e9), o6.minOutput = Math.round(255 * o6.minOutput), o6.maxOutput = Math.round(255 * o6.maxOutput)), this._globalSymbolizerParams = o6;
  }
  _updateSymbolizerParams() {
    const { resolution: e8 } = this.previousLOD, t10 = this._getBandIds();
    this._symbolizerParams = this.layer.symbolizer.generateWebGLParameters({ pixelBlock: null, isGCS: this.layerView.view.spatialReference.isGeographic, resolution: { x: e8, y: e8 }, bandIds: t10 });
  }
  _updateBlockCacheRegistry(e8 = false) {
    const { layer: t10, layerView: i15 } = this, { raster: s10 } = t10, { multidimensionalDefinition: r15 } = t10.normalizeRasterFetchOptions({ multidimensionalDefinition: t10.multidimensionalDefinition, timeExtent: i15.timeExtent }), a10 = s10.rasterInfo.multidimensionalInfo ? s10.getSliceIndex(r15) : null, o6 = s10.rasterInfo.storageInfo.isBsqTile ? t10.getRawDisplayBandIds() : null, l7 = i6(s10.rasterId, a10, o6);
    if (l7 !== this._blockCacheRegistryUrl) {
      if (null != this._blockCacheRegistryUrl && a3(this._blockCacheRegistryUrl, this._blockCacheRegistryId), this._blockCacheRegistryId = u3(l7, s10.rasterInfo), e8) {
        const { view: e9 } = i15, t11 = this._tileInfoView.getClosestInfoForScale(e9.scale), r16 = this._srcResolutions[t11.level];
        g(l7, this._blockCacheRegistryId, e9.extent, e9.resolution, r16, s10.ioConfig.sampling);
      }
      this._blockCacheRegistryUrl = l7;
    }
  }
  async doRefresh() {
    if (!this.attached || !this.previousLOD || this.layerView.suspended) return;
    await this.layer.updateRenderer(), this.canUseLocalSymbolizerParams && this._updateSymbolizerParams(), this._updateBlockCacheRegistry(true), this._fetchQueue.reset();
    const e8 = [];
    this._globalUpdateRequested = this.isCPUBasedDRA || !this.useProgressiveUpdate, this._tileStrategy.refresh((t10) => e8.push(this._enqueueTileFetch(t10))), await this._updatingHandles.addPromise(Promise.allSettled(e8));
  }
};
__decorate([m()], S7.prototype, "_globalUpdateRequested", void 0), __decorate([m()], S7.prototype, "attached", void 0), __decorate([m()], S7.prototype, "canUseWebGLForProcessing", null), __decorate([m()], S7.prototype, "canUseLocalSymbolizerParams", null), __decorate([m()], S7.prototype, "isCPUBasedDRA", null), __decorate([m()], S7.prototype, "container", void 0), __decorate([m()], S7.prototype, "layer", void 0), __decorate([m()], S7.prototype, "layerView", void 0), __decorate([m()], S7.prototype, "scheduler", void 0), __decorate([m()], S7.prototype, "type", void 0), __decorate([m()], S7.prototype, "useWebGLForProcessing", null), __decorate([m()], S7.prototype, "useProgressiveUpdate", null), __decorate([m()], S7.prototype, "timeExtent", void 0), __decorate([m()], S7.prototype, "updating", null), S7 = __decorate([a("esri.views.2d.layers.imagery.BaseImageryTileSubView2D")], S7);

// node_modules/@arcgis/core/views/2d/layers/imagery/ImageryTileView2D.js
var m11 = class extends S7 {
  constructor() {
    super(...arguments), this.type = "raster";
  }
  get canUseWebGLForProcessing() {
    const { loaded: e8, symbolizer: t10 } = this.layer;
    if (!e8 || !t10) return false;
    const r15 = t10.lookup.colormapLut?.indexedColormap, s10 = r15 && r15.length > this._maxIndexedColormapSize, i15 = l2(this.layer.serviceRasterInfo);
    return !(has("ios") && i15 > 4) && this.useWebGLForProcessing && t10.canRenderInWebGL && !s10 && !("majority" === this.layer.interpolation && o3(this.layer));
  }
  attach() {
    super.attach(), this.container = new o5(this._tileInfoView), this.container.isCustomTilingScheme = this._isCustomTilingScheme, this.updateRasterFunctionParameters();
  }
  detach() {
    super.detach(), this.container.removeAllChildren(), this.container = null;
  }
  fetchTile(e8, t10) {
    return this.layer.fetchTile(e8.level, e8.row, e8.col, t10);
  }
  updateRasterFunctionParameters() {
    const { raster: e8, type: t10 } = this.layer, { container: r15 } = this;
    if ("Function" !== e8.datasetFormat || "wcs" === t10) return r15.rasterFunctionChain = null, r15.children.forEach((e9) => {
      const { bitmap: t11 } = e9;
      t11 && (t11.suspended = true, t11.processed = false, t11.projected && (t11.invalidateTexture(), t11.rasterTexture = null));
    }), void (this._rasterFunctionState = "na");
    const s10 = this._rasterFunctionState, { rasterFunction: i15, primaryRasters: o6 } = e8, n7 = i15.supportsGPU && (!o6 || o6.rasters.length <= 1), a10 = n7 ? i15.flatWebGLFunctionChain : null, { renderer: l7 } = this.layer, c10 = !n7 || !a10?.functions.length || "raster-stretch" === l7?.type && l7.dynamicRangeAdjustment || !this.canUseWebGLForProcessing;
    r15.rasterFunctionChain = c10 ? null : this._addProjection(a10);
    const p6 = null == i15 ? "na" : r15.rasterFunctionChain ? "gpu" : "cpu", u9 = s10 === p6 || "na" === s10 && "cpu" === p6 && 0 === a10?.functions?.length;
    r15.children.forEach((e9) => {
      const { bitmap: t11 } = e9;
      t11 && (t11.suspended = !u9, t11.processed = false, t11.processedTexture = null);
    }), this._rasterFunctionState = p6;
  }
  async updateTileSource(e8, t10) {
    const r15 = this._getBandIds(), s10 = this._getLayerInterpolation(), { canUseWebGLForProcessing: i15 } = this, { source: n7, globalSymbolizerParams: l7, suspended: c10, coords: p6, resolution: u9 } = t10, h20 = this.isCPUBasedDRA ? l7 : t10.symbolizerParams, { bitmap: d8 } = e8;
    if ([d8.x, d8.y] = p6, d8.resolution = u9, null != n7?.pixelBlock) {
      const e9 = { extent: n7.extent, pixelBlock: n7.pixelBlock, srcPixelSize: n7.srcTilePixelSize };
      if (d8.rawPixelData = e9, i15) d8.source = n7.pixelBlock, d8.isRendereredSource = false;
      else {
        const t11 = await this.layer.applyRenderer(e9, "stretch" === l7?.type ? l7 : void 0);
        d8.source = t11, d8.isRendereredSource = true;
      }
      d8.symbolizerParameters = i15 ? h20 : null, d8.transformGrid = i15 ? n7.transformGrid : null;
    } else {
      const e9 = this.createEmptyTilePixelBlock();
      d8.source = e9, d8.symbolizerParameters = i15 ? h20 : null, d8.transformGrid = null;
    }
    const { isBsqTile: m12 } = this.layer.raster.rasterInfo.storageInfo;
    d8.bandIds = i15 && !m12 ? r15 : null, d8.width = this._tileInfoView.tileInfo.size[0], d8.height = this._tileInfoView.tileInfo.size[1], d8.interpolation = s10, d8.suspended = c10;
    const { raster: f10 } = this.layer;
    if (t(f10)) {
      const t11 = f10.getClippingGeometry(this.layerView.view.spatialReference);
      if (t11) {
        const r16 = f10.getTileExtentFromTileInfo(e8.key.level, e8.key.row, e8.key.col, this._tileInfoView.tileInfo);
        r16 && (d8.mask = h5({ srcExtent: r16, geometry: t11, size: [d8.width, d8.height] }));
      }
    }
    d8.invalidateTexture();
  }
  async updateTileSymbolizerParameters(e8, t10, r15) {
    const { local: s10, global: i15 } = t10, o6 = this._getBandIds(), n7 = this._getLayerInterpolation(), { canUseWebGLForProcessing: a10 } = this, { bitmap: l7 } = e8, { rawPixelData: c10 } = l7;
    a10 || null == c10 ? (l7.isRendereredSource && null != c10 && (l7.source = c10.pixelBlock), l7.isRendereredSource = false) : (l7.source = await this.layer.applyRenderer(c10, "stretch" === i15?.type ? i15 : void 0, { signal: r15 }), l7.isRendereredSource = true), l7.symbolizerParameters = a10 ? this.layerView.hasTilingEffects ? i15 : s10 : null;
    const { isBsqTile: p6 } = this.layer.raster.rasterInfo.storageInfo;
    l7.bandIds = a10 && !p6 ? o6 : null, l7.interpolation = n7, l7.suspended = false;
  }
  updateHighlightOptions(e8) {
    if (!e8.length) return void (this.container.pixelHighlights = void 0);
    const s10 = [], { highlights: i15 } = this.layerView.view;
    e8.sort((e9, t10) => i15.findIndex(({ name: e10 }) => e10 === r6(t10.options)) - i15.findIndex(({ name: t11 }) => t11 === r6(e9.options)));
    for (const { target: o6, options: n7 } of e8) {
      const { pixelRanges: e9 } = o6, a10 = Array.from({ length: 2 * l3 }, () => 0);
      for (let t10 = 0; t10 < e9.length; t10++) a10[2 * t10] = e9[t10][0], a10[2 * t10 + 1] = e9[t10][1];
      for (let t10 = e9.length; t10 < l3; t10++) a10[2 * t10] = q, a10[2 * t10 + 1] = -q;
      const c10 = o6.bandId ?? 0, p6 = r6(n7), u9 = i15.find((e10) => e10.name === p6)?.color ?? e2, m12 = u2.toUnitRGBA(u9);
      s10.push({ ranges: a10, bandId: c10, color: m12 });
    }
    this.container.pixelHighlights = s10;
  }
  _getLayerInterpolation() {
    const { interpolation: e8, renderer: t10 } = this.layer;
    if (!t10) return e8;
    const r15 = t10.type;
    return "raster-colormap" === r15 || "unique-value" === r15 ? "nearest" : "raster-stretch" === t10.type && null != t10.colorRamp ? "bilinear" === e8 || "cubic" === e8 ? "bilinear" : "nearest" : e8;
  }
  _addProjection(e8) {
    return e8?.functions?.length && !e8.hasFocalFunction && e8.functions.unshift({ name: "Reproject", parameters: { targetImageSize: this._tileInfoView.tileInfo.size, requireNNEdge: e8.isSourceSingleBand }, pixelType: "f32", id: 0, isNoopProcess: false }), e8;
  }
};
__decorate([m()], m11.prototype, "canUseWebGLForProcessing", null), __decorate([m()], m11.prototype, "container", void 0), __decorate([m()], m11.prototype, "layer", void 0), __decorate([m()], m11.prototype, "type", void 0), m11 = __decorate([a("esri.views.2d.layers.imagery.ImageryTileView2D")], m11);

// node_modules/@arcgis/core/views/2d/engine/imagery/RasterVFTile.js
var r14 = class extends r5 {
  constructor(t10, e8, s10, a10, r15, l7, o6 = null) {
    super(t10, e8, s10, a10, r15, l7), this.tileData = new v3(o6), this.tileData.coordScale = [r15, l7], this.tileData.once("isReady", () => this.ready());
  }
  destroy() {
    super.destroy(), this.tileData.destroy(), this.tileData = null, this.stage = null;
  }
  set stencilRef(t10) {
    this.tileData.stencilRef = t10;
  }
  get stencilRef() {
    return this.tileData.stencilRef;
  }
  _createTransforms() {
    return { displayViewScreenMat3: e3(), tileMat3: e3() };
  }
  setTransform(s10) {
    super.setTransform(s10);
    const i15 = this.resolution / (s10.resolution * s10.pixelRatio), a10 = this.transforms.tileMat3, [r15, l7] = this.tileData.offset, o6 = [this.x + r15 * this.resolution, this.y - l7 * this.resolution], [n7, h20] = s10.toScreenNoRotation([0, 0], o6), { symbolTileSize: c10 } = this.tileData.symbolizerParameters, f10 = Math.round((this.width - this.tileData.offset[0]) / c10) * c10, m12 = Math.round((this.height - this.tileData.offset[1]) / c10) * c10, D4 = f10 / this.rangeX * i15, d8 = m12 / this.rangeY * i15;
    r2(a10, D4, 0, 0, 0, d8, 0, n7, h20, 1), i4(this.transforms.displayViewScreenMat3, s10.displayViewMat3, a10), this.tileData.transforms.displayViewScreenMat3 = this.transforms.displayViewScreenMat3;
  }
  onAttach() {
    this.tileData.stage = this.stage;
  }
  onDetach() {
    this.tileData.stage = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/imagery/RasterVFTileContainer.js
var i14 = class extends n3 {
  constructor() {
    super(...arguments), this.isCustomTilingScheme = false, this.symbolTypes = ["triangle"];
  }
  createTile(s10) {
    const t10 = this.tileInfoView.getTileBounds(i3(), s10), [i15, o6] = this.tileInfoView.tileInfo.size, n7 = this.tileInfoView.getTileResolution(s10.level);
    return new r14(s10, n7, t10[0], t10[3], i15, o6);
  }
  prepareRenderPasses(e8) {
    const r15 = e8.registerRenderPass({ name: "imagery (vf tile)", brushes: [i9], target: () => this.children.map((e9) => e9.tileData), drawPhase: 1 });
    return [...super.prepareRenderPasses(e8), r15];
  }
  doRender(e8) {
    this.visible && 1 === e8.drawPhase && this.symbolTypes.forEach((s10) => {
      e8.renderPass = s10, super.doRender(e8);
    });
  }
};

// node_modules/@arcgis/core/views/2d/layers/imagery/VectorFieldTileView2D.js
var a9 = class extends S7 {
  constructor() {
    super(...arguments), this._handle = null, this.type = "rasterVF";
  }
  async fetchTile(e8, t10) {
    t10 = { ...t10, interpolation: "nearest", requestProjectedLocalDirections: true };
    const i15 = await this.layer.fetchTile(e8.level, e8.row, e8.col, t10);
    return "vector-magdir" === this.layer.serviceRasterInfo?.dataType && i15?.pixelBlock && (i15.pixelBlock = await this.layer.convertVectorFieldData(i15.pixelBlock, "vector-magdir", t10)), i15;
  }
  updateTileSource(e8, t10) {
    const i15 = t10.symbolizerParams, { tileData: r15 } = e8;
    r15.key = e8.key, r15.width = this._tileInfoView.tileInfo.size[0], r15.height = this._tileInfoView.tileInfo.size[1];
    const { symbolTileSize: o6 } = i15, { source: s10 } = t10;
    if (r15.offset = this._getTileSymbolOffset(r15.key, o6), null != s10?.pixelBlock) {
      const e9 = { extent: s10.extent, pixelBlock: s10.pixelBlock };
      r15.rawPixelData = e9, r15.symbolizerParameters = i15, r15.source = this._sampleVectorFieldData(s10.pixelBlock, i15, r15.offset);
    } else {
      const e9 = [Math.round((this._tileInfoView.tileInfo.size[0] - r15.offset[0]) / o6), Math.round((this._tileInfoView.tileInfo.size[1] - r15.offset[1]) / o6)], t11 = this.createEmptyTilePixelBlock(e9);
      r15.source = t11, r15.symbolizerParameters = i15;
    }
    return r15.invalidateVAO(), Promise.resolve();
  }
  updateTileSymbolizerParameters(e8, t10) {
    const i15 = t10.local, { symbolTileSize: r15 } = i15, { tileData: o6 } = e8;
    o6.offset = this._getTileSymbolOffset(o6.key, r15);
    const s10 = o6.symbolizerParameters.symbolTileSize;
    o6.symbolizerParameters = i15;
    const l7 = o6.rawPixelData?.pixelBlock;
    return null != l7 && s10 !== r15 && (o6.source = this._sampleVectorFieldData(l7, o6.symbolizerParameters, o6.offset)), Promise.resolve();
  }
  attach() {
    super.attach(), this.container = new i14(this._tileInfoView), this.container.isCustomTilingScheme = this._isCustomTilingScheme, this._updateSymbolType(this.layer.renderer), this._handle = l(() => this.layer.renderer, (e8) => this._updateSymbolType(e8));
  }
  detach() {
    super.detach(), this.container.removeAllChildren(), this._handle?.remove(), this._handle = null, this.container = null;
  }
  _getTileSymbolOffset(e8, t10) {
    const i15 = e8.col * this._tileInfoView.tileInfo.size[0] % t10, r15 = e8.row * this._tileInfoView.tileInfo.size[1] % t10;
    return [i15 > t10 / 2 ? t10 - i15 : -i15, r15 > t10 / 2 ? t10 - r15 : -r15];
  }
  _sampleVectorFieldData(e8, t10, i15) {
    const { symbolTileSize: r15 } = t10;
    return S(e8, "vector-uv", r15, i15);
  }
  _updateSymbolType(e8) {
    "vector-field" === e8?.type && (this.container.symbolTypes = "wind-barb" === e8.style ? ["scalar", "triangle"] : "simple-scalar" === e8.style ? ["scalar"] : ["triangle"]);
  }
};
__decorate([m()], a9.prototype, "container", void 0), __decorate([m()], a9.prototype, "layer", void 0), __decorate([m()], a9.prototype, "type", void 0), a9 = __decorate([a("esri.views.2d.layers.imagery.VectorFieldTileView2D")], a9);

// node_modules/@arcgis/core/views/layers/ImageryTileLayerView.js
var f9 = (f10) => {
  const h20 = f10;
  let d8 = class extends h20 {
    constructor(...t10) {
      super(...t10), this.layer = null, this.tileInfo = null;
    }
    get fullExtent() {
      try {
        return this.layer.loaded ? this._getFullExtent() : null;
      } catch {
        return null;
      }
    }
    get timeExtent() {
      return i8(this.layer, this.view?.timeExtent, this._get("timeExtent"));
    }
    get hasTilingEffects() {
      const { renderer: t10 } = this.layer;
      return !!("raster-stretch" === t10?.type && t10.dynamicRangeAdjustment && !("min-max" === t10.stretchType || "standard-deviation" === t10.stretchType));
    }
    get datumTransformation() {
      try {
        return this.layer.loaded ? v(this.layer.fullExtent, this.view.spatialReference, true) : null;
      } catch {
        return null;
      }
    }
    supportsSpatialReference(t10) {
      try {
        return !this.layer.loaded || !!ue(this.layer.serviceRasterInfo, t10);
      } catch {
        return false;
      }
    }
    async fetchPopupFeaturesAtLocation(t10, i15) {
      const { layer: s10 } = this;
      if (!t10) throw new s("imageryTileLayerView:fetchPopupFeatures", "Nothing to fetch without area", { layer: s10 });
      const { popupEnabled: l7 } = s10, p6 = n2(s10, i15);
      if (!l7 || null == p6) return [];
      const c10 = [], { value: m12, magdirValue: f11, processedValue: h21 } = await s10.identify(t10, { timeExtent: this.timeExtent, signal: i15?.signal });
      let d9 = "";
      if (m12?.length) {
        d9 = "imagery-tile" === s10.type && s10.hasStandardTime() && null != m12[0] ? m12.map((t12) => s10.getStandardTimeValue(t12)).join(", ") : m12.join(", ");
        const t11 = { ObjectId: 0 };
        t11[i5.servicePixelValue] = "imagery-tile" === s10.type && t(s10.raster) ? h21?.join(", ") : d9, t11[i5.rawServicePixelValue] = d9;
        const r15 = s10.raster?.rasterInfo ?? s10.serviceRasterInfo, i16 = r15?.attributeTable;
        if (null != i16) {
          const { fields: e8, features: r16 } = i16, s11 = e8.find(({ name: t12 }) => "value" === t12.toLowerCase()), a10 = t11[i5.servicePixelValue], l9 = s11 ? r16.find((t12) => String(t12.attributes[s11.name]) === a10) : null;
          if (l9) {
            for (const i17 in l9.attributes) if (l9.attributes.hasOwnProperty(i17)) {
              t11[a2 + i17] = l9.attributes[i17];
            }
          }
        }
        const l8 = r15?.dataType;
        "vector-magdir" !== l8 && "vector-uv" !== l8 || (t11[i5.magnitude] = f11?.[0], t11[i5.direction] = f11?.[1]);
        const { multidimensionalDefinition: p7 } = this.layer.normalizeRasterFetchOptions({ timeExtent: this.timeExtent });
        V(s10.rasterFields, t11, p7);
        const { graphicOrigin: y8 } = s10, g12 = new _2({ geometry: this.fullExtent?.clone(), attributes: t11, layer: s10, origin: y8, sourceLayer: s10 });
        c10.push(g12);
      }
      return c10;
    }
    async getSourceScale() {
      return await this.layer.load(), I(this.layer.serviceRasterInfo, this.view.spatialReference);
    }
    _getFullExtent() {
      return ue(this.layer.serviceRasterInfo, this.view.spatialReference);
    }
  };
  return __decorate([m()], d8.prototype, "fullExtent", null), __decorate([m()], d8.prototype, "layer", void 0), __decorate([m({ readOnly: true })], d8.prototype, "timeExtent", null), __decorate([m()], d8.prototype, "tileInfo", void 0), __decorate([m({ readOnly: true })], d8.prototype, "hasTilingEffects", null), __decorate([m()], d8.prototype, "datumTransformation", null), d8 = __decorate([a("esri.views.layers.ImageryTileLayerView")], d8), d8;
};

// node_modules/@arcgis/core/views/2d/layers/ImageryTileLayerView2D.js
var b8 = class extends f9(i7(b3(d2))) {
  constructor() {
    super(...arguments), this._useWebGLForProcessing = true, this._useProgressiveUpdate = true, this._pixelHighlights = [], this.subview = null;
  }
  get useWebGLForProcessing() {
    return this._useWebGLForProcessing;
  }
  set useWebGLForProcessing(e8) {
    this._useWebGLForProcessing = e8, this.subview && "useWebGLForProcessing" in this.subview && (this.subview.useWebGLForProcessing = e8);
  }
  get useProgressiveUpdate() {
    return this._useWebGLForProcessing;
  }
  set useProgressiveUpdate(e8) {
    this._useProgressiveUpdate = e8, this.subview && "useProgressiveUpdate" in this.subview && (this.subview.useProgressiveUpdate = e8);
  }
  get displayParameters() {
    const { layer: e8 } = this, i15 = this._get("displayParameters");
    return e8.renderer && e8.visible ? { bandIds: e8.bandIds, renderer: e8.renderer, interpolation: e8.interpolation, multidimensionalDefinition: e8.multidimensionalDefinition, rasterFunction: "imagery-tile" === e8.type ? e8.rasterFunction : null } : i15;
  }
  update(e8) {
    this.subview?.update(e8), this.notifyChange("updating");
  }
  isUpdating() {
    return !this.subview || this.subview.updating;
  }
  attach() {
    this.layer.increaseRasterJobHandlerUsage(), this._updateSubview(), this.addAttachHandles([l(() => this.displayParameters, (e8, i15) => {
      const r15 = e8.interpolation !== i15?.interpolation && ("majority" === e8.interpolation || "majority" === i15?.interpolation) && o3(this.layer), o6 = !!this.layer.serviceRasterInfo?.storageInfo?.isBsqTile && e8.bandIds?.join() !== i15?.bandIds?.join(), a10 = e8.renderer !== i15?.renderer && this._getSubviewType(i15?.renderer) !== this._getSubviewType(e8.renderer);
      a10 && this._updateSubview();
      const n7 = e8.multidimensionalDefinition !== i15?.multidimensionalDefinition, h20 = e8.rasterFunction !== i15?.rasterFunction, u9 = h20 && !this._useWebGLForProcessing, l7 = n7 || r15 || a10 || u9 || o6;
      this.subview.redrawOrRefetch({ refetch: l7, reprocess: h20 }).catch((e9) => {
        d(e9) || i.getLogger(this).error(e9);
      }), this.notifyChange("updating");
    }), l(() => this.layer.multidimensionalSubset ?? null, (e8, i15) => {
      const { multidimensionalDefinition: r15 } = this.layer;
      null != r15 && c2(r15, e8) !== c2(r15, i15) && (this.subview.redrawOrRefetch({ refetch: true }).catch((e9) => {
        d(e9) || i.getLogger(this).error(e9);
      }), this.notifyChange("updating"));
    }, U), l(() => this.timeExtent, () => {
      this.subview.timeExtent = this.timeExtent, this.subview.redrawOrRefetch({ refetch: true }).catch((e8) => {
        d(e8) || i.getLogger(this).error(e8);
      });
    }, h), l(() => this.view.highlights.items.map(({ name: e8, color: i15 }) => ({ name: e8, color: i15 })), () => this._updateHighlightOptions(this.subview), h)]);
  }
  detach() {
    this.layer.decreaseRasterJobHandlerUsage(), this._detachSubview(this.subview), this.subview?.destroy(), this.subview = null;
  }
  viewChange() {
    this.requestUpdate();
  }
  moveEnd() {
    this.subview.moveEnd();
  }
  highlight(e8, s10) {
    if (!e8.pixelRanges?.length) return e();
    const t10 = { target: { ...e8 }, options: { ...s10 } };
    return this._pixelHighlights.push(t10), this._updateHighlightOptions(this.subview), e(() => {
      const e9 = this._pixelHighlights.indexOf(t10);
      -1 !== e9 && (this._pixelHighlights.splice(e9, 1), this._updateHighlightOptions(this.subview));
    });
  }
  doRefresh() {
    return this.subview ? this.subview.doRefresh() : Promise.resolve();
  }
  _updateSubview() {
    const { renderer: e8 } = this.layer;
    if (!e8) return;
    const i15 = this._getSubviewType(e8);
    if (this.subview) {
      if (this.subview.type === i15) return void this._attachSubview(this.subview);
      this._detachSubview(this.subview), this.subview?.destroy(), this.subview = null;
    }
    const { layer: s10 } = this;
    let t10;
    if (t10 = "rasterVF" === i15 ? new a9({ layer: s10, layerView: this, scheduler: this.scheduler }) : "flow" === i15 ? new d3({ layer: s10, layerView: this, scheduler: this.scheduler }) : new m11({ layer: s10, layerView: this, scheduler: this.scheduler }), "useWebGLForProcessing" in t10 && (t10.useWebGLForProcessing = this._useWebGLForProcessing), "useProgressiveUpdate" in t10 && (t10.useProgressiveUpdate = this._useProgressiveUpdate), "previousLOD" in t10) {
      const { subview: e9 } = this;
      t10.previousLOD = e9 && "previousLOD" in e9 ? e9.previousLOD : null;
    }
    this._attachSubview(t10), this._updateHighlightOptions(t10), this.subview = t10, this.requestUpdate();
  }
  _attachSubview(e8) {
    e8 && !e8.attached && (e8.attach(), e8.attached = true, this.container.addChildAt(e8.container, 0));
  }
  _detachSubview(e8) {
    e8?.attached && (this.container.removeChild(e8.container), e8.detach(), e8.attached = false);
  }
  _getSubviewType(e8) {
    const i15 = e8?.type;
    return "vector-field" === i15 ? "rasterVF" : "flow" === i15 ? "flow" : "raster";
  }
  _updateHighlightOptions(e8) {
    "raster" === e8?.type && e8.updateHighlightOptions(this._pixelHighlights);
  }
};
__decorate([m()], b8.prototype, "subview", void 0), __decorate([m()], b8.prototype, "useWebGLForProcessing", null), __decorate([m()], b8.prototype, "useProgressiveUpdate", null), __decorate([m({ readOnly: true })], b8.prototype, "displayParameters", null), b8 = __decorate([a("esri.views.2d.layers.ImageryTileLayerView2D")], b8);
var y7 = b8;
export {
  y7 as default
};
//# sourceMappingURL=ImageryTileLayerView2D-RAMJXEBA.js.map
