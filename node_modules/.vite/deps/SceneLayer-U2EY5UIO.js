import {
  a as a5
} from "./chunk-QVM6IWUX.js";
import {
  $
} from "./chunk-CC4SOILQ.js";
import "./chunk-D6KKUGCT.js";
import "./chunk-GUZURMV5.js";
import {
  n as n6,
  p as p5
} from "./chunk-RRK2YVM5.js";
import "./chunk-VIDAPS4J.js";
import {
  t as t4
} from "./chunk-STXFDKJW.js";
import {
  a as a4,
  m as m7,
  p as p4,
  y as y2
} from "./chunk-7XHCDINS.js";
import {
  _ as _3
} from "./chunk-K5O7EA6J.js";
import {
  $ as $2,
  R,
  j as j3
} from "./chunk-GD72EK2J.js";
import "./chunk-NFPLS75J.js";
import "./chunk-I4DSU5MJ.js";
import "./chunk-MCWHCMX6.js";
import "./chunk-D7KJNSAT.js";
import "./chunk-BZV32YR7.js";
import "./chunk-IT62DCG6.js";
import "./chunk-YOYO2XMY.js";
import "./chunk-SZTZNZQW.js";
import "./chunk-AJG2ZYEA.js";
import "./chunk-CFXCM2NO.js";
import "./chunk-B3BLJNSM.js";
import "./chunk-ALKEERWI.js";
import "./chunk-34M4K5HY.js";
import "./chunk-ME5HHRVQ.js";
import "./chunk-U6CJFTOF.js";
import "./chunk-WVAXXVEK.js";
import "./chunk-NJSGYS3K.js";
import {
  p as p2,
  s as s5
} from "./chunk-PJJUVY7C.js";
import "./chunk-A7O5R67Z.js";
import {
  s as s6
} from "./chunk-RGWH5UES.js";
import {
  i as i3
} from "./chunk-HIGI45S6.js";
import {
  o as o3
} from "./chunk-SL3GC7WV.js";
import {
  l as l3
} from "./chunk-CJZPTLIZ.js";
import {
  A,
  l as l4
} from "./chunk-EVZ7KLPS.js";
import {
  f as f2
} from "./chunk-JSH3APTG.js";
import {
  c,
  u as u3
} from "./chunk-WQT2KLDB.js";
import {
  d as d2
} from "./chunk-UVDECGZC.js";
import {
  o as o2,
  s as s3
} from "./chunk-VKFTCFFM.js";
import {
  s as s4
} from "./chunk-ZETARPSI.js";
import {
  I,
  b2,
  d as d3,
  l as l5,
  m as m6,
  p as p3,
  s as s7
} from "./chunk-CZOYDK6P.js";
import {
  u as u2
} from "./chunk-RS755KXS.js";
import "./chunk-TMUM75KQ.js";
import {
  N,
  Y,
  ne
} from "./chunk-KY5OS6CK.js";
import "./chunk-3U5UUY3S.js";
import "./chunk-UOYGMZIS.js";
import "./chunk-RXH2WNPA.js";
import "./chunk-TWU3GKHX.js";
import "./chunk-BGIBV6LL.js";
import "./chunk-UQXJMFRI.js";
import "./chunk-DY7N5RAZ.js";
import {
  j as j2
} from "./chunk-6TCXGIIN.js";
import {
  l
} from "./chunk-NP2TBOXH.js";
import "./chunk-WFCLXKCE.js";
import "./chunk-WX3525ER.js";
import "./chunk-FHCV4NTV.js";
import {
  i as i4,
  m as m5,
  t2 as t3
} from "./chunk-GXTJATEK.js";
import "./chunk-2JMKFI2D.js";
import "./chunk-QYAMBIRP.js";
import "./chunk-EOQ2S5UA.js";
import "./chunk-WBXDB33U.js";
import "./chunk-NH6FXYCM.js";
import "./chunk-YE4E5JCT.js";
import "./chunk-SXZO7ULH.js";
import {
  s as s8
} from "./chunk-63RKYW5K.js";
import "./chunk-HROH5C5D.js";
import {
  t as t2
} from "./chunk-5BAQPFKY.js";
import "./chunk-H34D76ZQ.js";
import "./chunk-GVMCGYZ6.js";
import "./chunk-JHV6OBEB.js";
import "./chunk-QTRET3PG.js";
import "./chunk-FMOL5XMB.js";
import "./chunk-VNSHGTPN.js";
import "./chunk-OEBAFVQK.js";
import "./chunk-76V6RN4F.js";
import {
  F
} from "./chunk-Y3FKYMXQ.js";
import {
  n as n5,
  r as r2
} from "./chunk-S5K4XWUR.js";
import "./chunk-WHHIH5YU.js";
import "./chunk-MEDXVTKR.js";
import "./chunk-5LMH6D7V.js";
import "./chunk-EK7HOTRR.js";
import "./chunk-GCTH5LET.js";
import "./chunk-TTLSEJNG.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import "./chunk-CBCHZD3F.js";
import "./chunk-EKZRA6TO.js";
import "./chunk-M5SP6ZBM.js";
import {
  Z
} from "./chunk-2HGIYEIL.js";
import "./chunk-MDJNYPVI.js";
import "./chunk-Z6VKIQV2.js";
import "./chunk-4PXNA4MD.js";
import "./chunk-ET5EDAFM.js";
import "./chunk-7HTU7ZUX.js";
import "./chunk-WDTGOP77.js";
import "./chunk-VYMBX5H5.js";
import {
  b
} from "./chunk-647DAMHU.js";
import "./chunk-O6G3PPOK.js";
import "./chunk-ZKNZTIAS.js";
import "./chunk-OJMISN3F.js";
import "./chunk-EFV6H5NA.js";
import "./chunk-QZQPB5XR.js";
import "./chunk-AQFRVV3U.js";
import {
  t
} from "./chunk-W5S3VUFT.js";
import "./chunk-7YH7T6CS.js";
import "./chunk-3T4IXPP4.js";
import "./chunk-XTZAIV4X.js";
import "./chunk-63LDVRFI.js";
import {
  _ as _2,
  n as n3
} from "./chunk-C3FRY5U4.js";
import {
  n2 as n4,
  q
} from "./chunk-JNJX34GB.js";
import "./chunk-3STJRSDT.js";
import "./chunk-67Q6KVC6.js";
import "./chunk-23NJHA5Q.js";
import "./chunk-4LA6K4VI.js";
import "./chunk-KEZCWFAR.js";
import "./chunk-JZUJ34RR.js";
import "./chunk-PMGS7UDU.js";
import "./chunk-3GHCGAH2.js";
import "./chunk-HWUOAPTX.js";
import "./chunk-QHCKOBU7.js";
import "./chunk-K2OZ6WVC.js";
import {
  F as F2,
  T,
  y2 as y
} from "./chunk-MC6NAKKX.js";
import "./chunk-TF6255HN.js";
import "./chunk-GD4FJL3C.js";
import "./chunk-C5OQVQZF.js";
import "./chunk-F7DKSAOI.js";
import "./chunk-4SOQWNPG.js";
import "./chunk-LTULADK2.js";
import "./chunk-35ST7YRB.js";
import "./chunk-EDA5QFHZ.js";
import {
  l as l6
} from "./chunk-6NEMIXIJ.js";
import {
  j as j4
} from "./chunk-U3X2LY5C.js";
import "./chunk-JRCD3NNE.js";
import "./chunk-NPYFNHY2.js";
import "./chunk-JW6DU3OK.js";
import "./chunk-CNYNCKEV.js";
import "./chunk-XL5QPCXN.js";
import {
  H as H2
} from "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-W75DBJD7.js";
import "./chunk-QF7FRVN6.js";
import {
  b as b3
} from "./chunk-P6IKJIMO.js";
import {
  m as m4
} from "./chunk-MHV23XAQ.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import "./chunk-MA3QDRC3.js";
import {
  r
} from "./chunk-W6J7XCPU.js";
import "./chunk-ONXWBTTM.js";
import {
  l as l2
} from "./chunk-T7F6Q6JJ.js";
import {
  O
} from "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-7P2ANHQ3.js";
import "./chunk-XCKT47LJ.js";
import "./chunk-3FUHCAX3.js";
import "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import {
  U,
  a as a3,
  j
} from "./chunk-2OFHDVO5.js";
import "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-5UPBUJPC.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-CCQFL76O.js";
import "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import "./chunk-7H3U4IJR.js";
import "./chunk-SMWUT52Z.js";
import {
  _
} from "./chunk-AXZMNHTN.js";
import "./chunk-5T3MJDSR.js";
import "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import {
  H2 as H,
  V,
  g2 as g,
  p
} from "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import {
  o
} from "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import {
  n as n2
} from "./chunk-XXLHAM2M.js";
import {
  m,
  m2
} from "./chunk-5EI5H4QX.js";
import {
  a2
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import {
  n
} from "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import {
  d,
  f2 as f,
  i as i2,
  m2 as m3,
  s as s2,
  u2 as u
} from "./chunk-GNMPGHLQ.js";
import {
  a,
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/graphic/isSceneGraphicOrigin.js
var n7 = Symbol("isSceneGraphicOrigin");

// node_modules/@arcgis/core/graphic/SceneGraphicOrigin.js
var o4;
var a6 = class extends s3 {
  get [(o4 = n7, n4)]() {
    return this.layer;
  }
  get [n3]() {
    return this.layer;
  }
  get [o2]() {
    return this.layer;
  }
  constructor(r3) {
    super(), this[o4] = true, this.type = "scene", this.layer = r3;
  }
  get id() {
    return this.layer.id;
  }
};

// node_modules/@arcgis/core/layers/support/sceneLayerCacheUtils.js
function e({ associatedLayer: e3, serviceUpdateTimeStamp: t6 }) {
  const n8 = e3?.editingInfo?.lastEditDate, r3 = e3?.serverGens, a8 = null != n8, i6 = null != t6, s10 = a8 && i6 && t6.lastUpdate !== n8.getTime();
  return a8 && (s10 || !i6 && r3?.minServerGen !== r3?.serverGen);
}

// node_modules/@arcgis/core/layers/mixins/TemporalSceneLayer.js
var a7 = (t6) => {
  const a8 = t6;
  let p6 = class extends a8 {
    constructor() {
      super(...arguments), this.serviceTimeInfo = null;
    }
    get timeInfo() {
      const e3 = this.associatedLayer?.timeInfo;
      if (null == e3) return null;
      const t7 = e3.clone();
      return F2(t7, this.fieldsIndex), t7;
    }
    set timeInfo(e3) {
      F2(e3, this.fieldsIndex), this._override("timeInfo", e3);
    }
    get timeExtent() {
      return this.associatedLayer?.timeExtent;
    }
    set timeExtent(e3) {
      this._override("timeExtent", e3);
    }
    get timeOffset() {
      return this.associatedLayer?.timeOffset;
    }
    set timeOffset(e3) {
      this._override("timeOffset", e3);
    }
    get datesInUnknownTimezone() {
      return this.associatedLayer?.datesInUnknownTimezone ?? false;
    }
    set datesInUnknownTimezone(e3) {
      this._override("datesInUnknownTimezone", e3);
    }
    async loadTimeInfoFromService(e3) {
      const { serviceTimeInfo: t7 } = this;
      if (null == t7) return;
      const { startTimeField: r3, endTimeField: i6 } = t7;
      if (null == r3 && null == i6) return;
      if (e({ associatedLayer: this.associatedLayer, serviceUpdateTimeStamp: this.serviceUpdateTimeStamp })) return;
      const n8 = async (t8) => {
        let i7 = null;
        try {
          const r4 = await this.fetchStatistics?.(t8, e3);
          i7 = r4?.stats;
        } catch {
        }
        if (null == i7) return null;
        const { minTimeStr: n9, min: s10, maxTimeStr: o5, max: l7 } = i7, m9 = t8 === r3 ? n9 ?? s10 : o5 ?? l7;
        return null != m9 ? new Date(m9) : null;
      }, [m8, a9] = await Promise.all([n8(r3), n8(i6)]);
      if (null != r3 && null == m8 || null != i6 && null == a9) return;
      const c3 = new m4({ start: m8, end: a9 });
      this.setAtOrigin("timeInfo", new u3({ endField: i6, startField: r3, fullTimeExtent: c3 }), "service");
    }
  };
  return __decorate([m({ type: u3, json: { read: false, write: false } })], p6.prototype, "timeInfo", null), __decorate([m({ type: m4, json: { read: false, write: false } })], p6.prototype, "timeExtent", null), __decorate([m({ type: c, json: { read: false, write: false } })], p6.prototype, "timeOffset", null), __decorate([m({ type: Boolean, nonNullable: true, json: { read: false, write: false } })], p6.prototype, "datesInUnknownTimezone", null), __decorate([m({ type: c2, readOnly: true, json: { read: { source: "timeInfo" } }, clonable: false })], p6.prototype, "serviceTimeInfo", void 0), p6 = __decorate([a2("esri.layers.mixins.TemporalSceneLayer")], p6), p6;
};
var c2 = class extends n2 {
  constructor() {
    super(...arguments), this.endTimeField = null, this.startTimeField = null;
  }
};
__decorate([m({ type: String })], c2.prototype, "endTimeField", void 0), __decorate([m({ type: String })], c2.prototype, "startTimeField", void 0), c2 = __decorate([a2("esri.layers.mixins.TemporalSceneLayer.SceneServiceTimeInfo")], c2);

// node_modules/@arcgis/core/layers/support/RangeInfo.js
var s9 = class extends n2 {
  constructor() {
    super(...arguments), this.name = null, this.field = null, this.currentRangeExtent = null, this.fullRangeExtent = null, this.type = "rangeInfo";
  }
};
__decorate([m({ type: String, json: { read: true, write: { isRequired: true } } })], s9.prototype, "name", void 0), __decorate([m({ type: String, json: { read: true, write: { isRequired: true } } })], s9.prototype, "field", void 0), __decorate([m({ type: [Number], json: { read: true, write: true } })], s9.prototype, "currentRangeExtent", void 0), __decorate([m({ type: [Number], json: { read: true, write: true } })], s9.prototype, "fullRangeExtent", void 0), __decorate([m({ type: ["rangeInfo"], readOnly: true, json: { read: false, write: { isRequired: true } } })], s9.prototype, "type", void 0), s9 = __decorate([a2("esri.layers.support.RangeInfo")], s9);

// node_modules/@arcgis/core/layers/support/SceneFilter.js
var u4;
var g2 = u4 = class extends n2 {
  constructor(e3) {
    super(e3), this.spatialRelationship = "disjoint", this.geometries = new l6(), this._geometriesSource = null;
  }
  initialize() {
    this.addHandles(a3(() => this.geometries, "after-changes", () => this.geometries = this.geometries, U));
  }
  readGeometries(e3, r3, o5) {
    Array.isArray(e3) ? this.geometries = l6.fromJSON(e3, o5) : "web-scene" !== o5.origin && "portal-item" !== o5.origin || (this._geometriesSource = { url: p(e3, o5), context: o5 });
  }
  async loadGeometries(e3, o5) {
    if (null == this._geometriesSource) return;
    const { url: s10, context: t6 } = this._geometriesSource, i6 = await H(s10, { responseType: "json", signal: o5?.signal }), a8 = e3.toJSON(), p6 = i6.data.map((e4) => ({ ...e4, spatialReference: a8 }));
    this.geometries = l6.fromJSON(p6, t6), this._geometriesSource = null;
  }
  clone() {
    const e3 = new u4({ geometries: a(this.geometries), spatialRelationship: this.spatialRelationship });
    return e3._geometriesSource = this._geometriesSource, e3;
  }
};
__decorate([m({ type: ["disjoint", "contains"], nonNullable: true, json: { write: { isRequired: true } } })], g2.prototype, "spatialRelationship", void 0), __decorate([m({ type: l6, nonNullable: true, json: { write: true, origins: { "web-scene": { write: { isRequired: true } } } } }), j4({ origins: ["web-scene", "portal-item"], type: "resource", prefix: "geometries", contentAddressed: true })], g2.prototype, "geometries", void 0), __decorate([o(["web-scene", "portal-item", "service"], "geometries")], g2.prototype, "readGeometries", null), g2 = u4 = __decorate([a2("esri.layers.support.SceneFilter")], g2);
var d4 = g2;

// node_modules/@arcgis/core/layers/support/sceneLayerStatistics.js
async function i5({ fieldName: i6, statisticsInfo: a8, errorContext: o5, fieldsIndex: r3, path: n8, customParameters: l7, apiKey: c3, signal: f3 }) {
  if (null == a8) throw new s(`${o5}:no-cached-statistics`, "Cached statistics are not available for this layer");
  const d5 = r3.get(i6);
  if (null == d5) throw new s(`${o5}:field-unexisting`, `Field '${i6}' does not exist on the layer`);
  const h = a8.find((t6) => t6.name === d5.name);
  if (null == h) throw new s(`${o5}:no-cached-statistics`, "Cached statistics for this attribute are not available");
  const m8 = V(n8, h.href), { data: u5 } = await H(m8, { query: { f: "json", ...l7, token: c3 }, responseType: "json", signal: f3 });
  return u5;
}

// node_modules/@arcgis/core/support/zipUtils.js
async function e2(e3) {
  const r3 = [];
  for (const n8 of e3) n8.name.toLowerCase().endsWith(".zip") ? r3.push(t5(n8)) : r3.push(Promise.resolve(n8));
  return (await Promise.all(r3)).flat();
}
async function t5(e3) {
  const { BlobReader: t6, ZipReader: r3, BlobWriter: n8 } = await import("./zipjs-wrapper-GVJHFULY.js"), a8 = [], i6 = new r3(new t6(e3));
  return (await i6.getEntries()).forEach((e4) => {
    if (e4.directory || /^__MACOS/i.test(e4.filename)) return;
    const t7 = new n8();
    a8.push(e4.getData(t7).then((t8) => new File([t8], e4.filename)));
  }), Promise.all(a8);
}

// node_modules/@arcgis/core/layers/SceneLayer.js
var _e = /* @__PURE__ */ new Set(["3DObject", "Point"]);
var Pe = s6();
var Te = class extends a7(F(_3(l3(b2(j2(t(l(s4(o3(l2(b3))))))))))) {
  constructor(...e3) {
    super(...e3), this.featureReduction = null, this.rangeInfos = null, this.operationalLayerType = "ArcGISSceneServiceLayer", this.type = "scene", this.fields = null, this.graphicOrigin = new a6(this), this.floorInfo = null, this.outFields = null, this.nodePages = null, this.materialDefinitions = null, this.textureSetDefinitions = null, this.geometryDefinitions = null, this.serviceUpdateTimeStamp = null, this.excludeObjectIds = new O(), this.definitionExpression = null, this.filter = null, this.path = null, this.labelsVisible = true, this.labelingInfo = null, this.legendEnabled = true, this.priority = null, this.semantic = null, this.cachedDrawingInfo = { color: false }, this.popupEnabled = true, this.popupTemplate = null, this.attributeTableTemplate = null, this.objectIdField = null, this.globalIdField = null, this._fieldUsageInfo = {}, this.screenSizePerspectiveEnabled = true, this.serviceItemId = void 0;
  }
  normalizeCtorArgs(e3, t6) {
    return "string" == typeof e3 ? { url: e3, ...t6 } : e3;
  }
  destroy() {
    this._set("renderer", null), this.associatedLayer = u(this.associatedLayer);
  }
  getField(e3) {
    return this.fieldsIndex.get(e3);
  }
  getFieldDomain(e3, t6) {
    const r3 = this.getField(e3)?.domain ?? null;
    return this.associatedLayer ? N(this.associatedLayer, e3, t6, r3) : r3;
  }
  getFeatureType(e3) {
    return e3 && this.associatedLayer ? this.associatedLayer.getFeatureType(e3) : null;
  }
  get types() {
    return this.associatedLayer?.types ?? [];
  }
  get typeIdField() {
    return this.associatedLayer?.typeIdField ?? null;
  }
  get templates() {
    return this.associatedLayer?.templates ?? null;
  }
  get formTemplate() {
    return this.associatedLayer?.formTemplate ?? null;
  }
  get fieldsIndex() {
    return new Z(this.fields);
  }
  readNodePages(e3, t6, r3) {
    return "Point" === t6.layerType && (e3 = t6.pointNodePages), null == e3 || "object" != typeof e3 ? null : p4.fromJSON(e3, r3);
  }
  set elevationInfo(e3) {
    this._set("elevationInfo", e3), this.loaded && this._validateElevationInfo();
  }
  get effectiveCapabilities() {
    return this._capabilitiesFromAssociatedFeatureLayer(this.associatedLayer?.effectiveCapabilities);
  }
  get effectiveEditingEnabled() {
    return null != this.associatedLayer && Y(this.associatedLayer);
  }
  get geometryType() {
    return xe[this.profile] || "mesh";
  }
  set renderer(e3) {
    y(e3, this.fieldsIndex), this._set("renderer", e3);
  }
  readCachedDrawingInfo(e3) {
    return null != e3 && "object" == typeof e3 || (e3 = {}), null == e3.color && (e3.color = false), e3;
  }
  get capabilities() {
    return this._capabilitiesFromAssociatedFeatureLayer(this.associatedLayer?.capabilities);
  }
  _capabilitiesFromAssociatedFeatureLayer(e3) {
    e3 = null != e3 ? e3 : t4;
    const { query: t6, queryRelated: r3, editing: { supportsGlobalId: i6, supportsRollbackOnFailure: s10, supportsUploadWithItemId: o5, supportsGeometryUpdate: a8, supportsReturnServiceEditsInSourceSpatialReference: n8 }, data: { supportsZ: l7, supportsM: p6, isVersioned: d5, supportsAttachment: y3 }, operations: { supportsEditing: c3, supportsAdd: u5, supportsUpdate: h, supportsDelete: f3, supportsQuery: m8, supportsQueryAttachments: g3, supportsAsyncConvert3D: v } } = e3, b4 = e3.operations.supportsChangeTracking, w = !!this.associatedLayer?.infoFor3D;
    return { query: t6, queryRelated: r3, editing: { supportsGlobalId: i6, supportsReturnServiceEditsInSourceSpatialReference: n8, supportsRollbackOnFailure: s10, supportsGeometryUpdate: w && a8, supportsUploadWithItemId: o5 }, data: { supportsAttachment: y3, supportsZ: l7, supportsM: p6, isVersioned: d5 }, operations: { supportsQuery: m8, supportsQueryAttachments: g3, supportsEditing: c3 && b4, supportsAdd: w && u5 && b4, supportsDelete: w && f3 && b4, supportsUpdate: h && b4, supportsAsyncConvert3D: v } };
  }
  get editingEnabled() {
    return this._isOverridden("editingEnabled") ? this._get("editingEnabled") : this.associatedLayer?.editingEnabled ?? false;
  }
  set editingEnabled(e3) {
    this._overrideIfSome("editingEnabled", e3);
  }
  get infoFor3D() {
    return this.associatedLayer?.infoFor3D ?? null;
  }
  get relationships() {
    return this.associatedLayer?.relationships;
  }
  get defaultPopupTemplate() {
    return this.associatedLayer || this.attributeStorageInfo ? this.createPopupTemplate() : null;
  }
  readObjectIdField(e3, t6) {
    return !e3 && t6.fields && t6.fields.some((t7) => ("esriFieldTypeOID" === t7.type && (e3 = t7.name), !!e3)), e3 || void 0;
  }
  readGlobalIdField(e3, t6) {
    return !e3 && t6.fields && t6.fields.some((t7) => ("esriFieldTypeGlobalID" === t7.type && (e3 = t7.name), !!e3)), e3 || void 0;
  }
  get displayField() {
    return this.associatedLayer?.displayField ?? null;
  }
  readProfile(e3, t6) {
    const r3 = t6.store.profile;
    return null != r3 && Ae[r3] ? Ae[r3] : (i.getLogger(this).error("Unknown or missing profile", { profile: r3, layer: this }), "mesh-pyramids");
  }
  get useViewTime() {
    return this.associatedLayer?.useViewTime ?? true;
  }
  set useViewTime(e3) {
    this._override("useViewTime", e3);
  }
  load(e3) {
    return this.addResolvingPromise(this._load(e3)), Promise.resolve(this);
  }
  async _load(e3) {
    const t6 = e3?.signal;
    await this.loadFromPortal({ supportedTypes: ["Scene Service"] }, e3).catch(f), await this._fetchService(t6), await Promise.all([this._fetchIndexAndUpdateExtent(this.nodePages, t6), this._setAssociatedFeatureLayer(t6), this._loadFilterGeometries()]), this._validateElevationInfo(), this._applyAssociatedLayerOverrides(), this._populateFieldUsageInfo(), await this.loadTimeInfoFromService(e3), await t2(this, { origin: "service" }, t6), y(this.renderer, this.fieldsIndex), await this.finishLoadEditablePortalLayer(e3);
  }
  async beforeSave() {
    null != this.filter && (this.filter = this.filter.clone(), await this.load());
  }
  async _loadFilterGeometries() {
    if (this.filter) try {
      await this.filter.loadGeometries(this.spatialReference);
    } catch (e3) {
      i.getLogger(this).error("#_loadFilterGeometries()", this, "Failed to load filter geometries. Geometry filter will not be applied for this layer.", { error: e3 }), this.filter = null;
    }
  }
  createQuery() {
    const e3 = new b();
    return "mesh" === this.geometryType ? this.capabilities.query.supportsReturnMesh && (e3.returnGeometry = true) : (e3.returnGeometry = true, e3.returnZ = true), e3.where = this.definitionExpression || "1=1", e3.sqlFormat = "standard", e3.outFields = ["*"], e3;
  }
  queryExtent(e3, t6) {
    return this._getAssociatedLayerForQuery().then((r3) => r3.queryExtent(e3 || this.createQuery(), t6));
  }
  queryFeatureCount(e3, t6) {
    return this._getAssociatedLayerForQuery().then((r3) => r3.queryFeatureCount(e3 || this.createQuery(), t6));
  }
  queryFeatures(e3, t6) {
    return this._getAssociatedLayerForQuery().then((r3) => r3.queryFeatures(e3 || this.createQuery(), t6)).then((e4) => {
      if (e4?.features) for (const t7 of e4.features) t7.layer = this, t7.sourceLayer = this, t7.origin = this.graphicOrigin;
      return e4;
    });
  }
  async queryRelatedFeatures(e3, t6) {
    if (await this.load(), !this.associatedLayer) throw new s("scenelayer:query-not-available", "SceneLayer queries are not available without an associated feature layer", { layer: this });
    return this.associatedLayer.queryRelatedFeatures(e3, t6);
  }
  async queryRelatedFeaturesCount(e3, t6) {
    if (await this.load(), !this.associatedLayer) throw new s("scenelayer:query-not-available", "SceneLayer queries are not available without an associated feature layer", { layer: this });
    return this.associatedLayer.queryRelatedFeaturesCount(e3, t6);
  }
  async queryCachedAttributes(e3, t6) {
    const r3 = T(this.fieldsIndex, await p5(this, n6(this)));
    return $(this.parsedUrl?.path ?? "", this.attributeStorageInfo ?? [], e3, t6, r3, this.apiKey, this.customParameters);
  }
  async queryCachedFeature(e3, r3) {
    const i6 = await this.queryCachedAttributes(e3, [r3]);
    if (!i6 || 0 === i6.length) throw new s("scenelayer:feature-not-in-cached-data", "Feature not found in cached data");
    const s10 = new _2();
    return s10.attributes = i6[0], s10.layer = this, s10.sourceLayer = this, s10.origin = this.graphicOrigin, s10;
  }
  queryObjectIds(e3, t6) {
    return this._getAssociatedLayerForQuery().then((r3) => r3.queryObjectIds(e3 || this.createQuery(), t6));
  }
  queryAttachments(e3, t6) {
    return this._getAssociatedLayerForQuery().then((r3) => r3.queryAttachments(e3, t6));
  }
  getFieldUsageInfo(e3) {
    const t6 = { supportsLabelingInfo: false, supportsRenderer: false, supportsPopupTemplate: false, supportsLayerQuery: false };
    return this.loaded ? this._fieldUsageInfo[e3] || t6 : (i.getLogger(this).error("#getFieldUsageInfo()", "Unavailable until layer is loaded"), t6);
  }
  createPopupTemplate(e3) {
    return d2(this, e3);
  }
  _getAssociatedLayerForQuery() {
    const e3 = this.associatedLayer;
    return e3?.loaded ? Promise.resolve(e3) : this._loadAssociatedLayerForQuery();
  }
  async _loadAssociatedLayerForQuery() {
    if (await this.load(), !this.associatedLayer) throw new s("scenelayer:query-not-available", "SceneLayer queries are not available without an associated feature layer", { layer: this });
    try {
      await this.associatedLayer.load();
    } catch (e3) {
      throw new s("scenelayer:query-not-available", "SceneLayer associated feature layer could not be loaded", { layer: this, error: e3 });
    }
    return this.associatedLayer;
  }
  hasCachedStatistics(e3) {
    return null != this.statisticsInfo && this.statisticsInfo.some((t6) => t6.name === e3);
  }
  async queryCachedStatistics(e3, t6) {
    return await this.load(t6), await this.fetchStatistics(e3, t6);
  }
  async saveAs(e3, t6) {
    return this._debouncedSaveOperations(1, { ...t6, getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "scene" }, e3);
  }
  async save() {
    const e3 = { getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "scene" };
    return this._debouncedSaveOperations(0, e3);
  }
  async applyEdits(e3, t6) {
    const { applyEdits: r3 } = await import("./editingSupport-AZ6EUTCP.js");
    let i6 = t6;
    await this.load();
    const s10 = this.associatedLayer;
    if (!s10) throw new s(`${this.type}-layer:not-editable`, "Service is not editable");
    await s10.load();
    const { globalIdField: o5 } = s10, n8 = !!s10.infoFor3D, l7 = i6?.globalIdUsed ?? true;
    if (n8 && null == o5) throw new s(`${this.type}-layer:not-editable`, "Valid globalIdField expected on editable SceneLayer");
    if (n8 && !l7) throw new s(`${this.type}-layer:globalid-required`, "globalIdUsed must not be false for SceneLayer editing as globalIds are required.");
    return g(s10.url) && n8 && null != e3.deleteFeatures && null != o5 && (i6 = { ...i6, globalIdToObjectId: await ne(s10, e3.deleteFeatures, o5) }), r3(this, s10.source, e3, i6);
  }
  async uploadAssets(e3, t6) {
    if (await this.load(), null == this.associatedLayer) throw new s(`${this.type}-layer:not-editable`, "Service is not editable");
    return await this.associatedLayer.load(), this.associatedLayer.uploadAssets(e3, t6);
  }
  async convertMesh(e3, t6) {
    t6 ??= {}, null != t6.location && m2(i.getLogger(this), "The 'location' option of convertMesh() has been deprecated in favour of 'origin'.", { version: "4.34", replacement: "origin", warnOnce: true });
    const r3 = (e4) => {
      throw i.getLogger(this).error(".convertMesh()", e4.message), e4;
    };
    await this.load(t6), this.infoFor3D || r3(new s("invalid:layer", "SceneLayer has no capability for mesh conversion"));
    const i6 = await this.extractAndFilterFiles(e3);
    s2(t6);
    const s10 = i6.reduce((e4, t7) => r2(this.infoFor3D, t7) ? e4 + 1 : e4, 0);
    0 === s10 && r3(new i4()), s10 > 1 && r3(new m5());
    const n8 = this.spatialReference, p6 = t6.origin ?? t6.location, d5 = await H2(p6 ?? t6.defaultOrigin ?? new _({ x: 0, y: 0, z: 0, spatialReference: n8 }), n8, t6), y3 = d5.spatialReference.isGeographic ? "local" : "georeferenced", { default: u5 } = await import("./Mesh-GI3JZRRF.js");
    s2(t6);
    const h = u5.createWithExternalSource(d5, { type: "client", files: i6 }, { vertexSpace: y3, transform: t3(d5.spatialReference), unitConversionDisabled: true }), [f3] = await this.uploadAssets([h], { ...t6, useAssetOrigin: !p6 });
    return f3;
  }
  async extractAndFilterFiles(e3) {
    await this.load();
    const t6 = this.infoFor3D;
    if (!t6) return e3;
    return (await e2(e3)).filter((e4) => n5(t6, e4));
  }
  validateLayer(e3) {
    if (e3.layerType && !_e.has(e3.layerType)) throw new s("scenelayer:layer-type-not-supported", "SceneLayer does not support this layer type", { layerType: e3.layerType });
    if (isNaN(this.version.major) || isNaN(this.version.minor)) throw new s("layer:service-version-not-supported", "Service version is not supported.", { serviceVersion: this.version.versionString, supportedVersions: "1.x, 2.x" });
    if (this.version.major > 2) throw new s("layer:service-version-too-new", "Service version is too new.", { serviceVersion: this.version.versionString, supportedVersions: "1.x, 2.x" });
    function t6(e4, t7) {
      let r3 = false, i6 = false;
      if (null == e4) r3 = true, i6 = true;
      else {
        const s10 = t7 && t7.isGeographic;
        switch (e4) {
          case "east-north-up":
          case "earth-centered":
            r3 = true, i6 = s10;
            break;
          case "vertex-reference-frame":
            r3 = true, i6 = !s10;
            break;
          default:
            r3 = false;
        }
      }
      if (!r3) throw new s("scenelayer:unsupported-normal-reference-frame", "Normal reference frame is invalid.");
      if (!i6) throw new s("scenelayer:incompatible-normal-reference-frame", "Normal reference frame is incompatible with layer spatial reference.");
    }
    t6(this.normalReferenceFrame, this.spatialReference);
  }
  _getTypeKeywords() {
    const e3 = [];
    if ("points" === this.profile) e3.push("Point");
    else {
      if ("mesh-pyramids" !== this.profile) throw new s("scenelayer:unknown-profile", "SceneLayer:save() encountered an unknown SceneLayer profile: " + this.profile);
      e3.push("3DObject");
    }
    return e3;
  }
  _populateFieldUsageInfo() {
    if (this._fieldUsageInfo = {}, this.fields) for (const e3 of this.fields) {
      const t6 = !!this.attributeStorageInfo?.some((t7) => t7.name === e3.name), r3 = !!this.associatedLayer?.fields?.some((t7) => t7 && e3.name === t7.name), i6 = { supportsLabelingInfo: t6, supportsRenderer: t6, supportsPopupTemplate: t6 || r3, supportsLayerQuery: r3 };
      this._fieldUsageInfo[e3.name] = i6;
    }
  }
  _applyAssociatedLayerOverrides() {
    this._applyAssociatedLayerFieldsOverrides(), this._applyAssociatedLayerPropertyOverrides(), this._applyAssociatedLayerExtentOverride(), this._applyAssociatedLayerPrivileges();
  }
  _applyAssociatedLayerFieldsOverrides() {
    if (!this.associatedLayer?.fields) return;
    let e3 = null;
    for (const t6 of this.associatedLayer.fields) {
      const r3 = this.getField(t6.name);
      r3 ? (!r3.domain && t6.domain && (r3.domain = t6.domain.clone()), r3.editable = t6.editable, r3.nullable = t6.nullable, r3.length = t6.length) : (e3 || (e3 = this.fields ? this.fields.slice() : []), e3.push(t6.clone()));
    }
    e3 && this._set("fields", e3);
  }
  _applyAssociatedLayerPropertyOverrides() {
    if (!this.associatedLayer) return;
    const e3 = ["popupTemplate", "popupEnabled", "attributeTableTemplate"], t6 = n(this);
    for (let r3 = 0; r3 < e3.length; r3++) {
      const i6 = e3[r3], s10 = this.originIdOf(i6), o5 = this.associatedLayer.originIdOf(i6);
      s10 < o5 && (2 === o5 || 3 === o5) && t6.setAtOrigin(i6, this.associatedLayer[i6], o5);
    }
  }
  _applyAssociatedLayerExtentOverride() {
    const e3 = this.associatedLayer?.getAtOrigin("fullExtent", "service");
    if (null == this.associatedLayer?.infoFor3D || !e3 || !g(this.associatedLayer?.url) || !e(this)) return;
    n(this).setAtOrigin("fullExtent", e3.clone(), 2);
  }
  _applyAssociatedLayerPrivileges() {
    const e3 = this.associatedLayer;
    e3 && (this._set("userHasEditingPrivileges", e3.userHasEditingPrivileges), this._set("userHasFullEditingPrivileges", e3.userHasFullEditingPrivileges), this._set("userHasUpdateItemPrivileges", e3.userHasUpdateItemPrivileges));
  }
  async _setAssociatedFeatureLayer(e3) {
    if (["mesh-pyramids", "points"].includes(this.profile)) try {
      const { serverUrl: t6, layerId: r3, portalItem: i6 } = await s8(`${this.url}/layers/${this.layerId}`, { sceneLayerItem: this.portalItem, customParameters: this.customParameters, apiKey: this.apiKey, signal: e3 }), s10 = await a5.FeatureLayer();
      this.associatedLayer = new s10({ url: t6, customParameters: this.customParameters, layerId: r3, portalItem: i6 }), await this.associatedLayer.load();
    } catch (t6) {
      d(t6) || this._logWarningOnPopupEnabled();
    }
  }
  async _logWarningOnPopupEnabled() {
    const e3 = new AbortController();
    this.addHandles(i2(e3));
    try {
      await j(() => this.popupEnabled && null != this.popupTemplate, e3.signal);
    } catch (r3) {
      return void m3(r3);
    }
    const t6 = `this SceneLayer: ${this.title}`;
    null == this.attributeStorageInfo ? i.getLogger(this).warn(`Associated FeatureLayer could not be loaded and no binary attributes found. Popups will not work on ${t6}`) : i.getLogger(this).info(`Associated FeatureLayer could not be loaded. Falling back to binary attributes for Popups on ${t6}`);
  }
  _validateElevationInfo() {
    const e3 = this.elevationInfo;
    "mesh-pyramids" === this.profile && j3(i.getLogger(this), $2("Mesh scene layers", "relative-to-scene", e3)), j3(i.getLogger(this), R("Scene layers", e3));
  }
  async fetchStatistics(e3, t6) {
    return await i5({ fieldName: e3, statisticsInfo: this.statisticsInfo, errorContext: "scenelayer", fieldsIndex: this.fieldsIndex, path: this.parsedUrl?.path ?? "", customParameters: this.customParameters, apiKey: this.apiKey, signal: t6?.signal });
  }
};
__decorate([m({ types: { key: "type", base: s5, typeMap: { selection: p2 } }, json: { origins: { "web-scene": { name: "layerDefinition.featureReduction", write: { allowNull: true } }, "portal-item": { name: "layerDefinition.featureReduction", write: { allowNull: true } } } } })], Te.prototype, "featureReduction", void 0), __decorate([m({ type: [s9], json: { read: false, origins: { "web-scene": { name: "layerDefinition.rangeInfos", write: true }, "portal-item": { name: "layerDefinition.rangeInfos", write: true } } }, clonable: false })], Te.prototype, "rangeInfos", void 0), __decorate([m({ json: { read: false } })], Te.prototype, "associatedLayer", void 0), __decorate([m({ type: ["show", "hide"] })], Te.prototype, "listMode", void 0), __decorate([m({ type: ["ArcGISSceneServiceLayer"] })], Te.prototype, "operationalLayerType", void 0), __decorate([m({ json: { read: false }, readOnly: true })], Te.prototype, "type", void 0), __decorate([m({ ...Pe.fields, readOnly: true, json: { read: false, origins: { service: { read: true } } } })], Te.prototype, "fields", void 0), __decorate([m()], Te.prototype, "types", null), __decorate([m()], Te.prototype, "typeIdField", null), __decorate([m()], Te.prototype, "templates", null), __decorate([m()], Te.prototype, "formTemplate", null), __decorate([m({ readOnly: true })], Te.prototype, "graphicOrigin", void 0), __decorate([m({ readOnly: true, clonable: false })], Te.prototype, "fieldsIndex", null), __decorate([m({ type: i3, json: { read: { source: "layerDefinition.floorInfo" }, write: { target: "layerDefinition.floorInfo" } } })], Te.prototype, "floorInfo", void 0), __decorate([m(Pe.outFields)], Te.prototype, "outFields", void 0), __decorate([m({ type: p4, readOnly: true, json: { read: false }, clonable: false })], Te.prototype, "nodePages", void 0), __decorate([o("service", "nodePages", ["nodePages", "pointNodePages"])], Te.prototype, "readNodePages", null), __decorate([m({ type: [a4], readOnly: true, clonable: false })], Te.prototype, "materialDefinitions", void 0), __decorate([m({ type: [y2], readOnly: true, clonable: false })], Te.prototype, "textureSetDefinitions", void 0), __decorate([m({ type: [m7], readOnly: true, clonable: false })], Te.prototype, "geometryDefinitions", void 0), __decorate([m({ readOnly: true })], Te.prototype, "serviceUpdateTimeStamp", void 0), __decorate([m({ readOnly: true })], Te.prototype, "attributeStorageInfo", void 0), __decorate([m({ readOnly: true })], Te.prototype, "statisticsInfo", void 0), __decorate([m({ type: O.ofType(Number), nonNullable: true, json: { origins: { service: { read: false, write: false } }, name: "layerDefinition.excludeObjectIds", write: { enabled: true } } })], Te.prototype, "excludeObjectIds", void 0), __decorate([m({ type: String, json: { origins: { service: { read: false, write: false } }, name: "layerDefinition.definitionExpression", write: { enabled: true, allowNull: true } } })], Te.prototype, "definitionExpression", void 0), __decorate([m({ type: d4, json: { name: "layerDefinition.polygonFilter", write: { enabled: true, allowNull: true }, origins: { service: { read: false, write: false } } } })], Te.prototype, "filter", void 0), __decorate([m({ type: String, json: { origins: { "web-scene": { read: true, write: true } }, read: false } })], Te.prototype, "path", void 0), __decorate([m(m6)], Te.prototype, "elevationInfo", null), __decorate([m({ readOnly: true, json: { read: false } })], Te.prototype, "effectiveCapabilities", null), __decorate([m({ readOnly: true })], Te.prototype, "effectiveEditingEnabled", null), __decorate([m({ type: String })], Te.prototype, "geometryType", null), __decorate([m(p3)], Te.prototype, "labelsVisible", void 0), __decorate([m({ type: [A], json: { origins: { service: { name: "drawingInfo.labelingInfo", read: { reader: l4 }, write: false } }, name: "layerDefinition.drawingInfo.labelingInfo", read: { reader: l4 }, write: true } })], Te.prototype, "labelingInfo", void 0), __decorate([m(d3)], Te.prototype, "legendEnabled", void 0), __decorate([m({ type: Number, json: { origins: { "web-document": { default: 1, write: { enabled: true, target: { opacity: { type: Number }, "layerDefinition.drawingInfo.transparency": { type: Number } } }, read: { source: ["opacity", "layerDefinition.drawingInfo.transparency"], reader(e3, t6) {
  if ("number" == typeof e3 && e3 >= 0 && e3 <= 1) return e3;
  const r3 = t6.layerDefinition?.drawingInfo?.transparency;
  return void 0 !== r3 ? r(r3) : void 0;
} } }, "portal-item": { write: true }, service: { read: false } } } })], Te.prototype, "opacity", void 0), __decorate([m({ type: ["Low", "High"], readOnly: true, json: { read: false, origins: { service: { read: true } } } })], Te.prototype, "priority", void 0), __decorate([m({ type: ["Labels"], readOnly: true, json: { read: false, origins: { service: { read: true } } } })], Te.prototype, "semantic", void 0), __decorate([m({ types: u2, json: { origins: { service: { read: { source: "drawingInfo.renderer" } } }, name: "layerDefinition.drawingInfo.renderer", write: true }, value: null })], Te.prototype, "renderer", null), __decorate([m({ json: { read: false } })], Te.prototype, "cachedDrawingInfo", void 0), __decorate([o("service", "cachedDrawingInfo")], Te.prototype, "readCachedDrawingInfo", null), __decorate([m({ readOnly: true, json: { read: false } })], Te.prototype, "capabilities", null), __decorate([m({ type: Boolean, json: { read: false } })], Te.prototype, "editingEnabled", null), __decorate([m({ readOnly: true, json: { write: false, read: false } })], Te.prototype, "infoFor3D", null), __decorate([m({ readOnly: true, json: { write: false, read: false } })], Te.prototype, "relationships", null), __decorate([m(l5)], Te.prototype, "popupEnabled", void 0), __decorate([m({ type: q, json: { name: "popupInfo", write: true } })], Te.prototype, "popupTemplate", void 0), __decorate([m({ readOnly: true, json: { read: false } })], Te.prototype, "defaultPopupTemplate", null), __decorate([m(I)], Te.prototype, "attributeTableTemplate", void 0), __decorate([m({ type: String, json: { read: false } })], Te.prototype, "objectIdField", void 0), __decorate([o("service", "objectIdField", ["objectIdField", "fields"])], Te.prototype, "readObjectIdField", null), __decorate([m({ type: String, json: { read: false } })], Te.prototype, "globalIdField", void 0), __decorate([o("service", "globalIdField", ["globalIdField", "fields"])], Te.prototype, "readGlobalIdField", null), __decorate([m({ readOnly: true, type: String, json: { read: false } })], Te.prototype, "displayField", null), __decorate([m({ type: String, json: { read: false } })], Te.prototype, "profile", void 0), __decorate([o("service", "profile", ["store.profile"])], Te.prototype, "readProfile", null), __decorate([m({ readOnly: true, type: String, json: { origins: { service: { read: { source: "store.normalReferenceFrame" } } }, read: false } })], Te.prototype, "normalReferenceFrame", void 0), __decorate([m(s7)], Te.prototype, "screenSizePerspectiveEnabled", void 0), __decorate([m({ json: { read: false, origins: { service: { read: true } } } })], Te.prototype, "serviceItemId", void 0), __decorate([m(f2)], Te.prototype, "useViewTime", null), Te = __decorate([a2("esri.layers.SceneLayer")], Te);
var Ae = { "mesh-pyramids": "mesh-pyramids", meshpyramids: "mesh-pyramids", "features-meshes": "mesh-pyramids", points: "points", "features-points": "points", lines: "lines", "features-lines": "lines", polygons: "polygons", "features-polygons": "polygons" };
var xe = { "mesh-pyramids": "mesh", points: "point" };
var Ee = Te;
export {
  Ee as default
};
//# sourceMappingURL=SceneLayer-U2EY5UIO.js.map
