import {
  E2 as E,
  Q,
  bt,
  ft,
  ht,
  rt,
  wt
} from "./chunk-KDOWKZ3H.js";
import {
  e
} from "./chunk-EC56NYYL.js";
import {
  f
} from "./chunk-KDGDF37U.js";
import {
  i,
  y
} from "./chunk-SJ2OBYX2.js";
import {
  c
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/lodRendering/LodResources.js
var i2 = class {
  constructor(e2, t, r, s) {
    this.material = e2, this.buffer = t, this.numVertices = r, this.boundingInfo = s, this.bufferWriter = e2.createBufferWriter();
  }
  get layout() {
    return this.bufferWriter.layout;
  }
  get numTriangles() {
    return this.numVertices / 3;
  }
  computeUsedMemory() {
    return this.buffer.byteLength + y;
  }
  get renderGeometry() {
    return this;
  }
  intersect(e2, t, r, s, n, i3, o2, m3) {
    const a2 = this.bufferWriter, c3 = this.buffer;
    a2.intersect(c3, this.material.parameters, null, e2, r, s, (r2, s2, a3) => u(r2, s2, a3, e2, t, i3, o2, n, m3));
  }
};
var o = class {
  constructor(e2) {
    this.engineGeometry = e2;
    const t = this.material, r = this.engineGeometry, s = r.attributes, n = r.boundingInfo, o2 = t.createBufferWriter(), u2 = o2.layout, m3 = o2.elementCount(s), a2 = u2.createBuffer(m3);
    o2.write(null, null, s, null, a2, 0), this.renderGeometry = new i2(t, a2.buffer, m3, n);
  }
  get material() {
    return this.engineGeometry.material;
  }
  get numVertices() {
    return this.engineGeometry.indexCount;
  }
  get numTriangles() {
    return this.numVertices / 3;
  }
  get boundingInfo() {
    return this.engineGeometry.boundingInfo;
  }
  computeUsedMemory() {
    return Array.from(this.engineGeometry.attributes.values()).reduce((e2, r) => e2 + i(r.data, r.indices), 0);
  }
  intersect(e2, t, r, s, n, i3, o2, m3) {
    const a2 = this.engineGeometry;
    this.material.intersect(a2, e2.transform.transform, e2, r, s, (r2, s2, a3) => u(r2, s2, a3, e2, t, i3, o2, n, m3));
  }
};
function u(e2, t, r, i3, o2, u2, m3, a2, c3) {
  if (e2 < 0) return;
  if (o2 && !o2(i3.rayBegin, i3.rayEnd, e2)) return;
  const l2 = new e(u2.layerViewUid, u2.graphicUid(a2), r, m3, c3);
  if ((null == i3.results.min.distance || e2 < i3.results.min.distance) && i3.results.min.set(3, l2, e2, t, i3.transform.transform), (null == i3.results.max.distance || e2 > i3.results.max.distance) && i3.results.max.set(3, l2, e2, t, i3.transform.transform), 2 === i3.options.store) {
    const r2 = new f(i3.results.min.ray);
    r2.set(3, l2, e2, t, i3.transform.transform), i3.results.all.push(r2);
  }
}
var m = class {
  constructor(e2, t = null) {
    this.geometry = e2, this.textures = t;
  }
  get material() {
    return this.geometry.material;
  }
  get numTriangles() {
    return this.geometry.numTriangles;
  }
};
var a = class {
  constructor(t, r, s) {
    this.components = t, this.minScreenSpaceRadius = r, this.pivotOffset = s;
    const n = c(this.components.map((e2) => e2.geometry));
    this.numVertices = n.reduce((e2, t2) => e2 + t2.numVertices, 0);
  }
};
var c2 = class {
  constructor(e2) {
    this.levels = e2, this.levels.sort((e3, t) => e3.minScreenSpaceRadius === t.minScreenSpaceRadius ? e3.numVertices - t.numVertices : e3.minScreenSpaceRadius - t.minScreenSpaceRadius);
  }
  get materialParameters() {
    return this.levels[0].components[0].geometry.material.parameters;
  }
  getMaterials() {
    const t = [];
    return this.levels.forEach((e2) => e2.components.forEach((e3) => t.push(e3.geometry.material))), c(t);
  }
  getTextures() {
    const t = new Array();
    return this.levels.forEach((e2) => e2.components.forEach((e3) => {
      null != e3.textures && t.push(...e3.textures);
    })), c(t);
  }
  getGeometries() {
    const t = new Array();
    return this.levels.forEach((e2) => e2.components.forEach((e3) => {
      t.push(e3.geometry);
    })), c(t);
  }
  getEngineGeometries() {
    return this.getGeometries().map((e2) => e2.engineGeometry).filter((e2) => null != e2);
  }
  computeUsedMemory() {
    const e2 = this.getGeometries(), t = this.getTextures(), r = e2.reduce((e3, t2) => e3 + t2.computeUsedMemory(), 0);
    return t.reduce((e3, t2) => e3 + t2.usedMemory, 0) + r;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/primitiveObjectSymbolUtils.js
function S(e2) {
  switch (e2) {
    case "sphere":
    case "cube":
    case "diamond":
    case "cylinder":
    case "cone":
    case "inverted-cone":
    case "tetrahedron":
      return true;
  }
  return false;
}
function l(S2, l2) {
  const p = (n, s, a2 = false) => new c2(n.map((n2) => {
    const c3 = s(n2.tesselation);
    return a2 && bt(c3), new a([new m(new o(c3))], n2.minScreenSpaceRadius);
  }));
  switch (S2) {
    case "sphere":
      return p([{ tesselation: 0, minScreenSpaceRadius: 0 }, { tesselation: 1, minScreenSpaceRadius: 8 }, { tesselation: 2, minScreenSpaceRadius: 16 }, { tesselation: 3, minScreenSpaceRadius: 50 }, { tesselation: 4, minScreenSpaceRadius: 250 }], (e2) => ht(l2, 0.5, e2, true));
    case "cube":
      return p([{ tesselation: 0, minScreenSpaceRadius: 0 }], () => E(l2, 1));
    case "cone":
      return p(m2, (e2) => ft(l2, 1, 0.5, e2, false), true);
    case "inverted-cone":
      return p(m2, (e2) => ft(l2, 1, 0.5, e2, true), true);
    case "cylinder":
      return p(m2, (e2) => wt(l2, 1, 0.5, e2, [0, 0, 1], [0, 0, 0.5]));
    case "tetrahedron":
      return p([{ tesselation: 0, minScreenSpaceRadius: 0 }], () => rt(l2, 1), true);
    case "diamond":
      return p([{ tesselation: 0, minScreenSpaceRadius: 0 }], () => Q(l2, 1), true);
    default:
      return;
  }
}
var m2 = [{ tesselation: 6, minScreenSpaceRadius: 0 }, { tesselation: 18, minScreenSpaceRadius: 7 }, { tesselation: 64, minScreenSpaceRadius: 65 }];

export {
  o,
  m,
  a,
  c2 as c,
  S,
  l
};
//# sourceMappingURL=chunk-LBWWJ76V.js.map
