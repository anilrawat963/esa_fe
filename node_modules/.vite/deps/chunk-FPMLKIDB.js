import {
  z
} from "./chunk-H74Q4SYB.js";

// node_modules/@arcgis/core/geometry/support/aaBoundingRect.js
function r2(n) {
  return n;
}
function i(n = S) {
  return r2([n[0], n[1], n[2], n[3]]);
}
function a(n, t) {
  return n !== t && (n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3]), n;
}
function e(n, t, r3, u, a2 = i()) {
  return a2[0] = n, a2[1] = t, a2[2] = r3, a2[3] = u, a2;
}
function o(n, t = i()) {
  return t[0] = n.xmin, t[1] = n.ymin, t[2] = n.xmax, t[3] = n.ymax, t;
}
function c(n, r3, i2 = new z()) {
  return i2.xmin = n[0], i2.ymin = n[1], i2.xmax = n[2], i2.ymax = n[3], i2.spatialReference = r3, i2;
}
function f(n, t) {
  t[0] < n[0] && (n[0] = t[0]), t[0] > n[2] && (n[2] = t[0]), t[1] < n[1] && (n[1] = t[1]), t[1] > n[3] && (n[3] = t[1]);
}
function m(n, t) {
  t < n[0] && (n[0] = t), t > n[2] && (n[2] = t);
}
function h(n, t) {
  t < n[1] && (n[1] = t), t > n[3] && (n[3] = t);
}
function M(n, t, r3) {
  if (null != t) if ("length" in t) L(t) ? (r3[0] = Math.min(n[0], t[0]), r3[1] = Math.min(n[1], t[1]), r3[2] = Math.max(n[2], t[2]), r3[3] = Math.max(n[3], t[3])) : 2 !== t.length && 3 !== t.length || (r3[0] = Math.min(n[0], t[0]), r3[1] = Math.min(n[1], t[1]), r3[2] = Math.max(n[2], t[0]), r3[3] = Math.max(n[3], t[1]));
  else switch (t.type) {
    case "extent":
      r3[0] = Math.min(n[0], t.xmin), r3[1] = Math.min(n[1], t.ymin), r3[2] = Math.max(n[2], t.xmax), r3[3] = Math.max(n[3], t.ymax);
      break;
    case "point":
      r3[0] = Math.min(n[0], t.x), r3[1] = Math.min(n[1], t.y), r3[2] = Math.max(n[2], t.x), r3[3] = Math.max(n[3], t.y);
  }
  else a(r3, n);
}
function x(n, t, r3 = n) {
  const i2 = t.length;
  let u = n[0], a2 = n[1], e2 = n[2], o2 = n[3];
  for (let c2 = 0; c2 < i2; c2++) {
    const n2 = t[c2];
    u = Math.min(u, n2[0]), a2 = Math.min(a2, n2[1]), e2 = Math.max(e2, n2[0]), o2 = Math.max(o2, n2[1]);
  }
  return r3[0] = u, r3[1] = a2, r3[2] = e2, r3[3] = o2, r3;
}
function s(n) {
  for (let t = 0; t < 4; t++) if (!isFinite(n[t])) return false;
  return true;
}
function l(n) {
  return null == n || n[0] >= n[2] ? 0 : n[2] - n[0];
}
function y(n) {
  return null == n || n[1] >= n[3] ? 0 : n[3] - n[1];
}
function p(n) {
  return l(n) * y(n);
}
function g(n, t = [0, 0]) {
  return t[0] = (n[0] + n[2]) / 2, t[1] = (n[1] + n[3]) / 2, t;
}
function j(n) {
  const t = l(n), r3 = y(n);
  return Math.sqrt(t * t + r3 * r3);
}
function k(n, t) {
  return !!n && E(n, t.x, t.y);
}
function E(n, t, r3) {
  return t >= n[0] && r3 >= n[1] && t <= n[2] && r3 <= n[3];
}
function d(n, t) {
  return Math.max(t[0], n[0]) <= Math.min(t[2], n[2]) && Math.max(t[1], n[1]) <= Math.min(t[3], n[3]);
}
function v(n, t, r3) {
  return Math.max(t[0], n[0]) - r3 <= Math.min(t[2], n[2]) && Math.max(t[1], n[1]) - r3 <= Math.min(t[3], n[3]);
}
function z2(n, t) {
  return t[0] >= n[0] && t[2] <= n[2] && t[1] >= n[1] && t[3] <= n[3];
}
function G(n, t, r3, i2) {
  return i2 ??= n, i2[0] = n[0] + t, i2[1] = n[1] + r3, i2[2] = n[2] + t, i2[3] = n[3] + r3, i2;
}
function K(n) {
  return n ? a(n, Q) : i(Q);
}
function L(n) {
  return null != n && 4 === n.length;
}
function O(n, t) {
  return L(n) && L(t) ? n[0] === t[0] && n[1] === t[1] && n[2] === t[2] && n[3] === t[3] : n === t;
}
var P = r2([-1 / 0, -1 / 0, 1 / 0, 1 / 0]);
var Q = r2([1 / 0, 1 / 0, -1 / 0, -1 / 0]);
var S = r2([0, 0, 0, 0]);
var T = r2([0, 0, 1, 1]);

export {
  i,
  a,
  e,
  o,
  c,
  f,
  m,
  h,
  M,
  x,
  s,
  l,
  y,
  p,
  g,
  j,
  k,
  E,
  d,
  v,
  z2 as z,
  G,
  K,
  O,
  Q
};
//# sourceMappingURL=chunk-FPMLKIDB.js.map
