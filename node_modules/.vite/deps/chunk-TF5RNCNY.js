import {
  h as h2
} from "./chunk-WQW6HIRX.js";
import {
  e as e2
} from "./chunk-U2MAPSMR.js";
import {
  f as f5
} from "./chunk-QPBITBUR.js";
import {
  o as o4
} from "./chunk-7VJQTJLO.js";
import {
  V
} from "./chunk-PUWBFCEG.js";
import {
  F
} from "./chunk-VVMIB6RA.js";
import {
  c as c2
} from "./chunk-SQ4OSZIG.js";
import {
  a as a4
} from "./chunk-ZEI5DZXH.js";
import {
  s as s5
} from "./chunk-RGWH5UES.js";
import {
  c as c3
} from "./chunk-NOLINR6O.js";
import {
  c as c4
} from "./chunk-2KBTJPSU.js";
import {
  t as t4
} from "./chunk-JVMNF6GR.js";
import {
  o as o3
} from "./chunk-SL3GC7WV.js";
import {
  l as l5
} from "./chunk-CJZPTLIZ.js";
import {
  p as p5
} from "./chunk-5D65KWSM.js";
import {
  a as a5
} from "./chunk-4FQUAV7M.js";
import {
  A as A2,
  l as l7
} from "./chunk-EVZ7KLPS.js";
import {
  l as l6
} from "./chunk-JSH3APTG.js";
import {
  u as u3
} from "./chunk-WQT2KLDB.js";
import {
  d
} from "./chunk-UVDECGZC.js";
import {
  o as o2,
  s as s3
} from "./chunk-VKFTCFFM.js";
import {
  s as s4
} from "./chunk-ZETARPSI.js";
import {
  f as f3
} from "./chunk-TCDV4P3G.js";
import {
  I,
  T as T2,
  b as b3,
  b2 as b4,
  d as d2,
  l as l8,
  p as p7,
  s as s6,
  u as u4
} from "./chunk-CZOYDK6P.js";
import {
  m as m5,
  u as u2
} from "./chunk-RS755KXS.js";
import {
  i as i2
} from "./chunk-OC3OQ2CI.js";
import {
  A,
  B,
  C,
  D as D2,
  E,
  F as F3,
  H as H2,
  L as L2,
  M as M2,
  N,
  O as O2,
  P as P2,
  R as R2,
  S,
  T,
  Y,
  ae,
  j,
  k,
  oe,
  q as q2,
  te,
  v
} from "./chunk-KY5OS6CK.js";
import {
  j as j2
} from "./chunk-6TCXGIIN.js";
import {
  l
} from "./chunk-NP2TBOXH.js";
import {
  g
} from "./chunk-HCTBVF3W.js";
import {
  t as t3
} from "./chunk-5BAQPFKY.js";
import {
  F as F2
} from "./chunk-Y3FKYMXQ.js";
import {
  t as t2
} from "./chunk-QNDHLVDC.js";
import {
  p as p6
} from "./chunk-ZCI5A4FF.js";
import {
  b as b2
} from "./chunk-647DAMHU.js";
import {
  R
} from "./chunk-EFV6H5NA.js";
import {
  p as p4
} from "./chunk-PEL3D3ZN.js";
import {
  t
} from "./chunk-W5S3VUFT.js";
import {
  a as a3
} from "./chunk-7YH7T6CS.js";
import {
  _,
  n as n4
} from "./chunk-C3FRY5U4.js";
import {
  f as f4,
  n2 as n5,
  q
} from "./chunk-JNJX34GB.js";
import {
  D,
  M,
  c,
  h,
  l as l4
} from "./chunk-3STJRSDT.js";
import {
  x
} from "./chunk-23NJHA5Q.js";
import {
  m as m4
} from "./chunk-PMGS7UDU.js";
import {
  F as F4,
  H as H3,
  y2 as y
} from "./chunk-MC6NAKKX.js";
import {
  l as l3
} from "./chunk-TF6255HN.js";
import {
  n as n3
} from "./chunk-C5OQVQZF.js";
import {
  b as b5
} from "./chunk-P6IKJIMO.js";
import {
  n as n6
} from "./chunk-W6J7XCPU.js";
import {
  l as l2
} from "./chunk-T7F6Q6JJ.js";
import {
  O,
  n
} from "./chunk-YDTPM7OQ.js";
import {
  p as p3
} from "./chunk-XCKT47LJ.js";
import {
  P
} from "./chunk-PZ5RULLK.js";
import {
  z
} from "./chunk-H74Q4SYB.js";
import {
  m as m3
} from "./chunk-5UPBUJPC.js";
import {
  f as f2
} from "./chunk-5T3MJDSR.js";
import {
  H2 as H,
  m2,
  p2,
  w as w2
} from "./chunk-V2H77UEV.js";
import {
  s as s2
} from "./chunk-WRA2WBYC.js";
import {
  o
} from "./chunk-XWE6BM2U.js";
import {
  r
} from "./chunk-SOIZOFSB.js";
import {
  n as n2
} from "./chunk-XXLHAM2M.js";
import {
  b,
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2,
  w
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  L,
  f2 as f,
  p,
  u2 as u
} from "./chunk-GNMPGHLQ.js";
import {
  a,
  e,
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  has
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/graphic/isFeatureGraphicOrigin.js
var i3 = Symbol("isFeatureGraphicOrigin");

// node_modules/@arcgis/core/graphic/FeatureGraphicOrigin.js
var o5;
var a6 = class extends s3 {
  get [(o5 = i3, n5)]() {
    return this.layer;
  }
  get [n4]() {
    return this.layer;
  }
  get [o2]() {
    return this.layer;
  }
  constructor(r3) {
    super(), this[o5] = true, this.type = "feature", this.layer = r3;
  }
  get id() {
    return this.layer.id;
  }
};

// node_modules/@arcgis/core/layers/graphics/sources/MemorySource.js
var _2 = 0;
var T3 = class extends p3(m3(O)) {
  constructor(e4) {
    super(e4), this._idToClientGeometry = null, this.type = "memory";
  }
  load(e4) {
    const t5 = null != e4 ? e4.signal : null;
    return this.addResolvingPromise(this._startWorker(t5)), Promise.resolve(this);
  }
  destroy() {
    this._connection?.close(), this._connection = null;
  }
  get _workerGeometryType() {
    const e4 = this.layer?.geometryType;
    return e4 ? this._geometryTypeRequiresClientGraphicMapping(e4) ? "polygon" : e4 : null;
  }
  applyEdits(e4) {
    return this.load().then(() => this._applyEdits(e4));
  }
  openPorts() {
    return this.load().then(() => this._connection.openPorts());
  }
  async queryFeatures(e4, t5 = {}) {
    await this.load(t5);
    const r3 = await this._connection.invoke("queryFeatures", e4 ? e4.toJSON() : null, t5);
    t2(e4, this.layer.spatialReference, r3);
    const o7 = g.fromJSON(r3);
    if (!this._requiresClientGraphicMapping() || !this._idToClientGeometry) return o7;
    const s7 = this.layer.objectIdField;
    for (const i4 of o7.features) {
      const e5 = i4.attributes[s7], t6 = this._idToClientGeometry.get(e5);
      void 0 !== t6 && (i4.geometry = t6);
    }
    return o7.geometryType = this.layer.geometryType, o7;
  }
  async queryFeaturesJSON(e4, t5 = {}) {
    if (this._requiresClientGraphicMapping()) throw new s("query-features-json:unsupported", "Cannot query in JSON format for client only geometry types (mesh and extent)");
    await this.load(t5);
    const r3 = await this._connection.invoke("queryFeatures", e4 ? e4.toJSON() : null, t5);
    return t2(e4, this.layer.spatialReference, r3), r3;
  }
  queryFeatureCount(e4, t5 = {}) {
    return this.load(t5).then(() => this._connection.invoke("queryFeatureCount", e4 ? e4.toJSON() : null, t5));
  }
  queryObjectIds(e4, t5 = {}) {
    return this.load(t5).then(() => this._connection.invoke("queryObjectIds", e4 ? e4.toJSON() : null, t5));
  }
  queryExtent(e4, t5 = {}) {
    return this.load(t5).then(() => this._connection.invoke("queryExtent", e4 ? e4.toJSON() : null, t5)).then((e5) => ({ count: e5.count, extent: z.fromJSON(e5.extent) }));
  }
  querySnapping(e4, t5 = {}) {
    return this.load(t5).then(() => this._connection.invoke("querySnapping", e4, t5));
  }
  async queryAttributeBins(e4, t5 = {}) {
    return await this.load(), this._connection.invoke("queryAttributeBins", e4?.toJSON(), t5);
  }
  async _applyEdits(e4) {
    if (!this._connection) throw new s("feature-layer-source:edit-failure", "Memory source not loaded");
    const t5 = this.layer.objectIdField;
    let r3 = null;
    const s7 = [], i4 = [];
    await Promise.all([this._prepareClientMapping(e4.addFeatures, null), this._prepareClientMapping(e4.updateFeatures, null)]);
    const n8 = (e5) => "objectId" in e5 && null != e5.objectId ? e5.objectId : "attributes" in e5 && null != e5.attributes[t5] ? e5.attributes[t5] : null;
    if (e4.addFeatures && (r3 = this._prepareAddFeatures(e4.addFeatures)), e4.deleteFeatures) for (const o7 of e4.deleteFeatures) {
      const e5 = n8(o7);
      null != e5 && s7.push(e5);
    }
    const a8 = e4.updateFeatures && this._idToClientGeometry ? /* @__PURE__ */ new Map() : null;
    if (e4.updateFeatures) {
      for (const o7 of e4.updateFeatures) if (i4.push(this._serializeFeature(o7)), a8 && null != o7.geometry) {
        const e5 = n8(o7);
        null != e5 && a8.set(e5, o7);
      }
    }
    i2(r3 ? r3.features : null, i4, this.layer.spatialReference);
    const { fullExtent: l9, featureEditResults: u6 } = await this._connection.invoke("applyEdits", { adds: r3 ? r3.features : [], updates: i4, deletes: s7 });
    return this.fullExtent = l9, r3 && r3.finish(u6.uidToObjectId), this._updateIdToClientGeometries(a8, u6), this._createEditsResult(u6);
  }
  async _prepareClientMapping(e4, t5) {
    if ("mesh" !== this._layerOrSourceGeometryType || null == e4) return;
    const r3 = [];
    for (const { geometry: o7 } of e4) null == o7 || "mesh" !== o7.type || o7.hasExtent || o7.loaded || r3.push(o7.load({ signal: t5 }));
    r3.length && await Promise.all(r3);
  }
  _updateIdToClientGeometries(e4, t5) {
    if (this._idToClientGeometry) {
      if (e4) for (const r3 of t5.updateResults) {
        if (!r3.success) continue;
        const t6 = e4.get(r3.objectId);
        null != t6 && this._addIdToClientGeometry(t6);
      }
      for (const e5 of t5.deleteResults) e5.success && this._idToClientGeometry.delete(e5.objectId);
    }
  }
  _createEditsResult(e4) {
    return { addFeatureResults: e4.addResults ? e4.addResults.map(this._createFeatureEditResult, this) : [], updateFeatureResults: e4.updateResults ? e4.updateResults.map(this._createFeatureEditResult, this) : [], deleteFeatureResults: e4.deleteResults ? e4.deleteResults.map(this._createFeatureEditResult, this) : [], addAttachmentResults: [], updateAttachmentResults: [], deleteAttachmentResults: [] };
  }
  _createFeatureEditResult(e4) {
    const t5 = true === e4.success ? null : e4.error || { code: void 0, description: "" };
    return { objectId: e4.objectId, globalId: e4.globalId, error: t5 ? new s("feature-layer-source:edit-failure", t5.description, { code: t5.code }) : null };
  }
  _prepareAddFeatures(e4) {
    const t5 = /* @__PURE__ */ new Map(), r3 = new Array(e4.length);
    let o7 = null;
    for (let i4 = 0; i4 < e4.length; i4++) {
      const s8 = e4[i4], n8 = this._serializeFeature(s8);
      o7 || null == s8.geometry || (o7 = s8.geometry.type), r3[i4] = n8, t5.set(`${n8.uid}`, s8);
    }
    const s7 = this;
    return { features: r3, inferredGeometryType: o7, finish(e5) {
      const r4 = s7.sourceJSON.objectIdField;
      for (const o8 in e5) {
        const i4 = e5[o8], n8 = t5.get(o8);
        n8 && (n8.attributes || (n8.attributes = {}), -1 === i4 ? delete n8.attributes[r4] : n8.attributes[r4] = i4, s7._addIdToClientGeometry(n8));
      }
    } };
  }
  _addIdToClientGeometry(e4) {
    if (!this._idToClientGeometry) return;
    const t5 = this.sourceJSON.objectIdField, r3 = e4.attributes?.[t5];
    null != r3 && this._idToClientGeometry.set(r3, e4.geometry ?? null);
  }
  get _layerOrSourceGeometryType() {
    return this.layer?.geometryType ?? this.sourceJSON?.geometryType;
  }
  _requiresClientGraphicMapping() {
    return this._geometryTypeRequiresClientGraphicMapping(this._layerOrSourceGeometryType);
  }
  _geometryRequiresClientGraphicMapping(e4) {
    return this._geometryTypeRequiresClientGraphicMapping(e4.type);
  }
  _geometryTypeRequiresClientGraphicMapping(e4) {
    return "mesh" === e4 || "multipatch" === e4 || "extent" === e4;
  }
  _serializeFeature(e4) {
    const { attributes: t5 } = e4, r3 = this._geometryForSerialization(e4), o7 = (_2++).toString();
    return r3 ? { uid: o7, geometry: r3.toJSON(), attributes: t5 } : { uid: o7, attributes: t5 };
  }
  _geometryForSerialization(e4) {
    const { geometry: t5 } = e4;
    if (null == t5) return null;
    if (this._geometryRequiresClientGraphicMapping(t5)) {
      return t5.extent ? P.fromExtent(t5.extent) : null;
    }
    return t5;
  }
  async _startWorker(e4) {
    this._connection = await p6("MemorySourceWorker", { strategy: has("feature-layers-workers") ? "dedicated" : "local", signal: e4, registryTarget: this });
    const { fields: t5, spatialReference: r3, objectIdField: o7, hasM: s7, hasZ: n8, timeInfo: l9, dateFieldsTimeZone: u6 } = this.layer, p9 = "defaults" === this.layer.originOf("spatialReference");
    await this._prepareClientMapping(this.items, e4);
    const c6 = this._prepareAddFeatures(this.items);
    this.addHandles(this.on("before-changes", (e5) => {
      i.getLogger(this).error("Source modifications will not propagate after layer has been loaded. Please use .applyEdits() instead"), e5.preventDefault();
    }));
    const d3 = { features: c6.features, fields: t5?.map((e5) => e5.toJSON()), geometryType: m4.toJSON(this._workerGeometryType), hasM: "mesh" !== this._layerOrSourceGeometryType && s7, hasZ: "mesh" === this._layerOrSourceGeometryType || n8, objectIdField: o7, spatialReference: p9 ? null : r3 && r3.toJSON(), timeInfo: l9?.toJSON() ?? null, dateFieldsTimeZone: u6 }, y2 = await this._connection.invoke("load", d3, { signal: e4 });
    for (const a8 of y2.warnings) i.getLogger(this.layer).warn("#load()", `${a8.message} (title: '${this.layer.title || "no title"}', id: '${this.layer.id ?? "no id"}')`, { warning: a8 });
    y2.featureErrors.length && i.getLogger(this.layer).warn("#load()", `Encountered ${y2.featureErrors.length} validation errors while loading features. (title: '${this.layer.title || "no title"}', id: '${this.layer.id ?? "no id"}')`, { errors: y2.featureErrors });
    const m7 = y2.layerDefinition;
    this._geometryTypeRequiresClientGraphicMapping(c6.inferredGeometryType) && (m7.geometryType = m4.toJSON(c6.inferredGeometryType)), this.sourceJSON = m7, this._requiresClientGraphicMapping() && (this._idToClientGeometry = /* @__PURE__ */ new Map()), c6.finish(y2.assignedObjectIds);
  }
};
__decorate([n({ Type: _, ensureType: w(_) })], T3.prototype, "itemType", void 0), __decorate([m()], T3.prototype, "type", void 0), __decorate([m({ constructOnly: true })], T3.prototype, "layer", void 0), __decorate([m({ readOnly: true })], T3.prototype, "_workerGeometryType", null), __decorate([m()], T3.prototype, "sourceJSON", void 0), T3 = __decorate([a2("esri.layers.graphics.sources.MemorySource")], T3);

// node_modules/@arcgis/core/layers/support/PublishingInfo.js
var e3 = class extends b {
  constructor() {
    super(...arguments), this.updating = false, this.status = "unknown";
  }
};
__decorate([m()], e3.prototype, "updating", void 0), __decorate([m()], e3.prototype, "status", void 0), e3 = __decorate([a2("esri.layers.support.PublishingInfo")], e3);

// node_modules/@arcgis/core/layers/mixins/PublishableLayer.js
var o6 = Symbol();
var n7 = (i4) => {
  var _a;
  var n8;
  const c6 = i4;
  let a8 = (_a = class extends c6 {
    constructor() {
      super(...arguments), this[n8] = true;
    }
    get publishingInfo() {
      if (this.destroyed) return null;
      const t5 = this._get("publishingInfo");
      if (t5) return t5;
      const s7 = new e3();
      return this._checkPublishingStatus(s7), s7;
    }
    _checkPublishingStatus(t5) {
      const s7 = 250, e4 = 125;
      let r3 = 0;
      const o7 = async (s8) => {
        let n9;
        t5.updating = true;
        try {
          n9 = await this.fetchPublishingStatus();
        } catch (c7) {
          n9 = "unavailable";
        }
        "published" !== n9 && "unavailable" !== n9 || ("publishing" === t5.status && this.refresh(), i5.remove()), t5.status = n9, t5.updating = false, i5.removed || (r3 = setTimeout(o7, s8, s8 + e4));
      }, i5 = { removed: false, remove() {
        this.removed = true, clearTimeout(r3);
      } };
      this.when().catch(() => i5.remove()), o7(s7), this.addHandles(i5);
    }
  }, n8 = o6, _a);
  return __decorate([m({ readOnly: true, clonable: false })], a8.prototype, "publishingInfo", null), a8 = __decorate([a2("esri.layers.mixins.PublishableLayer")], a8), a8;
};

// node_modules/@arcgis/core/layers/support/FieldConfiguration.js
var p8 = class extends l2(n2) {
  constructor(o7) {
    super(o7), this.alias = null, this.name = void 0, this.fieldFormat = null;
  }
};
__decorate([m({ type: String, json: { write: true } })], p8.prototype, "alias", void 0), __decorate([m({ type: String, nonNullable: true, json: { write: { isRequired: true } } })], p8.prototype, "name", void 0), __decorate([m({ types: l4, json: { write: true } })], p8.prototype, "fieldFormat", void 0), p8 = __decorate([a2("esri.layers.support.FieldConfiguration")], p8);

// node_modules/@arcgis/core/layers/support/fieldConfigUtils.js
function r2(n8) {
  const { popupTemplate: t5, fieldsIndex: s7 } = n8, f6 = t5?.fieldInfos;
  if (!f6?.length || !s7) return;
  const i4 = [];
  for (const l9 of f6) {
    const { fieldName: n9, label: t6 } = l9, f7 = s7.get(n9);
    if (!f7) continue;
    const r3 = t6 && t6 !== f7.alias ? t6 : null, a8 = c(l9, f7);
    (r3 || a8) && i4.push(new p8({ name: f7.name, alias: r3, fieldFormat: a8 }));
  }
  return i4.length ? i4 : null;
}
function a7(n8) {
  const { fields: o7 } = n8;
  if (!o7?.length) return;
  const f6 = [];
  for (const i4 of o7) {
    const n9 = h(i4) ? M(i4) : null;
    n9 && f6.push(new p8({ name: i4.name, fieldFormat: n9 }));
  }
  return f6.length ? f6 : null;
}
function u5(n8, e4) {
  const { popupTemplate: o7, fieldsIndex: t5 } = n8;
  if (!o7 || !t5) return;
  const s7 = c5(n8, e4, o7.fieldInfos);
  if (!s7) return;
  const f6 = o7.clone();
  return f6.fieldInfos = s7, f6;
}
function c5(e4, o7, s7) {
  o7 ??= [], s7 = a(s7) ?? [];
  let i4 = false;
  const l9 = /* @__PURE__ */ new Map();
  for (const n8 of o7) {
    const o8 = e4.fieldsIndex.get(n8.name);
    o8 && l9.set(o8.name, n8);
  }
  for (const n8 of s7) {
    const o8 = e4.fieldsIndex.get(n8.fieldName);
    if (!o8) continue;
    const s8 = l9.get(o8.name);
    n8.label = s8?.alias || o8.alias, n8.format = h(o8) && s8?.fieldFormat ? D(s8.fieldFormat, o8) : null, i4 = true, l9.delete(o8.name);
  }
  for (const n8 of l9.values()) {
    const o8 = m6(e4, n8);
    o8 && (s7.push(o8), i4 = true);
  }
  return i4 ? s7 : null;
}
function m6(n8, e4) {
  const { name: o7, alias: s7, fieldFormat: r3 } = e4, a8 = n8.fieldsIndex.get(o7);
  if (!a8 || !s7 && !r3) return;
  const u6 = s7 || a8.alias, c6 = h(a8) && r3 ? D(r3, a8) : null;
  return new f4({ fieldName: a8.name, label: u6, format: c6, visible: false, isEditable: H3(a8, n8) });
}

// node_modules/@arcgis/core/layers/FeatureLayer.js
var ze = "FeatureLayer";
function ke(e4, t5) {
  return new s("layer:unsupported", `Layer (${e4.title}, ${e4.id}) of type '${e4.declaredClass}' ${t5}`, { layer: e4 });
}
function Ke(e4) {
  return e4 && e4 instanceof O;
}
var Xe = s5();
function Ye(e4, t5, r3) {
  const i4 = !!r3?.writeLayerSchema;
  return { enabled: i4, ignoreOrigin: i4 };
}
var et = class extends V(f5(c2(n7(F2(a4(p4(p5(l6(e2(t(f3(l5(b4(j2(l(s4(o3(l2(b5))))))))))))))))))) {
  constructor(...e4) {
    super(...e4), this.attributeTableTemplate = null, this.charts = null, this.copyright = null, this.displayField = null, this.dynamicDataSource = null, this.fields = null, this.fieldsIndex = null, this.formTemplate = null, this.fullExtent = null, this.geometryType = null, this.graphicOrigin = new a6(this), this.hasM = void 0, this.hasZ = void 0, this.infoFor3D = null, this.isTable = false, this.labelsVisible = true, this.labelingInfo = null, this.legendEnabled = true, this.objectIdField = null, this.operationalLayerType = "ArcGISFeatureLayer", this.outFields = null, this.path = null, this.popupEnabled = true, this.popupTemplate = null, this.resourceInfo = null, this.screenSizePerspectiveEnabled = true, this.spatialReference = f2.WGS84, this.subtypeCode = null, this.supportedSourceTypes = /* @__PURE__ */ new Set(["Feature Layer", "Oriented Imagery Layer", "Table", "Catalog Layer"]), this.templates = null, this.timeInfo = null, this.title = null, this.sublayerTitleMode = "item-title", this.type = "feature", this.typeIdField = null, this.types = null, this.visible = true, this._debouncedSaveOperations = L(async (e5, t5, r3) => {
      const { save: i4, saveAs: o7 } = await import("./featureLayerUtils-XSPSJ4JS.js");
      switch (e5) {
        case 0:
          return i4(this, t5);
        case 1:
          return o7(this, r3, t5);
      }
    });
  }
  destroy() {
    this.source?.destroy();
  }
  normalizeCtorArgs(e4, t5) {
    return "string" == typeof e4 ? { url: e4, ...t5 } : e4;
  }
  load(e4) {
    const t5 = null != e4 ? e4.signal : null;
    if (this.portalItem?.loaded && this.source) return this.addResolvingPromise(this.createGraphicsSource(t5).then((e5) => this.initLayerProperties(e5))), Promise.resolve(this);
    const r3 = this.loadFromPortal({ supportedTypes: ["Feature Service", "Feature Collection", "Scene Service"] }, e4).catch(f).then(async () => {
      if (this.url && null == this.layerId && /FeatureServer|MapServer\/*$/i.test(this.url)) {
        const e5 = await this._fetchFirstValidLayerId(t5);
        null != e5 && (this.layerId = e5);
      }
      if (!this.url && !this._hasMemorySource()) throw new s("feature-layer:missing-url-or-source", "Feature layer must be created with either a url or a source");
      return this.initLayerProperties(await this.createGraphicsSource(t5));
    }).then(() => H2(this, "load", e4));
    return this.addResolvingPromise(r3), Promise.resolve(this);
  }
  get _titleCreator() {
    const e4 = this._get("_titleCreator");
    return u(e4), new h2({ fieldsIndex: this.fieldsIndex, objectIdField: this.objectIdField, fields: this.fields, displayField: this.displayField, effectivePopupTemplate: this.popupTemplate ?? this.defaultPopupTemplate });
  }
  readCapabilities(e4, t5) {
    return t5 = t5.layerDefinition || t5, c3(t5, this.url);
  }
  get createQueryVersion() {
    return this.commitProperty("definitionExpression"), this.commitProperty("dynamicDataSource"), this.commitProperty("timeExtent"), this.commitProperty("timeOffset"), this.commitProperty("geometryType"), this.commitProperty("gdbVersion"), this.commitProperty("historicMoment"), this.commitProperty("returnZ"), this.commitProperty("capabilities"), this.commitProperty("returnM"), (this._get("createQueryVersion") ?? 0) + 1;
  }
  get editingEnabled() {
    return !(this.loaded && !this.capabilities?.operations.supportsEditing) && (this._isOverridden("editingEnabled") ? this._get("editingEnabled") : this._hasMemorySource() || this.userHasEditingPrivileges);
  }
  set editingEnabled(e4) {
    this._overrideIfSome("editingEnabled", e4);
  }
  readEditingEnabled(e4, t5) {
    return this._readEditingEnabled(t5, false);
  }
  readEditingEnabledFromWebMap(e4, t5, r3) {
    return this._readEditingEnabled(t5, true, r3);
  }
  writeEditingEnabled(e4, t5) {
    this._writeEditingEnabled(e4, t5, false);
  }
  writeEditingEnabledToWebMap(e4, t5, r3, i4) {
    this._writeEditingEnabled(e4, t5, true, i4);
  }
  get effectiveEditingEnabled() {
    return Y(this);
  }
  get featureTitleFields() {
    return [...this._titleCreator.requiredFields];
  }
  set fieldConfigurations(e4) {
    if (this._hasMemorySource()) return;
    if (this._override("fieldConfigurations", e4), !this.loaded) return;
    const t5 = u5(this, e4);
    t5 && this._set("popupTemplate", t5);
  }
  get fieldConfigurations() {
    if (!this._hasMemorySource()) return this._isOverridden("fieldConfigurations") ? this._get("fieldConfigurations") : r2(this) || null;
  }
  readIsTable(e4, t5) {
    return "Table" === (t5 = t5?.layerDefinition ?? t5).type || !t5.geometryType;
  }
  writeIsTable(e4, t5, r3, i4) {
    i4?.writeLayerSchema && e(r3, e4 ? "Table" : "Feature Layer", t5);
  }
  readGlobalIdField(e4, t5) {
    return M2(t5.layerDefinition || t5);
  }
  readObjectIdField(e4, t5) {
    return k(t5.layerDefinition || t5);
  }
  writePopupTemplate(e4, t5, r3, i4) {
    e4 && (t5[r3] = e4.toJSON({ ...i4, writeFieldFormat: !i4?.writeLayerSchema }));
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  set renderer(e4) {
    y(e4, this.fieldsIndex), this._set("renderer", e4);
  }
  readRenderer(e4, t5, r3) {
    t5 = t5.layerDefinition || t5;
    const i4 = t5.drawingInfo?.renderer;
    if (i4) {
      const e5 = o4(i4, t5, r3) ?? void 0;
      return e5 || i.getLogger(this).error("Failed to create renderer", { rendererDefinition: t5.drawingInfo.renderer, layer: this, context: r3 }), e5;
    }
    return te(t5, r3);
  }
  set source(e4) {
    const t5 = this._get("source");
    t5 !== e4 && (Ke(t5) && this._resetMemorySource(t5), Ke(e4) && this._initMemorySource(e4), this._set("source", e4));
  }
  castSource(e4) {
    return e4 ? Array.isArray(e4) || e4 instanceof O ? new T3({ layer: this, items: e4 }) : e4 : null;
  }
  readSource(e4, t5) {
    const r3 = g.fromJSON(t5.featureSet);
    return new T3({ layer: this, items: r3?.features ?? [] });
  }
  readTemplates(e4, t5) {
    const r3 = t5.editFieldsInfo, i4 = r3?.creatorField, o7 = r3?.editorField;
    return e4 = e4?.map((e5) => a5.fromJSON(e5)), this._fixTemplates(e4, i4), this._fixTemplates(e4, o7), e4;
  }
  readTitle(e4, t5) {
    const r3 = t5.layerDefinition?.name ?? t5.name, i4 = t5.title || t5.layerDefinition?.title;
    if (r3) {
      const e5 = this.portalItem?.title;
      if ("item-title" === this.sublayerTitleMode) return this.url ? w2(this.url, r3) : r3;
      let t6 = r3;
      if (!t6 && this.url) {
        const e6 = p2(this.url);
        null != e6 && (t6 = e6.title);
      }
      if (!t6) return;
      return "item-title-and-service-name" === this.sublayerTitleMode && e5 && e5 !== t6 && (t6 = e5 + " - " + t6), m2(t6);
    }
    if ("item-title" === this.sublayerTitleMode && i4) return i4;
  }
  readTitleFromWebMap(e4, t5) {
    return t5.title || t5.layerDefinition?.name;
  }
  readTypeIdField(e4, t5) {
    let r3 = (t5 = t5.layerDefinition || t5).typeIdField;
    if (r3 && t5.fields) {
      r3 = r3.toLowerCase();
      const e5 = t5.fields.find((e6) => e6.name.toLowerCase() === r3);
      e5 && (r3 = e5.name);
    }
    return r3;
  }
  readTypes(e4, t5) {
    e4 = (t5 = t5.layerDefinition || t5).types;
    const r3 = t5.editFieldsInfo, i4 = r3?.creatorField, o7 = r3?.editorField;
    return e4?.map((e5) => (e5 = c4.fromJSON(e5), this._fixTemplates(e5.templates, i4), this._fixTemplates(e5.templates, o7), e5));
  }
  readVisible(e4, t5) {
    return null != t5.layerDefinition?.defaultVisibility ? !!t5.layerDefinition.defaultVisibility : null != t5.visibility ? !!t5.visibility : void 0;
  }
  async addAttachment(e4, t5) {
    const r3 = await F3(this, e4, t5, ze);
    return this.lastEditsEventDate = /* @__PURE__ */ new Date(), r3;
  }
  async updateAttachment(e4, t5, r3) {
    const i4 = await P2(this, e4, t5, r3, ze);
    return this.lastEditsEventDate = /* @__PURE__ */ new Date(), i4;
  }
  async applyEdits(e4, t5) {
    return q2(this, e4, t5);
  }
  async uploadAssets(e4, t5) {
    return S(this, e4, t5);
  }
  createFieldConfigurations() {
    return a7(this);
  }
  createPopupTemplate(e4) {
    return d(this, e4);
  }
  async createGraphicsSource(e4) {
    if (this._hasMemorySource() && this.source) return this.source.load({ signal: e4 });
    const { default: t5 } = await p(import("./FeatureLayerSource-ALLV5SO3.js"), e4);
    return new t5({ layer: this, supportedSourceTypes: this.supportedSourceTypes }).load({ signal: e4 });
  }
  createQuery() {
    const e4 = R2(this);
    e4.dynamicDataSource = this.dynamicDataSource;
    const t5 = null != this.subtypeCode ? `${this.subtypeField} = ${this.subtypeCode}` : null, r3 = l3(this.definitionExpression, t5);
    return e4.where = r3 || "1=1", e4;
  }
  async deleteAttachments(e4, t5) {
    const r3 = await v(this, e4, t5, ze);
    return this.lastEditsEventDate = /* @__PURE__ */ new Date(), r3;
  }
  async fetchRecomputedExtents(e4) {
    return O2(this, e4, ze);
  }
  async getFeatureTitle(e4, t5) {
    return this._titleCreator.getTitle(this, e4, t5);
  }
  async getFeatureTitles(e4, t5) {
    return this._titleCreator.getTitles(this, e4, t5);
  }
  getFeatureType(e4) {
    return oe(this.types, this.typeIdField, e4);
  }
  getFieldAlias(e4) {
    const t5 = this.getField(e4);
    if (t5) return this.getFieldConfiguration(t5.name)?.alias || t5.alias;
  }
  getFieldConfiguration(e4) {
    return e4 = e4.toLowerCase(), this.fieldConfigurations?.find((t5) => t5.name.toLowerCase() === e4);
  }
  getFieldDomain(e4, t5) {
    return N(this, e4, t5, this.getField(e4)?.domain ?? null);
  }
  async queryAttachments(e4, t5) {
    return A(this, e4, t5, ze);
  }
  async queryFeatures(e4, t5) {
    const r3 = await this.load(), i4 = await r3.source.queryFeatures(b2.from(e4) ?? r3.createQuery(), t5), o7 = this.graphicOrigin;
    if (i4?.features) for (const s7 of i4.features) s7.layer = s7.sourceLayer = r3, s7.origin = o7;
    return i4;
  }
  async queryObjectIds(e4, t5) {
    return await L2(this, e4, t5, ze);
  }
  async queryFeatureCount(e4, t5) {
    return E(this, e4, t5, ze);
  }
  async queryExtent(e4, t5) {
    return D2(this, e4, t5, ze);
  }
  async queryRelatedFeatures(e4, t5) {
    return T(this, e4, t5, ze);
  }
  async queryRelatedFeaturesCount(e4, t5) {
    return C(this, e4, t5, ze);
  }
  async queryPivot(e4, t5) {
    const { source: r3, capabilities: i4 } = await this.load();
    if (!r3.queryPivot || !i4?.operations?.supportsQueryPivot) throw new s(ze, "Layer source does not support queryPivot capability");
    const o7 = await import("./PivotQuery-MM2UBTXE.js"), a8 = await r3.queryPivot(o7.default.from(e4), t5);
    if (a8?.features) for (const s7 of a8.features) s7.layer = s7.sourceLayer = this;
    return a8;
  }
  async queryTopFeatures(e4, t5) {
    const { source: r3, capabilities: i4 } = await this.load();
    if (!r3.queryTopFeatures || !i4?.query?.supportsTopFeaturesQuery) throw new s(ze, "Layer source does not support queryTopFeatures capability");
    const o7 = await import("./TopFeaturesQuery-XWB7EKKD.js"), a8 = await r3.queryTopFeatures(o7.default.from(e4), t5);
    if (a8?.features) for (const s7 of a8.features) s7.layer = s7.sourceLayer = this;
    return a8;
  }
  async queryAttributeBins(e4, t5) {
    const { source: r3, capabilities: i4 } = await this.load();
    if (!r3.queryAttributeBins) throw new s(ze, "Layer source does not support queryAttributeBins capability");
    ae(e4, i4, ze);
    const o7 = await import("./AttributeBinsQuery-OSMHDGXH.js"), a8 = await r3.queryAttributeBins(o7.default.from(e4), t5);
    if (a8.features) for (const s7 of a8.features) s7.layer = s7.sourceLayer = this;
    return a8;
  }
  async queryTopObjectIds(e4, t5) {
    const { source: r3, capabilities: i4 } = await this.load();
    if (!r3.queryTopObjectIds || !i4?.query.supportsTopFeaturesQuery) throw new s(ze, "Layer source does not support queryTopObjectIds capability");
    const o7 = await import("./TopFeaturesQuery-XWB7EKKD.js");
    return (await r3.queryTopObjectIds(o7.default.from(e4), t5)).filter(n3);
  }
  async queryTopFeaturesExtent(e4, t5) {
    const { source: r3, capabilities: i4 } = await this.load();
    if (!r3.queryTopExtents || !i4?.query?.supportsTopFeaturesQuery) throw new s(ze, "Layer source does not support queryTopExtents capability");
    const o7 = await import("./TopFeaturesQuery-XWB7EKKD.js");
    return r3.queryTopExtents(o7.default.from(e4), t5);
  }
  async queryTopFeatureCount(e4, t5) {
    const { source: r3, capabilities: i4 } = await this.load();
    if (!r3.queryTopCount || !i4?.query?.supportsTopFeaturesQuery) throw new s(ze, "Layer source does not support queryFeatureCount capability");
    const o7 = await import("./TopFeaturesQuery-XWB7EKKD.js");
    return r3.queryTopCount(o7.default.from(e4), t5);
  }
  read(e4, t5) {
    const r3 = e4.featureCollection;
    if ((r3 || "Feature Collection" === e4.type) && (this.resourceInfo = e4), r3) {
      const { layers: e5, showLegend: i4 } = r3;
      1 === e5?.length && (super.read(e5[0], t5), null != i4 && super.read({ showLegend: i4 }, t5));
    }
    super.read(e4, t5), t5 && "service" === t5.origin && (this.revert(["objectIdField", "fields", "timeInfo", "dateFieldsTimeZone"], "service"), this.spatialReference || this.revert(["spatialReference"], "service"));
  }
  write(e4, t5) {
    t5 = { ...t5, origin: t5?.origin ?? void 0, writeLayerSchema: t5?.writeLayerSchema ?? this._hasMemorySource() };
    const { origin: r3, layerContainerType: i4, messages: o7 } = t5;
    if (this.dynamicDataSource) return o7?.push(ke(this, "using a dynamic data source cannot be written to web scenes, web maps and feature service items")), null;
    if (this.isTable) {
      if (("web-map" === r3 || "web-scene" === r3) && "tables" !== i4) return o7?.push(ke(this, `a table source can only be written to tables, not ${i4}`)), null;
      if (this._hasMemorySource()) return o7?.push(ke(this, "using an in-memory table source cannot be written to web scenes and web maps")), null;
    } else if (this.loaded && ("web-map" === r3 || "web-scene" === r3) && "tables" === i4) return o7?.push(ke(this, "using a non-table source cannot be written to tables in web maps or web scenes")), null;
    return super.write(e4, t5);
  }
  clone() {
    if (this._hasMemorySource()) throw new s(ze, `FeatureLayer (title: ${this.title}, id: ${this.id}) created using in-memory source cannot be cloned`);
    return super.clone();
  }
  serviceSupportsSpatialReference(e4) {
    return !!this.loaded && ("memory" === this.source?.type || t4(this, e4));
  }
  async save(e4) {
    return this._debouncedSaveOperations(0, e4);
  }
  async saveAs(e4, t5) {
    return this._debouncedSaveOperations(1, t5, e4);
  }
  _readEditingEnabled(e4, t5, r3) {
    let i4 = e4.layerDefinition?.capabilities;
    return i4 ? this._hasEditingCapability(i4) : (i4 = e4.capabilities, t5 && "web-map" === r3?.origin && !this._hasMemorySource() && i4 ? this._hasEditingCapability(i4) : void 0);
  }
  _hasEditingCapability(e4) {
    return e4.toLowerCase().split(",").map((e5) => e5.trim()).includes("editing");
  }
  _writeEditingEnabled(e4, t5, r3, i4) {
    if (!e4) {
      const e5 = this.capabilities?.operations?.supportsSync ? "Query,Sync" : "Query";
      e("layerDefinition.capabilities", e5, t5), r3 && !i4?.writeLayerSchema && (t5.capabilities = e5);
    }
  }
  _fetchFirstValidLayerId(e4) {
    return H(this.url ?? "", { query: { f: "json", ...this.customParameters, token: this.apiKey }, responseType: "json", signal: e4 }).then((e5) => {
      const t5 = e5.data;
      if (t5) return this.applyPreferredHost(t5), this.findFirstValidLayerId(t5);
    });
  }
  async initLayerProperties(e4) {
    return this._set("source", e4), e4.sourceJSON && (this.sourceJSON = e4.sourceJSON, this.read(e4.sourceJSON, { origin: "service", portalItem: this.portalItem, portal: this.portalItem?.portal, url: this.parsedUrl })), this._verifySource(), this._verifyFields(), y(this.renderer, this.fieldsIndex), F4(this.timeInfo, this.fieldsIndex), this._hasMemorySource() && "mesh" === this.geometryType && (this.capabilities.query.supportsReturnMesh = true), t3(this, { origin: "service" });
  }
  async hasDataChanged() {
    return B(this);
  }
  async fetchPublishingStatus() {
    const e4 = this.source;
    return e4?.fetchPublishingStatus ? e4.fetchPublishingStatus() : "unavailable";
  }
  _verifyFields() {
    const e4 = this.parsedUrl?.path ?? "undefined";
    this.objectIdField || console.log("FeatureLayer: 'objectIdField' property is not defined (url: " + e4 + ")"), this.isTable || this._hasMemorySource() || -1 !== e4.search(/\/FeatureServer\//i) || this.fields?.some((e5) => "geometry" === e5.type) || console.log("FeatureLayer: unable to find field of type 'geometry' in the layer 'fields' list. If you are using a map service layer, features will not have geometry (url: " + e4 + ")");
  }
  _fixTemplates(e4, t5) {
    e4 && e4.forEach((e5) => {
      const r3 = e5.prototype?.attributes;
      r3 && t5 && delete r3[t5];
    });
  }
  _verifySource() {
    if (this._hasMemorySource()) {
      if (this.url) throw new s("feature-layer:mixed-source-and-url", "FeatureLayer cannot be created with both an in-memory source and a url");
    } else if (!this.url) throw new s("feature-layer:source-or-url-required", "FeatureLayer requires either a url, a valid portal item or a source");
  }
  _initMemorySource(e4) {
    e4.forEach((e5) => {
      e5.layer = this, e5.sourceLayer = this;
    }), this.addHandles([e4.on("after-add", (e5) => {
      e5.item.layer = this, e5.item.sourceLayer = this;
    }), e4.on("after-remove", (e5) => {
      e5.item.layer = null, e5.item.sourceLayer = null;
    })], "fl-source");
  }
  _resetMemorySource(e4) {
    e4.forEach((e5) => {
      e5.layer = null, e5.sourceLayer = null;
    }), this.removeHandles("fl-source");
  }
  _hasMemorySource() {
    return !(this.url || !this.source);
  }
  findFirstValidLayerId(e4) {
    return Array.isArray(e4.layers) && e4.layers.length > 0 ? e4.layers[0].id : Array.isArray(e4.tables) && e4.tables.length > 0 ? e4.tables[0].id : void 0;
  }
};
__decorate([m({ clonable: false, readOnly: true })], et.prototype, "_titleCreator", null), __decorate([m(I)], et.prototype, "attributeTableTemplate", void 0), __decorate([o("service", "capabilities")], et.prototype, "readCapabilities", null), __decorate([m({ json: { origins: { "web-scene": { write: false } }, write: true } })], et.prototype, "charts", void 0), __decorate([m({ readOnly: true })], et.prototype, "createQueryVersion", null), __decorate([m({ json: { read: { source: "layerDefinition.copyrightText" } } })], et.prototype, "copyright", void 0), __decorate([m({ json: { read: { source: "layerDefinition.displayField" } } })], et.prototype, "displayField", void 0), __decorate([m({ types: x, readOnly: true })], et.prototype, "defaultSymbol", void 0), __decorate([m({ type: R })], et.prototype, "dynamicDataSource", void 0), __decorate([m({ type: Boolean })], et.prototype, "editingEnabled", null), __decorate([o(["portal-item", "web-scene"], "editingEnabled", ["layerDefinition.capabilities"])], et.prototype, "readEditingEnabled", null), __decorate([o("web-map", "editingEnabled", ["capabilities", "layerDefinition.capabilities"])], et.prototype, "readEditingEnabledFromWebMap", null), __decorate([r(["portal-item", "web-scene"], "editingEnabled", { "layerDefinition.capabilities": { type: String } })], et.prototype, "writeEditingEnabled", null), __decorate([r("web-map", "editingEnabled", { capabilities: { type: String }, "layerDefinition.capabilities": { type: String } })], et.prototype, "writeEditingEnabledToWebMap", null), __decorate([m({ readOnly: true })], et.prototype, "effectiveEditingEnabled", null), __decorate([m({ clonable: false, readOnly: true })], et.prototype, "featureTitleFields", null), __decorate([m({ type: [p8], json: { name: "layerDefinition.fieldConfigurations", write: { overridePolicy(e4, t5, r3) {
  return { enabled: !r3?.writeLayerSchema, ignoreOrigin: 1 === this.originIdOf(t5) };
} } } })], et.prototype, "fieldConfigurations", null), __decorate([m({ ...Xe.fields, json: { read: { source: "layerDefinition.fields" }, origins: { service: { name: "fields" }, "web-map": { write: { target: "layerDefinition.fields", overridePolicy: Ye } } } } })], et.prototype, "fields", void 0), __decorate([m(Xe.fieldsIndex)], et.prototype, "fieldsIndex", void 0), __decorate([m({ type: F, json: { name: "formInfo", write: true, origins: { "web-scene": { read: false, write: false } } } })], et.prototype, "formTemplate", void 0), __decorate([m({ json: { read: { source: "layerDefinition.extent" } } })], et.prototype, "fullExtent", void 0), __decorate([m({ json: { origins: { "web-map": { write: { target: "layerDefinition.geometryType", overridePolicy: Ye, writer(e4, t5, r3) {
  const i4 = e4 ? j.toJSON(e4) : null;
  i4 && e(r3, i4, t5);
} } } }, read: { source: "layerDefinition.geometryType", reader: j.read } } })], et.prototype, "geometryType", void 0), __decorate([m({ readOnly: true, clonable: false })], et.prototype, "graphicOrigin", void 0), __decorate([m({ json: { read: { source: "layerDefinition.hasM" } } })], et.prototype, "hasM", void 0), __decorate([m({ json: { read: { source: "layerDefinition.hasZ" } } })], et.prototype, "hasZ", void 0), __decorate([m(u4)], et.prototype, "id", void 0), __decorate([m({ readOnly: true, json: { origins: { service: { read: true } }, read: false } })], et.prototype, "infoFor3D", void 0), __decorate([m({ json: { origins: { "web-map": { write: { target: "layerDefinition.type" } } } } })], et.prototype, "isTable", void 0), __decorate([o("service", "isTable", ["type", "geometryType"]), o("isTable", ["layerDefinition.type", "layerDefinition.geometryType"])], et.prototype, "readIsTable", null), __decorate([r("web-map", "isTable")], et.prototype, "writeIsTable", null), __decorate([m(p7)], et.prototype, "labelsVisible", void 0), __decorate([m({ type: [A2], json: { origins: { service: { name: "drawingInfo.labelingInfo", read: l7, write: false } }, name: "layerDefinition.drawingInfo.labelingInfo", read: l7, write: { layerContainerTypes: a3 } } })], et.prototype, "labelingInfo", void 0), __decorate([m((() => {
  const e4 = a(b3);
  return e4.json.origins["portal-item"] = { write: { target: "layerDefinition.drawingInfo.transparency", writer(e5, t5, r3) {
    e(r3, n6(e5), t5);
  } } }, e4;
})())], et.prototype, "opacity", void 0), __decorate([m(d2)], et.prototype, "legendEnabled", void 0), __decorate([m({ type: ["show", "hide"], json: (() => {
  const e4 = a(T2.json);
  return e4.origins["portal-item"] = { read: false, write: false }, e4;
})() })], et.prototype, "listMode", void 0), __decorate([o("globalIdField", ["layerDefinition.globalIdField", "layerDefinition.fields"])], et.prototype, "readGlobalIdField", null), __decorate([m({ json: { origins: { "web-map": { write: { target: "layerDefinition.objectIdField", overridePolicy: Ye } } } } })], et.prototype, "objectIdField", void 0), __decorate([o("objectIdField", ["layerDefinition.objectIdField", "layerDefinition.fields"])], et.prototype, "readObjectIdField", null), __decorate([m({ type: ["ArcGISFeatureLayer"], json: { write: { target: "layerType", ignoreOrigin: true, layerContainerTypes: a3 } } })], et.prototype, "operationalLayerType", void 0), __decorate([m(Xe.outFields)], et.prototype, "outFields", void 0), __decorate([m({ type: String, json: { origins: { "web-scene": { read: true, write: true } }, read: false } })], et.prototype, "path", void 0), __decorate([m(l8)], et.prototype, "popupEnabled", void 0), __decorate([m({ type: q, json: { name: "popupInfo", write: true } })], et.prototype, "popupTemplate", void 0), __decorate([r("popupTemplate")], et.prototype, "writePopupTemplate", null), __decorate([m({ readOnly: true })], et.prototype, "defaultPopupTemplate", null), __decorate([m({ types: m5, json: { origins: { service: { write: { target: "drawingInfo.renderer", enabled: false } }, "web-scene": { types: u2, name: "layerDefinition.drawingInfo.renderer", write: { layerContainerTypes: a3, overridePolicy: (e4, t5, r3) => ({ ignoreOrigin: r3?.writeLayerSchema, layerContainerTypes: a3 }) } } }, write: { target: "layerDefinition.drawingInfo.renderer", overridePolicy: (e4, t5, r3) => ({ ignoreOrigin: r3?.writeLayerSchema, layerContainerTypes: a3 }) } } })], et.prototype, "renderer", null), __decorate([o("service", "renderer", ["drawingInfo.renderer", "defaultSymbol"]), o("renderer", ["layerDefinition.drawingInfo.renderer", "layerDefinition.defaultSymbol"])], et.prototype, "readRenderer", null), __decorate([m()], et.prototype, "resourceInfo", void 0), __decorate([m((() => {
  const e4 = a(s6);
  return e4.json.origins["portal-item"] = { read: false, write: false }, e4;
})())], et.prototype, "screenSizePerspectiveEnabled", void 0), __decorate([m({ clonable: false })], et.prototype, "source", null), __decorate([s2("source")], et.prototype, "castSource", null), __decorate([o("portal-item", "source", ["featureSet"]), o("web-map", "source", ["featureSet"])], et.prototype, "readSource", null), __decorate([m({ json: { read: { source: "layerDefinition.extent.spatialReference" } } })], et.prototype, "spatialReference", void 0), __decorate([m({ type: Number })], et.prototype, "subtypeCode", void 0), __decorate([m({ type: [a5] })], et.prototype, "templates", void 0), __decorate([o("templates", ["editFieldsInfo", "creatorField", "editorField", "templates"])], et.prototype, "readTemplates", null), __decorate([m({ type: u3 })], et.prototype, "timeInfo", void 0), __decorate([m()], et.prototype, "title", void 0), __decorate([o("service", "title", ["name"]), o("portal-item", "title", ["layerDefinition.title", "layerDefinition.name", "title"])], et.prototype, "readTitle", null), __decorate([o("web-map", "title", ["layerDefinition.name", "title"])], et.prototype, "readTitleFromWebMap", null), __decorate([m({ type: String })], et.prototype, "sublayerTitleMode", void 0), __decorate([m({ json: { read: false } })], et.prototype, "type", void 0), __decorate([m({ type: String })], et.prototype, "typeIdField", void 0), __decorate([o("service", "typeIdField"), o("typeIdField", ["layerDefinition.typeIdField"])], et.prototype, "readTypeIdField", null), __decorate([m({ type: [c4] })], et.prototype, "types", void 0), __decorate([o("service", "types", ["types"]), o("types", ["layerDefinition.types"])], et.prototype, "readTypes", null), __decorate([m({ type: Boolean, json: { origins: { "portal-item": { write: { target: "layerDefinition.defaultVisibility", layerContainerTypes: a3 } } } } })], et.prototype, "visible", void 0), __decorate([o("portal-item", "visible", ["visibility", "layerDefinition.defaultVisibility"])], et.prototype, "readVisible", null), et = __decorate([a2("esri.layers.FeatureLayer")], et);

export {
  et
};
//# sourceMappingURL=chunk-TF5RNCNY.js.map
