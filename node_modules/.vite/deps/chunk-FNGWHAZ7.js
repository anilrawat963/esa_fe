import {
  w
} from "./chunk-62W3XEE6.js";
import {
  h
} from "./chunk-7CDU3B2L.js";
import {
  e
} from "./chunk-JUZ3H47H.js";
import {
  z
} from "./chunk-YP3WVJP3.js";
import {
  c,
  i
} from "./chunk-FPMLKIDB.js";
import {
  G
} from "./chunk-NMQNUPE4.js";
import {
  b,
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  L,
  f2 as f,
  j,
  s
} from "./chunk-GNMPGHLQ.js";

// node_modules/@arcgis/core/views/2d/viewStateUtils.js
var t = Math.PI / 180;
function n(n2) {
  return n2 * t;
}
function o(t2, o2) {
  const a3 = n(o2.rotation), r = Math.abs(Math.cos(a3)), s2 = Math.abs(Math.sin(a3)), [u, c2] = o2.size;
  return t2[0] = Math.round(c2 * s2 + u * r), t2[1] = Math.round(c2 * r + u * s2), t2;
}
function a2(t2, n2, o2, a3) {
  const [r, s2] = n2, [u, c2] = a3, h2 = 0.5 * o2;
  return t2[0] = r - h2 * u, t2[1] = s2 - h2 * c2, t2[2] = r + h2 * u, t2[3] = s2 + h2 * c2, t2;
}

// node_modules/@arcgis/core/views/2d/layers/support/ExportStrategy.js
var y = i();
var x = [0, 0];
var S = new e(0, 0, 0, 0);
var w2 = { imageMaxWidth: 2048, imageMaxHeight: 2048, imageRotationSupported: false, imageNormalizationSupported: false, hidpi: false };
var M = class extends b {
  constructor(t2) {
    super(t2), this._imagePromise = null, this.bitmaps = [], this.hidpi = w2.hidpi, this.imageMaxWidth = w2.imageMaxWidth, this.imageMaxHeight = w2.imageMaxHeight, this.imageRotationSupported = w2.imageRotationSupported, this.imageNormalizationSupported = w2.imageNormalizationSupported, this.update = L(async (t3, e2) => {
      if (s(e2), !t3.stationary || this.destroyed) return;
      const i2 = t3.state, s2 = G(i2.spatialReference), a3 = this.hidpi ? t3.pixelRatio : 1, p = i2.worldScreenWidth > 0, n2 = p && this.imageNormalizationSupported && i2.worldScreenWidth < i2.size[0], m2 = Math.round((this.imageMaxWidth ?? 0) / a3), h2 = Math.round((this.imageMaxHeight ?? 0) / a3);
      n2 ? (x[0] = i2.worldScreenWidth, x[1] = i2.size[1]) : this.imageRotationSupported ? (x[0] = i2.size[0], x[1] = i2.size[1]) : o(x, i2);
      const c2 = Math.floor(x[0]) > m2 || Math.floor(x[1]) > h2, u = s2 && (i2.extent.xmin < s2.valid[0] || i2.extent.xmax > s2.valid[1]), g = !this.imageNormalizationSupported && u, f2 = !c2 && !g, y2 = this.imageRotationSupported ? i2.rotation : 0, S2 = this.container.children.slice();
      if (f2) {
        const t4 = n2 ? i2.paddedViewState.center : i2.center;
        this._imagePromise = this._singleExport(i2, x, t4, i2.resolution, y2, a3, e2);
      } else {
        let t4 = Math.min(m2, h2);
        p && (t4 = Math.min(i2.worldScreenWidth, t4), t4 = Math.round(i2.worldScreenWidth / Math.ceil(i2.worldScreenWidth / t4))), this._imagePromise = this._tiledExport(i2, t4, a3, e2);
      }
      try {
        const t4 = await this._imagePromise ?? [];
        s(e2);
        const i3 = [];
        if (this._imagePromise = null, this.destroyed) return;
        this.bitmaps = t4;
        for (const e3 of S2) t4.includes(e3) || i3.push(e3.fadeOut().then(() => {
          e3.remove(), e3.destroy();
        }));
        for (const e3 of t4) i3.push(e3.fadeIn());
        await Promise.all(i3);
      } catch (w3) {
        this._imagePromise = null, f(w3);
      }
    }, 5e3), this.updateExports = L(async (t3) => {
      const e2 = [];
      for (const i2 of this.container.children) {
        if (!i2.visible || !i2.stage) return;
        e2.push(t3(i2).then(() => {
          i2.invalidateTexture(), i2.requestRender();
        }));
      }
      this._imagePromise = j(e2).then(() => this._imagePromise = null), await this._imagePromise;
    });
  }
  destroy() {
    this.bitmaps.forEach((t2) => t2.destroy()), this.bitmaps = [];
  }
  get updating() {
    return !this.destroyed && null !== this._imagePromise;
  }
  async _export(t2, e2, i2, r, s2, a3) {
    const p = await this.fetchSource(t2, Math.floor(e2 * s2), Math.floor(i2 * s2), { rotation: r, pixelRatio: s2, signal: a3 });
    s(a3);
    const n2 = new w(null, true);
    return n2.x = t2.xmin, n2.y = t2.ymax, n2.resolution = t2.width / e2, n2.rotation = r, n2.pixelRatio = s2, n2.opacity = 0, this.container.addChild(n2), await n2.setSourceAsync(p, a3), s(a3), n2;
  }
  async _singleExport(t2, e2, i2, o2, r, s2, a3) {
    a2(y, i2, o2, e2);
    const p = c(y, t2.spatialReference);
    return [await this._export(p, e2[0], e2[1], r, s2, a3)];
  }
  _tiledExport(t2, e2, i2, o2) {
    const r = z.create({ size: e2, spatialReference: t2.spatialReference, scales: [t2.scale] }), s2 = new h(r), a3 = s2.getTileCoverage(t2);
    if (!a3) return null;
    const p = [];
    return a3.forEach((r2, a4, m2, d) => {
      S.set(r2, a4, m2, 0), s2.getTileBounds(y, S);
      const h2 = c(y, t2.spatialReference);
      p.push(this._export(h2, e2, e2, 0, i2, o2).then((t3) => (0 !== d && (S.set(r2, a4, m2, d), s2.getTileBounds(y, S), t3.x = y[0], t3.y = y[3]), t3)));
    }), Promise.all(p);
  }
};
__decorate([m()], M.prototype, "_imagePromise", void 0), __decorate([m()], M.prototype, "bitmaps", void 0), __decorate([m()], M.prototype, "container", void 0), __decorate([m()], M.prototype, "fetchSource", void 0), __decorate([m()], M.prototype, "hidpi", void 0), __decorate([m()], M.prototype, "imageMaxWidth", void 0), __decorate([m()], M.prototype, "imageMaxHeight", void 0), __decorate([m()], M.prototype, "imageRotationSupported", void 0), __decorate([m()], M.prototype, "imageNormalizationSupported", void 0), __decorate([m()], M.prototype, "requestUpdate", void 0), __decorate([m()], M.prototype, "updating", null), M = __decorate([a("esri.views.2d.layers.support.ExportStrategy")], M);

export {
  M
};
//# sourceMappingURL=chunk-FNGWHAZ7.js.map
