import {
  n as n7
} from "./chunk-GEGX35PE.js";
import {
  e
} from "./chunk-6Z5KSPPF.js";
import {
  F
} from "./chunk-LRXVZGY2.js";
import {
  l as l5
} from "./chunk-6NEMIXIJ.js";
import {
  j
} from "./chunk-U3X2LY5C.js";
import {
  n2 as n5,
  n3 as n6,
  t
} from "./chunk-LRCBJR5A.js";
import {
  l as l2
} from "./chunk-RO646JIV.js";
import {
  l as l4
} from "./chunk-XXBJY7RN.js";
import {
  a as a4
} from "./chunk-L4A2QJG4.js";
import {
  n as n2
} from "./chunk-QF7FRVN6.js";
import {
  n
} from "./chunk-MA3QDRC3.js";
import {
  n as n4,
  r as r3
} from "./chunk-W6J7XCPU.js";
import {
  f as f2,
  l as l3
} from "./chunk-T7F6Q6JJ.js";
import {
  O
} from "./chunk-YDTPM7OQ.js";
import {
  u as u2
} from "./chunk-XCKT47LJ.js";
import {
  f
} from "./chunk-2OFHDVO5.js";
import {
  l
} from "./chunk-TFJXG32O.js";
import {
  u as u3
} from "./chunk-CCQFL76O.js";
import {
  r as r2
} from "./chunk-7H3U4IJR.js";
import {
  H2 as H,
  i2,
  p
} from "./chunk-V2H77UEV.js";
import {
  s as s3
} from "./chunk-WRA2WBYC.js";
import {
  o as o2
} from "./chunk-XWE6BM2U.js";
import {
  r
} from "./chunk-SOIZOFSB.js";
import {
  a as a3,
  n as n3
} from "./chunk-XXLHAM2M.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2,
  w,
  x
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  d,
  s as s2,
  u2 as u
} from "./chunk-GNMPGHLQ.js";
import {
  a,
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  o
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/ground/NavigationConstraint.js
var p2;
var c = p2 = class extends n3 {
  constructor(o3) {
    super(o3), this.type = "none";
  }
  clone() {
    return new p2({ type: this.type });
  }
};
__decorate([r2({ none: "none", stayAbove: "stay-above" }), m({ json: { write: { isRequired: true } } })], c.prototype, "type", void 0), c = p2 = __decorate([a2("esri.ground.NavigationConstraint")], c);

// node_modules/@arcgis/core/Ground.js
var S;
var I;
var _a;
var b = I = (_a = class extends a3(u2) {
  constructor(r4) {
    super(r4), this[S] = true, this.parent = null, this.opacity = 1, this.surfaceColor = null, this.navigationConstraint = null, this.layers = new O();
    const e2 = (r5) => {
      const { parent: e3 } = r5;
      e3 && e3 !== this && "remove" in e3 && e3.remove?.(r5), r5.parent = this, "elevation" !== r5.type && "base-elevation" !== r5.type && i.getLogger(this).error(`Layer '${r5.title}, id:${r5.id}' of type '${r5.type}' is not supported as a ground layer and will therefore be ignored. Only layers of type 'elevation' are supported.`);
    }, s4 = (r5) => {
      r5.parent = null;
    };
    this.addHandles([this.layers.on("after-add", (r5) => e2(r5.item)), this.layers.on("after-remove", (r5) => s4(r5.item))]), this.allLayers = new l4({ getCollections: () => [this.layers, this.parent?.basemap?.groundLayers] });
  }
  removeChildLayer(r4) {
    this.layers.remove(r4);
  }
  initialize() {
    this.when().catch((r4) => {
      d(r4) || i.getLogger(this).error("#load()", "Failed to load ground", r4);
    }), this.resourceInfo && this.read(this.resourceInfo.data, this.resourceInfo.context);
  }
  get integratedMeshGround() {
    const r4 = this.parent?.basemap?.groundLayers.at(0);
    return r4?.replacesTerrain ? r4 : null;
  }
  destroy() {
    const r4 = this.layers.removeAll();
    for (const e2 of r4) u(e2);
    this.layers.destroy();
  }
  normalizeCtorArgs(r4) {
    return r4 && "resourceInfo" in r4 && (this._set("resourceInfo", r4.resourceInfo), delete (r4 = { ...r4 }).resourceInfo), r4;
  }
  get loaded() {
    return super.loaded;
  }
  get layers() {
    return this._get("layers");
  }
  set layers(r4) {
    this._set("layers", n(r4, this._get("layers")));
  }
  writeLayers(r4, e2, o3, t3) {
    const s4 = [];
    r4 ? (t3 = { ...t3, layerContainerType: "ground" }, r4.forEach((r5) => {
      if ("write" in r5) {
        const e3 = {};
        o(r5)().write(e3, t3) && s4.push(e3);
      } else t3?.messages && t3.messages.push(new s("layer:unsupported", `Layers (${r5.title}, ${r5.id}) of type '${r5.declaredClass}' cannot be persisted in the ground`, { layer: r5 }));
    }), e2.layers = s4) : e2.layers = s4;
  }
  load(r4) {
    return this.addResolvingPromise(this._loadFromSource(r4)), Promise.resolve(this);
  }
  loadAll() {
    return l2(this, (r4) => {
      r4(this.layers);
    });
  }
  async queryElevation(r4, e2) {
    await this.load({ signal: e2?.signal });
    const { queryAll: o3 } = await import("./ElevationQuery-IMK5N772.js");
    s2(e2);
    return o3(this.layers.filter(A).toArray(), r4, e2);
  }
  async createElevationSampler(r4, e2) {
    await this.load({ signal: e2?.signal });
    const { createSampler: o3 } = await import("./ElevationQuery-IMK5N772.js");
    s2(e2);
    return o3(this.layers.filter(A).toArray(), r4, e2);
  }
  clone() {
    const r4 = { opacity: this.opacity, surfaceColor: a(this.surfaceColor), navigationConstraint: a(this.navigationConstraint), layers: this.layers.slice() };
    return this.loaded && (r4.loadStatus = "loaded"), new I({ resourceInfo: this.resourceInfo }).set(r4);
  }
  read(r4, e2) {
    this.resourceInfo || this._set("resourceInfo", { data: r4, context: e2 }), super.read(r4, e2);
  }
  _loadFromSource(r4) {
    const e2 = this.resourceInfo;
    return e2 ? this._loadLayersFromJSON(e2.data, e2.context, r4) : Promise.resolve();
  }
  async _loadLayersFromJSON(r4, e2, o3) {
    const t3 = e2?.origin || "web-scene", s4 = e2?.portal || null, a6 = e2?.url || null, { populateOperationalLayers: i5 } = await import("./layersCreator-5GUIYQS3.js");
    s2(o3);
    const n8 = [];
    if (r4.layers && Array.isArray(r4.layers)) {
      const e3 = { context: { origin: t3, url: a6, portal: s4, layerContainerType: "ground" }, defaultLayerType: "ArcGISTiledElevationServiceLayer" };
      n8.push(i5(this.layers, r4.layers, e3));
    }
    await Promise.allSettled(n8);
  }
}, S = n7, _a);
function A(r4) {
  return r4 && "createElevationSampler" in r4;
}
__decorate([m()], b.prototype, "parent", void 0), __decorate([m()], b.prototype, "integratedMeshGround", null), __decorate([m({ json: { read: false, write: { isRequired: true } } })], b.prototype, "layers", null), __decorate([m()], b.prototype, "allLayers", void 0), __decorate([r("layers")], b.prototype, "writeLayers", null), __decorate([m({ readOnly: true })], b.prototype, "resourceInfo", void 0), __decorate([m({ type: Number, nonNullable: true, range: { min: 0, max: 1 }, json: { type: x, read: { reader: r3, source: "transparency" }, write: { writer: (r4, e2) => {
  e2.transparency = n4(r4);
}, target: "transparency" } } })], b.prototype, "opacity", void 0), __decorate([m({ type: u3, json: { type: [x], write: (r4, e2) => {
  e2.surfaceColor = r4.toJSON().slice(0, 3);
} } })], b.prototype, "surfaceColor", void 0), __decorate([m({ type: c, json: { write: true } })], b.prototype, "navigationConstraint", void 0), b = I = __decorate([a2("esri.Ground")], b);
var _ = b;

// node_modules/@arcgis/core/effects/FocusAreaOutline.js
var m2 = class extends l3(n3) {
  constructor(o3) {
    super(o3), this.color = null;
  }
};
__decorate([m({ type: u3, json: { type: [x], write: true } })], m2.prototype, "color", void 0), m2 = __decorate([a2("esri.effects.FocusAreaOutline")], m2);
var i3 = m2;

// node_modules/@arcgis/core/effects/FocusArea.js
var d2 = class extends a3(f2) {
  constructor(e2) {
    super(e2), this.id = `focusarea-${n2()}`, this.title = null, this.enabled = true, this.outline = null, this.geometries = new l5();
  }
  readGeometries(e2, o3, r4) {
    Array.isArray(e2) ? this.geometries = l5.fromJSON(e2, r4) : "web-scene" !== r4.origin && "portal-item" !== r4.origin || r4.hooks?.onAfterLoad?.(() => this._loadGeometries(p(e2, r4), r4));
  }
  async _loadGeometries(e2, r4) {
    const t3 = await H(e2, { responseType: "json" });
    this.geometries = l5.fromJSON(t3.data, r4);
  }
};
__decorate([m({ type: String, nonNullable: true, json: { write: true, origins: { "web-scene": { write: { isRequired: true } } } } }), m()], d2.prototype, "id", void 0), __decorate([m({ type: String, json: { write: true } })], d2.prototype, "title", void 0), __decorate([m({ type: Boolean, nonNullable: true, json: { write: true, origins: { "web-scene": { write: { isRequired: true } } } } })], d2.prototype, "enabled", void 0), __decorate([m({ type: i3, json: { write: true } })], d2.prototype, "outline", void 0), __decorate([m({ type: l5, nonNullable: true, json: { write: true, origins: { "web-scene": { write: { isRequired: true } } } }, clonable: (e2) => new l5(e2.items.map((e3) => e3.clone())) }), j({ origins: ["web-scene", "portal-item"], type: "resource", prefix: "geometries", contentAddressed: true })], d2.prototype, "geometries", void 0), __decorate([o2(["web-scene", "portal-item", "service"], "geometries")], d2.prototype, "readGeometries", null), d2 = __decorate([a2("esri.effects.FocusArea")], d2);
var u4 = d2;

// node_modules/@arcgis/core/effects/FocusAreas.js
var c2 = class extends a3(f2) {
  constructor(o3) {
    super(o3), this.areas = new O(), this.style = "bright";
  }
};
__decorate([m({ type: O.ofType(u4), nonNullable: true, json: { write: true, origins: { "web-scene": { write: { isRequired: true } } } }, clonable: (o3) => new O(o3.items.map((o4) => o4.clone())) })], c2.prototype, "areas", void 0), __decorate([m({ type: ["bright", "dark"], nonNullable: true, json: { write: true } })], c2.prototype, "style", void 0), c2 = __decorate([a2("esri.effects.FocusAreas")], c2);
var a5 = c2;

// node_modules/@arcgis/core/support/basemapEnsureType.js
var c3 = () => i.getLogger("esri.support.basemapUtils");
function f3() {
  return {};
}
function l6(e2) {
  for (const r4 in e2) {
    const s4 = e2[r4];
    s4 && !s4.destroyed && s4.destroy(), delete e2[r4];
  }
}
function p3(r4, s4) {
  let i5;
  if ("string" == typeof r4) {
    const o3 = r4 in a4, a6 = !o3 && r4.includes("/");
    if (!o3 && !a6) {
      if (i2()) c3().warn(`Unable to find basemap definition for: ${r4}. See available styles at https://developers.arcgis.com/rest/basemap-styles/`);
      else {
        const e2 = Object.entries(a4).filter(([e3, r5]) => r5.classic || r5.is3d).map(([e3]) => `"${e3}"`).sort().join(", ");
        c3().warn(`Unable to find basemap definition for: ${r4}. Try one of these: ${e2}`);
      }
      return null;
    }
    s4 && (i5 = s4[r4]), i5 || (i5 = o3 ? F.fromId(r4) : new F({ style: { id: r4 } }), s4 && (s4[r4] = i5));
  } else i5 = w(F, r4);
  return i5?.destroyed && (c3().warn("The provided basemap is already destroyed", { basemap: i5 }), i5 = null), i5;
}

// node_modules/@arcgis/core/support/groundUtils.js
var i4 = { "world-elevation": { id: "worldElevation", url: "//elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer", layerType: "ArcGISTiledElevationServiceLayer" }, "world-topobathymetry": { id: "worldTopoBathymetry", url: "//elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/TopoBathy3D/ImageServer", layerType: "ArcGISTiledElevationServiceLayer" } };
function t2(t3) {
  let a6 = null;
  if ("string" == typeof t3) if (t3 in i4) {
    const r4 = i4[t3];
    a6 = new _({ resourceInfo: { data: { layers: [r4] } } });
  } else i.getLogger("esri.support.groundUtils").warn(`Unable to find ground definition for: ${t3}. Try "world-elevation"`);
  else a6 = w(_, t3);
  return a6;
}

// node_modules/@arcgis/core/Map.js
var g = class extends n6(n5(l)) {
  constructor(e2) {
    super(e2), this.allLayers = new l4({ getCollections: () => [this.basemap?.baseLayers, this.basemap?.groundLayers, this.ground?.layers, this.layers, this.basemap?.referenceLayers], getChildrenFunction: (e3) => "layers" in e3 ? e3.layers : null }), this.focusAreas = new a5(), this.allTables = t(this), this.basemap = null, this.editableLayers = new l4({ getCollections: () => [this.allLayers], itemFilterFunction: e }), this.ground = new _(), this._basemapCache = f3(), this.addHandles(f(() => this.ground, (e3, s4) => {
      s4?.parent === this && (s4.parent = null), e3.parent = this;
    }, { sync: true }));
  }
  destroy() {
    l6(this._basemapCache), this._basemapCache = null, this.focusAreas.destroy(), this.allLayers.destroy(), this.allTables.destroy(), this.editableLayers.destroy(), this.basemap = u(this.basemap), u(this.ground), this._set("ground", null);
  }
  castBasemap(e2) {
    return p3(e2, this._basemapCache);
  }
  castGround(e2) {
    const s4 = t2(e2);
    return s4 ?? this._get("ground");
  }
  findLayerById(e2) {
    return this.allLayers.find((s4) => s4.id === e2);
  }
  findTableById(e2) {
    return this.allTables.find((s4) => s4.id === e2);
  }
};
__decorate([m({ readOnly: true, dependsOn: [] })], g.prototype, "allLayers", void 0), __decorate([m({ type: a5, nonNullable: true, json: { write: { overridePolicy: (e2) => ({ enabled: e2.areas.length > 0, ignoreOrigin: true }) } } })], g.prototype, "focusAreas", void 0), __decorate([m({ readOnly: true })], g.prototype, "allTables", void 0), __decorate([m({ type: F, json: { read: { source: "baseMap" }, write: { target: "baseMap" } } })], g.prototype, "basemap", void 0), __decorate([s3("basemap")], g.prototype, "castBasemap", null), __decorate([m({ readOnly: true })], g.prototype, "editableLayers", void 0), __decorate([m({ type: _, nonNullable: true })], g.prototype, "ground", void 0), __decorate([s3("ground")], g.prototype, "castGround", null), __decorate([m()], g.prototype, "undoRedo", void 0), g = __decorate([a2("esri.Map")], g);
var L = g;

export {
  L
};
//# sourceMappingURL=chunk-BODQJTP6.js.map
