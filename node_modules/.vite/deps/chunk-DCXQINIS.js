import {
  t as t6,
  t2 as t7,
  u as u2
} from "./chunk-2I7JAYEU.js";
import {
  i as i2,
  n2 as n4,
  r as r3
} from "./chunk-43423NKQ.js";
import {
  n as n3,
  t as t5
} from "./chunk-TJ7BXOCK.js";
import {
  m
} from "./chunk-NNZE65VM.js";
import {
  h as h2
} from "./chunk-7LPDSYJP.js";
import {
  r as r2
} from "./chunk-QTS3W27E.js";
import {
  o as o2
} from "./chunk-3RABUJDL.js";
import {
  J,
  T as T2,
  i
} from "./chunk-FDSAQJ3R.js";
import {
  t as t4
} from "./chunk-CFXCM2NO.js";
import {
  t2
} from "./chunk-JPZOLUPV.js";
import {
  t
} from "./chunk-4X4BOGIG.js";
import {
  n as n2
} from "./chunk-LQPKVYW2.js";
import {
  A as A2,
  a,
  h,
  t as t3,
  u
} from "./chunk-U55FA2EK.js";
import {
  A,
  B,
  D,
  E,
  I,
  N,
  O,
  R,
  _
} from "./chunk-QNVJVDYZ.js";
import {
  n
} from "./chunk-45CFSCQX.js";
import {
  T,
  r2 as r
} from "./chunk-GNMPGHLQ.js";
import {
  o
} from "./chunk-QY7XKUIV.js";
import {
  has
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/MaterialPrograms.js
var t8 = (e6) => {
  let r5 = "";
  r5 += e6[0].toUpperCase();
  for (let t11 = 1; t11 < e6.length; t11++) {
    const o5 = e6[t11];
    o5 === o5.toUpperCase() ? (r5 += "_", r5 += o5) : r5 += o5.toUpperCase();
  }
  return r5;
};
var o3 = (e6) => {
  const o5 = {};
  for (const r5 in e6) {
    o5[t8(r5)] = e6[r5];
  }
  return n3(o5);
};
function s(r5, t11, s2) {
  const n6 = r5 + r5.slice(Math.max(0, r5.lastIndexOf("/"))), a3 = t11 + t11.slice(Math.max(0, t11.lastIndexOf("/"))), l2 = o3(s2);
  return { vertexShader: l2 + n4(`${n6}.vert`), fragmentShader: l2 + n4(`${a3}.frag`) };
}

// node_modules/@arcgis/core/views/2d/engine/webgl/VertexStream.js
var a2 = class {
  constructor(e6, a3) {
    this._rctx = e6, this._attributes = [{ name: "position", offset: 0, type: R.SHORT, count: 2 }], this.layout = { hash: t2(this._attributes), attributes: this._attributes, stride: 4 }, this._vertexBuffer = new r2(e6, [new t("a_position", 2, R.SHORT, 0, 4)], new Uint16Array(a3)), this._vao = new h2(e6, this._vertexBuffer), this._count = a3.length / 2;
  }
  get locations() {
    return this._vao.locations;
  }
  bind() {
    this._rctx.bindVAO(this._vao);
  }
  unbind() {
    this._rctx.bindVAO(null);
  }
  dispose() {
    this._vao.dispose();
  }
  draw() {
    this._rctx.bindVAO(this._vao), this._rctx.drawArrays(_.TRIANGLE_STRIP, 0, this._count);
  }
};

// node_modules/@arcgis/core/views/webgl/ContextState.js
var e = class {
  constructor() {
    this.blend = false, this.blendColor = { r: 0, g: 0, b: 0, a: 0 }, this.blendFunction = { srcRGB: 1, dstRGB: 0, srcAlpha: 1, dstAlpha: 0 }, this.blendEquation = { mode: 32774, modeAlpha: 32774 }, this.colorMask = { r: true, g: true, b: true, a: true }, this.faceCulling = false, this.cullFace = 1029, this.frontFace = 2305, this.scissorTest = false, this.scissorRect = { x: 0, y: 0, width: 0, height: 0 }, this.depthTest = false, this.depthFunction = 513, this.clearDepth = 1, this.depthWrite = true, this.depthRange = { zNear: 0, zFar: 1 }, this.viewport = null, this.stencilTest = false, this.polygonOffsetFill = false, this.polygonOffset = [0, 0], this.stencilFunction = { face: 1032, func: 519, ref: 0, mask: 1 }, this.clearStencil = 0, this.stencilWriteMask = 1, this.stencilOperation = { face: 1032, fail: 7680, zFail: 7680, zPass: 7680 }, this.clearColor = { r: 0, g: 0, b: 0, a: 0 }, this.program = null, this.vertexBuffer = null, this.indexBuffer = null, this.uniformBuffer = null, this.pixelPackBuffer = null, this.pixelUnpackBuffer = null, this.copyReadBuffer = null, this.copyWriteBuffer = null, this.transformFeedbackBuffer = null, this.uniformBufferBindingPoints = new Array(), this.transformBufferBindingPoints = new Array(), this.readFramebuffer = null, this.drawFramebuffer = null, this.drawBuffers = { defaultFramebuffer: [B], fbos: /* @__PURE__ */ new WeakMap() }, this.renderbuffer = null, this.activeTexture = 0, this.textureUnitMap = new Array(), this.vertexArrayObject = null;
  }
};

// node_modules/@arcgis/core/views/webgl/AllocationTracer.js
var e2 = class {
  constructor(e6) {
    this._objectType = e6, this._active = /* @__PURE__ */ new Map();
  }
  get _stack() {
    const e6 = new Error().stack.split("\n");
    return e6.shift(), e6.shift(), e6.shift(), e6.join("\n");
  }
  add(e6) {
    this._active.set(e6, new t9(this._stack));
  }
  remove(e6) {
    this._active.delete(e6);
  }
  addReference(e6) {
    const t11 = this._active.get(e6);
    t11 && t11.retains.push(this._stack);
  }
  removeReference(e6) {
    const t11 = this._active.get(e6);
    t11 && t11.releases.push(this._stack);
  }
  resetLog() {
    const e6 = /* @__PURE__ */ new Map();
    let t11 = "";
    this._active.forEach((s3, { usedMemory: r6 }) => {
      e6.has(s3.from) || (e6.set(s3.from, /* @__PURE__ */ new Map()), s3.retains.length > 0 && (t11 += `  First reference count mismatch:
  Retain:
    ${s3.retains.join("\n\n    ")}

  Release:    ${s3.releases.join("\n\n    ")}
`));
      const n6 = e6.get(s3.from);
      n6.set(r6 ?? 0, n6.get(r6 ?? 0) ?? 1);
    }), this._active.clear();
    let s2 = 0;
    const r5 = new Array();
    return e6.forEach((e7, t12) => {
      let n6 = 0;
      e7.forEach((e8, t13) => n6 += e8 * t13), e7.set(-1, n6), s2 += n6, r5.push([t12, e7]);
    }), e6.clear(), r5.sort((e7, t12) => t12[1].get(-1) - e7[1].get(-1)), r5.reduce((e7, [t12, s3]) => {
      const r6 = Math.round(s3.get(-1) / 1024);
      s3.delete(-1);
      return e7 += `  ${r6}KB from ${Array.from(s3.values()).reduce((e8, t13) => e8 + t13, 0)} allocations at ${t12}
`;
    }, `Total ${this._objectType} memory: ${Math.round(s2 / 1024)}KB
${t11}`);
  }
};
var t9 = class {
  constructor(e6) {
    this.from = e6, this.retains = new Array(), this.releases = new Array();
  }
};

// node_modules/@arcgis/core/views/webgl/InstanceCounter.js
var o4 = { RECORD_ALLOCATIONS: false };
var n5 = class {
  constructor() {
    for (this._current = new Array(), this._allocations = o4.RECORD_ALLOCATIONS ? new e2("WebGLObject") : null; this._current.length < O.COUNT; ) this._current.push(0);
  }
  increment(t11, r5, e6 = 1) {
    this._current[t11] += e6, this._allocations?.add(r5);
  }
  decrement(t11, r5, e6 = 1) {
    this._current[t11] -= e6, this._allocations?.remove(r5);
  }
  get current() {
    return this._current;
  }
  get total() {
    return this.current.reduce((t11, r5, o5) => t11 + (o5 < O.UNCOUNTED ? r5 : 0), 0);
  }
  get resourceInformation() {
    let r5 = "";
    if (this.total > 0) {
      r5 += "Live objects:\n";
      for (let o5 = 0; o5 < O.COUNT; ++o5) {
        const n6 = this._current[o5];
        n6 > 0 && (r5 += `${o(O, o5)}: ${n6}
`);
      }
    }
    return r5 += this._allocations?.resetLog(), r5;
  }
};

// node_modules/@arcgis/core/views/webgl/Parameters.js
var e3 = class {
  constructor(e6, t11, r5) {
    const a3 = t11.textureFilterAnisotropic;
    this.versionString = e6.getParameter(e6.VERSION), this.maxVertexTextureImageUnits = e6.getParameter(e6.MAX_VERTEX_TEXTURE_IMAGE_UNITS), this.maxVertexAttributes = e6.getParameter(e6.MAX_VERTEX_ATTRIBS);
    const m3 = r5.maxAnisotropy;
    this.maxMaxAnisotropy = a3 ? Math.min(e6.getParameter(a3.MAX_TEXTURE_MAX_ANISOTROPY), m3) : 1, this.maxTextureImageUnits = e6.getParameter(e6.MAX_TEXTURE_IMAGE_UNITS), this.maxTextureSize = e6.getParameter(e6.MAX_TEXTURE_SIZE), this.maxPreferredTexturePixels = r5.maxPreferredTexturePixels, this.maxRenderbufferSize = e6.getParameter(e6.MAX_RENDERBUFFER_SIZE), this.maxViewportDims = e6.getParameter(e6.MAX_VIEWPORT_DIMS), this.maxUniformBufferBindings = e6.getParameter(e6.MAX_UNIFORM_BUFFER_BINDINGS), this.maxVertexUniformBlocks = e6.getParameter(e6.MAX_VERTEX_UNIFORM_BLOCKS), this.maxFragmentUniformBlocks = e6.getParameter(e6.MAX_FRAGMENT_UNIFORM_BLOCKS), this.maxUniformBlockSize = e6.getParameter(e6.MAX_UNIFORM_BLOCK_SIZE), this.uniformBufferOffsetAlignment = e6.getParameter(e6.UNIFORM_BUFFER_OFFSET_ALIGNMENT), this.maxArrayTextureLayers = e6.getParameter(e6.MAX_ARRAY_TEXTURE_LAYERS), this.maxSamples = e6.getParameter(e6.MAX_SAMPLES), this.maxDrawBuffers = e6.getParameter(e6.MAX_DRAW_BUFFERS);
  }
};

// node_modules/@arcgis/core/views/webgl/AppleAmdDriverHelper.js
var i3 = class _i {
  constructor(r5) {
    this._rctx = r5, this._indexBuffer = this._createIndexbuffer(), this._program = this._createHelperProgram();
  }
  static getShaderSources() {
    return { vertex: "#version 300 es\n    precision highp float;\n\n    void main(void) {\n      gl_Position = vec4(0.0, 0.0, float(gl_VertexID)-2.0, 1.0);\n    }", fragment: "#version 300 es\n    precision highp float;\n\n    out vec4 fragColor;\n\n    void main(void) {\n      fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }" };
  }
  _createHelperProgram() {
    const r5 = _i.getShaderSources();
    return this._rctx.programCache.acquire(r5.vertex, r5.fragment, /* @__PURE__ */ new Map([]));
  }
  _createIndexbuffer() {
    return o2.createIndex(this._rctx, 35044, new Uint32Array([0]));
  }
  run() {
    this._program.compiled && this._indexBuffer && (this._rctx.bindVAO(null), this._rctx.useProgram(this._program), this._rctx.bindBuffer(this._indexBuffer, 34963), this._rctx.drawElements(_.POINTS, 1, R.UNSIGNED_INT, 0));
  }
  dispose() {
    this._program.dispose(), this._indexBuffer.dispose();
  }
  get test() {
  }
};

// node_modules/@arcgis/core/views/webgl/testAppleAmdDrawArrays.js
var l = class extends t7 {
  constructor(e6) {
    super(), this._rctx = e6, this._helperProgram = null, has("mac") && has("chrome") && (this._program = this._prepareProgram(), this._helperProgram = this._prepareHelperProgram());
  }
  dispose() {
    super.dispose(), this._helperProgram?.dispose(), this._helperProgram = null;
  }
  _test(e6) {
    const r5 = this._rctx, p = r5.getBoundFramebufferObject(), { x: l2, y: c, width: m3, height: g } = r5.getViewport();
    r5.resetState();
    const f = new h(1);
    f.wrapMode = 33071, f.samplingMode = 9728;
    const d = new m(r5, f), h3 = o2.createIndex(this._rctx, 35044, new Uint8Array([0]));
    r5.bindFramebuffer(d), r5.setViewport(0, 0, 1, 1), r5.useProgram(this._helperProgram), r5.bindBuffer(h3, 34963), r5.drawElements(_.POINTS, 1, R.UNSIGNED_BYTE, 0), r5.useProgram(e6), r5.bindVAO(null), r5.drawArrays(_.TRIANGLES, 0, 258);
    const u3 = new Uint8Array(4);
    return d.readPixels(0, 0, 1, 1, 6408, N.UNSIGNED_BYTE, u3), r5.setViewport(l2, c, m3, g), r5.bindFramebuffer(p), d.dispose(), h3.dispose(), 255 === u3[0];
  }
  _prepareProgram() {
    const r5 = 85, t11 = `#version 300 es
    precision highp float;

    out float triangleId;

    const vec3 triangleVertices[3] = vec3[3](vec3(-0.5, -0.5, 0.0), vec3(0.5, -0.5, 0.0), vec3(0.0, 0.5, 0.0));

    void main(void) {
      triangleId = floor(float(gl_VertexID)/3.0);

      vec3 position = triangleVertices[gl_VertexID % 3];
      float offset = triangleId / ${t4.float(r5)};
      position.z = 0.5 - offset;

      gl_Position = vec4(position, 1.0);
    }
    `, o5 = `#version 300 es
    precision highp float;

    in float triangleId;

    out vec4 fragColor;

    void main(void) {
      fragColor = triangleId == ${t4.float(r5)} ? vec4(0.0, 1.0, 0.0, 1.0) : vec4(1.0, 0.0, 0.0, 1.0);
    }
    `;
    return this._rctx.programCache.acquire(t11, o5, /* @__PURE__ */ new Map([]));
  }
  _prepareHelperProgram() {
    const e6 = i3.getShaderSources();
    return this._rctx.programCache.acquire(e6.vertex, e6.fragment, /* @__PURE__ */ new Map([]));
  }
};

// node_modules/@arcgis/core/views/webgl/testFloatBufferBlend.js
var m2 = class extends t7 {
  constructor(r5) {
    if (super(), this._rctx = r5, !r5.gl) return;
    if (!(r5.capabilities.colorBufferFloat?.textureFloat && r5.capabilities.colorBufferFloat?.floatBlend)) return;
    const e6 = "\n    precision highp float;\n    attribute vec2 position;\n\n    void main() {\n      gl_Position = vec4(position * 2.0 - 1.0, 0.0, 1.0);\n    }\n    ", t11 = "\n     precision highp float;\n\n     void main() {\n      gl_FragColor = vec4(0.5, 0.5, 0.5, 0.5);\n     }\n    ";
    this._program = r5.programCache.acquire(e6, t11, i2);
  }
  _test(p) {
    const l2 = this._rctx, m3 = new h(1);
    m3.wrapMode = 33071, m3.dataType = N.FLOAT, m3.internalFormat = E.RGBA32F, m3.samplingMode = 9728;
    const u3 = new m(l2, m3), b = new r2(l2, r3, new Uint16Array([0, 0, 1, 0, 0, 1, 1, 1])), d = new h2(l2, b);
    l2.gl.getError(), l2.useProgram(p);
    const g = l2.getBoundFramebufferObject(), { x: w, y: A3, width: j, height: x2 } = l2.getViewport();
    l2.bindFramebuffer(u3), l2.setViewport(0, 0, 1, 1), l2.bindVAO(d), l2.drawArrays(_.TRIANGLE_STRIP, 0, 4);
    const h3 = T2({ blending: i });
    l2.setPipelineState(h3), l2.drawArrays(_.TRIANGLE_STRIP, 0, 4);
    const F2 = l2.gl.getError();
    return l2.setViewport(w, A3, j, x2), l2.bindFramebuffer(g), d.dispose(), u3.dispose(), F2 !== l2.gl.INVALID_OPERATION || (console.warn("Device claims support for WebGL extension EXT_float_blend but does not support it. Using fall back."), false);
  }
};

// node_modules/@arcgis/core/views/webgl/WebGLDriverTest.js
var r4 = class {
  constructor(r5) {
    this.rctx = r5, this.floatBufferBlend = new m2(r5), this.svgPremultipliesAlpha = new u2(r5), this.drawArraysRequiresIndicesTypeReset = new l(r5);
  }
  dispose() {
    this.svgPremultipliesAlpha.dispose(), this.floatBufferBlend.dispose(), this.drawArraysRequiresIndicesTypeReset.dispose();
  }
};

// node_modules/@arcgis/core/views/webgl/capabilities/load.js
function _2(_4, E3) {
  if (E3.compressedTextureETC) return null;
  const R3 = _4.getExtension("WEBGL_compressed_texture_etc");
  return R3 ? { COMPRESSED_R11_EAC: R3.COMPRESSED_R11_EAC, COMPRESSED_SIGNED_R11_EAC: R3.COMPRESSED_SIGNED_R11_EAC, COMPRESSED_RG11_EAC: R3.COMPRESSED_RG11_EAC, COMPRESSED_SIGNED_RG11_EAC: R3.COMPRESSED_SIGNED_RG11_EAC, COMPRESSED_RGB8_ETC2: R3.COMPRESSED_RGB8_ETC2, COMPRESSED_SRGB8_ETC2: R3.COMPRESSED_SRGB8_ETC2, COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: R3.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: R3.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2, COMPRESSED_RGBA8_ETC2_EAC: R3.COMPRESSED_RGBA8_ETC2_EAC, COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: R3.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC } : null;
}
function E2(_4, E3) {
  if (E3.compressedTextureS3TC) return null;
  const R3 = _4.getExtension("WEBGL_compressed_texture_s3tc");
  return R3 ? { COMPRESSED_RGB_S3TC_DXT1: R3.COMPRESSED_RGB_S3TC_DXT1_EXT, COMPRESSED_RGBA_S3TC_DXT1: R3.COMPRESSED_RGBA_S3TC_DXT1_EXT, COMPRESSED_RGBA_S3TC_DXT3: R3.COMPRESSED_RGBA_S3TC_DXT3_EXT, COMPRESSED_RGBA_S3TC_DXT5: R3.COMPRESSED_RGBA_S3TC_DXT5_EXT } : null;
}
function R2(_4, E3) {
  if (E3.textureFilterAnisotropic) return null;
  const R3 = _4.getExtension("EXT_texture_filter_anisotropic") || _4.getExtension("MOZ_EXT_texture_filter_anisotropic") || _4.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
  return R3 ? { MAX_TEXTURE_MAX_ANISOTROPY: R3.MAX_TEXTURE_MAX_ANISOTROPY_EXT, TEXTURE_MAX_ANISOTROPY: R3.TEXTURE_MAX_ANISOTROPY_EXT } : null;
}
function t10(_4, E3) {
  const R3 = !E3.colorBufferHalfFloat && _4.getExtension("EXT_color_buffer_half_float") || !E3.colorBufferFloat && _4.getExtension("EXT_color_buffer_float"), t11 = !E3.colorBufferFloat && _4.getExtension("EXT_color_buffer_float"), S2 = !E3.floatBlend && !E3.colorBufferFloat && _4.getExtension("EXT_float_blend");
  return R3 || t11 || S2 ? { textureFloat: !!t11, textureHalfFloat: !!R3, floatBlend: !!S2, R16F: _4.R16F, RG16F: _4.RG16F, RGBA16F: _4.RGBA16F, R32F: _4.R32F, RG32F: _4.RG32F, RGBA32F: _4.RGBA32F, R11F_G11F_B10F: _4.R11F_G11F_B10F, RGB16F: _4.RGB16F } : null;
}
function S(_4, E3, R3, t11, S2) {
  if (t11) return true;
  if (E3[R3]) return false;
  for (const e6 of S2) if (_4.getExtension(e6)) return true;
  return false;
}
function e4(_4, E3) {
  if (E3.textureNorm16) return null;
  const R3 = _4.getExtension("EXT_texture_norm16");
  return R3 ? { R16: R3.R16_EXT, RG16: R3.RG16_EXT, RGB16: R3.RGB16_EXT, RGBA16: R3.RGBA16_EXT, R16_SNORM: R3.R16_SNORM_EXT, RG16_SNORM: R3.RG16_SNORM_EXT, RGB16_SNORM: R3.RGB16_SNORM_EXT, RGBA16_SNORM: R3.RGBA16_SNORM_EXT } : null;
}

// node_modules/@arcgis/core/views/webgl/capabilities/LoseContext.js
function e5(e6, t11) {
  const n6 = t11.loseContext && e6.getExtension("WEBGL_lose_context");
  return n6 ? { loseRenderingContext: () => n6.loseContext() } : null;
}

// node_modules/@arcgis/core/views/webgl/capabilities/Capabilities.js
var _3 = class {
  constructor(e6, t11) {
    this._gl = e6, this._compressedTextureETC = null, this._compressedTextureS3TC = null, this._textureFilterAnisotropic = null, this._colorBufferFloat = null, this._loseContext = null, this._textureNorm16 = null, this._textureFloatLinear = null, this._parallelShaderCompile = null, this._rendererInfo = null, this._disabledExtensions = t11.disabledExtensions, this._debugWebGLExtensions = t11.debugWebGLExtensions;
  }
  get compressedTextureETC() {
    return this._compressedTextureETC ??= _2(this._gl, this._disabledExtensions), this._compressedTextureETC;
  }
  get compressedTextureS3TC() {
    return this._compressedTextureS3TC ??= E2(this._gl, this._disabledExtensions), this._compressedTextureS3TC;
  }
  get textureFilterAnisotropic() {
    return this._textureFilterAnisotropic ??= R2(this._gl, this._disabledExtensions), this._textureFilterAnisotropic;
  }
  get disjointTimerQuery() {
    return this._disjointTimerQuery ??= t6(this._gl, this._disabledExtensions), this._disjointTimerQuery;
  }
  get colorBufferFloat() {
    return this._colorBufferFloat ??= t10(this._gl, this._disabledExtensions), this._colorBufferFloat;
  }
  get textureNorm16() {
    return this._textureNorm16 ??= e4(this._gl, this._disabledExtensions), this._textureNorm16;
  }
  get textureFloatLinear() {
    return this._textureFloatLinear ??= S(this._gl, this._disabledExtensions, "textureFloatLinear", false, ["OES_texture_float_linear"]), this._textureFloatLinear;
  }
  get parallelShaderCompile() {
    return this._parallelShaderCompile ??= S(this._gl, this._disabledExtensions, "parallelShaderCompile", false, ["KHR_parallel_shader_compile"]), this._parallelShaderCompile;
  }
  get loseContext() {
    return this._loseContext ??= e5(this._gl, this._debugWebGLExtensions), this._loseContext;
  }
  get rendererInfo() {
    return this._rendererInfo ??= n2(this._gl), this._rendererInfo;
  }
  enable(e6) {
    return this[e6];
  }
};

// node_modules/@arcgis/core/views/webgl/RenderingContext.js
var F = class {
  constructor(t11, e6) {
    this.gl = t11, this.instanceCounter = new n5(), this._programCache = new t5(this), this._transformFeedbackRequestInfo = null, this._state = new e(), this._numOfDrawCalls = 0, this._numOfTriangles = 0, this._options = e6, this.configure(e6);
  }
  configure(e6) {
    this._options = e6, this._capabilities = new _3(this.gl, e6), this._parameters = new e3(this.gl, this._capabilities, e6), A2.TEXTURE_UNIT_FOR_UPDATES = this._parameters.maxTextureImageUnits - 1;
    const s2 = this.gl.getParameter(this.gl.VIEWPORT);
    this._state = new e(), this._state.viewport = { x: s2[0], y: s2[1], width: s2[2], height: s2[3] }, this._stateTracker = new J({ setBlending: (t11) => {
      if (t11) {
        this.setBlendingEnabled(true), this.setBlendEquationSeparate(t11.opRgb, t11.opAlpha), this.setBlendFunctionSeparate(t11.srcRgb, t11.dstRgb, t11.srcAlpha, t11.dstAlpha);
        const e7 = t11.color;
        this.setBlendColor(e7.r, e7.g, e7.b, e7.a);
      } else this.setBlendingEnabled(false);
    }, setCulling: (t11) => {
      t11 ? (this.setFaceCullingEnabled(true), this.setCullFace(t11.face), this.setFrontFace(t11.mode)) : this.setFaceCullingEnabled(false);
    }, setPolygonOffset: (t11) => {
      t11 ? (this.setPolygonOffsetFillEnabled(true), this.setPolygonOffset(t11.factor, t11.units)) : this.setPolygonOffsetFillEnabled(false);
    }, setDepthTest: (t11) => {
      t11 ? (this.setDepthTestEnabled(true), this.setDepthFunction(t11.func)) : this.setDepthTestEnabled(false);
    }, setStencilTest: (t11) => {
      if (t11) {
        this.setStencilTestEnabled(true);
        const e7 = t11.function;
        this.setStencilFunction(e7.func, e7.ref, e7.mask);
        const s3 = t11.operation;
        this.setStencilOp(s3.fail, s3.zFail, s3.zPass);
      } else this.setStencilTestEnabled(false);
    }, setDepthWrite: (t11) => {
      t11 ? (this.setDepthWriteEnabled(true), this.setDepthRange(t11.zNear, t11.zFar)) : this.setDepthWriteEnabled(false);
    }, setColorWrite: (t11) => {
      t11 ? this.setColorMask(t11.r, t11.g, t11.b, t11.a) : this.setColorMask(false, false, false, false);
    }, setStencilWrite: (t11) => {
      t11 ? this.setStencilWriteMask(t11.mask) : this.setStencilWriteMask(0);
    }, setDrawBuffers: (t11) => {
      if (t11) this.setDrawBuffers(t11.buffers);
      else {
        const { drawFramebuffer: t12 } = this._state;
        null === t12 ? this.setDrawBuffers([B]) : 0 === t12.colorAttachments.length ? this.setDrawBuffers([A]) : this.setDrawBuffers([D]);
      }
    } }), this.enforceState(), r(this._driverTest), this._driverTest = new r4(this);
  }
  updateOptions(t11) {
    this._options = { ...this._options, ...t11 }, this._parameters = new e3(this.gl, this._capabilities, this._options);
  }
  dispose() {
    this._driverTest = r(this._driverTest), this._programCache = r(this._programCache), this.bindVAO(null), this.unbindBuffer(34962), this.unbindBuffer(34963), this.unbindBuffer(35345), this._state.uniformBufferBindingPoints.length = 0, this.unbindBuffer(35051), this.unbindBuffer(35052), this.unbindBuffer(36662), this.unbindBuffer(36663), this._state.textureUnitMap.length = 0, this._state = null, this._capabilities = null, this._stateTracker = null, a() && console.log(this.instanceCounter.resourceInformation);
  }
  get driverTest() {
    return this._driverTest;
  }
  get contextAttributes() {
    return this.gl.getContextAttributes();
  }
  get parameters() {
    return this._parameters;
  }
  get programCache() {
    return this._programCache;
  }
  setPipelineState(t11) {
    this._stateTracker.setPipeline(t11);
  }
  setBlendingEnabled(t11) {
    this._state.blend !== t11 && (true === t11 ? this.gl.enable(this.gl.BLEND) : this.gl.disable(this.gl.BLEND), this._state.blend = t11, this._stateTracker.invalidateBlending());
  }
  externalProgramUpdate() {
    this._state.program?.stop(), this._state.program = null;
  }
  externalTextureUnitUpdate(t11, e6) {
    for (let s2 = 0; s2 < t11.length; ++s2) this._state.textureUnitMap[t11[s2]] = null;
    e6 >= 0 && (this._state.activeTexture = e6);
  }
  externalVertexArrayObjectUpdate() {
    this.gl.bindVertexArray(null), this._state.vertexArrayObject = null, this._state.vertexBuffer = null, this._state.indexBuffer = null;
  }
  externalVertexBufferUpdate() {
    this._state.vertexBuffer = null;
  }
  externalIndexBufferUpdate() {
    this._state.indexBuffer = null;
  }
  setBlendColor(t11, e6, s2, i4) {
    t11 === this._state.blendColor.r && e6 === this._state.blendColor.g && s2 === this._state.blendColor.b && i4 === this._state.blendColor.a || (this.gl.blendColor(t11, e6, s2, i4), this._state.blendColor.r = t11, this._state.blendColor.g = e6, this._state.blendColor.b = s2, this._state.blendColor.a = i4, this._stateTracker.invalidateBlending());
  }
  setBlendFunction(t11, e6) {
    t11 === this._state.blendFunction.srcRGB && e6 === this._state.blendFunction.dstRGB || (this.gl.blendFunc(t11, e6), this._state.blendFunction.srcRGB = t11, this._state.blendFunction.srcAlpha = t11, this._state.blendFunction.dstRGB = e6, this._state.blendFunction.dstAlpha = e6, this._stateTracker.invalidateBlending());
  }
  setBlendFunctionSeparate(t11, e6, s2, i4) {
    this._state.blendFunction.srcRGB === t11 && this._state.blendFunction.srcAlpha === s2 && this._state.blendFunction.dstRGB === e6 && this._state.blendFunction.dstAlpha === i4 || (this.gl.blendFuncSeparate(t11, e6, s2, i4), this._state.blendFunction.srcRGB = t11, this._state.blendFunction.srcAlpha = s2, this._state.blendFunction.dstRGB = e6, this._state.blendFunction.dstAlpha = i4, this._stateTracker.invalidateBlending());
  }
  setBlendEquation(t11) {
    this._state.blendEquation.mode !== t11 && (this.gl.blendEquation(t11), this._state.blendEquation.mode = t11, this._state.blendEquation.modeAlpha = t11, this._stateTracker.invalidateBlending());
  }
  setBlendEquationSeparate(t11, e6) {
    this._state.blendEquation.mode === t11 && this._state.blendEquation.modeAlpha === e6 || (this.gl.blendEquationSeparate(t11, e6), this._state.blendEquation.mode = t11, this._state.blendEquation.modeAlpha = e6, this._stateTracker.invalidateBlending());
  }
  setColorMask(t11, e6, s2, i4) {
    this._state.colorMask.r === t11 && this._state.colorMask.g === e6 && this._state.colorMask.b === s2 && this._state.colorMask.a === i4 || (this.gl.colorMask(t11, e6, s2, i4), this._state.colorMask.r = t11, this._state.colorMask.g = e6, this._state.colorMask.b = s2, this._state.colorMask.a = i4, this._stateTracker.invalidateColorWrite());
  }
  setClearColor(t11, e6, s2, i4) {
    this._state.clearColor.r === t11 && this._state.clearColor.g === e6 && this._state.clearColor.b === s2 && this._state.clearColor.a === i4 || (this.gl.clearColor(t11, e6, s2, i4), this._state.clearColor.r = t11, this._state.clearColor.g = e6, this._state.clearColor.b = s2, this._state.clearColor.a = i4);
  }
  setFaceCullingEnabled(t11) {
    this._state.faceCulling !== t11 && (true === t11 ? this.gl.enable(this.gl.CULL_FACE) : this.gl.disable(this.gl.CULL_FACE), this._state.faceCulling = t11, this._stateTracker.invalidateCulling());
  }
  setPolygonOffsetFillEnabled(t11) {
    this._state.polygonOffsetFill !== t11 && (true === t11 ? this.gl.enable(this.gl.POLYGON_OFFSET_FILL) : this.gl.disable(this.gl.POLYGON_OFFSET_FILL), this._state.polygonOffsetFill = t11, this._stateTracker.invalidatePolygonOffset());
  }
  setPolygonOffset(t11, e6) {
    this._state.polygonOffset[0] === t11 && this._state.polygonOffset[1] === e6 || (this._state.polygonOffset[0] = t11, this._state.polygonOffset[1] = e6, this.gl.polygonOffset(t11, e6), this._stateTracker.invalidatePolygonOffset());
  }
  setCullFace(t11) {
    this._state.cullFace !== t11 && (this.gl.cullFace(t11), this._state.cullFace = t11, this._stateTracker.invalidateCulling());
  }
  setFrontFace(t11) {
    this._state.frontFace !== t11 && (this.gl.frontFace(t11), this._state.frontFace = t11, this._stateTracker.invalidateCulling());
  }
  setScissorTestEnabled(t11) {
    this._state.scissorTest !== t11 && (true === t11 ? this.gl.enable(this.gl.SCISSOR_TEST) : this.gl.disable(this.gl.SCISSOR_TEST), this._state.scissorTest = t11);
  }
  setScissorRect(t11, e6, s2, i4) {
    this._state.scissorRect.x === t11 && this._state.scissorRect.y === e6 && this._state.scissorRect.width === s2 && this._state.scissorRect.height === i4 || (this.gl.scissor(t11, e6, s2, i4), this._state.scissorRect.x = t11, this._state.scissorRect.y = e6, this._state.scissorRect.width = s2, this._state.scissorRect.height = i4);
  }
  setDepthTestEnabled(t11) {
    this._state.depthTest !== t11 && (true === t11 ? this.gl.enable(this.gl.DEPTH_TEST) : this.gl.disable(this.gl.DEPTH_TEST), this._state.depthTest = t11, this._stateTracker.invalidateDepthTest());
  }
  setClearDepth(t11) {
    this._state.clearDepth !== t11 && (this.gl.clearDepth(t11), this._state.clearDepth = t11);
  }
  setDepthFunction(t11) {
    this._state.depthFunction !== t11 && (this.gl.depthFunc(t11), this._state.depthFunction = t11, this._stateTracker.invalidateDepthTest());
  }
  setDepthWriteEnabled(t11) {
    this._state.depthWrite !== t11 && (this.gl.depthMask(t11), this._state.depthWrite = t11, this._stateTracker.invalidateDepthWrite());
  }
  setDepthRange(t11, e6) {
    this._state.depthRange.zNear === t11 && this._state.depthRange.zFar === e6 || (this.gl.depthRange(t11, e6), this._state.depthRange.zNear = t11, this._state.depthRange.zFar = e6, this._stateTracker.invalidateDepthWrite());
  }
  setStencilTestEnabled(t11) {
    this._state.stencilTest !== t11 && (true === t11 ? this.gl.enable(this.gl.STENCIL_TEST) : this.gl.disable(this.gl.STENCIL_TEST), this._state.stencilTest = t11, this._stateTracker.invalidateStencilTest());
  }
  setClearStencil(t11) {
    t11 !== this._state.clearStencil && (this.gl.clearStencil(t11), this._state.clearStencil = t11);
  }
  setStencilFunction(t11, e6, s2) {
    this._state.stencilFunction.func === t11 && this._state.stencilFunction.ref === e6 && this._state.stencilFunction.mask === s2 || (this.gl.stencilFunc(t11, e6, s2), this._state.stencilFunction.face = 1032, this._state.stencilFunction.func = t11, this._state.stencilFunction.ref = e6, this._state.stencilFunction.mask = s2, this._stateTracker.invalidateStencilTest());
  }
  setStencilFunctionSeparate(t11, e6, s2, i4) {
    this._state.stencilFunction.face === t11 && this._state.stencilFunction.func === e6 && this._state.stencilFunction.ref === s2 && this._state.stencilFunction.mask === i4 || (this.gl.stencilFuncSeparate(t11, e6, s2, i4), this._state.stencilFunction.face = t11, this._state.stencilFunction.func = e6, this._state.stencilFunction.ref = s2, this._state.stencilFunction.mask = i4, this._stateTracker.invalidateStencilTest());
  }
  setStencilWriteMask(t11) {
    this._state.stencilWriteMask !== t11 && (this.gl.stencilMask(t11), this._state.stencilWriteMask = t11, this._stateTracker.invalidateStencilWrite());
  }
  setStencilOp(t11, e6, s2) {
    1032 === this._state.stencilOperation.face && this._state.stencilOperation.fail === t11 && this._state.stencilOperation.zFail === e6 && this._state.stencilOperation.zPass === s2 || (this.gl.stencilOp(t11, e6, s2), this._state.stencilOperation.face = 1032, this._state.stencilOperation.fail = t11, this._state.stencilOperation.zFail = e6, this._state.stencilOperation.zPass = s2, this._stateTracker.invalidateStencilTest());
  }
  setStencilOpSeparate(t11, e6, s2, i4) {
    this._state.stencilOperation.face === t11 && this._state.stencilOperation.fail === e6 && this._state.stencilOperation.zFail === s2 && this._state.stencilOperation.zPass === i4 || (this.gl.stencilOpSeparate(t11, e6, s2, i4), this._state.stencilOperation.face = t11, this._state.stencilOperation.fail = e6, this._state.stencilOperation.zFail = s2, this._state.stencilOperation.zPass = i4, this._stateTracker.invalidateStencilTest());
  }
  setActiveTexture(t11, e6 = false) {
    const s2 = this._state.activeTexture;
    return t11 >= 0 && (e6 || t11 !== this._state.activeTexture) && (this.gl.activeTexture(I + t11), this._state.activeTexture = t11), s2;
  }
  setDrawBuffers(t11) {
    const { drawFramebuffer: e6 } = this._state, s2 = null === e6, i4 = s2 ? this._state.drawBuffers.defaultFramebuffer : this._state.drawBuffers.fbos.get(e6);
    if (i4?.length !== t11.length || !i4.every((e7, s3) => e7 === t11[s3])) if (t11.length > this.parameters.maxDrawBuffers) console.error("Setting more active draw buffers than GL.MAX_DRAW_BUFFERS allows.");
    else {
      if (s2) {
        if (t11.length > 1) return void console.error("The default framebuffer can only have one active draw buffer.");
        if (t11[0] !== B && t11[0] !== A) return void console.error("The default framebuffer can only use the constants GL.BACK or GL.NONE as draw buffers.");
      }
      s2 || !t11.includes(B) ? (this.gl.drawBuffers(t11), s2 ? this._state.drawBuffers.defaultFramebuffer = t11 : this._state.drawBuffers.fbos.set(e6, t11), this._stateTracker.invalidateDrawBuffers()) : console.error("A framebuffer object can only use the constants GL.COLOR_ATTACHMENTi or GL.NONE as draw buffers.");
    }
  }
  clear(t11, e6 = 255) {
    if (t11) {
      if (16384 & t11) {
        const t12 = this._state.drawFramebuffer?.colorAttachments;
        t12 && this.setDrawBuffers(t12), this.setColorMask(true, true, true, true);
      }
      256 & t11 && this.setDepthWriteEnabled(true), 1024 & t11 && this.setStencilWriteMask(e6), this.gl.clear(t11);
    }
  }
  clearFramebuffer(t11, e6 = false, s2 = false) {
    let i4 = 0;
    if (t11) {
      const e7 = 1e-13, s3 = Math.max(e7, t11[3]);
      this.setClearColor(t11[0], t11[1], t11[2], s3), i4 |= 16384;
    }
    e6 && (i4 |= 256), false === s2 ? s2 = 0 : (true === s2 && (s2 = 255), i4 |= 1024), i4 && this.clear(i4, s2);
  }
  clearBuffer(t11, e6, s2 = 6144, i4 = void 0) {
    this.gl.clearBufferfv(s2, t11, e6, i4);
  }
  clearBufferInteger(t11, e6, s2 = 6144, i4 = void 0) {
    this.gl.clearBufferiv(s2, t11, e6, i4);
  }
  clearBufferUnsignedInteger(t11, e6, s2 = 6144, i4 = void 0) {
    this.gl.clearBufferuiv(s2, t11, e6, i4);
  }
  drawArrays(t11, e6, s2) {
    if (this._transformFeedbackRequestInfo) {
      if (t11 !== this._transformFeedbackRequestInfo.primitiveType) throw new Error("DrawArrays called during transform feedback, but primitiveType does not match that of the current transform feedback request");
      if (null == this._state.program?.hasTransformFeedbackVaryings) throw new Error("DrawArrays called during transform feedback, but the shader program was not linked with a transform feedback varying");
    }
    if (a() && (this._numOfDrawCalls++, this._numOfTriangles += x(t11, s2), has("enable-feature:webgl-debug:textureReadWrite"))) {
      const t12 = this._state.textureUnitMap;
      for (let e7 = 0; e7 < t12.length; e7++) {
        const s3 = t12[e7];
        if (null != s3 && s3 === this._state.drawFramebuffer?.colorTexture) throw new Error(`Detected readWrite. Texture already bound at index ${e7}`);
      }
    }
    this.gl.drawArrays(t11, e6, s2), u(this.gl);
  }
  drawArraysInstanced(t11, e6, s2, i4) {
    this.gl.drawArraysInstanced(t11, e6, s2, i4), u(this.gl);
  }
  drawElements(t11, e6, s2, a3) {
    if (this._transformFeedbackRequestInfo) throw new Error("Cannot called drawElements during a transform feedback request");
    if (a() && (this._numOfDrawCalls++, this._numOfTriangles += x(t11, e6)), this.gl.drawElements(t11, e6, s2, a3), a()) {
      const i4 = t3(this.gl);
      if (i4) {
        const r5 = this.getBoundVAO(), n6 = r5?.indexBuffer, l2 = r5?.buffers, h3 = { indexBuffer: n6, vertexBuffers: l2 }, f = { mode: t11, count: e6, type: s2, offset: a3 }, o5 = n6?.size ?? 0, u3 = a3 + e6, c = o5 < u3 ? `. Buffer is too small. Attempted to draw index ${u3} of ${o5}` : "";
        console.error(`drawElements: ${i4}${c}`, { args: f, vao: h3 });
      }
    }
  }
  drawElementsInstanced(t11, e6, s2, i4, r5) {
    this.gl.drawElementsInstanced(t11, e6, s2, i4, r5), u(this.gl);
  }
  logInfo() {
    a() && console.log(`DrawCalls: ${this._numOfDrawCalls}, Triangles: ${this._numOfTriangles}`);
  }
  resetInfo() {
    a() && (this._numOfDrawCalls = 0, this._numOfTriangles = 0);
  }
  get capabilities() {
    return this._capabilities;
  }
  setViewport(t11, e6, s2, i4) {
    s2 = Math.max(Math.round(s2), 1), i4 = Math.max(Math.round(i4), 1);
    const a3 = this._state.viewport;
    a3.x === t11 && a3.y === e6 && a3.width === s2 && a3.height === i4 || (a3.x = t11, a3.y = e6, a3.width = s2, a3.height = i4, this.gl.viewport(t11, e6, s2, i4));
  }
  setViewport4fv(t11) {
    this.setViewport(t11[0], t11[1], t11[2], t11[3]);
  }
  restoreViewport({ x: t11, y: e6, width: s2, height: i4 }) {
    this.setViewport(t11, e6, s2, i4);
  }
  getViewport() {
    const t11 = this._state.viewport;
    return { x: t11.x, y: t11.y, width: t11.width, height: t11.height };
  }
  useProgram(t11) {
    this._state.program !== t11 && (this._state.program?.stop(), this._state.program = t11, this.gl.useProgram(t11?.glName ?? null));
  }
  bindTexture(t11, e6, s2 = false) {
    (e6 >= this.parameters.maxTextureImageUnits || e6 < 0) && console.error("Input texture unit is out of range of available units!");
    const i4 = this._state.textureUnitMap[e6];
    return null == t11?.glName ? (null != i4 && (this.setActiveTexture(e6, s2), this.gl.bindTexture(i4.descriptor.target, null)), this._state.textureUnitMap[e6] = null, i4) : s2 || i4 !== t11 ? (this.setActiveTexture(e6, s2), this.gl.bindTexture(t11.descriptor.target, t11.glName), t11.applyChanges(), this._state.textureUnitMap[e6] = t11, i4) : (t11.isDirty && (this.setActiveTexture(e6, s2), t11.applyChanges()), i4);
  }
  unbindTexture(t11) {
    if (null != t11) for (let e6 = 0; e6 < this.parameters.maxTextureImageUnits; e6++) this._state.textureUnitMap[e6] === t11 && (this.bindTexture(null, e6), this._state.textureUnitMap[e6] = null);
  }
  bindFramebuffer(t11, e6 = false) {
    if (e6 || this._state.readFramebuffer !== t11 || this._state.drawFramebuffer !== t11) {
      if (this._stateTracker.invalidateDrawBuffers(), null == t11) return this.gl.bindFramebuffer(36160, null), void (this._state.readFramebuffer = this._state.drawFramebuffer = null);
      t11.initializeAndBind(36160), this._state.readFramebuffer = t11, this._state.drawFramebuffer = t11;
    }
  }
  bindFramebufferSeparate(t11, e6, s2 = false) {
    const i4 = 36008 === e6, a3 = i4 ? this._state.readFramebuffer : this._state.drawFramebuffer;
    (s2 || a3 !== t11) && (null == t11 ? this.gl.bindFramebuffer(e6, null) : t11.initializeAndBind(e6), i4 ? this._state.readFramebuffer = t11 ?? null : (this._stateTracker.invalidateDrawBuffers(), this._state.drawFramebuffer = t11 ?? null));
  }
  blitFramebuffer(t11, e6, s2 = 16384, i4 = 9728, a3 = 0, r5 = 0, n6 = t11.width, l2 = t11.height, h3 = 0, f = 0, o5 = e6.width, u3 = e6.height) {
    this.bindFramebufferSeparate(t11, 36008, true), this.bindFramebufferSeparate(e6, 36009, true), this.gl.blitFramebuffer(a3, r5, n6, l2, h3, f, o5, u3, s2, i4);
  }
  bindBuffer(t11, e6) {
    if (t11) switch (e6 ??= t11.bufferType, e6) {
      case 34962:
        this._state.vertexBuffer = T3(this.gl, t11, e6, this._state.vertexBuffer);
        break;
      case 34963:
        this._state.indexBuffer = T3(this.gl, t11, e6, this._state.indexBuffer);
        break;
      case 35345:
        this._state.uniformBuffer = T3(this.gl, t11, e6, this._state.uniformBuffer);
        break;
      case 35051:
        this._state.pixelPackBuffer = T3(this.gl, t11, e6, this._state.pixelPackBuffer);
        break;
      case 35052:
        this._state.pixelUnpackBuffer = T3(this.gl, t11, e6, this._state.pixelUnpackBuffer);
        break;
      case 36662:
        this._state.copyReadBuffer = T3(this.gl, t11, e6, this._state.copyReadBuffer);
        break;
      case 36663:
        this._state.copyWriteBuffer = T3(this.gl, t11, e6, this._state.copyWriteBuffer);
        break;
      case 35982:
        this._state.transformFeedbackBuffer = T3(this.gl, t11, e6, this._state.transformFeedbackBuffer);
    }
  }
  bindRenderbuffer(t11) {
    const e6 = this.gl;
    t11 || (e6.bindRenderbuffer(e6.RENDERBUFFER, null), this._state.renderbuffer = null), this._state.renderbuffer !== t11 && (e6.bindRenderbuffer(e6.RENDERBUFFER, t11.glName), this._state.renderbuffer = t11);
  }
  _getBufferBinding(t11, e6) {
    if (e6 >= this.parameters.maxUniformBufferBindings || e6 < 0) return console.error("Uniform buffer binding point is out of range!"), null;
    const s2 = 35345 === t11 ? this._state.uniformBufferBindingPoints : this._state.transformBufferBindingPoints;
    let i4 = s2[e6];
    return null == i4 && (i4 = { buffer: null, offset: 0, size: 0 }, s2[e6] = i4), i4;
  }
  bindBufferBase(t11, e6, s2) {
    const i4 = this._getBufferBinding(t11, e6);
    null != i4 && (i4.buffer === s2 && 0 === i4.offset && 0 === i4.size || (this.gl.bindBufferBase(t11, e6, s2 ? s2.glName : null), i4.buffer = s2, i4.offset = 0, i4.size = 0));
  }
  bindBufferRange(t11, e6, s2, i4, a3) {
    const r5 = this._getBufferBinding(t11, e6);
    null != r5 && (r5.buffer === s2 && r5.offset === i4 && r5.size === a3 || (i4 % this._parameters.uniformBufferOffsetAlignment === 0 ? (this.gl.bindBufferRange(t11, e6, s2.glName, i4, a3), r5.buffer = s2, r5.offset = i4, r5.size = a3) : console.error("Uniform buffer binding offset is not a multiple of the context offset alignment")));
  }
  bindUBO(t11, e6, s2, a3) {
    null != e6 ? (a() && (a3 ?? e6.byteLength) > this._parameters.maxUniformBlockSize && console.error("Attempting to bind more data than the maximum uniform block size"), e6.initialize(), void 0 !== s2 && void 0 !== a3 ? this.bindBufferRange(35345, t11, e6.buffer, s2, a3) : this.bindBufferBase(35345, t11, e6.buffer)) : this.bindBufferBase(35345, t11, null);
  }
  unbindUBO(t11) {
    for (let e6 = 0, s2 = this._state.uniformBufferBindingPoints.length; e6 < s2; e6++) {
      const s3 = this._state.uniformBufferBindingPoints[e6];
      null != s3 && s3.buffer === t11.buffer && this.bindBufferBase(35345, e6, null);
    }
  }
  unbindBuffer(t11) {
    switch (t11) {
      case 34962:
        this._state.vertexBuffer = T3(this.gl, null, t11, this._state.vertexBuffer);
        break;
      case 34963:
        this._state.indexBuffer = T3(this.gl, null, t11, this._state.indexBuffer);
        break;
      case 35345:
        this._state.uniformBuffer = T3(this.gl, null, t11, this._state.uniformBuffer);
        break;
      case 35051:
        this._state.pixelPackBuffer = T3(this.gl, null, t11, this._state.pixelPackBuffer);
        break;
      case 35052:
        this._state.pixelUnpackBuffer = T3(this.gl, null, t11, this._state.pixelUnpackBuffer);
        break;
      case 36662:
        this._state.copyReadBuffer = T3(this.gl, null, t11, this._state.copyReadBuffer);
        break;
      case 36663:
        this._state.copyWriteBuffer = T3(this.gl, null, t11, this._state.copyWriteBuffer);
    }
  }
  bindVAO(t11, e6) {
    if (null == t11) return this._state.vertexArrayObject?.unbind(), void (this._state.vertexArrayObject = null);
    this._state.vertexArrayObject !== t11 && (t11.bind(e6), this._state.vertexArrayObject = t11);
  }
  bindTransformFeedback(t11) {
    const { gl: e6 } = this;
    e6.bindTransformFeedback(e6.TRANSFORM_FEEDBACK, t11.glName);
  }
  beginTransformFeedback(t11, e6) {
    if (this._transformFeedbackRequestInfo) throw new Error("Already in a transform feedback request");
    const { gl: s2 } = this;
    s2.bindTransformFeedback(s2.TRANSFORM_FEEDBACK, t11.glName), s2.beginTransformFeedback(e6), this._transformFeedbackRequestInfo = { primitiveType: e6 };
  }
  endTransformFeedback() {
    if (!this._transformFeedbackRequestInfo) throw new Error("Not in a transform feedback request");
    const { gl: t11 } = this;
    t11.endTransformFeedback(), t11.bindTransformFeedback(t11.TRANSFORM_FEEDBACK, null), this._transformFeedbackRequestInfo = null;
  }
  async clientWaitAsync(t11 = n(10)) {
    const { gl: i4 } = this, a3 = i4.fenceSync(37143, 0);
    if (!a3) throw new Error("Client wait failed, could not create sync object");
    let r5;
    this.instanceCounter.increment(O.Sync, a3), i4.flush();
    do {
      await T(t11), r5 = i4.clientWaitSync(a3, 0, 0);
    } while (37147 === r5);
    if (this.instanceCounter.decrement(O.Sync, a3), i4.deleteSync(a3), 37149 === r5) throw new Error("Client wait failed");
  }
  getBoundFramebufferObject(t11 = 36160) {
    return 36008 === t11 ? this._state.readFramebuffer : this._state.drawFramebuffer;
  }
  temporaryBindFramebufferObject(t11, e6, s2 = false) {
    const i4 = this.getBoundFramebufferObject();
    try {
      this.bindFramebuffer(t11, s2), e6();
    } finally {
      this.bindFramebuffer(i4, s2);
    }
  }
  getBoundVAO() {
    return this._state.vertexArrayObject;
  }
  resetState() {
    this.useProgram(null), this.bindVAO(null), this.bindFramebuffer(null, true), this.unbindBuffer(34962), this.unbindBuffer(34963), this.unbindBuffer(35345), this._state.uniformBufferBindingPoints.length = 0, this.unbindBuffer(35051), this.unbindBuffer(35052), this.unbindBuffer(36662), this.unbindBuffer(36663);
    for (let t11 = 0; t11 < this.parameters.maxTextureImageUnits; ++t11) this.bindTexture(null, t11);
    this.setBlendingEnabled(false), this.setBlendFunction(1, 0), this.setBlendEquation(32774), this.setBlendColor(0, 0, 0, 0), this.setFaceCullingEnabled(false), this.setCullFace(1029), this.setFrontFace(2305), this.setPolygonOffsetFillEnabled(false), this.setPolygonOffset(0, 0), this.setScissorTestEnabled(false), this.setScissorRect(0, 0, this.gl.canvas.width, this.gl.canvas.height), this.setDepthTestEnabled(false), this.setDepthFunction(513), this.setDepthRange(0, 1), this.setStencilTestEnabled(false), this.setStencilFunction(519, 0, 0), this.setStencilOp(7680, 7680, 7680), this.setClearColor(0, 0, 0, 0), this.setClearDepth(1), this.setClearStencil(0), this.setColorMask(true, true, true, true), this.setStencilWriteMask(4294967295), this.setDepthWriteEnabled(true), this.setDrawBuffers([B]), this.setViewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
  }
  enforceState() {
    const { gl: t11 } = this;
    t11.bindVertexArray(null);
    for (let s2 = 0; s2 < this.parameters.maxVertexAttributes; s2++) t11.disableVertexAttribArray(s2);
    this._state.vertexBuffer ? t11.bindBuffer(this._state.vertexBuffer.bufferType, this._state.vertexBuffer.glName) : t11.bindBuffer(34962, null), this._state.indexBuffer ? t11.bindBuffer(this._state.indexBuffer.bufferType, this._state.indexBuffer.glName) : t11.bindBuffer(34963, null), this._state.uniformBuffer ? t11.bindBuffer(this._state.uniformBuffer.bufferType, this._state.uniformBuffer.glName) : t11.bindBuffer(35345, null);
    for (let s2 = 0; s2 < this._parameters.maxUniformBufferBindings; s2++) {
      const e7 = this._state.uniformBufferBindingPoints[s2];
      if (null != e7) {
        const { buffer: i4, offset: a3, size: r5 } = e7;
        null !== i4 ? 0 === a3 && 0 === r5 ? t11.bindBufferBase(35345, s2, i4.glName) : t11.bindBufferRange(35345, s2, i4.glName, a3, r5) : t11.bindBufferBase(35345, s2, null);
      }
    }
    if (this._state.pixelPackBuffer ? t11.bindBuffer(this._state.pixelPackBuffer.bufferType, this._state.pixelPackBuffer.glName) : t11.bindBuffer(35051, null), this._state.pixelUnpackBuffer ? t11.bindBuffer(this._state.pixelUnpackBuffer.bufferType, this._state.pixelUnpackBuffer.glName) : t11.bindBuffer(35052, null), this._state.copyReadBuffer ? t11.bindBuffer(this._state.copyReadBuffer.bufferType, this._state.copyReadBuffer.glName) : t11.bindBuffer(36662, null), this._state.copyWriteBuffer ? t11.bindBuffer(this._state.copyWriteBuffer.bufferType, this._state.copyWriteBuffer.glName) : t11.bindBuffer(36663, null), t11.bindFramebuffer(36008, null), t11.readBuffer(t11.BACK), this._state.readFramebuffer && (t11.bindFramebuffer(36008, this._state.readFramebuffer.glName), t11.readBuffer(D)), t11.bindFramebuffer(36009, this._state.drawFramebuffer?.glName ?? null), null === this._state.drawFramebuffer) {
      const e7 = this._state.drawBuffers.defaultFramebuffer;
      t11.drawBuffers(e7 ?? [B]);
    } else {
      const e7 = this._state.drawBuffers.fbos.get(this._state.drawFramebuffer);
      t11.drawBuffers(e7 ?? [D]);
    }
    if (this._state.vertexArrayObject) {
      const t12 = this._state.vertexArrayObject;
      this._state.vertexArrayObject && (this._state.vertexArrayObject.unbind(), this._state.vertexArrayObject = null), this.bindVAO(t12);
    }
    t11.useProgram(this._state.program?.glName ?? null), t11.blendColor(this._state.blendColor.r, this._state.blendColor.g, this._state.blendColor.b, this._state.blendColor.a), t11.bindRenderbuffer(t11.RENDERBUFFER, this._state.renderbuffer?.glName ?? null), true === this._state.blend ? t11.enable(this.gl.BLEND) : t11.disable(this.gl.BLEND), t11.blendEquationSeparate(this._state.blendEquation.mode, this._state.blendEquation.modeAlpha), t11.blendFuncSeparate(this._state.blendFunction.srcRGB, this._state.blendFunction.dstRGB, this._state.blendFunction.srcAlpha, this._state.blendFunction.dstAlpha), t11.clearColor(this._state.clearColor.r, this._state.clearColor.g, this._state.clearColor.b, this._state.clearColor.a), t11.clearDepth(this._state.clearDepth), t11.clearStencil(this._state.clearStencil), t11.colorMask(this._state.colorMask.r, this._state.colorMask.g, this._state.colorMask.b, this._state.colorMask.a), t11.cullFace(this._state.cullFace), t11.depthFunc(this._state.depthFunction), t11.depthRange(this._state.depthRange.zNear, this._state.depthRange.zFar), true === this._state.depthTest ? t11.enable(t11.DEPTH_TEST) : t11.disable(t11.DEPTH_TEST), t11.depthMask(this._state.depthWrite), t11.frontFace(this._state.frontFace), t11.lineWidth(1), true === this._state.faceCulling ? t11.enable(t11.CULL_FACE) : t11.disable(t11.CULL_FACE), t11.polygonOffset(this._state.polygonOffset[0], this._state.polygonOffset[1]), true === this._state.polygonOffsetFill ? t11.enable(t11.POLYGON_OFFSET_FILL) : t11.disable(t11.POLYGON_OFFSET_FILL), t11.scissor(this._state.scissorRect.x, this._state.scissorRect.y, this._state.scissorRect.width, this._state.scissorRect.height), true === this._state.scissorTest ? t11.enable(t11.SCISSOR_TEST) : t11.disable(t11.SCISSOR_TEST), t11.stencilFunc(this._state.stencilFunction.func, this._state.stencilFunction.ref, this._state.stencilFunction.mask), t11.stencilOpSeparate(this._state.stencilOperation.face, this._state.stencilOperation.fail, this._state.stencilOperation.zFail, this._state.stencilOperation.zPass), true === this._state.stencilTest ? t11.enable(t11.STENCIL_TEST) : t11.disable(t11.STENCIL_TEST), t11.stencilMask(this._state.stencilWriteMask);
    for (let s2 = 0; s2 < this.parameters.maxTextureImageUnits; s2++) {
      t11.activeTexture(I + s2), t11.bindTexture(3553, null), t11.bindTexture(34067, null), t11.bindTexture(32879, null), t11.bindTexture(35866, null);
      const e7 = this._state.textureUnitMap[s2];
      null != e7 && t11.bindTexture(e7.descriptor.target, e7.glName);
    }
    t11.activeTexture(I + this._state.activeTexture);
    const e6 = this._state.viewport;
    t11.viewport(e6.x, e6.y, e6.width, e6.height), this.resetInfo();
  }
};
function T3(t11, e6, s2, i4) {
  return e6 ? i4 !== e6 && t11.bindBuffer(s2, e6.glName) : t11.bindBuffer(s2, null), e6;
}
function x(t11, e6) {
  switch (t11) {
    case _.POINTS:
      return 2 * e6;
    case _.TRIANGLES:
      return e6 / 3;
    case _.TRIANGLE_STRIP:
    case _.TRIANGLE_FAN:
      return e6 - 2;
    default:
      return 0;
  }
}

export {
  s,
  a2 as a,
  F
};
//# sourceMappingURL=chunk-DCXQINIS.js.map
