import {
  Q,
  U,
  h,
  i,
  p,
  te,
  ue
} from "./chunk-AH42IBBP.js";
import {
  n
} from "./chunk-4PXNA4MD.js";
import {
  e,
  n as n2,
  o
} from "./chunk-C5OQVQZF.js";
import {
  b
} from "./chunk-5EI5H4QX.js";

// node_modules/@arcgis/core/arcade/containerUtils.js
var p2 = { point: ["hasZ", "hasM", "spatialReference", "type", "x", "y", "z", "m"], multipoint: ["hasZ", "hasM", "spatialReference", "type", "points"], polyline: ["hasZ", "hasM", "spatialReference", "type", "paths"], polygon: ["hasZ", "hasM", "spatialReference", "type", "rings"], extent: ["hasZ", "hasM", "spatialReference", "type", "xmin", "xmax", "ymin", "ymax", "zmin", "zmax", "mmin", "mmax"] };
function f(e2) {
  return p2[e2.type];
}
var m = 0;
function d(r, s, i2, c, o2 = 1) {
  let u;
  switch (s = s.toLowerCase()) {
    case "hasz": {
      const e2 = r.hasZ;
      return void 0 !== e2 && e2;
    }
    case "hasm": {
      const e2 = r.hasM;
      return void 0 !== e2 && e2;
    }
    case "spatialreference": {
      let a = r.spatialReference._arcadeCacheId;
      if (void 0 === a) {
        let e2 = true;
        b.isFrozen(r.spatialReference) && (e2 = false), e2 && (m++, r.spatialReference._arcadeCacheId = m, a = m);
      }
      const t = new p({ __proto__: null, wkt: r.spatialReference.wkt, wkid: r.spatialReference.wkid });
      return void 0 !== a && (t._arcadeCacheId = "SPREF" + a.toString()), t;
    }
  }
  switch (r.type) {
    case "extent":
      switch (s) {
        case "xmin":
        case "xmax":
        case "ymin":
        case "ymax":
        case "zmin":
        case "zmax":
        case "mmin":
        case "mmax": {
          const e2 = r[s];
          return void 0 !== e2 ? e2 : null;
        }
        case "type":
          return "Extent";
      }
      break;
    case "polygon":
      switch (s) {
        case "rings":
          u = r.cache._arcadeCacheId, void 0 === u && (m++, u = m, r.cache._arcadeCacheId = u);
          return new h(r.rings, r.spatialReference, true === r.hasZ, true === r.hasM, u);
        case "type":
          return "Polygon";
      }
      break;
    case "point":
      switch (s) {
        case "x":
        case "y":
        case "z":
        case "m":
          return r[s] ?? null;
        case "type":
          return "Point";
      }
      break;
    case "polyline":
      switch (s) {
        case "paths":
          u = r.cache._arcadeCacheId, void 0 === u && (m++, u = m, r.cache._arcadeCacheId = u);
          return new h(r.paths, r.spatialReference, true === r.hasZ, true === r.hasM, u);
        case "type":
          return "Polyline";
      }
      break;
    case "multipoint":
      switch (s) {
        case "points":
          u = r.cache._arcadeCacheId, void 0 === u && (m++, u = m, r.cache._arcadeCacheId = u);
          return new i(r.points, r.spatialReference, true === r.hasZ, true === r.hasM, u, 1);
        case "type":
          return "Multipoint";
      }
  }
  if (1 === o2) throw new n(i2, "InvalidIdentifier", c);
  return 2 === o2 ? { keystate: "notfound" } : null;
}
function y(e2, a) {
  let t, n3 = e2;
  if (null == n3) return null;
  if (o(a)) t = a;
  else if (te(a)) t = a.toArray();
  else {
    if (null == a) return null;
    t = [a];
  }
  for (const r of t) {
    if (Q(n3)) {
      if (false === e(r)) return null;
      if (!n3.hasField(r)) return null;
      n3 = n3.field(r);
    } else if (U(n3)) {
      if (false === e(r)) return null;
      n3 = d(n3, r, null, null, 0);
    } else if (o(n3)) {
      if (false === n2(r)) return null;
      n3 = r >= 0 ? n3[r] : n3[n3.length + r];
    } else {
      if (!te(n3)) return null;
      if (false === n2(r)) return null;
      n3 = r >= 0 ? n3.get(r) : n3.get(n3.length() + r);
    }
    if (null == n3) return null;
  }
  return n3;
}
function x(e2) {
  return !!ue(e2) || (o(e2) ? 0 === e2.length : te(e2) ? 0 === e2.length() : !!Q(e2) && e2.isEmpty());
}

export {
  f,
  d,
  y,
  x
};
//# sourceMappingURL=chunk-2ZH6SNCD.js.map
