import {
  o
} from "./chunk-Z6VKIQV2.js";
import {
  Ie,
  Te,
  c,
  ee,
  ge,
  he,
  xe
} from "./chunk-MC6NAKKX.js";
import {
  f,
  n,
  t as t2
} from "./chunk-THQO67BJ.js";
import {
  FixedOffsetZone,
  IANAZone
} from "./chunk-4YDOPHTZ.js";
import {
  t
} from "./chunk-V2H77UEV.js";
import {
  e
} from "./chunk-4DGC7CBY.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/layers/support/FieldsIndex.js
function y(e2) {
  return "timeZone" in e2;
}
function _(e2) {
  return "timeZone" in e2;
}
function g(e2) {
  return "dateFieldsTimeZone" in e2;
}
var T = /* @__PURE__ */ new Map();
var Z = class _Z {
  static fromJSON(e2) {
    return new _Z(e2.fields, e2.timeZoneByFieldName);
  }
  static fromLayer(e2) {
    return new _Z(e2.fields ?? [], S(e2));
  }
  static fromLayerJSON(e2) {
    return new _Z(e2.fields ?? [], S(e2));
  }
  constructor(e2 = [], i2) {
    this._fieldsMap = /* @__PURE__ */ new Map(), this._normalizedFieldsMap = /* @__PURE__ */ new Map(), this._dateFieldsSet = /* @__PURE__ */ new Set(), this._numericFieldsSet = /* @__PURE__ */ new Set(), this._requiredFields = null, this.dateFields = [], this.numericFields = [], this.fields = e2 || [], this._timeZoneByFieldName = i2 ? new Map(i2) : null;
    const t3 = [];
    for (const s2 of this.fields) {
      const e3 = s2?.name, i3 = M(e3);
      if (e3 && i3) {
        const n2 = w(e3);
        this._fieldsMap.set(e3, s2), this._fieldsMap.set(n2, s2), this._normalizedFieldsMap.set(i3, s2), t3.push(`${n2}:${s2.type}:${this._timeZoneByFieldName?.get(e3)}`), Ie(s2) ? (this.dateFields.push(s2), this._dateFieldsSet.add(s2)) : ge(s2) && (this._numericFieldsSet.add(s2), this.numericFields.push(s2)), Te(s2) || he(s2) || (s2.editable = null == s2.editable || !!s2.editable, s2.nullable = null == s2.nullable || !!s2.nullable);
      }
    }
    t3.sort(), this.uid = t3.join();
  }
  get requiredFields() {
    if (!this._requiredFields) {
      this._requiredFields = [];
      for (const e2 of this.fields) Te(e2) || he(e2) || e2.nullable || void 0 !== ee(e2) || this._requiredFields.push(e2);
    }
    return this._requiredFields;
  }
  equals(e2) {
    return this.uid === e2?.uid;
  }
  has(e2) {
    return null != this.get(e2);
  }
  get(e2) {
    if (!e2) return;
    let i2 = this._fieldsMap.get(e2);
    return i2 || (i2 = this._fieldsMap.get(w(e2)) ?? this._normalizedFieldsMap.get(M(e2)), i2 && this._fieldsMap.set(e2, i2), i2);
  }
  getTimeZone(t3) {
    const s2 = this.get(t3 && "string" != typeof t3 ? t3.name : t3);
    return s2 ? this._timeZoneByFieldName ? this._timeZoneByFieldName.get(s2.name) : "date" === s2.type || "esriFieldTypeDate" === s2.type ? (i.getLogger("esri.layers.support.FieldsIndex").errorOnce(new s("getTimeZone:no-timezone-information", `no time zone information for field '${s2.name}'`)), n) : N.has(s2.type) ? t2 : null : null;
  }
  getLuxonTimeZone(e2) {
    const i2 = this.getTimeZone(e2);
    return i2 ? i2 === t2 ? o.instance : i2 === n ? FixedOffsetZone.utcInstance : e(T, i2, () => IANAZone.create(i2)) : null;
  }
  isDateField(e2) {
    return this._dateFieldsSet.has(this.get(e2));
  }
  isTimeOnlyField(e2) {
    return xe(this.get(e2));
  }
  isNumericField(e2) {
    return this._numericFieldsSet.has(this.get(e2));
  }
  normalizeFieldName(e2) {
    return this.get(e2)?.name ?? void 0;
  }
  toJSON() {
    return { fields: this.fields.map((e2) => t(e2) ? e2.toJSON() : e2), timeZoneByFieldName: this._timeZoneByFieldName ? Array.from(this._timeZoneByFieldName.entries()) : null };
  }
};
function w(e2) {
  return e2.trim().toLowerCase();
}
function M(e2) {
  return c(e2)?.toLowerCase() ?? "";
}
var N = /* @__PURE__ */ new Set(["time-only", "date-only", "timestamp-offset", "esriFieldTypeDateOnly", "esriFieldTypeTimeOnly", "esriFieldTypeTimestampOffset"]);
function S(e2) {
  const i2 = /* @__PURE__ */ new Map();
  if (!e2.fields) return i2;
  const t3 = true === e2.datesInUnknownTimezone, { timeInfo: s2, editFieldsInfo: n2 } = e2, r = (s2 ? "startField" in s2 ? s2.startField : s2.startTimeField : "") ?? "", l = (s2 ? "endField" in s2 ? s2.endField : s2.endTimeField : "") ?? "", o2 = g(e2) ? e2.dateFieldsTimeZone ?? null : e2.dateFieldsTimeReference ? f(e2.dateFieldsTimeReference) : null, d = n2 ? y(n2) ? n2.timeZone ?? o2 : n2.dateFieldsTimeReference ? f(n2.dateFieldsTimeReference) : o2 ?? n : null, a = s2 ? _(s2) ? s2.timeZone ?? o2 : s2.timeReference ? f(s2.timeReference) : o2 : null, m = /* @__PURE__ */ new Map([[w(n2?.creationDateField ?? ""), d], [w(n2?.editDateField ?? ""), d], [w(r), a], [w(l), a]]);
  for (const { name: u, type: f2 } of e2.fields) if (N.has(f2)) i2.set(u, t2);
  else if ("date" !== f2 && "esriFieldTypeDate" !== f2) i2.set(u, null);
  else if (t3) i2.set(u, t2);
  else {
    const e3 = m.get(w(u ?? "")) ?? o2;
    i2.set(u, e3);
  }
  return i2;
}

export {
  Z
};
//# sourceMappingURL=chunk-2HGIYEIL.js.map
