import {
  c,
  o as o2
} from "./chunk-LPZUGJNG.js";
import {
  e
} from "./chunk-THQO67BJ.js";
import {
  o
} from "./chunk-XWE6BM2U.js";
import {
  r
} from "./chunk-SOIZOFSB.js";
import {
  n
} from "./chunk-XXLHAM2M.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";

// node_modules/@arcgis/core/time/TimeExtent.js
var u;
var _a;
var m2 = (_a = class extends n {
  static get allTime() {
    return p;
  }
  static get empty() {
    return d;
  }
  static fromArray(t) {
    return new u({ start: null != t[0] ? new Date(t[0]) : t[0], end: null != t[1] ? new Date(t[1]) : t[1] });
  }
  constructor(t) {
    super(t), this.end = null, this.start = null;
  }
  readEnd(t, e2) {
    return null != e2.end ? new Date(e2.end) : null;
  }
  writeEnd(t, e2) {
    e2.end = t?.getTime() ?? null;
  }
  get isAllTime() {
    return this.equals(u.allTime);
  }
  get isEmpty() {
    return this.equals(u.empty);
  }
  readStart(t, e2) {
    return null != e2.start ? new Date(e2.start) : null;
  }
  writeStart(t, e2) {
    e2.start = t?.getTime() ?? null;
  }
  clone() {
    return new u({ end: this.end, start: this.start });
  }
  equals(t) {
    if (!t) return false;
    const e2 = this.start?.getTime() ?? this.start, r2 = this.end?.getTime() ?? this.end, s = t.start?.getTime() ?? t.start, n2 = t.end?.getTime() ?? t.end;
    return e2 === s && r2 === n2;
  }
  expandTo(t, e2 = e) {
    if (this.isEmpty || this.isAllTime) return this.clone();
    let n2 = this.start;
    n2 && (n2 = c(n2, t, e2));
    let i = this.end;
    if (i) {
      const n3 = c(i, t, e2);
      i = i.getTime() === n3.getTime() ? n3 : o2(n3, 1, t, e2);
    }
    return new u({ start: n2, end: i });
  }
  intersection(t) {
    if (!t) return this.clone();
    if (this.isEmpty || t.isEmpty) return u.empty;
    if (this.isAllTime) return t.clone();
    if (t.isAllTime) return this.clone();
    const e2 = this.start?.getTime() ?? -1 / 0, r2 = this.end?.getTime() ?? 1 / 0, s = t.start?.getTime() ?? -1 / 0, n2 = t.end?.getTime() ?? 1 / 0;
    let i, l;
    return s >= e2 && s <= r2 ? i = s : e2 >= s && e2 <= n2 && (i = e2), r2 >= s && r2 <= n2 ? l = r2 : n2 >= e2 && n2 <= r2 && (l = n2), null == i || null == l || isNaN(i) || isNaN(l) ? u.empty : new u({ start: i === -1 / 0 ? null : new Date(i), end: l === 1 / 0 ? null : new Date(l) });
  }
  offset(t, e2, r2 = e) {
    if (this.isEmpty || this.isAllTime) return this.clone();
    const n2 = new u(), { start: i, end: l } = this;
    return null != i && (n2.start = o2(i, t, e2, r2)), null != l && (n2.end = o2(l, t, e2, r2)), n2;
  }
  toArray() {
    return this.isEmpty ? [void 0, void 0] : [this.start?.getTime() ?? null, this.end?.getTime() ?? null];
  }
  union(t) {
    if (!t || t.isEmpty) return this.clone();
    if (this.isEmpty) return t.clone();
    if (this.isAllTime || t.isAllTime) return p.clone();
    const e2 = null != this.start && null != t.start ? new Date(Math.min(this.start.getTime(), t.start.getTime())) : null, r2 = null != this.end && null != t.end ? new Date(Math.max(this.end.getTime(), t.end.getTime())) : null;
    return new u({ start: e2, end: r2 });
  }
}, u = _a, _a);
__decorate([m({ type: Date, json: { write: { allowNull: true } } })], m2.prototype, "end", void 0), __decorate([o("end")], m2.prototype, "readEnd", null), __decorate([r("end")], m2.prototype, "writeEnd", null), __decorate([m({ readOnly: true, json: { read: false } })], m2.prototype, "isAllTime", null), __decorate([m({ readOnly: true, json: { read: false } })], m2.prototype, "isEmpty", null), __decorate([m({ type: Date, json: { write: { allowNull: true } } })], m2.prototype, "start", void 0), __decorate([o("start")], m2.prototype, "readStart", null), __decorate([r("start")], m2.prototype, "writeStart", null), m2 = u = __decorate([a("esri.time.TimeExtent")], m2);
var p = new m2();
var d = new m2({ start: void 0, end: void 0 });

export {
  m2 as m
};
//# sourceMappingURL=chunk-MHV23XAQ.js.map
