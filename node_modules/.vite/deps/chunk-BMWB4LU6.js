import {
  p
} from "./chunk-PBFXKJNR.js";
import {
  t as t2
} from "./chunk-KOVWXXQR.js";
import {
  t as t3
} from "./chunk-WNQORCSA.js";
import {
  r
} from "./chunk-EGPAQBOO.js";
import {
  e as e2
} from "./chunk-6GHQTYW5.js";
import {
  s
} from "./chunk-WJ3E33GQ.js";
import {
  r as r2
} from "./chunk-YOYO2XMY.js";
import {
  n as n2,
  t
} from "./chunk-CFXCM2NO.js";
import {
  n
} from "./chunk-WDTGOP77.js";
import {
  e
} from "./chunk-K2OZ6WVC.js";
import {
  i
} from "./chunk-XLOINTMG.js";
import {
  o
} from "./chunk-AZXJIEZ6.js";

// node_modules/@arcgis/core/chunks/LaserlinePath.glsl.js
function p2(t4) {
  const r3 = new s();
  r3.include(p, t4);
  const { vertex: p3, fragment: f2 } = r3;
  p3.uniforms.add(new t2("modelView", (t5, { camera: o2 }) => i(g, o2.viewMatrix, t5.origin)), new t3("proj", ({ camera: e3 }) => e3.projectionMatrix), new r2("glowWidth", (e3, { camera: t5 }) => e3.glowWidth * t5.pixelRatio), new e2("pixelToNDC", ({ camera: e3 }) => o(w, 2 / e3.fullViewport[2], 2 / e3.fullViewport[3]))), r3.attributes.add("start", "vec3"), r3.attributes.add("end", "vec3"), t4.spherical && (r3.attributes.add("startUp", "vec3"), r3.attributes.add("endUp", "vec3")), r3.attributes.add("extrude", "vec2"), r3.varyings.add("uv", "vec2"), r3.varyings.add("vViewStart", "vec3"), r3.varyings.add("vViewEnd", "vec3"), r3.varyings.add("vViewSegmentNormal", "vec3"), r3.varyings.add("vViewStartNormal", "vec3"), r3.varyings.add("vViewEndNormal", "vec3");
  const u = !t4.spherical;
  return p3.main.add(t`
    vec3 pos = mix(start, end, extrude.x);

    vec4 viewPos = modelView * vec4(pos, 1);
    vec4 projPos = proj * viewPos;
    vec2 ndcPos = projPos.xy / projPos.w;

    // in planar we hardcode the up vectors to be Z-up */
    ${n2(u, t`vec3 startUp = vec3(0, 0, 1);`)}
    ${n2(u, t`vec3 endUp = vec3(0, 0, 1);`)}

    // up vector corresponding to the location of the vertex, selecting either startUp or endUp */
    vec3 up = extrude.y * mix(startUp, endUp, extrude.x);
    vec3 viewUp = (modelView * vec4(up, 0)).xyz;

    vec4 projPosUp = proj * vec4(viewPos.xyz + viewUp, 1);
    vec2 projUp = normalize(projPosUp.xy / projPosUp.w - ndcPos);

    // extrude ndcPos along projUp to the edge of the screen
    vec2 lxy = abs(sign(projUp) - ndcPos);
    ndcPos += length(lxy) * projUp;

    vViewStart = (modelView * vec4(start, 1)).xyz;
    vViewEnd = (modelView * vec4(end, 1)).xyz;

    vec3 viewStartEndDir = vViewEnd - vViewStart;

    vec3 viewStartUp = (modelView * vec4(startUp, 0)).xyz;

    // the normal of the plane that aligns with the segment and the up vector
    vViewSegmentNormal = normalize(cross(viewStartUp, viewStartEndDir));

    // the normal orthogonal to the segment normal and the start up vector
    vViewStartNormal = -normalize(cross(vViewSegmentNormal, viewStartUp));

    // the normal orthogonal to the segment normal and the end up vector
    vec3 viewEndUp = (modelView * vec4(endUp, 0)).xyz;
    vViewEndNormal = normalize(cross(vViewSegmentNormal, viewEndUp));

    // Add enough padding in the X screen space direction for "glow"
    float xPaddingPixels = sign(dot(vViewSegmentNormal, viewPos.xyz)) * (extrude.x * 2.0 - 1.0) * glowWidth;
    ndcPos.x += xPaddingPixels * pixelToNDC.x;

    // uv is used to read back depth to reconstruct the position at the fragment
    uv = ndcPos * 0.5 + 0.5;

    gl_Position = vec4(ndcPos, 0, 1);
  `), f2.uniforms.add(new r("perScreenPixelRatio", (e3) => e3.camera.perScreenPixelRatio)), f2.code.add(t`float planeDistance(vec3 planeNormal, vec3 planeOrigin, vec3 pos) {
return dot(planeNormal, pos - planeOrigin);
}
float segmentDistancePixels(vec3 segmentNormal, vec3 startNormal, vec3 endNormal, vec3 pos, vec3 start, vec3 end) {
float distSegmentPlane = planeDistance(segmentNormal, start, pos);
float distStartPlane = planeDistance(startNormal, start, pos);
float distEndPlane = planeDistance(endNormal, end, pos);
float dist = max(max(distStartPlane, distEndPlane), abs(distSegmentPlane));
float width = fwidth(distSegmentPlane);
float maxPixelDistance = length(pos) * perScreenPixelRatio * 2.0;
float pixelDist = dist / min(width, maxPixelDistance);
return abs(pixelDist);
}`), f2.main.add(t`fragColor = vec4(0.0);
vec3 dEndStart = vViewEnd - vViewStart;
if (dot(dEndStart, dEndStart) < 1e-5) {
return;
}
vec3 pos;
vec3 normal;
float angleCutoffAdjust;
float depthDiscontinuityAlpha;
if (!laserlineReconstructFromDepth(pos, normal, angleCutoffAdjust, depthDiscontinuityAlpha)) {
return;
}
float distance = segmentDistancePixels(
vViewSegmentNormal,
vViewStartNormal,
vViewEndNormal,
pos,
vViewStart,
vViewEnd
);
vec4 color = laserlineProfile(distance);
float alpha = (1.0 - smoothstep(0.995 - angleCutoffAdjust, 0.999 - angleCutoffAdjust, abs(dot(normal, vViewSegmentNormal))));
fragColor = laserlineOutput(color * alpha * depthDiscontinuityAlpha);`), r3;
}
var w = n();
var g = e();
var f = Object.freeze(Object.defineProperty({ __proto__: null, build: p2 }, Symbol.toStringTag, { value: "Module" }));

export {
  p2 as p,
  f
};
//# sourceMappingURL=chunk-BMWB4LU6.js.map
