import {
  e2 as e
} from "./chunk-27W5ILTF.js";
import {
  n
} from "./chunk-45CFSCQX.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/animatedFormats/utils.js
function r(e2) {
  return n(e2.frameDurations.reduce((t, e3) => t + e3, 0));
}
function i(t) {
  const { width: e2, height: r2 } = t, i2 = t.frameDurations.reverse(), a2 = (e3) => {
    const r3 = t.frameDurations.length - 1 - e3;
    return t.getFrame(r3);
  };
  return { frameCount: t.frameCount, duration: t.duration, frameDurations: i2, getFrame: a2, width: e2, height: r2 };
}
function a(e2, r2) {
  const { width: i2, height: a2, getFrame: n3 } = e2, s2 = r2 / e2.duration, o2 = e2.frameDurations.map((e3) => n(e3 * s2));
  return { frameCount: e2.frameCount, duration: e2.duration, frameDurations: o2, getFrame: n3, width: i2, height: a2 };
}
function n2(e2, r2) {
  const { width: i2, height: a2, getFrame: n3 } = e2, s2 = e2.frameDurations.slice(), o2 = s2.shift();
  return s2.unshift(n(o2 + r2)), { frameCount: e2.frameCount, duration: e2.duration + r2, frameDurations: s2, getFrame: n3, width: i2, height: a2 };
}
function s(e2, r2) {
  const { width: i2, height: a2, getFrame: n3 } = e2, s2 = e2.frameDurations.slice(), o2 = s2.pop();
  return s2.push(n(o2 + r2)), { frameCount: e2.frameCount, duration: e2.duration + r2, frameDurations: s2, getFrame: n3, width: i2, height: a2 };
}
var o = class {
  constructor(e2, r2, i2, a2) {
    this._animation = e2, this._repeatType = i2, this._onFrameData = a2, this._direction = 1, this._currentFrame = 0, this._lastUpdated = n(0), this.timeInFrame = 0, this.timeToFrame = this._animation.frameDurations[this._currentFrame];
    let n3 = 0;
    for (; r2 > n3; ) n3 += this.timeToFrame, this.nextFrame();
    const s2 = this._animation.getFrame(this._currentFrame);
    this._onFrameData(s2);
  }
  nextFrame() {
    if (this._currentFrame += this._direction, this._direction > 0) {
      if (this._currentFrame === this._animation.frameDurations.length) switch (this._repeatType) {
        case "None":
          this._currentFrame -= this._direction;
          break;
        case "Loop":
          this._currentFrame = 0;
          break;
        case "Oscillate":
          this._currentFrame -= this._direction, this._direction = -1;
      }
    } else if (-1 === this._currentFrame) switch (this._repeatType) {
      case "None":
        this._currentFrame -= this._direction;
        break;
      case "Loop":
        this._currentFrame = this._animation.frameDurations.length - 1;
        break;
      case "Oscillate":
        this._currentFrame -= this._direction, this._direction = 1;
    }
    this.timeToFrame = this._animation.frameDurations[this._currentFrame], this.timeInFrame = 0;
    const t = this._animation.getFrame(this._currentFrame);
    this._onFrameData(t);
  }
  update(e2) {
    const r2 = n(e2 - this._lastUpdated);
    this._lastUpdated = e2, this._advance(r2);
  }
  _advance(t) {
    this.timeInFrame += t, this.timeInFrame > this.timeToFrame && this.nextFrame();
  }
};
function m(e2, r2) {
  e2.animationsEnabled && r2?.update(n(e2.time));
}
function h(m2, h2, u, c) {
  let d, { repeatType: f } = h2;
  if (null == f && (f = "Loop"), true === h2.reverseAnimation && (m2 = i(m2)), null != h2.duration && (m2 = a(m2, n(1e3 * h2.duration))), null != h2.repeatDelay) {
    const e2 = 1e3 * h2.repeatDelay;
    "Loop" === f ? m2 = s(m2, n(e2)) : "Oscillate" === f && (m2 = n2(s(m2, n(e2 / 2)), n(e2 / 2)));
  }
  if (null != h2.startTimeOffset) d = n(1e3 * h2.startTimeOffset);
  else if (null != h2.randomizeStartTime) {
    const i2 = 82749913, a2 = null != h2.randomizeStartSeed ? h2.randomizeStartSeed : i2, n3 = e(u, a2);
    d = n(n3 * r(m2));
  } else d = n(0);
  return new o(m2, d, f, c);
}

export {
  m,
  h
};
//# sourceMappingURL=chunk-45IUKBSH.js.map
