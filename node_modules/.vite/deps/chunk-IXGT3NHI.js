import {
  A as A2,
  C as C2,
  E,
  L as L2,
  T,
  a as a3,
  b as b2,
  b2 as b3,
  d as d2,
  f as f4,
  h,
  l as l2,
  m as m4,
  p as p4,
  p2 as p5,
  r as r3,
  s2 as s3,
  t as t2,
  v,
  w,
  y
} from "./chunk-5EUFYFR7.js";
import {
  t
} from "./chunk-JCVDJALY.js";
import {
  et
} from "./chunk-TF5RNCNY.js";
import {
  c as c3
} from "./chunk-2KBTJPSU.js";
import {
  p as p3
} from "./chunk-KY5OS6CK.js";
import {
  u
} from "./chunk-76V6RN4F.js";
import {
  L,
  a,
  i as i2,
  r as r2
} from "./chunk-FAA2FDN5.js";
import {
  B,
  Ye,
  p,
  qe
} from "./chunk-AH42IBBP.js";
import {
  G,
  I,
  J,
  M,
  N,
  S,
  a as a2,
  c as c2,
  d,
  f as f2,
  m as m3,
  o as o3
} from "./chunk-ZGTANDVY.js";
import {
  Z
} from "./chunk-2HGIYEIL.js";
import {
  i,
  o as o2,
  r
} from "./chunk-MDJNYPVI.js";
import {
  o
} from "./chunk-4PXNA4MD.js";
import {
  b
} from "./chunk-647DAMHU.js";
import {
  p as p2
} from "./chunk-ZKNZTIAS.js";
import {
  m as m2
} from "./chunk-QZQPB5XR.js";
import {
  _
} from "./chunk-C3FRY5U4.js";
import {
  l
} from "./chunk-TF6255HN.js";
import {
  f as f3
} from "./chunk-GD4FJL3C.js";
import {
  n as n2,
  x
} from "./chunk-JW6DU3OK.js";
import {
  k
} from "./chunk-W75DBJD7.js";
import {
  b as b4
} from "./chunk-P6IKJIMO.js";
import {
  m
} from "./chunk-XCKT47LJ.js";
import {
  c
} from "./chunk-AXZMNHTN.js";
import {
  f
} from "./chunk-5T3MJDSR.js";
import {
  A
} from "./chunk-NMQNUPE4.js";
import {
  H2 as H,
  s2
} from "./chunk-V2H77UEV.js";
import {
  C,
  n
} from "./chunk-GNMPGHLQ.js";
import {
  s
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/arcade/featureSetCollection.js
var e = class {
  constructor() {
    this.declaredRootClass = "esri.arcade.featureSetCollection", this._layerById = {}, this._layerByName = {};
  }
  add(e3, t4, a4) {
    this._layerById[t4] = a4, this._layerByName[e3] = a4;
  }
  async featureSetByName(e3, t4 = true, a4 = ["*"]) {
    return void 0 === this._layerByName[e3] ? null : this._layerByName[e3];
  }
  async featureSetById(e3, t4 = true, a4 = ["*"]) {
    return void 0 === this._layerById[e3] ? null : this._layerById[e3];
  }
  castToText(e3 = false) {
    return "object, FeatureSetCollection";
  }
};

// node_modules/@arcgis/core/arcade/featureset/actions/AttributeFilter.js
var h2 = class _h extends b3 {
  constructor(e3) {
    super(e3), this.declaredClass = "esri.arcade.featureset.actions.AttributeFilter", this._maxProcessing = 1e3, this._parent = e3.parentfeatureset, e3.whereclause instanceof L ? (this._whereclause = e3.whereclause, this._whereClauseFunction = null) : (this._whereClauseFunction = e3.whereclause, this._whereclause = null);
  }
  _initialiseFeatureSet() {
    null !== this._parent ? (this.fields = this._parent.fields.slice(), this.geometryType = this._parent.geometryType, this.objectIdField = this._parent.objectIdField, this.globalIdField = this._parent.globalIdField, this.spatialReference = this._parent.spatialReference, this.hasM = this._parent.hasM, this.hasZ = this._parent.hasZ, this.typeIdField = this._parent.typeIdField, this.types = this._parent.types, this.subtypeField = this._parent.subtypeField, this.subtypes = this._parent.subtypes) : (this.fields = [], this.typeIdField = "", this.subtypeField = "", this.objectIdField = "", this.globalIdField = "", this.spatialReference = new f({ wkid: 4326 }), this.geometryType = S.point);
  }
  async _getSet(e3) {
    if (null === this._wset) {
      await this._ensureLoaded();
      const t4 = await this._parent._getFilteredSet("", null, this._whereclause, null, e3);
      return this._checkCancelled(e3), null !== this._whereClauseFunction ? this._wset = new t2(t4._candidates.slice().concat(t4._known.slice()), [], t4._ordered, this._clonePageDefinition(t4.pagesDefinition)) : this._wset = new t2(t4._candidates.slice(), t4._known.slice(), t4._ordered, this._clonePageDefinition(t4.pagesDefinition)), this._wset;
    }
    return this._wset;
  }
  _isInFeatureSet(e3) {
    let t4 = this._parent?._isInFeatureSet(e3);
    return 1 === t4 ? t4 : (t4 = this._idstates[e3], void 0 === t4 ? 2 : t4);
  }
  _getFeature(e3, t4, s5) {
    return this._parent._getFeature(e3, t4, s5);
  }
  _getFeatures(e3, t4, s5, i5) {
    return this._parent._getFeatures(e3, t4, s5, i5);
  }
  _featureFromCache(e3) {
    return this._parent._featureFromCache(e3);
  }
  executeWhereClause(e3) {
    return this._whereclause?.testFeature(e3) ?? false;
  }
  async executeWhereClauseDeferred(e3) {
    if (null !== this._whereClauseFunction) {
      const t4 = this._whereClauseFunction(e3);
      return C(t4), t4;
    }
    return this.executeWhereClause(e3);
  }
  async _fetchAndRefineFeatures(e3, t4, i5) {
    const r4 = new t2([], e3, false, null), n5 = Math.min(t4, e3.length);
    if (await this._parent?._getFeatures(r4, -1, n5, i5), this._checkCancelled(i5), null == this._whereClauseFunction) {
      for (let t5 = 0; t5 < n5; t5++) {
        const s5 = this._parent?._featureFromCache(e3[t5]);
        true === this.executeWhereClause(s5) ? this._idstates[e3[t5]] = 0 : this._idstates[e3[t5]] = 1;
      }
      return "success";
    }
    const a4 = [];
    for (let s5 = 0; s5 < n5; s5++) {
      const t5 = this._parent?._featureFromCache(e3[s5]);
      a4.push(await this.executeWhereClauseDeferred(t5));
    }
    for (let s5 = 0; s5 < t4; s5++) true === a4[s5] ? this._idstates[e3[s5]] = 0 : this._idstates[e3[s5]] = 1;
    return "success";
  }
  async _getFilteredSet(e3, t4, i5, n5, a4) {
    null !== this._whereClauseFunction || (null !== i5 ? null !== this._whereclause && (i5 = p4(this._whereclause, i5)) : i5 = this._whereclause), await this._ensureLoaded();
    const l3 = await this._parent._getFilteredSet(e3, t4, i5, n5, a4);
    let h3;
    return this._checkCancelled(a4), h3 = null !== this._whereClauseFunction ? new t2(l3._candidates.slice().concat(l3._known.slice()), [], l3._ordered, this._clonePageDefinition(l3.pagesDefinition)) : new t2(l3._candidates.slice(), l3._known.slice(), l3._ordered, this._clonePageDefinition(l3.pagesDefinition)), h3;
  }
  async _stat(e3, t4, s5, i5, n5, a4, l3) {
    if (null !== this._whereClauseFunction) return null === n5 && "" === s5 && null === i5 ? this._manualStat(e3, t4, a4, l3) : { calculated: false };
    let h3 = this._whereclause;
    null !== n5 && null !== this._whereclause && (h3 = p4(this._whereclause, n5));
    const u2 = await this._parent._stat(e3, t4, s5, i5, h3, a4, l3);
    return false === u2.calculated ? null === n5 && "" === s5 && null === i5 ? this._manualStat(e3, t4, a4, l3) : { calculated: false } : u2;
  }
  async _canDoAggregates(e3, t4, s5, i5, n5) {
    return null === this._whereClauseFunction && (null !== n5 ? null !== this._whereclause && (n5 = p4(this._whereclause, n5)) : n5 = this._whereclause, null !== this._parent && this._parent._canDoAggregates(e3, t4, s5, i5, n5));
  }
  async _getAggregatePagesDataSourceDefinition(t4, s5, i5, n5, a4, l3, h3) {
    if (null === this._parent) throw new r3("NeverReach");
    return null !== a4 ? null !== this._whereclause && (a4 = p4(this._whereclause, a4)) : a4 = this._whereclause, this._parent._getAggregatePagesDataSourceDefinition(t4, s5, i5, n5, a4, l3, h3);
  }
  static registerAction() {
    b3._featuresetFunctions.filter = function(e3) {
      if ("function" == typeof e3) return new _h({ parentfeatureset: this, whereclause: e3 });
      let t4 = null;
      return e3 instanceof L && (t4 = e3), new _h({ parentfeatureset: this, whereclause: t4 });
    };
  }
  getFieldsIndex() {
    return this._parent.getFieldsIndex();
  }
};

// node_modules/@arcgis/core/arcade/featureset/actions/Adapted.js
var E2 = class {
  constructor(e3) {
    this.field = e3, this.sqlRewritable = false;
  }
  postInitialization(e3, t4) {
  }
};
var x2 = class extends E2 {
  constructor(e3) {
    super(e3), this.sqlRewritable = true;
  }
  extractValue(e3) {
    return e3.attributes[this.field.name];
  }
  rewriteSql(e3) {
    return { rewritten: this.sqlRewritable, where: e3 };
  }
};
var D = class extends E2 {
  constructor(e3, t4, r4) {
    super(o3(e3)), this.originalField = e3, this.sqlRewritable = true, this.field.name = t4, this.field.alias = r4;
  }
  rewriteSql(e3, t4) {
    return { rewritten: this.sqlRewritable, where: m4(e3, this.field.name, this.originalField.name, t4.getFieldsIndex()) };
  }
  extractValue(e3) {
    return e3.attributes[this.originalField.name];
  }
};
var _I = class _I extends E2 {
  constructor(e3, t4, r4) {
    super(e3), this.codefield = t4, this.lkp = r4, this.reverseLkp = {};
    for (const s5 in r4) this.reverseLkp[r4[s5]] = s5;
    this.sqlRewritable = true;
  }
  rewriteSql(e3, t4) {
    const r4 = this.evaluateNodeToWhereClause(e3.parseTree, 0, this.field.name, this.codefield instanceof L ? l2(this.codefield, 0) : this.codefield, e3.parameters);
    return r4.includes(_I.BADNESS) ? { rewritten: false, where: e3 } : { rewritten: this.sqlRewritable, where: L.create(r4, { fieldsIndex: t4._parent.getFieldsIndex(), timeZone: t4.dateFieldsTimeZoneDefaultUTC }) };
  }
  evaluateNodeToWhereClause(e3, t4, r4 = null, s5 = null, a4) {
    let h3, c4, d3, p6;
    switch (e3.type) {
      case "interval":
        return C2(this.evaluateNodeToWhereClause(e3.value, t4, r4, s5, a4), e3.qualifier, e3.op);
      case "case-expression": {
        let s6 = " CASE ";
        "simple" === e3.format && (s6 += this.evaluateNodeToWhereClause(e3.operand, t4, r4, _I.BADNESS, a4));
        for (let i5 = 0; i5 < e3.clauses.length; i5++) s6 += " WHEN " + this.evaluateNodeToWhereClause(e3.clauses[i5].operand, t4, r4, _I.BADNESS, a4) + " THEN " + this.evaluateNodeToWhereClause(e3.clauses[i5].value, t4, r4, _I.BADNESS, a4);
        return null !== e3.else && (s6 += " ELSE " + this.evaluateNodeToWhereClause(e3.else, t4, r4, _I.BADNESS, a4)), s6 += " END ", s6;
      }
      case "parameter": {
        const r5 = a4[e3.value.toLowerCase()];
        if ("string" == typeof r5) return "'" + r5.toString().replaceAll("'", "''") + "'";
        if (c2(r5)) return A2(r5, t4);
        if (m3(r5)) return A2(r5, t4);
        if (d(r5)) return E(r5, t4);
        if (a2(r5)) return y(r5, t4);
        if (f2(r5)) return T(r5, t4);
        if (Array.isArray(r5)) {
          const e4 = [];
          for (let s6 = 0; s6 < r5.length; s6++) "string" == typeof r5[s6] ? e4.push("'" + r5[s6].toString().replaceAll("'", "''") + "'") : c2(r5[s6]) || m3(r5[s6]) ? e4.push(A2(r5[s6], t4)) : d(r5[s6]) ? e4.push(E(r5[s6], t4)) : a2(r5[s6]) ? e4.push(y(r5[s6], t4)) : f2(r5[s6]) ? e4.push(T(r5[s6], t4)) : e4.push(r5[s6].toString());
          return e4;
        }
        return r5.toString();
      }
      case "expression-list":
        c4 = [];
        for (const i5 of e3.value) c4.push(this.evaluateNodeToWhereClause(i5, t4, r4, s5, a4));
        return c4;
      case "unary-expression":
        return " ( NOT " + this.evaluateNodeToWhereClause(e3.expr, t4, r4, _I.BADNESS, a4) + " ) ";
      case "binary-expression":
        switch (e3.operator) {
          case "AND":
            return " (" + this.evaluateNodeToWhereClause(e3.left, t4, r4, s5, a4) + " AND " + this.evaluateNodeToWhereClause(e3.right, t4, r4, s5, a4) + ") ";
          case "OR":
            return " (" + this.evaluateNodeToWhereClause(e3.left, t4, r4, s5, a4) + " OR " + this.evaluateNodeToWhereClause(e3.right, t4, r4, s5, a4) + ") ";
          case "IS":
            if ("null" !== e3.right.type) throw new a("UnsupportedIsRhs");
            return " (" + this.evaluateNodeToWhereClause(e3.left, t4, r4, s5, a4) + " IS NULL )";
          case "ISNOT":
            if ("null" !== e3.right.type) throw new a("UnsupportedIsRhs");
            return " (" + this.evaluateNodeToWhereClause(e3.left, t4, r4, s5, a4) + " IS NOT NULL )";
          case "IN":
            if (h3 = [], "expression-list" === e3.right.type) {
              if ("column-reference" === e3.left.type && e3.left.column.toUpperCase() === this.field.name.toUpperCase()) {
                const i5 = [];
                let l3 = true;
                for (const t5 of e3.right.value) {
                  if ("string" !== t5.type) {
                    l3 = false;
                    break;
                  }
                  if (void 0 === this.lkp[t5.value]) {
                    l3 = false;
                    break;
                  }
                  i5.push(this.lkp[t5.value].toString());
                }
                if (l3) return " (" + this.evaluateNodeToWhereClause(e3.left, t4, r4, s5, a4) + " IN (" + i5.join(",") + ")) ";
              }
              return h3 = this.evaluateNodeToWhereClause(e3.right, t4, r4, s5, a4), " (" + this.evaluateNodeToWhereClause(e3.left, t4, r4, s5, a4) + " IN (" + h3.join(",") + ")) ";
            }
            return p6 = this.evaluateNodeToWhereClause(e3.right, t4, r4, s5, a4), Array.isArray(p6) ? " (" + this.evaluateNodeToWhereClause(e3.left, t4, r4, s5, a4) + " IN (" + p6.join(",") + ")) " : " (" + this.evaluateNodeToWhereClause(e3.left, t4, r4, s5, a4) + " IN (" + p6 + ")) ";
          case "NOT IN":
            if (h3 = [], "expression-list" === e3.right.type) {
              if ("column-reference" === e3.left.type && e3.left.column.toUpperCase() === this.field.name.toUpperCase()) {
                const i5 = [];
                let l3 = true;
                for (const t5 of e3.right.value) {
                  if ("string" !== t5.type) {
                    l3 = false;
                    break;
                  }
                  if (void 0 === this.lkp[t5.value]) {
                    l3 = false;
                    break;
                  }
                  i5.push(this.lkp[t5.value].toString());
                }
                if (l3) return " (" + this.evaluateNodeToWhereClause(e3.left, t4, r4, s5, a4) + " NOT IN (" + i5.join(",") + ")) ";
              }
              return h3 = this.evaluateNodeToWhereClause(e3.right, t4, r4, s5, a4), " (" + this.evaluateNodeToWhereClause(e3.left, t4, r4, s5, a4) + " NOT IN (" + h3.join(",") + ")) ";
            }
            return p6 = this.evaluateNodeToWhereClause(e3.right, t4, r4, s5, a4), Array.isArray(p6) ? " (" + this.evaluateNodeToWhereClause(e3.left, t4, r4, s5, a4) + " NOT IN (" + p6.join(",") + ")) " : " (" + this.evaluateNodeToWhereClause(e3.left, t4, r4, s5, a4) + " NOT IN (" + p6 + ")) ";
          case "BETWEEN":
            return d3 = this.evaluateNodeToWhereClause(e3.right, t4, r4, _I.BADNESS, a4), " (" + this.evaluateNodeToWhereClause(e3.left, t4, r4, _I.BADNESS, a4) + " BETWEEN " + d3[0] + " AND " + d3[1] + " ) ";
          case "NOTBETWEEN":
            return d3 = this.evaluateNodeToWhereClause(e3.right, t4, r4, _I.BADNESS, a4), " (" + this.evaluateNodeToWhereClause(e3.left, t4, r4, _I.BADNESS, a4) + " NOT BETWEEN " + d3[0] + " AND " + d3[1] + " ) ";
          case "LIKE":
            return "" !== e3.escape ? " (" + this.evaluateNodeToWhereClause(e3.left, t4, r4, _I.BADNESS, a4) + " LIKE " + this.evaluateNodeToWhereClause(e3.right, t4, r4, _I.BADNESS, a4) + " ESCAPE '" + e3.escape + "') " : " (" + this.evaluateNodeToWhereClause(e3.left, t4, r4, _I.BADNESS, a4) + " LIKE " + this.evaluateNodeToWhereClause(e3.right, t4, r4, _I.BADNESS, a4) + ") ";
          case "NOT LIKE":
            return "" !== e3.escape ? " (" + this.evaluateNodeToWhereClause(e3.left, t4, r4, _I.BADNESS, a4) + " NOT LIKE " + this.evaluateNodeToWhereClause(e3.right, t4, r4, _I.BADNESS, a4) + " ESCAPE '" + e3.escape + "') " : " (" + this.evaluateNodeToWhereClause(e3.left, t4, r4, _I.BADNESS, a4) + " NOT LIKE " + this.evaluateNodeToWhereClause(e3.right, t4, r4, _I.BADNESS, a4) + ") ";
          case "<>":
          case "=":
            if ("column-reference" === e3.left.type && "string" === e3.right.type) {
              if (e3.left.column.toUpperCase() === this.field.name.toUpperCase() && void 0 !== this.lkp[e3.right.value.toString()]) return " (" + s5 + " " + e3.operator + " " + this.lkp[e3.right.value.toString()].toString() + ") ";
            } else if ("column-reference" === e3.right.type && "string" === e3.left.type && e3.right.column.toUpperCase() === this.field.name.toUpperCase()) return " (" + this.lkp[e3.right.value.toString()].toString() + " " + e3.operator + " " + s5 + ") ";
            return " (" + this.evaluateNodeToWhereClause(e3.left, t4, r4, _I.BADNESS, a4) + " " + e3.operator + " " + this.evaluateNodeToWhereClause(e3.right, t4, r4, _I.BADNESS, a4) + ") ";
          case "<":
          case ">":
          case ">=":
          case "<=":
          case "*":
          case "-":
          case "+":
          case "/":
          case "||":
            return " (" + this.evaluateNodeToWhereClause(e3.left, t4, r4, _I.BADNESS, a4) + " " + e3.operator + " " + this.evaluateNodeToWhereClause(e3.right, t4, r4, _I.BADNESS, a4) + ") ";
        }
      case "null":
        return "null";
      case "boolean":
        return true === e3.value ? "1" : "0";
      case "string":
        return "'" + e3.value.toString().replaceAll("'", "''") + "'";
      case "timestamp":
        return `timestamp '${e3.value}'`;
      case "date":
        return `date '${e3.value}'`;
      case "time":
        return `time '${e3.value}'`;
      case "number":
        return e3.value.toString();
      case "current-time":
        return w(e3.mode, t4);
      case "current-user":
        return "CURRENT_USER";
      case "column-reference":
        return r4 && r4.toLowerCase() === e3.column.toLowerCase() ? "(" + s5 + ")" : d2(e3.column);
      case "data-type":
        return e3.value;
      case "function": {
        const s6 = this.evaluateNodeToWhereClause(e3.args, t4, r4, _I.BADNESS, a4);
        return h(e3.name, s6, t4);
      }
    }
    throw new a("UnsupportedSyntax", { node: e3.type });
  }
  extractValue(e3) {
    if (this.codefield instanceof L) {
      const t4 = this.codefield.calculateValueCompiled(e3);
      return this.reverseLkp[L.convertValueToStorageFormat(t4)];
    }
    return this.reverseLkp[e3.attributes[this.codefield]];
  }
};
_I.BADNESS = "_!!!_BAD_LKP_!!!!";
var I2 = _I;
var k2 = class extends E2 {
  constructor(e3, t4) {
    super(e3), this._sql = t4;
  }
  rewriteSql(e3, t4) {
    return { rewritten: true, where: m4(e3, this.field.name, l2(this._sql, 0), t4.getFieldsIndex()) };
  }
  extractValue(e3) {
    return L.convertValueToStorageFormat(this._sql.calculateValueCompiled(e3), this.field.type);
  }
};
var b5 = class extends b3 {
  static findField(e3, t4) {
    for (const r4 of e3) if (r4.name.toLowerCase() === t4.toString().toLowerCase()) return r4;
    return null;
  }
  constructor(e3) {
    super(e3), this._calcFunc = null, this.declaredClass = "esri.arcade.featureset.actions.Adapted", this.adaptedFields = [], this._extraFilter = null, this._extraFilter = e3.extraFilter, this._parent = e3.parentfeatureset, this._maxProcessing = 30, this.adaptedFields = e3.adaptedFields;
  }
  _initialiseFeatureSet() {
    null !== this._parent ? (this.geometryType = this._parent.geometryType, this.objectIdField = this._parent.objectIdField, this.globalIdField = this._parent.globalIdField, this.spatialReference = this._parent.spatialReference, this.hasM = this._parent.hasM, this.hasZ = this._parent.hasZ, this.typeIdField = this._parent.typeIdField, this.types = this._parent.types) : (this.spatialReference = new f({ wkid: 4326 }), this.objectIdField = "", this.globalIdField = "", this.geometryType = S.point, this.typeIdField = "", this.types = null, this.subtypeField = null, this.subtypes = null), this.fields = [];
    for (const e3 of this.adaptedFields) e3.postInitialization(this, this._parent), this.fields.push(e3.field);
  }
  async _getSet(e3) {
    if (null === this._wset) {
      await this._ensureLoaded();
      let t4 = null;
      return t4 = this._extraFilter ? await this._getFilteredSet("", null, null, null, e3) : await this._parent?._getSet(e3), this._checkCancelled(e3), n(t4), this._wset = new t2(t4._candidates.slice(), t4._known.slice(), t4._ordered, this._clonePageDefinition(t4.pagesDefinition)), this._wset;
    }
    return this._wset;
  }
  _isInFeatureSet(e3) {
    return this._parent._isInFeatureSet(e3);
  }
  async _getFeatures(r4, s5, i5, l3) {
    const n5 = [];
    -1 !== s5 && void 0 === this._featureCache[s5] && n5.push(s5);
    const o4 = this._maxQueryRate();
    if (true === this._checkIfNeedToExpandKnownPage(r4, o4)) return await this._expandPagedSet(r4, o4, 0, 0, l3), this._getFeatures(r4, s5, i5, l3);
    let u2 = 0;
    for (let e3 = r4._lastFetchedIndex; e3 < r4._known.length && (u2++, u2 <= i5 && (r4._lastFetchedIndex += 1), !(void 0 === this._featureCache[r4._known[e3]] && (r4._known[e3] !== s5 && n5.push(r4._known[e3]), n5.length >= o4))); e3++) ;
    if (0 === n5.length) return "success";
    r4 = new t2([], n5, r4._ordered, null);
    const h3 = Math.min(n5.length, i5);
    await this._parent?._getFeatures(r4, -1, h3, l3), this._checkCancelled(l3);
    const c4 = [];
    for (let e3 = 0; e3 < h3; e3++) {
      const t4 = this._parent?._featureFromCache(n5[e3]);
      void 0 !== t4 && c4.push({ geometry: t4.geometry, attributes: t4.attributes, id: n5[e3] });
    }
    for (const a4 of c4) {
      const r5 = [];
      for (const e3 of this.adaptedFields) r5[e3.field.name] = e3.extractValue(a4);
      this._featureCache[a4.id] = new _({ attributes: r5, geometry: o2(a4.geometry) });
    }
    return "success";
  }
  async _fetchAndRefineFeatures() {
    throw new r3("NeverReach");
  }
  async _getFilteredSet(e3, t4, r4, s5, i5) {
    let l3 = false;
    const n5 = this._reformulateWithoutAdaptions(r4);
    l3 = n5.cannot, r4 = n5.where;
    let o4 = false;
    if (null !== s5) {
      o4 = true;
      const e4 = [];
      for (const t5 of this.adaptedFields) if (!(t5 instanceof x2) && true === s5.scanForField(t5.field.name)) {
        if (!(t5 instanceof D)) {
          s5 = null, o4 = false;
          break;
        }
        e4.push({ field: t5.field.name, newfield: t5.originalField.name });
      }
      s5 && e4.length > 0 && (s5 = s5.replaceFields(e4));
    }
    null !== r4 ? null !== this._extraFilter && (r4 = p4(this._extraFilter, r4)) : r4 = this._extraFilter, await this._ensureLoaded();
    const u2 = await this._parent._getFilteredSet(e3, t4, r4, s5, i5);
    let h3;
    return this._checkCancelled(i5), h3 = true === l3 ? new t2(u2._candidates.slice().concat(u2._known.slice()), [], true === o4 && u2._ordered, this._clonePageDefinition(u2.pagesDefinition)) : new t2(u2._candidates.slice(), u2._known.slice(), true === o4 && u2._ordered, this._clonePageDefinition(u2.pagesDefinition)), h3;
  }
  _reformulateWithoutAdaptions(e3) {
    const t4 = { cannot: false, where: e3 };
    if (null !== e3) {
      for (const r4 of this.adaptedFields) if (true === b2(e3, r4.field.name)) {
        const s5 = r4.rewriteSql(e3, this);
        if (true !== s5.rewritten) {
          t4.cannot = true, t4.where = null;
          break;
        }
        t4.where = s5.where;
      }
    }
    return t4;
  }
  async _stat(e3, t4, r4, s5, a4, i5, l3) {
    let n5 = false, o4 = this._reformulateWithoutAdaptions(t4);
    if (n5 = o4.cannot, t4 = o4.where, o4 = this._reformulateWithoutAdaptions(a4), n5 = n5 || o4.cannot, null !== (a4 = o4.where) ? null !== this._extraFilter && (a4 = p4(this._extraFilter, a4)) : a4 = this._extraFilter, true === n5) return null === a4 && "" === r4 && null === s5 ? this._manualStat(e3, t4, i5, l3) : { calculated: false };
    const u2 = await this._parent._stat(e3, t4, r4, s5, a4, i5, l3);
    return false === u2.calculated ? null === a4 && "" === r4 && null === s5 ? this._manualStat(e3, t4, i5, l3) : { calculated: false } : u2;
  }
  async _canDoAggregates(e3, t4, r4, s5, a4) {
    if (null === this._parent) return false;
    for (let n5 = 0; n5 < e3.length; n5++) for (const t5 of this.adaptedFields) if (e3[n5].toLowerCase() === t5.field.name.toLowerCase() && !(t5 instanceof x2)) return false;
    const i5 = [];
    for (let n5 = 0; n5 < t4.length; n5++) {
      const e4 = t4[n5];
      if (null !== e4.workingexpr) {
        const t5 = this._reformulateWithoutAdaptions(e4.workingexpr);
        if (t5.cannot) return false;
        const r5 = e4.clone();
        r5.workingexpr = t5.where, i5.push(r5);
      } else i5.push(e4);
    }
    const l3 = this._reformulateWithoutAdaptions(a4);
    return !l3.cannot && (null !== (a4 = l3.where) ? null !== this._extraFilter && (a4 = p4(this._extraFilter, a4)) : a4 = this._extraFilter, this._parent._canDoAggregates(e3, i5, r4, s5, a4));
  }
  async _getAggregatePagesDataSourceDefinition(e3, t4, s5, a4, i5, l3, n5) {
    if (null === this._parent) throw new r3("NeverReach");
    const o4 = [];
    for (let h3 = 0; h3 < t4.length; h3++) {
      const e4 = t4[h3];
      if (null !== e4.workingexpr) {
        const t5 = this._reformulateWithoutAdaptions(e4.workingexpr);
        if (t5.cannot) throw new r3("NeverReach");
        const s6 = e4.clone();
        s6.workingexpr = t5.where, o4.push(s6);
      } else o4.push(e4);
    }
    const u2 = this._reformulateWithoutAdaptions(i5);
    if (u2.cannot) throw new r3("NeverReach");
    return null !== (i5 = u2.where) ? null !== this._extraFilter && (i5 = p4(this._extraFilter, i5)) : i5 = this._extraFilter, this._parent._getAggregatePagesDataSourceDefinition(e3, o4, s5, a4, i5, l3, n5);
  }
};

// node_modules/@arcgis/core/arcade/featureset/support/OrderbyClause.js
function t3(t4, e3) {
  return t4 === e3 ? 0 : null === t4 ? -1 : null === e3 ? 1 : t4 < e3 ? -1 : 1;
}
var e2 = class _e {
  constructor(t4) {
    const e3 = t4.split(",");
    this._fields = [], this._directions = [];
    for (let s5 = 0; s5 < e3.length; s5++) {
      const t5 = e3[s5].match(/\S+/g);
      this._fields.push(t5[0]), 2 === t5.length ? "asc" === t5[1].toLowerCase() ? this._directions.push(1) : this._directions.push(0) : this._directions.push(1);
    }
  }
  constructClause() {
    let t4 = "";
    for (let e3 = 0; e3 < this._fields.length; e3++) 0 !== e3 && (t4 += ","), t4 += this._fields[e3], 1 === this._directions[e3] ? t4 += " ASC" : t4 += " DESC";
    return t4;
  }
  order(e3) {
    e3.sort((e4, s5) => {
      for (let i5 = 0; i5 < this._fields.length; i5++) {
        const r4 = this.featureValue(e4.feature, this._fields[i5], i5), l3 = this.featureValue(s5.feature, this._fields[i5], i5);
        let o4 = 0;
        if (o4 = 1 === this._directions[i5] ? t3(r4, l3) : -1 * t3(r4, l3), 0 !== o4) return o4;
      }
      return 0;
    });
  }
  scanForField(t4) {
    for (let e3 = 0; e3 < this._fields.length; e3++) if (this._fields[e3].toLowerCase().trim() === t4.toLowerCase().trim()) return true;
    return false;
  }
  replaceFields(t4) {
    let s5 = "";
    for (let e3 = 0; e3 < this._fields.length; e3++) {
      0 !== e3 && (s5 += ",");
      let i5 = this._fields[e3];
      for (const e4 of t4) if (i5.toLowerCase() === e4.field.toLowerCase()) {
        i5 = e4.newfield;
        break;
      }
      s5 += i5, 1 === this._directions[e3] ? s5 += " ASC" : s5 += " DESC";
    }
    return new _e(s5);
  }
  featureValue(t4, e3, s5) {
    const i5 = t4.attributes[e3];
    if (void 0 !== i5) return i5;
    for (const r4 in t4.attributes) if (e3.toLowerCase() === r4.toLowerCase()) return this._fields[s5] = r4, t4.attributes[r4];
    return null;
  }
};

// node_modules/@arcgis/core/arcade/featureset/actions/OrderBy.js
var i3 = class _i extends b3 {
  constructor(e3) {
    super(e3), this._orderbyclause = null, this.declaredClass = "esri.arcade.featureset.actions.OrderBy", this._maxProcessing = 100, this._orderbyclause = e3.orderbyclause, this._parent = e3.parentfeatureset;
  }
  async _getSet(e3) {
    if (null === this._wset) {
      await this._ensureLoaded();
      const t4 = await this._getFilteredSet("", null, null, this._orderbyclause, e3);
      return this._checkCancelled(e3), this._wset = t4, this._wset;
    }
    return this._wset;
  }
  async manualOrderSet(e3, t4) {
    const r4 = await this.getIdColumnDictionary(e3, [], -1, t4);
    this._orderbyclause?.order(r4);
    const s5 = new t2([], [], true, null);
    for (let n5 = 0; n5 < r4.length; n5++) s5._known.push(r4[n5].id);
    return s5;
  }
  async getIdColumnDictionary(t4, r4, n5, s5) {
    if (n5 < t4._known.length - 1) {
      const i5 = this._maxQueryRate();
      if ("GETPAGES" === t4._known[n5 + 1]) return await Ye(this._parent._expandPagedSet(t4, i5, 0, 0, s5)), this.getIdColumnDictionary(t4, r4, n5, s5);
      let a4 = n5 + 1;
      const o4 = [];
      for (; a4 < t4._known.length && "GETPAGES" !== t4._known[a4]; ) o4.push(t4._known[a4]), a4++;
      n5 += o4.length;
      const u2 = await Ye(this._parent._getFeatureBatch(o4, s5));
      this._checkCancelled(s5);
      for (const e3 of u2) r4.push({ id: e3.attributes[this.objectIdField], feature: e3 });
      return this.getIdColumnDictionary(t4, r4, n5, s5);
    }
    return t4._candidates.length > 0 ? (await Ye(this._refineSetBlock(t4, this._maxProcessingRate(), s5)), this._checkCancelled(s5), this.getIdColumnDictionary(t4, r4, n5, s5)) : r4;
  }
  _isInFeatureSet(e3) {
    return this._parent._isInFeatureSet(e3);
  }
  _getFeatures(e3, t4, r4, n5) {
    return this._parent._getFeatures(e3, t4, r4, n5);
  }
  _featureFromCache(e3) {
    if (void 0 === this._featureCache[e3]) {
      const t4 = this._parent._featureFromCache(e3);
      if (void 0 === t4) return;
      return null === t4 ? null : (this._featureCache[e3] = t4, t4);
    }
    return this._featureCache[e3];
  }
  async _fetchAndRefineFeatures() {
    throw new r3("NeverReach");
  }
  async _getFilteredSet(e3, t4, r4, s5, i5) {
    await this._ensureLoaded();
    const a4 = await this._parent._getFilteredSet(e3, t4, r4, null === s5 ? this._orderbyclause : s5, i5);
    this._checkCancelled(i5);
    const o4 = new t2(a4._candidates.slice(), a4._known.slice(), a4._ordered, this._clonePageDefinition(a4.pagesDefinition));
    let u2 = true;
    if (a4._candidates.length > 0 && (u2 = false), false === o4._ordered) {
      let e4 = await this.manualOrderSet(o4, i5);
      return false === u2 && (null === t4 && null === r4 || (e4 = new t2(e4._candidates.slice().concat(e4._known.slice()), [], e4._ordered, this._clonePageDefinition(e4.pagesDefinition)))), e4;
    }
    return o4;
  }
  static registerAction() {
    b3._featuresetFunctions.orderBy = function(e3) {
      return "" === e3 ? this : new _i({ parentfeatureset: this, orderbyclause: new e2(e3) });
    };
  }
  getFieldsIndex() {
    return this._parent.getFieldsIndex();
  }
};

// node_modules/@arcgis/core/arcade/featureset/support/StatsField.js
function n3(n5) {
  if ("function" === n5.parseTree.type) {
    if (0 === n5.parseTree.args.value.length) return { name: n5.parseTree.name, expr: null };
    if (n5.parseTree.args.value.length > 1) throw new a("MissingStatisticParameters");
    const i5 = L.create(f4(n5.parseTree.args.value[0], 0, n5.parameters), { fieldsIndex: n5.fieldsIndex, timeZone: n5.timeZone, currentUser: n5.currentUser });
    return { name: n5.parseTree.name, expr: i5 };
  }
  return null;
}
var i4 = class _i {
  constructor() {
    this.field = "", this.tofieldname = "", this.typeofstat = "MIN", this.workingexpr = null;
  }
  clone() {
    const e3 = new _i();
    return e3.field = this.field, e3.tofieldname = this.tofieldname, e3.typeofstat = this.typeofstat, e3.workingexpr = this.workingexpr, e3;
  }
  static parseStatField(e3, s5, a4, o4) {
    const l3 = new _i();
    l3.field = e3;
    const u2 = L.create(s5, { fieldsIndex: a4, timeZone: o4 }), f5 = n3(u2);
    if (null === f5) throw new a("UnsupportedSqlFunction", { function: "" });
    const p6 = f5.name.toUpperCase().trim();
    if ("MIN" === p6) {
      if (l3.typeofstat = "MIN", l3.workingexpr = f5.expr, null === u2) throw new a("InvalidFunctionParameters", { function: "min" });
    } else if ("MAX" === p6) {
      if (l3.typeofstat = "MAX", l3.workingexpr = f5.expr, null === u2) throw new a("InvalidFunctionParameters", { function: "max" });
    } else if ("COUNT" === p6) l3.typeofstat = "COUNT", l3.workingexpr = f5.expr;
    else if ("STDEV" === p6) {
      if (l3.typeofstat = "STDDEV", l3.workingexpr = f5.expr, null === u2) throw new a("InvalidFunctionParameters", { function: "stdev" });
    } else if ("SUM" === p6) {
      if (l3.typeofstat = "SUM", l3.workingexpr = f5.expr, null === u2) throw new a("InvalidFunctionParameters", { function: "sum" });
    } else if ("MEAN" === p6) {
      if (l3.typeofstat = "AVG", l3.workingexpr = f5.expr, null === u2) throw new a("InvalidFunctionParameters", { function: p6 });
    } else if ("AVG" === p6) {
      if (l3.typeofstat = "AVG", l3.workingexpr = f5.expr, null === u2) throw new a("InvalidFunctionParameters", { function: "avg" });
    } else {
      if ("VAR" !== p6) throw new a("UnsupportedSqlFunction", { function: p6 });
      if (l3.typeofstat = "VAR", l3.workingexpr = f5.expr, null === u2) throw new a("InvalidFunctionParameters", { function: "var" });
    }
    return l3;
  }
  toStatisticsName() {
    switch (this.typeofstat.toUpperCase()) {
      case "MIN":
        return "min";
      case "MAX":
        return "max";
      case "SUM":
        return "sum";
      case "COUNT":
      default:
        return "count";
      case "VAR":
        return "var";
      case "STDDEV":
        return "stddev";
      case "AVG":
        return "avg";
    }
  }
};

// node_modules/@arcgis/core/arcade/featureset/actions/GroupBy.js
var C3 = new o(["MIN", "MAX", "VAR", "STDDEV", "COUNT", "SUM", "AVG"], [["VARIANCE", "VAR"], ["AVERAGE", "AVG"], ["MEAN", "AVG"], ["STDEV", "STDDEV"]]);
var T2 = class _T extends b3 {
  constructor(e3) {
    super(e3), this._decodedStatsfield = [], this._decodedGroupbyfield = [], this._candosimplegroupby = true, this.phsyicalgroupbyfields = [], this.objectIdField = "ROW__ID", this._internalObjectIdField = "ROW__ID", this._adaptedFields = [], this.declaredClass = "esri.arcade.featureset.actions.Aggregate", this._uniqueIds = 1, this._maxQuery = 10, this._maxProcessing = 10, this._parent = e3.parentfeatureset, this._config = e3;
  }
  isTable() {
    return true;
  }
  async _getSet(e3) {
    if (null === this._wset) {
      const t4 = await this._getFilteredSet("", null, null, null, e3);
      return this._wset = t4, this._wset;
    }
    return this._wset;
  }
  _isInFeatureSet() {
    return 0;
  }
  _nextUniqueName(e3) {
    for (; 1 === e3["T" + this._uniqueIds.toString()]; ) this._uniqueIds++;
    const t4 = "T" + this._uniqueIds.toString();
    return e3[t4] = 1, t4;
  }
  _convertToEsriFieldType(e3) {
    return e3;
  }
  _initialiseFeatureSet() {
    const e3 = {};
    let t4 = false, i5 = 1;
    const r4 = this._parent ? this._parent.getFieldsIndex() : new Z([]);
    for (this.objectIdField = "ROW__ID", this.globalIdField = ""; false === t4; ) {
      let e4 = false;
      for (let t5 = 0; t5 < this._config.groupbyfields.length; t5++) if (this._config.groupbyfields[t5].name.toLowerCase() === this.objectIdField.toLowerCase()) {
        e4 = true;
        break;
      }
      if (false === e4) {
        for (let t5 = 0; t5 < this._config.statsfields.length; t5++) if (this._config.statsfields[t5].name.toLowerCase() === this.objectIdField.toLowerCase()) {
          e4 = true;
          break;
        }
      }
      false === e4 ? t4 = true : (this.objectIdField = "ROW__ID" + i5.toString(), i5++);
    }
    for (const s5 of this._config.statsfields) {
      const e4 = new i4();
      e4.field = s5.name, e4.tofieldname = s5.name, e4.workingexpr = s5.expression instanceof L ? s5.expression : L.create(s5.expression, { fieldsIndex: r4, timeZone: this.dateFieldsTimeZoneDefaultUTC }), e4.typeofstat = C3.lookup(s5.statistic) ?? "COUNT", this._decodedStatsfield.push(e4);
    }
    this._decodedGroupbyfield = [];
    for (const s5 of this._config.groupbyfields) {
      const e4 = { name: s5.name, singlefield: null, tofieldname: s5.name, expression: s5.expression instanceof L ? s5.expression : L.create(s5.expression, { fieldsIndex: r4, timeZone: this.dateFieldsTimeZoneDefaultUTC }), sqlType: null };
      this._decodedGroupbyfield.push(e4);
    }
    if (null !== this._parent) {
      this.geometryType = this._parent.geometryType, this.spatialReference = this._parent.spatialReference, this.hasM = this._parent.hasM, this.hasZ = this._parent.hasZ, this.typeIdField = "";
      for (const t5 of this._parent.fields) e3[t5.name.toUpperCase()] = 1;
      this.types = null, this.subtypes = null, this.subtypeField = "";
    } else this.geometryType = S.point, this.typeIdField = "", this.types = null, this.subtypes = null, this.subtypeField = "", this.spatialReference = new f({ wkid: 4326 });
    this.fields = [];
    const a4 = new i4();
    a4.field = this._nextUniqueName(e3), a4.tofieldname = this.objectIdField, a4.workingexpr = L.create(this._parent.objectIdField, { fieldsIndex: this._parent.getFieldsIndex(), timeZone: this.dateFieldsTimeZoneDefaultUTC }), a4.typeofstat = "MIN", this._decodedStatsfield.push(a4);
    for (const n5 of this._decodedGroupbyfield) {
      const t5 = new m2();
      if (n5.name = this._nextUniqueName(e3), t5.name = n5.tofieldname, t5.alias = t5.name, v(n5.expression)) {
        const e4 = this._parent.getField(l2(n5.expression, 0));
        if (!e4) throw new r3("AggregationFieldNotFound");
        n5.name = e4.name, n5.singlefield = e4.name, this.phsyicalgroupbyfields.push(e4.name), t5.type = e4.type, n5.sqlType = e4.type;
      } else {
        t5.type = this._convertToEsriFieldType(L2(n5.expression, this._parent.fields));
        const e4 = new m2();
        e4.name = n5.name, e4.alias = e4.name, this.phsyicalgroupbyfields.push(n5.name), this._adaptedFields.push(new k2(e4, n5.expression)), this._candosimplegroupby = false, n5.sqlType = t5.type;
      }
      this.fields.push(t5);
    }
    if (this._adaptedFields.length > 0) for (const s5 of this._parent.fields) this._adaptedFields.push(new x2(s5));
    for (let s5 = 0; s5 < this._decodedStatsfield.length; s5++) {
      const t5 = new m2();
      let i6 = null;
      const n5 = this._decodedStatsfield[s5];
      n5.field = this._nextUniqueName(e3), n5.tofieldname === this.objectIdField && (this._internalObjectIdField = n5.field), t5.name = n5.tofieldname, t5.alias = t5.name;
      const r5 = null !== n5.workingexpr && v(n5.workingexpr) ? l2(n5.workingexpr, 0) : "";
      switch (this._decodedStatsfield[s5].typeofstat) {
        case "SUM":
          if ("" !== r5) {
            if (i6 = this._parent.getField(r5), !i6) throw new r3("AggregationFieldNotFound");
            t5.type = i6.type;
          } else t5.type = "double";
          break;
        case "MIN":
        case "MAX":
          if ("" !== r5) {
            if (i6 = this._parent.getField(r5), !i6) throw new r3("AggregationFieldNotFound");
            t5.type = i6.type;
          } else t5.type = "double";
          break;
        case "COUNT":
          t5.type = "integer";
          break;
        case "STDDEV":
        case "VAR":
        case "AVG":
          if ("" !== r5 && (i6 = this._parent.getField(r5), !i6)) throw new r3("AggregationFieldNotFound");
          t5.type = "double";
      }
      this.fields.push(t5);
    }
  }
  async _canDoAggregates() {
    return false;
  }
  async _getFeatures(e3, t4, i5, s5) {
    -1 !== t4 && this._featureCache[t4];
    const n5 = this._maxQuery;
    return true === this._checkIfNeedToExpandKnownPage(e3, n5) ? (await this._expandPagedSet(e3, n5, 0, 0, s5), this._getFeatures(e3, t4, i5, s5)) : "success";
  }
  async _getFilteredSet(e3, t4, i5, s5, n5) {
    if ("" !== e3) return new t2([], [], true, null);
    let l3 = null;
    const d3 = { ordered: false, nowhereclause: false };
    if (await this._ensureLoaded(), null !== i5) {
      for (let r4 = 0; r4 < this._decodedStatsfield.length; r4++) if (true === b2(i5, this._decodedStatsfield[r4].tofieldname)) {
        d3.nowhereclause = true, i5 = null;
        break;
      }
    }
    if (null !== s5) {
      d3.ordered = true;
      for (let e4 = 0; e4 < this._decodedStatsfield.length; e4++) if (true === s5.scanForField(this._decodedStatsfield[e4].tofieldname)) {
        s5 = null, d3.ordered = false;
        break;
      }
      if (null !== s5) {
        for (const e4 of this._decodedGroupbyfield) if (null === e4.singlefield && true === s5.scanForField(e4.tofieldname)) {
          s5 = null, d3.ordered = false;
          break;
        }
      }
    }
    if (false !== this._candosimplegroupby && await this._parent._canDoAggregates(this.phsyicalgroupbyfields, this._decodedStatsfield, "", null, null)) {
      let e4 = null;
      i5 && (e4 = this._reformulateWhereClauseWithoutGroupByFields(i5));
      let t5 = null;
      s5 && (t5 = this._reformulateOrderClauseWithoutGroupByFields(s5));
      const r4 = await this._parent._getAggregatePagesDataSourceDefinition(this.phsyicalgroupbyfields, this._decodedStatsfield, "", null, e4, t5, this._internalObjectIdField);
      return this._checkCancelled(n5), l3 = true === d3.nowhereclause ? new t2(r4._candidates.slice().concat(r4._known.slice()), [], true === d3.ordered && r4._ordered, this._clonePageDefinition(r4.pagesDefinition)) : new t2(r4._candidates.slice(), r4._known.slice(), true === d3.ordered && r4._ordered, this._clonePageDefinition(r4.pagesDefinition)), l3;
    }
    let p6 = this._parent;
    if (this._adaptedFields.length > 0 && (p6 = new b5({ parentfeatureset: this._parent, adaptedFields: this._adaptedFields, extraFilter: null })), true === d3.nowhereclause) l3 = new t2(["GETPAGES"], [], false, { aggregatefeaturesetpagedefinition: true, resultOffset: 0, resultRecordCount: this._maxQuery, internal: { fullyResolved: false, workingItem: null, type: "manual", iterator: null, set: [], subfeatureset: new i3({ parentfeatureset: p6, orderbyclause: new e2(this.phsyicalgroupbyfields.join(",") + "," + this._parent.objectIdField + " ASC") }) } });
    else {
      let e4 = p6;
      if (null !== i5) {
        let t5 = null;
        i5 && (t5 = this._reformulateWhereClauseWithoutGroupByFields(i5)), e4 = new h2({ parentfeatureset: e4, whereclause: t5 });
      }
      l3 = new t2(["GETPAGES"], [], false, { aggregatefeaturesetpagedefinition: true, resultOffset: 0, resultRecordCount: this._maxQuery, internal: { fullyResolved: false, workingItem: null, type: "manual", iterator: null, set: [], subfeatureset: new i3({ parentfeatureset: e4, orderbyclause: new e2(this.phsyicalgroupbyfields.join(",") + "," + this._parent.objectIdField + " ASC") }) } });
    }
    return l3;
  }
  _reformulateWhereClauseWithoutStatsFields(e3) {
    for (const t4 of this._decodedStatsfield) e3 = m4(e3, t4.tofieldname, l2(t4.workingexpr, 0), this._parent.getFieldsIndex());
    return e3;
  }
  _reformulateWhereClauseWithoutGroupByFields(e3) {
    for (const t4 of this._decodedGroupbyfield) t4.tofieldname !== t4.name && (e3 = m4(e3, t4.tofieldname, l2(t4.expression, 0), this._parent.getFieldsIndex()));
    return e3;
  }
  _reformulateOrderClauseWithoutGroupByFields(e3) {
    const t4 = [];
    for (const i5 of this._decodedGroupbyfield) i5.tofieldname !== i5.name && t4.push({ field: i5.tofieldname, newfield: i5.name });
    return t4.length > 0 ? e3.replaceFields(t4) : e3;
  }
  _clonePageDefinition(e3) {
    return null === e3 ? null : true === e3.aggregatefeaturesetpagedefinition ? { aggregatefeaturesetpagedefinition: true, resultRecordCount: e3.resultRecordCount, resultOffset: e3.resultOffset, internal: e3.internal } : this._parent._clonePageDefinition(e3);
  }
  async _refineSetBlock(e3, t4, i5) {
    if (true === this._checkIfNeedToExpandCandidatePage(e3, this._maxQuery)) return await this._expandPagedSet(e3, this._maxQuery, 0, 0, i5), this._refineSetBlock(e3, t4, i5);
    this._checkCancelled(i5);
    const s5 = e3._candidates.length;
    this._refineKnowns(e3, t4);
    e3._candidates.length;
    return e3._candidates.length, e3;
  }
  _expandPagedSet(e3, t4, i5, s5, n5) {
    return this._expandPagedSetFeatureSet(e3, t4, i5, s5, n5);
  }
  async _getPhysicalPage(t4, i5, s5) {
    if (true === t4.pagesDefinition.aggregatefeaturesetpagedefinition) return this._sequentialGetPhysicalItem(t4, t4.pagesDefinition.resultRecordCount, s5, []);
    const n5 = await this._getAgregagtePhysicalPage(t4, i5, s5);
    for (const r4 of n5) {
      const t5 = { geometry: r4.geometry, attributes: {} }, i6 = {};
      for (const e3 in r4.attributes) i6[e3.toLowerCase()] = r4.attributes[e3];
      for (const e3 of this._decodedGroupbyfield) t5.attributes[e3.tofieldname] = i6[e3.name.toLowerCase()];
      for (const e3 of this._decodedStatsfield) t5.attributes[e3.tofieldname] = i6[e3.field.toLowerCase()];
      this._featureCache[t5.attributes[this.objectIdField]] = new _(t5);
    }
    return n5.length;
  }
  _sequentialGetPhysicalItem(e3, t4, i5, s5) {
    return new Promise((n5, r4) => {
      null === e3.pagesDefinition.internal.iterator && (e3.pagesDefinition.internal.iterator = e3.pagesDefinition.internal.subfeatureset.iterator(i5)), true === e3.pagesDefinition.internal.fullyResolved || 0 === t4 ? n5(s5.length) : this._nextAggregateItem(e3, t4, i5, s5, (r5) => {
        null === r5 ? n5(s5.length) : (t4 -= 1, n5(this._sequentialGetPhysicalItem(e3, t4, i5, s5)));
      }, r4);
    });
  }
  _nextAggregateItem(e3, t4, s5, n5, r4, a4) {
    try {
      Ye(e3.pagesDefinition.internal.iterator.next()).then((i5) => {
        if (null === i5) if (null !== e3.pagesDefinition.internal.workingItem) {
          const t5 = this._calculateAndAppendAggregateItem(e3.pagesDefinition.internal.workingItem);
          n5.push(t5), e3.pagesDefinition.internal.workingItem = null, e3.pagesDefinition.internal.set.push(t5.attributes[this.objectIdField]), e3.pagesDefinition.internal.fullyResolved = true, r4(null);
        } else e3.pagesDefinition.internal.fullyResolved = true, r4(null);
        else {
          const o4 = this._generateAggregateHash(i5);
          if (null === e3.pagesDefinition.internal.workingItem) e3.pagesDefinition.internal.workingItem = { features: [i5], id: o4 };
          else {
            if (o4 !== e3.pagesDefinition.internal.workingItem.id) {
              const s6 = this._calculateAndAppendAggregateItem(e3.pagesDefinition.internal.workingItem);
              return n5.push(s6), e3.pagesDefinition.internal.workingItem = null, e3.pagesDefinition.internal.set.push(s6.attributes[this.objectIdField]), t4 -= 1, e3.pagesDefinition.internal.workingItem = { features: [i5], id: o4 }, void r4(s6);
            }
            e3.pagesDefinition.internal.workingItem.features.push(i5);
          }
          this._nextAggregateItem(e3, t4, s5, n5, r4, a4);
        }
      }, a4);
    } catch (o4) {
      a4(o4);
    }
  }
  _calculateFieldStat(e3, t4, i5) {
    const s5 = [];
    for (const n5 of e3.features) if (null !== t4.workingexpr) {
      const e4 = t4.workingexpr.calculateValue(n5);
      null !== e4 && (e4 instanceof i || e4 instanceof r ? s5.push(e4.toNumber()) : e4 instanceof i2 ? s5.push(e4.toMilliseconds()) : s5.push(e4));
    } else s5.push(null);
    i5.attributes[t4.tofieldname] = r2(t4.typeofstat, [s5]);
  }
  _calculateAndAppendAggregateItem(t4) {
    const i5 = { attributes: {}, geometry: null };
    for (const e3 of this._decodedGroupbyfield) {
      const s6 = e3.singlefield ? t4.features[0].attributes[e3.singlefield] : L.convertValueToStorageFormat(e3.expression.calculateValue(t4.features[0]), e3.sqlType);
      i5.attributes[e3.tofieldname] = s6;
    }
    for (const e3 of this._decodedStatsfield) this._calculateFieldStat(t4, e3, i5);
    const s5 = [];
    for (let e3 = 0; e3 < this._decodedStatsfield.length; e3++) s5.push(this._calculateFieldStat(t4, this._decodedStatsfield[e3], i5));
    return this._featureCache[i5.attributes[this.objectIdField]] = new _({ attributes: i5.attributes, geometry: i5.geometry }), i5;
  }
  _generateAggregateHash(e3) {
    let t4 = "";
    for (const i5 of this._decodedGroupbyfield) {
      const s5 = i5.singlefield ? e3.attributes[i5.singlefield] : i5.expression.calculateValue(e3);
      t4 += null == s5 ? ":" : ":" + s5.toString();
    }
    return x(t4, n2.String);
  }
  async _stat() {
    return { calculated: false };
  }
  async getFeatureByObjectId() {
    return null;
  }
  static registerAction() {
    b3._featuresetFunctions.groupby = function(e3, t4) {
      return new _T({ parentfeatureset: this, groupbyfields: e3, statsfields: t4 });
    };
  }
};

// node_modules/@arcgis/core/arcade/featureset/actions/Top.js
var s4 = class _s extends b3 {
  constructor(t4) {
    super(t4), this._topnum = 0, this.declaredClass = "esri.arcade.featureset.actions.Top", this._countedin = 0, this._maxProcessing = 100, this._topnum = t4.topnum, this._parent = t4.parentfeatureset;
  }
  async _getSet(t4) {
    if (null === this._wset) {
      await this._ensureLoaded();
      const e3 = await this._parent._getSet(t4);
      return this._wset = new t2(e3._candidates.slice(), e3._known.slice(), false, this._clonePageDefinition(e3.pagesDefinition)), this._setKnownLength(this._wset) > this._topnum && (this._wset._known = this._wset._known.slice(0, this._topnum)), this._setKnownLength(this._wset) >= this._topnum && (this._wset._candidates = []), this._wset;
    }
    return this._wset;
  }
  _setKnownLength(t4) {
    return t4._known.length > 0 && "GETPAGES" === t4._known[t4._known.length - 1] ? t4._known.length - 1 : t4._known.length;
  }
  _isInFeatureSet(t4) {
    const e3 = this._parent._isInFeatureSet(t4);
    if (1 === e3) return e3;
    const n5 = this._idstates[t4];
    return 0 === n5 || 1 === n5 ? n5 : 0 === e3 && void 0 === n5 ? this._countedin < this._topnum ? (this._idstates[t4] = 0, this._countedin++, 0) : (this._idstates[t4] = 1, 1) : 2;
  }
  async _expandPagedSet(e3, n5, s5, i5, a4) {
    if (null === this._parent) throw new r3("NotImplemented");
    if (n5 > this._topnum && (n5 = this._topnum), this._countedin >= this._topnum && e3.pagesDefinition.internal.set.length <= e3.pagesDefinition.resultOffset) {
      let t4 = e3._known.length;
      return t4 > 0 && "GETPAGES" === e3._known[t4 - 1] && (e3._known.length = t4 - 1), t4 = e3._candidates.length, t4 > 0 && "GETPAGES" === e3._candidates[t4 - 1] && (e3._candidates.length = t4 - 1), "success";
    }
    const _2 = await this._parent._expandPagedSet(e3, n5, s5, i5, a4);
    return this._setKnownLength(e3) > this._topnum && (e3._known.length = this._topnum), this._setKnownLength(e3) >= this._topnum && (e3._candidates.length = 0), _2;
  }
  async _getFeatures(t4, e3, s5, i5) {
    const a4 = [], _2 = this._maxQueryRate();
    if (true === this._checkIfNeedToExpandKnownPage(t4, _2)) return await this._expandPagedSet(t4, _2, 0, 0, i5), this._getFeatures(t4, e3, s5, i5);
    -1 !== e3 && void 0 === this._featureCache[e3] && a4.push(e3);
    let o4 = 0;
    for (let n5 = t4._lastFetchedIndex; n5 < t4._known.length && (o4++, o4 <= s5 && (t4._lastFetchedIndex += 1), !(void 0 === this._featureCache[t4._known[n5]] && (t4._known[n5] !== e3 && a4.push(t4._known[n5]), a4.length > _2))); n5++) ;
    if (0 === a4.length) return "success";
    const h3 = new t2([], a4, false, null), r4 = Math.min(a4.length, s5);
    await this._parent._getFeatures(h3, -1, r4, i5);
    for (let n5 = 0; n5 < r4; n5++) {
      const t5 = this._parent._featureFromCache(a4[n5]);
      void 0 !== t5 && (this._featureCache[a4[n5]] = t5);
    }
    return "success";
  }
  async _getFilteredSet(t4, e3, s5, i5, a4) {
    await this._ensureLoaded();
    const _2 = await this._getSet(a4);
    return new t2(_2._candidates.slice().concat(_2._known.slice()), [], false, this._clonePageDefinition(_2.pagesDefinition));
  }
  _refineKnowns(t4, e3) {
    let n5 = 0, s5 = null;
    const i5 = [];
    for (let a4 = 0; a4 < t4._candidates.length; a4++) {
      const _2 = this._isInFeatureSet(t4._candidates[a4]);
      if (0 === _2) {
        if (t4._known.push(t4._candidates[a4]), n5 += 1, null === s5 ? s5 = { start: a4, end: a4 } : s5.end === a4 - 1 ? s5.end = a4 : (i5.push(s5), s5 = { start: a4, end: a4 }), t4._known.length >= this._topnum) break;
      } else if (1 === _2) null === s5 ? s5 = { start: a4, end: a4 } : s5.end === a4 - 1 ? s5.end = a4 : (i5.push(s5), s5 = { start: a4, end: a4 }), n5 += 1;
      else if (2 === _2) break;
      if (n5 >= e3) break;
    }
    null !== s5 && i5.push(s5);
    for (let a4 = i5.length - 1; a4 >= 0; a4--) t4._candidates.splice(i5[a4].start, i5[a4].end - i5[a4].start + 1);
    this._setKnownLength(t4) > this._topnum && (t4._known = t4._known.slice(0, this._topnum)), this._setKnownLength(t4) >= this._topnum && (t4._candidates = []);
  }
  async _stat() {
    return { calculated: false };
  }
  async _canDoAggregates() {
    return false;
  }
  static registerAction() {
    b3._featuresetFunctions.top = function(t4) {
      return new _s({ parentfeatureset: this, topnum: t4 });
    };
  }
  getFieldsIndex() {
    return this._parent.getFieldsIndex();
  }
};

// node_modules/@arcgis/core/arcade/featureset/sources/FeatureLayerDynamic.js
function D2(e3) {
  if (0 === e3.length) throw new r3("NeverReach");
  const t4 = [];
  for (let i5 = 0; i5 < e3.length; i5++) {
    const r5 = e3[i5], s5 = [`"${r5.name.replaceAll('"', '""')}" ${r5.asc ? ">" : "<"} @last_${i5}`];
    for (let t5 = 0; t5 < i5; t5++) {
      const r6 = e3[t5];
      s5.push(`"${r6.name.replaceAll('"', '""')}" = @last_${t5}`);
    }
    t4.push(s5.join(" AND "));
  }
  const r4 = t4.join(" OR ");
  return L.create(r4);
}
function P(e3, t4) {
  null == e3.clause && (e3.clause = D2(e3.keyFields));
  for (let r4 = 0; r4 < e3.keyFields.length; r4++) {
    const i5 = e3.keyFields[r4].name;
    e3.clause.parameters[`last_${r4}`] = t4.attributes[i5];
  }
}
var C4 = class _C extends b3 {
  constructor(e3) {
    super(e3), this.declaredClass = "esri.arcade.featureset.sources.FeatureLayerDynamic", this._removeGeometry = false, this._overrideFields = null, this.formulaCredential = null, this._pageJustIds = false, this._requestStandardised = false, this._useDefinitionExpression = true, e3.spatialReference && (this.spatialReference = e3.spatialReference), this._transparent = true, this._maxProcessing = 1e3, this._layer = e3.layer, this._wset = null, void 0 !== e3.outFields && (this._overrideFields = e3.outFields), void 0 !== e3.includeGeometry && (this._removeGeometry = false === e3.includeGeometry);
  }
  _maxQueryRate() {
    return G;
  }
  end() {
    return this._layer;
  }
  optimisePagingFeatureQueries(e3) {
    this._pageJustIds = e3;
  }
  get urlQueryPath() {
    return this._layer.parsedUrl.path || "";
  }
  convertQueryToLruCacheKey(e3) {
    const t4 = this.urlQueryPath + "," + J(e3.toJSON());
    return x(t4, n2.String);
  }
  async loadImpl() {
    return true === this._layer.loaded ? (this._initialiseFeatureSet(), this) : (await this._layer.load(), this._initialiseFeatureSet(), this);
  }
  _initialiseFeatureSet() {
    if (null == this.spatialReference && (this.spatialReference = this._layer.spatialReference), this.geometryType = this._layer.geometryType ?? "", this.fields = this._layer.fields.slice(), this.hasZ = true === this._layer?.capabilities?.data?.supportsZ, this.hasM = true === this._layer?.capabilities?.data?.supportsM, null !== this._overrideFields) if (1 === this._overrideFields.length && "*" === this._overrideFields[0]) this._overrideFields = null;
    else {
      const e3 = [], t4 = [];
      for (const r4 of this.fields) if ("oid" === r4.type) e3.push(r4), t4.push(r4.name);
      else for (const i5 of this._overrideFields) if (i5.toLowerCase() === r4.name.toLowerCase()) {
        e3.push(r4), t4.push(r4.name);
        break;
      }
      this.fields = e3, this._overrideFields = t4;
    }
    if (this._layer.source && this._layer.source.sourceJSON) {
      const e3 = this._layer.source.sourceJSON.currentVersion;
      true === this._layer.source.sourceJSON.useStandardizedQueries ? (this._databaseType = 1, null != e3 && e3 >= 10.61 && (this._databaseType = 0)) : null != e3 && (e3 >= 10.5 && (this._databaseType = 1, this._requestStandardised = true), e3 >= 10.61 && (this._databaseType = 0));
    }
    this.objectIdField = this._layer.objectIdField;
    for (const e3 of this.fields) "global-id" === e3.type && (this.globalIdField = e3.name);
    this.subtypeField = this._layer.subtypeField ?? "", this.subtypes = this._layer.subtypes, this.typeIdField = ("typeIdField" in this._layer ? this._layer.typeIdField : null) ?? "", this.types = "types" in this._layer ? this._layer.types : null;
  }
  _isInFeatureSet() {
    return 0;
  }
  async _refineSetBlock(e3) {
    return e3;
  }
  _candidateIdTransform(e3) {
    return e3;
  }
  async _getSet(e3) {
    if (null === this._wset) {
      await this._ensureLoaded();
      const t4 = await this._getFilteredSet("", null, null, null, e3);
      return this._wset = t4, t4;
    }
    return this._wset;
  }
  async _runDatabaseProbe(e3) {
    await this._ensureLoaded();
    const t4 = new b();
    this.datesInUnknownTimezone && (t4.timeReferenceUnknownClient = true), t4.where = e3.replace("OBJECTID", this._layer.objectIdField);
    try {
      return await this._layer.queryObjectIds(t4), true;
    } catch (r4) {
      return false;
    }
  }
  _canUsePagination() {
    return !(!this._layer.capabilities || !this._layer.capabilities.query || true !== this._layer.capabilities.query.supportsPagination);
  }
  _cacheableFeatureSetSourceKey() {
    return this._layer.url;
  }
  get gdbVersion() {
    return this._layer && this._layer.capabilities && this._layer.capabilities.data && this._layer.capabilities.data.isVersioned ? this._layer.gdbVersion || "SDE.DEFAULT" : "";
  }
  nativeCapabilities() {
    return { title: this._layer.title ?? "", source: this, canQueryRelated: true, capabilities: this._layer.capabilities, databaseType: this._databaseType, requestStandardised: this._requestStandardised };
  }
  _createQuery() {
    const e3 = this._layer.createQuery();
    return e3.returnZ = this.hasZ, e3.returnM = this.hasM, this.datesInUnknownTimezone && (e3.timeReferenceUnknownClient = true), this._requestStandardised && (e3.sqlFormat = "standard"), this._useDefinitionExpression ? "subtype-group" === this._layer.type && (e3.where = this._layer.definitionExpression) : e3.where = null, e3;
  }
  executeQuery(e3, t4) {
    const r4 = "execute" === t4 ? this._layer.queryFeatures.bind(this._layer) : "executeForCount" === t4 ? this._layer.queryFeatureCount.bind(this._layer) : this._layer.queryObjectIds.bind(this._layer);
    let i5 = null;
    if (this.recentlyUsedQueries) {
      const t5 = this.convertQueryToLruCacheKey(e3);
      i5 = this.recentlyUsedQueries.getFromCache(t5), null === i5 && (i5 = r4(e3), this.recentlyUsedQueries.addToCache(t5, i5), i5 = i5.catch((e4) => {
        throw this.recentlyUsedQueries?.removeFromCache(t5), e4;
      }));
    }
    return this.featureSetQueryInterceptor && this.featureSetQueryInterceptor.preLayerQueryCallback({ layer: this._layer, query: e3, method: t4 }), null === i5 && (i5 = r4(e3)), i5;
  }
  async _getFilteredSet(e3, t4, r4, i5, s5) {
    const a4 = await this.databaseType();
    if (this.isTable() && t4 && null !== e3 && "" !== e3) {
      return new t2([], [], true, null);
    }
    if (this._canUsePagination()) return this._getFilteredSetUsingPaging(e3, t4, r4, i5, s5);
    let n5 = "", o4 = false;
    null !== i5 && this._layer.capabilities && this._layer.capabilities.query && true === this._layer.capabilities.query.supportsOrderBy && (n5 = i5.constructClause(), o4 = true);
    const u2 = this._createQuery();
    u2.where = l(u2.where, null === r4 ? null === t4 ? "1=1" : "" : l2(r4, a4)), u2.spatialRelationship = this._makeRelationshipEnum(e3), u2.outSpatialReference = this.spatialReference, u2.orderByFields = "" !== n5 ? n5.split(",") : null, u2.geometry = null === t4 ? null : t4, u2.relationParameter = this._makeRelationshipParam(e3);
    let c4 = await this.executeQuery(u2, "executeForIds");
    null === c4 && (c4 = []), this._checkCancelled(s5);
    return new t2([], c4, o4, null);
  }
  _expandPagedSet(e3, t4, r4, i5, s5) {
    return this._expandPagedSetFeatureSet(e3, t4, r4, i5, s5);
  }
  async _getFilteredSetUsingPaging(e3, t4, r4, i5, s5) {
    let a4 = "", n5 = false;
    null !== i5 && this._layer.capabilities && this._layer.capabilities.query && true === this._layer.capabilities.query.supportsOrderBy && (a4 = i5.constructClause(), n5 = true);
    const o4 = await this.databaseType(), u2 = null === r4 ? null === t4 ? "1=1" : "" : l2(r4, o4);
    let c4 = this._maxQueryRate();
    const h3 = this._layer.capabilities?.query.maxRecordCount;
    null != h3 && h3 < c4 && (c4 = h3);
    let p6 = null;
    if (true === this._pageJustIds) p6 = new t2([], ["GETPAGES"], n5, { spatialRel: this._makeRelationshipEnum(e3), relationParam: this._makeRelationshipParam(e3), outFields: this._layer.objectIdField, resultRecordCount: c4, resultOffset: 0, geometry: null === t4 ? null : t4, where: u2, orderByFields: a4, returnGeometry: false, returnIdsOnly: "false", internal: { set: [], lastRetrieved: 0, lastPage: 0, fullyResolved: false } });
    else {
      let r5 = true;
      true === this._removeGeometry && (r5 = false);
      const i6 = this._overrideFields ?? this._fieldsIncludingObjectId(["*"]);
      p6 = new t2([], ["GETPAGES"], n5, { spatialRel: this._makeRelationshipEnum(e3), relationParam: this._makeRelationshipParam(e3), outFields: i6.join(","), resultRecordCount: c4, resultOffset: 0, geometry: null === t4 ? null : t4, where: u2, orderByFields: a4, returnGeometry: r5, returnIdsOnly: "false", internal: { set: [], lastRetrieved: 0, lastPage: 0, fullyResolved: false } });
    }
    return await this._expandPagedSet(p6, c4, 0, 1, s5), p6;
  }
  _clonePageDefinition(e3) {
    return null === e3 ? null : true !== e3.groupbypage ? { groupbypage: false, spatialRel: e3.spatialRel, relationParam: e3.relationParam, outFields: e3.outFields, resultRecordCount: e3.resultRecordCount, resultOffset: e3.resultOffset, geometry: e3.geometry, where: e3.where, orderByFields: e3.orderByFields, returnGeometry: e3.returnGeometry, returnIdsOnly: e3.returnIdsOnly, internal: e3.internal } : { groupbypage: true, spatialRel: e3.spatialRel, relationParam: e3.relationParam, outFields: e3.outFields, resultRecordCount: e3.resultRecordCount, useOIDpagination: e3.useOIDpagination, generatedOid: e3.generatedOid, groupByFieldsForStatistics: e3.groupByFieldsForStatistics, resultOffset: e3.resultOffset, outStatistics: e3.outStatistics, geometry: e3.geometry, where: e3.where, orderByFields: e3.orderByFields, returnGeometry: e3.returnGeometry, returnIdsOnly: e3.returnIdsOnly, internal: e3.internal };
  }
  async _getPhysicalPage(e3, t4, r4) {
    const i5 = e3.pagesDefinition.internal.lastRetrieved, s5 = i5, a4 = e3.pagesDefinition.internal.lastPage, n5 = this._createQuery();
    n5.spatialRelationship = e3.pagesDefinition.spatialRel, n5.relationParameter = e3.pagesDefinition.relationParam, n5.outFields = e3.pagesDefinition.outFields.split(","), n5.num = e3.pagesDefinition.resultRecordCount, n5.start = e3.pagesDefinition.internal.lastPage, n5.geometry = e3.pagesDefinition.geometry, n5.where = l(n5.where, e3.pagesDefinition.where), n5.orderByFields = "" !== e3.pagesDefinition.orderByFields ? e3.pagesDefinition.orderByFields.split(",") : null, n5.returnGeometry = e3.pagesDefinition.returnGeometry, n5.outSpatialReference = this.spatialReference;
    const l3 = await this.executeQuery(n5, "execute");
    if (this._checkCancelled(r4), e3.pagesDefinition.internal.lastPage !== a4) return "done";
    const o4 = this._layer.objectIdField;
    for (let u2 = 0; u2 < l3.features.length; u2++) e3.pagesDefinition.internal.set[s5 + u2] = l3.features[u2].attributes[o4];
    if (false === this._pageJustIds) for (let u2 = 0; u2 < l3.features.length; u2++) this._featureCache[l3.features[u2].attributes[o4]] = l3.features[u2];
    return (void 0 === l3.exceededTransferLimit && l3.features.length !== e3.pagesDefinition.resultRecordCount || false === l3.exceededTransferLimit) && (e3.pagesDefinition.internal.fullyResolved = true), e3.pagesDefinition.internal.lastRetrieved = i5 + l3.features.length, e3.pagesDefinition.internal.lastPage += e3.pagesDefinition.resultRecordCount, "done";
  }
  _fieldsIncludingObjectId(e3) {
    if (null === e3) return [this.objectIdField];
    const t4 = e3.slice();
    if (t4.includes("*")) return t4;
    let r4 = false;
    for (const i5 of t4) if (i5.toUpperCase() === this.objectIdField.toUpperCase()) {
      r4 = true;
      break;
    }
    return false === r4 && t4.push(this.objectIdField), t4;
  }
  async _getFeatures(e3, t4, r4, i5) {
    const s5 = [];
    if (-1 !== t4 && void 0 === this._featureCache[t4] && s5.push(t4), true === this._checkIfNeedToExpandKnownPage(e3, this._maxProcessingRate())) return await this._expandPagedSet(e3, this._maxProcessingRate(), 0, 0, i5), this._getFeatures(e3, t4, r4, i5);
    let n5 = 0;
    for (let a4 = e3._lastFetchedIndex; a4 < e3._known.length; a4++) {
      if (e3._lastFetchedIndex += 1, n5++, void 0 === this._featureCache[e3._known[a4]]) {
        let r5 = false;
        if (null !== this._layer._mode && void 0 !== this._layer._mode) {
          const t5 = this._layer._mode;
          if (void 0 !== t5._featureMap[e3._known[a4]]) {
            const i6 = t5._featureMap[e3._known[a4]];
            null !== i6 && (r5 = true, this._featureCache[e3._known[a4]] = i6);
          }
        }
        if (false === r5 && (e3._known[a4] !== t4 && s5.push(e3._known[a4]), s5.length >= this._maxProcessingRate() - 1)) break;
      }
      if (n5 >= r4 && 0 === s5.length) break;
    }
    if (0 === s5.length) return "success";
    const l3 = this._createQuery();
    l3.objectIds = s5, l3.outFields = this._overrideFields ?? this._fieldsIncludingObjectId(["*"]), l3.returnGeometry = true, true === this._removeGeometry && (l3.returnGeometry = false), l3.outSpatialReference = this.spatialReference;
    const o4 = await this.executeQuery(l3, "execute");
    if (this._checkCancelled(i5), void 0 !== o4.error) throw new r3("RequestFailed", { reason: o4.error });
    const u2 = this._layer.objectIdField;
    for (let a4 = 0; a4 < o4.features.length; a4++) this._featureCache[o4.features[a4].attributes[u2]] = o4.features[a4];
    return "success";
  }
  async _getDistinctPages(e3, t4, r4, i5, s5, n5, l3, o4, u2) {
    await this._ensureLoaded();
    const c4 = await this.databaseType();
    let h3 = r4.parseTree.column;
    const p6 = this._layer.fields ?? [];
    for (let a4 = 0; a4 < p6.length; a4++) if (p6[a4].name.toLowerCase() === h3.toLowerCase()) {
      h3 = p6[a4].name;
      break;
    }
    const y3 = this._createQuery();
    y3.where = l(y3.where, null === n5 ? null === s5 ? "1=1" : "" : l2(n5, c4)), y3.spatialRelationship = this._makeRelationshipEnum(i5), y3.relationParameter = this._makeRelationshipParam(i5), y3.geometry = null === s5 ? null : s5, y3.returnDistinctValues = true, y3.returnGeometry = false, y3.outFields = [h3];
    const f5 = await this.executeQuery(y3, "execute");
    if (this._checkCancelled(u2), !f5.hasOwnProperty("features")) throw new r3("InvalidStatResponse");
    let g2 = false;
    for (let a4 = 0; a4 < p6.length; a4++) if (p6[a4].name === h3) {
      "date" === p6[a4].type && (g2 = true);
      break;
    }
    for (let a4 = 0; a4 < f5.features.length; a4++) {
      if (g2) {
        const e4 = f5.features[a4].attributes[h3];
        null !== e4 ? o4.push(new Date(e4)) : o4.push(e4);
      } else o4.push(f5.features[a4].attributes[h3]);
      if (o4.length >= l3) break;
    }
    if (0 === f5.features.length) return o4;
    if (f5.features.length === this._layer.capabilities?.query.maxRecordCount && o4.length < l3) {
      return { calculated: true, result: await this._getDistinctPages(e3 + f5.features.length, t4, r4, i5, s5, n5, l3, o4, u2) };
    }
    return o4;
  }
  async _distinctStat(e3, t4, r4, i5, s5, a4, n5) {
    return { calculated: true, result: await this._getDistinctPages(0, e3, t4, r4, i5, s5, a4, [], n5) };
  }
  isTable() {
    return this._layer.isTable || null === this._layer.geometryType || "table" === this._layer.type || "" === this._layer.geometryType || "esriGeometryNull" === this._layer.geometryType;
  }
  async _countstat(e3, t4, r4, i5) {
    const s5 = await this.databaseType();
    if (this.isTable() && r4 && null !== t4 && "" !== t4) return { calculated: true, result: 0 };
    const a4 = this._createQuery();
    a4.where = l(a4.where, null === i5 ? null === r4 ? "1=1" : "" : l2(i5, s5)), a4.spatialRelationship = this._makeRelationshipEnum(t4), a4.relationParameter = this._makeRelationshipParam(t4), a4.geometry = null === r4 ? null : r4, a4.returnGeometry = false;
    return { calculated: true, result: await this.executeQuery(a4, "executeForCount") };
  }
  async _stats(e3, t4, r4, i5, s5, n5, l3) {
    await this._ensureLoaded();
    const o4 = this._layer.capabilities?.query, u2 = !!o4?.supportsSqlExpression, c4 = !!o4?.supportsStatistics, y3 = !!o4?.supportsDistinct;
    if ("count" === e3) return y3 ? this._countstat(e3, r4, i5, s5) : { calculated: false };
    if (false === c4 || false === v(t4) && false === u2 || false === t4.isStandardized) return "" !== r4 || null !== s5 ? { calculated: false } : this._manualStat(e3, t4, n5, l3);
    if ("distinct" === e3) return false === y3 ? "" !== r4 || null !== s5 ? { calculated: false } : this._manualStat(e3, t4, n5, l3) : this._distinctStat(e3, t4, r4, i5, s5, n5, l3);
    const f5 = await this.databaseType();
    if (this.isTable() && i5 && null !== r4 && "" !== r4) return { calculated: true, result: null };
    const g2 = this._createQuery();
    g2.where = l(g2.where, null === s5 ? null === i5 ? "1=1" : "" : l2(s5, f5)), g2.spatialRelationship = this._makeRelationshipEnum(r4), g2.relationParameter = this._makeRelationshipParam(r4), g2.geometry = null === i5 ? null : i5;
    const m5 = new p2();
    m5.statisticType = p5(e3), m5.onStatisticField = l2(t4, f5), m5.outStatisticFieldName = "ARCADE_STAT_RESULT", g2.returnGeometry = false;
    let w2 = "ARCADE_STAT_RESULT";
    g2.outStatistics = [m5];
    const R2 = await this.executeQuery(g2, "execute");
    if (!R2.hasOwnProperty("features") || 0 === R2.features.length) throw new r3("InvalidStatResponse");
    let F2 = false;
    const b7 = R2.fields ?? [];
    for (let a4 = 0; a4 < b7.length; a4++) if ("ARCADE_STAT_RESULT" === b7[a4].name.toUpperCase()) {
      w2 = b7[a4].name, "date" === b7[a4].type && (F2 = true);
      break;
    }
    if (F2) {
      let e4 = R2.features[0].attributes[w2];
      return null !== e4 && (e4 = new Date(R2.features[0].attributes[w2])), { calculated: true, result: e4 };
    }
    return { calculated: true, result: R2.features[0].attributes[w2] };
  }
  _stat(e3, t4, r4, i5, s5, a4, n5) {
    return this._stats(e3, t4, r4, i5, s5, a4, n5);
  }
  async _canDoAggregates(e3, t4) {
    await this._ensureLoaded();
    let r4 = false;
    const i5 = this._layer.capabilities?.query, s5 = true === i5?.supportsSqlExpression;
    if (null != i5 && true === i5.supportsStatistics && true === i5.supportsOrderBy && (r4 = true), r4) for (let a4 = 0; a4 < t4.length - 1; a4++) (false === t4[a4].workingexpr?.isStandardized || false === v(t4[a4].workingexpr) && false === s5) && (r4 = false);
    return false !== r4;
  }
  _makeRelationshipEnum(e3) {
    if (e3.includes("esriSpatialRelRelation")) return "relation";
    switch (e3) {
      case "esriSpatialRelRelation":
        return "relation";
      case "esriSpatialRelIntersects":
        return "intersects";
      case "esriSpatialRelContains":
        return "contains";
      case "esriSpatialRelOverlaps":
        return "overlaps";
      case "esriSpatialRelWithin":
        return "within";
      case "esriSpatialRelTouches":
        return "touches";
      case "esriSpatialRelCrosses":
        return "crosses";
      case "esriSpatialRelEnvelopeIntersects":
        return "envelope-intersects";
    }
    return e3;
  }
  _makeRelationshipParam(e3) {
    return e3.includes("esriSpatialRelRelation") ? e3.split(":")[1] : "";
  }
  async _getAggregatePagesDataSourceDefinition(e3, t4, r4, i5, s5, a4, n5) {
    await this._ensureLoaded();
    const o4 = await this.databaseType();
    let u2 = null;
    if (!this._layer.capabilities.query.supportsPaginationOnAggregatedQueries) {
      const t5 = this.getFieldsIndex();
      u2 = { keyFields: e3.map((e4, r5) => ({ name: t5.normalizeFieldName(e4) ?? e4, asc: null == a4 || 1 === a4._directions[r5] })) };
    }
    let c4 = "", h3 = false;
    null != a4 && true === this._layer.capabilities?.query?.supportsOrderBy && (null == u2 || s(e3, 0, e3.length, a4._fields, 0, Math.min(a4._fields.length, e3.length), (e4, t5) => e4.toLowerCase() === t5.toLowerCase())) && (c4 = a4.constructClause(), h3 = true), "" === c4 && (c4 = e3.join(","));
    const p6 = [];
    for (let l3 = 0; l3 < t4.length; l3++) {
      const e4 = new p2();
      e4.onStatisticField = null !== t4[l3].workingexpr ? l2(t4[l3].workingexpr, o4) : "", e4.outStatisticFieldName = t4[l3].field, e4.statisticType = t4[l3].toStatisticsName(), p6.push(e4);
    }
    let f5 = this._maxQueryRate();
    const g2 = this._layer.capabilities?.query.maxRecordCount;
    null != g2 && g2 < f5 && (f5 = g2);
    const _2 = null === s5 ? null === i5 ? "1=1" : "" : l2(s5, o4);
    return new t2([], ["GETPAGES"], h3, { groupbypage: true, spatialRel: this._makeRelationshipEnum(r4), relationParam: this._makeRelationshipParam(r4), outFields: ["*"], useOIDpagination: false, generatedOid: n5, resultRecordCount: f5, resultOffset: 0, groupByFieldsForStatistics: e3, outStatistics: p6, geometry: null === i5 ? null : i5, where: _2, orderByFields: c4, returnGeometry: false, returnIdsOnly: false, internal: { lastMaxId: -1, set: [], lastRetrieved: 0, lastPage: 0, fullyResolved: false, keysetPagination: u2 } });
  }
  async _getAgregagtePhysicalPage(t4, r4, i5) {
    let s5 = t4.pagesDefinition.where;
    if (true === t4.pagesDefinition.useOIDpagination && (s5 = l(s5, t4.pagesDefinition.generatedOid + ">" + t4.pagesDefinition.internal.lastMaxId.toString())), null != t4.pagesDefinition.internal.keysetPagination?.clause) {
      if (!this._layer.capabilities.query.supportsOrderBy) throw new r3("NotImplemented");
      s5 = l(s5, l2(t4.pagesDefinition.internal.keysetPagination.clause, await this.databaseType()));
    }
    const n5 = t4.pagesDefinition.internal.lastRetrieved, l3 = n5, o4 = t4.pagesDefinition.internal.lastPage, u2 = this._createQuery();
    if (u2.where = l(u2.where, s5), u2.spatialRelationship = t4.pagesDefinition.spatialRel, u2.relationParameter = t4.pagesDefinition.relationParam, u2.outFields = t4.pagesDefinition.outFields, u2.outStatistics = t4.pagesDefinition.outStatistics, u2.geometry = t4.pagesDefinition.geometry, u2.groupByFieldsForStatistics = t4.pagesDefinition.groupByFieldsForStatistics, u2.num = t4.pagesDefinition.resultRecordCount, u2.start = t4.pagesDefinition.internal.lastPage, u2.returnGeometry = t4.pagesDefinition.returnGeometry, u2.orderByFields = "" !== t4.pagesDefinition.orderByFields ? t4.pagesDefinition.orderByFields.split(",") : null, this.isTable() && u2.geometry && u2.spatialRelationship) return [];
    const c4 = await this.executeQuery(u2, "execute");
    if (this._checkCancelled(i5), !c4.hasOwnProperty("features")) throw new r3("InvalidStatResponse");
    const h3 = [];
    if (t4.pagesDefinition.internal.lastPage !== o4) return [];
    c4.features.length > 0 && void 0 === c4.features[0].attributes[t4.pagesDefinition.generatedOid] && (t4.pagesDefinition.generatedOid = t4.pagesDefinition.generatedOid.toLowerCase());
    for (let e3 = 0; e3 < c4.features.length; e3++) t4.pagesDefinition.internal.set[l3 + e3] = c4.features[e3].attributes[t4.pagesDefinition.generatedOid];
    for (let a4 = 0; a4 < c4.features.length; a4++) h3.push(new _({ attributes: c4.features[a4].attributes, geometry: null }));
    return t4.pagesDefinition.internal.keysetPagination ? 0 !== c4.features.length && c4.exceededTransferLimit ? P(t4.pagesDefinition.internal.keysetPagination, h3.at(-1)) : t4.pagesDefinition.internal.fullyResolved = true : true === t4.pagesDefinition.useOIDpagination ? 0 === c4.features.length ? t4.pagesDefinition.internal.fullyResolved = true : t4.pagesDefinition.internal.lastMaxId = c4.features[c4.features.length - 1].attributes[t4.pagesDefinition.generatedOid] : (void 0 === c4.exceededTransferLimit && c4.features.length !== t4.pagesDefinition.resultRecordCount || false === c4.exceededTransferLimit) && (t4.pagesDefinition.internal.fullyResolved = true), t4.pagesDefinition.internal.lastRetrieved = n5 + c4.features.length, t4.pagesDefinition.internal.lastPage += t4.pagesDefinition.resultRecordCount, h3;
  }
  static create(e3, t4, r4, i5, s5) {
    const a4 = new et({ url: e3, outFields: null === t4 ? ["*"] : t4 });
    return new _C({ layer: a4, spatialReference: r4, lrucache: i5, interceptor: s5 });
  }
  relationshipMetaData() {
    return this._layer && this._layer.source && this._layer.source.sourceJSON?.relationships ? this._layer.source.sourceJSON.relationships : [];
  }
  serviceUrl() {
    return I(this._layer.parsedUrl.path);
  }
  async queryAttachments(e3, t4, r4, a4, n5) {
    function l3(e4) {
      const t5 = e4.capabilities;
      return t5?.data.supportsAttachment && t5?.operations.supportsQueryAttachments;
    }
    const o4 = this._layer;
    if (l3(o4)) {
      const l4 = { objectIds: [e3], returnMetadata: n5 };
      (t4 && t4 > 0 || r4 && r4 > 0) && (l4.size = [t4 && t4 > 0 ? t4 : 0, r4 && r4 > 0 ? r4 : t4 + 1]), a4 && a4.length > 0 && (l4.attachmentTypes = a4), this.featureSetQueryInterceptor && this.featureSetQueryInterceptor.preLayerQueryCallback({ layer: o4, query: l4, method: "attachments" });
      const u2 = await o4.queryAttachments(new p3(l4)), c4 = [];
      return u2 && u2[e3] && u2[e3].forEach((t5) => {
        const r5 = this._layer.parsedUrl.path + "/" + e3.toString() + "/attachments/" + t5.id.toString();
        let a5 = null;
        n5 && t5.exifInfo && (a5 = p.convertJsonToArcade(t5.exifInfo, "system", true)), c4.push(new t(t5.id, t5.name, t5.contentType, t5.size, r5, a5, t5.keywords ?? null));
      }), c4;
    }
    return [];
  }
  async queryRelatedFeatures(t4) {
    const i5 = { f: "json", relationshipId: t4.relationshipId.toString(), definitionExpression: t4.where, outFields: t4.outFields?.join(","), returnGeometry: t4.returnGeometry.toString() };
    void 0 !== t4.resultOffset && null !== t4.resultOffset && (i5.resultOffset = t4.resultOffset.toString()), void 0 !== t4.resultRecordCount && null !== t4.resultRecordCount && (i5.resultRecordCount = t4.resultRecordCount.toString()), t4.orderByFields && (i5.orderByFields = t4.orderByFields.join(",")), t4.objectIds && t4.objectIds.length > 0 && (i5.objectIds = t4.objectIds.join(",")), t4.outSpatialReference && (i5.outSR = A(t4.outSpatialReference)), this.featureSetQueryInterceptor && this.featureSetQueryInterceptor.preRequestCallback({ layer: this._layer, queryPayload: i5, method: "relatedrecords", url: this._layer.parsedUrl.path + "/queryRelatedRecords" });
    const s5 = await H(this._layer.parsedUrl.path + "/queryRelatedRecords", { responseType: "json", query: i5 });
    if (s5.data) {
      const t5 = {}, r4 = s5.data;
      if (r4?.relatedRecordGroups) {
        const i6 = r4.spatialReference;
        for (const s6 of r4.relatedRecordGroups) {
          const a4 = s6.objectId, n5 = [];
          for (const t6 of s6.relatedRecords) {
            t6.geometry && (t6.geometry.spatialReference = i6);
            const r5 = new _({ geometry: t6.geometry ? f3(t6.geometry) : null, attributes: t6.attributes });
            n5.push(r5);
          }
          t5[a4] = { features: n5, exceededTransferLimit: true === r4.exceededTransferLimit };
        }
      }
      return t5;
    }
    throw new r3("InvalidRequest");
  }
  async getFeatureByObjectId(e3, t4) {
    const r4 = this._createQuery();
    r4.outFields = t4, r4.returnGeometry = false, r4.outSpatialReference = this.spatialReference, r4.where = l(r4.where, this.objectIdField + "=" + e3.toString()), this.featureSetQueryInterceptor && this.featureSetQueryInterceptor.preLayerQueryCallback({ layer: this._layer, query: r4, method: "execute" });
    const i5 = await this._layer.queryFeatures(r4);
    return 1 === i5.features.length ? i5.features[0] : null;
  }
  async getIdentityUser() {
    await this.load();
    const e3 = s2?.findCredential(this._layer.url);
    return e3 ? e3.userId : null;
  }
  async getOwningSystemUrl() {
    await this.load();
    const e3 = s2?.findServerInfo(this._layer.url);
    if (e3) return e3.owningSystemUrl;
    let i5 = this._layer.url;
    const s5 = i5.toLowerCase().indexOf("/rest/services");
    if (i5 = s5 > -1 ? i5.slice(0, s5) : i5, i5) {
      i5 += "/rest/info";
      try {
        const e4 = await H(i5, { query: { f: "json" } });
        let t4 = "";
        return e4.data?.owningSystemUrl && (t4 = e4.data.owningSystemUrl), t4;
      } catch (a4) {
        return "";
      }
    }
    return "";
  }
  getDataSourceFeatureSet() {
    const e3 = new _C({ layer: this._layer, spatialReference: this.spatialReference ?? void 0, outFields: this._overrideFields ?? void 0, includeGeometry: !this._removeGeometry, lrucache: this.recentlyUsedQueries ?? void 0, interceptor: this.featureSetQueryInterceptor ?? void 0 });
    return e3._useDefinitionExpression = false, e3;
  }
  get preferredTimeZone() {
    return this._layer.preferredTimeZone ?? null;
  }
  get dateFieldsTimeZone() {
    return this._layer.dateFieldsTimeZone ?? null;
  }
  get datesInUnknownTimezone() {
    return this._layer.datesInUnknownTimezone ?? false;
  }
  get editFieldsInfo() {
    return this._layer.editFieldsInfo ?? null;
  }
  get timeInfo() {
    return this._layer.timeInfo ?? null;
  }
  async getFeatureSetInfo() {
    if (this.fsetInfo) return this.fsetInfo;
    let e3 = null, t4 = "serviceItemId" in this._layer ? this._layer.serviceItemId : null;
    const i5 = this._layer.parsedUrl?.path ?? null;
    if (i5) {
      const s6 = await H(i5, { responseType: "json", query: { f: "json" } });
      e3 = s6?.data?.name ?? null, t4 = s6?.data?.serviceItemId ?? null;
    }
    const s5 = this._layer.title && null !== (this._layer.parent ?? null);
    return this.featureSetInfo = { layerId: this._layer.layerId, layerName: "" === e3 ? null : e3, itemId: "" === t4 ? null : t4, serviceLayerUrl: "" === i5 ? null : i5, webMapLayerId: s5 ? this._layer.id ?? null : null, webMapLayerTitle: s5 ? this._layer.title ?? null : null, className: null, objectClassId: null }, this.fsetInfo;
  }
};

// node_modules/@arcgis/core/arcade/featureset/sources/FeatureLayerMemory.js
var y2 = class _y extends b3 {
  constructor(e3) {
    super(e3), this.declaredClass = "esri.arcade.featureset.sources.FeatureLayerMemory", this._removeGeometry = false, this._overrideFields = null, this._forceIsTable = false, e3.spatialReference && (this.spatialReference = e3.spatialReference), this._transparent = true, this._maxProcessing = 1e3, this._layer = e3.layer, this._wset = null, true === e3.isTable && (this._forceIsTable = true), void 0 !== e3.outFields && (this._overrideFields = e3.outFields), void 0 !== e3.includeGeometry && (this._removeGeometry = false === e3.includeGeometry);
  }
  _maxQueryRate() {
    return G;
  }
  end() {
    return this._layer;
  }
  optimisePagingFeatureQueries() {
  }
  async loadImpl() {
    return true === this._layer.loaded ? (this._initialiseFeatureSet(), this) : (await this._layer.load(), this._initialiseFeatureSet(), this);
  }
  get gdbVersion() {
    return "";
  }
  _initialiseFeatureSet() {
    if (null == this.spatialReference && (this.spatialReference = this._layer.spatialReference), this.geometryType = this._layer.geometryType ?? "", this.fields = this._layer.fields.slice(), null !== this._overrideFields) if (1 === this._overrideFields.length && "*" === this._overrideFields[0]) this._overrideFields = null;
    else {
      const e3 = [], t4 = [];
      for (const s5 of this.fields) if ("oid" === s5.type || this._layer.objectIdField === s5.name) e3.push(s5), t4.push(s5.name);
      else for (const r4 of this._overrideFields) if (r4.toLowerCase() === s5.name.toLowerCase()) {
        e3.push(s5), t4.push(s5.name);
        break;
      }
      this.fields = e3, this._overrideFields = t4;
    }
    this.objectIdField = this._layer.objectIdField;
    for (const e3 of this.fields) "global-id" === e3.type && (this.globalIdField = e3.name);
    this._databaseType = 0, this.hasZ = true === this._layer?.capabilities?.data?.supportsZ, this.hasM = true === this._layer?.capabilities?.data?.supportsM, this.subtypeField = ("subtypeField" in this._layer ? this._layer.subtypeField : null) ?? "", this.subtypes = "subtypes" in this._layer ? this._layer.subtypes : null, this.typeIdField = ("typeIdField" in this._layer ? this._layer.typeIdField : null) ?? "", this.types = "types" in this._layer ? this._layer.types : null;
  }
  isTable() {
    return this._forceIsTable || "isTable" in this._layer && this._layer.isTable || "table" === this._layer.type || !this._layer.geometryType;
  }
  _isInFeatureSet() {
    return 0;
  }
  _candidateIdTransform(e3) {
    return e3;
  }
  async _getSet(e3) {
    if (null === this._wset) {
      await this._ensureLoaded();
      const t4 = await this._getFilteredSet("", null, null, null, e3);
      return this._wset = t4, t4;
    }
    return this._wset;
  }
  _createQuery() {
    const e3 = this._layer.createQuery();
    return e3.returnZ = this.hasZ, e3.returnM = this.hasM, e3.outFields = this._overrideFields ?? ["*"], e3.returnGeometry = !this._removeGeometry, e3;
  }
  _changeFeature(t4) {
    const s5 = {};
    for (const e3 of this.fields) s5[e3.name] = t4.attributes[e3.name];
    return new _({ geometry: true === this._removeGeometry ? null : t4.geometry, attributes: s5 });
  }
  async _getFilteredSet(e3, t4, s5, i5, n5) {
    let o4 = "", u2 = false;
    if (null !== i5 && (o4 = i5.constructClause(), u2 = true), this.isTable() && t4 && null !== e3 && "" !== e3) {
      return new t2([], [], true, null);
    }
    const h3 = this._createQuery();
    h3.where = l(h3.where, null === s5 ? null === t4 ? "1=1" : "" : l2(s5, 0)), h3.spatialRelationship = this._makeRelationshipEnum(e3), h3.outSpatialReference = this.spatialReference, h3.orderByFields = "" !== o4 ? o4.split(",") : null, h3.geometry = null === t4 ? null : t4, h3.relationParameter = this._makeRelationshipParam(e3);
    const y3 = await this._layer.queryFeatures(h3);
    if (null === y3) return new t2([], [], u2, null);
    this._checkCancelled(n5);
    const c4 = [];
    y3.features.forEach((e4) => {
      const t5 = e4.attributes[this._layer.objectIdField];
      c4.push(t5), this._featureCache[t5] = this._changeFeature(e4);
    });
    return new t2([], c4, u2, null);
  }
  _makeRelationshipEnum(e3) {
    if (e3.includes("esriSpatialRelRelation")) return "relation";
    switch (e3) {
      case "esriSpatialRelRelation":
        return "relation";
      case "esriSpatialRelIntersects":
        return "intersects";
      case "esriSpatialRelContains":
        return "contains";
      case "esriSpatialRelOverlaps":
        return "overlaps";
      case "esriSpatialRelWithin":
        return "within";
      case "esriSpatialRelTouches":
        return "touches";
      case "esriSpatialRelCrosses":
        return "crosses";
      case "esriSpatialRelEnvelopeIntersects":
        return "envelope-intersects";
    }
    return e3;
  }
  _makeRelationshipParam(e3) {
    return e3.includes("esriSpatialRelRelation") ? e3.split(":")[1] : "";
  }
  async _queryAllFeatures() {
    if (this._wset) return this._wset;
    if (await this._ensureLoaded(), this._layer.source && this._layer.source.items) {
      const e4 = [];
      return this._layer.source.items.forEach((t5) => {
        const s6 = t5.attributes[this._layer.objectIdField];
        e4.push(s6), this._featureCache[s6] = this._changeFeature(t5);
      }), this._wset = new t2([], e4, false, null), this._wset;
    }
    const e3 = this._createQuery();
    e3.where = "1=1";
    const t4 = await this._layer.queryFeatures(e3), s5 = [];
    return t4.features.forEach((e4) => {
      const t5 = e4.attributes[this._layer.objectIdField];
      s5.push(t5), this._featureCache[t5] = this._changeFeature(e4);
    }), this._wset = new t2([], s5, false, null), this._wset;
  }
  async _getFeatures(e3, s5, r4) {
    const i5 = [];
    -1 !== s5 && void 0 === this._featureCache[s5] && i5.push(s5);
    for (let t4 = e3._lastFetchedIndex; t4 < e3._known.length && (e3._lastFetchedIndex += 1, !(void 0 === this._featureCache[e3._known[t4]] && (e3._known[t4] !== s5 && i5.push(e3._known[t4]), i5.length > r4))); t4++) ;
    if (0 === i5.length) return "success";
    throw new r3("MissingFeatures");
  }
  async _refineSetBlock(e3) {
    return e3;
  }
  async _stat() {
    return { calculated: false };
  }
  async _canDoAggregates() {
    return false;
  }
  relationshipMetaData() {
    return [];
  }
  static _cloneAttr(e3) {
    const t4 = {};
    for (const s5 in e3) t4[s5] = e3[s5];
    return t4;
  }
  nativeCapabilities() {
    return { title: this._layer.title ?? "", canQueryRelated: false, source: this, capabilities: this._layer.capabilities, databaseType: this._databaseType, requestStandardised: true };
  }
  static create(e3, t4) {
    let s5 = e3.layerDefinition.objectIdField;
    const r4 = e3.layerDefinition.typeIdField ?? "", i5 = [];
    if (e3.layerDefinition.types) for (const n5 of e3.layerDefinition.types) i5.push(c3.fromJSON(n5));
    let a4 = e3.layerDefinition.geometryType;
    void 0 === a4 && (a4 = e3.featureSet.geometryType || "");
    let l3 = e3.featureSet.features;
    const c4 = t4.toJSON();
    if (!s5) {
      let t5 = false;
      for (const r5 of e3.layerDefinition.fields) if ("oid" === r5.type || "esriFieldTypeOID" === r5.type) {
        s5 = r5.name, t5 = true;
        break;
      }
      if (false === t5) {
        let t6 = "FID", r5 = true, i6 = 0;
        for (; r5; ) {
          let s6 = true;
          for (const r6 of e3.layerDefinition.fields) if (r6.name === t6) {
            s6 = false;
            break;
          }
          true === s6 ? r5 = false : (i6++, t6 = "FID" + i6.toString());
        }
        e3.layerDefinition.fields.push({ type: "esriFieldTypeOID", name: t6, alias: t6 });
        const a5 = [];
        for (let s6 = 0; s6 < l3.length; s6++) a5.push({ geometry: e3.featureSet.features[s6].geometry, attributes: e3.featureSet.features[s6].attributes ? this._cloneAttr(e3.featureSet.features[s6].attributes) : {} }), a5[s6].attributes[t6] = s6;
        l3 = a5, s5 = t6;
      }
    }
    const d3 = [];
    for (const n5 of e3.layerDefinition.fields) n5 instanceof m2 ? d3.push(n5) : d3.push(m2.fromJSON(n5));
    let p6 = a4;
    switch (p6 || (p6 = ""), p6) {
      case "esriGeometryPoint":
        p6 = "point";
        break;
      case "esriGeometryPolyline":
        p6 = "polyline";
        break;
      case "esriGeometryPolygon":
        p6 = "polygon";
        break;
      case "esriGeometryEnvelope":
        p6 = "extent";
        break;
      case "esriGeometryMultipoint":
        p6 = "multipoint";
        break;
      case "":
      case "esriGeometryNull":
        p6 = "esriGeometryNull";
    }
    if ("esriGeometryNull" !== p6) for (const o4 of l3) o4.geometry && o4.geometry instanceof c == false && (o4.geometry.type = p6, void 0 === o4.geometry.spatialReference && (o4.geometry.spatialReference = c4));
    else for (const n5 of l3) n5.geometry && (n5.geometry = null);
    const f5 = { outFields: ["*"], source: l3, fields: d3, hasZ: true === e3?.layerDefinition?.hasZ || true === e3?.featureSet?.hasZ, hasM: true === e3?.layerDefinition?.hasM || true === e3?.featureSet?.hasM, types: i5, typeIdField: r4, objectIdField: s5, spatialReference: t4 }, _2 = "esriGeometryNull" === p6 || null === p6;
    _2 || (f5.geometryType = p6);
    const m5 = new et(f5);
    e3?.layerDefinition?.subtypeField && e3?.layerDefinition?.subtypes && m5.read({ subtypes: e3.layerDefinition.subtypes, subtypeField: e3.layerDefinition.subtypeField });
    return new _y({ layer: m5, spatialReference: t4, isTable: _2 });
  }
  async queryAttachments() {
    return [];
  }
  async getFeatureByObjectId(e3) {
    const t4 = this._createQuery();
    t4.where = this.objectIdField + "=" + e3.toString();
    const s5 = await this._layer.queryFeatures(t4);
    return 1 === s5.features.length ? s5.features[0] : null;
  }
  async getOwningSystemUrl() {
    return "";
  }
  async getIdentityUser() {
    return "";
  }
  get preferredTimeZone() {
    return "preferredTimeZone" in this._layer ? this._layer.preferredTimeZone : null;
  }
  get dateFieldsTimeZone() {
    return "dateFieldsTimeZone" in this._layer ? this._layer.dateFieldsTimeZone : null;
  }
  get datesInUnknownTimezone() {
    return "datesInUnknownTimezone" in this._layer && this._layer.datesInUnknownTimezone;
  }
  get editFieldsInfo() {
    return "editFieldsInfo" in this._layer ? this._layer.editFieldsInfo : null;
  }
  get timeInfo() {
    return this._layer?.timeInfo;
  }
  async getFeatureSetInfo() {
    const e3 = this._layer.title && this._layer.parent;
    return this.fsetInfo ?? { layerId: null, layerName: null, itemId: null, serviceLayerUrl: null, webMapLayerId: e3 ? this._layer.id ?? null : null, webMapLayerTitle: e3 ? this._layer.title ?? null : null, className: null, objectClassId: null };
  }
};

// node_modules/@arcgis/core/arcade/featureset/sources/FeatureLayerRelated.js
var n4 = class extends b3 {
  constructor(e3) {
    super(e3), this.declaredClass = "esri.arcade.featureset.sources.FeatureLayerRelated", this._findObjectId = -1, this._requestStandardised = false, this._removeGeometry = false, this._overrideFields = null, this.featureObjectId = null, e3.spatialReference && (this.spatialReference = e3.spatialReference), this._transparent = true, this._maxProcessing = 1e3, this._layer = e3.layer, this._wset = null, this._findObjectId = e3.objectId, this.featureObjectId = e3.objectId, this.relationship = e3.relationship, this._relatedLayer = e3.relatedLayer, void 0 !== e3.outFields && (this._overrideFields = e3.outFields), void 0 !== e3.includeGeometry && (this._removeGeometry = false === e3.includeGeometry);
  }
  _maxQueryRate() {
    return G;
  }
  end() {
    return this._layer;
  }
  optimisePagingFeatureQueries() {
  }
  async loadImpl() {
    return await Promise.all([this._layer.load(), this._relatedLayer?.load()]), this._initialiseFeatureSet(), this;
  }
  nativeCapabilities() {
    return this._relatedLayer.nativeCapabilities();
  }
  _initialiseFeatureSet() {
    if (null == this.spatialReference && (this.spatialReference = this._layer.spatialReference), this.geometryType = this._relatedLayer.geometryType, this.fields = this._relatedLayer.fields.slice(), this.hasZ = this._relatedLayer.hasZ, this.hasM = this._relatedLayer.hasM, null !== this._overrideFields) if (1 === this._overrideFields.length && "*" === this._overrideFields[0]) this._overrideFields = null;
    else {
      const e4 = [], t4 = [];
      for (const r4 of this.fields) if ("oid" === r4.type) e4.push(r4), t4.push(r4.name);
      else for (const i5 of this._overrideFields) if (i5.toLowerCase() === r4.name.toLowerCase()) {
        e4.push(r4), t4.push(r4.name);
        break;
      }
      this.fields = e4, this._overrideFields = t4;
    }
    const e3 = this._layer.nativeCapabilities();
    e3 && (this._databaseType = e3.databaseType, this._requestStandardised = e3.requestStandardised), this.objectIdField = this._relatedLayer.objectIdField, this.globalIdField = this._relatedLayer.globalIdField, this.hasM = this._relatedLayer.supportsM, this.hasZ = this._relatedLayer.supportsZ, this.typeIdField = this._relatedLayer.typeIdField, this.types = this._relatedLayer.types, this.subtypeField = this._relatedLayer.subtypeField, this.subtypes = this._relatedLayer.subtypes;
  }
  async databaseType() {
    return await this._relatedLayer.databaseType(), this._databaseType = this._relatedLayer._databaseType, this._databaseType;
  }
  isTable() {
    return this._relatedLayer.isTable();
  }
  _isInFeatureSet() {
    return 0;
  }
  _candidateIdTransform(e3) {
    return e3;
  }
  async _getSet(e3) {
    if (null === this._wset) {
      await this._ensureLoaded();
      const t4 = await this._getFilteredSet("", null, null, null, e3);
      return this._wset = t4, t4;
    }
    return this._wset;
  }
  _changeFeature(t4) {
    const r4 = {};
    for (const e3 of this.fields) r4[e3.name] = t4.attributes[e3.name];
    return new _({ geometry: true === this._removeGeometry ? null : t4.geometry, attributes: r4 });
  }
  async _getFilteredSet(e3, t4, r4, s5, n5) {
    if (await this.databaseType(), this.isTable() && t4 && null !== e3 && "" !== e3) {
      return new t2([], [], true, null);
    }
    const l3 = this._layer.nativeCapabilities();
    if (false === l3.canQueryRelated) {
      return new t2([], [], true, null);
    }
    if (l3.capabilities?.queryRelated.supportsPagination) return this._getFilteredSetUsingPaging(e3, t4, r4, s5, n5);
    let d3 = "", o4 = false;
    null !== s5 && true === l3.capabilities?.queryRelated.supportsOrderBy && (d3 = s5.constructClause(), o4 = true);
    const u2 = new u();
    u2.objectIds = [this._findObjectId];
    const h3 = null !== this._overrideFields ? this._overrideFields : this._fieldsIncludingObjectId(this._relatedLayer.fields ? this._relatedLayer.fields.map((e4) => e4.name) : ["*"]);
    u2.outFields = h3, u2.relationshipId = this.relationship.id, u2.where = "1=1";
    let c4 = true;
    true === this._removeGeometry && (c4 = false), u2.returnGeometry = c4, this._requestStandardised && (u2.sqlFormat = "standard"), u2.outSpatialReference = this.spatialReference, u2.orderByFields = "" !== d3 ? d3.split(",") : null;
    const y3 = await l3.source.queryRelatedFeatures(u2);
    this._checkCancelled(n5);
    const p6 = y3[this._findObjectId] ? y3[this._findObjectId].features : [], _2 = [];
    for (let i5 = 0; i5 < p6.length; i5++) this._featureCache[p6[i5].attributes[this._relatedLayer.objectIdField]] = p6[i5], _2.push(p6[i5].attributes[this._relatedLayer.objectIdField]);
    const f5 = t4 && null !== e3 && "" !== e3, g2 = null != r4;
    return new t2(f5 || g2 ? _2 : [], f5 || g2 ? [] : _2, o4, null);
  }
  _fieldsIncludingObjectId(e3) {
    if (null === e3) return [this.objectIdField];
    const t4 = e3.slice();
    if (t4.includes("*")) return t4;
    let r4 = false;
    for (const i5 of t4) if (i5.toUpperCase() === this.objectIdField.toUpperCase()) {
      r4 = true;
      break;
    }
    return false === r4 && t4.push(this.objectIdField), t4;
  }
  async _getFilteredSetUsingPaging(e3, t4, r4, s5, a4) {
    let n5 = "", l3 = false;
    const d3 = this._layer.nativeCapabilities();
    null !== s5 && true === d3.capabilities?.queryRelated.supportsOrderBy && (n5 = s5.constructClause(), l3 = true), await this.databaseType();
    const o4 = "1=1";
    let u2 = this._maxQueryRate();
    const h3 = d3.capabilities?.query.maxRecordCount;
    null != h3 && h3 < u2 && (u2 = h3);
    const c4 = t4 && null !== e3 && "" !== e3, y3 = null != r4;
    let p6 = null, _2 = true;
    true === this._removeGeometry && (_2 = false);
    const f5 = null !== this._overrideFields ? this._overrideFields : this._fieldsIncludingObjectId(this._relatedLayer.fields ? this._relatedLayer.fields.map((e4) => e4.name) : ["*"]);
    return p6 = new t2(c4 || y3 ? ["GETPAGES"] : [], c4 || y3 ? [] : ["GETPAGES"], l3, { outFields: f5.join(","), resultRecordCount: u2, resultOffset: 0, objectIds: [this._findObjectId], where: o4, orderByFields: n5, returnGeometry: _2, returnIdsOnly: "false", internal: { set: [], lastRetrieved: 0, lastPage: 0, fullyResolved: false } }), await this._expandPagedSet(p6, u2, 0, 0, a4), p6;
  }
  _expandPagedSet(e3, t4, r4, i5, s5) {
    return this._expandPagedSetFeatureSet(e3, t4, r4, i5, s5);
  }
  _clonePageDefinition(e3) {
    return null === e3 ? null : true !== e3.groupbypage ? { groupbypage: false, outFields: e3.outFields, resultRecordCount: e3.resultRecordCount, resultOffset: e3.resultOffset, where: e3.where, objectIds: e3.objectIds, orderByFields: e3.orderByFields, returnGeometry: e3.returnGeometry, returnIdsOnly: e3.returnIdsOnly, internal: e3.internal } : { groupbypage: true, outFields: e3.outFields, resultRecordCount: e3.resultRecordCount, useOIDpagination: e3.useOIDpagination, generatedOid: e3.generatedOid, groupByFieldsForStatistics: e3.groupByFieldsForStatistics, resultOffset: e3.resultOffset, outStatistics: e3.outStatistics, geometry: e3.geometry, where: e3.where, objectIds: e3.objectIds, orderByFields: e3.orderByFields, returnGeometry: e3.returnGeometry, returnIdsOnly: e3.returnIdsOnly, internal: e3.internal };
  }
  async _getPhysicalPage(e3, t4, r4) {
    const i5 = e3.pagesDefinition.internal.lastRetrieved, s5 = i5, n5 = e3.pagesDefinition.internal.lastPage, l3 = this._layer.nativeCapabilities(), d3 = new u();
    true === this._requestStandardised && (d3.sqlFormat = "standard"), d3.relationshipId = this.relationship.id, d3.objectIds = e3.pagesDefinition.objectIds, d3.resultOffset = e3.pagesDefinition.internal.lastPage, d3.resultRecordCount = e3.pagesDefinition.resultRecordCount, d3.outFields = e3.pagesDefinition.outFields.split(","), d3.where = e3.pagesDefinition.where, d3.orderByFields = "" !== e3.pagesDefinition.orderByFields ? e3.pagesDefinition.orderByFields.split(",") : null, d3.returnGeometry = e3.pagesDefinition.returnGeometry, d3.outSpatialReference = this.spatialReference;
    const o4 = await l3.source.queryRelatedFeatures(d3);
    if (this._checkCancelled(r4), e3.pagesDefinition.internal.lastPage !== n5) return 0;
    const u2 = o4[this._findObjectId] ? o4[this._findObjectId].features : [];
    for (let a4 = 0; a4 < u2.length; a4++) e3.pagesDefinition.internal.set[s5 + a4] = u2[a4].attributes[this._relatedLayer.objectIdField];
    for (let a4 = 0; a4 < u2.length; a4++) this._featureCache[u2[a4].attributes[this._relatedLayer.objectIdField]] = u2[a4];
    const h3 = !o4[this._findObjectId] || false === o4[this._findObjectId].exceededTransferLimit;
    return u2.length !== e3.pagesDefinition.resultRecordCount && h3 && (e3.pagesDefinition.internal.fullyResolved = true), e3.pagesDefinition.internal.lastRetrieved = i5 + u2.length, e3.pagesDefinition.internal.lastPage += e3.pagesDefinition.resultRecordCount, u2.length;
  }
  async _getFeatures(e3, r4, i5, s5) {
    const a4 = [];
    -1 !== r4 && void 0 === this._featureCache[r4] && a4.push(r4);
    const n5 = this._maxQueryRate();
    if (true === this._checkIfNeedToExpandKnownPage(e3, n5)) return await this._expandPagedSet(e3, n5, 0, 0, s5), this._getFeatures(e3, r4, i5, s5);
    let l3 = 0;
    for (let t4 = e3._lastFetchedIndex; t4 < e3._known.length && (l3++, l3 <= i5 && (e3._lastFetchedIndex += 1), !("GETPAGES" !== e3._known[t4] && void 0 === this._featureCache[e3._known[t4]] && (e3._known[t4] !== r4 && a4.push(e3._known[t4]), a4.length > i5))) && !(l3 >= i5 && 0 === a4.length); t4++) ;
    if (0 === a4.length) return "success";
    throw new r3("MissingFeatures");
  }
  async _refineSetBlock(e3, t4, r4) {
    return e3;
  }
  async _stat(e3, t4, r4, i5, s5, a4, n5) {
    return { calculated: false };
  }
  get gdbVersion() {
    return this._relatedLayer.gdbVersion;
  }
  async _canDoAggregates(e3, t4, r4, i5, s5) {
    return false;
  }
  relationshipMetaData() {
    return this._relatedLayer.relationshipMetaData();
  }
  serviceUrl() {
    return this._relatedLayer.serviceUrl();
  }
  queryAttachments(e3, t4, r4, i5, s5) {
    return this._relatedLayer.queryAttachments(e3, t4, r4, i5, s5);
  }
  getFeatureByObjectId(e3, t4) {
    return this._relatedLayer.getFeatureByObjectId(e3, t4);
  }
  getOwningSystemUrl() {
    return this._relatedLayer.getOwningSystemUrl();
  }
  getIdentityUser() {
    return this._relatedLayer.getIdentityUser();
  }
  getDataSourceFeatureSet() {
    return this._relatedLayer;
  }
  get preferredTimeZone() {
    return this._relatedLayer?.preferredTimeZone ?? null;
  }
  get dateFieldsTimeZone() {
    return this._relatedLayer?.dateFieldsTimeZone ?? null;
  }
  get datesInUnknownTimezone() {
    return this._relatedLayer?.datesInUnknownTimezone;
  }
  get editFieldsInfo() {
    return this._relatedLayer?.editFieldsInfo ?? null;
  }
  get timeInfo() {
    return this._relatedLayer?.timeInfo ?? null;
  }
  async getFeatureSetInfo() {
    return this.fsetInfo ?? this._layer.featureSetInfo;
  }
};

// node_modules/@arcgis/core/arcade/featureSetUtils.js
function C5() {
  null === a3.applicationCache && (a3.applicationCache = new a3());
}
async function g(e3, t4, a4) {
  if (a3.applicationCache) {
    const a5 = a3.applicationCache.getLayerInfo(e3);
    if (a5) {
      const r4 = await a5;
      return new et({ url: e3, outFields: t4, sourceJSON: r4 });
    }
    const n5 = new et({ url: e3, outFields: t4 }), l3 = (async () => (await n5.load(), n5.sourceJSON))();
    if (a3.applicationCache) {
      a3.applicationCache.setLayerInfo(e3, l3);
      try {
        return await l3, n5;
      } catch (r4) {
        throw a3.applicationCache.clearLayerInfo(e3), r4;
      }
    }
    return await l3, n5;
  }
  if (null != a4) {
    const r4 = a4.getCachedLayerMetadata(e3);
    if (r4) {
      const a5 = await r4;
      return new et({ url: e3, outFields: t4, sourceJSON: a5 });
    }
    const l3 = new et({ url: e3, outFields: t4 }), s5 = (async () => (await l3.load(), l3.sourceJSON))();
    a4.setCachedLayerMetadata(e3, s5);
    try {
      return await s5, l3;
    } catch (n5) {
      throw a4.removeCachedLayerMetadata(e3, s5), n5;
    }
  }
  return new et({ url: e3, outFields: t4 });
}
async function k3(e3, t4, a4, r4, n5, l3 = null) {
  return F(await g(e3, ["*"], n5), t4, a4, r4, n5, l3);
}
function F(e3, t4 = null, a4 = null, r4 = true, n5 = null, l3 = null) {
  switch (e3.type) {
    case "catalog-footprint":
      return F(e3.parent, t4, a4, r4, n5, l3);
    case "subtype-sublayer": {
      const s5 = F(e3.parent, t4, a4, r4, n5, l3);
      return s5.filter(L.create(e3.parent.subtypeField + "=" + e3.subtypeCode.toString(), { fieldsIndex: e3.parent.fieldsIndex, timeZone: s5.dateFieldsTimeZoneDefaultUTC }));
    }
    case "csv":
    case "geojson":
    case "knowledge-graph-sublayer":
    case "wfs":
      return new y2({ layer: e3, spatialReference: t4, outFields: a4, includeGeometry: r4, lrucache: n5, interceptor: l3 });
    case "catalog":
    case "feature":
    case "oriented-imagery":
    case "subtype-group": {
      const s5 = { layer: e3, spatialReference: t4, outFields: a4, includeGeometry: r4, lrucache: n5, interceptor: l3 };
      return !e3.url && e3.source ? new y2(s5) : new C4(s5);
    }
    default:
      throw new Error(`Unsupported layer type: ${e3.type}`);
  }
}
async function N2(t4) {
  if (null !== a3.applicationCache) {
    const e3 = a3.applicationCache.getLayerInfo(t4);
    if (null !== e3) return e3;
  }
  const a4 = (async () => {
    const a5 = await H(t4, { responseType: "json", query: { f: "json" } });
    return a5.data ? a5.data : null;
  })();
  if (null !== a3.applicationCache) {
    a3.applicationCache.setLayerInfo(t4, a4);
    try {
      return await a4;
    } catch (r4) {
      throw a3.applicationCache.clearLayerInfo(t4), r4;
    }
  }
  return a4;
}
async function T3(t4, a4) {
  const r4 = "QUERYDATAELEMTS:" + a4.toString() + ":" + t4;
  if (null !== a3.applicationCache) {
    const e3 = a3.applicationCache.getLayerInfo(r4);
    if (null !== e3) return e3;
  }
  const n5 = (async () => {
    const r5 = await H(t4 + "/queryDataElements", { method: "post", responseType: "json", query: { layers: JSON.stringify([a4.toString()]), f: "json" } });
    if (r5.data) {
      const e3 = r5.data;
      if (e3.layerDataElements?.[0]) return e3.layerDataElements[0];
    }
    throw new r3("DataElementsNotFound");
  })();
  if (null !== a3.applicationCache) {
    a3.applicationCache.setLayerInfo(r4, n5);
    try {
      return await n5;
    } catch (l3) {
      throw a3.applicationCache.clearLayerInfo(r4), l3;
    }
  }
  return n5;
}
async function A3(t4, a4) {
  if (null !== a3.applicationCache) {
    const e3 = a3.applicationCache.getLayerInfo(t4);
    if (null !== e3) return e3;
  }
  if (null != a4) {
    const e3 = a4.getCachedServiceMetadata(t4);
    if (null != e3) return e3;
  }
  const r4 = (async () => {
    const a5 = await H(t4, { responseType: "json", query: { f: "json" } });
    if (a5.data) {
      const e3 = a5.data;
      return e3.layers || (e3.layers = []), e3.tables || (e3.tables = []), e3;
    }
    return { layers: [], tables: [] };
  })();
  if (null !== a3.applicationCache) {
    a3.applicationCache.setLayerInfo(t4, r4);
    try {
      return await r4;
    } catch (n5) {
      throw a3.applicationCache.clearLayerInfo(t4), n5;
    }
  }
  if (null != a4) {
    a4.setCachedServiceMetadata(t4, r4);
    try {
      return await r4;
    } catch (l3) {
      throw a4.removeCachedServiceMetadata(t4, r4), l3;
    }
  }
  return r4;
}
async function O(e3, t4, a4) {
  const r4 = { metadata: null, networkId: -1, unVersion: 3, terminals: [], layerIdLookup: /* @__PURE__ */ new Map(), sourceIdLookup: /* @__PURE__ */ new Map(), queryelem: null, layerNameLkp: {}, lkp: null }, n5 = await A3(e3, null);
  if (r4.metadata = n5, void 0 !== n5.controllerDatasetLayers?.utilityNetworkLayerId && null !== n5.controllerDatasetLayers.utilityNetworkLayerId) {
    if (n5.layers) for (const e4 of n5.layers) r4.layerNameLkp[e4.id] = e4.name;
    if (n5.tables) for (const e4 of n5.tables) r4.layerNameLkp[e4.id] = e4.name;
    const l3 = n5.controllerDatasetLayers.utilityNetworkLayerId;
    r4.networkId = l3;
    const s5 = await T3(e3, l3);
    if (s5) {
      r4.queryelem = s5, r4.queryelem?.dataElement && void 0 !== r4.queryelem.dataElement.schemaGeneration && (r4.unVersion = r4.queryelem.dataElement.schemaGeneration), r4.lkp = {}, r4.queryelem.dataElement.domainNetworks || (r4.queryelem.dataElement.domainNetworks = []);
      for (const e4 of r4.queryelem.dataElement.domainNetworks) {
        for (const t5 of e4.edgeSources ?? []) {
          const e5 = { layerId: t5.layerId, sourceId: t5.sourceId, className: r4.layerNameLkp[t5.layerId] ?? null };
          r4.layerIdLookup.set(e5.layerId, e5), r4.sourceIdLookup.set(e5.sourceId, e5), e5.className && (r4.lkp[e5.className] = e5);
        }
        for (const t5 of e4.junctionSources ?? []) {
          const e5 = { layerId: t5.layerId, sourceId: t5.sourceId, className: r4.layerNameLkp[t5.layerId] ?? null };
          r4.layerIdLookup.set(e5.layerId, e5), r4.sourceIdLookup.set(e5.sourceId, e5), e5.className && (r4.lkp[e5.className] = e5);
        }
      }
      if (r4.queryelem.dataElement.terminalConfigurations) for (const e4 of r4.queryelem.dataElement.terminalConfigurations) for (const t5 of e4.terminals) r4.terminals.push({ terminalId: t5.terminalId, terminalName: t5.terminalName });
      const n6 = await N2(e3 + "/" + l3);
      if (void 0 !== n6.systemLayers?.associationsTableId && null !== n6.systemLayers.associationsTableId) {
        let l4 = null;
        if (a4 && r4.unVersion < 8) {
          const a5 = [];
          r4.unVersion >= 4 && (a5.push("STATUS"), a5.push("PERCENTALONG")), l4 = await k3(e3 + "/" + n6.systemLayers.associationsTableId, t4, ["OBJECTID", "FROMNETWORKSOURCEID", "TONETWORKSOURCEID", "FROMGLOBALID", "TOGLOBALID", "TOTERMINALID", "FROMTERMINALID", "ASSOCIATIONTYPE", "ISCONTENTVISIBLE", "GLOBALID", ...a5], false, null, null), await l4.load(), r4.unVersion >= 4 && (l4 = l4.filter(L.create("STATUS NOT IN (1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19, 20, 21, 22, 23, 25, 26, 27, 28, 29, 30, 31, 33, 34, 35, 36, 37, 38, 39, 41, 42, 43, 44, 45, 46, 47, 49, 50, 51, 52, 53, 54, 55, 57, 58, 59, 60, 61, 62, 63)", { fieldsIndex: l4.getFieldsIndex(), timeZone: l4.dateFieldsTimeZoneDefaultUTC })), await l4.load());
        }
        return { lkp: r4.lkp, associations: l4, unVersion: r4.unVersion, terminals: r4.terminals, layerIdLookup: r4.layerIdLookup, sourceIdLookup: r4.sourceIdLookup };
      }
      return { associations: null, unVersion: r4.unVersion, lkp: null, terminals: [], layerIdLookup: /* @__PURE__ */ new Map(), sourceIdLookup: /* @__PURE__ */ new Map() };
    }
    return { associations: null, unVersion: r4.unVersion, lkp: null, terminals: [], layerIdLookup: /* @__PURE__ */ new Map(), sourceIdLookup: /* @__PURE__ */ new Map() };
  }
  return { associations: null, unVersion: r4.unVersion, lkp: null, terminals: [], layerIdLookup: /* @__PURE__ */ new Map(), sourceIdLookup: /* @__PURE__ */ new Map() };
}
async function E3(e3, t4, a4, r4 = null, n5 = null, l3 = true, s5 = null, i5 = null) {
  let o4 = e3.serviceUrl();
  if (!o4) return null;
  o4 = o4.endsWith("/") ? o4 + t4.relatedTableId.toString() : o4 + "/" + t4.relatedTableId.toString();
  const u2 = await k3(o4, r4, n5, l3, s5, i5);
  return new n4({ layer: e3, relatedLayer: u2, relationship: t4, objectId: a4, spatialReference: r4, outFields: n5, includeGeometry: l3, lrucache: s5, interceptor: i5 });
}
h2.registerAction(), T2.registerAction(), i3.registerAction(), s3.registerAction(), s4.registerAction();
var j = class extends e {
  constructor(e3, t4 = null, a4 = null, r4 = null) {
    super(), this._map = e3, this._overrideSpatialReference = t4, this._lrucache = a4, this._interceptor = r4, this._instantLayers = [];
  }
  _makeAndAddFeatureSet(e3, t4 = true, a4 = null) {
    const r4 = F(e3, this._overrideSpatialReference, null === a4 ? ["*"] : a4, t4, this._lrucache, this._interceptor);
    return this._instantLayers.push({ featureset: r4, opitem: e3, includeGeometry: t4, outFields: JSON.stringify(a4) }), r4;
  }
  async featureSetByName(e3, t4 = true, a4 = null) {
    if (m(this._map) && !this._map.loaded) return await this._map.load(), this.featureSetByName(e3, t4, a4);
    null === a4 && (a4 = ["*"]), a4 = (a4 = a4.slice()).sort();
    const r4 = JSON.stringify(a4);
    for (let l3 = 0; l3 < this._instantLayers.length; l3++) {
      const a5 = this._instantLayers[l3];
      if (a5.opitem.title === e3 && a5.includeGeometry === t4 && a5.outFields === r4) return this._instantLayers[l3].featureset;
    }
    const n5 = this._map.allLayers.find((t5) => N(t5) && t5.title === e3);
    if (null != n5) return this._makeAndAddFeatureSet(n5, t4, a4);
    if (this._map.allTables) {
      const r5 = this._map.allTables.find((t5) => N(t5) && t5.title === e3);
      if (null != r5) return this._makeAndAddFeatureSet(r5, t4, a4);
    }
    return null;
  }
  async featureSetById(e3, t4 = true, a4 = ["*"]) {
    if (m(this._map) && !this._map.loaded) return await this._map.load(), this.featureSetById(e3, t4, a4);
    null === a4 && (a4 = ["*"]), a4 = (a4 = a4.slice()).sort();
    const r4 = JSON.stringify(a4);
    for (let l3 = 0; l3 < this._instantLayers.length; l3++) {
      const a5 = this._instantLayers[l3];
      if (a5.opitem.id === e3 && a5.includeGeometry === t4 && a5.outFields === r4) return this._instantLayers[l3].featureset;
    }
    const n5 = this._map.allLayers.find((t5) => N(t5) && t5.id === e3);
    if (n5) return this._makeAndAddFeatureSet(n5, t4, a4);
    if (this._map.allTables) {
      const r5 = this._map.allTables.find((t5) => N(t5) && t5.id === e3);
      if (null != r5) return this._makeAndAddFeatureSet(r5, t4, a4);
    }
    return null;
  }
};
var D3 = class _D extends e {
  constructor(e3, t4 = null, a4 = null, r4 = null) {
    super(), this._url = e3, this._overrideSpatialReference = t4, this._lrucache = a4, this._interceptor = r4, this.metadata = null, this._instantLayers = [];
  }
  get url() {
    return this._url;
  }
  _makeAndAddFeatureSet(e3, t4 = true, a4 = null) {
    const r4 = F(e3, this._overrideSpatialReference, null === a4 ? ["*"] : a4, t4, this._lrucache);
    return this._instantLayers.push({ featureset: r4, opitem: e3, includeGeometry: t4, outFields: JSON.stringify(a4) }), r4;
  }
  async _loadMetaData() {
    const e3 = await A3(this._url, this._lrucache);
    return this.metadata = e3, e3;
  }
  load() {
    return this._loadMetaData();
  }
  clone() {
    return new _D(this._url, this._overrideSpatialReference, this._lrucache, this._interceptor);
  }
  async featureSetByName(e3, t4 = true, a4 = null) {
    null === a4 && (a4 = ["*"]), a4 = (a4 = a4.slice()).sort();
    const r4 = JSON.stringify(a4);
    for (let s5 = 0; s5 < this._instantLayers.length; s5++) {
      const a5 = this._instantLayers[s5];
      if (a5.opitem.title === e3 && a5.includeGeometry === t4 && a5.outFields === r4) return this._instantLayers[s5].featureset;
    }
    const n5 = await this._loadMetaData();
    let l3 = null;
    for (const s5 of n5.layers ?? []) s5.name === e3 && (l3 = s5);
    if (!l3) for (const s5 of n5.tables ?? []) s5.name === e3 && (l3 = s5);
    if (l3) {
      const e4 = await g(this._url + "/" + l3.id, ["*"], this._lrucache);
      return this._makeAndAddFeatureSet(e4, t4, a4);
    }
    return null;
  }
  async featureSetById(e3, t4 = true, a4 = ["*"]) {
    null === a4 && (a4 = ["*"]), a4 = (a4 = a4.slice()).sort();
    const r4 = JSON.stringify(a4);
    e3 = null != e3 ? e3.toString() : "";
    for (let s5 = 0; s5 < this._instantLayers.length; s5++) {
      const a5 = this._instantLayers[s5];
      if (a5.opitem.id === e3 && a5.includeGeometry === t4 && a5.outFields === r4) return this._instantLayers[s5].featureset;
    }
    const n5 = await this._loadMetaData();
    let l3 = null;
    for (const s5 of n5.layers ?? []) null !== s5.id && void 0 !== s5.id && s5.id.toString() === e3 && (l3 = s5);
    if (!l3) for (const s5 of n5.tables ?? []) null !== s5.id && void 0 !== s5.id && s5.id.toString() === e3 && (l3 = s5);
    if (l3) {
      const e4 = await g(this._url + "/" + l3.id, ["*"], this._lrucache);
      return this._makeAndAddFeatureSet(e4, t4, a4);
    }
    return null;
  }
};
function M2(e3, t4, a4 = null, r4 = null) {
  return new j(e3, t4, a4, r4);
}
function b6(e3, t4, a4 = null, r4 = null) {
  return new D3(e3, t4, a4, r4);
}
function v2(e3, t4, n5, l3, s5) {
  if (null === e3) return null;
  if (B(e3)) {
    switch (t4) {
      case "datasource":
        return e3.getDataSourceFeatureSet();
      case "parent":
        return e3;
      case "root":
        return e3.getRootFeatureSet();
    }
    return null;
  }
  if (e3 instanceof b4 && M(e3)) {
    const a4 = e3;
    switch (t4) {
      case "datasource":
        return F(a4, s5, "outFields" in a4 ? a4.outFields : null, true, n5, l3).getDataSourceFeatureSet();
      case "parent":
      case "root":
        return F(a4, s5, "outFields" in a4 ? a4.outFields : null, true, n5, l3);
    }
    return null;
  }
  if (qe(e3)) {
    switch (t4) {
      case "datasource":
        return F(e3.parent, s5, e3.parent.outFields, true, n5, l3).getDataSourceFeatureSet();
      case "parent":
      case "root":
        return F(e3, s5, e3.parent.outFields, true, n5, l3);
    }
    return null;
  }
  return null;
}
async function R(e3, t4, a4, r4, n5, l3, s5, i5 = null) {
  if (a3.applicationCache) {
    const o5 = a3.applicationCache.getLayerInfo(e3 + ":" + l3.url);
    if (o5) return q(await o5, t4, a4, r4, n5, s5, i5);
  }
  if (null != s5) {
    const o5 = s5.getCachedPortalItem(l3.url, e3);
    if (null != o5) return await q(await o5, t4, a4, r4, n5, s5, i5);
  }
  const o4 = new k({ id: e3, portal: l3 }).load();
  a3.applicationCache ? a3.applicationCache.setLayerInfo(e3 + ":" + l3.url, o4) : null != s5 && s5.setCachedPortalItem(l3.url, e3, o4);
  try {
    return await q(await o4, t4, a4, r4, n5, s5, i5);
  } catch (u2) {
    throw a3.applicationCache && a3.applicationCache.clearLayerInfo(e3 + ":" + l3.url), null != s5 && s5.removeCachedPortalItem(l3.url, e3, o4), u2;
  }
}
async function q(e3, t4, a4, r4, n5, l3, s5) {
  let i5;
  if ("Feature Service" === e3.type || "Map Service" === e3.type) i5 = await g(I(e3.url ?? "") + "/" + t4, ["*"], l3);
  else {
    if (t4) throw new Error(`layerId=${t4} provided for ${e3.type} item`);
    if (null != l3) {
      const t5 = l3.getCachedPortalItemLayer(e3.portal.url, e3.id);
      if (null != t5) i5 = await t5;
      else {
        const t6 = b4.fromPortalItem(e3);
        l3.setCachedPortalItemLayer(e3.portal.url, e3.id, t6);
        try {
          i5 = await t6;
        } catch (o4) {
          throw l3.removeCachedPortalItemLayer(e3.portal.url, e3.id, t6), o4;
        }
      }
    } else i5 = await b4.fromPortalItem(e3);
  }
  return F(i5, a4, r4, n5, l3, s5);
}

export {
  h2 as h,
  x2 as x,
  D,
  I2 as I,
  k2 as k,
  b5 as b,
  e2 as e,
  i3 as i,
  s4 as s,
  y2 as y,
  C5 as C,
  k3 as k2,
  F,
  O,
  E3 as E,
  M2 as M,
  b6 as b2,
  v2 as v,
  R
};
//# sourceMappingURL=chunk-IXGT3NHI.js.map
