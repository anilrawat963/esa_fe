import {
  a,
  c as c2,
  d as d2,
  f,
  g2 as g,
  l as l3,
  s as s3
} from "./chunk-3SCRAN3E.js";
import {
  b as b2,
  j as j6,
  q as q4
} from "./chunk-NTNXXNRP.js";
import {
  T,
  X as X2,
  q2 as q3,
  st
} from "./chunk-U6CJFTOF.js";
import {
  J as J2,
  O,
  R as R2,
  U,
  W,
  X,
  j as j4,
  j2 as j5,
  k,
  w
} from "./chunk-2JMKFI2D.js";
import {
  n as n2
} from "./chunk-ZVTEFYZX.js";
import {
  j as j2,
  s
} from "./chunk-LPUPM55U.js";
import {
  l as l2,
  n as n3,
  r as r2
} from "./chunk-WDTGOP77.js";
import {
  A,
  H,
  J,
  P,
  R,
  Z,
  _ as _2,
  c,
  j as j3,
  o as o2,
  p as p2,
  q as q2,
  s as s2,
  v
} from "./chunk-VYMBX5H5.js";
import {
  i
} from "./chunk-YLAGKT2D.js";
import {
  N as N2,
  n,
  r,
  t
} from "./chunk-75XOUSSS.js";
import {
  B,
  E,
  _,
  b,
  d,
  e as e2,
  j,
  o,
  p,
  q
} from "./chunk-AZXJIEZ6.js";
import {
  e
} from "./chunk-Q75WYS7K.js";
import {
  l,
  m
} from "./chunk-SMWUT52Z.js";
import {
  N,
  h
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/views/support/geometry3dUtils.js
function D({ start: t2, end: r3, type: e3 }, i2, u) {
  const a2 = [], f2 = e2(rt, r3, t2), m3 = e2(st2, t2, i2), d3 = p(f2), h2 = 2 * j(f2, m3), l4 = h2 * h2 - 4 * d3 * (p(m3) - u * u);
  if (0 === l4) {
    const n4 = -h2 / (2 * d3);
    (0 === e3 || n4 >= 0) && a2.push(d(n3(), t2, f2, n4));
  } else if (l4 > 0) {
    const n4 = Math.sqrt(l4), r4 = (-h2 + n4) / (2 * d3);
    (0 === e3 || r4 >= 0) && a2.push(d(n3(), t2, f2, r4));
    const o3 = (-h2 - n4) / (2 * d3);
    (0 === e3 || o3 >= 0) && a2.push(d(n3(), t2, f2, o3));
  }
  return a2;
}
function E2(t2, r3) {
  const s4 = t2.start, c3 = t2.end, i2 = e2(rt, c3, s4), u = o2(ot, -i2[1], i2[0], 0), a2 = r3.start, f2 = r3.end, p3 = R(ct, f2, a2), m3 = P(p3, u), d3 = o2(it, s4[0], s4[1], 0), b3 = R(ut, d3, a2), M = P(b3, u), g2 = e();
  if (Math.abs(m3) < g2) return Math.abs(M), [];
  const x = q2(at, a2, p3, M / m3);
  if (0 === r3.type) {
    const t3 = R(ft, x, a2);
    if (P(t3, p3) < -g2) return [];
  }
  if (1 === t2.type) {
    const t3 = B(st2, x, s4);
    if (j(t3, i2) < -g2) return [];
  }
  return [t(x)];
}
function F(t2, n4) {
  return V(Y2(mt, n4[2], t2), n4);
}
function G(t2, n4) {
  const r3 = 0;
  return T2(Y2(mt, r3, t2), Y2(dt, r3, n4)).map(([t3, n5]) => r2(t3, n5));
}
function I(t2, n4, r3) {
  return O2(t2, Y2(mt, t2[2], n4), r3);
}
function K(t2, e3, o3, c3 = n()) {
  const i2 = e2(rt, t2, e3), u = q(i2);
  return d(c3, e3, i2, 0 === u ? 1 : o3 / u), c3[2] = t2[2], c3;
}
function O2(t2, { start: n4, end: r3, type: s4 }, e3 = n()) {
  const o3 = R(et, t2, n4), c3 = R(ot, r3, n4), i2 = P(o3, c3) / P(c3, c3);
  return q2(e3, n4, c3, 0 === s4 ? Math.max(i2, 0) : i2);
}
var R3 = (() => {
  const t2 = n(), n4 = n(), r3 = n();
  return ({ start: s4, end: e3 }, { center: o3, radius: c3, normal: i2, slicePlane: a2 }) => {
    const f2 = U(o3, i2, pt);
    if ($(W(f2, s4), 0) && $(W(f2, e3), 0)) {
      j4(i2, t2, n4);
      const f3 = (s5, e4) => (c(r3, e4, o3), o(s5, P(r3, t2), P(r3, n4)), s5), p4 = g({ start: f3(rt, s4), end: f3(st2, e3), type: 1 }, l2, c3), m3 = [];
      for (const [r4, s5] of p4) {
        const e4 = s2(n(), o3);
        q2(e4, e4, t2, r4), q2(e4, e4, n4, s5), a2 && !tt(a2, e4) || m3.push(e4);
      }
      return m3;
    }
    const p3 = n();
    return J2(f2, s4, e3, p3) ? !$(p2(p3, o3), c3) || a2 && !tt(a2, p3) ? [] : [p3] : [];
  };
})();
function S({ start: t2, end: r3, type: s4 }, e3, i2) {
  const u = [], a2 = c(et, r3, t2), f2 = e2(st2, t2, e3), p3 = p(a2), m3 = 2 * j(a2, f2), d3 = m3 * m3 - 4 * p3 * (p(f2) - i2 * i2);
  if (0 === d3) {
    const n4 = -m3 / (2 * p3);
    (1 === s4 || n4 >= 0) && u.push(q2(n(), t2, a2, n4));
  } else if (d3 > 0) {
    const n4 = Math.sqrt(d3), r4 = (-m3 + n4) / (2 * p3);
    (1 === s4 || r4 >= 0) && u.push(q2(n(), t2, a2, r4));
    const e4 = (-m3 - n4) / (2 * p3);
    (1 === s4 || e4 >= 0) && u.push(q2(n(), t2, a2, e4));
  }
  return u;
}
function T2(t2, n4) {
  const r3 = t2.start, s4 = t2.end, e3 = n4.start, o3 = n4.end, c3 = R(et, s4, r3), i2 = R(ot, o3, e3), u = R(ct, e3, r3), a2 = _2(it, c3, i2);
  if (!$(P(u, a2), 0)) return [];
  const f2 = Z(a2);
  if ($(f2, 0)) return [];
  const p3 = _2(ut, u, i2), m3 = P(p3, a2) / f2, d3 = q2(at, r3, c3, m3);
  if (0 === t2.type) {
    const t3 = R(ft, d3, r3);
    if (P(c3, t3) < -e()) return [];
  }
  if (0 === n4.type) {
    const t3 = R(ft, d3, e3);
    if (P(i2, t3) < -e()) return [];
  }
  return [t(d3)];
}
function V({ start: t2, end: n4, type: r3 }, s4) {
  const e3 = R(et, s4, t2), o3 = R(ot, n4, t2), c3 = _2(ct, o3, e3), i2 = Z(c3) / Z(o3), u = e();
  if (i2 < u) switch (r3) {
    case 1:
      return [t(s4)];
    case 0:
      return P(o3, e3) < -u ? [] : [t(s4)];
  }
  return [];
}
function X3(t2, n4, r3, s4) {
  const [e3, o3] = t2, [c3, u] = r3, a2 = c3 - e3, f2 = u - o3, p3 = a2 * a2 + f2 * f2, d3 = Math.sqrt(p3);
  if (d3 > n4 + s4) return [];
  if (d3 < Math.abs(n4 - s4)) return [];
  if ($(d3, 0) && $(n4, s4)) return [];
  const h2 = (n4 * n4 - s4 * s4 + p3) / (2 * d3), l4 = Math.sqrt(n4 * n4 - h2 * h2), y = l4 * f2 / d3, j7 = l4 * a2 / d3, [b3, M] = _(rt, t2, r3, h2 / d3);
  return $(y, j7) ? [r2(b3, M)] : [r2(b3 + y, M - j7), r2(b3 - y, M + j7)];
}
function Y2(t2, n4, { start: r3, end: s4, type: e3 }) {
  return o2(t2.start, r3[0], r3[1], n4), o2(t2.end, s4[0], s4[1], n4), t2.type = nt[e3], t2;
}
function Z2(t2, n4) {
  return $(t2[2], n4[2]);
}
function $(n4, r3) {
  return m(Math.abs(n4 - r3), 0, e());
}
function _3(t2, n4) {
  return n4.filter((n5) => tt(t2, n5));
}
function tt(t2, n4) {
  return O(t2, n4);
}
var nt = { 0: 1, 1: 0 };
var rt = n3();
var st2 = n3();
var et = n();
var ot = n();
var ct = n();
var it = n();
var ut = n();
var at = n();
var ft = n();
var pt = j5();
var mt = { start: n(), end: n(), type: 1 };
var dt = { start: n(), end: n(), type: 1 };

// node_modules/@arcgis/core/views/interactive/sketch/constraints.js
var lt = class {
  intersect(t2) {
    return Et(this, t2);
  }
  closestPoints(t2) {
    return [this.closestTo(t2)];
  }
};
var dt2 = class extends lt {
  constructor(t2) {
    super(), this.point = t2;
  }
  equals(t2) {
    return this === t2 || me(t2) && H(this.point, t2.point);
  }
  closestTo() {
    return d2(this.point);
  }
};
var pt2 = class extends lt {
  constructor(t2, e3, s4) {
    super(), this.start = t2, this.end = e3, this.lineLike = { start: t2, end: e3, type: s4 };
  }
  equals(t2) {
    return this === t2 || ge(t2) && this.lineLike.type === t2.lineLike.type && H(this.start, t2.start) && H(this.end, t2.end);
  }
  closestTo(t2) {
    const e3 = f();
    return O2(t2, this.lineLike, e3), e3;
  }
};
var mt2 = class extends pt2 {
  constructor(t2, e3) {
    super(t2, e3, 1);
  }
};
var gt = class extends pt2 {
  constructor(t2, e3) {
    super(t2, e3, 0);
  }
};
var _t = class extends lt {
  constructor(t2) {
    super(), this.constraints = t2;
  }
  equals(t2) {
    return this === t2 || pe(t2) && h(this.constraints, t2.constraints, (t3, e3) => t3.equals(e3));
  }
  closestTo(t2) {
    let e3, s4 = 1 / 0;
    for (const n4 of this.constraints) {
      const r3 = n4.closestTo(t2), i2 = v(t2, r3);
      i2 < s4 && (s4 = i2, e3 = r3);
    }
    return d2(e3 ?? t2);
  }
  closestPoints(t2) {
    return this.constraints.flatMap((e3) => e3 === this ? [] : e3.closestPoints(t2));
  }
};
var kt = class extends lt {
  constructor(t2, e3) {
    super(), this.center = t2, this.radius = e3;
  }
  equals(t2) {
    return this === t2 || Le(t2) && this.center[0] === t2.center[0] && this.center[1] === t2.center[1] && this.radius === t2.radius;
  }
  closestTo(t2) {
    const e3 = f();
    return K(t2, this.center, this.radius, e3), e3;
  }
};
var Lt = class extends lt {
  constructor(t2, e3) {
    super(), this.center = t2, this.radius = e3;
  }
  equals(t2) {
    return this === t2 || xe(t2) && H(this.center, t2.center) && this.radius === t2.radius;
  }
  closestTo(t2) {
    const e3 = f();
    return K(t2, this.center, this.radius, e3), e3[2] = this.center[2], e3;
  }
  asCircle() {
    return new xt(d2(this.center), this.radius, a(0, 0, 1));
  }
};
var xt = class extends lt {
  constructor(t2, e3, s4, n4 = void 0) {
    super(), this.center = t2, this.radius = e3, this.normal = s4, this.slicePlane = n4;
  }
  equals(t2) {
    return this === t2 || ye(t2) && H(this.center, t2.center) && H(this.normal, t2.normal) && this.radius === t2.radius;
  }
  closestTo(t2) {
    const { center: e3, radius: s4 } = this;
    R2(this.getPlane(zt), t2, yt);
    const n4 = R(yt, yt, e3), r3 = j3(n4);
    if ($(r3, 0)) return d2(t2);
    const i2 = s4 / Math.sqrt(r3), o3 = f();
    q2(o3, e3, n4, i2);
    const { slicePlane: c3 } = this;
    if (c3 && !tt(c3, o3)) {
      const e4 = Ht(c3, this);
      return e4?.closestTo(t2) ?? d2(t2);
    }
    return o3;
  }
  getPlane(t2 = j5()) {
    return U(this.center, this.normal, t2);
  }
};
var yt = n();
var zt = j5();
var Mt = class extends lt {
  constructor(t2) {
    super(), this.z = t2;
  }
  equals(t2) {
    return this === t2 || _e(t2) && this.z === t2.z;
  }
  closestTo(t2) {
    return a(t2[0], t2[1], this.z);
  }
  getPlane(t2 = j5()) {
    return o2(Pt, 0, 0, this.z), U(Pt, N2, t2);
  }
};
var Pt = n();
var Tt = class extends lt {
  constructor(t2, e3, s4) {
    super(), this.start = t2, this.end = e3, this.planeLike = { start: s3(t2), end: s3(e3), type: s4 };
  }
  equals(t2) {
    return this === t2 || ke(t2) && this.planeLike.type === t2.planeLike.type && H(this.start, t2.start) && H(this.end, t2.end);
  }
  closestTo(t2) {
    const e3 = f();
    return I(t2, this.planeLike, e3), e3;
  }
  closestEndTo(t2) {
    const { start: e3, end: s4 } = this.planeLike;
    return Math.sign(j(e2(qt, s4, e3), e2(wt, s3(t2), e3))) > 0 ? this.end : this.start;
  }
  getPlane(t2 = j5()) {
    const e3 = s2(jt, this.end);
    return e3[2] += 1, w(this.start, this.end, e3, t2);
  }
  getSlicePlane(t2 = j5()) {
    const { start: e3, end: s4, type: n4 } = this.planeLike;
    if (0 === n4) return;
    const r3 = o2(jt, e3[0], e3[1], 0), i2 = o2(vt, s4[0], s4[1], 0), o3 = c(vt, i2, r3);
    return U(r3, o3, t2), t2;
  }
};
var qt = n3();
var wt = n3();
var jt = n();
var vt = n();
var Dt = class extends Tt {
  constructor(t2, e3) {
    super(t2, e3, 1);
  }
};
var bt = class extends Tt {
  constructor(t2, e3) {
    super(t2, e3, 0);
  }
};
var Rt = class extends lt {
  constructor(t2, e3) {
    super(), this.sphere = q3(t2, e3), this._center = t(t2);
  }
  equals(t2) {
    return this === t2 || ze(t2) && T(this.sphere, t2.sphere);
  }
  closestTo(t2) {
    const e3 = f();
    return st(this.sphere, t2, e3), e3;
  }
  get center() {
    return this._center;
  }
  get radius() {
    return this.sphere[3];
  }
};
var At = class extends lt {
  constructor(t2, e3, s4) {
    super(), this.start = t2, this.end = e3, this.getZ = s4, this.planeLike = { start: s3(t2), end: s3(e3), type: 0 };
  }
  equals(t2) {
    return this === t2 || Me(t2) && H(this.start, t2.start) && H(this.end, t2.end) && this.getZ === t2.getZ;
  }
  closestTo(t2) {
    return Ot(this, t2);
  }
  addIfOnTheGround(t2, e3) {
    for (const s4 of e3) {
      const e4 = this.getZ(s4[0], s4[1]) ?? 0;
      $(s4[2], e4) && (s4[2] = e4, t2.push(s4));
    }
  }
};
var Zt = class extends lt {
  constructor(t2, e3, s4) {
    super(), this._x = t2, this._y = e3, this._z = s4;
  }
  equals(t2) {
    return this === t2 || Te(t2) && this._x === t2._x && this._y === t2._y && this._z === t2._z;
  }
  closestTo([t2, e3, s4]) {
    return l3(this._x ?? t2, this._y ?? e3, this._z ?? s4);
  }
};
var Ut = class extends lt {
  constructor(t2, e3, s4, n4, r3) {
    super(), this._origin = t2, this._spatialReference = e3, this._distanceMeters = s4, this._z = n4, this._directionDegrees = r3;
  }
  equals(t2) {
    return this === t2 || Pe(t2) && E(this._origin, t2._origin) && this._spatialReference === t2._spatialReference && this._distanceMeters === t2._distanceMeters && this._z === t2._z && this._directionDegrees === t2._directionDegrees;
  }
  closestTo([t2, e3, s4]) {
    return o(Gt, t2, e3), E(Gt, this._origin) || this._applyDirectionAndDistance(Gt), l3(Gt[0], Gt[1], this._z ?? s4);
  }
  _applyDirectionAndDistance(t2) {
    if (null != this._directionDegrees && null != this._distanceMeters) j6(t2, this._origin, this._directionDegrees, this._distanceMeters, this._spatialReference);
    else if (null != this._directionDegrees) St(t2, this._origin, this._directionDegrees, t2, this._spatialReference);
    else if (null != this._distanceMeters) {
      const { azimuth: e3 } = q4(It, this._origin, t2, this._spatialReference);
      j6(t2, this._origin, e3 ?? 0, this._distanceMeters, this._spatialReference);
    }
  }
};
var Gt = [0, 0];
var It = new b2();
function St(t2, e3, s4, n4, r3) {
  let { azimuth: i2, distance: o3 } = q4(Ct, e3, n4, r3);
  i2 ??= 0;
  let c3 = o3 * Math.cos((i2 - s4) * i);
  c3 = Math.max(0, c3), j6(t2, e3, s4, c3, r3);
}
var Ct = new b2();
function Ot(t2, e3) {
  const s4 = f();
  return I(e3, t2.planeLike, s4), s4[2] = t2.getZ(s4[0], s4[1]) ?? qe, s4;
}
function Et(t2, e3) {
  if (pe(t2)) {
    const s4 = [];
    for (const n4 of t2.constraints) {
      const t3 = n4.intersect(e3);
      t3 && s4.push(t3);
    }
    return de(s4);
  }
  if (pe(e3)) return Et(e3, t2);
  if (Me(t2)) return ae(t2, e3);
  if (Me(e3)) return ae(e3, t2);
  if (me(t2)) {
    const { point: s4 } = t2;
    if (me(e3)) return H(s4, e3.point) ? t2 : void 0;
    const n4 = e3.closestTo(s4);
    return J(n4, s4) ? t2 : void 0;
  }
  if (ge(t2)) {
    if (me(e3)) return Et(e3, t2);
    if (ge(e3)) return fe(T2(t2.lineLike, e3.lineLike));
    if (_e(e3)) return Vt(t2, e3);
    if (ke(e3)) return fe(E2(e3.planeLike, t2.lineLike));
    if (Le(e3)) return fe(S(t2.lineLike, e3.center, e3.radius));
    if (ye(e3)) return fe(R3(t2.lineLike, e3));
    if (xe(e3)) return Bt(t2, e3);
    if (ze(e3)) return Ft(t2, e3);
  } else if (_e(t2)) {
    if (me(e3) || ge(e3)) return Et(e3, t2);
    if (_e(e3)) return Jt(t2, e3);
    if (ke(e3)) return Kt(t2, e3);
    if (Le(e3)) return Nt(t2, e3);
    if (ye(e3)) return Wt(t2, e3);
    if (xe(e3)) return Qt(t2, e3);
    if (ze(e3)) return Xt(t2, e3);
  } else if (ke(t2)) {
    if (me(e3) || ge(e3) || _e(e3)) return Et(e3, t2);
    if (ke(e3)) return he(G(t2.planeLike, e3.planeLike));
    if (Le(e3)) return he(D(t2.planeLike, e3.center, e3.radius));
    if (ye(e3)) return $t(t2, e3);
    if (xe(e3)) return Yt(t2, e3);
    if (ze(e3)) return te(t2, e3);
  } else if (Le(t2)) {
    if (me(e3) || ge(e3) || _e(e3) || ke(e3)) return Et(e3, t2);
    if (Le(e3)) return he(X3(s3(t2.center), t2.radius, s3(e3.center), e3.radius));
    if (ye(e3)) return ee();
    if (xe(e3)) return se(t2, e3);
    if (ze(e3)) return ne();
  } else if (ye(t2)) {
    if (me(e3) || ge(e3) || _e(e3) || ke(e3) || Le(e3)) return Et(e3, t2);
    if (ye(e3)) return re();
    if (xe(e3)) return re(e3.asCircle());
    if (ze(e3)) return ie();
  } else if (xe(t2)) {
    if (me(e3) || ge(e3) || _e(e3) || ke(e3) || Le(e3) || ye(e3)) return Et(e3, t2);
    if (xe(e3)) return oe(e3, t2);
    if (ze(e3)) return ce();
  } else if (ze(t2)) {
    if (me(e3) || ge(e3) || _e(e3) || ke(e3) || Le(e3) || xe(e3)) return Et(e3, t2);
    if (ze(e3)) return ue();
  }
}
var Vt = (() => {
  const t2 = j5();
  return (e3, s4) => {
    const { start: n4, end: r3 } = e3;
    if (Z2(n4, r3) && $(n4[2], s4.z)) return e3;
    const i2 = f();
    return J2(s4.getPlane(t2), n4, r3, i2) ? new dt2(i2) : void 0;
  };
})();
function Bt({ lineLike: t2 }, { center: e3, radius: s4 }) {
  const n4 = e3[2];
  return fe(S(t2, e3, s4).filter((t3) => $(t3[2], n4)));
}
function Ft({ lineLike: t2 }, { sphere: e3 }) {
  return fe(X2(e3, t2.start, t2.end));
}
var Ht = (() => {
  const t2 = n2(), e3 = n(), n4 = n();
  return (r3, i2, o3) => {
    const { normal: c3, center: u, radius: a2 } = i2;
    j4(c3, e3, n4);
    const h2 = k(r3), f2 = a2 * P(h2, e3), l4 = a2 * P(h2, n4);
    s(t2, u[0], u[1], u[2], 1);
    const d3 = j2(r3, t2), m3 = Math.hypot(f2, l4), g2 = $(m3, 0);
    if ($(W(r3, u), 0)) {
      if (g2) return i2;
      if ($(a2, 0)) return !o3 || tt(o3, u) ? new dt2(d2(u)) : void 0;
      _2(e3, h2, c3), A(e3, e3);
      const t3 = new Array(), s4 = t(u);
      q2(s4, s4, e3, a2), o3 && !tt(o3, s4) || t3.push(s4);
      const n5 = t(u);
      return q2(n5, n5, e3, -a2), o3 && !tt(o3, n5) || t3.push(n5), fe(t3);
    }
    if (g2) return;
    const _4 = -d3 / m3;
    if (Math.abs(_4) > 1 || $(_4, 1)) return;
    const z = Math.atan(f2 / l4), M = l(_4) - z, w2 = Math.PI - M, j7 = new Array(), v2 = n();
    q2(v2, u, e3, a2 * Math.cos(M)), q2(v2, v2, n4, a2 * Math.sin(M)), j7.push(v2);
    const D2 = n();
    return q2(D2, u, e3, a2 * Math.cos(w2)), q2(D2, D2, n4, a2 * Math.sin(w2)), j7.push(D2), fe(o3 ? _3(o3, j7) : j7);
  };
})();
function Jt(t2, e3) {
  return $(t2.z, e3.z) ? t2 : void 0;
}
function Kt({ z: t2 }, { planeLike: e3 }) {
  const [s4, n4] = e3.start, [r3, i2] = e3.end, o3 = a(s4, n4, t2), c3 = a(r3, i2, t2);
  return 0 === e3.type ? new mt2(o3, c3) : new gt(o3, c3);
}
function Nt(t2, e3) {
  const [s4, n4] = e3.center;
  return new Lt(a(s4, n4, t2.z), e3.radius);
}
function Qt(t2, e3) {
  return $(e3.center[2], t2.z) ? e3 : void 0;
}
var Wt = (() => {
  const t2 = j5();
  return (e3, s4) => Ht(e3.getPlane(t2), s4, s4.slicePlane);
})();
function Xt(t2, { center: e3, radius: s4 }) {
  const n4 = Math.abs(e3[2] - t2.z);
  if (n4 > s4 && !$(n4, s4)) return;
  const r3 = a(e3[0], e3[1], t2.z), i2 = Math.sqrt(s4 ** 2 - n4 ** 2);
  return $(i2, 0) ? void 0 : new Lt(r3, i2);
}
var Yt = (() => {
  const t2 = j5();
  return (e3, { center: s4, radius: n4 }) => {
    const r3 = D(e3.planeLike, s4, n4), i2 = s4[2];
    e3.getSlicePlane(t2);
    const o3 = new Array();
    for (const [c3, u] of r3) {
      const e4 = [c3, u, i2];
      tt(t2, e4) && o3.push(e4);
    }
    return fe(o3);
  };
})();
var $t = (() => {
  const t2 = j5(), e3 = j5();
  return (s4, n4) => Ht(s4.getPlane(t2), n4, s4.getSlicePlane(e3));
})();
var te = (() => {
  const t2 = j5();
  return (e3, { center: s4, radius: n4 }) => {
    const r3 = e3.getPlane(t2), i2 = X(r3, s4), o3 = Math.abs(i2);
    if (o3 > n4 && !$(o3, n4)) return;
    const c3 = Math.sqrt(n4 ** 2 - i2 ** 2);
    if ($(c3, 0)) {
      const t3 = f();
      return R2(r3, s4, t3), new dt2(t3);
    }
    const u = f(), a2 = t(k(r3));
    return q2(u, s4, a2, i2), new xt(u, c3, a2, e3.getSlicePlane());
  };
})();
function ee(t2, e3) {
}
function se(t2, e3) {
  const s4 = b(s3(t2.center), s3(e3.center));
  if ($(s4, 0) && $(t2.radius, e3.radius)) return e3;
  return le(X3(s3(t2.center), t2.radius, s3(e3.center), e3.radius), e3.center[2]);
}
function ne(t2, e3) {
}
function re(t2, e3) {
}
function ie(t2, e3) {
}
function oe(t2, e3) {
  if (!Z2(t2.center, e3.center)) return;
  const s4 = b(s3(t2.center), s3(e3.center));
  if ($(s4, 0) && $(t2.radius, e3.radius)) return t2;
  return le(X3(s3(t2.center), t2.radius, s3(e3.center), e3.radius), t2.center[2]);
}
function ce(t2, e3) {
}
function ue(t2, e3) {
}
function ae(t2, e3) {
  const { planeLike: s4, getZ: n4 } = t2, r3 = new Array();
  if (me(e3)) t2.addIfOnTheGround(r3, F(s4, e3.point));
  else if (ge(e3)) t2.addIfOnTheGround(r3, E2(s4, e3.lineLike));
  else if (Le(e3)) for (const [i2, o3] of D(s4, e3.center, e3.radius)) {
    const t3 = n4(i2, o3);
    null != t3 && r3.push(r(i2, o3, t3));
  }
  else if (ke(e3) || Me(e3)) for (const [i2, o3] of G(s4, e3.planeLike)) {
    const t3 = n4(i2, o3) ?? qe;
    r3.push(r(i2, o3, t3));
  }
  return fe(r3);
}
function he(t2) {
  return de(t2.map(([t3, e3]) => {
    const s4 = a(t3, e3, 0), n4 = a(t3, e3, 1);
    return new mt2(s4, n4);
  }));
}
function fe(t2) {
  return de(t2.map((t3) => t3 ? new dt2(c2(t3)) : void 0));
}
function le(t2, e3) {
  return fe(t2.map(([t3, s4]) => [t3, s4, e3]));
}
function de(e3) {
  if (0 !== e3.length) return 1 === e3.length ? e3[0] ?? void 0 : new _t(e3.filter(N));
}
function pe(t2) {
  return t2 instanceof _t;
}
function me(t2) {
  return t2 instanceof dt2;
}
function ge(t2) {
  return t2 instanceof pt2;
}
function _e(t2) {
  return t2 instanceof Mt;
}
function ke(t2) {
  return t2 instanceof Tt;
}
function Le(t2) {
  return t2 instanceof kt;
}
function xe(t2) {
  return t2 instanceof Lt;
}
function ye(t2) {
  return t2 instanceof xt;
}
function ze(t2) {
  return t2 instanceof Rt;
}
function Me(t2) {
  return t2 instanceof At;
}
function Pe(t2) {
  return t2 instanceof Ut;
}
function Te(t2) {
  return t2 instanceof Zt;
}
var qe = 0;

export {
  O2 as O,
  dt2 as dt,
  mt2 as mt,
  kt,
  Mt,
  Dt,
  bt,
  At,
  Zt,
  Ut,
  de,
  me
};
//# sourceMappingURL=chunk-BQ6DEXWK.js.map
