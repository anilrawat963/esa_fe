import {
  t as t4,
  t2 as t6
} from "./chunk-VIMURIWZ.js";
import {
  o as o2
} from "./chunk-U3B7YMY7.js";
import {
  T,
  V,
  l as l2,
  t as t5
} from "./chunk-PG6JVA4Q.js";
import {
  c,
  t as t3
} from "./chunk-XMUWUWWP.js";
import {
  _,
  a as a3,
  i as i2
} from "./chunk-VR2ODL2Y.js";
import {
  C
} from "./chunk-QENBEP2X.js";
import {
  t as t2
} from "./chunk-VZQ643XD.js";
import {
  a as a2,
  d as d2,
  e,
  f,
  h,
  h2,
  i,
  n as n3,
  o,
  p,
  r,
  s
} from "./chunk-SMJWJAIA.js";
import {
  e as e2
} from "./chunk-M5JMVUW2.js";
import "./chunk-XTEXJOLG.js";
import "./chunk-ALR6N4CF.js";
import "./chunk-4X4BOGIG.js";
import {
  n as n2
} from "./chunk-IOJ4QFRL.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import "./chunk-SJ2OBYX2.js";
import "./chunk-SHPBZTDJ.js";
import "./chunk-JE2NJSBU.js";
import "./chunk-QNVJVDYZ.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import "./chunk-CCQFL76O.js";
import "./chunk-GY6YF4EN.js";
import "./chunk-SMWUT52Z.js";
import "./chunk-AXZMNHTN.js";
import "./chunk-5T3MJDSR.js";
import "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import {
  t
} from "./chunk-5EI5H4QX.js";
import "./chunk-ZIE53VIV.js";
import "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import {
  a,
  d,
  n
} from "./chunk-GNMPGHLQ.js";
import {
  l3 as l
} from "./chunk-QY7XKUIV.js";
import "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/ScriptUtils.js
function e3(e5) {
  return 746 === e5 || 747 === e5 || !(e5 < 4352) && (e5 >= 12704 && e5 <= 12735 || (e5 >= 12544 && e5 <= 12591 || (e5 >= 65072 && e5 <= 65103 && !(e5 >= 65097 && e5 <= 65103) || (e5 >= 63744 && e5 <= 64255 || (e5 >= 13056 && e5 <= 13311 || (e5 >= 11904 && e5 <= 12031 || (e5 >= 12736 && e5 <= 12783 || (e5 >= 12288 && e5 <= 12351 && !(e5 >= 12296 && e5 <= 12305 || e5 >= 12308 && e5 <= 12319 || 12336 === e5) || (e5 >= 13312 && e5 <= 19903 || (e5 >= 19968 && e5 <= 40959 || (e5 >= 12800 && e5 <= 13055 || (e5 >= 12592 && e5 <= 12687 || (e5 >= 43360 && e5 <= 43391 || (e5 >= 55216 && e5 <= 55295 || (e5 >= 4352 && e5 <= 4607 || (e5 >= 44032 && e5 <= 55215 || (e5 >= 12352 && e5 <= 12447 || (e5 >= 12272 && e5 <= 12287 || (e5 >= 12688 && e5 <= 12703 || (e5 >= 12032 && e5 <= 12255 || (e5 >= 12784 && e5 <= 12799 || (e5 >= 12448 && e5 <= 12543 && 12540 !== e5 || (e5 >= 65280 && e5 <= 65519 && !(65288 === e5 || 65289 === e5 || 65293 === e5 || e5 >= 65306 && e5 <= 65310 || 65339 === e5 || 65341 === e5 || 65343 === e5 || e5 >= 65371 && e5 <= 65503 || 65507 === e5 || e5 >= 65512 && e5 <= 65519) || (e5 >= 65104 && e5 <= 65135 && !(e5 >= 65112 && e5 <= 65118 || e5 >= 65123 && e5 <= 65126) || (e5 >= 5120 && e5 <= 5759 || (e5 >= 6320 && e5 <= 6399 || (e5 >= 65040 && e5 <= 65055 || (e5 >= 19904 && e5 <= 19967 || (e5 >= 40960 && e5 <= 42127 || e5 >= 42128 && e5 <= 42191)))))))))))))))))))))))))))));
}
function c2(e5) {
  return !(e5 < 11904) && (e5 >= 12704 && e5 <= 12735 || (e5 >= 12544 && e5 <= 12591 || (e5 >= 65072 && e5 <= 65103 || (e5 >= 63744 && e5 <= 64255 || (e5 >= 13056 && e5 <= 13311 || (e5 >= 11904 && e5 <= 12031 || (e5 >= 12736 && e5 <= 12783 || (e5 >= 12288 && e5 <= 12351 || (e5 >= 13312 && e5 <= 19903 || (e5 >= 19968 && e5 <= 40959 || (e5 >= 12800 && e5 <= 13055 || (e5 >= 65280 && e5 <= 65519 || (e5 >= 12352 && e5 <= 12447 || (e5 >= 12272 && e5 <= 12287 || (e5 >= 12032 && e5 <= 12255 || (e5 >= 12784 && e5 <= 12799 || (e5 >= 12448 && e5 <= 12543 || (e5 >= 65040 && e5 <= 65055 || (e5 >= 42128 && e5 <= 42191 || e5 >= 40960 && e5 <= 42127)))))))))))))))))));
}
function s2(e5) {
  switch (e5) {
    case 10:
    case 32:
    case 38:
    case 40:
    case 41:
    case 43:
    case 45:
    case 47:
    case 173:
    case 183:
    case 8203:
    case 8208:
    case 8211:
    case 8231:
      return true;
  }
  return false;
}
function a4(e5) {
  switch (e5) {
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 32:
      return true;
  }
  return false;
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TextShaping.js
var c3 = 24;
var h3 = 17;
var l3 = class {
  constructor(t8, e5, i4, o5, s4, c4, h5) {
    this._glyphItems = t8, this._maxWidth = e5, this._lineHeight = i4, this._letterSpacing = o5, this._hAnchor = s4, this._vAnchor = c4, this._justify = h5;
  }
  getShaping(s4, c4, h5) {
    const l4 = this._letterSpacing, n6 = this._lineHeight, a6 = this._justify, r7 = this._maxWidth, m3 = [];
    let f3 = 0, p3 = 0;
    for (const t8 of s4) {
      const e5 = t8.codePointAt(0);
      if (null == e5) continue;
      const o5 = h5 && e3(e5);
      let s5;
      for (const t9 of this._glyphItems) if (s5 = t9[e5], s5) break;
      m3.push({ codePoint: e5, x: f3, y: p3, vertical: o5, glyphMosaicItem: s5 }), s5 && (f3 += s5.metrics.advance + l4);
    }
    let g = f3;
    if (r7 > 0) {
      g = f3 / Math.max(1, Math.ceil(f3 / r7));
    }
    const y3 = s4.includes("â€‹"), d4 = [], x2 = m3.length;
    for (let e5 = 0; e5 < x2 - 1; e5++) {
      const i4 = m3[e5].codePoint, s5 = c2(i4);
      if (s2(i4) || s5) {
        let t8 = 0;
        if (10 === i4) t8 -= 1e4;
        else if (s5 && y3) t8 += 150;
        else {
          40 !== i4 && 65288 !== i4 || (t8 += 50);
          const o5 = m3[e5 + 1].codePoint;
          41 !== o5 && 65289 !== o5 || (t8 += 50);
        }
        d4.push(this._buildBreak(e5 + 1, m3[e5].x, g, d4, t8, false));
      }
    }
    const u3 = this._optimalBreaks(this._buildBreak(x2, f3, g, d4, 0, true));
    let M = 0;
    const _2 = c4 ? -n6 : n6;
    let I = 0;
    for (let t8 = 0; t8 < u3.length; t8++) {
      const i4 = u3[t8];
      let o5 = I;
      for (; o5 < i4 && a4(m3[o5].codePoint); ) m3[o5].glyphMosaicItem = null, ++o5;
      let s5 = i4 - 1;
      for (; s5 > o5 && a4(m3[s5].codePoint); ) m3[s5].glyphMosaicItem = null, --s5;
      if (o5 <= s5) {
        const t9 = m3[o5].x;
        for (let i5 = o5; i5 <= s5; i5++) m3[i5].x -= t9, m3[i5].y = p3;
        let e5 = m3[s5].x;
        m3[s5].glyphMosaicItem && (e5 += m3[s5].glyphMosaicItem.metrics.advance), M = Math.max(e5, M), a6 && this._applyJustification(m3, o5, s5);
      }
      I = i4, p3 += _2;
    }
    if (m3.length > 0) {
      const t8 = u3.length - 1, e5 = (a6 - this._hAnchor) * M;
      let i4 = (-this._vAnchor * (t8 + 1) + 0.5) * n6;
      c4 && t8 && (i4 += t8 * n6);
      for (const o5 of m3) o5.x += e5, o5.y += i4;
    }
    return m3.filter((t8) => t8.glyphMosaicItem);
  }
  static getTextBox(t8, e5) {
    if (!t8.length) return null;
    let i4 = 1 / 0, o5 = 1 / 0, s4 = 0, c4 = 0;
    for (const l4 of t8) {
      const t9 = l4.glyphMosaicItem.metrics.advance, n6 = l4.x, a6 = l4.y - h3, r7 = n6 + t9, m3 = a6 + e5;
      i4 = Math.min(i4, n6), s4 = Math.max(s4, r7), o5 = Math.min(o5, a6), c4 = Math.max(c4, m3);
    }
    return { x: i4, y: o5, width: s4 - i4, height: c4 - o5 };
  }
  static getBox(t8) {
    if (!t8.length) return null;
    let e5 = 1 / 0, i4 = 1 / 0, o5 = 0, s4 = 0;
    for (const c4 of t8) {
      const { height: t9, left: h5, top: l4, width: n6 } = c4.glyphMosaicItem.metrics, a6 = c4.x, r7 = c4.y - (t9 - Math.abs(l4)), m3 = a6 + n6 + h5, f3 = r7 + t9;
      e5 = Math.min(e5, a6), o5 = Math.max(o5, m3), i4 = Math.min(i4, r7), s4 = Math.max(s4, f3);
    }
    return { x: e5, y: i4, width: o5 - e5, height: s4 - i4 };
  }
  static addDecoration(t8, e5) {
    const i4 = t8.length;
    if (0 === i4) return;
    const o5 = 3;
    let c4 = t8[0].x + t8[0].glyphMosaicItem.metrics.left, h5 = t8[0].y;
    for (let n6 = 1; n6 < i4; n6++) {
      const i5 = t8[n6];
      if (i5.y !== h5) {
        const l5 = t8[n6 - 1].x + t8[n6 - 1].glyphMosaicItem.metrics.left + t8[n6 - 1].glyphMosaicItem.metrics.width;
        t8.push({ codePoint: 0, x: c4, y: h5 + e5 - o5, vertical: false, glyphMosaicItem: { sdf: true, rect: new t2(4, 0, 4, 8), metrics: { width: l5 - c4, height: 2 + 2 * o5, left: 0, top: 0, advance: 0 }, page: 0, code: 0 } }), h5 = i5.y, c4 = i5.x + i5.glyphMosaicItem.metrics.left;
      }
    }
    const l4 = t8[i4 - 1].x + t8[i4 - 1].glyphMosaicItem.metrics.left + t8[i4 - 1].glyphMosaicItem.metrics.width;
    t8.push({ codePoint: 0, x: c4, y: h5 + e5 - o5, vertical: false, glyphMosaicItem: { sdf: true, rect: new t2(4, 0, 4, 8), metrics: { width: l4 - c4, height: 2 + 2 * o5, left: 0, top: 0, advance: 0 }, page: 0, code: 0 } });
  }
  _breakScore(t8, e5, i4, o5) {
    const s4 = (t8 - e5) * (t8 - e5);
    return o5 ? t8 < e5 ? s4 / 2 : 2 * s4 : s4 + Math.abs(i4) * i4;
  }
  _buildBreak(t8, e5, i4, o5, s4, c4) {
    let h5 = null, l4 = this._breakScore(e5, i4, s4, c4);
    for (const n6 of o5) {
      const t9 = e5 - n6.x, o6 = this._breakScore(t9, i4, s4, c4) + n6.score;
      o6 <= l4 && (h5 = n6, l4 = o6);
    }
    return { index: t8, x: e5, score: l4, previousBreak: h5 };
  }
  _optimalBreaks(t8) {
    return t8 ? this._optimalBreaks(t8.previousBreak).concat(t8.index) : [];
  }
  _applyJustification(t8, e5, i4) {
    const o5 = t8[i4], s4 = o5.vertical ? c3 : o5.glyphMosaicItem ? o5.glyphMosaicItem.metrics.advance : 0, h5 = (o5.x + s4) * this._justify;
    for (let c4 = e5; c4 <= i4; c4++) t8[c4].x -= h5;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/Placement.js
var m = 0.5;
var x = 2;
var d3 = class {
  constructor(e5, t8, i4 = 0, n6 = -1, s4 = m) {
    this.x = e5, this.y = t8, this.angle = i4, this.segment = n6, this.minzoom = s4;
  }
};
var p2 = class {
  constructor(e5, t8, i4, n6, a6, o5 = m, l4 = r) {
    this.anchor = e5, this.labelAngle = t8, this.glyphAngle = i4, this.page = n6, this.alternateVerticalGlyph = a6, this.minzoom = o5, this.maxzoom = l4;
  }
};
var w = class {
  constructor(e5, t8, i4, n6, s4, a6, o5, l4, h5, r7, c4, g) {
    this.tl = e5, this.tr = t8, this.bl = i4, this.br = n6, this.mosaicRect = s4, this.labelAngle = a6, this.minAngle = o5, this.maxAngle = l4, this.anchor = h5, this.minzoom = r7, this.maxzoom = c4, this.page = g;
  }
};
var y = class {
  constructor(e5) {
    this.shapes = e5;
  }
};
var f2 = class {
  getIconPlacement(t8, s4, a6) {
    const o5 = new i(t8.x, t8.y), l4 = 0 === a6.rotationAlignment, h5 = a6.keepUpright;
    let r7 = a6.rotate * s;
    l4 && (r7 += t8.angle);
    const c4 = new y([]);
    return a6.allowOverlap && a6.ignorePlacement || !o2 || (c4.iconColliders = []), this._addIconPlacement(c4, o5, s4, a6, r7), l4 && h5 && this._addIconPlacement(c4, o5, s4, a6, r7 + o), c4;
  }
  _addIconPlacement(t8, i4, n6, a6, o5) {
    const l4 = n6.rasterizationScale, h5 = n6.width / l4, r7 = n6.height / l4, c4 = a6.offset;
    let x2 = c4[0], d4 = c4[1];
    switch (a6.anchor) {
      case 0:
        x2 -= h5 / 2, d4 -= r7 / 2;
        break;
      case 1:
        d4 -= r7 / 2;
        break;
      case 2:
        x2 -= h5, d4 -= r7 / 2;
        break;
      case 3:
        x2 -= h5 / 2;
        break;
      case 4:
        x2 -= h5 / 2, d4 -= r7;
        break;
      case 5:
        break;
      case 7:
        d4 -= r7;
        break;
      case 6:
        x2 -= h5;
        break;
      case 8:
        x2 -= h5, d4 -= r7;
    }
    const p3 = n6.rect, y3 = 2 / l4, f3 = x2 - y3, u3 = d4 - y3, b = f3 + p3.width / l4, I = u3 + p3.height / l4, T2 = new i(f3, u3), k2 = new i(b, I), P = new i(f3, I), N = new i(b, u3);
    if (0 !== o5) {
      const e5 = Math.cos(o5), t9 = Math.sin(o5);
      T2.rotate(e5, t9), k2.rotate(e5, t9), P.rotate(e5, t9), N.rotate(e5, t9);
    }
    const z = new w(T2, N, P, k2, p3, o5, 0, 256, i4, m, r, 0);
    if (t8.shapes.push(z), (!a6.allowOverlap || !a6.ignorePlacement) && o2) {
      const e5 = a6.size, n7 = a6.padding, l5 = { xTile: i4.x, yTile: i4.y, dxPixels: x2 * e5 - n7, dyPixels: d4 * e5 - n7, hard: !a6.optional, partIndex: 0, width: h5 * e5 + 2 * n7, height: r7 * e5 + 2 * n7, angle: o5, minLod: m, maxLod: r };
      t8.iconColliders.push(l5);
    }
  }
  getTextPlacement(a6, o5, l4, g) {
    const d4 = new i(a6.x, a6.y), f3 = g.rotate * s, u3 = 0 === g.rotationAlignment, b = g.keepUpright, I = g.padding;
    let T2 = m;
    const k2 = !u3 ? 0 : a6.angle, P = a6.segment >= 0 && u3, N = g.allowOverlap && g.ignorePlacement ? null : [], z = [], A = 4, _2 = !P;
    let v = Number.POSITIVE_INFINITY, G = Number.NEGATIVE_INFINITY, M = v, E = G;
    const L = (P || u3) && b, V2 = g.size / c3;
    let j = false;
    for (const e5 of o5) if (e5.vertical) {
      j = true;
      break;
    }
    let O, C2 = 0, F = 0;
    if (!P && j) {
      const e5 = l3.getTextBox(o5, g.lineHeight * c3);
      switch (g.anchor) {
        case 1:
          C2 = e5.height / 2, F = -e5.width / 2;
          break;
        case 2:
          C2 = -e5.height / 2, F = e5.width / 2;
          break;
        case 3:
          C2 = e5.height / 2, F = e5.width / 2;
          break;
        case 4:
          C2 = -e5.height / 2, F = -e5.width / 2;
          break;
        case 5:
          C2 = e5.height;
          break;
        case 7:
          F = -e5.width;
          break;
        case 6:
          F = e5.width;
          break;
        case 8:
          C2 = -e5.height;
      }
    }
    C2 += g.offset[0] * c3, F += g.offset[1] * c3;
    for (const i4 of o5) {
      const o6 = i4.glyphMosaicItem;
      if (!o6 || o6.rect.isEmpty) continue;
      const h5 = o6.rect, r7 = o6.metrics, y3 = o6.page;
      if (N && _2) {
        if (void 0 !== O && O !== i4.y) {
          let e5, t8, i5, n6;
          j ? (e5 = -E + C2, t8 = v + F, i5 = E - M, n6 = G - v) : (e5 = v + C2, t8 = M + F, i5 = G - v, n6 = E - M);
          const o7 = { xTile: a6.x, yTile: a6.y, dxPixels: e5 * V2 - I, dyPixels: t8 * V2 - I, hard: !g.optional, partIndex: 1, width: i5 * V2 + 2 * I, height: n6 * V2 + 2 * I, angle: f3, minLod: m, maxLod: r };
          N.push(o7), v = Number.POSITIVE_INFINITY, G = Number.NEGATIVE_INFINITY, M = v, E = G;
        }
        O = i4.y;
      }
      const S2 = [];
      if (P) {
        const e5 = 0.5 * o6.metrics.width, n6 = (i4.x + r7.left - A + e5) * V2 * c;
        if (T2 = this._placeGlyph(a6, T2, n6, l4, a6.segment, 1, i4.vertical, y3, S2), b && (T2 = this._placeGlyph(a6, T2, n6, l4, a6.segment, -1, i4.vertical, y3, S2)), T2 >= x) break;
      } else S2.push(new p2(d4, k2, k2, y3, false)), u3 && b && S2.push(new p2(d4, k2 + o, k2 + o, y3, false));
      const Y = i4.x + r7.left, q = i4.y - h3 - r7.top, U = Y + r7.width, B = q + r7.height;
      let H, R, D, J, K, Q, W, X;
      if (!P && j) if (i4.vertical) {
        const t8 = (Y + U) / 2 - r7.height / 2, i5 = (q + B) / 2 + r7.width / 2;
        H = new i(-i5 - A + C2, t8 - A + F), R = new i(H.x + h5.width, H.y + h5.height), D = new i(H.x, R.y), J = new i(R.x, H.y);
      } else H = new i(-q + A + C2, Y - A + F), R = new i(H.x - h5.height, H.y + h5.width), D = new i(R.x, H.y), J = new i(H.x, R.y);
      else H = new i(Y - A + C2, q - A + F), R = new i(H.x + h5.width, H.y + h5.height), D = new i(H.x, R.y), J = new i(R.x, H.y);
      for (const t8 of S2) {
        let n6, s4, o7, l5;
        if (t8.alternateVerticalGlyph) {
          if (!K) {
            const t9 = (q + B) / 2 + F;
            K = new i((Y + U) / 2 + C2 - r7.height / 2 - A, t9 + r7.width / 2 + A), Q = new i(K.x + h5.height, K.y - h5.width), W = new i(Q.x, K.y), X = new i(K.x, Q.y);
          }
          n6 = K, s4 = W, o7 = X, l5 = Q;
        } else n6 = H, s4 = D, o7 = J, l5 = R;
        const c4 = q, m3 = B, d5 = t8.glyphAngle + f3;
        if (0 !== d5) {
          const e5 = Math.cos(d5), t9 = Math.sin(d5);
          n6 = n6.clone(), s4 = s4?.clone(), o7 = o7?.clone(), l5 = l5?.clone(), n6.rotate(e5, t9), l5?.rotate(e5, t9), s4?.rotate(e5, t9), o7?.rotate(e5, t9);
        }
        let p3 = 0, y4 = 256;
        if (P && j ? i4.vertical ? t8.alternateVerticalGlyph ? (p3 = 32, y4 = 96) : (p3 = 224, y4 = 32) : (p3 = 224, y4 = 96) : (p3 = 192, y4 = 64), z.push(new w(n6, o7, s4, l5, h5, t8.labelAngle, p3, y4, t8.anchor, t8.minzoom, t8.maxzoom, t8.page)), N && (!L || this._legible(t8.labelAngle))) {
          if (_2) Y < v && (v = Y), c4 < M && (M = c4), U > G && (G = U), m3 > E && (E = m3);
          else if (t8.minzoom < x) {
            const e5 = { xTile: a6.x, yTile: a6.y, dxPixels: (Y + C2) * V2 - I, dyPixels: (c4 + C2) * V2 - I, hard: !g.optional, partIndex: 1, width: (U - Y) * V2 + 2 * I, height: (m3 - c4) * V2 + 2 * I, angle: d5, minLod: t8.minzoom, maxLod: t8.maxzoom };
            N.push(e5);
          }
        }
      }
    }
    if (T2 >= x) return null;
    if (N && _2) {
      let e5, t8, i4, n6;
      j ? (e5 = -E + C2, t8 = v + F, i4 = E - M, n6 = G - v) : (e5 = v + C2, t8 = M + F, i4 = G - v, n6 = E - M);
      const o6 = { xTile: a6.x, yTile: a6.y, dxPixels: e5 * V2 - I, dyPixels: t8 * V2 - I, hard: !g.optional, partIndex: 1, width: i4 * V2 + 2 * I, height: n6 * V2 + 2 * I, angle: f3, minLod: m, maxLod: r };
      N.push(o6);
    }
    const S = new y(z);
    return N && N.length > 0 && (S.textColliders = N), S;
  }
  _legible(e5) {
    const t8 = f(e5);
    return t8 < 65 || t8 >= 193;
  }
  _placeGlyph(t8, i4, o5, h5, r7, c4, g, m3, x2) {
    let d4 = c4;
    const w2 = d4 < 0 ? a2(t8.angle + o, e) : t8.angle;
    let y3 = 0;
    o5 < 0 && (d4 *= -1, o5 *= -1, y3 = o), d4 > 0 && ++r7;
    let f3 = new i(t8.x, t8.y), u3 = h5[r7], b = r;
    if (h5.length <= r7) return b;
    for (; ; ) {
      const e5 = u3.x - f3.x, t9 = u3.y - f3.y, n6 = Math.sqrt(e5 * e5 + t9 * t9), s4 = Math.max(o5 / n6, i4), c5 = e5 / n6, I = t9 / n6, T2 = a2(Math.atan2(I, c5) + y3, e);
      if (x2.push(new p2(f3, w2, T2, m3, false, s4, b)), g && x2.push(new p2(f3, w2, T2, m3, true, s4, b)), s4 <= i4) return s4;
      f3 = u3.clone();
      do {
        if (r7 += d4, h5.length <= r7 || r7 < 0) return s4;
        u3 = h5[r7];
      } while (f3.isEqual(u3));
      let k2 = u3.x - f3.x, P = u3.y - f3.y;
      const N = Math.sqrt(k2 * k2 + P * P);
      k2 *= n6 / N, P *= n6 / N, f3.x -= k2, f3.y -= P, b = s4;
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/IndexMemoryBuffer.js
var r2 = class extends t5 {
  constructor() {
    super(12);
  }
  add(s4, r7, t8) {
    const e5 = this.array;
    e5.push(s4), e5.push(r7), e5.push(t8);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VertexMemoryBuffer.js
var o3 = class extends t5 {
  constructor(t8) {
    super(t8);
  }
  add(t8, o5, r7, u3, h5, a6, n6, d4, e5, p3, i4, c4) {
    const M = this.array;
    let l4 = t5.i1616to32(t8, o5);
    M.push(l4);
    const m3 = 31;
    l4 = t5.i8888to32(Math.round(m3 * r7), Math.round(m3 * u3), Math.round(m3 * h5), Math.round(m3 * a6)), M.push(l4), l4 = t5.i8888to32(Math.round(m3 * n6), Math.round(m3 * d4), Math.round(m3 * e5), Math.round(m3 * p3)), M.push(l4), l4 = t5.i1616to32(i4, 0), M.push(l4), c4 && M.push(...c4);
  }
};
var r3 = class extends t5 {
  constructor(t8) {
    super(t8);
  }
  add(t8, o5, r7) {
    const u3 = this.array;
    u3.push(t5.i1616to32(t8, o5)), r7 && u3.push(...r7);
  }
};
var u = class extends t5 {
  constructor(t8) {
    super(t8);
  }
  add(t8, o5, r7, u3, h5, a6, n6) {
    const d4 = this.array, e5 = this.index;
    let p3 = t5.i1616to32(t8, o5);
    d4.push(p3);
    const i4 = 15;
    return p3 = t5.i8888to32(Math.round(i4 * r7), Math.round(i4 * u3), h5, a6), d4.push(p3), n6 && d4.push(...n6), e5;
  }
};
var h4 = class extends t5 {
  constructor(t8) {
    super(t8);
  }
  add(o5, r7, u3, h5, a6, n6, d4, e5, p3, i4, c4, M) {
    const l4 = this.array;
    let m3 = t5.i1616to32(o5, r7);
    l4.push(m3), m3 = t5.i1616to32(Math.round(8 * u3), Math.round(8 * h5)), l4.push(m3), m3 = t5.i8888to32(a6 / 4, n6 / 4, e5, p3), l4.push(m3), m3 = t5.i8888to32(0, f(d4), 10 * i4, Math.min(10 * c4, 255)), l4.push(m3), M && l4.push(...M);
  }
};
var a5 = class extends t5 {
  constructor(t8) {
    super(t8);
  }
  add(t8, o5, r7, u3, h5) {
    const a6 = this.array, n6 = t5.i1616to32(2 * t8 + r7, 2 * o5 + u3);
    a6.push(n6), h5 && a6.push(...h5);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/buckets/BaseBucket.js
var e4 = class {
  constructor(e5, s4, r7) {
    this.layerExtent = t3, this._features = [], this.layer = e5, this.zoom = s4, this._spriteInfo = r7, this._filter = e5.getFeatureFilter();
  }
  pushFeature(t8) {
    this._filter && !this._filter.filter(t8, this.zoom) || this._features.push(t8);
  }
  hasFeatures() {
    return this._features.length > 0;
  }
  getResources(t8, e5, s4) {
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/buckets/CircleBucket.js
var t7 = class extends e4 {
  constructor(e5, t8, r7, i4, c4) {
    super(e5, t8, r7), this.type = 4, this._circleVertexBuffer = i4, this._circleIndexBuffer = c4;
  }
  get circleIndexStart() {
    return this._circleIndexStart;
  }
  get circleIndexCount() {
    return this._circleIndexCount;
  }
  processFeatures(e5) {
    const t8 = this._circleVertexBuffer, r7 = this._circleIndexBuffer;
    this._circleIndexStart = 3 * r7.index, this._circleIndexCount = 0;
    const i4 = this.layer, c4 = this.zoom;
    e5 && e5.setExtent(this.layerExtent);
    for (const s4 of this._features) {
      const n6 = s4.getGeometry(e5);
      if (!n6) continue;
      const l4 = i4.circleMaterial.encodeAttributes(s4, c4, i4);
      for (const e6 of n6) if (e6) for (const i5 of e6) {
        const e7 = t8.index;
        t8.add(i5.x, i5.y, 0, 0, l4), t8.add(i5.x, i5.y, 0, 1, l4), t8.add(i5.x, i5.y, 1, 0, l4), t8.add(i5.x, i5.y, 1, 1, l4), r7.add(e7, e7 + 1, e7 + 2), r7.add(e7 + 1, e7 + 2, e7 + 3), this._circleIndexCount += 6;
      }
    }
  }
  serialize() {
    let e5 = 6;
    e5 += this.layerUIDs.length, e5 += this._circleVertexBuffer.array.length, e5 += this._circleIndexBuffer.array.length;
    const t8 = new Uint32Array(e5), r7 = new Int32Array(t8.buffer);
    let i4 = 0;
    t8[i4++] = this.type, t8[i4++] = this.layerUIDs.length;
    for (let c4 = 0; c4 < this.layerUIDs.length; c4++) t8[i4++] = this.layerUIDs[c4];
    t8[i4++] = this._circleIndexStart, t8[i4++] = this._circleIndexCount, t8[i4++] = this._circleVertexBuffer.array.length;
    for (let c4 = 0; c4 < this._circleVertexBuffer.array.length; c4++) r7[i4++] = this._circleVertexBuffer.array[c4];
    t8[i4++] = this._circleIndexBuffer.array.length;
    for (let c4 = 0; c4 < this._circleIndexBuffer.array.length; c4++) t8[i4++] = this._circleIndexBuffer.array[c4];
    return t8.buffer;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/buckets/FillBucket.js
var n4 = class _n extends e4 {
  constructor(t8, e5, i4, r7, l4, n6, s4) {
    super(t8, e5, i4), this.type = 1, this._patternMap = /* @__PURE__ */ new Map(), this._fillVertexBuffer = r7, this._fillIndexBuffer = l4, this._outlineVertexBuffer = n6, this._outlineIndexBuffer = s4;
  }
  get fillIndexStart() {
    return this._fillIndexStart;
  }
  get fillIndexCount() {
    return this._fillIndexCount;
  }
  get outlineIndexStart() {
    return this._outlineIndexStart;
  }
  get outlineIndexCount() {
    return this._outlineIndexCount;
  }
  getResources(t8, e5, i4) {
    const r7 = this.layer, l4 = this.zoom, n6 = r7.getPaintProperty("fill-pattern");
    if (n6) if (n6.isDataDriven) for (const s4 of this._features) e5(n6.getValue(l4, s4), true);
    else e5(n6.getValue(l4), true);
  }
  processFeatures(t8) {
    this._fillIndexStart = 3 * this._fillIndexBuffer.index, this._fillIndexCount = 0, this._outlineIndexStart = 3 * this._outlineIndexBuffer.index, this._outlineIndexCount = 0;
    const e5 = this.layer, i4 = this.zoom, { fillMaterial: r7, outlineMaterial: l4, hasDataDrivenFill: n6, hasDataDrivenOutline: s4 } = e5;
    t8 && t8.setExtent(this.layerExtent);
    const o5 = e5.getPaintProperty("fill-pattern"), a6 = o5?.isDataDriven;
    let f3 = !o5 && e5.getPaintValue("fill-antialias", i4);
    if (e5.outlineUsesFillColor) {
      if (f3 && !e5.hasDataDrivenOpacity) {
        const t9 = e5.getPaintValue("fill-opacity", i4), r8 = e5.getPaintValue("fill-opacity", i4 + 1);
        t9 < 1 && r8 < 1 && (f3 = false);
      }
      if (f3 && !e5.hasDataDrivenColor) {
        const t9 = e5.getPaintValue("fill-color", i4), r8 = e5.getPaintValue("fill-color", i4 + 1);
        t9[3] < 1 && r8[3] < 1 && (f3 = false);
      }
    }
    const u3 = this._features, d4 = t8?.validateTessellation;
    if (a6) {
      const n7 = [];
      for (const a7 of u3) {
        const u4 = o5.getValue(i4, a7), h5 = this._spriteInfo[u4];
        if (!h5?.rect) continue;
        const x2 = r7.encodeAttributes(a7, i4, e5, h5), c4 = f3 && s4 ? l4.encodeAttributes(a7, i4, e5) : [], _2 = a7.getGeometry(t8);
        n7.push({ ddFillAttributes: x2, ddOutlineAttributes: c4, page: h5.page, geometry: _2 }), n7.sort((t9, e6) => t9.page - e6.page);
        for (const { ddFillAttributes: t9, ddOutlineAttributes: i5, page: r8, geometry: l5 } of n7) this._processFeature(l5, f3, e5.outlineUsesFillColor, t9, i5, d4, r8);
      }
    } else for (const h5 of u3) {
      const o6 = n6 ? r7.encodeAttributes(h5, i4, e5) : null, a7 = f3 && s4 ? l4.encodeAttributes(h5, i4, e5) : null, u4 = h5.getGeometry(t8);
      this._processFeature(u4, f3, e5.outlineUsesFillColor, o6, a7, d4);
    }
  }
  serialize() {
    let t8 = 10;
    t8 += this.layerUIDs.length, t8 += this._fillVertexBuffer.array.length, t8 += this._fillIndexBuffer.array.length, t8 += this._outlineVertexBuffer.array.length, t8 += this._outlineIndexBuffer.array.length, t8 += 3 * this._patternMap.size + 1;
    const e5 = new Uint32Array(t8), i4 = new Int32Array(e5.buffer);
    let r7 = 0;
    e5[r7++] = this.type, e5[r7++] = this.layerUIDs.length;
    for (let s4 = 0; s4 < this.layerUIDs.length; s4++) e5[r7++] = this.layerUIDs[s4];
    e5[r7++] = this._fillIndexStart, e5[r7++] = this._fillIndexCount, e5[r7++] = this._outlineIndexStart, e5[r7++] = this._outlineIndexCount;
    const l4 = this._patternMap, n6 = l4.size;
    if (e5[r7++] = n6, n6 > 0) for (const [s4, [o5, a6]] of l4) e5[r7++] = s4, e5[r7++] = o5, e5[r7++] = a6;
    e5[r7++] = this._fillVertexBuffer.array.length;
    for (let s4 = 0; s4 < this._fillVertexBuffer.array.length; s4++) i4[r7++] = this._fillVertexBuffer.array[s4];
    e5[r7++] = this._fillIndexBuffer.array.length;
    for (let s4 = 0; s4 < this._fillIndexBuffer.array.length; s4++) e5[r7++] = this._fillIndexBuffer.array[s4];
    e5[r7++] = this._outlineVertexBuffer.array.length;
    for (let s4 = 0; s4 < this._outlineVertexBuffer.array.length; s4++) i4[r7++] = this._outlineVertexBuffer.array[s4];
    e5[r7++] = this._outlineIndexBuffer.array.length;
    for (let s4 = 0; s4 < this._outlineIndexBuffer.array.length; s4++) e5[r7++] = this._outlineIndexBuffer.array[s4];
    return e5.buffer;
  }
  _processFeature(t8, e5, i4, r7, l4, s4, o5) {
    if (!t8) return;
    const a6 = t8.length, f3 = !l4 || 0 === l4.length;
    if (e5 && (!i4 || f3)) for (let n6 = 0; n6 < a6; n6++) this._processOutline(t8[n6], l4);
    const u3 = 32;
    let d4;
    for (let h5 = 0; h5 < a6; h5++) {
      const e6 = _n._area(t8[h5]);
      e6 > u3 ? (void 0 !== d4 && this._processFill(t8, d4, r7, s4, o5), d4 = [h5]) : e6 < -u3 && void 0 !== d4 && d4.push(h5);
    }
    void 0 !== d4 && this._processFill(t8, d4, r7, s4, o5);
  }
  _processOutline(t8, e5) {
    const i4 = this._outlineVertexBuffer, l4 = this._outlineIndexBuffer, n6 = l4.index;
    let s4, o5, a6;
    const f3 = new i(0, 0), u3 = new i(0, 0), d4 = new i(0, 0);
    let h5 = -1, x2 = -1, c4 = -1, _2 = -1, y3 = -1, g = false;
    const p3 = 0;
    let I = t8.length;
    if (I < 2) return;
    const B = t8[p3];
    let V2 = t8[I - 1];
    for (; I && V2.isEqual(B); ) --I, V2 = t8[I - 1];
    if (!(I - p3 < 2)) {
      for (let r7 = p3; r7 < I; ++r7) {
        r7 === p3 ? (s4 = t8[I - 1], o5 = t8[p3], a6 = t8[p3 + 1], f3.assignSub(o5, s4), f3.normalize(), f3.rightPerpendicular()) : (s4 = o5, o5 = a6, a6 = r7 !== I - 1 ? t8[r7 + 1] : t8[p3], f3.assign(u3));
        const n7 = this._isClipEdge(s4, o5);
        -1 === _2 && (g = n7), u3.assignSub(a6, o5), u3.normalize(), u3.rightPerpendicular();
        const B2 = f3.x * u3.y - f3.y * u3.x;
        d4.assignAdd(f3, u3), d4.normalize();
        const V3 = -d4.x * -f3.x + -d4.y * -f3.y;
        let m3 = Math.abs(0 !== V3 ? 1 / V3 : 1);
        m3 > 8 && (m3 = 8), B2 >= 0 ? (c4 = i4.add(o5.x, o5.y, f3.x, f3.y, 0, 1, e5), -1 === _2 && (_2 = c4), h5 >= 0 && x2 >= 0 && c4 >= 0 && !n7 && l4.add(h5, x2, c4), x2 = i4.add(o5.x, o5.y, m3 * -d4.x, m3 * -d4.y, 0, -1, e5), -1 === y3 && (y3 = x2), h5 >= 0 && x2 >= 0 && c4 >= 0 && !n7 && l4.add(h5, x2, c4), h5 = x2, x2 = c4, c4 = i4.add(o5.x, o5.y, d4.x, d4.y, 0, 1, e5), h5 >= 0 && x2 >= 0 && c4 >= 0 && !n7 && l4.add(h5, x2, c4), x2 = i4.add(o5.x, o5.y, u3.x, u3.y, 0, 1, e5), h5 >= 0 && x2 >= 0 && c4 >= 0 && !n7 && l4.add(h5, x2, c4)) : (c4 = i4.add(o5.x, o5.y, m3 * d4.x, m3 * d4.y, 0, 1, e5), -1 === _2 && (_2 = c4), h5 >= 0 && x2 >= 0 && c4 >= 0 && !n7 && l4.add(h5, x2, c4), x2 = i4.add(o5.x, o5.y, -f3.x, -f3.y, 0, -1, e5), -1 === y3 && (y3 = x2), h5 >= 0 && x2 >= 0 && c4 >= 0 && !n7 && l4.add(h5, x2, c4), h5 = x2, x2 = c4, c4 = i4.add(o5.x, o5.y, -d4.x, -d4.y, 0, -1, e5), h5 >= 0 && x2 >= 0 && c4 >= 0 && !n7 && l4.add(h5, x2, c4), h5 = i4.add(o5.x, o5.y, -u3.x, -u3.y, 0, -1, e5), h5 >= 0 && x2 >= 0 && c4 >= 0 && !n7 && l4.add(h5, x2, c4));
      }
      h5 >= 0 && x2 >= 0 && _2 >= 0 && !g && l4.add(h5, x2, _2), h5 >= 0 && _2 >= 0 && y3 >= 0 && !g && l4.add(h5, y3, _2), this._outlineIndexCount += 3 * (l4.index - n6);
    }
  }
  _processFill(r7, l4, n6, s4, o5) {
    s4 = true;
    let a6;
    l4.length > 1 && (a6 = []);
    let f3 = 0;
    for (const t8 of l4) 0 !== f3 && a6.push(f3), f3 += r7[t8].length;
    const u3 = 2 * f3, d4 = t.acquire();
    for (const t8 of l4) {
      const e5 = r7[t8], i4 = e5.length;
      for (let t9 = 0; t9 < i4; ++t9) d4.push(e5[t9].x, e5[t9].y);
    }
    const h5 = e2(d4, a6, 2);
    if (s4 && e2.deviation(d4, a6, 2, h5) > 0) {
      const t8 = l4.map((t9) => r7[t9].length), { buffer: e5, vertexCount: s5 } = a3(d4, t8);
      if (s5 > 0) {
        const t9 = this._fillVertexBuffer.index;
        for (let i4 = 0; i4 < s5; i4++) this._fillVertexBuffer.add(e5[2 * i4], e5[2 * i4 + 1], n6);
        for (let e6 = 0; e6 < s5; e6 += 3) {
          const i4 = t9 + e6;
          this._fillIndexBuffer.add(i4, i4 + 1, i4 + 2);
        }
        if (void 0 !== o5) {
          const t10 = this._patternMap, e6 = t10.get(o5);
          e6 ? e6[1] += s5 : t10.set(o5, [this._fillIndexStart + this._fillIndexCount, s5]);
        }
        this._fillIndexCount += s5;
      }
    } else {
      const t8 = h5.length;
      if (t8 > 0) {
        const e5 = this._fillVertexBuffer.index;
        let i4 = 0;
        for (; i4 < u3; ) this._fillVertexBuffer.add(d4[i4++], d4[i4++], n6);
        let r8 = 0;
        for (; r8 < t8; ) this._fillIndexBuffer.add(e5 + h5[r8++], e5 + h5[r8++], e5 + h5[r8++]);
        if (void 0 !== o5) {
          const e6 = this._patternMap, i5 = e6.get(o5);
          i5 ? i5[1] += t8 : e6.set(o5, [this._fillIndexStart + this._fillIndexCount, t8]);
        }
        this._fillIndexCount += t8;
      }
    }
    t.release(d4);
  }
  _isClipEdge(t8, e5) {
    return t8.x === e5.x ? t8.x <= -64 || t8.x >= 4160 : t8.y === e5.y && (t8.y <= -64 || t8.y >= 4160);
  }
  static _area(t8) {
    let e5 = 0;
    const i4 = t8.length - 1;
    for (let r7 = 0; r7 < i4; r7++) e5 += (t8[r7].x - t8[r7 + 1].x) * (t8[r7].y + t8[r7 + 1].y);
    return e5 += (t8[i4].x - t8[0].x) * (t8[i4].y + t8[0].y), 0.5 * e5;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/buckets/LineBucket.js
var i3 = 65535;
var s3 = class extends e4 {
  constructor(e5, i4, s4, l4, a6) {
    super(e5, i4, s4), this.type = 2, this._tessellationOptions = { pixelCoordRatio: 8, halfWidth: 0, offset: 0 }, this._patternMap = /* @__PURE__ */ new Map(), this.tessellationProperties = { _lineVertexBuffer: null, _lineIndexBuffer: null, _ddValues: null }, this.tessellationProperties._lineVertexBuffer = l4, this.tessellationProperties._lineIndexBuffer = a6, this._lineTessellator = new _(n5(this.tessellationProperties), r4(this.tessellationProperties), e5.canUseThinTessellation);
  }
  get lineIndexStart() {
    return this._lineIndexStart;
  }
  get lineIndexCount() {
    return this._lineIndexCount;
  }
  getResources(e5, t8, i4) {
    const s4 = this.layer, n6 = this.zoom, r7 = s4.getPaintProperty("line-pattern"), l4 = s4.getPaintProperty("line-dasharray"), a6 = s4.getLayoutProperty("line-cap");
    if (!r7 && !l4) return;
    const o5 = a6?.getValue(n6) || 0, u3 = a6?.isDataDriven, f3 = r7?.isDataDriven, h5 = l4?.isDataDriven;
    if (f3 || h5) for (const p3 of this._features) t8(f3 ? r7.getValue(n6, p3) : this._getDashArrayKey(p3, n6, s4, l4, u3, a6, o5));
    else if (r7) t8(r7.getValue(n6));
    else if (l4) {
      const e6 = l4.getValue(n6);
      t8(s4.getDashKey(e6, o5));
    }
  }
  processFeatures(e5) {
    this._lineIndexStart = 3 * this.tessellationProperties._lineIndexBuffer.index, this._lineIndexCount = 0;
    const t8 = this.layer, i4 = this.zoom, s4 = this._features, n6 = this._tessellationOptions, { hasDataDrivenLine: r7, lineMaterial: l4 } = t8;
    e5 && e5.setExtent(this.layerExtent);
    const a6 = t8.getPaintProperty("line-pattern"), o5 = t8.getPaintProperty("line-dasharray"), u3 = a6?.isDataDriven, f3 = o5?.isDataDriven;
    let h5;
    h5 = t8.getLayoutProperty("line-cap");
    const p3 = h5?.isDataDriven ? h5 : null, g = p3 ? null : t8.getLayoutValue("line-cap", i4), y3 = g || 0, d4 = !!p3;
    h5 = t8.getLayoutProperty("line-join");
    const c4 = h5?.isDataDriven ? h5 : null, _2 = c4 ? null : t8.getLayoutValue("line-join", i4);
    h5 = t8.getLayoutProperty("line-miter-limit");
    const x2 = h5?.isDataDriven ? h5 : null, V2 = x2 ? null : t8.getLayoutValue("line-miter-limit", i4);
    h5 = t8.getLayoutProperty("line-round-limit");
    const D = h5?.isDataDriven ? h5 : null, P = D ? null : t8.getLayoutValue("line-round-limit", i4);
    h5 = t8.getPaintProperty("line-width");
    const m3 = h5?.isDataDriven ? h5 : null, I = m3 ? null : t8.getPaintValue("line-width", i4);
    h5 = t8.getPaintProperty("line-offset");
    const L = h5?.isDataDriven ? h5 : null, B = L ? null : t8.getPaintValue("line-offset", i4);
    if (u3 || f3) {
      const r8 = [];
      for (const n7 of s4) {
        const s5 = u3 ? a6.getValue(i4, n7) : this._getDashArrayKey(n7, i4, t8, o5, d4, p3, y3), f4 = this._spriteInfo[s5];
        if (!f4?.rect) continue;
        const h6 = l4.encodeAttributes(n7, i4, t8, f4), v = n7.getGeometry(e5);
        r8.push({ ddAttributes: h6, page: f4.page, cap: p3 ? p3.getValue(i4, n7) : g, join: c4 ? c4.getValue(i4, n7) : _2, miterLimit: x2 ? x2.getValue(i4, n7) : V2, roundLimit: D ? D.getValue(i4, n7) : P, halfWidth: 0.5 * (m3 ? m3.getValue(i4, n7) : I), offset: L ? L.getValue(i4, n7) : B, geometry: v });
      }
      r8.sort((e6, t9) => e6.page - t9.page), n6.textured = true;
      for (const { ddAttributes: e6, page: t9, cap: i5, join: s5, miterLimit: l5, roundLimit: a7, halfWidth: o6, offset: u4, geometry: f4 } of r8) n6.capType = i5, n6.joinType = s5, n6.miterLimit = l5, n6.roundLimit = a7, n6.halfWidth = o6, n6.offset = u4, this._processFeature(f4, e6, t9);
    } else {
      if (a6) {
        const e6 = a6.getValue(i4), t9 = this._spriteInfo[e6];
        if (!t9?.rect) return;
      }
      n6.textured = !(!a6 && !o5), n6.capType = g, n6.joinType = _2, n6.miterLimit = V2, n6.roundLimit = P, n6.halfWidth = 0.5 * I, n6.offset = B;
      for (const a7 of s4) {
        const s5 = r7 ? l4.encodeAttributes(a7, i4, t8) : null;
        p3 && (n6.capType = p3.getValue(i4, a7)), c4 && (n6.joinType = c4.getValue(i4, a7)), x2 && (n6.miterLimit = x2.getValue(i4, a7)), D && (n6.roundLimit = D.getValue(i4, a7)), m3 && (n6.halfWidth = 0.5 * m3.getValue(i4, a7)), L && (n6.offset = L.getValue(i4, a7));
        const o6 = a7.getGeometry(e5);
        this._processFeature(o6, s5);
      }
    }
  }
  serialize() {
    let e5 = 6;
    e5 += this.layerUIDs.length, e5 += this.tessellationProperties._lineVertexBuffer.array.length, e5 += this.tessellationProperties._lineIndexBuffer.array.length, e5 += 3 * this._patternMap.size + 1;
    const t8 = new Uint32Array(e5), i4 = new Int32Array(t8.buffer);
    let s4 = 0;
    t8[s4++] = this.type, t8[s4++] = this.layerUIDs.length;
    for (let l4 = 0; l4 < this.layerUIDs.length; l4++) t8[s4++] = this.layerUIDs[l4];
    t8[s4++] = this._lineIndexStart, t8[s4++] = this._lineIndexCount;
    const n6 = this._patternMap, r7 = n6.size;
    if (t8[s4++] = r7, r7 > 0) for (const [l4, [a6, o5]] of n6) t8[s4++] = l4, t8[s4++] = a6, t8[s4++] = o5;
    t8[s4++] = this.tessellationProperties._lineVertexBuffer.array.length;
    for (let l4 = 0; l4 < this.tessellationProperties._lineVertexBuffer.array.length; l4++) i4[s4++] = this.tessellationProperties._lineVertexBuffer.array[l4];
    t8[s4++] = this.tessellationProperties._lineIndexBuffer.array.length;
    for (let l4 = 0; l4 < this.tessellationProperties._lineIndexBuffer.array.length; l4++) t8[s4++] = this.tessellationProperties._lineIndexBuffer.array[l4];
    return t8.buffer;
  }
  _processFeature(e5, t8, i4) {
    if (!e5) return;
    const s4 = e5.length;
    for (let n6 = 0; n6 < s4; n6++) this._processGeometry(e5[n6], t8, i4);
  }
  _processGeometry(e5, t8, s4) {
    if (e5.length < 2) return;
    const n6 = 1e-3;
    let r7, l4, a6 = e5[0], o5 = 1;
    for (; o5 < e5.length; ) r7 = e5[o5].x - a6.x, l4 = e5[o5].y - a6.y, r7 * r7 + l4 * l4 < n6 * n6 ? e5.splice(o5, 1) : (a6 = e5[o5], ++o5);
    if (e5.length < 2) return;
    const u3 = this.tessellationProperties._lineIndexBuffer, f3 = 3 * u3.index;
    this._tessellationOptions.initialDistance = 0, this._tessellationOptions.wrapDistance = i3, this.tessellationProperties._ddValues = t8, this._lineTessellator.tessellate(e5, this._tessellationOptions);
    const h5 = 3 * u3.index - f3;
    if (void 0 !== s4) {
      const e6 = this._patternMap, t9 = e6.get(s4);
      t9 ? t9[1] += h5 : e6.set(s4, [f3 + this._lineIndexCount, h5]);
    }
    this._lineIndexCount += h5;
  }
  _getDashArrayKey(e5, t8, i4, s4, n6, r7, l4) {
    const a6 = n6 ? r7.getValue(t8, e5) : l4, o5 = s4.getValue(t8, e5);
    return i4.getDashKey(o5, a6);
  }
};
var n5 = (e5) => (t8, i4, s4, n6, r7, l4, a6, o5, u3, f3, h5) => (e5._lineVertexBuffer.add(t8, i4, a6, o5, s4, n6, r7, l4, u3, f3, h5, e5._ddValues), e5._lineVertexBuffer.index - 1);
var r4 = (e5) => (t8, i4, s4) => {
  e5._lineIndexBuffer.add(t8, i4, s4);
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/buckets/SymbolBucket.js
var y2 = 10;
function m2(e5, t8) {
  return e5.iconMosaicItem && t8.iconMosaicItem ? e5.iconMosaicItem.page === t8.iconMosaicItem.page ? 0 : e5.iconMosaicItem.page - t8.iconMosaicItem.page : e5.iconMosaicItem && !t8.iconMosaicItem ? 1 : !e5.iconMosaicItem && t8.iconMosaicItem ? -1 : 0;
}
var _u = class _u extends e4 {
  constructor(e5, t8, n6, s4, i4, a6, o5, r7, l4) {
    super(t8, n6, l4.getSpriteItems()), this.type = 3, this._markerMap = /* @__PURE__ */ new Map(), this._glyphMap = /* @__PURE__ */ new Map(), this._glyphBufferDataStorage = /* @__PURE__ */ new Map(), this._isIconSDF = false, this._sourceTileKey = e5, this._iconVertexBuffer = s4, this._iconIndexBuffer = i4, this._textVertexBuffer = a6, this._textIndexBuffer = o5, this._placementEngine = r7, this._workerTileHandler = l4;
  }
  get markerPageMap() {
    return this._markerMap;
  }
  get glyphsPageMap() {
    return this._glyphMap;
  }
  get symbolInstances() {
    return this._symbolInstances;
  }
  getResources(e5, t8, s4) {
    const i4 = this.layer, a6 = this.zoom;
    e5 && e5.setExtent(this.layerExtent);
    const o5 = i4.getLayoutProperty("icon-image"), r7 = i4.getLayoutProperty("text-field");
    let l4 = i4.getLayoutProperty("text-transform"), h5 = i4.getLayoutProperty("text-font");
    const x2 = [];
    let c4, d4, f3, g;
    o5 && !o5.isDataDriven && (c4 = o5.getValue(a6)), r7 && !r7.isDataDriven && (d4 = r7.getValue(a6)), l4 && l4.isDataDriven || (f3 = i4.getLayoutValue("text-transform", a6), l4 = null), h5 && h5.isDataDriven || (g = i4.getLayoutValue("text-font", a6), h5 = null);
    for (const y3 of this._features) {
      const m3 = y3.getGeometry(e5);
      if (!m3 || 0 === m3.length) continue;
      let p3, _2;
      o5 && (p3 = o5.isDataDriven ? o5.getValue(a6, y3) : this._replaceKeys(c4, y3.values), p3 && t8(p3));
      let M = false;
      if (r7 && (_2 = r7.isDataDriven ? r7.getValue(a6, y3) : this._replaceKeys(d4, y3.values), _2)) {
        switch (_2 = _2.replaceAll("\\n", "\n"), l4 && (f3 = l4.getValue(a6, y3)), f3) {
          case 2:
            _2 = _2.toLowerCase();
            break;
          case 1:
            _2 = _2.toUpperCase();
        }
        if (_u._bidiEngine.hasBidiChar(_2)) {
          let e6;
          e6 = "rtl" === _u._bidiEngine.checkContextual(_2) ? "IDNNN" : "ICNNN", _2 = _u._bidiEngine.bidiTransform(_2, e6, "VLYSN"), M = true;
        }
        if (_2.length > 0) {
          h5 && (g = h5.getValue(a6, y3));
          for (const e6 of g) {
            let t9 = s4[e6];
            t9 || (t9 = s4[e6] = /* @__PURE__ */ new Set());
            for (const e7 of _2) {
              const n6 = e7.codePointAt(0);
              null != n6 && t9.add(n6);
            }
          }
        }
      }
      if (!p3 && !_2) continue;
      const b = i4.getLayoutValue("symbol-sort-key", a6, y3), P = { feature: y3, sprite: p3, label: _2, rtl: M, geometry: m3, hash: (_2 ? l(_2) : 0) ^ (p3 ? l(p3) : 0), priority: b, textFont: g };
      x2.push(P);
    }
    this._symbolFeatures = x2;
  }
  processFeatures(e5) {
    e5 && e5.setExtent(this.layerExtent);
    const n6 = this.layer, s4 = this.zoom, r7 = n6.getLayoutValue("symbol-placement", s4), l4 = 0 !== r7, d4 = n6.getLayoutValue("symbol-spacing", s4) * c, y3 = n6.getLayoutProperty("icon-image"), p3 = n6.getLayoutProperty("text-field"), _2 = y3 ? new V(n6, s4, l4) : null, M = p3 ? new T(n6, s4, l4) : null, b = this._workerTileHandler;
    let P;
    y3 && (P = b.getSpriteItems()), this._iconIndexStart = 3 * this._iconIndexBuffer.index, this._textIndexStart = 3 * this._textIndexBuffer.index, this._iconIndexCount = 0, this._textIndexCount = 0, this._markerMap.clear(), this._glyphMap.clear();
    const I = [];
    let A = 1;
    M?.size && (A = M.size / c3);
    const V2 = M ? M.maxAngle * s : 0, w2 = M ? M.size * c : 0;
    for (const o5 of this._symbolFeatures) {
      let e6;
      _2 && P && o5.sprite && (e6 = P[o5.sprite], e6 && e6.sdf && (this._isIconSDF = true));
      let n7;
      !!e6 && _2.update(s4, o5.feature);
      let f3 = 0;
      const g = o5.label;
      if (g) {
        n(M), M.update(s4, o5.feature);
        const e7 = l4 && 0 === M.rotationAlignment ? M.keepUpright : M.writingMode && M.writingMode.includes(1);
        let a6 = 0.5;
        switch (M.anchor) {
          case 5:
          case 1:
          case 7:
            a6 = 0;
            break;
          case 6:
          case 2:
          case 8:
            a6 = 1;
        }
        let r8 = 0.5;
        switch (M.anchor) {
          case 5:
          case 3:
          case 6:
            r8 = 0;
            break;
          case 7:
          case 4:
          case 8:
            r8 = 1;
        }
        let h5 = 0.5;
        switch (M.justify) {
          case 0:
            h5 = a6;
            break;
          case 1:
            h5 = 0;
            break;
          case 3:
            h5 = 1;
        }
        const d5 = M.letterSpacing * c3, y4 = l4 ? 0 : M.maxWidth * c3, m3 = M.lineHeight * c3, u3 = o5.textFont.map((e8) => b.getGlyphItems(e8));
        if (n7 = new l3(u3, y4, m3, d5, a6, r8, h5).getShaping(g, o5.rtl, e7), n7 && n7.length > 0) {
          let e8 = 1e30, t8 = -1e30;
          for (const s5 of n7) e8 = Math.min(e8, s5.x), t8 = Math.max(t8, s5.x);
          f3 = (t8 - e8 + 2 * c3) * A * c;
        }
      }
      for (let t8 of o5.geometry) {
        const s5 = [];
        if (1 === r7) {
          if (n7?.length && M?.size) {
            const e7 = M.size * c * (2 + Math.min(2, 4 * Math.abs(M.offset[1])));
            t8 = _u._smoothVertices(t8, e7);
          }
          _u._pushAnchors(s5, t8, d4, f3);
        } else 2 === r7 ? _u._pushCenterAnchor(s5, t8) : 3 === o5.feature.type ? _u._pushCentroid(s5, t8) : s5.push(new d3(t8[0].x, t8[0].y));
        for (const i4 of s5) {
          if (i4.x < 0 || i4.x > t3 || i4.y < 0 || i4.y > t3) continue;
          if (l4 && f3 > 0 && 0 === M?.rotationAlignment && !_u._honorsTextMaxAngle(t8, i4, f3, V2, w2)) continue;
          const s6 = { shaping: n7, line: t8, iconMosaicItem: e6, anchor: i4, symbolFeature: o5, textColliders: [], iconColliders: [], textVertexRanges: [], iconVertexRanges: [] };
          I.push(s6), this._processFeature(s6, _2, M);
        }
      }
    }
    I.sort(m2), this._addPlacedGlyphs(), this._symbolInstances = I;
  }
  serialize() {
    let e5 = 14;
    e5 += this.layerUIDs.length, e5 += 3 * this.markerPageMap.size, e5 += 3 * this.glyphsPageMap.size, e5 += _u._symbolsSerializationLength(this._symbolInstances), e5 += this._iconVertexBuffer.array.length, e5 += this._iconIndexBuffer.array.length, e5 += this._textVertexBuffer.array.length, e5 += this._textIndexBuffer.array.length;
    const t8 = new Uint32Array(e5), n6 = new Int32Array(t8.buffer), s4 = new Float32Array(t8.buffer), [i4, a6, o5] = this._sourceTileKey.split("/");
    let r7 = 0;
    t8[r7++] = this.type, t8[r7++] = this.layerUIDs.length;
    for (let l4 = 0; l4 < this.layerUIDs.length; l4++) t8[r7++] = this.layerUIDs[l4];
    t8[r7++] = this._isIconSDF ? 1 : 0, t8[r7++] = parseFloat(i4), t8[r7++] = parseFloat(a6), t8[r7++] = parseFloat(o5), t8[r7++] = this.markerPageMap.size;
    for (const [l4, [h5, x2]] of this.markerPageMap) t8[r7++] = l4, t8[r7++] = h5, t8[r7++] = x2;
    t8[r7++] = this.glyphsPageMap.size;
    for (const [l4, [h5, x2]] of this.glyphsPageMap) t8[r7++] = l4, t8[r7++] = h5, t8[r7++] = x2;
    t8[r7++] = this._iconVertexBuffer.index / 4, t8[r7++] = this._textVertexBuffer.index / 4, r7 = _u.serializeSymbols(t8, n6, s4, r7, this._symbolInstances), t8[r7++] = this._iconVertexBuffer.array.length;
    for (let l4 = 0; l4 < this._iconVertexBuffer.array.length; l4++) n6[r7++] = this._iconVertexBuffer.array[l4];
    t8[r7++] = this._iconIndexBuffer.array.length;
    for (let l4 = 0; l4 < this._iconIndexBuffer.array.length; l4++) t8[r7++] = this._iconIndexBuffer.array[l4];
    t8[r7++] = this._textVertexBuffer.array.length;
    for (let l4 = 0; l4 < this._textVertexBuffer.array.length; l4++) n6[r7++] = this._textVertexBuffer.array[l4];
    t8[r7++] = this._textIndexBuffer.array.length;
    for (let l4 = 0; l4 < this._textIndexBuffer.array.length; l4++) t8[r7++] = this._textIndexBuffer.array[l4];
    return t8.buffer;
  }
  static _symbolsSerializationLength(e5) {
    let t8 = 0;
    t8 += 1;
    for (const n6 of e5 || []) {
      t8 += 5, t8 += 1;
      for (const e6 of n6.textColliders) t8 += y2;
      for (const e6 of n6.iconColliders) t8 += y2;
      t8 += 1, t8 += 2 * n6.textVertexRanges.length, t8 += 1, t8 += 2 * n6.iconVertexRanges.length;
    }
    return t8;
  }
  static serializeSymbols(e5, t8, n6, s4, i4) {
    i4 = i4 || [], t8[s4++] = i4.length;
    for (const a6 of i4) {
      t8[s4++] = a6.anchor.x, t8[s4++] = a6.anchor.y, t8[s4++] = a6.symbolFeature.hash, t8[s4++] = a6.symbolFeature.priority, t8[s4++] = a6.symbolFeature.feature.featureIndex, t8[s4++] = a6.textColliders.length + a6.iconColliders.length;
      for (const e6 of a6.textColliders) t8[s4++] = e6.xTile, t8[s4++] = e6.yTile, t8[s4++] = e6.dxPixels, t8[s4++] = e6.dyPixels, t8[s4++] = e6.hard ? 1 : 0, t8[s4++] = e6.partIndex, n6[s4++] = e6.minLod, n6[s4++] = e6.maxLod, t8[s4++] = e6.width, t8[s4++] = e6.height;
      for (const e6 of a6.iconColliders) t8[s4++] = e6.xTile, t8[s4++] = e6.yTile, t8[s4++] = e6.dxPixels, t8[s4++] = e6.dyPixels, t8[s4++] = e6.hard ? 1 : 0, t8[s4++] = e6.partIndex, n6[s4++] = e6.minLod, n6[s4++] = e6.maxLod, t8[s4++] = e6.width, t8[s4++] = e6.height;
      t8[s4++] = a6.textVertexRanges.length;
      for (const [e6, n7] of a6.textVertexRanges) t8[s4++] = e6, t8[s4++] = n7;
      t8[s4++] = a6.iconVertexRanges.length;
      for (const [e6, n7] of a6.iconVertexRanges) t8[s4++] = e6, t8[s4++] = n7;
    }
    return s4;
  }
  _replaceKeys(e5, t8) {
    return e5.replaceAll(/{([^{}]+)}/g, (e6, n6) => n6 in t8 ? t8[n6] : "");
  }
  _processFeature(e5, t8, n6) {
    const { line: s4, iconMosaicItem: i4, shaping: a6, anchor: o5 } = e5, l4 = this.zoom, h5 = this.layer, x2 = !!i4;
    let c4 = true;
    x2 && (c4 = t8?.optional || !i4);
    const d4 = a6 && a6.length > 0, f3 = !d4 || n6?.optional;
    let g, y3;
    if (x2 && (g = this._placementEngine.getIconPlacement(o5, i4, t8)), (g || c4) && (d4 && (y3 = this._placementEngine.getTextPlacement(o5, a6, s4, n6)), y3 || f3)) {
      if (g && y3 || (f3 || c4 ? f3 || y3 ? c4 || g || (y3 = null) : g = null : (g = null, y3 = null)), y3) {
        const t9 = h5.hasDataDrivenText ? h5.textMaterial.encodeAttributes(e5.symbolFeature.feature, l4, h5) : null;
        if (this._storePlacedGlyphs(e5, y3.shapes, l4, n6.rotationAlignment, t9), y3.textColliders) {
          e5.textColliders = y3.textColliders;
          for (const e6 of y3.textColliders) {
            e6.minLod = Math.max(l4 + h2(e6.minLod), 0), e6.maxLod = Math.min(l4 + h2(e6.maxLod), 25);
            const t10 = e6.angle;
            if (t10) {
              const n7 = Math.cos(t10), s5 = Math.sin(t10), i5 = e6.dxPixels * n7 - e6.dyPixels * s5, a7 = e6.dxPixels * s5 + e6.dyPixels * n7, o6 = (e6.dxPixels + e6.width) * n7 - e6.dyPixels * s5, r7 = (e6.dxPixels + e6.width) * s5 + e6.dyPixels * n7, l5 = e6.dxPixels * n7 - (e6.dyPixels + e6.height) * s5, h6 = e6.dxPixels * s5 + (e6.dyPixels + e6.height) * n7, x3 = (e6.dxPixels + e6.width) * n7 - (e6.dyPixels + e6.height) * s5, c5 = (e6.dxPixels + e6.width) * s5 + (e6.dyPixels + e6.height) * n7, d5 = Math.min(i5, o6, l5, x3), f4 = Math.max(i5, o6, l5, x3), g2 = Math.min(a7, r7, h6, c5), y4 = Math.max(a7, r7, h6, c5);
              e6.dxPixels = d5, e6.dyPixels = g2, e6.width = f4 - d5, e6.height = y4 - g2;
            }
          }
        }
      }
      if (g) {
        const n7 = h5.hasDataDrivenIcon ? h5.iconMaterial.encodeAttributes(e5.symbolFeature.feature, l4, h5) : null;
        if (this._addPlacedIcons(e5, g.shapes, l4, i4.page, 1 === t8.rotationAlignment, n7), g.iconColliders) {
          e5.iconColliders = g.iconColliders;
          for (const e6 of g.iconColliders) {
            e6.minLod = Math.max(l4 + h2(e6.minLod), 0), e6.maxLod = Math.min(l4 + h2(e6.maxLod), 25);
            const t9 = e6.angle;
            if (t9) {
              const n8 = Math.cos(t9), s5 = Math.sin(t9), i5 = e6.dxPixels * n8 - e6.dyPixels * s5, a7 = e6.dxPixels * s5 + e6.dyPixels * n8, o6 = (e6.dxPixels + e6.width) * n8 - e6.dyPixels * s5, r7 = (e6.dxPixels + e6.width) * s5 + e6.dyPixels * n8, l5 = e6.dxPixels * n8 - (e6.dyPixels + e6.height) * s5, h6 = e6.dxPixels * s5 + (e6.dyPixels + e6.height) * n8, x3 = (e6.dxPixels + e6.width) * n8 - (e6.dyPixels + e6.height) * s5, c5 = (e6.dxPixels + e6.width) * s5 + (e6.dyPixels + e6.height) * n8, d5 = Math.min(i5, o6, l5, x3), f4 = Math.max(i5, o6, l5, x3), g2 = Math.min(a7, r7, h6, c5), y4 = Math.max(a7, r7, h6, c5);
              e6.dxPixels = d5, e6.dyPixels = g2, e6.width = f4 - d5, e6.height = y4 - g2;
            }
          }
        }
      }
    }
  }
  _addPlacedIcons(e5, t8, n6, s4, i4, a6) {
    const o5 = Math.max(n6 - 1, 0), l4 = this._iconVertexBuffer, h5 = this._iconIndexBuffer, x2 = this._markerMap;
    for (const c4 of t8) {
      const t9 = i4 ? 0 : Math.max(n6 + h2(c4.minzoom), o5), d4 = i4 ? 25 : Math.min(n6 + h2(c4.maxzoom), 25);
      if (d4 <= t9) continue;
      const f3 = c4.tl, g = c4.tr, y3 = c4.bl, m3 = c4.br, u3 = c4.mosaicRect, p3 = c4.labelAngle, _2 = c4.minAngle, M = c4.maxAngle, b = c4.anchor, P = l4.index, I = u3.x, A = u3.y, V2 = I + u3.width, w2 = A + u3.height, L = l4.index;
      l4.add(b.x, b.y, f3.x, f3.y, I, A, p3, _2, M, t9, d4, a6), l4.add(b.x, b.y, g.x, g.y, V2, A, p3, _2, M, t9, d4, a6), l4.add(b.x, b.y, y3.x, y3.y, I, w2, p3, _2, M, t9, d4, a6), l4.add(b.x, b.y, m3.x, m3.y, V2, w2, p3, _2, M, t9, d4, a6), e5.iconVertexRanges.length > 0 && e5.iconVertexRanges[0][0] + e5.iconVertexRanges[0][1] === L ? e5.iconVertexRanges[0][1] += 4 : e5.iconVertexRanges.push([L, 4]), h5.add(P, P + 1, P + 2), h5.add(P + 1, P + 2, P + 3), x2.has(s4) ? x2.get(s4)[1] += 6 : x2.set(s4, [this._iconIndexStart + this._iconIndexCount, 6]), this._iconIndexCount += 6;
    }
  }
  _addPlacedGlyphs() {
    const e5 = this._textVertexBuffer, t8 = this._textIndexBuffer, n6 = this._glyphMap;
    for (const [s4, i4] of this._glyphBufferDataStorage) for (const a6 of i4) {
      const i5 = e5.index, o5 = a6.symbolInstance, r7 = a6.ddAttributes, l4 = e5.index;
      e5.add(a6.glyphAnchor[0], a6.glyphAnchor[1], a6.tl[0], a6.tl[1], a6.xmin, a6.ymin, a6.labelAngle, a6.minAngle, a6.maxAngle, a6.minLod, a6.maxLod, r7), e5.add(a6.glyphAnchor[0], a6.glyphAnchor[1], a6.tr[0], a6.tr[1], a6.xmax, a6.ymin, a6.labelAngle, a6.minAngle, a6.maxAngle, a6.minLod, a6.maxLod, r7), e5.add(a6.glyphAnchor[0], a6.glyphAnchor[1], a6.bl[0], a6.bl[1], a6.xmin, a6.ymax, a6.labelAngle, a6.minAngle, a6.maxAngle, a6.minLod, a6.maxLod, r7), e5.add(a6.glyphAnchor[0], a6.glyphAnchor[1], a6.br[0], a6.br[1], a6.xmax, a6.ymax, a6.labelAngle, a6.minAngle, a6.maxAngle, a6.minLod, a6.maxLod, r7), o5.textVertexRanges.length > 0 && o5.textVertexRanges[0][0] + o5.textVertexRanges[0][1] === l4 ? o5.textVertexRanges[0][1] += 4 : o5.textVertexRanges.push([l4, 4]), t8.add(i5, i5 + 1, i5 + 2), t8.add(i5 + 1, i5 + 2, i5 + 3), n6.has(s4) ? n6.get(s4)[1] += 6 : n6.set(s4, [this._textIndexStart + this._textIndexCount, 6]), this._textIndexCount += 6;
    }
    this._glyphBufferDataStorage.clear();
  }
  _storePlacedGlyphs(e5, t8, n6, s4, i4) {
    const a6 = Math.max(n6 - 1, 0), o5 = 1 === s4;
    let l4, h5, x2, c4, d4, f3, g, y3, m3, u3, p3;
    for (const _2 of t8) {
      if (l4 = o5 ? 0 : Math.max(n6 + h2(_2.minzoom), a6), h5 = o5 ? 25 : Math.min(n6 + h2(_2.maxzoom), 25), h5 <= l4) continue;
      x2 = _2.tl, c4 = _2.tr, d4 = _2.bl, f3 = _2.br, g = _2.labelAngle, y3 = _2.minAngle, m3 = _2.maxAngle, u3 = _2.anchor, p3 = _2.mosaicRect, this._glyphBufferDataStorage.has(_2.page) || this._glyphBufferDataStorage.set(_2.page, []);
      this._glyphBufferDataStorage.get(_2.page).push({ glyphAnchor: [u3.x, u3.y], tl: [x2.x, x2.y], tr: [c4.x, c4.y], bl: [d4.x, d4.y], br: [f3.x, f3.y], xmin: p3.x, ymin: p3.y, xmax: p3.x + p3.width, ymax: p3.y + p3.height, labelAngle: g, minAngle: y3, maxAngle: m3, minLod: l4, maxLod: h5, placementLod: a6, symbolInstance: e5, ddAttributes: i4 });
    }
  }
  static _pushAnchors(e5, t8, n6, i4) {
    n6 += i4;
    let a6 = 0;
    const o5 = t8.length - 1;
    for (let l4 = 0; l4 < o5; l4++) a6 += i.distance(t8[l4], t8[l4 + 1]);
    let r7 = i4 || n6;
    if (r7 *= 0.5, a6 <= r7) return;
    const x2 = r7 / a6;
    let c4 = 0, d4 = -(n6 = a6 / Math.max(Math.round(a6 / n6), 1)) / 2;
    const f3 = t8.length - 1;
    for (let s4 = 0; s4 < f3; s4++) {
      const i5 = t8[s4], a7 = t8[s4 + 1], o6 = a7.x - i5.x, r8 = a7.y - i5.y, f4 = Math.sqrt(o6 * o6 + r8 * r8);
      let g;
      for (; d4 + n6 < c4 + f4; ) {
        d4 += n6;
        const t9 = (d4 - c4) / f4, y3 = p(i5.x, a7.x, t9), m3 = p(i5.y, a7.y, t9);
        void 0 === g && (g = Math.atan2(r8, o6)), e5.push(new d3(y3, m3, g, s4, x2));
      }
      c4 += f4;
    }
  }
  static _pushCenterAnchor(e5, t8) {
    let n6 = 0;
    const i4 = t8.length - 1;
    for (let l4 = 0; l4 < i4; l4++) n6 += i.distance(t8[l4], t8[l4 + 1]);
    const a6 = n6 / 2;
    let o5 = 0;
    const r7 = t8.length - 1;
    for (let s4 = 0; s4 < r7; s4++) {
      const n7 = t8[s4], i5 = t8[s4 + 1], r8 = i5.x - n7.x, x2 = i5.y - n7.y, c4 = Math.sqrt(r8 * r8 + x2 * x2);
      if (a6 < o5 + c4) {
        const t9 = (a6 - o5) / c4, d4 = p(n7.x, i5.x, t9), f3 = p(n7.y, i5.y, t9), g = Math.atan2(x2, r8);
        return void e5.push(new d3(d4, f3, g, s4, 0));
      }
      o5 += c4;
    }
  }
  static _deviation(e5, t8, n6) {
    const s4 = (t8.x - e5.x) * (n6.x - t8.x) + (t8.y - e5.y) * (n6.y - t8.y), i4 = (t8.x - e5.x) * (n6.y - t8.y) - (t8.y - e5.y) * (n6.x - t8.x);
    return Math.atan2(i4, s4);
  }
  static _honorsTextMaxAngle(e5, t8, n6, i4, a6) {
    let o5 = 0;
    const r7 = n6 / 2;
    let l4 = new i(t8.x, t8.y), h5 = t8.segment + 1;
    for (; o5 > -r7; ) {
      if (--h5, h5 < 0) return false;
      o5 -= i.distance(e5[h5], l4), l4 = e5[h5];
    }
    o5 += i.distance(e5[h5], e5[h5 + 1]);
    const x2 = [];
    let c4 = 0;
    const d4 = e5.length;
    for (; o5 < r7; ) {
      const t9 = e5[h5];
      let n7, r8 = h5;
      do {
        if (++r8, r8 === d4) return false;
        n7 = e5[r8];
      } while (n7.isEqual(t9));
      let l5, f3 = r8;
      do {
        if (++f3, f3 === d4) return false;
        l5 = e5[f3];
      } while (l5.isEqual(n7));
      const g = this._deviation(t9, n7, l5);
      for (x2.push({ deviation: g, distToAnchor: o5 }), c4 += g; o5 - x2[0].distToAnchor > a6; ) c4 -= x2.shift().deviation;
      if (Math.abs(c4) > i4) return false;
      o5 += i.distance(n7, l5), h5 = r8;
    }
    return true;
  }
  static _smoothVertices(e5, t8) {
    if (t8 <= 0) return e5;
    let n6 = e5.length;
    if (n6 < 3) return e5;
    const i4 = [];
    let a6 = 0, o5 = 0;
    i4.push(0);
    for (let y3 = 1; y3 < n6; y3++) {
      const t9 = i.distance(e5[y3], e5[y3 - 1]);
      t9 > 0 && (a6 += t9, i4.push(a6), o5++, o5 !== y3 && (e5[o5] = e5[y3]));
    }
    if (n6 = o5 + 1, n6 < 3) return e5;
    t8 = Math.min(t8, 0.2 * a6);
    const r7 = e5[0].x, l4 = e5[0].y, h5 = e5[n6 - 1].x, x2 = e5[n6 - 1].y, c4 = i.sub(e5[0], e5[1]);
    c4.normalize(), e5[0].x += t8 * c4.x, e5[0].y += t8 * c4.y, c4.assignSub(e5[n6 - 1], e5[n6 - 2]), c4.normalize(), e5[n6 - 1].x += t8 * c4.x, e5[n6 - 1].y += t8 * c4.y, i4[0] -= t8, i4[n6 - 1] += t8;
    const d4 = [];
    d4.push(new i(r7, l4));
    const f3 = 1e-6, g = 0.5 * t8;
    for (let y3 = 1; y3 < n6 - 1; y3++) {
      let a7 = 0, o6 = 0, r8 = 0;
      for (let n7 = y3 - 1; n7 >= 0; n7--) {
        const s4 = g + i4[n7 + 1] - i4[y3];
        if (s4 < 0) break;
        const l5 = i4[n7 + 1] - i4[n7], h6 = i4[y3] - i4[n7] < g ? 1 : s4 / l5;
        if (h6 < f3) break;
        const x3 = h6 * h6, c5 = h6 * s4 - 0.5 * x3 * l5, d5 = h6 * l5 / t8, m3 = e5[n7 + 1], u3 = e5[n7].x - m3.x, p3 = e5[n7].y - m3.y;
        a7 += d5 / c5 * (m3.x * h6 * s4 + 0.5 * x3 * (s4 * u3 - l5 * m3.x) - x3 * h6 * l5 * u3 / 3), o6 += d5 / c5 * (m3.y * h6 * s4 + 0.5 * x3 * (s4 * p3 - l5 * m3.y) - x3 * h6 * l5 * p3 / 3), r8 += d5;
      }
      for (let s4 = y3 + 1; s4 < n6; s4++) {
        const n7 = g - i4[s4 - 1] + i4[y3];
        if (n7 < 0) break;
        const l5 = i4[s4] - i4[s4 - 1], h6 = i4[s4] - i4[y3] < g ? 1 : n7 / l5;
        if (h6 < f3) break;
        const x3 = h6 * h6, c5 = h6 * n7 - 0.5 * x3 * l5, d5 = h6 * l5 / t8, m3 = e5[s4 - 1], u3 = e5[s4].x - m3.x, p3 = e5[s4].y - m3.y;
        a7 += d5 / c5 * (m3.x * h6 * n7 + 0.5 * x3 * (n7 * u3 - l5 * m3.x) - x3 * h6 * l5 * u3 / 3), o6 += d5 / c5 * (m3.y * h6 * n7 + 0.5 * x3 * (n7 * p3 - l5 * m3.y) - x3 * h6 * l5 * p3 / 3), r8 += d5;
      }
      d4.push(new i(a7 / r8, o6 / r8));
    }
    return d4.push(new i(h5, x2)), e5[0].x = r7, e5[0].y = l4, e5[n6 - 1].x = h5, e5[n6 - 1].y = x2, d4;
  }
  static _pushCentroid(e5, t8) {
    const n6 = 0, s4 = 0, i4 = t3, o5 = t3, r7 = t8.length - 1;
    let l4 = 0, x2 = 0, c4 = 0, d4 = t8[0].x, f3 = t8[0].y;
    d4 > i4 && (d4 = i4), d4 < n6 && (d4 = n6), f3 > o5 && (f3 = o5), f3 < s4 && (f3 = s4);
    for (let a6 = 1; a6 < r7; a6++) {
      let e6 = t8[a6].x, r8 = t8[a6].y, h5 = t8[a6 + 1].x, g = t8[a6 + 1].y;
      e6 > i4 && (e6 = i4), e6 < n6 && (e6 = n6), r8 > o5 && (r8 = o5), r8 < s4 && (r8 = s4), h5 > i4 && (h5 = i4), h5 < n6 && (h5 = n6), g > o5 && (g = o5), g < s4 && (g = s4);
      const y3 = (e6 - d4) * (g - f3) - (h5 - d4) * (r8 - f3);
      l4 += y3 * (d4 + e6 + h5), x2 += y3 * (f3 + r8 + g), c4 += y3;
    }
    l4 /= 3 * c4, x2 /= 3 * c4, isNaN(l4) || isNaN(x2) || e5.push(new d3(l4, x2));
  }
};
_u._bidiEngine = new C();
var u2 = _u;

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileParser.js
var k = class {
  constructor(t8, r7, o5, a6, n6, l4) {
    if (this._pbfTiles = {}, this._tileClippers = {}, this._client = o5, this._tile = r7, this._sourceDataMaxLOD = a6, l4) {
      this._styleLayerUIDs = /* @__PURE__ */ new Set();
      for (const e5 of l4) this._styleLayerUIDs.add(e5);
    }
    this._styleRepository = n6, this._layers = this._styleRepository?.layers ?? [];
    const [u3, f3, p3] = r7.tileKey.split("/").map(parseFloat);
    this._level = u3;
    const h5 = d2(this._level);
    for (const c4 of Object.keys(t8)) {
      const r8 = t8[c4];
      this._pbfTiles[c4] = new n2(new Uint8Array(r8.protobuff), new DataView(r8.protobuff));
      if (r8.refKey) {
        const [e5] = r8.refKey.split("/").map(parseFloat), t9 = u3 - e5;
        if (t9 > 0) {
          const e6 = (1 << t9) - 1, r9 = f3 & e6, i4 = p3 & e6;
          this._tileClippers[c4] = new h(t9, r9, i4, 8, h5);
        }
      }
      this._tileClippers[c4] || (this._tileClippers[c4] = new n3());
    }
  }
  _canParseStyleLayer(e5) {
    return !this._styleLayerUIDs || this._styleLayerUIDs.has(e5);
  }
  async parse(e5) {
    const t8 = i2(), s4 = this._initialize(e5), { returnedBuckets: i4 } = s4;
    this._processLayers(s4), this._linkReferences(s4), this._filterFeatures(s4);
    const o5 = [], c4 = /* @__PURE__ */ new Set(), a6 = (e6, t9) => {
      c4.has(e6) || (o5.push({ name: e6, repeat: t9 }), c4.add(e6));
    }, n6 = {};
    for (const r7 of i4) r7.getResources(r7.tileClipper, a6, n6);
    if (4 === this._tile.status) return [];
    const l4 = this._fetchResources(o5, n6, e5);
    return Promise.all([...l4, t8]).then(() => this._processFeatures(s4.returnedBuckets));
  }
  _initialize(e5) {
    const t8 = e5?.signal;
    return { signal: t8, sourceNameToTileData: this._parseTileData(this._pbfTiles), layers: this._layers, zoom: this._level, sourceNameToTileClipper: this._tileClippers, sourceNameToUniqueSourceLayerBuckets: {}, sourceNameToUniqueSourceLayers: {}, returnedBuckets: [], layerIdToBucket: {}, referencerUIDToReferencedId: /* @__PURE__ */ new Map() };
  }
  _processLayers(e5) {
    const { sourceNameToTileData: t8, zoom: r7, layers: s4, sourceNameToTileClipper: i4, sourceNameToUniqueSourceLayerBuckets: o5, sourceNameToUniqueSourceLayers: c4, returnedBuckets: a6, layerIdToBucket: n6, referencerUIDToReferencedId: l4 } = e5, u3 = this._sourceDataMaxLOD;
    for (let f3 = s4.length - 1; f3 >= 0; f3--) {
      const e6 = s4[f3];
      if (r7 < u3) {
        if (e6.minzoom && r7 < Math.floor(e6.minzoom) || e6.maxzoom && r7 >= e6.maxzoom) continue;
      } else if (e6.maxzoom && r7 >= e6.maxzoom) continue;
      if (0 === e6.type || !this._canParseStyleLayer(e6.uid) || !t8[e6.source] || !i4[e6.source]) continue;
      const p3 = t8[e6.source], h5 = i4[e6.source], m3 = e6.sourceLayer, _2 = p3[m3];
      if (_2) {
        let t9 = c4[e6.source];
        if (t9 || (t9 = c4[e6.source] = /* @__PURE__ */ new Set()), t9.add(e6.sourceLayer), e6.refLayerId) l4.set(e6.uid, e6.refLayerId);
        else {
          const t10 = this._createBucket(e6);
          if (t10) {
            t10.layerUIDs = [e6.uid], t10.layerExtent = _2.extent, t10.tileClipper = h5;
            let r8 = o5[e6.source];
            r8 || (r8 = o5[e6.source] = {});
            let s5 = r8[m3];
            s5 || (s5 = r8[m3] = []), s5.push(t10), a6.push(t10), n6[e6.id] = t10;
          }
        }
      }
    }
  }
  _linkReferences(e5) {
    const { layerIdToBucket: t8, referencerUIDToReferencedId: r7 } = e5;
    r7.forEach((e6, r8) => {
      t8[e6] && t8[e6].layerUIDs.push(r8);
    });
  }
  _filterFeatures(e5) {
    const { signal: r7, sourceNameToTileData: s4, sourceNameToUniqueSourceLayerBuckets: i4, sourceNameToUniqueSourceLayers: c4 } = e5, a6 = 10 * this._level, n6 = 10 * (this._level + 1), l4 = [], u3 = [];
    for (const t8 of Object.keys(c4)) {
      c4[t8].forEach((e6) => {
        l4.push(e6), u3.push(t8);
      });
    }
    for (let f3 = 0; f3 < l4.length; f3++) {
      const e6 = u3[f3], c5 = l4[f3];
      if (!s4[e6] || !i4[e6]) continue;
      const p3 = s4[e6][c5], h5 = i4[e6][c5];
      if (!h5 || 0 === h5.length) continue;
      if (a(r7)) return;
      let m3 = 0;
      const _2 = p3.getData();
      for (; _2.nextTag(2); ) {
        const e7 = _2.getMessage(), t8 = new t4(e7, p3, m3++);
        e7.release();
        const r8 = t8.values;
        if (r8) {
          const e8 = r8._minzoom;
          if (e8 && e8 >= n6) continue;
          const t9 = r8._maxzoom;
          if (t9 && t9 <= a6) continue;
        }
        for (const s5 of h5) s5.pushFeature(t8);
      }
    }
  }
  _fetchResources(e5, t8, r7) {
    const s4 = [], i4 = this._tile.getWorkerTileHandler();
    let o5, c4;
    e5.length > 0 && (o5 = i4.fetchSprites(e5, this._client, r7), s4.push(o5));
    for (const a6 in t8) {
      const e6 = t8[a6];
      e6.size > 0 && (c4 = i4.fetchGlyphs(this._tile.tileKey, a6, e6, this._client, r7), s4.push(c4));
    }
    return s4;
  }
  _processFeatures(e5) {
    const t8 = e5.filter((e6) => e6.hasFeatures() || this._canParseStyleLayer(e6.layer.uid));
    for (const r7 of t8) r7.processFeatures(r7.tileClipper);
    return t8;
  }
  _parseTileData(e5) {
    const t8 = {};
    for (const r7 of Object.keys(e5)) {
      const s4 = e5[r7], i4 = {};
      for (; s4.next(); ) switch (s4.tag()) {
        case 3: {
          const e6 = s4.getMessage(), t9 = new t6(e6);
          e6.release(), i4[t9.name] = t9;
          break;
        }
        default:
          s4.skip();
      }
      t8[r7] = i4;
    }
    return t8;
  }
  _createBucket(e5) {
    switch (e5.type) {
      case 0:
        return null;
      case 1:
        return this._createFillBucket(e5);
      case 2:
        return this._createLineBucket(e5);
      case 4:
        return this._createCircleBucket(e5);
      case 3:
        return this._createSymbolBucket(e5);
    }
  }
  _createFillBucket(e5) {
    return new n4(e5, this._level, this._tile.getWorkerTileHandler().getSpriteItems(), new r3(e5.fillMaterial.getStride()), new r2(), new u(e5.outlineMaterial.getStride()), new r2());
  }
  _createLineBucket(e5) {
    return new s3(e5, this._level, this._tile.getWorkerTileHandler().getSpriteItems(), new o3(e5.lineMaterial.getStride()), new r2());
  }
  _createCircleBucket(e5) {
    return new t7(e5, this._level, this._tile.getWorkerTileHandler().getSpriteItems(), new a5(e5.circleMaterial.getStride()), new r2());
  }
  _createSymbolBucket(e5) {
    const t8 = this._tile;
    return new u2(t8.tileKey, e5, this._level, new h4(e5.iconMaterial.getStride()), new r2(), new h4(e5.textMaterial.getStride()), new r2(), t8.placementEngine, t8.getWorkerTileHandler());
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/WorkerTile.js
var r5 = class {
  constructor(t8, s4, r7, i4) {
    this.status = 0, this.placementEngine = new f2(), this.tileKey = t8, this.refKeys = s4, this._workerTileHandler = r7, this._styleRepository = i4;
  }
  release() {
    this.tileKey = "", this.refKeys = null, this.status = 0, this._workerTileHandler = null;
  }
  async parse(e5, s4) {
    const r7 = s4?.signal;
    if (null != r7) {
      const t8 = () => {
        r7.removeEventListener("abort", t8), this.status = 4;
      };
      r7.addEventListener("abort", t8);
    }
    let i4;
    const a6 = { bucketsWithData: [], emptyBuckets: null };
    try {
      i4 = await this._parse(e5, s4);
    } catch (h5) {
      if (d(h5)) throw h5;
      return { result: a6, transferList: [] };
    }
    this.status = 2;
    const n6 = a6.bucketsWithData, l4 = [];
    for (const t8 of i4) if (t8.hasFeatures()) {
      const e6 = t8.serialize();
      n6.push(e6);
    } else l4.push(t8.layer.uid);
    const o5 = [...n6];
    let u3 = null;
    return l4.length > 0 && (u3 = Uint32Array.from(l4), o5.push(u3.buffer)), a6.emptyBuckets = u3, { result: a6, transferList: o5 };
  }
  setObsolete() {
    this.status = 4;
  }
  getLayers() {
    return this._workerTileHandler.getLayers();
  }
  getWorkerTileHandler() {
    return this._workerTileHandler;
  }
  async _parse(t8, e5) {
    const r7 = t8.sourceName2DataAndRefKey;
    if (0 === Object.keys(r7).length) return [];
    this.status = 3;
    return new k(r7, this, e5.client, t8.sourceDataMaxLOD, this._styleRepository, t8.styleLayerUIDs).parse(e5);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/WorkerTileHandler.js
var r6 = 25;
var o4 = class {
  constructor() {
    this._spriteInfo = {}, this._glyphInfo = {}, this._sourceDataMaxLOD = r6;
  }
  reset() {
    return this._spriteInfo = {}, this._glyphInfo = {}, Promise.resolve();
  }
  getLayers() {
    return this._styleRepository?.layers ?? [];
  }
  async createTileAndParse(s4, r7) {
    const { key: o5 } = s4, i4 = {};
    for (const e5 of Object.keys(s4.sourceName2DataAndRefKey)) {
      const t8 = s4.sourceName2DataAndRefKey[e5];
      i4[e5] = t8.refKey;
    }
    const a6 = new r5(o5, i4, this, this._styleRepository);
    try {
      return await a6.parse({ ...s4, sourceDataMaxLOD: this._sourceDataMaxLOD }, r7);
    } catch (n6) {
      if (a6.setObsolete(), a6.release(), !d(n6)) throw n6;
      return null;
    }
  }
  updateStyle(e5) {
    if (!e5 || 0 === e5.length || !this._styleRepository) return;
    const t8 = this._styleRepository;
    for (const s4 of e5) {
      const e6 = s4.type, r7 = s4.data;
      switch (e6) {
        case 0:
          t8.setPaintProperties(r7.layer, r7.paint);
          break;
        case 1:
          t8.setLayoutProperties(r7.layer, r7.layout);
          break;
        case 3:
          t8.deleteStyleLayer(r7.layer);
          break;
        case 2:
          t8.setStyleLayer(r7.layer, r7.index);
          break;
        case 4:
          this._spriteInfo = {};
      }
    }
  }
  setStyle(e5) {
    const { style: t8, sourceDataMaxLOD: r7 } = e5;
    this._styleRepository = new l2(t8), this._sourceDataMaxLOD = r7, this._spriteInfo = {}, this._glyphInfo = {};
  }
  fetchSprites(e5, t8, s4) {
    const r7 = [], o5 = this._spriteInfo;
    for (const i4 of e5) {
      void 0 === o5[i4.name] && r7.push(i4);
    }
    return 0 === r7.length ? Promise.resolve() : t8.invoke("getSprites", r7, { signal: s4?.signal }).then((e6) => {
      for (const t9 in e6) {
        const s5 = e6[t9];
        o5[t9] = s5;
      }
    });
  }
  getSpriteItems() {
    return this._spriteInfo;
  }
  fetchGlyphs(e5, t8, s4, r7, o5) {
    const i4 = [];
    let a6 = this._glyphInfo[t8];
    return a6 ? s4.forEach((e6) => {
      a6[e6] || i4.push(e6);
    }) : (a6 = this._glyphInfo[t8] = [], s4.forEach((e6) => i4.push(e6))), 0 === i4.length ? Promise.resolve() : r7.invoke("getGlyphs", { tileID: e5, font: t8, codePoints: i4 }, o5).then((e6) => {
      for (let t9 = 0; t9 < e6.length; t9++) e6[t9] && (a6[t9] = e6[t9]);
    });
  }
  getGlyphItems(e5) {
    return this._glyphInfo[e5];
  }
};
export {
  o4 as default
};
//# sourceMappingURL=WorkerTileHandler-GULSUWE6.js.map
