import {
  E,
  I,
  N as N2
} from "./chunk-2W3LGFFY.js";
import {
  E as E2,
  S,
  d as d3,
  f as f3,
  h,
  p
} from "./chunk-5BM4D5UD.js";
import "./chunk-W2EKXSEY.js";
import {
  a,
  l,
  u
} from "./chunk-DUZAVZR4.js";
import "./chunk-EK7HOTRR.js";
import {
  f
} from "./chunk-5DFXT3PU.js";
import "./chunk-CKE7BUXC.js";
import "./chunk-B5SL7XHP.js";
import {
  W
} from "./chunk-3VXANCFN.js";
import "./chunk-MBQEPUQX.js";
import "./chunk-ODQ5APZK.js";
import "./chunk-G5IXTUNN.js";
import "./chunk-ZNQKJRCD.js";
import {
  f as f2,
  g
} from "./chunk-BA6HYZ35.js";
import "./chunk-GCTH5LET.js";
import "./chunk-Q7VRQYAO.js";
import "./chunk-SJB744AD.js";
import "./chunk-WM2VG5F2.js";
import "./chunk-IXFJYDA2.js";
import "./chunk-TTLSEJNG.js";
import "./chunk-U73R3I4U.js";
import "./chunk-VGXUPJSS.js";
import "./chunk-ZVTEFYZX.js";
import "./chunk-LPUPM55U.js";
import "./chunk-DLM5SBNY.js";
import "./chunk-EKZRA6TO.js";
import "./chunk-M5SP6ZBM.js";
import "./chunk-FAA2FDN5.js";
import {
  Z
} from "./chunk-2HGIYEIL.js";
import {
  lt,
  ot,
  rt,
  st,
  ut
} from "./chunk-XX3OKYJS.js";
import "./chunk-OTCNIJ2H.js";
import "./chunk-JGA5YJWL.js";
import "./chunk-GCI4MA3M.js";
import "./chunk-SJ2OBYX2.js";
import "./chunk-MDJNYPVI.js";
import "./chunk-Z6VKIQV2.js";
import "./chunk-4PXNA4MD.js";
import "./chunk-XDLV73DB.js";
import "./chunk-ARTU4L55.js";
import "./chunk-6VL5D5UP.js";
import "./chunk-6QHY54HZ.js";
import "./chunk-GXJJY3ND.js";
import "./chunk-5ONGWFJ3.js";
import "./chunk-PLNHHGHL.js";
import "./chunk-DFK6QMLO.js";
import "./chunk-EM7Y2JZC.js";
import {
  i as i2
} from "./chunk-AQFRVV3U.js";
import "./chunk-3GHCGAH2.js";
import "./chunk-HWUOAPTX.js";
import "./chunk-QHCKOBU7.js";
import "./chunk-K2OZ6WVC.js";
import {
  ee,
  ne
} from "./chunk-MC6NAKKX.js";
import "./chunk-TF6255HN.js";
import {
  v
} from "./chunk-GD4FJL3C.js";
import "./chunk-C5OQVQZF.js";
import {
  d as d2
} from "./chunk-XL5QPCXN.js";
import "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-C5M24ACM.js";
import "./chunk-L4A2QJG4.js";
import "./chunk-ENINOZUZ.js";
import "./chunk-V2X4OKYI.js";
import "./chunk-LPZUGJNG.js";
import "./chunk-XLOINTMG.js";
import "./chunk-T7F6Q6JJ.js";
import "./chunk-YDTPM7OQ.js";
import "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-3FUHCAX3.js";
import "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import "./chunk-2OFHDVO5.js";
import "./chunk-TFJXG32O.js";
import "./chunk-DDOCCRD4.js";
import {
  n
} from "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-CSMCPN64.js";
import "./chunk-GY6YF4EN.js";
import "./chunk-7H3U4IJR.js";
import "./chunk-SMWUT52Z.js";
import "./chunk-AXZMNHTN.js";
import "./chunk-5T3MJDSR.js";
import {
  N,
  T
} from "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import "./chunk-234CIOHE.js";
import {
  H2 as H
} from "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import "./chunk-5EI5H4QX.js";
import "./chunk-ZIE53VIV.js";
import "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import {
  d
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/layers/graphics/sources/geojson/GeoJSONSourceWorker.js
var D = { hasAttachments: false, capabilities: "query, editing, create, delete, update", useStandardizedQueries: true, supportsCoordinatesQuantization: true, supportsReturningQueryGeometry: true, advancedQueryCapabilities: { supportsQueryAttachments: false, supportsQueryAttachmentOrderByFields: false, supportsQueryAttachmentWithTypeWildcard: false, supportsQueryBins: true, supportsQueryPivot: false, supportsQueryWithCacheHint: true, supportsQueryWithDistance: true, supportsQueryWithResultType: true, supportsStatistics: true, supportsPercentileStatistics: true, supportsReturningGeometryCentroid: true, supportsDistinct: true, supportsReturningQueryExtent: true, supportsReturningGeometryProperties: false, supportsHavingClause: true, supportsOrderBy: true, supportsPagination: true, supportsSqlExpression: true, supportsDisjointSpatialRel: true }, queryBinsCapabilities: S };
var A = class {
  constructor() {
    this._queryEngine = null, this._snapshotFeatures = async (e) => {
      const t = await this._fetch(e);
      return this._createFeatures(t);
    };
  }
  destroy() {
    this._queryEngine?.destroy(), this._queryEngine = this._createDefaultAttributes = null;
  }
  async load(e, t = {}) {
    this._loadOptions = { url: e.url, customParameters: e.customParameters };
    const i3 = [], [r] = await Promise.all([e.url ? this._fetch(t?.signal) : null, this._checkProjection(e.spatialReference)]), n2 = I(r, { geometryType: e.geometryType }), o = e.fields || n2.fields || [], u2 = null != e.hasZ ? e.hasZ : n2.hasZ, l2 = n2.geometryType;
    let d4 = e.objectIdField || n2.objectIdFieldName || "__OBJECTID";
    const p2 = e.spatialReference || N;
    let c = e.timeInfo;
    o === n2.fields && n2.unknownFields.length > 0 && i3.push({ name: "geojson-layer:unknown-field-types", message: "Some fields types couldn't be inferred from the features and were dropped", details: { unknownFields: n2.unknownFields } });
    const m = new Z(o);
    let h2 = m.get(d4);
    h2 ? ("esriFieldTypeString" !== h2.type && (h2.type = "esriFieldTypeOID"), h2.editable = false, h2.nullable = false, d4 = h2.name) : (h2 = { alias: d4, name: d4, type: "string" === n2.objectIdFieldType ? "esriFieldTypeString" : "esriFieldTypeOID", editable: false, nullable: false }, o.unshift(h2));
    const _ = {};
    for (const a2 of o) {
      if (null == a2.name && (a2.name = a2.alias), null == a2.alias && (a2.alias = a2.name), !a2.name) throw new s("geojson-layer:invalid-field-name", "field name is missing", { field: a2 });
      if (!i2.jsonValues.includes(a2.type)) throw new s("geojson-layer:invalid-field-type", `invalid type for field "${a2.name}"`, { field: a2 });
      if (a2.name !== h2.name) {
        const e2 = ee(a2);
        void 0 !== e2 && (_[a2.name] = e2);
      }
      null == a2.length && (a2.length = ne(a2));
    }
    if (c) {
      if (c.startTimeField) {
        const e2 = m.get(c.startTimeField);
        e2 ? (c.startTimeField = e2.name, e2.type = "esriFieldTypeDate") : c.startTimeField = null;
      }
      if (c.endTimeField) {
        const e2 = m.get(c.endTimeField);
        e2 ? (c.endTimeField = e2.name, e2.type = "esriFieldTypeDate") : c.endTimeField = null;
      }
      if (c.trackIdField) {
        const e2 = m.get(c.trackIdField);
        e2 ? c.trackIdField = e2.name : (c.trackIdField = null, i3.push({ name: "geojson-layer:invalid-timeInfo-trackIdField", message: "trackIdField is missing", details: { timeInfo: c } }));
      }
      c.startTimeField || c.endTimeField || (i3.push({ name: "geojson-layer:invalid-timeInfo", message: "startTimeField and endTimeField are missing", details: { timeInfo: c } }), c = null);
    }
    const I2 = l2 ? u(l2) : void 0, b = m.dateFields.length ? { timeZoneIANA: n } : null, T2 = { warnings: i3, featureErrors: [], layerDefinition: { ...D, drawingInfo: I2 ?? void 0, templates: l(_), extent: void 0, geometryType: l2, objectIdField: d4, fields: o, hasZ: !!u2, timeInfo: c, dateFieldsTimeReference: b } }, w = { type: "object-id", fieldName: d4 };
    this._queryEngine = new W({ fieldsIndex: Z.fromLayerJSON({ fields: o, timeInfo: c, dateFieldsTimeReference: b }), geometryType: l2, hasM: false, hasZ: u2, featureIdInfo: w, spatialReference: p2, timeInfo: c, featureStore: new f({ geometryType: l2, hasM: false, hasZ: u2 }) });
    const q = this._queryEngine.fieldsIndex.requiredFields.indexOf(h2);
    q > -1 && this._queryEngine.fieldsIndex.requiredFields.splice(q, 1), this._createDefaultAttributes = a(_, d4);
    const x = this._createFeatures(r);
    this._objectIdGenerator = this._createObjectIdGenerator(this._queryEngine, x);
    const S2 = this._normalizeFeatures(x, T2.featureErrors);
    this._queryEngine.featureStore.addMany(S2);
    const { fullExtent: A2, timeExtent: v2 } = await this._queryEngine.fetchRecomputedExtents();
    if (T2.layerDefinition.extent = A2, v2) {
      const { start: e2, end: t2 } = v2;
      T2.layerDefinition.timeInfo.timeExtent = [e2, t2];
    }
    return T2;
  }
  async applyEdits(e) {
    const { spatialReference: t, geometryType: s2 } = this._queryEngine;
    return await Promise.all([E2(t, s2), f2(e.adds, t), f2(e.updates, t)]), await this._waitSnapshotComplete(), this._applyEdits(e);
  }
  async queryFeatures(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQuery(e, t.signal);
  }
  async queryFeatureCount(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForCount(e, t.signal);
  }
  async queryObjectIds(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForIds(e, t.signal);
  }
  async queryExtent(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForExtent(e, t.signal);
  }
  async querySnapping(e, t = {}) {
    return await this._waitSnapshotComplete(), await this._queryEngine.executeQueryForSnapping(e, t.signal);
  }
  async queryAttributeBins(e, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeAttributeBinsQuery(e, t.signal);
  }
  async refresh(e) {
    this._loadOptions.customParameters = e, this._snapshotTask?.abort(), this._snapshotTask = d2(this._snapshotFeatures), this._snapshotTask.promise.then((e2) => {
      this._queryEngine.featureStore.clear(), this._objectIdGenerator = this._createObjectIdGenerator(this._queryEngine, e2);
      const t = this._normalizeFeatures(e2);
      t && this._queryEngine.featureStore.addMany(t);
    }, (e2) => {
      this._queryEngine.featureStore.clear(), d(e2) || i.getLogger("esri.layers.GeoJSONLayer").error(new s("geojson-layer:refresh", "An error occurred during refresh", { error: e2 }));
    }), await this._waitSnapshotComplete();
    const { fullExtent: n2, timeExtent: a2 } = await this._queryEngine.fetchRecomputedExtents();
    return { extent: n2, timeExtent: a2 };
  }
  _createFeatures(e) {
    if (null == e) return [];
    const { geometryType: t, hasZ: s2, objectIdField: i3 } = this._queryEngine, r = N2(e, { geometryType: t, hasZ: s2, objectIdField: i3 });
    if (!T(this._queryEngine.spatialReference, N)) for (const n2 of r) null != n2.geometry && (n2.geometry = ut(g(lt(n2.geometry, this._queryEngine.geometryType, this._queryEngine.hasZ, false), N, this._queryEngine.spatialReference)));
    return r;
  }
  async _waitSnapshotComplete() {
    if (this._snapshotTask && !this._snapshotTask.finished) {
      try {
        await this._snapshotTask.promise;
      } catch {
      }
      return this._waitSnapshotComplete();
    }
  }
  async _fetch(t) {
    const { url: s2, customParameters: i3 } = this._loadOptions, r = (await H(s2 ?? "", { responseType: "json", query: { ...i3 }, signal: t })).data;
    return E(r), r;
  }
  _normalizeFeatures(e, t) {
    const { objectIdField: s2, fieldsIndex: i3 } = this._queryEngine, r = [];
    for (const n2 of e) {
      const e2 = this._createDefaultAttributes(), a2 = d3(i3, e2, n2.attributes, true);
      a2 ? t?.push(a2) : (this._assignObjectId(e2, n2.attributes, true), n2.attributes = e2, n2.objectId = e2[s2], r.push(n2));
    }
    return r;
  }
  async _applyEdits(e) {
    const { adds: t, updates: s2, deletes: i3 } = e, r = { addResults: [], deleteResults: [], updateResults: [], uidToObjectId: {} };
    if (t?.length && this._applyAddEdits(r, t), s2?.length && this._applyUpdateEdits(r, s2), i3?.length) {
      for (const e2 of i3) r.deleteResults.push(f3(e2));
      this._queryEngine.featureStore.removeManyById(i3);
    }
    const { fullExtent: n2, timeExtent: a2 } = await this._queryEngine.fetchRecomputedExtents();
    return { extent: n2, timeExtent: a2, featureEditResults: r };
  }
  _applyAddEdits(e, t) {
    const { addResults: s2 } = e, { geometryType: i3, hasM: r, hasZ: a2, objectIdField: o, spatialReference: u2, featureStore: l2, fieldsIndex: p2 } = this._queryEngine, c = [], y = { type: "object-id", fieldName: o };
    for (const d4 of t) {
      if (d4.geometry && i3 !== v(d4.geometry)) {
        s2.push(p("Incorrect geometry type."));
        continue;
      }
      const t2 = this._createDefaultAttributes(), r2 = d3(p2, t2, d4.attributes);
      if (r2) s2.push(r2);
      else {
        if (this._assignObjectId(t2, d4.attributes), d4.attributes = t2, null != d4.uid) {
          const t3 = d4.attributes[o];
          e.uidToObjectId[d4.uid] = t3;
        }
        if (null != d4.geometry) {
          const e2 = d4.geometry.spatialReference ?? u2;
          d4.geometry = g(h(d4.geometry, e2), e2, u2);
        }
        c.push(d4), s2.push(f3(d4.attributes[o]));
      }
    }
    l2.addMany(rt([], c, i3, a2, r, y));
  }
  _applyUpdateEdits({ updateResults: e }, t) {
    const { geometryType: s2, hasM: i3, hasZ: r, objectIdField: a2, spatialReference: o, featureStore: u2, fieldsIndex: l2 } = this._queryEngine, d4 = { type: "object-id", fieldName: a2 };
    for (const y of t) {
      const { attributes: t2, geometry: m } = y, f4 = t2?.[a2];
      if (null == f4) {
        e.push(p(`Identifier field ${a2} missing`));
        continue;
      }
      if (!u2.has(f4)) {
        e.push(p(`Feature with object id ${f4} missing`));
        continue;
      }
      const g2 = st(u2.getFeature(f4), s2, r, i3);
      if (null != m) {
        if (s2 !== v(m)) {
          e.push(p("Incorrect geometry type."));
          continue;
        }
        const t3 = m.spatialReference ?? o;
        g2.geometry = g(h(m, t3), t3, o);
      }
      if (t2) {
        const s3 = d3(l2, g2.attributes, t2);
        if (s3) {
          e.push(s3);
          continue;
        }
      }
      u2.add(ot(g2, s2, r, i3, d4)), e.push(f3(f4));
    }
  }
  _createObjectIdGenerator(e, t) {
    const s2 = e.fieldsIndex.get(e.objectIdField);
    if ("esriFieldTypeString" === s2.type) return () => s2.name + "-" + Date.now().toString(16);
    let i3 = Number.NEGATIVE_INFINITY;
    for (const r of t) r.objectId && (i3 = Math.max(i3, r.objectId));
    return i3 = Math.max(0, i3) + 1, () => i3++;
  }
  _assignObjectId(e, t, s2 = false) {
    const i3 = this._queryEngine.objectIdField;
    e[i3] = s2 && i3 in t ? t[i3] : this._objectIdGenerator();
  }
  async _checkProjection(e) {
    try {
      await f2(N, e);
    } catch {
      throw new s("geojson-layer", "Projection not supported");
    }
  }
};
export {
  A as default
};
//# sourceMappingURL=GeoJSONSourceWorker-W4KUERDK.js.map
