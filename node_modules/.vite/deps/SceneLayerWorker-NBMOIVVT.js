import "./chunk-A2QKOXAQ.js";
import "./chunk-B3BLJNSM.js";
import "./chunk-ALKEERWI.js";
import {
  d,
  n as n3
} from "./chunk-HHDWMGJ3.js";
import "./chunk-WHHIH5YU.js";
import {
  i,
  i2
} from "./chunk-V6V3WWJF.js";
import "./chunk-ZCI5A4FF.js";
import "./chunk-2D47RURG.js";
import "./chunk-BBYMM7CM.js";
import {
  f as f2,
  u
} from "./chunk-QHCKOBU7.js";
import "./chunk-K2OZ6WVC.js";
import "./chunk-2LC2762W.js";
import "./chunk-W6HOAVT4.js";
import "./chunk-DTZUXJMD.js";
import "./chunk-YLAGKT2D.js";
import "./chunk-6YRQYUCY.js";
import "./chunk-6KDQMJAI.js";
import "./chunk-UDHS2MGH.js";
import "./chunk-ENINOZUZ.js";
import "./chunk-T7F6Q6JJ.js";
import {
  n as n2
} from "./chunk-75XOUSSS.js";
import "./chunk-TH4EQWJJ.js";
import "./chunk-3FUHCAX3.js";
import "./chunk-PZ5RULLK.js";
import "./chunk-OPJX4KXH.js";
import "./chunk-LTPHDYPK.js";
import "./chunk-3OVERDFX.js";
import "./chunk-FPMLKIDB.js";
import "./chunk-AZXJIEZ6.js";
import "./chunk-Q75WYS7K.js";
import "./chunk-H74Q4SYB.js";
import "./chunk-DDOCCRD4.js";
import "./chunk-THQO67BJ.js";
import "./chunk-4YDOPHTZ.js";
import "./chunk-YY5PITIH.js";
import "./chunk-GY6YF4EN.js";
import "./chunk-7H3U4IJR.js";
import {
  T
} from "./chunk-SMWUT52Z.js";
import "./chunk-AXZMNHTN.js";
import {
  f
} from "./chunk-5T3MJDSR.js";
import "./chunk-NMQNUPE4.js";
import "./chunk-6KIXN4DJ.js";
import "./chunk-7DGJB37R.js";
import {
  n
} from "./chunk-234CIOHE.js";
import "./chunk-V2H77UEV.js";
import "./chunk-WRA2WBYC.js";
import "./chunk-XWE6BM2U.js";
import "./chunk-SOIZOFSB.js";
import "./chunk-XXLHAM2M.js";
import "./chunk-5EI5H4QX.js";
import "./chunk-ZIE53VIV.js";
import "./chunk-SS5CLIUY.js";
import "./chunk-R54Q5TGA.js";
import "./chunk-6SSZNBOK.js";
import "./chunk-LZ2XTYP2.js";
import "./chunk-45CFSCQX.js";
import {
  r
} from "./chunk-A5XN2VFT.js";
import "./chunk-65HD3WXL.js";
import "./chunk-4DGC7CBY.js";
import "./chunk-GNMPGHLQ.js";
import "./chunk-QY7XKUIV.js";
import "./chunk-AL6YUTZM.js";
import "./chunk-G26ADAPQ.js";

// node_modules/@arcgis/core/libs/i3s/I3SModule.js
function s() {
  return n4 ??= (async () => {
    const s2 = await import("./i3s-PDL7OP7J.js");
    return await s2.default({ locateFile: (s3) => n(`esri/libs/i3s/${s3}`) });
  })(), n4;
}
function i3() {
  n4 = null;
}
var n4;

// node_modules/@arcgis/core/views/3d/layers/I3SMeshWorkerHandle.js
var n6 = class {
  constructor(s2, o2, t, e, r2, i5) {
    this.layout = s2, this.interleavedVertexData = o2, this.indices = t, this.hasColors = e, this.hasModifications = r2, this.positionData = i5;
  }
};
var h = class {
  constructor(s2, o2, t, e, r2, i5, n7) {
    this.componentOffsets = s2, this.featureIds = o2, this.anchorIds = t, this.anchors = e, this.transformedGeometry = r2, this.globalTrafo = i5, this.obb = n7;
  }
};
var p = new r({ deallocator: null });
var c = n2();

// node_modules/@arcgis/core/views/3d/layers/SceneLayerWorker.js
async function m(e) {
  A = await N();
  const r2 = [e.geometryBuffer];
  return { result: L(A, e, r2), transferList: r2 };
}
async function y(e) {
  A = await N();
  const r2 = [e.geometryBuffer], { geometryBuffer: t } = e, o2 = t.byteLength, n7 = A._malloc(o2), s2 = new Uint8Array(A.HEAPU8.buffer, n7, o2);
  s2.set(new Uint8Array(t));
  const i5 = A.dracoDecompressPointCloudData(n7, s2.byteLength);
  if (A._free(n7), i5.error.length > 0) throw new Error(`i3s.wasm: ${i5.error}`);
  const a = i5.featureIds?.length > 0 ? i5.featureIds.slice() : null, f3 = i5.positions.slice();
  return a && r2.push(a.buffer), r2.push(f3.buffer), { result: { positions: f3, featureIds: a }, transferList: r2 };
}
async function p2(e) {
  await N(), S(e);
  const r2 = { buffer: e.buffer };
  return { result: r2, transferList: [r2.buffer] };
}
async function h2(e) {
  await N(), j(e);
}
async function b(e) {
  A = await N(), A.setLegacySchema(e.context, e.jsonSchema);
}
async function d2(e) {
  const { localMatrix: i5, origin: a, positions: f3, vertexSpace: c2 } = e, l = f.fromJSON(e.inSpatialReference), u2 = f.fromJSON(e.outSpatialReference), m2 = i5 ? u(i5) : void 0, y2 = f2(a);
  let p3;
  const [{ projectBuffer: h3 }, { initializeProjection: b2 }] = await Promise.all([import("./projectBuffer-5V776FVG.js"), import("./projectionUtils-75MGZULH.js")]);
  await b2(l, u2);
  const d3 = [0, 0, 0];
  if (!h3(y2, l, 0, d3, u2, 0)) throw new Error("Failed to project");
  if ("georeferenced" === c2.type && null == c2.origin) {
    if (p3 = new Float64Array(f3.length), !h3(f3, l, 0, p3, u2, 0, p3.length / 3)) throw new Error("Failed to project");
  } else {
    const e2 = "georeferenced" === c2.type ? i.fromJSON(c2) : i2.fromJSON(c2), { projectMeshVertexPositions: r2 } = await import("./projectMeshVertexPositions-I6S5G4MC.js"), t = r2({ vertexAttributes: { position: f3 }, transform: m2 ? { localMatrix: m2 } : void 0, vertexSpace: e2, spatialReference: l }, u2);
    if (!t) throw new Error("Failed to project");
    p3 = t;
  }
  const g2 = p3.length, [w2, E2, A2] = d3;
  for (let r2 = 0; r2 < g2; r2 += 3) p3[r2] -= w2, p3[r2 + 1] -= E2, p3[r2 + 2] -= A2;
  return { result: { projected: p3, original: f3, projectedOrigin: d3 }, transferList: [p3.buffer, f3.buffer] };
}
async function g({ normalMatrix: r2, normals: t }) {
  const o2 = new Float32Array(t.length);
  return n3(o2, t, r2), T(r2) && d(o2, o2), { result: { transformed: o2, original: t }, transferList: [o2.buffer, t.buffer] };
}
function w(e) {
  _(e);
}
var E;
var A;
function j(e) {
  if (!A) return;
  const r2 = e.modifications, t = A._malloc(8 * r2.length), o2 = new Float64Array(A.HEAPU8.buffer, t, r2.length);
  for (let n7 = 0; n7 < r2.length; ++n7) o2[n7] = r2[n7];
  A.setModifications(e.context, t, r2.length, e.isGeodetic), A._free(t);
}
function L(e, r2, t) {
  const { context: o2, globalTrafo: n7, mbs: s2, obbData: i5, elevationOffset: a, geometryBuffer: f3, geometryDescriptor: c2, indexToVertexProjector: m2, vertexToRenderProjector: y2 } = r2, p3 = e._malloc(f3.byteLength), h3 = 33, b2 = e._malloc(h3 * Float64Array.BYTES_PER_ELEMENT), d3 = new Uint8Array(e.HEAPU8.buffer, p3, f3.byteLength);
  d3.set(new Uint8Array(f3));
  const g2 = new Float64Array(e.HEAPU8.buffer, b2, h3);
  P(g2, [NaN, NaN, NaN]);
  let w2 = g2.byteOffset + 3 * g2.BYTES_PER_ELEMENT, E2 = new Float64Array(g2.buffer, w2);
  P(E2, n7), w2 += 16 * g2.BYTES_PER_ELEMENT, E2 = new Float64Array(g2.buffer, w2), P(E2, s2), w2 += 4 * g2.BYTES_PER_ELEMENT, i5 && (E2 = new Float64Array(g2.buffer, w2), P(E2, i5));
  const A2 = c2, j2 = { isDraco: false, isLegacy: false, color: r2.layouts.some((e2) => e2.some((e3) => "color" === e3.name)), normal: r2.needNormals && r2.layouts.some((e2) => e2.some((e3) => "normalCompressed" === e3.name)), uv0: r2.layouts.some((e2) => e2.some((e3) => "uv0" === e3.name)), uvRegion: r2.layouts.some((e2) => e2.some((e3) => "uvRegion" === e3.name)), featureIndex: A2.featureIndex }, L2 = e.process(o2, !!r2.obbData, p3, d3.byteLength, A2, j2, b2, a, m2, y2, r2.normalReferenceFrame);
  if (e._free(b2), e._free(p3), L2.error.length > 0) throw new Error(`i3s.wasm: ${L2.error}`);
  if (L2.discarded) return null;
  const x2 = L2.componentOffsets.length > 0 ? L2.componentOffsets.slice() : null, S2 = L2.featureIds.length > 0 ? L2.featureIds.slice() : null, _2 = L2.anchorIds.length > 0 ? Array.from(L2.anchorIds) : null, M2 = L2.anchors.length > 0 ? Array.from(L2.anchors) : null, N2 = L2.interleavedVertedData.slice().buffer, U2 = 1 === L2.indicesType ? new Uint16Array(L2.indices.buffer, L2.indices.byteOffset, L2.indices.byteLength / 2).slice() : new Uint32Array(L2.indices.buffer, L2.indices.byteOffset, L2.indices.byteLength / 4).slice(), F = L2.positions.slice(), { buffer: T2, byteOffset: v, byteLength: B } = L2.positionIndices, I = 1 === L2.positionIndicesType ? new Uint16Array(T2, v, B / 2).slice() : new Uint32Array(T2, v, B / 4).slice(), O = new n6(r2.layouts[0], N2, U2, L2.hasColors, L2.hasModifications, { data: F, indices: I });
  return S2 && t.push(S2.buffer), x2 && t.push(x2.buffer), t.push(N2), t.push(U2.buffer), t.push(F.buffer), t.push(I.buffer), new h(x2, S2, _2, M2, O, n7, L2.obb);
}
function x(e) {
  return 0 === e ? 0 : 1 === e ? 1 : 2 === e ? 2 : 3;
}
function S(e) {
  if (!A) return;
  const { context: r2, buffer: t } = e, o2 = A._malloc(t.byteLength), n7 = t.byteLength / Float64Array.BYTES_PER_ELEMENT, s2 = new Float64Array(A.HEAPU8.buffer, o2, n7), i5 = new Float64Array(t);
  s2.set(i5), A.filterOBBs(r2, o2, n7), i5.set(s2), A._free(o2);
}
function _(e) {
  A && 0 === A.destroy(e) && (A = null, E = null, i3());
}
function P(e, r2) {
  for (let t = 0; t < r2.length; ++t) e[t] = r2[t];
}
async function M() {
  A || await N();
}
async function N() {
  return A || (A = await (E ??= s())), A;
}
var U = { transform: (e, r2) => A && L(A, e, r2), destroy: _ };
export {
  w as destroyContext,
  y as dracoDecompressPointCloudData,
  p2 as filterObbsForModifications,
  S as filterObbsForModificationsSync,
  M as initialize,
  x as interpretObbModificationResults,
  m as process,
  d2 as project,
  b as setLegacySchema,
  h2 as setModifications,
  j as setModificationsSync,
  U as test,
  g as transformNormals
};
//# sourceMappingURL=SceneLayerWorker-NBMOIVVT.js.map
