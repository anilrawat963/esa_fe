import {
  a as a4,
  e as e7,
  m as m3,
  n as n5,
  o as o2,
  o2 as o3,
  o3 as o4,
  t as t3
} from "./chunk-Z4KE5G4E.js";
import {
  a as a3,
  j,
  l as l2,
  m as m2,
  s,
  t as t2
} from "./chunk-CYVJEU2B.js";
import {
  t as t4
} from "./chunk-ECKVUXN3.js";
import {
  T,
  d
} from "./chunk-FDSAQJ3R.js";
import {
  r3 as r4
} from "./chunk-I4DSU5MJ.js";
import {
  f
} from "./chunk-66AADZ63.js";
import {
  e as e6
} from "./chunk-MCWHCMX6.js";
import {
  g,
  v
} from "./chunk-SESXYKK5.js";
import {
  r as r5
} from "./chunk-AUP2E2QB.js";
import {
  e as e4
} from "./chunk-U5J3MCMX.js";
import {
  e as e2
} from "./chunk-D7KJNSAT.js";
import {
  c
} from "./chunk-BZV32YR7.js";
import {
  e as e3
} from "./chunk-IT62DCG6.js";
import {
  r as r3
} from "./chunk-EGPAQBOO.js";
import {
  e as e5
} from "./chunk-SZTZNZQW.js";
import {
  n as n4,
  t
} from "./chunk-CFXCM2NO.js";
import {
  A,
  h
} from "./chunk-U55FA2EK.js";
import {
  n as n3
} from "./chunk-QNVJVDYZ.js";
import {
  n as n2
} from "./chunk-WDTGOP77.js";
import {
  H
} from "./chunk-VYMBX5H5.js";
import {
  a as a2,
  e
} from "./chunk-75XOUSSS.js";
import {
  o
} from "./chunk-AZXJIEZ6.js";
import {
  l
} from "./chunk-2OFHDVO5.js";
import {
  p
} from "./chunk-GY6YF4EN.js";
import {
  r as r2
} from "./chunk-SMWUT52Z.js";
import {
  m
} from "./chunk-5EI5H4QX.js";
import {
  a2 as a
} from "./chunk-ZIE53VIV.js";
import {
  __decorate
} from "./chunk-SS5CLIUY.js";
import {
  n
} from "./chunk-45CFSCQX.js";
import {
  r2 as r
} from "./chunk-GNMPGHLQ.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/pbrUtils.js
function n6({ normalTexture: e10, metallicRoughnessTexture: n8, metallicFactor: r7, roughnessFactor: t8, emissiveTexture: o7, emissiveFactor: s3, occlusionTexture: c3 }) {
  return null == e10 && null == n8 && null == o7 && (null == s3 || H(s3, a2)) && null == c3 && (null == t8 || 1 === t8) && (null == r7 || 1 === r7);
}
var t5 = e(1, 1, 0.5);
var o5 = e(0, 0.6, 0.2);
var s2 = e(0, 1, 0.2);

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js
function a5(a7, e10) {
  switch (e10.output) {
    case 4:
    case 5:
    case 6:
    case 7:
      a7.fragment.code.add(t`float _calculateFragDepth(const in float depth) {
const float SLOPE_SCALE = 2.0;
const float BIAS = 20.0 * .000015259;
float m = max(abs(dFdx(depth)), abs(dFdy(depth)));
return depth + SLOPE_SCALE * m + BIAS;
}
void outputDepth(float _linearDepth){
float fragDepth = _calculateFragDepth(_linearDepth);
gl_FragDepth = fragDepth;
}`);
      break;
    case 8:
      a7.fragment.code.add(t`void outputDepth(float _linearDepth){
gl_FragDepth = _linearDepth;
}`);
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/effects/ssao/SSAOBlurTechnique.js
var l3 = class extends m2 {
  constructor(r7, t8) {
    super(r7, t8, new t2(f, () => import("./SSAOBlur.glsl-JKOSKJFF.js")), s);
  }
  initializePipeline() {
    return T({ colorWrite: d });
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/effects/ssao/SSAONoiseData.js
var e8 = "eXKEvZaUc66cjIKElE1jlJ6MjJ6Ufkl+jn2fcXp5jBx7c6KEflSGiXuXeW6OWs+tfqZ2Yot2Y7Zzfo2BhniEj3xoiXuXj4eGZpqEaHKDWjSMe7palFlzc3BziYOGlFVzg6Zzg7CUY5JrjFF7eYJ4jIKEcyyEonSXe7qUfqZ7j3xofqZ2c4R5lFZ5Y0WUbppoe1l2cIh2ezyUho+BcHN2cG6DbpqJhqp2e1GcezhrdldzjFGUcyxjc3aRjDyEc1h7Sl17c6aMjH92pb6Mjpd4dnqBjMOEhqZleIOBYzB7gYx+fnqGjJuEkWlwnCx7fGl+c4hjfGyRe5qMlNOMfnqGhIWHc6OMi4GDc6aMfqZuc6aMzqJzlKZ+lJ6Me3qRfoFue0WUhoR5UraEa6qMkXiPjMOMlJOGe7JrUqKMjK6MeYRzdod+Sl17boiPc6qEeYBlcIh2c1WEe7GDiWCDa0WMjEmMdod+Y0WcdntzhmN8WjyMjKJjiXtzgYxYaGd+a89zlEV7e2GJfnd+lF1rcK5zc4p5cHuBhL6EcXp5eYB7fnh8iX6HjIKEeaxuiYOGc66RfG2Ja5hzjlGMjEmMe9OEgXuPfHyGhPeEdl6JY02McGuMfnqGhFiMa3WJfnx2l4hwcG1uhmN8c0WMc39og1GBbrCEjE2EZY+JcIh2cIuGhIWHe0mEhIVrc09+gY5+eYBlnCyMhGCDl3drfmmMgX15aGd+gYx+fnuRfnhzY1SMsluJfnd+hm98WtNrcIuGh4SEj0qPdkqOjFF7jNNjdnqBgaqUjMt7boeBhnZ4jDR7c5pze4GGjEFrhLqMjHyMc0mUhKZze4WEa117kWlwbpqJjHZ2eX2Bc09zeId+e0V7WlF7jHJ2l72BfId8l3eBgXyBe897jGl7c66cgW+Xc76EjKNbgaSEjGx4fId8jFFjgZB8cG6DhlFziZhrcIh2fH6HgUqBgXiPY8dahGFzjEmMhEFre2dxhoBzc5SGfleGe6alc7aUeYBlhKqUdlp+cH5za4OEczxza0Gcc4J2jHZ5iXuXjH2Jh5yRjH2JcFx+hImBjH+MpddCl3dreZeJjIt8ZW18bm1zjoSEeIOBlF9oh3N7hlqBY4+UeYFwhLJjeYFwaGd+gUqBYxiEYot2fqZ2ondzhL6EYyiEY02Ea0VjgZB8doaGjHxoc66cjEGEiXuXiXWMiZhreHx8frGMe75rY02Ec5pzfnhzlEp4a3VzjM+EhFFza3mUY7Zza1V5e2iMfGyRcziEhDyEkXZ2Y4OBnCx7g5t2eyBjgV6EhEFrcIh2dod+c4Z+nJ5zjm15jEmUeYxijJp7nL6clIpjhoR5WrZraGd+fnuRa6pzlIiMg6ZzfHx5foh+eX1ufnB5eX1ufnB5aJt7UqKMjIh+e3aBfm5lbYSBhGFze6J4c39oc0mUc4Z+e0V7fKFVe0WEdoaGY02Ec4Z+Y02EZYWBfH6HgU1+gY5+hIWUgW+XjJ57ebWRhFVScHuBfJ6PhBx7WqJzlM+Ujpd4gHZziX6HjHmEgZN+lJt5boiPe2GJgX+GjIGJgHZzeaxufnB5hF2JtdN7jJ57hp57hK6ElFVzg6ZzbmiEbndzhIWHe3uJfoFue3qRhJd2j3xoc65zlE1jc3p8lE1jhniEgXJ7e657vZaUc3qBh52BhIF4aHKDa9drgY5+c52GWqZzbpqJe8tjnM+UhIeMfo2BfGl+hG1zSmmMjKJjZVaGgX15c1lze0mEp4OHa3mUhIWHhDyclJ6MeYOJkXiPc0VzhFiMlKaEboSJa5Jze41re3qRhn+HZYWBe0mEc4p5fnORbox5lEp4hGFjhGGEjJuEc1WEhLZjeHeGa7KlfHx2hLaMeX1ugY5+hIWHhKGPjMN7c1WEho1zhoBzZYx7fnhzlJt5exyUhFFziXtzfmmMa6qMYyiEiXxweV12kZSMeWqXSl17fnhzxmmMrVGEe1mcc4p5eHeGjK6MgY5+doaGa6pzlGV7g1qBh4KHkXiPeW6OaKqafqZ2eXZ5e1V7jGd7boSJc3BzhJd2e0mcYot2h1RoY8dahK6EQmWEWjx7e1l2lL6UgXyBdnR4eU9zc0VreX1umqaBhld7fo2Bc6KEc5Z+hDyEcIeBWtNrfHyGe5qMhMuMe5qMhEGEbVVupcNzg3aHhIF4boeBe0mEdlptc39ofFl5Y8uUlJOGiYt2UmGEcyxjjGx4jFF7a657ZYWBnElzhp57iXtrgZN+tfOEhIOBjE2HgU1+e8tjjKNbiWCDhE15gUqBgYN7fnqGc66ce9d7iYSBj0qPcG6DnGGcT3eGa6qMZY+JlIiMl4hwc3aRdnqBlGV7eHJ2hLZjfnuRhDyEeX6MSk17g6Z+c6aUjHmEhIF4gXyBc76EZW18fGl+fkl+jCxrhoVwhDyUhIqGlL2DlI6EhJd2tdN7eYORhEGMa2Faa6pzc3Bzc4R5lIRznM+UY9eMhDycc5Z+c4p5c4iGY117pb6MgXuPrbJafnx2eYOJeXZ5e657hDyEcziElKZjfoB5eHeGj4WRhGGEe6KGeX1utTStc76EhFGJnCyMa5hzfH6HnNeceYB7hmN8gYuMhIVrczSMgYF8h3N7c5pza5hzjJqEYIRdgYuMlL2DeYRzhGGEeX1uhLaEc4iGeZ1zdl6JhrVteX6Me2iMfm5lWqJzSpqEa6pzdnmchHx2c6OMhNdrhoR5g3aHczxzeW52gV6Ejm15frGMc0Vzc4Z+l3drfniJe+9rWq5rlF1rhGGEhoVwe9OEfoh+e7pac09+c3qBY0lrhDycdnp2lJ6MiYOGhGCDc3aRlL2DlJt5doaGdnp2gYF8gWeOjF2Uc4R5c5Z+jEmMe7KEc4mEeYJ4dmyBe0mcgXiPbqJ7eYB7fmGGiYSJjICGlF1reZ2PnElzbpqJfH6Hc39oe4WEc5eJhK6EhqyJc3qBgZB8c09+hEmEaHKDhFGJc5SGiXWMUpaEa89zc6OMnCyMiXtrho+Be5qMc7KEjJ57dmN+hKGPjICGbmiEe7prdod+hGCDdnmchBx7eX6MkXZ2hGGEa657hm98jFFjY5JreYOJgY2EjHZ2a295Y3FajJ6Mc1J+YzB7e4WBjF2Uc4R5eV12gYxzg1qBeId+c9OUc5pzjFFjgY5+hFiMlIaPhoR5lIpjjIKBlNdSe7KEeX2BfrGMhIqGc65zjE2UhK6EklZ+QmWEeziMWqZza3VzdnR4foh+gYF8n3iJiZhrnKp7gYF8eId+lJ6Me1lrcIuGjKJjhmN8c66MjFF7a6prjJ6UnJ5zezyUfruRWlF7nI5zfHyGe657h4SEe8tjhBx7jFFjc09+c39ojICMeZeJeXt+YzRzjHZ2c0WEcIeBeXZ5onSXkVR+gYJ+eYFwdldzgYF7eX2BjJ6UiXuXlE1jh4SEe1mchLJjc4Z+hqZ7eXZ5bm1zlL6Ue5p7iWeGhKqUY5pzjKJjcIeBe8t7gXyBYIRdlEp4a3mGnK6EfmmMZpqEfFl5gYxzjKZuhGFjhoKGhHx2fnx2eXuMe3aBiWeGvbKMe6KGa5hzYzB7gZOBlGV7hmN8hqZlYot2Y117a6pzc6KEfId8foB5rctrfneJfJ6PcHN2hFiMc5pzjH92c0VzgY2EcElzdmCBlFVzg1GBc65zY4OBboeBcHiBeYJ4ewxzfHx5lIRzlEmEnLKEbk1zfJ6PhmN8eYBljBiEnMOEiXxwezyUcIeBe76EdsKEeX2BdnR4jGWUrXWMjGd7fkl+j4WRlEGMa5Jzho+BhDyEfnqMeXt+g3aHlE1jczClhNN7ZW18eHx8hGFjZW18iXWMjKJjhH57gYuMcIuGWjyMe4ZtjJuExmmMj4WRdntzi4GDhFFzYIRdnGGcjJp7Y0F7e4WEkbCGiX57fnSHa657a6prhBCMe3Z+SmmMjH92eHJ2hK6EY1FzexhrvbKMnI5za4OEfnd+eXuMhImBe897hLaMjN+EfG+BeIOBhF1+eZeJi4GDkXZ2eXKEgZ6Ejpd4c2GHa1V5e5KUfqZuhCx7jKp7lLZrg11+hHx2hFWUoot2nI5zgbh5mo9zvZaUe3qRbqKMfqZ2kbCGhFiM";

// node_modules/@arcgis/core/views/3d/webgl-engine/effects/ssao/SSAOParameters.js
var r6 = class extends c {
  constructor() {
    super(...arguments), this.projScale = 1;
  }
};
var t6 = class extends r6 {
  constructor() {
    super(...arguments), this.intensity = 1;
  }
};
var o6 = class extends c {
};
var c2 = class extends o6 {
  constructor() {
    super(...arguments), this.blurSize = n2();
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/effects/ssao/SSAOTechnique.js
var l4 = class extends m2 {
  constructor(r7, t8) {
    super(r7, t8, new t2(g, () => import("./SSAO.glsl-FVW67SHD.js")), s);
  }
  initializePipeline() {
    return T({ colorWrite: d });
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/effects/ssao/SSAO.js
var g2 = 2;
var j2 = class extends a3 {
  constructor(e10) {
    super(e10), this.consumes = { required: ["normals"] }, this.produces = j.SSAO, this.isEnabled = () => false, this._enableTime = n(0), this._passParameters = new t6(), this._drawParameters = new c2();
  }
  initialize() {
    const e10 = Uint8Array.from(atob(e8), (e11) => e11.charCodeAt(0)), r7 = new h(32);
    r7.wrapMode = 33071, r7.pixelFormat = 6407, r7.wrapMode = 10497, r7.hasMipmap = true, this._passParameters.noiseTexture = new A(this.renderingContext, r7, e10), this.techniques.precompile(l4), this.techniques.precompile(l3), this.addHandles(l(() => this.isEnabled(), () => this._enableTime = n(0)));
  }
  destroy() {
    this._passParameters.noiseTexture = r(this._passParameters.noiseTexture);
  }
  render(e10) {
    const t8 = e10.find(({ name: e11 }) => "normals" === e11), s3 = t8?.getTexture(), o7 = t8?.getTexture(n3);
    if (!s3 || !o7) return;
    const a7 = this.techniques.get(l4), p3 = this.techniques.get(l3);
    if (!a7.compiled || !p3.compiled) return this._enableTime = n(performance.now()), void this.requestRender(1);
    0 === this._enableTime && (this._enableTime = n(performance.now()));
    const l5 = this.renderingContext, d2 = this.view.qualitySettings.fadeDuration, f3 = this.bindParameters, T2 = f3.camera, _ = T2.relativeElevation, j3 = r2((o2 - _) / (o2 - e7), 0, 1), x = d2 > 0 ? Math.min(d2, performance.now() - this._enableTime) / d2 : 1, q = x * j3;
    this._passParameters.normalTexture = s3, this._passParameters.depthTexture = o7, this._passParameters.projScale = 1 / T2.computeScreenPixelSizeAtDist(1), this._passParameters.intensity = 4 * P / v(T2) ** 6 * q;
    const v3 = T2.fullViewport[2], y = T2.fullViewport[3], A2 = this.fboCache.acquire(v3, y, "ssao input", 2);
    l5.bindFramebuffer(A2.fbo), l5.setViewport(0, 0, v3, y), l5.bindTechnique(a7, f3, this._passParameters, this._drawParameters), l5.screen.draw();
    const C = Math.round(v3 / g2), O = Math.round(y / g2), V = this.fboCache.acquire(C, O, "ssao blur", 0);
    l5.bindFramebuffer(V.fbo), this._drawParameters.colorTexture = A2.getTexture(), o(this._drawParameters.blurSize, 0, g2 / y), l5.bindTechnique(p3, f3, this._passParameters, this._drawParameters), l5.setViewport(0, 0, C, O), l5.screen.draw(), A2.release();
    const M = this.fboCache.acquire(C, O, j.SSAO, 0);
    return l5.bindFramebuffer(M.fbo), l5.setViewport(0, 0, v3, y), l5.setClearColor(1, 1, 1, 0), l5.clear(16384), this._drawParameters.colorTexture = V.getTexture(), o(this._drawParameters.blurSize, g2 / v3, 0), l5.bindTechnique(p3, f3, this._passParameters, this._drawParameters), l5.setViewport(0, 0, C, O), l5.screen.draw(), l5.setViewport4fv(T2.fullViewport), V.release(), x < 1 && this.requestRender(2), M;
  }
};
__decorate([m()], j2.prototype, "consumes", void 0), __decorate([m()], j2.prototype, "produces", void 0), __decorate([m({ constructOnly: true })], j2.prototype, "isEnabled", void 0), j2 = __decorate([a("esri.views.3d.webgl-engine.effects.ssao.SSAO")], j2);
var P = 0.5;

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl.js
function t7(t8, o7) {
  o7.receiveAmbientOcclusion ? (t8.uniforms.add(new e4("ssaoTex", (e10) => e10.ssao?.getTexture())), t8.constants.add("blurSizePixelsInverse", "float", 1 / g2), t8.code.add(t`float evaluateAmbientOcclusionInverse() {
vec2 ssaoTextureSizeInverse = 1.0 / vec2(textureSize(ssaoTex, 0));
return texture(ssaoTex, gl_FragCoord.xy * blurSizePixelsInverse * ssaoTextureSizeInverse).r;
}
float evaluateAmbientOcclusion() {
return 1.0 - evaluateAmbientOcclusionInverse();
}`)) : t8.code.add(t`float evaluateAmbientOcclusionInverse() { return 1.0; }
float evaluateAmbientOcclusion() { return 0.0; }`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/BlackLevelLightSoftCompression.glsl.js
function a6(a7) {
  a7.code.add(t`float mapChannel(float x, vec2 p) {
return (x < p.x) ? mix(0.0, p.y, x/p.x) : mix(p.y, 1.0, (x - p.x) / (1.0 - p.x) );
}`), a7.code.add(t`vec3 blackLevelSoftCompression(vec3 color, float averageAmbientRadiance) {
vec2 p = vec2(0.02, 0.0075) * averageAmbientRadiance;
return vec3(mapChannel(color.x, p), mapChannel(color.y, p), mapChannel(color.z, p));
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js
function p2(i) {
  i.constants.add("ambientBoostFactor", "float", l2);
}
function v2(i) {
  i.uniforms.add(new r3("lightingGlobalFactor", (i2) => i2.lighting.globalFactor));
}
function f2(g3, f3) {
  const L = g3.fragment, { pbrMode: b, spherical: C, hasColorTexture: N } = f3;
  L.include(t7, f3), 0 !== b && L.include(n5, f3), g3.include(m3, f3), L.include(t4), L.include(o4, f3);
  const R = !(2 === b && !N);
  switch (R && L.include(a6), L.code.add(t`
    const float GAMMA_SRGB = ${t.float(p)};
    const float INV_GAMMA_SRGB = 0.4761904;
    ${n4(0 !== b, "const float GROUND_REFLECTANCE = 0.2;")}
  `), p2(L), v2(L), t3(L), L.code.add(t`
    float additionalDirectedAmbientLight(vec3 vPosWorld) {
      float vndl = dot(${C ? t`normalize(vPosWorld)` : t`vec3(0.0, 0.0, 1.0)`}, mainLightDirection);
      return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));
    }
  `), a4(L), L.code.add(t`vec3 evaluateAdditionalLighting(float ambientOcclusion, vec3 vPosWorld) {
float additionalAmbientScale = additionalDirectedAmbientLight(vPosWorld);
return (1.0 - ambientOcclusion) * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor * mainLightIntensity;
}`), b) {
    case 0:
    case 4:
    case 3:
      g3.include(o3), L.code.add(t`vec3 evaluateSceneLighting(vec3 normalWorld, vec3 albedo, float shadow, float ssao, vec3 additionalLight) {
vec3 mainLighting = applyShading(normalWorld, shadow);
vec3 ambientLighting = calculateAmbientIrradiance(normalWorld, ssao);
vec3 albedoLinear = pow(albedo, vec3(GAMMA_SRGB));
vec3 totalLight = mainLighting + ambientLighting + additionalLight;
totalLight = min(totalLight, vec3(PI));
vec3 outColor = vec3((albedoLinear / PI) * totalLight);
return pow(outColor, vec3(INV_GAMMA_SRGB));
}`);
      break;
    case 1:
    case 2:
      L.code.add(t`const float fillLightIntensity = 0.25;
const float horizonLightDiffusion = 0.4;
const float additionalAmbientIrradianceFactor = 0.02;
vec3 evaluateSceneLightingPBR(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight,
vec3 viewDir, vec3 groundNormal, vec3 mrr, float additionalAmbientIrradiance) {
vec3 viewDirection = -viewDir;
vec3 h = normalize(viewDirection + mainLightDirection);
PBRShadingInfo inputs;
inputs.NdotV = clamp(abs(dot(normal, viewDirection)), 0.001, 1.0);
inputs.NdotNG = clamp(dot(normal, groundNormal), -1.0, 1.0);
vec3 reflectedView = normalize(reflect(viewDirection, normal));
inputs.RdotNG = clamp(dot(reflectedView, groundNormal), -1.0, 1.0);
inputs.albedoLinear = pow(albedo, vec3(GAMMA_SRGB));
inputs.ssao = ssao;
inputs.metalness = mrr[0];
inputs.roughness = clamp(mrr[1] * mrr[1], 0.001, 0.99);`), L.code.add(t`inputs.f0 = (0.16 * mrr[2] * mrr[2]) * (1.0 - inputs.metalness) + inputs.albedoLinear * inputs.metalness;
inputs.f90 = vec3(clamp(dot(inputs.f0, vec3(50.0 * 0.33)), 0.0, 1.0));
inputs.diffuseColor = inputs.albedoLinear * (vec3(1.0) - inputs.f0) * (1.0 - inputs.metalness);`), f3.useFillLights ? L.uniforms.add(new r5("hasFillLights", (i) => i.enableFillLights)) : L.constants.add("hasFillLights", "bool", false), L.code.add(t`vec3 ambientDir = vec3(5.0 * groundNormal[1] - groundNormal[0] * groundNormal[2], - 5.0 * groundNormal[0] - groundNormal[2] * groundNormal[1], groundNormal[1] * groundNormal[1] + groundNormal[0] * groundNormal[0]);
ambientDir = ambientDir != vec3(0.0) ? normalize(ambientDir) : normalize(vec3(5.0, -1.0, 0.0));
inputs.NdotAmbDir = hasFillLights ? abs(dot(normal, ambientDir)) : 1.0;
float NdotL = clamp(dot(normal, mainLightDirection), 0.001, 1.0);
vec3 mainLightIrradianceComponent = NdotL * (1.0 - shadow) * mainLightIntensity;
vec3 fillLightsIrradianceComponent = inputs.NdotAmbDir * mainLightIntensity * fillLightIntensity;
vec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(normal, ssao) + additionalLight;
inputs.skyIrradianceToSurface = ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;
inputs.groundIrradianceToSurface = GROUND_REFLECTANCE * ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;`), L.uniforms.add(new r3("lightingSpecularStrength", (i) => i.lighting.mainLight.specularStrength), new r3("lightingEnvironmentStrength", (i) => i.lighting.mainLight.environmentStrength)).code.add(t`vec3 horizonRingDir = inputs.RdotNG * groundNormal - reflectedView;
vec3 horizonRingH = normalize(viewDirection + horizonRingDir);
inputs.NdotH_Horizon = dot(normal, horizonRingH);
float NdotH = clamp(dot(normal, h), 0.0, 1.0);
vec3 mainLightRadianceComponent = lightingSpecularStrength * normalDistribution(NdotH, inputs.roughness) * mainLightIntensity * (1.0 - shadow);
vec3 horizonLightRadianceComponent = lightingEnvironmentStrength * normalDistribution(inputs.NdotH_Horizon, min(inputs.roughness + horizonLightDiffusion, 1.0)) * mainLightIntensity * fillLightIntensity;
vec3 ambientLightRadianceComponent = lightingEnvironmentStrength * calculateAmbientRadiance(ssao) + additionalLight;
float normalDirectionModifier = mix(1., min(mix(0.1, 2.0, (inputs.NdotNG + 1.) * 0.5), 1.0), clamp(inputs.roughness * 5.0, 0.0 , 1.0));
inputs.skyRadianceToSurface = (ambientLightRadianceComponent + horizonLightRadianceComponent) * normalDirectionModifier + mainLightRadianceComponent;
inputs.groundRadianceToSurface = 0.5 * GROUND_REFLECTANCE * (ambientLightRadianceComponent + horizonLightRadianceComponent) * normalDirectionModifier + mainLightRadianceComponent;
inputs.averageAmbientRadiance = ambientLightIrradianceComponent[1] * (1.0 + GROUND_REFLECTANCE);`), L.code.add(t`
        vec3 reflectedColorComponent = evaluateEnvironmentIllumination(inputs);
        vec3 additionalMaterialReflectanceComponent = inputs.albedoLinear * additionalAmbientIrradiance;
        vec3 outColorLinear = reflectedColorComponent + additionalMaterialReflectanceComponent;
        ${R ? t`vec3 outColor = pow(blackLevelSoftCompression(outColorLinear, inputs.averageAmbientRadiance), vec3(INV_GAMMA_SRGB));` : t`vec3 outColor = pow(max(vec3(0.0), outColorLinear - 0.005 * inputs.averageAmbientRadiance), vec3(INV_GAMMA_SRGB));`}
        return outColor;
      }
    `);
      break;
    case 5:
    case 6:
      t3(L), a4(L), L.code.add(t`const float roughnessTerrain = 0.5;
const float specularityTerrain = 0.5;
const vec3 fresnelReflectionTerrain = vec3(0.04);
vec3 evaluatePBRSimplifiedLighting(vec3 n, vec3 c, float shadow, float ssao, vec3 al, vec3 vd, vec3 nup) {
vec3 viewDirection = -vd;
vec3 h = normalize(viewDirection + mainLightDirection);
float NdotL = clamp(dot(n, mainLightDirection), 0.001, 1.0);
float NdotV = clamp(abs(dot(n, viewDirection)), 0.001, 1.0);
float NdotH = clamp(dot(n, h), 0.0, 1.0);
float NdotNG = clamp(dot(n, nup), -1.0, 1.0);
vec3 albedoLinear = pow(c, vec3(GAMMA_SRGB));
float lightness = 0.3 * albedoLinear[0] + 0.5 * albedoLinear[1] + 0.2 * albedoLinear[2];
vec3 f0 = (0.85 * lightness + 0.15) * fresnelReflectionTerrain;
vec3 f90 =  vec3(clamp(dot(f0, vec3(50.0 * 0.33)), 0.0, 1.0));
vec3 mainLightIrradianceComponent = (1. - shadow) * NdotL * mainLightIntensity;
vec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(n, ssao) + al;
vec3 ambientSky = ambientLightIrradianceComponent + mainLightIrradianceComponent;
vec3 indirectDiffuse = ((1.0 - NdotNG) * mainLightIrradianceComponent + (1.0 + NdotNG ) * ambientSky) * 0.5;
vec3 outDiffColor = albedoLinear * (1.0 - f0) * indirectDiffuse / PI;
vec3 mainLightRadianceComponent = normalDistribution(NdotH, roughnessTerrain) * mainLightIntensity;
vec2 dfg = prefilteredDFGAnalytical(roughnessTerrain, NdotV);
vec3 specularColor = f0 * dfg.x + f90 * dfg.y;
vec3 specularComponent = specularityTerrain * specularColor * mainLightRadianceComponent;
vec3 outColorLinear = outDiffColor + specularComponent;
vec3 outColor = pow(outColorLinear, vec3(INV_GAMMA_SRGB));
return outColor;
}`);
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js
function n7(u, a7) {
  const i = a7.pbrMode, n8 = u.fragment;
  if (2 !== i && 0 !== i && 1 !== i) return void n8.code.add(t`void applyPBRFactors() {}`);
  if (0 === i) return void n8.code.add(t`void applyPBRFactors() {}
float getBakedOcclusion() { return 1.0; }`);
  if (2 === i) return void n8.code.add(t`vec3 mrr = vec3(0.0, 0.6, 0.2);
float occlusion = 1.0;
void applyPBRFactors() {}
float getBakedOcclusion() { return 1.0; }`);
  const { hasMetallicRoughnessTexture: d2, hasMetallicRoughnessTextureTransform: m4, hasOcclusionTexture: p3, hasOcclusionTextureTransform: f3, bindType: h2 } = a7;
  (d2 || p3) && u.include(r4, a7), n8.code.add(t`vec3 mrr;
float occlusion;`), d2 && n8.uniforms.add(1 === h2 ? new e5("texMetallicRoughness", (e10) => e10.textureMetallicRoughness) : new e6("texMetallicRoughness", (e10) => e10.textureMetallicRoughness)), p3 && n8.uniforms.add(1 === h2 ? new e5("texOcclusion", (e10) => e10.textureOcclusion) : new e6("texOcclusion", (e10) => e10.textureOcclusion)), n8.uniforms.add(1 === h2 ? new e3("mrrFactors", (e10) => e10.mrrFactors) : new e2("mrrFactors", (e10) => e10.mrrFactors)), n8.code.add(t`
    ${n4(d2, t`void applyMetallicRoughness(vec2 uv) {
            vec3 metallicRoughness = textureLookup(texMetallicRoughness, uv).rgb;
            mrr[0] *= metallicRoughness.b;
            mrr[1] *= metallicRoughness.g;
          }`)}

    ${n4(p3, "void applyOcclusion(vec2 uv) { occlusion *= textureLookup(texOcclusion, uv).r; }")}

    float getBakedOcclusion() {
      return ${p3 ? "occlusion" : "1.0"};
    }

    void applyPBRFactors() {
      mrr = mrrFactors;
      occlusion = 1.0;

      ${n4(d2, `applyMetallicRoughness(${m4 ? "metallicRoughnessUV" : "vuv0"});`)}
      ${n4(p3, `applyOcclusion(${f3 ? "occlusionUV" : "vuv0"});`)}
    }
  `);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/effects/weather/SnowCover.glsl.js
function e9(e10, n8) {
  n8.snowCover && (e10.uniforms.add(new r3("snowCover", (o7) => o7.snowCover)).code.add(t`float getSnow(vec3 normal, vec3 groundNormal) {
return smoothstep(0.5, 0.55, dot(normal, groundNormal)) * snowCover;
}
float getRealisticTreeSnow(vec3 faceNormal, vec3 shadingNormal, vec3 groundNormal) {
float snow = min(1.0, smoothstep(0.5, 0.55, dot(faceNormal, groundNormal)) +
smoothstep(0.5, 0.55, dot(-faceNormal, groundNormal)) +
smoothstep(0.0, 0.1, dot(shadingNormal, groundNormal)));
return snow * snowCover;
}`), e10.code.add(t`vec3 applySnowToMRR(vec3 mrr, float snow) {
return mix(mrr, vec3(0.0, 1.0, 0.04), snow);
}`));
}

export {
  n6 as n,
  t5 as t,
  o5 as o,
  s2 as s,
  a5 as a,
  t7 as t2,
  p2 as p,
  v2 as v,
  f2 as f,
  n7 as n2,
  e9 as e
};
//# sourceMappingURL=chunk-T6CRNJ3D.js.map
