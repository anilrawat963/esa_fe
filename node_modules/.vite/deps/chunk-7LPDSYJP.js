import {
  r as r3
} from "./chunk-ALR6N4CF.js";
import {
  y
} from "./chunk-SJ2OBYX2.js";
import {
  R
} from "./chunk-U55FA2EK.js";
import {
  O
} from "./chunk-QNVJVDYZ.js";
import {
  r2
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i
} from "./chunk-QY7XKUIV.js";
import {
  r
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/views/webgl/VertexArrayObject.js
var f = () => i.getLogger("esri.views.webgl.VertexArrayObject");
var h = class t {
  constructor(t2, r4, s, i2) {
    this._context = t2, this._indexBuffer = s, this._buffers = r4 instanceof Map ? r4 : /* @__PURE__ */ new Map([["geometry", r4]]), this._baseInstances = null == i2 ? /* @__PURE__ */ new Map() : "number" == typeof i2 ? /* @__PURE__ */ new Map([["geometry", i2]]) : i2, this.locations = r(r3(this._buffers));
  }
  get glName() {
    return this._glName;
  }
  get context() {
    return this._context;
  }
  get buffers() {
    return r(this._buffers);
  }
  buffer(e = "geometry") {
    return this.buffers.get(e);
  }
  get indexBuffer() {
    return this._indexBuffer;
  }
  getByteLength(e) {
    return this.buffer(e)?.sizeBytes ?? 0;
  }
  vertexCount(e) {
    const t2 = this.buffer(e);
    return t2 ? t2.sizeBytes / t2.layout[0].stride : 0;
  }
  get usedMemory() {
    return Array.from(this._buffers.values()).reduce((e, t2) => e + t2.usedMemory, this._indexBuffer?.usedMemory ?? 0 + (this._buffers.size + (this._indexBuffer ? 1 : 0)) * y);
  }
  dispose() {
    this._context ? (this._buffers.forEach((e) => e.dispose()), this._buffers.clear(), this._indexBuffer = r2(this._indexBuffer), this.disposeVAOOnly()) : (this._glName || this._buffers.size > 0) && f().warn("Leaked WebGL VAO");
  }
  disposeVAOOnly() {
    this._context ? (this._context.getBoundVAO() === this && this._context.bindVAO(null), this._glName && (this._context.gl.deleteVertexArray(this._glName), this._glName = null, this._context.instanceCounter.decrement(O.VertexArrayObject, this)), this._context = null) : this._glName && f().warn("Leaked WebGL VAO");
  }
  bind(e = this.locations) {
    const t2 = this._context.gl;
    this._glName ? t2.bindVertexArray(this._glName) : (this._context.instanceCounter.increment(O.VertexArrayObject, this), this._glName = t2.createVertexArray(), t2.bindVertexArray(this._glName), this._bindLayout(e));
  }
  _bindLayout(e) {
    const { _buffers: t2, _indexBuffer: r4 } = this;
    if (t2 || f().error("Vertex buffer dictionary is empty!"), t2.forEach((t3, r5) => R(this._context, e, t3, this._baseInstances.get(r5) ?? 0)), null != r4) {
      const e2 = this._context.gl;
      this._context.gl.bindBuffer(e2.ELEMENT_ARRAY_BUFFER, r4.glName);
    }
  }
  unbind() {
    this._context.gl.bindVertexArray(null);
  }
  shallowCloneWithBaseInstances(e) {
    return new t(this._context, this._buffers, this._indexBuffer, e);
  }
};

export {
  h
};
//# sourceMappingURL=chunk-7LPDSYJP.js.map
