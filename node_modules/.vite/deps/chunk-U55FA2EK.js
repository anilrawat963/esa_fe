import {
  E,
  G,
  N,
  O,
  S,
  T,
  Y
} from "./chunk-QNVJVDYZ.js";
import {
  d,
  e2 as e,
  s as s2
} from "./chunk-GNMPGHLQ.js";
import {
  i3 as i,
  l2 as l,
  s2 as s
} from "./chunk-QY7XKUIV.js";
import {
  has
} from "./chunk-AL6YUTZM.js";

// node_modules/@arcgis/core/views/webgl/checkWebGLError.js
var n = () => i.getLogger("esri.views.webgl.checkWebGLError");
function t(e2) {
  switch (e2.getError()) {
    case e2.NO_ERROR:
      return null;
    case e2.INVALID_ENUM:
      return "Invalid Enum. An unacceptable value has been specified for an enumerated argument.";
    case e2.INVALID_VALUE:
      return "Invalid Value. A numeric argument is out of range.";
    case e2.INVALID_OPERATION:
      return "Invalid Operation. The specified command is not allowed for the current state.";
    case e2.INVALID_FRAMEBUFFER_OPERATION:
      return "Invalid Framebuffer operation. The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.";
    case e2.OUT_OF_MEMORY:
      return "Out of memory. Not enough memory is left to execute the command.";
    case e2.CONTEXT_LOST_WEBGL:
      return "WebGL context has been lost";
    default:
      return "Unknown error";
  }
}
var o = !!has("enable-feature:webgl-debug");
function a() {
  return o;
}
function c() {
  return o;
}
function u(r, o2 = a()) {
  if (o2) {
    const o3 = t(r);
    if (o3) {
      const r2 = new Error().stack;
      n().error(new s("webgl-error", "WebGL error occurred", { message: o3, stack: r2 }));
    }
  }
}

// node_modules/@arcgis/core/views/webgl/Util.js
function R(c3, a2, r, t3 = 0) {
  const R2 = c3.gl;
  c3.bindBuffer(r);
  for (const n3 of r.layout) {
    const r2 = a2.get(n3.name);
    if (null == r2) {
      console.warn(`There is no location for vertex attribute '${n3.name}' defined.`);
      continue;
    }
    const _2 = t3 * n3.stride;
    if (n3.count <= 4) R2.vertexAttribPointer(r2, n3.count, n3.type, n3.normalized, n3.stride, n3.offset + _2), R2.enableVertexAttribArray(r2), n3.divisor > 0 && R2.vertexAttribDivisor(r2, n3.divisor);
    else if (9 === n3.count) for (let e2 = 0; e2 < 3; e2++) R2.vertexAttribPointer(r2 + e2, 3, n3.type, n3.normalized, n3.stride, n3.offset + 12 * e2 + _2), R2.enableVertexAttribArray(r2 + e2), n3.divisor > 0 && R2.vertexAttribDivisor(r2 + e2, n3.divisor);
    else if (16 === n3.count) for (let e2 = 0; e2 < 4; e2++) R2.vertexAttribPointer(r2 + e2, 4, n3.type, n3.normalized, n3.stride, n3.offset + 16 * e2 + _2), R2.enableVertexAttribArray(r2 + e2), n3.divisor > 0 && R2.vertexAttribDivisor(r2 + e2, n3.divisor);
    else console.error("Unsupported vertex attribute element count: " + n3.count);
    if (a()) {
      const e2 = t(c3.gl);
      e2 && console.error(`Unable to bind vertex attribute "${n3.name}" with baseInstanceOffset ${_2}:`, e2, n3);
    }
  }
}
function n2(e2) {
  switch (e2) {
    case 6406:
    case 6409:
    case 6403:
    case 36244:
    case 6402:
    case 34041:
      return 1;
    case 6410:
    case 33319:
    case 33320:
      return 2;
    case 6407:
    case 36248:
      return 3;
    case 6408:
    case 36249:
      return 4;
  }
  return 0;
}
function _(e2) {
  switch (e2) {
    case 6406:
    case 6409:
    case 6403:
    case 36244:
    case E.R8:
    case E.R8I:
    case E.R8UI:
    case E.R8_SNORM:
    case 36168:
      return 1;
    case 6410:
    case 33319:
    case 33320:
    case E.RGBA4:
    case E.R16F:
    case E.R16I:
    case E.R16UI:
    case E.RG8:
    case E.RG8I:
    case E.RG8UI:
    case E.RG8_SNORM:
    case E.RGB565:
    case E.RGB5_A1:
    case T.DEPTH_COMPONENT16:
      return 2;
    case 6407:
    case 36248:
    case E.RGB8:
    case E.RGB8I:
    case E.RGB8UI:
    case E.RGB8_SNORM:
    case E.SRGB8:
    case T.DEPTH_COMPONENT24:
      return 3;
    case 6408:
    case 36249:
    case E.RGBA8:
    case E.R32F:
    case E.R11F_G11F_B10F:
    case E.RG16F:
    case E.R32I:
    case E.R32UI:
    case E.RG16I:
    case E.RG16UI:
    case E.RGBA8I:
    case E.RGBA8UI:
    case E.RGBA8_SNORM:
    case E.SRGB8_ALPHA8:
    case E.RGB9_E5:
    case E.RGB10_A2UI:
    case E.RGB10_A2:
    case T.DEPTH_COMPONENT32F:
    case G.DEPTH24_STENCIL8:
      return 4;
    case G.DEPTH32F_STENCIL8:
      return 5;
    case E.RGB16F:
    case E.RGB16I:
    case E.RGB16UI:
      return 6;
    case E.RG32F:
    case E.RG32I:
    case E.RG32UI:
    case E.RGBA16F:
    case E.RGBA16I:
    case E.RGBA16UI:
      return 8;
    case E.RGB32F:
    case E.RGB32I:
    case E.RGB32UI:
      return 12;
    case E.RGBA32F:
    case E.RGBA32I:
    case E.RGBA32UI:
      return 16;
    case Y.COMPRESSED_RGB_S3TC_DXT1_EXT:
    case Y.COMPRESSED_RGBA_S3TC_DXT1_EXT:
      return 0.5;
    case Y.COMPRESSED_RGBA_S3TC_DXT3_EXT:
    case Y.COMPRESSED_RGBA_S3TC_DXT5_EXT:
      return 1;
    case Y.COMPRESSED_R11_EAC:
    case Y.COMPRESSED_SIGNED_R11_EAC:
    case Y.COMPRESSED_RGB8_ETC2:
    case Y.COMPRESSED_SRGB8_ETC2:
    case Y.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
    case Y.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:
      return 0.5;
    case Y.COMPRESSED_RG11_EAC:
    case Y.COMPRESSED_SIGNED_RG11_EAC:
    case Y.COMPRESSED_RGBA8_ETC2_EAC:
    case Y.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:
      return 1;
  }
  return 0;
}

// node_modules/@arcgis/core/views/webgl/TextureDescriptor.js
var h = class {
  constructor(i2 = 0, h3 = i2) {
    this.width = i2, this.height = h3, this.type = 0, this.target = 3553, this.pixelFormat = 6408, this.dataType = N.UNSIGNED_BYTE, this.samplingMode = 9729, this.wrapMode = 10497, this.maxAnisotropy = 1, this.flipped = false, this.hasMipmap = false, this.isOpaque = false, this.unpackAlignment = 4, this.preMultiplyAlpha = false, this.compareEnabled = false, this.linearFilterDepth = false, this.depth = 1, this.isImmutable = false;
  }
};
function s3(t3) {
  return t3.width <= 0 || t3.height <= 0 || t3.depth <= 0 ? 0 : Math.round(t3.width * t3.height * t3.depth * (t3.hasMipmap ? 4 / 3 : 1) * (null == t3.internalFormat ? 4 : _(t3.internalFormat)) * (34067 === t3.target ? 6 : 1));
}

// node_modules/@arcgis/core/views/webgl/textureUtils.js
var c2 = () => i.getLogger("esri/views/webgl/textureUtils");
function s4(t3) {
  const { width: e2, height: r, depth: n3 } = t3;
  (null != e2 && e2 < 0 || null != r && r < 0 || null != n3 && n3 < 0) && c2().error("Negative dimension parameters are not allowed!");
  const { internalFormat: o2 } = t3;
  if (o2 && (m(o2) || p(o2))) {
    const { linearFilterDepth: e3, compareEnabled: r2, samplingMode: n4, hasMipmap: o3 } = t3;
    o3 && c2().error("Depth textures cannot have mipmaps"), e3 ? 9729 !== n4 && 9728 !== n4 && c2().error("Depth textures cannot sample mipmaps") : (9728 !== n4 && c2().error("Depth textures without filtering must use NEAREST filtering"), r2 && c2().error("Depth textures without filtering cannot use compare function"));
  }
}
function h2(t3) {
  return S.includes(t3);
}
function m(t3) {
  return l(T, t3);
}
function p(t3) {
  return l(G, t3);
}
function f(t3) {
  return null != t3 && l(Y, t3);
}
function d2(t3) {
  return null != t3 && "type" in t3 && "compressed" === t3.type;
}
function g(t3) {
  return null != t3 && "byteLength" in t3;
}
function w(t3) {
  return null != t3 && !d2(t3) && !g(t3);
}
function x(t3) {
  return 32879 === t3 || 35866 === t3;
}
function F(t3, e2, r, n3 = 1) {
  let o2 = Math.max(e2, r);
  return 32879 === t3 && (o2 = Math.max(o2, n3)), Math.floor(Math.log2(o2)) + 1;
}
function E2(e2) {
  if (null != e2.internalFormat) return e2.internalFormat;
  switch (e2.dataType) {
    case N.FLOAT:
      switch (e2.pixelFormat) {
        case 6408:
          return E.RGBA32F;
        case 6407:
          return E.RGB32F;
        default:
          throw new s("texture:unknown-format", "Unable to derive format");
      }
    case N.UNSIGNED_BYTE:
      switch (e2.pixelFormat) {
        case 6408:
          return E.RGBA8;
        case 6407:
          return E.RGB8;
      }
  }
  const { pixelFormat: r } = e2;
  return e2.internalFormat = 34041 === r ? G.DEPTH24_STENCIL8 : 6402 === r ? T.DEPTH_COMPONENT24 : r, e2.internalFormat;
}
function T2(t3) {
  let e2 = "width" in t3 ? t3.width : t3.codedWidth, r = "height" in t3 ? t3.height : t3.codedHeight;
  const n3 = 1;
  return t3 instanceof HTMLVideoElement && (e2 = t3.videoWidth, r = t3.videoHeight), { width: e2, height: r, depth: n3 };
}

// node_modules/@arcgis/core/views/webgl/ValidatedTextureDescriptor.js
var t2 = class _t extends h {
  constructor(e2, t3) {
    switch (super(), this.context = e2, Object.assign(this, t3), this.internalFormat) {
      case E.R16F:
      case E.R32F:
      case E.R8_SNORM:
      case E.R8:
        this.pixelFormat = 6403;
        break;
      case E.R8I:
      case E.R8UI:
      case E.R16I:
      case E.R16UI:
      case E.R32I:
      case E.R32UI:
        this.pixelFormat = 36244;
    }
  }
  static validate(s5, e2) {
    return new _t(s5, e2);
  }
};

// node_modules/@arcgis/core/views/webgl/Texture.js
var D = !!has("esri-tests-disable-gpu-memory-measurements");
var E3 = () => i.getLogger("esri/views/webgl/Texture");
var _a;
var A = (_a = class {
  constructor(e2, i2 = null, r = null) {
    if (this.type = 1, this._glName = null, this._samplingModeDirty = false, this._wrapModeDirty = false, this._shadowFilterDirty = false, this._wasImmutablyAllocated = false, "context" in e2) this._descriptor = e2, r = i2;
    else {
      const r2 = t2.validate(e2, i2);
      if (!r2) throw new s("texture:invalid-descriptor", "Texture descriptor invalid");
      this._descriptor = r2;
    }
    34067 === this._descriptor.target ? this._setDataCubeMap(r) : this.setData(r);
  }
  get glName() {
    return this._glName;
  }
  get descriptor() {
    return this._descriptor;
  }
  get usedMemory() {
    return D ? 0 : s3(this._descriptor);
  }
  get isDirty() {
    return this._samplingModeDirty || this._wrapModeDirty || this._shadowFilterDirty;
  }
  get hasWebGLTextureObject() {
    return !!this._glName;
  }
  dispose() {
    this.abortCompression(), this.hasWebGLTextureObject && this._descriptor.context?.gl && (this._descriptor.context.instanceCounter.decrement(O.Texture, this), this._descriptor.context.unbindTexture(this), this._descriptor.context.gl.deleteTexture(this._glName), this._glName = null, this._descriptor = null);
  }
  release() {
    this.dispose();
  }
  [Symbol.dispose]() {
    this.dispose();
  }
  resize(e2, i2) {
    const r = this._descriptor;
    if (r.width !== e2 || r.height !== i2) {
      if (this._wasImmutablyAllocated) throw new s("texture:immutable-resize", "Immutable textures can't be resized!");
      r.width = e2, r.height = i2, 34067 === this._descriptor.target ? this._setDataCubeMap(null) : this.setData(null);
    }
  }
  enableCompression(t3) {
    this._descriptor.compress = t3;
  }
  disableCompression() {
    this._descriptor.compress = void 0;
  }
  setData(t3) {
    this.abortCompression(), !d2(t3) && this._descriptor.internalFormat && l(Y, this._descriptor.internalFormat) && (this._descriptor.internalFormat = void 0), this._setData(t3), !d2(t3) && this._descriptor.compress && this._compressOnWorker(t3);
  }
  updateData(i2, r, s5, o2, a2, n3, p2 = 0) {
    n3 || E3().error("An attempt to use uninitialized data!"), this.hasWebGLTextureObject || E3().error("An attempt to update uninitialized texture!");
    const l2 = this._descriptor;
    l2.internalFormat = E2(l2);
    const { context: c3, pixelFormat: _2, dataType: u2, target: g2, isImmutable: x2 } = l2;
    if (x2 && !this._wasImmutablyAllocated) throw new s("texture:uninitialized", "Cannot update immutable texture before allocation!");
    const T3 = c3.bindTexture(this, _a.TEXTURE_UNIT_FOR_UPDATES, true);
    (r < 0 || s5 < 0 || r + o2 > l2.width || s5 + a2 > l2.height) && E3().error("An attempt to update out of bounds of the texture!"), this._configurePixelStorage();
    const { gl: M } = c3;
    p2 && (o2 && a2 || E3().warn("Must pass width and height if `UNPACK_SKIP_ROWS` is used"), M.pixelStorei(M.UNPACK_SKIP_ROWS, p2)), w(n3) ? M.texSubImage2D(g2, i2, r, s5, o2, a2, _2, u2, n3) : d2(n3) ? M.compressedTexSubImage2D(g2, i2, r, s5, o2, a2, l2.internalFormat, n3.levels[i2]) : M.texSubImage2D(g2, i2, r, s5, o2, a2, _2, u2, n3), p2 && M.pixelStorei(M.UNPACK_SKIP_ROWS, 0), c3.bindTexture(T3, _a.TEXTURE_UNIT_FOR_UPDATES);
  }
  updateData3D(i2, r, s5, o2, a2, n3, p2, l2) {
    l2 || E3().error("An attempt to use uninitialized data!"), this.hasWebGLTextureObject || E3().error("An attempt to update an uninitialized texture!");
    const d3 = this._descriptor;
    d3.internalFormat = E2(d3);
    const { context: _2, pixelFormat: u2, dataType: g2, isImmutable: x2, target: T3 } = d3;
    if (x2 && !this._wasImmutablyAllocated) throw new s("texture:uninitialized", "Cannot update immutable texture before allocation!");
    x(T3) || E3().warn("Attempting to set 3D texture data on a non-3D texture");
    const M = _2.bindTexture(this, _a.TEXTURE_UNIT_FOR_UPDATES);
    _2.setActiveTexture(_a.TEXTURE_UNIT_FOR_UPDATES), (r < 0 || s5 < 0 || o2 < 0 || r + a2 > d3.width || s5 + n3 > d3.height || o2 + p2 > d3.depth) && E3().error("An attempt to update out of bounds of the texture!"), this._configurePixelStorage();
    const { gl: b } = _2;
    if (d2(l2)) l2 = l2.levels[i2], b.compressedTexSubImage3D(T3, i2, r, s5, o2, a2, n3, p2, d3.internalFormat, l2);
    else {
      const t3 = l2;
      b.texSubImage3D(T3, i2, r, s5, o2, a2, n3, p2, u2, g2, t3);
    }
    _2.bindTexture(M, _a.TEXTURE_UNIT_FOR_UPDATES);
  }
  generateMipmap() {
    const i2 = this._descriptor;
    if (0 === i2.width || 0 === i2.height) return;
    if (!i2.hasMipmap) {
      if (this._wasImmutablyAllocated) throw new s("texture:immutable-change", "Cannot add mipmaps to immutable texture after allocation");
      i2.hasMipmap = true, this._samplingModeDirty = true, s4(i2);
    }
    9729 === i2.samplingMode ? (this._samplingModeDirty = true, i2.samplingMode = 9985) : 9728 === i2.samplingMode && (this._samplingModeDirty = true, i2.samplingMode = 9984);
    const r = this._descriptor.context.bindTexture(this, _a.TEXTURE_UNIT_FOR_UPDATES);
    this._descriptor.context.setActiveTexture(_a.TEXTURE_UNIT_FOR_UPDATES), this._descriptor.context.gl.generateMipmap(i2.target), this._descriptor.context.bindTexture(r, _a.TEXTURE_UNIT_FOR_UPDATES);
  }
  clearMipmap() {
    const e2 = this._descriptor;
    if (e2.hasMipmap) {
      if (this._wasImmutablyAllocated) throw new s("texture:immutable-change", "Cannot delete mipmaps to immutable texture after allocation");
      e2.hasMipmap = false, this._samplingModeDirty = true, s4(e2);
    }
    9985 === e2.samplingMode ? (this._samplingModeDirty = true, e2.samplingMode = 9729) : 9984 === e2.samplingMode && (this._samplingModeDirty = true, e2.samplingMode = 9728);
  }
  setSamplingMode(t3) {
    t3 !== this._descriptor.samplingMode && (this._descriptor.samplingMode = t3, this._samplingModeDirty = true);
  }
  setWrapMode(t3) {
    t3 !== this._descriptor.wrapMode && (this._descriptor.wrapMode = t3, s4(this._descriptor), this._wrapModeDirty = true);
  }
  setShadowFiltering(t3) {
    t3 !== this._descriptor.linearFilterDepth && (this._descriptor.linearFilterDepth = this._descriptor.compareEnabled = t3, this.setSamplingMode(t3 ? 9729 : 9728), s4(this._descriptor), this._shadowFilterDirty = true);
  }
  applyChanges() {
    this._samplingModeDirty && (this._applySamplingMode(), this._samplingModeDirty = false), this._wrapModeDirty && (this._applyWrapMode(), this._wrapModeDirty = false), this._shadowFilterDirty && (this._applyShadowMode(), this._shadowFilterDirty = false);
  }
  abortCompression() {
    this._compressionAbortController = e(this._compressionAbortController);
  }
  _setData(i2, r) {
    const s5 = this._descriptor, o2 = s5.context?.gl;
    if (!o2) return;
    u(o2), this.hasWebGLTextureObject || (this._glName = o2.createTexture(), s5.context.instanceCounter.increment(O.Texture, this)), s4(s5);
    const p2 = s5.context.bindTexture(this, _a.TEXTURE_UNIT_FOR_UPDATES);
    s5.context.setActiveTexture(_a.TEXTURE_UNIT_FOR_UPDATES), this._configurePixelStorage(), u(o2);
    const l2 = r ?? s5.target, g2 = x(l2);
    if (w(i2)) this._setDataFromTexImageSource(i2, l2);
    else {
      const { width: e2, height: r2, depth: n3 } = s5;
      if (null == e2 || null == r2) throw new s("texture:missing-size", "Width and height must be specified!");
      if (g2 && null == n3) throw new s("texture:missing-depth", "Depth must be specified!");
      if (s5.internalFormat = E2(s5), s5.isImmutable && !this._wasImmutablyAllocated && this._texStorage(l2, s5.internalFormat, s5.hasMipmap, e2, r2, n3), d2(i2)) {
        if (!f(s5.internalFormat)) throw new s("texture:format-mismatch", "Attempting to use compressed data with an uncompressed format!");
        this._setDataFromCompressedSource(i2, s5.internalFormat, l2);
      } else this._texImage(l2, 0, s5.internalFormat, e2, r2, n3, i2), u(o2), s5.hasMipmap && this.generateMipmap();
    }
    this._applySamplingMode(), this._applyWrapMode(), this._applyAnisotropicFilteringParameters(), this._applyShadowMode(), u(o2), s5.context.bindTexture(p2, _a.TEXTURE_UNIT_FOR_UPDATES);
  }
  _setDataCubeMap(t3 = null) {
    for (let e2 = 34069; e2 <= 34074; e2++) this._setData(t3, e2);
  }
  _configurePixelStorage() {
    const t3 = this._descriptor.context.gl, { unpackAlignment: e2, flipped: i2, preMultiplyAlpha: r } = this._descriptor;
    t3.pixelStorei(t3.UNPACK_ALIGNMENT, e2), t3.pixelStorei(t3.UNPACK_FLIP_Y_WEBGL, i2 ? 1 : 0), t3.pixelStorei(t3.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r ? 1 : 0);
  }
  _setDataFromTexImageSource(t3, e2) {
    const { gl: i2 } = this._descriptor.context, r = this._descriptor;
    r.internalFormat = E2(r);
    const s5 = x(e2), { width: o2, height: n3, depth: p2 } = T2(t3);
    r.width && r.height, r.width || (r.width = o2), r.height || (r.height = n3), s5 && r.depth, s5 && (r.depth = p2), r.isImmutable && !this._wasImmutablyAllocated && this._texStorage(e2, r.internalFormat, r.hasMipmap, o2, n3, p2), this._texImage(e2, 0, r.internalFormat, o2, n3, p2, t3), u(i2), r.hasMipmap && (this.generateMipmap(), u(i2));
  }
  _setDataFromCompressedSource(t3, e2, i2) {
    const r = this._descriptor, { width: s5, height: o2, depth: a2 } = r, n3 = t3.levels, p2 = F(i2, s5, o2, a2), l2 = Math.min(p2, n3.length) - 1;
    this._descriptor.context.gl.texParameteri(r.target, 33085, l2), this._forEachMipmapLevel((t4, r2, s6, o3) => {
      const a3 = n3[Math.min(t4, n3.length - 1)];
      this._compressedTexImage(i2, t4, e2, r2, s6, o3, a3);
    }, l2);
  }
  _texStorage(e2, i2, r, s5, o2, a2) {
    const { gl: n3 } = this._descriptor.context;
    if (!h2(i2) && !m(i2) && !p(i2)) throw new s("texture:missing-format", "Immutable textures must have a sized internal format");
    if (!this._descriptor.isImmutable) return;
    const p2 = r ? F(e2, s5, o2, a2) : 1;
    if (x(e2)) {
      if (null == a2) throw new s("texture:missing-depth", "Missing depth dimension for 3D texture upload");
      n3.texStorage3D(e2, p2, i2, s5, o2, a2);
    } else n3.texStorage2D(e2, p2, i2, s5, o2);
    this._wasImmutablyAllocated = true;
  }
  _texImage(e2, i2, r, s5, o2, a2, n3) {
    const p2 = this._descriptor.context.gl, l2 = x(e2), { isImmutable: m2, pixelFormat: h3, dataType: d3 } = this._descriptor;
    if (m2) {
      if (null != n3) {
        const r2 = n3;
        if (l2) {
          if (null == a2) throw new s("texture:missing-depth", "Missing depth dimension for 3D texture upload");
          p2.texSubImage3D(e2, i2, 0, 0, 0, s5, o2, a2, h3, d3, r2);
        } else p2.texSubImage2D(e2, i2, 0, 0, s5, o2, h3, d3, r2);
      }
    } else {
      const m3 = n3;
      if (l2) {
        if (null == a2) throw new s("texture:missing-depth", "Missing depth dimension for 3D texture upload");
        p2.texImage3D(e2, i2, r, s5, o2, a2, 0, h3, d3, m3);
      } else p2.texImage2D(e2, i2, r, s5, o2, 0, h3, d3, m3);
    }
  }
  _compressedTexImage(e2, i2, r, s5, o2, a2, n3) {
    const p2 = this._descriptor.context.gl, l2 = x(e2);
    if (this._descriptor.isImmutable) {
      if (null != n3) if (l2) {
        if (null == a2) throw new s("texture:missing-depth", "Missing depth dimension for 3D texture upload");
        p2.compressedTexSubImage3D(e2, i2, 0, 0, 0, s5, o2, a2, r, n3);
      } else p2.compressedTexSubImage2D(e2, i2, 0, 0, s5, o2, r, n3);
    } else if (l2) {
      if (null == a2) throw new s("texture:missing-depth", "Missing depth dimension for 3D texture upload");
      p2.compressedTexImage3D(e2, i2, r, s5, o2, a2, 0, n3);
    } else p2.compressedTexImage2D(e2, i2, r, s5, o2, 0, n3);
  }
  async _compressOnWorker(t3) {
    const { width: i2, height: r, context: a2, flipped: n3, preMultiplyAlpha: p2, hasMipmap: l2 } = this._descriptor, m2 = this._descriptor.compress?.compressionTracker, h3 = this._descriptor.compress?.compressionCallback, { compressedTextureETC: d3, compressedTextureS3TC: c3 } = a2.capabilities;
    if (!_a.compressionWorkerHandle?.isCompressible(t3, this._descriptor) || !d3 && !c3) return;
    this.abortCompression();
    const _2 = new AbortController();
    let u2;
    this._compressionAbortController = _2, m2?.increment();
    try {
      t3 instanceof Uint8Array ? u2 = t3.buffer : (u2 = await createImageBitmap(t3, { imageOrientation: n3 ? "flipY" : "none" }), s2(_2));
      const o2 = { data: u2, width: i2, height: r, needsFlip: t3 instanceof Uint8Array && this.descriptor.flipped, components: 6408 === this._descriptor.pixelFormat ? 4 : 3, preMultiplyAlpha: p2, hasMipmap: l2, hasETC: !!d3, hasS3TC: !!c3 }, a3 = await _a.compressionWorkerHandle.invoke(o2, _2.signal, "low");
      if (s2(_2), a3.compressedTexture && this.hasWebGLTextureObject) {
        const t4 = this.usedMemory;
        this._descriptor.internalFormat = a3.internalFormat, this._setData(a3.compressedTexture), h3?.(t4 - this.usedMemory);
      }
    } catch (g2) {
      d(g2) || E3().error("Texture compression failed!");
    } finally {
      m2?.decrement(), this._compressionAbortController?.signal.aborted && (this._compressionAbortController = null), u2 instanceof ImageBitmap && u2.close();
    }
  }
  _forEachMipmapLevel(e2, i2 = 1 / 0) {
    let { width: r, height: s5, depth: o2, hasMipmap: a2, target: n3 } = this._descriptor;
    const p2 = 32879 === n3;
    if (null == r || null == s5 || p2 && null == o2) throw new s("texture:missing-size", "Missing texture dimensions for mipmap calculation");
    for (let t3 = 0; e2(t3, r, s5, o2), a2 && (1 !== r || 1 !== s5 || p2 && 1 !== o2) && !(t3 >= i2); ++t3) r = Math.max(1, r >> 1), s5 = Math.max(1, s5 >> 1), p2 && (o2 = Math.max(1, o2 >> 1));
  }
  _applySamplingMode() {
    const t3 = this._descriptor, e2 = t3.context?.gl;
    let i2 = t3.samplingMode, r = t3.samplingMode;
    9985 === i2 || 9987 === i2 ? (i2 = 9729, t3.hasMipmap || (r = 9729)) : 9984 !== i2 && 9986 !== i2 || (i2 = 9728, t3.hasMipmap || (r = 9728)), e2.texParameteri(t3.target, e2.TEXTURE_MAG_FILTER, i2), e2.texParameteri(t3.target, e2.TEXTURE_MIN_FILTER, r);
  }
  _applyWrapMode() {
    const t3 = this._descriptor, e2 = t3.context?.gl;
    "number" == typeof t3.wrapMode ? (e2.texParameteri(t3.target, e2.TEXTURE_WRAP_S, t3.wrapMode), e2.texParameteri(t3.target, e2.TEXTURE_WRAP_T, t3.wrapMode)) : (e2.texParameteri(t3.target, e2.TEXTURE_WRAP_S, t3.wrapMode.s), e2.texParameteri(t3.target, e2.TEXTURE_WRAP_T, t3.wrapMode.t));
  }
  _applyShadowMode() {
    const t3 = this._descriptor, e2 = t3.context?.gl, i2 = t3.compareEnabled ? e2.COMPARE_REF_TO_TEXTURE : e2.NONE;
    e2.texParameteri(t3.target, e2.TEXTURE_COMPARE_MODE, i2), t3.compareEnabled && e2.texParameteri(t3.target, e2.TEXTURE_COMPARE_FUNC, e2.GREATER), u(e2);
  }
  _applyAnisotropicFilteringParameters() {
    const t3 = this._descriptor, e2 = t3.context.capabilities.textureFilterAnisotropic;
    if (!e2) return;
    t3.context.gl.texParameterf(t3.target, e2.TEXTURE_MAX_ANISOTROPY, t3.maxAnisotropy ?? 1);
  }
}, _a.TEXTURE_UNIT_FOR_UPDATES = 0, _a.compressionWorkerHandle = null, _a);

export {
  t,
  a,
  c,
  u,
  R,
  n2 as n,
  _,
  h,
  t2,
  A
};
//# sourceMappingURL=chunk-U55FA2EK.js.map
