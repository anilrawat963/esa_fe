import {
  c
} from "./chunk-XMUWUWWP.js";
import {
  I,
  N,
  P,
  b,
  p
} from "./chunk-SMJWJAIA.js";
import {
  C,
  U,
  q
} from "./chunk-XTEXJOLG.js";
import {
  n,
  t as t2
} from "./chunk-ALR6N4CF.js";
import {
  t
} from "./chunk-4X4BOGIG.js";
import {
  e as e2
} from "./chunk-SHPBZTDJ.js";
import {
  T
} from "./chunk-JE2NJSBU.js";
import {
  R
} from "./chunk-QNVJVDYZ.js";
import {
  e
} from "./chunk-FPMLKIDB.js";
import {
  u
} from "./chunk-CCQFL76O.js";
import {
  d
} from "./chunk-GY6YF4EN.js";
import {
  a
} from "./chunk-QY7XKUIV.js";

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/MemoryBuffer.js
var t3 = class {
  constructor(t6) {
    this._array = [], this._stride = t6;
  }
  get array() {
    return this._array;
  }
  get index() {
    return 4 * this._array.length / this._stride;
  }
  get itemSize() {
    return this._stride;
  }
  get sizeInBytes() {
    return 4 * this._array.length;
  }
  reset() {
    this.array.length = 0;
  }
  toBuffer() {
    return new Uint32Array(this._array).buffer;
  }
  static i1616to32(t6, r3) {
    return 65535 & t6 | r3 << 16;
  }
  static i8888to32(t6, r3, e6, i4) {
    return 255 & t6 | (255 & r3) << 8 | (255 & e6) << 16 | i4 << 24;
  }
  static i8816to32(t6, r3, e6) {
    return 255 & t6 | (255 & r3) << 8 | e6 << 16;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/VTLMaterial.js
var _s = class _s {
  constructor(t6) {
    this._key = t6;
  }
  get key() {
    return this._key;
  }
  get type() {
    return 7 & this._key;
  }
  defines() {
    return [];
  }
  getStride() {
    return this._geometryLayout || this._buildAttributesInfo(), this._stride;
  }
  getAttributeLocations() {
    return this._geometryLayout || this._buildAttributesInfo(), this._locations;
  }
  get geometryLayout() {
    return this._geometryLayout || this._buildAttributesInfo(), this._geometryLayout;
  }
  getEncodingInfos() {
    return this._propertyEncodingInfo || this._buildAttributesInfo(), this._propertyEncodingInfo;
  }
  getUniforms() {
    return this._uniforms || this._buildAttributesInfo(), this._uniforms;
  }
  getShaderHeader() {
    return this._shaderHeader || this._buildAttributesInfo(), this._shaderHeader;
  }
  getShaderMain() {
    return this._shaderMain || this._buildAttributesInfo(), this._shaderMain;
  }
  setDataUniforms(t6, e6, o2, n2, r3) {
    const s2 = this.getUniforms();
    for (const a6 of s2) {
      const { name: s3, type: i4, getValue: c5 } = a6, u3 = c5(o2, e6, n2, r3);
      if (null !== u3) switch (i4) {
        case "float":
          t6.setUniform1f(s3, u3);
          break;
        case "vec2":
          t6.setUniform2fv(s3, u3);
          break;
        case "vec4":
          t6.setUniform4fv(s3, u3);
      }
    }
  }
  encodeAttributes(t6, e6, o2, n2) {
    const r3 = this.attributesInfo, s2 = this.getEncodingInfos(), a6 = [];
    let i4 = 0, c5 = 0;
    for (const u3 of Object.keys(s2)) {
      const h2 = s2[u3], { type: d5, precisionFactor: f2, isLayout: l3 } = r3[u3], y3 = l3 ? o2.getLayoutProperty(u3) : o2.getPaintProperty(u3), _3 = y3.interpolator?.getInterpolationRange(e6);
      let m2 = 0;
      for (const o3 of h2) {
        const { offset: r4, bufferElementsToAdd: s3 } = o3;
        if (s3 > 0) {
          for (let t7 = 0; t7 < s3; t7++) a6.push(0);
          i4 += c5, c5 = o3.bufferElementsToAdd;
        }
        const u4 = n2 ?? y3.getValue(_3 ? _3[m2] : e6, t6);
        switch (d5) {
          case 0:
          case 1:
            a6[i4] |= this._encodeByte(u4 * (f2 || 1), 8 * r4);
            break;
          case 2:
          case 3:
            a6[i4] |= this._encodeShort(u4 * (f2 || 1), 8 * r4);
            break;
          case 4:
          case 5:
            a6[i4] |= this._encodeByte(u4 * (f2 || 1), 8 * r4), a6[i4] |= this._encodeByte(u4 * (f2 || 1), 8 * r4 + 8);
            break;
          case 6:
          case 7:
            a6[i4] |= this._encodeShort(u4 * (f2 || 1), 8 * r4), a6[i4] |= this._encodeShort(u4 * (f2 || 1), 8 * r4 + 16);
            break;
          case 8:
          case 9:
            a6[i4] |= this._encodeByte(u4 * (f2 || 1), 8 * r4), a6[i4] |= this._encodeByte(u4 * (f2 || 1), 8 * r4 + 8), a6[i4] |= this._encodeByte(u4 * (f2 || 1), 8 * r4 + 16), a6[i4] |= this._encodeByte(u4 * (f2 || 1), 8 * r4 + 24);
            break;
          case 10:
            a6[i4] = this._encodeColor(u4);
            break;
          case 11:
          case 12:
            this._encodePattern(i4, a6, u4);
            break;
          default:
            throw new Error("Unsupported encoding type");
        }
        m2++;
      }
    }
    return a6;
  }
  getAtributeState(t6) {
    let e6 = 0;
    const o2 = 3 + 2 * t6;
    return e6 |= this._bit(o2), e6 |= this._bit(o2 + 1) << 1, e6;
  }
  _buildAttributesInfo() {
    const t6 = [], o2 = {}, { attributesInfo: n2, attributes: r3 } = this, a6 = {};
    let i4 = -1, c5 = -1;
    for (const e6 of r3) {
      c5++;
      const r4 = this.getAtributeState(c5);
      if (0 === r4 || 3 === r4) continue;
      const u3 = n2[e6], h2 = [];
      o2[e6] = h2;
      const d5 = u3.type;
      for (let e7 = 0; e7 < r4; e7++) {
        const { dataType: e8, bytesPerElement: o3, count: n3, normalized: r5 } = _s._encodingInfo[d5], c6 = o3 * n3, u4 = `${e8}-${true === r5}`;
        let f2 = a6[u4], l3 = 0;
        if (!f2 || f2.count + n3 > 4) i4++, f2 = { dataIndex: i4, count: 0, offset: 0 }, 4 !== n3 && (a6[u4] = f2), t6.push({ location: -1, name: "a_data_" + i4, count: n3, type: e8, normalized: r5 }), l3 = Math.ceil(Math.max(c6 / 4, 1));
        else {
          const e9 = t6[f2.dataIndex];
          e9.count += n3;
          l3 = Math.ceil(Math.max(e9.count * o3 / 4, 1)) - Math.ceil(Math.max(f2.offset / 4, 1));
        }
        h2.push({ dataIndex: f2.dataIndex, offset: f2.offset, bufferElementsToAdd: l3 }), f2.offset += c6, f2.count += n3;
      }
    }
    for (const s2 of t6) switch (s2.type) {
      case R.BYTE:
      case R.UNSIGNED_BYTE:
        s2.count = 4;
        break;
      case R.SHORT:
      case R.UNSIGNED_SHORT:
        s2.count += s2.count % 2;
    }
    this._buildVertexBufferLayout(t6), this._buildShaderInfo(t6, o2), this._propertyEncodingInfo = o2;
  }
  _buildVertexBufferLayout(t6) {
    const e6 = this.baseGeometryLayout;
    let s2 = e6[0].stride;
    if (0 === t6.length) this._geometryLayout = e6;
    else {
      const o2 = [];
      let n2 = s2;
      for (const e7 of t6) s2 += a2(e7.type) * e7.count;
      for (const t7 of e6) o2.push(new t(t7.name, t7.count, t7.type, t7.offset, s2, t7.normalized));
      for (const e7 of t6) o2.push(new t(e7.name, e7.count, e7.type, n2, s2, e7.normalized)), n2 += a2(e7.type) * e7.count;
      this._geometryLayout = o2;
    }
    this.opacityLayout ? this._locations = t2([this._geometryLayout, this.opacityLayout]) : this._locations = n(this._geometryLayout), this._stride = s2;
  }
  _buildShaderInfo(t6, e6) {
    let o2 = "\n", n2 = "\n";
    const r3 = [];
    for (const s2 of t6) o2 += `attribute ${this._getType(s2.count)} ${s2.name};
`;
    const { attributesInfo: a6, attributes: c5 } = this;
    let u3 = -1;
    for (const h2 of c5) {
      u3++;
      const { name: t7, type: c6, precisionFactor: d5, isLayout: f2 } = a6[h2], l3 = d5 && 1 !== d5 ? " * " + 1 / d5 : "", { bytesPerElement: y3, count: _3 } = _s._encodingInfo[c6], m2 = (t8) => `a_data_${t8.dataIndex}${i(_3, t8.offset, y3)}`;
      switch (this.getAtributeState(u3)) {
        case 0:
          {
            const e7 = this._getType(_3), s2 = `u_${t7}`;
            r3.push({ name: s2, type: e7, getValue: (t8, e8, o3, n3) => {
              const r4 = f2 ? t8.getLayoutValue(h2, e8) : t8.getPaintValue(h2, e8);
              if (11 === c6) {
                const o4 = t8.getDashKey(r4, t8.getLayoutValue("line-cap", e8)), s3 = n3.getMosaicItemPosition(o4, false);
                if (null == s3) return null;
                const { tl: a7, br: i4 } = s3;
                return [a7[0], i4[1], i4[0], a7[1]];
              }
              if (12 === c6) {
                const t9 = n3.getMosaicItemPosition(r4, !h2.includes("line-"));
                if (null == t9) return null;
                const { tl: e9, br: o4 } = t9;
                return [e9[0], o4[1], o4[0], e9[1]];
              }
              if (10 === c6) {
                const t9 = r4[3];
                return [t9 * r4[0], t9 * r4[1], t9 * r4[2], t9];
              }
              return r4;
            } }), o2 += `uniform ${e7} ${s2};
`, n2 += `${e7} ${t7} = ${s2};
`;
          }
          break;
        case 1:
          {
            const o3 = m2(e6[h2][0]);
            n2 += `${this._getType(_3)} ${t7} = ${o3}${l3};
`;
          }
          break;
        case 2: {
          const s2 = `u_t_${t7}`;
          r3.push({ name: s2, type: "float", getValue: (t8, e7, o3, n3) => (f2 ? t8.getLayoutProperty(h2) : t8.getPaintProperty(h2)).interpolator.interpolationUniformValue(o3, e7) }), o2 += `uniform float ${s2};
`;
          const a7 = m2(e6[h2][0]), i4 = m2(e6[h2][1]);
          n2 += `${this._getType(_3)} ${t7} = mix(${a7}${l3}, ${i4}${l3}, ${s2});
`;
        }
      }
    }
    this._shaderHeader = o2, this._shaderMain = n2, this._uniforms = r3;
  }
  _bit(t6) {
    return (this._key & 1 << t6) >> t6;
  }
  _getType(t6) {
    switch (t6) {
      case 1:
        return "float";
      case 2:
        return "vec2";
      case 3:
        return "vec3";
      case 4:
        return "vec4";
    }
    throw new Error("Invalid count");
  }
  _encodeColor(e6) {
    const o2 = 255 * e6[3];
    return t3.i8888to32(e6[0] * o2, e6[1] * o2, e6[2] * o2, o2);
  }
  _encodePattern(t6, e6, o2) {
    if (!o2?.rect) return;
    const n2 = 2, r3 = o2.rect, s2 = o2.width, a6 = o2.height;
    e6[t6] = this._encodeShort(r3.x + n2, 0), e6[t6] |= this._encodeShort(r3.y + n2 + a6, 16), e6[t6 + 1] = this._encodeShort(r3.x + n2 + s2, 0), e6[t6 + 1] |= this._encodeShort(r3.y + n2, 16);
  }
  _encodeByte(t6, e6) {
    return (255 & t6) << e6;
  }
  _encodeShort(t6, e6) {
    return (65535 & t6) << e6;
  }
};
_s._encodingInfo = { 0: { dataType: R.BYTE, bytesPerElement: 1, count: 1, normalized: false }, 1: { dataType: R.UNSIGNED_BYTE, bytesPerElement: 1, count: 1, normalized: false }, 2: { dataType: R.SHORT, bytesPerElement: 2, count: 1, normalized: false }, 3: { dataType: R.UNSIGNED_SHORT, bytesPerElement: 2, count: 1, normalized: false }, 4: { dataType: R.BYTE, bytesPerElement: 1, count: 2, normalized: false }, 5: { dataType: R.UNSIGNED_BYTE, bytesPerElement: 1, count: 2, normalized: false }, 6: { dataType: R.SHORT, bytesPerElement: 2, count: 2, normalized: false }, 7: { dataType: R.UNSIGNED_SHORT, bytesPerElement: 2, count: 2, normalized: false }, 8: { dataType: R.BYTE, bytesPerElement: 1, count: 4, normalized: false }, 9: { dataType: R.UNSIGNED_BYTE, bytesPerElement: 1, count: 4, normalized: false }, 10: { dataType: R.UNSIGNED_BYTE, bytesPerElement: 1, count: 4, normalized: true }, 11: { dataType: R.UNSIGNED_SHORT, bytesPerElement: 2, count: 4, normalized: false }, 12: { dataType: R.UNSIGNED_SHORT, bytesPerElement: 2, count: 4, normalized: false } };
var s = _s;
var a2 = (t6) => {
  switch (t6) {
    case R.FLOAT:
    case R.INT:
    case R.UNSIGNED_INT:
      return 4;
    case R.SHORT:
    case R.UNSIGNED_SHORT:
    case R.HALF_FLOAT:
      return 2;
    case R.BYTE:
    case R.UNSIGNED_BYTE:
      return 1;
  }
};
var i = (t6, e6, o2) => {
  const n2 = e6 / o2;
  if (1 === t6) switch (n2) {
    case 0:
      return ".x";
    case 1:
      return ".y";
    case 2:
      return ".z";
    case 3:
      return ".w";
  }
  else if (2 === t6) switch (n2) {
    case 0:
      return ".xy";
    case 1:
      return ".yz";
    case 2:
      return ".zw";
  }
  else if (3 === t6) switch (n2) {
    case 0:
      return ".xyz";
    case 1:
      return ".yzw";
  }
  return "";
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/VTLBackgroundMaterial.js
var _T = class _T extends s {
  constructor(t6) {
    super(t6), this.baseGeometryLayout = _T.GEOMETRY_LAYOUT, this.attributes = _T.ATTRIBUTES, this.attributesInfo = _T.ATTRIBUTES_INFO;
  }
};
_T.ATTRIBUTES = [];
_T.GEOMETRY_LAYOUT = [new t("a_pos", 2, R.BYTE, 0, 2)];
_T.ATTRIBUTES_INFO = {};
var T2 = _T;

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/VTLCircleMaterial.js
var _c = class _c extends s {
  constructor(e6) {
    super(e6), this.baseGeometryLayout = _c.GEOMETRY_LAYOUT, this.attributes = _c.ATTRIBUTES, this.attributesInfo = _c.ATTRIBUTES_INFO;
  }
};
_c.ATTRIBUTES = ["circle-radius", "circle-color", "circle-opacity", "circle-stroke-width", "circle-stroke-color", "circle-stroke-opacity", "circle-blur"];
_c.GEOMETRY_LAYOUT = [new t("a_pos", 2, R.SHORT, 0, 4)];
_c.ATTRIBUTES_INFO = { "circle-radius": { name: "radius", type: 1 }, "circle-color": { name: "color", type: 10 }, "circle-opacity": { name: "opacity", type: 1, precisionFactor: 100 }, "circle-stroke-width": { name: "stroke_width", type: 1, precisionFactor: 4 }, "circle-stroke-color": { name: "stroke_color", type: 10 }, "circle-stroke-opacity": { name: "stroke_opacity", type: 1, precisionFactor: 100 }, "circle-blur": { name: "blur", type: 1, precisionFactor: 32 } };
var c2 = _c;

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/VTLFillMaterial.js
var _T2 = class _T2 extends s {
  constructor(t6) {
    super(t6), this.baseGeometryLayout = _T2.GEOMETRY_LAYOUT, this.attributes = _T2.ATTRIBUTES, this.attributesInfo = _T2.ATTRIBUTES_INFO;
  }
};
_T2.ATTRIBUTES = ["fill-color", "fill-opacity", "fill-pattern"];
_T2.GEOMETRY_LAYOUT = [new t("a_pos", 2, R.SHORT, 0, 4)];
_T2.ATTRIBUTES_INFO = { "fill-color": { name: "color", type: 10 }, "fill-opacity": { name: "opacity", type: 1, precisionFactor: 100 }, "fill-pattern": { name: "tlbr", type: 12, isOptional: true } };
var T3 = _T2;
var _e = class _e extends s {
  constructor(t6, i4) {
    super(t6), this.baseGeometryLayout = _e.GEOMETRY_LAYOUT, this.attributes = i4 ? _e.ATTRIBUTES_FILL : _e.ATTRIBUTES_OUTLINE, this.attributesInfo = i4 ? _e.ATTRIBUTES_INFO_FILL : _e.ATTRIBUTES_INFO_OUTLINE;
  }
};
_e.ATTRIBUTES_OUTLINE = ["fill-outline-color", "fill-opacity"];
_e.ATTRIBUTES_FILL = ["fill-color", "fill-opacity"];
_e.GEOMETRY_LAYOUT = [new t("a_pos", 2, R.SHORT, 0, 8), new t("a_offset", 2, R.BYTE, 4, 8), new t("a_xnormal", 2, R.BYTE, 6, 8)];
_e.ATTRIBUTES_INFO_OUTLINE = { "fill-outline-color": { name: "color", type: 10 }, "fill-opacity": { name: "opacity", type: 1, precisionFactor: 100 } };
_e.ATTRIBUTES_INFO_FILL = { "fill-color": { name: "color", type: 10 }, "fill-opacity": { name: "opacity", type: 1, precisionFactor: 100 } };
var e3 = _e;

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/VTLLineMaterial.js
var _a = class _a extends s {
  constructor(e6) {
    super(e6), this.baseGeometryLayout = _a.GEOMETRY_LAYOUT, this.attributes = _a.ATTRIBUTES, this.attributesInfo = _a.ATTRIBUTES_INFO;
  }
};
_a.ATTRIBUTES = ["line-blur", "line-color", "line-gap-width", "line-offset", "line-opacity", "line-width", "line-pattern", "line-dasharray"];
_a.GEOMETRY_LAYOUT = [new t("a_pos", 2, R.SHORT, 0, 16), new t("a_extrude_offset", 4, R.BYTE, 4, 16), new t("a_dir_normal", 4, R.BYTE, 8, 16), new t("a_accumulatedDistance", 2, R.UNSIGNED_SHORT, 12, 16)];
_a.ATTRIBUTES_INFO = { "line-width": { name: "width", type: 1, precisionFactor: 2 }, "line-gap-width": { name: "gap_width", type: 1, precisionFactor: 2 }, "line-offset": { name: "offset", type: 0, precisionFactor: 2 }, "line-color": { name: "color", type: 10 }, "line-opacity": { name: "opacity", type: 1, precisionFactor: 100 }, "line-blur": { name: "blur", type: 1, precisionFactor: 4 }, "line-pattern": { name: "tlbr", type: 12, isOptional: true }, "line-dasharray": { name: "tlbr", type: 11, isOptional: true } };
var a3 = _a;

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/VTLSymbolMaterial.js
var i2 = [new t("a_pos", 2, R.SHORT, 0, 16), new t("a_vertexOffset", 2, R.SHORT, 4, 16), new t("a_texAngleRange", 4, R.UNSIGNED_BYTE, 8, 16), new t("a_levelInfo", 4, R.UNSIGNED_BYTE, 12, 16)];
var a4 = [new t("a_opacityInfo", 1, R.UNSIGNED_BYTE, 0, 1)];
var _c2 = class _c2 extends s {
  constructor(t6) {
    super(t6), this.baseGeometryLayout = i2, this.opacityLayout = a4, this.attributes = _c2.ATTRIBUTES, this.attributesInfo = _c2.ATTRIBUTES_INFO;
  }
};
_c2.ATTRIBUTES = ["icon-color", "icon-opacity", "icon-halo-blur", "icon-halo-color", "icon-halo-width", "icon-size"];
_c2.ATTRIBUTES_INFO = { "icon-color": { name: "color", type: 10 }, "icon-opacity": { name: "opacity", type: 1, precisionFactor: 100 }, "icon-halo-color": { name: "halo_color", type: 10 }, "icon-halo-width": { name: "halo_width", type: 1, precisionFactor: 4 }, "icon-halo-blur": { name: "halo_blur", type: 1, precisionFactor: 4 }, "icon-size": { name: "size", type: 1, precisionFactor: 32, isLayout: true } };
var c3 = _c2;
var _r = class _r extends s {
  constructor(t6) {
    super(t6), this.baseGeometryLayout = i2, this.opacityLayout = a4, this.attributes = _r.ATTRIBUTES, this.attributesInfo = _r.ATTRIBUTES_INFO;
  }
};
_r.ATTRIBUTES = ["text-color", "text-opacity", "text-halo-blur", "text-halo-color", "text-halo-width", "text-size"];
_r.ATTRIBUTES_INFO = { "text-color": { name: "color", type: 10 }, "text-opacity": { name: "opacity", type: 1, precisionFactor: 100 }, "text-halo-color": { name: "halo_color", type: 10 }, "text-halo-width": { name: "halo_width", type: 1, precisionFactor: 4 }, "text-halo-blur": { name: "halo_blur", type: 1, precisionFactor: 4 }, "text-size": { name: "size", type: 1, isLayout: true } };
var r = _r;

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/expression/types.js
var r2 = { kind: "null" };
var e4 = { kind: "number" };
var t4 = { kind: "string" };
var i3 = { kind: "boolean" };
var o = { kind: "color" };
var f = { kind: "object" };
var u2 = { kind: "value" };
function a5(n2, r3) {
  return { kind: "array", itemType: n2, n: r3 };
}
var y = [r2, e4, t4, i3, o, f, a5(u2)];
function k(n2) {
  if ("array" === n2.kind) {
    const r3 = k(n2.itemType);
    return "number" == typeof n2.n ? `array<${r3}, ${n2.n}>` : "value" === n2.itemType.kind ? "array" : `array<${r3}>`;
  }
  return n2.kind;
}
function l(y3) {
  if (null === y3) return r2;
  if ("string" == typeof y3) return t4;
  if ("boolean" == typeof y3) return i3;
  if ("number" == typeof y3) return e4;
  if (y3 instanceof u) return o;
  if (Array.isArray(y3)) {
    let n2;
    for (const r3 of y3) {
      const e6 = l(r3);
      if (n2) {
        if (n2 !== e6) {
          n2 = u2;
          break;
        }
      } else n2 = e6;
    }
    return a5(n2 || u2, y3.length);
  }
  return "object" == typeof y3 ? f : u2;
}
function c4(n2, r3) {
  if ("array" === r3.kind) return "array" === n2.kind && (0 === n2.n && "value" === n2.itemType.kind || c4(n2.itemType, r3.itemType)) && ("number" != typeof r3.n || r3.n === n2.n);
  if ("value" === r3.kind) {
    for (const e6 of y) if (c4(n2, e6)) return true;
  }
  return r3.kind === n2.kind;
}
function d2(r3) {
  if (null === r3) return "";
  const e6 = typeof r3;
  return "string" === e6 ? r3 : "number" === e6 || "boolean" === e6 ? String(r3) : r3 instanceof u ? r3.toString() : JSON.stringify(r3);
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/expression/expression.js
var y2 = class {
  constructor(t6) {
    this._parent = t6, this._vars = {};
  }
  add(t6, e6) {
    this._vars[t6] = e6;
  }
  get(t6) {
    return this._vars[t6] ? this._vars[t6] : this._parent ? this._parent.get(t6) : null;
  }
};
var _ = class __ {
  constructor() {
    this.type = u2;
  }
  static parse(t6) {
    if (t6.length > 1) throw new Error('"id" does not expect arguments');
    return new __();
  }
  evaluate(t6, e6) {
    return t6?.id;
  }
};
var v = class _v {
  constructor() {
    this.type = t4;
  }
  static parse(t6) {
    if (t6.length > 1) throw new Error('"geometry-type" does not expect arguments');
    return new _v();
  }
  evaluate(t6, e6) {
    if (!t6) return null;
    switch (t6.type) {
      case 1:
        return "Point";
      case 2:
        return "LineString";
      case 3:
        return "Polygon";
      default:
        return null;
    }
  }
};
var b2 = class _b {
  constructor() {
    this.type = f;
  }
  static parse(t6) {
    if (t6.length > 1) throw new Error('"properties" does not expect arguments');
    return new _b();
  }
  evaluate(t6, e6) {
    return t6?.values;
  }
};
var d3 = class _d {
  constructor() {
    this.type = e4;
  }
  static parse(t6) {
    if (t6.length > 1) throw new Error('"zoom" does not expect arguments');
    return new _d();
  }
  evaluate(t6, e6) {
    return e6;
  }
};
var x = class _x {
  constructor(t6, e6, r3) {
    this._lhs = t6, this._rhs = e6, this._compare = r3, this.type = i3;
  }
  static parse(t6, e6, r3) {
    if (3 !== t6.length && 4 !== t6.length) throw new Error(`"${t6[0]}" expects 2 or 3 arguments`);
    if (4 === t6.length) throw new Error(`"${t6[0]}" collator not supported`);
    return new _x(ht(t6[1], e6), ht(t6[2], e6), r3);
  }
  evaluate(t6, e6) {
    return this._compare(this._lhs.evaluate(t6, e6), this._rhs.evaluate(t6, e6));
  }
};
var E = class extends x {
  static parse(t6, e6) {
    return x.parse(t6, e6, (t7, e7) => t7 === e7);
  }
};
var $ = class extends x {
  static parse(t6, e6) {
    return x.parse(t6, e6, (t7, e7) => t7 !== e7);
  }
};
var M = class extends x {
  static parse(t6, e6) {
    return x.parse(t6, e6, (t7, e7) => t7 < e7);
  }
};
var k2 = class extends x {
  static parse(t6, e6) {
    return x.parse(t6, e6, (t7, e7) => t7 <= e7);
  }
};
var A = class extends x {
  static parse(t6, e6) {
    return x.parse(t6, e6, (t7, e7) => t7 > e7);
  }
};
var j = class extends x {
  static parse(t6, e6) {
    return x.parse(t6, e6, (t7, e7) => t7 >= e7);
  }
};
var q2 = class _q {
  constructor(t6) {
    this._arg = t6, this.type = i3;
  }
  static parse(t6, e6) {
    if (2 !== t6.length) throw new Error('"!" expects 1 argument');
    return new _q(ht(t6[1], e6));
  }
  evaluate(t6, e6) {
    return !this._arg.evaluate(t6, e6);
  }
};
var N2 = class _N {
  constructor(t6) {
    this._args = t6, this.type = i3;
  }
  static parse(t6, e6) {
    const r3 = [];
    for (let s2 = 1; s2 < t6.length; s2++) r3.push(ht(t6[s2], e6));
    return new _N(r3);
  }
  evaluate(t6, e6) {
    for (const r3 of this._args) if (!r3.evaluate(t6, e6)) return false;
    return true;
  }
};
var R2 = class _R {
  constructor(t6) {
    this._args = t6, this.type = i3;
  }
  static parse(t6, e6) {
    const r3 = [];
    for (let s2 = 1; s2 < t6.length; s2++) r3.push(ht(t6[s2], e6));
    return new _R(r3);
  }
  evaluate(t6, e6) {
    for (const r3 of this._args) if (r3.evaluate(t6, e6)) return true;
    return false;
  }
};
var C2 = class _C {
  constructor(t6) {
    this._args = t6, this.type = i3;
  }
  static parse(t6, e6) {
    const r3 = [];
    for (let s2 = 1; s2 < t6.length; s2++) r3.push(ht(t6[s2], e6));
    return new _C(r3);
  }
  evaluate(t6, e6) {
    for (const r3 of this._args) if (r3.evaluate(t6, e6)) return false;
    return true;
  }
};
var z = class _z {
  constructor(t6, e6, r3) {
    this.type = t6, this._args = e6, this._fallback = r3;
  }
  static parse(t6, e6, r3) {
    if (t6.length < 4) throw new Error('"case" expects at least 3 arguments');
    if (t6.length % 2 == 1) throw new Error('"case" expects an odd number of arguments');
    let s2;
    const n2 = [];
    for (let o2 = 1; o2 < t6.length - 1; o2 += 2) {
      const a7 = ht(t6[o2], e6), i4 = ht(t6[o2 + 1], e6, r3);
      s2 || (s2 = i4.type), n2.push({ condition: a7, output: i4 });
    }
    const a6 = ht(t6[t6.length - 1], e6, r3);
    return s2 || (s2 = a6.type), new _z(s2, n2, a6);
  }
  evaluate(t6, e6) {
    for (const r3 of this._args) if (r3.condition.evaluate(t6, e6)) return r3.output.evaluate(t6, e6);
    return this._fallback.evaluate(t6, e6);
  }
};
var I2 = class _I {
  constructor(t6, e6) {
    this.type = t6, this._args = e6;
  }
  static parse(t6, e6) {
    if (t6.length < 2) throw new Error('"coalesce" expects at least 1 argument');
    let r3;
    const s2 = [];
    for (let n2 = 1; n2 < t6.length; n2++) {
      const a6 = ht(t6[n2], e6);
      r3 || (r3 = a6.type), s2.push(a6);
    }
    return new _I(r3, s2);
  }
  evaluate(t6, e6) {
    for (const r3 of this._args) {
      const s2 = r3.evaluate(t6, e6);
      if (null !== s2) return s2;
    }
    return null;
  }
};
var L = class _L {
  constructor(t6, e6, r3, s2, n2) {
    this.type = t6, this._input = e6, this._labels = r3, this._outputs = s2, this._fallback = n2;
  }
  static parse(t6, e6) {
    if (t6.length < 3) throw new Error('"match" expects at least 3 arguments');
    if (t6.length % 2 == 0) throw new Error('"case" expects an even number of arguments');
    let r3;
    const s2 = ht(t6[1], e6), n2 = [], a6 = {};
    let o2;
    for (let i4 = 2; i4 < t6.length - 1; i4 += 2) {
      let s3 = t6[i4];
      Array.isArray(s3) || (s3 = [s3]);
      for (const t7 of s3) {
        const e7 = typeof t7;
        if ("string" !== e7 && "number" !== e7) throw new Error('"match" requires string or number literal as labels');
        if (o2) {
          if (e7 !== o2) throw new Error('"match" requires labels to have the same type');
        } else o2 = e7;
        a6[t7] = n2.length;
      }
      const l3 = ht(t6[i4 + 1], e6);
      r3 || (r3 = l3.type), n2.push(l3);
    }
    return new _L(r3, s2, a6, n2, ht(t6[t6.length - 1], e6));
  }
  evaluate(t6, e6) {
    const r3 = this._input.evaluate(t6, e6);
    return (this._outputs[this._labels[r3]] || this._fallback).evaluate(t6, e6);
  }
};
var U2 = class _U {
  constructor(t6, e6, r3, s2, n2) {
    this._operator = t6, this.type = e6, this.interpolation = r3, this.input = s2, this._stops = n2;
  }
  static parse(t6, e6, r3) {
    const s2 = t6[0];
    if (t6.length < 5) throw new Error(`"${s2}" expects at least 4 arguments`);
    const n2 = t6[1];
    if (!Array.isArray(n2) || 0 === n2.length) throw new Error(`"${n2}" is not a valid interpolation`);
    switch (n2[0]) {
      case "linear":
        if (1 !== n2.length) throw new Error("Linear interpolation cannot have parameters");
        break;
      case "exponential":
        if (2 !== n2.length || "number" != typeof n2[1]) throw new Error("Exponential interpolation requires one numeric argument");
        break;
      case "cubic-bezier":
        if (5 !== n2.length) throw new Error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1");
        for (let t7 = 1; t7 < 5; t7++) {
          const e7 = n2[t7];
          if ("number" != typeof e7 || e7 < 0 || e7 > 1) throw new Error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1");
        }
        break;
      default:
        throw new Error(`"${t6[0]}" unknown interpolation type "${n2[0]}"`);
    }
    if (t6.length % 2 != 1) throw new Error(`"${s2}" expects an even number of arguments`);
    const a6 = ht(t6[2], e6, e4);
    let o2;
    "interpolate-hcl" === s2 || "interpolate-lab" === s2 ? o2 = o : r3 && "value" !== r3.kind && (o2 = r3);
    const l3 = [];
    for (let i4 = 3; i4 < t6.length; i4 += 2) {
      const r4 = t6[i4];
      if ("number" != typeof r4) throw new Error(`"${s2}" requires stop inputs as literal numbers`);
      if (l3.length && l3[l3.length - 1][0] >= r4) throw new Error(`"${s2}" requires strictly ascending stop inputs`);
      const n3 = ht(t6[i4 + 1], e6, o2);
      o2 || (o2 = n3.type), l3.push([r4, n3]);
    }
    if (o2 && o2 !== o && o2 !== e4 && ("array" !== o2.kind || o2.itemType !== e4)) throw new Error(`"${s2}" cannot interpolate type ${k(o2)}`);
    return new _U(s2, o2, n2, a6, l3);
  }
  evaluate(n2, o2) {
    const i4 = this._stops;
    if (1 === i4.length) return i4[0][1].evaluate(n2, o2);
    const l3 = this.input.evaluate(n2, o2);
    if (l3 <= i4[0][0]) return i4[0][1].evaluate(n2, o2);
    if (l3 >= i4[i4.length - 1][0]) return i4[i4.length - 1][1].evaluate(n2, o2);
    let u3 = 0;
    for (; ++u3 < i4.length && !(l3 < i4[u3][0]); ) ;
    const c5 = i4[u3 - 1][0], h2 = i4[u3][0], g = _U.interpolationRatio(this.interpolation, l3, c5, h2), f2 = i4[u3 - 1][1].evaluate(n2, o2), w = i4[u3][1].evaluate(n2, o2);
    if ("interpolate" === this._operator) {
      if ("array" === this.type.kind && Array.isArray(f2) && Array.isArray(w)) return f2.map((t6, e6) => p(t6, w[e6], g));
      if ("color" === this.type.kind && f2 instanceof u && w instanceof u) {
        const e6 = new u(f2), r3 = new u(w);
        return new u([p(e6.r, r3.r, g), p(e6.g, r3.g, g), p(e6.b, r3.b, g), p(e6.a, r3.a, g)]);
      }
      if ("number" === this.type.kind && "number" == typeof f2 && "number" == typeof w) return p(f2, w, g);
      throw new Error(`"${this._operator}" cannot interpolate type ${k(this.type)}`);
    }
    if ("interpolate-hcl" === this._operator) {
      const s2 = q(f2), n3 = q(w), o3 = n3.h - s2.h, i5 = U({ h: s2.h + g * (o3 > 180 || o3 < -180 ? o3 - 360 * Math.round(o3 / 360) : o3), c: p(s2.c, n3.c, g), l: p(s2.l, n3.l, g) });
      return new u({ a: p(f2.a, w.a, g), ...i5 });
    }
    if ("interpolate-lab" === this._operator) {
      const e6 = C(f2), n3 = C(w), o3 = U({ l: p(e6.l, n3.l, g), a: p(e6.a, n3.a, g), b: p(e6.b, n3.b, g) });
      return new u({ a: p(f2.a, w.a, g), ...o3 });
    }
    throw new Error(`Unexpected operator "${this._operator}"`);
  }
  interpolationUniformValue(t6, e6) {
    const r3 = this._stops;
    if (1 === r3.length) return 0;
    if (t6 >= r3[r3.length - 1][0]) return 0;
    let s2 = 0;
    for (; ++s2 < r3.length && !(t6 < r3[s2][0]); ) ;
    const n2 = r3[s2 - 1][0], a6 = r3[s2][0];
    return _U.interpolationRatio(this.interpolation, e6, n2, a6);
  }
  getInterpolationRange(t6) {
    const e6 = this._stops;
    if (1 === e6.length) {
      const t7 = e6[0][0];
      return [t7, t7];
    }
    const r3 = e6[e6.length - 1][0];
    if (t6 >= r3) return [r3, r3];
    let s2 = 0;
    for (; ++s2 < e6.length && !(t6 < e6[s2][0]); ) ;
    return [e6[s2 - 1][0], e6[s2][0]];
  }
  static interpolationRatio(t6, e6, r3, s2) {
    let a6 = 0;
    if ("linear" === t6[0]) a6 = _U._exponentialInterpolationRatio(e6, 1, r3, s2);
    else if ("exponential" === t6[0]) a6 = _U._exponentialInterpolationRatio(e6, t6[1], r3, s2);
    else if ("cubic-bezier" === t6[0]) {
      a6 = e2(t6[1], t6[2], t6[3], t6[4])(_U._exponentialInterpolationRatio(e6, 1, r3, s2), 1e-5);
    }
    return a6 < 0 ? a6 = 0 : a6 > 1 && (a6 = 1), a6;
  }
  static _exponentialInterpolationRatio(t6, e6, r3, s2) {
    const n2 = s2 - r3;
    if (0 === n2) return 0;
    const a6 = t6 - r3;
    return 1 === e6 ? a6 / n2 : (e6 ** a6 - 1) / (e6 ** n2 - 1);
  }
};
var B = class _B {
  constructor(t6, e6, r3) {
    this.type = t6, this._input = e6, this._stops = r3;
  }
  static parse(t6, e6) {
    if (t6.length < 5) throw new Error('"step" expects at least 4 arguments');
    if (t6.length % 2 != 1) throw new Error('"step" expects an even number of arguments');
    const r3 = ht(t6[1], e6, e4);
    let s2;
    const n2 = [];
    n2.push([-1 / 0, ht(t6[2], e6)]);
    for (let a6 = 3; a6 < t6.length; a6 += 2) {
      const r4 = t6[a6];
      if ("number" != typeof r4) throw new Error('"step" requires stop inputs as literal numbers');
      if (n2.length && n2[n2.length - 1][0] >= r4) throw new Error('"step" requires strictly ascending stop inputs');
      const o2 = ht(t6[a6 + 1], e6);
      s2 || (s2 = o2.type), n2.push([r4, o2]);
    }
    return new _B(s2, r3, n2);
  }
  evaluate(t6, e6) {
    const r3 = this._stops;
    if (1 === r3.length) return r3[0][1].evaluate(t6, e6);
    const s2 = this._input.evaluate(t6, e6);
    let n2 = 0;
    for (; ++n2 < r3.length && !(s2 < r3[n2][0]); ) ;
    return this._stops[n2 - 1][1].evaluate(t6, e6);
  }
};
var S = class _S {
  constructor(t6, e6) {
    this.type = t6, this._output = e6;
  }
  static parse(t6, e6, r3) {
    if (t6.length < 4) throw new Error('"let" expects at least 3 arguments');
    if (t6.length % 2 == 1) throw new Error('"let" expects an odd number of arguments');
    const s2 = new y2(e6);
    for (let a6 = 1; a6 < t6.length - 1; a6 += 2) {
      const r4 = t6[a6];
      if ("string" != typeof r4) throw new Error(`"let" requires a string to define variable names - found ${r4}`);
      s2.add(r4, ht(t6[a6 + 1], e6));
    }
    const n2 = ht(t6[t6.length - 1], s2, r3);
    return new _S(n2.type, n2);
  }
  evaluate(t6, e6) {
    return this._output.evaluate(t6, e6);
  }
};
var P2 = class _P {
  constructor(t6, e6) {
    this.type = t6, this.output = e6;
  }
  static parse(t6, e6, r3) {
    if (2 !== t6.length || "string" != typeof t6[1]) throw new Error('"var" requires just one literal string argument');
    const s2 = e6.get(t6[1]);
    if (!s2) throw new Error(`${t6[1]} must be defined before being used in a "var" expression`);
    return new _P(r3 || u2, s2);
  }
  evaluate(t6, e6) {
    return this.output.evaluate(t6, e6);
  }
};
var O = class _O {
  constructor(t6, e6, r3) {
    this.type = t6, this._index = e6, this._array = r3;
  }
  static parse(t6, e6) {
    if (3 !== t6.length) throw new Error('"at" expects 2 arguments');
    const r3 = ht(t6[1], e6, e4), s2 = ht(t6[2], e6);
    return new _O(s2.type.itemType, r3, s2);
  }
  evaluate(t6, e6) {
    const r3 = this._index.evaluate(t6, e6), s2 = this._array.evaluate(t6, e6);
    if (r3 < 0 || r3 >= s2.length) throw new Error('"at" index out of bounds');
    if (r3 !== Math.floor(r3)) throw new Error('"at" index must be an integer');
    return s2[r3];
  }
};
var T4 = class _T3 {
  constructor(t6, e6) {
    this._key = t6, this._obj = e6, this.type = u2;
  }
  static parse(t6, e6) {
    let r3, s2;
    switch (t6.length) {
      case 2:
        return r3 = ht(t6[1], e6), new _T3(r3);
      case 3:
        return r3 = ht(t6[1], e6), s2 = ht(t6[2], e6), new _T3(r3, s2);
      default:
        throw new Error('"get" expects 1 or 2 arguments');
    }
  }
  evaluate(t6, e6) {
    const r3 = this._key.evaluate(t6, e6);
    if (this._obj) {
      return this._obj.evaluate(t6, e6)[r3];
    }
    return t6?.values[r3];
  }
};
var F = class _F {
  constructor(t6, e6) {
    this._key = t6, this._obj = e6, this.type = i3;
  }
  static parse(t6, e6) {
    let r3, s2;
    switch (t6.length) {
      case 2:
        return r3 = ht(t6[1], e6), new _F(r3);
      case 3:
        return r3 = ht(t6[1], e6), s2 = ht(t6[2], e6), new _F(r3, s2);
      default:
        throw new Error('"has" expects 1 or 2 arguments');
    }
  }
  evaluate(t6, e6) {
    const r3 = this._key.evaluate(t6, e6);
    if (this._obj) {
      return r3 in this._obj.evaluate(t6, e6);
    }
    return !!t6?.values[r3];
  }
};
var G = class _G {
  constructor(t6, e6) {
    this._key = t6, this._vals = e6, this.type = i3;
  }
  static parse(t6, e6) {
    if (3 !== t6.length) throw new Error('"in" expects 2 arguments');
    return new _G(ht(t6[1], e6), ht(t6[2], e6));
  }
  evaluate(t6, e6) {
    const r3 = this._key.evaluate(t6, e6);
    return this._vals.evaluate(t6, e6).includes(r3);
  }
};
var V = class _V {
  constructor(t6, e6, r3) {
    this._item = t6, this._array = e6, this._from = r3, this.type = e4;
  }
  static parse(t6, e6) {
    if (t6.length < 3 || t6.length > 4) throw new Error('"index-of" expects 3 or 4 arguments');
    const r3 = ht(t6[1], e6), s2 = ht(t6[2], e6);
    if (4 === t6.length) {
      const n2 = ht(t6[3], e6, e4);
      return new _V(r3, s2, n2);
    }
    return new _V(r3, s2);
  }
  evaluate(t6, e6) {
    const r3 = this._item.evaluate(t6, e6), s2 = this._array.evaluate(t6, e6);
    if (this._from) {
      const n2 = this._from.evaluate(t6, e6);
      if (n2 !== Math.floor(n2)) throw new Error('"index-of" index must be an integer');
      return s2.indexOf(r3, n2);
    }
    return s2.indexOf(r3);
  }
};
var D = class _D {
  constructor(t6) {
    this._arg = t6, this.type = e4;
  }
  static parse(t6, e6) {
    if (2 !== t6.length) throw new Error('"length" expects 2 arguments');
    const r3 = ht(t6[1], e6);
    return new _D(r3);
  }
  evaluate(t6, e6) {
    const r3 = this._arg.evaluate(t6, e6);
    if ("string" == typeof r3) return r3.length;
    if (Array.isArray(r3)) return r3.length;
    throw new Error('"length" expects string or array');
  }
};
var H = class _H {
  constructor(t6, e6, r3, s2) {
    this.type = t6, this._array = e6, this._from = r3, this._to = s2;
  }
  static parse(t6, e6) {
    if (t6.length < 3 || t6.length > 4) throw new Error('"slice" expects 2 or 3 arguments');
    const r3 = ht(t6[1], e6), s2 = ht(t6[2], e6, e4);
    if (s2.type !== e4) throw new Error('"slice" index must return a number');
    if (4 === t6.length) {
      const n2 = ht(t6[3], e6, e4);
      if (n2.type !== e4) throw new Error('"slice" index must return a number');
      return new _H(r3.type, r3, s2, n2);
    }
    return new _H(r3.type, r3, s2);
  }
  evaluate(t6, e6) {
    const r3 = this._array.evaluate(t6, e6);
    if (!Array.isArray(r3) && "string" != typeof r3) throw new Error('"slice" input must be an array or a string');
    const s2 = this._from.evaluate(t6, e6);
    if (s2 < 0 || s2 >= r3.length) throw new Error('"slice" index out of bounds');
    if (s2 !== Math.floor(s2)) throw new Error('"slice" index must be an integer');
    if (this._to) {
      const n2 = this._to.evaluate(t6, e6);
      if (n2 < 0 || n2 >= r3.length) throw new Error('"slice" index out of bounds');
      if (n2 !== Math.floor(n2)) throw new Error('"slice" index must be an integer');
      return r3.slice(s2, n2);
    }
    return r3.slice(s2);
  }
};
var J = class _J {
  constructor() {
    this.type = i3;
  }
  static parse(t6) {
    if (1 !== t6.length) throw new Error('"has-id" expects no arguments');
    return new _J();
  }
  evaluate(t6, e6) {
    return void 0 !== t6?.id;
  }
};
var K = class _K {
  constructor(t6, e6) {
    this._args = t6, this._calculate = e6, this.type = e4;
  }
  static parse(t6, e6, r3) {
    const s2 = t6.slice(1).map((t7) => ht(t7, e6));
    return new _K(s2, r3);
  }
  evaluate(t6, e6) {
    let r3;
    return this._args && (r3 = this._args.map((r4) => r4.evaluate(t6, e6))), this._calculate(r3);
  }
};
var Q = class extends K {
  static parse(t6, e6) {
    switch (t6.length) {
      case 2:
        return K.parse(t6, e6, (t7) => -t7[0]);
      case 3:
        return K.parse(t6, e6, (t7) => t7[0] - t7[1]);
      default:
        throw new Error('"-" expects 1 or 2 arguments');
    }
  }
};
var W = class extends K {
  static parse(t6, e6) {
    return K.parse(t6, e6, (t7) => {
      let e7 = 1;
      for (const r3 of t7) e7 *= r3;
      return e7;
    });
  }
};
var X = class extends K {
  static parse(t6, e6) {
    if (3 === t6.length) return K.parse(t6, e6, (t7) => t7[0] / t7[1]);
    throw new Error('"/" expects 2 arguments');
  }
};
var Y = class extends K {
  static parse(t6, e6) {
    if (3 === t6.length) return K.parse(t6, e6, (t7) => t7[0] % t7[1]);
    throw new Error('"%" expects 2 arguments');
  }
};
var Z = class extends K {
  static parse(t6, e6) {
    if (3 === t6.length) return K.parse(t6, e6, (t7) => t7[0] ** t7[1]);
    throw new Error('"^" expects 1 or 2 arguments');
  }
};
var tt = class extends K {
  static parse(t6, e6) {
    return K.parse(t6, e6, (t7) => {
      let e7 = 0;
      for (const r3 of t7) e7 += r3;
      return e7;
    });
  }
};
var _et = class _et {
  constructor(t6, e6) {
    this._args = t6, this._calculate = e6, this.type = e4;
  }
  static parse(t6, e6) {
    const r3 = t6.slice(1).map((t7) => ht(t7, e6));
    return new _et(r3, _et.ops[t6[0]]);
  }
  evaluate(t6, e6) {
    let r3;
    return this._args && (r3 = this._args.map((r4) => r4.evaluate(t6, e6))), this._calculate(r3);
  }
};
_et.ops = { abs: (t6) => Math.abs(t6[0]), acos: (t6) => Math.acos(t6[0]), asin: (t6) => Math.asin(t6[0]), atan: (t6) => Math.atan(t6[0]), ceil: (t6) => Math.ceil(t6[0]), cos: (t6) => Math.cos(t6[0]), e: () => Math.E, floor: (t6) => Math.floor(t6[0]), ln: (t6) => Math.log(t6[0]), ln2: () => Math.LN2, log10: (t6) => Math.log(t6[0]) / Math.LN10, log2: (t6) => Math.log(t6[0]) / Math.LN2, max: (t6) => Math.max(...t6), min: (t6) => Math.min(...t6), pi: () => Math.PI, round: (t6) => Math.round(t6[0]), sin: (t6) => Math.sin(t6[0]), sqrt: (t6) => Math.sqrt(t6[0]), tan: (t6) => Math.tan(t6[0]) };
var et = _et;
var rt = class _rt {
  constructor(t6) {
    this._args = t6, this.type = t4;
  }
  static parse(t6, e6) {
    return new _rt(t6.slice(1).map((t7) => ht(t7, e6)));
  }
  evaluate(t6, e6) {
    return this._args.map((r3) => r3.evaluate(t6, e6)).join("");
  }
};
var _st = class _st {
  constructor(t6, e6) {
    this._arg = t6, this._calculate = e6, this.type = t4;
  }
  static parse(t6, e6) {
    if (2 !== t6.length) throw new Error(`${t6[0]} expects 1 argument`);
    const r3 = ht(t6[1], e6);
    return new _st(r3, _st.ops[t6[0]]);
  }
  evaluate(t6, e6) {
    return this._calculate(this._arg.evaluate(t6, e6));
  }
};
_st.ops = { downcase: (t6) => t6.toLowerCase(), upcase: (t6) => t6.toUpperCase() };
var st = _st;
var nt = class _nt {
  constructor(t6) {
    this._args = t6, this.type = o;
  }
  static parse(t6, e6) {
    if (4 !== t6.length) throw new Error('"rgb" expects 3 arguments');
    const r3 = t6.slice(1).map((t7) => ht(t7, e6));
    return new _nt(r3);
  }
  evaluate(e6, r3) {
    const s2 = this._validate(this._args[0].evaluate(e6, r3)), n2 = this._validate(this._args[1].evaluate(e6, r3)), a6 = this._validate(this._args[2].evaluate(e6, r3));
    return new u({ r: s2, g: n2, b: a6 });
  }
  _validate(t6) {
    if ("number" != typeof t6 || t6 < 0 || t6 > 255) throw new Error(`${t6}: invalid color component`);
    return Math.round(t6);
  }
};
var at = class _at {
  constructor(t6) {
    this._args = t6, this.type = o;
  }
  static parse(t6, e6) {
    if (5 !== t6.length) throw new Error('"rgba" expects 4 arguments');
    const r3 = t6.slice(1).map((t7) => ht(t7, e6));
    return new _at(r3);
  }
  evaluate(e6, r3) {
    const s2 = this._validate(this._args[0].evaluate(e6, r3)), n2 = this._validate(this._args[1].evaluate(e6, r3)), a6 = this._validate(this._args[2].evaluate(e6, r3)), o2 = this._validateAlpha(this._args[3].evaluate(e6, r3));
    return new u({ r: s2, g: n2, b: a6, a: o2 });
  }
  _validate(t6) {
    if ("number" != typeof t6 || t6 < 0 || t6 > 255) throw new Error(`${t6}: invalid color component`);
    return Math.round(t6);
  }
  _validateAlpha(t6) {
    if ("number" != typeof t6 || t6 < 0 || t6 > 1) throw new Error(`${t6}: invalid alpha color component`);
    return t6;
  }
};
var ot = class _ot {
  constructor(t6) {
    this._color = t6, this.type = a5(e4, 4);
  }
  static parse(t6, e6) {
    if (2 !== t6.length) throw new Error('"to-rgba" expects 1 argument');
    const r3 = ht(t6[1], e6);
    return new _ot(r3);
  }
  evaluate(e6, r3) {
    return new u(this._color.evaluate(e6, r3)).toRgba();
  }
};
var it = class _it {
  constructor(t6, e6) {
    this.type = t6, this._args = e6;
  }
  static parse(t6, e6) {
    const r3 = t6[0];
    if (t6.length < 2) throw new Error(`${r3} expects at least one argument`);
    let s2, n2 = 1;
    if ("array" === r3) {
      if (t6.length > 2) {
        switch (t6[1]) {
          case "string":
            s2 = t4;
            break;
          case "number":
            s2 = e4;
            break;
          case "boolean":
            s2 = i3;
            break;
          default:
            throw new Error('"array" type argument must be string, number or boolean');
        }
        n2++;
      } else s2 = u2;
      let e7;
      if (t6.length > 3) {
        if (e7 = t6[2], null !== e7 && ("number" != typeof e7 || e7 < 0 || e7 !== Math.floor(e7))) throw new Error('"array" length argument must be a positive integer literal');
        n2++;
      }
      s2 = a5(s2, e7);
    } else switch (r3) {
      case "string":
        s2 = t4;
        break;
      case "number":
        s2 = e4;
        break;
      case "boolean":
        s2 = i3;
        break;
      case "object":
        s2 = f;
    }
    const a6 = [];
    for (; n2 < t6.length; n2++) {
      const r4 = ht(t6[n2], e6);
      a6.push(r4);
    }
    return new _it(s2, a6);
  }
  evaluate(t6, e6) {
    let r3;
    for (const s2 of this._args) {
      const n2 = s2.evaluate(t6, e6);
      if (r3 = l(n2), c4(r3, this.type)) return n2;
    }
    throw new Error(`Expected ${k(this.type)} but got ${k(r3)}`);
  }
};
var _lt = class _lt {
  constructor(t6, e6) {
    this.type = t6, this._args = e6;
  }
  static parse(t6, e6) {
    const r3 = t6[0], s2 = _lt.types[r3];
    if (s2 === i3 || s2 === t4) {
      if (2 !== t6.length) throw new Error(`${r3} expects one argument`);
    } else if (t6.length < 2) throw new Error(`${r3} expects at least one argument`);
    const n2 = [];
    for (let a6 = 1; a6 < t6.length; a6++) {
      const r4 = ht(t6[a6], e6);
      n2.push(r4);
    }
    return new _lt(s2, n2);
  }
  evaluate(e6, r3) {
    if (this.type === i3) return Boolean(this._args[0].evaluate(e6, r3));
    if (this.type === t4) return d2(this._args[0].evaluate(e6, r3));
    if (this.type === e4) {
      for (const t6 of this._args) {
        const s2 = Number(t6.evaluate(e6, r3));
        if (!isNaN(s2)) return s2;
      }
      return null;
    }
    if (this.type === o) {
      for (const s2 of this._args) try {
        const n2 = _lt.toColor(s2.evaluate(e6, r3));
        if (n2 instanceof u) return n2;
      } catch {
      }
      return null;
    }
  }
  static toBoolean(t6) {
    return Boolean(t6);
  }
  static toString(t6) {
    return d2(t6);
  }
  static toNumber(t6) {
    const e6 = Number(t6);
    if (isNaN(e6)) throw new Error(`"${t6}" is not a number`);
    return e6;
  }
  static toColor(e6) {
    if (e6 instanceof u) return e6;
    if ("string" == typeof e6) {
      const r3 = u.fromString(e6);
      if (r3) return r3;
      throw new Error(`"${e6}" is not a color`);
    }
    if (Array.isArray(e6)) return u.fromArray(e6);
    throw new Error(`"${e6}" is not a color`);
  }
};
_lt.types = { "to-boolean": i3, "to-color": o, "to-number": e4, "to-string": t4 };
var lt = _lt;
var ut = class _ut {
  constructor(t6) {
    this._val = t6, this.type = l(t6);
  }
  static parse(t6) {
    if (2 !== t6.length) throw new Error('"literal" expects 1 argument');
    return new _ut(t6[1]);
  }
  evaluate(t6, e6) {
    return this._val;
  }
};
var ct = class _ct {
  constructor(t6) {
    this._arg = t6, this.type = t4;
  }
  static parse(t6, e6) {
    if (2 !== t6.length) throw new Error('"typeof" expects 1 argument');
    return new _ct(ht(t6[1], e6));
  }
  evaluate(t6, e6) {
    return k(l(this._arg.evaluate(t6, e6)));
  }
};
function ht(t6, e6, r3) {
  const s2 = typeof t6;
  if ("string" === s2 || "boolean" === s2 || "number" === s2 || null === t6) {
    if (r3) switch (r3.kind) {
      case "string":
        "string" !== s2 && (t6 = lt.toString(t6));
        break;
      case "number":
        "number" !== s2 && (t6 = lt.toNumber(t6));
        break;
      case "color":
        t6 = lt.toColor(t6);
    }
    t6 = ["literal", t6];
  }
  if (!Array.isArray(t6) || 0 === t6.length) throw new Error("Expression must be a non empty array");
  const n2 = t6[0];
  if ("string" != typeof n2) throw new Error("First element of expression must be a string");
  const a6 = pt[n2];
  if (void 0 === a6) throw new Error(`Invalid expression operator "${n2}"`);
  if (!a6) throw new Error(`Unimplemented expression operator "${n2}"`);
  return a6.parse(t6, e6, r3);
}
var pt = { array: it, boolean: it, collator: null, format: null, image: null, literal: ut, number: it, "number-format": null, object: it, string: it, "to-boolean": lt, "to-color": lt, "to-number": lt, "to-string": lt, typeof: ct, accumulated: null, "feature-state": null, "geometry-type": v, id: _, "line-progress": null, properties: b2, at: O, get: T4, has: F, in: G, "index-of": V, length: D, slice: H, "!": q2, "!=": $, "<": M, "<=": k2, "==": E, ">": A, ">=": j, all: N2, any: R2, case: z, coalesce: I2, match: L, within: null, interpolate: U2, "interpolate-hcl": U2, "interpolate-lab": U2, step: B, let: S, var: P2, concat: rt, downcase: st, "is-supported-script": null, "resolved-locale": null, upcase: st, rgb: nt, rgba: at, "to-rgba": ot, "-": Q, "*": W, "/": X, "%": Y, "^": Z, "+": tt, abs: et, acos: et, asin: et, atan: et, ceil: et, cos: et, e: et, floor: et, ln: et, ln2: et, log10: et, log2: et, max: et, min: et, pi: et, round: et, sin: et, sqrt: et, tan: et, zoom: d3, "heatmap-density": null, "has-id": J, none: C2 };

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/style/Filter.js
var t5 = class _t {
  constructor(e6) {
    this._expression = e6;
  }
  filter(e6, r3) {
    if (!this._expression) return true;
    try {
      return this._expression.evaluate(e6, r3);
    } catch (t6) {
      return console.log(t6.message), true;
    }
  }
  static createFilter(n2) {
    if (!n2) return null;
    this.isLegacyFilter(n2) && (n2 = this.convertLegacyFilter(n2));
    try {
      const s2 = ht(n2, null, i3);
      return new _t(s2);
    } catch (s2) {
      return console.log(s2.message), null;
    }
  }
  static isLegacyFilter(e6) {
    if (!Array.isArray(e6)) return true;
    if (0 === e6.length) return true;
    switch (e6[0]) {
      case "==":
      case "!=":
      case ">":
      case "<":
      case ">=":
      case "<=":
        return 3 === e6.length && "string" == typeof e6[1] && !Array.isArray(e6[2]);
      case "in":
        return e6.length >= 3 && "string" == typeof e6[1] && !Array.isArray(e6[2]);
      case "!in":
      case "none":
      case "!has":
        return true;
      case "any":
      case "all":
        for (let r3 = 1; r3 < e6.length; r3++) if (this.isLegacyFilter(e6[r3])) return true;
        return false;
      case "has":
        return 2 === e6.length && ("$id" === e6[1] || "$type" === e6[1]);
      default:
        return false;
    }
  }
  static convertLegacyFilter(e6) {
    if (!Array.isArray(e6) || 0 === e6.length) return true;
    const r3 = e6[0];
    if (1 === e6.length) return "any" !== r3;
    switch (r3) {
      case "==":
        return _t.convertComparison("==", e6[1], e6[2]);
      case "!=":
        return _t.negate(_t.convertComparison("==", e6[1], e6[2]));
      case ">":
      case "<":
      case ">=":
      case "<=":
        return _t.convertComparison(r3, e6[1], e6[2]);
      case "in":
        return _t.convertIn(e6[1], e6.slice(2));
      case "!in":
        return _t.negate(_t.convertIn(e6[1], e6.slice(2)));
      case "any":
      case "all":
      case "none":
        return _t.convertCombining(r3, e6.slice(1));
      case "has":
        return _t.convertHas(e6[1]);
      case "!has":
        return _t.negate(_t.convertHas(e6[1]));
      default:
        throw new Error("Unexpected legacy filter.");
    }
  }
  static convertComparison(e6, r3, t6) {
    switch (r3) {
      case "$type":
        return [e6, ["geometry-type"], t6];
      case "$id":
        return [e6, ["id"], t6];
      default:
        return [e6, ["get", r3], t6];
    }
  }
  static convertIn(e6, r3) {
    switch (e6) {
      case "$type":
        return ["in", ["geometry-type"], ["literal", r3]];
      case "$id":
        return ["in", ["id"], ["literal", r3]];
      default:
        return ["in", ["get", e6], ["literal", r3]];
    }
  }
  static convertHas(e6) {
    switch (e6) {
      case "$type":
        return true;
      case "$id":
        return ["has-id"];
      default:
        return ["has", e6];
    }
  }
  static convertCombining(e6, r3) {
    return [e6].concat(r3.map(this.convertLegacyFilter));
  }
  static negate(e6) {
    return ["!", e6];
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/style/StyleDefinition.js
var _e2 = class _e2 {
};
_e2.backgroundLayoutDefinition = { visibility: { type: "enum", values: ["visible", "none"], default: 0 } };
_e2.fillLayoutDefinition = { visibility: { type: "enum", values: ["visible", "none"], default: 0 } };
_e2.lineLayoutDefinition = { visibility: { type: "enum", values: ["visible", "none"], default: 0 }, "line-cap": { type: "enum", values: ["butt", "round", "square"], default: 0 }, "line-join": { type: "enum", values: ["bevel", "round", "miter"], default: 2 }, "line-miter-limit": { type: "number", default: 2 }, "line-round-limit": { type: "number", default: 1.05 } };
_e2.symbolLayoutDefinition = { visibility: { type: "enum", values: ["visible", "none"], default: 0 }, "symbol-avoid-edges": { type: "boolean", default: false }, "symbol-placement": { type: "enum", values: ["point", "line", "line-center"], default: 0 }, "symbol-sort-key": { type: "number", default: -1 }, "symbol-spacing": { type: "number", minimum: 1, default: 250 }, "icon-allow-overlap": { type: "boolean", default: false }, "icon-anchor": { type: "enum", values: ["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"], default: 0 }, "icon-ignore-placement": { type: "boolean", default: false }, "icon-image": { type: "string" }, "icon-keep-upright": { type: "boolean", default: false }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0] }, "icon-optional": { type: "boolean", default: false }, "icon-padding": { type: "number", minimum: 0, default: 2 }, "icon-rotate": { type: "number", default: 0 }, "icon-rotation-alignment": { type: "enum", values: ["map", "viewport", "auto"], default: 2 }, "icon-size": { type: "number", minimum: 0, default: 1 }, "text-allow-overlap": { type: "boolean", default: false }, "text-anchor": { type: "enum", values: ["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"], default: 0 }, "text-field": { type: "string" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"] }, "text-ignore-placement": { type: "boolean", default: false }, "text-justify": { type: "enum", values: ["auto", "left", "center", "right"], default: 2 }, "text-keep-upright": { type: "boolean", default: true }, "text-letter-spacing": { type: "number", default: 0 }, "text-line-height": { type: "number", default: 1.2 }, "text-max-angle": { type: "number", minimum: 0, default: 45 }, "text-max-width": { type: "number", minimum: 0, default: 10 }, "text-offset": { type: "array", value: "number", length: 2, default: [0, 0] }, "text-optional": { type: "boolean", default: false }, "text-padding": { type: "number", minimum: 0, default: 2 }, "text-rotate": { type: "number", default: 0 }, "text-rotation-alignment": { type: "enum", values: ["map", "viewport", "auto"], default: 2 }, "text-size": { type: "number", minimum: 0, default: 16 }, "text-transform": { type: "enum", values: ["none", "uppercase", "lowercase"], default: 0 }, "text-writing-mode": { type: "array", value: "enum", values: ["horizontal", "vertical"], default: [0] } };
_e2.circleLayoutDefinition = { visibility: { type: "enum", values: ["visible", "none"], default: 0 } };
_e2.backgroundPaintDefinition = { "background-color": { type: "color", default: [0, 0, 0, 1] }, "background-opacity": { type: "number", minimum: 0, maximum: 1, default: 1 }, "background-pattern": { type: "string" } };
_e2.fillPaintDefinition = { "fill-antialias": { type: "boolean", default: true }, "fill-color": { type: "color", default: [0, 0, 0, 1] }, "fill-opacity": { type: "number", minimum: 0, maximum: 1, default: 1 }, "fill-outline-color": { type: "color", default: [0, 0, 0, 0] }, "fill-pattern": { type: "string" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0] }, "fill-translate-anchor": { type: "enum", values: ["map", "viewport"], default: 0 } };
_e2.linePaintDefinition = { "line-blur": { type: "number", minimum: 0, default: 0 }, "line-color": { type: "color", default: [0, 0, 0, 1] }, "line-dasharray": { type: "array", value: "number", default: [] }, "line-gap-width": { type: "number", minimum: 0, default: 0 }, "line-offset": { type: "number", default: 0 }, "line-opacity": { type: "number", minimum: 0, maximum: 1, default: 1 }, "line-pattern": { type: "string" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0] }, "line-translate-anchor": { type: "enum", values: ["map", "viewport"], default: 0 }, "line-width": { type: "number", minimum: 0, default: 1 } };
_e2.symbolPaintDefinition = { "icon-color": { type: "color", default: [0, 0, 0, 1] }, "icon-halo-blur": { type: "number", minimum: 0, default: 0 }, "icon-halo-color": { type: "color", default: [0, 0, 0, 0] }, "icon-halo-width": { type: "number", minimum: 0, default: 0 }, "icon-opacity": { type: "number", minimum: 0, maximum: 1, default: 1 }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0] }, "icon-translate-anchor": { type: "enum", values: ["map", "viewport"], default: 0 }, "text-color": { type: "color", default: [0, 0, 0, 1] }, "text-halo-blur": { type: "number", minimum: 0, default: 0 }, "text-halo-color": { type: "color", default: [0, 0, 0, 0] }, "text-halo-width": { type: "number", minimum: 0, default: 0 }, "text-opacity": { type: "number", minimum: 0, maximum: 1, default: 1 }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0] }, "text-translate-anchor": { type: "enum", values: ["map", "viewport"], default: 0 } };
_e2.rasterPaintDefinition = { "raster-opacity": { type: "number", minimum: 0, maximum: 1, default: 1 }, "raster-hue-rotate": { type: "number", default: 0 }, "raster-brightness-min": { type: "number", minimum: 0, maximum: 1, default: 0 }, "raster-brightness-max": { type: "number", minimum: 0, maximum: 1, default: 1 }, "raster-saturation": { type: "number", minimum: -1, maximum: 1, default: 0 }, "raster-contrast": { type: "number", minimum: -1, maximum: 1, default: 0 }, "raster-fade-duration": { type: "number", minimum: 0, default: 300 } };
_e2.circlePaintDefinition = { "circle-blur": { type: "number", minimum: 0, default: 0 }, "circle-color": { type: "color", default: [0, 0, 0, 1] }, "circle-opacity": { type: "number", minimum: 0, maximum: 1, default: 1 }, "circle-radius": { type: "number", minimum: 0, default: 5 }, "circle-stroke-color": { type: "color", default: [0, 0, 0, 1] }, "circle-stroke-opacity": { type: "number", minimum: 0, maximum: 1, default: 1 }, "circle-stroke-width": { type: "number", minimum: 0, default: 0 }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0] }, "circle-translate-anchor": { type: "enum", values: ["map", "viewport"], default: 0 } };
var e5 = _e2;

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/style/StyleProperty.js
var h = class _h {
  constructor(t6, e6) {
    let r3;
    switch (this.isDataDriven = false, this.interpolator = null, t6.type) {
      case "number":
      case "color":
        r3 = true;
        break;
      case "array":
        r3 = "number" === t6.value;
        break;
      default:
        r3 = false;
    }
    if ((null == e6 || "" === e6 && "color" === t6.type) && (e6 = t6.default), Array.isArray(e6) && e6.length > 0 && pt[e6[0]]) {
      const r4 = { number: e4, color: o, string: t4, boolean: i3, enum: t4 };
      try {
        const i4 = "array" === t6.type ? a5(r4[t6.value] || u2, t6.length) : r4[t6.type], n2 = ht(e6, null, i4);
        this.getValue = this._buildExpression(n2, t6), this.isDataDriven = true, n2 instanceof U2 && n2.input instanceof d3 && (this.interpolator = n2);
      } catch (h2) {
        console.log(h2.message), this.getValue = this._buildSimple(t6.default);
      }
      return;
    }
    r3 && "interval" === e6.type && (r3 = false);
    const m2 = e6?.stops && e6.stops.length > 0;
    if (m2) for (const i4 of e6.stops) i4[1] = this._validate(i4[1], t6);
    if (this.isDataDriven = !!e6 && !!e6.property, this.isDataDriven) if (void 0 !== e6.default && (e6.default = this._validate(e6.default, t6)), m2) switch (e6.type) {
      case "identity":
        this.getValue = this._buildIdentity(e6, t6);
        break;
      case "categorical":
        this.getValue = this._buildCategorical(e6, t6);
        break;
      default:
        this.getValue = r3 ? this._buildInterpolate(e6, t6) : this._buildInterval(e6, t6);
    }
    else this.getValue = this._buildIdentity(e6, t6);
    else m2 ? this.getValue = r3 ? this._buildZoomInterpolate(e6) : this._buildZoomInterval(e6) : (e6 = this._validate(e6, t6), this.getValue = this._buildSimple(e6));
  }
  _validate(t6, e6) {
    if ("number" === e6.type) {
      if (null != e6.minimum && t6 < e6.minimum) return e6.minimum;
      if (null != e6.maximum && t6 > e6.maximum) return e6.maximum;
    } else "color" === e6.type ? t6 = _h._parseColor(t6) : "enum" === e6.type ? "string" == typeof t6 && (t6 = e6.values.indexOf(t6)) : "array" === e6.type && "enum" === e6.value ? t6 = t6.map((t7) => "string" == typeof t7 ? e6.values.indexOf(t7) : t7) : "string" === e6.type && (t6 = d2(t6));
    return t6;
  }
  _buildSimple(t6) {
    return () => t6;
  }
  _buildExpression(t6, e6) {
    return (r3, i4) => {
      try {
        const l3 = t6.evaluate(i4, r3);
        return void 0 === l3 ? e6.default : this._validate(l3, e6);
      } catch (l3) {
        return console.log(l3.message), e6.default;
      }
    };
  }
  _buildIdentity(t6, e6) {
    return (r3, i4) => {
      let l3;
      return i4 && (l3 = i4.values[t6.property]), void 0 !== l3 && (l3 = this._validate(l3, e6)), null != l3 ? l3 : void 0 !== t6.default ? t6.default : e6.default;
    };
  }
  _buildCategorical(t6, e6) {
    return (r3, i4) => {
      let l3;
      return i4 && (l3 = i4.values[t6.property]), l3 = this._categorical(l3, t6.stops), void 0 !== l3 ? l3 : void 0 !== t6.default ? t6.default : e6.default;
    };
  }
  _buildInterval(t6, e6) {
    return (r3, i4) => {
      let l3;
      return i4 && (l3 = i4.values[t6.property]), "number" == typeof l3 ? this._interval(l3, t6.stops) : void 0 !== t6.default ? t6.default : e6.default;
    };
  }
  _buildInterpolate(t6, e6) {
    return (r3, i4) => {
      let l3;
      return i4 && (l3 = i4.values[t6.property]), "number" == typeof l3 ? this._interpolate(l3, t6.stops, t6.base || 1) : void 0 !== t6.default ? t6.default : e6.default;
    };
  }
  _buildZoomInterpolate(t6) {
    return (e6) => this._interpolate(e6, t6.stops, t6.base || 1);
  }
  _buildZoomInterval(t6) {
    return (e6) => this._interval(e6, t6.stops);
  }
  _categorical(t6, e6) {
    const r3 = e6.length;
    for (let i4 = 0; i4 < r3; i4++) if (e6[i4][0] === t6) return e6[i4][1];
  }
  _interval(t6, e6) {
    const r3 = e6.length;
    let i4 = 0;
    for (let l3 = 0; l3 < r3 && e6[l3][0] <= t6; l3++) i4 = l3;
    return e6[i4][1];
  }
  _interpolate(t6, e6, i4) {
    let l3, s2;
    const a6 = e6.length;
    for (let r3 = 0; r3 < a6; r3++) {
      const i5 = e6[r3];
      if (!(i5[0] <= t6)) {
        s2 = i5;
        break;
      }
      l3 = i5;
    }
    if (l3 && s2) {
      const e7 = s2[0] - l3[0], a7 = t6 - l3[0], o2 = 1 === i4 ? a7 / e7 : (i4 ** a7 - 1) / (i4 ** e7 - 1);
      if (Array.isArray(l3[1])) {
        const t7 = l3[1], e8 = s2[1], i5 = [];
        for (let l4 = 0; l4 < t7.length; l4++) i5.push(p(t7[l4], e8[l4], o2));
        return i5;
      }
      return p(l3[1], s2[1], o2);
    }
    return l3 ? l3[1] : s2 ? s2[1] : void 0;
  }
  static _isEmpty(t6) {
    for (const e6 in t6) if (t6.hasOwnProperty(e6)) return false;
    return true;
  }
  static _parseColor(r3) {
    return Array.isArray(r3) ? r3 : "string" == typeof r3 ? d(r3) ?? void 0 : r3 instanceof u && !this._isEmpty(r3) ? u.toUnitRGBA(r3) : void 0;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/style/StyleLayer.js
var D2 = class {
  constructor(t6, i4, e6, a6, o2, r3) {
    this.layer = t6, this.feature = i4, this.bounds = e6, this.normalizationRatio = a6, this.normalizationOffsetX = o2, this.normalizationOffsetY = r3;
  }
};
var m = class {
  constructor(t6, i4, e6, a6) {
    switch (this.type = t6, this.typeName = i4.type, this.id = i4.id, this.source = i4.source, this.sourceLayer = i4["source-layer"], this.minzoom = i4.minzoom, this.maxzoom = i4.maxzoom, this.filter = i4.filter, this.layout = i4.layout, this.paint = i4.paint, this.z = e6, this.uid = a6, t6) {
      case 0:
        this._layoutDefinition = e5.backgroundLayoutDefinition, this._paintDefinition = e5.backgroundPaintDefinition;
        break;
      case 1:
        this._layoutDefinition = e5.fillLayoutDefinition, this._paintDefinition = e5.fillPaintDefinition;
        break;
      case 2:
        this._layoutDefinition = e5.lineLayoutDefinition, this._paintDefinition = e5.linePaintDefinition;
        break;
      case 3:
        this._layoutDefinition = e5.symbolLayoutDefinition, this._paintDefinition = e5.symbolPaintDefinition;
        break;
      case 4:
        this._layoutDefinition = e5.circleLayoutDefinition, this._paintDefinition = e5.circlePaintDefinition;
    }
    this._layoutProperties = this._parseLayout(this.layout), this._paintProperties = this._parsePaint(this.paint);
  }
  getFeatureFilter() {
    return void 0 !== this._featureFilter ? this._featureFilter : this._featureFilter = t5.createFilter(this.filter);
  }
  getLayoutProperty(t6) {
    return this._layoutProperties[t6];
  }
  getPaintProperty(t6) {
    return this._paintProperties[t6];
  }
  getLayoutValue(t6, i4, e6) {
    let a6;
    const o2 = this._layoutProperties[t6];
    return o2 && (a6 = o2.getValue(i4, e6)), void 0 === a6 && (a6 = this._layoutDefinition[t6].default), a6;
  }
  getPaintValue(t6, i4, e6) {
    let a6;
    const o2 = this._paintProperties[t6];
    return o2 && (a6 = o2.getValue(i4, e6)), void 0 === a6 && (a6 = this._paintDefinition[t6].default), a6;
  }
  isPainterDataDriven() {
    const t6 = this._paintProperties;
    if (t6) {
      for (const i4 in t6) if (t6[i4].isDataDriven) return true;
    }
    return false;
  }
  isIntersectingFeature(t6, i4, e6, a6, o2, r3, n2) {
    return false;
  }
  getFeatureInflatedBounds(t6, i4, e6, a6) {
    return null;
  }
  _parseLayout(t6) {
    const i4 = {};
    for (const e6 in t6) {
      const a6 = this._layoutDefinition[e6];
      a6 && (i4[e6] = new h(a6, t6[e6]));
    }
    return i4;
  }
  _parsePaint(t6) {
    const i4 = {};
    for (const e6 in t6) {
      const a6 = this._paintDefinition[e6];
      a6 && (i4[e6] = new h(a6, t6[e6]));
    }
    return i4;
  }
  computeAttributesKey(t6, i4, e6, a6) {
    let o2 = 0, r3 = 0;
    for (const n2 of i4) {
      let t7 = 3;
      if (!n2 || n2 !== a6) {
        const i5 = e6[n2], { isLayout: a7, isOptional: o3 } = i5, r4 = a7 ? this.getLayoutProperty(n2) : this.getPaintProperty(n2);
        t7 = r4?.interpolator ? 2 : r4?.isDataDriven ? 1 : o3 && !r4 ? 3 : 0;
      }
      r3 |= t7 << o2, o2 += 2;
    }
    return r3 << 3 | t6;
  }
};
var d4 = class extends m {
  constructor(t6, i4, e6, a6) {
    super(t6, i4, e6, a6), this.backgroundMaterial = new T2(this.computeAttributesKey(0, T2.ATTRIBUTES, T2.ATTRIBUTES_INFO));
  }
};
var _2 = class extends m {
  constructor(t6, i4, e6, a6) {
    super(t6, i4, e6, a6);
    const o2 = this.getPaintProperty("fill-color"), r3 = this.getPaintProperty("fill-opacity"), n2 = this.getPaintProperty("fill-pattern");
    this.hasDataDrivenColor = o2?.isDataDriven, this.hasDataDrivenOpacity = r3?.isDataDriven, this.hasDataDrivenFill = this.hasDataDrivenColor || this.hasDataDrivenOpacity || n2?.isDataDriven;
    const s2 = this.getPaintProperty("fill-outline-color");
    this.outlineUsesFillColor = !s2, this.hasDataDrivenOutlineColor = s2?.isDataDriven, this.hasDataDrivenOutline = s2 ? s2.isDataDriven : !!o2 && o2.isDataDriven, this.hasDataDrivenOutline = (s2 ? this.hasDataDrivenOutlineColor : this.hasDataDrivenColor) || this.hasDataDrivenOpacity, this.fillMaterial = new T3(this.computeAttributesKey(1, T3.ATTRIBUTES, T3.ATTRIBUTES_INFO)), this.outlineMaterial = new e3(this.computeAttributesKey(2, this.outlineUsesFillColor ? e3.ATTRIBUTES_FILL : e3.ATTRIBUTES_OUTLINE, this.outlineUsesFillColor ? e3.ATTRIBUTES_INFO_FILL : e3.ATTRIBUTES_INFO_OUTLINE), this.outlineUsesFillColor);
  }
  getFeatureInflatedBounds(t6, i4, e6, a6) {
    const o2 = z2(t6);
    if (!o2) return null;
    const r3 = this.getPaintValue("fill-translate", i4, t6), n2 = a6 * Math.max(r3[0], r3[1]);
    return o2[0] -= n2, o2[2] -= n2, o2[1] += n2, o2[3] += n2, o2;
  }
  isIntersectingFeature(t6, a6, n2, s2, l3, h2, u3) {
    const p2 = s2.getGeometry();
    if (!p2) return false;
    const g = c / u3.normalizationRatio;
    t6 = t6 / u3.normalizationRatio + u3.normalizationOffsetX, a6 = a6 / u3.normalizationRatio + u3.normalizationOffsetY;
    const c5 = b(this.getPaintValue("fill-translate", l3, s2), this.getPaintValue("fill-translate-anchor", l3, s2), h2, c);
    t6 -= g * c5.x, a6 -= g * c5.y;
    return !!I(t6, a6, p2) || N(t6, a6, p2, g * n2);
  }
};
var L2 = class extends m {
  constructor(t6, i4, e6, a6) {
    super(t6, i4, e6, a6);
    const o2 = this.getPaintProperty("line-pattern");
    if (this.lineMaterial = new a3(this.computeAttributesKey(3, a3.ATTRIBUTES, a3.ATTRIBUTES_INFO, o2 ? "line-dasharray" : "")), this.hasDataDrivenLine = this.getPaintProperty("line-blur")?.isDataDriven || this.getPaintProperty("line-color")?.isDataDriven || this.getPaintProperty("line-gap-width")?.isDataDriven || this.getPaintProperty("line-offset")?.isDataDriven || this.getPaintProperty("line-opacity")?.isDataDriven || this.getPaintProperty("line-pattern")?.isDataDriven || this.getPaintProperty("line-dasharray")?.isDataDriven || this.getLayoutProperty("line-cap")?.isDataDriven || this.getPaintProperty("line-width")?.isDataDriven, this.canUseThinTessellation = false, !this.hasDataDrivenLine) {
      const t7 = this.getPaintProperty("line-width");
      if (!t7 || "number" == typeof t7 && 0.5 * t7 < T) {
        const t8 = this.getPaintProperty("line-offset");
        (!t8 || "number" == typeof t8 && 0 === t8) && (this.canUseThinTessellation = true);
      }
    }
  }
  getDashKey(t6, i4) {
    let e6;
    switch (i4) {
      case 0:
      default:
        e6 = "Butt";
        break;
      case 1:
        e6 = "Round";
        break;
      case 2:
        e6 = "Square";
    }
    return `dasharray-[${t6.toString()}]-${e6}`;
  }
  getFeatureInflatedBounds(t6, i4, e6, a6) {
    const o2 = z2(t6);
    if (!o2) return null;
    const r3 = this.getPaintValue("line-translate", i4, t6), n2 = a6 * Math.max(r3[0], r3[1]);
    o2[0] -= n2, o2[2] -= n2, o2[1] += n2, o2[3] += n2;
    const s2 = a6 * Math.abs(this.getPaintValue("line-offset", i4, t6) || 0), l3 = a6 * (this.getPaintValue("line-width", i4, t6) / 2);
    return o2[0] -= s2 + l3, o2[1] -= s2 + l3, o2[2] += s2 + l3, o2[3] += s2 + l3, o2;
  }
  isIntersectingFeature(t6, r3, n2, s2, l3, h2, u3) {
    let p2 = s2.getGeometry();
    if (!p2) return false;
    const g = c / u3.normalizationRatio;
    t6 = t6 / u3.normalizationRatio + u3.normalizationOffsetX, r3 = r3 / u3.normalizationRatio + u3.normalizationOffsetY;
    const c5 = b(this.getPaintValue("line-translate", l3, s2), this.getPaintValue("line-translate-anchor", l3, s2), h2, c);
    t6 -= g * c5.x, r3 -= g * c5.y;
    const y3 = g * this.getPaintValue("line-offset", l3, s2) || 0;
    0 !== y3 && (p2 = P(p2, -y3));
    const P3 = this.getPaintValue("line-width", l3, s2);
    return N(t6, r3, p2, g * (n2 + P3 / 2));
  }
};
var v2 = class extends m {
  constructor(t6, i4, e6, a6) {
    super(t6, i4, e6, a6), this.iconMaterial = new c3(this.computeAttributesKey(4, c3.ATTRIBUTES, c3.ATTRIBUTES_INFO)), this.textMaterial = new r(this.computeAttributesKey(6, r.ATTRIBUTES, r.ATTRIBUTES_INFO)), this.hasDataDrivenIcon = this.getPaintProperty("icon-color")?.isDataDriven || this.getPaintProperty("icon-halo-blur")?.isDataDriven || this.getPaintProperty("icon-halo-color")?.isDataDriven || this.getPaintProperty("icon-halo-width")?.isDataDriven || this.getPaintProperty("icon-opacity")?.isDataDriven || this.getLayoutProperty("icon-size")?.isDataDriven, this.hasDataDrivenText = this.getPaintProperty("text-color")?.isDataDriven || this.getPaintProperty("text-halo-blur")?.isDataDriven || this.getPaintProperty("text-halo-color")?.isDataDriven || this.getPaintProperty("text-halo-width")?.isDataDriven || this.getPaintProperty("text-opacity")?.isDataDriven || this.getLayoutProperty("text-size")?.isDataDriven;
  }
};
var x2 = class extends m {
  constructor(t6, i4, e6, a6) {
    super(t6, i4, e6, a6), this.circleMaterial = new c2(this.computeAttributesKey(5, c2.ATTRIBUTES, c2.ATTRIBUTES_INFO));
  }
  getFeatureInflatedBounds(t6, e6, a6, o2) {
    const r3 = z2(t6);
    if (!r3) return null;
    const n2 = this.getPaintValue("circle-translate", e6, t6), s2 = Math.max(n2[0], n2[1]);
    r3[0] -= s2, r3[2] -= s2, r3[1] += s2, r3[3] += s2;
    const l3 = o2 * (c * (this.getPaintValue("circle-radius", e6, t6) + this.getPaintValue("circle-stroke-width", e6, t6)) / 2);
    return r3[0] -= l3, r3[1] -= l3, r3[2] += l3, r3[3] += l3, r3;
  }
  isIntersectingFeature(t6, a6, o2, r3, n2, s2, l3) {
    const h2 = r3.getGeometry();
    if (!h2) return false;
    const u3 = c / l3.normalizationRatio;
    t6 = t6 / l3.normalizationRatio + l3.normalizationOffsetX, a6 = a6 / l3.normalizationRatio + l3.normalizationOffsetY, o2 *= u3;
    const p2 = b(this.getPaintValue("circle-translate", n2, r3), this.getPaintValue("circle-translate-anchor", n2, r3), s2, u3), g = u3 * (this.getPaintValue("circle-radius", n2, r3) + this.getPaintValue("circle-stroke-width", n2, r3));
    let c5, y3;
    for (const i4 of h2) if (i4) for (const e6 of i4) {
      c5 = e6.x + p2.x, y3 = e6.y + p2.y;
      if (Math.sqrt((t6 - c5) * (t6 - c5) + (a6 - y3) * (a6 - y3)) - o2 <= g) return true;
    }
    return false;
  }
};
var V2 = class {
  constructor(t6, i4, e6) {
    let a6;
    this.allowOverlap = t6.getLayoutValue("icon-allow-overlap", i4), this.ignorePlacement = t6.getLayoutValue("icon-ignore-placement", i4), this.keepUpright = t6.getLayoutValue("icon-keep-upright", i4), this.optional = t6.getLayoutValue("icon-optional", i4), this.rotationAlignment = t6.getLayoutValue("icon-rotation-alignment", i4), 2 === this.rotationAlignment && (this.rotationAlignment = e6 ? 0 : 1), a6 = t6.getLayoutProperty("icon-anchor"), a6?.isDataDriven ? this._anchorProp = a6 : this.anchor = t6.getLayoutValue("icon-anchor", i4), a6 = t6.getLayoutProperty("icon-offset"), a6?.isDataDriven ? this._offsetProp = a6 : this.offset = t6.getLayoutValue("icon-offset", i4), a6 = t6.getLayoutProperty("icon-padding"), a6?.isDataDriven ? this._paddingProp = a6 : this.padding = t6.getLayoutValue("icon-padding", i4), a6 = t6.getLayoutProperty("icon-rotate"), a6?.isDataDriven ? this._rotateProp = a6 : this.rotate = t6.getLayoutValue("icon-rotate", i4), a6 = t6.getLayoutProperty("icon-size"), a6?.isDataDriven ? this._sizeProp = a6 : this.size = t6.getLayoutValue("icon-size", i4);
  }
  update(t6, i4) {
    this._anchorProp && (this.anchor = this._anchorProp.getValue(t6, i4)), this._offsetProp && (this.offset = this._offsetProp.getValue(t6, i4)), this._paddingProp && (this.padding = this._paddingProp.getValue(t6, i4)), this._rotateProp && (this.rotate = this._rotateProp.getValue(t6, i4)), this._sizeProp && (this.size = this._sizeProp.getValue(t6, i4));
  }
};
var T5 = class {
  constructor(t6, i4, e6) {
    let a6;
    this.allowOverlap = t6.getLayoutValue("text-allow-overlap", i4), this.ignorePlacement = t6.getLayoutValue("text-ignore-placement", i4), this.keepUpright = t6.getLayoutValue("text-keep-upright", i4), this.optional = t6.getLayoutValue("text-optional", i4), this.rotationAlignment = t6.getLayoutValue("text-rotation-alignment", i4), 2 === this.rotationAlignment && (this.rotationAlignment = e6 ? 0 : 1), a6 = t6.getLayoutProperty("text-anchor"), a6?.isDataDriven ? this._anchorProp = a6 : this.anchor = t6.getLayoutValue("text-anchor", i4), a6 = t6.getLayoutProperty("text-justify"), a6?.isDataDriven ? this._justifyProp = a6 : this.justify = t6.getLayoutValue("text-justify", i4), a6 = t6.getLayoutProperty("text-letter-spacing"), a6?.isDataDriven ? this._letterSpacingProp = a6 : this.letterSpacing = t6.getLayoutValue("text-letter-spacing", i4), a6 = t6.getLayoutProperty("text-line-height"), a6?.isDataDriven ? this._lineHeightProp = a6 : this.lineHeight = t6.getLayoutValue("text-line-height", i4), a6 = t6.getLayoutProperty("text-max-angle"), a6?.isDataDriven ? this._maxAngleProp = a6 : this.maxAngle = t6.getLayoutValue("text-max-angle", i4), a6 = t6.getLayoutProperty("text-max-width"), a6?.isDataDriven ? this._maxWidthProp = a6 : this.maxWidth = t6.getLayoutValue("text-max-width", i4), a6 = t6.getLayoutProperty("text-offset"), a6?.isDataDriven ? this._offsetProp = a6 : this.offset = t6.getLayoutValue("text-offset", i4), a6 = t6.getLayoutProperty("text-padding"), a6?.isDataDriven ? this._paddingProp = a6 : this.padding = t6.getLayoutValue("text-padding", i4), a6 = t6.getLayoutProperty("text-rotate"), a6?.isDataDriven ? this._rotateProp = a6 : this.rotate = t6.getLayoutValue("text-rotate", i4), a6 = t6.getLayoutProperty("text-size"), a6?.isDataDriven ? this._sizeProp = a6 : this.size = t6.getLayoutValue("text-size", i4), a6 = t6.getLayoutProperty("text-writing-mode"), a6?.isDataDriven ? this._writingModeProp = a6 : this.writingMode = t6.getLayoutValue("text-writing-mode", i4);
  }
  update(t6, i4) {
    this._anchorProp && (this.anchor = this._anchorProp.getValue(t6, i4)), this._justifyProp && (this.justify = this._justifyProp.getValue(t6, i4)), this._letterSpacingProp && (this.letterSpacing = this._letterSpacingProp.getValue(t6, i4)), this._lineHeightProp && (this.lineHeight = this._lineHeightProp.getValue(t6, i4)), this._maxAngleProp && (this.maxAngle = this._maxAngleProp.getValue(t6, i4)), this._maxWidthProp && (this.maxWidth = this._maxWidthProp.getValue(t6, i4)), this._offsetProp && (this.offset = this._offsetProp.getValue(t6, i4)), this._paddingProp && (this.padding = this._paddingProp.getValue(t6, i4)), this._rotateProp && (this.rotate = this._rotateProp.getValue(t6, i4)), this._sizeProp && (this.size = this._sizeProp.getValue(t6, i4)), this._writingModeProp && (this.writingMode = this._writingModeProp.getValue(t6, i4));
  }
};
function z2(i4) {
  const e6 = i4?.getGeometry();
  if (null == e6) return null;
  let a6 = 1 / 0, o2 = 1 / 0, r3 = -1 / 0, n2 = -1 / 0;
  for (const t6 of e6) if (t6) for (const i5 of t6) a6 = Math.min(a6, i5.x), o2 = Math.min(o2, i5.y), r3 = Math.max(r3, i5.x), n2 = Math.max(n2, i5.y);
  return e(a6, o2, r3, n2);
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/style/StyleRepository.js
var l2 = class _l {
  constructor(t6, r3 = true) {
    if (this.backgroundBucketIds = [], this._uidToLayer = /* @__PURE__ */ new Map(), this._layerByName = {}, this._runningId = 0, this._style = r3 ? a(t6) : t6, this._style.layers || (this._style.layers = []), this.version = parseFloat(this._style.version), this.layers = this._style.layers.map((e6, t7, r4) => this._create(e6, t7, r4)).filter((e6) => !!e6), this.layers) for (let e6 = 0; e6 < this.layers.length; e6++) {
      const t7 = this.layers[e6];
      this._layerByName[t7.id] = t7, this._uidToLayer.set(t7.uid, t7), 0 === t7.type && this.backgroundBucketIds.push(t7.id);
    }
    this._identifyRefLayers();
  }
  getLayerStyleProperties(e6, t6) {
    const r3 = this.getStyleLayerByUID(e6), a6 = 0 !== r3?.getLayoutValue("symbol-placement", t6);
    let i4 = r3?.getLayoutValue("icon-rotation-alignment", t6);
    2 === i4 && (i4 = a6 ? 0 : 1);
    let s2 = r3?.getLayoutValue("text-rotation-alignment", t6);
    2 === s2 && (s2 = a6 ? 0 : 1);
    const l3 = r3?.getPaintValue("icon-translate", t6), n2 = r3?.getPaintValue("icon-translate-anchor", t6), y3 = r3?.getPaintValue("text-translate", t6), o2 = r3?.getPaintValue("text-translate-anchor", t6);
    return { geometryType: null, iconAllowOverlap: r3?.getLayoutValue("icon-allow-overlap", t6), iconIgnorePlacement: r3?.getLayoutValue("icon-ignore-placement", t6), textAllowOverlap: r3?.getLayoutValue("text-allow-overlap", t6), textIgnorePlacement: r3?.getLayoutValue("text-ignore-placement", t6), iconRotationAlignment: i4, textRotationAlignment: s2, iconTranslateAnchor: n2, iconTranslate: l3, textTranslateAnchor: o2, textTranslate: y3 };
  }
  isPainterDataDriven(e6) {
    const t6 = this._layerByName[e6];
    return !!t6 && t6.isPainterDataDriven();
  }
  getStyleLayerId(e6) {
    return e6 >= this.layers.length ? null : this.layers[e6].id;
  }
  getStyleLayerByUID(e6) {
    return this._uidToLayer.get(e6) ?? null;
  }
  getStyleLayerIndex(e6) {
    const t6 = this._layerByName[e6];
    return t6 ? this.layers.indexOf(t6) : -1;
  }
  setStyleLayer(e6, t6) {
    if (!e6?.id) return;
    const r3 = this._style;
    null != t6 && t6 >= this.layers.length && (t6 = this.layers.length - 1);
    let a6, i4 = true;
    const s2 = this._layerByName[e6.id];
    if (s2) {
      const n2 = this.layers.indexOf(s2);
      t6 || (t6 = n2), t6 === n2 ? (i4 = false, a6 = _l._recreateLayer(e6, s2), this.layers[t6] = a6, r3.layers[t6] = e6) : (this.layers.splice(n2, 1), r3.layers.splice(n2, 1), a6 = this._create(e6, t6, this.layers), this.layers.splice(t6, 0, a6), r3.layers.splice(t6, 0, e6));
    } else a6 = this._create(e6, t6, this.layers), !t6 || t6 >= this.layers.length ? (this.layers.push(a6), r3.layers.push(e6)) : (this.layers.splice(t6, 0, a6), r3.layers.splice(t6, 0, e6));
    this._layerByName[e6.id] = a6, this._uidToLayer.set(a6.uid, a6), i4 && this._recomputeZValues(), this._identifyRefLayers();
  }
  getStyleLayer(e6) {
    const t6 = this._layerByName[e6];
    return t6 ? { type: t6.typeName, id: t6.id, source: t6.source, "source-layer": t6.sourceLayer, minzoom: t6.minzoom, maxzoom: t6.maxzoom, filter: t6.filter, layout: t6.layout, paint: t6.paint } : null;
  }
  deleteStyleLayer(e6) {
    const t6 = this._layerByName[e6];
    if (t6) {
      delete this._layerByName[e6], this._uidToLayer.delete(t6.uid);
      const r3 = this.layers.indexOf(t6);
      this.layers.splice(r3, 1), this._style.layers.splice(r3, 1), this._recomputeZValues(), this._identifyRefLayers();
    }
  }
  getLayerById(e6) {
    return this._layerByName[e6];
  }
  getLayoutProperties(e6) {
    const t6 = this._layerByName[e6];
    return t6 ? t6.layout : null;
  }
  getPaintProperties(e6) {
    const t6 = this._layerByName[e6];
    return t6 ? t6.paint : null;
  }
  setPaintProperties(e6, t6) {
    const r3 = this._layerByName[e6];
    if (!r3) return;
    const a6 = { type: r3.typeName, id: r3.id, source: r3.source, "source-layer": r3.sourceLayer, minzoom: r3.minzoom, maxzoom: r3.maxzoom, filter: r3.filter, layout: r3.layout, paint: t6 }, i4 = _l._recreateLayer(a6, r3), s2 = this.layers.indexOf(r3);
    this.layers[s2] = i4, this._style.layers[s2].paint = t6, this._layerByName[r3.id] = i4, this._uidToLayer.set(r3.uid, i4);
  }
  setLayoutProperties(e6, t6) {
    const r3 = this._layerByName[e6];
    if (!r3) return;
    const a6 = { type: r3.typeName, id: r3.id, source: r3.source, "source-layer": r3.sourceLayer, minzoom: r3.minzoom, maxzoom: r3.maxzoom, filter: r3.filter, layout: t6, paint: r3.paint }, i4 = _l._recreateLayer(a6, r3), s2 = this.layers.indexOf(r3);
    this.layers[s2] = i4, this._style.layers[s2].layout = t6, this._layerByName[r3.id] = i4, this._uidToLayer.set(r3.uid, i4);
  }
  setStyleLayerVisibility(e6, t6) {
    const r3 = this._layerByName[e6];
    if (!r3) return;
    const a6 = r3.layout || {};
    a6.visibility = t6;
    const i4 = { type: r3.typeName, id: r3.id, source: r3.source, "source-layer": r3.sourceLayer, minzoom: r3.minzoom, maxzoom: r3.maxzoom, filter: r3.filter, layout: a6, paint: r3.paint }, s2 = _l._recreateLayer(i4, r3), n2 = this.layers.indexOf(r3);
    this.layers[n2] = s2, this._style.layers[n2].layout = a6, this._layerByName[r3.id] = s2, this._uidToLayer.set(r3.uid, s2);
  }
  getStyleLayerVisibility(e6) {
    const t6 = this._layerByName[e6];
    if (!t6) return "none";
    const r3 = t6.layout;
    return r3?.visibility ?? "visible";
  }
  _recomputeZValues() {
    const e6 = this.layers, t6 = 1 / (e6.length + 1);
    for (let r3 = 0; r3 < e6.length; r3++) e6[r3].z = 1 - (1 + r3) * t6;
  }
  _identifyRefLayers() {
    const e6 = [], t6 = [];
    let r3 = 0;
    for (const a6 of this.layers) {
      const i4 = a6.layout;
      if (1 === a6.type) {
        const t7 = a6;
        let s2 = a6.source + "|" + a6.sourceLayer;
        s2 += "|" + (i4?.visibility ?? ""), s2 += "|" + a6.minzoom, s2 += "|" + a6.maxzoom, s2 += "|" + JSON.stringify(a6.filter), (t7.hasDataDrivenFill || t7.hasDataDrivenOutline) && (s2 += "|" + r3), e6.push({ key: s2, layer: a6 });
      } else if (2 === a6.type) {
        const e7 = a6, s2 = a6.paint, l3 = null != s2 && (null != s2["line-pattern"] || null != s2["line-dasharray"]);
        let n2 = a6.source + "|" + a6.sourceLayer;
        n2 += "|" + (i4?.visibility ?? ""), n2 += "|" + a6.minzoom, n2 += "|" + a6.maxzoom, n2 += "|" + JSON.stringify(a6.filter), n2 += "|" + (void 0 !== i4 ? i4["line-cap"] : ""), n2 += "|" + (void 0 !== i4 ? i4["line-join"] : ""), (e7.hasDataDrivenLine || l3) && (n2 += "|" + r3), t6.push({ key: n2, layer: a6 });
      }
      ++r3;
    }
    this._assignRefLayers(e6), this._assignRefLayers(t6);
  }
  _assignRefLayers(e6) {
    let t6, r3;
    e6.sort((e7, t7) => e7.key < t7.key ? -1 : e7.key > t7.key ? 1 : 0);
    const a6 = e6.length;
    for (let i4 = 0; i4 < a6; i4++) {
      const s2 = e6[i4];
      if (s2.key === t6) s2.layer.refLayerId = r3;
      else if (t6 = s2.key, r3 = s2.layer.id, 1 === s2.layer.type) {
        if (!s2.layer.getPaintProperty("fill-outline-color")) for (let l3 = i4 + 1; l3 < a6; l3++) {
          const a7 = e6[l3];
          if (a7.key !== t6) break;
          if (a7.layer.getPaintProperty("fill-outline-color")) {
            e6[i4] = a7, e6[l3] = s2, r3 = a7.layer.id;
            break;
          }
        }
      } else if (2 === s2.layer.type) {
        let l3 = s2.layer;
        for (let n2 = i4 + 1; n2 < a6; n2++) {
          const a7 = e6[n2];
          if (a7.key !== t6) break;
          const y3 = a7.layer;
          (l3.canUseThinTessellation && !y3.canUseThinTessellation || !l3.canUseThinTessellation && (y3.getPaintProperty("line-pattern") || y3.getPaintProperty("line-dasharray"))) && (l3 = y3, e6[i4] = a7, e6[n2] = s2, r3 = a7.layer.id);
        }
      }
    }
  }
  _create(e6, l3, n2) {
    const y3 = 1 - (1 + l3) * (1 / (n2.length + 1)), o2 = this._runningId++;
    switch (e6.type) {
      case "background":
        return new d4(0, e6, y3, o2);
      case "fill":
        return new _2(1, e6, y3, o2);
      case "line":
        return new L2(2, e6, y3, o2);
      case "symbol":
        return new v2(3, e6, y3, o2);
      case "raster":
        return console.warn(`Unsupported vector tile raster layer ${e6.id}`), null;
      case "circle":
        return new x2(4, e6, y3, o2);
    }
    return null;
  }
  static _recreateLayer(e6, l3) {
    switch (e6.type) {
      case "background":
        return new d4(0, e6, l3.z, l3.uid);
      case "fill":
        return new _2(1, e6, l3.z, l3.uid);
      case "line":
        return new L2(2, e6, l3.z, l3.uid);
      case "symbol":
        return new v2(3, e6, l3.z, l3.uid);
      case "raster":
        return console.warn(`Unsupported vector tile raster layer ${e6.id}`), null;
      case "circle":
        return new x2(4, e6, l3.z, l3.uid);
    }
    return null;
  }
};

export {
  t3 as t,
  D2 as D,
  V2 as V,
  T5 as T,
  l2 as l
};
//# sourceMappingURL=chunk-PG6JVA4Q.js.map
