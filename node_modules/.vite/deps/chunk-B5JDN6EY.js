import {
  d
} from "./chunk-XL5QPCXN.js";
import {
  O
} from "./chunk-YDTPM7OQ.js";
import {
  a as a2
} from "./chunk-2OFHDVO5.js";
import {
  a,
  c,
  l,
  u3 as u,
  y
} from "./chunk-GNMPGHLQ.js";

// node_modules/@arcgis/core/core/mapCollectionUtils.js
function c2(e, o, s) {
  const r = s?.createCollection?.() ?? new O(), n = !!s?.recycleItems ? new d2() : null, i = (e2, t = 0) => {
    if (!e2?.length) return;
    const o2 = r.splice(t, e2.length);
    n ? n.processRemoved(e2) : o2.forEach(m);
  }, c3 = (e2, t = 0) => {
    if (!e2?.length) return;
    const s2 = [];
    for (const r2 of e2) {
      const e3 = n?.use(r2);
      if (e3) s2.push(e3);
      else {
        const e4 = o(r2);
        n?.register(r2, e4), s2.push(e4);
      }
    }
    r.addMany(s2, t);
  }, l3 = a2(e, "after-splice", ({ added: e2, start: t, removed: o2 }) => {
    i(o2, t), c3(e2, t);
  }, { sync: true, onListenerRemove: (e2) => i(e2.items), onListenerAdd: (e2) => c3(e2.items) });
  return r.addHandles(l3), r;
}
var d2 = class {
  constructor() {
    this._originalToMapped = /* @__PURE__ */ new Map(), this._removedItemCandidates = /* @__PURE__ */ new Set(), this._garbageCollectionQueued = false;
  }
  processRemoved(e) {
    if (!e?.length) return;
    const { _removedItemCandidates: t } = this;
    for (const o of e) this._getItem(o)?.markRemoved() && (t.add(o), this._queueGarbageCollection());
  }
  use(e) {
    const t = this._getItem(e);
    return t && (t.removed = false), t?.item;
  }
  register(e, t) {
    this._originalToMapped.set(e, new l2(t));
  }
  _getItem(e) {
    return this._originalToMapped.get(e);
  }
  _queueGarbageCollection() {
    this._garbageCollectionQueued || (this._garbageCollectionQueued = true, queueMicrotask(() => this._garbageCollectCandidates()));
  }
  _garbageCollectCandidates() {
    this._garbageCollectionQueued = false;
    const { _removedItemCandidates: e } = this, t = Array.from(e);
    e.clear(), t.forEach((e2) => this._garbageCollectIfRemoved(e2));
  }
  _garbageCollectIfRemoved(e) {
    const { _originalToMapped: t } = this, o = this._getItem(e);
    o?.removed && (m(o.item), t.delete(e));
  }
};
var l2 = class {
  constructor(e) {
    this.item = e, this.removed = false;
  }
  markRemoved() {
    return this.removed = true, true;
  }
};
function m(e) {
  "object" == typeof e && e && ("destroy" in e && "function" == typeof e.destroy ? e.destroy() : l(e));
}
function u2(o, a3, d3) {
  const l3 = new O(), u3 = c2(o, (t) => d(async (e) => {
    const o2 = await a3(t, e);
    if (a(e)) throw m(o2), u();
    return o2;
  }), d3), f = () => null, g = async (e) => {
    const t = await e.promise, o2 = u3.indexOf(e);
    o2 < 0 || l3.splice(o2, 1, t);
  };
  l3.addMany(u3.items.map(f));
  for (const e of u3) y(g(e));
  const h = u3.on("after-splice", ({ added: e, start: t, deleteCount: o2 }) => {
    const s = l3.splice(t, o2);
    for (const r of s) m(r);
    if (e?.length) {
      l3.addMany(e.map(f), t);
      for (const t2 of e) y(g(t2));
    }
  });
  return l3.addHandles([c(u3), h]), l3;
}

export {
  c2 as c,
  u2 as u
};
//# sourceMappingURL=chunk-B5JDN6EY.js.map
